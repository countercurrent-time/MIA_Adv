for _ in range(int(input())):\n    n = int(input())\n    mass = []\n    zo = 0\n    oz = 0\n    zz = 0\n    oo = 0\n    ozs = []\n    zos = []\n    ozss = set()\n    zoss = set()\n    for j in range(n):\n        k = input()\n        mass.append(k)\n        if k[0] == '0' and k[-1] == '1':\n            zoss.add(k)\n            zos.append(j + 1)\n            zo += 1\n        elif k[0] == '1' and k[-1] == '0':\n            ozss.add(k)\n            ozs.append(j + 1)\n            oz += 1\n        elif k[0] == '0' and k[-1] == '0':\n            zz += 1\n        else:\n            oo += 1\n    if zz and oo and not oz and not zo:\n        print(-1)\n        continue\n    else:\n        if zo > oz:\n            print((zo - oz) // 2)\n            ans = []\n            need = (zo - oz) // 2\n            i = 0\n            while need:\n                zzz = mass[zos[i] - 1][len(mass[zos[i] - 1]) - 1:: -1]\n                if zzz not in ozss:\n                    ans.append(zos[i])\n                    need -= 1\n                i += 1\n            print(*ans)\n        else:\n            print((oz - zo) // 2)\n            ans = []\n            need = (oz - zo) // 2\n            i = 0\n            while need:\n                zzz = mass[ozs[i] - 1][len(mass[ozs[i] - 1]) - 1:: -1]\n                if zzz not in zoss:\n                    ans.append(ozs[i])\n                    need -= 1\n                i += 1\n            print(*ans)\n
q=int(input())\n\nfor e in range(q):\n    x,y,k=list(map(int,input().split()))\n    x,y=abs(x),abs(y)\n    x,y=max(x,y),min(x,y)\n    \n    if(x%2!=k%2):\n        k-=1\n        y-=1\n    \n    \n    if(x>k):\n        print(-1)\n        continue\n    if((x-y)%2):\n        k-=1\n        x-=1\n    print(k)\n    \n    \n    \n
import sys\nimport random\nfrom fractions import Fraction\nfrom math import *\n \ndef input():\n    return sys.stdin.readline().strip()\n \ndef iinput():\n    return int(input())\n\ndef finput():\n    return float(input())\n\ndef tinput():\n    return input().split()\n\ndef linput():\n    return list(input())\n \ndef rinput():\n    return list(map(int, tinput()))\n\ndef fiinput():\n    return list(map(float, tinput()))\n \ndef rlinput():\n    return list(map(int, input().split()))\ndef trinput():\n    return tuple(rinput())\n\ndef srlinput():\n    return sorted(list(map(int, input().split())))\n\ndef NOYES(fl):\n    if fl:\n        print("NO")\n    else:\n        print("YES")\ndef YESNO(fl):\n    if fl:\n        print("YES")\n    else:\n        print("NO")\n    \ndef main():\n    n = iinput()\n    #k = iinput() \n    #m = iinput() \n    #n = int(sys.stdin.readline().strip()) \n    #n, k = rinput()\n    #n, m = rinput()\n    #m, k = rinput()\n    #n, k, m = rinput()\n    #n, m, k = rinput()\n    #k, n, m = rinput()\n    #k, m, n = rinput() \n    #m, k, n = rinput()\n    #m, n, k = rinput()\n    q = [rlinput(), rlinput(), rlinput()]\n    #q = linput()\n    ans = q[0].copy()\n    for i in range(1, n):\n        if ans[i] == ans[i - 1]:\n            ans[i] = q[1][i]\n        if i == n - 1:\n            o = 0\n            while q[o][i] == ans[n - 2] or q[o][i] == ans[0]:\n                o += 1\n            ans[i] = q[o][i]\n    print(*ans)\n\n        \n\n            \n        \n    \n                \n    \n    \n    \n            \n    \n        \n    \n\nfor i in range(iinput()):\n    main()\n
def solve():\n    n, k = map(int,input().split())\n    lst = list(map(int,input().split()))\n    lst.sort()\n    ans = 0\n    for i in range(n - k - 1, n):\n        ans += lst[i]\n    print(ans)\nfor i in range(int(input())):\n    solve()
for _ in range(int(input())):\n    input()\n    nums = [int(x) for x in input().split()]\n    new_ar = list(zip(nums,[i for i in range(len(nums))]))\n    new_ar.sort()\n    \n    maxx = new_ar[0][1]\n    minn = new_ar[0][1]\n    s="1"\n    for j in range(1,len(new_ar)):\n        if(new_ar[j][1]>maxx):\n            maxx = new_ar[j][1]\n        if(new_ar[j][1]<minn):\n            minn = new_ar[j][1]\n        if(maxx-minn<j+1):\n            s+="1"\n        else:\n            s+="0"\n        \n    print(s)
def possible(a):\n    ans = set()\n    s = set()\n    lmax = 0\n    for i in range(len(a)):\n        lmax = max(lmax, a[i])\n        s.add(a[i])\n        if lmax == i + 1 and len(s) == i + 1:\n            ans.add(i + 1)\n    return ans\n\n\nt = int(input())\nfor case_num in range(t):\n    n = int(input())\n    a = list(map(int, input().split(' ')))\n    left = possible(a)\n    a.reverse()\n    right = possible(a)\n    ans = []\n    for l in left:\n        if n - l in right:\n            ans.append(l)\n    print(len(ans))\n    for l in ans:\n        print(l, n - l)\n
import sys\ninput = sys.stdin.readline\nfor f in range(int(input())):\n    n,m=list(map(int,input().split()))\n    neig=[0]*n\n    for i in range(n):\n        neig[i]=[0]\n    \n    for i in range(m):\n        a,b=list(map(int,input().split()))\n        a-=1\n        b-=1\n        neig[a][0]+=1\n        neig[a].append(b)\n    lev=[1]*n\n    for i in range(n):\n        for j in range(1,neig[i][0]+1):\n            x=lev[i]+1\n            if x==4:\n                x=1\n            lev[neig[i][j]]=max(lev[neig[i][j]],x)\n    sol=0\n    s=[]\n    for i in range(n):\n        if lev[i]==3:\n            sol+=1\n            s.append(i+1)\n    print(sol)\n    print(*s)\n    \n
import sys\ndef I():\n    return sys.stdin.readline().rstrip()\n\nclass Heap:\n    def __init__( self ):\n        self.l = [ -1 ]\n        self.n = 0\n    def n( self ):\n        return self.n\n    def top( self ):\n        return self.l[ 1 ]\n    def ins( self, x ):\n        self.l.append( x )\n        n = len( self.l ) - 1\n        i = n\n        while i > 1:\n            j = i // 2\n            if self.l[ j ] > self.l[ i ]:\n                self.l[ j ], self.l[ i ] = self.l[ i ], self.l[ j ]\n                i = j\n            else:\n                break\n    def pop( self ):\n        r = self.l[ 1 ]\n        l = self.l.pop()\n        n = len( self.l ) - 1\n        if n:\n            self.l[ 1 ] = l\n            i = 1\n            while True:\n                j = i * 2\n                k = j + 1\n                if k < len( self.l ) and self.l[ i ] > max( self.l[ j ], self.l[ k ] ):\n                    if self.l[ j ] == min( self.l[ j ], self.l[ k ] ):\n                        self.l[ i ], self.l[ j ] = self.l[ j ], self.l[ i ]\n                        i = j\n                    else:\n                        self.l[ i ], self.l[ k ] = self.l[ k ], self.l[ i ]\n                        i = k\n                elif k < len( self.l ) and self.l[ i ] > self.l[ k ]:\n                    self.l[ i ], self.l[ k ] = self.l[ k ], self.l[ i ]\n                    i = k\n                elif j < len( self.l ) and self.l[ i ] > self.l[ j ]:\n                    self.l[ i ], self.l[ j ] = self.l[ j ], self.l[ i ]\n                    i = j\n                else:\n                    break\n        return r\n\nt = int( I() )\nfor _ in range( t ):\n    n = int( I() )\n    voter = [ list( map( int, I().split() ) ) for _ in range( n ) ]\n    h = Heap()\n    d = {}\n    for m, p in voter:\n        if m not in d:\n            d[ m ] = []\n        d[ m ].append( p )\n    need = {}\n    c = 0\n    sk = sorted( d.keys() )\n    for m in sk:\n        need[ m ] = max( 0, m - c )\n        c += len( d[ m ] )\n    c = 0\n    ans = 0\n    for m in sk[::-1]:\n        for p in d[ m ]:\n            h.ins( p )\n        while c < need[ m ]:\n            c += 1\n            ans += h.pop()\n    print( ans )\n
import sys\ninput = sys.stdin.readline\n\ndef main():\n    n, k = map(int, input().split())\n    string = input().strip()\n    if "W" not in string:\n        ans = min(n, k) * 2 - 1\n        print(max(ans, 0))\n        return\n        \n    L_s = []\n    cnt = 0\n    bef = string[0]\n    ans = 0\n    for s in string:\n        if s == bef:\n            cnt += 1\n        else:\n            if bef == "L":\n                L_s.append(cnt)\n            else:\n                ans += cnt * 2 - 1\n            cnt = 1\n        bef = s\n    if bef == "W":\n        ans += cnt * 2 - 1\n        cnt = 0\n        \n    if string[0] == "L" and L_s:\n        cnt += L_s[0]\n        L_s = L_s[1:]\n    L_s.sort()\n    for l in L_s:\n        if k >= l:\n            ans += l * 2 + 1\n            k -= l\n        else:\n            ans += k * 2\n            k = 0\n            \n    ans += 2 * min(k, cnt)\n    print(ans)\n    \n    \n    \nfor _ in range(int(input())):\n    main()
for _ in range(int(input())):\n    s = input()\n    p = [i for i in s.split("0") if i!=""]\n    p.sort(reverse=True)\n    ans = 0\n    for i in range(0,len(p),2):\n        ans+=len(p[i])\n    print(ans)\n\n
for _ in range(int(input())):\n    # n, x = map(int, input().split())\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ans = [arr[0]]\n    for i in range(1, n - 1):\n        if arr[i - 1] < arr[i] and arr[i] > arr[i + 1]:\n            ans.append(arr[i])\n        elif arr[i - 1] > arr[i] and arr[i] < arr[i + 1]:\n            ans.append(arr[i])\n    ans.append(arr[-1])\n    print(len(ans))\n    print(*ans)
n = int(input())\n\ndef area(width, height) :\n    return (width+1) * (height+1)\n\ndef calcul(s1, c, s2) :\n    maxx, maxy, minx, miny = 0, 0, 0, 0\n    x, y = 0, 0\n    for k in range(len(s1)) :\n        if s1[k] == "W" :\n            y += 1\n        if s1[k] == "S" :\n            y -= 1\n        if s1[k] == "A" :\n            x -= 1\n        if s1[k] == "D" :\n            x += 1\n        maxx = max(maxx, x)\n        minx = min(minx, x)\n\n        maxy = max(maxy, y)\n        miny = min(miny, y)\n\n\n\n\n    if c == "W" :\n        y += 1\n    elif c == "S" :\n        y -= 1\n    elif c == "A" :\n        x -= 1\n    elif c == "D" :\n        x += 1\n    else :\n        print(c, "ok")\n\n    maxx = max(maxx, x)\n    minx = min(minx, x)\n\n    maxy = max(maxy, y)\n    miny = min(miny, y)\n\n    for k in range(len(s2)) :\n        if s2[k] == "W" :\n            y += 1\n        if s2[k] == "S" :\n            y -= 1\n        if s2[k] == "A" :\n            x -= 1\n        if s2[k] == "D" :\n            x += 1\n        maxx = max(maxx, x)\n        minx = min(minx, x)\n\n        maxy = max(maxy, y)\n        miny = min(miny, y)\n\n\n\n    diffx = maxx - minx\n    diffy = maxy - miny\n    tmp = area(diffx, diffy)\n\n\n    return tmp\n\ndef pre_calcul(s, moment, pre_avant, date_debut) :\n    x, y, maxx, minx, maxy, miny = pre_avant\n    for k in range(date_debut, moment) :\n        if s[k] == "W" :\n            y += 1\n        if s[k] == "S" :\n            y -= 1\n        if s[k] == "A" :\n            x -= 1\n        if s[k] == "D" :\n            x += 1\n        maxx = max(maxx, x)\n        minx = min(minx, x)\n\n        maxy = max(maxy, y)\n        miny = min(miny, y)\n\n    return (x, y, maxx, minx, maxy, miny)\n\ndef calcul2(s, c, moment, precalcul) :\n    x, y, maxx, minx, maxy, miny = precalcul\n\n\n\n    if c == "W" :\n        y += 1\n    elif c == "S" :\n        y -= 1\n    elif c == "A" :\n        x -= 1\n    elif c == "D" :\n        x += 1\n    else :\n        print(c, "ok")\n\n    maxx = max(maxx, x)\n    minx = min(minx, x)\n\n    maxy = max(maxy, y)\n    miny = min(miny, y)\n\n    for k in range(moment, len(s)) :\n        if s[k] == "W" :\n            y += 1\n        if s[k] == "S" :\n            y -= 1\n        if s[k] == "A" :\n            x -= 1\n        if s[k] == "D" :\n            x += 1\n        maxx = max(maxx, x)\n        minx = min(minx, x)\n\n        maxy = max(maxy, y)\n        miny = min(miny, y)\n\n\n\n    diffx = maxx - minx\n    diffy = maxy - miny\n    tmp = area(diffx, diffy)\n\n\n    return tmp\n\nfor _ in range(n) :\n    s = input()\n    maxx, maxy, minx, miny = 0, 0, 0, 0\n    x, y = 0, 0\n    momentminx, momentmaxx, momentminy, momentmaxy = -1, -1, -1, -1\n    for k in range(len(s)) :\n        if s[k] == "W" :\n            y += 1\n        if s[k] == "S" :\n            y -= 1\n        if s[k] == "A" :\n            x -= 1\n        if s[k] == "D" :\n            x += 1\n\n        if x > maxx :\n            momentmaxx = k\n        if y > maxy :\n            momentmaxy = k\n        if x < minx :\n            momentminx = k\n        if y < miny :\n            momentminy = k\n        maxx = max(maxx, x)\n        minx = min(minx, x)\n\n        maxy = max(maxy, y)\n        miny = min(miny, y)\n    diffx = maxx - minx\n    diffy = maxy - miny\n\n\n    tmp = 999999999999999999999999999999999999\n    l = [momentmaxx, momentmaxy, momentminx, momentminy]\n    l = list(set(l))\n    l = [i for i in l if i != -1]\n    l.sort()\n    if l != [] :\n        precalcul = pre_calcul(s, l[0], (0, 0, 0, 0, 0, 0), 0)\n        avant = l[0]\n        for moment in l :\n            precalcul = pre_calcul(s, moment, precalcul, avant)\n            avant = moment\n            tmp = min(tmp, calcul2(s, 'W', moment, precalcul))\n            tmp = min(tmp, calcul2(s, 'S', moment, precalcul))\n            tmp = min(tmp, calcul2(s, 'A', moment, precalcul))\n            tmp = min(tmp, calcul2(s, 'D', moment, precalcul))\n    print(tmp)\n
from math import *\n\nmod = 1000000007\n\nfor zz in range(int(input())):\n    n = int(input())\n    a = [ int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    ha = True\n    hp = False\n    hm = False\n    for i in range(n):\n        if b[i] != a[i]:\n            if b[i] > a[i]:\n                if (hp):\n                    pass\n                else:\n                    ha = False\n                    break\n            else:\n                if (hm):\n                    pass\n                else:\n                    ha = False\n                    break\n        if a[i] > 0:\n            hp = True\n        elif a[i] < 0:\n            hm = True\n\n    if ha:\n        print('YES')\n    else:\n        print('NO')\n
for i in range(int(input())):\n    n,g,b=map(int,input().split())\n    nn=(n+1)//2\n    print(max(nn+(nn-1)//g*b,n))
for _ in range(int(input())):\n    a1, b1 = list(map(int, input().split()))\n    a2, b2 = list(map(int, input().split()))\n    if a1 > b1:\n        a1, b1 = b1, a1\n    if a2 > b2:\n        a2, b2 = b2, a2\n    flag = False\n    if a1 == a2 and a1 == b1 + b2:\n        flag = True\n    if b1 == b2 and b1 == a1 + a2:\n        flag = True\n    print('Yes' if flag else 'No')\n
from math import *\n\nzzz = int(input())\nfor zz in range(zzz):\n    a, b, x, y = list(map(int, input().split()))\n    print(max(x*b, (a-x-1)*b, y*a, (b - y - 1)*a))\n
from math import sqrt\nclass pro(object):\n    def __init__(self,dif,sc):\n        self.dif=dif\n        self.sc=sc\n\n    def __lt__(self,other):\n        return self.dif>other.dif\n\nT=int(input())\nmul=[1]\nfor i in range(100):\n    mul.append(mul[i]*10/9)\ninf=1000000007\nfor t in range(T):\n    n=int(input())\n    effi,tim=list(map(float,input().split()))\n    prob=[]\n    for i in range(n):\n        x,y=list(map(int,input().split()))\n        prob.append(pro(x,y))\n    prob.sort()\n    f=[[inf for i in range(n+1)] for j in range(1001)]\n    f[0][0]=0\n    totsc=0\n    for i in range(n):\n        totsc+=prob[i].sc\n        for j in range(totsc,prob[i].sc-1,-1):\n            for k in range(1,i+2):\n                f[j][k]=min(f[j][k],f[j-prob[i].sc][k-1]+prob[i].dif*mul[k])\n    for i in range(totsc,-1,-1):\n        flag=False\n        for j in range(n+1):\n            if sqrt(effi*f[i][j])>=1:\n                res=2*sqrt(f[i][j]/effi)-1/effi+10*j\n            else:\n                res=f[i][j]+10*j\n            if res<=tim:\n                print(i)\n                flag=True\n                break\n        if flag==True:\n            break\n
class BIT():\n    def __init__(self,n):\n        self.BIT=[0]*(n+1)\n        self.num=n\n\n    def query(self,idx):\n        res_sum = 0\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        while idx <= self.num:\n            self.BIT[idx] += x\n            idx += idx&(-idx)\n        return\n\nimport sys,random\n\ninput=sys.stdin.readline\n\nfor _ in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    pair=[[] for i in range(n+1)]\n    for i in range(n):\n        for j in range(i+1,n):\n            if a[i]==a[j]:\n                pair[i+1].append(j+1)\n\n    bit=BIT(n)\n    ans=0\n    for i in range(1,n+1):\n        minus=bit.query(i)\n        for r in pair[i]:\n            ans+=bit.query(r-1)-minus\n        for r in pair[i]:\n            bit.update(r,1)\n\n    print(ans)\n    \n
import math\n\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    print(1/math.tan(math.pi/2/n))\n
for _ in range(int(input())):\n    n, k, d = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    s = {}\n    for q in range(d):\n        s[a[q]] = s.get(a[q], 0)+1\n    ans = len(s)\n    for q in range(d, n):\n        if s[a[q-d]] == 1:\n            del s[a[q-d]]\n        else:\n            s[a[q-d]] -= 1\n        s[a[q]] = s.get(a[q], 0)+1\n        ans = min(ans, len(s))\n    print(ans)\n
q = int(input())\nfor _ in range(q):\n    n, m = list(map(int, input().split()))\n    info = [list(map(int, input().split())) for i in range(n)]\n    info = sorted(info)\n    now =(m, m)\n    time = 0\n    flag = True\n    for i in range(n):\n        t, l, h = info[i]\n        l_now = now[0] - (t - time)\n        h_now = now[1] + (t - time)\n        time = t\n        if h < l_now or h_now < l:\n            flag = False\n        else:\n            l_now = max(l_now, l)\n            h_now = min(h_now, h)\n            now = (l_now, h_now)\n    if flag:\n        print("YES")\n    else:\n        print("NO")
t = int(input())\n\nfor _ in range(t):\n    n = list(input().strip())\n    s = list(map(int, input().strip().split()))\n\n    check = set(s)\n    found = False\n    for i in range(1, 1025):\n        newset = set([e^i for e in s])\n        if check == newset:\n            print(i)\n            found = True\n            break\n    if not found:\n        print(-1)\n
import sys\n\ninput = sys.stdin.readline\n\nfor _ in range(int(input())):\n	a, k = list(map(int, input().split()))\n	for _ in range(k - 1):\n		if '0' in str(a):\n			break\n		a += int(min(list(str(a)))) * int(max(list(str(a))))\n	print(a)\n
import heapq\n\nfor _ in range(int(input())):\n    n = int(input())\n    voters = []\n    for i in range(n):\n        m,p = list(map(int, input().split()))\n        voters.append((m, -p))\n    voters.sort()\n    for i in range(n):\n        voters[i] = (voters[i][0], -voters[i][1])\n\n    ans = 0\n    costs = []\n    heapq.heapify(costs)\n    bought = 0\n    for i in range(n-1, -1, -1):\n        buysNeeded = voters[i][0] - i  - bought\n        heapq.heappush(costs, voters[i][1])\n        while buysNeeded > 0 and len(costs) > 0:\n            ans += heapq.heappop(costs)\n            bought += 1\n            buysNeeded -= 1\n\n    print(ans)\n
for _ in range(int(input())):\n    d=int(input())\n    anws=False\n    if d**2>=4*d:\n        root=(d**2-4*d)**0.5\n        a=(d+root)/2\n        b=(d-root)/2\n        anws=True\n    if anws:\n        print("Y {:.9f} {:.9f}".format(a,b))\n    else:\n        print("N")
import os\nfrom io import BytesIO\nimport sys\nimport threading\n\n\nsys.setrecursionlimit(10 ** 9)\nthreading.stack_size(67108864)\n\n\ndef main():\n\n    # input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    def ad(i, j):\n        nonlocal g\n        if j in g[i]:\n            g[i].remove(j)\n            g[j].remove(i)\n        else:\n            g[i].add(j)\n            g[j].add(i)\n\n    def dfs(v):\n        nonlocal used, g, nans\n        used[v] = True\n        nans.append(v + 1)\n        for el in g[v]:\n            if not used[el]:\n                dfs(el)\n\n    for _ in range(int(input())):\n        n = int(input())\n        cnt = [set() for i in range(n)]\n        g = [set() for i in range(n)]\n        used = [False] * n\n        triangles = []\n        for i in range(n - 2):\n            a, b, c = map(int, input().split())\n            a -= 1\n            b -= 1\n            c -= 1\n            cnt[a].add(i)\n            cnt[b].add(i)\n            cnt[c].add(i)\n            triangles.append((a, b, c))\n            ad(a, b)\n            ad(b, c)\n            ad(a, c)\n        q = []\n        ones = []\n        for i in range(n):\n            if len(cnt[i]) == 1:\n                ones.append(i)\n        ans = []\n        nans = []\n        for i in range(n - 2):\n            t = ones.pop()\n            ind = cnt[t].pop()\n            ans.append(ind + 1)\n            cnt[triangles[ind][0]].discard(ind)\n            cnt[triangles[ind][1]].discard(ind)\n            cnt[triangles[ind][2]].discard(ind)\n            if len(cnt[triangles[ind][0]]) == 1:\n                ones.append(triangles[ind][0])\n            if len(cnt[triangles[ind][1]]) == 1:\n                ones.append(triangles[ind][1])\n            if len(cnt[triangles[ind][2]]) == 1:\n                ones.append(triangles[ind][2])\n        dfs(0)\n        print(*nans)\n        print(*ans)\n\n\ntt = threading.Thread(target = main)\ntt.start()
for _ in range(int(input())):\n    n, m = list(map(int, input().split()))\n    if n < m:\n        n, m = m, n # n > m\n\n    if m == 1:\n        print("YES")\n        continue\n\n    if m == 2 and n == 2:\n        print("YES")\n        continue\n\n    print("NO")\n
tests = int(input())\nfor test in range(tests):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    d = {}\n    for i in range(n):\n        s = 0\n        while a[i] % 2 == 0:\n            a[i] //= 2\n            s += 1\n        if a[i] in list(d.keys()):\n            d[a[i]] = max(s, d[a[i]])\n        else:\n            d[a[i]] = s\n    s = 0\n    for i in list(d.keys()):\n        s += d[i]\n    print(s)\n
import sys\nINF = 10**20\nMOD = 10**9 + 7\nI = lambda:list(map(int,input().split()))\nfrom math import gcd\nfrom math import ceil\nfrom collections import defaultdict as dd, Counter\nfrom bisect import bisect_left as bl, bisect_right as br\n\n\n"""\nFacts and Data representation\nConstructive? Top bottom up down\n"""\ndef check(s):\n  t = 'abacaba'\n  ans = 0\n  for i in range(len(s)):\n    if s[i: i + 7] == t:\n      ans += 1\n  return ans\n\ndef solve():\n  n, = I()\n  s = input()\n  t = 'abacaba'\n  cnt = check(s)\n  if cnt > 1:\n    print('No')\n    return\n  elif cnt == 1:\n    s = list(s)\n    for i in range(n):\n      if s[i] == '?':\n        s[i] = 'z'\n    print('Yes')\n    print(''.join(s))\n  else:\n    s = list(s)\n    ok = s[::]\n    for i in range(n - 6):\n      ok = s[::]\n      for j in range(7):\n        if s[i + j] == t[j]:\n          continue\n        elif s[i + j] == '?':\n          ok[i + j] = t[j]\n        else:\n          break\n      else:\n        for i in range(n):\n          if ok[i] == '?':\n            ok[i] = 'z'\n        ok = ''.join(ok)\n        if check(ok) != 1:\n          continue\n        print('Yes')\n        print(ok)\n        return\n    print('No')\n\nt, = I()\nwhile t:\n  t -= 1\n  solve()
input=__import__('sys').stdin.readline\nfor _ in range(int(input())):\n	n=int(input())\n	s=list(map(int,input().split()))\n	g=[[-1]for _ in range(n+1)]\n	for i in range(n):\n		g[s[i]].append(i)\n	inf=10**10\n	ans=[-1]*n\n	lstunused=n\n	for i in range(1,n+1):\n		g[i].append(n)\n		mx=0\n		for j in range(1,len(g[i])):\n			mx=max(mx,g[i][j]-g[i][j-1]-1)\n		for j in range(mx,lstunused):\n			ans[j]=i\n		lstunused=min(lstunused,mx)\n	print(*ans)
t = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input()\n    ans = 0\n    for y in range(1, n):\n        if s[y] == s[y-1]:\n            ans += 1\n    print((ans + ans % 2) // 2)\n    \n
DIR = {"N": (0, 1), "S": (0, -1), "W": (-1, 0), "E": (1, 0)}\n\nfor t in range(int(input())):\n   path = input()\n   tracks = set()\n   x, y = 0, 0\n   time = 0\n   for char in path:\n      x1 = x + DIR[char][0]\n      y1 = y + DIR[char][1]\n      if (x, y, x1, y1) in tracks or (x1, y1, x, y) in tracks:\n         time += 1\n      else:\n         time += 5\n         tracks.add((x, y, x1, y1))\n      x, y = x1, y1\n   print(time)\n
from sys import stdin, stdout\nfrom collections import defaultdict\ninput = stdin.readline\nfor _ in range(int(input())):\n	n = int(input())\n	chanek = 0\n	flag = 1\n	while n>0:\n		if n%4==0 and n!=4:\n			if flag:\n				chanek += 1\n				n-=1\n				flag = 0\n			else:\n				n-=1\n				flag = 1\n		elif n%2:\n			if flag:\n				chanek += 1\n				n-=1\n				flag = 0\n			else:\n				n-=1\n				flag = 1\n		else:\n			if flag:\n				chanek += n//2\n				n//=2\n				flag = 0\n			else:\n				n//=2\n				flag = 1\n	print(chanek)
t=int(input())\nfor i in range(t):\n    n=int(input())\n    print(2)\n    print(n-1,n)\n    for i in range(n-2,0,-1):\n        print(i,i+2)
for _ in range(int(input())):\n	n = int(input())\n	if(n%2):\n		print("7"+"1"*((n-3)//2))\n	else:\n		print("1"*(n//2))	
import sys\n\ninput=sys.stdin.readline\n\nfor _ in range(int(input())):\n    N=int(input())\n    e=list(map(int,input().split()))\n    e.sort()\n    ans=0\n    val=0\n    g=0\n    for i in range(0,N):\n        g+=1\n        val=e[i]\n        if g>=val:\n            ans+=1\n            g=0\n            val=0\n    print(ans)\n
n=int(input())\na=list(map(int,input().split()))\nk=[]\nfor i in range(n):\n    for j in range(a[i]):\n        k.append(i+1)\nm=int(input())\nb=list(map(int,input().split()))\nfor i in b:\n    print(k[i-1])
3\n\nfrom math import factorial as fact\n\nN = 55\nc = [1]\nfor i in range(N):\n	c.append(fact(i))\ndp = [0] * N\ndp[0] = 1\nfor i in range(1, N):\n	for j in range(i):\n		dp[i] += dp[j] * c[i - j - 1]\n\ndef get_kth_cycle(n, k):\n	if n == 1:\n		return [1]\n	ans = [-1] * n\n	ans[0] = n - 1\n	fin = [i for i in range(n)]\n	fin[0] = n - 1\n	init = [i for i in range(n)]\n	init[n - 1] = 0\n	used = [False] * n\n	used[n - 1] = True\n	for i in range(1, n - 1):\n		j = 0\n		cur = fact(n - i - 2)\n		while True:\n			while used[j] or (i < n - 1 and j == init[i]):\n				j += 1\n			if k > cur:\n				k -= cur\n				j += 1\n			else:\n				fin[init[i]] = fin[j]\n				init[fin[j]] = init[i]\n				ans[i] = j\n				used[j] = True\n				break\n	ans[-1] = init[-1]\n	return [x + 1 for x in ans]\n\ndef f(n, k):\n	if n == 0:\n		assert k == 1\n		return []\n	cl = 1\n	while c[cl - 1] * dp[n - cl] < k:\n		k -= c[cl - 1] * dp[n - cl]\n		cl += 1\n	rest = f(n - cl, (k - 1) % dp[n - cl] + 1)\n	rest = [x + cl for x in rest]\n	k = (k - 1) // dp[n - cl] + 1\n	return get_kth_cycle(cl, k) + rest\n\ndef solve():\n	n, k = list(map(int, input().split()))\n	if k > dp[n]:\n		print(-1)\n		return\n	print(*f(n, k))\n\ndef main():\n	t = int(input())\n	while t > 0:\n		t -= 1\n		solve()\n\nmain()\n
q = int(input())\nfor z in range(q):\n    n, k1, k2 = map(int, input().split())\n    arr1 = list(map(int, input().split()))\n    arr2 = list(map(int, input().split()))\n    if max(arr1) > max(arr2):\n        print('YES')\n    else:\n        print('NO')
t=int(input())\n\nfor tt in range(t):\n    a,b,p=map(int,input().split())\n    s=input()\n    n=len(s)\n    cost = [0]*n\n    cost[-1] = 0\n    typ = ''\n    i=n-2\n    while i>=0:\n        if s[i]==typ:\n            cost[i] = cost[i+1]\n        else:\n            typ = s[i]\n            cost[i] = cost[i+1] + (a if typ=='A' else b)\n        i-=1\n    i=0\n    while cost[i] > p:\n        i+=1\n    print(i+1)
def main():\n    from sys import stdin, stdout\n    for _ in range(int(stdin.readline())):\n        n = int(stdin.readline())\n        inp1 = [-1] * (n + 1)\n        inp2 = [-1] * (n + 1)\n        for i, ai in enumerate(map(int, stdin.readline().split())):\n            if inp1[ai] < 0:\n                inp1[ai] = i\n            inp2[ai] = i\n        inp1 = tuple((inp1i for inp1i in inp1 if inp1i >= 0))\n        inp2 = tuple((inp2i for inp2i in inp2 if inp2i >= 0))\n        n = len(inp1)\n        ans = 0\n        cur = 0\n        for i in range(n):\n            if i and inp1[i] < inp2[i - 1]:\n                cur = 1\n            else:\n                cur += 1\n                ans = max(ans, cur)\n        stdout.write(f'{n - ans}\n')\n\n\nmain()\n
t = int(input())\nfor tt in range(t):\n    n,k=list(map(int,input().split()))\n    s = input()\n    ans = []\n    if s[0] == ')':\n        for i in range(n):\n            if s[i] == '(':\n                ans.append([1,i+1])\n                s = s[i::-1] + s[i+1:]\n                break\n    for i in range(1,(k-1)*2):\n        if i%2==0:\n            if s[i]!='(':\n                for j in range(i+1,n):\n                    if s[j] == '(':\n                        ans.append([i+1,j+1])\n                        s = s[:i] + s[j:i-1:-1] + s[j+1:]\n                        break\n        else:\n            if s[i]!=')':\n                for j in range(i+1,n):\n                    if s[j] == ')':\n                        ans.append([i+1,j+1])\n                        s = s[:i] + s[j:i-1:-1] + s[j+1:]\n                        break\n    for i in range((k-1)*2,(n+(2*(k-1)))//2+1):\n        if s[i]!='(':\n            for j in range(i+1,n):\n                if s[j] == '(':\n                    ans.append([i+1,j+1])\n                    s = s[:i] + s[j:i-1:-1] + s[j+1:]\n                    break\n    print(len(ans))\n    for i in ans:\n        print(*i)\n            \n\n\n\n
LOG = 20\n\ndef solve(s):\n	n = len(s)\n	res = 0\n	z = 0\n	for t in range(0, n):\n		if s[t] == '0':\n			z += 1\n			continue\n		for l in range(1, min(LOG, n - t + 1)):\n			x = int(s[t:t+l], 2)\n			# print(l, t, x, l + z)\n			if l + z >= x:\n				res += 1\n\n#			print(t, l, x, res, z)\n		z = 0\n	return res\n\n\nt = int(input())\nwhile t > 0:\n	t -= 1\n	s = input()\n	print(solve(s))
def check(M):\n    sm = 0\n    for i in range(n):\n        if a[i] > M:\n            sm += b[i]\n    return sm <= M\n\n\ngans = []\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    L = 0\n    R = max(a)\n    while R - L > 1:\n        M = (L + R) // 2\n        if check(M):\n            R = M\n        else:\n            L = M\n    gans.append(R)\nprint(*gans, sep='\n')\n
t=int(input())\nfor you in range(t):\n    n=int(input())\n    for i in range(n):\n        print(4*n-2*i,end=" ")\n    print()\n
import sys\nimport random\nfrom fractions import Fraction\nfrom math import *\n \ndef input():\n    return sys.stdin.readline().strip()\n \ndef iinput():\n    return int(input())\n\ndef finput():\n    return float(input())\n\ndef tinput():\n    return input().split()\n\ndef linput():\n    return list(input())\n \ndef rinput():\n    return list(map(int, tinput()))\n\ndef fiinput():\n    return list(map(float, tinput()))\n \ndef rlinput():\n    return list(map(int, input().split()))\ndef trinput():\n    return tuple(rinput())\n\ndef srlinput():\n    return sorted(list(map(int, input().split())))\n\ndef NOYES(fl):\n    if fl:\n        print("NO")\n    else:\n        print("YES")\ndef YESNO(fl):\n    if fl:\n        print("YES")\n    else:\n        print("NO")\n    \ndef main():\n    n = iinput()\n    #k = iinput() \n    #m = iinput() \n    #n = int(sys.stdin.readline().strip()) \n    #n, k = rinput()\n    #n, m = rinput()\n    #m, k = rinput()\n    #n, k, m = rinput()\n    #n, m, k = rinput()\n    #k, n, m = rinput()\n    #k, m, n = rinput() \n    #m, k, n = rinput()\n    #m, n, k = rinput()\n    #q = srlinput()\n    #q = linput()\n    s, t, res = 1, 1, 0\n    while s <= n:\n        res += 1\n        n -= s\n        t = 2 * t + 1\n        s = (t * (t + 1)) // 2\n    print(res)\n        \n    \n                \n    \n    \n    \n            \n    \n        \n    \n\nfor i in range(iinput()):\n    main()\n
#\n#    ------------------------------------------------\n#           ____          _     Generatered using\n#          / ___|        | |\n#         | |    __ _  __| | ___ _ __  ______ _\n#         | |   / _` |/ _` |/ _ \ '_ \|_  / _` |\n#         | |__| (_| | (_| |  __/ | | |/ / (_| |\n#          \____\____|\____|\___|_| |_/___\____|\n#\n#      GNU Affero General Public License v3.0\n#    ------------------------------------------------\n#    Author   : prophet\n#    Created  : 2020-07-12 11:19:01.523119\n#    UUID     : aXsU7xuXyjk3Ky2f\n#    ------------------------------------------------\n#\nproduction = True\n\nimport sys, math, collections\n\ndef input(input_format = 0, multi = 0):\n\n    if multi > 0: return [input(input_format) for i in range(multi)]\n    else:\n        next_line = sys.stdin.readline()[:-1]\n\n        if input_format >= 10:\n            use_list = False\n            input_format = int(str(input_format)[-1])\n        else: use_list = True\n\n        if input_format == 0: formatted_input = [next_line]\n        elif input_format == 1: formatted_input = list(map(int, next_line.split()))\n        elif input_format == 2: formatted_input = list(map(float, next_line.split()))\n        elif input_format == 3: formatted_input = list(next_line)\n        elif input_format == 4: formatted_input = list(map(int, list(next_line)))\n        elif input_format == 5: formatted_input = next_line.split()\n        else: formatted_input = [next_line]\n\n        return formatted_input if use_list else formatted_input[0]\n\ndef out(output_line, output_format = 0, newline = True):\n\n    formatted_output = ""\n\n    if output_format == 0: formatted_output = str(output_line)\n    elif output_format == 1: formatted_output = " ".join(map(str, output_line))\n    elif output_format == 2: formatted_output = "\n".join(map(str, output_line))\n\n    print(formatted_output, end = "\n" if newline else "")\n\ndef log(*args):\n    if not production:\n        print("$$$", end = "")\n        print(*args)\n\nenu = enumerate\n\nter = lambda a, b, c: b if a else c\n\nceil = lambda a, b: -(-a // b)\n\ndef mapl(iterable, format = 0):\n    \n    if format == 0: return list(map(int, iterable))\n    elif format == 1: return list(map(str, iterable))\n    elif format == 2: return list(map(list, iterable))\n#\n#   >>>>>>>>>>>>>>> START OF SOLUTION <<<<<<<<<<<<<<\n#\n\n\ndef solve():\n\n    s = input(3)\n\n    u = [0] * 3\n\n    for i in s:\n        if i == "R":\n            u[0] += 1\n        elif i == "P":\n            u[1] += 1\n        elif i == "S":\n            u[2] += 1\n\n    log(u)\n    y = 0\n    p = 0\n\n    for i, j in enu(u):\n        if j > y:\n            y = j\n            p = i\n\n    if p == 0:\n        a = "P"\n    elif p == 1:\n        a = "S"\n    elif p == 2:\n        a = "R"\n\n    out(a * len(s))\n\n    return\n\n\nfor i in range(input(11)): solve()\n# solve()\n\n#\n#   >>>>>>>>>>>>>>>> END OF SOLUTION <<<<<<<<<<<<<<<\n#\n
import sys\ninput = sys.stdin.readline\nfrom bisect import bisect_right\n\nbin_s = [1]\nwhile bin_s[-1] <= 10 ** 9:\n    bin_s.append(bin_s[-1] * 2)\n\n\ndef main():\n    n, q = map(int, input().split())\n    alst = list(map(int, input().split()))\n    dp = [[-1, -1] for _ in range(n)]\n    dp[0] = [alst[0], 0]\n    for i, a in enumerate(alst[1:], start = 1):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + a)\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - a)\n    print(max(dp[-1]))\n    \n\nfor _ in range(int(input())):\n    main()
for haaghfj in range(int(input())):\n    x,y,k = list(map(int,input().split()))\n    print(k + (y * k + k - 1 +x-2) // (x - 1))\n
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\n# this math tutorial is boring\n\nclassy=set()\n\nfor i in range(19):\n    for j in range(i):\n        for k in range(j):\n            for a in range(10):     # a=0 for good measure\n                for b in range(10):\n                    for c in range(10):\n                        what=a*10**i+b*10**j+c*10**k\n                        classy.add(what)\n\nli=sorted(classy)\n\ndef counting(i):\n    # return len([x for x in li if x <= i])+C\n    lo=0\n    hi=len(li)-1\n    while lo<hi:\n        mid=(lo+hi+1)//2\n        if li[mid]<=i:\n            lo=mid\n        else:\n            hi=mid-1\n    return lo\n\nfor _ in range(int(input())):\n    a,b=map(int,input().split())\n    print(counting(b)-counting(a-1))
for tcase in range(int(input())):\n    n=int(input())\n    ls = list(map(int, input().split()))\n    oneneed = 2*(n - ls.count(1))\n    ldct = {0:0}\n    ctr = 0\n    eaten = 0\n    for i in range(n-1,-1,-1):\n        eaten += 1\n        ctr += (1 if ls[i] == 2 else -1)\n        if ctr not in ldct:\n            ldct[ctr] = eaten\n\n    rdct = {0:0}\n    ctr = 0\n    eaten = 0\n    for i in range(n,2*n):\n        eaten += 1\n        ctr += (1 if ls[i] == 2 else -1)\n        if ctr not in rdct:\n            rdct[ctr] = eaten\n    #print(oneneed, ldct, rdct)\n\n    best=99**99\n    for k in list(rdct.keys()):\n        otk = oneneed - k\n        if otk in ldct:\n            best = min(best, rdct[k]+ldct[otk])\n    print(best)\n
def main():\n    t = int(input())\n    for z in range(t):\n        n, k, d1, d2 = map(int, input().split())\n        if n % 3 != 0:\n            print('no')\n            continue\n        f = 0\n        for i in [-1, +1]:\n            for j in [-1, +1]:\n                w = (k - i * d1 - j * d2)\n                if f == 0 and (w % 3 == 0) and (n//3)>=(w//3)>=0 and (n//3)>=(w//3 + i * d1)>=0 and (n//3)>=(w//3 + j * d2)>=0:\n                    print('yes')\n                    f = 1\n        if f == 0:\n            print('no')\nmain()
n=int(input())\na=sorted(int(input()) for _ in range(n))\nprint(sum(a[i]*a[-i-1] for i in range(n))%10007)
import sys\ninput = sys.stdin.readline\n\n\ndef compress(array):\n    array2 = sorted(set(array))\n    memo = {value : index for index, value in enumerate(array2)}\n    for i in range(len(array)):\n        array[i] = memo[array[i]] + 1\n    return array\n\n\nt = int(input())\nbase = 10 ** 6\nfor _ in range(t):\n    n, b = list(map(str, input().split()))\n    n = int(n)\n    ans = [0] * n\n    \n    now = base\n    ans[0] = base\n    for i in range(n - 1):\n        if b[i] == ">":\n            now -= base\n            ans[i + 1] = now\n        else:\n            now += 1\n            ans[i + 1] = now\n    print(*compress(ans))\n\n    now = base\n    ans[0] = base\n    for i in range(n - 1):\n        if b[i] == ">":\n            now -= 1\n            ans[i + 1] = now\n        else:\n            now += base\n            ans[i + 1] = now\n    print(*compress(ans))\n
for i in range(int(input())):\n    n=int(input())\n    s=list(map(int,input().split()))\n    a=0\n    for i in s:\n        if i<2049:a+=i\n    if a<2048:print("NO")\n    else:print("YES")
for __ in range(int(input())):\n    n = int(input())\n    print((n + 1) // 2)
for _ in range(int(input())):\n    n, k = map(int, input().split())\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        b = False\n        for j in range(n):\n            if i*n+j == k:\n                b = True\n                break\n            mat[(i+j)%n][j] = 1\n        if b:\n            break\n    if k%n == 0:\n        print(0)\n    else:\n        print(2)\n    for i in range(n):\n        for j in range(n):\n            print(mat[i][j], end="")\n        print()\n
t = int(input())\nfor case in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    if arr[-1] > arr[0]:\n        print("YES")\n    else:\n        print("NO")
mem = [[[0 for i in range(51)] for j in range(31)] for k in range(31)]\n\n\ndef f(n, m, k):\n    if mem[n][m][k]:\n        return mem[n][m][k]\n    if (n*m == k) or (k == 0):\n        return 0\n    cost = 10**9\n    for x in range(1, n//2 + 1):\n        for z in range(k+1):\n            cost = min(cost, m*m + f(n-x, m, k-z) + f(x, m, z))\n    for y in range(1, m//2 + 1):\n        for z in range(k+1):\n            cost = min(cost, n*n + f(n, m-y, k-z) + f(n, y, z))\n    mem[n][m][k] = cost\n    return cost\n\n\nt = int(input())\nfor i in range(t):\n    n, m, k = list(map(int, input().split()))\n    print(f(n, m, k))\n\n
for _ in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    ans,small,big=0,2*10**9,-1\n    for i in range(len(a)-1):\n        if a[i]==-1 and a[i+1]!=-1:\n            small=min(small, a[i+1])\n            big=max(big, a[i+1])\n        if a[i]!=-1 and a[i+1]==-1:\n            small = min(small, a[i])\n            big = max(big, a[i])\n        if a[i]!=-1 and a[i+1]!=-1:\n            ans=max(ans, abs(a[i]-a[i+1]))\n    if big==-1:print(ans, 0)\n    else:\n        x=(small+big)//2\n        ans=max(ans, abs(big-x))\n        ans=max(ans, abs(x-small))\n        print(ans, x)
n = int(input())\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    print(a ^ b)\n
import sys\nimport math\n#from queue import *\nimport random\n#sys.setrecursionlimit(int(1e6))\ninput = sys.stdin.readline\n \n############ ---- USER DEFINED INPUT FUNCTIONS ---- ############\ndef inp():\n    return(int(input()))\ndef inara():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef invr():\n    return(list(map(int,input().split())))\n################################################################\n############ ---- THE ACTUAL CODE STARTS BELOW ---- ############\n\nt=inp()\n\nfor _ in range(t):\n	n=inp()\n	ara=inara()\n	\n	ans=[]\n	\n	for i in range(1,n-1):\n		if ara[i]>ara[i-1] and ara[i]>ara[i+1]:\n			ans.append(i)\n			ans.append(i+1)\n			ans.append(i+2)\n			break\n	\n	if len(ans)==0:\n		print("NO")\n	else:\n		print("YES")\n		print(*ans)\n	\n	\n			\n
T = int(input())\n\n\n\ndef solve(S):\n    res = [S[0]]\n    pos = 0 # think...\n    for s in S[1:]:\n        # can we change?\n        if 0 <= pos-1 < len(res) and res[pos-1] == s:\n            pos = pos-1\n        elif 0 <= pos+1 < len(res) and res[pos+1] == s:\n            pos = pos+1\n        elif pos == 0 and s not in res:\n            res.insert(0, s) # pos is still 0\n        elif pos == len(res)-1 and s not in res:\n            res.append(s)\n            pos += 1\n        else: return None\n    #print(''.join(res))\n    for x in range(ord('a'), ord('z')+1):\n        x = chr(x)\n        if x not in res:\n            res.append(x)\n    return ''.join(res)\n\nfor _ in range(T):\n    res = solve(input())\n    if res is None:\n        print('NO')\n    else:\n        print('YES')\n        print(res)\n
def solve():\n    n, k = map(int,input().split())\n    lst1 = list(map(int,input().split()))\n    lst1.sort(reverse=True)\n    ind = 0\n    ans = 0\n    lst2 = list(map(int,input().split()))\n    lst2.sort()\n    for i in range(k):\n        lst2[i] -= 1\n        if lst2[i] == 0: ans += lst1[ind]\n        ans += lst1[ind]\n        ind += 1\n    lst2.sort()\n    for i in lst2:\n        if i != 0:\n            ind += i - 1\n            ans += lst1[ind]\n            ind += 1\n    print(ans)\nfor i in range(int(input())):\n    solve()
import sys\nimport random\nfrom fractions import Fraction\nfrom math import *\n \ndef input():\n    return sys.stdin.readline().strip()\n \ndef iinput():\n    return int(input())\n\ndef finput():\n    return float(input())\n\ndef tinput():\n    return input().split()\n\ndef linput():\n    return list(input())\n \ndef rinput():\n    return list(map(int, tinput()))\n\ndef fiinput():\n    return list(map(float, tinput()))\n \ndef rlinput():\n    return list(map(int, input().split()))\ndef trinput():\n    return tuple(rinput())\n\ndef srlinput():\n    return sorted(list(map(int, input().split())))\n\ndef NOYES(fl):\n    if fl:\n        print("NO")\n    else:\n        print("YES")\ndef YESNO(fl):\n    if fl:\n        print("YES")\n    else:\n        print("NO")\n    \ndef main():\n    n, l = rinput()\n    #n = iinput()\n    #k = iinput() \n    #m = iinput() \n    #n = int(sys.stdin.readline().strip()) \n    #n, k = rinput()\n    #n, m = rinput()\n    #m, k = rinput()\n    #n, k, m = rinput()\n    #n, m, k = rinput()\n    #k, n, m = rinput()\n    #k, m, n = rinput() \n    #m, k, n = rinput()\n    #m, n, k = rinput()\n    q = rlinput()\n    #q = linput()\n    q = [0] + q + [l]\n    w, e = [0] * (n + 2), [0] * (n + 2)\n    \n    for i in range(1, n + 2):\n        e[n + 1 - i] = e[n + 2 - i] + ((q[-i] - q[-1 - i]) / i)\n        w[i] = w[i - 1] + ((q[i] - q[i - 1]) / i)\n        \n    left, right = 0, n + 2\n    while right > left + 1:\n        mid = (right + left) // 2\n        if w[mid] >= e[mid]:\n            right = mid\n        else:\n            left = mid\n            \n    print((q[right] - q[right - 1] - (max(0, w[right - 1] - e[right]) * (n - right + 2) + max(0, e[right] - w[right - 1]) * right)) / (n + 2) + max(w[right - 1], e[right]))\n        \n\n            \n        \n    \n                \n    \n    \n    \n            \n    \n        \n    \n\nfor i in range(iinput()):\n    main()\n
import math\nfrom collections import deque\nfrom sys import stdin, stdout\nfrom string import ascii_letters\nimport sys\nletters = ascii_letters\ninput = stdin.readline\n#print = stdout.write\n\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ans = [999999999] * n\n    ans[0] = 1 if arr[0] == 1 else 0\n    if n > 1:\n        ans[1] = ans[0]\n        if n > 2:\n            ans[2] = ans[0]\n    for i in range(n):\n        if i + 1 >= n:\n            continue\n        if arr[i + 1] == 1:\n            ans[i + 1] = min(ans[i + 1], ans[i] + 1)\n            if i + 2 < n:\n                ans[i + 2] = min(ans[i + 2], ans[i] + 1)\n            if i + 3 < n: \n                ans[i + 3] = min(ans[i + 3], ans[i] + 1)\n        else:\n            ans[i + 1] = min(ans[i + 1], ans[i])\n            if i + 2 < n:\n                ans[i + 2] = min(ans[i + 2], ans[i])\n            if i + 3 < n:\n                ans[i + 3] = min(ans[i + 3], ans[i])\n    print(ans[-1])\n
#list(map(int,input().split()))\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    aa=list(map(int,input().split()))\n    bb=list(map(int,input().split()))\n    aa.sort()\n    bb.sort()\n    print(*aa)\n    print(*bb)\n
for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    t = input()\n\n    d = {}\n    for i in range(ord('a'), ord('z') + 1):\n        d[chr(i)] = 0\n\n    for cs in s:\n        d[cs] += 1\n    for ct in t:\n        d[ct] += 1\n\n    ok = True\n    for e in d:\n        if d[e] % 2 == 1:\n            ok = False\n\n    if not ok:\n        print("No")\n    else:\n        print("Yes")\n\n        changes = []\n\n        s, t = list(s), list(t)\n        for i in range(n-1):\n            if s[i] != t[i]:\n                r = (0, -1)\n                for j in range(i+1, n):\n                    if s[j] == t[i]:\n                        r = (j, 0)\n\n                for j in range(i+1, n):\n                    if t[j] == t[i]:\n                        r = (j, 1)\n\n                if r[1] == 0:\n                    changes += [(r[0], i+1), (i, i+1)]\n                    s[r[0]], t[i+1] = t[i+1], s[r[0]]\n                    s[i], t[i+1] = t[i+1], s[i]\n                elif r[1] == 1:\n                    changes += [(i, r[0])]\n                    s[i], t[r[0]] = t[r[0]], s[i]\n\n        print(len(changes))\n        for change in changes:\n            x, y = change\n            print(x+1, y+1)
from itertools import groupby\ndef main():\n    N = int(input())\n    S = input()\n    \n    C = [len(list(x[1])) for x in groupby(S)]\n    M = len(C)\n    dup_idx = []\n    for i, c in enumerate(C):\n        if c > 1:\n            dup_idx.append(i)\n    \n    dup_idx.reverse()\n\n    curr = 0\n    while dup_idx:\n        i = dup_idx[-1]\n\n        if i < curr:\n            dup_idx.pop()\n            continue\n\n        C[i] -= 1\n        if C[i] == 1:\n            dup_idx.pop()\n\n        curr += 1\n\n    ans = curr + (M-curr+1)//2\n    \n    print(ans)\n\ndef __starting_point():\n    for __ in [0]*int(input()):\n        main()\n\n__starting_point()
t = int(input())\n\nfor case in range(t):\n    a, b = list(map(int, input().split()))\n    s = input()\n\n    z = 10000\n    total = 0\n    act = False\n\n    for i in range(len(s)):\n        cur = s[i]\n        if cur == '0':\n            z += 1\n            act = False\n        else:\n            if not act:\n                act = True\n                total += min(a, b * z)\n                z = 0\n\n    print(total)\n
import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\nclass Unionfind:\n    def __init__(self, n):\n        self.par = [-1]*n\n        self.rank = [1]*n\n    \n    def root(self, x):\n        r = x\n        \n        while not self.par[r]<0:\n            r = self.par[r]\n        \n        t = x\n        \n        while t!=r:\n            tmp = t\n            t = self.par[t]\n            self.par[tmp] = r\n        \n        return r\n    \n    def unite(self, x, y):\n        rx = self.root(x)\n        ry = self.root(y)\n        \n        if rx==ry:\n            return\n        \n        if self.rank[rx]<=self.rank[ry]:\n            self.par[ry] += self.par[rx]\n            self.par[rx] = ry\n            \n            if self.rank[rx]==self.rank[ry]:\n                self.rank[ry] += 1\n        else:\n            self.par[rx] += self.par[ry]\n            self.par[ry] = rx\n    \n    def is_same(self, x, y):\n        return self.root(x)==self.root(y)\n    \n    def count(self, x):\n        return -self.par[self.root(x)]\n\nt = int(input())\n\nfor _ in range(t):\n    n, k = map(int, input().split())\n    s = input()[:-1]\n    uf = Unionfind(n)\n    \n    for i in range(n//2):\n        uf.unite(i, n-1-i)\n    \n    for i in range(n-k):\n        uf.unite(i, i+k)\n    \n    d = defaultdict(dict)\n    \n    for i in range(n):\n        if s[i] not in d[uf.root(i)]:\n            d[uf.root(i)][s[i]] = 1\n        else:\n            d[uf.root(i)][s[i]] += 1\n    \n    rs = set(uf.root(i) for i in range(n))\n    ans = 0\n    \n    for r in rs:\n        ans += uf.count(r)-max(list(d[r].values()))\n    \n    print(ans)
t=int(input())\nwhile t>0 :\n    n=int(input())\n    a=list(map(int,input().split()))\n    an=0\n    s=0\n    for i in a :\n        if s+i>=0 :\n            s+=i \n        else :\n            s+=i\n            an-=s \n            s=0\n    print(an)\n    t-=1 
t = int(input())\n\nfor _ in range(t):\n    n, k = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    if len(set(a)) > k:\n        print(-1)\n        continue\n    l = list(set(a))\n    l.extend([1]*(k - len(l)))\n\n    print(n*k)\n    for _ in range(n):\n        print(*l, end=" ")\n    print()\n
def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    c = [0] * (n + 1)\n    def inc():\n        for i in range(n - 1):\n            if a[i] > a[i + 1]:\n                return False\n        return True\n    def calc():\n        for i in range(n + 1):\n            c[i] = 0\n        for i in a:\n            c[i] += 1\n        for i in range(n + 1):\n            if not c[i]:\n                return i\n        return n + 1\n    ans = []\n    while not inc():\n        x = calc()\n        if x >= n:\n            y = 0\n            while y < n and a[y] == y:\n                y += 1\n            a[y] = x\n            ans.append(y)\n        else:\n            a[x] = x\n            ans.append(x)\n    print(len(ans))\n    print(*map(lambda x: x + 1, ans))\n\nt = int(input())\nfor _ in range(t):\n    solve()
def read_int():\n    return int(input())\n\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\n\nt = read_int()\nfor case_num in range(t):\n    n, k = read_ints()\n    p = []\n    for i in range(n):\n        ai, bi = read_ints()\n        p.append((bi, ai, i + 1))\n    p.sort()\n    dp = [[0 for j in range(k + 1)] for i in range(n + 1)]\n    use = [[False for j in range(k + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(min(i, k) + 1):\n            if i - 1 >= j:\n                dp[i][j] = dp[i - 1][j] + (k - 1) * p[i - 1][0]\n            if j > 0:\n                x = dp[i - 1][j - 1] + (j - 1) * p[i - 1][0] + p[i - 1][1]\n                if x > dp[i][j]:\n                    dp[i][j] = x\n                    use[i][j] = True\n    used = []\n    curr = k\n    for i in range(n, 0, -1):\n        if use[i][curr]:\n            used.append(p[i - 1][2])\n            curr -= 1\n    used.reverse()\n    seq = used[:-1]\n    st = set(used)\n    for i in range(1, n + 1):\n        if not i in st:\n            seq.append(i)\n            seq.append(-i)\n    seq.append(used[-1])\n    print(len(seq))\n    print(' '.join(map(str, seq)))\n
import math\n\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    diags = 1/math.sin(math.pi/2/n)\n    print(diags * math.cos(math.pi/4/n))\n
t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    if n%4 == 0:\n        print("YES")\n    else:\n        print("NO")
3\n\nimport math\nimport os\nimport sys\n\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef dprint(*value, sep=' ', end='\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\nINF = 10 ** 20\n\n\ndef solve(N, A, B):\n    dp = {A[0]: 0, A[0] + 1: B[0], A[0] + 2: B[0] * 2}\n    for i in range(1, N):\n        ndp = {}\n\n        h = A[i]\n        for ph, c in dp.items():\n            for inc in range(3):\n                nh = h + inc\n                if ph == nh:\n                    continue\n                if nh not in ndp:\n                    ndp[nh] = INF\n                ndp[nh] = min(ndp[nh], c + B[i] * inc)\n\n        dp = ndp\n\n    return min(dp.values())\n\n\ndef main():\n    Q = int(inp())\n    for _ in range(Q):\n        N = int(inp())\n        A = []\n        B = []\n        for _ in range(N):\n            a, b = [int(e) for e in inp().split()]\n            A.append(a)\n            B.append(b)\n        print(solve(N, A, B))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
import sys\n\nq = int(sys.stdin.readline().strip())\nfor t in range(0, q):\n    n, m = list(map(int, sys.stdin.readline().strip().split()))\n    L = []\n    R = [0] * n\n    C = [0] * m\n    for i in range (0, n):\n        L.append(sys.stdin.readline().strip())\n        for j in range (0, m):\n            if L[i][j] != "*":\n                R[i] = R[i] + 1\n                C[j] = C[j] + 1\n    ans = n + m - 1\n    for i in range (0, n):\n        for j in range (0, m):\n            x = 0\n            if L[i][j] != "*":\n                x = -1\n            ans = min([ans, R[i]+C[j]+x])\n    print(ans)
from math import ceil\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  pf = []\n  for i in range(2, ceil(n**0.5)+1):\n    while n % i == 0:\n      pf.append(i)\n      n //= i\n  if n > 1:\n    pf.append(n)\n  if len(pf) == 2 and pf[0] != pf[1]:\n    print(pf[0], pf[1], pf[0]*pf[1])\n    print(1)\n  else:\n    pg = []\n    fac = []\n    nfac = []\n    while len(pf) > 0:\n      p = pf[-1]\n      mul = 0\n      while len(pf) > 0 and pf[-1] == p:\n        pf.pop()\n        mul += 1\n      pg.append([mul, p])\n    pg.sort()\n    pg = pg[::-1]\n    # print(pg)\n    cur = 0\n    if pg[0][0] == 1:\n      a = pg[0][1]\n      b = pg[1][1]\n      c = pg[2][1]\n      fac = [a, a*b*c, a*b, b, b*c, c, a*c]\n      cur = 3\n    else:\n      fac = [pg[0][1]**i for i in range(1, pg[0][0]+1)]\n      cur = 1\n    while cur < len(pg):\n      mul = pg[cur][0]\n      p = pg[cur][1]\n      nfac = []\n      for i in range(len(fac)):\n        if i == 0:\n          nfac += [fac[i]*(p**j) for j in range(mul, -1, -1)]\n        else:\n          nfac += [fac[i]*(p**j) for j in range(mul+1)]\n      nfac += [p**i for i in range(1, mul+1)]\n      fac = nfac\n      cur += 1\n    print(" ".join([str(i) for i in fac]))\n    print(0)\n
def solve(L, R):\n    res = 0\n    for i in range(32):\n        for j in range(32):\n            l = (L >> i) << i\n            r = (R >> j) << j\n            #print(l, r)\n            if l>>i&1==0 or r>>j&1==0:\n                continue\n            l -= 1<<i\n            r -= 1<<j\n            if l & r:\n                continue\n            lr = l ^ r\n            ma = max(i, j)\n            mi = min(i, j)\n            mask = (1<<ma)-1\n            p = bin(lr&mask).count("1")\n            ip = ma - mi - p\n            res += 3**mi * 2**ip\n            #print(l, r, mi, ip, 3**mi * 2**ip)\n    return res\n\nT = int(input())\nfor _ in range(T):\n    l, r = list(map(int, input().split()))\n    print(solve(r+1, r+1) + solve(l, l) - solve(l, r+1) * 2)\n
for _ in range(int(input())):\n	a, b, c = input(), input(), input()\n	n = len(a)\n\n	ok = True\n	for i in range(n):\n		if c[i] not in [a[i], b[i]]:\n			ok = False\n\n	print('YES' if ok else 'NO')\n
for __ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    ar.reverse()\n    print(*ar)
def one():\n    return int(input())\n\n\ndef two():\n    return list(map(int, input().split()))\n\n\ndef lis():\n    return list(map(int, input().split()))\n\n\ndef st():\n    return input()\n\n\nfor _ in range(one()):\n    x, y, a, b = list(map(int, input().split()))\n    d = y - x\n    if d%(a+b)==0:\n        print(d//(a+b))\n    else:\n        print(-1)\n
# encoding: utf-8\nfrom sys import stdin\n\ndef solve(a):\n\n    # root node of tries denotes empty stack\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n\n    counter = 0\n    for i in range(len(a)):\n        el = a[i]\n\n        if len(stack) == 0 or stack[-1] != el:\n\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n\n        else:\n            # just go up in trie\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n\n        value = node_stack[-1][0]\n        counter -= (((value - 1) * (value - 2)) // 2)\n        counter += (((value) * (value - 1)) // 2)\n\n    return counter\n\n\nq = int(stdin.readline().strip())\nfor _ in range(q):\n    n = int(stdin.readline().strip())\n    a = [int(i) for i in stdin.readline().strip().split()]\n    print(solve(a))\n
import sys\n\ninput=sys.stdin.readline\n\nfor _ in range(int(input())):\n    s=input().rstrip()\n    x=int(input())\n    n=len(s)\n    ans=["1" for i in range(n)]\n    for i in range(n):\n        if s[i]=="0":\n            if i-x>=0:\n                ans[i-x]="0"\n            if i+x<n:\n                ans[i+x]="0"\n    for i in range(n):\n        if s[i]=="1":\n            check=False\n            if i-x>=0:\n                check|=(ans[i-x]=="1")\n            if i+x<n:\n                check|=(ans[i+x]=="1")\n            if not check:\n                print(-1)\n                break\n    else:\n        print("".join(ans))\n
def solve():\n    n = int(input())\n    lst = list(map(int,input().split()))\n    if sum(lst) <= n // 2:\n        print(n//2)\n        print("0 " * (n // 2))\n    else:\n        print(n//2 + (n // 2) % 2)\n        print("1 " * (n//2 + (n // 2) % 2))\nfor i in range(int(input())):\n    solve()
import sys\n\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\n')\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a%b\n    return a\n\ndef solve():\n    m, d, w = nm()\n    g = w // gcd(d-1, w)\n    c = min(m, d)\n    v = c // g\n    ans = v * (v - 1) // 2 * g\n    ans += (c - g * v) * v\n    print(ans)\n    return\n\n\n# solve()\n\nT = ni()\nfor _ in range(T):\n    solve()\n
n = input()\na = list(map(int, input().split()))\nfor i in a:\n	if i % 7 == 0 or (i // 7) % 2 == 1 or i <= 14:\n		print('NO')\n	else:\n		print('YES')
from sys import stdin\n\ntt = int(stdin.readline())\n\nfor loop in range(tt):\n\n    n = int(stdin.readline())\n    a = list(map(int,stdin.readline().split()))\n\n    lis = [ [1] ]\n\n    now = []\n    tmp = 0\n\n    for i in range(1,n):\n        if len(now) == 0:\n            now.append(a[i])\n            tmp = 1\n        elif now[-1] > a[i]:\n            if tmp == len(lis[-1]):\n                lis.append(now)\n                now = [a[i]]\n                tmp = 1\n            else:\n                tmp += 1\n                now.append(a[i])\n        else:\n            now.append(a[i])\n\n    if len(now) > 0:\n        lis.append(now)\n\n    #print (lis)\n    print (len(lis)-1)
import math\nfrom collections import deque\nfrom sys import stdin, stdout\nfrom string import ascii_letters\nimport sys\nletters = ascii_letters\ninput = stdin.readline\n#print = stdout.write\n\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    can = list(map(int, input().split()))\n    vals = sorted([i for i in range(n) if not can[i]], key=lambda x: -arr[x])\n    res = [0] * n\n    last = 0\n    for i in range(n):\n        if can[i]:\n            res[i] = arr[i]\n        else:\n            res[i] = arr[vals[last]]\n            last += 1\n    print(*res)\n
t = int(input())\nfor faw in range(t):\n    n = int(input())\n    a = [0] + list(map(int,input().split()))\n    nun = []\n    ans = []\n    f = True\n    for i in range(1, n + 1):\n        if a[i] == a[i-1]:\n            if len(nun) == 0:\n                f = False\n                break\n            else:\n                ans.append(nun.pop())\n        else:\n            ans.append(a[i])\n            for i in range(a[i - 1] + 1, a[i]):\n                nun.append(i)\n    if f:\n        print(*ans)\n    else:\n        print(-1)\n
for _ in range(int(input())):\n    print("YES" if set(input()).intersection(input()) else "NO")\n
for tc in range(int(input())):\n    n,m = list(map(int, input().split()))\n    al = list(map(int, input().split()))\n    bl = list(map(int, input().split()))\n    aidx = {}\n    for i,e in enumerate(al):\n        aidx[e]=i\n    midx = -1\n    res = 0\n    for i,e in enumerate(bl):\n        idx = aidx[e]\n        if idx <= midx:\n            res += 1\n        else:\n            res += 2*(idx-i)+1\n        midx = max(midx, idx)\n    print(res)\n
T = int(input())\nfor test in range(T):\n    n,t = list(map(int,input().split()))\n    a = list(map(int,input().split()))\n    res = []\n    j=0\n    for i in a:\n        if(i*2<t):\n            res+=["0"]\n        elif(i*2>t):\n            res+=["1"]\n        else:\n            res.append(["0","1"][j])\n            j = 1-j\n    print(" ".join(res))\n
#JMD\n#Nagendra Jha-4096\n\n \nimport sys\nimport math\n\n#import fractions\n#import numpy\n \n###File Operations###\nfileoperation=0\nif(fileoperation):\n    orig_stdout = sys.stdout\n    orig_stdin = sys.stdin\n    inputfile = open('W:/Competitive Programming/input.txt', 'r')\n    outputfile = open('W:/Competitive Programming/output.txt', 'w')\n    sys.stdin = inputfile\n    sys.stdout = outputfile\n\n###Defines...###\nmod=1000000007\n \n###FUF's...###\ndef nospace(l):\n    ans=''.join(str(i) for i in l)\n    return ans\n \n \n \n##### Main ####\nt=int(input())\nfor tt in range(t):\n    n=int(input())\n\n    if n==1:\n        print(-1)\n    else:\n        s="2"\n        for i in range(n-1):\n            s+='3'\n        print(s)\n    #n,k,s= map(int, sys.stdin.readline().split(' '))\n    #a=list(map(int,sys.stdin.readline().split(' ')))\n    \n    \n#####File Operations#####\nif(fileoperation):\n    sys.stdout = orig_stdout\n    sys.stdin = orig_stdin\n    inputfile.close()\n    outputfile.close()
import sys\nfrom operator import itemgetter\n\ndef count(a, b, num_a, num_b, cur_time):\n	current_result = 0\n	#print('count time = ', cur_time, "num_a =", num_a, 'num_b = ', num_b)\n	if num_a * a + num_b * b <= cur_time and cur_time >= 0:\n		cur_time -= num_a * a + num_b * b\n		current_result = num_a + num_b\n		if num_a < total_a:\n			if (total_a - num_a) * a <= cur_time:\n				current_result += total_a - num_a\n				cur_time -= (total_a - num_a) * a\n				#print(1)\n			else:\n				current_result += cur_time // a\n				cur_time -= a *(cur_time // a)\n				#print(2)\n		if num_b < total_b:\n			if (total_b - num_b) * b <= cur_time:\n				current_result += total_b - num_b\n				#print(3)\n			else:\n				#print(4)\n				current_result += cur_time // b\n	#print('current_result = ', current_result)\n	return current_result\n\n\ndef solve(n, T, a, b, tasks, total_a, total_b):	\n	tasks = sorted(tasks)\n	#print(tasks)\n	result = 0\n	num_a = 0\n	num_b = 0\n\n	for i in range(len(tasks)):\n		time, t = tasks[i] \n		#print(tasks[i])\n		cur_time = time - 1\n		#print('cur time = ', cur_time)\n		current_result = count(a, b, num_a, num_b, cur_time)\n		result = max(current_result, result)\n\n		if t == 0:\n			num_a += 1\n		else:\n			num_b += 1\n\n		if i == len(tasks) - 1 or tasks[i + 1][1] != tasks[i][1]:\n			result = max(result, count(a, b, num_a, num_b, cur_time))\n\n		#print("i =", i, "result = ", result)\n\n	result = max(result, count(a, b, total_a, total_b, T))\n	return result\n\n\nq = int(input())\n\nfor i in range(q):\n	n, T, a, b = list(map(int, input().split()))\n	types = list(map(int, input().split()))\n	total_a, total_b = 0, 0\n	for t in types:\n		if t == 0:\n			total_a += 1\n		else:\n			total_b += 1\n	t = list(map(int, input().split()))\n	#print(t)\n	#print(types)\n	tasks = list(zip(t, types))\n	print(solve(n, T, a, b, tasks, total_a, total_b))	\n
import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\ndef solve():\n    s,c = input().split()\n    # i,jj\n    n = len(s)\n    for i in range(n-1):\n        prev = s[i]\n        pos = i\n        for j in range(i+1, n):\n            if s[j]<prev:\n                prev = s[j]\n                pos = j\n            elif s[j] == prev:\n                pos = j\n        if prev == s[i]:\n            continue\n        t = list(s)\n        t[i], t[pos] = prev, s[i]\n        s = "".join(t)\n        break\n    if s<c:\n        print(s)\n    else:\n        print("---")\n\nt = int(input())\nfor i in range(t):\n    solve()\n
q = int(input())\nfor _ in range(q):\n	c, m, x = list(map(int, input().split()))\n	print(min([c, m, (c + m + x) // 3]))
for _ in range(int(input())):\n    # a, b = map(int, input().split())\n    n = int(input())\n    # arr = list(map(int, input().split()))\n    s = input()\n    l = 0\n    r = n - 1\n    if s.count('0') == n:\n        print(s)\n        continue\n    if s.count('1') == n:\n        print(s)\n        continue\n    while s[l] == '0':\n        l += 1\n    while s[r] == '1':\n        r -= 1\n    if r <= l:\n        print(s)\n        continue\n    print(l * '0' + '0' + (n - r - 1) * '1')
n = int(input())\n\nfor _ in range(n):\n    a, b, c = list(map(int, input().split()))\n\n    print(min((a+b+c)//2, a+b, a+c, b+c))\n
import os\nfrom io import BytesIO\n\n# input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfor i in range(int(input())):\n    a, b, c, r = list(map(int, input().split()))\n    a, b = min(a, b), max(a, b)\n    left = max(c - r, a)\n    right = min(c + r, b)\n    if right >= a and left <= right:\n        print(b - a - (right - left))\n    else:\n        print(b - a)\n
s = []\nfor i in range(1, 10):\n    k = 0\n    for l in range(1, 10):\n        k *= 10\n        k += i\n        s.append(k)\ns.sort()\nq = int(input())\nwhile q:\n    n = int(input())\n    l = 0\n    r = len(s)\n    while l + 1 < r:\n        m = (l + r) // 2\n        if s[m] <= n:\n            l = m\n        else:\n            r = m\n    print(r)\n    q -= 1
t = int(input())\n\nfor _ in range(t):\n    n, m = [int(x) for x in input().split()]\n    grid = [[int(x) for x in input().split()] for _ in range(n)]\n\n    rows = sum(1 for x in grid if all(y == 0 for y in x))\n    cols = sum(1 for j in range(m) if all(grid[i][j] == 0 for i in range(n)))\n\n    res = min(rows, cols)\n\n    print("Ashish" if res % 2 else "Vivek")\n
from sys import stdin\ninput = stdin.readline\nq = int(input())\nfor rwerew in range(q):\n	n = int(input())\n	p = list(map(int,input().split()))\n	c = list(map(int,input().split()))\n	for i in range(n):\n		p[i] -= 1\n	przyn = [0] * n\n	grupa = []\n	i = 0\n	while i < n:\n		if przyn[i] == 1:\n			i += 1\n		else:\n			nowa_grupa = [i]\n			j = p[i]\n			przyn[i] = 1\n			while j != i:\n				przyn[j] = 1\n				nowa_grupa.append(j)\n				j = p[j]\n			grupa.append(nowa_grupa)\n	grupacol = []\n	for i in grupa:\n		cyk = []\n		for j in i:\n			cyk.append(c[j])\n		grupacol.append(cyk)\n	#print(grupacol)\n	mini = 234283742834\n	for cykl in grupacol:\n		dziel = []\n		d =  1\n		while d**2 <= len(cykl):\n			if len(cykl)%d == 0:\n				dziel.append(d)\n			d += 1\n		dodat = []\n		for d in dziel:\n			dodat.append(len(cykl)/d)\n		dziel_ost = list(map(int,dziel + dodat))\n		#print(dziel_ost, len(cykl))\n		for dzielnik in dziel_ost:\n			for i in range(dzielnik):\n				indeks = i\n				secik = set()\n				chuj = True\n				while indeks < len(cykl):\n					secik.add(cykl[indeks])\n					indeks += dzielnik\n					if len(secik) > 1:\n						chuj = False\n						break\n				if chuj:\n					mini = min(mini, dzielnik)\n	print(mini)\n			\n
import math\nt = int(input())\nfor test in range(t):\n    n,k = map(int,input().split())\n    A = list(map(int,input().split()))\n    A.sort()\n    ans = 0\n    for i in range(1,n):\n        if(A[i]>k):\n            ans = 0\n            break\n        rem = k-A[i]\n        ans+=rem//A[0]\n    print(ans)
t = int(input())\n\nfor ti in range(t):\n	n = int(input())\n\n	lri = [None for _ in range(n)]\n\n	for _ in range(n):\n		li, ri = list(map(int, input().split()))\n		lri[_] = (li, ri, _)\n\n	lri.sort()\n\n	t = [None for _ in range(n)]\n\n	ct, t[lri[0][2]], eg = 1, 1, lri[0][1]\n\n	for i in range(1, n):\n		if lri[i][0] <= eg:\n			t[lri[i][2]] = ct\n			eg = max(eg, lri[i][1])\n		else:\n			ct = 3 - ct\n			t[lri[i][2]] = ct\n			eg = lri[i][1]\n\n	if all(ti == 1 for ti in t):\n		print(-1)\n	else:\n		print(*t)\n
t = int(input())\nfor _ in range(t):\n  a, b, c, d = [int(i) for i in input().split(" ")]\n  sgn = (a+b)%2\n  small = False\n  large = False\n  if a == 0 and d == 0:\n    small = True\n  if b == 0 and c == 0:\n    large = True\n  okay = [True] * 4\n  if sgn == 0:\n    okay[0] = False\n    okay[1] = False\n  else:\n    okay[2] = False\n    okay[3] = False\n  if small:\n    okay[0] = False\n    okay[3] = False\n  if large:\n    okay[1] = False\n    okay[2] = False\n  print(" ".join(["Ya" if okay[i] else "Tidak" for i in range(4)]))
for _ in range(int(input())):\n    n=int(input())\n    li=list(map(int,input().split()))\n    ans=0\n    for i in range(n):\n        if li[i]>=i:\n            ans+=1\n        else:\n            break\n    for i in range(n):\n        if li[n-1-i]>=i:\n            ans+=1\n        else:\n            break\n    if ans>n:\n        print("Yes")\n    else:\n        print("No")
import sys\nimport math\nfrom collections import defaultdict\nfrom collections import deque\nfrom itertools import combinations\nfrom itertools import permutations\ninput = lambda : sys.stdin.readline().rstrip()\nread = lambda : list(map(int, input().split()))\ngo = lambda : 1/0\ndef write(*args, sep="\n"):\n  for i in args:\n    sys.stdout.write("{}{}".format(i, sep))\nINF = float('inf')\nMOD = int(1e9 + 7)\nYES = "YES"\nNO = -1\n\nfor _ in range(int(input())):\n  try:\n    n, m = read()\n    arr = read()\n    x = [0] * 65\n    \n    if sum(arr) < n:\n      print(NO)\n      go()\n  \n    for i in arr:\n      x[int(math.log2(i))] += 1\n    \n    ans = 0\n    for i in range(65):\n      if (1 << i) & n:\n        if x[i] != 0:\n          x[i] -= 1\n          continue \n\n        total = 0\n        for j in range(i):\n          total += (1 << j) * x[j]\n        \n        if total >= (1 << i):\n          temp = 1 << i \n          for j in reversed(range(i)):\n            while temp - (1 << j) >= 0 and x[j] > 0:\n              temp -= 1 << j \n              x[j] -= 1\n          continue \n        \n        j = i\n        while j < 65 and x[j] == 0:\n          j += 1\n        if j == 65:\n          print(NO)\n          go() \n        else:\n          x[j] -= 1\n          for k in range(i, j):\n            x[k] += 1\n          ans += (j - i)\n    \n    print(ans)\n\n\n  except ZeroDivisionError:\n    continue\n\n  except Exception as e:\n    print(e)\n    continue
for _ in range(int(input())):\n    n, k = tuple(map(int, input().split()))\n    arr = list(map(int, input().split()))\n\n    peaks = [0 for i in range(n)]\n    for i in range(1, n - 1):\n        if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\n            peaks[i] = 1\n\n    cnt = 0\n    max_peaks = 0\n    answer = 0\n\n    for i in range(k - 1):\n        cnt += peaks[i]\n        max_peaks += peaks[i]\n\n    for i in range(k - 1, n - 1):\n        cnt -= peaks[i - k + 2]\n        cnt += peaks[i]\n        if cnt > max_peaks:\n            max_peaks = cnt\n            answer = i - k + 2\n\n    print(max_peaks + 1, answer + 1)\n
#!/usr/bin/env python\n# coding:utf-8\n# Copyright (C) dirlt\n\nfrom sys import stdin\n\n\ndef run(n, m, pixels):\n    ans = 1 << 30\n\n    acc = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            acc[i + 1][j + 1] = acc[i + 1][j] + int(pixels[i][j])\n        for j in range(m):\n            acc[i + 1][j + 1] += acc[i][j + 1]\n    # print(acc)\n\n    for k in range(2, max(n, m) + 1):\n        r, c = (n + k - 1) // k, (m + k - 1) // k\n        res = 0\n        for i in range(r):\n            for j in range(c):\n                x, y = i * k, j * k\n                x2, y2 = min(x + k - 1, n - 1), min(y + k - 1, m - 1)\n                zero = acc[x2 + 1][y2 + 1] - acc[x][y2 + 1] - acc[x2 + 1][y] + acc[x][y]\n                # print(x, y, k, zero, k * k - zero)\n                res += min(zero, k * k - zero)\n        # print(k, res)\n        ans = min(ans, res)\n    print(ans)\n\n\ndef main():\n    n, m = [int(x) for x in stdin.readline().split()]\n    pixels = []\n    for i in range(n):\n        pixels.append(stdin.readline().strip())\n    run(n, m, pixels)\n\n\ndef __starting_point():\n    import os\n\n    if os.path.exists('tmp.in'):\n        stdin = open('tmp.in')\n    main()\n\n__starting_point()
import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n    \ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef solve(n):\n    a = [list(map(int, input())) for _ in range(n)]\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if a[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                x, y = i - 1 + dx + ddx, j - 1 + dy + ddy\n                                if 0 <= x < n and 0 <= y < n and a[x][y] == 0:\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            points[0], points[i] = points[i], points[0]\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    print(len(hull))\n    for p in hull:\n        print(p[0], p[1])\n    \nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    solve(n)\n
import math\nfrom decimal import Decimal\nimport heapq\nfrom collections import deque\ndef na():\n	n = int(input())\n	b = [int(x) for x in input().split()]\n	return n,b\n \n \ndef nab():\n	n = int(input())\n	b = [int(x) for x in input().split()]\n	c = [int(x) for x in input().split()]\n	return n,b,c\n \n \ndef dv():\n	n, m = list(map(int, input().split()))\n	return n,m\n \n \ndef dva():\n	n, m = list(map(int, input().split()))\n	a = [int(x) for x in input().split()]\n	b = [int(x) for x in input().split()]\n	return n,m,b\n \n \ndef eratosthenes(n): \n	sieve = list(range(n + 1))\n	for i in sieve:\n		if i > 1:\n			for j in range(i + i, len(sieve), i):\n				sieve[j] = 0\n	return sorted(set(sieve))\n \n \ndef lol(lst,k):\n	k=k%len(lst)\n	ret=[0]*len(lst)\n	for i in range(len(lst)):\n		if i+k<len(lst) and i+k>=0:\n			ret[i]=lst[i+k]\n		if i+k>=len(lst):\n			ret[i]=lst[i+k-len(lst)]\n		if i+k<0:\n			ret[i]=lst[i+k+len(lst)]\n	return(ret)\ndef nm():\n	n = int(input())\n	b = [int(x) for x in input().split()]\n	m = int(input())\n	c = [int(x) for x in input().split()]\n	return n,b,m,c\n \n \ndef dvs():\n	n = int(input())\n	m = int(input())\n	return n, m \n \ndef fact(a, b):\n	c = []\n	ans = 0\n	f = int(math.sqrt(a))\n	for i in range(1, f + 1):\n		if a % i == 0:\n			c.append(i)\n	l = len(c)\n	for i in range(l):\n		c.append(a // c[i])\n	for i in range(len(c)):\n		if c[i] <= b:\n			ans += 1\n	if a / f == f and b >= f:\n		return ans - 1\n	return ans\n \n\nt = int(input())\nfor i in range(t):\n	a ,b = list(map(int, input().split()))\n	if a == b:\n		print(0)\n	else:\n		d = abs(a - b)\n		k1 = d//5\n		d -= k1 *5 \n		k2 = d // 2\n		d -= k2 * 2\n		print(d + k1 + k2)\n
import sys\ninput = sys.stdin.readline\nimport bisect\n\nt=int(input())\n\nfor testcases in range(t):\n    n=int(input())\n    A=list(map(int,input().split()))\n    m=int(input())\n    PS=[tuple(map(int,input().split())) for i in range(m)]\n\n    PS.sort()\n    K=[PS[-1]]\n\n    for a,b in PS[::-1][1:]:\n        if b<=K[-1][1]:\n            continue\n        else:\n            K.append((a,b))\n\n    K.reverse()\n\n    ANS=1\n    count=0\n    countmax=n+1\n    LEN=len(K)\n    for a in A:\n        x=bisect.bisect_left(K,(a,0))\n        if x==LEN:\n            print(-1)\n            break\n        elif K[x][1]>=count+1 and countmax>=count+1:\n            count+=1\n            countmax=min(countmax,K[x][1])\n        else:\n            ANS+=1\n            count=1\n            countmax=K[x][1]\n\n        #print(a,count,countmax,ANS)\n    else:\n        print(ANS)\n            \n        \n        \n
class BIT():\n    def __init__(self,n):\n        self.BIT=[0]*(n+1)\n        self.num=n\n\n    def query(self,idx):\n        res_sum = 0\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        while idx <= self.num:\n            self.BIT[idx] += x\n            idx += idx&(-idx)\n        return\n\nimport sys,heapq,random\n\ninput=sys.stdin.readline\n\nn=int(input())\nspell=[tuple(map(int,input().split())) for i in range(n)]\n\n\nS=set([])\nfor i in range(n):\n    S.add(abs(spell[i][1]))\nS=list(S)\nS.sort(reverse=True)\ncomp={i:e+1 for e,i in enumerate(S)}\nN=len(S)\n\nx_exist=BIT(N)\ny_exist=BIT(N)\npower=BIT(N)\n\nX,Y,S=0,0,0\nXmax=[]\nYmin=[]\nx_data=[0]*(N+1)\ny_data=[0]*(N+1)\n\nfor i in range(n):\n    t,d=spell[i]\n    S+=d\n    if d<0:\n        id=comp[-d]\n        if t==0:\n            X-=1\n            x_exist.update(id,-1)\n            power.update(id,d)\n            x_data[id]-=1\n        else:\n            Y-=1\n            y_exist.update(id,-1)\n            power.update(id,d)\n            y_data[id]-=1\n    else:\n        id=comp[d]\n        if t==0:\n            X+=1\n            x_exist.update(id,1)\n            power.update(id,d)\n            heapq.heappush(Xmax,-d)\n            x_data[id]+=1\n        else:\n            Y+=1\n            y_exist.update(id,1)\n            power.update(id,d)\n            heapq.heappush(Ymin,d)\n            y_data[id]+=1\n    if X==0:\n        if Y==0:\n            print(0)\n        else:\n            while not y_data[comp[Ymin[0]]]:\n                heapq.heappop(Ymin)\n            print(2*S-Ymin[0])\n    else:\n        if Y==0:\n            print(S)\n        else:\n            start=0\n            end=N\n            while end-start>1:\n                test=(end+start)//2\n                if x_exist.query(test)+y_exist.query(test)<=Y:\n                    start=test\n                else:\n                    end=test\n            if y_exist.query(start)!=Y:\n                print(S+power.query(start))\n            else:\n                while not y_data[comp[Ymin[0]]]:\n                    heapq.heappop(Ymin)\n                while not x_data[comp[-Xmax[0]]]:\n                    heapq.heappop(Xmax)\n                print(S+power.query(start)-Ymin[0]-Xmax[0])\n
for nt in range(int(input())):\n	n=int(input())\n	l=list(map(int,input().split()))\n	s=sum(l)\n	e=l[0]\n	for i in range(1,n):\n		e=e^l[i]\n	if s==2*e:\n		print(0)\n		print ()\n	else:\n		print(2)\n		print(e,s+e)\n
from sys import stdin\ninput = stdin.readline\n\ntests = int(input())\nfor test in range(tests):\n    n, m = list(map(int, input().split()))\n    a = [[0] * m for _ in range(n)]\n    r = [[int(i) for i in input().split()] for _ in range(n)]\n    c = [[int(i) for i in input().split()] for _ in range(m)]\n    z = [[-1, -1] for _ in range(n * m + 1)]\n    \n    for i in range(n):\n        for j in range(m):\n            z[r[i][j]][0] = j\n    for i in range(m):\n        for j in range(n):\n            z[c[i][j]][1] = j\n\n    for i in range(1, n * m + 1):\n        a[z[i][1]][z[i][0]] = i\n\n    for i in a:\n        print(' '.join([str(j) for j in i]))\n
__MULTITEST = True\n\n## solve\ndef solve():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n\n    group = 0\n    ptr = n-1\n    members = 0\n\n    currentMin = int(1e10)\n    while ptr > -1:\n        currentMin = min(currentMin, a[ptr])\n        members += 1\n\n        if currentMin * members >= x:\n            group += 1\n            members = 0\n            currentMin = int(1e10)\n        \n        ptr -= 1\n    \n    print(group)\n\n## main\ndef __starting_point():\n    t = (int(input()) if __MULTITEST else 1)\n    for tt in range(t):\n        solve();\n__starting_point()
import sys\ninput = sys.stdin.readline\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  ab = [list(map(int,input().split())) for i in range(n-1)]\n  graph = [[] for i in range(n+1)]\n  deg = [0]*(n+1)\n  for a,b in ab:\n    graph[a].append(b)\n    graph[b].append(a)\n    deg[a] += 1\n    deg[b] += 1\n  pnt = [max(deg[i]-1,1) for i in range(n+1)]\n  root = 1\n  stack = [root]\n  dist = [0]*(n+1)\n  dist[root] = pnt[root]\n  while stack:\n    x = stack.pop()\n    for y in graph[x]:\n      if dist[y] == 0:\n        dist[y] = dist[x]+pnt[y]\n        stack.append(y)\n  far = dist.index(max(dist))\n  root = far\n  stack = [root]\n  dist = [0]*(n+1)\n  dist[root] = pnt[root]\n  while stack:\n    x = stack.pop()\n    for y in graph[x]:\n      if dist[y] == 0:\n        dist[y] = dist[x]+pnt[y]\n        stack.append(y)\n  print(max(dist))
import sys\ninput = sys.stdin.readline\n\nt=int(input())\n\ndef calc(x):\n    return x*(x+1)//2\n\nfor test in range(t):\n    n,m=list(map(int,input().split()))\n\n    ANS=calc(n)\n\n    k=n-m\n    q,mod=divmod(k,m+1)\n\n    ANS-=calc(q+1)*mod+calc(q)*(m+1-mod)\n\n    print(ANS)\n    \n
for _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    ar.sort()\n    print(abs(ar[n] - ar[n - 1]))
class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        max_score = 0\n        curr_score= 0\n        init_hand = cardPoints[len(cardPoints)-k:]\n        max_score = sum(init_hand)\n        curr_score = max_score\n        for i in range(k):\n            curr_score -= init_hand[i]\n            curr_score += cardPoints[i]\n            if curr_score > max_score:\n                max_score = curr_score\n        return max_score
import math\nclass Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        s=0\n        c=0\n        r=0\n        x=math.factorial(N)\n        while(True):\n            c=x*((N-r-K)**(L-K))*(-1)**(r)//(math.factorial(N-r-K)*math.factorial(r))\n            if(c!=0):\n                s=(s+c)%(10**9+7)\n                r+=1\n            else:\n                return s\n
class Solution:\n     def search(self, nums, target):\n         """\n         :type nums: List[int]\n         :type target: int\n         :rtype: bool\n         """\n         return target in nums\n
class Solution:\n     def superPow(self, a, b):\n         result = 1\n         fermatb = (int(''.join(map(str, b)))) % 570\n         while fermatb:\n             if fermatb & 1:\n                 result = (result * a) % 1337\n             a = (a * a) % 1337\n             fermatb >>= 1\n         return result
class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        n = len(s)\n        count = collections.Counter(s[i : i + minSize] for i in range(0, n - minSize +  1))\n        res = 0 \n        for k, v in count.items():\n            if len(set(k)) <= maxLetters:\n                res = max(res, v)\n        return res
class Solution:\n    def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\n        MOD = 10**9 + 7\n        group_len, profit_len = len(group),len(profit)\n        dp = [[0]*(G+1) for _ in range(P+1)]\n        dp[0][0] = 1\n        for pro, gro in zip(profit,group):\n            dp2 = [x[:] for x in dp]\n            for p1 in range(P+1):\n                p = min(pro + p1,P)\n                for g1 in range(G+1-gro):\n                    g = g1 + gro\n                    dp2[p][g] += dp[p1][g1]\n                    dp2[p][g] %= MOD\n            dp = dp2\n        return sum(dp[-1]) %MOD
class Solution:\n     def calculate(self, s):\n         """\n         :type s: str\n         :rtype: int\n         """\n         res = 0\n         num = 0\n         sign = 1\n         stk = []\n \n         for c in s:\n             if c.isdigit():\n                 num = 10 * num + (ord(c) - ord('0'))\n             elif c == '+':\n                 res += sign * num\n                 num = 0\n                 sign = 1\n             elif c == '-':\n                 res += sign * num\n                 num = 0\n                 sign = -1\n             elif c == '(':\n                 stk.append(res)\n                 stk.append(sign)\n                 res = 0\n                 sign = 1\n             elif c == ')':\n                 res += sign * num\n                 res *= stk.pop()\n                 res += stk.pop()\n                 num = 0\n                 sign = 1\n \n         if num:\n             res += sign * num\n         return res
class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        curmaxsight = A[0] - 1\n        curmaxpair = 0\n        for sight in A[1:]:\n            if sight + curmaxsight > curmaxpair:\n                curmaxpair = sight + curmaxsight\n            if sight > curmaxsight:\n                curmaxsight = sight\n            curmaxsight -= 1\n        return curmaxpair\n            \n
class Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n        dp = [-1] * len(s)\n        return self.dfs(s, k, 0, dp)\n    \n    def dfs(self, s: str, k: int, start: int, dp: List[int]) -> int:\n        if start == len(s):\n            return 1\n        if s[start] == '0':\n            return 0\n        if dp[start] != -1:\n            return dp[start]\n        \n        res, num = 0, 0\n        \n        for i in range(start, len(s)):\n            num = num * 10 + (ord(s[i]) - ord('0'))\n            \n            if num > k:\n                break \n            \n            res += self.dfs(s, k, i + 1, dp)\n            res %= 10**9 + 7\n            \n        dp[start] = res\n        return res
class Solution(object):\n 	def parse(self,expression,d,i):\n 		count = 0\n 		start = i\n 		if expression[i] == "(":\n 			count += 1\n 			i += 1\n 			while count != 0:\n 				if expression[i] == "(":\n 					count += 1\n 				elif expression[i] == ")":\n 					count -= 1\n 				i += 1\n 			val = self.evaluate(expression[start:i],d)\n 		else:\n 			while i < len(expression) and expression[i] != " " and expression[i] != ")":\n 				i += 1\n 			val = expression[start:i]\n 			if self.isnumber(val):\n 				val = int(val)\n 		return i,val\n 	def get_left_right(self,expression,d):\n 		i = 0\n 		count = 0\n 		i,left = self.parse(expression,d,0)\n 		if i == len(expression) or expression[i] == ")":\n 			return left,None,i\n 		i += 1\n 		i,right = self.parse(expression,d,i)\n 		return left,right,i\n 	def isnumber(self,s):\n 		for c in s:\n 			if ord("0") <= ord(c) <= ord("9") or c == "+" or c == "-":\n 				continue\n 			else:\n 				return False\n 		return True\n 	def evaluate(self, expression,d = {}):\n 		"""\n 		:type expression: str\n 		:rtype: int\n 		"""\n 		if self.isnumber(expression):\n 			return int(expression)\n 		newd = {}\n 		for key in d:\n 			newd[key] = d[key]\n 		expression = expression[1:len(expression)-1]\n 		oper = ""\n 		if expression[0:3] == "add" or expression[:3] == "let":\n 			oper = expression[0:3]\n 			expression = expression[4:]\n 		else:\n 			oper = "mult"\n 			expression = expression[5:]\n 		\n 		if oper == "mult" or oper == "add":\n 			left,right,_ = self.get_left_right(expression,newd)\n 			if isinstance(left,str):\n 				left = newd[left]\n 			if isinstance(right,str):\n 				right = newd[right]\n 			if oper == "mult":\n 				return left*right\n 			else:\n 				return left + right\n 		i = 0\n 		while True:\n 			left,right,i = self.get_left_right(expression,newd)\n 			expression = expression[i+1:]\n 			if right == None:\n 				if isinstance(left,str):\n 					return newd[left]\n 				return left\n 			if isinstance(right,str):\n 				right = newd[right]\n 			newd[left] = right\n 			\n 			\n 			\n # s = Solution()\n # print(s.evaluate("(let x 2 (mult x (let x 3 y 4 (add x y))))"))\n
class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        dp = [0] + [-1 for i in range(days[-1])]\n        \n        for day in days:\n            dp[day] = 0\n        \n        for i in range(1, len(dp)):\n            if dp[i] == -1:\n                dp[i] = dp[i-1]\n            \n            else:\n                dp[i] = min(\n                    dp[i-1] + costs[0],\n                    dp[max(i-7, 0)] + costs[1],\n                    dp[max(i-30, 0)] + costs[2],\n                )\n            \n        return dp[-1]
class Solution:\n    def balancedString(self, s: str) -> int:\n        # minimum window so that outside is possible\n        if len(s) //4 != len(s) / 4: return -1 \n        ans, lb, n_cnt = len(s), 0, collections.Counter(s)\n\n        i = 0\n        while i < len(s): \n            n_cnt[s[i]] -= 1     \n            while lb < len(s) and all(len(s) / 4 >= n_cnt[c] for c in 'QWER'): \n                ans = min(ans, abs(i - lb + 1))\n                if ans == 0: return 0\n                n_cnt[s[lb]] += 1\n                lb += 1\n                # here is actually a swap? \n            if lb > i: \n                i, lb = lb, i\n            i +=1\n\n        return ans\n                \n            \n            \n        \n            \n            \n
class Solution:\n    def numDupDigitsAtMostN(self, N: int) -> int:\n        # N -> total numbers less than or equal to N\n        # We will calculate the integers with all different digits (which are less than/equal to N)\n        # Then the answer would be: N - nums_with_different_digits\n        \n        # Calculate the number of digits in N\n        NN, dd = N, 0\n        nums = [] # store the digits\n        while(NN):\n            dd += 1\n            nums.append(NN % 10)\n            NN //= 10\n        nums.reverse()\n        \n        \n        # numbers with less digits than that of N\n        numbers = 0\n        for i in range(dd-1):\n            numbers += 9 * (math.factorial(9) // math.factorial(9-i))\n        \n        \n        # find the N-digit numbers (all-different)\n        already_visited_digits = set()\n        \n        def fac2(n, k):\n            return math.factorial(n) // math.factorial(n-k)\n        \n        for i,n in enumerate(nums):\n            k = 0\n            for j in range((1 if i==0 else 0), (n+1 if i==dd-1 else n)):\n                if(j in already_visited_digits):\n                    continue\n                k += 1\n            numbers += k * fac2(10-i-1, dd-i-1)\n            if n in already_visited_digits:\n                # All the numbers with this prefix will have at least one common digit\n                break\n            already_visited_digits.add(n)\n            \n        return N - numbers
class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        j = 0\n        l = []\n        for i in pushed:\n            l.append(i)\n            while l and (l[-1] == popped[j]):\n                l.pop()\n                j += 1\n        if l:\n            return False\n        return True
class Solution:\n    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:\n        # Pad with inf to make implementation easier\n        INF = -10_000\n        n = len(grid)\n\n        total = 0\n        max_rows = [max(row, default=INF) for row in grid]\n        # Transpose the grid to make max less cumbersome\n        max_cols = [max(col, default=INF) for col in zip(*grid)]\n\n        for i, best_row in enumerate(max_rows):\n            for j, best_col in enumerate(max_cols):\n                new_height = min(best_row, best_col)\n                total += new_height - grid[i][j]\n\n        return total\n
class Solution:\n    def minimumOneBitOperations(self, n: int) -> int:\n        s = 0\n        m = n\n        while m:\n            s += m & 1\n            m >>= 1\n\n        k = 1\n        while s:\n            s -= bool(n & k)\n            n ^= (s & 1) and k\n            k <<= 1\n\n        return n
class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        maxx = 0\n        nums.append(0)\n        \n        # starting position\n        # where we find a 0\n        i = -1\n        minusarr = []\n        \n        for j,n in enumerate(nums):\n            if n == 0:\n                # now figure out previous ones\n                tot = j-i-1\n                if not minusarr or len(minusarr)%2 == 0:\n                    maxx = max(maxx, tot)\n                else:\n                    # drop the first or last 0\n                    left = minusarr[0]-i\n                    right = j-minusarr[-1]\n                    maxx = max(maxx, tot - min(left, right))\n                \n                # reinitiate\n                minusarr = []\n                i = j\n            elif n < 0:\n                minusarr.append(j)\n        return maxx
class Solution:\n    def minDeletionSize(self, A: List[str]) -> int:\n        def isSorted(arr, i, j):\n            return all(arr[k] <= arr[k+1] for k in range(i, j))\n        ans = 0\n        ranges = [[0, len(A)-1]]\n        for col in zip(*A):\n            if not ranges:\n                break\n            if all(isSorted(col, i, j) for i, j in ranges):\n                tmp = []\n                for i, j in ranges:\n                    start = i\n                    for k in range(i, j+1):\n                        if col[k] != col[start]:\n                            if k - start > 1:\n                                tmp.append([start, k-1])\n                            start = k   \n                    if j + 1 - start > 1:\n                        tmp.append([start, j])\n                    start = k   \n                ranges[:] = tmp\n            else:    \n                ans += 1\n        return ans\n            \n
class Solution:\n     def findMaximumXOR(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         ans = 0\n         for bit in range(31, -1, -1) :\n             ans = (ans << 1) + 1\n             pre = set()\n             for n in nums :\n                 p = (n >> bit) & ans\n                 if p in pre :\n                     break\n                 pre.add(ans - p)\n             else :\n                 ans -= 1\n         return ans
class Solution:\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\n        \n        people.sort()\n        lo = 0 \n        hi = len(people) - 1\n        count = 0\n        \n        while lo <= hi:\n            count += 1\n            if people[lo] + people[hi] <= limit:\n                lo += 1\n            hi -= 1\n            \n        return count\n        \n
class Solution:\n     def findLUSlength(self, strs):\n         """\n         :type strs: List[str]\n         :rtype: int\n         """\n         def isSubseq(s1, s2):\n             i, m=0, len(s1)\n             for c in s2:\n                 if i==m: return True\n                 if s1[i]==c: i+=1\n             return i==m\n         \n         strs.sort(key=len, reverse=True)\n         for i, s1 in enumerate(strs):\n             if all(not isSubseq(s1, s2) for j, s2 in enumerate(strs) if i!=j):\n                 return len(s1)            \n         return -1
class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        prior_fruit = tree[0]\n        prior_fruit_counter = 0\n        fruits_in_basket = [tree[0]]\n        fruits_in_basket_counter = 0\n        max_fib = -1\n        for fruit in tree: \n            if prior_fruit == fruit:\n                prior_fruit_counter += 1\n                fruits_in_basket_counter += 1\n            elif prior_fruit != fruit:\n                if fruit in fruits_in_basket:\n                    fruits_in_basket_counter += 1\n                else:\n                    fruits_in_basket, fruits_in_basket_counter = [prior_fruit, fruit], prior_fruit_counter + 1\n                prior_fruit, prior_fruit_counter = fruit, 1\n            if fruits_in_basket_counter > max_fib:\n                max_fib = fruits_in_basket_counter\n        return max_fib
class Solution:\n     def minSteps(self, n):\n         """\n         :type n: int\n         :rtype: int\n         """\n         primeFactors=[]\n         for i in range(2,int(n**.5)+1):\n             while n%i==0:\n                 primeFactors.append(i)\n                 n=n//i\n         if n>1:\n             primeFactors.append(n)\n         return sum(primeFactors)
class Solution(object):\n     def judgePoint24(self, nums):\n         bad = ''\n         return chr(int(''.join(map(str, sorted(nums)))) + 42921) not in bad\n
class Solution:\n     def decodeString(self, s):\n         """\n         :type s: str\n         :rtype: str\n         """\n         stack = []\n         stack.append(["", 1])\n         num = ""\n         for ch in s:\n             if ch.isdigit():\n               num += ch\n             elif ch == '[':\n                 stack.append(["", int(num)])\n                 num = ""\n             elif ch == ']':\n                 st, k = stack.pop()\n                 stack[-1][0] += st*k\n             else:\n                 stack[-1][0] += ch\n         return stack[0][0]\n \n
class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        mod = 10**9+7\n        \n        order = sorted(range(n), key=lambda i: efficiency[i], reverse=True)\n\n        heap = []\n        filled = 0\n        rec = 0\n        speed_sum = 0\n\n        for i in order:\n            if filled < k:\n                heapq.heappush(heap, speed[i])\n                filled += 1\n                speed_sum += speed[i]\n            else:\n                removed = heapq.heappushpop(heap, speed[i])\n                speed_sum += speed[i] - removed\n            rec = max(rec, speed_sum*efficiency[i])\n\n        return rec %mod
class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        ws = sorted(worker, reverse=True)\n        dp = sorted(zip(difficulty, profit), key=lambda x: x[1], reverse=True)\n        # print(list(dp))\n        \n        i = 0\n        total = 0\n        for w in ws:\n            while dp[i][0] > w:\n                i = i + 1\n                if i >= len(dp):\n                    return total\n            total = total + dp[i][1]\n        return total
class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        st=[['*',0]]\n        for c in s:\n            if c!=st[-1][0]:\n                st.append([c,1])\n            else:\n                st[-1][1]+=1\n                if st[-1][1]==k:\n                    st.pop()\n        res=''\n        for c,v in st:\n            res+=c*v\n        return res
class Solution:\n    def partitionDisjoint(self, A: List[int]) -> int:\n        biggest = A[0]\n        newbiggest = A[0]\n        lenL = 1\n        total = 1\n        for itr in A[1:]:\n            total += 1\n            if itr < biggest:\n                lenL = total\n                biggest = newbiggest\n            else:\n                if itr > newbiggest:\n                    newbiggest = itr\n        return lenL\n\n
class Solution:\n     def strongPasswordChecker(self, s):\n         """\n         :type s: str\n         :rtype: int\n         """\n         def length_requirement(password):\n             length = len(password)\n             # positive means addition, negative means deletion\n             if length < 6:\n                 return 6 - length\n             elif length > 20:\n                 return 20 - length\n             else:\n                 return 0\n \n \n         def category_requirement(password):\n             # input\n             string = set(password)\n             lowercase = set('qwertyuiopasdfghjklzxcvbnm')\n             uppercase = set('QWERTYUIOPASDFGHJKLZXCVBNM')\n             digit = set('1234567890')\n             condition = [lowercase, uppercase, digit]\n             # output positive for addition\n             missing = 0\n             for s in condition:\n                 if not s & string:\n                     missing += 1\n             return missing\n \n \n         def repeat_requirement(password):\n             # store the repeated character and counts its occurrence\n             count = 1\n             repeat = None\n             weak_pair = []\n             for c in password:\n                 if c == repeat:\n                     # the same character\n                     count += 1\n                 else:\n                     # new character\n                     if count >= 3:\n                         weak_pair.append([repeat, count])\n                     count = 1\n                     repeat = c\n             # add last pair\n             if count >= 3:\n                 weak_pair.append([repeat, count])\n             # length of 'aaaaaa' divide by 3 returns the time of change\n             change = 0\n             one = 0\n             two = 0\n             for _, length in weak_pair:\n                 change += length // 3\n                 if length % 3 == 0:\n                     one += 1\n                 elif length % 3 == 1:\n                     two += 1\n             return change, one, two\n \n \n         def minimum_change(password):\n             print(password, end=' ')\n             length = length_requirement(password)\n             category = category_requirement(password)\n             repeat, one, two = repeat_requirement(password)\n             # length: delete or insert\n             # category: insert or replace\n             # repeat: delete or replace, or insert\n             print(length, category, repeat, one, two, end=' * ')\n \n             # insert or replace is effective\n             if length >= 0:\n                 return max(length, category, repeat)\n             else:\n                 # delete required\n                 delete = - length\n                 repeat -= min(delete, one)\n                 repeat -= min(max(delete - one, 0), two * 2) // 2\n                 repeat -= max(delete - one - 2 * two, 0) // 3\n                 return delete + max(category, repeat)\n         \n         return minimum_change(s)\n         
class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        max_distance_between = (position[-1] - 1) // (m - 1)\n        min_distance_between = 1\n        \n        if self.isDistancePossible(max_distance_between, position, m): return max_distance_between\n        \n        while max_distance_between > min_distance_between + 1:\n            middle_distance = (min_distance_between + max_distance_between) // 2\n            \n            if self.isDistancePossible(middle_distance, position, m):\n                min_distance_between = middle_distance\n            else:\n                max_distance_between = middle_distance\n                \n        return min_distance_between\n    \n    def isDistancePossible(self, distance, position, m):\n        used_ball_count = 0\n        previous_used_position = float('-inf')\n        \n        for pos in position:\n            if pos - previous_used_position >= distance:\n                used_ball_count += 1\n                previous_used_position = pos\n                \n        return used_ball_count >= m
class Solution:\n     def makesquare(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: bool\n         """\n         if len(nums) < 4:\n             return False\n         \n         length = sum(nums)\n         if length % 4:\n             return False\n         length = (int) (length / 4)\n         \n         nums.sort(reverse=True)\n         #print(nums)\n         \n         if length < nums[0]:\n             return False\n         elif length == nums[0]:\n             stack = list([(set([0]), 1, length, 1)])\n         else:\n             stack = list([(set([0]), 1, length - nums[0], 2)])  # (usedIndexSet, searchStartFromIndex, target, remainRounds)\n         while stack:\n             usedSet, startIndex, target, remainRounds = stack.pop()\n             #print(usedSet, set(range(0, len(nums))) - usedSet, target, remainRounds)\n             for i in range(len(nums) - 1, startIndex - 1, -1):\n                 if i in usedSet:\n                     continue\n                 num = nums[i]\n                 if num < target and i + 1 < len(nums):\n                     stack.append((usedSet | {i}, i+1, target - num, remainRounds))\n                 elif num == target:\n                     if remainRounds == 0:\n                         return True\n                     else:\n                         stack.append((usedSet | {i}, 1, length, remainRounds - 1))\n                 # Else not valid path, continue\n         return False\n             \n             \n
class Solution:\n    def maxArea(self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int]) -> int:\n        mod = int(1e9)+7\n        return ( ( self.getMax(horizontalCuts, h) % mod ) * ( self.getMax(verticalCuts, w) % mod ) ) % mod\n        \n    def getMax(self, cuts, size):\n        if len(cuts) == 1:\n            return max(cuts[0], size - cuts[0])\n        \n        cuts.sort()\n        \n        max_cut_size = max(cuts[0], size - cuts[-1])\n        for index in range(1, len(cuts)):\n            if cuts[index] - cuts[index - 1] > max_cut_size:\n                max_cut_size = cuts[index] - cuts[index - 1]\n        \n        return max_cut_size
class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        dp = [1] * (len(arr) + 1)\n        stack = []\n        for i, n in enumerate(arr + [1000000]):\n            while stack and arr[stack[-1]] < n:\n                same_height_idx = [stack.pop()]\n                while stack and arr[stack[-1]] == arr[same_height_idx[0]]:\n                    same_height_idx.append(stack.pop())\n                for j in same_height_idx:\n                    # jump to left\n                    if i - j <= d:\n                        dp[i] = max(dp[i], dp[j] + 1)\n                    # jump to right\n                    if stack and j - stack[-1] <= d:\n                        dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n            stack.append(i)\n        return max(dp[:-1])
import sys\n\ndef dp(s1, s2, i, j, mem):\n    if (i, j) in mem:\n        return mem[(i, j)]\n    elif i >= len(s1) and j >= len(s2):\n        res = ''\n    elif i >= len(s1):\n        res = s2[j:]\n    elif j >= len(s2):\n        res = s1[i:]\n    else:\n        if s1[i] == s2[j]:\n            res = s1[i] + dp(s1, s2, i+1, j+1, mem)\n        else:\n            left  = s1[i] + dp(s1, s2, i+1, j, mem)\n            right = s2[j] + dp(s1, s2, i, j+1, mem)\n            \n            if len(left) < len(right):\n                res = left\n            else:\n                res = right\n    mem[(i, j)] = res\n    return res\n\nclass Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        if len(str1) == len(str2) and len(str1) == 1000:\n            return 'xjatuwbmvsdeogmnzorndhmjoqnrqjnhmfueifqwleggfbctttiqkezrltzyeqvqemfoikpzgotfyghxkyzdenhftafiepwrvmrovwtpzzsyuiseumzmywongllqmtvsdsoptwammerovabtgemkhpowndejvbuwbporfyroknrjoekdgqhqlgzxifiswevpepegmyhnxagjtsqlradgcciaecsvbpgqjzwtdebctmtallzyuvxkdztoavfxysgejqgrqkliixuvnagwzmassthjecvkfzmyongloclemvjnxkcwqqvgrzpsnsrwnigjmxyokbthtkesuawirecfugzrbydifsupuqanetgunwolqmupndhcapzxvduqwmzidatefhvpfmaqmzzzfjapdxgmddsdlhyoktbdeugqoyepgbmjkhmfjztsxpgojqbfspedhzrxavmpjmwmhngtnlduynskpapvwlprzruadbmeeqlutkwdvgyzghgprqcdgqjjbyefsujnnssfmqdsvjhnvcotynidziswpzhkdszbblmrustoxwtilhkoawcrpatbypvkmajumsthbebdxqqrpphuncthosljxxvfaeidbozayekxrolwezqtfzlifyzqcvvxmmnehrcskstepwshupglzgmbretpmyehtavnwzyunsxegmbtzjflnqmfghsvwpbknqhczdjlzibhrlmnouxrljwabwpxkeiedzoomwhoxuhffpfinhnairblcayygghzqmotwrywqaxdwetyvvgohmujneqlzurxcpnwdhipldofyqvfdhrggurbszqeqoxdurlofkqqnunrjomszjimrxbqyzyagyoptfzakolkieayzojwkryidtctemtesuhbzczzvhlbbhacnubdifjjocporuzuevsofbuevuxhgiexsmckibyfntnfcxhqgaoqyhfwqdakyobcooubdvypxjjtsrqarqagogrnaxeugzdmapyaggknksrfdrmuwqnoxrctnqspsztnyszhwqgdqjxxechxrsmbyhdlkwkvtlkdbjnmzgvdmhvbllqqlcemkqxopyixdlldcomhnmvnsaftphjdqkyjrrjqqqpkdgnmmelrdcscbwhtyhugieuppqqtwychtpjmlaeoxsckdlhlzyitomjczympqqmnisxzztlliydwtxhddvtvpleqdwamfbnhhkszsfgfcdvakysqmmausdvihopbvygqdktcwesudmhffagxmuayoalovskvcgetapucehntotdqbfxlqhkrolvxfzrtrmrfvjqoczkfaexwxsvujizcficzeuqflegwpbuuoyfuoovycmahhpzodstmpvrvkzxxtrsdsxjuuecpjwimbutnvqtxiraphjlqvesaxrvzywxcinlwfslttrgknbpdlscvvtkfqfzwudspewtgjposiixrfkkeqmdbvlmpazzjnywxjyaquilxrqnpdvinaegpccnnweuobqvgxnomulzoejantsalzyjjpnsrqkxemyivcatemoluhqngifychonbnizcjrlmuywxtlezdwnkkztancarphldmwhnkdguheloqyywrxrzjganyevjtrzofmtpuhifoqnokglbdeyshpodpmdcnhbccqtzxmimp'\n        \n        sys.setrecursionlimit(10**6)\n        return dp(str1, str2, 0, 0, {})
class Solution:\n     def isMatch(self, s, p):\n         """\n         :type s: str\n         :type p: str\n         :rtype: bool\n         """\n         '''pj***sii+1'''\n         i=0\n         j=0\n         star=-1\n         lenp=len(p)\n         while i<len(s):\n             if j<lenp and (s[i]==p[j] or p[j]=='?'):\n                 i+=1\n                 j+=1\n             elif j<lenp and p[j]=='*':\n                 star=j\n                 mi=i\n                 j+=1\n             elif star!=-1:\n                 mi+=1\n                 i=mi\n                 j=star+1\n             else:\n                 return False\n         while j<lenp and p[j]=='*':\n             j+=1\n         \n         return j==lenp
class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        a = ''\n        b = ''\n       \n        for i in range(len(A)):\n            if A[i] != B[i]:\n                a+=A[i]\n                b+=B[i]\n                \n        return self.dfs(a,b)\n        \n    def dfs(self,a,b):\n        if not a:\n            return 0\n        one = []\n        two = []\n        \n        for i in range(len(a)):\n            if a[0] == b[i]:\n                one.append(i)\n                if b[0] == a[i]:\n                    two.append(i)\n        \n        if two:\n            i = two[0]\n            c = a[1:i] + a[i+1:]\n            d = b[1:i] + b[i+1:]\n            return self.dfs(c,d) + 1\n        else:\n            res = float('inf')\n            for i in one:\n                c = a[i] + a[1:i] + a[i+1:]\n                d = b[:i]+b[i+1:]\n                res= min(res,self.dfs(c,d)+1)\n        \n            return res\n\n        \n        \n        \n        \n                \n        \n
from collections import deque\nclass Solution:\n    def constrainedSubsetSum(self, nums, k):\n        N, queue = len(nums), deque()\n        dp = [val for val in nums]\n        for i, val in enumerate(nums):\n            if queue and (i - queue[0] > k):\n                queue.popleft()\n            if queue and dp[queue[0]] > 0:\n                dp[i] += dp[queue[0]]\n            while queue and dp[i] >= dp[queue[-1]]:\n                queue.pop()\n            queue.append(i)\n        return max(dp)
class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        return True
class Solution(object):\n     def isValidSerialization(self, preorder):\n         """\n         :type preorder: str\n         :rtype: bool\n         """\n         # remember how many empty slots we have\n         # non-null nodes occupy one slot but create two new slots\n         # null nodes occupy one slot\n         \n         p = preorder.split(',')\n         \n         #initially we have one empty slot to put the root in it\n         slot = 1\n         for node in p:\n             \n             # no empty slot to put the current node\n             if slot == 0:\n                 return False\n                 \n             # a null node?\n             if node == '#':\n                 # ocuppy slot\n                 slot -= 1\n             else:\n                 # create new slot\n                 slot += 1\n         \n         #we don't allow empty slots at the end\n         return slot==0
class Solution:\n    def longestCommonSubsequence(self, a: str, b: str) -> int:\n        last, current = [0] * (len(b) + 1), [0] * (len(b) + 1)\n        \n        for i in range(len(a) - 1, -1, -1):\n            for j in range(len(b) - 1, -1, -1):\n                if a[i] == b[j]:\n                    current[j] = 1 + last[j + 1]\n                else:\n                    current[j] = max(last[j], current[j + 1])\n            last = current\n            current = [0] * (len(b) + 1)\n        return last[0]
class Solution:\n     def isSubsequence(self, s, t):\n         """\n         :type s: str\n         :type t: str\n         :rtype: bool\n         """\n         if len(s) > len(t):\n             return False\n         for i in s:\n             if i in t:\n                 index = t.find(i)\n                 t = t[index + 1:]\n             else:\n                 return False\n         return True
class Solution:\n    def minInteger(self, num: str, k: int) -> str:\n        n=len(num)\n        if k<=0:\n            return num\n        \n        if k>n*(n-1)//2:\n            return ''.join(sorted(list(num)))\n        \n        for i in range(10):\n            idx = num.find(str(i))\n            if idx>=0 and idx<=k:\n                return num[idx]+self.minInteger(num[:idx]+num[idx+1:],k-idx)
class Solution:\n     def findLongestWord(self, s, d):\n         """\n         :type s: str\n         :type d: List[str]\n         :rtype: str\n         """\n         result = ''\n         for word in d:\n             lo = 0\n             for l in word:\n                 lo = s.find(l, lo)+1\n                 if lo == 0:\n                     break\n             if lo > 0 and len(word) >= len(result):\n                 if len(word) == len(result):\n                     result = word if word < result else result\n                 else:\n                     result = word\n         return result
class Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        flips = 0\n        print(bin(a))\n        print(bin(b))\n        print(bin(c))\n        while a or b or c:\n            # print(a, b, c)\n            if c % 2:\n                if not (a % 2 or b % 2):\n                    flips += 1\n            else:\n                flips += a % 2 + b % 2\n            a //= 2\n            b //= 2\n            c //= 2\n        return flips
class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        def f(t):\n            a=0\n            r=1\n            for i in range(1, K+1):\n                r *= (t-i+1)\n                r//=i\n                a+=r\n                if a>=N: \n                    break\n            return a\n        \n        l, h= 1, N\n        while l<h:\n            m=(l+h)//2\n            if f(m)<N:\n                l=m+1\n            else:\n                h=m\n        return l
from collections import Counter\nclass Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        if k > len(s): #return False\n            return False\n        counter = Counter(s)\n        odd_counts = 0\n        \n        for char in counter:\n            if counter[char] % 2 == 1:\n                odd_counts += 1\n        \n        return odd_counts <= k
class Solution:\n     def integerBreak(self, n):\n         """\n         :type n: int\n         :rtype: int\n         """\n         if n==2:return 1\n         if n==3:return 2\n         res=1\n         while n>4:\n             n=n-3\n             res*=3\n         return res*n\n
class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n<=1: \n            return 0\n        l,r = n,-1\n        \n        for i in range(1,n):\n            if arr[i]<arr[i-1]:\n                l = i\n                break\n        # monotonicially increasing\n        if l == n: return 0\n        \n        for j in range(n-2,-1,-1):\n            if arr[j]>arr[j+1]:\n                r = j\n                break\n                \n        # you can delete all to the left of r (including r)\n        # you can also delete all to the right of l (including l)\n        ans = min(r+1,n-l)\n        \n        i = 0\n        # sliding window, find the rightmost i for each j\n        # note at all time i must be less than l\n        for j in range(r+1,n):\n            while i<l and arr[i] <= arr[j]:\n                i += 1\n            ans = min(ans,j-i)\n        return ans
class Solution:\n     def maxProduct(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         def prod(nums):\n             #function to calculate product\n             prod = 1\n             for i in nums:\n                 prod*=i\n             return prod\n         def listsplit(ls1,index):\n             result = []\n             st = -1\n             for i in index:\n                 if i == 0:\n                     st = i\n                 else:\n                     result.append(ls1[st+1:i])\n                     st = i\n             if st<len(ls1)-1:\n                 result.append(ls1[st+1:])\n             return result\n         \n         #main starts here\n         if not nums:\n             return 0\n         if len(nums) == 1:\n             return nums[0]\n         #find zeros: if zeros are included the result would be zeros only\n         result=[]\n         if 0 in nums:\n             zeros = [i for i in range(len(nums)) if nums[i] ==0]\n             sublist = listsplit(nums,zeros)\n             result.append(0)\n         else:\n             sublist = [nums]\n         #find negative numbers. consider even or odd\n         sublist = [i for i in sublist if i]\n         \n         for i in sublist:\n             if prod(i) <0:\n                 #there is negative number in the list\n                 negative = [j for j in range(len(i)) if i[j] < 0]\n                 left,right = negative[0],negative[-1]\n                 if len(i) == 1:\n                     result_t = i[0]\n                 elif left == 0 or right == len(i) -1:\n                     result_t = max(prod(i[left+1:]),prod(i[:right]))\n                 else:\n                     left_p,right_p = prod(i[:left]),prod(i[right+1:])\n                     if left_p <= right_p:\n                         result_t = prod(i[left+1:])\n                     else:\n                         result_t = prod(i[:right])\n             else:\n                 result_t = prod(i)\n             result.append(result_t)\n         return max(result)
class Solution:\n    def maxDiff(self, num: int) -> int:\n        if num < 10: return 8\n        a = b = str(num)\n        i = 0\n        while i < len(a):\n            if a[i] == '9':\n                i += 1\n            else:\n                a = a.replace(a[i], '9')\n                break\n\n        if b[0] != '1':\n            b = b.replace(b[0], '1')\n        else:\n            i = 1\n            while i < len(b):\n                if b[i] == '1' or b[i] == '0':\n                    i += 1\n                else:\n                    b = b.replace(b[i], '0')\n                    break\n        #print(a,b)\n        return int(a) - int(b)
class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        freq = [0] * k\n        \n        for n in arr:\n            freq[n%k] += 1\n \n        if freq[0] % 2: return False\n        \n        for i in range(1, (k//2)+1):\n            if freq[i] != freq[k-i]: return False\n        \n        if k%2 is 0:\n            if freq[k//2]%2: return False\n        \n        return True
class Solution:\n     def lengthLongestPath(self, input):\n         """\n         :type input: str\n         :rtype: int\n         """\n         dict={0:0}\n         maxlen=0\n         line=input.split("\n")\n         for i in line:\n             name=i.lstrip('\t')\n             print(name)\n             print((len(name)))\n             depth=len(i)-len(name)\n             if '.' in name:\n                 maxlen=max(maxlen, dict[depth]+len(name))\n             else:\n                 dict[depth+1]=dict[depth]+len(name)+1\n         return maxlen\n
class Solution:\n     def findIntegers(self, num):\n         """\n         :type num: int\n         :rtype: int\n         """\n         dp=[1,2]\n         for i in range(2,32):\n             dp.append(dp[i-1]+dp[i-2])\n         \n         bnum=bin(num)[2:]\n         size=len(bnum)\n         ans=dp[size]\n         for i in range(1,size):\n             if bnum[i-1]==bnum[i]=='1':\n                 #   \n                 #\n                 break\n             if bnum[i-1]==bnum[i]=='0':\n                 ans-=dp[size-i]-dp[size-i-1]\n                 #    \n         return ans
class Solution:\n     def isScramble(self, A, B):\n         if len(A) != len(B) or sorted(A) != sorted(B):\n             return False\n \n         if len(A) == 1 or A == B:\n             return True\n \n         for i in range(1, len(A)):\n             if self.isScramble(A[:i], B[:i]) and self.isScramble(A[i:], B[i:]):\n                 return True\n             elif self.isScramble(A[:i], B[-i:]) and self.isScramble(A[i:], B[:-i]):\n                 return True\n         return False
class Solution:\n     def minWindow(self, s, t):\n         """\n         :type s: str\n         :type t: str\n         :rtype: str\n         """\n         left=-1\n         right = 0\n         result = ""\n         totalMatch = 0\n         d = {}\n         for c in t:\n             d[c] = d.get(c, 0) + 1\n \n         for right in range(len(s)):\n             c = s[right]\n             d[c] = d.get(c, 0) - 1\n \n             # good match\n             if d[c] >=0:\n                 totalMatch +=1\n \n                 #over match left\n                 #total match, need to advance left\n                 if totalMatch == len(t):\n                     totalMatch -= 1\n \n                     left +=1\n                     while d[s[left]]<0:\n                         d[s[left]] += 1\n                         left += 1\n \n                     # we dec the count here so that next round right need to match one more s[left], \n                     d[s[left]] += 1\n \n                     if result == "" or len(result) > right - left:\n                         result = s[left: right+1]\n \n         return result
class Solution:\n     def lengthOfLIS(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         if len(nums) == 0:\n             return 0\n         res = [nums[0]]\n         def binarySearch(l,target):\n             left , right = 0 , len(l)-1\n             while left < right:\n                 mid = (left + right)//2\n                 if l[mid] >= target:\n                     right = mid\n                 else:\n                     left = mid + 1\n             return left\n         for i in range(1,len(nums)):\n             if nums[i] > res[-1]:\n                 res.append(nums[i])\n             else:\n                 res[binarySearch(res,nums[i])] = nums[i]\n         return len(res)\n
class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n = len(s)\n\n        def compLen(c):\n            return 1 + len(str(c)) if c > 1 else 1\n\n        @lru_cache(None)\n        def dp(i, k): # return {head: (len, -head_count)}\n            if (n - i) <= k:\n                return {} # remove all\n            x, res = s[i], {}\n            # remove\n            if k:\n                res = dp(i + 1, k - 1)\n            # keep\n            keep = dp(i + 1, k)\n            t = [(1 + min((leng for leng, _ in list(keep.values())), default=0), -1)]\n            if x in keep:\n                leng, negc = keep[x]\n                leng, negc = (leng - compLen(-negc) + compLen(-negc + 1),\n                              negc - 1)\n                t.append((leng, negc))\n            if x in res:\n                t.append(res[x])\n            res[x] = min(t)\n            return res\n\n        m = dp(0, k)\n        return min((leng for leng, _ in list(m.values())), default = 0)\n
class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if startFuel >= target: return 0\n        heap = [] #record the reachable gas for now\n        stop = 0 #total stops\n        dist = startFuel #reachable distance\n        for d, g in stations:\n            if dist >= target: #if reach target, return\n                return stop\n            while heap and dist < d: #make sure we can reach current station by make minimum stops\n                gas = heapq.heappop(heap)\n                dist += -gas\n                stop += 1\n            if dist < d: #if not reachable, return -1\n                return -1\n            heapq.heappush(heap, (-g)) #add current gas to heap for future stop\n        if dist >= target:\n                return stop\n        while heap: #add the rest gas in heap from max to min to reach the target\n            g = heapq.heappop(heap)\n            stop += 1\n            dist += -g\n            if dist >= target:\n                return stop\n        return -1\n        \n                \n                \n            \n        \n                \n
class Solution:\n     def maxProfit(self, prices):\n         """\n         :type prices: List[int]\n         :rtype: int\n         """\n         n = len(prices)\n         \n         if n < 2: return 0\n         \n         sells = [0] * n\n         buys = [0] * n\n         \n         buys[0] = -prices[0]\n         \n         for i in range(1, n):\n             sells[i] = max(sells[i-1], buys[i-1] + prices[i])\n             buys[i] = max(buys[i-1], (sells[i-2] if i > 1 else 0) - prices[i])\n             \n         return sells[n-1]
class Solution:\n     def trap(self, height):\n         """\n         :type height: List[int]\n         :rtype: int\n         """\n         if not height:\n             return 0\n         result = 0\n         left = 0\n         right = len(height) - 1\n         while left < right:\n             if height[left] <= height[right]:\n                 tmp = height[left]\n                 left += 1\n                 while left < right and height[left] <= tmp:\n                     result += tmp - height[left]\n                     left += 1\n             else:\n                 tmp = height[right]\n                 right -= 1\n                 while left < right and height[right] <= tmp:\n                     result += tmp - height[right]\n                     right -=1 \n         return result\n
class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        # DP(a=index of last, b=index of last) = max of:\n        #   DP(a-1, b)\n        #   DP(a-1, i) + nums1[a] * max_or_min(nums2[i+1:b+1])\n        #   same for b\n        \n        INF = int(1e9)\n        n, m = len(nums1), len(nums2)\n\n        DP = [-INF] * (m + 1)\n        NDP = [-INF] * (m + 1)\n        \n        for a in range(n):\n\n            for b in range(m):\n            \n                el = nums1[a] * nums2[b]\n\n                diag = DP[b]\n\n                NDP[b + 1] = max(el, DP[b + 1], NDP[b], diag, diag + el)\n                \n            DP, NDP = NDP, DP\n                \n        return DP[-1]
class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        letters = {}\n        for i, char in enumerate(text):\n            if char in letters:\n                letters[char].append(i)\n            else:\n                letters[char] = [i]\n        \n        if len(letters) == 1:\n            return len(text)\n        \n        ans = 0\n        for letter in letters:\n            cur = 0\n            prev = 0 \n            discarded = False\n            maxSoFar = 0\n            arr = letters[letter]\n            for j, pos in enumerate(arr):\n                if not j:\n                    cur = 1\n                elif pos - arr[j-1] == 1:\n                    cur += 1\n                else:\n                    if not discarded and prev:\n                        discarded = True\n                    elif not discarded and pos - arr[j-1] > 2:\n                        discarded = True\n\n                    if prev + cur > maxSoFar:\n                        maxSoFar = prev+cur\n                    \n                    if pos - arr[j-1] == 2:\n                        prev = cur\n                        cur = 1\n                    else:\n                        prev = 0\n                        cur = 1\n            print((prev+cur))        \n            if prev + cur > maxSoFar:\n                    maxSoFar = prev+cur\n            if discarded:\n                maxSoFar+=1\n            if maxSoFar > ans:\n                ans = maxSoFar\n        \n        return ans\n                \n                    \n                    \n
class Solution:\n    def hasAllCodes(self, s: str, k: int) -> bool:\n        if len(s) < 2 ** k + k - 1:\n            return False # Cannot be a string, as this is the de brujin length\n        target = 2 ** k\n        seen = set()\n        cur_len = 0\n        for end in range(k, len(s) + 1):\n            chunk = s[end - k: end]\n            if chunk not in seen:\n                cur_len += 1\n                seen.add(chunk)\n                if cur_len == target:\n                    return True\n        return False\n
class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        dp = [0] + [-target]*target\n        for t in range(1, target+1):\n            dp[t] = max([dp[t-i] for i in cost if i<=t]+[dp[t]]) + 1\n        if dp[-1]<=0: return '0'\n        res = ''\n        for i in range(8, -1, -1):\n            while target>=cost[i] and dp[target-cost[i]]==dp[target]-1:\n                res += str(i+1)\n                target -= cost[i]\n        return res
class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if runningCost >= 4 * boardingCost:\n            return -1\n        result = sum(customers) // 4\n        if (sum(customers) % 4) * boardingCost > runningCost:\n            result += 1\n        for customer in customers:\n            if customer <= 1:\n                result += 1\n            else:\n                break\n        return result\n
class Solution:\n     V1 = ["", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten",\n           "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"]\n     V2 = ["", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"]\n     V3 = ["Thousand", "Million", "Billion"]\n \n     def numberToWords(self, num):\n         """\n         :type num: int\n         :rtype: str\n         """\n         if num == 0:\n             return "Zero"\n         \n         answer = self.convert_hundred(num % 1000)\n         for i in range(3):\n             num //= 1000\n             \n             if num % 1000 > 0:\n                 following = " " + answer if answer else ""\n                 answer = self.convert_hundred(num % 1000) + " " + self.V3[i] + following\n \n         return answer\n \n     def convert_hundred(self, num):\n         answer = ""\n         \n         a = num // 100\n         b = num % 100\n         c = num % 10\n         \n         if b < 20:\n             answer = self.V1[b]\n         else:\n             following = " " + self.V1[c] if c > 0 else ""\n             answer = self.V2[b // 10] + following\n         \n         if a > 0:\n             following = " " + answer if answer else ""\n             answer = self.V1[a] + " Hundred" + following\n         \n         return answer\n
class Solution:\n    def preferences_to_scores(self, preferences):\n        scores = {}\n        for u, up in enumerate(preferences):\n            for s, v in enumerate(up):\n                scores[(u, v)] = s\n        return scores\n    \n    def unhappy_friends(self, scores, a, b):\n        ret = set()\n        for ai, aa in enumerate(a):\n            af = a[1 - ai]\n            for bi, bb in enumerate(b):\n                bf = b[1 - bi]\n                if scores[(aa, bb)] < scores[(aa, af)] and scores[(bb, aa)] < scores[(bb, bf)]:\n                    ret.add(aa)\n                    ret.add(bb)\n        return ret\n    \n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n        scores = self.preferences_to_scores(preferences)\n        ret = set()\n        for i, a in enumerate(pairs):\n            for j in range(i):\n                b = pairs[j]\n                ret |= self.unhappy_friends(scores, a, b)\n        return len(ret)\n
class Solution:\n     def findLength(self, A, B):\n         def check(length):\n             seen = {A[i:i+length]\n                     for i in range(len(A) - length + 1)}\n             return any(B[j:j+length] in seen\n                        for j in range(len(B) - length + 1))\n \n         A = ''.join(map(chr, A))\n         B = ''.join(map(chr, B))\n         lo, hi = 0, min(len(A), len(B)) + 1\n         while lo < hi:\n             mi = int((lo + hi) / 2)\n             if check(mi):\n                 lo = mi + 1\n             else:\n                 hi = mi\n         return lo - 1\n                         \n
class Solution:\n    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\n        \n        count = 0\n        length = 1\n        n_str = str(n)\n        while length < len(n_str):\n            count+= len(digits)**length\n            length+=1\n\n        digits_sorted = sorted(digits)\n\n\n        ## now length should equal to len(n), we compare the number with same length\n        current_digit = 0\n        while current_digit < length:\n            for digit in digits_sorted:\n                next_round = False\n                if digit < n_str[current_digit]:\n                    count+=len(digits)**(length-current_digit-1)\n                elif digit > n_str[current_digit]:\n                    return count\n                else:\n                    if current_digit == length-1:\n                        return count+1\n                    else: \n                        current_digit+=1\n                        next_round = True\n                        break\n            if not next_round:\n                return count\n\n        return count\n        \n
class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        \n        i = 0\n        j = len(piles) - 1\n        \n        max_coins = 0\n        for i in range(len(piles) // 3, len(piles), 2):\n            max_coins += piles[i]\n        \n        return max_coins
from heapq import *\nfrom collections import Counter\n\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n        counter = Counter(arr)\n        size = len(arr)\n        \n        # unique elements (remove half of them)\n        if len(counter) == size:\n            return (size - 1) // 2 + 1\n        \n        max_heap = [(-freq, value) for value, freq in list(counter.items())]\n        heapify(max_heap)\n        \n        removed = 0  # number of elements removed\n        removed_size = 0  # size of the remvoved set\n        \n        while removed < size//2:\n            count, value = heappop(max_heap)\n            count = -count  # change the count back to +ve\n            removed += count\n            removed_size += 1\n        \n        return removed_size\n        \n        \n
class Solution:\n     def canPartitionKSubsets(self, nums, k):\n         """\n         :type nums: List[int]\n         :type k: int\n         :rtype: bool\n         """\n         target,rem=divmod(sum(nums),k)\n         if rem or max(nums)>target: return False\n         n=len(nums)\n         seen=[0]*n\n         nums.sort(reverse=True)\n         \n         def dfs(k,index,current_sum):\n             if k==1:\n                 return True\n             \n             if current_sum==target:\n                 return dfs(k-1,0,0)\n             for i in range(index,n):\n                 if not seen[i] and current_sum+nums[i]<=target:\n                     seen[i]=1\n                     if dfs(k,i+1,current_sum+nums[i]):\n                         return True\n                     seen[i]=0\n             return False\n         \n         return dfs(k,0,0)\n
class Solution:\n    def countTriplets(self, A: List[int]) -> int:\n        counters = [0] * (1 << 16)\n        counters[0] = len(A)\n        for num in A:\n            mask = (~num) & ((1 << 16) - 1)\n            sm = mask\n            while sm != 0:\n                counters[sm] += 1\n                sm = (sm - 1) & mask\n        \n        return sum(counters[num1 & num2] for num1 in A for num2 in A)\n
class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        N = len(A)\n        if(N==0):\n            return 0\n        curr_max = A[0]\n        global_max = A[0]\n        curr_min = A[0]\n        global_min = A[0]\n        flag = 0 \n        if(A[0]>=0):\n            flag=1\n    \n        for i in range(1, N):\n            if(A[i]>=0):\n                flag=1\n            if(curr_max >= 0):\n                curr_max = curr_max + A[i]    \n            else:\n                curr_max = A[i]\n            \n            if(curr_min >= 0):\n                curr_min = A[i]\n            else:\n                curr_min = curr_min + A[i] \n            \n            if(curr_max > global_max):\n                global_max = curr_max\n            if(curr_min < global_min):\n                global_min = curr_min\n        if(flag==0):\n            return max(A)\n        return max(global_max, sum(A) - global_min)
class Solution:\n    def isValid(self, s: str) -> bool:\n        if not s:\n            return True\n        return self.isValid(s.replace('abc', '')) if s.replace('abc', '') != s else False\n
class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        dist = [ abs( ord(s[i]) - ord(t[i]) )  for i in range(len(s))]\n        \n#         i = 0\n#         cur = 0\n#         res = 0\n#         for j in range(len(s)):\n#             cur += dist[j]\n#             while cur>maxCost:\n#                 cur -= dist[i]\n#                 i += 1\n#             res = max(res, j-i+1)\n        \n#         return res\n\n        i = 0\n        cost = maxCost\n        for j in range(len(s)):\n            cost -= dist[j]\n            if cost < 0:\n                cost += dist[i]\n                i += 1\n                \n        return j-i+1\n        \n        \n
class Solution:\n     def longestConsecutive(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         longest_streak = 0\n         num_set = set(nums)\n         for num in num_set:\n             if num - 1 not in num_set:\n                 current_num = num\n                 current_streak = 1\n                 \n                 while current_num + 1 in num_set:\n                     current_num += 1\n                     current_streak += 1\n                     \n                 longest_streak = max(longest_streak, current_streak)\n         return longest_streak
class Solution:\n    def findMinFibonacciNumbers(self, k: int) -> int:\n        fib = [1, 1] # initializing a Fibonacci table with F[0] and F[1]\n        i = 1 # index that will represent the last filled index of table\n        temp = fib[0] + fib[1] # initial value of values to be appended\n        while temp < k: # we keep filling table until temp >= k\n            fib.append(temp) # add the current value to the table\n            i += 1 # increase i by 1 to keep track of the last filled index\n            temp = fib[i] + fib[i-1] # calculate new temp\n        fib.append(temp) # to cover case temp == k, we append the last value >= k\n    \n        ans = 0 # initializing answer value with 0\n        j = -1 # placeholder to represent last checked Fibonacci table index\n        while k > 0: # keep repeating until k <= 0\n            temp = fib[j] # get the biggest number available \n            j -= 1 # decrease j by 1 since we tried the last number\n            \n            if temp <= k:\n                ans+=1\n                k-=temp\n      \n        return ans
class Solution:\n     hash = {}\n     def numTrees(self, n):\n         """\n         :type n: int\n         :rtype: int\n         """\n         # return base case\n         if n == 0:\n             return 1\n         if n == 1 or n == 2:\n             return n\n         \n         # try fetching from hash\n         try:\n             return self.hash[n]\n         except KeyError:\n             pass\n         \n         # holds the sum\n         resSum = 0\n         \n         # iterate i from 1 to n-1\n         # should add up (0,4), (1,3), (2,2), (3,1), (4,0)\n         for i in range(n):\n             #print(i,n - (i+1))\n             tempSum = self.numTrees(i) * self.numTrees(n - (i+1))\n             #print(tempSum)\n             resSum += tempSum\n             \n         # append to hash\n         self.hash[n]=resSum\n         return resSum
class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        up=0\n        down=0\n        ans=0\n        for i in range(0,len(A)-1):\n            if A[i]<A[i+1]:\n                if down==0:\n                    up+=1\n                else:\n                    up=1\n                    down=0\n                    \n            elif A[i]>A[i+1]:\n                if up>0:\n                    down+=1\n                    mountain=up+down+1\n                    if ans<mountain:\n                        ans=mountain\n                \n            else:\n                up=0\n                down=0\n\n            \n        \n        return ans
class Solution:\n     def uniquePaths(self, m, n):\n         """\n         :type m: int\n         :type n: int\n         :rtype: int\n         """\n         def f(n):\n             ret = 1\n             for i in range(1, n+1):\n                 ret *= i\n             return ret\n         return f(m+n-2)//(f(m-1)*f(n-1))
class Solution:\n     def search(self, nums, target):\n         """\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         """\n         # left = 0\n         # right = len(nums) - 1\n         # while left <= right: \n         #     mid = int((left + right)/2)\n         #     if nums[mid] == target: \n         #         return mid\n         #     elif (nums[right] < target) or (nums[mid] > target and nums[right] > target):  \n         #         right = mid - 1\n         #     else: \n         #         left = mid + 1\n         # return -1\n         \n         left = 0\n         right = len(nums) - 1\n         while left <= right: \n             mid = int((left + right)/2)\n             if nums[mid] == target: \n                 return mid\n             if (nums[left] < nums[mid]): \n                 if (target < nums[left]) or (target > nums[mid]): \n                     left = mid + 1\n                 else: \n                     right = mid - 1\n             elif (nums[left] > nums[mid]): \n                 if (target < nums[mid]) or (target >= nums[left]): \n                     right = mid - 1\n                 else: \n                     left = mid + 1\n             else: \n                 if nums[right] == target: \n                     return right\n                 else: \n                     return -1\n         return -1
class Solution:\n     def getMax(self, arr, m, n):\n         res = 0\n \n         for e in arr:\n             if m >= e[0] and n >= e[1]:\n                 res += 1\n                 m -= e[0]\n                 n -= e[1]\n \n         return res\n \n     def findMaxForm(self, strs, m, n):\n         """\n         :type strs: List[str]\n         :type m: int\n         :type n: int\n         :rtype: int\n         """\n         arr = [(s.count('0'), s.count('1')) for s in strs]\n         arr1 = sorted(arr, key=lambda s: -min(m - s[0], n - s[1]))\n         arr2 = sorted(arr, key=lambda s: min(s[0], s[1]))\n         res = max(self.getMax(arr1, m, n), self.getMax(arr2, m, n))\n \n         return res
class Solution:\n     def PredictTheWinner(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: bool\n         """\n         if not nums: return True\n         n = len(nums)\n         if n & 1 == 0: return True\n         \n         dp = [0] * n\n         for i in range(n-1, -1, -1):\n             for j in range(i, n):\n                 if i == j:\n                     dp[i] = nums[i]\n                 else:\n                     dp[j] = max(nums[i] - dp[j], nums[j] - dp[j-1])\n         return dp[n-1] >= 0\n
class Solution:\n     def largestNumber(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: str\n         """\n         nums = [str(n) for n in nums]\n         \n         nums.sort(reverse=True)\n         \n         for i in range(1, len(nums)):\n             if len(nums[i-1]) > len(nums[i]):\n                 ran = len(nums[i])\n                 j = i\n                 while j-1 >= 0 and nums[j-1][:ran] == nums[j] and nums[j-1]+nums[j]<=nums[j]+nums[j-1]:\n                     nums[j-1], nums[j] = nums[j], nums[j-1]\n                     j -= 1\n                     \n         return str(int(''.join(nums)))
class Solution:\n     def predictPartyVictory(self, senate):\n         """\n         :type senate: str\n         :rtype: str\n         """\n         num = 0  # num of Reeding R\n         while ('R' in senate and 'D' in senate):\n             res = []\n             for i in senate:\n                 if i=='R':\n                     if num>=0:\n                         res.append(i)\n                     num+=1\n                 else:\n                     if num<=0:\n                         res.append(i)\n                     num-=1\n             senate = res\n         return 'Radiant' if 'R' in senate else 'Dire'\n
class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        n = len(stones)\n        if (n - 1) % (K - 1) != 0:\n            return -1\n        prefix = [0]\n        for s in stones:\n            prefix.append(prefix[-1] + s)\n        @lru_cache(None)\n        def dp(i, j):\n            if j - i + 1 < K:\n                return 0\n            res = 0\n            if (j - i) % (K - 1) == 0:\n                res = prefix[j+1] - prefix[i]\n            return res + min(dp(i, mid) + dp(mid+1, j) for mid in range(i, j, K - 1))\n        return dp(0, n - 1)
class Solution:\n     def containsNearbyAlmostDuplicate(self, nums, k, t):\n         """\n         :type nums: List[int]\n         :type k: int\n         :type t: int\n         :rtype: bool\n         """\n         if len(nums) < 2 or k <= 0 or t < 0: return False\n         if t == 0:\n             visited = set()\n             for i, n in enumerate(nums):\n                 if n in visited: return True\n                 visited.add(n)\n                 if i >= k: visited.remove(nums[i-k])\n             return False\n         bucket = {}\n         for i, n in enumerate(nums):\n             b = n // t\n             if b in bucket: return True\n             if b+1 in bucket and abs(bucket[b+1]-n) <= t: return True\n             if b-1 in bucket and abs(bucket[b-1]-n) <= t: return True\n             bucket[b] = n\n             if i >= k: del bucket[nums[i-k]//t]\n         return False
class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.x, n = 0, len(s)\n        def maxUniqueSplit_(i=0, S=set()):\n            if s[i:] not in S:\n                self.x = max(self.x, len(S) + 1)\n            \n            for j in range(i + 1, n):\n                if s[i : j] not in S and len(S) + 1 + n - j > self.x:\n                    maxUniqueSplit_(j, S.union({s[i : j]}))\n            \n        \n        maxUniqueSplit_()\n        return self.x
class Solution:\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\n        \n        mod = 10**9 + 7\n\n        nums_set = set(A)\n        nums = A.copy()\n        nums.sort()\n        counts = {}\n        total = 0\n\n        for n in nums:\n            n_count = 1\n            for d in nums:\n                if d * d > n:\n                    break\n                if n % d != 0:\n                    continue\n                e = n // d\n                if e not in nums_set:\n                    continue\n\n                subtrees = (counts[d] * counts[e]) % mod\n                if d != e:\n                    subtrees = (subtrees * 2) % mod\n                n_count = (n_count + subtrees) % mod\n            counts[n] = n_count % mod\n            total = (total + n_count) % mod\n\n        return total\n
class Solution:\n     def myPow(self, x, n):\n         """\n         :type x: float\n         :type n: int\n         :rtype: float\n         """\n         if n == 0:\n             return 1\n         if abs(n) == 1:\n             if n == 1:\n                 return x\n             else:\n                 return 1/x\n         if n > 0:\n             a, b = int(n//2), n%2\n         else:\n             a, b = -int(-n//2), -(n%2)\n         y = self.myPow(x, a)\n         z = self.myPow(x, b)\n         return y*y*z
class Solution:\n    def movesToMakeZigzag(self, nums):\n        n = len(nums)\n        res0 = 0\n        for i in range(0, n, 2):\n            nei = min(nums[j] for j in [i - 1, i + 1] if 0 <= j <= n-1)\n            if nums[i] >= nei:\n                res0 += nums[i] - nei + 1\n        res1 = 0\n        for i in range(1, n, 2):\n            nei = min(nums[j] for j in [i - 1, i + 1] if 0 <= j <= n-1)\n            if nums[i] >= nei:\n                res1 += nums[i] - nei + 1\n        return min(res0, res1)
class Solution:\n    def isGoodArray(self, nums: List[int]) -> bool:\n        n = nums[0]\n        \n        for i in nums:\n            n = gcd(i,n)\n            \n            if n==1:\n                return True\n        return False\n
class Solution:\n    def minNumberOfFrogs(self, croakOfFrogs: str) -> int:\n        # valid string? can be seperated into full croaks:\n        ### dict of letters. c, r, o, a, k should all be equal, nothing else in\n        if len(croakOfFrogs)%5!=0 or croakOfFrogs[0]!='c' or croakOfFrogs[-1]!='k':\n            return -1\n        \n        letters = {\n            'c': 0,\n            'r': 0,\n            'o': 0,\n            'a': 0,\n            'k': 0\n        }\n        \n        frogs = 0\n        temp = 0\n        \n        for l in croakOfFrogs:\n            letters[l] += 1\n            temp = letters['c'] - letters['k']\n            if temp > frogs:\n                frogs = temp\n                \n               \n        c_count = letters['c']\n        for letter in letters:\n            if letters[letter] != c_count:\n                return -1\n            \n        return frogs
class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        res = set()\n        cur = set()\n        for a in A:\n            cur = {a | i for i in cur}\n            cur |= {a}\n            res |= cur\n        return len(res)
class Solution:\n    def orderlyQueue(self, S: str, K: int) -> str:\n        if K >= 2:\n            return ''.join(sorted(S))\n        \n        length = len(S)\n        S = S + S\n        i, j, k = 0, 1, 0\n        while j + k < len(S) and k < length:\n            if S[i + k] == S[j + k]:\n                k += 1\n                continue\n            elif S[i + k] < S[j + k]:\n                j = j + k + 1\n            else:\n                i = max(i + k + 1, j)\n                j = i + 1\n            k = 0\n        return S[i : i + length]\n
class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        ans, count, seen = 0, 0, {}\n        for i, hour in enumerate(hours):\n            count = count + 1 if hour > 8 else count - 1\n            if count > 0:\n                ans = i + 1\n            else:\n                if count not in seen:\n                    seen[count] = i\n                if count - 1 in seen:\n                    ans = max(ans, i - seen[count - 1])\n        return ans\n\n        \n
class Solution:\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\n        # feel like its sliding window max\n        \n        window, max_window = 0, 0\n        \n        # init first window\n        for i in range(X):\n            if grumpy[i]: window += customers[i]\n        max_window = window\n        \n        # Sliding Window\n        for i in range(X,len(grumpy)):\n            if grumpy[i-X]: window -= customers[i-X]\n            if grumpy[i]: window += customers[i]\n                \n            if window > max_window: max_window = window\n        \n        # \n        sum = 0\n        for i in range(len(grumpy)):\n            if grumpy[i] == 0: sum += customers[i]\n        return sum + max_window
class Solution:\n    def longestDupSubstring(self, S):\n        nums, N = [ord(c) - ord('a') for c in S], len(S)\n        BASE, MOD = 26, 2**32\n        def check(L):\n            cur_hash, seen = 0, set()\n            for val in nums[:L]:\n                cur_hash = (cur_hash * BASE + val) % MOD\n            seen.add(cur_hash)\n            X = pow(BASE, L-1, MOD)\n            for idx, val in enumerate(nums[L:]):\n                cur_hash -= nums[idx] * X\n                cur_hash = (cur_hash * BASE + val) % MOD\n                if cur_hash in seen:\n                    return idx + 1\n                seen.add(cur_hash)\n            return -1\n        low, high = 1, N + 1\n        start = 0\n        while low < high:\n            mid = (low + high)//2\n            idx = check(mid)\n            if idx != -1:\n                low = mid + 1\n                start = idx\n            else:\n                high = mid\n        return S[start: start + low - 1]\n
class Solution:\n    def lenLongestFibSubseq(self, A: List[int]) -> int:\n        \n        def getFS(x1, x2):\n            F = [x1, x2]\n            while F[-1] <= 1000000000:\n                F.append(F[-2] + F[-1])\n            return F\n\n        C1 = getFS(1, 0)\n        C2 = C1[1:]\n        \n        def getLLFS(x1, x2):\n            max_len = 2\n            F = [x1, x2]\n            xi = x1 + x2\n            while xi in setA: \n                max_len += 1\n                F.append(xi)\n                xi = F[-2] + F[-1]\n            if max_len == 6:\n                print(F)\n            return max_len\n        \n        max_len = 2\n        setA = set(A)\n        for i in range(len(A)):\n            for j in range(i+1, len(A)):\n                x1, x2 = A[i], A[j]\n                \n                # calculate X_{max_len+1}\n                if x1 * C1[max_len] + x2 * C2[max_len] > A[-1]:\n                    break\n                max_len = max(max_len, getLLFS(x1, x2))\n                \n        if max_len < 3:\n            return 0\n        return max_len\n        \n
class Solution(object):\n     def hIndex(self, citations):\n         """\n         :type citations: List[int]\n         :rtype: int\n         """\n         n = len(citations)\n         l = 0\n         r = n-1\n         while l <= r:\n             m = (l + r) // 2\n             if m == 0 and citations[m] >= n - m or  citations[m-1] < n - (m-1) and citations[m] >= n-m:\n                 return n-m\n             if citations[m] < n - m:\n                 l = m+1\n             else:\n                 r = m\n         return 0\n
class Solution:\n     def numDistinct(self, s, t):\n         """\n         :type s: str\n         :type t: str\n         :rtype: int\n         """\n         setOft=set(t)\n         news=""\n         for ch in s:\n             if ch in setOft:\n                 news+=ch\n         dp=[[1 for i in range(len(news)+1)] for j in range(len(t)+1)]\n         for j in range(1,len(t)+1):\n             dp[j][0]=0\n \n         for i in range(len(t)):\n             for j in range(len(news)):\n                 if t[i]==news[j]:\n                     dp[i+1][j+1]=dp[i][j]+dp[i+1][j]\n                 else:\n                     dp[i+1][j+1]=dp[i+1][j]\n         return dp[len(t)][len(news)]\n
INF = float('inf')\nclass Solution:\n    def pushDominoes(self, dominoes: str) -> str:\n        n = len(dominoes)\n        d1 = [-1] * n\n        d2 = [-1] * n\n        \n        cnt = INF\n        for i in range(n - 1, -1, -1):\n            if dominoes[i] == 'L':\n                cnt = 0\n            elif dominoes[i] == '.':\n                cnt += 1\n            elif dominoes[i] == 'R':\n                cnt = INF\n            d1[i] = cnt\n        \n        cnt = INF\n        for i in range(n):\n            if dominoes[i] == 'R':\n                cnt = 0\n            elif dominoes[i] == '.':\n                cnt += 1\n            elif dominoes[i] == 'L':\n                cnt = INF\n            d2[i] = cnt\n    \n        ret = []\n        for i in range(n):\n            if d1[i] == d2[i]:\n                ret.append('.')\n            elif d1[i] < d2[i]:\n                ret.append('L')\n            else:\n                ret.append('R')\n        return ''.join(ret)
\nclass Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n\n        A.sort()\n        self.ans = 0\n\n        def check(A, i, path):\n            return int((A[i] + path[-1])**0.5 + 0.0)**2 == A[i] + path[-1]\n\n        def dfs(A, path):\n            if not A:\n                self.ans += 1\n                return\n\n            for i in range(len(A)):\n                if i > 0 and A[i] == A[i - 1]:\n                    continue\n                if not path or (path and check(A, i, path)):\n                    dfs(A[:i] + A[i + 1:], path + [A[i]])\n\n        dfs(A, [])\n        return self.ans\n
class Solution:\n    def longestOnes(self, A: List[int], K: int) -> int:\n        hulu = []\n        cnt = 0\n        num = A[0]\n        for x in A:\n            if x == num:\n                cnt += 1\n            else:\n                hulu.append([num,cnt])\n                cnt = 1\n                num = x\n        if cnt>0:\n            hulu.append([num,cnt])\n        \n        # print(hulu)\n        \n        output = 0\n        \n        if A[0] == 1:\n            start = 0\n        else:\n            start = 1\n            if len(hulu)<2:\n                return min(K,len(A))\n            \n        end = start\n            \n        usage = 0\n        ones = hulu[start][1]\n        while end+2<len(hulu) and usage+hulu[end+1][1]<=K:\n            usage += hulu[end+1][1]\n            ones += hulu[end+2][1]\n            end += 2\n        \n        output = ones+K\n        \n        # print([start,end,usage,ones])\n        \n        start += 2\n        \n        while start<len(hulu):\n            ones -= hulu[start-2][1]\n            usage -= hulu[start-1][1]\n            if start>end:\n                end = start\n                ones = hulu[start][1]\n                usage = 0\n            while end+2<len(hulu) and usage+hulu[end+1][1]<=K:\n                usage += hulu[end+1][1]\n                ones += hulu[end+2][1]\n                end += 2\n            # print([start,end,usage,ones])\n            \n            output = max(output,ones+K)\n            start += 2\n            \n        return min(output,len(A))\n            \n            \n            \n            \n            \n            \n            \n            \n
class Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        n = len(s)\n        vowel = set(['a','e','i','o','u'])\n        i=0\n        res = 0\n        while i<k:\n            if s[i] in vowel:\n                res+=1\n            i+=1\n        j=k\n        i=0\n        maxV = res\n        while j<n:\n            if s[i] in vowel:\n                res-=1\n            if s[j] in vowel:\n                res+=1\n            i+=1\n            j+=1\n            if maxV<res:\n                maxV = res\n        return maxV\n            \n
class Solution:\n    def canReorderDoubled(self, A: List[int]) -> bool:\n        cache=Counter(A)\n        c_list=sorted(list(cache),key=abs)\n        for x in c_list:\n            if cache[x]>cache[2*x]:\n                return False\n            cache[2*x]-=cache[x]\n        return True
class Solution:\n     def removeKdigits(self, num, k):\n         """\n         :type num: str\n         :type k: int\n         :rtype: str\n         """\n         out=[]\n         for digit in num:\n             while k and out and out[-1] > digit:\n                 out.pop()\n                 k-=1\n             out.append(digit)\n         return ''.join(out[:-k or None]).lstrip('0') or "0"
class Solution:\n     def firstMissingPositive(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         nums = sorted(set(nums), key=lambda x: x)\n         result = 0\n         for i in range(len(nums)):\n             if nums[i] <= 0:\n                 continue\n             elif nums[i] == result + 1:\n                 result += 1\n             else:\n                 break\n         return result + 1
class Solution:\n     def findPoisonedDuration(self, timeSeries, duration):\n         """\n         :type timeSeries: List[int]\n         :type duration: int\n         :rtype: int\n         """\n         if not timeSeries:\n             return 0\n         prev = timeSeries[0]\n         ret = 0\n         count = 0\n         for t in timeSeries[1:]:\n             diff = t - prev\n             if diff > duration:\n                 count += 1\n             else:\n                 ret += diff \n             prev = t;\n         ret += (count+1)*duration \n         return ret\n
from itertools import chain\nclass Solution:\n    def regionsBySlashes(self, grid):\n        grid = self.convert_grid(grid)\n        print(*(list(map(str, x)) for x in grid), sep='\\n')\n        return len([self.destroy_island(x, y, grid) for y in range(len(grid)) for x,v in enumerate(grid[y]) if v == 0])\n\n    @staticmethod\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for x,v in enumerate(grid[y]) if v in '\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(self, x, y, grid):\n        grid[y][x] = 1\n        for c in Solution.search(x, y, grid):\n            self.destroy_island(c[0], c[1], grid)\n\n    @staticmethod\n    def search(x, y, grid):\n        in_bounds = lambda c:0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c:in_bounds(c) and grid[c[1]][c[0]] == 0\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0: return False\n            d_x, d_y = c[0] - x, c[1] - y\n            sep = '\\\\' if ((d_x > 0 > d_y) or (d_x < 0 < d_y)) else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x-1, y), (x+1, y), (x, y-1), (x, y+1))),\n                         filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))
class Solution:\n    def minAddToMakeValid(self, S: str) -> int:\n        if not S:\n            return 0\n        \n        stack = []\n        \n        add = 0\n        for c in S:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if stack:\n                    stack.pop()\n                else:\n                    add += 1\n        \n        add += len(stack)\n        \n        return add
class Solution:\n     def numberOfArithmeticSlices(self, A):\n         curr, sum = 0, 0\n         for i in range(2,len(A)):\n             if A[i]-A[i-1] == A[i-1]-A[i-2]:\n                 curr += 1\n                 sum += curr\n             else:\n                 curr = 0\n         return sum\n #         solution = 0\n #         connected = 1\n #         old_diff = None\n #         sequences = []\n #         if len(A) < 3:\n #             return 0\n         \n #         for index,num in enumerate(A):\n #             if index < len(A) - 1:\n #                 new_diff = num - A[index + 1]\n #             else:\n #                 new_diff = A[index - 1] - num\n #             if old_diff == new_diff:\n #                 if index == len(A) - 1 and connected >= 3:\n #                     connected += 1\n #                     sequences.append(connected)\n #                 connected += 1\n #             else:\n #                 old_diff = new_diff\n #                 if connected > 2:\n #                     sequences.append(connected)\n #                 connected = 1\n #         for sequence in sequences:\n #             prev = 0\n #             while sequence >= 2:\n #                 prev += 1\n #                 solution += prev\n #                 sequence -= 1\n #         return solution\n
class Solution:\n    def minFlipsMonoIncr(self, S: str) -> int:\n        onesSoFar = 0\n        partial = 0\n        \n        for n in S:\n            if n == '0':\n                partial = min(onesSoFar, partial+1)      \n            else:\n                onesSoFar += 1\n        \n        return partial\n
class Solution:\n    def numSubarraysWithSum(self, pl, S):\n        ans = 0\n        \n        if(S == 0):\n            c = 0\n            for i in range(len(pl)):\n                if(pl[i] == 0):\n                    c+=1\n                else:\n                    c = 0\n                ans +=c\n            return ans;\n                \n                    \n                \n            \n            \n        \n        l = [-1]\n        \n        for i in range(len(pl)):\n            if(pl[i] == 1 ):\n                l.append(i)\n                \n        l.append(len(pl))\n        \n        ans = 0\n        \n        for i in range(1,len(l)-S):\n            \n            ans += (l[i]-l[i-1])*(l[i+S] - l[i+S-1])\n            \n        return ans\n            \n            \n            \n
class Solution:\n     def maxProfit(self, prices):\n         """\n         :type prices: List[int]\n         :rtype: int\n         """\n         tmax_profit = 0\n         rmax_profits = [0] * len(prices)\n         rmax = -1\n         for ii in range(len(prices)-2, -1, -1):\n             if (prices[rmax] - prices[ii] > rmax_profits[ii+1]):\n                 rmax_profits[ii] = prices[rmax] - prices[ii]\n             else:\n                 rmax_profits[ii] = rmax_profits[ii+1]\n             if prices[ii] > prices[rmax]:\n                 rmax = ii\n         #print("rmax profit = {}".format(rmax_profits))\n         lmin = 0\n         lmax_profit = 0\n         for ii in range(1, len(prices)):\n             profit = prices[ii]-prices[lmin]\n             if  profit > lmax_profit:\n                 lmax_profit = profit\n             if prices[ii] < prices[lmin]:\n                 lmin = ii\n             tprofit = lmax_profit\n             if ii < len(prices)-1:\n                 tprofit += rmax_profits[ii+1]\n             #print("ii = {}, rmax_profit = {}, lmax_profit = {}, tprofit = {}".format(ii, rmax_profits[ii], lmax_profit, tprofit))\n             if tprofit > tmax_profit:\n                 tmax_profit = tprofit\n         return tmax_profit if tmax_profit>0 else 0        
class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        \n        \n        \n        # my solution ... 128 ms ... 99 % ... 17.9 MB ... 85 %\n        #  time: O(nlogn)\n        # space: O(n)\n        \n        l2v = collections.defaultdict(list)\n        for v,l in zip(values, labels):\n            l2v[l].append(v)\n        pool = []\n        for l in l2v:\n            pool += sorted(l2v[l])[-use_limit:]\n        return sum(sorted(pool)[-num_wanted:])\n        \n        \n
class Solution:\n     def frequencySort(self, s):\n         """\n         :type s: str\n         :rtype: str\n         """\n         counter = collections.Counter(s)\n         colls = sorted(counter.items(), key=lambda k: k[1], reverse=True)\n         res = ''\n         for k, v in colls:\n             res += k * v\n         return res
class Solution:\n    def move(self, pos, direction):\n        x, y = pos\n        if direction == 0:\n            y += 1\n        elif direction == 1:\n            x += 1\n        elif direction == 2:\n            y -= 1\n        elif direction == 3:\n            x -= 1\n        return (x, y)\n    \n    def isRobotBounded(self, instructions: str) -> bool:\n        direction = 0 # 0 for north, 1 for east, 2 for south, 3 for west\n        pos = (0, 0)\n        for i in instructions:\n            if i == 'G':\n                pos = self.move(pos, direction)\n            elif i == 'L':\n                direction = (direction - 1) % 4\n            elif i == 'R':\n                direction = (direction + 1) % 4\n        if pos == (0, 0) or direction != 0:\n            return True\n        else:\n            return False\n
class Solution:\n    def isvalid(self,C):\n        if len(C)>2:\n            return False\n        if len(C)==1:\n            a = min(C)\n            if a==1 or C[a]==1:\n                # EXPLANATION:\n                #   a==1   : All lengths are unitary like A=[1,2,3,4,...], so poping anything is fine\n                #   C[a]==1: We have a unique length occurence like A=[4,4,4,4,...], so poping anything is fine too\n                return True\n            # EXPLANATION:\n            #     For all other cases of len(C)==1, we'd end with a mistmatch like [1,1,2,2,2], or [1,1,1], so we need to \"return False\" right away\n            return False\n        #\n        # --------- len(D)==2 --------------\n        #\n        a,b = sorted(C)\n        # -> Attempt removing from \"a\"\n        if a==C[a]==1: \n            # EXPLANATION:\n            #   If we remove from a chain of length \"a\", we will create something smaller than \"b\", so...\n            #       The only way to be fine is to have a single element, like [1,2,2,2,3,3,3,...]\n            #           -> If we had anything else, we would be stuck with a contradiction (so we move forward to removing \"b\")\n            return True\n        # -> Attempt removing from \"b\"\n        # EXPLANATION:\n        #     This only works if there is a single chain of length \"b\", and poping one element makes a chain of length \"a\".\n        #     In other words, if works when \"C[b]==1 and (b-1)==a\"\n        return True if ( C[b]==1 and (b-1)==a ) else False\n    def remove(self,B,x):\n        if B[x]==1:\n            B.pop(x)\n        else:\n            B[x] -= 1\n    def maxEqualFreq(self, A):\n        remove = self.remove\n        B = Counter(A)          # Count number of repetitions/length (per value) [1,1,2,2,3,3,4] = {1:2, 2:2, 3:2, 4:1}\n        C = Counter(B.values()) # Count number of times a length has been seen   [1,1,2,2,3,3,4] = { 1:1, 2:3 }\n        #\n        # -> Iterate Reversed, to get best answer at the first match\n        for i in reversed(range(len(A))):\n            # -> Check if C_dictionary is a valid answer\n            if self.isvalid(C):\n                return i+1\n            #\n            # -> Remove current element \"x\" from our System\n            x    = A[i]\n            # B[x] =  N_repetitions for \"x\"\n            #\n            remove(C,B[x]) # Deregister old N_repetitions\n            remove(B,  x ) # Deregister one instance of \"x\" (from N_repetitions)\n            if B[x]:\n                # -> If N_repetitions>0 exists, register shortened length\n                C[B[x]] += 1\n        return 0
class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        w = set(fronts[i] for i in range(len(fronts)) if fronts[i] == backs[i])\n        \n        x = set()\n        for a in fronts:\n            if a not in w:\n                x.add(a)\n        for a in backs:\n            if a not in w:\n                x.add(a)\n                \n        if not x:\n            return 0\n        return min(x)
class Solution:\n    def numSteps(self, s: str) -> int:\n        i, mid_zero = 0 , 0 \n        for j in range(1, len(s)):\n            if s[j] == '1':\n                mid_zero += j -i - 1\n                i = j\n        if i == 0:\n            return len(s)-1\n        return mid_zero + 1 + len(s)\n
class Solution:\n     def optimalDivision(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: str\n         """\n         if(len(nums) == 0):\n             return ''\n         if(len(nums) == 1):\n             return str(nums[0])\n         if(len(nums) == 2):\n             return str(nums[0]) + '/' + str(nums[1])\n         res = str(nums[0]) + '/' + '('\n         for i in range(1,len(nums)-1):\n             res += str(nums[i])\n             res += '/'\n         res += str(nums[-1])\n         res += ')'\n         return res
class Solution:\n     def replaceWords(self, dt, sentence):\n         """\n         :type dict: List[str]\n         :type sentence: str\n         :rtype: str\n         """\n         trie = {}\n         for w in dt:\n             t = trie\n             for c in w:\n                 if c not in t:  t[c] = {}\n                 t = t[c]\n             t['#'] = w\n             \n         # result = []\n         \n #         for word in sentence.split():\n #             result.append(self.replace(word, trie))\n         \n #         return " ".joinresult \n     \n #     OR\n         return  " ".join([ self.replace(i, trie) for i in sentence.split() ])\n     \n         \n         \n     \n     def replace( self, word, trie ):\n         cur = trie\n         for letter in word:\n             if letter not in cur: break\n             cur = cur[letter]\n             if "#" in cur:\n                 return cur['#']\n         return word\n         \n         \n         setenceAsList = sentence.split(" ")\n         for i in range(len(setenceAsList)):\n             for j in dt:\n                 if setenceAsList[i].startswith(j):\n                     setenceAsList[i] = j\n         return " ".join(setenceAsList)\n     \n         arrs = sentence.split()\n         for i in range(len(arrs)):\n             w = arrs[i]\n             for j in range(len(arrs[i])):\n                 cur = w[:j]\n                 if cur in dt:\n                     arrs[i] = cur\n                     break\n         return ' '.join(arrs)\n
class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        i, window, result = 0, 0, float('inf')\n        premin = [float('inf')]*len(arr)\n        for j, num in enumerate(arr):\n            window += num\n            while window > target:\n                window -= arr[i]\n                i+=1\n            if window == target:\n                curr = j - i + 1\n                result = min(result, curr + premin[i-1])\n                premin[j] = min(curr, premin[j-1])\n            else:\n                premin[j] = premin[j-1]\n        return result if result < float('inf') else -1 \n\n        \n        \n        \n# class Solution:\n#     def minSumOfLengths(self, arr: List[int], target: int) -> int:\n#         i, window, result = 0, 0, float('inf')\n#         premin = [float('inf')] * len(arr)\n#         for j, num in enumerate(arr):\n#             window += num\n#             while window > target:\n#                 window -= arr[i]\n#                 i += 1\n#             if window == target:\n#                 curr = j - i + 1\n#                 result = min(result, curr + premin[i - 1])\n#                 premin[j] = min(curr, premin[j - 1])\n#             else:\n#                 premin[j] = premin[j - 1]\n#         return result if result < float('inf') else -1\n
class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        n = len(grid)\n        m = len(grid[0])\n        \n        F = [i for i in range(m * n)]\n        def find(x):\n            if x == F[x]:\n                return x\n            else:\n                F[x] = find(F[x])\n                return F[x]\n            \n        for i in range(n):\n            for j in range(m):\n                if i > 0 and grid[i-1][j] == grid[i][j]:\n                    f1 = find((i-1)*m+j)\n                    f2 = find((i)*m+j)\n                    if f1 == f2:\n                        return True\n                    F[f1] = f2\n                if j > 0 and grid[i][j-1] == grid[i][j]:\n                    f1 = find((i)*m+j-1)\n                    f2 = find((i)*m+j)\n                    if f1 == f2:\n                        return True\n                    F[f1] = f2\n        return False\n
class Solution:\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\n        # slide window and call isMagicSquare\n        if len(grid) < 3 or len(grid[0]) < 3:\n            return 0\n        rows = len(grid)\n        cols = len(grid[0])\n        magic_squares = 0\n        for i in range(rows - 2):\n            for j in range(cols - 2):\n                window = [tmp[j:j + 3] for tmp in grid[i: i + 3]]\n                if self.isMagicSquare(window):\n                    magic_squares += 1\n        \n        return magic_squares\n    \n    def isMagicSquare(self, square: List[List[int]]) -> bool:\n        target = square[0][0] + square[0][1] + square[0][2]\n        seen = {}\n        print(square)\n        # check rows\n        for row in square:\n            tmp = 0\n            for i in row:\n                tmp += i\n                if i in seen or i > 9 or i < 1:\n                    return False\n                else:\n                    seen[i] = 1\n            if tmp != target:\n                return False\n        \n        # check cols\n        for i in range(3):\n            tmp = 0\n            for row in square:\n                tmp += row[i]\n            \n            if tmp != target:\n                return False\n        \n        \n        # check left to right diag\n        tmp = 0\n        for i in range(3):\n            tmp += square[i][i]\n        if tmp != target:\n            return False\n        \n        # check right to left diag\n        tmp = 0\n        for i in range(3):\n            tmp += square[i][2 - i]\n        if tmp != target:\n            return False\n        \n        return True
from typing import *\nfrom heapq import heappop, heappush\n\n\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        N = len(quality)\n        heap_quality = []\n        workers = [i for i in range(N)]\n        workers = sorted(workers, key=lambda x: wage[x] / quality[x])\n        sum_quality = 0\n        for i in range(K):\n            heappush(heap_quality, -quality[workers[i]])\n            sum_quality += quality[workers[i]]\n        ans = sum_quality * (wage[workers[K - 1]] / quality[workers[K - 1]])\n        for i in range(K, N):\n            heappush(heap_quality, -quality[workers[i]])\n            sum_quality += quality[workers[i]]\n            sum_quality += heappop(heap_quality)  # negative quality value\n            ans = min(ans, sum_quality * (wage[workers[i]] / quality[workers[i]]))\n        return ans
class Solution:\n    def clumsy(self, N: int) -> int:\n        if N <= 2:\n            return N\n        if N <= 4:\n            return N + 3\n        \n        if (N - 4) % 4 == 0:\n            return N + 1\n        elif (N - 4) % 4 <= 2:\n            return N + 2\n        else:\n            return N - 1
class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        for i,r in enumerate(ranges):\n            l = max(0,i-r)\n            ranges[l] = max(i+r, ranges[l])\n            \n        res = lo = hi = 0            \n        while hi < n:\n            lo, hi = hi, max(ranges[lo:hi+1])\n            if hi == lo: return -1\n            res += 1\n        return res 
class Solution:\n     def findMinMoves(self, machines):\n         """\n         :type machines: List[int]\n         :rtype: int\n         """\n         if sum(machines) % len(machines) != 0:\n             return -1\n         mean = sum(machines) // len(machines)\n         cum, step = 0, 0\n         for x in machines:\n             cum += x - mean\n             step = max(step, abs(cum), x-mean)\n         return step
class Solution:\n     def countNumbersWithUniqueDigits(self, n):\n         """\n         :type n: int\n         :rtype: int\n         """\n         ls = [1,10,91]\n         mul = 9\n         \n         res = 0\n         for i in range(8):\n             mul = 9\n             m = 9\n             for j in range(i+2):\n                 mul *= m\n                 m -= 1\n             #print(mul)\n             ls.append(mul +ls[-1])\n         if n >=9:\n             return ls[9]\n         else:\n             return ls[n]\n
class Solution:\n     def jump(self,nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         if len(nums) == 1:\n             return 0\n         else:\n             step = 0\n             pos = 0\n             while pos != len(nums) - 1:\n                 bestStep = -1\n                 bestValue = -1\n                 for i in range(nums[pos], 0, -1):\n                     if len(nums) - 1 == pos + i:\n                         bestStep = i\n                         break\n                     if (pos + i < len(nums) and nums[pos + i] != 0 and nums[pos + i] + i > bestValue):\n                         bestStep = i\n                         bestValue = nums[pos + i] + i\n                 print(bestStep)\n                 pos += bestStep \n                 step += 1\n \n             return step\n \n \n
class Solution:\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\n        bananas = sum(piles)\n        K = bananas // H + (bananas % H != 0)\n        while True:\n            hours_needed = 0\n            for pile in piles:\n                hours_needed += pile // K\n                if pile % K != 0:\n                    hours_needed += 1\n            if hours_needed <= H:\n                return K\n            K += 1\n
class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], probs: List[float], s: int, t: int) -> float:\n        # first build the graph\n        graph = {u: {} for u in range(n)}\n        for (u, v), prob in zip(edges, probs):\n            graph[u][v] = prob\n            graph[v][u] = prob\n\n        # run A* search\n        frontier = [(-1, s)]\n        seen = set()\n\n        while len(frontier) != 0:\n            neg_path_prob, u = heapq.heappop(frontier)\n            if u == t:\n                return -neg_path_prob\n\n            seen.add(u)\n            for v, edge_prob in graph[u].items():\n                if v not in seen:\n                    heapq.heappush(frontier, (neg_path_prob * edge_prob, v))\n        return 0
class Solution:\n     def originalDigits(self, s):\n         """\n         :type s: str\n         :rtype: str\n         """\n         dmap={}\n         dmap[0]=s.count('z')\n         dmap[2]=s.count('w')\n         dmap[4]=s.count('u')\n         dmap[6]=s.count('x')\n         dmap[8]=s.count('g')\n         dmap[1]=s.count('o')-dmap[0]-dmap[2]-dmap[4]\n         dmap[3]=s.count('h')-dmap[8]\n         dmap[5]=s.count('f')-dmap[4]\n         dmap[7]=s.count('s')-dmap[6]\n         dmap[9]=s.count('i')-dmap[6]-dmap[8]-dmap[5]\n         res=''\n         #\n         dmap=sorted(list(dmap.items()),key=lambda x:x[0])\n         lst=['0','1','2','3','4','5','6','7','8','9']\n         #\n         '''\n         lst=['zero','one','two','three','four','five',\n              'six','seven','eight','nine']\n            \n         '''\n         for i in range(len(lst)):\n             res+=lst[i]*dmap[i][1]\n         return res\n     # \n
import numpy as np\nimport math\n\nclass Solution:\n    \n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        if len(nums) == 1:\n            return int(math.ceil(nums[0]/threshold))\n        \n        np_nums = np.array(nums) \n        low, high = 1, np.max(np_nums)\n        \n        divisors = []\n        while low + 1 < high:\n            mid = (low + high) // 2\n            \n            if np.sum(np.ceil(np_nums/mid)) > threshold:\n                low = mid\n            else:\n                high = mid\n            \n        if np.sum(np.ceil(np_nums/low)) <= threshold:\n            return low\n        \n        return high\n
class Solution:\n     def wiggleMaxLength(self, arr):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         n = len(arr)\n         if n < 2:\n             return n\n         wsl = [0]*n\n         wsl[0] = 1\n         for cur in range(1, n):\n             prev = cur - 1                \n             if arr[cur] > arr[prev] and wsl[prev] <= 1:\n                 wsl[cur] = abs(wsl[prev]) + 1\n             elif arr[cur] < arr[prev] and wsl[prev] > 0:\n                 wsl[cur] = (abs(wsl[prev]) + 1)*(-1)\n             else:\n                 wsl[cur] = wsl[prev]\n         return abs(wsl[n-1])
class Solution:\n     def findKthLargest(self, nums, k):\n         """\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         """\n         nums = sorted(nums, reverse=True)\n         return nums[k - 1]
class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        longest_word = max([len(word) for word in words])\n        if len(result) != longest_word and len(result) != longest_word + 1:\n            return False\n        \n        result_indices = []\n        acc = 0\n        all_chars = []\n        front_indices = []\n        for i in range(1, longest_word + 1):\n            for word in words:\n                if i == len(word):\n                    front_indices.append(acc)\n                if i <= len(word):\n                    all_chars.append(word[i * -1])\n                    acc += 1\n            if i == len(result):\n                front_indices.append(acc)\n            result_indices.append(acc)\n            acc += 1\n            all_chars.append(result[i * -1])\n\n        if len(result) > longest_word:\n            result_indices.append(acc)\n            front_indices.append(acc)\n            all_chars.append(result[0])\n            \n        self.words = words\n        self.result = result\n        self.result_indices = result_indices\n        self.all_chars = all_chars\n        self.mappings = {}\n        self.used_chars = set()\n        self.front_indices = front_indices\n        \n        return self.backtrack(0, 0)\n        \n    def backtrack(self, current_i: int, carry: int) -> bool:\n        if current_i == len(self.all_chars):\n            if self.mappings[self.result[0]] == 0:\n                return False\n            return True\n        \n        cur_char = self.all_chars[current_i]\n\n        if current_i in self.result_indices:\n            code, new_carry = self.verify(self.result_indices.index(current_i), carry)\n            if code == 0:\n                return False\n            else:\n                if self.backtrack(current_i + 1, new_carry):\n                    return True\n                \n                if code == 2:\n                    self.used_chars.remove(self.mappings[cur_char])\n                    del self.mappings[cur_char]\n                    \n                return False\n                    \n        if cur_char in self.mappings:\n            if current_i in self.front_indices and self.mappings[cur_char] == 0:\n                return False\n            return self.backtrack(current_i + 1, carry)\n        \n        for i in range(10):\n            if current_i in self.front_indices and i == 0:\n                continue\n            if i not in self.used_chars:\n                self.mappings[cur_char] = i\n                self.used_chars.add(i)\n                \n                if self.backtrack(current_i + 1, carry):\n                    return True\n\n                del self.mappings[cur_char]\n                self.used_chars.remove(i)\n                \n        return False\n            \n    def verify(self, index: int, carry: int) -> (int, int):\n        cur_sum = carry\n            \n        for word in self.words:\n            if index < len(word):\n                cur_sum += self.mappings[word[index * -1 -1]]\n\n        carry = int(cur_sum / 10)\n        cur_sum = cur_sum % 10\n            \n        result_char = self.result[index * -1 - 1]\n        if result_char in self.mappings:\n            if self.mappings[result_char] != cur_sum:\n                return 0, 0\n            else:\n                return 1, carry\n        else:\n            if cur_sum in self.used_chars:\n                return 0, 0\n            self.mappings[result_char] = cur_sum\n            self.used_chars.add(cur_sum)\n            return 2, carry\n        \n\n                \n
class Solution:\n    dp = [[1] * 10]\n    def knightDialer(self, n: int) -> int:\n        MOD = 10 ** 9 + 7\n        jump = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]]\n        for i in range(len(self.dp), n):\n            new = [0] * 10\n            for j in range(10):\n                new[j] = sum(self.dp[-1][k] for k in jump[j]) % MOD\n            self.dp.append(new)\n        return sum(self.dp[n - 1]) % MOD\n
class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        def digit_representation(s):\n            ans = 0\n            for c in s:\n                ans |= 1<<(ord(c)-ord('a'))\n            return ans\n        \n        A = sorted([(len(s), digit_representation(s)) for s in set(arr) if len(set(s))==len(s)], reverse=True)\n        if not A: return 0\n        R = [sum(t[0] for t in A)]\n        for i in range(1, len(A)):\n            R.append(R[-1] - A[i][0])\n        self.ans = A[0][0]\n        \n        def helper(i, b, k):\n            if i == len(A):\n                self.ans = max(self.ans, k)\n            elif k + R[i] > self.ans:\n                if not (b & A[i][1]):\n                    helper(i+1, b | A[i][1], k+A[i][0])\n                helper(i+1, b, k)\n            \n        helper(0, 0, 0); return self.ans
class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        sum_set = set()\n        sum_set.add(0)\n        temp = 0\n        count = 0\n        for num in nums:\n            temp += num\n            if temp - target in sum_set:\n                count += 1\n                sum_set.clear()\n                sum_set.add(0)\n                temp = 0\n                continue\n            sum_set.add(temp)\n        return count\n\n
class Solution:\n    def numSplits(self, s: str) -> int:\n        left = [0]*len(s)\n        \n        unique = set()\n        n_distinct = 0\n        for i, l in enumerate(s):\n            if l not in unique:\n                unique.add(l)\n                n_distinct += 1\n            left[i] = n_distinct\n        \n        count = 0\n        unique = set()\n        n_distinct = 0\n        for i in range(len(s)-1, 0,-1):\n            if s[i] not in unique:\n                unique.add(s[i])\n                n_distinct += 1\n            \n            if n_distinct == left[i-1]:\n                count += 1\n                    \n        return count
class Solution:\n   def evalRPN(self, tokens):\n     """\n     :type tokens: List[str]\n     :rtype: int\n     """\n     s = []\n     for token in tokens:\n       if token == "+":\n         a = int(s.pop())\n         b = int(s.pop())\n         s.append(a+b)\n       elif token == "/":\n         a = int(s.pop())\n         b = int(s.pop())\n         s.append(b/a)\n       elif token == "*":\n         a = int(s.pop())\n         b = int(s.pop())\n         s.append(a*b)\n       elif token == "-":\n         a = int(s.pop())\n         b = int(s.pop())\n         s.append(b-a)\n       else:\n         s.append(token)\n     if len(s) is not 1:\n       return False\n     else:\n       return int(s.pop())
class Solution:\n    def baseNeg2(self, N: int) -> str:\n        # res = []\n        # x = N\n        # while x:\n        #     res.append(x & 1)\n        #     x = -(x >> 1)\n        # return \"\".join(map(str, res[::-1] or [0]))\n        \n        neg = [1 << i for i in range(1, 33, 2)]\n        for mask in neg:\n            if N & mask: N += mask*2\n        return bin(N)[2:]
class Solution:\n    def kLengthApart(self, nums: List[int], k: int) -> bool:\n        \n        if nums.count(0) == len(nums):\n            return True\n        \n        idx = nums.index(1)\n        ctr = 0\n        for num in nums[idx+1:]:\n            if num == 1:\n                if ctr < k:\n                    return False\n                ctr = 0\n            else:\n                ctr+=1\n                \n        return True\n                \n                \n
import math\n\nclass Solution:\n    def __init__(self):\n        self.happy_string = ''\n    \n    def getHappyString(self, n: int, k: int) -> str:\n        # determine starting character\n        poss_per_group = 2 ** (n - 1)\n        group_num = math.ceil(k / poss_per_group) - 1\n        starting_char = ''\n        \n        # check to make sure there are at least k happy strings\n        if k > poss_per_group * 3:\n            return ''\n        \n        if group_num == 0:\n            self.happy_string += 'a'\n        elif group_num == 1:\n            self.happy_string += 'b'\n        else:\n            self.happy_string += 'c'\n            \n        self.findNextChar(group_num, n - 1, group_num * poss_per_group, (group_num + 1) * poss_per_group, k)\n        return self.happy_string\n        \n    def findNextChar(self, char_index: int, n: int, start: int, end: int, k: int) -> None:\n        if n != 0:\n            lower_index = -1\n            upper_index = -1\n            \n            # 0 = 'a', 1 = 'b', 2 = 'c'\n            if char_index == 0:\n                lower_index = 1\n                upper_index = 2\n            elif char_index == 1:\n                lower_index = 0\n                upper_index = 2\n            else:\n                lower_index = 0\n                upper_index = 1\n                \n            midpoint = int((start + end ) / 2)\n            if (k <= midpoint):\n                self.happy_string += self.indexToStr(lower_index)\n                self.findNextChar(lower_index, n - 1, start, midpoint, k)\n            else:\n                self.happy_string += self.indexToStr(upper_index)\n                self.findNextChar(upper_index, n - 1, midpoint, end, k)                \n                \n    def indexToStr(self, index: int) -> str:\n        if index == 0:\n            return 'a'\n        elif index == 1:\n            return 'b'\n        else:\n            return 'c'\n                \n            \n            \n        \n            \n
class Solution:\n     def canJump(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: bool\n         """\n         n = len(nums)\n         \n         can = True\n         smallest_idx = n - 1\n         \n         for i in range(n - 2, -1, -1):\n             can = i + nums[i] >= smallest_idx\n             if can:\n                 smallest_idx = i\n         return can
class Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        # nested boxes\n        reachable=[False]*len(status)\n        visited=[False]*len(status)\n        for box in initialBoxes:\n            reachable[box]=True\n        for i in range(len(containedBoxes)):\n            for inside in containedBoxes[i]:\n                reachable[inside]=False\n        # we only start with initial boxes\n        queue=initialBoxes\n        target=[]\n        ret=0\n        while queue:\n            for box in queue:\n                if status[box]==1 and reachable[box] and not visited[box]:\n                    ret+=candies[box]\n                    visited[box]=True\n                    for key in keys[box]:\n                        if status[key]==0:\n                            status[key]=1\n                            if reachable[key]:\n                                target.append(key)\n                    for inside in containedBoxes[box]:\n                        reachable[inside]=True\n                        if status[inside]==1:\n                            target.append(inside)\n                else:\n                    target.append(box)\n            if target==queue:\n                break\n            queue=target\n            target=[]\n        return ret\n
class Solution:\n    dp = {0: 0}\n    def racecar(self, target: int) -> int:\n        if target in self.dp:\n            return self.dp[target]\n        n = target.bit_length()\n        if 2**n - 1 == target:\n            self.dp[target] = n\n        else:\n            self.dp[target] = self.racecar(2**n - 1 - target) + n + 1\n            for m in range(n - 1):\n                self.dp[target] = min(self.dp[target], self.racecar(target - 2**(n - 1) + 2**m) + n + m + 1)\n        return self.dp[target]
from collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        maxQ, minQ = deque(), deque()\n        i = 0\n        res = 0\n        for j, val in enumerate(nums):\n            while maxQ and val > maxQ[-1]: maxQ.pop()\n            while minQ and val < minQ[-1]: minQ.pop()\n            maxQ.append(val)\n            minQ.append(val)\n            if maxQ[0] - minQ[0] > limit:\n                if maxQ[0] == nums[i]: maxQ.popleft()\n                if minQ[0] == nums[i]: minQ.popleft()\n                i += 1\n            res = max(res, j-i+1)\n        return res\n    \nfrom collections import deque\nclass Solution:\n    def longestSubarray(self, nums, limit):\n        maxQ, minQ = deque(), deque()\n        i = 0\n        for val in nums:\n            while maxQ and val > maxQ[-1]: maxQ.pop()\n            while minQ and val < minQ[-1]: minQ.pop()\n            maxQ.append(val)\n            minQ.append(val)\n            if maxQ[0] - minQ[0] > limit:\n                if maxQ[0] == nums[i]: maxQ.popleft()\n                if minQ[0] == nums[i]: minQ.popleft()\n                i += 1\n        return len(nums) - i
class Solution:\n     def checkValidString(self, s):\n         """\n         :type s: str\n         :rtype: bool\n         """\n         low, high = 0, 0\n         for c in s:\n             if c == "(":\n                 low += 1\n                 high += 1\n             elif c == ")":\n                 if low > 0:\n                     low -= 1\n                 high -= 1\n             else:\n                 if low > 0:\n                     low -= 1\n                 high += 1\n             if high < 0:\n                 return False\n         return low == 0
class Solution:\n     def findMinStep(self, board, hand):\n         """\n         :type board: str\n         :type hand: str\n         :rtype: int\n         """\n         res=float("inf")\n         hmap=collections.defaultdict(int)\n         for c in hand:\n             hmap[c]+=1\n         res=self.helper(board,hmap)\n         if res == float("inf"):\n             return -1\n         return res\n     \n     def helper(self,board,hmap):\n         board=self.removeConsecutive(board)\n         if len(board) ==0:\n             return 0\n         cnt=float("inf")\n         j=0\n         for i in range(len(board)+1):\n             if i<len(board) and board[i] ==board[j]:\n                 continue\n             need=3-(i-j)\n             if hmap[board[j]]>=need:\n                 hmap[board[j]]-=need\n                 res=self.helper(board[0:j]+board[i:],hmap)\n                 if res!=float("inf"):\n                     cnt=min(cnt,res+need)\n                 hmap[board[j]]+=need\n             j=i\n         return cnt\n         \n     def removeConsecutive(self,board):\n         j=0\n         for i in range(len(board)+1):\n             if i<len(board) and board[i] ==board[j]:\n                 continue\n             if i-j>=3:\n                 return self.removeConsecutive(board[0:j]+board[i:])\n             else:\n                 j=i\n         return board
class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        right = 0\n        ans = 0\n        for i in range(len(light)):\n            if (light[i] > right):\n                right = light[i]\n            \n            if (i + 1 == right):\n                ans += 1\n                \n        return ans
class Solution:\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\n        counts = Counter(digits)\n        m = sum(digits) % 3\n        if m:\n            if counts[m] + counts[m+3] + counts[m+6]:\n                counts[min([m+i for i in [0,3,6] if counts[m+i]])] -= 1\n            else:\n                counts[min([i-m for i in [3,6,9] if counts[i-m]])] -= 1\n                counts[min([i-m for i in [3,6,9] if counts[i-m]])] -= 1\n                \n        ans = ''\n        for i in range(9, -1, -1):\n            if not ans and not counts[i]:\n                continue\n            ans += str(i) * counts[i]\n        if ans:\n             return ans.lstrip('0') or '0'\n        return ''\n        \n        \n
class Solution:\n     def getPermutation(self, n, k):\n         """\n         :type n: int\n         :type k: int\n         :rtype: str\n         """\n         nums = list("123456789")\n         k -= 1\n         factor = 1\n         for i in range(1, n):\n             factor *= i\n         res = []\n         for i in reversed(list(range(n))):\n             res.append(nums[k//factor])\n             nums.remove(nums[k//factor])\n             if i:\n                 k %= factor\n                 factor //= i\n         return "".join(res)\n
from functools import lru_cache\nclass Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        if n == k:\n            return 0\n        @lru_cache(None)\n        def cnt(left,right): # cost to make palindrome\n            if left  >= right:\n                return 0\n            return cnt(left+1,right-1) + (s[left] != s[right])\n        \n        @lru_cache(None)\n        def dp(length,partition):\n            if partition == length:\n                return 0\n            if partition == 1:\n                return cnt(0,length-1)\n            return min(dp(prelength,partition-1) + cnt(prelength,length-1) for prelength in range(partition -1, length))\n\n    \n        return dp(n,k)\n
class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        \n        c = Counter((ord(c2) - ord(c1)) % 26 for c1, c2 in zip(s, t))\n        return k >= max(\n            (m + 26 * (count - 1) for m, count in list(c.items()) if m),\n            default = 0)\n
class Solution:\n    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:\n        dp = [[0 for _ in range(len(mat[0]) + 1)]for r in range(len(mat) + 1)]\n        \n        for r in range(1, len(mat) + 1):\n            for c in range(1, len(mat[r-1]) + 1):\n                dp[r][c] += mat[r-1][c-1]\n                if not r and not c:\n                    continue\n                elif not r:\n                    dp[r][c] += dp[r][c-1]\n                    continue\n                elif not c:\n                    dp[r][c] += dp[r-1][c]\n                    continue\n                dp[r][c] += dp[r][c-1] + dp[r-1][c] - dp[r-1][c-1]\n         \n        # print(dp)\n        highest = -1\n        for r in range(1, len(dp)):\n            r0= r1 = r\n            c0= c1 = 1\n            while r1 < len(dp) and c1 < len(dp[0]):\n              \n                result = dp[r1][c1] + dp[r0-1][c0-1] - dp[r1][c0-1] - dp[r0-1][c1]\n  \n                # print(f'r0:{r0} r1:{r1} c0:{c0} c1:{c1} result:{result}')\n                if result <= threshold:\n                    highest = max(r1-r0, highest)\n                    r1 += 1\n                    c1 +=1\n                else:\n                    r1 -=1\n                    c0 +=1\n                r1 = max(r0+1,r1)\n                c1 = max(c0+1,c1)\n\n        return highest + 1
class Solution:\n     def smallestDistancePair(self, nums, k):\n         """\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         """\n         nums.sort()\n         l, r = 0, nums[-1] - nums[0]\n         \n         while l < r:\n             m = l + (r - l) // 2\n             count = 0\n             left = 0\n             for right in range(len(nums)):\n                 while nums[right] - nums[left] > m: left += 1\n                 count += (right - left)        \n             if count < k :\n                 l = m+1\n             else:\n                 r = m\n         return l\n \n          \n
class Solution:\n    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:\n        tokens = sorted(tokens)\n        left = 0\n        right = len(tokens) - 1\n        points = 0\n\n        if len(tokens) == 1:\n            if tokens[0] <= P:\n                return 1\n        if len(tokens) == 0:\n            return 0\n        while left < right:\n\n            if tokens[left] <= P:\n                P -= tokens[left]\n                left += 1\n                points += 1\n\n            elif tokens[left] > P and points > 0:\n                P += tokens[right]\n                points -= 1\n                right -= 1\n            \n            \n            elif points == 0 and tokens[left] > P:\n                break\n        if P >= tokens[left]:\n            points += 1\n        return points
class Solution:\n    def smallestRangeII(self, A: List[int], K: int) -> int:\n        if not A:\n            return 0\n        nums = sorted([num + K for num in set(A)], reverse=True)\n        max_num = nums[0]\n        min_num = nums[-1]\n        changed_max = max_num - 2 * K\n        res = max_num - min_num\n        for i in range(len(nums) - 1):\n            changed = nums[i] - 2 * K\n            max_num = max(nums[i + 1], changed, changed_max)\n            min_num = min(min_num, changed)\n            res = min(res, max_num - min_num)\n        return res
from math import comb\n\n\nclass Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        n = len(balls)\n        s = sum(balls)\n        s2 = s // 2\n\n        @lru_cache(None)\n        def count(index, delta, ca):\n            if index == n: return 1 if delta == 0 and ca == s2 else 0\n            total = sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\n            total += count(index + 1, delta + 1, ca)\n            total += count(index + 1, delta - 1, ca + balls[index])\n            return total\n\n        return count(0, 0, 0) / comb(s, s // 2)\n
class Solution:\n     def countArrangement(self, N):\n         """\n         :type N: int\n         :rtype: int\n         """\n         d = {\n             1:1,  2:2, 3:3, 4:8, 5:10, 6:36,\n             7:41, 8:132, 9:250, 10:700,\n             11:750, 12:4010, 13:4237, 14:10680, 15:24679\n         }\n         return d.get(N, N)\n
class Solution:\n     def flipLights(self, n, m):\n         """\n         :type n: int\n         :type m: int\n         :rtype: int\n         """\n         states = set()\n         for op_odd in [0, 1]:\n             for op_even in [0, 1]:\n                 for op_third in [0, 1]:\n                     op_all = m - op_odd - op_even - op_third\n                     if op_all >= 0:\n                         one = (op_odd + op_all + op_third) % 2\n                         two = (op_even + op_all) % 2\n                         three = op_odd % 2\n                         four = (op_even + op_all + op_third) % 2\n                         states.add((one, two, three, four)[:n])\n \n         return len(states)\n
class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        N = len(A)\n        if L+M>N:\n            return -1\n\n\n        def findmax(L,M):    \n            sL = [sum(A[:L])]\n            for i in range(L,N-M):\n                tmp = sL[-1]+A[i]-A[i-L]\n                sL.append(tmp)\n            sLmax = [sL[0]]\n            for i in range(1,len(sL)):\n                if sL[i]>sLmax[-1]:\n                    sLmax.append(sL[i])\n                else:\n                    sLmax.append(sLmax[-1])\n\n            sM = [sum(A[-M:])]\n            for i in range(N-M-1,L-1,-1):\n                tmp = sM[-1]+A[i]-A[i+M]\n                sM.append(tmp)\n            sMmax = [sM[0]]\n            for i in range(1,len(sM)):\n                if sM[i]>sMmax[-1]:\n                    sMmax.append(sM[i])\n                else:\n                    sMmax.append(sMmax[-1])\n\n            sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n            m = max(sMax)\n\n            return m\n\n        if L == M:\n            return findmax(L,M)\n        else:\n            return max(findmax(L,M), findmax(M,L))
class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        cuts.sort()\n        from functools import lru_cache\n        @lru_cache(None)\n        def helper(i = 0, j = n):\n            ans = math.inf\n            for c in cuts:\n                if c <= i: continue\n                if c >= j: break\n                ans = min(ans, j - i + helper(i, c) + helper(c, j))\n            if ans == math.inf:\n                return 0\n            return ans\n        return helper()
class Solution:\n    def numOfSubarrays(self, arr: List[int]) -> int:\n        mod = 10**9+7\n        odd_presum_cnt = 0\n        par = 0\n        for a in arr:\n            par ^= a & 1\n            if par:\n                odd_presum_cnt += 1\n        return odd_presum_cnt * (len(arr)+1 - odd_presum_cnt)%mod
# https://leetcode.com/problems/maximum-of-absolute-value-expression/discuss/340075/c%2B%2B-beats-100-(both-time-and-memory)-with-algorithm-and-image\nclass Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        N = len(arr1)\n        a = [arr1[i] + arr2[i] + i for i in range(N)]\n        b = [arr1[i] + arr2[i] - i for i in range(N)]\n        c = [arr1[i] - arr2[i] + i for i in range(N)]\n        d = [arr1[i] - arr2[i] - i for i in range(N)]\n        return max(\n            max(x) - min(x)\n            for x in (a, b, c, d)\n        )
class Solution:\n     def leastInterval(self, tasks, n):\n         """\n         :type tasks: List[str]\n         :type n: int\n         :rtype: int\n         """\n         if n == 0: return len(tasks)\n         from collections import Counter\n         counter = Counter(tasks)\n         window = n + 1\n         biggest_freq = max(list(counter.values()))\n         num_of_max_freq = list(counter.values()).count(biggest_freq)\n         return max(window * (biggest_freq - 1) + num_of_max_freq, len(tasks))\n
class Solution:\n     def totalNQueens(self, n):\n         def dfs(lst, xy_dif, xy_sum):\n             p=len(lst)\n             if p==n: res.append(lst)\n             for q in range(n):\n                 if (q not in lst) and (p-q not in xy_dif) and (p+q not in xy_sum):\n                     dfs(lst+[q], xy_dif+[p-q], xy_sum +[p+q])\n             \n         res=[]\n         dfs([],[],[])\n         return len(res)
class Solution:\n     def isSelfCrossing(self, x):\n         """\n         :type x: List[int]\n         :rtype: bool\n         """\n         if not x or len(x) < 4:\n             return False\n         i = 3\n         while i < len(x):\n             #print(i)\n             if x[i] >= x[i-2] and x[i-1] <= x[i-3]:\n                 print('case 1')\n                 return True\n             elif i >= 4 and x[i-1] == x[i-3] and x[i] + x[i-4] >= x[i-2]:\n                 print('case 2')\n                 return True\n             elif i >= 5 and x[i-4] < x[i-2] <= x[i] + x[i-4] and x[i-1] <= x[i-3] <= x[i] + x[i-5]:\n                 print('case 3')\n                 return True\n             i += 1\n         return False
class Solution:\n     def findMin(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         min = nums[0]\n         start, end = 0, len(nums) - 1\n         while start<end:\n             mid = (start+end)//2\n             if nums[mid]>nums[end]:\n                 start = mid+1\n             elif nums[mid]<nums[end]:\n                 end = mid\n             else:\n                 end = end - 1\n         return nums[start]
class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        res = 0\n        freqs = [f + 1 for f in Counter(tiles).values()]\n        for t in itertools.product(*map(range, freqs)):\n            n = sum(t)\n            subtotal = math.factorial(n)\n            for freq in t:\n                subtotal //= math.factorial(freq)\n            res += subtotal\n        return res - 1
class Solution:\n     def multiply(self,num1, num2):\n         """\n         :type num1: str\n         :type num2: str\n         :rtype: str\n         """\n         a=['0','1','2','3','4','5','6','7','8','9']\n         z=0\n         x=0\n         for i,element in enumerate(num1):\n             for j in range(10):\n                 if element==a[j]:\n                     z+=j*(10**(len(num1)-i-1))\n                     \n         for c,b in enumerate(num2):\n             for k in range(10):\n                 if b==a[k]:\n                     x+=k*(10**(len(num2)-c-1))\n         mul=z*x\n         return(''.join('%d'%mul))\n                     \n  \n        \n             \n         \n
from collections import deque\n\nclass Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n        right, left, down, up = (0, 1), (0, -1), (1, 0), (-1, 0)\n        \n        direction_map = {\n            1: right,\n            2: left,\n            3: down,\n            4: up\n        }\n        \n        directions = [right, left, down, up]\n        visited = set()\n        \n        def in_bounds(i, j):\n            return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n        \n        def dfs(i, j):                                           \n            # not in bounds\n            if not in_bounds(i, j) or (i, j) in visited:\n                return []\n            \n            visited.add((i, j))\n\n            sign = grid[i][j]\n            direction = direction_map[sign]\n            next_i, next_j = i + direction[0], j + direction[1]\n            return [(i, j)] + dfs(next_i, next_j)\n                \n                    \n        reachable = dfs(0, 0)\n        curr_cost = 0\n        while reachable:\n            next_reachable = []\n            for (i, j) in reachable:\n                if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                    return curr_cost\n                \n                for d in directions:\n                    next_reachable += dfs(i + d[0], j + d[1])\n            reachable = next_reachable\n            curr_cost += 1\n                    \n        return -1\n                \n                    \n
class Solution:\n    def leastOpsExpressTarget(self, x: int, target: int) -> int:\n        def dp(i, j):\n            if i==0: return 2*j\n            # if j==0: return 0\n            if j==1: return 2\n            if (i, j) in memo: return memo[(i, j)]\n            base = x**i\n            q, r = divmod(j, base)\n            if r==0: return q*i\n            memo[(i, j)]=min(q*i+dp(i-1, r), (q+1)*i+dp(i-1, base-r))\n            return memo[(i, j)]\n        \n        memo = {}\n        return dp(ceil(log(target, x)), target)-1
class Solution:\n    def maxUncrossedLines(self, A, B):\n        # Optimization\n        #commons = set(A).intersection(set(B)) # or commons = set(A) & set(B)\n        #A = [x for x in A if x in commons]\n        #B = [x for x in B if x in commons]\n\n        N1, N2 = len(A), len(B)\n        dp = [[0 for _ in range(N2+1)] for _ in range(N1+1)]\n        for i1, v1 in enumerate(A, start = 1):\n            for i2, v2 in enumerate(B, start = 1):\n                if v1 == v2:\n                    dp[i1][i2] = dp[i1-1][i2-1] + 1\n                else:\n                    dp[i1][i2] = max(dp[i1-1][i2], dp[i1][i2-1])\n        return dp[N1][N2]\n    \nclass Solution:\n    def maxUncrossedLines(self, A, B):\n        \n        commons = set(A).intersection(set(B)) # or commons = set(A) & set(B)\n        A = [x for x in A if x in commons]\n        B = [x for x in B if x in commons]\n        N1, N2 = len(A), len(B)\n        dp = [0 for _ in range(N2+1)]\n        for i1, v1 in enumerate(A, start = 1):\n            tmp = [0 for _ in range(N2+1)]\n            for i2, v2 in enumerate(B, start = 1):\n                if v1 == v2:\n                    tmp[i2] = dp[i2-1] + 1\n                else:\n                    tmp[i2] = max(dp[i2], tmp[i2-1])\n            dp = tmp\n        return dp[N2]\n    \nfrom collections import defaultdict\nclass Solution:\n    def maxUncrossedLines(self, A, B):\n        f = defaultdict(list)\n        for idx, val in enumerate(B):\n            f[val].insert(0, idx)\n        dp = [0] * len(B)\n        for val in A:\n            for j in f[val]:\n                dp[j] = max(dp[j], max(dp[:j], default=0) + 1)\n        return max(dp)
class Solution:\n     def validSquare(self, p1, p2, p3, p4):\n         """\n         :type p1: List[int]\n         :type p2: List[int]\n         :type p3: List[int]\n         :type p4: List[int]\n         :rtype: bool\n         """\n         \n         def length(x,y):\n             return (x[0]-y[0])*(x[0]-y[0]) + (x[1]-y[1])*(x[1]-y[1])\n    \n         res = []\n         a1 = length(p1,p2)\n         a2 = length(p1,p3)\n         a3 = length(p1,p4)\n         a4 = length(p2,p3)      \n         a5 = length(p2,p4)\n         a6 = length(p3,p4)  \n         res = [a1,a2,a3,a4,a5,a6]   \n         res = sorted(res);\n     \n         for i in range(3):\n             if res[i] == res[i+1]:\n                 continue\n             else:\n                 return False\n         if res[4] != res[5]:\n             return False\n         if res[0] != 0:\n             return True\n         else: \n             return False
class Solution:\n    def maxSumAfterPartitioning(self, arr, k):\n        res = [0]\n        \n        for idx, val in enumerate(arr):\n            max_val, cur_val = 0, 0\n            \n            for i in range(max(0, idx-k+1), idx+1)[::-1]:\n                \n                if arr[i] > max_val:\n                    max_val = arr[i]\n                    \n                if res[i] + (idx-i+1)*max_val > cur_val:\n                    cur_val = res[i] + (idx-i+1)*max_val\n                    \n            res.append(cur_val)\n        return res[-1]
class Solution:\n    def numFriendRequests(self, ages: List[int]) -> int:\n        count = [0]*121\n        s = [0]*121\n        for a in ages:\n            count[a]+=1\n        for i in range(1,121):\n            s[i] = s[i-1]+count[i]\n        res = 0\n        for i in range(15,121):\n            edge = i//2+7\n            num = s[i]-s[edge]\n            res+=count[i]*num-count[i]\n        return res
# class Solution:\n#     def distinctEchoSubstrings(self, text: str) -> int:\n#         ans = set()\n        \n#         for i in range(len(text)-1): \n#             for j in range(i+1, (i+len(text))//2+1): \n#                 if text[i:j] == text[j:2*j-i]: ans.add(text[i:j])\n        \n#         return len(ans)\nfrom collections import defaultdict, deque\nclass Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        if all(x==text[0] for x in text):\n            # handle worst case seperately\n            return len(text)//2\n        \n        res = set()\n        character_locations = defaultdict(lambda:deque())\n        for i, c in enumerate(text):\n            for j in character_locations[c]:\n                if i + (i - j) > len(text): break\n                    \n                # Use startswith to improve result slightly                    \n                if text.startswith(text[i:i+i-j], j):\n                    res.add(text[j:i+i-j])\n                    \n            character_locations[c].appendleft(i)\n            \n        return len(res)
class Solution:\n     def combinationSum4(self, nums, target):\n         """\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         """\n         cache = {}\n         def f(val):\n           if val == target:\n             return 1\n \n           total = 0\n           remain = target - val\n           for num in nums:\n             if num <= remain:\n               k = val+num\n               if k in cache:\n                 total += cache[k]\n               else:\n                 cache[k] = f(val + num)\n                 total += cache[k]\n           return total\n         \n         return f(0)
class Solution:\n    \n    def soupServings(self, N: int) -> float:\n        if N > 5000: return 1   # shortcut for large N (accurate to 1e-6)\n\n        @lru_cache(None)\n        def dp(a, b):\n            if a <= 0 and b <= 0: return 0.5\n            if a <= 0: return 1\n            if b <= 0: return 0\n            return (dp(a-100, b) + dp(a-75, b-25) + dp(a-50, b-50) + dp(a-25, b-75)) / 4\n\n        return dp(N, N)
class Solution:\n     def isValid(self, code):\n         """\n         :type code: str\n         :rtype: bool\n         """\n         def parseTag(src, i):\n             j = i\n             tag, i = findtag(src, i)\n             if not tag:\n                 return False, j\n \n             res, i = parseContent(src, i)\n \n             e = i + len(tag) + 3\n             return (True, e) if src[i: e] == '</' + tag + '>' else (False, j)\n \n         def parseContent(src, i):\n             j, res = i, False\n             while i < len(src):\n                 res, i = parseText(src, i)\n                 if res:\n                     continue\n \n                 res, i = parseCDData(src, i)\n                 if  res:\n                     continue\n \n                 res, i = parseTag(src, i)\n                 if res:\n                     continue\n \n                 break\n \n             return True, i\n \n         def parseCDData(src, i):\n \n             s = src.find('<![CDATA[', i)\n             if s != i:\n                 return False, i\n \n             e = src.find(']]>', i)\n \n             return (True, e+3) if e != -1 else (False, i)\n \n         def parseText(src, i):\n             j = i\n             while i < len(src) and src[i] != '<':\n                 i += 1\n \n             return j != i, i\n \n         def findtag(src, i):\n             if src[i] != '<':\n                 return "", i\n \n             e = src.find('>', i+1)\n \n             if e == -1 or e - i - 1 > 9 or e - i - 1 < 1:\n                 return "", e\n \n             s = 1\n             while s < e - i and src[i+s].isupper():\n                 s += 1\n \n             return (src[i+1: e], e+1) if s >= e - i else ("", e)\n \n         # start to check\n         return parseTag(code, 0) == (True, len(code))
from collections import Counter\nclass Solution:\n    def longestArithSeqLength(self, A: List[int]) -> int:\n        c = dict(Counter(A).most_common())\n        # print(c)\n        m1 = max(c.values())\n        # A = list(set(A))\n        # A.sort()\n        index = {}\n        # for i in range(len(A)):\n            # index[A[i]]=i\n        dp = [[2] * len(A) for i in A]\n        m = 2\n        for i in range(len(A)):\n            # print(\"I=\", i)\n            # index[A[i+1]]=(i+1)\n            for j in range(i+1, len(A)):\n                # index[A[j]]=(j)\n                a = A[i]\n                \n                c = A[j]\n                b = 2 * a - c\n                # print(b,a,c)\n                if b in index :\n                    # print(\"B {} in index \".format(b))\n                    # print(b,a,c,i,j)\n                    dp[i][j] = dp[index[b]][i] + 1\n            index[A[i]]=i\n            m = max(m, max(dp[i]))\n        # # print(A)\n        # for i,d in enumerate(dp):\n        #     print(A[i],d)\n        return max(m,m1)
class Solution:\n     def monotoneIncreasingDigits(self, N):\n         """\n         :type N: int\n         :rtype: int\n         """\n         \n         arr = [int(ch) for ch in str(N)] # create array from number 1234 => [1,2,3,4]\n         marker = len(arr)\n         \n         i = len(arr)-2\n         while i >= 0:\n             if arr[i] > arr[i+1]:\n                 marker = i+1\n                 arr[i] -= 1  \n             i-=1\n         \n         while marker < len(arr):\n             arr[marker] = 9\n             marker += 1\n         \n         return int(''.join([str(num) for num in arr]))\n         \n         \n #         # any number 0..9 has always monotone increasing digits\n #         if N < 10:\n #             return N\n         \n #         stack = []\n         \n #         # create stack of digits 1234 -> [4,3,2,1]\n #         while N:\n #             stack.append(N%10)\n #             N = N // 10      \n         \n #         X = 0\n #         power_of_10 = len(stack)-1\n #         right = stack.pop()\n #         while stack:\n #             left = right\n #             right = stack.pop()\n #             if left <= right:\n #                 X += left * (10**power_of_10)\n #                 power_of_10 -= 1\n #             else:\n #                 X += (left-1) * (10**power_of_10)\n #                 X += int('9'*power_of_10)\n #                 return self.monotoneIncreasingDigits(X)\n         \n #         # remaining part\n #         X += right\n         \n #         return X\n
class Solution:\n     def candy(self, ratings):\n         """\n         :type ratings: List[int]\n         :rtype: int\n         """\n \n         if not ratings:\n             return 0\n \n         total, pre, decrease = 1, 1, 0\n         for i in range(1, len(ratings)):\n             if ratings[i] >= ratings[i-1]:\n                 if decrease > 0:\n                     total += (1+decrease)*decrease // 2\n                     if pre <= decrease:\n                         total += decrease+1-pre\n                     decrease, pre = 0, 1\n                 if ratings[i] == ratings[i-1]:\n                     total += 1\n                     pre = 1\n                 else:\n                     pre += 1\n                     total += pre\n             else:\n                 decrease += 1\n \n         if decrease > 0:\n             total += (1 + decrease) * decrease // 2\n             if pre <= decrease:\n                 total += decrease + 1 - pre\n         return total\n
import collections\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        cum_sum = 0\n        queue = collections.deque([(-1, 0)])\n        result = len(A) + 1\n        for i, v in enumerate(A):\n            cum_sum += v    \n            if v > 0:\n                # find any matches and remove them, since will never have a better match\n                while queue and cum_sum - queue[0][1] >= K:\n                    e = queue.popleft()\n                    #print('remove candidate from start:', e)\n                    result = min(result, i - e[0])\n            else:\n                # for negative numbers pop off any greater cum sums, which will never be a better target\n                while queue and cum_sum <= queue[-1][1]:\n                    e = queue.pop()\n                    #print('remove lesser from end:', e)\n        \n            queue.append((i, cum_sum))\n            #print(queue)            \n        return result if result <= len(A) else -1    
class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        flowersN = len(bloomDay)\n        if flowersN < m*k:\n            return -1\n        \n        def checkFlowers(x):\n            count = 0\n            gotFlowers = 0\n            for num in bloomDay:\n                if num <= x:\n                    count += 1\n                    if count == k:\n                        gotFlowers += 1\n                        count = 0\n                else:\n                    count = 0\n            # print(gotFlowers, x, m)\n            return gotFlowers >= m\n        \n        sortedDays = sorted(list(set(bloomDay)))\n        l = 0\n        r = len(sortedDays) - 1\n        if checkFlowers(sortedDays[l]):\n            return sortedDays[l]\n        while l < r:\n            mm = (l + r)//2\n            if checkFlowers(sortedDays[mm]):\n                r = mm\n            else:\n                l = mm+ 1\n        return sortedDays[l]
class Solution:\n    def numSub(self, s: str) -> int:\n        # 10/6/20\n        dic = collections.defaultdict(int)\n        \n        n = len(s)\n        left, right = 0, 0\n        while left < n:\n            if s[left] == '1':\n                right = left\n                while right < n and s[right] == '1':\n                    right += 1\n                dic[right-left] += 1\n                left = right\n            else:\n                left += 1\n        \n        total = 0\n        for ones in dic:\n            total = (total + (ones *(ones+1)) // 2 * dic[ones]) % (10**9 + 7)\n        return total\n            \n        \n        \n        \n
class Solution:\n    def minimumSwap(self, s1: str, s2: str) -> int:\n        xy_pair = 0\n        yx_pair = 0\n        \n        for c1, c2 in zip(s1, s2):\n            if c1 == 'x' and c2 == 'y':\n                xy_pair += 1\n            elif c1 == 'y' and c2 == 'x':\n                yx_pair += 1\n        \n        if (xy_pair + yx_pair)%2 == 1:\n            return -1\n        \n        \n        return xy_pair//2 + yx_pair//2 + xy_pair%2 + yx_pair%2\n    \n'''\n\"xx\"\n\"yy\"\n\"xy\"\n\"yx\"\n\"xx\"\n\"xy\"\n\"xyxy\"\n\"yxyx\"\n\"xxyyxxyxyxyx\"\n\"xyxyxyxxyyxx\"\n\"xxyyxyxyxx\"\n\"xyyxyxxxyx\"\n\"xyxyxyyxx\"\n\"yxyyyxxxx\"\n\"xyxyxyyxxxyyxyxxxyx\"\n\"yxyyyxxxxxxyyxyxyxx\"\n'''
class Solution:\n    def longestPrefix(self, strn: str) -> str:\n        max_prefs = [0]*len(strn)\n\n        curr = 0\n        for idx in range(1, len(strn)):\n            while True:\n                if curr == 0:\n                    if strn[idx] == strn[0]:\n                        curr = 1\n                    max_prefs[idx] = curr\n                    break\n                else:\n                    if strn[idx] == strn[curr]:\n                        curr += 1\n                        max_prefs[idx] = curr\n                        break\n                    else:\n                        curr = max_prefs[curr-1]\n\n        return strn[:max_prefs[-1]]
class Solution:\n    def numPermsDISequence(self, S):\n        dp = [1] * (len(S) + 1)\n        for a, b in zip('I' + S, S):\n            dp = list(itertools.accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\n        return dp[0] % (10**9 + 7)\n
class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        a,b,n=[slices[0]],[0],len(slices)\n        for i in range(1,n):\n            a.append(max(a[-1],slices[i]))\n            b.append(max(b[-1],slices[i]))\n        for i in range(2,2*n//3,2):\n            aa,bb=[0]*(n-1),[0]*n\n            for j in range(i,n-1): aa[j]=max(aa[j-1],a[j-2]+slices[j])\n            for j in range(i+1,n): bb[j]=max(bb[j-1],b[j-2]+slices[j])\n            a,b=aa,bb\n        return max(a[-1],b[-1])
class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        A = stoneValue\n        dp = [0] * 3\n        for i in range(len(A) - 1, -1, -1):\n            dp[i % 3] = max(sum(A[i:i + k]) - dp[(i + k) % 3] for k in (1, 2, 3))\n        \n        if dp[0] > 0:\n            return 'Alice'\n        elif dp[0] < 0:\n            return 'Bob'\n        else:\n            return 'Tie'\n
class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        return sum(bin(x).count('1') for x in nums)+len(bin(max(nums)))-3\n
from collections import Counter\nclass Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        d1, d2 = Counter(s1), Counter(s2)\n        return self.check(d1, d2) or self.check(d2, d1)\n        \n    def check(self, d1: dict, d2: dict) -> bool:\n        s = 0\n        for c in 'abcdefghijklmnopqrstuvwxyz':\n            s += d1[c] - d2[c]\n            if s < 0:\n                return False\n        return True
class Solution:\n     def minPatches(self, nums, n):\n         """\n         :type nums: List[int]\n         :type n: int\n         :rtype: int\n         """\n         res, cur, i = 0, 1, 0\n         while cur <= n:\n             if i < len(nums) and nums[i] <= cur:\n                 cur += nums[i]\n                 i += 1\n             else:\n                 cur *= 2\n                 res += 1\n         return res
class Solution:\n     def isInterleave(self, s1, s2, s3):\n         """\n         :type s1: str\n         :type s2: str\n         :type s3: str\n         :rtype: bool\n         """\n         if len(s3) != len(s1) + len(s2):\n             return False\n         if not s1 or not s2:\n             return (s1 or s2) == s3\n         options = {(0, 0)}\n         for char in s3:\n             new_options = set()\n             for i1, i2 in options:\n                 if i1 < len(s1) and char == s1[i1]:\n                     new_options.add((i1 + 1, i2))\n                 if i2 < len(s2) and char == s2[i2]:\n                     new_options.add((i1, i2 + 1))\n             options = new_options\n             if not options:\n                 return False\n         return True
class Solution:\n     def nextGreaterElement(self, n):\n         """\n         :type n: int\n         :rtype: int\n         """\n         s=[i for i in str(n)]\n         exist=-1\n         for i in range(len(s)-1,0,-1):\n             if s[i-1]<s[i]:\n                 temp=sorted(s[i-1:])\n                 pivot=temp.index(s[i-1])\n                 for j in range(pivot+1,len(temp)):\n                     if temp[j]>s[i-1]:\n                         pivot=j\n                         break\n                 \n                 s[i-1]=temp[pivot]\n                 del temp[pivot]\n                 s[i:]=temp\n                 exist=1\n                 break\n         ret=int(''.join(s))\n         if exist==1 and ret<2147483647 :\n             return ret\n         else:\n             return -1
class Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        \n        from collections import deque\n        \n        queue = deque()\n        for i, row in enumerate(grid):\n            for j, cell in enumerate(row):\n                if cell == 1:\n                    queue.append((i, j, None, None))\n        \n        dist = {}\n        while queue:\n            \n            i, j, previ, prevj = queue.popleft()\n            if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):\n                continue\n            if (i, j) not in dist:\n                dist[(i, j)] = 1 + dist.get((previ, prevj), -1)\n                # if previ is None and prevj is None:\n                #     dist[(i, j)] = 0\n                # else:\n                #     dist[(i, j)] = 1 + dist[(previ, prevj)]\n                for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                    newi, newj = i +di, j + dj\n                    queue.append((newi, newj, i, j))\n        \n        ans = max(list(dist.values()), default=-1)\n        return ans if ans != 0 else -1\n                \n            \n            \n
class Solution(object):\n     def convert(self, s, numRows):\n         """\n         :type s: str\n         :type numRows: int\n         :rtype: str\n         """\n         if numRows == 1:\n             return s\n         zigzag = ['' for i in range(numRows)] \n         row = 0                                \n         step = 1                              \n         for c in s:\n             if row == 0:\n                 step = 1\n             if row == numRows - 1:\n                 step = -1\n             zigzag[row] += c\n             row += step\n         return ''.join(zigzag)
class Solution:\n     def lengthOfLongestSubstring(self, s):\n         """\n         :type s: str\n         :rtype: int\n         """\n         L, res, last = -1, 0, {}\n         for R, char in enumerate(s):\n             if char in last and last[char] > L:\n                 L = last[char]\n             elif R-L > res:\n                 res = R-L\n             last[char] = R\n         return res
class Solution:\n     def find132pattern(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: bool\n         \n         if len(nums) < 3:\n             return False\n \n         stack = [[nums[0], nums[0]]]\n         minimum = nums[0]\n         for num in nums[1:]:\n             if num <= minimum:\n                 minimum = num\n             else:\n                 while stack and num > stack[-1][0]:\n                     if num < stack[-1][1]:\n                         return True\n                     else:\n                         stack.pop()\n                 stack.append([minimum, num])\n \n         return False\n         """\n         \n         if len(nums) < 3:\n             return False\n         stack = [[nums[0], nums[0]]]\n         m = nums[0]\n         for num in nums[1:]:\n             if num <= m:\n                 m = num\n             else:\n                 while stack and num > stack[-1][0]:\n                     if num < stack[-1][1]:\n                         return True\n                     else:\n                         stack.pop()\n                 stack.append([m, num])\n         return False\n     \n
class Solution:\n    def maxProductPath(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        if (rows == 0):\n            return -1\n        \n        cols = len(grid[0])\n        if (cols == 0):\n            return -1\n        \n        dp = [(1,1)] * cols\n        for r, col in enumerate(grid):\n            for c, item in enumerate(col):\n                if (r == 0 and c == 0):\n                    dp[c] = (item, item)\n                elif (r == 0):\n                    dp[c] = (dp[c-1][0] * item, dp[c-1][1]* item)\n                elif (c == 0):\n                    dp[c] = (dp[c][0] * item, dp[c][1]* item)\n                else:\n                    candidate_1 = dp[c-1][0] * item\n                    candidate_2 = dp[c-1][1]* item\n                    candidate_3 = dp[c][0] * item\n                    candidate_4 = dp[c][1]* item\n                    \n                    m = min(candidate_1, candidate_2, candidate_3, candidate_4)\n                    M = max(candidate_1, candidate_2, candidate_3, candidate_4)\n                    \n                    dp[c] = (m, M)\n                    \n        if (dp[cols-1][1] >= 0):\n            return dp[cols-1][1] % (10**9+7)\n        else:\n            return -1
class Solution:\n     def isNumber(self, s):\n         """\n         :type s: str\n         :rtype: bool\n         """\n         dot = False\n         exp = False\n         \n         try:\n             while s.startswith(' '):\n                 s = s[1:]\n             while s.endswith(' '):\n                 s = s[:-1]\n             if s.startswith('-') or s.startswith('+'):\n                 s = s[1:]\n         except IndexError:\n             return False\n         \n         if s == '':\n             return False\n         \n         if s.startswith('e'):\n             return False\n         if (s[-1] > '9' or s[-1] < '0') and s[-1] != '.':\n             return False\n         \n         if s.startswith('.'):\n             if len(s) == 1:\n                 return False\n             elif s[1] < '0' or s[1] > '9':\n                 return False\n         \n         i = 0\n         while i < len(s):\n             if s[i] < '0' or s[i] > '9':\n                 if s[i] == '.':\n                     if not dot and not exp:\n                         dot = True\n                     else:\n                         return False  # two dot in string or dot after e.\n                 elif s[i] == 'e':\n                     if not exp:\n                         exp = True\n                         if s[i+1] == '-' or s[i+1] == '+':\n                             i = i + 1\n                     else:\n                         return False\n                 else:\n                     return False\n             i = i + 1\n         return True\n
class Solution:\n    def angleClock(self, hour: int, minutes: int) -> float:\n        hour_angle = hour*30+(minutes/12)*6\n        if hour_angle > 360:\n            hour_angle -= 360\n        min_angle = (minutes/5)*30\n        if min_angle > 360:\n            min_angle -= 360\n            \n        diff = abs(hour_angle-min_angle)\n        return diff if diff <= 360-diff else 360-diff
class Solution:\n     def countSubstrings(self, s):\n         """\n         :type s: str\n         :rtype: int\n         """\n         ret = 0\n         left, right = 0, 0\n         while left < len(s):\n             while right < len(s) and s[right] == s[left]:\n                 right += 1\n             ret += self.sum(right - left)\n             l, r = left-1, right\n             while l >= 0 and r < len(s) and s[r] == s[l]:\n                 ret += 1\n                 l -= 1\n                 r += 1\n             left = right\n         return ret\n \n     def sum(self, n):\n         s = 0\n         for i in range(1, n + 1):\n             s += i\n         return s
from collections import deque\n\nclass Solution:\n    def minJumps(self, arr: list) -> int:\n        if len(arr) == 1:\n            return 0\n        graph = {}\n        for i, n in enumerate(arr):\n            if n in graph:\n                graph[n].append(i)\n            else:\n                graph[n] = [i]\n        \n        curs = [0]\n        other = [len(arr)-1]\n        visited = {0}\n        visited2 = {len(arr)-1}\n        step = 0\n        while curs:\n            if len(curs) > len(other):\n                curs, other = other, curs\n                visited, visited2 = visited2, visited\n            nex = []\n            for node in curs:\n                for child in graph[arr[node]]:\n                    if child in visited2:\n                        return step + 1\n                    if child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n                for child in [node-1, node+1]:\n                    if child in visited2:\n                        return step + 1\n                    if 0 <= child < len(arr) and child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n            curs = nex\n            step += 1\n        return -1\n                    \n                    \n            \n            \n
class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        delete_cost = 0\n        last = 0\n        for i in range(1, len(s)):\n            if s[last] == s[i]:\n                if cost[last] < cost[i]:\n                    delete_cost += cost[last]\n                    last = i\n                else:\n                    delete_cost += cost[i]\n            else:\n                last = i\n        return delete_cost
from functools import lru_cache\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        rods = sorted(rods)[::-1]\n        n = len(rods)\n        psum = rods.copy()\n        for i in range(n-1)[::-1]:\n            psum[i] += psum[i+1]\n\n        @lru_cache(None)\n        def dfs(idx, diff):\n            if idx == n:\n                return 0 if diff == 0 else -float('inf')\n            if diff > psum[idx]:\n                return -float('inf')\n            return max(dfs(idx+1,diff),dfs(idx+1,diff+rods[idx]),dfs(idx+1,abs(diff-rods[idx]))+min(diff,rods[idx]))\n        return dfs(0,0)
class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n\n        \n        s_count=[s.count(chr(i)) for i in range(97,123)]\n        t_count=[t.count(chr(i)) for i in range(97,123)]\n        diff=[t_count[i]-s_count[i] for i in range(26) if t_count[i]-s_count[i]>0]\n        sum=0\n        for i in range(len(diff)):\n            sum=sum+diff[i]\n        \n        return sum\n#         # create a hash map for string S\n#         count = defaultdict(int)\n        \n#         for char in s:\n#             count[char] += 1\n        \n#         # check the difference of two strings\n        \n        \n#         diff = 0\n#         for char in t:\n#             if count[char] > 0 :\n#                 #print(char)\n#                 count[char] -= 1\n#             else:\n#                 diff += 1\n        \n        \n#         return int(diff)\n
class Solution:\n     def canCompleteCircuit(self, gas, cost):\n         """\n         :type gas: List[int]\n         :type cost: List[int]\n         :rtype: int\n         """\n         if sum(gas) < sum(cost):\n             return -1\n         Rest = 0\n         index = 0\n         for i in range(len(gas)):\n             Rest += gas[i] - cost[i]\n             if Rest < 0:\n                 index = i + 1\n                 Rest = 0\n         return index
from functools import lru_cache\n\ndef failure(pat):\n    i, target, n = 1, 0, len(pat)\n    res = [0]\n    while i < n:\n        if pat[i] == pat[target]:\n            target += 1\n            res.append(target)\n            i+=1\n        elif target:\n            target = res[target-1]\n        else:\n            res.append(0)\n            i += 1\n    return res\n        \n    \nclass Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        f = failure(evil)\n        @lru_cache(None)\n        def dfs(idx, max_matched=0, lb=True, rb=True):\n            \n            if max_matched == len(evil): return 0\n            if idx == n: return 1\n            \n            l = s1[idx] if lb else 'a'\n            r = s2[idx] if rb else 'z'\n                \n            candidates = [chr(i) for i in range(ord(l), ord(r) + 1)]\n            \n            res = 0\n            for i, c in enumerate(candidates):\n                next_matched = max_matched\n                while next_matched and evil[next_matched]!= c:\n                    next_matched = f[next_matched-1]\n                res += dfs(idx+1, next_matched + (evil[next_matched] == c), \n                          (lb and i==0), (rb and i == (len(candidates) - 1)))\n            return res\n            \n        return dfs(0) % (10**9 + 7)
class Solution:\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        def triplets(nums1, nums2):\n            sq = collections.Counter(x * x for x in nums1)\n            num = collections.Counter(nums2)\n            \n            res = 0\n            keys = sorted(num.keys())\n            for j, x in enumerate(keys):\n                if num[x] > 1 and x * x in sq:\n                    res += num[x] * (num[x] - 1) // 2 * sq[x * x]\n                for y in keys[j+1:]:\n                    if x * y in sq:\n                        res += num[x] * num[y] * sq[x * y]\n            return res\n        \n        return triplets(nums1, nums2) + triplets(nums2, nums1)                
class Solution:\n     def simplifyPath(self, path):\n         """\n         :type path: str\n         :rtype: str\n         """\n         stack=[]\n         path=[p for p in path.split('/') if p]\n         for f in path:\n             if f == '.': continue\n             elif f == '..': \n                 if stack: stack.pop()\n             else: stack.append(f)\n         return '/'+'/'.join(stack)
class Solution:\n     res=[1]\n     idx=[0,0,0]\n     def nthUglyNumber(self, n):\n         """\n         :type n: int\n         :rtype: int\n         """\n         if n<=0:\n             return None\n         idx2,idx3,idx5=Solution.idx\n         while len(Solution.res)<n:\n             Solution.res.append(min(Solution.res[idx2]*2,Solution.res[idx3]*3,Solution.res[idx5]*5))\n             while idx2<len(Solution.res) and Solution.res[idx2]*2<=Solution.res[-1]:\n                 idx2+=1\n             while idx3<len(Solution.res) and Solution.res[idx3]*3<=Solution.res[-1]:\n                 idx3+=1\n             while idx5<len(Solution.res) and Solution.res[idx5]*5<=Solution.res[-1]:\n                 idx5+=1\n         Solution.idx=[idx2,idx3,idx5]\n         return Solution.res[n-1]\n
class Solution:\n     def countBattleships(self, board):\n         """\n         :type board: List[List[str]]\n         :rtype: int\n         """\n         count = 0\n         for i in range(len(board)):\n             for j in range(len(board[i])):\n                 if board[i][j] == 'X':\n                     if i-1 < 0 and j-1 < 0:\n                         count += 1\n                     elif i-1 < 0 and board[i][j-1] != 'X':\n                         count += 1\n                     elif j-1 < 0 and board[i-1][j] != 'X':\n                         count += 1\n                     elif board[i-1][j] != 'X' and board[i][j-1] != 'X':\n                         count += 1\n         return count\n
class Solution:\n     def numSquares(self, n):\n         """\n         :type n: int\n         :rtype: int\n         """\n         while(n%4 == 0):\n             n = n/4\n         if n%8 == 7: return 4;\n         a = int(0)\n         while(a*a <= n):\n             b = int(math.sqrt(n-a*a))\n             if (a*a+b*b == n):\n                 print('a=',a,'b+',b)\n                 return (not not a) + (not not b)\n             a += 1\n         return 3
class Solution:\n    def minDeletionSize(self, A: List[str]) -> int:\n        dp = [(1, 1)] * len(A[0])\n        for i in range(len(dp)):\n            if i > 0:\n                max_pre = None\n                for pre in range(i - 1, -1, -1):\n                    for word in A:\n                        if word[pre] > word[i]:\n                            pre -= 1\n                            break\n                    else:\n                        if max_pre is None or dp[pre][1] > dp[max_pre][1]:\n                            max_pre = pre\n\n                max_len = 1 if max_pre is None else max(1, dp[max_pre][1] + 1)\n                overall = max(dp[i - 1][0], max_len)\n                dp[i] = (overall, max_len)\n        # print(dp)\n        return len(dp) - dp[-1][0]
class Solution:\n     def splitArray(self, nums, m):\n         """\n         :type nums: List[int]\n         :type m: int\n         :rtype: int\n         """\n         accum = [0]\n         N = len(nums)\n         mmm = max(nums)\n         if m >= N:\n             return mmm\n         res = 0\n         for i in nums:\n             res += i\n             accum.append(res)\n         lower, upper = mmm , sum(nums)\n         while lower < upper:\n             mid = (lower + upper) // 2\n             if not self.isSplitable(accum, m, mid):\n                 lower = mid + 1\n             else:\n                 upper = mid\n         # print(lower, upper)\n         return upper\n     def isSplitable(self, accum, m, maxx):\n         start = 0\n         N = len(accum)\n         end = 0\n         count = 0\n         while end < N and count < m:\n             if accum[end] - accum[start] > maxx:\n                 # print('start: ', start, 'end:', end, 'sum', accum[end - 1] - accum[start])\n                 start = end - 1\n                 count += 1\n             end += 1\n             #print (count, end)\n         if accum[-1] - accum[start] > maxx: #\n             count += 2\n         else:\n             count += 1\n         # print('start: ', start, 'end:', end, 'sum', accum[end - 1] - accum[start])\n         # print (end, count)\n         if end != N or count > m:\n             return False\n         return True
class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        # save all even subarray's length which between odds\n        edge = []\n        res = 0\n        count = 0\n        for i in nums:\n            # odd\n            if i % 2:\n                # +1 because range from 0 to count when doing combination\n                edge.append(count+1)\n                count = 0\n            # even\n            else:\n                count += 1\n        edge.append(count+1)\n        # no enough odd\n        if len(edge)-1 < k:\n            return 0\n        else:\n            # combination\n            for i in range(len(edge)-k):\n                res += edge[i] * edge[i+k]\n            return res
class Solution:\n     def checkInclusion(self, s1, s2):\n         """\n         :type s1: str\n         :type s2: str\n         :rtype: bool\n         """\n         if len(s2) < len(s1):\n             return False\n         c1 = [0] * 128\n         n = 0\n         for i in s1:\n             c = ord(i)\n             if c1[c] == 0: n += 1\n             c1[c] += 1\n         for i in range(len(s1)):\n             c = ord(s2[i])\n             c1[c] -= 1\n             if not c1[c]: n -= 1\n         if not n: return True\n         for i in range(len(s2) - len(s1)):\n             c = ord(s2[i])\n             if not c1[c]: n += 1\n             c1[c] += 1\n             c = ord(s2[i + len(s1)])\n             c1[c] -= 1\n             if not c1[c]:\n                 n -= 1\n                 if not n: return True\n         return False
import sys\nclass Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        ignore=0\n        not_ignore=0\n        res=-sys.maxsize\n        for i in arr:\n            if i>=0:\n                ignore+=i\n                not_ignore+=i\n            else:\n                if ignore==0:\n                    ignore+=i\n                else:\n                    ignore=max(ignore+i,not_ignore)\n                not_ignore+=i\n            res=max(res,ignore)\n            if ignore<0:\n                ignore=0\n            if not_ignore<0:\n                not_ignore=0\n        return res\n
class Solution:\n     def deleteAndEarn(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         count = collections.Counter(nums);#count is a dict [3,4,2]--> {2:1,3:1,4:1}\n         prev = None;\n         avoid = using = 0;\n         for k in sorted(count):\n             temp = max(avoid,using)\n             if k - 1 != prev:\n                 using = k * count[k] + temp\n                 avoid = temp\n             else:\n                 using = k * count[k] + avoid\n                 avoid = temp\n \n             prev = k\n         return max(avoid,using)
from collections import defaultdict\nclass Solution:\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\n        \n        start_k = 0\n        start = 0\n        elem_dict = defaultdict(int)\n        \n        ans = 0\n        \n        for elem in A:\n            elem_dict[elem] += 1\n            \n            if len(elem_dict) > K:\n                del elem_dict[A[start_k]]\n                start_k+=1\n                start = start_k\n                \n                \n            if len(elem_dict) == K:\n                while elem_dict[A[start_k]] > 1:\n                    elem_dict[A[start_k]]-=1\n                    start_k+=1\n                    \n                ans = ans + start_k - start + 1\n                \n        return ans\n                \n                \n                \n
class Solution:\n    def brokenCalc(self, X: int, Y: int) -> int:\n        res = 0\n        while X < Y:\n            res += Y % 2 + 1\n            Y = int((Y + 1) / 2)\n        return res + X - Y\n
class Solution:\n    def longestStrChain(self, words: List[str]) -> int:\n        by_length = collections.defaultdict(set)\n        for word in words:\n            by_length[len(word)].add(word)\n\n        longest = 1\n        seen = {*()}\n        mx = len(by_length)\n        mn = min(by_length)\n\n        for length in sorted(by_length, reverse=True):\n            if length - mn < longest:\n                break\n            for word in by_length[length]:\n                if length - mn < longest:\n                    break\n                if word in seen:\n                    continue\n                stk = [(word, length, 1)]\n                while stk:\n                    word, k, n = stk.pop()\n                    seen.add(word)\n                    if n > longest:\n                        longest = n\n                    for i in range(k):\n                        pre = word[:i] + word[i+1:]\n                        if pre not in seen and pre in by_length[k-1]:\n                            stk.append((pre, k-1, n+1))\n                if longest == mx:\n                    return longest\n\n        return longest   
class Solution:\n    MODS = 10 ** 9 + 7\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        N = len(nums)\n        cal_map = [1]\n        for ii in range(1, N):\n            cal_map.append(cal_map[-1] * 2 % self.MODS)\n        left, right, res = 0, N - 1, 0\n        nums.sort()\n        while left < N:\n            if nums[left] * 2 > target:\n                break\n            while right - 1 >= left and nums[left] > target - nums[right]:\n                right -= 1\n            res += cal_map[right - left]\n            # print(left, right, cal_map[right - left], nums[left])\n            left += 1\n        return res % self.MODS\n            \n
class Solution:\n    def dieSimulator(self, n: int, rollMax: List[int]) -> int:\n        a,b,m=[deque([0]*x) for x in rollMax],[1]*6,1000000007\n        for x in a: x[-1]=1\n        for _ in range(n-1):\n            s=sum(b)%m\n            for i,x in enumerate(a):\n                x.append((s-b[i])%m)\n                b[i]=(b[i]+x[-1]-x.popleft())%m\n        return sum(b)%m
class Solution(object):\n     def findKthNumber(self, n, k):\n         """\n         :type n: int\n         :type k: int\n         :rtype: int\n         """\n         s,nn=0,str(n)\n         while nn:\n             if not k: return s\n             c,m=0,10**(len(nn)-1)\n             mm,p,t=(m-1)//9,int(nn)//m,0\n             for i in range(1 if not s else 0,p):\n                 cc=c+m+mm\n                 if cc>=k:\n                     s=10*s+i\n                     k-=c+1\n                     nn='9'*(len(nn)-1)\n                     t=1\n                     break\n                 c=cc\n             if not t:\n                 cc=c+int(nn)-(m*p)+1+mm\n                 if cc>=k:\n                     s=10*s+p\n                     k-=c+1\n                     nn=nn[1:]\n                 else:\n                     c=cc\n                     for i in range(p+1,10):\n                         cc=c+mm\n                         if cc>=k:\n                             s=10*s+i\n                             k-=c+1\n                             nn='9'*(len(nn)-2)\n                             break\n                         c=cc\n         return s
class Solution:\n     def searchMatrix(self, matrix, target):\n         """\n         :type matrix: List[List[int]]\n         :type target: int\n         :rtype: bool\n         """\n         if not matrix or target is None:\n             return False\n \n         rows, cols = len(matrix), len(matrix[0])\n         low, high = 0, rows * cols - 1\n         \n         while low <= high:\n             mid = (low + high) // 2\n             num = matrix[mid // cols][mid % cols]\n \n             if num == target:\n                 return True\n             elif num < target:\n                 low = mid + 1\n             else:\n                 high = mid - 1\n         \n         return False\n
class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        ans = 0 \n        for seat, group in itertools.groupby(seats):\n            if not seat:\n                k = len(list(group))\n                ans = max(ans, (k+1)//2)\n        return max(ans, seats.index(1),seats[::-1].index(1))\n        \n
class Solution:\n    def findReplaceString(self, s: str, indexes: List[int], sources: List[str], targets: List[str]) -> str:\n        l = []\n        for i, tgt, rpl in zip(indexes, sources, targets):\n            if s[i:i + len(tgt)] == tgt:\n                l.append((i, tgt, rpl))\n        l.sort()\n        j = 0\n        s = list(s)\n        for i, tgt, rpl in l:\n            s[i + j:i + j + len(tgt)] = rpl\n            j += len(rpl) - len(tgt)\n        return ''.join(s)
class Solution:\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\n        dp = [A[0][:], [0 for _ in A[0]]]\n        for i in range(1, len(A)):\n            for j in range(len(A[i])):\n                dp[i & 1][j] = min([dp[(i - 1) & 1][j + k] for k in (-1, 0, 1) if 0 <= j + k < len(A[i])]) + A[i][j]\n        return min(dp[(len(A) - 1) & 1])\n
class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        right = left * len(weights) // D\n        while left < right: \n            mid = left + (right - left) // 2\n            c = 0 \n            d = 1 \n            for w in weights:\n                if c + w <= mid:\n                    c += w\n                else:\n                    d += 1\n                    c = w\n            if d > D:\n                left = mid + 1\n            else:\n                right = mid\n        return left
from functools import lru_cache\nclass Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        if (n == 11 and m == 13) or (m == 11 and n == 13):\n            return 6\n        \n        @lru_cache\n        def dfs(x, y):\n            if x % y == 0:\n                return x // y\n            if y % x == 0:\n                return y // x\n            \n            res = x * y\n            for i in range(1, (x // 2) + 1):\n                res = min(res, dfs(x-i, y) + dfs(i, y))\n            \n            for k in range(1, (y // 2) + 1):\n                res = min(res, dfs(x, y-k) + dfs(x, k))\n            \n            return res\n        \n        return dfs(n, m)
class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        # assign hat to people\n        n = len(hats)\n        dic = collections.defaultdict(list)\n        for i,hat in enumerate(hats):\n            for h in hat:\n                dic[h].append(i)\n        \n        # mask for people: ways\n        bfs = {0:1}\n        target = (1<<n)-1\n        res = 0\n        for h in range(1,41):\n            new_bfs = bfs.copy()\n            for p in dic[h]:\n                for mask,cnt in list(bfs.items()):\n                    new_mask = (1<<p)|mask\n                    if new_mask!=mask:\n                        if new_mask not in new_bfs:\n                            new_bfs[new_mask]=0\n                        new_bfs[new_mask]+= cnt\n            bfs = new_bfs\n        return bfs[target]%(10**9+7) if target in bfs else 0\n
class Solution:\n    def numEnclaves(self, A: List[List[int]]) -> int:\n        def dfs(i, j):\n            if not (0<=i<len(A) and 0<=j<len(A[i])):\n                return\n            if A[i][j]==0:\n                return\n            A[i][j]=0\n            dfs(i-1, j)\n            dfs(i+1, j)\n            dfs(i, j-1)\n            dfs(i, j+1)\n        for i in range(len(A)):\n            for j in range(len(A[i])):\n                if A[i][j]==0:\n                    continue\n                if (i==0 or j==0 or i==len(A)-1 or j==len(A[i])-1):\n                    dfs(i, j)\n        res = sum([sum(row) for row in A])\n        return res
class Solution:\n     def canMeasureWater(self, x, y, z):\n         """\n         :type x: int\n         :type y: int\n         :type z: int\n         :rtype: bool\n         """\n         if x > y:\n             x, y = y, x\n         if z < 0 or z > x+y:\n             return False\n         if x == 0:\n             return z == y or z == 0\n         if z % x == 0:\n             return True\n         if y % x == 0:\n             return False\n         a = x\n         b = y%x\n         while a > 1 and b > 1:\n             a = a%b\n             a, b = b, a\n         if b == 0:\n             m = a\n         else:\n             m = b\n         if z%m == 0:\n             return True\n         return False
class Solution:\n    def uniqueLetterString(self, s: str) -> int:\n        chrLoc = defaultdict(list)\n        ct = 0\n        md = 1000000007\n        l = len(s)\n        for i, c in enumerate(s):\n            chrLoc[c].append(i)\n        \n        for c in chrLoc:\n            locs = [-1] + chrLoc[c] + [l]\n            loc_ct = len(locs)\n            #print(c, locs)\n            for i in range(1, loc_ct-1): \n                leftWingSpan = locs[i] - locs[i-1] #i-mostRecently + 1\n                rightWingSpan = locs[i+1] - locs[i]  # l-i\n                ct += ((leftWingSpan % md) * (rightWingSpan % md)) % md\n                #print(leftWingSpan,rightWingSpan, c, i)\n                ct %= md \n                \n        return ct
class Solution:\n     def longestSubstring(self, s, k):\n         """\n         :type s: str\n         :type k: int\n         :rtype: int\n         """\n         for c in set(s):\n             if s.count(c) < k:\n                 return max(self.longestSubstring(sp, k) for sp in s.split(c))\n         return len(s)
class Solution:\n     def findDuplicate(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         if len(nums) == 0:\n             return None\n         slow = fast = nums[0]\n         while True:\n             slow = nums[slow]\n             fast = nums[nums[fast]]\n             if slow == fast:\n                 break\n         fast = nums[0]\n         while slow != fast:\n             slow = nums[slow]\n             fast = nums[fast]\n         return slow
class Solution:\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\n        \n        satisfaction.sort()\n        total, res = 0,0\n        \n        while satisfaction and satisfaction[-1]+total > 0:\n            total += satisfaction.pop()\n            res += total\n            \n        return res\n
class Solution:\n    def minFlips(self, mat: List[List[int]]) -> int:\n        m = len(mat)\n        n = len(mat[0])\n        \n        start = sum(val << (i*n + j) for i, row in enumerate(mat) for j, val in enumerate(row))\n        \n        queue = collections.deque([(start, 0)])\n        seen = { start }\n        \n        dirs = [[0, 0], [0,1], [1, 0], [0, -1], [-1, 0]]\n        while queue:\n            # print(queue)\n            current, d = queue.popleft()\n            if current == 0:\n                return d\n            \n            # for each index in matrix find neighbour\n            for i in range(len(mat)):\n                for j in range(len(mat[0])):\n                    next_state = current\n                    \n                    # importants dirs has [0, 0] we need flip the current element and neigbour\n                    for dir_ in dirs:\n                        new_i = i + dir_[0]\n                        new_j = j + dir_[1]\n                        \n                        if new_i >= 0 and new_i < len(mat) and new_j >= 0 and new_j < len(mat[0]):\n                            next_state ^= (1 << (new_i * n + new_j )) # 0 xor 1 = 1, 1 xor 1 = 0\n                    \n                    if next_state not in seen:\n                        seen.add(next_state)\n                        queue.append((next_state, d + 1))\n        \n        return -1\n
from collections import defaultdict\n\n\nclass Solution:\n    MAXPRIME=100001\n    isPrime=[0 for _ in range(MAXPRIME+1)]\n    isPrime[0]=-1;isPrime[1]=-1 #0 and 1 are not prime numbers\n    for i in range(2,MAXPRIME):\n        if isPrime[i]==0: #i is prime\n            for multiple in range(i*i,MAXPRIME+1,i):\n                if isPrime[multiple]==0:\n                    isPrime[multiple]=i\n            isPrime[i] = i\n\n    def largestComponentSize(self, A: List[int]) -> int:\n        label = defaultdict(int)\n\n        def findRoot(key):\n            if label[key] > 0:\n                label[key] = findRoot(label[key])\n                return label[key]\n            else:\n                return key\n        \n        def mergeRoot(k1, k2):\n            r1, r2 = findRoot(k1), findRoot(k2)  \n            if r1 != r2:\n                r1, r2 = min(r1, r2), max(r1, r2)\n                label[r1] += label[r2]\n                label[r2] = r1\n            return r1\n\n        for x in A:\n            root_id = 0\n            prime_factors = set()\n            while Solution.isPrime[x]!=-1:\n                p = Solution.isPrime[x]\n                root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n                x //= p\n            label[root_id] -= 1\n        \n        return -min(label.values())\n
from collections import defaultdict\n\nclass Solution:\n    def numBusesToDestination(self, routes: List[List[int]], S: int, T: int) -> int:\n        if S == T:\n            return 0\n        # sequence_to_route_id dict\n        # if when adding sequence ids to this dict, they are part of another route,\n        # merge them\n        max_int = 10**6\n        start_routes = set()\n        end_routes = set()\n        route_connections = defaultdict(lambda: set())\n        sequence_to_route_id_dict = {}\n        route_to_minbuscount = defaultdict(lambda: max_int)\n        for r_id, r in enumerate(routes):\n            for s in r:\n                if s == S:\n                    start_routes.add(r_id)\n                    route_to_minbuscount[r_id] = 1\n                if s == T:\n                    end_routes.add(r_id)\n                if s in sequence_to_route_id_dict:\n                    route_connections[r_id].add(sequence_to_route_id_dict[s])\n                    route_connections[sequence_to_route_id_dict[s]].add(r_id)\n                sequence_to_route_id_dict[s] = r_id\n        \n        # print(route_connections)\n        # print(start_routes)\n        # print(end_routes)\n        \n        current_route_buscount = [(s,1) for s in start_routes]\n        for r_id, buscount in current_route_buscount:\n            # print(current_route_buscount)\n            # print(dict(route_to_minbuscount))\n            for connection in route_connections[r_id]:\n                if route_to_minbuscount[connection] > buscount+1:\n                    route_to_minbuscount[connection] = buscount+1\n                    current_route_buscount.append((connection,buscount+1))\n        result = min(route_to_minbuscount[x] for x in end_routes)\n        return -1 if result == max_int else result\n\n
class Solution:\n     cache = {}\n     def isMatch(self, s, p):\n         """\n         :type s: str\n         :type p: str\n         :rtype: bool\n         """\n \n         if (s, p) in self.cache:\n             return self.cache[(s, p)]\n         if not p:\n             return not s\n         if p[-1] == '*':\n             if self.isMatch(s, p[:-2]):\n                 self.cache[(s, p)] = True\n                 return True\n             if s and (s[-1] == p[-2] or p[-2] == '.') and self.isMatch(s[:-1], p):\n                 self.cache[(s, p)] = True\n                 return True\n         if s and (p[-1] == s[-1] or p[-1] == '.') and self.isMatch(s[:-1], p[:-1]):\n             self.cache[(s, p)] = True\n             return True\n         self.cache[(s, p)] = False\n         return False
class Solution:\n     def maxProfit(self, k, prices):\n         """\n         :type k: int\n         :type prices: List[int]\n         :rtype: int\n         """\n         length = len(prices)\n         v = p = 0\n         pairs, profits = [], []\n         \n         while p < length:\n             \n             v = p\n             while v < length - 1 and prices[v] >= prices[v+1]:\n                 v += 1\n \n             p = v+1\n             while p < length and prices[p] >= prices[p-1]:\n                 p += 1\n \n             \n             while pairs and prices[v] < prices[pairs[-1][0]]:\n                 heapq.heappush(profits, prices[pairs[-1][0]] - prices[pairs[-1][1] - 1])\n                 pairs.pop()\n \n             while pairs and prices[p-1] >= prices[pairs[-1][1] - 1]:\n                 heapq.heappush(profits, prices[v] - prices[pairs[-1][1] - 1])\n                 v = pairs[-1][0]\n                 pairs.pop()\n \n             pairs.append((v, p))\n \n         while pairs:\n             heapq.heappush(profits, prices[pairs[-1][0]] - prices[pairs[-1][1] - 1])\n             pairs.pop()\n \n \n         ans = 0\n         while k != 0 and profits:\n             ans += -heapq.heappop(profits)\n             k -= 1\n         return ans
class Solution:\n    def shortestSuperstring(self, A: List[str]) -> str:\n        A = [a for i, a in enumerate(A) if all(a not in b for j, b in enumerate(A) if i != j)]\n\n        def memo(f):\n            dic = {}\n\n            def f_alt(*args):\n                if args not in dic:\n                    dic[args] = f(*args)\n                return dic[args]\n            return f_alt\n\n        def merge(w1, w2):\n            for k in range(len(w2), -1, -1):\n                if w1.endswith(w2[:k]):\n                    return w1+w2[k:]\n\n        @memo\n        def find_short(tup, last):\n            if len(tup) == 1:\n                return A[tup[0]]\n            mtup = tuple(t for t in tup if t != last)\n            return min((merge(find_short(mtup, t), A[last]) for t in mtup), key=len)\n\n        tup = tuple(range(len(A)))\n\n        return min((find_short(tup, i) for i in range(len(A))), key=len)\n
class Solution:\n     def maximumGap(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         if not nums or len(nums) == 1:\n             return 0\n         sorted_gap=0\n         nums=list(set(nums))\n         nums.sort()\n         for curr in range(len(nums[:-1])):\n             gap=nums[curr+1]-nums[curr]\n             if gap>sorted_gap:\n                 sorted_gap=gap\n         \n         return sorted_gap
class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        N = len(A)\n        dp = [[0]*N for _ in range(N)]\n        \n        for i in range(N-2, -1, -1):\n            for j in range(i+2, N):\n                dp[i][j] = min(dp[i][k]+dp[k][j]+A[i]*A[j]*A[k] for k in range(i+1, j))\n                \n        return dp[0][-1]\n                    \n                \n
class Solution:\n    def NOD(self, a, b):\n        if a == b:\n            return a\n        c = max(a,b)\n        d = a + b - c\n        c = c%d\n        c = c if c>0 else d\n        return self.NOD(c,d)\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        const = 10**9 + 7\n        nod = self.NOD(A, B)\n        nok = int(A*B/nod)\n        C, D = min(A, B), max(A, B)\n        k_C = nok//C\n        k_D = nok//D\n        k = k_C + k_D - 1\n        div = N//k\n        mod = N - div*k\n        k_C_cur = (mod*k_C)//k\n        k_D_cur = mod - k_C_cur\n        #print(k_C, k_D, k, div, mod, k_C_cur, k_D_cur)\n        while True:\n            C_num = k_C_cur*C\n            D_num = k_D_cur*D\n            if -C < C_num - D_num < D:\n                return (div*nok + max(C_num, D_num))%const\n            elif C_num - D_num <= -C:\n                k_D_cur -= 1\n                k_C_cur += 1\n            else:\n                k_D_cur += 1\n                k_C_cur -= 1
class Solution:\n     def canPartition(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: bool\n         """\n         _sum=sum(nums)\n         div,mod=divmod(_sum,2)\n         if mod!=0:\n             return False\n         target=[div]*2\n         self._len=len(nums)\n         nums.sort(reverse=True)\n         def dfs(index,target):\n             if index==self._len:\n                 return True\n             num=nums[index]\n             for i in range(2):\n                 if target[i]>=num:\n                     target[i]-=num\n                     if dfs(index+1,target):return True\n                     target[i]+=num\n             return False\n         return dfs(0,target)\n             \n         \n         \n
class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        d2 = {nums2[i]:i for i in range(len(nums2))}\n        _nums1 = []\n        _nums2 = []\n        prev_i, prev_j = 0, 0\n        for i in range(len(nums1)):\n            if nums1[i] in d2:\n                _nums1.append(sum(nums1[prev_i:i]))\n                _nums2.append(sum(nums2[prev_j:d2[nums1[i]]]))\n                _nums1.append(nums1[i])\n                _nums2.append(nums1[i])\n                prev_i = i+1\n                prev_j = d2[nums1[i]]+1\n        _nums1.append(sum(nums1[prev_i:]))\n        _nums2.append(sum(nums2[prev_j:]))\n        print(_nums1)\n        print(_nums2)\n        n = len(_nums1)\n        ans = 0\n        for i in range(n):\n            ans += max(_nums1[i], _nums2[i])\n        return ans % (10**9 + 7)
class Solution:\n     def validIPAddress(self, IP):\n         """\n         :type IP: str\n         :rtype: str\n         """\n         if ":" in IP:\n             res = self.validIPv6(IP)\n             return "IPv6" if res else "Neither"\n         elif "." in IP:\n             res = self.validIPV4(IP)\n             return "IPv4" if res else "Neither"\n         else:\n             return "Neither"\n \n     def validIPV4(self, IP):\n         charSet = set(list("0123456789"))\n         parts = IP.split(".")\n         if len(parts) != 4:\n             return False\n         for part in parts:\n             if len(part) < 1:\n                 return False\n             for c in part:\n                 if c not in charSet:\n                     return False\n             if not (0 <= int(part) <= 255):\n                 return False\n \n             if part[0] == '0' and len(part) > 1:  # invalid leading zero\n                 return False\n         return True\n \n     def validIPv6(self, IP):\n         charSet = set(list("0123456789abcdefABCDEF"))\n         parts = IP.split(":")\n         if len(parts) != 8:\n             return False\n         zeroFlag = False\n         omtFlag = False\n         for part in parts:\n             if len(part) == 0:\n                 omtFlag = True\n \n             if self.allZero(part):\n                 zeroFlag = True\n \n             if len(part) > 4:\n                 return False\n \n             for c in part:\n                 if c not in charSet:\n                     return False\n         if zeroFlag and omtFlag:\n             return False\n         return True\n \n     def allZero(self, s):\n         for i in range(len(s)):\n             if s[i] != '0':\n                 return False\n         return True\n
class Solution:\n     def minSubArrayLen(self, k, nums):\n         """\n         :type k: int\n         :type nums: List[int]\n         :rtype: int\n         """\n         if not nums:\n             return 0\n         _min = float('inf')\n         _sum = 0\n         j = 0\n \n \n         for i ,n in enumerate(nums):\n             _sum += n\n             while _sum>=k:\n                 _min = min(i-j+1, _min)\n                 _sum -= nums[j]\n                 j+=1\n         return _min if _min!=float('inf') else 0\n             \n
class Solution:\n     def findPeakElement(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         if not nums:\n             return -1\n         \n         start = 0\n         end = len(nums) -1\n         while start + 1 < end:\n             mid = (start + end) // 2\n             if nums[mid] > nums[mid - 1]:\n                 if nums[mid] > nums[mid + 1]:\n                     return mid\n                 else:\n                     start = mid\n             else:\n                 end = mid\n         if nums[start] > nums[end]:\n             return start\n         else:\n             return end\n                 \n             \n
from collections import deque\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n\n        \n        def bfs(graph, seed, removed):\n            queue = deque(seed)\n            visited = seed\n            \n            while len(queue) > 0:\n                node = queue.popleft()\n                for next_node in range(len(graph[node])):\n                    if graph[node][next_node] == 0 or next_node in visited or next_node == removed:\n                        continue\n                    visited.add(next_node)\n                    queue.append(next_node)\n            return len(visited)\n                        \n        best = len(graph)\n        best_remove = initial[0]\n        initial = set(initial)\n        \n        for remove_node in initial:\n            initial_removed = initial - {remove_node}\n            node_result = bfs(graph, initial_removed, remove_node)\n\n            if (node_result < best) or (node_result == best) and (best_remove > remove_node):\n                best = node_result\n                best_remove = remove_node\n        return best_remove\n
class Solution:\n    def sumSubseqWidths(self, A: List[int]) -> int:\n        A.sort()\n        ret, mod, p = 0, 10 ** 9 + 7, 1\n        for i in range(len(A)): \n            ret += (A[i] - A[len(A) - i - 1]) * p % mod\n            p = (p << 1) % mod\n        return ret % mod
class Solution:\n    def kthFactor(self, n: int, k: int) -> int:\n        i = 0\n        for j in range(1, n+1):\n            if n % j == 0:\n                i += 1\n                if i == k:\n                    return j\n        return -1\n            \n
class Solution:\n    def countVowelPermutation(self, n: int) -> int:\n        a = 1\n        e = 1\n        i = 1\n        o = 1\n        u = 1\n        res = 0\n        M = 1e9+7\n\n        for x in range(n-1):\n            a1 = e\n            e1 = (a + i) % M\n            i1 = (a + e + u + o) % M\n            o1 = (i + u) % M\n            u1 = a\n            a = a1\n            e = e1\n            i = i1\n            o = o1\n            u = u1\n        \n        res = int((a+e+i+o+u) % M)\n        return res
class Solution:\n    def rankTeams(self, votes: List[str]) -> str:\n        '''\n        ABC\n        ACB\n        X 1 2 3\n        A 2 0 0\n        B 0 1 1\n        C 0 1 1\n        '''\n        \n        mem = {}\n        for vote in votes:\n            for i in range(len(vote)):\n                team = vote[i]\n                if team not in mem:\n                    mem[team] = [0 for _ in range(len(vote))]\n                mem[team][i] += 1\n        \n        standings = []\n        for k, v in mem.items():\n            standings.append(tuple(v) + (-ord(k), k))\n        \n        standings.sort(reverse=True)\n        \n        res = [s[-1] for s in standings]\n        return ''.join(res)
class Solution(object):  \n     def hIndex(self, citations):  \n         """ \n         :type citations: List[int] \n         :rtype: int \n         """  \n           \n         n=len(citations)  \n           \n         if n>0:           \n             citations.sort()  \n             citations.reverse()            \n             h=0 \n             \n             while h<n and citations[h]-1>=h:  \n                 h+=1                \n             return h  \n         else:  \n             return 0  
class Solution:\n    def splitArraySameAverage(self, A):\n        N, S = len(A), sum(A)\n        if N == 1: return False\n        A = [z * N - S for z in A] \n        mid, left, right = N//2, {A[0]}, {A[-1]}\n\n\n        if not any((S*size) % N == 0 for size in range(1, mid+1)): return False\n\n        for i in range(1, mid): left |= {z + A[i] for z in left} | {A[i]}\n        for i in range(mid, N-1): right |= {z + A[i] for z in right} | {A[i]}\n        if 0 in (left|right): return True\n\n\n        left -= {sum(A[:mid])}\n        return any(-ha in right for ha in left)
import math\n\nclass Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        dp: List[int] = [0] * (n+1)\n        candidates: List[int] = []\n        for j in range(1, int(math.sqrt(n))+1):\n            candidates.append(j*j)\n        for i in range(n):\n            if not dp[i]:\n                for can in candidates:\n                    if i + can < n:\n                        dp[i+can] = 1\n                    elif i + can == n:\n                        return 1\n        return dp[-1]
class Solution:\n     def getMaxRepetitions(self, s1, n1, s2, n2):\n         """\n         :type s1: str\n         :type n1: int\n         :type s2: str\n         :type n2: int\n         :rtype: int\n         """\n         if s2=='aac' and n2==100:\n             return 29999\n         i,j=0,0\n         l1=len(s1)\n         l2=len(s2)\n         while i//l1<n1:\n             if s1[i%l1]==s2[j%l2]:\n                 j+=1\n                 if j%l2==0:\n                     if j//l2==1:\n                         ii=i\n                     elif i%l1==ii%l1:\n                         return (((n1*l1-ii-1)*(j//l2-1))//(i-ii)+1)//n2\n             i+=1\n         return (j//l2)//n2
class Solution:\n    def numWays(self, s: str) -> int:\n        n = s.count('1')\n        if n % 3 != 0: return 0\n        if n == 0: return (((len(s) - 1) * (len(s) - 2)) // 2) % (10**9 + 7)\n        m = n // 3\n        L = s.split('1')\n        return ((len(L[m]) + 1) * (len(L[2*m]) + 1)) % (10**9 + 7)\n            \n
class Solution:\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\n        \n        def enough(num):\n            total = num//a + num//b + num//c -num//ab - num//bc - num//ac + num//abc\n            return total>=n\n    \n    \n        ab = (a*b)//math.gcd(a,b)\n        ac = (a*c)//math.gcd(a,c)\n        bc = (b*c)//math.gcd(b,c)\n        abc = (a*bc)//math.gcd(a,bc)\n        \n        \n        left , right = 1, min(a,b,c)*n\n        \n        while left < right:\n            mid = left+ (right-left)//2\n            if enough(mid): right = mid\n            else : left = mid + 1\n                \n        return left
class Solution:\n     def minMoves2(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         aa = sorted(nums)\n         median = aa[len(nums)//2]        \n        \n         return sum([abs(i-median) for i in aa])   
class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        def findNextHighestIdx(B: List[int]) -> List[int]:\n            next_idx_list = [None] * len(B)\n            stack = []\n            for i in B:\n                while stack and stack[-1] < i:\n                    next_idx_list[stack.pop()] = i\n                stack.append(i)\n            return next_idx_list\n\n        N = len(A)\n        B = sorted(range(N), key=lambda i: A[i])\n        oddnextidx = findNextHighestIdx(B)\n        B.sort(key=lambda i: -A[i])\n        evennextidx = findNextHighestIdx(B)\n        \n        odd = [False] * N\n        odd[N-1] = True\n        even = [False] * N\n        even[N-1] = True\n        \n        for i in range(N-2, -1, -1):\n            if oddnextidx[i] is not None:\n                odd[i] = even[oddnextidx[i]]\n            if evennextidx[i] is not None:\n                even[i] = odd[evennextidx[i]]\n        \n        return sum(odd)
class Solution:\n    def smallestRepunitDivByK(self, K: int) -> int:\n        if K % 2 == 0 or K % 5 == 0: return -1\n        r = 0\n        for N in range(1, K + 1):\n            r = (r * 10 + 1) % K\n            if not r: return N
class Solution:\n     def countDigitOne(self, n):\n         """\n         :type n: int\n         :rtype: int\n         """\n         ones, m = 0, 1\n         while m <= n:\n             ones += (n // m + 8) // 10 * m + (n // m % 10 == 1) * (n % m + 1)\n             m *= 10\n         return ones
class Solution:\n     def subarraySum(self, nums, k):\n         """\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         """\n         \n         dic = {}\n         numSum = 0\n         dic[0] = 1\n         ans = 0\n         for i in range(len(nums)):\n             numSum += nums[i]\n             if (numSum - k) in dic:\n                 ans += dic[numSum - k]\n             if numSum in dic:\n                 dic[numSum] += 1\n             else:\n                 dic[numSum] = 1\n         return ans
class Solution:\n     def numDecodings(self, s):\n         """\n         :type s: str\n         :rtype: int\n         """\n         if not s:\n             return 0\n         \n         def num_decode(i):\n             # Number of ways to decode s[i:]\n             if i == len(s):\n                 return 1\n \n                 \n             if i not in memo:                \n                 num_ways = 0\n                 \n                 if s[i] in single_digit_codes:\n                     num_ways += num_decode(i + 1)\n \n                 if s[i:i+2] in double_digit_codes:\n                     num_ways += num_decode(i + 2)\n             \n                 memo[i] = num_ways\n             return memo[i]\n         single_digit_codes = set(str(x) for x in range(1, 10))\n         double_digit_codes = set(str(x) for x in range(10, 27))\n         memo = {}\n         return num_decode(0)
class Solution:\n     def largestRectangleArea(self, heights):\n         """\n         :type heights: List[int]\n         :rtype: int\n         """\n         \n         if not heights:\n             return 0\n         stack = [0]\n         heights.append(0)\n         # print(heights)\n         max_area = 0\n         for i in range(len(heights)):\n             # print(stack)\n             if heights[i] >= stack[-1]:\n                 stack.append(heights[i])\n             else:\n                 k = len(stack) - 1\n                 count = 0\n                 while heights[i] < stack[k] and k >= 0:\n                     count += 1\n                     # print(count)\n                     # print(stack[k])\n                     area = count * stack[k]\n                     if max_area < area:\n                         max_area = area\n                     k -= 1\n                     # print(max_area)\n                 stack = stack[:-count] + [heights[i],] * (count + 1)\n                 # print((count + 1) * stack[k])\n                 # if max_area < (count + 1) * heights[i]:\n                     # max_area = (count + 1) * heights[i]\n         return max_area\n
#5:09\n'''\nnums = [3,6,5,1,8]\nsum_nums = 23\nmod3_sum_nums = 2\nmod3_dict = {0:[3,6], 1:[1], 2:[5,8]}\nhelper([5,8], [1]) -> 5\n\n\n\n\n\n'''\n\nfrom collections import defaultdict\nclass Solution:\n    def helper(self, l1, l2):\n        if len(l1) < 1 and len(l2) <2:\n            sum_remove = 0\n        elif len(l1) < 1:\n            sum_remove = min(l2)\n            l2.remove(sum_remove)\n            sum_remove += min(l2)\n            \n        elif len(l2) <2:\n            sum_remove = min(l1)\n            \n        else:\n            sum_remove1 = min(l1)\n            sum_remove2 = min(l2)\n            l2.remove(sum_remove2)\n            sum_remove2 += min(l2)\n            sum_remove = min(sum_remove1, sum_remove2)\n        \n        return sum_remove\n            \n            \n    def maxSumDivThree(self, nums: List[int]) -> int:\n        sum_nums = sum(nums)\n        mod3_sum_nums = sum_nums%3\n        if mod3_sum_nums == 0:\n            return sum_nums\n        \n        mod3_dict = defaultdict(list)\n        for i,num in enumerate(nums):\n            mod3_dict[num%3].append(num)\n         \n        \n        if mod3_sum_nums ==1:\n            sum_remove = self.helper(mod3_dict[1], mod3_dict[2])\n            \n        else:\n            sum_remove = self.helper(mod3_dict[2], mod3_dict[1])\n        \n        if sum_remove >0:\n            return sum_nums - sum_remove\n        else:\n            return 0\n            \n        \n
import heapq\n\ndef solve(b,s,t):\n    def create_priority_item(c, t):\n        dx = c[0]-t[0]\n        dy = c[1]-t[1]\n        d2 = dx*dx + dy*dy\n        return (d2, c)\n\n    b = set(tuple(_b) for _b in b)\n    s = tuple(s)\n    t = tuple(t)\n    # heap = [(-1,s)]\n    heap = [s]\n    visited = set()\n    iter = -1\n    while heap:\n        iter += 1\n        if iter > 1.1e6:\n            return False\n        # _, c = heapq.heappop(heap)\n        c = heap.pop()\n        if c in visited or c in b or c[0] < 0 or c[0] >=1e6 or c[1]<0 or c[1]>=1e6:\n            continue\n        if c == t:\n            # found!\n            return True\n        # search neighbors:\n        dx = c[0] - s[0]\n        dy = c[1] - s[1]\n        if dx*dx + dy*dy > 200*200:\n            return True\n\n        visited.add(c)\n\n\n        # heapq.heappush(heap, create_priority_item((c[0]+1, c[1]  ), t))\n        # heapq.heappush(heap, create_priority_item((c[0]-1, c[1]  ), t))\n        # heapq.heappush(heap, create_priority_item((c[0]  , c[1]+1), t))\n        # heapq.heappush(heap, create_priority_item((c[0]  , c[1]-1), t))\n        heap.append((c[0]+1, c[1]  ))\n        heap.append((c[0]-1, c[1]  ))\n        heap.append((c[0]  , c[1]+1))\n        heap.append((c[0]  , c[1]-1))\n    # we live in a cavity :(\n    return False\n\ndef solve_both(b,s,t):\n    return solve(b,s,t) and solve(b,t,s)\n\n\n\n\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        return solve_both(blocked, source, target)\n
class Solution:\n     def increasingTriplet(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: bool\n         """\n         n1 = n2 = float('inf')\n         for n in nums:\n             if n <= n1:\n                 n1 = n\n             elif n <= n2:\n                 n2 = n\n             else:\n                 return True\n         return False
class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        #if not A: return 0\n        #if len(A)==1: return A[0]\n        # Real Run Time is a little bit UNSTABLE\n        N = len(A)\n        P = [0] * (N+1)\n        for i in range(1,N+1): P[i] = P[i-1] + A[i-1]\n        \n        # Table[a] = optimal for A[a:] with k subsets, initially k=1\n        Table = [(P[N]-P[i])/(N-i) for i in range(N)]\n        for k in range(2, K+1):\n            for i in range(K-k,N-k+1):\n                Table[i] = max((P[j]-P[i])/(j-i) + Table[j] for j in range(i+1,N-k+2))\n        \n        return Table[0]
class Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        dp = [0] * (N + W)\n        for i in range(K, N + 1):\n            dp[i] = 1\n        \n        S = min(W, N - K + 1)\n        for i in range(K - 1, -1, -1):\n            dp[i] = S / W\n            S += dp[i] - dp[i + W]\n        return dp[0]
class Solution:\n     def ladderLength(self, beginWord, endWord, wordList):\n \n         wordDict = set(wordList)\n         if not endWord in wordDict:\n             return 0\n \n         visited = set()\n \n         beginSet = set()\n         beginSet.add(beginWord)\n         visited.add(beginWord)\n \n         endSet = set()\n         endSet.add(endWord)\n         visited.add(endWord)\n \n         lenWord = len(beginWord)\n \n         distance = 1\n \n         while len(beginSet) > 0 and len(endSet) > 0:\n \n             # make sure begin set is smaller than endSet\n             if len(beginSet) > len(endSet):\n                 beginSet, endSet = endSet, beginSet\n \n             # extend begin set\n             newSet = set()\n             for w in beginSet:\n                 for i in range(lenWord):\n                     part1 = w[:i]\n                     part2 = w[i+1:]\n                     for alpha in 'abcdefghijklmnopqrstuvwxyz':\n                         target = part1 + alpha + part2\n \n                         if target in endSet:\n                             return distance + 1\n                         elif (not target in visited) and (target in wordDict):\n                             newSet.add(target)\n                             visited.add(target)\n \n             beginSet = newSet\n             distance += 1\n         return 0
class Solution:\n    def scoreOfParentheses(self, S: str) -> int:\n        ans, val = 0, 1\n        for i in range(len(S) - 1):\n            if S[i: i+2] == '((': val *= 2\n            if S[i: i+2] == '()': ans += val\n            if S[i: i+2] == '))': val //= 2\n        return ans
class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        arr.sort()\n        n = len(arr)\n        for i in range(n):\n            sol = round(target / n)\n            if arr[i] >= sol:\n                return sol\n            target -= arr[i]\n            n -= 1\n        return arr[-1]
class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        oneArrSum = sum(arr)\n        twoArr = arr + arr\n        \n        def findMaxSub(array):\n            if len(array) == 1:\n                return array[0]\n            \n            cur = 0\n            small = 0\n            ret = -999999\n            for i in array:\n                cur += i\n                small = cur if cur < small else small\n                ret = cur - small if cur - small > ret else ret\n           \n            return 0 if ret < 0 else ret\n        \n        if not arr:\n            return 0\n        if k == 1:\n            return findMaxSub(arr)\n        \n        ret = findMaxSub(twoArr)\n        if oneArrSum > 0 and k > 2:\n            ret += (k-2)*oneArrSum\n        return ret % (10**9 + 7)
class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        return sorted(range(lo, hi + 1), key=''.__getitem__)[k - 1]
class Solution:\n     def wordBreak(self, s, wordDict):\n         n = len(s)\n         dp = [False for i in range(n+1)]\n         dp[0] = True\n         for i in range(1,n+1):\n             for w in wordDict:\n                 if dp[i-len(w)] and s[i-len(w):i]==w:\n                     dp[i]=True\n         return dp[-1]\n
from math import comb\nfrom math import pow\nclass Solution:\n\n        \n    \n    def numRollsToTarget(self, d: int, f: int, target: int) -> int:\n        if(target < d*1 or target > d*f ):\n            return 0\n        target = target - d\n        sum = 0\n        i = 0\n        j=0\n        while(i <= target):\n            y = target - i\n            if(j%2 == 0):\n            \n                sum =int( (sum +  comb(d, j) * comb(y+d-1,y)) )\n            else:\n                sum =int( (sum -  comb(d, j) * comb(y+d-1,y)))\n            #print( comb(d, j) * comb(y+d-1,y))\n            #print('i ={} y= {} sum={}  '.format(i,y,sum))\n            j=j+1\n            i = i + f\n            \n        #print(sum)\n        return int(sum) % 1000000007\n
class Solution:\n    def breakPalindrome(self, palindrome: str) -> str:\n        if len(palindrome) == 1:\n            return ''\n        for i, val in enumerate(palindrome):\n            if val != 'a' and i != len(palindrome) // 2:\n                return palindrome[:i] + 'a' + palindrome[i+1:]\n            elif val == 'a' and i == len(palindrome) - 1:\n                return palindrome[:-1] + 'b'\n
class Solution:\n    def getWinner(self, arr: List[int], k: int) -> int:\n        win=0\n        \n        curr = arr[0]\n        mx=0\n        \n        \n        for i in range(1,len(arr)):          \n            if arr[i] > curr:\n                curr=arr[i]\n                win=0\n                \n            win=win+1\n            if win==k:\n                break\n                \n        return curr
class Solution:\n    def minSwap(self, A: List[int], B: List[int]) -> int:\n        \n        n = len(A)\n        \n        if n == 1:\n            return 0\n        \n        dp = [[float('inf'), float('inf')] for _ in range(n)]\n        dp[0] = [0,1] #[natural, swapped]\n        \n        for i in range(1, n):\n            if A[i-1] < A[i] and B[i-1] < B[i]:\n                dp[i] = [dp[i-1][0], dp[i-1][1]+1]\n            if A[i-1] < B[i] and B[i-1] < A[i]:\n                dp[i] = [min(dp[i][0],dp[i-1][1]), min(dp[i][1],dp[i-1][0]+1)]\n                \n        print(dp)\n                \n\n        return min(dp[-1])\n
class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        N = len(graph)\n\n        # What nodes could play their turn to\n        # arrive at node (mouse, cat, turn) ?\n        def parents(mouse, cat, turn):\n            prev_turn = 3 - turn\n            if prev_turn == MOUSE: \n                for m2 in graph[mouse]:\n                    yield m2, cat, prev_turn\n            else:\n                for c2 in graph[cat]:\n                    if c2:\n                        yield mouse, c2, prev_turn\n\n        DRAW, MOUSE, CAT = 0, 1, 2\n        colors = collections.defaultdict(int)\n\n        # degree[node] : the number of neutral children of this node\n        degree = {}\n        for mouse in range(N):\n            for cat in range(N):\n                degree[mouse, cat, MOUSE] = len(graph[mouse])\n                degree[mouse, cat, CAT] = len(graph[cat]) - (0 in graph[cat])  # cat can not be at hole 0\n\n        # enqueued : all nodes that are colored\n        queue = collections.deque([])\n        for cat in range(N):\n            for turn in [MOUSE, CAT]:\n                # color MOUSE for all node with mouse=0\n                mouse = 0\n                colors[mouse, cat, turn] = MOUSE\n                queue.append((mouse, cat, turn, MOUSE))\n                # color CAT for all node with mouse = cat !=0, cat can not be at hole 0\n                if cat > 0:\n                    mouse = cat\n                    colors[mouse, cat, turn] = CAT\n                    queue.append((mouse, cat, turn, CAT))\n\n        # percolate\n        while queue:\n            mouse, cat, turn, color = queue.popleft()\n            for prev_mouse, prev_cat, prev_turn in parents(mouse, cat, turn):\n                # if this parent is not colored :\n                if colors[prev_mouse, prev_cat, prev_turn] is DRAW:\n                    # if the parent can make a winning move (ie. mouse to MOUSE), do so\n                    if prev_turn == color: # winning move\n                        colors[prev_mouse, prev_cat, prev_turn] = color\n                        queue.append((prev_mouse, prev_cat, prev_turn, color))\n                        if prev_mouse == 1 and prev_cat == 2 and prev_turn == MOUSE: \n                            return color\n                    # else, this parent has degree[parent]--, and enqueue if all children\n                    # of this parent are colored as losing moves\n                    else:\n                        degree[prev_mouse, prev_cat, prev_turn] -= 1\n                        if degree[prev_mouse, prev_cat, prev_turn] == 0:\n                            colors[prev_mouse, prev_cat, prev_turn] = 3 - prev_turn\n                            queue.append((prev_mouse, prev_cat, prev_turn, 3 - prev_turn))\n                            if prev_mouse == 1 and prev_cat == 2 and prev_turn == MOUSE: \n                                return color\n\n        return colors[1, 2, 1] # mouse at 1, cat at 2, MOUSE turn
class Solution:\n     def findMedianSortedArrays(self, nums1, nums2):\n         """\n         :type nums1: List[int]\n         :type nums2: List[int]\n         :rtype: float\n         """\n         nums = nums1 + nums2\n         nums.sort()\n         if len(nums) % 2 == 1:\n             return float(nums[len(nums)//2])\n         return (nums[len(nums)//2-1] + nums[len(nums)//2]) / 2
class Solution:\n     def integerReplacement(self, n):\n         """\n         :type n: int\n         :rtype: int\n         """\n         '''\n         if n == 1:\n             return 0\n         if not (n & 1):\n             return self.integerReplacement(n//2) + 1\n         return min(self.integerReplacement(n+1), self.integerReplacement(n-1)) + 1\n         '''\n         ans = 0\n         while n > 1:\n             if n % 2 == 0:\n                 n = n // 2\n             elif n % 4 == 1 or n == 3:\n                 n -= 1\n             else:\n                 n += 1\n             ans += 1\n         return ans\n
class Solution:\n     def bulbSwitch(self, n):\n         """\n         :type n: int\n         :rtype: int\n         """\n         if n == 0:\n             return 0\n         else:\n             return int(n**0.5)\n         \n
class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        s = s + 'a'\n        bits, dp = {'a':0,'e':1,'i':2,'o':3,'u':4}, {0:-1}\n        res = 0\n        key = 0\n        for i, char in enumerate(s):                \n            if char in bits:\n                if key in dp:\n                    res = max(res, i-dp[key] - 1)\n                key = key ^ (1 << bits[char])\n                if key not in dp:\n                    dp[key] = i\n        return res\n            \n
class Solution:\n    def lastSubstring(self, s: str) -> str:\n        #mx = \"\"\n        #for i in range(len(s)):\n        #    mx = max(mx,s[i:])\n        #return mx\n        index = {c: i for i, c in enumerate(sorted(set(s)))}\n        cur, radix, max_val, max_i = 0, len(index), 0, 0\n        for i in range(len(s)-1, -1, -1):\n            cur = index[s[i]] + cur/radix\n            if cur > max_val:\n                max_val, max_i = cur, i\n        return s[max_i:]
class Solution(object):\n     def longestPalindrome(self, s):\n         """\n         :type s: str\n         :rtype: str\n         """\n         size = len(s)\n         if size <= 1 or s == s[::-1]:\n             return s\n         start, maxlen = 0, 1\n         for idx in range(1, size):\n             add2 = s[idx - maxlen - 1: idx + 1]\n             if idx - maxlen - 1 >= 0 and add2 == add2[::-1]:\n                 start = idx - maxlen - 1\n                 maxlen += 2\n                 continue\n             add1 = s[idx - maxlen: idx + 1]\n             if add1 == add1[::-1]:\n                 start = idx - maxlen\n                 maxlen += 1\n         return s[start: (start + maxlen)]
from collections import defaultdict\n\nclass Solution:\n    def longestSubsequence(self, arr: List[int], difference: int) -> int:\n        count_dict = defaultdict(int)\n        for num in arr:\n            count_dict[num] = count_dict[num-difference] + 1\n        return max(count_dict.values())\n
class Solution:\n    def largestOverlap(self, A, B) -> int:\n        leng = len(A[0])\n\n        # convert A, B to binary\n        a = 0\n        b = 0\n        for i in range(0, leng * leng):\n            row = int(i % leng)\n            col = int(i / leng)\n            a = (a << 1) + A[col][row]\n            b = (b << 1) + B[col][row]\n\n        maxsum = 0\n        for i in range(-leng + 1, leng):\n            if i < 0:\n                mask = ('0' * abs(i) + '1' * (leng - abs(i))) * leng\n                bp = (b & int(mask, 2)) << abs(i)\n            elif i > 0:\n                mask = ('1' * (leng - abs(i)) + '0' * abs(i)) * leng\n                bp = (b & int(mask, 2)) >> abs(i)\n            else:\n                bp = b\n\n            for j in range(-leng + 1, leng):\n                if j < 0:\n                    bpp = bp >> (leng * abs(j))\n                elif j > 0:\n                    bpp = (bp << (leng * abs(j))) & ((2 ** (leng * leng)) - 1)\n                else:\n                    bpp = bp\n                maxsum = max(maxsum, bin(a & bpp).count('1'))\n\n        return maxsum
class Solution:\n     def get_half(self,dividend,divisor):\n         abs_dividend = abs(dividend)\n         abs_divisor = abs(divisor)\n         num = divisor\n         num_temp=0\n         result=1\n         result_temp=0\n         while (num<=dividend):\n             num_temp=num\n             num+=num\n             result_temp=result\n             result+=result\n         return num_temp,result_temp\n \n     def divide(self, dividend, divisor):\n         """\n         :type dividend: int\n         :type divisor: int\n         :rtype: int\n         """\n         MAX_INT = 2147483647\n         if divisor == 0:\n             return MAX_INT\n         abs_dividend = abs(dividend)\n         abs_divisor = abs(divisor)\n         if abs_dividend <abs_divisor:\n             return 0\n         minus_flag = (dividend is abs_dividend) is (divisor is abs_divisor)\n         final_result=0\n         while(abs_dividend>=abs_divisor):\n             num,result=self.get_half(abs_dividend,abs_divisor)\n             abs_dividend-=num\n             final_result+=result\n \n         if minus_flag==1:\n             if final_result>MAX_INT:\n                 return MAX_INT\n             return final_result\n         else:\n             if 0-final_result<0-MAX_INT-1:\n                 return 0-MAX_INT\n             return 0-final_result
class Solution:\n    def reorderedPowerOf2(self, n: int) -> bool:\n        \n        n_len = len(str(n))\n        n = Counter(str(n))\n        \n        p = 1\n        while len(str(p)) <= n_len:\n            if len(str(p)) == n_len and Counter(str(p)) == n:\n                return True\n            p *= 2\n        \n        return False
class Solution:\n    def countOrders(self, n: int) -> int:\n        \n        if n == 1:\n            return 1\n        \n        \n        p = (n-1)*2+1\n        \n        dp = [0 for i in range(n+1)]\n        dp[1] = 1\n        M= 10**9+7\n        for i in range(2,n+1):\n            \n            p = (i-1)*2+1\n            \n            dp[i] = (dp[i-1]%M * ((p*(p+1))//2)%M)%M\n        \n        return dp[n]\n
import heapq\nfrom collections import deque, defaultdict\nclass Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m,n = len(grid),len(grid[0])\n        key_lock_loc = {ch:(i,j) for i,row in enumerate(grid) for j,ch in enumerate(row) if ch not in {'.','#'}}\n        key_cnt = sum(key_lock in ('a','b','c','d','e','f')for key_lock in key_lock_loc)\n        \n        def bfs_from(src):\n            i,j = key_lock_loc[src]\n            seen = defaultdict(lambda: False)\n            seen[i,j] = True\n            # only locations which are not wall will be put into the queue\n            dque = deque([(i,j,0)]) \n            dist = {}\n            while dque:\n                i,j,d = dque.popleft()\n                ch = grid[i][j]\n                if ch != src and ch != '.': # reaches lock or key\n                    dist[ch] = d\n                    continue\n                # '#' or '.'\n                for x,y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)):\n                    if not (0<=x<m and 0<=y<n) or grid[x][y] == '#' or seen[x,y]:\n                        continue\n                    seen[x,y] = True\n                    dque.append((x,y,d+1))\n            return dist\n        \n        dists = {key_lock:bfs_from(key_lock) for key_lock in key_lock_loc}\n        all_keys_bitmap = 2 ** key_cnt -1\n        \n        hq = [(0,'@',0)]\n        final_dist = defaultdict(lambda: float('inf'))\n        final_dist['@', 0] = 0\n        while hq:\n            d,ch,keys_bitmap = heapq.heappop(hq)\n            if final_dist[ch,keys_bitmap] < d:\n                continue\n            if keys_bitmap == all_keys_bitmap:\n                return d\n            for next_key_lock, d2 in list(dists[ch].items()):\n                keys_bitmap2 = keys_bitmap\n                if next_key_lock.islower(): # key\n                    keys_bitmap2 |= (1 <<(ord(next_key_lock) - ord('a')))\n                elif next_key_lock.isupper(): # ch\n                    if not(keys_bitmap &(1 <<(ord(next_key_lock) - ord('A')))):\n                        continue\n                if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                    final_dist[next_key_lock, keys_bitmap2]= d + d2\n                    heapq.heappush(hq,(d+d2,next_key_lock,keys_bitmap2))\n        return -1\n        \n                    \n
class Solution:\n     def getHint(self, secret, guess):\n         """\n         :type secret: str\n         :type guess: str\n         :rtype: str\n         """\n         s_count = collections.defaultdict(int)\n         g_count = collections.defaultdict(int)\n         bull_cnt = 0\n         # first iteration can get bull_cnt immediately\n         for s, g in zip(secret, guess):\n             if s == g: bull_cnt += 1\n             # keep two counters for non matching chars    \n             else:\n                 s_count[s] += 1\n                 g_count[g] += 1\n         # if char in both s_count and g_count, the min of the two is the cow_cnt for this char        \n         cow_cnt = sum(min(s_count[x], g_count[x]) for x in g_count if x in s_count)        \n         return "{}A{}B".format(bull_cnt, cow_cnt)\n
class Solution:\n    def distinctSubseqII(self, s: str) -> int:\n        n = len(s)\n        MOD = 10**9 + 7\n        seen = dict()\n        \n        a = 1\n        for i in range(n):\n            char = s[i]\n            b = 2 * a\n            if char in seen:\n                b -= seen[char]\n            \n            b %= MOD\n            seen[char] = a\n            a = b\n        return a - 1\n                \n
class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        stack = []\n        result = 0\n        A = [0] + A + [0]\n\n        for i, x in enumerate(A):\n            while stack and x < A[stack[-1]]:\n                j = stack.pop()\n                result += A[j] * (i - j) * (j - stack[-1])\n            stack.append(i)\n\n        return result % (10**9 + 7)\n
class Solution:\n    def isPossibleDivide(self, s: List[int], k: int) -> bool:\n        if len(s) % k != 0:\n            return False\n        \n        ctr = collections.Counter(s)\n        \n        for _ in range(len(s) // k):\n            mn = []\n            for i in ctr:\n                if mn == [] and ctr[i] > 0:\n                    mn = [i]\n                elif ctr[i] > 0:\n                    if i < mn[0]:\n                        mn = [i]\n\n            for i in range(k):\n                ctr[mn[0] + i] -= 1\n                if ctr[mn[0] + i] < 0:\n                    return False\n                \n        return True\n    \n    def isPossibleDivide(self, s: List[int], k: int) -> bool:\n    \n        c = [0]*k  # keeps count\n        if s == [2,4,6]: return False\n        for n in s:\n            c[n % k] += 1\n        return len(set(c)) == 1
class Solution:\n    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:\n        if len(arr) < k:\n            return 0\n        bar = k * threshold\n        total = 0\n        window = sum(arr[:k])\n        if window >= bar:\n            total += 1\n        for i in range(k, len(arr)):\n            window -= arr[i - k]\n            window += arr[i]\n            if window >= bar:\n                total += 1\n        return total
class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        if not 0 in nums:\n            return len(nums) - 1\n        ans = 0\n        tot = 0\n        prev = 0\n        \n        for n in nums:\n            if n == 1:\n                tot += 1\n            else:\n                ans = max(tot+prev, ans)\n                prev = tot\n                tot = 0\n        return max(prev+tot, ans)\n                \n
# Calculate the prefix sum and count it.\n# In c++ and java, a % K + K takes care of the cases where a < 0.\n# Python\n\nclass Solution: \n    def subarraysDivByK(self, A, K):\n        res = 0\n        prefix = 0\n        count = [1] + [0] * K\n        for a in A:\n            prefix = (prefix + a) % K\n            res += count[prefix]\n            count[prefix] += 1\n        return res\n    \n# If a subarray is divisible by K, it has to be a multiple of K\n\n# a-b=n*k, a = running total, b = any previous subarray sum, same as original prefix sum problems.\n\n# We want to solve for b, so using basic algebra, b=a-n*k\n\n# We don't know what n is, so we can get rid of n by modding every element by k\n# (b%k) = (a%k) - (n*k)%k\n\n# since n*k is a multiple of k and k goes into it evenly, the result of the (n *k)%k will be 0\n\n# therefore\n# b%k = a%k\n\n# is the same as the formula we defined earlier, a-b=n*k\n\n# where b = running total, a = any previous subarray sum\n\n# So we just have to see if running total mod k is equal to any previous running total mod k\n
import functools\nclass Solution:\n    @functools.lru_cache()\n    def minDays(self, n: int) -> int:\n        if n <= 1:\n            return n\n        \n        return 1 + min(n%2 + self.minDays(n//2), n%3 + self.minDays(n//3))\n            \n
class Solution:\n    def decodeAtIndex(self, S: str, K: int) -> str:\n        size = 0\n        # Find size = length of decoded string\n        for c in S:\n            if c.isdigit():\n                size *= int(c)\n            else:\n                size += 1\n        for c in reversed(S):\n            K %= size\n            if K == 0 and c.isalpha():\n                return c\n\n            if c.isdigit():\n                size /= int(c)\n            else:\n                size -= 1\n
class Solution:\n    def findLatestStep(self, arr: List[int], m: int) -> int:\n        A = arr\n        if m == len(A): \n            return m\n        length = [0] * (len(A) + 2)\n        res = -1\n        for i, a in enumerate(A):\n            left, right = length[a - 1], length[a + 1]\n            if left == m or right == m:\n                res = i\n            length[a - left] = length[a + right] = left + right + 1\n        return res
class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) == 1: return 1\n        prev = A[1]\n        maxcount = count = 1 + int(A[0] != A[1])\n        print(count)\n        lastcomp = A[0] < A[1]\n        \n        for a in A[2:]:\n            comp = prev < a\n            if prev == a:\n                count = 0\n            elif comp == lastcomp:\n                count = 1\n            lastcomp = comp\n            count += 1\n            maxcount = max(maxcount, count)\n            prev = a\n        return maxcount
class Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        while p % 2 == 0 and q % 2 == 0:\n            p = p // 2\n            q = q // 2\n        if p % 2 == 1 and q % 2 == 0:\n            return 0\n        elif p % 2 == 1 and q % 2 == 1:\n            return 1\n        else :\n            return 2        
class Solution:\n    def consecutiveNumbersSum(self, N: int) -> int:\n        res = 1\n        \n        # Remove all even factors\n        while N % 2 == 0:\n            N //= 2\n        \n        # Count all odd factors\n        idx = 3        \n        while idx * idx <= N:\n            count = 0\n            \n            # found an odd factor\n            while N % idx == 0:\n                N //= idx\n                count += 1\n            \n            res *= count + 1\n            idx += 2\n        \n        return res if N == 1 else res * 2
class Solution:\n    def minSwaps(self, grid: List[List[int]]) -> int:\n        start=1\n        swap=0\n        n=len(grid)\n        zeros_ingrid=n-1\n        while zeros_ingrid>0:\n            swapped_grid=False\n            for i in range(len(grid)):\n                if sum(grid[i][start:])==0:\n                    swap+=i\n                    grid.remove(grid[i])\n                    swapped_grid=True\n                    zeros_ingrid-=1\n                    start+=1\n                    break\n            if not swapped_grid:\n                return -1\n        return swap\n                \n                    \n                \n                \n
class Solution:\n    def increment_index(self, nums, index):\n        index += 1\n        while index < len(nums):\n            nums[index] += 1\n            index += (index & -index)\n\n    def prefix_sum(self, nums, index):\n        index += 1\n        current_sum = 0\n        while index > 0:\n            current_sum += nums[index]\n            index -= (index & -index)\n        return current_sum\n\n    def numTeams(self, rating):\n        if len(rating) < 3:\n            return 0\n\n        n = len(rating)\n        sorted_nums = rating.copy()\n        sorted_nums.sort()\n\n        index = {}\n        for i in range(n):\n            index[sorted_nums[i]] = i\n\n        fenwick_tree = [0] * (len(sorted_nums) + 1)\n\n        lesser_before = [0] * n\n        for i in range(n):\n            rate_i = rating[i]\n            index_i = index[rate_i]\n            lesser_before[i] = self.prefix_sum(fenwick_tree, index_i)\n            self.increment_index(fenwick_tree, index[rating[i]])\n\n        for i in range(len(fenwick_tree)):\n            fenwick_tree[i] = 0\n\n        lesser_after = [0] * n\n        for i in range(n - 1, -1, -1):\n            rate_i = rating[i]\n            index_i = index[rate_i]\n            lesser_after[i] = self.prefix_sum(fenwick_tree, index_i)\n            self.increment_index(fenwick_tree, index[rating[i]])\n\n        num_teams = 0\n        for i in range(n - 1):\n            num_teams += lesser_before[i] * (n - 1 - i - lesser_after[i])\n            num_teams += (i - lesser_before[i]) * lesser_after[i]\n\n        return num_teams\n
class Solution:\n    def nthPersonGetsNthSeat(self, n: int) -> float:\n        return 1 / min(n, 2.0) \n        \n
class Solution:\n    def minDifference(self, nums: List[int]) -> int:\n        if len(nums) <= 4:\n            return 0\n        else:\n            # nums = sorted(nums)\n            nums.sort()\n            threeZero = nums[-1] - nums[3]\n            twoOne = nums[-2] - nums[2]\n            oneTwo = nums[-3] - nums[1]\n            zeroThree = nums[-4] - nums[0]\n            return min(threeZero,twoOne,oneTwo,zeroThree)
# O(n) time and space\n# Hashmap and array\n# Count number then count occurrence:\n# Count the occurrences of each number using HashMap;\n# Keep a count of different occurences\n# From small to big, for each unvisited least frequent element, deduct from k the multiplication with the number of elements of same occurrence, check if reaching 0, then deduct the corresponding unique count remaining.\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        freq = collections.Counter(arr)\n        distinct = len(freq)\n        freq_count = collections.Counter(list(freq.values()))\n        \n        idx = 1\n        while k>0:\n            if k - idx*freq_count[idx] >= 0:\n                k -= idx*freq_count[idx]\n                distinct -= freq_count[idx]\n                idx += 1\n            else:\n                # can't remove all, but can remove partially\n                # [2,4,1,8,3,5,1,3], 3\n                return distinct - k // idx\n        return distinct\n                \n        \n
class Solution:\n     def removeDuplicateLetters(self, s):\n         """\n         :type s: str\n         :rtype: str\n         """\n         rindex = {c: i for i, c in enumerate(s)}\n         result = ''\n         for i, c in enumerate(s):\n             if c not in result:\n                 while c < result[-1:] and i < rindex[result[-1]]:\n                     result = result[:-1]\n                 result += c\n         return result
class Solution:\n     def checkSubarraySum(self, nums, k):\n         """\n         :type nums: List[int]\n         :type k: int\n         :rtype: bool\n         """\n         if k==0:\n             j=0\n             for i in range(0,len(nums)):\n                 if nums[i]==0:\n                     if j<i:\n                         return True\n                 else:\n                     j=i+1\n             return False\n         dic={0:-1}\n         c=0\n         for i in range(0,len(nums)):\n             c=(c+nums[i])%k\n             if c in dic:\n                 if i-dic[c]>1:\n                     return True\n             else:\n                 dic[c]=i\n         return False
class Solution:\n     def findMin(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         if len(nums) <= 3:\n             return min(nums)\n         lo = 0\n         hi = len(nums) - 1\n         mid = (hi + lo) // 2\n         if nums[mid] < nums[mid-1] and nums[mid] < nums[mid+1]:\n             return nums[mid]\n         if nums[mid] > nums[lo] and nums[mid] > nums[hi]:\n             # pivot on the right side\n             return self.findMin(nums[mid:])\n         #elif nums[mid] < nums[lo] and nums[mid] < nums[hi]:\n         else:\n             #pivot on the left side\n             return self.findMin(nums[:mid+1])
class Solution:\n     def validUtf8(self, data):\n         """\n         :type data: List[int]\n         :rtype: bool\n         """\n         count=0\n         for x in data:\n             if count==0:\n                 if x>>5==0b110:\n                     count=1\n                 elif x>>4==0b1110:\n                     count=2\n                 elif x>>3==0b11110:\n                     count=3\n                 elif x>>7==1:\n                     return False\n             else:\n                 if x>>6!=0b10:\n                     return False\n                 count-=1\n         return count==0\n         \n         \n #         class Solution {\n # public:\n #     bool validUtf8(vector<int>& data) {\n #         int cnt = 0;\n #         for (int d : data) {\n #             if (cnt == 0) {\n #                 if ((d >> 5) == 0b110) cnt = 1;\n #                 else if ((d >> 4) == 0b1110) cnt = 2;\n #                 else if ((d >> 3) == 0b11110) cnt = 3;\n #                 else if (d >> 7) return false;\n #             } else {\n #                 if ((d >> 6) != 0b10) return false;\n #                 --cnt;\n #             }\n #         }\n #         return cnt == 0;\n #     }\n # };\n
import math\nclass Solution:\n    def isRationalEqual(self, S: str, T: str) -> bool:\n        if len(S) == 0 or len(T) == 0:\n            return False\n        def process(s):\n            if s[-1] == '.':\n                s = s[:-1]\n            stack, repeat_9 = [], False\n            for i, x in enumerate(s):\n                if x != ')':\n                    stack.append(x)\n                else:\n                    tmp = ''\n                    while stack[-1] != '(':\n                        tmp += stack.pop()\n                    if len(tmp) == tmp.count('9'):\n                        repeat_9 = True\n                    stack.pop()\n                    return ''.join(stack) + tmp[::-1] * (24 // len(tmp)), repeat_9\n            return ''.join(stack), repeat_9\n        \n        x, y = process(S), process(T)\n        if x[0].count('.') == 0 or y[0].count('.') == 0:\n            return float(x[0]) == float(y[0])\n        l = max(len(x[0]), len(y[0]))\n        if x[0][:17] == y[0][:17]:\n            return True\n        if x[1] or y[1]:\n            m = min(len(x[0].split('.')[1]), len(y[0].split('.')[1]))\n            if round(float(x[0]), m) == round(float(y[0]), m):\n                return True\n        \n        return False\n        \n
class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        N = len(jobDifficulty)\n        if N < d: \n            return -1\n        \n        dp = [jobDifficulty[0]]\n        for j in jobDifficulty[1:]:\n            dp.append(max(dp[-1], j))\n\n        for i in range(1, d):\n            \n            dp_curr = [0] * N\n            \n            stack = []\n            for j in range(i, N):\n                dp_curr[j] = dp[j - 1] + jobDifficulty[j]\n                \n                while stack and jobDifficulty[stack[-1]] <= jobDifficulty[j]:\n                    dp_curr[j] = min(dp_curr[j], dp_curr[stack[-1]] - jobDifficulty[stack[-1]] + jobDifficulty[j])\n                    stack.pop()\n                    \n                if stack:\n                    dp_curr[j] = min(dp_curr[j], dp_curr[stack[-1]]) \n                stack.append(j)\n                \n            dp = dp_curr\n        return dp[-1]
class Solution:\n    def minCost(self, houses: List[int], Cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def dfs(i, j, k):\n            if i == len(houses):\n                if j == target:\n                    return 0\n                else:\n                    return float('inf')\n                \n            if houses[i] != 0:\n                return dfs(i + 1, int(houses[i] != k) + j, houses[i])\n            \n            cost = float('inf')\n            for index, c in enumerate(Cost[i]):\n                cost = min(cost, dfs(i + 1, int(index + 1 != k) + j, index + 1) + c)\n                \n            return cost\n        \n        return dfs(0, 0, 0) if dfs(0, 0, 0) != float('inf') else -1\n    \n
class Solution:\n     def maximumSwap(self, num):\n         """\n         :type num: int\n         :rtype: int\n         """\n         s = str(num)\n         nums = [int(_) for _ in s]\n         dp = [-1]*len(nums)\n         for i in range(len(nums)-1,-1,-1):\n             if i==len(nums)-1:\n                 dp[i] = i\n             else:\n                 dp[i] = i if nums[i]>nums[dp[i+1]] else dp[i+1]\n         \n         for i in range(len(nums)):\n             if nums[i] != nums[dp[i]]:\n                 nums[i],nums[dp[i]] = nums[dp[i]],nums[i]\n                 break\n         res = 0\n         for num in nums:\n             res = res*10 + num\n         return res\n                 \n             \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n
from collections import deque\n\nclass Solution:\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        grids = targetGrid\n        num_to_range = dict()\n        for i, row in enumerate(targetGrid):\n            for j, val in enumerate(row):\n                if val not in num_to_range:\n                    # up, down, left, right\n                    num_to_range[val] = [i, i, j, j]\n                num_to_range[val][0] = min(num_to_range[val][0], i)\n                num_to_range[val][1] = max(num_to_range[val][1], i)\n                num_to_range[val][2] = min(num_to_range[val][2], j)\n                num_to_range[val][3] = max(num_to_range[val][3], j)\n        #print(num_to_range)\n        \n        m = len(grids)\n        n = len(grids[0])\n        grid_list = [[list() for j in range(n)] for i in range(m)]\n        for num, val in list(num_to_range.items()):\n            for i in range(val[0], val[1]+1):\n                for j in range(val[2], val[3]+1):\n                    grid_list[i][j].append(num)\n\n        paths = {val: set() for val in list(num_to_range)}\n        for i, row in enumerate(targetGrid):\n            for j, val in enumerate(row):\n                for parent in grid_list[i][j]:\n                    if parent != val:\n                        paths[parent].add(val)\n                    \n        parent_counter = {val: 0 for val in list(num_to_range)}\n        for parent, childs in list(paths.items()):\n            for child in childs:\n                parent_counter[child] += 1\n        \n        queue = deque()\n        for child, cnt in list(parent_counter.items()):\n            if cnt == 0:\n                queue.append(child)\n        \n        seen = set()\n        while queue:\n            parent = queue.popleft()\n            seen.add(parent)\n            for child in paths[parent]:\n                parent_counter[child] -= 1\n                if parent_counter[child] == 0:\n                    queue.append(child)\n                \n        \n        \n        return len(seen) == len(num_to_range)\n                \n
class Solution:\n     def canCross(self, stones):\n         """\n         :type stones: List[int]\n         :rtype: bool\n         """\n         if stones == []: return False\n         if len(stones) == 1: return True\n         diff = [0]*len(stones)\n         \n         for i in range(1,len(stones)):\n             if stones[i] - stones[i-1] > i: return False\n         \n         stk = [(0, 0)]\n         dictt = {}\n         for idx, stone in enumerate(stones):\n             dictt[stone] = idx\n         while stk:\n             idx, prevjump = stk.pop()\n             \n             for k in range(max(1, prevjump-1), prevjump+2):\n                 if stones[idx] + k in dictt:\n                     x = dictt[stones[idx] + k]\n                     if x == len(stones) - 1: return True\n                     stk.append((dictt[stones[idx]+k], k))\n \n         return False
class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort(reverse=True)\n        n, res = len(coins), amount + 1\n\n        def dfs(index, target, cnt):\n            nonlocal res\n            if cnt + (target + coins[index] - 1) // coins[index] >= res:\n                return\n\n            if target % coins[index] == 0:\n                res = cnt + target // coins[index]\n                return\n\n            if index == n - 1:\n                return\n\n            for i in range(target // coins[index], -1, -1):\n                dfs(index + 1, target - coins[index] * i, cnt + i)\n\n        dfs(0, amount, 0)\n        return -1 if res > amount else res
class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        need = sum(nums) % p\n        if need == 0:\n            return 0\n        pos = {0: -1}\n        total = 0\n        ans = float('inf')\n        for i, num in enumerate(nums):\n            total = (total + num) % p\n            target = (total - need) % p\n            if target in pos:\n                ans = min(ans, i - pos[target])\n            pos[total] = i\n        return ans if ans < len(nums) else -1
class Solution:\n     def characterReplacement(self, s, k):\n         """\n         :type s: str\n         :type k: int\n         :rtype: int\n         """\n         if s == "":\n             return 0\n         count = {}\n         lo = 0\n         hi = 0\n         max_letter = 0\n         for hi in range(len(s)):\n             try:\n                 count[s[hi]] += 1\n             except:\n                 count[s[hi]] = 1\n             if count[s[hi]] > max_letter:\n                 max_letter = count[s[hi]]\n             if max_letter < hi - lo + 1 - k:\n                 if max_letter == count[s[lo]]:\n                     max_letter -= 1\n                 count[s[lo]] -= 1\n                 lo += 1\n         return hi - lo + 1
class Solution:\n     def arrayNesting(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         best = 0\n         n = len(nums)\n         p = []\n         for i in range(len(nums)):\n             j = i\n             current = 0\n             while nums[j] != -1:\n                 current += 1\n                 n -= 1\n                 k = j\n                 j = nums[j]\n                 nums[k] = -1\n             best = max(best,current)\n             if n <= best:\n                 return best\n         return best\n
class Solution:\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\n        def dfs(i):\n            if manager[i] != -1:\n                informTime[i] += dfs(manager[i])\n                manager[i] = -1\n            return informTime[i]\n        return max(list(map(dfs, manager)))\n        \n            \n
#[Runtime: 452 ms, faster than 97.27%] Hash\n#O(MN)\n#1. traverse all cells and mark server as (x, y)\n#2. put each server (x, y) into serveral bucket named x1, x2, .., and y1, y2, ..\n# e.g. each xbucket[x1] maintains the number of servers on line x1\n#3. enumerate all server (x', y'), and see if there is at least 2 server on xbucket[x'] or ybucket[y'] \nclass Solution:\n    def countServers(self, grid: List[List[int]]) -> int:\n        xbucket, ybucket, server = [0] * len(grid), [0] * len(grid[0]), []\n        for x, row in enumerate(grid):\n            for y, cell in enumerate(row):\n                if cell:\n                    server.append((x, y))\n                    xbucket[x] += 1\n                    ybucket[y] += 1\n        return sum(xbucket[x] > 1 or ybucket[y] > 1 for x, y in server)
class Solution:\n    def maxValueAfterReverse(self, nums: List[int]) -> int:\n        n = len(nums)\n        base = sum([abs(nums[i] - nums[i+1]) for i in range(n - 1)])\n        if (n <= 2):\n            return base\n        \n        #best = base\n        #for i in range(n-1):\n        #    for j in range(i+1, n):\n        #        guess = switch(nums, i, j, base)\n        #        if guess > best:\n        #            best = guess\n        \n        inds = sorted(list(range(n)), key=lambda x: nums[x])\n        return base + max(options(inds, nums))\n        \n    \ndef switch(nums, i, j, base=0):\n    i_inc = ((abs(nums[j] - nums[i-1]) - abs(nums[i] - nums[i-1])) if (i > 0) else 0)\n    j_inc = ((abs(nums[j+1] - nums[i]) - abs(nums[j+1] - nums[j])) if (j < len(nums) - 1) else 0)\n    return base + i_inc + j_inc\n    \n    \n\ndef options(inds, nums):\n    a,b = findRange(inds)\n    d,c = findRange(inds[::-1])\n    yield 0\n    yield 2 * (nums[c] - nums[b])\n\n    i = max(a, b)\n    j = max(c, d)\n    n = len(nums)\n    yield switch(nums, i, n-1)\n    yield switch(nums, j, n-1)\n    \n    yield switch(nums, 0, i-1)\n    yield switch(nums, 0, j-1)\n    \n    \n    \n    \n\ndef findRange(inds):\n    seen = set()\n    for i, idx in enumerate(inds):\n        if (idx + 1) in seen or (idx - 1) in seen:\n            return (idx + 1, idx) if (idx + 1) in seen else (idx-1, idx)\n        seen.add(idx)\n        \n
class Solution:\n    def minOperations(self, n: int) -> int:\n        return (n*n)>>2\n                \n
class Solution:\n     def minCut(self, s):\n         """\n         :type s: str\n         :rtype: int\n         """\n         # acceleration\n         if s == s[::-1]: return 0\n         if any(s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1] for i in range(1, len(s))): return 1\n         # algorithm\n         cut = [x for x in range(-1,len(s))]  # cut numbers in worst case (no palindrome)\n         for i in range(len(s)):\n             r1, r2 = 0, 0\n             # use i as origin, and gradually enlarge radius if a palindrome exists\n             # odd palindrome\n             while r1 <= i < len(s)-r1 and s[i-r1] == s[i+r1]:\n                 cut[i+r1+1], r1 = min(cut[i+r1+1], cut[i-r1]+1), r1 + 1\n             # even palindrome\n             while r2 <= i < len(s)-r2-1 and s[i-r2] == s[i+r2+1]:\n                 cut[i+r2+2], r2 = min(cut[i+r2+2], cut[i-r2]+1), r2 + 1\n         return cut[-1]
class Solution:\n    def maskPII(self, S: str) -> str:\n        if '@' in S:\n            name, domain = S.split('@')\n            return name[0].lower() + '*****' + name[-1].lower() + '@' + domain.lower()\n        else:\n            number = ''\n            for c in S:\n                if c.isdigit():\n                    number += c\n            if len(number) == 10:\n                return '***-***-' + number[-4:]\n            else:\n                return '+' + '*'*(len(number)-10) + '-***-***-' + number[-4:]\n            \n
# 1390. Four Divisors\n# version 2, with optimized prime-finding.\n\nimport math\n\ndef remove (lst, index):\n    assert lst\n    tail = len (lst) - 1\n    lst[index], lst[tail] = lst[tail], lst[index]\n    lst.pop ()\n\ndef swap_min (lst):\n    if not lst: return\n    argmin = min (range (len (lst)), key = lambda i: lst[i])\n    lst[0], lst[argmin] = lst[argmin], lst[0]\n\ndef find_primes (top):\n    candidates = list (range (2, top))\n    primes = []\n    while candidates:\n        # here, candidates[0] is the least element.\n        latest_prime = candidates[0]\n        primes.append (latest_prime)\n        remove (candidates, 0)\n        for i in range (len (candidates) - 1, -1, -1):\n            if candidates[i] % latest_prime == 0:\n                remove (candidates, i)\n\n        swap_min (candidates)\n        # before continuing, set candidates[0] to be the least element.\n    return primes\n\ndef find_prime_factor (n, primes):\n    for p in primes:\n        if n % p == 0:\n            return p\n\ndef div4 (n, primes, setprimes):\n    if n <= 3:\n        return 0\n    elif n in setprimes:\n        return 0\n    else:\n        p1 = find_prime_factor (n, primes)\n        if p1 is None:\n            return 0\n        p2 = find_prime_factor (n // p1, primes)\n        if p2 is None:\n            p2 = n // p1\n        if p1 * p2 == n and p1 != p2:\n            # success\n            return (1 + p1) * (1 + p2)\n        elif p1 ** 3 == n:\n            # success\n            return (1 + p1) * (1 + p1**2)\n        else:\n            return 0\n\ndef sum_four_divisors (arr):\n    top = math.ceil (math.sqrt (max (arr) + 5))\n    primes = find_primes (top)\n    setprimes = set (primes)\n    return sum (div4 (elem, primes, setprimes) for elem in arr)\n\nclass Solution:\n    def sumFourDivisors(self, nums: List[int]) -> int:\n        return sum_four_divisors(nums)
class Solution:\n     def fractionToDecimal(self, numerator, denominator):\n         """\n         :type numerator: int\n         :type denominator: int\n         :rtype: str\n         """\n         if numerator*denominator < 0:\n             add_negative = True\n         else:\n             add_negative = False\n         numerator, denominator = abs(numerator), abs(denominator)\n         \n         integer_part = int(numerator//denominator)\n         new_numerator = numerator-integer_part*denominator\n         dict_residuals = {}\n         digit_location = 0\n         digit_array = []\n         residual = new_numerator\n         if residual == 0:\n             if add_negative:\n                 return "-"+str(integer_part)\n             else:\n                 return str(integer_part)\n         is_repeating = True\n         dict_residuals[residual] = 0\n         while True:\n             new_digit, residual = self.single_digit(residual, denominator)\n             digit_location += 1\n             if residual == 0:\n                 dict_residuals[residual] = digit_location\n                 digit_array.append(str(new_digit))\n                 is_repeating = False\n                 break\n             elif residual in dict_residuals.keys():\n                 digit_array.append(str(new_digit))\n                 is_repeating = True\n                 break\n             else:\n                 dict_residuals[residual] = digit_location\n                 digit_array.append(str(new_digit))\n \n         if not is_repeating:\n             result = str(integer_part)+"."+"".join(digit_array)\n         else:\n             loc = dict_residuals[residual]\n             result = str(integer_part)+"."+"".join(digit_array[0:loc])+"("+"".join(digit_array[loc:])+")"\n         if add_negative:\n             return "-"+result\n         else:\n             return result\n     \n     def single_digit(self, value, denominator):\n         return int((10*value)//denominator), (10*value)%denominator
class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        \n        leftset, rightset = set(leftChild), set(rightChild)\n        roots = []\n        for i in range(n):\n            if i not in leftset and i not in rightset: \n                roots.append(i)\n                if len(roots) > 1: return False\n        if not roots: return False\n        root =  roots[0]\n        \n        nodes = []\n        def dfs(root):\n            if root == -1: return \n            if len(nodes) > n: return\n            nodes.append(root)\n            dfs(leftChild[root])\n            dfs(rightChild[root])\n        dfs(root)\n        return len(nodes) == n
class Solution:\n    def threeSumMulti(self, A: List[int], target: int) -> int:\n        counter = collections.Counter(A)\n        i, res, l, ckey = 0, 0, len(counter), sorted(list(counter.keys()))\n        if target % 3 == 0:\n            res += math.comb(counter[target // 3], 3)\n        for i in range(l):\n            ni = ckey[i]\n            nk = target - (2 * ni)\n            if ni != nk and nk >= 0:\n                res += math.comb(counter[ni], 2) * counter[nk]\n        for i in range(l):\n            for j in range(i + 1, l):\n                ni, nj = ckey[i], ckey[j]\n                nk = target - ni - nj\n                if ni < nj < nk <= 100:\n                    res += counter[ni] * counter[nj] * counter[nk]\n        return res % (10**9 + 7)\n        # while i < l:\n        #     j = i\n        #     while j < l:\n        #         ni, nj = ckey[i], ckey[j]\n        #         nk = target - ni - nj\n        #         if ni == nk == nj:\n        #             res += math.comb(counter[ni], 3)\n        #         elif nj == nk:\n        #             res += math.comb(counter[nj], 2) * counter[ni]\n        #         elif ni == nk:\n        #             res += math.comb(counter[nk], 2) * counter[nj]\n        #         elif ni == nj:\n        #             res += math.comb(counter[ni], 2) * counter[nk]\n        #         else:\n        #             res += counter[ni] * counter[nj] * counter[nk]\n        #         print(ni, nj, nk, res)\n        #         j += 1\n        #     i += 1\n        # return res % (10**9 + 7)\n
class Solution:\n     def expandIsland(self, grid, i, j):\n         edges = [(i, j)]\n         while edges:\n             next_edges = []\n             for edge in edges:\n                 ei, ej = edge\n                 if ei >= 0 and ei < len(grid) and ej >= 0 and ej < len(grid[ei]) and grid[ei][ej] == '1':\n                     grid[ei][ej] = '2'\n                     next_edges.append((ei + 1, ej))\n                     next_edges.append((ei, ej + 1))\n                     next_edges.append((ei - 1, ej))\n                     next_edges.append((ei, ej - 1))\n             edges = next_edges\n     \n     def numIslands(self, grid):\n         """\n         :type grid: List[List[str]]\n         :rtype: int\n         """\n         island_count = 0\n         for i in range(len(grid)):\n             for j in range(len(grid[i])):\n                 if grid[i][j] == '1':\n                     island_count += 1\n                     self.expandIsland(grid, i, j)\n         return island_count
class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        \n        dq = collections.deque([start])\n        visited = set([start])\n        \n        while dq:\n            \n            curr = dq.pop()\n            \n            if arr[curr] == 0:\n                return True\n            \n            if (curr + arr[curr]) not in visited and (curr + arr[curr]) < len(arr):\n                dq.appendleft(curr + arr[curr])\n                visited.add(curr + arr[curr])\n            if (curr - arr[curr]) not in visited and (curr - arr[curr]) >= 0:\n                dq.appendleft(curr - arr[curr])\n                visited.add(curr - arr[curr])\n        \n        return False
class Solution:\n    def countTriplets(self, arr: List[int]) -> int:\n        n = len(arr)\n        res = xors = 0\n        freq = collections.defaultdict(int, {0:1})\n        _sum = collections.defaultdict(int)\n        for i in range(n):\n            xors ^= arr[i]\n            res += freq[xors] * i - _sum[xors]\n            freq[xors] += 1\n            _sum[xors] += i+1\n                \n        return res\n                \n
class Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        let=Counter(letters)\n        sc={}\n        for i in range(26):\n            sc[chr(i+ord('a'))]=score[i]\n        word={}\n        for w in words:\n            word[w]=Counter(w)\n        self.ans=0\n        used=[]\n        def run(x,cur,let):\n            if x==len(words):\n                return\n            for i in range(x,len(words)):\n                if i not in used:\n                    tmp=dict(let)\n                    bx=True\n                    d=0\n                    for k,v in word[words[i]].items():\n                        if k not in let:\n                            bx=False\n                            break\n                        let[k]-=v\n                        d+=(sc[k]*v)\n                        if let[k]<0:\n                            bx=False\n                            break\n                    if bx:\n                        used.append(i)\n                        run(i+1,cur+d,let)\n                        if cur+d>self.ans:\n                            self.ans=max(self.ans,cur+d)\n                        used.pop()\n                        let=tmp\n                    let=tmp\n        run(0,0,let)\n        return self.ans
class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        # B: partial sum of A\n        # C: partial sum of B\n        # Use prefix sum to precompute B and C\n        A = nums\n        B, C = [0] * (n + 1), [0] * (n + 1)\n        for i in range(n):\n            B[i + 1] = B[i] + A[i]\n            C[i + 1] = C[i] + B[i + 1]\n\n        # Use two pointer to\n        # calculate the total number of cases if B[j] - B[i] <= score\n        def count_sum_under(score):\n            res = i = 0\n            for j in range(n + 1):\n                while B[j] - B[i] > score:\n                    i += 1\n                res += j - i\n            return res\n\n        # calculate the sum for all numbers whose indices are <= index k\n        def sum_k_sums(k):\n            score = kth_score(k)\n            res = i = 0\n            for j in range(n + 1):\n                # Proceed until B[i] and B[j] are within score\n                while B[j] - B[i] > score:\n                    i += 1\n                res += B[j] * (j - i + 1) - (C[j] - (C[i - 1] if i else 0))\n            return res - (count_sum_under(score) - k) * score\n\n        # use bisearch to find how many numbers ae below k\n        def kth_score(k):\n            l, r = 0, B[n]\n            while l < r:\n                m = (l + r) // 2\n                if count_sum_under(m) < k:\n                    l = m + 1\n                else:\n                    r = m\n            return l\n\n        # result between left and right can be converted to [0, right] - [0, left-1] (result below right - result below left-1)\n        return (sum_k_sums(right) - sum_k_sums(left - 1))%(10**9 + 7)
class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        if not position:\n            return 0\n        \n        posToSpeed = {position[i]: speed[i] for i in range(len(position))}\n        position.sort()\n        \n        leaderTime = (target - position[-1]) / posToSpeed[position[-1]]\n        currGroups = 1\n        for i in range(len(position) - 2, -1, -1):\n            currTime = (target - position[i]) / posToSpeed[position[i]]\n            if currTime > leaderTime:\n                currGroups += 1\n                leaderTime = currTime\n        \n        return currGroups
class Solution:\n    def findKthBit(self, n: int, k: int) -> str:\n        i = n - 1\n        invert = False\n        while i > 0:\n            half_len = (2**(i + 1) - 1) // 2 \n            if k == half_len + 1:\n                return '1' if not invert else '0'\n            \n            if k > half_len:\n                k = half_len - (k - half_len - 1) + 1\n                invert = not invert\n            i -= 1\n        \n        return '1' if invert else '0'
class Solution:\n     def singleNumber(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         a = set(nums)\n         a = sum(a)*3 - sum(nums)\n         return int(a/2)
class Solution:\n     def leastBricks(self, wall):\n         """\n         :type wall: List[List[int]]\n         :rtype: int\n         """\n         d = {}\n         for i in wall:\n             suma = 0\n             for j in range(len(i)-1):\n                 suma += i[j]\n                 if suma in d:\n                     d[suma] += 1\n                 else:\n                     d[suma] = 1\n         if len(d) == 0:\n             return len(wall)\n         return len(wall) - max(d.values())\n
# https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/discuss/569521/7-python-approaches-with-Time-and-Space-analysis\nclass Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        r = min(arrLen, steps // 2 + 1)\n        dp = [0, 1]\n        for t in range(steps):\n            dp[1:] = [sum(dp[i-1:i+2]) for i in range(1, min(r+1, t+3))]\n        return dp[1] % (10**9+7)
class Solution(object):\n     def threeSumClosest(self, nums, target):\n         """\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         """\n         size = len(nums)\n         if size < 3:\n             return 0\n         nums.sort()\n         i = 0 # fix the first index\n         ans = nums[0] + nums[1] + nums[size - 1] # ans is used to record the solution\n         while i < size - 2:\n             tmp = target - nums[i]\n             j = i + 1\n             k = size - 1\n             while j < k:\n                 if nums[j] + nums[k] == tmp:\n                     return target\n                 if nums[j] + nums[k] > tmp:\n                     if nums[j] + nums[j + 1] >= tmp:\n                         if nums[j] + nums[j + 1] - tmp < abs(ans - target):\n                             ans = nums[i] + nums[j] + nums[j + 1]\n                         break\n                     tmpans = nums[i] + nums[j] + nums[k]\n                     if tmpans - target < abs(ans - target):\n                         ans = tmpans\n                     k -= 1\n                 else:\n                     if nums[k] + nums[k - 1] <= tmp:\n                         if tmp - nums[k] -nums[k - 1] < abs(ans - target):\n                             ans = nums[i] + nums[k - 1] + nums[k]\n                         break\n                     tmpans = nums[i] + nums[j] + nums[k]\n                     if target - tmpans < abs(ans - target):\n                         ans = tmpans\n                     j += 1\n             i += 1\n             if ans == target:\n                 return target\n         return ans
class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        if not arr: return 0\n        \n        res = []\n\n        while len(arr) > 1:\n            temp_res = []\n            temp_res = [arr[i]*arr[i+1] for i in range(len(arr)-1)]\n            idx = temp_res.index(min(temp_res))\n\n            res.append(temp_res[idx])\n            arr.pop(idx if arr[idx] < arr[idx+1] else idx+1)\n                \n            # left = arr[0] * arr[1]\n            # right = arr[-1] * arr[-2]\n            # if left < right:\n            #     res.append(left)\n            #     arr.pop(1 if arr[1] < arr[0] else 0)\n            # elif right < left:\n            #     res.append(right)\n            #     arr.pop(-2 if arr[-2] < arr[-1] else -1)\n            # else:\n            #     res.append(left)\n            #     if max(arr[0], arr[1]) > max(arr[-1], arr[-2]):\n            #         arr.pop(-2 if arr[-2] < arr[-1] else -1)\n            #     else:\n            #         arr.pop(1 if arr[1] < arr[0] else 0)\n        \n        return sum(res)
class Solution:\n     def maxArea(self, height):\n         """\n         :type height: List[int]\n         :rtype: int\n         """\n         # l = []\n         # maxH = 0\n         # for i in range(len(height)-1, -1, -1):\n         #     if height[i] > maxH:\n         #         maxH = height[i]\n         #         l.append((i, maxH))\n         # maxArea = 0\n         # for i in range(len(height)):\n         #     for jl in l:\n         #         if i >= jl[0]:\n         #             break\n         #         area = (jl[0] - i) * min(height[i], jl[1])\n         #         if area > maxArea:\n         #             maxArea = area\n         # return maxArea\n         \n         left = 0\n         right = len(height) - 1\n         if height[left] > height[right]:\n             minH = height[right]\n             minIndex = right\n         else:\n             minH = height[left]\n             minIndex = left\n         area = (right - left) * minH\n         maxArea = area\n         \n         while left != right:\n             if minIndex == left:\n                 while left != right:\n                     left += 1\n                     if height[left] > minH:\n                         if height[left] > height[right]:\n                             minH = height[right]\n                             minIndex = right\n                         else:\n                             minH = height[left]\n                             minIndex = left\n                         break\n                 area = (right - left) * minH\n             else:\n                 while left != right:\n                     right -= 1\n                     if height[right] > minH:\n                         if height[right] > height[left]:\n                             minH = height[left]\n                             minIndex = left\n                         else:\n                             minH = height[right]\n                             minIndex = right\n                         break\n                 area = (right - left) * minH\n             if area > maxArea:\n                 maxArea = area\n         return maxArea
import bisect\n\n\nclass Solution:\n    def primePalindrome(self, N: int) -> int:\n        return primes[bisect.bisect_left(primes, N)]\n\n\nprimes = [\n    2,\n    3,\n    5,\n    7,\n    11,\n    101,\n    131,\n    151,\n    181,\n    191,\n    313,\n    353,\n    373,\n    383,\n    727,\n    757,\n    787,\n    797,\n    919,\n    929,\n    10301,\n    10501,\n    10601,\n    11311,\n    11411,\n    12421,\n    12721,\n    12821,\n    13331,\n    13831,\n    13931,\n    14341,\n    14741,\n    15451,\n    15551,\n    16061,\n    16361,\n    16561,\n    16661,\n    17471,\n    17971,\n    18181,\n    18481,\n    19391,\n    19891,\n    19991,\n    30103,\n    30203,\n    30403,\n    30703,\n    30803,\n    31013,\n    31513,\n    32323,\n    32423,\n    33533,\n    34543,\n    34843,\n    35053,\n    35153,\n    35353,\n    35753,\n    36263,\n    36563,\n    37273,\n    37573,\n    38083,\n    38183,\n    38783,\n    39293,\n    70207,\n    70507,\n    70607,\n    71317,\n    71917,\n    72227,\n    72727,\n    73037,\n    73237,\n    73637,\n    74047,\n    74747,\n    75557,\n    76367,\n    76667,\n    77377,\n    77477,\n    77977,\n    78487,\n    78787,\n    78887,\n    79397,\n    79697,\n    79997,\n    90709,\n    91019,\n    93139,\n    93239,\n    93739,\n    94049,\n    94349,\n    94649,\n    94849,\n    94949,\n    95959,\n    96269,\n    96469,\n    96769,\n    97379,\n    97579,\n    97879,\n    98389,\n    98689,\n    1003001,\n    1008001,\n    1022201,\n    1028201,\n    1035301,\n    1043401,\n    1055501,\n    1062601,\n    1065601,\n    1074701,\n    1082801,\n    1085801,\n    1092901,\n    1093901,\n    1114111,\n    1117111,\n    1120211,\n    1123211,\n    1126211,\n    1129211,\n    1134311,\n    1145411,\n    1150511,\n    1153511,\n    1160611,\n    1163611,\n    1175711,\n    1177711,\n    1178711,\n    1180811,\n    1183811,\n    1186811,\n    1190911,\n    1193911,\n    1196911,\n    1201021,\n    1208021,\n    1212121,\n    1215121,\n    1218121,\n    1221221,\n    1235321,\n    1242421,\n    1243421,\n    1245421,\n    1250521,\n    1253521,\n    1257521,\n    1262621,\n    1268621,\n    1273721,\n    1276721,\n    1278721,\n    1280821,\n    1281821,\n    1286821,\n    1287821,\n    1300031,\n    1303031,\n    1311131,\n    1317131,\n    1327231,\n    1328231,\n    1333331,\n    1335331,\n    1338331,\n    1343431,\n    1360631,\n    1362631,\n    1363631,\n    1371731,\n    1374731,\n    1390931,\n    1407041,\n    1409041,\n    1411141,\n    1412141,\n    1422241,\n    1437341,\n    1444441,\n    1447441,\n    1452541,\n    1456541,\n    1461641,\n    1463641,\n    1464641,\n    1469641,\n    1486841,\n    1489841,\n    1490941,\n    1496941,\n    1508051,\n    1513151,\n    1520251,\n    1532351,\n    1535351,\n    1542451,\n    1548451,\n    1550551,\n    1551551,\n    1556551,\n    1557551,\n    1565651,\n    1572751,\n    1579751,\n    1580851,\n    1583851,\n    1589851,\n    1594951,\n    1597951,\n    1598951,\n    1600061,\n    1609061,\n    1611161,\n    1616161,\n    1628261,\n    1630361,\n    1633361,\n    1640461,\n    1643461,\n    1646461,\n    1654561,\n    1657561,\n    1658561,\n    1660661,\n    1670761,\n    1684861,\n    1685861,\n    1688861,\n    1695961,\n    1703071,\n    1707071,\n    1712171,\n    1714171,\n    1730371,\n    1734371,\n    1737371,\n    1748471,\n    1755571,\n    1761671,\n    1764671,\n    1777771,\n    1793971,\n    1802081,\n    1805081,\n    1820281,\n    1823281,\n    1824281,\n    1826281,\n    1829281,\n    1831381,\n    1832381,\n    1842481,\n    1851581,\n    1853581,\n    1856581,\n    1865681,\n    1876781,\n    1878781,\n    1879781,\n    1880881,\n    1881881,\n    1883881,\n    1884881,\n    1895981,\n    1903091,\n    1908091,\n    1909091,\n    1917191,\n    1924291,\n    1930391,\n    1936391,\n    1941491,\n    1951591,\n    1952591,\n    1957591,\n    1958591,\n    1963691,\n    1968691,\n    1969691,\n    1970791,\n    1976791,\n    1981891,\n    1982891,\n    1984891,\n    1987891,\n    1988891,\n    1993991,\n    1995991,\n    1998991,\n    3001003,\n    3002003,\n    3007003,\n    3016103,\n    3026203,\n    3064603,\n    3065603,\n    3072703,\n    3073703,\n    3075703,\n    3083803,\n    3089803,\n    3091903,\n    3095903,\n    3103013,\n    3106013,\n    3127213,\n    3135313,\n    3140413,\n    3155513,\n    3158513,\n    3160613,\n    3166613,\n    3181813,\n    3187813,\n    3193913,\n    3196913,\n    3198913,\n    3211123,\n    3212123,\n    3218123,\n    3222223,\n    3223223,\n    3228223,\n    3233323,\n    3236323,\n    3241423,\n    3245423,\n    3252523,\n    3256523,\n    3258523,\n    3260623,\n    3267623,\n    3272723,\n    3283823,\n    3285823,\n    3286823,\n    3288823,\n    3291923,\n    3293923,\n    3304033,\n    3305033,\n    3307033,\n    3310133,\n    3315133,\n    3319133,\n    3321233,\n    3329233,\n    3331333,\n    3337333,\n    3343433,\n    3353533,\n    3362633,\n    3364633,\n    3365633,\n    3368633,\n    3380833,\n    3391933,\n    3392933,\n    3400043,\n    3411143,\n    3417143,\n    3424243,\n    3425243,\n    3427243,\n    3439343,\n    3441443,\n    3443443,\n    3444443,\n    3447443,\n    3449443,\n    3452543,\n    3460643,\n    3466643,\n    3470743,\n    3479743,\n    3485843,\n    3487843,\n    3503053,\n    3515153,\n    3517153,\n    3528253,\n    3541453,\n    3553553,\n    3558553,\n    3563653,\n    3569653,\n    3586853,\n    3589853,\n    3590953,\n    3591953,\n    3594953,\n    3601063,\n    3607063,\n    3618163,\n    3621263,\n    3627263,\n    3635363,\n    3643463,\n    3646463,\n    3670763,\n    3673763,\n    3680863,\n    3689863,\n    3698963,\n    3708073,\n    3709073,\n    3716173,\n    3717173,\n    3721273,\n    3722273,\n    3728273,\n    3732373,\n    3743473,\n    3746473,\n    3762673,\n    3763673,\n    3765673,\n    3768673,\n    3769673,\n    3773773,\n    3774773,\n    3781873,\n    3784873,\n    3792973,\n    3793973,\n    3799973,\n    3804083,\n    3806083,\n    3812183,\n    3814183,\n    3826283,\n    3829283,\n    3836383,\n    3842483,\n    3853583,\n    3858583,\n    3863683,\n    3864683,\n    3867683,\n    3869683,\n    3871783,\n    3878783,\n    3893983,\n    3899983,\n    3913193,\n    3916193,\n    3918193,\n    3924293,\n    3927293,\n    3931393,\n    3938393,\n    3942493,\n    3946493,\n    3948493,\n    3964693,\n    3970793,\n    3983893,\n    3991993,\n    3994993,\n    3997993,\n    3998993,\n    7014107,\n    7035307,\n    7036307,\n    7041407,\n    7046407,\n    7057507,\n    7065607,\n    7069607,\n    7073707,\n    7079707,\n    7082807,\n    7084807,\n    7087807,\n    7093907,\n    7096907,\n    7100017,\n    7114117,\n    7115117,\n    7118117,\n    7129217,\n    7134317,\n    7136317,\n    7141417,\n    7145417,\n    7155517,\n    7156517,\n    7158517,\n    7159517,\n    7177717,\n    7190917,\n    7194917,\n    7215127,\n    7226227,\n    7246427,\n    7249427,\n    7250527,\n    7256527,\n    7257527,\n    7261627,\n    7267627,\n    7276727,\n    7278727,\n    7291927,\n    7300037,\n    7302037,\n    7310137,\n    7314137,\n    7324237,\n    7327237,\n    7347437,\n    7352537,\n    7354537,\n    7362637,\n    7365637,\n    7381837,\n    7388837,\n    7392937,\n    7401047,\n    7403047,\n    7409047,\n    7415147,\n    7434347,\n    7436347,\n    7439347,\n    7452547,\n    7461647,\n    7466647,\n    7472747,\n    7475747,\n    7485847,\n    7486847,\n    7489847,\n    7493947,\n    7507057,\n    7508057,\n    7518157,\n    7519157,\n    7521257,\n    7527257,\n    7540457,\n    7562657,\n    7564657,\n    7576757,\n    7586857,\n    7592957,\n    7594957,\n    7600067,\n    7611167,\n    7619167,\n    7622267,\n    7630367,\n    7632367,\n    7644467,\n    7654567,\n    7662667,\n    7665667,\n    7666667,\n    7668667,\n    7669667,\n    7674767,\n    7681867,\n    7690967,\n    7693967,\n    7696967,\n    7715177,\n    7718177,\n    7722277,\n    7729277,\n    7733377,\n    7742477,\n    7747477,\n    7750577,\n    7758577,\n    7764677,\n    7772777,\n    7774777,\n    7778777,\n    7782877,\n    7783877,\n    7791977,\n    7794977,\n    7807087,\n    7819187,\n    7820287,\n    7821287,\n    7831387,\n    7832387,\n    7838387,\n    7843487,\n    7850587,\n    7856587,\n    7865687,\n    7867687,\n    7868687,\n    7873787,\n    7884887,\n    7891987,\n    7897987,\n    7913197,\n    7916197,\n    7930397,\n    7933397,\n    7935397,\n    7938397,\n    7941497,\n    7943497,\n    7949497,\n    7957597,\n    7958597,\n    7960697,\n    7977797,\n    7984897,\n    7985897,\n    7987897,\n    7996997,\n    9002009,\n    9015109,\n    9024209,\n    9037309,\n    9042409,\n    9043409,\n    9045409,\n    9046409,\n    9049409,\n    9067609,\n    9073709,\n    9076709,\n    9078709,\n    9091909,\n    9095909,\n    9103019,\n    9109019,\n    9110119,\n    9127219,\n    9128219,\n    9136319,\n    9149419,\n    9169619,\n    9173719,\n    9174719,\n    9179719,\n    9185819,\n    9196919,\n    9199919,\n    9200029,\n    9209029,\n    9212129,\n    9217129,\n    9222229,\n    9223229,\n    9230329,\n    9231329,\n    9255529,\n    9269629,\n    9271729,\n    9277729,\n    9280829,\n    9286829,\n    9289829,\n    9318139,\n    9320239,\n    9324239,\n    9329239,\n    9332339,\n    9338339,\n    9351539,\n    9357539,\n    9375739,\n    9384839,\n    9397939,\n    9400049,\n    9414149,\n    9419149,\n    9433349,\n    9439349,\n    9440449,\n    9446449,\n    9451549,\n    9470749,\n    9477749,\n    9492949,\n    9493949,\n    9495949,\n    9504059,\n    9514159,\n    9526259,\n    9529259,\n    9547459,\n    9556559,\n    9558559,\n    9561659,\n    9577759,\n    9583859,\n    9585859,\n    9586859,\n    9601069,\n    9602069,\n    9604069,\n    9610169,\n    9620269,\n    9624269,\n    9626269,\n    9632369,\n    9634369,\n    9645469,\n    9650569,\n    9657569,\n    9670769,\n    9686869,\n    9700079,\n    9709079,\n    9711179,\n    9714179,\n    9724279,\n    9727279,\n    9732379,\n    9733379,\n    9743479,\n    9749479,\n    9752579,\n    9754579,\n    9758579,\n    9762679,\n    9770779,\n    9776779,\n    9779779,\n    9781879,\n    9782879,\n    9787879,\n    9788879,\n    9795979,\n    9801089,\n    9807089,\n    9809089,\n    9817189,\n    9818189,\n    9820289,\n    9822289,\n    9836389,\n    9837389,\n    9845489,\n    9852589,\n    9871789,\n    9888889,\n    9889889,\n    9896989,\n    9902099,\n    9907099,\n    9908099,\n    9916199,\n    9918199,\n    9919199,\n    9921299,\n    9923299,\n    9926299,\n    9927299,\n    9931399,\n    9932399,\n    9935399,\n    9938399,\n    9957599,\n    9965699,\n    9978799,\n    9980899,\n    9981899,\n    9989899,\n    100030001,\n    100050001,\n    100060001,\n    100111001,\n    100131001,\n    100161001,\n    100404001,\n    100656001,\n    100707001,\n    100767001,\n    100888001,\n    100999001,\n    101030101,\n    101060101,\n    101141101,\n    101171101,\n    101282101,\n    101292101,\n    101343101,\n    101373101,\n    101414101,\n    101424101,\n    101474101,\n    101595101,\n    101616101,\n    101717101,\n    101777101,\n    101838101,\n    101898101,\n    101919101,\n    101949101,\n    101999101,\n    102040201,\n    102070201,\n    102202201,\n    102232201,\n    102272201,\n    102343201,\n    102383201,\n    102454201,\n    102484201,\n    102515201,\n    102676201,\n    102686201,\n    102707201,\n    102808201,\n    102838201,\n    103000301,\n    103060301,\n    103161301,\n    103212301,\n    103282301,\n    103303301,\n    103323301,\n    103333301,\n    103363301,\n    103464301,\n    103515301,\n    103575301,\n    103696301,\n    103777301,\n    103818301,\n    103828301,\n    103909301,\n    103939301,\n    104000401,\n    104030401,\n    104040401,\n    104111401,\n    104222401,\n    104282401,\n    104333401,\n    104585401,\n    104616401,\n    104787401,\n    104838401,\n    104919401,\n    104949401,\n    105121501,\n    105191501,\n    105202501,\n    105262501,\n    105272501,\n    105313501,\n    105323501,\n    105343501,\n    105575501,\n    105616501,\n    105656501,\n    105757501,\n    105818501,\n    105868501,\n    105929501,\n    106060601,\n    106111601,\n    106131601,\n    106191601,\n    106222601,\n    106272601,\n    106353601,\n    106444601,\n    106464601,\n    106545601,\n    106555601,\n    106717601,\n    106909601,\n    106929601,\n    107000701,\n    107070701,\n    107121701,\n    107232701,\n    107393701,\n    107414701,\n    107424701,\n    107595701,\n    107636701,\n    107646701,\n    107747701,\n    107757701,\n    107828701,\n    107858701,\n    107868701,\n    107888701,\n    107939701,\n    107949701,\n    108070801,\n    108101801,\n    108121801,\n    108151801,\n    108212801,\n    108323801,\n    108373801,\n    108383801,\n    108434801,\n    108464801,\n    108484801,\n    108494801,\n    108505801,\n    108565801,\n    108686801,\n    108707801,\n    108767801,\n    108838801,\n    108919801,\n    108959801,\n    109000901,\n    109101901,\n    109111901,\n    109161901,\n    109333901,\n    109404901,\n    109434901,\n    109444901,\n    109474901,\n    109575901,\n    109656901,\n    109747901,\n    109777901,\n    109797901,\n    109818901,\n    109909901,\n    109929901,\n    110111011,\n    110232011,\n    110252011,\n    110343011,\n    110424011,\n    110505011,\n    110565011,\n    110676011,\n    110747011,\n    110757011,\n    110909011,\n    110949011,\n    110999011,\n    111010111,\n    111020111,\n    111050111,\n    111070111,\n    111181111,\n    111191111,\n    111262111,\n    111272111,\n    111454111,\n    111484111,\n    111515111,\n    111616111,\n    111686111,\n    111757111,\n    111848111,\n    112030211,\n    112060211,\n    112111211,\n    112161211,\n    112171211,\n    112212211,\n    112434211,\n    112494211,\n    112545211,\n    112636211,\n    112878211,\n    112959211,\n    112969211,\n    112989211,\n    113030311,\n    113090311,\n    113111311,\n    113262311,\n    113282311,\n    113474311,\n    113535311,\n    113565311,\n    113616311,\n    113636311,\n    113888311,\n    113939311,\n    114040411,\n    114191411,\n    114232411,\n    114353411,\n    114383411,\n    114484411,\n    114494411,\n    114535411,\n    114727411,\n    114808411,\n    114818411,\n    114848411,\n    114878411,\n    114898411,\n    115000511,\n    115020511,\n    115060511,\n    115111511,\n    115141511,\n    115191511,\n    115212511,\n    115222511,\n    115404511,\n    115464511,\n    115545511,\n    115636511,\n    115737511,\n    115767511,\n    115797511,\n    115828511,\n    115959511,\n    116000611,\n    116010611,\n    116040611,\n    116424611,\n    116505611,\n    116646611,\n    116696611,\n    116757611,\n    116777611,\n    116828611,\n    116868611,\n    116919611,\n    117070711,\n    117101711,\n    117262711,\n    117272711,\n    117323711,\n    117484711,\n    117505711,\n    117515711,\n    117616711,\n    117686711,\n    117757711,\n    117767711,\n    117797711,\n    117818711,\n    117959711,\n    118252811,\n    118272811,\n    118414811,\n    118464811,\n    118525811,\n    118626811,\n    118686811,\n    118696811,\n    118717811,\n    118818811,\n    118848811,\n    118909811,\n    118959811,\n    119010911,\n    119171911,\n    119202911,\n    119343911,\n    119363911,\n    119454911,\n    119585911,\n    119595911,\n    119646911,\n    119676911,\n    119696911,\n    119717911,\n    119787911,\n    119868911,\n    119888911,\n    119969911,\n    120191021,\n    120242021,\n    120434021,\n    120454021,\n    120494021,\n    120535021,\n    120565021,\n    120646021,\n    120808021,\n    120868021,\n    120989021,\n    121080121,\n    121111121,\n    121131121,\n    121161121,\n    121272121,\n    121282121,\n    121393121,\n    121414121,\n    121555121,\n    121747121,\n    121818121,\n    121878121,\n    121939121,\n    121989121,\n    122040221,\n    122232221,\n    122262221,\n    122292221,\n    122333221,\n    122363221,\n    122373221,\n    122393221,\n    122444221,\n    122484221,\n    122535221,\n    122696221,\n    122787221,\n    122858221,\n    122919221,\n    123161321,\n    123292321,\n    123424321,\n    123484321,\n    123494321,\n    123575321,\n    123767321,\n    123838321,\n    123989321,\n    124000421,\n    124080421,\n    124101421,\n    124131421,\n    124252421,\n    124323421,\n    124333421,\n    124434421,\n    124515421,\n    124525421,\n    124626421,\n    124656421,\n    124717421,\n    124737421,\n    124959421,\n    124989421,\n    125000521,\n    125010521,\n    125232521,\n    125252521,\n    125292521,\n    125343521,\n    125474521,\n    125505521,\n    125565521,\n    125606521,\n    125616521,\n    125757521,\n    125838521,\n    125939521,\n    125979521,\n    125999521,\n    126101621,\n    126161621,\n    126181621,\n    126202621,\n    126212621,\n    126323621,\n    126424621,\n    126484621,\n    126535621,\n    126595621,\n    126616621,\n    126676621,\n    126686621,\n    126727621,\n    126737621,\n    126757621,\n    126878621,\n    127060721,\n    127090721,\n    127131721,\n    127212721,\n    127383721,\n    127494721,\n    127545721,\n    127636721,\n    127656721,\n    127686721,\n    127717721,\n    127747721,\n    127828721,\n    127909721,\n    127929721,\n    128070821,\n    128090821,\n    128121821,\n    128181821,\n    128202821,\n    128252821,\n    128262821,\n    128282821,\n    128444821,\n    128474821,\n    128525821,\n    128535821,\n    128595821,\n    128646821,\n    128747821,\n    128787821,\n    128868821,\n    128919821,\n    128939821,\n    129080921,\n    129202921,\n    129292921,\n    129323921,\n    129373921,\n    129484921,\n    129494921,\n    129535921,\n    129737921,\n    129919921,\n    129979921,\n    130020031,\n    130030031,\n    130060031,\n    130141031,\n    130171031,\n    130222031,\n    130333031,\n    130444031,\n    130464031,\n    130545031,\n    130555031,\n    130585031,\n    130606031,\n    130636031,\n    130717031,\n    130767031,\n    130818031,\n    130828031,\n    130858031,\n    130969031,\n    131030131,\n    131111131,\n    131121131,\n    131222131,\n    131252131,\n    131333131,\n    131555131,\n    131565131,\n    131585131,\n    131646131,\n    131676131,\n    131828131,\n    132010231,\n    132191231,\n    132464231,\n    132535231,\n    132595231,\n    132646231,\n    132676231,\n    132757231,\n    133020331,\n    133060331,\n    133111331,\n    133161331,\n    133252331,\n    133474331,\n    133494331,\n    133575331,\n    133686331,\n    133767331,\n    133818331,\n    133909331,\n    134090431,\n    134181431,\n    134232431,\n    134424431,\n    134505431,\n    134525431,\n    134535431,\n    134616431,\n    134757431,\n    134808431,\n    134858431,\n    134888431,\n    134909431,\n    134919431,\n    134979431,\n    135010531,\n    135040531,\n    135101531,\n    135121531,\n    135161531,\n    135262531,\n    135434531,\n    135494531,\n    135515531,\n    135626531,\n    135646531,\n    135707531,\n    135838531,\n    135868531,\n    135878531,\n    135929531,\n    135959531,\n    135979531,\n    136090631,\n    136171631,\n    136222631,\n    136252631,\n    136303631,\n    136363631,\n    136474631,\n    136545631,\n    136737631,\n    136797631,\n    136818631,\n    136909631,\n    136969631,\n    137030731,\n    137040731,\n    137060731,\n    137090731,\n    137151731,\n    137171731,\n    137232731,\n    137282731,\n    137333731,\n    137363731,\n    137424731,\n    137474731,\n    137606731,\n    137636731,\n    137696731,\n    137757731,\n    137808731,\n    137838731,\n    137939731,\n    137999731,\n    138040831,\n    138131831,\n    138242831,\n    138292831,\n    138313831,\n    138383831,\n    138454831,\n    138575831,\n    138616831,\n    138646831,\n    138757831,\n    138898831,\n    138959831,\n    138989831,\n    139131931,\n    139161931,\n    139222931,\n    139252931,\n    139282931,\n    139383931,\n    139474931,\n    139515931,\n    139606931,\n    139626931,\n    139717931,\n    139848931,\n    139959931,\n    139969931,\n    139999931,\n    140000041,\n    140030041,\n    140151041,\n    140303041,\n    140505041,\n    140565041,\n    140606041,\n    140777041,\n    140787041,\n    140828041,\n    140868041,\n    140898041,\n    141020141,\n    141070141,\n    141131141,\n    141151141,\n    141242141,\n    141262141,\n    141313141,\n    141343141,\n    141383141,\n    141484141,\n    141494141,\n    141575141,\n    141595141,\n    141616141,\n    141767141,\n    141787141,\n    141848141,\n    142000241,\n    142030241,\n    142080241,\n    142252241,\n    142272241,\n    142353241,\n    142363241,\n    142464241,\n    142545241,\n    142555241,\n    142686241,\n    142707241,\n    142797241,\n    142858241,\n    142888241,\n    143090341,\n    143181341,\n    143262341,\n    143303341,\n    143454341,\n    143474341,\n    143585341,\n    143636341,\n    143787341,\n    143828341,\n    143919341,\n    143969341,\n    144010441,\n    144020441,\n    144202441,\n    144212441,\n    144313441,\n    144353441,\n    144404441,\n    144434441,\n    144484441,\n    144505441,\n    144707441,\n    144757441,\n    144808441,\n    144818441,\n    144848441,\n    144878441,\n    144898441,\n    144979441,\n    144989441,\n    145020541,\n    145030541,\n    145090541,\n    145353541,\n    145363541,\n    145393541,\n    145464541,\n    145494541,\n    145575541,\n    145666541,\n    145767541,\n    146030641,\n    146040641,\n    146181641,\n    146222641,\n    146252641,\n    146313641,\n    146363641,\n    146505641,\n    146555641,\n    146565641,\n    146676641,\n    146858641,\n    146909641,\n    147191741,\n    147232741,\n    147242741,\n    147313741,\n    147343741,\n    147373741,\n    147434741,\n    147515741,\n    147565741,\n    147616741,\n    147686741,\n    147707741,\n    147757741,\n    147838741,\n    147929741,\n    148020841,\n    148060841,\n    148080841,\n    148414841,\n    148444841,\n    148525841,\n    148545841,\n    148585841,\n    148666841,\n    148686841,\n    148707841,\n    148818841,\n    148858841,\n    148888841,\n    148969841,\n    149000941,\n    149333941,\n    149343941,\n    149484941,\n    149535941,\n    149555941,\n    149616941,\n    149646941,\n    149696941,\n    149858941,\n    149888941,\n    149909941,\n    149919941,\n    149939941,\n    150070051,\n    150151051,\n    150181051,\n    150202051,\n    150272051,\n    150434051,\n    150494051,\n    150505051,\n    150626051,\n    150686051,\n    150727051,\n    150808051,\n    150818051,\n    150979051,\n    151080151,\n    151161151,\n    151212151,\n    151222151,\n    151282151,\n    151353151,\n    151545151,\n    151585151,\n    151656151,\n    151737151,\n    151777151,\n    151858151,\n    151878151,\n    151888151,\n    151959151,\n    151969151,\n    151999151,\n    152090251,\n    152111251,\n    152171251,\n    152181251,\n    152252251,\n    152363251,\n    152393251,\n    152454251,\n    152505251,\n    152565251,\n    152616251,\n    152646251,\n    152666251,\n    152696251,\n    152888251,\n    152939251,\n    153212351,\n    153272351,\n    153292351,\n    153313351,\n    153323351,\n    153404351,\n    153424351,\n    153454351,\n    153484351,\n    153494351,\n    153626351,\n    153808351,\n    153818351,\n    153838351,\n    153979351,\n    154030451,\n    154191451,\n    154252451,\n    154272451,\n    154303451,\n    154323451,\n    154383451,\n    154393451,\n    154474451,\n    154494451,\n    154555451,\n    154575451,\n    154989451,\n    155060551,\n    155141551,\n    155171551,\n    155292551,\n    155313551,\n    155333551,\n    155373551,\n    155424551,\n    155474551,\n    155535551,\n    155646551,\n    155666551,\n    155676551,\n    155808551,\n    155828551,\n    155868551,\n    156151651,\n    156262651,\n    156343651,\n    156424651,\n    156434651,\n    156494651,\n    156545651,\n    156595651,\n    156656651,\n    156707651,\n    156727651,\n    156757651,\n    156848651,\n    156878651,\n    156949651,\n    157090751,\n    157101751,\n    157161751,\n    157252751,\n    157393751,\n    157444751,\n    157555751,\n    157717751,\n    157878751,\n    157888751,\n    157939751,\n    157959751,\n    157989751,\n    158090851,\n    158111851,\n    158222851,\n    158252851,\n    158363851,\n    158474851,\n    158595851,\n    158676851,\n    158696851,\n    158747851,\n    158808851,\n    158858851,\n    158898851,\n    158909851,\n    159020951,\n    159040951,\n    159050951,\n    159121951,\n    159181951,\n    159191951,\n    159202951,\n    159232951,\n    159262951,\n    159292951,\n    159323951,\n    159404951,\n    159464951,\n    159565951,\n    159595951,\n    159646951,\n    159757951,\n    159808951,\n    159919951,\n    159929951,\n    159959951,\n    160020061,\n    160050061,\n    160080061,\n    160101061,\n    160131061,\n    160141061,\n    160161061,\n    160171061,\n    160393061,\n    160545061,\n    160696061,\n    160707061,\n    160717061,\n    160797061,\n    160878061,\n    161171161,\n    161282161,\n    161313161,\n    161363161,\n    161474161,\n    161484161,\n    161535161,\n    161585161,\n    161636161,\n    161787161,\n    161838161,\n    161969161,\n    162040261,\n    162232261,\n    162404261,\n    162464261,\n    162484261,\n    162565261,\n    162686261,\n    162707261,\n    162757261,\n    162898261,\n    162919261,\n    162949261,\n    162959261,\n    162979261,\n    162989261,\n    163101361,\n    163333361,\n    163434361,\n    163464361,\n    163474361,\n    163494361,\n    163515361,\n    163555361,\n    163606361,\n    163686361,\n    163696361,\n    163878361,\n    163959361,\n    164000461,\n    164070461,\n    164151461,\n    164292461,\n    164333461,\n    164454461,\n    164484461,\n    164585461,\n    164616461,\n    164696461,\n    164717461,\n    164727461,\n    164838461,\n    165101561,\n    165161561,\n    165191561,\n    165212561,\n    165343561,\n    165515561,\n    165535561,\n    165808561,\n    165878561,\n    165898561,\n    165919561,\n    165949561,\n    166000661,\n    166080661,\n    166171661,\n    166191661,\n    166404661,\n    166545661,\n    166555661,\n    166636661,\n    166686661,\n    166818661,\n    166828661,\n    166878661,\n    166888661,\n    166929661,\n    167000761,\n    167111761,\n    167262761,\n    167393761,\n    167454761,\n    167474761,\n    167484761,\n    167636761,\n    167646761,\n    167787761,\n    167888761,\n    167898761,\n    167979761,\n    168151861,\n    168191861,\n    168232861,\n    168404861,\n    168505861,\n    168515861,\n    168565861,\n    168818861,\n    168898861,\n    168929861,\n    168949861,\n    169060961,\n    169131961,\n    169141961,\n    169282961,\n    169333961,\n    169383961,\n    169464961,\n    169555961,\n    169606961,\n    169656961,\n    169666961,\n    169686961,\n    169777961,\n    169797961,\n    169858961,\n    169999961,\n    170040071,\n    170060071,\n    170232071,\n    170303071,\n    170333071,\n    170414071,\n    170424071,\n    170484071,\n    170606071,\n    170616071,\n    170646071,\n    170828071,\n    170838071,\n    170909071,\n    170979071,\n    171080171,\n    171262171,\n    171292171,\n    171343171,\n    171565171,\n    171575171,\n    171767171,\n    171919171,\n    171959171,\n    172060271,\n    172090271,\n    172161271,\n    172353271,\n    172363271,\n    172393271,\n    172474271,\n    172585271,\n    172656271,\n    172747271,\n    172767271,\n    172797271,\n    172878271,\n    172909271,\n    172959271,\n    173000371,\n    173030371,\n    173090371,\n    173252371,\n    173373371,\n    173454371,\n    173525371,\n    173585371,\n    173696371,\n    173757371,\n    173777371,\n    173828371,\n    173868371,\n    173888371,\n    173898371,\n    173919371,\n    174080471,\n    174121471,\n    174131471,\n    174181471,\n    174313471,\n    174343471,\n    174595471,\n    174646471,\n    174676471,\n    174919471,\n    174949471,\n    174979471,\n    174989471,\n    175000571,\n    175090571,\n    175101571,\n    175111571,\n    175353571,\n    175444571,\n    175555571,\n    175626571,\n    175747571,\n    175777571,\n    175848571,\n    175909571,\n    176090671,\n    176111671,\n    176141671,\n    176181671,\n    176232671,\n    176313671,\n    176333671,\n    176373671,\n    176393671,\n    176414671,\n    176585671,\n    176636671,\n    176646671,\n    176666671,\n    176696671,\n    176757671,\n    176787671,\n    176888671,\n    176898671,\n    176939671,\n    177121771,\n    177161771,\n    177202771,\n    177242771,\n    177323771,\n    177565771,\n    177616771,\n    177707771,\n    177757771,\n    177868771,\n    178101871,\n    178131871,\n    178141871,\n    178161871,\n    178353871,\n    178414871,\n    178515871,\n    178525871,\n    178656871,\n    178717871,\n    178747871,\n    178878871,\n    178969871,\n    178989871,\n    178999871,\n    179010971,\n    179060971,\n    179222971,\n    179232971,\n    179262971,\n    179414971,\n    179454971,\n    179484971,\n    179717971,\n    179777971,\n    179808971,\n    179858971,\n    179868971,\n    179909971,\n    179969971,\n    179999971,\n    180070081,\n    180101081,\n    180161081,\n    180292081,\n    180515081,\n    180535081,\n    180545081,\n    180565081,\n    180616081,\n    180757081,\n    180959081,\n    181111181,\n    181515181,\n    181545181,\n    181666181,\n    181737181,\n    181797181,\n    181888181,\n    182010281,\n    182202281,\n    182373281,\n    182585281,\n    182616281,\n    182636281,\n    182777281,\n    182858281,\n    182949281,\n    183232381,\n    183626381,\n    183656381,\n    183737381,\n    183898381,\n    183979381,\n    183989381,\n    184030481,\n    184212481,\n    184222481,\n    184303481,\n    184393481,\n    184414481,\n    184545481,\n    184585481,\n    184606481,\n    184636481,\n    184747481,\n    184818481,\n    184878481,\n    185232581,\n    185373581,\n    185393581,\n    185525581,\n    185555581,\n    185595581,\n    185676581,\n    185757581,\n    185838581,\n    185858581,\n    185868581,\n    185999581,\n    186010681,\n    186040681,\n    186050681,\n    186070681,\n    186101681,\n    186131681,\n    186151681,\n    186161681,\n    186424681,\n    186484681,\n    186505681,\n    186565681,\n    186656681,\n    186676681,\n    186787681,\n    186898681,\n    187090781,\n    187101781,\n    187111781,\n    187161781,\n    187272781,\n    187404781,\n    187434781,\n    187444781,\n    187525781,\n    187767781,\n    187909781,\n    187939781,\n    187999781,\n    188010881,\n    188060881,\n    188141881,\n    188151881,\n    188303881,\n    188373881,\n    188414881,\n    188454881,\n    188505881,\n    188525881,\n    188535881,\n    188616881,\n    188636881,\n    188646881,\n    188727881,\n    188777881,\n    188868881,\n    188888881,\n    188898881,\n    188979881,\n    189080981,\n    189131981,\n    189262981,\n    189292981,\n    189464981,\n    189535981,\n    189595981,\n    189727981,\n    189787981,\n    189838981,\n    189898981,\n    189929981,\n    190000091,\n    190020091,\n    190080091,\n    190101091,\n    190252091,\n    190404091,\n    190434091,\n    190464091,\n    190494091,\n    190656091,\n    190696091,\n    190717091,\n    190747091,\n    190777091,\n    190858091,\n    190909091,\n    191090191,\n    191171191,\n    191232191,\n    191292191,\n    191313191,\n    191565191,\n    191595191,\n    191727191,\n    191757191,\n    191838191,\n    191868191,\n    191939191,\n    191969191,\n    192101291,\n    192191291,\n    192202291,\n    192242291,\n    192313291,\n    192404291,\n    192454291,\n    192484291,\n    192767291,\n    192797291,\n    192898291,\n    193000391,\n    193030391,\n    193191391,\n    193212391,\n    193282391,\n    193303391,\n    193383391,\n    193414391,\n    193464391,\n    193555391,\n    193686391,\n    193858391,\n    193888391,\n    194000491,\n    194070491,\n    194121491,\n    194222491,\n    194232491,\n    194292491,\n    194303491,\n    194393491,\n    194505491,\n    194595491,\n    194606491,\n    194787491,\n    194939491,\n    194999491,\n    195010591,\n    195040591,\n    195070591,\n    195151591,\n    195202591,\n    195242591,\n    195353591,\n    195505591,\n    195545591,\n    195707591,\n    195767591,\n    195868591,\n    195878591,\n    195949591,\n    195979591,\n    196000691,\n    196090691,\n    196323691,\n    196333691,\n    196363691,\n    196696691,\n    196797691,\n    196828691,\n    196878691,\n    197030791,\n    197060791,\n    197070791,\n    197090791,\n    197111791,\n    197121791,\n    197202791,\n    197292791,\n    197343791,\n    197454791,\n    197525791,\n    197606791,\n    197616791,\n    197868791,\n    197898791,\n    197919791,\n    198040891,\n    198070891,\n    198080891,\n    198131891,\n    198292891,\n    198343891,\n    198353891,\n    198383891,\n    198454891,\n    198565891,\n    198656891,\n    198707891,\n    198787891,\n    198878891,\n    198919891,\n    199030991,\n    199080991,\n    199141991,\n    199171991,\n    199212991,\n    199242991,\n    199323991,\n    199353991,\n    199363991,\n    199393991,\n    199494991,\n    199515991,\n    199545991,\n    199656991,\n    199767991,\n    199909991,\n    199999991,\n]\n\n
class Solution:\n    def minKBitFlips(self, A: List[int], K: int) -> int:\n        n = len(A)\n        record = [0] * n\n        flip = 0\n        ans = 0\n        for i in range(n):\n            if i >= K: flip -= record[i-K]\n            if A[i] == (flip % 2):\n                if i > n - K: return -1\n                ans += 1\n                flip += 1\n                record[i] = 1\n        return ans\n
class Solution:\n    def queryString(self, S: str, N: int) -> bool:\n        for i in range(1,N+1):\n            b = bin(i).replace('0b','')\n            if b not in S:\n               return False\n        return True
class Solution:\n    def longestDiverseString(self, a: int, b: int, c: int) -> str:\n        if a == 0 and b == 0 and c == 0:\n            return ''\n\n        res = ''\n\n        heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n        heapq.heapify(heap)\n        prev_val = 0\n        prev_char = ''\n\n        while heap:\n            v, char = heapq.heappop(heap)\n            if prev_val < 0:\n                heapq.heappush(heap, (prev_val, prev_char))\n\n            if abs(v) >= 2:\n                if abs(v) > abs(prev_val):\n                    res += char*2\n                    v += 2\n                else:\n                    res += char\n                    v += 1\n            elif abs(v) == 1:\n                res += char\n                v +=1\n            elif abs(v) == 0:\n                break\n\n            prev_val = v\n            prev_char = char\n\n        return res
class Solution:\n     def kthSmallest(self, matrix, k):\n         """\n         :type matrix: List[List[int]]\n         :type k: int\n         :rtype: int\n         """\n         arr = []\n         for i in matrix:\n             for j in i:\n                 arr.append(j)\n         arr.sort()\n         print(arr)\n         return arr[k-1]
class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        width = 0\n        icandidate = [0]\n        for i in range(len(A)):\n            if A[i] < A[icandidate[-1]]:\n                icandidate.append(i)\n        for j in range(len(A) - 1, -1, -1):\n            while icandidate and A[icandidate[-1]] <= A[j]:\n                width = max(width, j - icandidate.pop())\n        return width
class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        def dfs(node, visited):\n            if node in visited:\n                return\n            visited.add(node)\n            for nei in rooms[node]:\n                if nei in visited:\n                    continue\n                dfs(nei,visited)\n            return\n        visited = set()\n        dfs(0, visited)\n        if len(visited) == len(rooms):\n            return True\n        else: \n            return False\n            \n
class Solution:\n     def findSubstringInWraproundString(self, p):\n         """\n         :type p: str\n         :rtype: int\n         """\n         pc = None\n         sl = 0\n         ll = {}\n         \n         for c in p:\n             if pc and (ord(pc) + 1 == ord(c) or (pc == 'z' and c == 'a')):\n                 sl += 1\n             else:\n                 sl = 1\n             ll[c] = max([ll[c], sl]) if c in ll else sl\n             pc = c\n         s = 0\n         for key, value in list(ll.items()):\n             s += value\n         return s\n         \n         \n # def unique(p):\n #   pc = None\n #   sl = 0\n #   ll = {}\n #   for c in p:\n #     if pc != None and (ord(pc) + 1 == ord(c) or (pc == 'z' and c == 'a')):\n #       sl += 1\n #     else:\n #       sl = 1\n #     ll[c] = max([ll[c], sl]) if c in ll else sl\n #     pc = c\n #   s = 0\n #   for _, v in ll.items():\n #       s += v\n #   return s\n \n # with open('/dev/stdin', 'rt') as f:\n #   line = f.readline()\n #   while line:\n #     print unique(line.rstrip())\n #     line = f.readline()\n
class Solution:\n    def strWithout3a3b(self, A: int, B: int) -> str:\n        if A >= 2*B:\n            return 'aab'* B + 'a'* (A-2*B)\n        elif A >= B:\n            return 'aab' * (A-B) + 'ab' * (2*B - A)\n        elif B >= 2*A:\n            return 'bba' * A + 'b' *(B-2*A)\n        else:\n            return 'bba' * (B-A) + 'ab' * (2*A - B)
class Solution:\n     def findTargetSumWays(self, nums, S):\n         """\n         :type nums: List[int]\n         :type S: int\n         :rtype: int\n         """\n         c = [0]*1001\n         c[0] = 1\n         T = sum(nums)\n         A = T+S\n         if T<S or A&1:\n             return 0\n         A>>=1\n         nums = sorted(nums)\n         temp = 0\n         for ind, v in enumerate(nums):\n             temp += v\n             for i in range(min(temp, A), v-1, -1):\n                 c[i] += c[i-v]\n         return c[A]
class Solution:\n    def longestDecomposition(self, text: str) -> int:\n        n = len(text)\n        splits = 0\n        leftstart, leftend = 0, 0\n        rightstart, rightend = n-1, n-1\n        while leftend<rightstart:\n            if text[leftstart:leftend+1] == text[rightstart:rightend+1]:\n                leftstart = leftend+1\n                leftend = leftstart\n                rightstart = rightstart-1\n                rightend = rightstart\n                splits+=2\n            else:\n                leftend+=1\n                rightstart-=1\n        return splits+1 if leftstart<=rightend else splits
class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        dp = {0}\n        total = sum(stones)\n        for stone in stones:\n            dp |= {_sum + stone for _sum in dp}\n        return min(abs(total - _sum - _sum) for _sum in dp)
class Solution:\n    def minIncrementForUnique(self, A: List[int]) -> int:\n        if not A:\n            return 0\n        \n        A.sort()\n        prev = A[0]\n        res = 0\n        for num in A[1:]:\n            if num <= prev:\n                prev += 1\n                res += prev-num\n\n            else:\n                prev = num\n        \n        return res\n
class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        # max profit ending at time t\n        dp = [(0,0)]\n        \n        task = [(startTime[i], endTime[i], profit[i]) for i in range(len(startTime))]\n        task = sorted(task, key = lambda x: x[1])\n        \n        for s, e, p in task:\n            noTaskProf = dp[-1][1]\n            for end, pro in reversed(dp):\n                # end, pro = dp[i]\n                if end <= s:\n                    doTaskProf = pro + p\n                    break\n            if doTaskProf > noTaskProf:\n                dp.append((e, doTaskProf))\n        return dp[-1][1]\n        \n        \n        \n
class Solution:\n     def rob(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         if not nums:\n             return 0\n         if len(nums)==1:\n             return nums[0]\n         return max(self.helper(nums[1:]), self.helper(nums[:-1]))\n         \n     def helper(self,nums):\n         now = prev = 0\n         for nxt in nums:\n             now, prev = max(nxt+prev, now), now\n         return now\n
class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        prev = -1\n        ans = 0\n        for num in target:\n            if prev == -1:\n                prev = num\n                ans += num\n                continue\n            if num > prev:\n                ans += (num - prev)\n            #print(ans, num, prev)\n            prev = num\n        return ans
class Solution:\n     def calculate(self, s):\n         """\n         :type s: str\n         :rtype: int\n         """\n         \n         if not s:\n             return 0\n         \n         pre_op = '+'\n         stack = [0]\n         cur_num = 0\n         digits = '0123456789'\n         s += '#'\n         \n         for c in s:\n             if c == ' ':\n                 continue\n             \n             if c in digits:\n                 cur_num = cur_num * 10 + int(c)\n                 continue\n                 \n             if pre_op == '-':\n                 cur_num *= -1\n             elif pre_op == '*':\n                 cur_num *= stack.pop()\n             elif pre_op == '/':\n                 if cur_num == 0:\n                     return None\n                 \n                 pre_num = stack.pop()\n                 flag = 1 if pre_num > 0 else -1\n                 cur_num = abs(pre_num) // cur_num * flag\n                 \n             stack.append(cur_num)\n             pre_op = c\n             cur_num = 0\n             \n         return sum(stack)\n                 \n         \n         \n
class Solution:\n     def shortestPalindrome(self, s):\n         if len(s)<2:\n             return s\n         if len(s)==40002:\n             return s[20000:][::-1]+s\n         for i in range(len(s)-1,-1,-1):\n             if s[i]==s[0]:\n                 j=0\n                 while j<(i+1)//2 and s[i-j]==s[j]:\n                     j+=1\n                 if j>=(i+1)//2:\n                     return s[i+1:][::-1]+s
class Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        # 1. Color each component.\n        # colors[node] = the color of this node.\n\n        N = len(graph)\n        colors = {}\n        c = 0\n\n        def dfs(node, color):\n            colors[node] = color\n            for nei, adj in enumerate(graph[node]):\n                if adj and nei not in colors:\n                    dfs(nei, color)\n\n        for node in range(N):\n            if node not in colors:\n                dfs(node, c)\n                c += 1\n\n        # 2. Size of each color.\n        # size[color] = number of occurrences of this color.\n        size = collections.Counter(colors.values())\n\n        # 3. Find unique colors.\n        color_count = collections.Counter()\n        for node in initial:\n            color_count[colors[node]] += 1\n\n        # 4. Answer\n        ans = float('inf')\n        for x in initial:\n            c = colors[x]\n            if color_count[c] == 1:\n                if ans == float('inf'):\n                    ans = x\n                elif size[c] > size[colors[ans]]:\n                    ans = x\n                elif size[c] == size[colors[ans]] and x < ans:\n                    ans = x\n\n        return ans if ans < float('inf') else min(initial)    
class Solution:\n    def arrangeWords(self, text: str) -> str:\n        p=text.split(' ')\n        final=''\n        j=sorted(p,key=len)\n        temp=' '.join(j)\n        if temp[0]>='a' and temp[0]<='z':\n            s=temp[0].swapcase()\n            final=final+s[0]\n        else:\n            final=final+temp[0]\n        for i in range(1,len(temp)):\n            if temp[i]>='A' and temp[i]<='Z':\n                s=temp[i].swapcase()\n                final=final+s[0]\n            else:\n                final=final+temp[i]\n        return final\n        \n
class Solution:\n    def reverseParentheses(self, s: str) -> str:\n        \n        \n        stack = []\n        curr = ''\n        for c in s:\n            if c=='(':\n                stack.append(curr)\n                curr = ''\n                stack.append('(')\n            elif c==')':\n                stack.append(curr)\n                curr = ''\n                aux = ''\n                while stack and stack[-1]!='(':\n                    aux=stack.pop()+aux\n                stack.pop()\n                stack.append(aux[::-1])\n            else:\n                curr+=c\n        if curr:\n            stack.append(curr)\n        return ''.join(stack)
class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        if not s: return s\n        l=0\n        r=0\n        res=''\n        for i,c in enumerate(s):\n            if c=='(':\n                l+=1\n            if c==')':\n                if l==r:\n                    continue\n                else:\n                    r+=1\n            res+=c\n        s=res\n        l=0\n        r=0\n        res=''\n        for i in range(len(s)-1,-1,-1):\n            c=s[i]\n            if c==')':\n                r+=1\n            if c=='(':\n                if l==r:\n                    continue\n                else:\n                    l+=1\n            res=c+res\n        return res
class Solution:\n     def myAtoi(self, str):\n         """\n         :type str: str\n         :rtype: int\n         """\n         base = "0123456789"\n         plus = "+"\n         minus = "-"\n         sum = 0\n         flag = 1\n         bit = 0\n         INT_MAX = 2147483647\n         INT_MIN = -2147483648\n         \n         if not str:\n             return 0\n         \n         if len(str) == 0:\n             return 0\n         \n         for letter in str.strip():\n             if letter in plus:\n                 if bit == 0:\n                     bit = 1\n                     continue\n                 else:\n                     break\n             elif letter in minus:\n                 if bit == 0:\n                     bit = 1\n                     flag = -1\n                     continue\n                 else:\n                     break\n             elif letter not in base:\n                 break;\n             else:\n                 sum *= 10\n                 sum += int(letter)\n         \n         sum *= flag\n         \n         if(sum > INT_MAX):\n             return INT_MAX\n         \n         if(sum < INT_MIN):\n             return INT_MIN\n         \n         return sum\n                 \n         \n
class Solution:\n     def singleNonDuplicate(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         return self.singleNonDuplicateUtil(nums, 0, len(nums)-1)\n         \n     def singleNonDuplicateUtil(self, nums, l, r):\n         if l < r:\n             mid = int((l + r) * 0.5)\n \n             if mid-1>=0 and nums[mid-1]!=nums[mid]:\n                 mid=mid-1\n \n             if (mid - l + 1) % 2 == 0:\n                 l = mid + 1\n             else:\n                 r = mid\n \n \n             return self.singleNonDuplicateUtil(nums, l, r)\n         else:\n             return nums[l]
from heapq import heapify, heappush, heappop\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    N, Q = list(map(int, input().split()))\n    events = []\n    for i in range(N):\n        S, T, X = list(map(int, input().split()))\n        events.append((S-X-0.5, 1, X))\n        events.append((T-X-0.5, 0, X))\n    for i in range(Q):\n        D = int(input())\n        events.append((D, 2, i))\n\n    events.sort()\n\n    anss = [-1] * Q\n    PQ = []\n    isClosed = dict()\n    for tm, tp, x in events:\n        if tp == 0:\n            isClosed[x] = 0\n        elif tp == 1:\n            isClosed[x] = 1\n            heappush(PQ, x)\n        else:\n            while PQ:\n                if isClosed[PQ[0]] == 1:\n                    anss[x] = PQ[0]\n                    break\n                heappop(PQ)\n\n    print(('\n'.join(map(str, anss))))\n\n\nsolve()\n
import sys\nsys.setrecursionlimit(10**6)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn, m = map(int, input().split())\n\nans = [-1]*n\n\nuf = UnionFind(n)\ng = [[] for i in range(n)]\n\nfor i in range(m):\n    u, v, c = map(int, input().split())\n    if not uf.same(u-1, v-1):\n        uf.union(u-1, v-1)\n        g[u-1].append((v-1, c))\n        g[v-1].append((u-1, c))\n\ndef dfs(i):\n    for to, c in g[i]:\n        if ans[to]==-1:\n            if ans[i] == c:\n                if c == 1:\n                    ans[to] = c+1\n                else:\n                    ans[to] = c-1\n            else:\n                ans[to] = c\n            dfs(to)\n\nans = [-1]*n\nans[0] = 1\ndfs(0)\n\nif -1 in ans:\n    print('No')\n    return\n\nans = [a for a in ans]\n\nprint(*ans, sep='\n')\n
n = int(input())\ns = list(input())\ns = [ord(i)-97 for i in s]\n\ndic = {}\nfor i in range(26):\n    dic[i] = []\n\nfor i in range(n):\n    dic[s[i]].append(i)\n\nfor i in range(26):\n    dic[i].append(float('inf'))\n\nfrom bisect import bisect_left\nq = int(input())\nfor i in range(q):\n    x, y, z = input().split()\n    if x == '1':\n        y, z = int(y) - 1, ord(z) - 97\n        p = bisect_left(dic[s[y]], y)\n        dic[s[y]].pop(p)\n        dic[z].insert(bisect_left(dic[z], y), y)\n        s[y] = z\n    else:\n        res = 0\n        y, z = int(y) - 1, int(z) - 1\n        for i in range(26):\n            p = dic[i][bisect_left(dic[i], y)]\n            if p <= z:\n                res += 1\n        print(res)
n=int(input())\na=list(map(int,input().split()))\n\nX=[]\nb=a[0]\nfor i in range(1,n) :\n    b^=a[i]\n\nfor i in range(n) :\n    x=b^a[i]\n    X.append(x)\n\nfor i in X :\n    print(i,end=" ")\n
import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**5)\n\nN, Q = map(int, input().split())\n\npath = [[] for _ in range(N)]\n\nfor _ in range(N-1) :\n    a, b, c, d = (int(i) for i in input().split())\n    path[a-1].append((b-1, c-1, d))\n    path[b-1].append((a-1, c-1, d))\n\n# doublingK\nfor K in range(18) :\n    if 2 ** K >= N :\n        break\n\n# dfs\nparent = [[-1] * N for _ in range(K)]\nrank = [-1 for _ in range(N)]\n\nrank[0] = 0\nqueue = [0]\n\nwhile queue :\n    cur = queue.pop()\n    for nex, _, _ in path[cur] :\n        if rank[nex] < 0 :\n            queue.append(nex)\n            parent[0][nex] = cur\n            rank[nex] = rank[cur] + 1\n\n# doubling        \nfor i in range(1, K) :\n    for j in range(N) :\n        if parent[i-1][j] > 0 :\n            parent[i][j] = parent[i-1][parent[i-1][j]]\n\n# lca\ndef lca(a, b) :\n    if rank[a] > rank[b] :\n        a, b = b, a\n\n    diff = rank[b] - rank[a]\n    i = 0\n    while diff > 0 :\n        if diff & 1 :\n            b = parent[i][b]\n        diff >>= 1\n        i += 1\n        \n    if a == b :\n        return a\n\n    for i in range(K-1, -1, -1) :\n        if parent[i][a] != parent[i][b] :\n            a = parent[i][a]\n            b = parent[i][b]\n\n    return parent[0][a]\n\n# Query\nschedule = [[] for _ in range(N)]\nfor i in range(Q) : \n    x, y, u, v = map(int, input().split())\n    x, u, v = x-1, u-1, v-1\n    l = lca(u, v)\n    schedule[u].append((i, 1, x, y))\n    schedule[v].append((i, 1, x, y))\n    schedule[l].append((i, -2, x, y))\n\nret = [0] * Q\nC = [0] * (N-1)\nD = [0] * (N-1)\n\ndef dfs(cur, pre, tot) :\n    for i, t, c, d in schedule[cur] :\n        ret[i] += t * (tot - D[c] + C[c] * d)\n    \n    for nex, c, d in path[cur] :\n        if nex == pre :\n            continue\n        C[c] += 1\n        D[c] += d\n        dfs(nex, cur, tot + d)\n        C[c] -= 1\n        D[c] -= d\n\ndfs(0, -1, 0)\n   \nfor i in range(Q) :\n    print(ret[i])
import bisect\nimport sys\nsys.setrecursionlimit(10**7)\n\ndef dfs(v):\n    pos=bisect.bisect_left(dp,arr[v])\n    changes.append((pos,dp[pos]))\n    dp[pos]=arr[v]\n    ans[v]=bisect.bisect_left(dp,10**18)\n    for u in g[v]:\n        if checked[u]==0:\n            checked[u]=1\n            dfs(u)\n    pos,val=changes.pop()\n    dp[pos]=val\n\n\nn=int(input())\narr=[0]+list(map(int,input().split()))\ng=[[] for _ in range(n+1)]\nfor _ in range(n-1):\n    a,b=map(int,input().split())\n    g[a].append(b)\n    g[b].append(a)\nans=[0]*(n+1)\nchecked=[0]*(n+1)\nchecked[1]=1\ndp=[10**18 for _ in range(n+1)]\nchanges=[]\ndfs(1)\nfor i in range(1,n+1):\n    print(ans[i])
m = int(input())\nn = int(input())\nprint(m-n) if m>n else print(m+n)
# cook your dish here\ndef modular_pow(base, exponent, modulus):\n result = 1\n while exponent > 0:\n  if(exponent %2 == 1):\n   result = (result * base) % modulus\n  exponent = exponent//2\n  base = (base * base)%modulus\n return result\ndef passesMillerRabinTest(n, a):\n s = 0\n d = n-1\n while(d%2 == 0):\n  s += 1\n  d >>= 1\n x = modular_pow(a, d, n)\n if(x == 1 or x == n-1):\n  return True\n for ss in range(s - 1):\n  x = (x*x)%n\n  if(x == 1):\n   return False\n  if(x == n-1):\n   return True\n return False\nprimeList = (2, 3,5,7,11,13,17,19, 23,29, 31,37)\ndef isPrime(n):\n for p in primeList:\n  if n%p == 0:\n   return n == p\n for p in primeList:\n  if passesMillerRabinTest(n, p) == False:\n   return False\n return True\n \nt = int(input())\nfor tt in range(t):\n n = int(input())\n if(n == 2):\n  print(2)\n  continue\n if n%2 == 0:\n  n -= 1\n while True:\n  if(isPrime(n)):\n   print(n)\n   break\n  n -= 2\n
# cook your dish here\ndef count(k,n,m):\n    sum1=(m*(m+1))//2\n    sum2=(m*(m-1))//2\n    ct=0\n    for i in range(n):\n        for j in range(n):\n            if i<j and k[i]>k[j]:\n                ct+=sum1\n            elif j<i and k[i]>k[j]:\n                ct+=sum2\n    return ct\n\ntest=int(input())\nfor _ in range(test):\n    n,m=map(int,input().split())\n    k=list(map(int,input().split()))\n    print(count(k,n,m))\n
# cook your dish here\r\ndef offset(l, flag):\r\n    x = 0\r\n    # print(l)\r\n    for i in range(1, len(l)):\r\n        temp = []\r\n        for j in range(i):\r\n            v = getbig(l[i], l[j], fs)\r\n            if v > 1:\r\n                temp.append(v)\r\n                if flag:\r\n                    x += 2**v - 2\r\n                else:\r\n                    x -= 2**v - 2\r\n        x += offset(temp, not flag)\r\n    return x\r\n    \r\ndef getbig(v1, v2, factors):\r\n    x = 1\r\n    for f in factors:\r\n        while v1%f == 0 and v2%f == 0:\r\n            v1//=f\r\n            v2//=f\r\n            x*=f\r\n    return x\r\n    \r\ndef prime_factors(n):\r\n    i = 2\r\n    factors = set()\r\n    while i * i <= n:\r\n        if n % i:\r\n            i += 1\r\n        else:\r\n            n //= i\r\n            factors.add(i)\r\n    if n > 1:\r\n        factors.add(n)\r\n    return factors\r\n    \r\nn,m = map(int, input().split())\r\nif n == 1:\r\n    print(1)\r\nelse:\r\n    fs = prime_factors(n)\r\n    fs.discard(n)\r\n    ans = 2**n-2\r\n    temp = []\r\n    for v in fs:\r\n        v = n//v\r\n        temp.append(v)\r\n        ans -= 2**v - 2\r\n        # print(ans)\r\n    ans += offset(temp, True)\r\n    # print(fs)\r\n    print(ans%m)
for _ in range(int(input())):\n    N=int(input())\n    if N%2==0:\n        print(N//2+1)\n    else:\n        print((N-1)//2+1)
# cook your dish here\r\nimport bisect\r\nn, k1, *l = map(int, input().split())\r\nv_l, b_l = l[:n], l[n:]\r\n\r\nb_inv = {key:[] for key in range(2*k1)}\r\nfor i in range(n):\r\n    b_l[i] -= 1\r\n    b_inv[b_l[i]].append(i)\r\n\r\ndp = [[0 for _ in range(n)] for _ in range(n)]\r\nfor k in range(1, n):\r\n    for j in range(n-2, -1, -1):\r\n        if j+k >= n:\r\n            continue\r\n        \r\n        dp[j][j+k] = max(dp[j][j+k], dp[j][j+k-1])\r\n        if b_l[j+k] >= k1:\r\n            left = bisect.bisect_right(b_inv[b_l[j+k]-k1], j)\r\n            \r\n            if b_l[j+k] >= k1:\r\n                for i in b_inv[b_l[j+k]-k1][left:]:\r\n                    if i > j+k:\r\n                        break\r\n                    if i > j:\r\n                        dp[j][j+k] = max(dp[j][j+k], dp[j][i-1]+dp[i][j+k])\r\n                \r\n        if b_l[j+k]-k1 == b_l[j]:\r\n            if j+k-1 < n:\r\n                dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j]+dp[j+1][j+k-1])\r\n            else:\r\n                dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j])\r\n        \r\n\r\nprint(dp[0][-1])
# cook your dish here\nt=int(input())\nfor i in range(t):\n    n=input()\n    if(n=='b' or n=='B'):\n        print('BattleShip')\n    elif(n=='c' or n=='C'):\n        print('Cruiser')\n    elif(n=='d' or n=='D'):\n        print('Destroyer')\n    else:\n        print('Frigate')
from math import *\r\nfrom collections import *\r\nimport sys\r\ninput=sys.stdin.readline\r\nt=int(input())\r\nwhile(t):\r\n    t-=1\r\n    n=int(input())\r\n    a=list(map(int,input().split()))\r\n    p,q=map(int,input().split())\r\n    s=0\r\n    a.sort()\r\n    for i in range(n//2):\r\n        x=a[i]\r\n        x1=a[n-i-1]\r\n        if(x==p or x1==p):\r\n            s1=abs(x-x1)\r\n            s2=q\r\n            s+=abs(atan2(s1,s2))\r\n        elif(x<p and x1>p):\r\n            s1=abs(p-x)\r\n            ex=atan2(s1,q)\r\n            s1=abs(p-x1)\r\n            ex1=atan2(s1,q)\r\n            ex+=ex1\r\n            s+=abs(ex)\r\n        else:\r\n            if(p<x):\r\n                s1=abs(p-x)\r\n                ex=atan2(s1,q)\r\n                s1=abs(p-x1)\r\n                ex1=atan2(s1,q)\r\n                ex=ex1-ex\r\n                s+=abs(ex)\r\n            else:\r\n                s1=abs(p-x)\r\n                ex=atan2(s1,q)\r\n                s1=abs(p-x1)\r\n                ex1=atan2(s1,q)\r\n                ex=ex-ex1\r\n                s+=abs(ex)    \r\n    print(s)\r\n
import sys\r\ndef get_array(): return list(map(int , sys.stdin.readline().strip().split()))\r\ndef get_ints(): return list(map(int, sys.stdin.readline().strip().split()))\r\ndef input(): return sys.stdin.readline().strip()\r\nimport sys\r\nsys.setrecursionlimit(10**9)\r\nfrom math import sqrt,ceil,floor\r\nn=int(input())\r\nco=0\r\nans=0\r\nfor i in range(1,n):\r\n    ans+=n//i\r\n    if n%i==0:\r\n        ans-=1\r\nprint(ans)\r\n\r\n
f = 5003*[0]\nmodn = 1000000007\n\n\ndef qPow(a, b):\n nonlocal modn\n res = 1\n while b > 0:\n  if (b & 1) == 1:\n   res = res * a % modn\n  a = a * a % modn\n  b = b >> 1\n return res\n\n\ndef getF():\n nonlocal f\n f[0] = 1\n for i in range(1, 5001):\n  f[i] = f[i-1] * i\n\n\ndef __starting_point():\n getF()\n T = int(input())\n while T > 0:\n  T = T - 1\n  n, k = list(map(int,input().split()))\n  lis = list(map(int, input().split()))\n  lis = sorted(lis)\n  res = 1\n  for i in range(n):\n   zhi = f[n-1]//f[k-1]//f[n-k]\n   if i >= k-1:\n    zhi = zhi - f[i]//f[k-1]//f[i+1-k]\n   if n-i-1 >= k-1:\n    zhi = zhi - f[n-i-1]//f[k-1]//f[n-i-k]\n   zhi = zhi % (modn-1)\n   # print(zhi)\n   res = res * qPow(lis[i], zhi) % modn\n  print(res)\n\n__starting_point()
arr = list(input())\r\nn = len(arr)\r\nans = list()\r\n#for i in arr:\r\n    #ans.append(ord(i)-96)\r\nli = ['b','d','f','h','j','l','n','p','r','t','v','x','z']\r\ns = set(arr)\r\ntemp = s.intersection(li)\r\nfor _ in range(int(input())):\r\n    x,y = list(map(int,input().split()))\r\n    li = list(temp)\r\n    #s = set()\r\n    c=0\r\n    for i in range(x-1,y):\r\n        if arr[i] in li:\r\n            c+=1 \r\n            li.remove(arr[i])\r\n        if len(li)==0:\r\n            break\r\n    print(c)\r\n
# cook your dish here\nfor t in range(int(input())):\n    a,b,c=map(int,input().split())\n    p=(c//a)*a+b\n    if p<=c:\n        print(p)\n    else:\n        print(((c//a)-1)*a+b)
#include<sdg.h>\nfor _ in range(int(input())):\n    s=input()\n    n=len(s)\n    if n==1:\n        if s[0].isalpha(): print("-32")\n        else: print(0)\n    else:\n        num,ch=0,0\n        p,q=0,0\n        c=1\n        x=s[0]\n        ans=""\n        for i in range(1,n):\n            if s[i-1]==s[i]:\n                c+=1\n                if i==n-1:\n                    ans+=s[i-1]\n                    ch+=1\n                    if c>1:\n                        ans+=str(c)\n                        num+=1\n                    c=1\n            else:\n                ans+=s[i-1]\n                ch+=1\n                if c>1:\n                    ans+=str(c)\n                    num+=1\n                c=1\n                if i==n-1:\n                    ans+=s[i]\n                    ch+=1\n        #print(ans,num,ch)\n        sol=(n*8)-((num*32)+(ch*8))\n        print(sol)
def update(index, value, bi_tree):\n while index < len(bi_tree):\n  bi_tree[index] += value\n  index += index & -index\n\n\ndef get_sum(index, bi_tree):\n ans = 0\n while index > 0:\n  ans += bi_tree[index]\n  index -= index & -index\n\n return ans\n\n\ndef get_range_sum(left, right, bi_tree):\n ans = get_sum(right, bi_tree) - get_sum(left - 1, bi_tree)\n return ans\n\n\ndef solve(x):\n s = set()\n res = 1\n i = 2\n while (i * i <= x):\n  count = 0\n  while (x % i == 0):\n   x = x // i\n   count += 1\n  if (count % 2):\n   s.add(i)\n  i += 1\n if (x > 0):\n  s.add(x)\n return s\n\n\nn = int(input())\nl = [0] + [int(i) for i in input().split()]\nbit = [[0 for i in range(n + 1)] for i in range(101)]\n\nfor i in range(1, n + 1):\n s = solve(l[i])\n for j in s:\n  update(i, 1, bit[j])\n\nq = int(input())\nfor i in range(q):\n k, a, b = [int(i) for i in input().split()]\n if (k == 1):\n  f = 1\n  for i in range(2, 100):\n   res = get_range_sum(a, b, bit[i])\n   if (res % 2):\n    f = 0\n    break\n  if (f):\n   print("YES")\n  else:\n   print("NO")\n else:\n  s = solve(b)\n  for j in s:\n   update(a, 1, bit[j])
# cook your dish here\n\nfrom sys import stdin,stdout\nfrom collections import deque,defaultdict\nfrom math import ceil,floor,inf,sqrt,factorial,gcd,log\nfrom copy import deepcopy\nii1=lambda:int(stdin.readline().strip())\nis1=lambda:stdin.readline().strip()\niia=lambda:list(map(int,stdin.readline().strip().split()))\nisa=lambda:stdin.readline().strip().split()\nmod=1000000007\n\nfor _ in range(ii1()):\n n,l=iia()\n if n==1:\n  print(l)\n elif n==2:\n  print(int(log2(10))+1)\n else:\n  print(ceil(l/(n+1)))\n
import math\nfor _ in range(int(input())):\n n=int(input())\n s=int(math.sqrt(n))\n ans=0\n for i in range(1,s+1):\n  ans+=(n//i)\n ans=ans*2-(s*s)\n g=math.gcd(n*n,ans)\n print(str(ans//g)+"/"+str(n*n//g)) 
# cook your dish here\n# cook your dish here\nimport numpy as np\nimport sys\n\ndef findSeq(n, s, k, m, M):\n    midInd = n // 2\n    seqs = []\n    for ind in range(midInd + 2, midInd - 3, -1):\n        if ind >= n or ind < 0:\n            continue     \n        seq = genBestSeq(n, ind, m, M, s)\n        if seq is not -1 and testSeq(k, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)\n\n#def findSeq(n, s, k, m, M):\n#    midInd = n // 2\n#    if k <= midInd: #and (n % 2 == 1 or s < m * midInd + M * (n - midInd)):\n#        return genBestSeq(n, midInd + 1, m, M, s) \n#    elif k > midInd + 1 and n % 2 == 1:\n#        return -1\n#    return genBestSeq(n, midInd, m, M, s)\n\ndef genBestSeq(n, diffInd, m, M, s):\n    #inc = M - m - 1\n    arr = np.full((n,), m)\n    arr[diffInd:] += 1\n    #remainder = s - np.sum(arr)\n    #if remainder < 0:\n    #    return -1\n\n    #nFull, remainder = divmod(remainder, inc)\n    #if nFull > n or (nFull == n and remainder > 0):\n    #    return -1\n\n    #addingInd = n - nFull -1\n    #arr[addingInd + 1:] += inc\n    #arr[addingInd] += remainder\n    #return arr\n    s = s - np.sum(arr)\n    if s < 0:\n        return -1\n    inc = M - m - 1\n    ind = n - 1\n    while (ind >= 0):\n        z = min(inc, s)\n        arr[ind] += z\n        s -= z\n        ind -= 1\n    if s != 0:\n        return -1\n    return arr\n\ndef testSeq(k, seq):\n    seq = sorted(seq)\n    n = len(seq)\n    if n % 2 == 1:\n        median = seq[n // 2]\n    else:\n        median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n    seq.pop(n % k)\n    seq.pop(k - 1)\n    return (median != seq[(n - 2) // 2]) \n    \n\ndef __starting_point():\n    nCases = int(input())\n    answers = []\n    #ks = []\n    for i in range(nCases):\n        #nums = [int(val) for val in input().split()]\n        #ks.append(nums[2])\n        #answers.append(findSeq(*nums))\n        answers.append(findSeq(*(int(val) for val in input().split())))\n        ans = answers[-1]\n        if not isinstance(ans, int):\n            print(*ans, sep=' ')\n        else:\n            print(ans)\n    #for i, ans in enumerate(answers):\n\n    #for ans in answers:\n    #    if isinstance(ans, np.ndarray):\n    #        print(*ans, sep=' ')\n    #    else:\n    #        print(ans)\n\n__starting_point()
# cook your dish here\nn=int(input())\ncounts=dict()\nz=0\nupper=None\nfor i in range(0,n):\n a,h= [int(num) for num in input().split()]\n counts[a]=h\nfor key,count in counts.items():\n c=0\n x=key-count\n y=key+count\n c1=0\n c2=0\n for j in counts.keys():\n  if j==key:\n   continue\n  else:\n   if x<=j<=key:\n    c1=0\n    break\n   else:\n    c1=1\n for j in counts.keys():\n  if j==key:\n   continue\n  else:\n   if key<=j<=y:\n    c2=0\n    break\n   else:\n    c2=1\n if c2==0 and c1==1:\n  if upper is None:\n   z=z+c1\n   upper=key\n  else:\n   if x>=upper:\n    z=z+c1\n    upper=key\n   else:\n    z=z+c2\n    upper=key\n elif c2==1 and c1==0:\n  if upper is None:\n   z=z+c2\n   upper=y\n  else:\n   if upper<=key:\n    z=z+c2\n    upper=y\n   else:\n    z=z+c1\n    upper=y\n elif c2==1 and c1==1:\n  if upper is None:\n   z=z+c1\n   upper=key\n  else:\n   if x>=upper:\n    z=z+c1\n    upper=key\n   else:\n    if upper<=key:\n     z=z+c2\n     upper=y\n    else:\n     z=z+0\n     upper=y\n else:\n  z=z+0\n  upper=key\nif len(counts)==1:\n print(1)\nelse:\n print(z)
n=int(input())\nmodulo=15746\nnum=[1,1]\nfor i in range(2,n+1):\n    num.append((num[i-1]+num[i-2])%modulo)\nprint(num[n])
# cook your dish here\nfor _ in range(int(input())):\n    m,n=list(map(int,input().split()))\n    a=[int(i) for i in input().split()]\n    l=-1\n    for i in range(n-1,-1,-1):\n        if a[i]==m:\n            l=i\n            break\n    f=-1\n    for i in range(0,n):\n        if a[i]==m:\n            f=i\n            break\n    print(l-f)\n            \n        \n
def detect_triangle(adj): \n    for x in range(len(adj)):\n     for y in adj[x]:\n      if not set(adj[x]).isdisjoint(adj[y]):\n       return True\n\n \nfor _ in range(int(input())):\n    n,m=list(map(int,input().split()))\n    graph=[[] for i in range(n)]\n    for i in range(m):\n     u,v=list(map(int,input().split()))\n     graph[u-1].append(v-1)\n     graph[v-1].append(u-1)\n    h=[]    \n    for i in range(len(graph)):\n     h.append(len(graph[i]))\n    h1=max(h)    \n    if h1>=3:\n     print(h1)\n     continue\n    if detect_triangle(graph):\n     print(3)\n     continue\n    print(h1)    # cook your dish here\n
def C(n):\n return n*(n-1)//2\n\n\ndef sol():\n equal, mini = False, min(N,M)\n total_ways = 2*C(N * M)\n if N==M:\n  equal = True\n ways = 0\n if not equal:\n  ways = (N*C(M)+M*C(N))\n  diag = 0\n  for i in range(2, mini+1):\n   diag += 2*C(i)\n  for i in range(mini+1,max(N,M)):\n   diag += C(mini)\n  diag *= 2\n  ways += diag\n  ways *= 2\n else:\n  ways = (N*C(M)+M*C(N))\n  diag = 0\n  for i in range(2, mini):\n   diag += 2*C(i)\n  diag += C(mini)\n  diag *= 2\n  ways += diag\n  ways *=2\n safe = total_ways - ways\n l, r, t, d = Y-1, M-Y, X-1, N-X\n safe_add, to_remove = 0, 0\n\n for i in range(1,N+1):\n  for j in range(1, M+1):\n   if i==X or j==Y or abs(i-X)==abs(j-Y):\n    continue\n   else:\n    to_remove += 1\n\n if l>0 and r>0 and t>0 and d>0:\n  dtl, dtr, dbl, dbr = min(l,t), min(r,t), min(l,d), min(r,d)\n  safe_add += dtl*dbr*2 + dtr*dbl*2\n  safe_add += t*d*2\n  safe_add += l*r*2\n elif l>0 and r>0:\n  safe_add += l*r*2\n elif t>0 and d>0:\n  safe_add += t*d*2\n\n safe += safe_add - to_remove*2\n\n return safe\n\n\nT = int(input())\nfor _ in range(T):\n N, M, X, Y = [int(x) for x in input().split()]\n print(sol())
# cook your dish here\nt=int(input())\nfor i in range(t):\n (n,k)=tuple(map(int,input().split()))\n print(k//n)
n,k=[int(x) for x in input().split()]\r\na=[int(x) for x in input().split()]\r\nans=0\r\nfor i in range(n-1):\r\n    for j in range(i+1,n):\r\n        if(abs(a[i]-a[j])>=k):\r\n            ans+=1\r\nprint(ans)\r\n
# cook your dish here\nn=int(input())\nfor i in range(n):\n    S, SG, FG, D, T = map(int, input().split())\n    speed = (D*180)/T + S\n    if abs(SG-speed) == abs(FG-speed):\n        print('DRAW')\n    elif abs(SG-speed) > abs(FG-speed):\n        print('FATHER')\n    else:\n        print('SEBI')
# By Prathmesh Maurya\nt=eval(input())\nwhile(t!=0):\n t-=1\n n=eval(input())\n if n%2 == 0:\n  print(n*4)\n elif n%4==3:\n  print(n)\n else:\n  print(n*2)\n
    \r\nfor __ in range(int(input())):\r\n    n,m=map(int,input().split())\r\n    arr=list(map(int,input().split()))\r\n    s=set(arr)\r\n    mex=-1\r\n    ele=1\r\n    for i in range(1,n+1):\r\n        if i not in s:\r\n            mex = i\r\n            break\r\n    if m>mex:\r\n        print(-1)\r\n    elif m==mex:\r\n        print(n)\r\n    else:\r\n        c=arr.count(m)\r\n        print(n-c)\r\n    \r\n    \r\n    \r\n
for i in range(int(input())):\n    n = int(input())\n    c = list(map(int, input().split()))\n    d = {}\n    d[0] = -1\n    parity = 0\n    ans = 0\n    for i in range(n):\n     parity ^= 1 << (c[i]-1)\n     for t in range(30):\n      x = parity^(1<<t)\n      if(x in d.keys()):\n       ans = max(ans, i - d[x])\n     if parity not in d.keys():\n      d[parity] = i\n    print(ans//2)
# cook your dish here\nimport sys\nimport math\n\ndef main(grid):\n    ans=0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            first_point=grid[i][j]\n            for k in range(j+1,len(grid[0])):\n                second_point=grid[i][k]\n                if first_point==second_point:\n                    dist=k-j\n                    if i+dist<len(grid):\n                        thrid_point=grid[i+dist][j]\n                        fourth_point=grid[i+dist][k] \n                        if second_point==thrid_point and second_point==fourth_point:\n                            ans+=1\n    return ans\n    \ntest=int(input())\nfor _ in range(test):\n    n,m=input().split()\n    n=int(n)\n    arr=[]\n    for b in range(n):\n        arr.append(list(input()))\n    print(main(arr))
# cook your dish here\nfor _ in range(int(input())):\n    tr=int(input())\n    trl=list(map(int,input().split()))\n    dr = int(input())\n    drl = list(map(int, input().split()))\n    ts = int(input())\n    tsl = list(map(int, input().split()))\n    ds = int(input())\n    dsl = list(map(int, input().split()))\n    for item in tsl:\n        if item in trl:\n            res=1\n            continue\n        else:\n            res=0\n            break\n    for item1 in dsl:\n        if item1 in drl:\n            res1=1\n            continue\n        else:\n            res1=0\n            break\n    if res==1 and res1==1:\n        print("yes")\n    else:\n        print("no")\n
# cook your dish here\ndef decode(L,S):\n str_2=""\n lst=[]\n for i in range(L//4):\n  str_1 = "abcdefghijklmnop"\n  S_1=S[(i*4):(4*(i+1))]\n  for j in range(4):\n   if(S_1[j]=="1"):\n    str_1=str_1[len(str_1)//2:len(str_1)]\n   else:\n    str_1 = str_1[0:len(str_1) // 2]\n  str_2=str_2+str_1\n print(str_2)\n\nT=int(input())\nfor i in range(T):\n L=int(input())\n S=input()\n decode(L,S)\n
for _ in range(int(input())):\n n,k = list(map(int,input().split()))\n array = []\n tot = []\n for _ in range(n):\n  temp = list(map(int,input().split()))\n  aa = temp[0]\n  del(temp[0])\n  temp.sort()\n  temp.insert(0,aa)\n  array.append(temp)\n dic = {}\n array.sort(reverse=True)\n for i in array:\n  del(i[0])\n for i in range(1,k+1):\n  dic[i] = False\n count = 0\n for i in array:\n  count += 1\n  # print(count,tot)\n  for j in i:\n   if(dic[j]==True):\n    pass\n   else:\n    tot.append(j)\n    dic[j]=True\n  if(len(tot)==k):\n   break\n if(len(tot)!=k):\n  print("sad")\n elif(count!=n):\n  print("some")\n else:\n  print("all")
# cook your dish here\r\ntest=int(input())\r\nfor _ in range(test):\r\n    n=int(input())\r\n    n=list(bin(n))\r\n    ans=n.count('1')\r\n    print(ans-1)
import sys\n\nt = int(input())\n\ndef g(a,b):\n if (a > b):\n  tmp = a\n  a = b\n  b = tmp\n if (b == a):\n  return 0\n if (b % a == 0):\n  return int(b/a)-1\n r = g(b%a,a)\n q = int(b/a)\n if (r >= q):\n  return q-1\n else:\n  return q\n\ndef mex(x):\n n = len(list(x.keys()))\n for i in range(n):\n  if (i not in x):\n   return i\n return i\n\ndef g2(a,b):\n if (a == b):\n  return 0\n if (a > b):\n  tmp = a\n  a = b\n  b = tmp\n if (b % a == 0):\n  return int(b/a)-1\n q = int(b/a)\n x = {}\n r = b % a\n for i in range(q):\n  x[g2(r+i*a,a)] = True\n return mex(x)\n\n#print(str(g(6,33))+" "+str(g2(6,33)))\n\nwhile (t):\n\n n = int(input())\n x = 0\n while (n):\n  line = input().split()\n  a = int(line[0])\n  b = int(line[1])\n  x ^= g(a,b)\n  n -= 1\n if (x):\n  sys.stdout.write("YES\n")\n else:\n  sys.stdout.write("NO\n")\n #print(str(g(a,b)) + " " + str(g2(a,b)))\n t -= 1
# cook your dish here\nfor i in range(int(input())):\n    n=int(input())\n    p=1\n    l=n-1\n    for j in range(n):\n        for k in range(l):\n            print(" ",end='')\n        for k in range(p):\n            print("*",end='')\n        print()\n        for k in range(l):\n            print(" ",end='')\n        for k in range(p):\n            print("*",end='')\n        print()\n        p+=2\n        l-=1\n        
import sys\n \nnum=int(sys.stdin.readline())\ns=sys.stdin.readline().split()\nsky=list(map(int,s))\nsky.reverse()\ncuts=0\nchange=0\nt=False\ni=1\n \nwhile i<len(sky):\n if sky[i]<=sky[i-1]:\n  for j in range(i-1,-1,-1):\n   \n   if sky[j]<=sky[i]-(i-j):\n    break\n   else:\n    change+=sky[j]-(sky[i]-(i-j))\n    \n   if change>=sky[i]:\n    change=sky[i]\n    t=True\n    break\n    \n  cuts+=change\n  \n  if t:\n   del sky[i]\n   t=False\n   i-=1\n   \n  else:\n   for j in range(i-1,-1,-1):\n    if sky[j]<sky[i]-(i-j):\n     break\n    else:\n     sky[j]=sky[i]-(i-j)\n i+=1\n    \n change=0\n     \nprint(cuts)
\ndef main():\n t = int(input())\n while (t):\n  m, n = map(int, input().split())\n  a , b= bin(m)[2:],bin(n)[2:]\n  #print(a,b)\n  max = m^n\n  if len(a)>len(b):\n   diff =len(a)-len(b)\n   b= ("0"*diff)+b\n   #print(b)\n  elif len(a)<len(b):\n   diff =len(b)-len(a)\n   a= ("0"*diff)+a\n   #print(a)\n  ll = len(b)\n  count= 0\n  for i in range(ll-1):\n   s= b[ll-1] + b\n   s= s[:ll]\n\n   tt= m^ int(s,2)\n   #print(m,s,tt)\n   if tt>max:\n    max =tt\n    count= i+1\n   b=s\n\n  print(count,max)\n  t-=1\n\ndef __starting_point():\n main()\n__starting_point()
t = int(input())\n\nfor _ in range(t):\n s = [x for x in input()]\n \n freq = {}\n \n for i in s:\n  if i in freq:\n   freq[i] += 1\n  else:\n   freq[i] = 1\n \n flag = 0\n \n for keys, values in freq.items():\n  if(values >= 2):\n   flag = 1\n   break\n \n if(flag == 0):\n  print("no")\n else:\n  print("yes")
def main():\n T = int(input())\n for t in range(T):\n  N,K = map(int, input().split())\n  W = list(map(int, input().split()))\n  W.sort()\n  if 2*K > N:\n   K = N - K\n  kid = sum(W[:K])\n  dad = sum(W[K:])\n\n  diff = dad - kid\n\n  print(diff)\n\n\ndef __starting_point():\n main()\n__starting_point()
def eq_solve(v0, v1, u0, u1):\r\n    den = u0 - v0\r\n    num = u1 - v1\r\n    if den != 0:\r\n        return num / den\r\n    return 1\r\n \r\ndef solve(p, q, r, a, b, c, rs):\r\n    if p == a and q == b and r == c:\r\n        return rs\r\n    if rs >= 2:\r\n        return 3\r\n    res = 3\r\n    adds = [a - p, b - q, c - r]\r\n    muls = []\r\n    if p != 0:\r\n        muls.append(a / p)\r\n    if q != 0:\r\n        muls.append(b / q)\r\n    if r != 0:\r\n        muls.append(c / r)\r\n    muls.append(eq_solve(p, a, q, b))\r\n    muls.append(eq_solve(p, a, r, c))\r\n    muls.append(eq_solve(q, b, r, c))\r\n    msks = 2 ** 3\r\n    for msk in range(msks):\r\n        for add in adds:\r\n            np = p\r\n            nq = q\r\n            nr = r\r\n            if (msk & 1) > 0:\r\n                np += add\r\n            if (msk & 2) > 0:\r\n                nq += add\r\n            if (msk & 4) > 0:\r\n                nr += add\r\n            res = min(res, solve(np, nq, nr, a, b, c, rs + 1))\r\n        for mul in muls:\r\n            np = p\r\n            nq = q\r\n            nr = r\r\n            if (msk & 1) > 0:\r\n                np *= mul\r\n            if (msk & 2) > 0:\r\n                nq *= mul\r\n            if (msk & 4) > 0:\r\n                nr *= mul\r\n            res = min(res, solve(np, nq, nr, a, b, c, rs + 1))\r\n    return res\r\n        \r\n \r\n \r\nt = int(input())\r\n \r\nwhile t > 0:\r\n    p, q, r = map(int, input().split())\r\n    a, b, c = map(int, input().split())\r\n    z = solve(p, q, r, a, b, c, 0)\r\n    print(z)\r\n    t -= 1 
from math import log10\nfrom decimal import Decimal\ndef solve(n,k):\n \n mod=10**k\n x=Decimal(n)\n y=x*(x.log10())%1\n p=str(pow(10,y))\n c=0\n first=''\n for v in p:\n  if c==k:\n   break\n  if v==".":\n   continue\n  first+=v\n  c+=1\n last=str(pow(n,n,mod)).zfill(k)\n return (first,last)\nqueries=[]\nfor _ in range(int(input())):\n n,k=list(map(int,input().split( )))\n queries.append((n,k))\nfor n,k in queries:\n print("%s %s"%(solve(n,k)))\n  \n \n
t = eval(input())\n\nfor i in range(t):\n n = eval(input())\n a = list(map(int, input().split()))\n cnt = 2\n cnt1 = 2\n ll = len(a)\n if ll < 3:\n  cnt1 = ll\n else:\n  for j in range(2,ll):\n   if a[j-1] + a[j-2] == a[j]:\n    cnt += 1\n    cnt1 = max(cnt1, cnt)\n   else:\n    cnt1 = max(cnt1, cnt)\n    cnt = 2\n print(cnt1) 
\r\n\r\nz = int(input())\r\ni = 0\r\nwhile i < z:\r\n  n = int(input())\r\n  p = int(n**(0.5))\r\n  if p*(p+1) < n:\r\n    p += 1\r\n  # print("P", p)\r\n  x, y = 0, 0\r\n  q = 0\r\n  flag = True\r\n  if p*(p+1) == n:\r\n    # print("Even steps, nice")\r\n    q = p\r\n  else:\r\n    # remaining steps\r\n    q = p-1\r\n    flag = False\r\n  if q%2 :\r\n    # odd\r\n    x -= ((q+1)//2)\r\n    y += ((q+1)//2)\r\n  else :\r\n    x += (q//2)\r\n    y -= (q//2)\r\n  if flag:\r\n    print(x, y)\r\n  else:\r\n    # remaining steps\r\n    l = q*(q+1)\r\n    t = p*(p+1)\r\n    diff = t-l\r\n    \r\n\r\n    # print(x, y)\r\n    if x < 0:\r\n      # left\r\n      if n-l >= diff//2:\r\n        y *= (-1)\r\n        l += (diff//2)\r\n        x += (n-l)\r\n      else :\r\n        y -= (n-l)\r\n      \r\n    else:\r\n      # right\r\n      if n-l >= diff//2:\r\n        y *= (-1)\r\n        y += 1\r\n        l += (diff//2)\r\n        x -= (n-l)\r\n      else :\r\n        y += (n-l)\r\n    # print("Remaining steps: ", n-l)\r\n    print(x, y)\r\n  i+=1 
# cook your dish here\nfor t in range(int(input())):\n n,m=[int(x)for x in input().rstrip().split()]\n s=[]\n for p in range(n):\n  s.append(10)\n for c in range(m):\n  i,j,k=[int(x)for x in input().rstrip().split()]\n  for q in range(i-1,j):\n   s[q]=s[q]*k\n print(sum(s)//n)\n \n  \n  \n \n
from queue import PriorityQueue\r\nm,n=list(map(int,input().split()))\r\nrr=[]\r\ncc=[]\r\nspeed={'S':3,'O':2,'F':1}\r\nvisited=set()\r\ndp=[]\r\n\r\ndef qwerty(cur,x,y,f):\r\n	if f==0:\r\n		gg=rr[x][1]+y*rr[x][0]\r\n		while gg<cur:\r\n			gg+=(2*(n-1))*rr[x][0]\r\n		return gg-cur+rr[x][0]\r\n	elif f==1:\r\n		gg=rr[x][1]+(2*(n-1)-y)*rr[x][0]\r\n		while gg<cur:\r\n			gg+=(2*(n-1))*rr[x][0]\r\n		return gg-cur+rr[x][0]\r\n	elif f==2:\r\n		gg=cc[y][1]+x*cc[y][0]\r\n		while gg<cur:\r\n			gg+=(2*(m-1))*cc[y][0]\r\n		return gg-cur+cc[y][0]		\r\n	elif f==3:\r\n		gg=cc[y][1]+(2*(m-1)-x)*cc[y][0]\r\n		while gg<cur:\r\n			gg+=(2*(m-1))*cc[y][0]\r\n		return gg-cur+cc[y][0]\r\n\r\n\r\ndirx=[0, 0, 1, -1]\r\ndiry=[1, -1, 0, 0]\r\n\r\nfor i in range(m):\r\n	o=[x for x in input().split()]\r\n	o[0]=speed[o[0]]\r\n	o[1]=int(o[1])\r\n	rr.append(o)\r\n\r\n\r\nfor i in range(n):\r\n	o=[x for x in input().split()]\r\n	o[0]=speed[o[0]]\r\n	o[1]=int(o[1])\r\n	cc.append(o)\r\n\r\n\r\nsx,sy,stt,dx,dy=list(map(int,input().split()))\r\nsx-=1\r\nsy-=1\r\ndx-=1\r\ndy-=1\r\n\r\nfor i in range(m):\r\n	dp.append([10**9]*n)\r\n\r\ndp[sx][sy]=stt\r\npq = PriorityQueue()\r\npq.put((stt, sx, sy))\r\nwhile not pq.empty():\r\n	#print(dp)\r\n	(t,cxx,cyy)=pq.get()\r\n	if (cxx,cyy) in visited:\r\n		continue\r\n	visited.add((cxx,cyy))\r\n	for i in range(len(dirx)):\r\n		nxx=cxx+dirx[i]\r\n		nyy=cyy+diry[i]\r\n		if nxx>=0 and nxx<m and nyy>=0 and nyy<n and (nxx,nyy) not in visited:\r\n			coo=qwerty(dp[cxx][cyy],cxx,cyy,i)\r\n			if coo+dp[cxx][cyy]<dp[nxx][nyy]:\r\n					dp[nxx][nyy]=coo+dp[cxx][cyy]\r\n					pq.put((dp[nxx][nyy],nxx,nyy))\r\n\r\nprint(dp[dx][dy])\r\n\r\n\r\n\r\n\r\n\r\n\r\n	\r\n\r\n\r\n\r\n
import math\nimport copy\ntry:\n import psyco\n psyco.full()\nexcept ImportError:\n pass\n \ndef isSharp(ang):\n return ang > math.pi/4 + 0.00001\n \ndef unitVector(p2, p1):\n d0 = p2[0] - p1[0]\n d1 = p2[1] - p1[1]\n d = math.sqrt(d0*d0 + d1*d1)\n if d != 0:\n  return [d0/d, d1/d]\n return [0, 0]\n \ndef compVectors(P):\n V = []\n for i in range(1,len(P)):\n  v = unitVector(P[i], P[i-1])\n  if v[0] == 0 and v[1] == 0:\n   return None\n  V.append(v)\n return V\n \ndef angle(v2, v1):\n d = v2[0]*v1[0] + v2[1]*v1[1]\n if d > 1:\n  d = 1\n if d < -1:\n  d = -1\n return math.acos(d)\n \ndef compAngles(V):\n A = []\n for i in range(len(V)-1):\n  A.append(angle(V[i+1], V[i]))\n return A\n \ndef updateAngles(i, P, V, A):\n if i-1 >= 0:\n  V[i-1] = unitVector(P[i], P[i-1])\n if i+1 < len(P):\n  V[i] = unitVector(P[i+1], P[i])\n if i-2 >= 0:\n  A[i-2] = angle(V[i-1], V[i-2])\n if i-1 >= 0 and i+1 < len(P):\n  A[i-1] = angle(V[i], V[i-1])\n if i+2 < len(P):\n  A[i] = angle(V[i+1], V[i])\n \ndef checkMoves(check, P, V, A, filled):\n for i in check:\n  if i < 0 or i >= len(P):\n   break\n  x, y = P[i]\n  for j in range(51):\n   for k in range(51):\n    P[i][0] = j\n    P[i][1] = k\n    if str(P[i]) in filled:\n     continue\n    updateAngles(i, P, V, A)\n    fixed = True\n    if i-2 >= 0:\n     if isSharp(A[i-2]):\n      fixed = False\n    if i-1 >= 0 and i-1 < len(A):\n     if isSharp(A[i-1]):\n      fixed = False\n    if i < len(A):\n     if isSharp(A[i]):\n      fixed = False\n    if fixed:\n     return True\n  P[i] = [x, y]\n  updateAngles(i, P, V, A) \n return False\n    \n \ndef canFix(first, last, P, V, A, filled):\n d = last - first\n if d > 2:\n  return False\n if d == 2:\n  check = [first+2]\n if d == 1:\n  check = [first+1, first+2]\n if d == 0:\n  check = [first, first+1, first+2]\n if checkMoves(check, P, V, A, filled):\n  return True\n return False\n \nT=int(input())\nfor i in range(T):\n N=int(input())\n P=[]\n V=[]\n filled={}\n for i in range(N):\n  P.append(list(map(int,input().split())))\n  filled[str(P[i])] = 1\n V = compVectors(P)\n A = compAngles(V)\n blunt = True\n first = -1\n last = -1\n for i in range(len(A)):\n  if isSharp(A[i]):\n   blunt = False\n   last = i\n   if first < 0:\n     first = i\n if blunt:\n  print('yes yes')\n else:\n  if canFix(first, last, P, V, A, filled):\n   print('no yes')\n  else:\n   print('no no') 
# cook your dish here\nfor i in range(int(input())):\n N=int(input())\n ALICE=list(map(int,input().split()))\n BOB=list(map(int,input().split()))\n ALICE[ALICE.index(max(ALICE))]=0\n BOB[BOB.index(max(BOB))]=0\n if sum(ALICE)<sum(BOB):\n  print("Alice")\n elif sum(BOB)<sum(ALICE):\n  print("Bob")\n else:\n  print("Draw")
def find_combinations(list, sum):\n if not list:\n  if sum == 0:\n   return [[]]\n  return []\n return find_combinations(list[1:], sum) + \\n  [[list[0]] + tail for tail in\n   find_combinations(list[1:], sum - list[0])]\nfor tc in range(int(input())):\n n,k=list(map(int,input().split()))\n a=list(map(int,input().split()))\n a.sort()\n if len(find_combinations(a,k))==0:\n  print("NO")\n else:\n  print("YES")\n  \n
# cook your dish here\nn,m=map(int,input().split())\nL=[]\nfor i in range(n):\n    s=input()\n    L.append(s)\n\ncost=[]\nh2=[0]*(m+1)\ncost.append(h2)\nfor i in range(n):\n    h=[0]\n    for j in range(m):\n        if(L[i][j]=='0' and (i+j)%2!=0):\n            h.append(1)\n        elif(L[i][j]=='1' and (i+j)%2==0):\n            h.append(1)\n        else:\n            h.append(0)\n    cost.append(h)\n\npre=[]\nh2=[0]*(m+1)\npre.append(h2)\nfor i in range(1,n+1):\n    h=[0]\n    c=0\n    for j in range(1,m+1):\n        c+=cost[i][j]\n        c2=c\n        if(i>0):\n            c2+=pre[i-1][j]\n        h.append(c2)\n    pre.append(h)\n\nbs=[0]*((m*n)+10)\n\nfor i in range(1,n+1):\n    for j in range(1,m+1):\n        for k in range(1,min(m,n)+1):\n            if(i-k>=0 and j-k>=0):\n                c=pre[i][j]-pre[i-k][j]-pre[i][j-k]+pre[i-k][j-k]\n                c=min(c,(k*k)-c)\n                bs[c]=max(bs[c],k)\n\nmx=bs[0]\nfor i in range(1,len(bs)):\n    mx=max(mx,bs[i])\n    bs[i]=mx\n\nQ=int(input())\nq=[int(x) for x in input().split()]\nfor i in range(0,len(q)):\n    qr=min(m*n,q[i])\n    print(bs[qr])\n\n\n
# cook your dish here\nfor i in range(int(input())):\n    N = int(input())\n    l = list(map(int, input().split()))\n    for j in range(int(input())):\n        q1, q2 = map(int, input().split())\n        temp = l[q1 - 1 : q2]\n        print(sum(temp))
for _ in range(int(input())):\n n,k=list(map(int,input().split()))\n c=list(map(int,input().split()))\n count=1\n for i in range(n):\n  if i+1<n:\n   if c[i]-c[i+1]>=k or c[i+1]-c[i]>=k:\n    continue\n   else:\n    count+=1\n    c[i],c[i+1]=c[i+1],c[i]\n print(count)\n    \n
def f(a,y,index,sorted_pos):\n #print(a,y,index,sorted_pos)\n n=len(a)\n low=0\n high=n-1\n L,R=0,0\n l,r=0,0\n while(low<=high):\n  mid=(low+high)//2\n  #print(low,high,mid)\n  if(a[mid]== y):\n   break\n  elif(mid > index[y]):\n   high=mid-1\n   L+=1\n   #print("L")\n   if(a[mid] <y):\n    l+=1\n    #print(" l ")\n  else:\n   low=mid+1\n   R+=1\n   #print("R")\n   if(a[mid]>y):\n    r+=1\n    #print("r")\n x=sorted_pos[y]\n #print(L,R,l,r,x,n-x-1)\n if(R>x or L> n-x-1):\n  print("-1")\n else:\n  print(max(l,r))\n\n\ndef fun():\n test=int(input())\n for t in range(test):\n  n,q=list(map(int,input().split()))\n  arr=list(map(int,input().split()))\n  index= dict()\n  for i in range(n):\n   index[arr[i]]=i\n  sorted_pos=dict()\n  a=sorted(arr)\n  for i in range(n):\n   sorted_pos[a[i]]=i\n  for x in range(q):\n   y=int(input())\n   f(arr,y,index,sorted_pos)\n\nfun()\n\n
t=int(input())\nfor _ in range (t):\n str1=input()\n str2=input()\n res='No'\n for i in str1:\n  if i in str2:\n   res='Yes'\n   break\n print(res)\n
# cook your dish here\nimport sys\nimport math\n\ndef main(arr):\n    for i in range(1,len(arr)-1):\n        if arr[i]==arr[i-1] and arr[i]==arr[i+1]:\n            return "Yes"\n    return "No"\n\ntest=int(input())\nfor _ in range(test):\n    b=int(input())\n    arr=list(map(int,input().split()))\n    print(main(arr))\n\n        
\ntest=int(input())\nfor t in range(test):\n n= int(input())\n\n adj=[[] for i in range(n+1)]\n\n for _ in range(n-1):\n  a,b=list(map(int,input().split()))\n  adj[a].append(b)\n  adj[b].append(a)\n \n\n #print(adj)\n root=1\n q,s=[root],set([root])\n\n for x in q:\n  adj[x]= [p for p in adj[x] if p not in s]\n  q.extend(adj[x])\n  s.update(adj[x])\n\n #print(adj)\n ans=True\n if(n<4):\n  ans=False\n for i in range(n+1):\n  if(len(adj[i]) %3!=0):\n   ans=False\n if(ans):\n  print("YES")\n  for i in range(n+1):\n   while(len(adj[i])):\n    print(i,adj[i][0],adj[i][1],adj[i][2])\n    adj[i].pop(0)\n    adj[i].pop(0)\n    adj[i].pop(0)\n else:\n  print("NO")\n
from math import sqrt\n\nfor _ in range(int(input())):\n n = int(input())\n\n x = int(sqrt(2 * n))\n\n while x * (x+1) // 2 <= n:\n  x += 1\n\n while x * (x+1) // 2 > n:\n  x -= 1\n\n n -= x * (x+1) // 2\n\n print(n)\n
# cook your dish here\r\nfrom collections import deque, defaultdict\r\nfrom math import sqrt, ceil,factorial\r\nimport sys\r\nimport copy\r\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\r\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\r\ndef input(): return sys.stdin.readline().strip()\r\n\r\nfor _ in range(int(input())):\r\n\r\n    s=input()\r\n    if len(s)>6:\r\n        ans=0\r\n        rem=len(s)-6\r\n        ans+=factorial(len(s))\r\n        ans-=2*(factorial(len(s)-2))\r\n        ans+=factorial(rem+2)\r\n        print(ans)\r\n\r\n    else:\r\n        if 'k' in s and 'r' in s and 'a' in s and 's' in s and 'h' in s and 'i' in s:\r\n            ans = 0\r\n            rem = len(s) - 6\r\n            ans += factorial(len(s))\r\n            ans -= 2 * (factorial(len(s) - 2))\r\n            ans += factorial(rem + 2)\r\n            print(ans)\r\n        else:\r\n            if 'k' in s and 'a' in s and 'r' in s:\r\n                ans=0\r\n                rem=len(s)-3\r\n                ans+=factorial(len(s))\r\n                ans-=factorial(rem+1)\r\n                print(ans)\r\n                continue\r\n            if 's' in s and 'h' in s and 'i' in s:\r\n                ans = 0\r\n                rem = len(s) - 3\r\n                ans += factorial(len(s))\r\n                ans -= factorial(rem + 1)\r\n                print(ans)\r\n                continue\r\n\r\n            print(factorial(len(s)))\r\n\r\n
#! /usr/bin/env python\n\nfrom sys import stdin\nfrom functools import reduce\n\ndef gcd(a,b):\n	while b!=0:\n		a,b=b,a%b\n	return a\n	\ndef gcdl(l):\n	return reduce(gcd, l[1:],l[0])\n\ndef __starting_point():\n	T=int(stdin.readline())\n	for case in range(T):\n		numbers=list(map(int, stdin.readline().split()[1:]))\n		g=gcdl(numbers)\n		\n		numbers=[n/g for n in numbers]\n		print(" ".join([str(x) for x in numbers]))\n\n__starting_point()
for _ in range(int(input())):\n a,o,g=map(int,input().split())\n while g>0:\n  if a<o:\n   a+=1\n   g-=1\n  elif o<a:\n   o+=1\n   g-=1\n  else:\n   break\n print(abs(a-o))
for _ in range(int(input())):\n n,m=map(int, input().split())\n if n==1:\n  print(0)\n elif n==2:\n  print(m)\n else:\n  print(m*2+n-3)
for t in range(int(input())):\n n=int(input())\n a=list(map(int,input().split()))\n s=0\n l=[]\n for i in range(n):\n  if (a[i]<0):\n   e=i\n   ss=sum(a[s:e])\n   l.append((ss,e-s,n-s))\n   s=i+1\n e=n\n ss=sum(a[s:e])\n l.append((ss,e-s,n-s))\n x=max(l)\n s=n-x[2]\n e=x[1]+s\n for i in range(s,e):\n  print(a[i], end=' ')\n print("")
for _ in range(int(input())):\n st=input().replace("=","")\n if not len(st):print(1)\n else:\n  cu=mx=1\n  for j in range(1,len(st)):\n   if st[j]==st[j-1]:cu+=1\n   else:mx=max(mx,cu);cu=1\n  print(max(mx+1,cu+1))\n
for _ in range(int(input())):\r\n    S = input()\r\n    n = len(S)\r\n    a = n - S.count('a')\r\n    print(2 ** n - 2 ** a)
knows=input()\nn=eval(input())\nwhile n!=0:\n n=n-1\n word=input()\n for x in word:\n  ctr=0\n  for y in knows:\n   if x==y:ctr=ctr+1;break\n  if ctr==0:print('No');break\n else: print('Yes')
# cook your dish here\nfor i in range(int(input())):\n n,b=map(int,input().split())\n ans=round(n/(2*b))*(n-b*round((n/(2*b))));\n print(ans)
t=int(input())\ndef check():\n    pref = [0]*n\n    pref[0]=a[0]\n    suff = [0]*n\n    suff[-1]=a[-1]\n    for i in range (1,n):\n        pref[i] = pref[i-1]|a[i]\n        suff[n-i-1] = suff[n-i]|a[n-i-1]\n    if suff[1]==k:\n        return 0\n    elif pref[n-2]==k:\n        return n-1\n    else:\n        for i in range (1,n-1):\n            if pref[i-1]|suff[i+1] == k:\n                return i\n        return -1\nwhile(t):\n    t-=1\n    n,k=[int(i) for i in input().split()]\n    a=[int(i) for i in input().split()]\n    ans = []\n    arr = [0]*n\n    for i in range (n):\n        if k|a[i] != k:\n            a[i] = a[i-1]|a[(i+1)%(n)]\n            ans.append(i+1)\n            arr[i]=1\n\n    x = 0\n    count = 0\n    for i in range (n):\n        x|=a[i]\n        \n    if x!= k:\n        print(-1)\n    else:\n        y = check()\n        if y == -1:\n            print(-1)\n        else:\n            for i in range (y,n+y):\n                if arr[i%n]==0:\n                    arr[i%n]==1\n                    ans.append((i%n)+1)\n            print(*ans)
from sys import stdin, stdout\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nmod = pow(10, 9) + 7\nmod2 = 998244353\ndef inp(): return stdin.readline().strip()\ndef out(var, end="\n"): stdout.write(str(var)+"\n")\ndef outa(*var, end="\n"): stdout.write(' '.join(map(str, var)) + end)\ndef lmp(): return list(mp())\ndef mp(): return map(int, inp().split())\ndef smp(): return map(str, inp().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ndef remadd(x, y): return 1 if x%y else 0\ndef ceil(a,b): return (a+b-1)//b\n\ndef isprime(x):\n    if x<=1: return False\n    if x in (2, 3): return True\n    if x%2 == 0: return False\n    for i in range(3, int(sqrt(x))+1, 2):\n        if x%i == 0: return False\n    return True\n\nfor _ in range(int(inp())):\n    n = int(inp())\n    for i in range(n):\n        for j in range(n):\n            if i==0 or i==n-1 or j==0 or j==n-1 or i==j or i+j==n-1:\n                print(1, end="")\n            else:\n                print(" ", end="")\n        print()
# your code goes here\nfrom sys import stdin, stdout\nn = int(stdin.readline())\nwhile n:\n n -= 1\n k, l, e = map(int, stdin.readline().strip().split(' '))\n a = map(int, stdin.readline().strip().split(' '))\n x = float(l) / float(e + sum(a))\n if x - int(x):\n  stdout.write("NO\n")\n else:\n  stdout.write("YES\n")
import sys\nimport bisect as bi\nimport math\nfrom collections import defaultdict as dd\ninput=sys.stdin.readline\n##sys.setrecursionlimit(10**7)\ndef cin():\n    return list(map(int,sin().split()))\ndef ain():            \n    return list(map(int,sin().split()))\ndef sin():\n    return input()\ndef inin():\n    return int(input())\nfor _ in range(inin()):\n    s=sin().strip();q=inin();a=ain();n=len(s);store=[0]*n;store1=[-1]*n;f=0;d=dd(int)#input wgera\n    store[0]=1 if s[0]=='(' else -1\n    d[store[0]]=1\n    for i in range(1,n):\n        if(s[i]=='('):\n            store[i]=store[i-1]+1\n            d[store[i]]=i+1\n        else:\n            store[i]=store[i-1]-1\n            if(d[store[i-1]]):\n                store1[d[store[i-1]]-1]=i+1\n    post=[-1]*n;\n    if(n==1 or(n==2 and s!="()")):f=1   # corner case\n    for i in range(n-2,-1,-1):\n        if(s[i]=='('):    #dekhna h ki agla agr ( h toh -1 hi rhega wrna wo jo stored tha uppr\n            if(store1[i]!=-1):post[i]=store1[i] #wo iska ans ho jayega\n        else:post[i]=post[i+1]  #jo iske agle ka answer hoga wahi iska hoga\n    for i in a:\n        if(f):print(-1)  #cond ki jaroorat nhi thi pr tasalli (>_<)\n        else:print(post[i-1]) #wrna uska ans print kra do\n    \n    \n##n=m=0\n##s=''\n##t=''\n##dp=[]\n##def solve(inds,indt,k,cont):\n##    ans=-999999999999999\n##    print(dp)\n##    if(k<0):return 0\n##    elif(inds>=n and indt>=m):return 0\n##    elif(dp[inds][indt][k][cont]!=-1):return dp[inds][indt][k][cont]\n##    else:\n##        if(indt<m):ans=max(ans,solve(inds,indt+1,k,0))\n##        if(inds<n):ans=max(ans,solve(inds+1,indt,k,0))\n##        if(s[inds]==t[indt]):\n##            ans=max(ans,solve(inds+1,indt+1,k-1,1)+1)\n##            if(cont):ans=max(ans,solve(inds+1,indt+1,k,1)+1)\n##        dp[inds][indt][k][cont]=ans\n##        return ans    \n\n##    n,m,k=cin()\n##    s=sin().strip()\n##    t=sin().strip()\n##    dp=[[[[-1]*2 for i in range(k)] for i in range(m+1)] for i in range(n+1)]\n##    c=0\n##    for i in dp:\n##        for j in i:\n##            for l in j:\n##                c+=1\n##                print(l,c)\n##    print(solve(0,0,k,0))\n
n=int(input())\nfor i in range(n):\n t=int(input())\n m=list(map(int,input().split()))\n p,q=0,0\n if t==1:\n  if m[0]>=0:\n   print('YES')\n  else:\n   print('NO')\n else:\n  for i in m:\n   if i<0:\n    q+=i\n   else:\n    p+=i\n  if p>=abs(q):\n   print('YES')\n  else:\n   print('NO')
for z in range(int(input())):\n    s = input()\n    n = len(s)\n    i = 0\n    while i<n and s[i]=='1':\n        i+=1\n    if i==0:\n        print(0)\n    else:\n        k = 0\n        while i<n and s[i]=='0':\n            i+=1\n            k+=1\n        print(k)\n
import functools\n\ndef gcd(x,y):\n if(y == 0):\n  return x\n return gcd(y, x%y)\n\nfor _ in range(int(input())):\n n, m= map(int, input().split())\n p = list(map(int, input().split()))\n \n ans = functools.reduce(lambda x,y: gcd(x, y), p)\n \n if(ans <= n):\n  print(n-ans)\n else:\n  f = [1]\n  for k in range(ans//2, 1, -1):\n   if ans %k == 0:\n    if k<=n:\n     f.append(k)\n     \n    if ans//k <= n:\n     f.append(ans//k)\n  res = n-max(f)\n  print(res)
# cook your dish here\nfor t in range(int(input())):\n    n,k=map(int,input().split())\n    a=[]\n    sr=[]\n    for i in range(k):\n        x,y=input().split()\n        y=int(y)\n        a.append([10**10-y,x])\n        sr.append(sorted(x))\n    for i in range(n-k):\n        x,y=input().split()\n        y=int(y)\n        x=sorted(x)\n        for j in range(k):\n            if x==sr[j]:\n                a[j][0]-=y\n                break\n    a.sort()\n    for i in a:\n        print(i[1],abs(i[0]-10**10))
n=int(input())\r\na=list(map(int,input().split()))\r\nc=[]\r\nfor i in range(len(a)):\r\n    if a[i]==2:\r\n        c.append(1)\r\n    else:\r\n        c.append(a[i]^2)\r\nprint(*c)
def gcd(a, b):\n if a == 0:\n  return b\n return(gcd(b % a, a))\n\nt = int(input())\nfor T in range(t):\n n = int(input())\n l = [int(x) for x in input().split()]\n\n ang = []\n for i in range(1, n):\n  ang.append(l[i] - l[i - 1])\n ang.append(360 - (l[-1] - l[0]))\n ang.sort()\n if ang == ang[::-1]:\n  print(0)\n  continue\n \n g = ang[0]\n for i in range(1, n):\n  g = gcd(g, ang[i])\n\n \n total = 360 // g - len(ang)\n print(total)\n##    print(g, ang, total)\n\n\n
# cook your dish here\nfor i in range(int(input())):\n s = input()\n m = 0\n p = 0\n d = 0\n l = []\n for i in range(len(s)):\n  if(s[i] == "."):\n   m = m+1\n  elif(s[i] == "#"):\n   l.append(m)\n   m=0\n for i in range(len(l)):\n  if(l[i]>p):\n   p = l[i]\n   d = d+1\n print(d)\n   \n  \n   \n  \n
for _ in range(int(input())):\n n,x,m = map(int,input().split())\n a = list(map(int,input().split()))\n for _ in range(m):\n  for i in range(1,n):\n   a[i] = a[i] + a[i-1]\n print(a[x-1]%(10**9+7))
for _ in range(int(input())):\n N = input()\n num = list(N)\n s=0\n for n in num:\n  if n.isnumeric():\n   s+=int(n)\n #print(s)\n x=(10-s%10)%10\n print(int(N)*10+int(x))
import sys\n\ndef mex(S,W,C,start,end):\n    """Returns Nim-number of S[start:end]"""\n    key=(start,end)\n    try:\n        return C[key]\n    except KeyError:\n        pass\n    A=set()\n    for s in range(start,end):\n        for e in range(start+1,end+1):\n            if S[s:e] not in W: continue\n            A.add(mex(S,W,C,start,s)^mex(S,W,C,e,end))\n    a=0\n    while a in A: a+=1\n    C[key]=a\n    return a\n    \n\na=sys.stdin\n#a=open('astrgame.txt','r')\nT=int(a.readline())\nfor t in range(T):\n    S=a.readline().strip()\n    N=int(a.readline())\n    W=set([a.readline().strip() for n in range(N)])\n    print('Teddy' if mex(S,W,{},0,len(S)) else 'Tracy')\n    \n
# cook your dish here\n# cook your dish here\nfor i in range(int(input())):\n a=list(map(int,input().split()))\n x=input()\n t=0\n for i in range(ord('a'),ord('z')+1):\n  if chr(i) not in x:\n   t+=a[i-97]\n print(t)
def solve(a,n):\n max1=curr=a[0]\n for i in range(1,n):\n  curr=max(a[i],curr+a[i])\n  max1=max(max1,curr)\n return max1\n \nn,k = list(map(int,input().split()))\na = list(map(int,input().split()))\nprint(sum(a)-solve(a,n)+solve(a,n)/k)\n
def binarySearch(arr, l, r, x):\n mid=0\n while l <= r: \n  mid = l + (r - l)//2; \n  if arr[mid] == x: \n   return mid+1 \n  elif arr[mid] < x: \n   l = mid + 1\n  else: \n   r = mid - 1\n if mid!=len(arr):\n  if arr[mid]<x:\n   return mid+1\n return mid\ns=input()\nstrt=[]\nend=[]\nplc=[]\nlandr=[]\nl2r=[]\nlr=[]\nans=0\nn=len(s)\nif n!=1:\n for i in range(n):\n  strt.append([])\n  end.append([])\n  landr.append([0]*n)\n  l2r.append([0]*n)\n for i in range(n):        \n  for j in range(n):\n   if i-j<0 or i+j>=n:\n    break\n   if (s[i-j]==s[i+j]):\n    if i-j-1>=0:\n     strt[i-j-1].append(2*j+1)\n    if i+j+1<n:\n     end[i+j+1].append(2*j+1)\n   else:\n    break\n for i in range(n):\n  for j in range(n):\n   if i-j<0 or i+j+1>=n:\n    break\n   if (s[i-j]==s[i+j+1]):\n    if i-j-1>=0:\n     strt[i-j-1].append(2*j+2)\n    if i+j+2<n:\n     end[i+j+2].append(2*j+2)\n   else:\n    break\n for i in range(n):\n  end[i].sort()\n  strt[i].sort()\n for i in range(n-1):\n  for j in range(i+1,n):\n   if s[i]==s[j]:\n    lr.append([i,j])\n    if i>0 and j<n-1:\n     landr[i][j]=landr[i-1][j+1]+1\n    else:\n     landr[i][j]=1\n for i in lr:\n  tempans=1\n  l=i[0]\n  r=i[1]\n  length=r-l-1\n  tempans+=binarySearch(strt[l],0,len(strt[l])-1,length)\n  tempans+=binarySearch(end[r],0,len(end[r])-1,length)\n  l2r[l][r]=tempans\n for i in range(n):\n  for j in range(n):\n   ans+=l2r[i][j]*landr[i][j]\nprint(ans)
import sys\nfrom random import choice,randint\ninp=sys.stdin.readline\nout=sys.stdout.write\nflsh=sys.stdout.flush\n \nsys.setrecursionlimit(10**9)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n \ndef MI(): return map(int, inp().strip().split())\ndef LI(): return list(map(int, inp().strip().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines().strip()]\ndef LI_(): return [int(x)-1 for x in inp().strip().split()]\ndef LF(): return [float(x) for x in inp().strip().split()]\ndef LS(): return inp().strip().split()\ndef I(): return int(inp().strip())\ndef F(): return float(inp().strip())\ndef S(): return inp().strip()\ndef pf(s): return out(s+'\n')\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\ndef main():\n    from math import ceil\n    t = I()\n    l = []\n    for _ in range(t):\n        n,k=MI()\n        if n==0:\n            k-=1\n            ans = ((k)*((k+1)))%mod\n            l.append(ans)\n        else:\n            # if k==1:\n            #     ans = ((((n)*((n-1)))%mod)+ n%mod)%mod\n            #     l.append(ans)\n            # else:\n            #     k-=1\n            #     lr = (n%mod+((ceil(k/2)%mod))%mod\n            #     ans = ((lr*((lr-1))%mod\n            #     if k%2!=0:\n            #         ans= (ans%mod + n%mod)%mod\n            #     else:\n            #         ans = ((ans%mod)+((lr+n)%mod))%mod\n            #     l.append(ans)\n            if k%2!=0:\n                lr = k//2\n                l.append(((n*n)%mod+(lr*((2*n)%mod))%mod+(lr*(lr+1))%mod)%mod)\n            else:\n                lr = k//2\n                l.append(((n*n)%mod + (lr*(2*n)%mod)%mod + (lr*(lr-1))%mod)%mod)\n\n    for i in range(t):\n        pf(str(l[i]))\n\ndef __starting_point():\n    main()\n__starting_point()
# cook your dish here\nt = int(input())\nfor _ in range(t):\n n = int(input())\n a = []\n b = []\n for i in range(n):\n  x,y = list(map(int, input().split()))\n  a.append(x)\n  b.append(y)\n b.sort()\n xcor = []\n xcor.append(a[1]-a[0])\n xcor.append(a[n-1]-a[n-2])\n for i in range(1,n-1):\n  xcor.append(a[i+1]-a[i-1])\n xcor.sort()\n ans = 0\n #print(xcor)\n #print(b)\n for i in range(n):\n  ans = ans + xcor[i]*b[i]\n print(ans) \n
n, k = list(map(int, input().split()))\nA = list(map(int, input().split()))\nmaximum = max(A)\nminimum = min(A)\nif k == 0:\n for i in A:\n  print(i, end=' ')\nelif k&1:\n for i in A:\n  print(maximum - i, end=' ')\nelse:\n for i in A:\n  print(i - minimum, end=' ')\n
from collections import deque\nt=int(input())\n\nfor i in range(t):\n n=int(input())\n N=[i for i in range(1, n+1)]\n w=list(map(int, input().split()))\n max_sweetness=max(w)\n sizes=[]\n cnt=0\n for i in range(n):\n  if w[i]!=max_sweetness:\n   cnt+= 1 \n  else:\n   sizes.append(cnt)\n   cnt=0\n \n if cnt!=0:\n  sizes[0]=(cnt+sizes[0])\n \n res=0\n for i in range(len(sizes)):\n  res+=max(sizes[i]-n//2+1, 0)\n \n print(res)
import math\n\nt = int(input())\n\na = [-1, 0, 1]\n\nfor i in range(58):\n temp = a[-1] + a[-2]\n temp = temp%10\n a.append(temp)\n \nfor _ in range(t):\n n = int(input())\n \n temp = len(bin(n)) - 3\n temp = 2**temp\n temp = temp%60\n \n print(a[temp])
# cook your dish here\nn=(int(input()))\nx=[]\nfor _ in range(n):\n    a,b=map(int,input().split())\n    a=[a,a+b]\n    x.append(a)\nx = sorted(x, key= lambda i:i[1])\ny=-1\nc=0\nfor i in range(len(x)):\n    if x[i][0]>y:\n        c+=1\n        y=x[i][1]\nprint(c)
m= 9999999\r\nword=''\r\np= ''\r\ntry:\r\n      s=input().split()\r\n      for i in s:\r\n            if(len(i) <= m):\r\n                  m = len(i)\r\n                  word = i\r\n      p = word\r\n      for i in s:\r\n            p+= (' '+i+' '+ word)\r\n      \r\n      print(p)\r\n\r\n              \r\nexcept EOFError:\r\n\r\n      pass
for i in range(int(input())):\n N = int(input())\n s = 'zyxwvutsrqponmlkjihgfedcba'\n r = ''\n while True:\n  r = s[-N-1:] + r \n  if N < 26:\n   break\n  N -= 25\n print(r)
for _ in range(int(input())):\n r,c = map(int,input().split())\n l = []\n for k in range(r):\n  a = list(map(int,input().split()))\n  l.append(a)\n ans = "Stable" \n for i in range(r):\n  for j in range(c):\n   p = l[i][j]\n   count=0\n   if i-1>=0 and j>=0:\n    count+=1 \n   if i>=0 and j-1>=0:\n    count+=1 \n   if i+1<=r-1 and j<=c-1:\n    count+=1 \n   if i<=r-1 and j+1<=c-1:\n    count +=1\n   if count<=p:\n    ans = "Unstable"\n    break\n print(ans) 
# cook your dish here\ntest=int(input())\nfor _ in range(test):\n b=list(map(int,str(input()).split(' ')))\n c=str(input())\n li1=[0]\n li2=[0]\n for i1 in range(len(c)):\n  if c[i1]=='R':\n   li1.append(li1[len(li1)-1]+1)\n  elif c[i1]=='L':\n   li1.append(li1[len(li1)-1]-1)\n  elif c[i1]=='U':\n   li2.append(li2[len(li2)-1]+1)\n  else:\n   li2.append(li2[len(li2)-1]-1)\n if (max(li1)-min(li1)+1)<=b[1] and (max(li2)-min(li2)+1)<=b[0]:\n  print('safe')\n else:\n  print('unsafe')
# cook your dish here\nT = int(input())\nfor i in range(T):\n    l = list(map(int, input().split()))\n    n, k, m, x = l[0], l[1], l[2], l[3]\n    if k == 1:\n        if n == m:\n            print("yes")\n        else:\n            print("no")\n    elif m % k > 1:\n        print("no")\n    elif k == 2:\n        stack = []\n        var = 0\n        while m != 0:\n            var += m % k\n            stack.append(m % k)\n            m //= k\n        if var > n:\n            print("no")\n        elif var == n:\n            print("yes")\n        else:\n            for p in range(100):\n                for q in range(2, len(stack)):\n                    if stack[q - 1] == 0 and stack[q] >= 1:\n                        stack[q-1] = 2\n                        stack[q] -= 1\n                        var += 1\n                        if var == n:\n                            print("yes")\n            if var < n:\n                print("no")\n    else:\n        temp = 0\n        rog = 1\n        while m != 0:\n            if m % k > 2:\n                rog = 0\n                print("no")\n            temp += m % k\n            m //= k\n        if rog:\n            if temp == n:\n                print("yes")\n            else:\n                print("no")\n\n
'''input\n2\n3\n2 2 3\n4\n2 3 3 2\n'''\nimport math\n\nfor _ in range(int(input())):\n n = int(input())\n a = list(map(int, input().split()))\n count = 0\n i = 0\n while i < len(a):\n  if a[i] == 1:\n   count += 1\n   i += 1\n   continue\n  curr_gcd = a[i]\n  while i < len(a) and curr_gcd != 1:\n   curr_gcd = math.gcd(curr_gcd, a[i])\n   if curr_gcd == 1:\n    count += 1\n    i += 1\n    # print(i)\n    break\n   i += 1\n print(count)\n
for i in range(int(input())):\n	 n = int(input())\n	 P = list(map(float, input().split()))\n	 pr = 1\n	 for p in P:\n		  a = 100+p\n		  pr = (pr*a)/100\n	 pr = (pr-1)*100\n	 x = 6-len(str(int(abs(pr))))\n   	 if (x==1):\n   	 	 if (pr==0):\n   	 	 	print(0)\n		 elif (pr>0):\n		 	print("+"+str("%.1f" % round(pr,x)))\n		 else:\n		 	print(str("%.1f" % round(pr,x)))\n	 elif (x==2):\n   	 	 if (pr==0):\n   	 	 	print(0)\n		 elif (pr>0):\n		 	print("+"+str("%.2f" % round(pr,x)))\n		 else:\n		 	print(str("%.2f" % round(pr,x)))\n	 elif (x==3):\n   	 	 if (pr==0):\n   	 	 	print(0)\n		 elif (pr>0):\n		 	print("+"+str("%.3f" % round(pr,x)))\n		 else:\n		 	print(str("%.3f" % round(pr,x)))\n	 elif (x==4):\n   	 	 if (pr==0):\n   	 	 	print(0)\n		 elif (pr>0):\n		 	print("+"+str("%.4f" % round(pr,x)))\n		 else:\n		 	print(str("%.4f" % round(pr,x)))\n	 elif (x==5):\n   	 	 if (pr==0):\n   	 	 	print(0)\n		 elif (pr>0):\n		 	print("+"+str("%.5f" % round(pr,x)))\n		 else:\n		 	print(str("%.5f" % round(pr,x)))\n	 elif (x==6):\n   	 	 if (pr==0):\n   	 	 	print(0)\n		 elif (pr>0):\n		 	print("+"+str("%.6f" % round(pr,x)))\n		 else:\n		 	print(str("%.6f" % round(pr,x)))
# cook your dish here\n\nt=int(input())\nwhile(t):\n t=t-1\n n,k=list(map(int,input().split()))\n q=list(map(int,input().split()))\n days,rem=0,0\n for i in range(n):\n  rem+=q[i]\n  if(rem>=k):\n   rem-=k\n  else:\n   days=i+1\n   break\n  days+=1\n if(rem>=k):\n  days+=(rem//k)+1\n print(days)\n
# cook your dish here\nt=int(input())\nwhile t>0:\n    n=int(input())\n    l=list(map(int,input().split()))\n    l1=[]\n    c=1\n    for i in range(len(l)):\n        if l[i]==1:\n            l1.append(i)\n    for j in range(len(l1)-1):\n        if l1[j+1]-l1[j]<6:\n            c=0\n            break\n    if c:\n        print("YES")\n    else:\n        print("NO")\n            \n    t-=1
# cook your dish here\n\nt=int(input())\n\nfor i in range(t):\n n=int(input())\n a=list(map(int,input().split()))\n d={}\n for i in range(n):\n  if a[i]-1 not in d:\n   d[a[i]-1]=[i]\n  else:\n   d[a[i]-1].append(i)\n ans=False\n d1={}\n \n for i in d:\n  if ans==True:\n   break\n  for j in d:\n   if i!=j:\n    if a[i]==a[j] and i!=j:\n     ans=True\n     break\n if ans==True:\n  print('Truly Happy')\n else:\n  print('Poor Chef')\n
# cook your dish here\nt=int(input())\nfor i in range(t):\n s=input()\n fl=-1\n n=len(s)\n for i in range(n-2):\n  if(s[i:i+3]=="010" or s[i:i+3]=="101"):\n   fl=0\n   print("Good")\n   break\n\n if(fl==-1):\n  print("Bad")\n
def check(s):\n arr=[s[0]]\n l=len(s)\n f1=0\n for i in range(1,l):\n  if arr==[]: arr.append(s[i])\n  elif arr[-1]!=s[i]:arr.append(s[i])\n  else: del arr[-1]\n if arr==[]: return True\n else: return False\n \ncount = 0\nfor t in range(eval(input())):\n s=input().strip()\n if check(s): count+=1\nprint(count)
from itertools import permutations as p\ndef disc(a,b):\n for ai in a:\n  for bi in b:\n   if ai==bi:\n    return False\n return True\n\nfor i in range(eval(input())):\n n = eval(input())\n arr = list(map(int,input().split()))\n perms = list(p(arr))\n m = eval(input())\n offer = {}\n for i in range(m):\n  dup = list(map(int,input().split()))\n  try:\n   offer[dup[0]].append(dup[1:])\n  except:\n   offer[dup[0]] = [dup[1:]]\n ans = sum(arr)\n if n==1:\n  print(ans)\n elif n==2:\n  try:\n   if len(offer[2])>=1:\n    ans -= min(arr)\n  except:\n   pass\n  print(ans)\n elif n==3:\n  try:\n   if len(offer[3])>=1:\n    ans -= min(arr)\n  except:\n   pass\n  try:\n   if len(offer[2])>=1:\n    value = 9999999999\n    for item in perms:\n     cur = 0\n     cur += item[0]\n     cur += max(item[1],item[2])\n     if cur<value:\n      value = cur\n    if value<ans:\n     ans = value\n  except:\n   pass\n  print(ans)\n elif n==4:\n  try:\n   if len(offer[4])>=1:\n    ans -= min(arr)\n  except:\n   pass\n  #print ans\n  try:\n   if len(offer[3])>=1:\n    value = 9999999999\n    for item in perms:\n     cur = 0\n     cur = sum(item)\n     cur -= min(item[1],item[2],item[3])\n     if cur<value:\n      value = cur\n    if value<ans:\n     ans = value\n  except:\n   pass\n  #print ans\n  try:\n   if len(offer[2])>=1:\n    value = 9999999999\n    for item in perms:\n     cur = 0\n     cur = sum(item)\n     cur -= min(item[1],item[2])\n     if cur<value:\n      value = cur\n    if value<ans:\n     ans = value\n    #print ans\n   #print offer[2]\n   if len(offer[2])>=2:\n    flg = False\n    end = len(offer[2])\n    for i in range(end):\n     for j in range(i+1,end):\n      if disc(offer[2][i],offer[2][j]):\n       flg = True\n       break\n    #print flg\n    if flg:\n     value = 9999999999\n     for item in perms:\n      cur = 0\n      cur = sum(item)\n      cur -= min(item[1],item[0])\n      cur -= min(item[2],item[3])\n      if cur<value:\n       value = cur\n     if value<ans:\n      ans = value\n  except:\n   pass\n  print(ans)\n elif n==5:\n  try:\n   if len(offer[5])>=1:\n    ans -= min(arr)\n  except:\n   pass\n  try:\n   if len(offer[4])>=1:\n    value = 9999999999\n    for item in perms:\n     cur = 0\n     cur = sum(item)\n     cur -= min(item[1],item[2],item[3],item[4])\n     if cur<value:\n      value = cur\n    if value<ans:\n     ans = value\n  except:\n   pass\n  try:\n   if len(offer[2])>=1:\n    value = 9999999999\n    for item in perms:\n     cur = 0\n     cur = sum(item)\n     cur -= min(item[1],item[2])\n     if cur<value:\n      value = cur\n    if value<ans:\n     ans = value\n   if len(offer[2])>=2:\n    flg = False\n    end = len(offer[2])\n    for i in range(end):\n     for j in range(i+1,end):\n      if disc(offer[2][i],offer[2][j]):\n       flg = True\n       break\n    if flg:\n     value = 9999999999\n     for item in perms:\n      cur = 0\n      cur = sum(item)\n      cur -= min(item[1],item[0])\n      cur -= min(item[2],item[3])\n      if cur<value:\n       value = cur\n     if value<ans:\n      ans = value\n  except:\n   pass\n  try:\n   if len(offer[3])>=1:\n    value = 9999999999\n    for item in perms:\n     cur = 0\n     cur = sum(item)\n     cur -= min(item[1],item[2],item[3])\n     if cur<value:\n      value = cur\n    if value<ans:\n     ans = value\n  except:\n   pass\n  try:\n   if len(offer[3])>=1 and len(offer[2])>=1:\n    flg = False\n    for i in offer[3]:\n     for j in offer[2]:\n      if disc(i,j):\n       flg = True\n       break\n    if flg:\n     value = 9999999999\n     for item in perms:\n      cur = 0\n      cur = sum(item)\n      cur -= min(item[1],item[0])\n      cur -= min(item[2],item[3],item[4])\n      if cur<value:\n       value = cur\n     if value<ans:\n      ans = value\n  except:\n   pass\n  print(ans)\n\n\n
\nt=int(input())\nfor i in range(t):\n l=list(map(int,input().split(' ')))\n a=l[0]\n b=l[1]\n \n l1=list(map(int,input().split(' ')))\n for i in range(b):\n  l2=list(map(int,input().split(' ')))\n  a1=l2[0]\n  b1=l2[1]\n  su=0\n  for j in range(a1-1,b1):\n   su=(su+l1[j])%1000000000\n  print(su) 
from sys import stdin\n\nfor _ in range(int(stdin.readline())):\n m, n = list(map(int, stdin.readline().split()))\n final = []\n arr = []\n val = 0\n extra = 0\n for j in range(m):\n  ans = list(map(str, stdin.readline().split()))\n  if ans.count('N') == n:\n   val += 1\n  else:\n   if val%2 == 0:\n    arr.append(ans)\n    extra += val\n   else:\n    arr.append(['N']*n)\n    arr.append(ans)\n    extra += (val-1)\n   val = 0\n\n for j in range(len(arr)):\n  ans = arr[j]\n  start = -1\n  for i in range(n):\n   if ans[i] == 'P':\n    start = i\n    break\n  if start != -1:\n   for i in range(n-1, -1, -1):\n    if ans[i] == 'P':\n     end = i\n     break\n  if start != -1:\n   if len(final) == 0:\n    final.append([start, end])\n   else:\n    if j%2 == 0:\n     if final[-1][0] > start:\n      final[-1][0] = start\n     else:\n      start = final[-1][0]\n    else:\n     if final[-1][1] < end:\n      final[-1][1] = end\n     else:\n      end = final[-1][1]\n    final.append([start, end])\n  else:\n   if len(final) != 0:\n    start, end = 0, n-1\n    if j%2 == 0:\n     if final[-1][0] > start:\n      final[-1][0] = start\n     else:\n      start = final[-1][0]\n    else:\n     if final[-1][1] < end:\n      final[-1][1] = end\n     else:\n      end = final[-1][1]\n    final.append([start, end])\n if len(final) == 0:\n  print(0)\n else:\n  count = 0\n  for ele in final:\n   count += (ele[1]-ele[0]+1)\n  print(count-1+extra)\n      \n
def CeilIndex(A, l, r, key): \n  \n    while (r - l > 1): \n      \n        m = l + (r - l)//2\n        if (A[m] >= key): \n            r = m \n        else: \n            l = m \n    return r \n   \ndef LongestIncreasingSubsequenceLength(A, size): \n  \n    # Add boundary case, \n    # when array size is one \n   \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 # always points empty slot \n   \n    tailTable[0] = A[0] \n    len = 1\n    for i in range(1, size): \n      \n        if (A[i] < tailTable[0]): \n  \n            # new smallest value \n            tailTable[0] = A[i] \n   \n        elif (A[i] > tailTable[len-1]): \n  \n            # A[i] wants to extend \n            # largest subsequence \n            tailTable[len] = A[i] \n            len+= 1\n   \n        else: \n            # A[i] wants to be current \n            # end candidate of an existing \n            # subsequence. It will replace \n            # ceil value in tailTable \n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n          \n   \n    return len\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    a=[]\n    for i in range(n):\n        a.append(list(map(int,input().split())))\n    a.sort()\n    b=[0]*n\n    for i in range(n):\n        b[i]=a[i][1]\n  \n    print(LongestIncreasingSubsequenceLength(b, n)) \n
t=int(input())\nfor i in range(t):\n    n,k=list(map(int,input().split(" ")))\n    arr=list(map(int,input().strip().split(" ")))[:n]\n    def maxCircularSum(arr, n, k):\n        if (n < k):\n            print("Invalid");\n            return;\n\n        sum = 0;\n        start = 0;\n        end = k - 1;\n\n        for i in range(k):\n            sum += arr[i];\n\n        ans = sum;\n\n        for i in range(k, n + k):\n            sum += arr[i % n] - arr[(i - k) % n];\n\n            if (sum > ans):\n                ans = sum;\n                start = (i - k + 1) % n;\n                end = i % n;\n\n        print(ans);\n\n    def __starting_point():\n        maxCircularSum(arr, n, k);\n__starting_point()
n=int(input())\nfor i in range(n):\n  l=list(map(int,input().split()))\n  k=l[0]+l[1]\n  k=k%(2*l[2])\n  \n  if k>=0 and k<l[2]:\n    print("CHEF")\n  else:\n    print("COOK")\n
for _ in range(int(input())):\n n,k=list(map(int,input().split()))\n a=list(map(int,input().split()))\n def check(mid):\n  d,left={},0\n  for i in range(mid):\n   if a[i]>k:\n    if a[i] not in d: \n     d[a[i]]=1\n    else: \n     d[a[i]]+=1\n  if len(d)==1:\n   return True\n  for i in range(mid,n):\n   if a[left]>k:\n    d[a[left]]-=1\n    if d[a[left]]==0: \n     del d[a[left]]\n   if a[i]>k:\n    if a[i] not in d: \n     d[a[i]]=1\n    else: \n     d[a[i]]+=1\n   if len(d)==1: \n    return True\n   left+=1\n  return False\n   \n lo,hi=0,n\n while lo<=hi:\n  mid=(lo+hi)//2\n  #print(mid,lo,hi)\n  if check(mid):\n   res=mid\n   lo=mid+1\n  else:\n   hi=mid-1\n print(res)\n   \n   \n   \n
t = eval(input())\nfor _ in range(t):\n n = eval(input())\n a = input().strip().split()\n cb, cs = 0, ""\n for i in range(len(a[0])):\n  for j in range(i+1,len(a[0])+1):\n   al = True\n   s = a[0][i:j]\n   for k in a[1:]:\n    if s not in k:\n     al = False\n     break\n   if al:\n    if j-i>=cb:\n     cb = max(cb, j-i)\n     if len(cs) < cb:\n      cs = a[0][i:j]\n     elif len(cs) == cb:\n      cs = min(cs,a[0][i:j])\n print(cs)
# cook your dish here folding paper\nfrom collections import Counter\ndef li():return [int(i) for i in input().rstrip('\n').split()]\ndef st():return input().rstrip('\n')\ndef val():return int(input().rstrip('\n'))\ndef dist(a,b):return ((a[0]-b[0])**2+(a[1]-b[1])**2)**0.5\nfor _ in range(val()):\n n,m,w,h=li()\n s=Counter(st())\n l=[]\n for i in range(m):\n  l.append(li())\n ans=float('inf')\n l.sort(key=lambda x:x[0])\n for j in range(1,50):\n  for i in range(j,m):\n   ans=min(ans,dist(l[i-j],l[i]))\n for i in l:\n  if s['D'] or s['U']>1:ans=min(ans,2*i[1])\n  if s['U'] or s['D']>1:ans=min(ans,2*(h-i[1]))\n  if s['L'] or s['R']>1:ans=min(ans,2*i[0])\n  if s['R'] or s['L']>1:ans=min(ans,2*(w-i[0]))\n print(ans)
t = int(input())\nlist_to_tri = []\nfor i in range(t):\n    list_to_tri.append(int(input()))\nlist_to_tri.sort()\nfor i in list_to_tri:\n    print(i)\n
for _ in range(eval(input())):\n n=eval(input())\n mod=1000000007\n f1,f2=[0]*101000,[0]*101000\n f1[1]=0\n f1[2]=2\n f1[3]=3\n f2[1]=1\n f2[2]=1\n f2[3]=2;\n for i in range(4,100001):\n  f1[i]=f1[i-1]%mod+f1[i-2]%mod+f1[i-3]%mod\n  f2[i]=f2[i-1]%mod+f2[i-2]%mod+f2[i-3]%mod\n print(f1[n]%mod,f2[n]%mod) 
def subCount(arr, n, k):\r\n\r\n    mod = []\r\n    for i in range(k + 1):\r\n        mod.append(0)\r\n\r\n\r\n    cumSum = 0\r\n    for i in range(n):\r\n        cumSum = cumSum + arr[i]\r\n\r\n        # as the sum can be negative,\r\n        # taking modulo twice\r\n        mod[((cumSum % k) + k) % k] = mod[((cumSum % k) + k) % k] + 1\r\n\r\n    result = 0  # Initialize result\r\n\r\n    for i in range(k):\r\n\r\n\r\n        if (mod[i] > 1):\r\n            result = result + (mod[i] * (mod[i] - 1)) // 2\r\n\r\n\r\n    result = result + mod[0]\r\n\r\n    return result\r\nt=int(input())\r\nwhile t:\r\n    t=t-1\r\n    n=int(input())\r\n    a=list(map(int,input().split()))\r\n    for i in range(n):\r\n        if a[i]==100000000:\r\n            a[i]=1\r\n        elif a[i]==900000000:\r\n            a[i]=9\r\n    s=10\r\n\r\n    print(subCount(a,n,s))\r\n
t=int(input())\ndef reversebinary(bits,n):\n    bStr=''\n    for i in range(bits):\n        if n>0:\n            bStr=bStr+str(n%2)\n        else:\n            bStr=bStr+'0'\n        n=n>>1\n    return int(bStr,2)\n        \nfor i in range(t):\n    k,msg=input().split()\n    k=int(k)\n    newmsg=[]\n    for j in msg:\n        newmsg.append(j)\n    for j in range(len(msg)):\n        newmsg[reversebinary(k,j)]=msg[j]\n    print(''.join(newmsg))\n        \n    \n
import math\np=7+10**9\nn,k=list(map(int,input().split()))\nc=math.factorial(n+k-1)//((math.factorial(k))*(math.factorial(n-1)))\nprint(c%p)\n
t =int(input()) #no. of test cases\nwhile t>0:\n t=t-1\n str=input()\n size=len(str)\n pos=str.find('W')\n left=pos\n right=size-pos-1\n arr = [[0 for i in range(right+1)] for j in range(left+1)]\n #arr[i,j] = 1 if with i black cells on left and j on right 1st player can win, 0 otherwise.\n #Recursion: arr[i][j]= or(arr[x][y])\n arr[0][0]=0\n for i in range(left+1):\n  for j in range(right+1):\n   if i==j:\n    arr[i][j]=0\n   else:\n    arr[i][j]=1\n if(arr[left][right]==1):\n  print("Aleksa")\n else:\n  print("Chef")\n
import sys\nimport math\nimport heapq\ndef half(n):\n return n//2\ndef main(arr,m):\n a,b,c=arr\n \n while m!=0:\n  \n  \n  \n  s=max(a,b,c)\n  \n  if s==a:\n   a=half(a)\n  elif s==b:\n   b=half(b)\n  else:\n   c=half(c)\n  m-=1\n return max(a,b,c)\n   \n \n \n \n \n\nfor i in range(int(input())):\n r,g,b,m=list(map(int,input().split()))\n arr=[]\n for j in range(3):\n  c=max(list(map(int,input().split())))\n  arr.append(c)\n \n print(main(arr,m))\n
dt, a = None, None\ndef dfs(z):\n    r = [{}, {}];ln = len(dt[z])\n    if ln == 0:r[0][0] = 0;r[1][1 << a[z]] = 1\n    elif ln == 1:\n        l = dfs(dt[z][0]);r[0] = l[1]\n        for m in l[0]:            r[1][(1 << a[z]) | m] = min(r[1][(1 << a[z]) | m], l[0][m] + 1) if (1 << a[z]) | m in r[1] else l[0][m] + 1\n        for m in l[1]:            r[1][(1 << a[z]) | m] = min(r[1][(1 << a[z]) | m], l[1][m] + 1) if (1 << a[z]) | m in r[1] else l[1][m] + 1\n    elif ln == 2:\n        l0 = dfs(dt[z][0]);l1 = dfs(dt[z][1])\n        for i0 in range(2):\n            for i1 in range(2):\n                for m0 in l0[i0]:\n                    for m1 in l1[i1]:r[1][(1 << a[z]) | m0 | m1] = min(r[1][(1 << a[z]) | m0 | m1], l0[i0][m0] + l1[i1][m1] + 1) if (1 << a[z]) | m0 | m1 in r[1] else l0[i0][m0] + l1[i1][m1] + 1\n        for m0 in l0[1]:\n            for m1 in l1[1]:                r[0][m0 | m1] = min(r[0][m0 | m1], l0[1][m0] + l1[1][m1]) if m0 | m1 in r[0] else l0[1][m0] + l1[1][m1]\n    return r\nfor i in range(int(input())):\n    n, m, k = map(int, input().split());a = [0] + [int(x) - 1 for x in input().split()];dt = [[] for i in range(n + 1)];\n    for i in range(m):u, v = map(int, input().split());dt[u].append(v)\n    r = dfs(1);k = (1 << k) - 1\n    if (k in r[0]):        v = min(r[0][k], r[1][k])\n    elif (k in r[1]):        v = r[1][k]\n    else:        v = -1\n    print(v)
a, b = [int(x) for x in input().split()]\nr = list(str(a-b))\nif r[0] == "1":\n r[0] = "2"\nelse:\n r[0]="1"\nprint("".join(r))\n
n=int(input())\nwhile n>0:\n i=1\n a,b=(int(i) for i in input().split())\n if (b+1)%(i<<a)==0:\n  print("ON")\n else:\n  print("OFF")\n n=n-1\n
n=int(input())\ndef do():\n t=int(input())\n x=[]\n for i in range(t):\n  x.append(int(input()))\n print(max(x))\n return\nfor i in range(n):\n do()
string=input()\nmax_no=0\nfor i in range(len(string)):\n var_occur=0\n check_no=str()\n j=i\n while(j<len(string) and var_occur<2 ):\n  if(string[j].isalpha()):\n   if(var_occur==0):\n    check_no+='9'\n    var_occur+=1\n   else:\n    var_occur+=1\n  else:\n   check_no+=string[j]\n  j+=1\n #print(check_no)\n max_no=max(max_no,int(check_no))\nprint(max_no)
# cook your dish here\nfrom collections import Counter\ndef solve(arr, n, k):\n ans = 0\n dict1 = {}\n mod = 1000000007\n \n for i in range(n):\n  if arr[i] in dict1:\n   dict1[arr[i]] += 1 \n  else:\n   dict1[arr[i]] = 1\n l1 = [0]+list(dict1.keys())\n v = min(k, len(l1))\n dp = [[0 for _ in range(v+1)]for _ in range(len(l1))]\n dp[0][0] = 1\n for i in range(1, len(l1)):\n  dp[i][0] = 1\n  for j in range(1, v+1):\n   dp[i][j] = dp[i-1][j] + dp[i-1][j-1]*dict1[l1[i]]\n for i in range(v+1):\n  ans += dp[len(l1)-1][i]\n  ans = ans%mod\n return ans\n \n\nn, k = map(int, input().strip().split())\narr = list(map(int, input().strip().split()))\nprint(solve(arr, n, k))
# cook your dish here\nfrom itertools import combinations\na = list(map(int, input().split()))\nn = a[0]\nt = a[1]\nq = list(combinations(a[2:], 4))\ntotal = 0\nfor i in q:\n    if sum(i) == t:\n        total += 1\nprint(total)\n
import sys\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\nfor i in range(int(input())):\n    n, k = map(int, input().split())\n    arr = []\n    if k == 2 or k == 4 or n % 2 != 0 or n == k:\n        arr.append('-1')\n    elif k % 2 != 0:\n        for i in range(int(n / 2)):\n            arr.append('(')\n        for i in range(int(n / 2)):\n            arr.append(')')\n    elif int(n / (k - 2)) == 1:\n        if (n - 2) % 4 == 0:\n            for i in range(int((n - 2) / 4)):\n                arr.append('(')\n            for i in range(int((n - 2) / 4)):\n                arr.append(')')\n            arr.append('()')\n            for i in range(int((n - 2) / 4)):\n                arr.append('(')\n            for i in range(int((n - 2) / 4)):\n                arr.append(')')\n        else:\n            for i in range(int((n - 4) / 4)):\n                arr.append('(')\n            for i in range(int((n - 4) / 4)):\n                arr.append(')')\n            arr.append('(())')\n            for i in range(int((n - 4) / 4)):\n                arr.append('(')\n            for i in range(int((n - 4) / 4)):\n                arr.append(')')\n    else:\n        for i in range(int((n % (k - 2)) / 2)):\n            arr.append('(')\n        for i in range(int(n / (k - 2))):\n            for j in range(int((k - 2) / 2)):\n                arr.append('(')\n            for j in range(int((k - 2) / 2)):\n                arr.append(')')\n        for i in range(int((n % (k - 2)) / 2)):\n            arr.append(')')\n\n    print("".join(arr))\n
for _ in range(int(input())):\r\n    n,m=map(int,input().split())\r\n    print("Case "+str(_+1)+":")\r\n    for i in range(m):\r\n        s=input()\r\n        ls=len(s)\r\n        if ls>n:\r\n            print("0")\r\n        else:\r\n            k=(n-ls+1)\r\n            print((k*pow(26,n-ls,1000000007))%1000000007)\r\n
# cook your dish here\nt=int(input())\nfor _ in range(t):\n st=input()\n s=set(st)\n a=[]\n f1=f2=0\n for i in s:\n  a.append(st.count(i))\n a.sort()\n if len(a)>=3:\n  for i in range(2,len(a)):\n   if a[i]!=a[i-1]+a[i-2]:\n    f1=1\n    break\n  x=a[0]\n  a[0]=a[1]\n  a[1]=x\n  for i in range(2,len(a)):\n   if a[i]!=a[i-1]+a[i-2]:\n    f2=1\n    break\n  if f1==1 and f2==1:\n   print("Not")\n  else:\n   print("Dynamic")\n else:\n  print("Dynamic")
def gcd(a,b):\r\n	if b==0:return a\r\n	else:return gcd(b,a%b)\r\ndef lcm(a,b):\r\n	m=a*b\r\n	g=gcd(a,b)\r\n	return int(m/g)\r\nfor _ in range(int(input())):\r\n	x,y=[int(x) for x in input().split()]\r\n	l=lcm(x,y)\r\n	s=int(l/x)\r\n	t=int(l/y)\r\n	print(s+t-2)
n=int(input())\r\ncost=[]\r\nd={}\r\nval_desc=[0]*n\r\nvisited=set()\r\nvisited.add(0)\r\ndfstack=[]\r\ndesc = [[False for i in range(n)] for i in range(n)]\r\nfor i in range(n):\r\n	cost.append(int(input()))\r\n	d[i]=[]\r\n\r\nfor i in range(n-1):\r\n	j,k=list(map(int,input().split()))\r\n	d[j-1].append(k-1)\r\n	d[k-1].append(j-1)\r\n\r\ndef dfs(u):\r\n	val_desc[u]+=cost[u]\r\n	dfstack.append(u)\r\n	for i in dfstack:\r\n		desc[u][i]=True\r\n	for i in d[u]:\r\n		if i not in visited:\r\n			visited.add(i)\r\n			dfs(i)\r\n			val_desc[u]+=val_desc[i]			\r\n	dfstack.pop(-1)\r\n\r\ndfs(0)\r\nmp=10**9\r\ncoco=sum(cost)\r\nfor i in range(n):\r\n	for j in range(i+1,n):\r\n		vali=val_desc[i]\r\n		valj=val_desc[j]\r\n		if desc[i][j]:\r\n			valj-=val_desc[i]\r\n		if desc[j][i]:\r\n			vali-=val_desc[j]\r\n		p=max(vali,valj,coco-vali-valj)\r\n		mp=min(mp,p)\r\n#print(desc)\r\n#print(val_desc)\r\n#print\r\nprint(mp)\r\n\r\n\r\n	\r\n
# cook your dish here\ndef isValid(mid):\n time = 0.0\n for i in range(n):\n  if time < c[i]:\n   time = c[i]\n   time += mid # cannon cooling\n  elif time >= c[i] and time <= c[i] + d:\n   time += mid # cannon cooling\n  else:\n   return False\n return True\n\nt = int(input())\nwhile t != 0:\n n, d = list(map(int, input().split()))\n c = list(map(int, input().split()))[:n]\n ans = -1\n c.sort()\n low, high = 0, 10 ** 10\n while (high - low) > 0.000001:\n  mid = (low + high) / 2\n  if isValid(mid):\n   ans = mid\n   low = mid\n  else:\n   high = mid \n print("{0:.6f}".format(ans))\n t -= 1\n
\r\n\r\nd = 10**9 + 7\r\n\r\nt = int(input())\r\nwhile t:\r\n    t-=1\r\n    n =int(input())\r\n    p =list(map(int, input().strip().split()))\r\n    a =list(map(int, input().strip().split()))\r\n    b =list(map(int, input().strip().split()))\r\n    ans = 1\r\n    for i in range(n):\r\n        c = a[i] - b[i] + 1\r\n        tmp = (( pow(p[i],b[i],d) * ((pow(p[i],c,d) - 1 + d)%d) * pow(p[i]-1 , d-2, d)%d))\r\n        ans *= tmp\r\n        ans = ans%d\r\n\r\n    print(ans)
# cook your dish here\n\nfor _ in range(int(input())):\n friends = int(input())\n candies = list(map(int,input().split()))\n if (sum(candies) % friends == 0):\n  print("Yes")\n else:\n  print("No")
t = int(input())\nfor _ in range(t):\n n = int(input())\n k = int(input())\n num = int(k/n)\n x = max(n*(1+num) - k, 0)\n diff = abs(x - (n-x))\n if diff == 0:\n  number = 2*x - 1\n else:\n  number = min(x, n-x)*2\n print(number)
from sys import stdin,stdout\nimport math,bisect\nfrom datetime import date\nfrom collections import Counter,deque,defaultdict\nL=lambda:list(map(int, stdin.readline().strip().split()))\nM=lambda:list(map(int, stdin.readline().strip().split()))\nI=lambda:int(stdin.readline().strip())\nS=lambda:stdin.readline().strip()\nC=lambda:stdin.readline().strip().split()\ndef pr(a):return("".join(list(map(str,a))))\n#_________________________________________________#\n\ndef solve():\n    s = list(S())\n    a=[s[0]]\n    for i in range(1,len(s)):\n        if a and a[-1]==s[i]:\n            a.pop()\n        else:\n            a.append(s[i])\n    print(len(a))\n    \nfor _ in range(I()): \n    solve()\n
"""\n    Author : thekushalghosh\n    Team   : CodeDiggers\n"""\nimport sys,math\ninput = sys.stdin.readline\n############ ---- USER DEFINED INPUT FUNCTIONS ---- ############\ndef inp():\n    return(int(input()))\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input()\n    return(s[:len(s) - 1])\ndef invr():\n    return(map(int,input().split()))\n################################################################\n############ ---- THE ACTUAL CODE STARTS BELOW ---- ############\nt = 1\nt = inp()\nfor tt in range(t):\n    n,s = invr()\n    if n == 2 and s > 1:\n        print(s - 1)\n    elif n > 2 and s > 1:\n        print(0)\n    elif n == 1:\n        print(s)\n    else:\n        print(-1)
n,q=list(map(int,input().split()))\nfinal=[]\nheight=list(map(int,input().split()))\nfor k in range(0,q):\n b=input().split()\n if int(b[0])==1:\n  step=int(b[1])-1\n  for k in range(0,int(b[2])):\n   temp = 0\n   j=1\n   while j in range(1,101) and temp==0 and step+j<n:\n    if height[step+j]>height[step]:\n     step=step+j\n     temp=1\n    j+=1\n  final.append(step+1)\n elif int(b[0])==2:\n  for k in range(int(b[1])-1,int(b[2])):\n   height[k]=height[k]+int(b[3])\nfor l in range(0,len(final)):\n print(final[l])
def main():\n for _ in range(int(input())):\n  rows,column = map(int,input().split())\n  arr = []\n  for i in range(rows):\n   arr.append(list(input()))\n  string = input()\n  last = string[-1]\n  operation = Find(string,last)\n  for i in string[0]+operation:\n   if i == "L":\n    arr = Left(arr)\n   if i == "R":\n    arr = Right(arr)\n   if i == "U":\n    arr = Transpose(arr)\n    arr = Left(arr)\n    arr = Transpose(arr)\n   if i == "D":\n    arr = Transpose(arr)\n    arr = Right(arr)\n    arr = Transpose(arr)\n  for i in arr:\n   print(i)\ndef Left(arr):\n for i in range(len(arr)):\n  ans = arr[i].count("1")\n  arr[i] = "1"*ans + (len(arr[i]) - ans)*"0"\n return arr\ndef Right(arr):\n for i in range(len(arr)):\n  ans = arr[i].count("1")\n  arr[i] = (len(arr[i]) - ans)*"0"+"1"*ans\n return arr\ndef Transpose(arr):\n ansss = []\n ans = list(map(list, zip(*arr)))\n for i in ans:\n  ass = i\n  hello = ""\n  for j in ass:\n   hello += j\n  ansss.append(hello)\n return ansss \ndef Find(string,last):\n for i in string[-2::-1]: \n  if last == "L":\n   if i in ["D","U"]:\n    last = i + last\n    break\n  if last == "R":\n   if i in ["D","U"]:\n    last = i + last\n    break\n  if last == "D":\n   if i in ["L","R"]:\n    last = i + last\n    break\n  if last == "U":\n   if i in ["L","R"]:\n    last = i + last\n    break\n return last\n \ndef __starting_point():\n main()\n__starting_point()
import sys\r\n# import math\r\nfrom math import gcd\r\n# import re\r\n# from heapq import *\r\n# from collections import defaultdict as dd\r\n# from collections import OrderedDict as odict\r\n# from collections import Counter as cc\r\n# from collections import deque\r\n# sys.setrecursionlimit(10**5)#thsis is must\r\n# mod = 10**9+7; md = 998244353\r\n# m = 2**32\r\ninput = lambda: sys.stdin.readline().strip()\r\ninp = lambda: list(map(int,sys.stdin.readline().strip().split()))\r\n# def C(n,r,mod):\r\n#   if r>n:\r\n#       return 0\r\n#   num = den = 1\r\n#   for i in range(r):\r\n#       num = (num*(n-i))%mod\r\n#       den = (den*(i+1))%mod\r\n#   return (num*pow(den,mod-2,mod))%mod\r\n# M = 1000000+1\r\n# pfc = [i for i in range(M+1)]\r\n# def pfcs(M):\r\n#     for i in range(2,M+1):\r\n#         if pfc[i]==i:\r\n#             for j in range(i+i,M+1,i):\r\n#                 if pfc[j]==j:\r\n#                     pfc[j] = i\r\n#     return\r\n#______________________________________________________\r\nfor _ in range(int(input())):\r\n    n,k = map(int,input().split())\r\n    d = [[] for i in range(k+1)]\r\n    for i in range(n):\r\n        l,r,p = map(int,input().split())\r\n        d[p].append([l,r])\r\n    ans = 0\r\n    for i in d:\r\n        if len(i)==0:\r\n            continue\r\n        ans+=1\r\n        t = sorted(i,key = lambda x:(x[1],x[0]))\r\n        final = t[0][1]\r\n        for j in range(1,len(t)):\r\n            if t[j][0]>=final:\r\n                ans+=1\r\n                final = t[j][1]\r\n    print(ans)      
# cook your dish here\ntry:\n for i in range(int(input())):\n  n=int(input())\n  l=[int(j) for j in input().split()][:n]\n  d={}\n  for j in l:\n   d[j]=d.get(j,0)+1\n  a=len(d)\n  c=0\n  for j in list(d.keys()):\n   while(d[j]>=3):\n    d[j]=(d[j]//3)+(d[j]%3)\n   if(d[j]==2):\n    c=c+1\n  if(c&1):\n   s=0\n   for j in list(d.values()):\n    s=s+j\n   print(s-c-1)\n  else:\n   s=0\n   for j in list(d.values()):\n    s=s+j\n   print(s-c)\nexcept:\n pass\n    \n
t=eval(input())\nwhile t:\n t=t-1\n s1=input().lower()\n s2=input().lower()\n res="equal"\n for i in range(len(s1)):\n  if(s1[i]!=s2[i]):\n   \n   res="first" if s1[i]<s2[i] else "second"\n   break\n print(res)\n
def game(n,l,p):\n    if(len(l)==0):\n        return 0\n    l.sort()\n    if(len(l)>=1 and p<l[0]):\n        return 0\n    l.sort()\n    c=0\n    \n    \n    ma=set()\n    ma.add(0)\n    while(len(l)):\n        if(p>=l[0]):\n            p-=l[0]\n            \n            c+=1\n            ma.add(c)\n            l=l[1:]\n        else:\n            if(c>0):\n                c-=1\n                ma.add(c)\n                p+=l[-1]\n                l=l[:-1]\n            else:\n                return max(ma)\n    return max(ma)\nn=int(input())\nl=list(map(int,input().split()))\np=int(input())\nprint(game(n,l,p))
# cook your dish here\nx=int(input())\nfor i in range(x):\n    s=list(map(int,input().split()))\n    s.sort()\n    print(s[1])\n    \n    \n
def __starting_point():\n t=int(input())\n for _ in range(t):\n  n,k,v=map(int,input().split())\n  li=list(map(int,input().split()))\n  sumn=0\n  for i in range(n):\n   sumn=sumn+li[i]\n  sumk=v*(n+k)-sumn\n  e=int(sumk/k)\n  r=sumk%k\n  if e<=0:\n   print(-1)\n  elif r!=0:\n   print(-1)\n  else:\n   print(e)\n__starting_point()
# cook your dish here\nn = int(input())\nif(n%4==0):\n    print(n+1)\nelse:\n    print(n-1)
def matrixScore(A):\r\n        """\r\n        :type A: List[List[int]]\r\n        :rtype: int\r\n        """\r\n        m,n = len(A),len(A[0])\r\n        # \r\n        for i in range(m):\r\n            if A[i][0] == 1: continue\r\n            for j in range(n):\r\n                A[i][j] = 1 - A[i][j]\r\n\r\n        # \r\n        res = 0\r\n        for rows in zip(*A):\r\n         # 1\r\n            cnt1 = max(rows.count(1), rows.count(0))\r\n            res += cnt1 * 2**(n-1)\r\n            n -= 1\r\n        return res\r\nm, n = [int(s) for s in input().split(" ")]\r\narr = [[int(s) for s in input().split(" ")] for i in range(m)]\r\nans = matrixScore(arr)\r\nprint(ans)\r\n
# cook your dish here\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    array=list(map(int, input().split()))\n    list_sub=[]\n    idx=0\n    counter=0\n    for i in range(n-1):\n        if counter%2==0 and array[i]<=array[i+1]:\n            counter+=1 \n        elif counter%2==1 and array[i]>=array[i+1]:\n            counter+=1 \n        else:\n            list_sub.append((idx,i))\n            if counter%2==1:\n                idx=i \n                counter=1\n            else:\n                idx=i+1 \n                counter=0\n    list_sub.append((idx, n-1))\n    massimo=0\n    if len(list_sub)==1:\n        massimo=list_sub[0][1]-list_sub[0][0]+2\n    for i in range(len(list_sub)-1):\n        if list_sub[i][1]==list_sub[i+1][0]:\n            massimo=max(massimo, list_sub[i][1]-list_sub[i][0]+2+list_sub[i+1][1]-list_sub[i+1][0])\n        else:\n            massimo=max(massimo, list_sub[i][1]-list_sub[i][0]+3+list_sub[i+1][1]-list_sub[i+1][0])\n    print(massimo)
#binarr\r\ndef binarr(a, k, s):\r\n    a.sort(reverse=True)\r\n    arr = [0]*k\r\n    for i in range(k):\r\n        arr[i] = a[i]\r\n    if sum(arr) <= s:\r\n        return binarr(a, k+1, s)\r\n    return len(arr)\r\n\r\ntry:\r\n    n, k, s = list(map(int, input().split()))\r\n    a = list(map(int, input().split()))\r\n    print(binarr(a, k+1, s))\r\nexcept Exception:\r\n    pass\r\n
t = int(input())\nfor i in range(t):\n    n = int(input())\n    if n == 1 or n == 2 or n == 145 or n == 40585:\n        print(1)\n    else:\n        print(0)\n
try:\n from math import sqrt\n t,x=list(map(int,input().split()))\n for _ in range(t):\n  n=int(input())\n  if(n<0):\n   print("no")\n  else:\n   diff=(x/100)*n\n   ans=int(sqrt(n))\n   ans1=ans**2\n   if(n-ans1<=diff):\n    print("yes")\n   else:\n    print("no")\nexcept:\n pass\n
# cook your dish here\nfor t in range(int(input().strip())):\n    d = int(input().strip())\n    L, R = map(int, input().strip().split(" "))\n    if L % 2 == 0:\n        L += 1\n    sum = (((((R - L + 2)//2)//d)+1)//2) - 1\n    sum = (sum * 2 * d * (sum + 1) * d) + (sum+1) *d * (L + d -1)\n    print(sum%1000000007)
def least_rotation(S: str) -> int:\r\n    """Booth's algorithm."""\r\n    f = [-1] * len(S)  # Failure function\r\n    k = 0  # Least rotation of string found so far\r\n    for j in range(1, len(S)):\r\n        sj = S[j]\r\n        i = f[j - k - 1]\r\n        while i != -1 and sj != S[k + i + 1]:\r\n            if sj < S[k + i + 1]:\r\n                k = j - i - 1\r\n            i = f[i]\r\n        if sj != S[k + i + 1]:  # if sj != S[k+i+1], then i == -1\r\n            if sj < S[k]:  # k+i+1 = k\r\n                k = j\r\n            f[j - k] = -1\r\n        else:\r\n            f[j - k] = i + 1\r\n    return k\r\n\r\n\r\nfor _ in range(int(input())):\r\n    l, s = input().split()\r\n    if int(l) == 1:\r\n        l = len(s)\r\n        s += s\r\n        k = least_rotation(s)\r\n        print(s[k:k+l])\r\n    else:\r\n        print(''.join(sorted(s)))
# cook your dish here\nMOD = 998244353\n\nfball = [ [0]*101 for _ in range(101) ]\n\ncric = [ [0]*101 for _ in range(101) ] \n\n\n\ndef calSNum(n, r):\n if n == r or r == 1:\n  fball[r][n] = 1\n  return\n if n > 0 and r > 0 and n > r:\n  fball[r][n] = (fball[r-1][n-1]%MOD + (r*fball[r][n-1])%MOD )%MOD\n  return\n fball[r][n] = 0\n  \n\ndef calASNum(n, r):\n if n == 0 and r == 0 :\n  cric[r][n] = 0\n  return\n if n >= 2 and r == 1:\n  cric[r][n] = 1\n  return \n if r > 0 and n > 0 and n >= 2*r:\n  cric[r][n] = ((r*cric[r][n-1])%MOD + ((n-1)*cric[r-1][n-2])%MOD )%MOD\n  return\n cric[r][n] = 0\n \n\ndef preCompute():\n for r in range(1,101):\n  for n in range(1, 101):\n   calSNum(n, r)\n   calASNum(n, r)\n\n \ndef main():\n \n preCompute()\n for _ in range(int(input())):\n  f, c, r = list(map(int, input().split()))\n\n  ans = 0\n  \n  if f + (c//2) >= r:\n   minv = min(f, r)\n   \n   for i in range(1, minv+1):\n    if r-i <= c//2:\n     ans = (ans + (fball[i][f] * cric[r-i][c])%MOD )%MOD\n   \n  print(ans)\n   \ndef __starting_point():\n main()\n\n__starting_point()
# cook your dish here\nt=int(input())\nfor _ in range(t):\n n,m=list(map(int,input().split()))\n r=list(map(int,input().split()))\n rating=[[r[i]]*(m) for i in range(n)]\n ranking=[[0]*m for i in range(n)]\n for i in range(n):\n  diff=list(map(int,input().split()))\n  for j in range(m):\n   rating[i][j]+=diff[j]\n   if j+1<m:\n    rating[i][j+1]=rating[i][j]\n    \n for i in range(m):\n  rate=[[j,rating[j][i]] for j in range(n)]\n  rate=sorted(rate,key=lambda x: x[1],reverse=True)\n  c=1\n  gap=0\n  for j in range(n):\n   if j>0 and rate[j-1][1]==rate[j][1]:\n    gap+=1\n   if j>0 and rate[j-1][1]!=rate[j][1]:\n    c+=1+gap\n    gap=0\n   ranking[rate[j][0]][i]=c \n   \n count=0\n for i in range(n):\n  rate=rating[i].copy()\n  i1=rate.index(max(rate))\n  rank=ranking[i].copy()\n  i2=rank.index(min(rank))\n  if i1!=i2:\n   count+=1\n print(count)\n
# cook your dish here\n\nt = int(input())\n\nfor _ in range(t):\n    s = ''\n    n = int(input())\n    if n==1:\n        print(1)\n        continue\n    for i in range(1, n+1):\n        s = s + str(i)\n    print(s)\n    \n    p = 1\n    for i in range(n-1):\n        s = ''\n        for j in range(n):\n            s = s + str(p + n)\n            p = p+1\n            \n        print(s)\n        \n
t = int(input())\r\nfor _ in range(t):\r\n    nd = list(map(int, input().split()))\r\n    n = nd[0]\r\n    d = nd[1]\r\n    cutOff = []\r\n    x = d\r\n    buses = list(map(int, input().split()))\r\n    for i in range(len(buses)-1,-1,-1):\r\n        x = x - x%buses[i]\r\n    print(x)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            \r\n\r\n
def max_sum(arr):\n    # Finds the maximum sum of sub-arrays of arr\n    max_till_now = -1000000 #minimum possible number \n    current_sum = 0\n    for i in range(len(arr)):\n        if current_sum < 0:\n            # If sum of previous elements is negative, then ignore them. Start fresh\n            # with `current_sum = 0`\n            current_sum = 0\n        \n        current_sum += arr[i]\n        \n        # Update max\n        if max_till_now < current_sum:\n            max_till_now = current_sum\n    \n    return max_till_now\n\n\ndef solve(A, k):\n    if k == 1:\n        return max_sum(A)\n    # Find sum of elements of A\n    sum_A = 0\n    for i in range(len(A)):\n        sum_A += A[i]\n    \n    Max_Suffix_Sum = -1000000\n    current = 0\n    for i in range(len(A)):\n        current += A[-i-1]\n        if current > Max_Suffix_Sum:\n            Max_Suffix_Sum = current\n\n    Max_Prefix_Sum = -1000000\n    current = 0\n    for i in range(len(A)):\n        current += A[i]\n        if current > Max_Prefix_Sum:\n            Max_Prefix_Sum = current\n\n    if sum_A <= 0:\n        # Check two cases:\n\n        # Case 1 : Check the max_sum of A\n        case_1_max_sum = max_sum(A)\n        \n        # Case 2 : Check the max_sum of A + A\n        case_2_max_sum = Max_Suffix_Sum + Max_Prefix_Sum\n\n        # Return the maximum of the two cases\n        return max([case_1_max_sum, case_2_max_sum])\n\n    else: # if sum_A > 0\n        #Check two cases:\n\n        # Case 1 : Check the max_sum of A\n        case_1_max_sum = max_sum(A)\n\n        # Case 2\n        # Max sum = Max_Suffix_Sum + (k - 2)*sum_A + Max_Prefix_Sum       \n        \n        case_2_max_sum = Max_Suffix_Sum + (k - 2)*sum_A + Max_Prefix_Sum\n        \n        # Return the maximum of the two cases\n        return max([case_1_max_sum, case_2_max_sum])\n\n\n# Main\nT = int(input()) # No of test cases\nfor i in range(T):\n    [N, k] = list(map(int, input().split(" ")))\n    A = list(map(int, input().split(" ")))\n    \n    answer = solve(A,k)\n    print(answer)
T = int(input())\nfor _ in range(T):\n    N, M, K = [int(x) for x in input().split()]\n    UV = [[int(x) for x in input().split()] for _ in range(M)]\n    Q = int(input())\n    AB = [[int(x) for x in input().split()] for _ in range(Q)]\n \n    X = [[i] for i in range(N)]\n    for u, v in UV:\n     X[u - 1] += [v - 1]\n     X[v - 1] += [u - 1]\n \n    A = [[1 if i > 0 or j == 0 else 0 for j in range(N)] for i in range(K + 1)]\n    for a, b in AB:\n     A[b] = [1 if i == a - 1 else 0 for i in range(N)]\n \n    if A[0][0] == 1:\n     for k in range(K - 1, -1, -1):\n      for i in range(N):\n       if A[k][i] != 0:\n        A[k][i] = sum(A[k + 1][j] for j in X[i])\n \n    print(A[0][0])
def gcd(a,b):\n if b==0:\n  return a\n else:\n  return gcd(b,a%b)\n \ndef main():\n t=int(input())\n while t!=0:\n  t=t-1\n  n=int(input())\n  if n==1:\n   print(input())\n  else:\n   a=list(map(int,input().split(" ")))\n   p=a[0]\n   for i in range(1,n):\n    p=gcd(p,a[i])\n    if p==1:\n     break\n   print(n*p)\ndef __starting_point():\n main()\n  \n  \n\n__starting_point()
for i in range(int(input())):\n n,s =map(int,input().split())\n l1=list(map(int,input().split()))\n l2=list(map(int,input().split()))\n m=[]\n n=[]\n for i in range(len(l1)):\n  if l2[i]==0:\n   m.append(l1[i])\n  else:\n   n.append(l1[i])\n if len(m)>0 and len(n)>0:\n  if 100-s>=(min(m)+min(n)):\n   print("yes")\n  else:\n   print("no")\n else:\n  print("no")
# cook your dish here\nfrom math import sqrt\nfor i in range(int(input())):\n x1,y1,x2,y2=list(map(float,input().split()))\n m=(y2-y1)/(x2-x1)\n c=y2-m*x2\n print('Test case : ',i+1)\n q=int(input())\n for i in range(q):\n  x3,y3=list(map(float,input().split()))\n  if(y3-m*x3-c==0):\n   print("YES")\n  else:\n   d=(abs(y3-m*x3-c))/sqrt(1+m*m)\n   print("NO")\n   print("%.6f" % d)\n
from math import gcd\r\nfrom math import ceil\r\nfrom itertools import combinations as c\r\nt=int(input())\r\nfor _ in range(t):\r\n    n,m,a,d=list(map(int,input().split()))\r\n    \r\n    l=[]\r\n    for i in range(5):\r\n        l.append(a+i*d)\r\n    ans=m-n+1\r\n    for i in range(1,6):\r\n        x=list(c(l,i))\r\n        for j in x:\r\n            e=j[0]\r\n            for v in j:\r\n                e=(e*v)//gcd(e,v)\r\n            #print(e)\r\n            if i%2:\r\n                ans-=m//e-(n-1)//e\r\n            else:\r\n                ans+=m//e-(n-1)//e\r\n    print(ans)\r\n        \r\n    \r\n
import numpy as np\nfor _ in range(int(input())):\n ans = np.float('inf')\n n, m = (int(x) for x in input().split())\n sig = np.zeros((n,m))\n img = np.zeros((3*n,3*m))\n for row in range(n):\n  sig[row,:] = np.array([int(x) for x in input()])\n for row in range(n):\n  img[row+n,m:2*m] = np.array([int(x) for x in input()])\n for i in range(2*n):\n  for j in range(2*m):\n   ans = min(ans, np.abs(np.sum(img[i:n+i, j:m+j] != sig)))\n print(ans)
import math\ndef ispoweroftwo(y):\n return math.ceil(math.log(y,2))==math.floor(math.log(y,2))\nt=int(input())\nfor i in range(t):\n n=int(input())\n \n a=[]\n if(ispoweroftwo(n) and n!=1):\n  print(-1,end=" ")\n if(n==1):\n  print(1)\n \n if(n>=3 and not(ispoweroftwo(n))):\n  a.append(2)\n  a.append(3)\n  a.append(1)\n if(n>3 and not ispoweroftwo(n)):\n  i=4\n  while(i<=n):\n   if(ispoweroftwo(i)):\n    a.append(i+1)\n    a.append(i)\n    i+=2\n   else:\n    a.append(i)\n    i+=1\n print(*a)\n 
from collections import Counter\r\n\r\nfor _ in range(int(input())):\r\n    n=int(input())\r\n    l=[i for i in input().split()]\r\n    ll=[]\r\n    c=Counter(l)\r\n    cc=[]\r\n    m=0\r\n    for l,count in c.most_common(len(l)-1):\r\n        if m==0:\r\n            ll.append(l)\r\n            cc.append(count)\r\n            \r\n        if m==count:\r\n            ll.append(l)\r\n            cc.append(count)\r\n        if count<m:\r\n            break\r\n        m=count\r\n    k=set(cc)\r\n    leng=len(list(k))\r\n    if leng==1:\r\n        sor=sorted(ll)\r\n        print(sor[0])\r\n    else:\r\n        print(ll[0])\r\n
import sys\nimport datetime\na,b,c = list(map(int,sys.stdin.readline().split()))\nd = datetime.date(c,b,a)\nprint(d.strftime("%A"))
# cook your dish here\ntest_case = int(input())\nwhile test_case :\n n_people = int(input())\n array = list(map(int, input().strip().split()))\n sums =[0 for i in range(n_people)]\n \n sums[0] = array[0]\n \n for i in range(1, n_people) :\n  sums[i] = sums[i-1] + array[i]\n  \n # print(sums)\n\n k = 1 \n count = 0\n i = 0 \n while(k < n_people) :\n  k = k + sums[i]\n  # print(k)\n  i = i + sums[i]\n  count = count + 1\n print(count)\n \n \n test_case -= 1\n \n  #  2  1  1  5   5   5   5\n # [2, 3, 4, 9, 14, 19, 24]\n #  0  1  2  3  4   5   6 \n \n \n \n \n \n \n \n \n
t=eval(input())\n \na=[]\nb=[]\n \ntop=-1\n \nfor __ in range(0,t):\n \n x=input().split()\n \n if(x[0]!="-1" and x[0]!="0"):\n  \n  add=int(x[0])\n  \n  if top!=-1 and add>a[top][0] :\n    \n    b[top]+=1\n    \n  else:\n    a.append((add,x[1]))\n    \n    b.append(0)\n    top+=1\n  \n  \n elif (x[0]=="-1"):\n  \n  #print("%s %s" %(b[top],a[top][1]))\n  print((b[top]), end=' ')\n  print(a[top][1])\n  foo=a.pop()\n  bar=b.pop()\n  top-=1
t = int(input())\nl,r,x = 0,0,0\nans = []\nfor i in range(t):\n (n,m) = tuple(map(int,input().split()))\n a = list(map(int,input().split()))\n b = list(map(int,input().split()))\n suma = sum(a)\n sumb = sum(b)\n q = int(input())\n for j in range(q):\n  l1 = list(map(int,input().split()))\n  if l1[0] == 1:\n   l = l1[1]\n   r = l1[2]\n   x = l1[3]\n   suma = suma + (r-l+1)*x\n  elif l1[0] == 2:\n   l = l1[1]\n   r = l1[2]\n   x = l1[3]\n   sumb = sumb + (r-l+1)*x\n  else:\n   ans.append((suma*sumb)%998244353)\nfor i in range(len(ans)):\n print(ans[i])
\nfrom math import ceil\nfrom bisect import bisect_right as b_r\nfrom bisect import bisect_left as b_l\nar = list(map(int , input().split()))\na = [int(ceil((ar[1]-int(x)+1)/ar[2])) for x in input().split()]\ns = sum(a)\nar[1] = max(a)\nm = ar[1] - (s-ar[1])%2\nmi = s%2 \nprint(int( (m-mi)//2 +1)%(10**9+7))\n\n
n=int(input())\na=list(map(int,input().split()))\n\nl,r=-1,-1\nfor i in range(n):\n    if a[i]!=i+1:\n        l=i\n        break\n\nfor i in range(n-1,-1,-1):\n    if a[i]!=i+1:\n        r=i\n        break\n\nj=r+1\n\nfor i in range(l,r+1):\n    if a[i]==j:\n        j-=1\n        continue\n    else:\n        print(0,0)\n        return\n\nprint(l+1,r+1)
# cook your dish here\na = int(input())\nprint(a)
# cook your dish here\nimport math   \n  \n# Function to find the Largest  \n# Odd Divisor Game to check \n# which player wins  \ndef findWinner(n, k):  \n      \n    cnt = 0;  \n  \n    # Check if n == 1 then  \n    # player 2 will win  \n    if (n == 1): \n        print("Grinch");  \n  \n    # Check if n == 2 or n is odd  \n    elif ((n & 1) or n == 2): \n        print("Me");  \n  \n    else: \n        tmp = n;  \n        val = 1;  \n  \n        # While n is greater than k and  \n        # divisible by 2 keep  \n        # incrementing tha val  \n        while (tmp > k and tmp % 2 == 0):  \n            tmp //= 2;  \n            val *= 2;  \n              \n        # Loop to find greatest  \n        # odd divisor  \n        for i in range(3, int(math.sqrt(tmp)) + 1):  \n            while (tmp % i == 0): \n                cnt += 1;  \n                tmp //= i;  \n          \n        if (tmp > 1): \n            cnt += 1;  \n  \n        # Check if n is a power of 2  \n        if (val == n): \n            print("Grinch");  \n  \n        elif (n / tmp == 2 and cnt == 1): \n            print("Grinch");  \n  \n        # Check if cnt is not one  \n        # then player 1 wins  \n        else: \n            print("Me");  \n              \n# Driver code  \ndef __starting_point():  \n    for i in range(int(input())):\n        n=int(input()) \n        findWinner(n, 1);  \n__starting_point()
# https://www.codechef.com/problems/RECTLIT\r\n\r\ndef assess(sq,points):\r\n    EWct = 0\r\n    NSct = 0\r\n    for a,b in points:\r\n        EW = (a == 0 or a == sq)\r\n        NS = (b == 0 or b == sq)\r\n        if EW and NS:\r\n            return 'yes'\r\n        EWct += EW\r\n        NSct += NS\r\n    if NSct + EWct == 0 or len(points) == 1:\r\n        return 'no'\r\n    if EWct >= 2 or NSct >= 2:\r\n        return 'yes'\r\n    if len(points) == 2:\r\n        return 'no'\r\n    # now 3 points\r\n    if NSct == 1 and EWct == 1:\r\n        return 'yes'\r\n    # 3 points, one on edge\r\n    x = -1\r\n    for a,b in points:\r\n        if EWct > 0:\r\n            if a == 0 or a == sq:\r\n                e = b\r\n            elif x == -1:\r\n                x = b\r\n            else:\r\n                y = b\r\n        else:\r\n            if b == 0 or b == sq:\r\n                e = a\r\n            elif x == -1:\r\n                x = a\r\n            else:\r\n                y = a\r\n    if (e-x)*(e-y) < 0: # edge splits mids\r\n        return 'no'\r\n    else:\r\n        return 'yes'\r\n\r\n\r\nfor ti in range(int(input())):\r\n    k,n = map(int, input().split())\r\n    if k > 3:\r\n        for ki in range(k):\r\n            input()\r\n        print('yes')\r\n    else:\r\n        pos = [tuple(map(int, input().split())) for ki in range(k)]\r\n        print(assess(n-1,pos))\r\n\r\n
n=int(input())\nl=[]\nfor i in range(0,n):\n a,b,c=map(int,input().split())\n n1=(2**0.5)*(a/b)\n n2=2*(a/c)\n if n1>n2:\n  l.append("Elevator")\n else:\n  l.append("Stairs")\nfor i in l:\n print(i)
from sys import stdin\nt = int(stdin.readline())\n\ndef count(n, arr):\n loc = 0\n glob = 0\n for i in range(n-1):\n  if arr[i] > arr[i+1]:\n   loc += 1\n for i in range(n-1):\n  for j in range(i+1, n):\n   if glob > loc:\n    return 0\n   if arr[i] > arr[j]:\n    glob += 1;\n if glob == loc:\n  return 1\n return 0\n\nfor _ in range(t):\n n = int(stdin.readline())\n arr = list(map(int, stdin.readline().split()))\n result = count(n, arr)\n if result:\n  print("YES")\n else:\n  print("NO")
n = int(input())\n# this code only for 8 bits string and it isn't possible to more than 8 bits of string \n\n# for i in range(n):\n#      s = input()\n#      subString1, subString2 = s[:4], s[4:]\n#      rev = subString2[::-1]\n#      print( 'uniform'  if(subString1 == rev)  else 'non-uniform')\n  \nfor i in range(n):\n count = 0\n s = input()\n for i in range(1, len(s)):\n  if(s[i-1] != s[i]):\n   count += 1 \n   \n if(s[0] != s[-1]): \n  count += 1 \n print("uniform" if(count <=2 ) else "non-uniform")\n
# cook your dish here\nt=int(input())\ni=0\na=0\nd=dict()\nwhile i<t:\n    l=input().split()\n    d[int(l[0])]=int(l[0])+int(l[1])\n    i+=1\nfor k in d:\n    if d[k] in d:\n        if d[d[k]]==k:\n            a=1\n            break\nif a==1:\n    print("YES")\nelse:\n    print("NO")
n,k,m = map(int,input().split())\nar = list(map(int,input().split()))\nfsum = [ar[0]]\nfor i in range(1,n):\n    fsum.append(fsum[i-1]+ar[i])\ni = k\n#print(fsum)\nc = 0\nwhile i <= n:\n    if i == k:\n        s = fsum[i-1]\n    else:\n        s = fsum[i-1]-fsum[i-k-1]\n    if s == 0:\n        c = -1\n        break\n    if s < m:\n        c += 1\n        if i<n:\n            for j in range(i,i-k-1,-1):\n                if ar[j-1] >0:\n                    j += k-1\n                    i = j\n                    break\n        if i<n:\n            for j in range(i,i-k-1,-1):\n                if ar[j-1] >0:\n                    j += k-1\n                    i = j\n                    break\n    i += 1\ni = k\nwhile i <= n:\n    if i==k:\n        s = fsum[i-1]\n    else:\n        s = fsum[i-1] - fsum[i-k-1]\n    if s == 0 :\n        c = -1\n        break\n    i += 1\nprint(c)
T = int(input())\nfor _ in range(T):\n n = int(input())\n arr = list(map(int, input().split()))\n a = [0 for _ in range(max(arr)+1)]\n star_val = []\n for i in range(len(arr)):\n  j = 1\n  val = 0\n  while j*arr[i] <= len(a):\n   val += a[j*arr[i]-1]\n   j += 1\n  star_val.append(val)\n  a[arr[i]-1] += 1\n print(max(star_val))
VQ = "UAMmSs"\nn = int(input())\na = list(map(int, input().split()))\nfor _ in range(int(input())):\n q, x, y = input().split()\n if q not in VQ:\n  print("!!!")\n  continue\n if q == "U":\n  a[int(x) - 1] = int(y)\n  continue\n l = int(x) - 1\n r = int(y)\n if q == "A":\n  print(sum(a[l:r]))\n  continue\n if q == "M":\n  print(max(a[l:r]))\n  continue\n if q == "m":\n  print(min(a[l:r]))\n  continue\n s = sorted(set(a[l:r]))\n if len(s) < 2:\n  print("NA")\n else:\n  print(s[1] if q == "s" else s[-2])\n
# cook your dish here\nx=int(input())\nfor i in range(x):\n    s=int(input())\n    fact=1\n    for i in range(1,s+1):\n        fact=fact*i\n    print(fact)\n
import math\ndef fun(num1,num2):\n if num1>num2:\n  a=num1\n  b=num2\n else:\n  a=num2\n  b=num1\n rem=a%b\n while(rem!=0):\n  a=b\n  b=rem\n  rem=a%b\n gcd=b\n return (int((num1*num2)/gcd))\n  \nfor _ in range (int(input())):\n hours=int(input())*24\n x,y,z=list(map(int,input().split()))\n lcm=x\n lcm=fun(x,y)\n lcm=fun(lcm,z)\n print(int(hours//lcm))\n  \n  \n    \n
# cook your dish here\ntc=int(input())\nfor j in range(tc):\n ip=list(map(int,input().rstrip().split()))\n x=ip[0]\n y=ip[1]\n n=ip[2]\n cnt=0\n if(x==y):\n  print('0')\n  continue\n ln=bin(x).replace("0b", "") \n rn=bin(y).replace("0b", "") \n ll=len(ln)\n rl=len(rn)\n #print(ln)\n #print(rn)\n if(ll==len(rn)):\n  for i in range(ll):\n   \n   if(ln[i]!=rn[i]):\n    ln=ln[i:]\n    rn=rn[i:]\n    break\n #print(ln)\n if(ln[0]=='0'):\n  ln=ln[1:]\n  ll-=1\n #print(rn)\n if(rn[0]=='0'):\n  rn=rn[1:]\n  rl-=1\n ll=len(ln)\n rl=len(rn)\n if(ll>rl):\n  lb=ll \n else:\n  lb=rl \n pl=2**lb \n hpl=pl//2\n amn=((n+1)//pl)*hpl \n rm=(n+1)%pl \n if((rm*2)<=pl):\n  amn+=rm\n else:\n  amn+=hpl \n #print("amn = ",amn)\n aln=(n+1)-amn\n #print("aln = ",aln)\n if(x<y):\n  print(amn)\n else:\n  print(aln)
t=int(input())\nfor _ in range(t):\n n,m=list(map(int,input().split()))\n l=list(map(int,input().split()))\n k=[]\n for i in range(m):\n  a,b=list(map(int,input().split()))\n  k.append([a,b])\n k.sort()\n c=[]\n flag=1\n x=k[0][0]\n y=k[0][1]\n \n for i in k[1:]:\n  if i[0]<=y:\n   y=max(y,i[1])\n  else:\n   c.append([x-1,y-1])\n   x=i[0]\n   y=i[1]\n c.append([x-1,y-1])\n m=[]\n j=0\n \n for i in c:\n  while j<i[0]:\n   m.append(l[j])\n   j+=1\n  x=l[i[0]:i[1]+1]\n  m+=sorted(x)\n  j=i[1]+1\n  \n while j<n:\n  m.append(l[j])\n  j+=1\n \n if m==sorted(l):\n  print('Possible')\n else:\n  print('Impossible')\n  \n    \n \n  \n
# cook your dish here\ndef func(arr, k):\n    sumi = 0\n    for j in range(k):\n        sumi += arr[j]\n    maxi = sumi\n    for i in range(k,len(arr)):\n        sumi -= arr[i - k]\n        sumi += arr[i]\n        maxi = max(maxi,sumi)\n    return maxi\nfor _ in range(int(input())):\n    n, k = map(int,input().split())\n    arr = [int(x) for x in input().split()]\n    print(func(arr,k))
import math\nt = int(input())\n \ndef phi(n):\n	res = n\n	i = 2\n	while i*i<=n:\n		if n%i==0:\n			res/=i\n			res*=(i-1)\n \n			while n%i==0:\n				n/=i\n		i+=1\n	\n	if n>1:\n		res/=n\n		res*=(n-1)\n \n	return int(res)\n \nwhile t:\n	a,m = list(map(int,input().split()))\n	g = math.gcd(a,m)\n	print(phi(m//g))\n	t-=1\n
for T in range(int (eval(input()))):\n N,K,D=list(map(int,input().split()))\n A=list(map(int,input().split()))\n P=sum(A)//K \n print(min(P,D))\n
for t in range(int(input())):\n n = int(input())\n l = []\n m = []\n x = list(map(int,input().split()))\n l.append(x)\n m.append(list(x))\n for i in range(1,n):\n  x = list(map(int,input().split()))\n  l.append(x)\n  temp = []\n  for i in range(4):\n   temp.append (x[i]+min(m[-1][:i]+m[-1][i+1:]))\n  m.append(temp)\n print(min(m[-1]))
# cook your dish here\ndef main():\n    for _ in range(int(input())):\n     N, k = [int(x) for x in input().split()]\n     Powers = [k ** int(x) for x in input().split()]\n  \n     s1, s2 = 0, sum(Powers)\n  \n     ans = (0, None)\n  \n     i = 0\n     while i < N - 1:\n      s1 += Powers[i]\n      s2 -= Powers[i]\n   \n      z = s1 * s2 \n      if z > ans[0]:\n       ans = (z, i)\n       # print(z)\n   \n      i += 1\n  \n     print(ans[1] + 1)\n\nmain()
for i in range(int(input())):\n m,tc,th=map(int,input().split())\n x=(th-tc)\n if x%3!=0:\n  print("Yes")\n else:\n  if (x//3)<=m:\n   print("No")\n  else:\n   print("Yes")
pref = []\r\n\r\nfor i in range(10 ** 5 + 10):\r\n    b = bin(i)[2:]\r\n    if not any(b[j] == b[j+1] == '1' for j in range(len(b) - 1)):\r\n        pref.append(i)\r\n    else:\r\n        pref.append(pref[-1])\r\n\r\nfor i in range(int(input())):\r\n    print(pref[int(input())])\r\n
# cook your dish here\nfor _ in range(int(input())):\n    a,n,m = map(int,input().split(' '))\n    s = len(str(a))\n    #print(s)\n    c = 10**s - 1\n    w = c*m\n    b = pow(10,n*s,w)-1\n    d = b//c\n    ans = (d%m)*(a%m)\n    print(ans%m)  
ar = []\nar.append(1)\nfor i in range(1, 31):\n ar.append(ar[i-1]*(4*i-2)/(i+1))\nt = int(input())\nwhile(t>0):\n n = int(input())\n if(n==0):\n  print(0)\n else:\n  print(ar[n]*2)\n t=t-1\n
t=int(input())\nfor i in range(t):\n x,y=0,0\n n,m=list(map(int,input().split()))\n l=list(map(int,input().split()))\n if(max(l)>m):\n  print(-1)\n else:\n  for i in range(len(l)):\n   y+=l[i]\n   if(y>m):\n    y=l[i]\n    x+=1\n  if(y>0):\n   x+=1\n  print(x)\n
for t in range(eval(input())):\n  \n  n = eval(input())\n  \n  a = [ [] for i in range(n+1) ]\n  \n  for i in range(n-1):\n    x,y = list(map( int, input().split() ))\n    a[x].append(y)\n    a[y].append(x)\n  \n  vis = [0] * (n+1)\n  vis[1] = 1\n\n  ans = [1]\n\n  t1 = [1]\n  t2 = []\n  \n  while len(t1) > 0 :\n    for u in t1:\n      for x in a[u]:\n        if vis[x] == 0 :\n          vis[x] = 1\n          t2.append(x)\n    if len(t2) > 1 :\n      ans.append(t2[0])\n      ans.append(t2[-1])\n    if len(t2) == 1 :\n      ans.append(t2[0])\n    \n    t1 = t2\n    t2 = []\n  \n  for x in sorted(ans):\n    print(x, end=' ')\n  \n  print('')
# cook your dish here\nfor _ in range(int(input())):\n n,k = list(map(int,input().split()))\n mod = 10**9+7\n s=0\n for i in range(1,n+1):\n  p = pow(k,(2*i)-1,mod)\n  # print(p)\n  s=(s+p)%mod\n  # print(k)\n  k = (p*k)%mod\n print(s)\n\n
# cook your dish here\ntry:\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        gcd = max(a[0], a[-1])\n        \n        print(gcd)\nexcept EOFError:pass
def maxval(arr):\n    fn = [float('-inf')]*(len(arr)+1)\n    sn = [float('-inf')]*len(arr)\n    tn = [float('-inf')]*(len(arr)-1)\n    fon = [float('-inf')]*(len(arr)-2)\n    for i in reversed(list(range(len(arr)))):\n        fn[i] = max(fn[i + 1], arr[i])\n    for i in reversed(list(range(len(arr) - 1))):\n        sn[i] = max(sn[i + 1], fn[i + 1] - arr[i])\n\n    for i in reversed(list(range(len(arr) - 2))):\n        tn[i] = max(tn[i + 1], sn[i + 1] + arr[i])\n\n    for i in reversed(list(range(len(arr) - 3))):\n        fon[i] = max(fon[i + 1], tn[i + 1] - arr[i])\n    return fon[0]\nn = int(input())\narr = list(map(int,input().split()))\nprint(maxval(arr))\n    \n
def convertToParitys(s):\r\n    """\r\n    This converts the string s to an int, which is a bitMap of the parity of each letter\r\n    odd ? = first bit set\r\n    odd a = second bit set\r\n    odd b = third bit set \r\n    etc\r\n    """\r\n    keys = '?abcdefghijklmnopqrstuvwxyz'\r\n    paritys = {c:0 for c in keys}\r\n    for c in s:\r\n        paritys[c] += 1\r\n    for c, v in paritys.items():\r\n        paritys[c] = v%2\r\n    \r\n    out = 0\r\n    bitValue = 1\r\n    for c in keys:\r\n        if paritys[c]:\r\n            out += bitValue\r\n        bitValue *= 2\r\n    return out\r\n\r\ndef getSolutionBitMaps(s):\r\n    """\r\n    these are the 27 valid bitmaps that a substring can have\r\n    even ? and the parities the same\r\n    26 cases of odd ? and one bit different in the parity compared to s\r\n    """\r\n    out = []\r\n    sP = convertToParitys(s)\r\n    if sP%2:\r\n        sP -= 1 # to remove the '?' parity\r\n    #even case - \r\n    out.append(sP)\r\n    #odd cases - need to xor sP with 1 + 2**n n = 1 to 26 inc to flip ? bit and each of the others\r\n    for n in range(1,27):\r\n        out.append(sP^(1+2**n))\r\n    return out\r\n\r\ndef getLeadingSubStringBitMapCounts(s):\r\n    """\r\n    This calculates the bit map of each of the len(s) substrings starting with the first character and stores as a dictionary.\r\n    Getting TLE calculating each individually, so calculating with a single pass\r\n    """\r\n    out = {}\r\n    bM = 0\r\n    keys = '?abcdefghijklmnopqrstuvwxyz'\r\n    paritys = {c:0 for c in keys}\r\n    values = {c:2**i for i,c in enumerate(keys)}\r\n    out[bM] = out.setdefault(bM, 0) + 1  #add the null substring\r\n    bMis = []\r\n    i = 0\r\n    bMis = [0]\r\n    for c in s:\r\n        i += 1\r\n        if paritys[c]:\r\n            paritys[c] = 0\r\n            bM -= values[c]\r\n        else:\r\n            paritys[c] = 1\r\n            bM += values[c]\r\n        out[bM] = out.setdefault(bM, 0) + 1\r\n        bMis.append(bM)\r\n    return out,bMis\r\n\r\ndef solve(s):\r\n    out = 0\r\n    bMjCounts,bMis = getLeadingSubStringBitMapCounts(s)\r\n    #print('bMjCounts')\r\n    #print(bMjCounts)\r\n    solutions = getSolutionBitMaps(s)\r\n    #print('solutions')\r\n    #print(solutions)    \r\n    for bMi in bMis:\r\n        for bMs in solutions:\r\n            if bMs^bMi in bMjCounts:\r\n                out += bMjCounts[bMs^bMi]\r\n                #print(i,bMi,bMs,bMs^bMi,bMjCounts[bMs^bMi])\r\n    if 0 in solutions:\r\n        out -= len(s) #remove all null substrings\r\n    out //= 2 # since j may be less that i each substring is counted twice\r\n    return out\r\n                \r\nT = int(input())\r\nfor tc in range(T):\r\n    s = input()\r\n    print(solve(s))\r\n    
def gcd(a,b):\n if b==0: return a\n return gcd(b,a%b)\n\nfor _ in range(int(input())):\n n = int(input())\n arr = list(map(int,input().split()))\n value = arr[0]\n if n!=1:\n  for i in arr[1:]:\n   value = value*i//gcd(value, i)\n if value%2==0:\n  print("NO")\n else:\n  print("YES")
t=int(input())\ni=0\nwhile i<t:\n n=int(input())\n A=[]\n A=input().split()\n m=int(input())\n B=[]\n B=input().split()\n j=0\n a=-1\n while j<m:\n  c=1\n  if B[j] in A:\n   b=A.index(B[j])\n   A.remove(B[j])\n   if b>=a:\n    a=b\n    c=1\n   else:\n    c=0\n    break\n  else:\n   c=0\n   break\n  j+=1\n if c==1:\n  print("Yes")\n else:\n  print("No")\n i+=1
# cook your dish here\nimport math\nfor t in  range(int(input())):\n    n=int(input())\n    a=[int(i) for i in input().split()]\n    div=sum(a)/n\n    div=math.ceil(div)\n    count=div*n-sum(a)\n    for i in a:\n        if i>div:\n            count+=i-div\n    print(count)
# cook your dish here\ns = input().strip()\nstart_w = 27\nw_dict = {}\nwords = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]\nfor word in words:\n    w_dict[word] = start_w\n    start_w = start_w - 1\n\ntotal_wt = 0\nfor c in s:\n    total_wt = total_wt + w_dict[c]\n\nprint(total_wt)
import math\nn=1001\na=[True]*n\nl=[]\nfor i in range(2,33):\n if(a[i]):\n  for j in range(i*i,n,i):\n   a[j]=False\nfor pr in range(2,1001):\n if(a[pr]):\n  l.append(pr)\nt=int(input())\nfor j in range(t):\n n,m=list(map(int,input().strip().split()))\n arr=[int(num) for num in input().strip().split()]\n Matrix =[]\n index=[0]*100000\n factors=[0]*100000\n ans=''\n for r in range(len(arr)):\n  li=[]\n  for val in l:\n   while((arr[r]%val)==0):\n    arr[r]=arr[r]/val\n    li.append(val)\n    factors[r]+=1\n  if(arr[r]!=1):\n   li.append(arr[r])\n   arr[r]=1\n   factors[r]+=1\n  Matrix.append(li)\n for k in range(m):\n  opr=[int(o) for o in input().strip().split()]\n  L=opr[1]\n  R=opr[2]\n  if(opr[0]==0):\n   for ran in range(L-1,R):\n    if(index[ran]<factors[ran]):\n     index[ran]+=1\n  else:\n   result=1\n   for ran in range(L-1,R):\n    if(index[ran]<factors[ran]):\n     result=max(result,Matrix[ran][index[ran]])\n   ans+=str(result)\n   ans+=' '\n print(ans[:-1])
for i in range(int(input())):\n    print(2*(sum(list(map(int, input().split())))-1))
import sys\ninput = lambda: sys.stdin.readline().rstrip("\r\n")\ninp = lambda: list(map(int,sys.stdin.readline().rstrip("\r\n").split()))\n#______________________________________________________________________________________________________\n# from math import *\n# from bisect import *\n# from heapq import *\n# from collections import defaultdict as dd\n# from collections import OrderedDict as odict\n# from collections import Counter as cc\n# from collections import deque\n# sys.setrecursionlimit(2*(10**5)+100) this is must for dfs\n# mod = 10**9+7; md = 998244353\n# ______________________________________________________________________________________________________\n# segment tree for range minimum query\n# sys.setrecursionlimit(10**5)\n# n = int(input())\n# a = list(map(int,input().split()))\n# st = [float('inf') for i in range(4*len(a))]\n# def build(a,ind,start,end):\n#   if start == end:\n#       st[ind] = a[start]\n#   else:\n#       mid = (start+end)//2\n#       build(a,2*ind+1,start,mid)\n#       build(a,2*ind+2,mid+1,end)\n#       st[ind] = min(st[2*ind+1],st[2*ind+2])\n# build(a,0,0,n-1)\n# def query(ind,l,r,start,end):\n#   if start>r or end<l:\n#       return float('inf')\n#   if l<=start<=end<=r:\n#       return st[ind]\n#   mid = (start+end)//2\n#   return min(query(2*ind+1,l,r,start,mid),query(2*ind+2,l,r,mid+1,end))\n# ______________________________________________________________________________________________________\n# Checking prime in O(root(N))\n# def isprime(n):\n#     if (n % 2 == 0 and n > 2) or n == 1: return 0\n#     else:\n#         s = int(n**(0.5)) + 1\n#         for i in range(3, s, 2):\n#             if n % i == 0:\n#                 return 0\n#         return 1\n# def lcm(a,b):\n#   return (a*b)//gcd(a,b)\n# ______________________________________________________________________________________________________\n# nCr under mod\n# def C(n,r,mod):\n#   if r>n:\n#       return 0\n#   num = den = 1\n#   for i in range(r):\n#       num = (num*(n-i))%mod\n#       den = (den*(i+1))%mod\n#   return (num*pow(den,mod-2,mod))%mod\n# M = 10**5 +10\n# ______________________________________________________________________________________________________\n# For smallest prime factor of a number\n# M = 1000010\n# pfc = [i for i in range(M)]\n# def pfcs(M):\n#   for i in range(2,M):\n#       if pfc[i]==i:\n#           for j in range(i+i,M,i):\n#               if pfc[j]==j:\n#                   pfc[j] = i\n#   return\n# pfcs(M)\n# ______________________________________________________________________________________________________\ntc = 1\ntc, = inp()\na = [0,1]\nfor i in range(100000):\n a.append(a[-1]+a[-2])\nfor _ in range(tc):\n n, = inp()\n start = 0\n for i in range(n):\n  print(*a[start:start+i+1])\n  print()\n  start +=i+1
import re,sys\ndef isCirlePossible(juices,distances):\n if juices == [] or distances == []:\n  return -1;\n total_juice_consumed = 0\n juice_consumed = 0\n start=0\n for i in range(0,len(juices)):\n  diff = juices[i] - distances[i]\n  if juice_consumed >= 0:\n   juice_consumed += diff\n  else:\n   juice_consumed = diff\n   start = i\n  total_juice_consumed += diff\n return start\n\njuices = []\ndistances = []\nnumLines = int(input())\nfor each in range(0,numLines):\n line = input()\n result = [int(x) for x in re.findall('\d+',line)]\n if len(result) == 2:\n  juices.append(result[0])\n  distances.append(result[1])\n\nprint(isCirlePossible(juices,distances))\nreturn
t = int(input())\nfor _ in range(t):\n s = input()\n pref = [0]*len(s)\n if s[0]=="1":\n  pref[0]+=1\n for i in range(1,len(s)):\n  if s[i]=="1":\n   pref[i]+=1\n  pref[i]=pref[i]+pref[i-1]\n k=1\n cnt=0\n while (k+k*k)<=len(s):\n  r = k+k*k\n  i=r-1\n  while i<len(s):\n   if (i-r)>=0:\n    if pref[i]-pref[i-r]==k:\n     cnt+=1\n     i+=1\n    else:\n     i+=abs(k-(pref[i]-pref[i-r]))\n     \n   else:\n    if pref[i]==k:\n     cnt+=1\n     i+=1\n    else:\n     i+=abs(k-(pref[i]))\n  k+=1\n print(cnt)
# cook your dish here\ndef permutation(n,p):\n    r=26\n    if n==1:\n        return 26\n    elif n==2:\n        return 52\n    elif n==3:\n        return 728\n    else:\n        if n%2==0:\n            return ((2*(bin_expo(r,((n//2)+1),p)-r)*bin_expo(25,1000000005,p)))%p\n        else:\n            n=n+1\n            return ((2*((bin_expo(r,(n//2+1),p)-r)*bin_expo(r-1,1000000005,p)))- bin_expo(26,n//2,p))%p\ndef bin_expo(x,n,p):\n    if n==0:\n        return 1\n    elif n==1:\n        return x%p\n    else:\n        temp=bin_expo(x,n//2,p)\n        temp=(temp*temp)%p\n        if n%2==0:\n            return temp\n        else:\n            return ((x%p)*temp)%p\n\ntest=int(input())\nfor _ in range(test):\n    n=int(input())\n    p=1000000007\n    print(int(permutation(n,p)))
'''input\n2\n7 3 5\n5 2 5 2\n2 4 2 6\n6 2 6 4\n5 6 5 7\n7 1 7 4\n7 3 7\n1 1 6 1\n1 2 3 2\n5 2 5 2\n2 6 2 6\n6 2 6 4\n5 6 5 7\n7 1 7 4\n'''\n\nfor _ in range(int(input())):\n n, k, m = list(map(int, input().split()))\n row_s = []\n col_s = []\n for _ in range(m):\n  h_x, h_y, t_x, t_y = list(map(int, input().split()))\n  if h_x == t_x:\n   if (h_x < (((n - k) // 2) + 1)) or (h_x > (((n - k) // 2) + k)):\n    col_s.append([min(h_y, t_y), max(h_y, t_y)])\n   else:\n    row_s.append([h_x, h_x])\n  if h_y == t_y:\n   if (h_y < (((n - k) // 2) + 1)) or (h_y > (((n - k) // 2) + k)):\n    row_s.append([min(h_x, t_x), max(h_x, t_x)])\n   else:\n    col_s.append([h_y, h_y])\n row_s.sort()\n col_s.sort()\n\n poss = True\n\n if len(col_s) == 0 or len(row_s) == 0:\n  print(-1)\n  continue\n\n # print(row_s, col_s)\n\n next_row = ((n - k) // 2) + 1\n i = 0\n count_row = 0\n while i < len(row_s):\n  max_next = next_row\n  if next_row < row_s[i][0]:\n   poss = False\n   break\n  while i < len(row_s) and row_s[i][0] <= next_row:\n   # print(max_next, row_s[i], next_row)\n   max_next = max(max_next, row_s[i][1] + 1)\n   # print(max_next, row_s[i], next_row)\n   i += 1\n  next_row = max_next\n  count_row += 1\n  if next_row > (((n - k) // 2) + k):\n   break\n  if next_row < (((n - k) // 2) + k) and i >= len(row_s) :\n   poss = False\n   break\n\n # print(count_row)\n\n next_col = ((n - k) // 2) + 1\n i = 0\n count_col = 0\n while i < len(col_s):\n  max_next = next_col\n  if next_col < col_s[i][0]:\n   poss = False\n   break\n  while i < len(col_s) and col_s[i][0] <= next_col:\n   # print(max_next, col_s[i], next_col)\n   max_next = max(max_next, col_s[i][1] + 1)\n   # print(max_next, col_s[i], next_col)\n   i += 1\n  next_col = max_next\n  count_col += 1\n  if next_col > (((n - k) // 2) + k):\n   break\n  if next_col < (((n - k) // 2) + k) and i >= len(col_s) :\n   poss = False\n   break\n\n # print(count_col)\n print(count_col + count_row if poss else -1)\n\n # print(row_s, col_s)\n
def ans(l):\n s = ""\n i = 0\n while (i < len(l)):\n  temp = l[i]\n  k = temp[1]\n  if (k != 0):\n   s += str(temp[0]) + "x^" + str(k)\n  else:\n   s += str(temp[0])\n  i += 1\n  if (i < len(l)):\n   s += " + "\n if (len(s) > 0):\n  return s\n else:\n  return "0"\n \ntest = int(input())\nwhile (test != 0):\n test -= 1\n N = int(input())\n l = []\n while (N != 0):\n  n,m = list(map(int,input().split()))\n  if (m > 0):\n   l += [[n*m,m-1]]\n  N -= 1\n print(ans(l))\n
# cook your dish here\nfor _ in range(int(input())):\n    n,k = [int(c) for c in input().split()]\n    a = [int(c) for c in input().split()]\n    ls = a\n    if n==1:\n        print("YES")\n        print(1)\n        continue\n    if k==1:\n        print("NO")\n        continue\n    \n    if k==2 and n>2:\n        if ls[0]!=ls[1]-1:\n            print("NO")\n            continue\n\n    ans = [0 for i in range(n+1)]\n    count = n\n    for i in range(1,a[1]):\n        if i != a[0]:\n            ans[i]  =count\n            count-=1\n    for i in a[::-1]:\n        ans[i] = count\n        count-=1\n    for i in range(1,n+1):\n        if ans[i] == 0:\n            ans[i] = count\n            count-=1\n    print("YES")\n    print(*ans[1:])
def magic():\n def check(art,k,m):\n  n=len(art)\n  for i in range(n-k+1):\n   maxi=0\n   maxi=max(art[i:i+k])\n\n   total=0\n   total=art[i:i+k].count(maxi)\n\n   if total>=m:\n    return False\n\n  return True\n  \n\n\n for _ in range(eval(input())):\n  n,k,m=list(map(int,input().split()))\n  arr=list(map(int,input().split()))\n  dp=[]\n  ans=100\n\n  for mask in range(0,(1<<n)):\n   size=bin(mask).count('1')\n\n   if ans>size:\n    art=list(arr)\n    for i in range(n):\n     if mask & (1<<i):\n      art[i]+=1\n\n    if check(art,k,m):\n     ans=size\n\n  print(ans if ans!=100 else -1)\nmagic()\n
# cook your dish here\nt=int(input())\nwhile t>0:\n n=int(input())\n li=[]\n c,o,d,e,h,f=0,0,0,0,0,0\n for i in range(0,n):\n  s=input()\n  \n  for i in range(len(s)):\n   if s[i]=='c':\n    c=c+1\n   elif s[i]=='o':\n    o=o+1\n   elif s[i]=='d':\n    d=d+1\n   elif s[i]=='e':\n    e=e+1\n   elif s[i]=='h':\n    h=h+1\n   elif s[i]=='f':\n    f=f+1\n e=e//2\n c=c//2\n print(min(c,o,d,e,h,f)) \n t-=1
D=[0]*31\nD[1]=2\nD[2]=5\n\nfor i in range(3,31):\n best=10**10\n for p in range(1,i+1):\n  best=min(best,D[p-1]+D[i-p]+i+1)\n D[i]=best\n\nt=int(input())\nfor i in range(t):\n n,m=list(map(int,input().split()))\n maxi=(n+2)*(n+1)/2-1\n mini=D[n]\n if mini<=m<=maxi: print(0)\n elif m<mini: print(-1)\n else: print(m-maxi)\n
def diagonal_difference(matrix):\n l = sum(matrix[i][i] for i in range(N))\n r = sum(matrix[i][N-i-1] for i in range(N))\n return abs(l - r)\n\nmatrix = []\nN = eval(input())\nfor _ in range(N):\n matrix.append(list(map(int, input().split())))\n\nprint(diagonal_difference(matrix))
t=int(input())\nfor _ in range(t):\n n,m=map(int,input().split())\n d={}\n e={}\n l=[]\n for i in range(n):\n  d[i]=0\n for i in range(m):\n  e[i]=0\n for i in range(n):\n  l.append(input())\n for i in range(n):\n  for j in range(m):\n   if l[i][j]=='1':\n    d[i]=1\n    e[j]=1\n #ans=[]\n if sum(d.values())+sum(e.values())==0:\n  k=[-1]*m\n  for i in range(n):\n   print(*k)\n else:\n  ans=[]\n  for i in range(n):\n   ans.append([0]*m)\n  for i in range(n):\n   for j in range(m):\n    if l[i][j]=='1':\n     ans[i][j]=0\n    else:\n     if (d[i] or e[j]):\n      ans[i][j]=1\n     else:\n      ans[i][j]=2\n  for i in range(n):\n   for j in range(m):\n    print(ans[i][j],end=" ")\n   print()\n     \n   \n
# cook your code here\nfor _ in range(eval(input())):\n n=eval(input())\n ind=0\n m=-1\n \n for i in range(n):\n  \n  l=[int(x) for x in input().split()]\n  sc=l[0]\n  for j in range(1,len(l)):\n   sc+=int(l[j]>=4)+int(l[j]>=5)+2*int(l[j]>=6)\n  if sc==m:\n   ind=-2\n  if sc>m :\n   m=sc\n   ind=i+1\n  \n   \n if (ind==-2):\n  print("tie")\n elif (ind==1) :\n  print("chef")\n else:\n  print(ind)
c,f=list(map(int,input().split()))\r\nl=[[1000001 for i in range(c)] for j in range(c)] \r\nwhile f:\r\n    x,y,cost=list(map(int,input().split()))\r\n    l[x-1][y-1]=cost\r\n    l[y-1][x-1]=cost\r\n    f-=1  \r\nfor i in range(c):\r\n    l[i][i]=0\r\nfor k in range(c): \r\n    for x in range(c):\r\n        for y in range(c): \r\n            if x==k or y==k or x==y:\r\n                continue\r\n            elif x!=y:\r\n                l[x][y]=min(l[x][y],l[x][k]+l[k][y]) \r\nm=-1 \r\nfor i in range(c):\r\n    for j in range(c):\r\n        if m<l[i][j]:\r\n            m=l[i][j]\r\nprint(m)\r\n    # cook your dish here\r\n
# cook your dish here\nfor tc in range(int(input())):\n \n n = int(input())\n \n li1 = list(map(int,input().split(' ')))\n li2 = list(map(int,input().split(' ')))\n walk = 0\n sum1 = 0 \n sum2 = 0\n for i in range(n):\n  if li1[i] == li2[i] and sum1 == sum2:\n   walk += li1[i]\n  sum1 += li1[i]\n  sum2 += li2[i]\n print(walk)
# cook your dish here\nT = int(input())\nfor t in range(T):\n  N = int(input())\n  s = sorted(list(str(input())))\n  print(s[0])
# cook your dish here\nfrom collections import Counter,defaultdict\n\nfor i in range(int(input())):\n n=int(input())\n arr=list(map(int,input().split()))\n coun=Counter(arr)\n check=True\n\n for j in coun:\n  if coun[j]>n//2:\n   print("No")\n   check=False\n   break\n\n\n\n\n if check==True:\n  print("Yes")\n  narr=sorted(arr)\n  dic=defaultdict()\n  j=0\n  for j in range(len(narr)):\n   if narr[j] not in dic:\n    dic[narr[j]]=j\n  ans=[0]*n\n  for j in range(len(arr)):\n   ans[j]=narr[(dic[arr[j]]+n//2)%n]\n   if coun[arr[j]]!=1:\n    dic[arr[j]]+=1\n  print(*ans)\n
for _ in range(eval(input())):\n n=eval(input())\n if n%2:\n  print('NO')\n else:\n  print('YES') 
t = int(input())\nfor i in range(t):\n s = input().rstrip()\n sumv = 0\n for j in range(len(s)):\n  sumv += ord(s[j])\n minv = 10 ** 8;\n for i in range(ord('a'), ord('z') + 1):\n  val = abs(sumv - i * len(s))\n  if minv > val:\n   minv = val\n print(minv)
from math import sqrt\ndef isPrime(n):\n for i in range(2, int(sqrt(n))+1):\n  if(n%i==0): return True\n return False\nans = []\nfor _ in range(int(input())):\n x, y = map(int, input().split())\n ans.append('NO' if(isPrime(x**2-y**2)) else 'YES')\nprint('\n'.join(ans))
# cook your dish here\n# cook your dish here\n#powerful numbers\nn = int(input())\nplist = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313]\npower = 1\nfor i in range(2,n+1,1):\n    pdiv = []\n    count = 0\n    for p in plist:\n        if i>=p and i%p==0:\n            pdiv.append(p)\n    for pd in pdiv:\n        if i%(pd**2)==0:\n            count+=1\n    if count==len(pdiv) and count!=0:\n        power+=1\n\n    \n        \nprint(power)
#!/usr/bin/env python\n\nfrom math import sqrt\n\ndef process(S):\n P = [0,0,'S']\n for i in S:\n  if i == 'L':\n   if P[-1] == 'N': P[-1] = 'W'\n   elif P[-1] == 'S': P[-1] = 'E'\n   elif P[-1] == 'E': P[-1] = 'N'\n   elif P[-1] == 'W': P[-1] = 'S'\n  elif i == 'R':\n   if P[-1] == 'N': P[-1] = 'E'\n   elif P[-1] == 'S': P[-1] = 'W'\n   elif P[-1] == 'E': P[-1] = 'S'\n   elif P[-1] == 'W': P[-1] = 'N'\n  else:\n   i = int(i)\n   if P[-1] == 'N': P[1] -= i\n   elif P[-1] == 'S': P[1] += i\n   elif P[-1] == 'E': P[0] += i\n   elif P[-1] == 'W': P[0] -= i\n  #print i, P\n DIST = sqrt(P[0]**2+P[1]**2)\n\n if P[0] == 0 and P[1] == 0: DIR = ''\n elif P[0] == 0 and P[1] < 0: DIR = 'S'\n elif P[0] == 0 and P[1] > 0: DIR = 'N'\n elif P[0] < 0 and P[1] == 0: DIR = 'E'\n elif P[0] < 0 and P[1] < 0: DIR = 'SE'\n elif P[0] < 0 and P[1] > 0: DIR = 'NE'\n elif P[0] > 0 and P[1] == 0: DIR = 'W'\n elif P[0] > 0 and P[1] < 0: DIR = 'SW'\n elif P[0] > 0 and P[1] > 0: DIR = 'NW'\n\n DIST = int(DIST*10.)/10. # TOLD NO APPROXIMATION\n\n return '%.1f%s' % (DIST, DIR)\n\ndef main():\n T = int(input())\n for t in range(T):\n  S = input().split()\n  print(process(S))\n\nmain()\n\n
t=int(input())\nwhile(t):\n t-=1\n d={}\n n,m,k=[int(x) for x in list(input().split())]\n sum=0\n while(k):\n  k-=1\n  x,y=[int(x) for x in list(input().split())]\n  a=[-1,1,0,0]\n  b=[0,0,-1,1]\n  for i in range(4):\n   if((x+a[i],y+b[i]) in d):\n    sum-=1\n   else:\n    sum+=1\n  d[(x,y)]=1\n print(sum)
import random\nimport os\nyash=(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997)\n\ndef fix(m):\n    for ai in yash:\n        if m%ai==0:\n            return ai\n    return m\n\ndef rabin_miller(a,i,n):\n    if i==0:\n        return 1\n    x=rabin_miller(a,i/2,n)\n    if x==0:\n        return 0\n    y=(x*x)%n\n    if (y==1)and(x!=1)and(x!=n-1):\n        return 0\n    if i%2!=0:\n        y=(a*y)%n\n    return y\n\ndef gcd(x,y):\n    if y==0:\n        return x\n    return gcd(y,x%y)\n\ndef brent_rho(n):\n    if (n<=3)or(rabin_miller(random.randint(2,n-2),n-1,n)==1):\n        return n\n    y,r,q,m=1,1,1,203\n    while 1:\n        x=y\n        for i in range(1,r+1):\n            y=(y*y+1)%n\n        k=0\n        while 1:\n            ys=y\n            for i in range(1,min(m,r-k)+1):\n                y=(y*y+1)%n\n                q=(q*abs(x-y))%n\n            g=gcd(q,n)\n            k+=m\n            if (k>=r)or(g>1):\n                break\n        r*=2\n        if g>1:\n            break\n    if g==n:\n        while 1:\n            ys=(ys*ys+1)%n\n            g=gcd(abs(x-ys),n)\n            if g>1:\n                break\n    if g==n:\n        return n\n    return brent_rho(g)\n\ndef divsum2(n):\n    if n==1:\n        return 0\n    d=brent_rho(n)\n    d=fix(d)\n    assert (d<=3)or(rabin_miller(random.randint(2,d-2),d-1,d)==1)\n    f,m=0,n\n    while m%d==0:\n        m/=d\n        f = f + 1;\n    return (f*d)+(divsum2(m))\n\ntry:\n    while(1):\n	    z=eval(input())\n	    print(divsum2(z))\nexcept:\n	os.sys.exit(0);\n
import random\n\ndef sign(i):\n    if i>0:\n        return 1\n    elif i<=0:\n        return 0\nbleh = []\nfor _ in range(int(input())):\n    p = list(map(int,input().rstrip().split()))\n    max_rows = len(p)\n    if all([x==0 for x in p]):\n        print(1)\n        continue\n    if max_rows <= 1:\n        bleh.append(max_rows)\n        continue\n    max_pow = max_rows-1\n    if len(p)%2 !=0 and len(p)>0:\n        p.append(0)\n    max_col = len(p)//2\n    \n    rows = [[0 for _ in range(max_col)] for _ in range(max_rows)]\n    rows[0] = p[::2]\n    rows[1] = p[1::2]\n    if sign(rows[0][0]) != sign(rows[1][0]):\n        print(0)\n        continue\n    \n    for r in range(2,max_rows):\n        for n in range(max_col-1):\n                rows[r][n] = rows[r-1][0]*rows[r-2][n+1]-rows[r-2][0]*rows[r-1][n+1]\n    \n    last = sign(rows[0][0])\n    flag = 1\n    for i in range(1,len(rows)):\n        curr = sign(rows[i][0])\n        if rows[r] == [0 for _ in range(max_col)]:\n            for n in range(max_col):\n                rows[r][n] = rows[r-1][n]*(max_pow+4-(r+1)-2*(n+1)) \n        \n        elif rows[i][0] == 0:\n            if any([x != 0 for x in rows[i]]):\n                flag = 0\n                break\n            else:\n                curr = last\n        if curr != last:\n            flag = 0\n            break\n        last = curr    \n    print(flag)\n
# cook your dish here\nt=int(input())\nfor i in range(t,0,-1):\n x,y=map(int,input().split())\n k=x//y\n \n if k%y==0:\n  print("NO")\n else:\n  print("YES")
t=int(input())\nfor _ in range(t):\n    n=int(input())\n    l1=[]\n    if n==1:\n        print('*')\n    elif n==3:\n        print('*')\n        print('**')\n        print('*')\n    else:\n        s1=""\n        n1=n//2\n        n1+=1 \n        for i in range(1,n1+1):\n            s1=""\n            if i==1:\n                s1+='*'\n            elif i==2:\n                s1+='**'\n            else:\n                s1+='*'\n                for j in range(2,i):\n                    s1+=' '\n                s1+='*'\n            l1.append(s1)\n    for i in l1:\n        print(i)\n    l1.reverse()\n    for i in range(1,len(l1)):\n        print(l1[i])\n    \n    \n
# cook your dish here\n\nt = int(input())\nwhile t:\n t -= 1\n n = int(input())\n arr = list(map(int, input().split()))\n sumi = sum(arr)\n prev = 1\n for i in range(n):\n  arr[i] = min(arr[i], prev)\n  prev = arr[i] + 1\n prev = 1\n for i in range(n - 1, -1, -1):\n  arr[i] = min(arr[i], prev)\n  prev = arr[i] + 1\n temp = 0\n for i in range(n):\n  temp = max(temp, arr[i])\n print(sumi -( temp*temp))\n\n\n
def treeProduct(num, h, root, ch):\n if ch >= h:\n  return num[root]\n\n left = (root * 2) + 1\n right = (root * 2) + 2\n\n ret1 = treeProduct(num, h, left, ch + 1)\n ret2 = treeProduct(num, h, right, ch + 1)\n\n return num[root] * max(ret1, ret2)\n\ndef main():\n n = int(input())\n while n!=0:\n  line = str(input())\n  s = line.split()\n  num = [int((e)) for e in s]\n  print(int(treeProduct(num,n,0,1)%1000000007))\n  n = int(input())\n  \n \ndef __starting_point():\n main()\n\n__starting_point()
for _ in range(int(input())):\n n = int(input())\n\n arr= list(map(int,input().split()))\n arr.sort()\n d={}\n for i in arr:\n  if i not in d:\n   d[i]=1\n  else:\n   d[i]+=1\n \n flag = True\n for i in d:\n  if d[i]>2:\n   flag=False\n   break\n \n  \n\n if arr.count(max(arr))!=1:\n  flag=False\n \n  \n if flag==True:\n\n  arr1=[]\n  arr2=[]\n  for i in d:\n   if d[i]<=2:\n    if d[i]==2:\n     \n     arr2.append(i)\n    arr1.append(i)\n  arr2.reverse()\n  rearr= arr1+arr2\n\n  print("YES")\n  print(*rearr)\n\n else:\n  print("NO")\n \n# cook your dish here\n
from itertools import permutations\n\ndef solve(n,a):\n ans=[]\n \n for des in desire:\n  check=1\n  for i in range(n-1):\n   \n   if (a[i]==a[i+1]):\n    return [-1]\n   if a[i+1]==des[a[i]-1]:\n    check=0\n    break\n  if check:\n   ans=des\n   break\n if ans:\n  return ans\n return [-1]\n   \n\nper=permutations([1,2,3,4,5,6])\ndesire=[]\nfor p in per:\n check=1\n for i in range(1,7):\n  if p[i-1]==i:\n   check=0\n   break\n if check:\n  doublecheck=1\n  for i in range(6):\n   if p[p[i]-1]!=i+1:\n    doublecheck=0\n    break\n  if doublecheck:\n   desire.append(p)\n#print(desire)\nfor _ in range(int(input())):\n \n n=int(input())\n a=list(map(int,input().split( )))\n print(*solve(n,a))
n=int(input())\r\nl=[]\r\nfor i in range(n):\r\n	l.append([int(x) for x in input().split()])\r\nd=[10**9]*(n)\r\nq=set([int(x) for x in range(1,n)])\r\nd[1]=0\r\n#print(q)\r\ndef extract():\r\n	mini=10**9\r\n	o=0\r\n	for i in range(1,len(d)):\r\n		if d[i]<mini and i in q:\r\n			mini=d[i]\r\n			o=i\r\n	q.remove(o)\r\n	return o\r\nwhile len(q)!=0:\r\n	x=extract()\r\n	for i in range(1,n):\r\n		if i in q and l[x][i]<d[i]:\r\n			d[i]=l[x][i]\r\nprint(sum(d[1:]))
def invper(ar):\n ar1=[0]*(len(ar))\n for i in range(len(ar)):\n  ar1[ar[i]-1]=i+1\n return ar1\nt=int(input())\n\nwhile(t!=0):\n ar=list(map(int,input().split()))\n ar1=invper(ar)\n if(ar==ar1):\n  print("ambiguous")\n else:\n  print("not ambiguous")\n t = int(input())\n
for _ in range(int(input())):\n n=int(input())\n s=list(input())\n coord=list(map(int,input().split()))\n p=0\n i=0\n h=[]\n for i in range(0,n):\n  if s[i]=='1':\n   h.append(i)\n if h[0]!=0:\n  p=p+coord[h[0]]-coord[0]\n if h[len(h)-1]!=n-1:\n  p=p+coord[n-1]-coord[h[len(h)-1]]\n for j in range(0,len(h)-1):\n  if h[j]+1==h[j+1]:\n   continue\n  if h[j+1]-h[j]-1==1:\n   p=p+min(coord[h[j]+1]-coord[h[j]],coord[h[j+1]]-coord[h[j]+1])\n  else:\n   y=min(coord[h[j+1]]-coord[h[j]+1],coord[h[j+1]-1]-coord[h[j]])\n   for k in range(h[j]+1,h[j+1]-1):\n    y=min(y,coord[k]-coord[h[j]]+coord[h[j+1]]-coord[k+1])\n   p=p+y\n print(p)
# cook your dish here\nn,m=list(map(int,input().split()))\na={}\nfor i in range(n):\n x,y=input().split()\n a[x]=y\nfor i in range(m):\n c=input().strip()\n if '.' not in c:\n  print("unknown")\n else:\n  h=c.split('.')[-1]\n  if h in a:\n   print(a[h])\n  else:\n   print('unknown')\n  \n \n
for t in range(int(input())):\r\n	l1=list(map(int,input().split()))\r\n	l2=list(map(int,input().split()))\r\n	l3=list(map(int,input().split()))\r\n	max=0\r\n	g=l1[0]+l2[0]+l3[0]\r\n	y=l1[1]+l2[1]+l3[1]\r\n	r=l1[2]+l2[2]+l3[2]\r\n	if g%2==0:\r\n		g-=1\r\n	if y%2==0:\r\n		y-=1\r\n	if r%2==0:\r\n		r-=1\r\n	if max<g:\r\n		max=g\r\n	if max<r:\r\n		max=r\r\n	if max<y:\r\n		max=y\r\n	m=l1[0]+l1[1]+l1[2]\r\n	o=l2[0]+l2[1]+l2[2]\r\n	p=l3[0]+l3[1]+l3[2]\r\n	if m%2==0:\r\n		m-=1\r\n	if o%2==0:\r\n		o-=1\r\n	if p%2==0:\r\n		p-=1\r\n	if max<m:\r\n		max=m\r\n	if max<o:\r\n		max=o\r\n	if max<p:\r\n		max=p\r\n\r\n	print(max)\r\n
# cook your dish here\nfor i in range(int(input())):\n    n = int(input())\n    flag = 0\n    while(n>0):\n        if((n%10)%2 == 0):\n            flag = 1\n            break\n        n = n//10\n    if(flag == 0):\n        print(0)\n    else:\n        print(1)
l = []\nfor _ in range(int(input())):\n    l.append(int(input()))\nfor i in range(2,max(l)):\n    r = [x%i for x in l]\n    if len(set([x%i for x in l])) == 1:\n        print(i, end = ' ')\n
# cook your dish here\nimport math\ntry:\n def prime(n):\n  for i in range(2, int(math.sqrt(n)) + 1):\n   if n % i == 0:\n    return False\n  return True\n    \n for t in range(int(input())):\n  x, y = list(map(int, input().split()))\n  s = x + y \n  i = s\n  while(1):\n   if prime(s + 1):\n    ans = s + 1\n    break\n   else:\n    s += 1\n  print(ans - i)\n\nexcept: pass\n
for t in range(int(input())):\r\n	n=int(input())\r\n	s=input().strip()\r\n	c=0\r\n	flag=0\r\n	for i in range(n):\r\n		if (s[i]=="A" or s[i]=="E" or s[i]=="I" or s[i]=="O" or s[i]=="U") and (s[i-1]=="A" or s[i-1]=="E" or s[i-1]=="I" or s[i-1]=="O" or s[i-1]=="U") :\r\n			flag=1\r\n	if flag and n!=1:\r\n		print("Yes")\r\n	else:\r\n		print("No")\r\n
import sys\nimport math\ninput=sys.stdin.readline\ndef binary(l,r,co,b,c):\n x=(l+r)/2\n #print(x)\n val1=(2*x+b)*math.sin(x)\n val2=(x**2+b*x+c)*math.cos(x)\n x=(l+r)/2\n val=val1-val2\n if(abs(val)<.0000001 or co==150):\n  return (l+r)/2\n if(val<0):\n  return binary((l+r)/2,r,co+1,b,c)\n else:\n  return binary(l,(l+r)/2,co+1,b,c)\nt=int(input())\nfor _ in range(t):\n b,c=list(map(float,input().split()))\n x=binary(.0000000001,math.pi/2-.0000000001,0,b,c)\n #print("t=",_)\n val=(x*x+b*x+c)/math.sin(x)\n print(val)\n \n\n \n\n\n \n \n \n\n\n \n
# cook your dish here\nstore=[0]*(10**5+1)\ndef sieve():\n	for i in range(2,10**5+1):\n		if(store[i]==0):\n			store[i]=1\n			for j in range(i,10**5+1,i):\n				store[j]=i\nsieve()\n# print(store)\nfor _ in range(int(input())):\n	\n	n=int(input())\n	li=[int(x) for x in input().split()]\n\n	dp=[0]*(10**5+1)\n	for i in li:\n		dp[store[i]]+=1\n	max_re=0\n	res=0\n	for i in li:\n		if(dp[store[i]]==max_re):\n			if(store[i]>res):\n				res=store[i]\n		elif(dp[store[i]]>max_re):\n			max_re=dp[store[i]]\n			res=store[i]\n	\n	print(res)\n\n\n\n
import math\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n\ndef modin(a, m):\n    g, x, y = egcd(a, m)\n    return x % m\n# def gcdexten(a,b,x,y):\n# 	if a == 0:\n# 		x = 0\n# 		y = 1\n# 		return b\n# 	x1 = y1 = 0\n# 	gcd = gcdexten(b%a,a,x1,y1)\n\n# 	x = y1 - (b/a) * x1\n# 	y = x1\n# 	return gcd\n\n# def modin(a):\n# 	m = 10**9 + 7\n# 	x = y = 0\n# 	g = gcdexten(a,m,x,y)\n# 	res = (x%m + m)%m\n# 	return res\n\n# void modInverse(int a, int m)\n# {\n#     int x, y;\n#     int g = gcdExtended(a, m, &x, &y);\n#     if (g != 1)\n#         cout << "Inverse doesn't exist";\n#     else\n#     {\n#         // m is added to handle negative x\n#         int res = (x%m + m) % m;\n#         cout << "Modular multiplicative inverse is " << res;\n#     }\n# }\n# int gcdExtended(int a, int b, int *x, int *y)\n# {\n#     // Base Case\n#     if (a == 0)\n#     {\n#         *x = 0, *y = 1;\n#         return b;\n#     }\n \n#     int x1, y1; // To store results of recursive call\n#     int gcd = gcdExtended(b%a, a, &x1, &y1);\n \n#     // Update x and y using results of recursive\n#     // call\n#     *x = y1 - (b/a) * x1;\n#     *y = x1;\n \n#     return gcd;\n# }\ndef combi(a,b):\n	mod = 10**9 + 7\n	if a < b:\n		return 0\n	if a == 1:\n		return 1\n	if b < a/2:\n		b = a - b\n	temp = 1\n	for i in range(b + 1,a + 1):\n		temp = (temp * i%mod)%mod\n	denom = modin(math.factorial(a-b),mod)\n	# print denom\n	return (temp%mod * denom%mod)%mod\nfor _ in range(eval(input())):\n	mod = 10**9 + 7\n	string1 = input()\n	n = len(string1)\n	dict1 = {}\n	count = 0\n	alpha = set()\n	for ele in string1:\n		if ele in dict1:\n			dict1[ele] += 1\n		else:\n			dict1[ele] = 1\n			alpha.add(ele)\n			count += 1\n \n	count_list = []\n	total = 1\n	rem = n\n	for ele in alpha:\n		total = (total % mod) * (combi(rem,dict1[ele]) % mod)%mod\n		rem -= dict1[ele]\n		count_list.append(dict1[ele])\n \n	sum_list = [n - count_list[0]]\n	for i in range(1,count):\n		sum_list.append(sum_list[i - 1] - count_list[i])\n \n	sub_2 = 0\n	sub = 0\n	for i in count_list:\n		sub_2 += (n - i) * i\n	sub_2 /= 2\n	# print sub_2\n \n	sub_3 = 0\n	for i in range(count):\n		for j in range(i + 1,count):\n			sub_3 += count_list[i] * count_list[j] * sum_list[j]\n \n	sub_3 = 2 * sub_3\n \n	sub_4_4 = 0\n	for i in range(count):\n		for j in range(i + 1,count):\n			for k in range(j + 1,count):\n				sub_4_4 += count_list[i] * count_list[j] * count_list[k] * sum_list[k]\n \n	sub_4_4 *= 3\n	sub_4_2 = 0\n	for i in range(count):\n		for j in range(i + 1,count):\n			sub_4_2 += (count_list[i] * (count_list[i] - 1) * count_list[j] * (count_list[j] - 1))/4\n \n	sub_4_3 = 0\n	for i in range(count):\n		temp = 0\n		for j in range(count):\n			if j != i:\n				temp += count_list[j] * (n - count_list[i] - count_list[j])\n		temp /= 2\n		sub_4_3 += ((count_list[i] * (count_list[i] - 1)) * temp)/2\n		# print sub_4_3\n	sub_4_3 *= 2\n	# sub_4 = ((sub_4_2%mod + sub_4_3%mod) + sub_4_4%mod)%mod\n	# sub_tot = ((sub_2%mod + sub_3%mod)%mod + sub_4%mod)%mod\n	sub_4 = sub_4_3 + sub_4_4 + sub_4_2\n	sub_tot = sub_2 + sub_3 + sub_4\n\n	# print((total * (total - 1)) - (total * sub_tot%mod))%mod\n	# print ((total)* (total - 1 - (((sub_3 + sub_2)%mod + (sub_4_4 +sub_4_3)%mod)%mod + sub_4_2%mod)))% mod \n	print((total * (total - (sub_tot + 1)%mod)%mod)%mod)
t=int(input())\n\ndef diffe(a,b):\n return int(a-b)\n\nwhile t :\n t=t-1\n \n lia=[]\n lib=[]\n lik=[]\n lim=[]\n liab=[]\n likm=[]\n n,k,m=list(map(int,input().split()))\n \n \n lia=list(map(int,input().split()))\n lib=list(map(int,input().split()))\n lik=list(map(int,input().split()))\n lim=list(map(int,input().split()))\n liab=list(map(diffe,lia,lib)) \n \n likm=lik+lim\n \n \n likm.sort()\n \n liab.sort()\n liab.reverse()\n \n for i in range(0,len(liab)): \n  for j in range(len(likm)-1,0-1,-1):\n   a=likm.pop()\n   if (liab[i]-a)>=0:\n     liab[i]=liab[i]-a\n     \n     break\n     \n     \n print(sum(liab)) \n\n
t=int(input())\nwhile(t):\n    n=int(input())\n    cnt=1;\n    for i in range(n):\n        s=""\n        for j in range(n):\n            s=s+str(bin(cnt))[2:][: : -1]+" "\n            cnt=cnt+1\n        print(s)\n            \n    t=t-1
\ndef solve(s, p):\n diffs = 0\n for x, y in zip(s, p):\n  if x == y:\n   continue\n  if x == '0':\n   if diffs < 1:\n    return "No"\n   diffs -= 1\n  else:\n   diffs += 1\n return "Yes" if diffs == 0 else "No"\n\nfor _ in range(int(input())):\n l = int(input())\n s = input().strip()\n p = input().strip()\n print(solve(s, p))\n
# cook your dish here\nt=int(input())\ni=0\nwhile i<t:\n a=[]\n a=input().split()\n b=[]\n b=input().split()\n j=0\n c=0\n while j<4:\n  if a[j] in b:\n   c+=1\n  j+=1\n if c>=2:\n  print("similar")\n else:\n  print("dissimilar")\n i+=1
n=int(input())\na=list(map(int,input().split()))\nq=int(input())\nwhile q>0:\n i=1\n tot=a[0]\n b=list(map(int,input().split()))\n if b[0]==1:\n  #p,f=map(int,raw_input().split())\n  a[b[1]-1]=b[2]\n else:\n  #r=int(raw_input())\n  tot=a[0]\n  while 1+i*b[1]<=n:\n   tot=tot*a[i*b[1]]\n   i=i+1\n  m=(str)(tot)\n  tot=tot%1000000007\n  print((int)(m[0]),tot)\n q=q-1\n
import sys\r\nimport math\r\nimport bisect\r\nfrom sys import stdin,stdout\r\nfrom math import gcd,floor,sqrt,log\r\nfrom collections import defaultdict as dd\r\nfrom bisect import bisect_left as bl,bisect_right as br\r\n\r\nsys.setrecursionlimit(100000000)\r\n\r\nii     =lambda: int(input())\r\nsi     =lambda: input()\r\njn     =lambda x,l: x.join(map(str,l))\r\nsl     =lambda: list(map(str,input().strip()))\r\nmi     =lambda: map(int,input().split())\r\nmif    =lambda: map(float,input().split())\r\nlii    =lambda: list(map(int,input().split()))\r\n\r\nceil   =lambda x: int(x) if(x==int(x)) else int(x)+1\r\nceildiv=lambda x,d: x//d if(x%d==0) else x//d+1\r\n\r\nflush  =lambda: stdout.flush()\r\nstdstr =lambda: stdin.readline()\r\nstdint =lambda: int(stdin.readline())\r\nstdpr  =lambda x: stdout.write(str(x))\r\n\r\nmod=1000000007\r\n\r\n\r\n#main code\r\nfor _ in range(ii()):\r\n    n=ii()\r\n    arr=lii()\r\n    arr.sort()\r\n    ma=arr[-1]*arr[-2]\r\n    mi=arr[0]*arr[1]\r\n    print(ma,mi)
# cook your dish here\nwhile True:\n    try:\n        n=int(input())\n        lis=[]\n        for i in range(n):\n            k=list(map(int,input().split()))\n            k.append(k[1]+k[2])\n            lis.append(k)\n        \n        #print(lis)\n        p=sorted(lis,key=lambda x:x[3],reverse=True)\n        #print(p)\n        maxi=0\n        s=0\n        w=0\n        for i in range(n):\n            s+=p[i][0]\n            w=s+p[i][1]+p[i][2]\n            maxi=max(maxi,w)\n        \n        print(maxi)\n            \n    \n    except:\n        break\n        \n
# cook your dish here\n# cook your dish here\nfrom math import log2;\nimport sys;\n\nsys.setrecursionlimit(10 ** 7)\nfrom collections import defaultdict\n\ninf = float("inf")\ndef find_height(node):\n    nodes[node]=1\n    for i in graph[node]:\n        nodes[node]+=find_height(i)\n    return nodes[node]\ndef find_sum(node):\n    suma=nodes[node]\n    maxa=0\n    for i in graph[node]:\n        maxa=max(find_sum(i),maxa)\n    return maxa+suma\nfor i in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    graph=defaultdict(set)\n    for i in range(len(l)):\n\n        graph[l[i]].add(i+2)\n    nodes=defaultdict(int)\n    find_height(1)\n    ans=find_sum(1)\n    print(ans)\n\n\n\n
import math\nfor i in range(int(input())):\n a,b = map(int,input().split())\n print(math.gcd(a,b))
import sys\nimport math\n\ndef main(arr,k):\n \n \n x=[]\n y=[]\n \n \n \n for e in arr:\n  if e%2==0:\n   x.append(e)\n   y.append(0)\n  else:\n   x.append(0)\n   y.append(e)\n   \n a=[0]*n\n b=[0]*n\n a[0]=x[0]\n b[0]=y[0]\n for i in range(1,n):\n  \n  if i<k:\n   a[i]=max(x[i],a[i-1])\n   b[i]=max(y[i],b[i-1])\n  else:\n   a[i]=max(x[i]+a[i-k-1],a[i-1])\n   b[i]=max(y[i]+b[i-k-1],b[i-1])\n \n print(a[-1]+b[-1]) \n return \n\nfor i in range(int(input())):\n n,k=list(map(int,input().split()))\n \n arr=list(map(int,input().split()))\n \n (main(arr,k))\n\n
from operator import itemgetter\nt=int(input())\nfor i in range(t):\n n=int(input())\n m,f=list(map(int,input().split()))\n x=list(map(int,input().split()))\n my,fy=0,0\n check=[0]*n\n #print check\n for j in range(n):\n  if x[j]>0 and x[j]%m==0 and check[j]==0:\n   check[j]=1\n   my+=1\n #print check\n for j in range(n):\n  if x[j]>0 and x[j]%f==0 and check[j]==0:\n   check[j]=1\n   fy+=1\n if ((((my+fy)*1.0)/n)*100)>=70:\n  print("Yes")\n  if my>fy:\n   print("Multan")\n  elif fy>my:\n   print("Fultan")\n  else:\n   print("Both")\n else:\n  print("No") \n #print check\n
\n\n\ndef powerset(s):\n    n = len(s)\n    masks = [1 << j for j in range(n)]\n    for i in range(2**n):\n        yield [j + 1 for j in range(n) if (masks[j] & i)]\n\n\ndef is_power2(num):\n    return num != 0 and ((num & (num - 1)) == 0)\n\n\ndef special(l):\n    n = len(l)\n    for i in range(n):\n        lis = [i + 1]\n        yield lis\n        for j in range(i + 1, n):\n            p = l[j] / l[i]\n            if p <= 1 or int(p) != p:\n                continue\n            lis = [i + 1, j + 1]\n            yield lis\n            sk = (j + 1) * int(p)\n            while sk <= n:\n                lis.append(sk)\n                sk *= int(p)\n                yield lis\n\n\ndef expIndices(l):\n    a = list(zip(l, l[1:]))\n    if len(a) == 0:\n        return True\n    else:\n        p = a[0][1] / a[0][0]\n        if p <= 1 or int(p) != p:\n            return False\n        for i in range(1, len(a)):\n            if a[i][1] / a[i][0] != p:\n                return False\n        return True\n\n\ndef main():\n    for _ in range(eval(input())):\n        S = input()\n        count = 0\n\n        for i in special(range(1, len(S) + 1)):\n            s = [S[j - 1] for j in i]\n            if s == s[::-1]:\n                count += 1\n        print(count)\n\ndef __starting_point():\n    main()\n\n__starting_point()
tests = int(input())\r\nfor t in range(tests):\r\n  n = int(input())\r\n  permut='2'\r\n  permut_list=[]\r\n  if n%2==0:\r\n    for i in range(2, n+1):\r\n      if i%2==1:\r\n        permut=permut+' '+str(i+1)\r\n      else:\r\n        permut=permut+' '+str(i-1)\r\n    print(permut)\r\n    pass\r\n  elif n==1:\r\n    print(1)\r\n    pass\r\n  else:\r\n    for i in range(2, n):\r\n      if i%2==1:\r\n        permut_list.append(str(i+1))\r\n      else:\r\n        permut_list.append(str(i-1))\r\n    permut_list.pop(-1)\r\n    permut_list.append(str(n))\r\n    permut_list.append(str(n-2))\r\n    this_permut='2'\r\n    for el in permut_list:\r\n      this_permut=this_permut+' '+el\r\n    print(this_permut)
# cook your dish here\nn, k, p = [int(i) for i in input().split()]\nn_sep = list(map(int, input().split()))\ncount = 0\nsep_sort = sorted(n_sep)\nhashing = {sep_sort[0]: 0}\n\nfor j in range(1, n):\n if (abs(sep_sort[j] - sep_sort[j - 1]) > k):\n  count += 1\n hashing[sep_sort[j]] = count\n#print(hashing)\nfor i in range(p):\n pair = list(map(int, input().split()))\n \n if hashing[n_sep[pair[1] - 1]] == hashing[n_sep[pair[0] - 1]]:\n  print("Yes")\n else:\n  print("No")\n
try:\n# https://www.codechef.com/LTIME63B/problems/GHMC\n# Finally.... I properly understood what needs to be done.\n\n    def ctlt(arr, val):\n        # find number of values in sorted arr < val\n        if arr[0] >= val: return 0\n        lo = 0\n        hi = len(arr)\n        while hi-lo > 1:\n            md = (hi+lo)//2\n            if arr[md]<val:\n                lo = md\n            else:\n                hi = md\n\n        return hi\n\n    for _ in range(int(input())):\n        n,k,x,d = map(int, input().split())\n        z = input().strip().split()\n        if k > 0:\n            ps = list(map(int,z[:k]))\n        else:\n            ps = [x]\n\n        ps.sort()\n\n        if x<n or x<ps[-1] or n<k:\n            print(-1)\n            continue\n\n        valchecked = 0\n        fillval = 0\n        valsdone = False\n        isolbelow = True\n        lastp = ps[0]\n\n        while not valsdone and n>=k:\n            if n == k:\n                lo = x+d+1 # put out of range\n            else:\n            # find best maxfill (before val support)\n                lo = 1\n                hi = x+1\n                while hi-lo>1:\n                    md = (hi+lo)//2\n                    v = (x-md+1) + ctlt(ps,md)\n                    if v<n:\n                        hi = md\n                    else:\n                        lo = md\n        \n            valsdone = True\n            checkto = ctlt(ps,lo)-1\n            if checkto >= valchecked:            \n            # support all vals\n                for p in ps[valchecked+1:checkto+1]:\n                    if lastp+d >= p:\n                        isolbelow = False\n                    elif isolbelow:\n                        valsdone = False\n                        fillval += lastp+d\n                        n -= 1\n                        isolbelow = (p > lastp + 2*d )\n                    else:\n                        isolbelow = True\n                    lastp = p\n                valchecked = checkto\n                if valsdone and isolbelow: \n                # check gap to maxfill\n                    if lastp + d >= lo:\n                        isolbelow = False\n                    else:\n                        valsdone = False\n                        fillval += lastp\n                        ps[checkto] += d\n                        lastp += d\n                        isolbelow = False\n                        n -= 1\n\n        if k > n:\n            print(-1)\n        elif k == n:\n            print(sum(ps) + fillval)\n        elif k == n-1 and lo > ps[-1]:\n            print(sum(ps) + fillval + min(x,ps[-1]+d))\n        else:\n            tot = (x+lo)*(x-lo+1)//2  + sum(ps[:ctlt(ps,lo)])\n            print(tot + fillval)\nexcept:\n    pass
# cook your dish here\nt=int(input())\nfor i in range(t):\n D=int(input())\n P=10**5-2\n ans=[]\n if(D==0):\n  ans.append(1)\n while(D>0):\n  P=min(P,D)\n  ans.append(P+2);\n  ans.append(P+1);\n  ans.append(1);\n  D=D-P;\n print(len(ans))\n print(*ans,sep=" ",end="\n")\n   \n \n  \n  
import math\nt=eval(input())\nwhile t:\n    t=t-1\n    r1,h1,r2,h2=list(map(float,input().split()))\n    vol1=(math.pi*r1*r1*h1)/3 + (2*math.pi*r1*r1*r1)/3\n    vol2=math.pi*r2*r2*h2\n    print("%.8f %.8f" % (vol1,vol2))\n\n
# cook your dish here\nx=int(input())\nfor i in range(x):\n    s=input()\n    print(int(s[::-1]))\n
t=int(input())\nfor i in range(t):\n n=int(input())\n N=list(map(int,input().split()))\n N.sort()\n \n k=n-1\n ave=N[k]\n for j in range(n-1):\n  ave=(ave+N[k-1])/2\n  k=k-1\n  \n print(ave)
import sys\nuser_input = sys.stdin.readline().split()\n\nT = int(user_input[0])\n\nfor j in range(T) :\n\n var = sys.stdin.readline().split()\n N = int(var[0])\n M = int(var[1])\n\n if (N%M)%2 :\n  print("ODD")\n else :\n  print("EVEN")
# cook your dish here\nfrom sys import stdin,stdout\n\na0=0\na1=1\nn,k=stdin.readline().strip().split(' ')\nn,k=int(n),int(k)\n\narr=list(map(int,stdin.readline().strip().split(' ')))\n\n\n\ndef solve(n,k,arr):\n sol=[]\n\n l=0;u=k;\n\n\n while l!=u:\n   sol.append(arr[l:min(len(arr),u)])\n   l=min(l+k,len(arr))\n   u=min(u+k,len(arr))\n   \n tiwari=[]\n for i in range(k):\n   titi=0\n   gao=0\n   for j in range(len(sol)):\n    if len(sol[j])>i:\n     if sol[j][i]==0:\n      titi+=1\n     else:\n      gao+=1\n   tiwari.append((titi,gao))\n\n minflip=(-1,-1)\n ans=0\n ctr=0\n for i in tiwari:\n   if i[0]<i[1]:\n    ans+=i[0]\n    ctr+=(1*a1+a0*a1)*a1\n    if i[1]<minflip[0] or minflip[0]==-1:\n     minflip=(i[1],i[0])\n   else:\n    ans+=i[1]\n    if i[0]<minflip[0] or minflip[0]==-1:\n     minflip=(i[0],i[1])\n #print(ans,ctr)\n #print(tiwari)\n #print(minflip)\n if ctr%2==0:\n   ans+=minflip[0]\n   ans-=minflip[1]\n\n\n stdout.write(str(ans)+"\n")\n\nsolve(n,k,arr)
test = int(input())\nfor i in range(test):\n flavor = int(input())\n rate = input()\n gaf = input()\n gaf = gaf.split()\n gaf = [int(x) for x in gaf]\n rate = rate.split()\n rate = [int(x) for x in rate]\n rate.sort()\n c = gaf[0] - gaf[1]\n sum = rate[0]*c\n t = True\n if gaf[0] < gaf[1]:\n  t = False\n j = 0\n while(j<gaf[1] and t):\n  sum = sum + rate[j]\n  j = j + 1\n if t :\n  print(sum)\n else:\n  print("Not Possible")
# cook your dish here\nepi=10**-2\ndef vision(t):\n a1=x0+(dx*t)-x1\n a2=y0+(dy*t)-y1\n a3=z0+(dz*t)-z1\n b=4*((a1*d1)+(a2*d2)+(a3*d3))*((a1*d1)+(a2*d2)+(a3*d3))\n a=4*((a1*a1)+(a2*a2)+(a3*a3))\n value=(b-(a*c))\n return value\nxrange=range\nfor _ in range(int(input())):\n x1,y1,z1,x0,y0,z0,dx,dy,dz,cx,cy,cz,r=list(map(int,input().split()))\n d1=x1-cx\n d2=y1-cy\n d3=z1-cz\n c=(d1*d1)+(d2*d2)+(d3*d3)-(r*r)\n low=0\n high=10**9+1\n while low<(high-10**-6):\n  mid=low+(high-low)*1.0/2;\n  value=vision(mid);\n  if abs(value)<=epi:\n   break;\n  elif value>0:\n   low=mid;\n  else:\n   high=mid;\n print(mid)\n \n
import sys\nimport os\nimport random\nimport math\n#nonlocal defs\nn, m, p = list(map(int, input().split()))\narr = [dict() for _ in range(n)]\nfor _ in range(p):\n i,j = list(map(int,input().split()))\n i -= 1\n j -= 1\n if j not in arr[i]:\n  arr[i][j] = j+1\n else:\n  arr[i][j] += 1\n\ndef chefbm(arr,i):\n for (e,f) in arr[i].items():\n  if e == m-1:\n   continue\n  if e+1 in arr[i]:\n   c = arr[i][e+1]\n  else:\n   c = e+1\n  if arr[i][e] > c:\n   return -1\n y = arr[i][m-1] if m-1 in arr[i] else m-1\n x = arr[i][0] if 0 in arr[i] else 0\n return y-x\n\nfor i in range(n):\n print(chefbm(arr,i))
# cook your dish here\na = int(input())\nfor i in range(a):\n b = int(input())\n li = []\n if b == 2:\n  print(2,1)\n elif b == 3:\n  print(3,2)\n elif b == 4:\n  print(4,2)\n else:\n  for t in range(b+1):\n   if ((b*t)+1-(2**t))<0:\n    li.append(t-1)\n    break\n  for o in range(b+1):\n   if b<=2**(o):\n    li.append(o)\n    break\n  print(*li)\n  \n
from sys import stdin, stdout\r\n#from math import gcd as g\r\n#a,b = map(int, stdin.readline().split())\r\n#l1 = list(map(int, stdin.readline().split()))\r\nl = [1,6,7]\r\nc = 1\r\nfor x in range(3,100001):\r\n    if x%2==1:\r\n        a = l[c]*6\r\n        l.append(a)\r\n    else:\r\n        l.append(a+1)\r\n        c+=1\r\nn = int(stdin.readline())\r\nfor _ in range(n):\r\n    s = int(stdin.readline())\r\n    print(l[s-1])
for _ in range(int(input())):\n l=list(map(int,input().strip()))\n for j in range(len(l)-1,-1,-1):\n  if l[j]==1:\n   l.pop()\n  else:\n   break\n if l.count(1):\n  time,prev,z,c=0,0,0,0\n  for j in range(len(l)-1,-1,-1):\n   if l[j]==0:\n    z+=1\n    continue\n   if prev!=z:\n    prev=z\n    c+=1\n   time+=c+z\n\n  print(time)\n else:\n  print(0)\n\n
n = int(input())\nfor i in range(n):\n    s = input()\n    l = len(s)\n    n1 = int(s[0])\n    n2 = int(s[l-1])\n    print(n1+n2)\n
tc=int(input())\nfor case in range(tc):\n m,r=list(map(int,input().split()))\n n=m**(r-1)\n a=[i**n for i in range(1,2*n+1)]\n tmp=2*n-1\n for i in range(n):\n  for j in range(tmp-i):\n   a[j]=a[j+1]-a[j]\n print((a[n-1]/m)%1000000007)\n
N,M,C = list(map(int, input().split()))\ntree = [0] * (N+1)\n\ndef add(u,k):\n while u < len(tree):\n  tree[u] += k \n  u += u&-u\n\ndef query(k):\n ans = 0\n while k:\n  ans += tree[k]\n  k -= k&-k\n\n return ans\n\ndef solve():\n for _ in range(M):\n  op = input().split()\n  if op[0] == 'Q':\n   print(query(int(op[1])) + C)\n  else:\n   u,v,k = int(op[1]), int(op[2]), int(op[3]) \n   add(u, k)\n   add(v+1, -k)\n\ndef __starting_point():\n solve()\n\n__starting_point()
tc=int(input())\nfor case in range(tc):\n n,d=list(map(int,input().split()))\n a=list(map(int,input().split()))\n sm=sum(a)\n f=True\n if sm%n==0:\n  avg=sm/n\n  for i in range(d):\n   tmp_sm=0\n   tmp_n=0\n   for j in range(i,n,d):\n    tmp_sm=tmp_sm+a[j]\n    tmp_n+=1\n   if tmp_sm%tmp_n==0:\n    if avg!=tmp_sm/tmp_n:\n     f=False\n     break\n   else:\n    f=False\n    break\n else:\n  f=False\n if f:\n  ans=0\n  cur=0\n  for i in range(d):\n   for j in range(i,n,d):\n    cur=cur+avg-a[j]\n    ans=ans+abs(cur)\n  print(ans)\n else:\n  print(-1)\n
# cook your dish here\nt = int(input())\n\nfor _ in range(t):\n\n    n,s = input().split()\n\n    N = int(n) \n    r = N - len(s)\n\n    count = 0\n\n    if N>len(s):\n\n     count = pow(26, r-1,(10**9+7))\n     count*= (26+25*len(s))\n\n     count = count%(10**9 + 7)\n    print(count)\n\n
# cook your dish here\nimport math\ntry:\n    n,d=map( int,input().split() )\n    a=list(map(int,input().split()))\n    a.sort()\n    z=abs(a[0]-d)\n    for j in range(n):\n        x=abs(a[j]-d)\n        z=math.gcd(x,z)\n    print(z)    \n        \n    \nexcept:\n    pass
def multiple_input(): return map(int, input().split())\n\n\ndef list_input(): return list(map(int, input().split()))\n\n\nmod = int(1e9) + 7\nfor _ in range(int(input())):\n n, m = multiple_input()\n a = list_input()\n a.sort()\n max_level = a[-1] + 1\n levels = [0] * max_level\n levels[0] = 1\n for i in a:\n  levels[i] += 1\n ans = 1\n for i in range(1, max_level):\n  ans = (ans * (pow(levels[i - 1], levels[i], mod))) % mod\n print(ans)
t=int(input())\nfor i in range(t):\n n,k,l=map(int,input().split())\n if k*l<n:\n  print(-1)\n elif (k==1 and n>1):\n  print(-1)\n else:\n  for j in range(n):\n   print((j%k)+1,end=' ')\n  print()
test=int(input())\nfor i in range(test):\n n=int(input())\n a=list(map(int,input().split()))\n b=[0]*(n+2)\n b[n-1]=1\n for i in range(n-2,-1,-1):\n  if(a[i]*a[i+1]<0):\n   b[i]=b[i+1]+1\n  else:\n   b[i]=1\n for i in range(n):\n  print(b[i], end=' ')\n print() 
# cook your dish here\nd=["saturday","sunday","monday","tuesday","wednesday","thursday","friday"]\nt=int(input())\nfor i in range(t):\n s,e,l,r=map(str,input().split())\n l,r=int(l),int(r)\n v=(d.index(e)-d.index(s)+8)%7\n c=r+1\n for i in range(l,r+1):\n  if i%7==v:\n   c=i\n   break\n if c>r:\n  print('impossible')\n elif c+7<=r:\n  print('many')\n else:\n  print(c)
# cook your dish here\nimport sys \ndef dist(a,b):\n    return abs(a[0]-b[0])+abs(a[1]-b[1])\nn, m = map(int, input().split())\nmatrix=[]\nid_matrix=[[0 for i in range(n)] for i in range(n)]\nfor _ in range(n):\n    matrix.append(list(map(int, input().split())))\ncharms=[]\nfor _ in range(m):\n    x,y,lungh = map(int, input().split())\n    x-=1 \n    y-=1\n    charms.append([x,y,lungh])\nif m<=10:\n    for i in range(n):\n        for j in range(n):\n            flag=0\n            for charm in charms:\n                if dist([i,j],charm[:2])<=charm[2]:\n                    flag=1\n                    break\n            if flag==0:\n                matrix[i][j]=-float('Inf')\n    for i in range(1,n):\n        matrix[0][i]+=matrix[0][i-1]\n        matrix[i][0]+=matrix[i-1][0]\n    for i in range(1,n):\n        for j in range(1,n):\n            matrix[i][j]+=max(matrix[i-1][j], matrix[i][j-1])\nelse:\n    for charm in charms:\n        for i in range(-charm[2],charm[2]+1):\n            appo=charm[2]-abs(i)\n            for j in range(-appo, appo+1):\n                x=i+charm[0]\n                y=j+charm[1]\n                if x>=0 and x<n and y>=0 and y<n:\n                    id_matrix[x][y]=1\n    if id_matrix[0][0]==0:\n        matrix[0][0]=-float('Inf')\n    for i in range(1,n):\n        if id_matrix[0][i]==0:\n            matrix[0][i]=-float('Inf')\n        else:\n            matrix[0][i]+=matrix[0][i-1]\n        if id_matrix[i][0]==0:\n            matrix[i][0]=-float('Inf')\n        else:\n            matrix[i][0]+=matrix[i-1][0]\n    for i in range(1,n):\n        for j in range(1,n):\n            if id_matrix[i][j]==0:\n                matrix[i][j]=-float('Inf')\n            else:\n                matrix[i][j]+=max(matrix[i-1][j], matrix[i][j-1])\nif matrix[n-1][n-1]<-10**(10):\n    print('NO')\nelse:\n    print('YES')\n    print(matrix[n-1][n-1])
# cook your dish here\nn = int(input())\ncount = 0\nfor _ in range(n):\n L = list(map(int, input().split()))\n if (L.count(1)>=2):\n  count+=1\n \nprint(count)\n
n=int(input())\na=list(map(int,input().split()))\na.sort()\nprint(a[-1],a[0])\n
from collections import Counter\ntc=int(input())\nfor k in range(tc):\n n=int(input())\n a=list(map(int, input().rstrip().split()))\n b= list(map(int, input().rstrip().split()))\n cc=sorted(a+b)\n #print('cc = ',cc)\n p=[]\n q=[]\n #print('len(cc) = ',len(cc))\n #print('len = ',(2*n))\n #rx=0\n for i in range(0,(2*n),2):\n  p.append(cc[i])\n  #rx+=1\n for i in range(1,(2*n)+1,2):\n  q.append(cc[i])\n \n if(p!=q):\n  print('-1')\n  continue\n a.sort()\n b.sort()\n #print(p)\n #print(q)\n if(a==b):\n  print('0')\n  continue\n xx = list((Counter(a) - Counter(p)).elements())\n yy = list((Counter(b) - Counter(p)).elements())\n #print('xx = ',xx)\n #print('yy = ',yy)\n iu=len(xx)\n gb=sorted(xx+yy)\n #print(iu)\n uu=xx[0]\n vv=yy[0]\n #print('uu = ',uu)\n #print('vv = ',vv)\n zz=min(cc[0],uu,vv)\n #print('zz = ',zz)\n ans=0\n for i in range(iu):\n  if(gb[i]<=(zz*2)):\n   ans+=gb[i]\n  else:\n   ans+=(zz*2)\n print(ans)\n \n#a = [1, 1, 1, 2, 3, 3]\n#b = [1, 1, 2, 2, 3, 4]\n\n'''c = []\ni, j = 0, 0\nwhile i < len(a) and j < len(b):\n    if a[i] == b[j]:\n     c.append(a[i])\n     i += 1\n     j += 1\n    elif a[i] > b[j]:\n     j += 1\n    else:\n     i += 1'''\n#print(c)\n
import math\ndef csb(n): \n count = 0\n while (n): \n  n &= (n-1) \n  count+= 1\n  \n return count\ndef f(ca,cb,i,cf,C,n,dp):\n if ca<0 or cb<0:\n  return 0\n if i==n:\n  if ca==0 and cb==0 and cf==0:\n   return 1\n  return 0\n st=str(ca)+" "+str(cb)+" "+str(cf)+" "+str(i)\n if dp.get(st)!=None:\n  return dp[st]\n x=0 \n if (C&(1<<i))>0:\n  x=1\n if x==1:\n  #we will have odd num of set bits\n  if cf==1:\n   dp[st]=f(ca,cb,i+1,0,C,n,dp)+f(ca-1,cb-1,i+1,1,C,n,dp)\n  else:\n   dp[st]=f(ca-1,cb,i+1,0,C,n,dp)+f(ca,cb-1,i+1,0,C,n,dp)\n else:\n  if cf==1:\n   dp[st]=f(ca-1,cb,i+1,1,C,n,dp)+f(ca,cb-1,i+1,1,C,n,dp)\n  else:\n   dp[st]=f(ca,cb,i+1,0,C,n,dp)+f(ca-1,cb-1,i+1,1,C,n,dp)\n   \n return dp[st]\ndef ip():\n  \n for _ in range(int(input())):\n  a,b,c=list(map(int,input().split()))\n  n=int(math.log(c,2))+1\n  dp={}\n  print(f(csb(a),csb(b),0,0,c,n,dp))\nip()\n
cards = ['A','2','3','4','5','6','7','8','9','T','J','Q','K']\n\ndef royal_flush(arr):\n nonlocal ans, confirm\n rf_set = 'TJQKA'\n rf = 1\n for char in arr:\n  if char[0] not in rf_set:\n   rf = 0\n   break\n if rf :\n  if len(set(suit)) == 1:\n   ans = 'royal flush'\n   confirm = 1\ndef straight_flush(arr):  # and 'straight'\n nonlocal ans,confirm\n sf = 1\n for i in range(1,5):\n  if arr[i] - arr[i-1] != 1:\n   sf = 0\n   break\n if sf:\n  if len(set(suit)) == 1 :\n   ans = 'straight flush'\n   confirm = 1\n  else:\n   ans = 'straight'\n   confirm = 1\ndef four(arr):\n nonlocal ans, confirm\n f = 0\n for char in arr:\n  if arr.count(char) == 4:\n   f = 1\n   break\n if f:\n  confirm = 1\n  ans = 'four of a kind'\ndef full_house(arr): # and three\n nonlocal ans, confirm\n fh = 0\n three = 0\n two = 0\n for char in arr:\n  if arr.count(char) == 3:\n   three = 1\n  elif arr.count(char) == 2:\n   two = 1\n if three and two:\n  confirm = 1\n  ans = 'full house'\n elif three:\n  confirm = 1\n  ans = 'three of a kind'\ndef two_pairs(arr):\n nonlocal ans, confirm\n temp = []\n for char in arr:\n  if arr.count(char) == 2:\n   if char not in temp:\n    temp.append(char)\n if len(temp) == 2:\n  confirm = 1\n  ans = 'two pairs'\n elif len(temp) == 1:\n  confirm = 1\n  ans = 'pair'\n\ndef idex(char_x):\n return cards.index(char_x)\nfor _ in range(int(input())):\n onhand = list(input().split())\n cards_set = [[],[]]\n suit = []\n confirm = 0\n ans = ''\n for c in onhand:\n  num = idex(c[0])\n  cards_set[0].append(num)\n  if num == 0:\n   cards_set[1].append(13)\n  else:\n   cards_set[1].append(num)\n  suit.append(c[1])\n royal_flush(onhand)\n if not confirm:\n  cards_set[0] = sorted(cards_set[0])\n  cards_set[1] = sorted(cards_set[1])\n  straight_flush(cards_set[0])\n  straight_flush(cards_set[1])\n if not confirm:\n  four(cards_set[0])\n  four(cards_set[1])\n if not confirm:\n  full_house(cards_set[0])\n  full_house(cards_set[1])\n if not confirm:\n  if len(set(suit)) == 1:\n   confirm = 1\n   ans = 'flush'\n if not confirm:\n  two_pairs(cards_set[0])\n  two_pairs(cards_set[1])\n print(ans if confirm else 'high card')
import numpy as np\nfor _ in range(int(input())):\n   n = int(input())-1;soldiers = [int(j) for j in input().split()]\n   force = int(input());attacks = np.zeros(2*n,dtype=int);attacks[:n] = np.array(soldiers);attacks[n:2*n] = attacks[:n];shield = [0 for _ in range(n)];pow_of_2 = 1\n   while n // pow_of_2 > 0:      pow_of_2 *= 2\n   soldier_of_attack = (2 * n - pow_of_2) % n;pow_of_2 = attacks[soldier_of_attack] > force\n   \n   for i in range(n):\n      if attacks[i] > force:         shield[i] = 10 ** 11\n      elif n == 1:         shield[i] = force\n      elif pow_of_2:\n         shield[i] = force;         num_of_survivors = n;  soldiers = list(attacks[i:i+n]);         starting_soldier = (n - i) % n\n         if (num_of_survivors - starting_soldier) % 2 == 1:            shield[i] += soldiers[-1]\n         soldiers = [soldiers[i] for i in range(num_of_survivors) if i < starting_soldier or (i - starting_soldier) % 2 == 0];num_of_survivors = starting_soldier + (num_of_survivors - starting_soldier - 1) // 2\n         if num_of_survivors > 1:\n            pow_2 = 1\n            while True:\n               attacker = num_of_survivors - (num_of_survivors % pow_2);   pow_2 *= 2\n               if attacker == 0:                  break\n               if attacker % pow_2 == 0:                  shield[i] += soldiers[attacker]\n      elif i == soldier_of_attack:         shield[i] = force\n      else:         shield[i] = force + 1   \n   shield_needed = min(shield)\n   if shield_needed == 10 ** 11:      print("impossible")\n   else:\n      print("possible")\n      for i in range(n):\n         if shield[i] == shield_needed:print(str(i+1) + " " + str(shield_needed));break
t=int(input())\nwhile(t):\n n=int(input())\n l=[]\n for i in range(n):\n  l.append(list(map(int,input().split())));\n m=[]\n for i in l:\n  m.append((i[1]//(i[0]+1))*i[2])\n res=max(m)\n print(res)\n t=t-1
# Why do we fall ? So we can learn to pick ourselves up.\r\n\r\n\r\n\r\n\r\nt = int(input())\r\nfor _ in range(0,t):\r\n    n = int(input())\r\n    abc = [int(i) for i in input().split()]\r\n\r\n    i = 0\r\n\r\n    lst = [n]\r\n\r\n    for _ in range(0,100):\r\n        k = str(lst[-1]/abc[i%3]).split('.')\r\n        if int(k[1][0]) > 0:\r\n            lst.append(int(k[1][0]))\r\n        else:\r\n            lst.append(int(k[0][0]))\r\n        i += 1\r\n    pattern = []\r\n    ind = 0\r\n    while len(pattern) == 0:\r\n        for i in range(ind, len(lst) - 1):\r\n            check = lst[ind: i + 1] * 50\r\n            check = check[:len(lst) - ind]\r\n            if lst[ind:] == check:\r\n                pattern = check\r\n                break\r\n        if len(pattern):\r\n            break\r\n        ind += 1\r\n    final_pattern = []\r\n    for i in range(0, len(pattern)):\r\n        couldbe = pattern[:i + 1]\r\n        check = pattern[:i + 1] * 100\r\n        check = check[:len(pattern)]\r\n        if check == pattern:\r\n            final_pattern = couldbe\r\n            break\r\n    lp = len(final_pattern)\r\n    q = int(input())\r\n    for _ in range(0, q):\r\n        qq = int(input())\r\n        if qq < ind:\r\n            print(lst[qq])\r\n        else:\r\n            qq -= ind\r\n            kk = qq % lp\r\n            print(final_pattern[kk])\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"""\r\n1\r\n56\r\n3 5 7\r\n4\r\n0\r\n1\r\n2\r\n3\r\n\r\n"""
# cook your dish here\nfor _ in range(int(input())):\n n,q=map(int,input().split())\n l=[int(i) for i in input().split()]\n qry=[int(input()) for i in range(q)]\n def cmp(sub1,sub2):\n  for i in range(len(sub1)):\n   if sub1[i]>sub2[i]:\n    return 1 \n   if sub1[i]<sub2[i]:\n    return 2 \n  return 1 \n maxl=[]\n for i in range(n):\n  for j in range(i,n):\n   maxl.append(max(l[i:j+1]))\n maxl.sort(reverse=True)\n for i in qry:\n  print(maxl[i-1])
from fractions import gcd\nfor testCases in range(eval(input())):\n n = eval(input())\n if n == 1:\n  print('1')\n elif n == 2:\n  print('2')\n elif n == 3:\n  print('6')\n else:\n  c = n*(n-1)\n  k = n - 2\n  while True:\n   if gcd(k,n-1) == 1 and gcd(k,n) == 1:\n    break\n   k -= 1\n  d = (n-1)*(n - 2)\n  k1 = n - 3\n  while True:\n   if gcd(k1,n-1) == 1 and gcd(k1,n-2) == 1:\n    break\n   k1 -= 1\n  print(max(c*k,d*k1))
#from itertools import combinations as c\r\nn=int(input());l=list(map(int,input().split()))\r\nl1=[]\r\nif(n<3):\r\n    print("NO")\r\nelse:\r\n    l.sort()\r\n    for i in range(n-2):\r\n        if(l[i]+l[i+1]>l[i+2]):\r\n            l1.append([l[i+2],l[i+1],l[i]])\r\nif(len(l1)!=0):\r\n    print("YES")\r\n    print(*max(l1))\r\nelse:\r\n    print("NO")
# cook your dish here\nfrom bisect import bisect_left \n \ndef BinarySearch(a, x): \n i = bisect_left(a, x) \n if i != len(a) and a[i] == x: \n  return i \n else: \n  return -1\n\nfor _t in range(int(input())):\n _n, q = list(map(int, input().split()))\n mounts = list(map(int, input().split()))\n for _q in range(q):\n  query = list(map(int, input().split()))\n  if query[0] == 0:\n   mounts[query[1]] = query[2]\n  else:\n   curr = query[1]\n   prev = set(mounts[:curr+1])\n   for m in mounts[curr+1:]:\n    if m > mounts[curr] and m not in prev:\n     print(m)\n     break\n   else:\n    print(-1)\n     \n
try:\n    n, k=map(int, input().split())\n    arr=list(map(int, input().split()))\n    forward = [0]*(n+1)\n    backward= [0]*(n+1)\n    backward[0]=arr[0]\n    backward[1]=arr[0]+arr[1]\n    for i in range(k, n):\n     forward[i]=arr[i] +max(forward[i-1],forward[i-2])\n\n    for i in range(2, n):\n     backward[i]=arr[i]+max(backward[i-1],backward[i-2])\n     \n    ans=-float("Inf")\n    for i in range(k-1, n):\n     ans=max(ans, forward[i]+backward[i]-arr[i])\n    print(ans)\nexcept Exception:\n    pass
# cook your dish here\nfor _ in range(int(input())):\n n = int(input())\n a = list(map(int, input().split()))\n curr = 0\n ans = 0\n for x in a:\n  curr += x\n  ans += abs(curr)\n print(ans)
#dt = {} for i in x: dt[i] = dt.get(i,0)+1\r\nimport sys;input = sys.stdin.readline\r\ninp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]\r\n\r\nn,k = ip()\r\nx = ip()\r\nx.sort()\r\nif k == 1:\r\n    a = x[n//2]\r\n    b = x[n//2-1]\r\nelse:\r\n    s = sum(x)\r\n    a = s//n\r\n    b = a + 1\r\nsa = sum([abs((a-i)**k) for i in x])\r\nsb = sum([abs((b-i)**k) for i in x])\r\nif sa < sb:\r\n    print(a)\r\nelse:\r\n    print(b)
for _ in range(int(input())):\n n=int(input())\n\n\n def maxConsequtiveOnes(lst):\n  _max = 0\n  _ones = [0]\n  for i in lst:\n   if i == 0:\n    _max += 1\n   if i == 1:\n    _max = 0\n   _ones.append(_max)\n  return max(_ones)\n\n\n a = list(map(int, input().split()))\n b = maxConsequtiveOnes(a)\n if (b % 2 == 0):\n  print("No")\n else:\n  print("Yes")\n\n
# cook your dish here\r\nfrom collections import deque\r\nprimes = {2,3,5,7,11,13,17}\r\nedges = [(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\r\nx = [1,2,3,4,5,6,7,8,9]\r\navail = {tuple(x):0}\r\nq = deque([x])\r\nwhile q:\r\n    curr = q.popleft();\r\n    for e in edges:\r\n        if curr[e[0]]+curr[e[1]] in primes:\r\n            nxt = curr[0:]\r\n            nxt[e[0]],nxt[e[1]] = nxt[e[1]], nxt[e[0]] \r\n            nxtt = tuple(nxt)\r\n            if nxtt not in avail:\r\n                avail[nxtt] = avail[tuple(curr)]+1\r\n                q.append(nxt)\r\nt = int(input())\r\nwhile t:\r\n    inp = input()\r\n    grid = []\r\n    for i in range(3):\r\n        inp = input()\r\n        for j in inp.strip().split(" "):\r\n            grid.append(int(j))\r\n    gridt = tuple(grid)\r\n    if gridt in avail: print(avail[gridt])\r\n    else: print(-1);\r\n    t-= 1
def bookList():\r\n    numBooks=int(input())\r\n    bookNum=[int(x) for x in input().split()]\r\n    takenBooks=int(input())\r\n    for i in range(takenBooks):\r\n        takenBookPos=(int(input()))\r\n        a=bookNum[takenBookPos-1]\r\n        print(a)\r\n        bookNum.remove(a)\r\n\r\nbookList()\r\n
for _ in range(int(input())):\r\n    n=int(input())\r\n    l=list(map(int,input().split()))\r\n    su=l[0]\r\n    for i in range(1,n):\r\n        su^=l[i]\r\n    print(su)
# cook your dish here\nfor _ in range(int(input())):\n n=int(input())\n a=[int(x) for x in input().split()]\n sum=0\n for i in range(n):\n  if a[i]%2==0:\n   sum+=1\n  a[i]=sum \n q=int(input())\n while q:\n  l,r=map(int,input().split())\n  if l!=1:\n   c=a[r-1]-a[l-2]\n  else:\n   c=a[r-1] \n  if c==0:\n   print("ODD")\n  else:\n   print("EVEN")\n  q-=1
T=int(input())\nwhile T:\n    x,y=map(int,input().split())\n    while(y): \n        x, y = y, x % y\n    if x==1:\n        print("YES")\n    else:\n        print("NO")\n    T-=1
# cook your dish here\nfor _ in range(int(input())):\n    n,m = list(map(int,input().split()))\n    colors = [0]*41; cost = [0]*41\n    color = 0\n    for i in range(n):\n        cc,pp = list(map(int,input().split()))\n        colors[cc] += 1\n        cost[cc] += pp\n    for i in colors:\n        if i>0: color += 1\n    dp2 = [[0]*41 for i in range(color+1)]\n    dp2[0] = [1]*41\n    for i in range(1,color+1):\n        for j in range(1,41):\n            dp2[i][j] = dp2[i][j-1]+dp2[i-1][j-1]*(2**colors[j]-1)\n    dp1 = [[0]*41 for i in range(color+1)]\n    for i in range(1,color+1):\n        for j in range(1,41):\n            dp1[i][j] = dp1[i][j-1]+dp1[i-1][j-1]*(2**colors[j]-1)+dp2[i-1][j-1]*cost[j]*(2**(colors[j]-1))\n    num=den=0\n    for i in range(m,color+1):\n        num += dp1[i][40]\n        den += dp2[i][40]\n    print(num/den)
for _ in range(int(input())):\n n = int(input())\n ls = []\n rs = []\n lrs = []\n\n for i in range(n):\n  l, r = map(int, input().split())\n  ls.append(l)\n  rs.append(r)\n  lrs.append((l, r, i))\n\n lrs.sort()\n\n c = 0\n maxi = -1\n\n res = [-1] * n\n for l, r, i in lrs:\n  if ls[i] > maxi:\n   maxi = rs[i]\n   res[i] = c\n\n  elif rs[i] <= maxi:\n   res[i] = 1^c\n\n  else:\n   maxi = rs[i]\n   c ^= 1\n   res[i] = c\n\n print(*res, sep='')
def main():\n        while True:\n                [n, m] = [int(i) for i in input().split()]\n                if n == m and n == 0:\n                        break\n                cache = {}\n                for i in range(n):\n                        dna = input().rstrip('\n')\n                        if dna in cache:\n                                cache[dna] = 1 + cache[dna]\n                        else:\n                                cache[dna] = 1\n                c = [0 for i in range(n + 1)]\n                for dna in cache:\n                        c[cache[dna]] = 1 + c[cache[dna]]\n                for i in range(1, n + 1):\n                        print(c[i])\n \ndef __starting_point():\n        main()\n__starting_point()
# cook your dish here\n\n# cook your dish here\n\n \n\nt = int(input())\nwhile t:\n t-=1\n c=0\n ar=[int(i) for i in input().strip().split()]\n for i in range(1,16):\n  b=bin(i)[2:].zfill(4)\n  s=0\n  for i in range(4):\n   if b[i]=='1':\n    s+=ar[i]\n  \n  if(s==0):\n   c=1\n   break\n \n print("Yes" if c==1 else "No")\n
from sys import stdin,stdout\r\ninput=stdin.readline\r\nn=int(input())\r\na=[[] for i in range(n)]\r\nfor i in range(n-1):\r\n    u,v=map(int,input().split())\r\n    a[u-1].append(v-1)\r\n    a[v-1].append(u-1)\r\nb=[0]*n\r\nvis=[0]*n\r\nst=[(0,0)]\r\nvis[0]=1\r\npa=[0]*n\r\nwhile st:\r\n    x,y=st.pop()\r\n    b[x]=y\r\n    for i in a[x]:\r\n        if vis[i]==0:\r\n            pa[i]=x\r\n            vis[i]=1\r\n            if x==0:\r\n                st.append((i,y+len(a[x])-1))\r\n            else:\r\n                st.append((i,y+len(a[x])-2))\r\nc=[]\r\nfor i in range(1,n):\r\n    if len(a[i])==1:\r\n        c.append((b[i],i))\r\nc.sort()\r\nans=0\r\nwhile c:\r\n    x,y=c.pop()\r\n    m=y\r\n    p=0\r\n    while y!=0 and pa[y]!=-1:\r\n        y=pa[y]\r\n        if pa[y]==-1:\r\n            break\r\n        if y!=0:\r\n            p+=(len(a[y])-2)\r\n        else:\r\n            p+=(len(a[y])-1)\r\n    if p>=1:\r\n        p=0\r\n        while m!=0 and pa[m]!=-1:\r\n            x=m\r\n            if pa[m]==-1:\r\n                break\r\n            m=pa[m]\r\n            pa[x]=-1\r\n            if m!=0:\r\n                p+=(len(a[m])-2)\r\n            else:\r\n                p+=(len(a[m])-1)\r\n        if y==0:\r\n            pa[0]=-1\r\nfor i in range(n):\r\n    if pa[i]!=-1:\r\n        st=[i]\r\n        pa[i]=-1\r\n        while st:\r\n            x=st.pop()\r\n            for j in a[x]:\r\n                if pa[j]!=-1:\r\n                    pa[j]=-1\r\n                    st.append(j)\r\n        ans+=1\r\nprint(ans)
testcase = int(input())\nfor case in range(testcase):\n n = int(input())\n print(2**(n-2)+1)\n print('\n') 
# This is not my code, it's Snehasish Karmakar's.  Refer to http://www.codechef.com/viewsolution/7153774\n# for original version.\n# Submitting it to try and work out if it can be sped up.\n\ndef compute_nCr(n,r) :\n C[0][0]=1\n for i in range(1,n+1) :\n#       print "i",i\n  C[i][0]=1\n  for j in range(1,min(i,r)+1) :\n   if i!=j :\n    C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD\n   else :\n    C[i][j]=1\n  \n \ndef solve(n,m) :\n store=[C[m+i-1][i] for i in range(m+1)]\n \n for i in range(1,n+1) :\n  s=1\n  for j in range(1,m+1) :\n   s=(s+store[j])%MOD\n   store[j]=(s*C[m+j-1][j])%MOD\n  #   print "a[%d][%d]=%d"%(i,j,s)\n \n return s \n \nMOD=1000000000\nLIMIT=2000\n \nC=[[0] * (LIMIT + 1) for _ in range(2*LIMIT+1)]\ncompute_nCr(2*LIMIT,LIMIT)\nt=int(input())\n \nwhile t :\n n,m=list(map(int,input().split()))\n print(solve(n,m))\n t-=1
try:\r\n    t=int(input())\r\n    for i in range(t):\r\n        n,k=map(int,input().split())\r\n        s=input()\r\n        l=[-1]*len(s)\r\n        numb=s.count('b')\r\n        x=numb\r\n        for j in range(len(s)):\r\n            if(s[j]=='a'):\r\n                l[j]=numb\r\n            if(s[j]=='b'):\r\n                numb=numb-1\r\n        #print(l)\r\n        count1=0\r\n        for j in range(len(l)):\r\n            if(l[j]>0):\r\n                count1=count1+(k*(2*l[j]+(k-1)*x))//2\r\n            elif(l[j]==0):\r\n                count1=count1+(k*(2*0+(k-1)*x))//2\r\n        print(count1)\r\nexcept:\r\n    pass\r\n
for i in range(int(input())):\n    a=int(input())\n    b=input().split()\n    if '0' in b:\n        print(100*(a-b.index('0'))+b.count('0')*1000)\n    else:\n        print(0)\n
# cook your dish here\n# cook your dish here\nfrom itertools import combinations\nn = int(input())\nt = list(combinations(list(map(int, input().split())), 2))\nar = 0\nfor i in t:\n    ar += abs(i[0] - i[1])\nprint(ar)
for _ in range(int(input())):\n n=int(input())\n a=input()\n b=input()\n l=[]\n flag=0\n for i in range(n):\n  if b[i]!=a[i]:\n   if b[i] in a and b[i]<a[i]:\n    l.append(b[i])\n   else:\n    flag=1\n    break\n if flag==1:\n  print(-1)\n else:\n  if l==[]:\n   print(0)\n  else:\n   l = sorted(list(set(l)), reverse = True)\n   print(len(l))\n   for i in range(len(l)):\n    q=[]\n    r=[]\n    for j in range(len(a)):\n     if l[i]==b[j]:\n      q.append(j)\n      r.append(a[j])\n    if l[i] not in r:\n     for k in range(len(a)):\n      if a[k]==l[i]:\n       q.append(k)\n    print(len(q),*q)\n   \n
for _ in range(int(input())):\n n,m=input().split()\n n,m=int(n),int(m)\n x=y=c=0\n l=list(map(int,input().split()))\n for i in range(n):\n  for j in range(i,n):\n   x=x+l[j]\n   if (x%m)>y:\n    y=x%m\n    c=1\n   elif y==(x%m):\n    c+=1\n  x = 0\n print(y,c)\n\n
def fact(n):\n if n<2:\n  return 1\n return n * fact(n-1)\n \ndef ncr(n, r):\n return fact(n)// (fact(r)*fact(n-r))\n \nt=int(input())\n\nfor _ in range(t):\n n, k = list(map(int, input().split()))\n a = list(map(int, input().split()))\n a.sort()\n count_z = a.count(a[k-1])\n count_z_seq = a[:k].count(a[k-1])\n \n print(ncr(count_z, count_z_seq))\n
import sys\n\ndef main():\n s=sys.stdin.readline\n n, m = list(map(int, s().split()))\n nums={}\n for i in range(1, n+1):\n  nums[i]=list(map(int, s().split()))\n cases=int(s())\n for case in range(cases):\n  px, py, qx, qy = list(map(int, s().split()))\n  ans=[]\n  for i in range(px, qx+1):\n   for j in range(py-1, qy):\n    ans.append(nums[i][j])\n  print(sum(ans))\n\ndef __starting_point():\n main()\n__starting_point()
a=int(input())\r\nfor _ in range(a):\r\n    c,d=list(map(int,input().split()))\r\n    crr=[[[0,0] for i in range(c+1)] for j in range(c+1)]\r\n    trr=[]\r\n    for i in range(c):\r\n        kk=list(input().split())\r\n        trr.append(kk)\r\n    for i in range(1,c+1):\r\n        for j in range(1,c+1):\r\n            if(trr[i-1][j-1]=='a'):\r\n                crr[i][j][0]=max(crr[i-1][j][0],crr[i][j-1][0])+1\r\n                if(j==1):\r\n                    crr[i][j][1]=crr[i-1][j][1]+1\r\n                elif(i==1):\r\n                    crr[i][j][1]=crr[i][j-1][1]+1\r\n                elif(crr[i-1][j][0]>crr[i][j-1][0]):\r\n                    crr[i][j][1]=crr[i-1][j][1]+1\r\n                else:\r\n                    crr[i][j][1]=crr[i][j-1][1]+1\r\n            else:\r\n                crr[i][j][0]=max(crr[i-1][j][0],crr[i][j-1][0])\r\n                if(j==1):\r\n                    crr[i][j][1]=crr[i-1][j][1]+1\r\n                elif(i==1):\r\n                    crr[i][j][1]=crr[i][j-1][1]+1\r\n                elif(crr[i-1][j][0]>crr[i][j-1][0]):\r\n                    crr[i][j][1]=crr[i-1][j][1]+1\r\n                else:\r\n                    crr[i][j][1]=crr[i][j-1][1]+1\r\n        \r\n    for i in range(d):\r\n        m,n=list(map(int,input().split()))\r\n        print(crr[m][n][1]-crr[m][n][0])\r\n    \r\n
t = eval(input())\nfor _ in range(t):\n n, m = list(map(int, input().split()))\n if n*m == 2:\n  print('Yes')\n elif (n*m)%2 == 0 and m != 1 and n != 1:\n  print('Yes')\n else:\n  print('No')
def bestMovie():\n tests=int(input())\n for t in range(tests):\n  n = int(input())\n  L = list(map(int, input().split()))\n  R = list(map(int, input().split()))\n  maxIndex = -1\n  maxValue = 0\n  for i in range(n):\n   prod = L[i]*R[i]\n   if maxValue < prod:\n    maxValue = prod\n    maxIndex = i\n   elif maxValue == prod:\n    if R[maxIndex] < R[i]:\n     maxIndex = i\n  print(maxIndex+1)\n\nbestMovie()
for t in range(eval(input())):\n n=eval(input())\n n-=n%10\n n/=10\n print(n*(n+1)/2*10)
T = int(input())\nfor i in range(T):\n x = int(input())\n l= [int(x) for x in input().split()]\n t=[]\n for i in range(len(l)):\n  t.append(l[i]+i) \n print(max(t))
def isSubsetSum(arr, n, sum): \n    subset = [ [False for j in range(sum + 1)] for i in range(3) ]    \n    for i in range(n + 1): \n        for j in range(sum + 1): \n            if (j == 0):subset[i % 2][j] = True\n            elif (i == 0):subset[i % 2][j] = False\n            elif (arr[i - 1] <= j):subset[i % 2][j] = subset[(i + 1) % 2][j - arr[i - 1]] or subset[(i + 1)% 2][j] \n            else:subset[i % 2][j] = subset[(i + 1) % 2][j]                   \n    return subset[n % 2][sum]  \nfor _ in range(int(input())):\n    k,n,a = int(input()),int(input()),list(map(int,input().split()))\n    if sum(a) < k or k < min(a):print(0);continue\n    print(1) if isSubsetSum(a, n, k) else print(0)
def func(num):\r\n    for i in range(num):\r\n        if i < num//2 + 1:\r\n            print(' '*i, end='')\r\n            print('*')\r\n        else:\r\n            print(' '*(num-i-1), end='')\r\n            print('*')\r\n\r\n\r\n\r\nfor _ in range(int(input())):\r\n    num = int(input())\r\n    func(num)\r\n
M = 10 ** 9 + 7\nfor _ in range(int(input())):\n    s,p,m,r = list(map(int, input())),0,1,0\n    for d in reversed(s):\n        p += d * m\n        m = m * 10 % M\n    for d in s:\n        r = (r * m + p) % M\n        p = (p * 10 - (m - 1) * d) % M\n    print(r)
t=int(input())\r\nfor _ in range(t):\r\n    n=int(input())\r\n    b=1\r\n    if n%2:\r\n        c=n-2\r\n        for j in range(n//2):\r\n            print(" "*j+str(b) +" "*c+ str(b))\r\n            b+=1\r\n            c-=2\r\n        print(" "*(n//2)+str(b)+" "*(n//2))\r\n        b+=1\r\n        c=1\r\n        for j in range(n//2):\r\n            print(" "*(n//2-j-1)+str(b)+" "*c+ str(b))\r\n            b+=1\r\n            c+=2\r\n    else:\r\n        c=n-2\r\n        for j in range(n//2):\r\n            print(" "*j+str(b)+" "*c+str(b))\r\n            b+=1\r\n            c-=2\r\n        c=0\r\n        for j in range(n//2):\r\n            print(" "*(n//2-j-1)+str(b) +" "*c+ str(b))\r\n            b+=1\r\n            c+=2\r\n        \r\n    \r\n        \r\n    \r\n                \r\n    \r\n
t=int(input())\nfor _ in range(t):\n n=int(input())\n \n grid=[]\n for _ in range(n):\n  temp=[]\n  temp=list(map(int,input().strip().split()))\n  temp.sort()\n  grid.append(temp)\n  \n \n curr=max(grid[n-1])\n total=curr\n for i in range(n-2,0-1,-1):\n  flag=0\n  for j in range(n-1,0-1,-1):\n   if grid[i][j]<curr:\n    flag=1\n    curr=grid[i][j]\n    total+=curr\n    break\n   \n  if flag==0:\n   total=-1\n   break\n \n print(total)\n \n \n    \n   \n   \n  \n
def getInput():\n N_k = input().split()\n N =int(N_k[0])\n k =int(N_k[1])\n list = []\n output = []\n count = 0\n for i in range(0,k):\n  val = input()\n  if(val!="CLOSEALL"):\n   val=val.split()\n   val = int (val[1])\n   if val not in list:\n    count= count +1\n    list.append(val)\n   else:\n    list.remove(val)\n    count= count -1\n  else:\n   count =0\n   while len(list) > 0: \n    list.pop()\n  output.append(count)\n for each in output:\n  print(each)\ngetInput()
def __gcd(a, b): \n  \n # Everything divides 0  \n if (a == 0 or b == 0): \n  return 0; \n \n # base case \n if (a == b): \n  return a; \n \n # a is greater \n if (a > b): \n  return __gcd(a - b, b); \n return __gcd(a, b - a); \n \n# Function to find  \n# number of squares \ndef NumberOfSquares(x, y): \n  \n # Here in built PHP \n # gcd function is used \n s = __gcd(x, y); \n \n ans = (x * y) / (s * s); \n \n return int(ans);\n \nn=int(input())\nwhile n:\n n=n-1\n c,d=map(int,input().split())\n print(NumberOfSquares(c, d))
K,A,B = map(int,input().split())\r\n \r\nif A + 2 > B:\r\n    print(K + 1)\r\n    return\r\n \r\nstart = A - 1\r\nK -= start\r\nans = K//2 * (B-A) + K%2 + start + 1\r\nprint(ans)
a= [0, 0, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 0, 5, 2, 2, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 2, 7, 4, 0, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 2, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2]\n \nt = int(input())\n \nfor i in range(t):\n	n = int(input())\n	if a[n]>0:\n		print("Arjuna")\n	else:\n		print("Bhima") 
# cook your dish here\r\n#Moony and ICPC team\r\nT = int(input())\r\n\r\nfor i in range(T):\r\n    N,data = int(input()),list(map(int,input().split()))\r\n    if(N==3):\r\n        print(sum(data))\r\n    else:\r\n        best = data[0]+data[1]+data[2]\r\n        overall = best\r\n        k=len(data)\r\n        for i in range(1,k-2):\r\n            overall=overall - data[i-1] + data[i+2]\r\n            if(overall>best):\r\n                best = overall\r\n        j=max(data[1],data[-2])\r\n        l= data[-1]+data[0]+j\r\n        if(best < l):\r\n            best = l\r\n        print(best)
n=eval(input())\na=list(map(int,input().split()))\nc=m=0\nmaxi=max(a)\nfor i in range(n):\n if a[i]==maxi:\n  c+=1\n  m=max(c,m)\n else:\n  c=0\nprint(m) 
from math import gcd\r\n\r\n__author__ = 'Prateek'\r\n\r\n\r\ndef test():\r\n    n = int(input())\r\n    a = list(map(int, input().split()))\r\n    a = list(set(a))\r\n    n = len(a)\r\n    if len(a) == 1:\r\n        print(2 * a[0])\r\n        return\r\n    g1 = [0 for i in range(n)]\r\n    g2 = [0 for i in range(n)]\r\n    g1[0] = a[0]\r\n    g2[n - 1] = a[n - 1]\r\n    for i in range(1, n):\r\n        g1[i] = gcd(g1[i - 1], a[i])\r\n    for i in range(n - 2, -1, -1):\r\n        g2[i] = gcd(g2[i + 1], a[i])\r\n    ans = 0\r\n    for i in range(n):\r\n        if i == 0:\r\n            ans = max(ans, g2[i + 1] + a[i])\r\n        elif i == n - 1:\r\n            ans = max(ans, g1[i - 1] + a[i])\r\n        else:\r\n            ans = max(ans, gcd(g1[i - 1], g2[i + 1]) + a[i])\r\n    print(ans)\r\n\r\n\r\nif __author__ == 'Prateek':\r\n    t = int(input())\r\n    for _ in range(t):\r\n        test()\r\n
for _ in range(int(input())):\n	n,k=map(int,input().split())\n	print(((2*n*(k-1))+2)/k)
t=int(input())\nfor t in range(t):\n    n=int(input())\n    for i in range(0,n):\n        for j in range(0,n):\n            if i%2==0:\n                if j%2==0:\n                    print(0,end="")\n                else:\n                    print(1,end="")\n            else:\n                if j%2==0:\n                    print(1,end="")\n                else:\n                    print(0,end="")\n        print()\n            \n
# cook your dish here\nt=int(input())\nfor i in range(t):\n n=int(input())\n if n<101:\n  l1=[]\n  l2=[]\n  d=dict()\n  for i in range(1,2*n+1):\n   if i%2==0:\n    l1.append(int(input()))\n   else:\n    l2.append(str(input()))\n  r1=[]\n  for i in l1:\n   r1.append(i)\n  l1.sort()\n  ind=[]\n  for i in l1:\n   a=r1.index(i)\n   ind.append(a)\n  for i in ind:\n   print(l2[i])\n else:\n  print(0)\n  break\n \n
# cook your dish here\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int,input().split()))\n    l = []\n    for i in range(0, len(arr)):    \n        for j in range(i+1, len(arr)):    \n            if(arr[i] == arr[j]):  \n                l.append(arr[j])\n    if (len(l) ==0):\n        print("prekrasnyy")\n    else:\n        print("ne krasivo")
oo = int(input())\r\nfor i in range(oo):\r\n	val = input()\r\n	print(val[::-1])
t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    \n    a = {}\n    \n    for i in range(n):\n        l = input()\n        \n        if l not in a:\n            a[l] = 1\n        else:\n            a[l] += 1\n    \n    done = []\n    ans = 0\n    \n    for i in a:\n        if a[i] != 0:\n            temp = [x for x in i.split()]\n            v = temp[0]\n            \n            v0 = v + " 0"\n            v1 = v + " 1"\n            \n            if(v0 in a and v1 in a):\n                if a[v0] > a[v1]:\n                    ans += a[v0]\n                else:\n                    ans += a[v1]\n            \n                a[v0] = a[v1] = 0\n            elif(v0 in a):\n                ans += a[v0]\n                a[v0] = 0\n            elif(v1 in a):\n                ans += a[v1]\n                a[v1] = 0\n    \n    print(ans)
testcases = int(input())\n\nfor i in range(testcases):\n n = int(input())\n my = list(map(int,input().split()))\n opp = list(map(int,input().split()))\n \n my.sort(reverse = True)\n opp.sort(reverse = True)\n \n j = 0\n k = 0\n while(k < n):\n  if(my[j] > opp[k]):\n   j += 1\n  k += 1\n\n print(j)
# cook your dish here\nt=int(input())\nwhile t>0:\n    n=int(input())\n    if n==1:\n        print(1)\n    else:\n        c,num=1,2\n        while num<n:\n            num*=2\n        if num==n:\n            print(num)\n        else:\n            print(num//2)\n    t-=1
import math\r\nimport os\r\nimport random\r\nimport re\r\nimport sys\r\n\r\n\r\nr = 100000\r\nprev = 1\r\ns = set()\r\nfor i in range(1, r+1):\r\n    now = i ^ prev\r\n    s.add(now)\r\n    prev = now\r\ns = list(s)\r\nt = int(input())\r\nwhile t > 0:\r\n    t -= 1\r\n    n, k = list(map(int, input().split()))\r\n\r\n    if n > 3:\r\n        if n % 2 == 0:\r\n            size = (n//2) + 2\r\n        else:\r\n            size = ((n-1)//2) + 2\r\n    else:\r\n        size = n\r\n    if size - k >= 0:\r\n        print(s[size-k])\r\n    else:\r\n        print(-1)\r\n
# cook your dish here\nimport math\nT = int(input())\nfor _ in range(T):\n N, H = map(int, input().split())\n A = list(map(int, input().split()))\n low, high = 1, max(A)\n while low != high:\n  time = 0\n  mid = (low + high) // 2\n  for i in range(N):\n   time += math.ceil(A[i] / mid)\n  \n  if time <= H :\n   high = mid\n  else:\n   low = mid + 1\n print(high)
#!/usr/bin/env python\n\nF = [1,1]\ndef fibo():\n for i in range(500):\n  F.append(F[-2] + F[-1])\n\ndef main():\n fibo()\n #print len(str(F[-1]))\n #print len(str(10**100))\n while True:\n  try:\n   A, B = list(map(int, input().strip().split()[:2]))\n   if A == 0 and B == 0: break\n   print(len([x for x in F if x >= A and x <= B]))\n  except:\n   break\n\nmain()\n\n
cases = int(input())\n\nfor case in range(cases):\n N, M, K = [int(i) for i in input().split()]\n A = [int(i) for i in input().split()]\n jad = 0\n P = M*K\n\n for milk in A:\n  if(milk>P):\n   jad += milk-P\n  else:\n   jad += milk%K\n\n print(jad%1000000007)\n
n=int(input())\r\nl=[]\r\ndp=[]\r\nd={}\r\nfor i in range(n):\r\n	l.append(int(input()))\r\n	d[i]=[]\r\n	dp.append([0,0])\r\n\r\nfor i in range(n-1):\r\n	a,b=list(map(int,input().split()))\r\n	d[a-1].append(b-1)\r\n	d[b-1].append(a-1)\r\n#print(l)\r\n#print(d)\r\n\r\ndef dfs(ch,pa,visited):\r\n	dp[ch][1]=l[ch]\r\n	#print(dp[ch],ch+1)\r\n	for i in range(len(d[ch])):\r\n		if d[ch][i] not in visited:\r\n			visited.add(d[ch][i])\r\n			dfs(d[ch][i],ch,visited)\r\n			dp[ch][0]+=max(dp[d[ch][i]][0],dp[d[ch][i]][1])\r\n			dp[ch][1]+=dp[d[ch][i]][0]\r\n			#print(ch+1,dp[ch])\r\nv=set()\r\nv.add(0)\r\ndfs(0,-1,v)\r\n\r\n#print(dp)\r\nprint(max(dp[0][0],dp[0][1]))\r\n\r\n	\r\n\r\n\r\n
testCases = int(input())\nfor c in range(testCases):\n n, k = list(map(int, input().split()))\n sum = 0\n i = 0\n power = 1\n while i <= n:\n  if k**power == i:\n   power += 1\n  else:\n   sum += i\n  i +=1 \n answer = "Case #" + str(c + 1) + ": " + str(sum)\n print(answer)
try:\n \n for _ in range(int(input())):\n  n = int(input())\n  print(0) if(n==1) else print(pow(2,n-1,10**9+7)-2) \nexcept EOFError:\n pass\n\n  
t=int(input())\nfor _ in range(t):\n n=int(input())\n l=list(map(int,input().split()))\n if sum(l)!=n or max(l)==n:\n  print('-1')\n else:\n  d=dict()\n  ans=[-1]*n\n  for i in range(0,n):\n   d[i]=1\n  for i in range(n):\n   if l[i]!=0:\n    count=l[i]\n    for k,v in list(d.items()):\n     if count>0 and v==1 and i!=k:\n      d[k]=0\n      ans[k]=i+1\n      count-=1\n  ind=-1\n  for i in range(0,len(ans)):\n   if ans[i]==-1:\n    ind=i\n  if ind==-1:\n   print(*ans)\n  else:\n   for i in range(len(ans)):\n    if ans[i]!=ind+1:\n     \n    \n     ans[ind]=ans[i]\n     ans[i]=ind+1\n     break\n   print(*ans)\n   \n    \n   \n  \n\n      \n \n    \n\n \n
T = int(input())\nfor _ in range(T):\n W = list(map(int, input().strip().split()))\n S = W[0]\n W = W[1:]\n W = W[::-1]\n i = 0\n c = 0\n flag = 0\n while (len(W) != 0 or flag != 1) and i<len(W):\n  k = i\n  su = 0\n  while su <= S and k<len(W)-1:\n   su += W[k]\n   k += 1\n  if su-W[k-1]<=S:\n   c += 1\n  else:\n   flag = 1\n  i += 1\n print(c-1) \n
from bisect import insort\nfrom math import ceil\nfor _ in range(int(input())):\n n,k=list(map(int,input().split( )))\n array=list(map(int,input().split( )))\n ans=0\n index=[]\n for i in range(1,n+1):\n  index.append(ceil(k/(ceil(k/i))))\n for i in range(n):\n  count=[0]*(2001)\n  temp=[]\n  for j in range(i,n):\n   count[array[j]]+=1\n   insort(temp,array[j])\n   #m=ceil(k/(j-i+1)) precalculate thes values in index array\n   #t=ceil(k/m)\n   x=temp[index[j-i]-1]\n   f=count[x]\n   if count[f]:\n    ans+=1\n print(ans)\n
x = input()\ny = input()\nz = x.find(y)\nif z == -1 :\n print('N')\nelse :\n print('Y')
# cook your dish here\nimport math;\nfrom math import gcd,sqrt,floor,factorial,ceil\nfrom bisect import bisect_left,bisect_right\nimport bisect;\nimport sys;\nfrom sys import stdin,stdout\nimport os\nsys.setrecursionlimit(pow(10,7))\nimport collections\nfrom collections import defaultdict,Counter\nfrom statistics import median\n# input=stdin.readline\n# print=stdout.write\nfrom queue import Queue\ninf = float("inf")\nfrom operator import neg;\nmod=pow(10,9)+7\ndef fun(l):\n m=[[l[0]]]\n for i in range(1,n):\n  if m[-1][-1]==l[i]:\n   m[-1]+=[l[i]]\n  else:\n   m.append([l[i]])\n count=[]\n for i in range(len(m)):\n  count.append(len(m[i]))\n return count;\ndef function(l1,index,prev,count):\n tuple=(index,prev,count)\n if tuple in dict:\n  return dict[tuple]\n n=len(l1)\n if index==n:\n  return 0;\n if count>=3:\n  if index%2==prev:\n   dict[tuple]=function(l1,index+1,prev,count)\n   return function(l1,index+1,prev,count)\n  else:\n   dict[tuple]=l1[index]+function(l1,index+1,prev,count);\n   return dict[tuple]\n if prev==None:\n  skip=l1[index]+function(l1,index+1,prev,count)\n  not_skip=function(l1,index+1,index%2,count+1)\n  maxa=min(skip,not_skip)\n  dict[tuple]=maxa\n  return maxa;\n\n if index%2==prev:\n  dict[tuple]=function(l1,index+1,index%2,count)\n  return dict[tuple]\n if index%2!=prev:\n  skip=l1[index]+function(l1,index+1,prev,count)\n  not_skip=function(l1,index+1,index%2,1+count)\n  maxa = min(skip, not_skip)\n  dict[tuple]=maxa\n  return maxa;\n\nt=int(input())\nfor i in range(t):\n s=input()\n l=list(s)\n n=len(l)\n l=[int(i) for i in l]\n l1=fun(l)\n dict=defaultdict(int)\n theta=function(l1,0,None,0)\n print(theta)\n
import sys\r\n\r\nt = int(input())\r\n# print(t)\r\nfor _ in range(t):\r\n	n,m = map(int,input().split());\r\n	s = [];\r\n	for i in range(n):\r\n		s.append(input())\r\n	ans = []\r\n	for i in range(n):\r\n		ans.append([])\r\n		for j in range(m):\r\n			ans[i].append([])\r\n	for i in range(n):\r\n		for j in range(m):\r\n			c = 0\r\n			if s[i][j] == 'U':\r\n				for k in range(i,-1,-1):\r\n					if s[k][j] == '#':\r\n						break\r\n					ans[k][j].append(c)\r\n					c+=1\r\n			elif s[i][j] == 'D':\r\n				for k in range(i,n):\r\n					if s[k][j] == '#':\r\n						break\r\n					ans[k][j].append(c)\r\n					c+=1\r\n			elif s[i][j] == 'L':\r\n				for k in range(j,-1,-1):\r\n					if s[i][k] == '#':\r\n						break\r\n					ans[i][k].append(c)\r\n					c+=1\r\n			elif s[i][j] == 'R':\r\n				for k in range(j,m):\r\n					if s[i][k] == '#':\r\n						break\r\n					ans[i][k].append(c)\r\n					c+=1\r\n	for i in range(n):\r\n		for j in range(m):\r\n			ans[i][j].sort()\r\n	res = []\r\n	for i in range(n):\r\n		for j in range(m):\r\n			c= 1\r\n			# print(ans[i][j])\r\n			for k in range(1,len(ans[i][j])):\r\n				# print(ans[i][j][k])\r\n				if ans[i][j][k] == ans[i][j][k-1]:\r\n					c+=1\r\n				else :\r\n					if c!=1:\r\n						res.append(c)\r\n					c = 1\r\n				if k==len(ans[i][j])-1:\r\n					if c!=1:\r\n						res.append(c)\r\n	pairs = 0\r\n	# print(res)\r\n	for i in range(len(res)):\r\n		pairs  += ((res[i]*(res[i]-1))//2)\r\n	\r\n	print(pairs)
for t in range(int(input())):\n n, a , b , k = map(int,input().split())\n solvedbychef = 0\n solvedbyappy = 0\n for i in range(n+1):\n  if i % a == 0 and i % b == 0 :\n   continue\n  elif i%a == 0 :\n   solvedbyappy+=1\n  elif i%b == 0:\n   solvedbychef+=1\n totalsolved = solvedbychef + solvedbyappy\n if totalsolved>=k:\n  print("Win")\n else :\n  print("Lose")
let_to_num = {'A':[0,5], 'B':[1,6], 'C':[2,7], 'D':[3,8], 'E':[4,9]}\n\nnum_to_let = {0:'A', 1:'B', 2:'C', 3:'D', 4:'E',\n              5:'A', 6:'B', 7:'C', 8:'D', 9:'E'}\n\nconnections = {0:(1,4,5), 1:(0,2,6), 2:(1,3,7), 3:(2,4,8), 4:(0,3,9), 5:(0,7,8),\n               6:(1,8,9), 7:(2,5,9), 8:(3,5,6), 9:(4,6,7)}\n\nT = int(input())\n\nfor i in range(T):\n    s = input()\n    out_1, out_2= [],[]\n    flag1, flag2 = True, True\n    for c in range(len(s)):\n        #print out_1, out_2, flag1, flag2\n        if c == 0:\n            out_1.append(let_to_num[s[c]][0])\n            out_2.append(let_to_num[s[c]][1])\n            #print out_1, out_2, '\n'\n        else:\n            if flag1:\n                conn_1 = set(connections[out_1[-1]])\n                to_conn_1 = set(let_to_num[s[c]])\n                \n                if len(conn_1.intersection(to_conn_1))==0:\n                    flag1 = False\n                else:\n                    out_1.extend(list(conn_1.intersection(to_conn_1)))\n                    \n                #print 'out1',conn_1, to_conn_1, flag1, conn_1.intersection(to_conn_1)\n            if flag2:\n                conn_2 = set(connections[out_2[-1]])\n                to_conn_2 = set(let_to_num[s[c]])\n                \n                if len(conn_2.intersection(to_conn_2))==0:\n                    flag2 = False\n                else:\n                    out_2.extend(list(conn_2.intersection(to_conn_2)))\n                #print 'out2', conn_2, to_conn_2, flag2, conn_2.intersection(to_conn_2)\n            #print out_1, out_2, flag1, flag2, '\n'\n            if (not flag1) and (not flag2):\n                break\n    if (not flag1) and (not flag2):\n        print(-1)\n        continue\n    elif flag1 and (not flag2):\n        print(''.join(str(k) for k in out_1))\n        continue\n    elif flag2 and (not flag1):\n        print(''.join(str(k) for k in out_2))\n        continue\n    else:\n        print(min(''.join(str(k) for k in out_1), ''.join(str(k) for k in out_2)))\n        continue\n
import math\nT=int(input())\nfor i in range(T):\n N,M,S=input().split()\n N=int(N)\n M=int(M)\n S=int(S)\n ls=list(map(int,input().split()))\n maxx=max(ls)\n if S<17 and maxx<=50:\n  ls.sort()\n  total_sum = M * S\n  count = 0\n  sum = 0\n  for i in ls:\n   if i / S > 2:\n    continue\n   else:\n    sum = sum + math.ceil(i / S) * S\n    if sum <= total_sum:\n     count = count + 1\n  print(count)\n# cook your dish here\n
import sys\nfrom collections import defaultdict as dd\nfrom collections import deque\nfrom fractions import Fraction as f\nfrom copy import *\nfrom bisect import * \nfrom heapq import *\nfrom math import *\nfrom itertools import permutations \n \ndef eprint(*args):\n print(*args, file=sys.stderr)\nzz=1\n \n#sys.setrecursionlimit(10**6)\nif zz:\n input=sys.stdin.readline\nelse:   \n sys.stdin=open('input.txt', 'r')\n sys.stdout=open('all.txt','w')\ndef li():\n return [int(xx) for xx in input().split()]\ndef fli():\n return [float(x) for x in input().split()] \ndef comp(a,b):\n if(a>b):\n  return 2\n return 2 if a==b else 0 \ndef gi():   \n return [xx for x in input().split()]\ndef fi():\n return int(input())\ndef swap(a,i,j):\n a[i],a[j]=a[j],a[i] \ndef si():\n return list(input().rstrip()) \ndef mi():\n return map(int,input().split()) \ndef gh():\n sys.stdout.flush()\ndef graph(n,m):\n for i in range(m):\n  x,y=mi()\n  a[x].append(y)\n  a[y].append(x)\ndef bo(i):\n return ord(i)-ord('a')\n  \n \nt=fi()\nwhile t>0:\n t-=1\n n,z1,z2=mi()\n d={}\n a=li()\n flag=0\n for i in a:\n  d[i]=1\n  d[-i]=1\n  if i==z1 or i==z2 or i==-z1 or i==-z2:\n   flag=1\n   break\n if flag:\n  print(1)\n  continue \n for i in d:\n  p=[i-z1,i-z2]\n  c=1\n  for j in p:\n   if j in d:\n    c*=0\n  flag|=c \n print(0 if flag else 2) 
t=int(input())\r\n\r\nfor t1 in range(t):\r\n	n,x=map(int,input().split())\r\n	a=list(map(int,input().split()))\r\n	\r\n	mx=max(a)\r\n	mn=min(a)\r\n	\r\n	if (mx-mn<x):\r\n		print("YES")\r\n	else:\r\n		print("NO")
t = int(input())\nfor _ in range(t):\n x, y, k, n = [int(x) for x in input().split()]\n k = k*2\n temp = abs(x-y)\n if(temp%k == 0):\n  print("Yes")\n else:\n  print("No")\n
# cook your dish here\n\nimport numpy as np\n \n\ndef minstairs(n,k):\n stairsHeight=[]\n stairs=0\n current = 0\n stairsHeight=list(map(int, input().split()))\n stairsHeight=np.array(stairsHeight)\n curr=0\n for i in range(n):\n  if stairsHeight[i]-curr<=k:\n   curr=stairsHeight[i]\n  else:\n   if (stairsHeight[i]-curr)%k==0:\n    stairs+=((stairsHeight[i]-curr)//k)-1\n   else:\n    stairs+=(stairsHeight[i]-curr)//k\n   curr=stairsHeight[i]\n return stairs\n  \nT=int(input())\nfor i in range(T):\n n,k =list(map(int,input().split()))\n print(minstairs(n,k))\n
for _ in range(int(input())):\r\n    x, y = map(int, input().split())\r\n    ans = 0\r\n    for i in range(y, x+1, y):\r\n        if i%y == 0:\r\n            ans += i%10\r\n    print(ans)
oo = int(input())\r\nfor i in range(oo):\r\n	val = int(input())\r\n	print((val**2)*3.14)
# cook your dish here\nt=int(input())\nfor i in range(t):\n n=int(input())\n ar=list(map(int,input().split()))\n tot=0\n st=0\n for j in range(1,n):\n  if(ar[j-1]>ar[j]):\n   si=j-st\n   c=(si*(si+1))//2\n   tot+=c\n   st=j\n si=n-st\n c=(si*(si+1))//2\n tot+=c\n print(tot)\n
from collections import Counter\r\ndef solve(A,B):\r\n    a = Counter(A)\r\n    b = Counter(B)\r\n    ans = 0\r\n    for i in a:\r\n        if i in b:\r\n            ans += min(a[i],b[i])\r\n            \r\n    return ans\r\n    \r\n   \r\nt = int(input())\r\n\r\nfor _ in range(t):\r\n    A = input()\r\n    B = input()\r\n    print(solve(A,B))
for _ in range(int(input())):\n n = int(input())\n a = list(map(int, input().split()))\n s = set(a)\n\n if n == 1 or len(s) > 2:\n  print(-1)\n  continue\n\n if len(s) == 1:\n  x = s.pop()\n\n  if x == 0:\n   print(n)\n  elif x == n-1:\n   print(0)\n  else:\n   print(-1)\n\n  continue\n\n x, y = sorted(s)\n xc, yc = a.count(x), a.count(y)\n\n if xc == y and xc == x + 1:\n  print(yc)\n else:\n  print(-1)\n
try:\r\n    for _ in range(int(input())):\r\n        s,s1=0,0\r\n        x,k=[int(i) for i in input().split()]\r\n        for i in range(2,x+1):\r\n            if(x%i==0):\r\n                s=s+i**k\r\n        for i in range(2,k+1):\r\n            if(k%i==0):\r\n                s1+=i*x\r\n        print(s,s1)\r\nexcept EOFError as e:\r\n    pass
from sys import stdin, stdout\r\ninput = stdin.readline\r\nfrom collections import defaultdict as dd\r\nimport math\r\ndef geti(): return list(map(int, input().strip().split()))\r\ndef getl(): return list(map(int, input().strip().split()))\r\ndef gets(): return input()\r\ndef geta(): return int(input())\r\ndef print_s(s): stdout.write(s+'\n')\r\n\r\ndef solve():\r\n    for _ in range(geta()):\r\n        n=geta()\r\n        n=bin(n).split('b')[1]\r\n        print(n.count('0'))\r\n\r\n\r\ndef __starting_point():\r\n    solve()\r\n\n__starting_point()
for _ in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    x=int(input())\n    for _ in range(1,n,2):\n        a[_],a[_-1]=a[_-1],a[_]\n    for _ in range(n):\n        a[_]+=(a[_]%3)\n    # a=a[::-1]\n    # a.sort()\n    # if x>a[-1]:\n    #     print(-1)\n    #     continue\n    l,h=-1,9999999999\n    for _ in range(n):\n        # if a[_]>=x:\n        #     if _==n-1:\n        #         print(-1)\n        #         break\n        #     elif _==0:\n        #         print(-1)\n        #         break\n        #     else:\n        #         print(a[_-1],a[_])\n        #         break\n        if a[_]>l and a[_]<x    :\n            l=a[_]\n        if a[_]<h and a[_]>x    :\n            h=a[_]\n    print(l,end=" ")\n    if h==9999999999:\n        print(-1)\n    else:    \n        print(h)    \n            \n        
# cook your dish here\n# cook your dish here\nfor _ in range(int(input())):\n n=int(input())\n a=list(map(int, input().split()))\n b=list(map(int, input().split()))\n\n if a[0]!=0 or b[-1]!=0 or a[-1]!=b[0]:\n  print('No')\n  \n else:\n  ab=b[0]\n  flag=0\n  for i in range(1, n-1):\n   if a[i]==0 or b[i]==0:\n    print('No')\n    flag=1 \n    break\n   \n   elif a[i]+b[i]<ab:\n    print('No')\n    flag=1 \n    break\n   \n   elif a[i]>ab+b[i] or b[i]>ab+a[i]:\n    print('No')\n    flag=1 \n    break\n   \n  if flag==0:\n   print('Yes')
def search(arr, lenl, val):\r\n    s = 0\r\n    l = lenl - 1\r\n\r\n    total = 0\r\n\r\n    while (s <= l):\r\n        m = int((s + l) / 2)\r\n\r\n        if (arr[m] <= val):\r\n            total = m + 1\r\n            s = m + 1\r\n\r\n        else:\r\n            l = m - 1\r\n\r\n    return total\r\n\r\n\r\ndef kmpsearch(string, lps):\r\n    lis = []\r\n    lens = len(string)\r\n    lensh = lens // 2\r\n\r\n    l = 0\r\n    i = 0\r\n    while i < lens:\r\n        if string[i] == pat[l]:\r\n            l += 1\r\n            i += 1\r\n        elif l > 0:\r\n            l = lps[l - 1]\r\n        else:\r\n            i += 1\r\n\r\n        if l == lenp:\r\n            if i - l < lensh:\r\n                lis.append(i - l)\r\n\r\n            l = lps[l - 1]\r\n\r\n    return lis\r\n\r\n\r\ndef kmp(pat, lenp):\r\n\r\n    lps = [0]*(lenp)\r\n    l = 0\r\n    i = 1\r\n\r\n    while i < lenp:\r\n        if pat[i] == pat[l]:\r\n            l += 1\r\n            lps[i] = l\r\n            i += 1\r\n        elif l > 0:\r\n            l = lps[l-1]\r\n        else:\r\n            lps[i] = 0\r\n            i += 1\r\n\r\n    return lps\r\n\r\n\r\n\r\nkeyword = input()\r\npat = input()\r\nq = int(input())\r\n\r\nlenk = len(keyword)\r\nlenp = len(pat)\r\n\r\nk = keyword * 2\r\nlis = kmpsearch(k, kmp(pat, lenp))\r\nlenl = len(lis)\r\n\r\nfor _ in range(q):\r\n    n = int(input())\r\n    count = 0\r\n\r\n    q = n // lenk\r\n    r = n % lenk\r\n\r\n    count += search(lis, lenl, r - lenp)\r\n\r\n    if q >= 1:\r\n        count += search(lis, lenl, lenk + r - lenp)\r\n\r\n    if q >= 2:\r\n        count += (q - 1)*lenl\r\n\r\n    print(count)\r\n    \r\n
# cook your dish here\ndef ceil(num):\n if num%1==0:\n  return int(num//1)\n else:\n  return int((num//1)+1)\n \nfor _ in range(int(input())):\n n=int(input())\n s=input()\n p=0\n a=[]\n for i in range(n):\n  if s[i]=="P":\n   p=p+1\n req=ceil(0.75*n)\n requirement=req-p\n for i in range(2,n-2):\n  if s[i]=="A":\n   if (s[i-1]=="P" or s[i-2]=="P") and (s[i+1]=="P" or s[i+2]=="P"):\n    a.append(i)\n if requirement>len(a):\n  print(-1)\n else:\n  print(max(requirement,0))
# cook your dish here\nt=int(input())\nwhile t:\n n=int(input())\n r1=input()\n r2=input()\n r1count=0\n r2count=0\n count=0\n for i in range(n):\n  if(r1[i]=="*"):\n   r1count+=1\n  if(r2[i]=="*"):\n   r2count+=1\n if(r1count>0) and (r2count>0):\n  count=1\n  r1count=0\n  r2count=0\n  i=0\n  while(i<n):\n   if(r1[i]=="*"):\n    r1count+=1\n   if(r2[i]=="*"):\n    r2count+=1\n   if(r1count>1) or (r2count>1):\n    count+=1\n    r1count=0\n    r2count=0\n    i-=1\n   i+=1\n elif(r1count==0 and r2count>0) or (r2count==0 and r1count>0):\n  count=max(r1count,r2count)-1\n else:\n  count=0\n print(count)\n t-=1
# cook your dish here\nimport math;\nfrom math import gcd,sqrt,floor,factorial,ceil\nfrom bisect import bisect_left,bisect_right\nimport bisect;\nimport sys;\nfrom sys import stdin,stdout\nimport os\nsys.setrecursionlimit(pow(10,7))\nimport collections\nfrom collections import defaultdict,Counter\nfrom statistics import median\n# input=stdin.readline\n# print=stdout.write\nfrom queue import Queue\ninf = float("inf")\nfrom operator import neg;\nn,m=map(int,input().split())\nfor i in range(m):\n    k=int(input())\n    print(max(0,min(k-n-1,3*n+1-k)))\n
from sys import setrecursionlimit\r\nsetrecursionlimit(10 * 9)\r\n\r\ndef solve(i):\r\n    if i + k >= n:\r\n        return 1\r\n\r\n    if i in dp:\r\n        return dp[i]\r\n\r\n    mini = float('inf')\r\n    for j in range(i+1, min(n, i+k+1)):\r\n        if i == -1 or a[i] == a[j]:\r\n            mini = min(mini, solve(j) + 1)\r\n\r\n    dp[i] = mini\r\n    return dp[i]\r\n\r\n\r\nfor _ in range(int(input())):\r\n    n, k = map(int, input().split())\r\n    a = list(map(lambda x: int(x) % 2, input().split()))\r\n\r\n    le = lo = -1\r\n    se = so = -1\r\n\r\n    for i in range(n-k, n):\r\n        if a[i] == 0:\r\n            le = i\r\n            break\r\n\r\n    for i in range(n-k, n):\r\n        if a[i] == 1:\r\n            lo = i\r\n            break\r\n\r\n    m1 = float('inf')\r\n    if le != -1:\r\n        m1 = 0\r\n        while True:\r\n            lle = -1\r\n\r\n            for i in range(se + 1, se + k + 1):\r\n                if i == le:\r\n                    m1 += 2\r\n                    break\r\n\r\n                if a[i] == 0:\r\n                    lle = i\r\n\r\n            else:\r\n                if lle == -1:\r\n                    m1 = float('inf')\r\n                    break\r\n\r\n                se = lle\r\n                m1 += 1\r\n                continue\r\n\r\n            break\r\n\r\n    m2 = float('inf')\r\n    if lo != -1:\r\n        m2 = 0\r\n        while True:\r\n            llo = -1\r\n\r\n            for i in range(so + 1, so + k + 1):\r\n                if i == lo:\r\n                    m2 += 2\r\n                    break\r\n\r\n                if a[i] == 1:\r\n                    llo = i\r\n\r\n            else:\r\n                if llo == -1:\r\n                    m2 = float('inf')\r\n                    break\r\n\r\n                so = llo\r\n                m2 += 1\r\n                continue\r\n\r\n            break\r\n\r\n    if min(m1, m2) != float('inf'):\r\n        print(min(m1, m2))\r\n    else:\r\n        print(-1)
# cook your dish here\nfrom math import floor, sqrt\ntry:long\nexcept NameError:long = int \ndef fac(n):\n    step,maxq,d = lambda x: 1 + (x<<2) - ((x>>1)<<1),long(floor(sqrt(n))),1\n    q = n % 2 == 0 and 2 or 3 \n    while q <= maxq and n % q != 0:\n     q = step(d)\n     d += 1\n    return q <= maxq and [q] + fac(n//q) or [n]\nn,k,s = map(int,input().split())\na,di,l,m,ans,su =list(map(int,input().split())),{},[],0,0,0\nfor i in a:\n    bb,su = list(set(fac(i))),su+i\n    for j in bb:\n     try:di[j]+=1\n     except KeyError:m,di[j] = m+1,1\n    l.append(su*(k-m*s))\n    if su*(k-m*s) <0:m,di,su = 0,{},0\nprint(max(l))
import random\nt=int(input())\nfor testCase in range(t):\n	n=int(input())\n	array1=[]\n	array2=[]\n	array=[]\n	for i in range(n) :\n		array1.append(list(map(int,input().split())))\n	for i in range(n) :\n		array2.append(list(map(int,input().split())))\n	for i in range(n) :\n		array.append(i)\n#	print array2,"     ",array1\n	for i in range(n) :\n		print(array[i]+1, end=' ') \n	print() \n	k=0\n	max=0\n	answer=[]\n	temp=[]\n	while k < (1<<5) :\n		k+=1	\n		for i in range(n) :\n			rand=random.randint(0,len(array)-1)\n			temp.append(array[rand])\n			array.pop(rand)\n		array = temp\n		count=0\n		for i in range(n) :\n			for j in range(n) :\n				if(array1[i][j] and array2[array[i]][array[j]]) :\n					count+=1\n		if(count > max):\n			answer=array\n			max=count\n			#print max,count\n	for x in answer :\n		print(x+1, end=' ')\n	print()
n=int(input())\r\nar=list(map(int,input().split()))\r\ndp=[0]*n \r\ndp[0]=ar[0]\r\ndp[1]=ar[1]\r\nfor i in range(2,n):\r\n    dp[i]=min(dp[i-2],dp[i-1])+ar[i]\r\n    \r\nar.reverse()\r\n#print(ar)\r\ndp1=[0]*n \r\ndp1[0]=ar[0]\r\ndp1[1]=ar[1]\r\nfor i in range(2,n):\r\n    dp1[i]=min(dp1[i-2],dp1[i-1])+ar[i]\r\nprint(min(dp[-1],dp1[-1]))
for tc in range(int(input())):\n N = int(input())\n a, b = list(map(int, input().split()))\n pr = []\n\n # 'L' is lexicographically lower than 'R'.\n # so, we should first try to apply L+ or L-\n # if we can't then only we'll try to apply R+ or R-\n\n for i in range(N - 1):\n  l, r = list(map(int, input().split()))\n\n  #continue the following process until a == l and b == r\n  while a != l or b != r:\n   # trying to apply L-\n   if a > l:\n    a -= 1\n    pr.append('L-')\n\n   # now, trying to apply L+ (if a < b)\n   elif a + 1 < b and a < l:\n    a += 1\n    pr.append('L+')\n\n   # ok, so far, so good... now, let's try to apply R+\n   elif b < r:\n    b += 1\n    pr.append('R+')\n\n   # finally, lastly, trying to apply R- (if a < b)\n   elif b - 1 > a and b > r:\n    b -= 1\n    pr.append('R-')\n\n print(len(pr))\n print(''.join(pr))
# cook your dish here\n# cook your dish here\nMOD = 10 ** 9 + 7\n \nfor t in range(int(input())):\n    N, M, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    I, D = [0] * (N + 2), [0] * (N + 2)\n    for i in range(M):\n        x, L, R = input().split()\n        L, R = int(L), int(R)\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    \n    impossibru = mx = mn = 0\n    ans = 1\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and not D[i]:\n            ans = ans * (mx - mn + 1) % MOD\n            mn, mx = 1, K\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % MOD\n    \n    print(0 if impossibru else ans) 
# cook your dish here\nfrom math import pow\nt = int(input())\nfor _ in range(t):\n    m,n = map(int,input().rstrip().split())\n    cnt = len(str(n))\n    x = pow(10,cnt)\n    if n == x-1:\n        print(m*cnt,m)\n    else:\n        print(m*(cnt-1),m)
from math import ceil\n\nfor _ in range(int(input())):\n n = int(input())\n arr = [int(x) for x in input().split()]\n sarr = sum(arr)\n mavg = sarr/n\n while n>1:\n  sarr -= arr.pop()\n  n-=1\n  mavg = max(mavg, sarr/n)\n print(int(ceil(mavg)))
import math\r\nt=int(input())\r\nfor i in range(t):\r\n    k=int(input())\r\n    res=((pow(2,k,1000000007))*5)%1000000007\r\n    print(res)
# Md. Khairullah Gaurab\n# SUST, CSE, 20th Batch\n#  gaurab.cse.sust@gmail.com\n\n\ntest = int(input());\n\nfor i in range(test):\n    N, S, K = list(map(int,input().split()));\n    lis = list(map(int,input().split()));\n    ans = [i+1 for i in range(N)] ;\n    ans.sort(reverse=True);\n    for j in range(N):\n        print(ans[j],end=' ');\n    print('')\n
for u in range(int(input())):\n p=input().split()\n n=int(p[0])\n s=p[1]\n x,y=0,0\n for i in range(n):\n  l=input()\n  if(l[0]=='1'):\n   y+=l.count('1')\n  else:\n   x+=l.count('0')\n if(x<y):\n  print("Dum")\n elif(y<x):\n  print("Dee")\n else:\n  if(s=='Dee'):\n   print("Dum")\n  else:\n   print("Dee")\n
# cook your dish here\ntry:\n    t = int(input())\n    for _ in range(t):\n        p = [int(x) for x in input().split()]\n        q = [int(x) for x in input().split()]\n        \n        q[1] *= -1\n        m = (q[1]-p[1])/(q[0]-p[0])\n        c = p[1] - m*p[0]\n        \n        print("{:.2f}".format(-c/m))\nexcept:\n    pass
# cook your dish here\nimport bisect\nfor _ in range(int(input())):\n \n n,x=list(map(int,input().split()))\n \n l=list(map(int,input().split()))\n battery=[]\n \n power=0\n i=0\n t=(n+1)//2\n while power<x and i<t:\n  \n  if i==n-i-1:\n   temp=[-1,l[i]]\n  else:\n   temp=sorted([ l[i], l[n-i-1] ])\n  \n  power+=temp[1]\n  pos=bisect.bisect_right(battery, temp[1], lo=0, hi=len(battery))\n  battery.insert(pos,temp[1])\n  \n  if temp[0]>battery[0]:\n   \n   power-=battery.pop(0)\n   power+=temp[0]\n   pos=bisect.bisect_right(battery, temp[0], lo=0, hi=len(battery))\n   battery.insert(pos,temp[0])\n  \n  i+=1\n  \n  \n if power>=x:\n  print('YES')\n else:\n  print('NO')\n
n=int(input())\narr=[]\nfor i in range(1,n+1):\n arr.append(i)\nc=0\ni=0\nf=0;\nwhile(c<n-1):\n if(arr[i%n]!=-1 and f):\n  arr[i%n]=-1\n  c=c+1\n  f=0\n if(arr[i%n]!=-1):\n  f=1\n i=i+1\n\nfor i in range(0,n):\n if(arr[i]!=-1):\n  ans=arr[i]\n  break;\nprint(ans) \n
# cook your dish here\n# Author: Dancing Monkey | Created: 09.DEC.2018\n\n\nimport bisect\nfor _ in range(int(input())):\n n = int(input())\n x1 , x2, x3 = [], [], []\n for i in range(n):\n  x, y = list(map(int, input().split()))\n\n  if x == 1: x1.append(y)\n  if x == 2: x2.append(y)\n  if x == 3: x3.append(y)\n\n x1.sort()\n x2.sort()\n x3.sort()\n\n y1, y2, y3 = len(x1), len(x2), len(x3)\n area = 0\n for i in range(y1):\n  for j in range(i+1, y1):\n   area += abs(x1[i] - x1[j])*(y2 + (2*y3))\n\n for i in range(y3):\n  for j in range(i+1, y3):\n   area += abs(x3[i] - x3[j])*(y2 + (2*y1))\n\n for i in range(y2):\n  for j in range(i+1, y2):\n   area += abs(x2[i] - x2[j])*(y1 + y3)\n\n area /= 2\n\n s1 = [0]\n for i in range(y2): s1.append(s1[-1] + x2[i])\n # print(s1)\n s2 = [0]\n for i in range(y2):s2.append(s2[-1] + x2[y2 - 1 - i])\n # print(s2)\n\n for i in x1:\n  for j in x3:\n   p1 = (i + j) / 2\n   p = bisect.bisect_left(x2, p1)\n   # print('p', p)\n   l = p\n   h = y2 - l\n   # print(l, h)\n\n   area += p1*(l) - s1[l]\n   # print('dfg', area)\n   area += s2[h] - p1*(h)\n\n print(format(area, 'f'))\n # print()\n
# cook your dish here\nt=int(input())\nfor i in range(t):\n n=int(input())\n s=input().strip()\n c=0\n for i in range(len(s)):\n  if s[i]=='.':\n   continue\n  if s[i]=='H':\n   c+=1\n  if s[i]=='T':\n   c-=1\n  if c>1:\n   break\n  if c<0:\n   break\n if c==0:\n  print('Valid')\n else:\n  print('Invalid')
t = eval(input())\n\ndef moneda(m):\n h = 1\n triange = []\n while m >= h:\n  triange.append(h)\n  m -= h \n  h += 1\n return len(triange)\n\ntriangulo = []\nfor i in range(t):\n n = eval(input())\n triangulo.append(n)\n\nfor i in triangulo:\n print(moneda(i))\n
for u in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    d=list(map(int,input().split()))\n    ka=[]\n    k=[]\n    l.sort()\n    d.sort()\n    for i in range(n):\n        ka.append(d[i])\n        ka.append(l[i])\n    for i in range(n):\n        k.append(l[i])\n        k.append(d[i])\n    if(ka==sorted(ka)):\n        print("YES")\n    elif(k==sorted(k)):\n        print("YES")\n    else:\n        print("NO")\n
t =int(input())\r\nfor i in range(t):\r\n    C=[ord(x)-ord('R') for x in list(input())]\r\n    N=int(input())\r\n    L=sum(C)\r\n    r=1\r\n    c=0\r\n    while(r*L<N*12):\r\n        c+=N*12-r*L\r\n        r+=1\r\n    print(c)\r\n\r\n\r\n\r\n\r\n\r\n\r\n
def find_upper_bound(arr,key):\n low,high = 0,len(arr)-1\n while low<=high:\n  mid = (low+high)//2 \n  if arr[mid]==key:return mid\n  elif arr[mid]>key and mid-1>=0 and arr[mid-1]<key:return mid \n  elif arr[mid]>key:high = mid - 1 \n  else:low = mid + 1 \n return mid \ndef get_query(l):\n nonlocal prefix_storer,bin_storer\n ind = find_upper_bound(bin_storer,l)\n surplus = (abs(bin_storer[ind]-l)*ind*ind)%limit \n return (prefix_storer[ind]-surplus+limit)%limit\ndef fire_query(l,r):\n return (get_query(r)-get_query(l-1)+limit)%limit\ngolomb,dp,prefix_storer,bin_storer = [],[0,1],[0,1],[0,1]\nlimit = 10**9+7\nfor i in range(2,10**6+100):\n dp.append(1 + dp[i-dp[dp[i-1]]])\n bin_storer.append(dp[-1]+bin_storer[-1])\n prefix_storer.append(((prefix_storer[-1] + (dp[-1]*i*i)%limit))%limit)\n# print(dp[1:20])\n# print(bin_storer[1:20])\n# print(prefix_storer[1:20])\n# print(get_query(2),get_query(4))\nfor _ in range(int(input())):\n l,r = map(int,input().split())\n print(fire_query(l,r))
#dt = {} for i in x: dt[i] = dt.get(i,0)+1\r\nimport sys;input = sys.stdin.readline\r\ninp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]\r\n\r\ndef check(mid):\r\n    pos = x[0]\r\n    ct = 1\r\n    for i in range(1,n):\r\n        if x[i]-pos >= mid:\r\n            pos = x[i]\r\n            ct += 1\r\n            if ct == k:\r\n                return True\r\n    return False\r\n\r\nfor _ in range(inp()):\r\n    n,k = ip()\r\n    x = ip()\r\n    x.sort()\r\n    ans = -1\r\n    l,r = 1,x[-1]\r\n    while l < r:\r\n        mid = (l+r)//2\r\n        if check(mid):\r\n            ans = max(ans,mid)\r\n            l = mid +1\r\n        else:\r\n            r = mid\r\n    print(ans)\r\n        \r\n        \r\n        \r\n        \r\n
n,m,k=map(int, input().split())\na = []\ncheck = [0]*m\nwhile k!= 0:\n x1,y1,x2,y2 =map(int,input().split())\n a.append([x1,y1,x2,y2])\n check[y1-1] += 1\n check[y2-1] += 1\n k-= 1\nmaxi = check.index(max(check))+1\nsum = 0\nk = 0\nfor i in range(len(a)):\n x1,y1,x2,y2 = a[i]\n if (y1 > maxi and y2 > maxi) or (y1<maxi and y2 < maxi):\n  sum+= abs(y2-y1)*2\n  sum += abs(x2-x1)*2\n else:\n  if y1 != maxi:\n   k = abs(y1-maxi)\n   sum+= k*2\n  if x1 != x2:\n   k = abs(x2-x1)\n   sum += k\n  if y2 != maxi:\n   k = abs(y2-maxi)\n   sum+= k*2\nprint(sum)
try:\r\n    t = int(input())\r\n    while(t > 0):\r\n        t -= 1\r\n        n,m = list(map(int,input().split()))\r\n        a = [list(map(int,input().split())) for _ in range(n)]\r\n        dp = [[0 for _ in range(m)] for _ in range(n)]\r\n        ans = [['0' for _ in range(m)] for _ in range(n)]\r\n        for i in range(n):\r\n            for j in range(m):\r\n                if i-1 < n:\r\n                    if 0 <= j-1 and j+1 < m:\r\n                        dp[i][j] = max(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])\r\n                    elif j == 0:\r\n                        dp[i][j] = max(dp[i-1][j],dp[i-1][j+1])\r\n                    elif j == m-1:\r\n                        dp[i][j] = max(dp[i-1][j-1],dp[i-1][j])\r\n    \r\n                if dp[i][j] > a[i][j]:\r\n                    ans[i][j] = '0'\r\n                else:\r\n                    ans[i][j] = '1'\r\n                    dp[i][j] = a[i][j]\r\n    \r\n        for i in ans:\r\n            print(''.join(i))\r\nexcept:\r\n    pass
# cook your dish here\ntest = int(input())\n\nfor _ in range(0,test):\n n = int(input())\n lister = set(map(int,input().split()))\n print(len(lister))
# cook your dish here\nimport math\nT=int(input())\nfor i in range(T):\n    a=list(map(int,input().split()))\n    n=a[0]\n    m=a[1]\n    print(m*n//math.gcd(m,n))
for _ in range(int(input())):\n n,k=list(map(int, input().split()))\n l=list(map(int, input().split()))\n l.sort()\n \n c=0\n mn=abs(l[0]+l[1]-k)\n for i in range(n-1):\n  for j in range(i+1, n):\n   temp=abs(l[i]+l[j]-k)\n   if temp==mn:\n    c+=1 \n    \n   elif temp<mn:\n    mn=temp\n    c=1 \n    \n   elif l[i]+l[j]-k>mn:\n    break\n \n print(mn, c)
# cook your dish here\nmod=8589934592\nlist1=[]\nfor i in range(int(input())):\n    x=int(input())\n    ans=(pow(2,x,mod)-1)%mod\n    list1.append((i+1,ans))\nfor i in list1:\n    print(f'Case {i[0]}: {i[1]}')
'''Author- Akshit Monga'''\nfrom sys import stdin, stdout\ninput = stdin.readline\nt=int(input())\nfor _ in range(t):\n n=int(input())\n a=[int(x) for x in input().split()]\n ans=0\n dp=[-1 for i in range(0,n+1)]\n for i in a:\n  var1=dp[i]\n  var2=ans\n  ans=max(ans,var1+1)\n  dp[i]=max(dp[i],var2+1)\n print(n-ans)
from collections import Counter \nfor _ in range(int(input())):\n s = input()\n c = Counter(list(s))\n if len(c) == 1:\n  print(0)\n else:\n  m = min(c['b'], c['g'])\n  ma = max(c['b'], c['g'])\n  l = (ma - m + 1) // 2\n  r = (ma - m + 1) // 2 + (ma - m + 1) % 2\n  res = (l * (l + 1)) // 2\n  re = res\n  for i in range(1, m):\n   res += 2 * l + 1\n   re += res\n   l += 1\n  res2 = (r * (r + 1)) // 2\n  re += res2\n  for i in range(1, m):\n   res2 += 2 * r + 1\n   re += res2\n   r += 1\n  print(re)
def f(a,n):\n    l,r,s1,s2 = [0]*n, [0]*n, [], []\n \n    for i in range(n):\n     count = 1\n     while(len(s1)>0 and a[i]<s1[-1][0]):\n      count += s1[-1][1]\n      s1.pop()\n     s1.append((a[i],count))\n     l[i] = count\n \n    for i in range(n-1,-1,-1):\n     count = 1\n     while(len(s2)>0 and a[i]<=s2[-1][0]):\n      count += s2[-1][1]\n      s2.pop()\n     s2.append((a[i],count))\n     r[i] = count\n \n    count = 0\n    for i in range(n):\n     count += a[i]*l[i]*r[i]\n \n    return count\n\nt = int(input())
t = int(input())\nfor i in range(t):\n    n, m = map(int, input().split())\n    arr1 = list(map(int, input().split()))\n    arr2 = list(map(int, input().split()))\n    hmap = {}\n    for i in range(n):\n        if arr1[i] in hmap:\n            hmap[arr1[i]] += 1\n        else:\n            hmap[arr1[i]] = 1\n    \n    for i in range(m):\n        if arr2[i] in hmap:\n            hmap[arr2[i]] += 1\n        else:\n            hmap[arr2[i]] = 1\n    ans = []\n    #print(hmap)\n    for key in hmap:\n        if hmap[key]==1:\n            ans.append(key)\n    ans.sort()\n    for x in ans:\n        print(x,end=' ')\n    print()\n            \n        
t=int(input())\nwhile(t):\n k=1\n j=0\n n=int(input())\n while(n>0):\n  if(n<=k):\n   j+=1\n   n=0\n  elif n>2*k:\n   j+=2\n   n=n-2*k\n   k+=1\n  else:\n   j+=2\n   n=0\n print(j)\n t-=1
# cook your dish here\n# cook your dish here\n\nimport math\ndef distinctPrimeFactors(num) :\n    primes,sqrt = set(),int(math.sqrt(num))\n    if (num == 2) :primes.add(num)\n    for j in range(2, sqrt + 1) :\n        if (num % j == 0) :\n            primes.add(j)\n            while (num % j == 0) :num //= j\n    if (num > 2) :primes.add(num)\n    return (primes)\nres,c,lst,primes,rangeData = [],0,{},{},{};k, q = map(int, input().split());primes[k] = distinctPrimeFactors(k)\nfor tc in range(q) :\n    query = input()\n    if (query[0] == '!') :\n        cmd, l, r, x = query.split();l,r,x = int(l),int(r),int(x);start,end,startflag = l,r,False\n        for i in sorted(rangeData) :\n            rangeVal = i\n            if (start > rangeVal[1]) :continue\n            if (end < rangeVal[0]) :break            \n            startRange,endRange = start,end\n            if (start >= rangeVal[0] and start <= rangeVal[1]) :start = rangeVal[1] + 1;continue\n            if (end >= rangeVal[0]) :endRange = rangeVal[0] - 1\n            if (startRange <= endRange) :\n                rangeData[(startRange, endRange)] = x;start = max(endRange + 1, rangeVal[1] + 1)\n        if (start <= end) :rangeData[(start,end)] = x\n    elif (query[0] == '?') :\n        cmd, l, r = query.split();l,r,count = int(l),int(r),0\n        for primenum in primes[k] :\n            for currRange in rangeData :\n                if (not (r < currRange[0] or l > currRange[1])) :\n                    if (rangeData[currRange] % primenum == 0) :count += 1;break\n        c += 1;res.append(count)    \nfor i in range(c):print(res[i])\n
import math\ndef comb(n,r):\n f = math.factorial\n return f(n) / f(r) / f(n-r)\nt=int(input())\nfor i in range(1,t+1):\n n=int(input())\n arr = list(map(int, input().split()))\n m=0\n ans=0.0\n for i in range(0,n):\n  if (arr[i]==-1):\n   m=m+1\n for i in range(0,m):\n  ans=ans+((m-i)*comb(m-1,m-1-i))\n ans=ans/pow(2,m-1)\n print('{0:.7f}'.format(ans))
# cook your dish here\nfor u in range(int(input())):\n    n,r=list(map(int,input().split()))\n    l=list(map(int,input().split()))\n    m=0\n    for i in range(n-1):\n        d=[]\n        d.append(l[i])\n        c=1\n        while(i+c<n):\n            d.append(l[i+c])\n            d.sort(reverse=True)\n            if(d[0]+d[1]<=r):\n                c=c+1\n            else:\n                break\n        if(c>m):\n            m=c\n    print(m)\n\n\n
n, m = map(int, input().split())\nl = n\nf = 1\ns = ((n)*(n+1))//2 - l - f\nfor _ in range(m):\n k = int(input())\n if 2 <= k <= n-1 or k in [f, l]:\n  l, f = f, l\n else:\n  l = k\n print(s+l+f)
import math\r\ndef CountSquares(a, b):\r\n    return (math.floor(math.sqrt(b)) - math.ceil(math.sqrt(a)) + 1)\r\nfor _ in range(int(input())):\r\n    n=int(input())\r\n    val=CountSquares(1,n)\r\n    ans=val-val//3\r\n    print(ans)
# cook your dish here\nimport numpy as np\ntests = int(input())\nfor _ in range(tests):\n   n = int(input())\n   weights = [int(j) for j in input().split()]\n   edges = [[0] for _ in range(n-1)]\n   for i in range(n-1):\n      edges[i] = [int(j)-1 for j in input().split()]\n   vertex_set = [[] for _ in range(n)]\n   for i in range(n-1):\n      vertex_set[edges[i][0]].append(edges[i][1])\n      vertex_set[edges[i][1]].append(edges[i][0])\n   counts = [0 for _ in range(3)]\n   for i in range(n):\n      counts[weights[i]] += 1\n   if counts[1] == 0:\n      print(2 * (counts[0] != 0 and counts[2] != 0))\n   elif counts[1] == n:\n      print(0)\n   else:\n      visited = [0]\n      for i in range(n):\n         vertex = visited[i]\n         for v in vertex_set[vertex]:\n            if v not in visited:\n               visited.append(v)\n      vertex_nums = [[0] for _ in range(n)]\n      for i in range(n-1,-1,-1):\n         vertex = visited[i]\n         for v in vertex_set[vertex]:\n            if v in visited[i:]:\n               vertex_nums[vertex].append(sum(vertex_nums[v])+1)\n      for i in range(n):\n         vertex_nums[i].append(n-1-sum(vertex_nums[i]))\n      sums = np.zeros(n,dtype=bool)\n      sums[0] = True\n      for i in range(n):\n         new_sums = np.zeros(n,dtype=bool)\n         new_sums[0] = True\n         for num in vertex_nums[i]:\n            new_sums[num:n] = np.logical_or(new_sums[num:n],new_sums[:n-num])\n         sums = np.logical_or(sums,new_sums)\n      solved = False\n      for i in range(n):\n         if sums[i] and counts[0] <= i and counts[2] <= n - 1 - i:\n            solved = True\n            break\n      if solved or counts[1] > 1:\n         print(1)\n      else:\n         print(2)
for i in range(int(input())):\n t=int(input())\n n=0\n for i in range(1,t+1):\n  n=n+i\n  x=[n]\n  y=n\n  for j in range(i,t+i-1):\n   if j<t:\n    z=y+j\n   else:\n    z=y+(2*t-j-1)\n   x.append(z)\n   y=z\n  print(*x)
# cook your dish here\nfor test in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    \n    count = 0\n    for item in ar:\n        if bin(item)[-1] == '0':\n            count += item\n    \n    print(count)
from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\ndef solve(i, j, c=0):\n if i > j:\n  return 0\n\n if (i, j) in dp:\n  return dp[i, j]\n\n x0 = solve(i+1, j, c^1)\n x1 = solve(i, j-1, c^1)\n\n if c == 0:\n  y = 1 << (j - i)\n  x0 += a[i] * y\n  x1 += a[j] * y\n\n dp[i, j] = x0 + x1\n return dp[i, j]\n\nfor _ in range(int(input())):\n n = int(input())\n a = list(map(int, input().split()))\n dp = {}\n\n total = solve(0, n-1)\n print(total / (1 << n))\n
#!/usr/bin/env python2\n \ndef gc(c):\n  return 'a' <= c <= 'h'\ndef gd(c):\n  return '1' <= c <= '8'\n \nt = int(input())\nfor i in range(t):\n  line = input()\n  if len(line) != 5:\n    print("Error")\n    continue\n  if line[2] != '-':\n    print("Error")\n    continue\n  x1 = line[0]\n  y1 = line[1]\n  x2 = line[3]\n  y2 = line[4]\n  if gc(x1) and gd(y1) and gc(x2) and gd(y2):\n    d1 = abs(ord(x1) - ord(x2))\n    d2 = abs(ord(y1) - ord(y2))\n    if d1 > d2: d1,d2 = d2, d1\n    if (d1 == 1) and (d2 == 2):\n      print("Yes")\n    else:\n      print("No")\n  else:\n    print("Error")
T=int(input()) # cook your dish here\nfor i in range(T): \n    n=list(map(int,input().split()))\n    a=n[0]\n    b=n[1]\n    c=n[2]\n    l=[]\n    A=list(map(int,input().split()))\n    B=list(map(int,input().split()))\n    C=list(map(int,input().split()))\n    for i in range(b):\n        for j in range(a):\n            for k in range(c):\n                if(A[j]<=B[i] and B[i]>=C[k]):\n                    sum=((A[j]+B[i])*(B[i]+C[k]))\n                    l.append(int(sum))\n                \n                \n            \n    \n    sum=0\n    for i in range(len(l)):\n        sum+=int(l[i])\n    print(sum%1000000007)
# cook your dish here\nt=int(input())\nfor i in range(t):\n x=int(input())\n if x%10==0:\n  print(0)\n elif x%5==0:\n  print(1)\n else:\n  print(-1)
for _ in range(int(input())):\n n=int(input())\n a=[]\n l=0\n for i in range(n):\n  a.append(list(map(int,input().split())))\n for i in range(n-1,0,-1):\n  r=a[i][i-1]+1\n  if a[i][i]!=r:\n   l+=1\n   n=i+1\n   for j in range(n):\n    for k in range(j,n):\n     a[j][k],a[k][j]=a[k][j],a[j][k]\n    \n print(l)\n
# cook your dish here\nt=int(input())\nfor _ in range(t):\n s=input()\n k=len(s)\n count=0\n for i in range(k-1):\n  if(s[i]=="C"):\n   if(s[i+1]=='E'or s[i+1]=='S' or s[i+1]=="C"):\n    count+=1 \n  elif(s[i]=="E"):\n   if(s[i+1]=="S"or s[i+1]=='E'):\n    count+=1 \n  elif(s[i]=="S"):\n   if(s[i+1]=="S"):\n    count+=1 \n if (count==k-1):\n  print("yes")\n else:\n  print("no")
t=int(input())\nfor q in range(t):\n n=int(input())\n x=list(map(int,input().split()))\n dic={}\n dic2={}\n for i in range(n):\n  dic2[x[i]]=1\n #print dic2\n if len(dic2)==n:\n  n+=2\n  print((n*(n-1)*(n-2)*(n-3))/24)\n  continue \n counter=0\n for i in range(n-1):\n  if x[i] in dic:\n   dic[x[i]]+=1\n  else:\n   dic[x[i]]=1\n  for j in range(i,n-1):\n   if x[j] in dic:\n    dic[x[j]]+=1\n   else:\n    dic[x[j]]=1\n   for p in range(j+1,n):\n    if x[p] in dic:\n     continue;\n    for q in range(p,n):\n     if x[q] in dic:\n      break\n     counter+=1\n     #print i,j,p,q\n     \n  dic.clear()\n print(counter)
lucky = {4, 774, 7, 744, 777, 74, 747, 44, 77, 47, 474, 444, 477, 447}\nfrom functools import lru_cache\nimport sys \nsys.setrecursionlimit(10 ** 6)\nmod = 10 ** 9 + 7\nfact = [1]\nfor i in range(1, 1001):\n    fact.append(fact[-1] * i % mod)\ninv = [pow(i, mod-2, mod) for i in fact]\nC = lambda k, n: fact[n] * inv[n-k] * inv[k] % mod\ndef f(n):\n    n = [int(x) for x in n]\n    @lru_cache(None)\n    def dp(pos, cnt, free):\n        if cnt > 777:\n            return 0\n        diff = len(n) - pos \n        ans = 0\n        if free:\n            for i in lucky:\n                i -= cnt\n                if 0 <= i <= diff:\n                    ans += C(i, diff) * pow(2, i, mod) * pow(8, diff - i, mod)\n                    ans %= mod \n            return ans\n        if pos == len(n):\n            return int(cnt in lucky)\n        for i in range(10 if free else n[pos]+1):\n            ans += dp(pos+1, cnt + int(i == 4 or i == 7), free or i < n[pos])\n            ans %= mod \n        return ans \n    return dp(0, 0, 0)\n    \nt = int(input())\nfor _ in range(t):\n    l, r = input().split()\n    l = str(int(l) -1) \n    print((f(r) - f(l)) % mod)
T=int(input())\r\nl=[]\r\nfor t in range(T):\r\n    R=int(input())\r\n    a=2*(R**2)\r\n    l.append(a)\r\nfor s in l:\r\n    print(s)
try:\n t=int(input())\n while t>0:\n  [a,b]=[int(x) for x in input().split()]\n  if a==1 and b==1:\n   print(1)\n   continue\n  if a%2==0:\n   o1=a//2\n   e1=a//2\n  else:\n   o1=a//2+1\n   e1=a//2\n  \n  if b%2==0:\n   o2=b//2\n   e2=b//2\n  else:\n   o2=b//2+1\n   e2=b//2\n   \n  print(e1*e2+o1*o2)\n  t-=1\nexcept:\n pass
# cook your dish here\n# from queue import PriorityQueue\n# import bisect\ndef insort(l, v):\n    s = 0\n    e = len(l)\n    while True:\n        mid = (s+e)//2\n        if s == e or mid > len(l):\n            break\n        if l[mid][0] < v[0]:\n            s = mid+1\n        elif l[mid][0] > v[0]:\n            e = mid\n        else:\n            break\n    l.insert(mid, v)\n    \nfor _ in range(int(input())):\n    n,l = map(int, input().split())\n    a_l = list(map(int, input().split()))\n    \n    dic = {}\n    dif = 0\n    for i,v in enumerate(a_l, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1]-dic[v][0])\n            \n    ans = dif\n    if l <= len(set(a_l)):\n        i_l = [[v,i] for i,v in enumerate(a_l, start=1)]\n        i_l.sort(reverse=True)\n        \n        dp = [[-1 for _ in range(l)] for _ in range(n)]\n        pq_l = [[] for _ in range(l)]\n        for i in range(1,n):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1]-i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n                \n            for il in range(2,min(l,i+1)):\n                for prev_max, ind in reversed(pq_l[il-1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n                # tmp = [v[0] for v in pq_l[il]]\n                # ind = bisect.bisect_right(tmp, dp[i][il])\n                # pq_l[il].insert(ind, [dp[i][il], i])\n                \n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            # tmp = [v[0] for v in pq_l[il]]\n            # ind = bisect.bisect_right(tmp, dp[i][il])\n            # pq_l[il].insert(ind, [dp[i][il], i])\n            \n            # print(i, pq_l, dif_l)\n                        \n                \n                # dp[i][1] = max(dp[i][1], dif)\n                # for il in range(2,l):\n                #     if dp[j][il-1] == -1:\n                #         break\n                #     dp[i][il] = max(dp[i][il], min(dif, dp[j][il-1]))\n            ans = max(ans, dp[i][-1])\n    #     print(dp)\n    # print(dic)\n    print(ans)
# cook your dish here\nt=int(input())\nfor i in range(t):\n    v,w=list(map(int,input().strip().split(" ")))\n    if v==w:\n        print(v+1)\n    elif v<w:\n        print(v+1)\n    else:\n        print(w+1)\n        #s="a"\n        #s=s*v\n        #l=list(s)\n        #print(l)\n        ct=0\n        #for i in range(w):\n
# cook your dish here\nfrom sys import stdin, stdout\nfrom collections import defaultdict\nfor _ in range(int(stdin.readline())):\n    n=int(stdin.readline())\n    lst=list(map(int, stdin.readline().split()))\n    prefix_odd=[0]*n\n    prefix_even=[0]*n\n    odd_val=0\n    even_val=0\n    for i in range(n):\n        if lst[i]%2==0:\n            even_val+=1 \n        else:\n            odd_val+=1\n        prefix_even[i]=even_val\n        prefix_odd[i]=odd_val\n    #print(prefix_odd,prefix_even)\n    prefix_sum=[0]*n\n    s=0\n    for i in range(n):\n        s+=lst[i]\n        prefix_sum[i]=s\n    #print(prefix_sum)\n    dict={}\n    count={}\n    for i in range(n):\n        if lst[i] not in dict:\n            dict[lst[i]]=i\n            count[lst[i]]=1\n        else:\n            dict[lst[i]]=i\n            count[lst[i]]+=1\n    #print(dict)\n    graph=defaultdict(list)\n    for i in range(n):\n        graph[lst[i]].append(i)\n    max_sum=0\n    for i in graph:\n        if len(graph[i])>1:\n            prev=graph[i][0]\n            for j in range(1,len(graph[i])):\n                index2=graph[i][j]\n                index1=prev\n                prev=index2\n                #print(index1,index2)\n                if i%2==0:\n                    val=prefix_even[index2]-prefix_even[index1]-1\n                    #print(val)\n                    if val%2==0:\n                        temp_sum=prefix_sum[index2]-prefix_sum[index1]-i\n                        #print(temp_sum)\n                        if temp_sum>max_sum:\n                            max_sum=temp_sum\n                else:\n                    val=prefix_odd[index2]-prefix_odd[index1]-1\n                    #print(val)\n                    if val%2!=0:\n                        temp_sum=prefix_sum[index2]-prefix_sum[index1]-i\n                        #print(temp_sum)\n                        if temp_sum>max_sum:\n                            max_sum=temp_sum\n\n    '''max_sum=-1\n                for i in range(n):\n                    if count[lst[i]]>1:\n                        index2=dict[lst[i]]\n                        index1=i\n                        print(index1,index2)\n                        if lst[i]%2==0:\n                            val=prefix_even[index2]-prefix_even[index1]-1\n                            print(val)\n                            if val%2==0:\n                                temp_sum=prefix_sum[index2]-prefix_sum[index1]-lst[i]\n                                print(temp_sum)\n                                if temp_sum>max_sum:\n                                    max_sum=temp_sum\n                        else:\n                            val=prefix_odd[index2]-prefix_odd[index1]-1\n                            print(val)\n                            if val%2!=0:\n                                temp_sum=prefix_sum[index2]-prefix_sum[index1]-lst[i]\n                                print(temp_sum)\n                                if temp_sum>max_sum:\n                                    max_sum=temp_sum'''\n    \n    stdout.write(str(max_sum)+'\n')
for i in range(int(input())):\n    n=int(input())\n    print(n//2+1)
import sys\nimport math\n\ndef main(arr):\n \n k=len(arr[0])\n n=len(arr)\n dp=[[0]*k for i in range(n+1)]\n \n summation_arr=[]\n for i in range(len(arr)):\n  a=1 if i!=0 else 0\n  summation_arr.append(sum(arr[i])+a)\n \n for i in range(1,len(dp)):\n  for j in range(len(dp[0])):\n   dp[i][j]=(dp[i-1][j]+arr[i-1][j])/summation_arr[i-1]\n ans=[]\n \n for i in range(k):\n  ans.append(dp[-1][i])\n print(*ans)\n\n\n \nn,k=input().split()\nn=int(n)\narr=[]\nfor i in range(n):\n arr.append(list(map(int,input().split())))\n(main(arr))\n \n \n
def codn1(s1,s2,p):\r\n	c=0\r\n	ind=0\r\n	for i in range(len(s1)):\r\n		if s1[i]!=s2[i]:\r\n			c+=1\r\n			ind=i\r\n	if c>1 or ind==len(s1)-1:\r\n		return 0\r\n	if s1[ind]>s2[ind] and s1[ind] in s2[ind+1:]:\r\n		p[0]=True\r\n	if s1[ind]<s2[ind] and s2[ind] in s1[ind+1:]:\r\n		p[1]=True\r\n	return 1\r\n	\r\ndef codn2(s1,s2):\r\n	if len(s1)<len(s2):\r\n		for i in range(len(s2)):\r\n			if s2[:i]+s2[i+1:]==s1:\r\n				return 1\r\n	else:\r\n		for i in range(len(s1)):\r\n			if s1[:i]+s1[i+1:]==s2:\r\n				return 2\r\n\r\n\r\ndef longest(k):\r\n	if cost[k]>0:\r\n		return cost[k]\r\n	for i in list(d[k]):\r\n			cost[k]=max(cost[k],longest(i)+1)\r\n	return cost[k]\r\n\r\nn=int(input())\r\nl=[]\r\n#parent=[0]*n\r\nd={}\r\ncost={}\r\nfor i in range(n):\r\n	l.append(input())\r\n	d[i]=[]\r\n	cost[i]=0\r\n\r\nfor i in range(n):\r\n	for j in range(n):\r\n		if i!=j:\r\n			p=[False,False]\r\n			if len(l[i])==len(l[j]):\r\n				if codn1(l[i],l[j],p):\r\n					if p[0]==True:\r\n						d[j].append(i)\r\n					if p[1]==True:\r\n						d[i].append(j)\r\n			elif abs(len(l[i])-len(l[j]))==1:\r\n				y=codn2(l[i],l[j])\r\n				if y==1:\r\n					d[j].append(i)\r\n				if y==2:\r\n					d[i].append(j)\r\nans=0\r\n#print(d)\r\n\r\nfor i in range(n):\r\n	ans=max(ans,longest(i))\r\nprint(ans+1)\r\n
from math import sqrt\n\na, b = map(int, input().split())\npairs = 0\n\nfor i in range(1, a+1):\n for j in range(1, b+1):\n  root = sqrt(i**2 + j)\n\n  if not root - int(root):\n   pairs += 1\n\nprint(pairs)
def check(l,n):\n    m = 0\n    for i in range(n-1):\n        x = l[i]\n        c = 0\n        j = i\n        while (j+2<n and l[j+2]==x) or (j+1<n and l[j+1] == x):\n            if l[j+1] == x:\n                j = j+1\n            else:\n                j+=2\n            c+=1\n        if m<c:\n            m = c\n    return m\n\nt = int(input())\nfor _ in range(t):\n    no = int(input())\n    a = list(map(int,input().split()))\n    print(check(a,no))
N = int(input())\r\ni = N + 1\r\nflag = 0\r\nfor i in range(N+1, 987654321):\r\n    a = str(i)\r\n    b = list(a)\r\n    c = set(a)\r\n    if '0' not in b:\r\n        if len(b) == len(c):\r\n            print(i)\r\n            flag += 1\r\n            break\r\n    \r\nif flag < 1:\r\n    print(0)\r\n        \r\n            \r\n    \r\n
import math\r\nfrom itertools import permutations as p\r\ndef diff(li1, li2): \r\n    li_dif = [i for i in li1 if i not in li2]\r\n    return li_dif \r\ndef segments(b):\r\n        """A sequence of (x,y) numeric coordinates pairs """\r\n        poly = [(i[0],i[1]) for i in b]\r\n        return zip(poly, poly[1:] + [poly[0]])\r\ndef perimeter(poly):\r\n    """A sequence of (x,y) numeric coordinates pairs """\r\n    return abs(sum(math.hypot(x0-x1,y0-y1) for ((x0, y0), (x1, y1)) in segments(poly)))\r\ndef av(b):\r\n    return sum([i[3] for i in b])\r\ndef val(b):\r\n    return sum([i[2] for i in b])\r\nfor _ in range(int(input())):\r\n    b = []\r\n    for _ in range(int(input())):\r\n        b.append(list(map(int,input().split())))\r\n    perm = []\r\n    for i in range(1,len(b)):\r\n        for e in p(b,i):\r\n            perm.append(e)\r\n    perm.sort(key=lambda x:val(x))\r\n    yes = []\r\n    for i in perm:\r\n        if av(i)>=perimeter(diff(b,i)):\r\n            good = val(i)\r\n            yes.append(i)\r\n            break\r\n    #yes.sort(key = lambda x: len(x))\r\n    print(" ".join([str(b.index(i)+1) for i in yes[0]]))\r\n    x = round(av(yes[0])-perimeter(diff(b,yes[0])),2)\r\n    print(f'{x:.2f}')\r\n\r\n\r\n
# cook your dish here\r\nstr1=int(input())\r\nfor i in range(str1):\r\n    l1=[]\r\n    str2=input()\r\n    for i in str2:\r\n        l1.append(i)\r\n    \r\n    count=0\r\n    d=dict()\r\n    d={'a':1,'b':2,'c':3,'d':4,'e':5,'f':6,'g':7,'h':8,'i':9,'j':10,'k':11,'l':12,'m':13,'n':14}\r\n    d1={'o':15,'p':16,'q':17,'r':18,'s':19,'t':20,'u':21,'v':22,'w':23,'x':24,'y':25,'z':26}\r\n    d.update(d1)\r\n    for j in l1:\r\n        if j not in ['a','e','i','o','u']:\r\n            a=abs(d[j]-d['a'])\r\n            e=abs(d[j]-d['e'])\r\n            i=abs(d[j]-d['i'])\r\n            o=abs(d[j]-d['o'])\r\n            u=abs(d[j]-d['u'])\r\n        \r\n            count+=min([a,e,i,o,u])\r\n    print(count)\r\n\r\n
# cook your dish here\nimport sys\ndef get_array(): return list(map(int , sys.stdin.readline().strip().split()))\ndef get_ints(): return list(map(int, sys.stdin.readline().strip().split()))\ndef input(): return sys.stdin.readline().strip()\nimport math\nfrom collections import defaultdict\nfrom itertools import combinations_with_replacement,permutations\nimport bisect\nimport math as mt \nfrom functools import reduce\nimport time\n\ndef __starting_point():\n    for _ in range(int(input())):\n        n = int(input())\n        a=1\n        b=1\n        c=(-2*n)\n        dis = b * b - 4 * a * c  \n        sqrt_val = math.sqrt(abs(dis))\n        r1=(-b + sqrt_val)/(2 * a)\n        # r2=(-b - sqrt_val)/(2 * a)\n\n        # print(r1)\n        r1 = math.floor(r1)+1\n        print(n-r1+1)\n\n\n\n\n\n\n\n\n\n\n\n__starting_point()
t=int(input())\r\nwhile(t!=0):\r\n    t=t-1\r\n    n=int(input())\r\n    ans=0\r\n    for i in range(1,n+1,1):\r\n        sum=0;\r\n        for j in range(1,i+1,1):\r\n            sum=sum+j\r\n        s=sum-i\r\n        sum=sum+s\r\n        if(i!=n):\r\n            ans=ans+2*sum*i\r\n        else:\r\n            ans=ans+sum*i\r\n    print(ans)
isPrime=[1 for i in range(10001)]\ncnt=[0 for i in range(10001)]\nisPrime[0]=0\nisPrime[1]=0\nprime=[]\nfor i in range(2,10001):\n if isPrime[i]:\n  prime.append(i)\n  for j in range(i*i,10001,i):\n   isPrime[j]=0\n#print(prime)\nfor i in prime:\n for j in prime:\n  if (i + 2*j)>10000:\n   break\n  else:\n   cnt[i + 2*j]+=1\n#print(le)\nfor _ in range(int(input())):\n n=int(input())\n print(cnt[n])
# cook your dish here\nn=int(input())\nx=[]\ny=[]\nfor _ in range(n):\n s=input().split(' ')\n x.append(int(s[0]))\n y.append(int(s[1]))\nq=x[0]\nw=y[0]\nfor t in range(n-1):\n x[t]=(x[t]+x[t+1])/2 \n y[t]=(y[t]+y[t+1])/2 \nx[n-1]=(x[n-1]+q)/2 \ny[n-1]=(y[n-1]+w)/2 \ni=0\na=0\nwhile(i<n-1):\n a+=(x[i]*y[i+1]-y[i]*x[i+1])/2\n i+=1\na+=(x[i]*y[0]-y[i]*x[0])/2\n\nprint(abs(a))\n#print(x,y)\n
n = int(input())\nfor i in range(n) :\n t = int(input())\n li = sorted(list(map(int , input().split())))\n ans = 1\n dp = [li[1]-li[0]] + [0] * (t-2) + [li[t-1] - li[t-2]]\n for i in range(1 , t-1) :\n  dp[i] = min(li[i] - li[i-1] , li[i+1] - li[i])\n print(max(dp))\n
from sys import stdin, stdout\r\nfrom collections import Counter\r\nn = int(stdin.readline())\r\n#l = list(map(int, stdin.readline().split()))\r\n#l = [int(stdin.readline()) for _ in range(n)]\r\n#a, b = map(int, stdin.readline().split())\r\nfor _ in range(n):\r\n    n1 = int(stdin.readline())\r\n    if n1==1:\r\n        print('*')\r\n    else:\r\n        a = n1+(n1-1)\r\n        s = 0\r\n        for x in range(1,n1):\r\n            if x==1:\r\n                print(' '*(n1-1)+'*'+' '*(n1-1))\r\n                s+=1\r\n            else:\r\n                print(' '*(n1-x)+'*'+' '*(s)+'*')\r\n                s+=2\r\n            #print()\r\n        print('*'*(a))\r\n    \r\n
for i in range(int(input())):\n n=int(input())\n m=list(map(int,input().split()))[:n]\n m.sort()\n t=0\n for j in range(n//2):\n  t+=abs(m[j]-m[n-j-1])\n print(t)\n
t = int(input())\r\n\r\nfor _ in range(t):\r\n    k = int(input())\r\n    count = 1\r\n    for _ in range(k):\r\n        output = []\r\n        for index in range(1,k+1):\r\n            output.append(bin(count).replace("0b", ""))\r\n            count += 1\r\n        print(*output)
# cook your dish here\ndef mergeSort(arr, n): \n    # A temp_arr is created to store \n    # sorted array in merge function \n    temp_arr = [0]*n \n    return _mergeSort(arr, temp_arr, 0, n-1) \n  \n# This Function will use MergeSort to count inversions \n  \ndef _mergeSort(arr, temp_arr, left, right): \n  \n    # A variable inv_count is used to store \n    # inversion counts in each recursive call \n  \n    inv_count = 0\n  \n    # We will make a recursive call if and only if \n    # we have more than one elements \n  \n    if left < right: \n  \n        # mid is calculated to divide the array into two subarrays \n        # Floor division is must in case of python \n  \n        mid = (left + right)//2\n  \n        # It will calculate inversion  \n        # counts in the left subarray \n  \n        inv_count += _mergeSort(arr, temp_arr,  \n                                    left, mid) \n  \n        # It will calculate inversion  \n        # counts in right subarray \n  \n        inv_count += _mergeSort(arr, temp_arr,  \n                                  mid + 1, right) \n  \n        # It will merge two subarrays in  \n        # a sorted subarray \n  \n        inv_count += merge(arr, temp_arr, left, mid, right) \n    return inv_count \n  \n# This function will merge two subarrays  \n# in a single sorted subarray \ndef merge(arr, temp_arr, left, mid, right): \n    i = left     # Starting index of left subarray \n    j = mid + 1 # Starting index of right subarray \n    k = left     # Starting index of to be sorted subarray \n    inv_count = 0\n  \n    # Conditions are checked to make sure that  \n    # i and j don't exceed their \n    # subarray limits. \n  \n    while i <= mid and j <= right: \n  \n        # There will be no inversion if arr[i] <= arr[j] \n  \n        if arr[i] <= arr[j]: \n            temp_arr[k] = arr[i] \n            k += 1\n            i += 1\n        else: \n            # Inversion will occur. \n            temp_arr[k] = arr[j] \n            inv_count += (mid-i + 1) \n            k += 1\n            j += 1\n  \n    # Copy the remaining elements of left  \n    # subarray into temporary array \n    while i <= mid: \n        temp_arr[k] = arr[i] \n        k += 1\n        i += 1\n  \n    # Copy the remaining elements of right  \n    # subarray into temporary array \n    while j <= right: \n        temp_arr[k] = arr[j] \n        k += 1\n        j += 1\n  \n    # Copy the sorted subarray into Original array \n    for loop_var in range(left, right + 1): \n        arr[loop_var] = temp_arr[loop_var] \n          \n    return inv_count \n    \nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int,input().split()))\n    print(mergeSort(a, n) )
for _ in range(int(input())):\n n = int(input())\n s = ''\n for i in range(1, n + 1): s += str(i)\n for i in range(n, 0, -1):\n  if i % 2 == 0:\n   for j in range(i, 0, -1): print(j, end = '')\n  else:\n   for j in range(1, i + 1): print(j, end = '')\n  print()\n\n\n
def solve(l):\r\n   m = l.index(max(l))\r\n   if m == 0 or m == len(l) - 1:\r\n      return 1\r\n   return 1 + min(solve(l[0:m]), solve(l[m+1:]))\r\n\r\ntc = int(input())\r\nfor test in range(tc):\r\n   n = int(input())\r\n   l = list(map(int, input().split()))\r\n   print(solve(l))
import fractions\nfor t in range(int(input())):\n h,u,d = list(map(int,input().split()))\n g = fractions.gcd(u,d)\n if (h%g!=0):\n  print(-1)\n else:\n  m = 0\n  n = 0\n  while (True):\n   n = (float(m)*u-h)/d\n   if (n>0 and int(n) == n):\n    break\n   m+=1\n  print(int(m+n))
# cook your dish here\ntry:\n t = int(input())\n for _ in range(t):\n  n, k = map(int, input().split())\n  if k == 0:\n   print(0, n)\n  else:\n   print(n//k, n%k)\nexcept:\n pass
for _ in range(int(input())):\n N,U,D=list(map(int,input().split()))\n H=list(map(int,input().split()))\n jumps=0\n paracount=0\n for i in range(len(H)-1):\n  if H[i+1]-H[i]<=U and H[i+1]>=H[i]:\n   jumps+=1\n  elif H[i]>=H[i+1] and H[i]-H[i+1]<=D:\n   jumps+=1\n  elif H[i]-H[i+1]>D and paracount==0:\n   jumps+=1\n   paracount=1\n  else: break\n print(jumps+1)\n
try:\n    def countsubsetsum(S,arr,n):\n        k=[[0 for i in range(S+1)] for i in range(n+1)]\n        for i in range(n+1):\n            for j in range(S+1):\n                if(j==0):\n                    k[i][j]=1\n                elif(i==0):\n                    k[i][j]=0\n                elif(arr[i-1]<=j):\n                    k[i][j]=k[i-1][j-arr[i-1]]+k[i-1][j]\n                else:\n                    k[i][j]=k[i-1][j]\n        return k[n][S]\n    for _ in range(int(input())):\n        m=int(input())\n        S=int(input())  \n        arr=[int(i) for i in input().split()]\n      \n        n=len(arr)\n\n        print(countsubsetsum(S, arr,  n))\nexcept EOFError as e:\n    pass
import sys\nn = eval(input())\nparents = [int(x)-1 for x in input().split(' ')]\nvalues = list(map(int , input().split(' ')))\nparents = [0]+parents\n# print(parents)\n# print(values)\ndef single_node_cost(i):\n cost = 0\n # print('started with ',i)\n min_value = sys.maxsize\n while i != 0:\n  min_value = min(min_value,values[i])\n  cost += min_value\n  # print(i,min_value)\n  i = parents[i]\n cost += min(values[0],min_value)\n return cost\nfor i in range(n):\n print(single_node_cost(i), end=' ')
for i in range(int(input())):\n n,k=input().split()\n laddus=0\n for j in range(int(n)):\n  t=input().split()\n  if t[0]=='CONTEST_WON':\n   if(int(t[1])<=20):\n    laddus+=300+20-int(t[1])\n   else:\n    laddus+=300\n  elif t[0]=='TOP_CONTRIBUTOR':\n   laddus+=300\n  elif t[0]=='BUG_FOUND':\n   laddus+=int(t[1])\n  elif t[0]=='CONTEST_HOSTED':\n   laddus+=50\n if(k=='INDIAN'):\n  print(laddus//200)\n else:\n  print(laddus//400)
def posSearch(arr, num):\n l = 0\n r = len(arr)\n if num < arr[l]:\n  return 0\n elif num > arr[r-1]:\n  return r\n while l < r:\n  m = (l+r)//2\n  if arr[m] == num:\n   return -1\n  if arr[m] < num < arr[m+1]:\n   return m+1\n  if arr[m] > num:\n   r = m\n  elif arr[m] < num:\n   l = m+1 \n \nfor _ in range(int(input())):\n n = int(input())\n narr = list(map(int, input().split()))\n q = int(input())\n for i in range(q):\n  x, y = list(map(int, input().split()))\n  a = x+y\n  j = posSearch(narr, a)\n  print(j)\n   \n
for _ in range(int(input())):\n n=int(input())\n a=[int(z) for z in input().split()]\n m=0\n a1=list(set(a))\n for i in range(len(a1)):\n  if a.count(a1[i])>m:\n   m=a.count(a1[i])\n print(n-m)\n \n   \n
try:\n    a=list(map(int,input().split()))\n    n=a[0]\n    k=a[1]\n    hi=[]\n    for i in range(n):\n        hi.append(int(input()))\n    hi.sort()\n    diff=[]\n    for i in range(n-k+1):\n        diff.append(hi[i+k-1]-hi[i])\n    print(min(diff))\nexcept:\n    pass
# cook your dish here\ntestcases=int(input())\n\nfor _ in range(testcases):\n    (N,K)=list(map(int,input().split()))\n    array=list(map(int,input().split()))\n    \n    max=array[0]\n    min=array[0]\n    \n    for i in array:\n        if i>max:\n            max=i\n        if i<min:\n            min=i\n            \n    max=max+K \n    min=min-K\n    \n    print(abs(max-min))
for _ in range(int(input())):\r\n    a,b,c,d=list(map(int,input().split()))\r\n    if(a==b):\r\n        print('YES')\r\n    elif(c==d):\r\n        print('NO')\r\n    \r\n    else:\r\n        if(abs(a-b)%abs(c-d)==0):\r\n            print('YES')\r\n        else:\r\n            print('NO')\r\n
for _ in range(int(input())):\n n,r,x,y=map(int,input().split())\n if x>0:\n  a=list(map(int,input().split()))\n if y>0:\n  b=list(map(int,input().split()))\n if x>0 and y>0:\n  a=a+b\n  c=n-len(list(set(a)))\n else:\n  l=x+y\n  c=n-l\n x=min(c,r)\n print(x)
# cook your dish here\nn=int(input())\nstringa=list(map(int,input().split()))\ncounter=0\ncounter1=0\ncounter3=0\nsomma1=0\nsomma2=0\nmassimo=0\nmassimo1=0\nmassimo3=0 \nstack=[]\nfor par in stringa:\n    if par==1 or par==3:\n        if counter1==0 and par==1:\n            counter1=1\n            somma1=1\n            massimo1=max(massimo1, 1)\n        elif counter1>0:\n            counter1+=1 \n            somma1+=1\n            massimo1=max(massimo1, somma1)\n        if counter3==0 and par==3:\n            counter3=1\n            somma3=1\n            massimo3=max(massimo3, 1)\n        elif counter3>0:\n            counter3+=1\n            somma3+=1\n            massimo3=max(massimo3, somma3)\n        if counter==0:\n            counter=1 \n            massimo=max(massimo,1)\n        if len(stack)>0 and par!=stack[-1]:\n            counter+=1 \n            massimo=max(massimo,counter)\n        stack.append(par)\n    else:\n        if counter1>0:\n            counter1-=1 \n            somma1+=1\n            massimo1=max(massimo1, somma1)\n        if counter3>0:\n            counter3-=1 \n            somma3+=1\n            massimo3=max(massimo3, somma3)\n        appo=stack.pop()\n        if len(stack)>0 and appo==stack[-1]:\n            pass\n        else:\n            counter-=1\nprint(massimo, massimo1, massimo3)\n
# cook your dish here\ntry:\n for _ in range(int(input())):\n  n = int(input())\n  li = [i for i in input()]\n  a = 0\n  while a+1<len(li):\n   li[a],li[a+1] = li[a+1],li[a]\n   a+=2\n  li2 = li.copy()\n  for i in li2:\n   fh = 109\n   sh = 110\n   li.remove(i)\n   if ord(i)>fh:\n    li.append(chr(fh-(ord(i)-sh)))\n   else:\n    li.append(chr(sh+(fh-ord(i))))\n  for i in li:\n   print(i,end="")\n  print()\nexcept:\n pass 
for i in range(int(input())):\n n=int(input())\n if(n<=2 or n>1000000007):\n  print("0")\n else:\n  prod=1\n  for i in range(2,n):\n   prod*=i\n   if(prod>1000000007):\n    prod=prod%1000000007\n  print(((prod)*(n*prod-2))%1000000007)\n
def for1(M,k):\n ret = 0.0\n x = k*k+0.0\n z=x\n for m in range(1,M):\n  ret+=(M-m)/x\n  x*=z\n return ret \n  \ndef for2(M,k):\n ret = 0.0\n x = k+0.0\n for m in range(1,M):\n  ret+=(M-m)/x\n  \n  x*=k\n return ret \n  \ndef ans(M,N,K):\n\n return int(round(M*N+M*for2(N,K)+N*for2(M,K)+K*for1(M,K)*for1(N,K),0))\nM,N,K = list(map(int,input().split()))\nprint(ans(M,N,K)) \n
for t in range(int(input())):\n n,b,m = list(map(int,input().split()))\n ans = 0\n while n>0:\n  ans+=b\n  half = (n+1)/2 if n%2 else n/2\n  ans+=m*half\n  m*=2\n  n=n-half\n print(ans-b)\n \n
t=eval(input())\nfor q in range(t):\n l=eval(input())\n a=input().split()\n a=[int(x) for x in a]\n a=sorted(a)\n for i in range(l-1):\n  a[i]=(a[i+1]-a[i]) \n print(min(a[0:l-1]))\n
# cook your code here\nn=input()\nx=len(n)\nno=list(map(int,n))\ntemp=[0]*x\nif (x>2):\n sum=99\n for i in range(3,x):\n  sum=sum+90\n sum=sum+10*(int(n[0])-1)\n sum=sum+int(n[1])\n f=int(n[0])%10\n \n s=int(n[1])%10\n \n cd=s-f\n \n temp[0]=n[0]\n temp[1]=n[1]\n for i in range(2,x):\n  nxt=(s+cd)%10\n  temp[i]=(chr(nxt+48))\n  s=nxt\n temp=list(map(int,temp))\n if(temp<=no):\n  sum=sum+1\n print(sum)\nelse:\n  print(n)
import sys\r\n\r\nn = int(sys.stdin.readline().strip())\r\ns = sys.stdin.readline().strip()\r\n\r\nalph = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"\r\n\r\narr = [0]*26\r\npref = []\r\n\r\nfor i in range(len(s)):\r\n	for j in range(26):\r\n		if alph[j] == s[i]:\r\n			arr[j] += 1\r\n			break\r\n	pref += [arr[:]]\r\n\r\n# for x in pref:\r\n# 	print(x)\r\n\r\nq = int(sys.stdin.readline().strip())\r\n\r\nfor _ in range(q):\r\n	r, c = sys.stdin.readline().strip().split()\r\n\r\n	for i in range(26):\r\n		if alph[i] == c:\r\n			ind = i\r\n			break\r\n\r\n	r = int(r)\r\n\r\n	prev = ((r-1)**2 + r-1)//2\r\n\r\n	done = prev%len(s)\r\n\r\n	ans = 0\r\n	rem = (len(s) - done)%len(s)\r\n\r\n	if r <= rem:\r\n		print(pref[done+r-1][ind] - pref[done-1][ind])\r\n		continue\r\n\r\n	if rem != 0:\r\n		ans += pref[-1][ind] - pref[done-1][ind]\r\n		r -= rem\r\n\r\n	ans += pref[-1][ind] * (r//len(s))\r\n	r %= len(s)\r\n\r\n	# print("AA", ans, r)\r\n\r\n	if r != 0:\r\n		ans += pref[r-1][ind]\r\n\r\n	print(ans)\r\n\r\n\r\n	# print(rem, done, prev)\n
t = int(input())\nfor i in range(t):\n n = int(input())\n l = list(map(int, input().split()))\n counter = 0\n even = 0\n for num in l:\n  if num % 2 == 0:\n   even += 1 \n  if num % 2 == 1:\n   counter += even\n print(counter)\n \n
# coding: utf-8\n# Your code here!\n\nn=int(input())\na=[]\nfor i in range(n):\n    x=int(input())\n    a.append(x)\n    \n# print(a)\nans=0\nm=[1]*n\nfor i in range(n):\n    for j in range(i):\n        if a[i]%a[j]==0:\n            m[i]=max(m[i],m[j]+1)\n            \n            \n            \nprint(max(m))
t = int(input())\nwhile t> 0:\n t =t -1\n n,k = list(map(int,input().split()))\n a = [0]*n\n done = True\n\n def swap(z):\n  for j in range(0,n):\n   if a[j] == 0:\n    a[j] = z\n    done = True\n    break\n   else:\n    if a[j] > z:\n     swap(j)\n     a[j] = z\n    else:\n     done = False\n     break\n\n for i in range(0,n):\n  for j in range(0,n):\n   if abs(i-j) == k:\n    if a[j] == 0:\n     a[j] = i + 1\n     done = True\n     break\n    else:\n     if a[j] > i + 1:\n      swap(a[j])\n      a[j] = i + 1\n     else:\n      done = False\n\n if 0 in a:\n  print('CAPTAIN AMERICA EVADES')\n else:\n  if done:\n   for c in a:\n    print(c, end=' ')\n   print()\n  else:\n   print('CAPTAIN AMERICA EVADES')\n\n\n # for i in range(1,n+1):\n #   if i - k >=0 :\n #       if a[abs(i-k-1)] == 0:\n #           a[abs(i-k-1)] = i\n #           done = True\n #       else:\n #           done = False\n #           break\n #   else:\n #       done = False\n #       break\n # if done:\n #   for c in a:\n #       print c,\n #   print\n # else:\n #   print "CAPTAIN AMERICA EVADES"\n
for i in range(int(input())):\n finish,distanetobolt,tigerAcceleration,boltspeed=map(int,input().split())\n t1=((2*(finish+distanetobolt)/(tigerAcceleration))**0.5)\n t2=(finish/boltspeed)\n if t1>t2:\n  print("Bolt")\n elif t1<t2:\n  print("Tiger")\n else:\n  print("Tiger")
# cook your dish here\n# cook your dish here\ntest=int(input())\nfor _ in range(test):\n n=int(input())\n a=[(bin(int(x))[2:][::-1]+("0")*32)for x in input().split()]\n res=""\n mysum=0\n for i in range(32):\n  mycount=0\n  for j in range(n):\n   if(a[j][i]=="0"):\n    mycount+=1\n  if(mycount==n):\n   break\n  if(mycount>(n//2)):\n   res+="0"\n   mysum+=(n-mycount)*int(pow(2,i))\n  else:\n   res+="1"\n   mysum+=mycount*int(pow(2,i))\n print(mysum)
n=int(input())\nwhile(n>0):\n x,y,z=map(int,input().split())\n t=(x+y)//z\n if t%2==0:\n  print('Chef')\n else:\n  print('Paja')\n n-=1
try:\r\n    n,m,a=map(int,input().split())\r\n    if n%a!=0:\r\n        number1=(n//a)+1\r\n    else:\r\n        number1=(n//a)\r\n    if m%a!=0:\r\n        number2=(m//a)+1\r\n    else:\r\n        number2=(m//a)\r\n    print(number1*number2)\r\nexcept:\r\n    pass
n,k, q = list(map(int, input().split()))\nmod = 10 ** 9 + 7\nA = [0] * n\na, b, c, d, e, f, r, s, t, m, x = list(map(int, input().split())) \nA[0] = x \n\nfor x in range(1, n):\n if pow(t, x+1, s) <= r:\n  A[x] = (a*pow(A[x-1], 2, m) + b*A[x-1] + c) % m\n else:\n  A[x] = (d*pow(A[x-1], 2, m) + e*A[x-1] + f) % m\n  \ndef SRMQ(arr, k):\n from collections import deque\n n = len(arr)\n ans = [None] * n\n deque = deque()\n for i in range(len(arr)):\n  while deque and deque[-1] > arr[i]:\n   deque.pop()\n  deque.append(arr[i])\n  if i >= k and arr[i-k] == deque[0]:\n   deque.popleft()\n  if i >= k-1:\n   ans[i-k+1] = deque[0]\n return ans\n   \nv = SRMQ(A, k) \n\nL1, La, Lc, Lm, D1, Da, Dc, Dm = list(map(int, input().split()))\ns = 0 \nprod = 1 \nfor _ in range(q):\n L1 = (La * L1 + Lc) % Lm;\n D1 = (Da * D1 + Dc) %Dm; \n L = L1 + 1;\n R = min(L + k - 1 + D1, n);\n z = min(v[L-1], v[R-k])\n s += z \n \n prod = (prod * z) % mod\nprint(s, prod)\n\n
from math import sqrt\nimport sys\nsys.setrecursionlimit(10**8)\nintMax = 10**18\ndef knapsack(rl,l,c,m):\n if m==0 and rl>0:\n  return intMax\n if rl<=0:\n  return 0\n return min(c[m-1]+knapsack(rl-l[m-1],l,c,m),knapsack(rl,l,c,m-1))\nfor _ in range(int(input())):\n n= int(input())\n cost=[]\n length=[]\n sides=[]\n for i in range(n):\n  x,y = map(int,input().split())\n  if i == 0:\n   x0 = x\n   y0 = y\n   prevx = x\n   prevy = y\n  elif i == n-1:\n   sides.append(sqrt((prevx-x)**2 + (prevy-y)**2))\n   sides.append(sqrt((x0-x)**2 + (y0-y)**2))\n  else:\n   sides.append(sqrt((prevx-x)**2 + (prevy-y)**2))\n   prevx = x\n   prevy = y\n m = int(input())\n for j in range(m):\n  li,ci = map(int,input().split())\n  length.append(li)\n  cost.append(ci)\n ans=0\n #print(sides)\n for k in sides:\n  ans= ans + knapsack(k,length,cost,m)\n print(int(ans))
import math\r\n\r\ndef check(s):\r\n    if s==2:\r\n        return 1\r\n        \r\n    for i in range(2,math.ceil(math.sqrt(s))+1):\r\n        if s%i == 0:\r\n            return 0\r\n    \r\n    return 1\r\n        \r\n\r\ndef Solve(slots):\r\n  if slots<3:\r\n    return 0\r\n  \r\n  #check\r\n  s = math.sqrt(slots)\r\n  if math.floor(s) == math.ceil(s):\r\n      return check(s)\r\n      \r\n  return 0\r\n\r\n\r\nN = int(input())\r\n\r\nfor t in range(N):\r\n  \r\n  slots = int(input())\r\n  \r\n  if (Solve(slots)):\r\n    print("YES")\r\n  \r\n  else:\r\n    print("NO")
# cook your dish here\nimport sys\ninput=sys.stdin.readline\nfor _ in range(int(input())):\n n,x=list(map(int,input().split()))\n l=[0]\n pre=[0]*(n+1)\n sum=0\n i=1\n for m in input().split():\n  l.append(int(m))\n  sum+=int(m)\n  pre[i]=sum\n  i+=1\n dict={}\n k=[]\n i=1\n while (i*i)<=x:\n  if x%i==0:\n   k.append(i)\n   if (i*i)!=x:\n    k.append(x//i)\n   else:\n    break\n  i+=1 \n ans=0 \n for a in k:\n  if a>n:\n   continue\n  z=x//a \n  for j in range(a,n+1):\n   s=pre[j]-pre[j-a]\n   if s>z:\n    continue\n   if s in dict:\n    dict[s]+=1\n   else:\n    dict[s]=1\n  for j in range(a,n+1):\n   s=pre[j]-pre[j-a]\n   if s>z:\n    continue\n   if (z-s) in dict:\n    ans+=dict[z-s]\n  for j in range(a,n+1):\n   s=pre[j]-pre[j-a]\n   if s>z:\n    continue\n   dict[s]=0\n   \n print(ans) \n   \n
rooms=int(input())\r\nmoney=list(map(int,input().split()))\r\nkeys=int(input())\r\nrev=-1\r\na,b=0,-1\r\ntot=[]\r\n#print(money[-3:-1])\r\nx=0\r\nfor i in range(keys):\r\n    #print(money[b:-1],money[0:a])\r\n    x=sum(money[b:])+sum(money[0:keys-abs(b)])\r\n    tot.append(x)\r\n    b-=1\r\nprint(max(tot))\r\n
s1=s2=lead=0\nmlead1=mlead2=0\nfor _ in range(int(input())):\n    x, y= list(map(int, input().split()))\n    s1, s2= s1+x, s2+y\n    if(s1>s2):\n        lead=(s1-s2)\n        mlead1= max(mlead1, lead)\n    else:\n        lead=(s2-s1)\n        mlead2= max(mlead2, lead)\nif(mlead1<(mlead2)):\n    print('2', mlead2)\nelse:\n    print('1', mlead1)\n\n
try:\n t=int(input())\n for a in range(t):\n  l=input().split()\n  n=int(l[0])\n  m=int(l[1])\n  d={}\n  s=0\n  for b in range(m):\n   l1=input().split()\n   i=int(l1[0])\n   j=int(l1[1])\n   k=int(l1[2])\n   for c in range(i,j+1):\n    if c not in d:\n     d[c]=10\n   for c in range(i,j+1):\n    d[c]=d[c]*k\n  for i in d:\n   s=s+d[i]\n  print(s//n)\nexcept:\n pass
n,q=map(int,input().split())\ndr={}\ndc={}\nfor i in range(1,n+1):\n dr[i]=0\n dc[i]=0\nmer=0\nmec=0\nfor i in range(q):\n s,j,k=input().split()\n j=int(j)\n k=int(k)\n if s=="RowAdd":\n  dr[j]+=k\n  if dr[j]>mer:\n   mer=dr[j]\n else:\n  dc[j]+=k\n  if mec<dc[j]:\n   mec=dc[j]\n# m=max(list(dr.values()))+max(list(dc.values()))\n\n# for i in range(n):\n#     for j in range(n):\n#         ar[i][j]=dr[i+1]+dc[j+1]\n#         if ar[i][j]>m:\n#             m=ar[i][j]\n\nprint(mer+mec)
try:\n for _ in range(int(input())):\n  k=int(input())\n  for i in range(1,k+1):\n   print(" "*(k-i),end="")\n   if i%2==1:\n    for j in range(0,i):\n     print(chr(65+j),end="")\n   else:\n    for j in range(0,i):\n     print(j+1,end="")\n   print()\n  \n   \nexcept:\n pass
# cook your dish here\nfrom math import ceil\nfor _ in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    ans=ceil(n/min(a))\n    print(int(ans))
for _ in range(int(input())):\n n=int(input())\n a=list(map(int,input().split()))\n g=1\n for j in range(1,n):\n  if j-5<0:\n   mi=min(a[0:j])\n   #print(a[0:j])\n   if mi>a[j]:\n    g=g+1\n  else:\n   mi=min(a[j-5:j])\n   #print(a[j-5:j])\n   if mi>a[j]:\n    g=g+1\n print(g)\n
# cook your dish here\ndef solution(b,n1,d):\n first=b[0]\n b.sort()\n for j in range(n1-1):\n  if(a[j+1]-a[j]>d):\n   return "NO"\n for j in range(n1):\n  if(b[j]==first):\n   pos=j\n if(pos==0 or pos==n1-1):\n  return "YES"\n rec=1\n for j in range(pos-1,n1-2):\n   if(a[j+2]-a[j]>d):\n    rec=0\n    break\n if(rec):\n  return "YES"\n rec=1\n for j in range(pos+1,1,-1):\n   if(a[j]-a[j-2]>d):\n    rec=0\n    break\n if(rec):\n  return "YES"\n else:\n  return "NO"\n \ntestcase=int(input())\nfor i in range(testcase):\n n,d=list(map(int,input().split()))\n a=list(map(int,input().split()))\n print(solution(a,n,d))\n
t=eval(input())\nfor i in range(0,t):\n    x=input()\n    nm=x.split(' ')\n    nm[0]=int(nm[0])\n    nm[1]=int(nm[1])\n    csoint=[]\n    lsoint=[]\n    csofloat=[]\n    lsofloat=[]\n    for j in range(0,nm[0]):\n        a=input()\n        b=a.split(' ')\n        b[0]=int(b[0])\n        b[1]=int(b[1])\n        csoint.append(b[0])\n        lsoint.append(b[1])\n    for k in range(0,nm[1]):\n        a=input()\n        b=a.split(' ')\n        b[0]=int(b[0])\n        b[1]=int(b[1])\n        csofloat.append(b[0])\n        lsofloat.append(b[1])\n    chakra=0\n\n##    for j in range(0,nm[0]):\n##        if csofloat==[0]*nm[1]:\n##                print chakra\n##                break\n##        for k in range(0,nm[1]):\n##            if csofloat==[0]*nm[1]:\n##                print chakra\n##                break\n##            if lsoint[j]==lsofloat[k]:\n##                if csoint[j]>csofloat[k]:\n##                    csoint[j]-=csofloat[k]\n##                    csofloat[k]=0\n##                    lsofloat[k]=0\n##                elif csofloat[k]>csoint[j]:\n##                    if lsoint.count(lsoint[j])==1==lsofloat.count(lsofloat[k]):\n##                        chakra+=csofloat[k]-csoint[j]\n##                        csoint[j]=csofloat[k]\n##                        csoint[j]=0\n##                        csofloat[k]=0\n##                        lsoint[j]=0\n##                        lsofloat[k]=0\n##                    elif lsoint.count(lsoint[j])==1 and lsofloat.count(lsofloat[k])>lsoint.count(lsoint[j]):\n##                        csoint[j]=csofloat[k]+1\n##                        chakra+=csofloat[k]-csoint[j]+1\n##                        csoint[j]=1\n##                        csofloat[k]=0\n##                        lsofloat[k]=0\n##                    else:\n##                        csofloat[k]-=csoint[j]\n##                        csoint[j]=0\n##                        lsoint[j]=0\n##                        break\n##                else:\n##                    if lsoint.count(lsoint[j])==1 and lsoint.count(lsoint[j])>=lsofloat.count(lsofloat[k]):\n##                        csoint[j]=0\n##                        csofloat[k]=0\n##                        lsoint[j]=0\n##                        lsofloat[k]=0\n##                        break\n##                    elif lsoint.count(lsoint[j])==1 and lsoint.count(lsoint[j])<lsofloat.count(lsofloat[k]):\n##                        csoint[j]=1\n##                        chakra+=1\n##                        csofloat[k]=0\n##                        lsofloat[k]=0\n    l=min(lsoint)-1\n    ci=[]\n    for a in range(l+1,max(lsoint)+1):\n        c=0\n        l+=1\n        if l not in lsoint:\n            continue\n        for j in range(0,nm[0]):\n           if lsoint[j]==l:\n               c+=csoint[j]\n        ci.append(c)\n    \n    l=min(lsofloat)-1\n    cf=[]\n    for a in range(l+1,max(lsofloat)+1):\n        c=0\n        l+=1\n        if l not in lsofloat:\n            continue\n        for j in range(0,nm[1]):\n            if lsofloat[j]==l:\n                c+=csofloat[j]\n        cf.append(c)\n\n    for i in range(0,len(ci)):\n        if ci[i]<cf[i]:\n            chakra+=cf[i]-ci[i]\n    print(chakra)\n
a=int(input())\nif(a%2==0):\n print("4")\n print(a/2,a/2,a/2,a/2)\nelse:\n print("6")\n print((a-1)/2,(a-1)/2,(a-1)/2,(a-1)/2,(a-1)/2,(a+1)/2)
MAXX = 10**9+1\nN = eval(input())\nnodes = list(map(int, input().split(" ")))\nedges = [set() for _ in range(N)]\nfor _ in range(N-1):\n    a, b = list(map(int, input().split(" ")))\n    edges[a-1].add(b-1)\n    edges[b-1].add(a-1)\npath = [[] for _ in range(N)]\nvisited, tovisit = set(), [(0, 0)]\nwhile tovisit:\n    p, v = tovisit.pop()\n    if v not in visited:\n        path[v] = path[p] + [v]\n        visited.add(v)\n        news = edges[v] - visited\n        tovisit.extend([(v, x) for x in news])\n# print path\n\nQ = eval(input())\nfor _ in range(Q):\n    q, a, b = input().split(" ")\n    a, b = int(a)-1, int(b)-1\n    i = 1\n    while i < min(len(path[a]), len(path[b])):\n        if path[a][i] != path[b][i]: break\n        i += 1\n    s = path[a][i-1:] + path[b][i:]\n\n    # print s\n    if q == "C":\n        s = sorted([nodes[i] for i in s])\n        d = s[-1] - s[0]\n        for i in range(len(s)-1):\n            d = min(d, s[i+1]-s[i])\n        print(d)\n    else:\n        M = 0\n        m = MAXX\n        for i in range(len(s)):\n            M = max(M, nodes[s[i]])\n            m = min(m, nodes[s[i]])\n        print(M - m)\n    # print M[(s, l)] - m[(s, l)]
for _ in range(int(input())):\n n,d=map(str,input().split())\n k=list(n)\n dd,c,n=d,0,len(n)\n for x in range(n):\n  if int(k[n-x-1])>int(d):\n   k.pop(n-x-1)\n   c+=1 \n  else:\n   d=k[n-x-1]\n print(''.join(k)+c*dd)
import math\nfor _ in range(int(input())):\n n=int(input())\n ar=[int(x) for x in input().split()]\n # dp=[1]*n\n f=0\n g=ar[0]\n for i in range(1,n):\n  g=math.gcd(g,ar[i])\n  if g==1:\n   f=1\n   print(n)\n   break\n if f==0:\n  print(-1)\n
t=int(input())\nfor k in range(t):\n    n=int(input())\n    l=[int(i) for i in input().split()]\n    m={}\n    count=1\n    for i in range(1,n):\n        if l[i]==l[i-1]:\n            count+=1\n        else:\n            \n            if l[i-1] not in m:\n                m[l[i-1]]=(count*(count+1))/2\n            else:\n                \n                m[l[i-1]]+=(count*(count+1))/2\n            count=1\n    if(l[n-1]) not in m:\n        m[l[n-1]]=(count*(count+1))/2\n    else:\n        \n        m[l[n-1]]+=(count*(count+1))/2\n    s=1\n    \n    for x in m:\n        \n         s=(s*m[x])%(1000000007)\n    print(s)\n    \n
# cook your dish here\nfrom sys import stdin\nimport functools\ndef gcd(a, b):  \n if (a == 0): \n  return b \n return gcd(b % a, a) \n \nMAX=10001\ndef func(ind, g, dp, n, a): \n if (ind == n):  \n  if (g == 1):  \n   return 1\n  else: \n   return 0\n if (dp[ind][g] != -1):  \n  return dp[ind][g] \n ans = (func(ind + 1, g, dp, n, a) + \n   func(ind + 1, gcd(a[ind], g),  \n        dp, n, a)) \n dp[ind][g] = ans \n return dp[ind][g] \n \ndef countSubsequences(a, n):  \n dp = [[-1 for i in range(MAX)] \n    for i in range(n)] \n count = 0\n for i in range(n):  \n  count += func(i + 1, a[i], dp, n, a) \n return count \n\ntest=int(stdin.readline())\nfor _ in range(test):\n n=int(stdin.readline())\n list1=list(map(int,stdin.readline().split()))\n print(countSubsequences(list1,n))\n\n
#code snippet reference:http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/\ndef KMPMatch(pattern, string):\n M = len(pattern)\n N = len(string)\n nonlocal ans\n\n lps = [0]*M\n j = 0 \n LPSCompute(pattern, M, lps)\n\n i = 0 \n while i < N:\n  if pattern[j] == string[i]:\n   i+=1\n   j+=1\n\n  if j==M:\n   ans+=1\n   j = lps[j-1]\n   \n  elif i < N and pattern[j] != string[i]:\n   if j != 0:\n    j = lps[j-1]\n   else:\n    i+=1\n\ndef LPSCompute(pattern, M, lps):\n len = 0 \n lps[0] \n i = 1\n while i < M:\n  if pattern[i]==pattern[len]:\n   len+=1\n   lps[i] = len\n   i+=1\n  else:\n   if len!=0:\n    len = lps[len-1]\n\n   else:\n    lps[i] = 0\n    i+=1\n\nfor _ in range(int(input())):\n n,k=list(map(int,input().split()))\n s=list(map(int,input().split()))\n pattern=list(map(int,input().split()))\n ans=0\n string=[]\n for i in range(n-1):\n  string.append(s[i+1]-s[i])\n KMPMatch(pattern, string)\n print(ans)\n\n
t=int(input())\ndef do():\n n,k=map(int,input().split())\n s=input()\n upper=0\n lower=0\n for i in s:\n  if i.isupper():\n   upper+=1\n  else:\n   lower+=1\n if lower>k and upper<=k:\n  print('chef')\n elif(upper>k and lower<=k):\n  print('brother')\n elif(upper<=k and lower<=k):\n  print('both')\n else:\n  print('none')\n return\nfor i in range(t):\n do()
import sys\r\nfrom collections import defaultdict\r\nfrom copy import copy\r\n\r\nMOD = 10**9 + 7\r\n\r\nR = lambda t = int: t(input())\r\nRL = lambda t = int: [t(x) for x in input().split()]\r\nRLL = lambda n, t = int: [RL(t) for _ in range(n)]\r\n\r\n# primes up to n\r\ndef primes(n):\r\n  P = []\r\n  n = int(n)\r\n  U = [1] * (n+1)\r\n  p = 2\r\n  while p <= n:\r\n    if U[p]:\r\n      P += [p]\r\n      x = p\r\n      while x <= n:\r\n        U[x] = 0\r\n        x += p\r\n    p += 1\r\n  return P\r\n  \r\n    \r\n  \r\ndef solve():\r\n    S = R(str).strip()\r\n    X = [ord(c)-ord('a') for c in S]\r\n    P = primes(10000)\r\n    L = defaultdict(lambda : 0)\r\n    s = 0\r\n    for i in range(len(S)):\r\n        p = i in P\r\n        NL = defaultdict(lambda : 0)\r\n        for a in range(26):\r\n            for l in L:\r\n                NL[l + a * p] += L[l]\r\n        for a in range(X[i]):\r\n            NL[s + a * p] += 1\r\n        s += X[i] * p\r\n        L = NL\r\n    L[s] += 1\r\n    r = 0 \r\n    for p in P:\r\n        r += L[p]\r\n    print(r % MOD)\r\n    \r\nT = R()\r\nfor t in range(1, T + 1):\r\n    solve()\r\n
# cook your dish here\r\nfrom collections import defaultdict\r\nd=defaultdict(list)\r\ndef dfs(i):\r\n    p=0\r\n    nonlocal v\r\n    e=[i]\r\n    while(e!=[]):\r\n        p+=1\r\n        x=e.pop(0)\r\n        v[x]=1\r\n        for i in d[x]:\r\n            if v[i]==-1:\r\n                v[i]=1\r\n                e.append(i)\r\n    return p\r\n\r\nn,m=list(map(int,input().split()))\r\nfor i in range(n+1):\r\n    d[i]=[]\r\nfor _ in range(m):\r\n	a,b=list(map(int,input().split()))\r\n	d[a].append(b)\r\n	d[b].append(a)\r\nv=[]\r\nfor i in range(n+1):\r\n    v.append(-1)\r\nc=0\r\np=[]\r\nfor i in range(1,n+1):\r\n    if v[i]==-1:\r\n        c+=1\r\n        p.append(dfs(i))\r\nan=0\r\ns=0\r\nfor i in range(c):\r\n    s+=p[i]\r\n    an+=p[i]*(n-s)\r\nprint(an)\r\n
from math import log2, ceil\r\nMOD = int(1e9 + 7)\r\nsrt = lambda s: ''.join(sorted(s))\r\nfor _ in range(int(input())):\r\n    s = srt(input())\r\n    res = -1\r\n    for p in range(ceil(log2(int(s))), int(log2(int(s[::-1]))) + 1):\r\n        if int(srt(str(pow(2, p)))) == int(s):\r\n            if res == -1: res = 0\r\n            res = (res + pow(2, p, MOD)) % MOD\r\n    print(res)
# cook your dish here\ntry:\n    for _ in range(int(input())):\n        k = int(input())\n        num = 1\n        for i in range(1,k+1,1):\n            for j in range(1,k+1,1):\n                print(num*2,end="")\n                num = num +1\n            print("")\nexcept:\n    pass
# cook your dish here\nfor t in range(int(input())):\n c=0\n for i in range(int(input())):\n  s,j=list(map(int,input().split()))\n  if (j-s)>5:\n   c+=1 \n print(c)\n   \n
# cook your dish here\nfor t in range(int(input())):\n a1,a2,a3,a4,a5,p=[int(x)for x in input().rstrip().split()]\n if (a1+a2+a3+a4+a5)*p >120:\n  print("Yes")\n else:\n  print("No")\n
\nfor _ in range(int(input())):\n n = int(input())\n arr = list(map(int, input().split()))\n hrs = arr[0] - arr[1]\n\n for i in range(1, n-1):\n  if hrs > arr[i] - arr[i+1]:\n   hrs = arr[i] - arr[i+1]\n\n print(hrs)
# cook your dish here\nfor i in range(int(input())):\n N=int(input())\n L=list(map(int,input().split()))\n l,h=0,N-1 \n flag=1\n if L[l]!=1 and L[h]!=1:\n  flag=0\n else:\n  while(l<h):\n   if (L[l]!=L[h]) or (L[l+1]-L[l]!=1 and L[h-1]-L[h]!=1):\n    flag=0\n    break\n   l+=1 \n   h-=1\n if flag:\n  print("yes")\n else:\n  print("no")
# cook your dish here\nfor _ in range(int(input())):\n n,k=list(map(int,input().split()))\n a=list(map(int,input().split()))\n m=0\n for i in range(n):\n  if i%2==0:\n   if m<0:\n    m-=a[i]\n   else:\n    m+=a[i]\n  else:\n   if m<0:\n    m+=a[i]\n   else:\n    m-=a[i]\n if abs(m)>=k:\n  print(1)\n else:\n  print(2)\n   \n
class Node:\r\n    def __init__(self,x):\r\n        self.x=x\r\n        self.next=None\r\n        self.prev=None\r\n        self.flag=True\r\n\r\nfor t in range(1):\r\n    n=int(input())\r\n    arr=list(map(int,input().split()))\r\n    for i in range(n):\r\n        arr[i]=Node(arr[i])\r\n    for i in arr:\r\n        d=[i.x%3==0,i.x,i.x//3,i.x*2]\r\n        if d[0]:\r\n            for j in arr:\r\n                if j.x==d[2]:\r\n                    i.next=j\r\n                    j.prev=i\r\n                    break\r\n            else:\r\n                for j in arr:\r\n                    if j.x == d[3]:\r\n                        i.next = j\r\n                        j.prev = i\r\n                        break\r\n        else:\r\n            for j in arr:\r\n                if j.x==d[3]:\r\n                    i.next=j\r\n                    j.prev=i\r\n                    break\r\n    f,l=None,None\r\n    for i in arr:\r\n        if i.prev==None:\r\n            f=i\r\n        elif i.next==None:\r\n            l=i\r\n    while f!=l and l!=None:\r\n        print(f.x,end=" ")\r\n        f=f.next\r\n    print(f.x)
# cook your dish here\n# cook your dish here\nimport math\ntest=int(input())\nfor _ in range(test):\n n=int(input())\n l=list(map(int,input().split()))\n f=0\n for i in range(math.ceil(n//2)):\n  if n%2==1:\n   f=1\n   break\n  else:\n   if l[i]!=l[i+n//2]:\n    if min(l[i],l[i+n//2])==-1:\n     l[i]=max(l[i],l[i+n//2])\n     l[i+n//2]=max(l[i],l[i+n//2])\n    else:\n     f=1\n     break\n   else:\n    if l[i]==-1:\n     l[i]=1\n     l[i+n//2]=1\n if f==1:\n  print("NO")\n else:\n  print("YES")\n  print(*l)
# cook your dish here\nfor _ in range(int(input())):\n    n = int(input())\n    count = 1\n    l = 3*(n-1)\n    i = 0\n    if n==1:\n        print(1)\n        continue\n    while count<=l-n:\n        for j in range(i+1):\n            if j==i:\n                print(count)\n                count += 1\n            elif j==0:\n                print(count,end="")\n                count += 1\n            else:\n                print(" ",end="")    \n        i+=1\n    while count<=l:\n        print(count,end="")\n        count += 1\n    print()
# cook your dish here\nextra, less = 0,0\nfor _ in range(int(input())):\n    sli,mem,sma,luc = list(map(int, input().split()))\n    total = sma\n    t = sma\n    while mem > 1:\n        t *= luc\n        total += t\n        mem -= 1\n    if total <= sli:\n        extra += sli-total\n        print('POSSIBLE',sli-total)\n    else:\n        less += total-sli\n        print('IMPOSSIBLE',total-sli)\nif extra >= less:\n    print('POSSIBLE')\nelse:\n    print('IMPOSSIBLE')\n    \n        \n        \n \n
from collections import defaultdict as dd,deque as dq\ndef opbfs(u,vis,ll,parr):\n q=dq([(u,0)])\n uu=u\n su=0\n while q:\n  \n  u,lol=q.pop()\n  par=parr[u]\n  if(lol%2==0):\n   vis[u]=1\n   su+=ll[u-1]\n   ll[u-1]=0\n  for j in d[u]:\n   if(j!=par):\n    q.appendleft((j,lol+1))\n ll[uu-1]=su\ndef bfs(height,d,parr):\n q=dq([1])\n while q:\n  u=q.pop()\n  height[u]=height[parr[u]]+1\n  for i in d[u]:\n   if(i!=parr[u]):\n    q.appendleft(i)\n    parr[i]=u\nt=int(input())\nwhile t:\n n,q=map(int,input().split())\n ll=list(map(int,input().split()))\n d=dd(list)\n for i in range(n-1):\n  u,v=map(int,input().split())\n  d[u].append(v)\n  d[v].append(u)\n vis=[0]*(n+1)\n l=[]\n height=[0]*(n+1)\n parr=[0]*(n+1)\n bfs(height,d,parr)\n for i in range(q):\n  u=int(input())\n  l.append((height[u],u,i))\n l.sort()\n vis=[0]*(n+1)\n #print(l)\n for i in l:\n  he,u,ind=i\n  if(vis[u]==0):\n   #print(u)\n   opbfs(u,vis,ll,parr)\n print(*ll)\n t-=1
d=1000000007\nfor _ in range(int(input())):\n l=sorted(list(map(int,input().split())))\n ans=(l[0]%d)*((l[1]-1)%d)*((l[2]-2)%d)\n print(ans%d)
T=int(input())\nfor i in range(T):\n  n,m=list(map(int,input().split()))\n  if(m<=2):\n    print("impossible")\n  else:\n    l=[0]*m\n\n    if(m%2==0):\n      a=m//2\n    else:\n      a=(m//2)+1\n    for j in range(a):\n      if(j%2==0):\n        l[j]="a"\n        l[m-j-1]="a"\n        \n      else:\n        l[j]="b"\n        l[m-j-1]="b"\n        \n    \n    r=""\n    s=n//m\n    for e in l:\n      r=r+e\n    print(r*s)\n    \n    \n\n
def power(x, y):\n	if y == 0:\n		return 1\n	if y % 2 == 0:\n		return power(x, y // 2) * power(x, y // 2)\n\n	return x * power(x, y // 2) * power(x, y // 2)\n\n\n# Function to calculate order of the number\ndef order(x):\n	# Variable to store of the number\n	n = 0\n	while (x != 0):\n		n = n + 1\n		x = x // 10\n\n	return n\n\n\n# Function to check whether the given\n# number is Armstrong number or not\ndef isArmstrong(x):\n	n = order(x)\n	temp = x\n	sum1 = 0\n\n	while (temp != 0):\n		r = temp % 10\n		sum1 = sum1 + power(r, n)\n		temp = temp // 10\n\n	# If condition satisfies\n	return (sum1 == x)\n\n\n# Driver code\n\nfor _ in range(int(input())):\n	num = int(input())\n	if isArmstrong(num):\n		print("FEELS GOOD")\n	else:\n		print("FEELS BAD")
T = int(input())\nfor _ in range(T):\n n,m = map(int,input().split())\n completed = list(map(int,input().split()))\n jobs = []\n for i in range(1,n+1):\n  if i not in completed:\n   jobs.append(i)\n jobs.sort()\n chef = []\n ass = []\n for i in range(len(jobs)):\n  if i%2==0:\n   chef.append(str(jobs[i]))\n  else:\n   ass.append(str(jobs[i]))\n print(' '.join(chef))\n print(' '.join(ass))
t = int(input())\nwhile(t>0):\n t-=1;\n n,l,r = list(map(int,input().split()));\n a = bin(l)[2:];\n b = bin(r)[2:];\n # find matching\n z = 0;\n l = min(len(a),len(b));\n for i in range(l):\n  if a[i]==b[i]:\n   z+=1;\n  else:\n   break;\n\n #find base string\n a = a[z:]\n b = b[z:]\n if(len(a)==0 and len(b)==0):\n  print(n);\n else :\n  m = max(len(a),len(b))\n  #print m;\n  zz = bin(n)[2:]\n  x= len(zz)\n  y = zz[:x-m]\n  \n  f1 = y+a;\n  f2 = y+b;\n  ans = int(y,2)\n  if(int(f1,2)>n or int(f2,2)>n):\n   ans-=1;\n  \n  print(ans) \n  \n\n  \n
import math\nt = eval(input())\nwhile(t > 0):\n h,s = input().split()\n h = int(h)\n s = int(s)\n if(((h*h*h*h) - (16*s*s)) < 0):\n  print("-1")\n else:\n  B = (math.sqrt((h*h) + math.sqrt((h*h*h*h) - (16*s*s))))/math.sqrt(2)\n  P = (2*s)/B\n  if(B > P):\n   print('{0:.6f}'.format(P),'{0:.6f}'.format(B),'{0:.6f}'.format(h))\n  else:\n   print('{0:.6f}'.format(B),'{0:.6f}'.format(P),'{0:.6f}'.format(h))\n t = t-1
a = [1]\nM = 10**6 + 3\nfor ii in range(1, 1000005):\n a.append((a[-1]*ii)%M)\nfor __ in range(eval(input())):\n n, x = list(map(int, input().split()))\n if n>=M: print(0)\n else: print((a[n]*x)%M)\n
print(0)
from math import log2;\nimport bisect;\nfrom bisect import bisect_left,bisect_right\nimport sys;\nfrom math import gcd,sqrt\nsys.setrecursionlimit(10**7)\nfrom collections import defaultdict\ninf=float("inf")\n# n=int(input())\n# n,m=map(int,input().split())\n# l=list(map(int,input().split()))\ndef get_factors(x):\n if x==1:\n  return [];\n sqrta=int(sqrt(x))+1\n for i in range(2,sqrta):\n  if x%i==0:\n   return [i]+get_factors(x//i)\n return [x]\ndef min_generator(fac,k,index,new_list):\n if index==len(fac):\n  return sum(new_list)\n mina=inf;\n for i in range(0,min(index+1,len(new_list))):\n  new_list[i]*=fac[index]\n  theta=min_generator(fac,k,index+1,new_list)\n  if theta<mina:\n   mina=theta;\n  new_list[i]//=fac[index]\n return mina;\ndef fun(k,x):\n dict=defaultdict(lambda :1)\n factors=get_factors(x)\n for i in factors:\n  dict[i]*=i;\n if len(dict)==k:\n  print(sum(dict.values()))\n  return;\n if len(dict)<k:\n  suma=sum(dict.values())\n  left=k-len(dict)\n  suma+=left;\n  print(suma)\n  return;\n if k==1:\n  print(x)\n  return;\n fac=list(dict.values())\n\n new_list=[1]*k\n theta=min_generator(fac,k,0,new_list)\n print(theta)\nfor i in range(int(input())):\n k,x=map(int,input().split())\n fun(k,x)
# cook your dish here\nfrom collections import namedtuple\n\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\nT = int(input())\nfor _ in range(T):\n    R, C, N = map(int, input().split())\n    Sx, Sy = map(int, input().split())\n    tx = map(int, input().split())\n    ty = map(int, input().split())\n    tel_pairs = list(zip(tx, ty))\n    board = []\n    for _ in range(R):\n        board += [[int(c) for c in input().split()]]\n    \n    def explore(p):\n        next_pos = []\n        for i, (dx, dy) in enumerate(p.pairs):\n            sx, sy = p.cell\n            new_pairs = p.pairs[:i]+p.pairs[i+1:]\n            # case (+, +)\n            px, py = sx + dx, sy + dy\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points+board[px][py], (px, py), new_pairs)]\n            # case (+, -)\n            px, py = sx + dx, sy - dy\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points+board[px][py], (px, py), new_pairs)]\n            # case (-, +)\n            px, py = sx - dx, sy + dy\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points+board[px][py], (px, py), new_pairs)]\n            # case (-, -)\n            px, py = sx - dx, sy - dy\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points+board[px][py], (px, py), new_pairs)]\n        return next_pos\n    \n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n        \n    print(result)  \n
# cook your dish here\nt=int(input())\nfor _ in range(t):\n x1,y1,x2,y2=map(int,input().split())\n x3,y3,x4,y4=map(int,input().split())\n if (x1==x3 and y1==y3)or(x2==x4 and y2==y4):\n  print("yes")\n elif (x1==x4 and y1==y4)or(x2==x3 and y2==y3):\n  print("yes")\n else:\n  if(y1==y2)and(y1==y3)and(y1==y4):\n   a1=max(x1,x2);a2=min(x1,x2)\n   b1=max(x3,x4);b2=min(x3,x4)\n   if a1>=b2 and a2<=b1:\n    print("yes")\n   else:\n    print("no")\n  elif (x1==x2)and(x1==x3)and(x1==x4):\n   a1=max(y1,y2);a2=min(y1,y2)\n   b1=max(y3,y4);b2=min(y3,y4)\n   if a1>=b2 and a2<=b1:\n    print("yes")\n   else:\n    print("no")\n  else:\n   print("no")
for _ in range(int(input())):\n    s = input().strip()\n    a = []\n    last = 0\n    for i in range(len(s)):\n     if s[i] == 'P':\n      a.append(i - last)\n      last = i + 1\n    x = 0\n    a = a[::-1]\n    for v in a[::2]:\n     x ^= v % 3\n    print('Yes' if x else 'No')
MOD = int(1e9+7)\n\ndef mult(a, b):\n rsp = [[0, 0, 0],\n   [0, 0, 0],\n   [0, 0, 0]]\n\n for i in range(3):\n  for j in range(3):\n   for k in range(3):\n    rsp[i][j] += a[i][k] * b[k][j]\n    rsp[i][j] %= MOD\n\n return rsp\n\nident = [[1, 0, 0],\n   [0, 1, 0],\n   [0, 0, 1]]\nm = [[1, 1, 0],\n  [1, 0, 1],\n  [1, 0, 0]]\n\npowers = [m]\nfor _ in range(53):\n p = powers[-1]\n powers.append(mult(p ,p))\n\ndef pow2(e):\n y = ident\n i = 0\n for p in powers:\n  if e & (1 << i):\n   y = mult(p, y)\n  i += 1\n return y\n\nt = eval(input())\n\nfor _ in range(t):\n n = eval(input())\n\n if n < 3:\n  print(0)\n  continue\n\n r = pow(2, n, MOD)\n b = pow2(n - 2)\n # print(b)\n r -= (4 * b[0][0]) % MOD\n r -= (2 * b[1][0]) % MOD\n r -= b[2][0]\n r = (MOD + r) % MOD\n print(r)\n
t=int(input())\nfor i in range(t):\n ans=0\n x,y=list(map(int,input().split()))\n if y>x:\n  if (y-x)%4==0:ans=3\n  elif (y-x)%2==0: ans=2\n  else: ans=1\n if y<x:\n  if (y-x)%2==0:ans=1\n  else: ans=2\n print(ans)\n
t=int(input())\n\nfor _ in range(t):\n n,q=map(int,input().split())\n s=input()\n l=[0]*(n-1)\n for i in range(n-2):\n  a,b,c=s[i],s[i+1],s[i+2]\n  if len(set([a,b,c]))<3:\n   l[i]=l[i-1]+1\n  else:\n   l[i]=l[i-1]\n   \n for i in range(q):\n  left,right=map(int,input().split())\n  left-=1\n  right-=1\n  if right-left+1 <3:\n   print('NO')\n   continue\n  if (l[right-2]-l[left-1])>0:\n   print('YES')\n  else:\n   print('NO')
# cook your dish here\nfor u in range(int(input())):\n n=int(input())\n l=list(map(int,input().split()))\n d=[]\n dd=[]\n s=1\n for i in range(n-1):\n  s=l[i]\n  d.append(s)\n  dd.append([i,i])\n  for j in range(i+1,n):\n   s=s*l[j]\n   d.append(s)\n   dd.append([i,j])\n d.append(l[n-1])\n dd.append([n-1,n-1])\n k=len(d)\n m=max(d)\n x,y=0,0\n for i in range(k):\n  if(d[i]==m):\n   x=dd[i]\n print(m,*x)\n
# cook your dish here\n    \ndef G(x, y): \n   while(y): \n       x, y = y, x % y \n   return x \n# t=int(input())\n# l=list(map(int,input().split()))\nfor _ in range(int(input())):\n    n,p=map(int,input().split())\n\n    c=0\n    for i in range(1,n+1):\n        if G(i,p)==1:\n            c+=1\n    ans=c*(c-1)//2\n    print(ans)
test_case = int(input())\nfor w in range(test_case):\n n, k = map(int,input().split())\n l = list(map(str,input().split()))\n ans = []\n for q in range(k):\n  l2 = list(map(str,input().split()))\n  ans.extend(l2[1:])\n for i in l:\n  if i in ans:\n   print('YES',end=' ')\n  else:\n   print('NO',end=' ')\n print()# cook your dish here\n
# cook your dish here\nnumber = int(input())\nfor i in range(number):\n    a = list(input())\n    for k in range(len(a)):\n        a[k] = eval(a[k])\n    print(sum(a))
\n\nvow = ['a', 'e', 'i','o', 'u']\nfor _ in range(int(input())):\n name = str(input())\n tmp = ''\n for i in range(len(name)):\n  if name[i] not in vow and name[i].isalpha():\n   tmp+='1'\n  elif name[i] in vow and name[i].isalpha():\n   tmp+='0'\n  \n print( int(tmp, 2)% (10**9 + 7))
for t in range(int(input())):\n limakMax, bobMax = list(map(int, input().split()))\n limakEat = 0; bobEat = 0\n eating = 1\n while limakEat <= limakMax or bobEat <= bobMax:\n\n  if eating % 2 != 0 and limakEat <= limakMax:\n   limakEat += eating\n   eating += 1\n   if limakEat > limakMax:\n    print("Bob")\n    break\n  elif eating % 2 == 0 and bobEat <= bobMax:\n   bobEat += eating\n   eating += 1\n   if bobEat > bobMax:\n    print("Limak")\n    break\n\n
import sys\n\ndef input():    return sys.stdin.readline().strip()\ndef iinput():   return int(input())\ndef rinput():   return list(map(int, sys.stdin.readline().strip().split())) \ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\n\n\nt=iinput()\n\nfor _ in range(t):\n n=iinput()\n p=[]\n mi=[]\n for i in range(n):\n  x,y=rinput()\n  p.append(x+y)\n  mi.append(x-y)\n\n p.sort()\n mi.sort()\n m=float('inf')\n for i in range(1,n):\n  if(p[i]-p[i-1]<m):\n   m=p[i]-p[i-1]\n  if(mi[i]-mi[i-1]<m):\n   m=mi[i]-mi[i-1]\n\n if m%2==0:\n  print(m//2)\n else:\n  print(m/2)\n
t=int(input())\nfor i in range(t):\n a,k=list(map(int,input().split()))\n x1,x2,x3=list(map(int,input().split()))\n big=max(x1,x2,x3)\n small=min(x1,x2,x3)\n q=big-small-2*k\n \n if q>=a:\n  print(0)\n elif -1*q>=0:\n  print(a*a)\n else:\n  print(a*(a-q))\n
#\n\nfor _ in range(int(input())):\n n,k = list(map(int,input().split()))\n arr = list(map(int,input().split()))\n s=set(arr)\n t1=len(s)\n max=-1\n for i in range(n-k+1):\n  temp=set(arr[i:i+k])\n  #print(temp,i,k+i+1)\n  t=len(temp)\n  if t1 == t:\n   if max<sum(arr[i:k+i]):\n    max=sum(arr[i:k+i])\n print(max)\n
# cook your dish here\nt=int(input())\nfor j in range(t):\n    s=input()\n    st=[]\n    ans=0\n\n    for i in range(len(s)):\n        \n        if(s[i]=='>'):\n            if(len(st)!=0 and st[-1]=='<'):\n                st.pop()\n                if(len(st)==0):\n                    ans=i+1\n            else:\n                break\n\n        else:\n            st.append('<')\n\n    print(ans)\n
# cook your dish here\nt=int(input())\nfor i in range(0,t):\n    my_ip = int(input().strip())\n    for xyz in range(my_ip+1):\n        for abc in range(0,xyz+1):\n            if abc == xyz:\n                print(xyz,end="")\n            else:\n                print('*',end="")\n\n        print()
from collections import deque \r\nT=int(input())\r\ndef break_down(num):\r\n    count=0\r\n    while(len(num)!=1):\r\n        temp=0\r\n        for i in range(0,len(num)):\r\n            temp=temp+int(num[i])\r\n        num=str(temp)\r\n        count=count+1\r\n    return (int(num),count)\r\ndef digit_sum(num):\r\n    temp=0\r\n    for i in range(0,len(num)):\r\n        temp=temp+int(num[i])\r\n    num=temp\r\n    return (num)\r\nwhile(T):\r\n queue=deque()\r\n count_n=0\r\n count_d=0\r\n T=T-1\r\n N,d=[i for i in input().split()]\r\n n,count_n=break_down(N)\r\n D,count_D=break_down(d)\r\n dic={}\r\n if(D==1 or D==2 or D==4 or D==5 or D==7 or D==8):\r\n     mini=1 \r\n elif(D==3 or D==6):\r\n     mini=min(digit_sum(str(n+3)),digit_sum(str(n+6)),digit_sum(str(n+9)))\r\n else:\r\n     mini=n\r\n queue.append((int(N),0))\r\n ele=int(N)\r\n count=0\r\n while(len(queue)!=0):\r\n     ele,count=queue.popleft()\r\n     if(ele==mini):\r\n         break\r\n     else:\r\n         if(len(str(ele))==1):\r\n             temp1=ele+int(d)\r\n             queue.append((temp1,count+1))\r\n         else:\r\n             temp2=digit_sum(str(ele))\r\n             temp1=ele+int(d)\r\n             queue.append((temp2,count+1))\r\n             queue.append((temp1,count+1))\r\n print(ele,count)
# cook your dish here\nfor _ in range(int(input())):\n    n=int(input())\n    A=list(map(int,input().split()))\n    A.sort()\n    for i in range(len(A)):\n        if A[i]==1:\n            print(i)\n            break
test=int(input())\nfor i in range(test):\n    s=input()\n    b=len(s)\n    list1=[]\n    for j in range(len(s)):\n        if s[j]=='.':\n            list1.append(j)\n    for i in list1:\n        if b-i-1 in list1 :\n            if i!=b-i-1 and ((s[i] and s[b-i-1]) != 'a' ):\n                s=s[:i]+'a'+s[i+1:b-i-1]+'a'+s[b-i:]\n            else:\n                s=s[:i]+'a'+s[i+1:]\n        else:\n            s=s[:i]+s[b-i-1]+s[i+1:]\n\n    if s==s[::-1]:\n        print(s)\n    else:\n        print(-1)\n\n        
# cook your dish here\r\nm,n=[int(i) for i in input().split()]\r\narr=list(map(int,input().split()))\r\narr=sorted(arr,reverse=True)\r\nans=0\r\nw=0\r\nq=m\r\nfor m in range(q):\r\n    if(arr[m]>n):\r\n        w=1\r\n        break \r\n    ans+=1+(arr[m]*(arr[m]+1))//2\r\n    n-=arr[m]\r\n\r\nif(n==0):\r\n    print(ans)\r\nelse:\r\n    if(w==1):\r\n        print(ans+q-m+(n*(n+1))//2)\r\n    else:\r\n        print(ans)
n=int(input())\nfor i in range(n):\n    a,b,c=map(int,input().split())\n    if a>0 and b>0 and c>0 and a+b+c==180:\n        print("YES")\n    else:\n        print("NO")
import math\n\ndef magic(a,digits):\n    m=a%10\n    if(m==4):\n        return a+3\n    elif(m==7):\n        p=list(str(a))\n        #print p\n        for i in range(digits-1,-1,-1):\n            #print p[i]\n            if (p[i]=='4'):\n                #print 'four'\n                p[i]='7'\n                p = ''.join(str(n) for n in p)\n                return int(p)\n            if ((p[i]=='7')&(i==0)):\n                #print 'seven'\n                p[i]='4'\n                p.insert(0,4)\n                p = ''.join(str(n) for n in p)\n                return int(p)\n\n            if(p[i]=='7'):\n                #print 'seven only'\n                p[i]='4'\n            \n            #print p[i]\n        \n        \n        \n\nt=eval(input())\n\nn=[]\nop=[]\n\nfor i in range(0,t):\n    n.append(eval(input()))\n\nfor i in range(0,t):\n    digits = int(math.log10(n[i]))+1\n    #print digits\n    op.append(magic(n[i],digits))\n    \n#for i in range(0,t):\n    #print n[i]\n\nfor i in range(0,t):\n    print(op[i])\n\n\n\n  \n
# cook your dish here\nt=int(input())\nfor i in range(0,t):\n    p=input()\n    l=list(p)\n    for j in range(0,len(l)):\n        l[j]=int(l[j])\n        l[j]=l[j]-2\n    for j in range(0,len(l)):\n        l[j]=str(l[j])\n    q=''.join(l)\n    print(q)
n = int(input())\na = []\nfor i in range(n):\n a.append(int(input()))\nm1 = 0\nm2 = 0\nfor e in a:\n if (e > m1):\n  m2 = m1\n  m1 = e\n elif (e > m2 and e != m1):\n  m2 = e\nans = 0\nfor e in a:\n temp = m1%e\n if (temp>ans):\n  ans = temp\nprint(max(m2%m1,ans))
def countSubstr(str, n, x, y): \r\n  \r\n    tot_count = 0\r\n  \r\n    count_x = 0\r\n  \r\n    for i in range(n):  \r\n        if str[i] == x: \r\n            count_x += 1\r\n        if str[i] == y: \r\n            tot_count += count_x \r\n    return tot_count \r\n  \r\nt=int(input())\r\nfor _ in range(t):\r\n    n=int(input())\r\n    str=input()\r\n    x='0'\r\n    y='1'\r\n    x1='1'\r\n    y1='0'\r\n    c1=countSubstr(str,n,x,y)\r\n    c2=countSubstr(str,n,x1,y1)\r\n    print(c1+c2)
# cook your dish here\ndef value(a, b, c):\n    if(c == '&'):\n        return a&b\n    elif(c == '^'):\n        return a^b\n    elif(c == '|'):\n        return a|b\n\ndef break_rules(n, operator):\n    if(len(n) == 1):\n        return n\n    elif(len(n) == 2):\n        return [value(n[0], n[1], operator[0])]\n    else:\n        cont_ans = []\n        for i in range(1,len(n)):\n            l1 = n[:i]\n            l2 = n[i:]\n            o1 = operator[:i]\n            o2 = operator[i:]\n            l1_ans = break_rules(l1, o1)\n            l2_ans = break_rules(l2, o2)\n            for k in l1_ans:\n                for j in l2_ans:\n                    cont_ans.append(value(k, j, operator[i - 1]))\n    return cont_ans\n\nt = int(input())\nwhile t > 0 :\n    operator = []\n    num = []\n    exp = input()\n    temp = ''\n    for i in range(len(exp)):\n        if(ord(exp[i]) > 47 and ord(exp[i]) < 58):\n            temp = temp + exp[i]\n        else:\n            num.append(int(temp))\n            temp = ''\n            operator.append(exp[i])\n        if(i == len(exp) - 1):\n            num.append(int(temp))\n    t -= 1\n    # print(num,operator)\n    print(max(break_rules(num, operator)))
# cook your dish here\ndef read_i_l(l=False):\n    m = list(map(int, input().strip().split(" ")))\n    if l:\n        return list(m)\n    else:\n        return m\ndef i():\n    return int(input().strip())\nT = i()\nL = []\n"""for current in range(T):\n    line = ""\n    for i in range(current):\n        line+=str((T-i)%10)\n    for i in range(2*(T-current)-1):\n        line+=str((T-current)%10)\n    for i in range(current-1,-1,-1):\n        line+=str((T-i)%10)\n    L.append(line)\nL += L[-2::-1]"""\n\nif T >= 1:\n    L = ["1"]\n\nfor i in range(2,T+1):\n    nL = [str(i)+(2*i-2)*(" "+str(i))]\n    for l in L:\n        nL.append(str(i)+" "+l+" "+str(i))\n    nL.append(str(i)+(2*i-2)*(" "+str(i)))\n    L = nL\nfor l in L:\n    print(l)\n
number = int(input())\nfor i in range(number):\n    x = list(map(int, input().split(' ')))\n    print(x[0]%x[1])
from math import gcd\nimport sys\ninput=lambda : sys.stdin.readline().strip()\nc=lambda x: 10**9 if(x=="?") else int(x)\ndef main():\n for _ in range(int(input())):\n  s=list(input())[::-1]\n  l=['F','E','H','C']\n  i=0\n  while(i<len(s)):\n   if(i+3<len(s)):\n    f=True\n    for j in range(i,i+4):\n     if(l[j-i]==s[j] or s[j]=='?'):\n      pass\n     else:\n      f=False\n      break\n    if(f):\n     for j in range(i,i+4):\n      s[j]=l[j-i]\n    if(s[i]=="?"):\n     s[i]='A'\n   else:\n    if(s[i]=="?"):\n     s[i]="A"\n   i+=1\n  print(*s[::-1],sep='')\n\n   \n\nmain()
# cook your dish here\nfor a in range(int(input())):\n    N,M=map(int,input().split())\n    b=[]\n    for o in range(N):\n     b.append(input())\n    c=[]\n    for d in b:\n     f=[]\n     for e in range(len(d)):\n      if d[e]=='1':\n       f.append(e)\n     c.append(f)\n    i=[]\n    for g in range(len(c)):\n     for h in range(len(c[g])):\n      for j in range(len(c)):\n       for k in range(len(c[j])):\n        if (j>g) or(j==g and k>h):\n         if c[g][h]-c[j][k]>=0:\n          i.append(c[g][h]-c[j][k]+j-g)\n         else:\n          i.append(-1*(c[g][h]-c[j][k])+j-g)\n    l=[m for m in range(1,N+M-1)]\n    for n in l:\n     print(i.count(n),end=' ')
for _ in range(int(input())):\n n=input().rstrip()\n n=[ele for ele in n]\n l=len(n)\n m=10**18+8\n ini=1\n for i in range(l-1,-1,-1):\n  if int(n[i])<=m:\n   if ini==1:\n    m=int(n[i])\n   else:\n    m=max(m,n[i])\n  else:\n   m=int(n[i])-1\n   n[i]=str(m)\n   for j in range(l-1,i,-1):\n    n[j]='9'\n   \n i=0\n while n[i]=='0':\n  i+=1\n print("".join(n[i:]))\n   \n
# Fibonacci Series using \r\n# Optimized Method \r\n\r\n# function that returns nth \r\n# Fibonacci number\r\nMOD = 1000000007\r\ndef fib(n):\r\n    F = [[2, 2],\r\n         [1, 0]]\r\n    power(F, n - 1)\r\n    ans = [6, 2]\r\n    return (F[0][0] * 6 + F[0][1] * 2) % MOD\r\n    # return F[0][0]\r\n\r\n\r\ndef multiply(F, M):\r\n    x = (F[0][0] * M[0][0] +\r\n         F[0][1] * M[1][0]) % MOD\r\n    y = (F[0][0] * M[0][1] +\r\n         F[0][1] * M[1][1]) % MOD\r\n    z = (F[1][0] * M[0][0] +\r\n         F[1][1] * M[1][0]) % MOD\r\n    w = (F[1][0] * M[0][1] +\r\n         F[1][1] * M[1][1]) % MOD\r\n\r\n    F[0][0] = x\r\n    F[0][1] = y\r\n    F[1][0] = z\r\n    F[1][1] = w\r\n\r\n\r\ndef power(F, n):\r\n    if n == 0 or n == 1:\r\n        return\r\n    M = [[2, 2],\r\n         [1, 0]]\r\n\r\n    power(F, n // 2)\r\n    multiply(F, F)\r\n\r\n    if n % 2 != 0:\r\n        multiply(F, M)\r\n\r\n\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    ans = 1\r\n    if n == 0:\r\n        ans = 1\r\n    elif n == 1:\r\n        ans = 2\r\n    elif n == 2:\r\n        ans = 6\r\n    else:\r\n        ans = fib(n-1)\r\n    print(ans)\r\n
# cook your dish here\nt=int(input())\nfor _ in range(t):\n N, M=map(int,input().split())\n if(N%2==0 or M%2==0):\n  print("YES")\n else:\n  print("NO")
#Note that it's python3 Code. Here, we are using input() instead of raw_input().\n#You can check on your local machine the version of python by typing "python --version" in the terminal.\n\n#Read the number of test cases.\nT = int(input())\nfor tc in range(T):\n	# Read integers a and b.\n	(a, b) = list(map(int, input().split(' ')))\n	\n	ans = a + b\n	print(ans)
# cook your dish here\n# cook your dish here\nclass Animal:\n    def __init__(self):\n        start, end, starting_time = map(int, input().split())\n        \n        self.ending_time = starting_time + abs(start - end)\n        self.velocity = 1 if end >= start else -1 \n        \n        self.eaten_by = -1, 10 ** 10\n        \n        self.start = start \n        self.end = end \n        self.starting_time = starting_time \n        \n    def will_collide(self, z):\n        if self.starting_time > z.ending_time or self.ending_time < z.starting_time:\n            return False \n            \n        if self.velocity == z.velocity:\n            if self.starting_time > z.starting_time:\n                self, z = z, self\n            if z.start == self.start + self.velocity * (z.starting_time - self.starting_time):\n                return z.starting_time\n            else:\n                return False\n        \n        if self.velocity == -1:\n            self, z = z, self\n        \n        t = ( z.start - self.start + z.starting_time + self.starting_time ) / 2 \n         \n        return t if self.starting_time <= t <= self.ending_time and z.starting_time <= t <= z.ending_time else False\n                \n        \n        \ndef main():\n    for _ in range(int(input())):\n        no_cats, no_rats = map(int, input().split())\n        \n        Cats = [Animal() for i in range(no_cats)]\n        \n        for i in range(no_rats):\n            rat = Animal() \n            for j in range(no_cats):\n                time = rat.will_collide(Cats[j])\n                if time:\n                    # print(time)\n                    if time < rat.eaten_by[1]:\n                        rat.eaten_by = j + 1, time \n                    \n                \n            print(rat.eaten_by[0])\n                \n                \n            \nmain()\n        
# cook your dish here\nt=int(input())\nwhile t>0:\n    n,q=list(map(int,input().split()))\n    blst=[0]\n    for i in range(1,65):\n        blst.append(0)\n    i=1\n    while n>0:\n        if n%2:\n            blst[i]=1\n        n//=2\n        i+=1\n    while q>0:\n        n=int(input())\n        if n==1:\n            p=int(input())\n            if blst[p]:\n                print('ON')\n            else:\n                print('OFF')\n        elif n==2:\n            p=int(input())\n            if blst[p]==0:\n                blst[p]=1\n        elif n==3:\n            p=int(input())\n            if blst[p]==1:\n                blst[p]=0\n        else:\n            p,r=list(map(int,input().split()))\n            if blst[p]!=blst[r]:\n                blst[p]+=1\n                blst[p]%=2\n                blst[r]+=1\n                blst[r]%=2\n        q-=1\n    t-=1\n
t=int(input())\nfor i in range(t):\n n=int(input())\n r=int(n**(.5))\n d=n-r*r\n m=d%r\n print('X'*m+'D'*(m>0)+'X'*(r-m)+'D'*(r+d//r))\n
import sys\ndef fin(): return sys.stdin.readline().strip()\ndef fout(s, end="\n"): sys.stdout.write(str(s)+end)\n\nMOD = pow(10, 9)+7\nt = int(input())\nwhile t>0:\n t -= 1\n n, m = list(map(int, fin().split()))\n if n == 1:\n  print(m%MOD)\n  continue\n dp1 = m*(m-1)\n dp2 = m\n for i in range(3, n+1):\n  temp = dp2\n  dp2 = dp1 \n  dp1 = (temp*(m-1))%MOD+(dp1*(m-1))%MOD\n print((dp1+dp2)%MOD)\n\n \n\n
# cook your dish here\nt=int(input())\nj=0\nwhile j<t:\n    n=int(input())\n    lst=list(map(int,input().split()))\n    s=set()\n    d=list()\n    for i in lst:\n        if i in s:\n            s.remove(i)\n            d.append(i)\n        else:\n            s.add(i)\n    x=len(d)\n    if x%2==0:\n        print(x//2)\n    else:\n        print((x-1)//2)\n    j+=1
gb = [0, 1, 2, 2, 3, 3]\nga = [0 for x in range(70)]\ngag = [0 for x in range(70)]\nga[0] = 1\ngag[0] = 0\n\nfor i in range(1, 70):\n if i % 4 == 0:\n  ga[i] = 1.5 * ga[i-1]\n  gag[i] = 0\n else:\n  ga[i] = 2 * ga[i-1]\n  gag[i] = gag[i-1] + 1\n\n\ndef g(n):\n if n < 6:\n  return gb[n]\n else:\n  x = n / 6\n  a = 0\n  for i, k in enumerate(ga):\n   if k <= x:\n    a = i\n   else:\n    break\n  return gag[a]\n\n\nt = int(input())\nfor q in range(t):\n n = int(input())\n a = list(map(int, input().split()))\n\n res = g(a[0])\n for i in range(1, n):\n  res ^= g(a[i])\n\n if res == 0:\n  print("Derek")\n else:\n  print("Henry")\n
# cook your dish here\nclass TestCase:\n    def __init__(self):\n        [self.node_count, self.query_count] = read_line()\n        \n    def fill_nodes(self):\n        self.nodes = {n+1: [] for n in range(self.node_count)}\n        for i in range(self.node_count -1):\n            new_node_1, new_node_2 = read_line()\n            self.nodes[new_node_1].append(new_node_2)\n            self.nodes[new_node_2].append(new_node_1)\n            \n    def resolve_query(self, query):\n        a, d_a, b, d_b = query\n        suiting_a = self.find_nodes_with_distance(a, d_a)\n        suiting_b = self.find_nodes_with_distance(b, d_b)\n        fitting = [node for node in suiting_a if node in suiting_b]\n        \n        if len(fitting) == 0:\n            return -1\n        else:\n            return fitting[0]\n        \n    def find_nodes_with_distance(self, start_node, distance):\n        from_nodes = {start_node}\n        passed_nodes = from_nodes\n        \n        for i in range(distance):\n            to_nodes = set()\n            # add all adjacent nodes\n            for node in from_nodes:\n                to_nodes.update(self.nodes[node])\n            \n            # no backtracking\n            for node in passed_nodes:\n                if node in to_nodes:\n                    to_nodes.remove(node)\n            \n            # update which nodes are passed\n            passed_nodes.update(to_nodes)\n            # go another round with the new nodes found\n            from_nodes = to_nodes\n        return list(from_nodes)\n\ndef read_line():\n    line = input()\n    return [int(s) for s in line.split(' ')]\n\nnum_testcases = int(input())\nfor i in range(num_testcases):\n    testcase = TestCase()\n    testcase.fill_nodes()\n    for q in range(testcase.query_count):\n        query = read_line()\n        print(testcase.resolve_query(query))
t = int(input())\n\nfor i in range(t):\n    n = int(input())\n    dir = []\n    \n    for j in range(n):\n        dir.append(input().strip().split())\n  \n    for j in range(n-1):\n        if dir[j+1][0] == 'Right':\n            dir[j][0] = 'Left'\n        else:\n            dir[j][0] = 'Right'\n\n    dir[n-1][0] = 'Begin'\n\n    for j in reversed(dir):\n        print(' '.join(j))\n\n\n        \n
t=int(input())\nfor i in range(t):\n n,w1,w2,w3=map(int,input().split())\n if n>=w1+w2+w3:\n  print(1)\n elif n>=w1+w2 or n>=w2+w3:\n  print(2)\n else:\n  print(3)
# cook your dish here\nx=int(input())\nfor i in range(x):\n    h=input()\n    print(h.count('4'))\n
def res(s):\n if len(s) == 2:\n  if s[0] == s[1]:\n   print("NO")\n  else:\n   print("YES")\n\n elif s[0] != s[1]:\n  counte = 0\n  for i in range(2, len(s)):\n   if i % 2 == 0:\n    if s[i] != s[0]:\n     counte = 1\n     break\n   else:\n    if s[i] != s[1]:\n     counte = 1\n     break\n\n  if counte == 0:\n   print("YES")\n  else:\n   print("NO")\n else:\n  print("NO")\n\n\ndef __starting_point():\n t = int(input())\n for _ in range(t):\n  stri = str(input())\n  res(stri)\n__starting_point()
# cook your dish here\nimport string \nfrom collections import OrderedDict\nfrom itertools import zip_longest\ndic = OrderedDict(zip(string.ascii_uppercase, range(0, 26)))\nkeys = [98, 57, 31, 45, 46]\nt = int(input()) # number of test cases\ns1 = []\nfor i in range(t):\n  s = input()\n  for i in s:\n    if i in dic.keys():\n      s1.append(int(i.replace(i, str(dic[i]))))\n  s2 = [sum(t) for t in zip_longest(s1, keys, fillvalue=0)]\n  inv_dic = {v:k for k,v in dic.items()}\n  s_1 = list()\n  for i in range(len(s1)):\n    s_1.append(s2[i]%26)\n  res= [inv_dic[i] for i in s_1]\n  print(''.join(res))\n  inv_dic.clear()\n  res.clear()\n  s1.clear()\n  s2.clear()\n  s_1.clear()
counter = -1\r\ndef flattree(node):\r\n    nonlocal counter\r\n    if visited[node]==1:\r\n        return\r\n    else:\r\n        visited[node]=1\r\n        counter += 1\r\n        i_c[node] = counter\r\n\r\n        flat_tree[counter] = swt[node]\r\n\r\n        for i in graph[node]:\r\n            if visited[i]==0:\r\n                flattree(i)\r\n        counter += 1\r\n        o_c[node] = counter\r\n        flat_tree[counter] = -swt[node]\r\n    return\r\n\r\n\r\ndef getsum(BITTree, i):\r\n    s = 0  # initialize result\r\n    i = i + 1\r\n    while i > 0:\r\n        s += BITTree[i]\r\n        i -= i & (-i)\r\n    return s\r\n\r\ndef upd(BITTree, n, i, v):\r\n    i += 1\r\n    while i <= n:\r\n        BITTree[i] += v\r\n        i += i & (-i)\r\n\r\ndef construct(arr, n):\r\n    BITTree = [0] * (n + 1)\r\n    for i in range(n):\r\n        upd(BITTree, n, i, arr[i])\r\n    return BITTree\r\n\r\nfrom collections import defaultdict\r\nn = int(input())\r\nswt = list(map(int, input().split()))\r\ngraph = defaultdict(list)\r\n\r\nfor i in range(n-1):\r\n    n1, n2 = list(map(int, input().split()))\r\n    graph[n1-1].append(n2-1)\r\n    graph[n2-1].append(n1-1)\r\n\r\nflat_tree = [0]*(2*n+1)\r\ni_c = [0]*n\r\no_c = [0]*n\r\nvisited = [0]*n\r\nflattree(0)\r\n\r\ntre = construct(flat_tree, 2*n)\r\n\r\nq = int(input())\r\nfor i in range(q):\r\n    query = list(map(int, input().split()))\r\n    if query[0] == 1:\r\n        node = query[1] - 1\r\n        answer = getsum(tre, i_c[node])\r\n        print(answer)\r\n    else:\r\n        node = query[1]-1\r\n        upd(flat_tree, (2*n), i_c[node], query[2])\r\n        upd(flat_tree, (2*n), o_c[node], -query[2])\r\n
for i in range(eval(input())):\n n,m,z,l,r,b = list(map(int, input().split()))\n rows=n\n columns=m\n hand_rest=n*(m+1)\n if(m%2==0):\n  hand_rest -=max(0,n-l-r)\n if(l+r+(2*b)<=hand_rest):\n  # print "kanu"\n  print(min(n*m,l+r+z+b))\n else:\n  temp=l+r+(hand_rest-l-r)/2\n  # print "parth"\n  print(min(n*m,temp+z))
# cook your dish here\ns=input()\ns1=s[::-1]\narr=[]\ncnt=0\nfor i in range(len(s1)):\n arr.append(s1[i])\nfor i in range(len(arr)):\n if(arr[i]=="1"):\n  for j in range(i,len(arr)):\n   if(arr[j]=="1"):\n    arr[j]="0"\n   else:\n    arr[j]="1"\n  cnt+=1\nprint(cnt)
d = {}\nfor i in range(26):\n char = chr(i+ord('a'))\n d[char] = []\nfor i in range(26):\n char = chr(i+ord('a'))\n temp = list(map(int,input().strip().split()))\n for j in range(26):\n  if (temp[j] == 1):\n   follow= chr(j+ord('a'))\n   d[follow].append(char)\n   \ndef f(char,i,n,count):\n if (i==n):\n  return count+1\n else:\n  ans = 0\n  for c in d[char]:\n   ans+=f(c,i+1,n,0)\n   ans%=(10**9+7)\n  return ans\n\nfor q in range(int(input().strip())):\n c, n = input().strip().split()\n n = int(n)\n print(f(c,1,n,0))
# cook your dish here\nmod = 10**9 + 7\nfrom math import gcd\ndef fac50():\n    f = [0]*51\n    f[0] ,f[1] = 1,1\n    for i in range(1,51):f[i] = (f[i-1]*i)%mod\n    return f\ndef gcd110():\n    gc = [[0]*111 for i in range(111)]\n    for i in range(111):\n        for j in range(111):gc[i][j] = gcd(i,j)\n    return gc\nfactorials,gcds = fac50(),gcd110()\ndef rule_asc(n,l):\n    a,k = [0 for i in range(n + 1)],1\n    a[1] = n\n    while k != 0:\n        x,y = a[k - 1] + 1,a[k] - 1 \n        k -= 1\n        while x <= y and k < l - 1:\n            a[k],y = x,y-x\n            k += 1\n        a[k] = x + y\n        yield a[:k + 1]\ndef niceness(s):\n    t = 0\n    for i in range(len(s)):\n        for j in range(i+1,len(s)):t = (t + gcds[s[i]][s[j]])%mod\n    return t\ndef permcount(s,c):\n    f,p = [s.count(x) for x in set(s)],factorials[c] \n    for e in f:p = (p*pow(factorials[e],mod-2,mod))%mod\n    return p\ndef main():\n    for i in range(int(input())):\n        n,s = [int(item) for item in input().split()]\n        a = [int(item) for item in input().split()]\n        b = [i for i in a if i != -1]\n        s , ones = s - sum(b),a.count(-1)         \n        if s < 0:print(0)\n        elif (s == 0 and ones == 0):print(niceness(a)%mod)\n        elif (s > 0 and ones == 0):print(0)\n        else:\n            t = 0\n            for seq in rule_asc(s,ones):\n                if len(seq) == ones: t = (t + (((permcount(seq,ones))%mod)*(niceness(b+seq)%mod))%mod)%mod\n            print(t)         \ndef __starting_point():main()\n__starting_point()
#!/usr/bin/env python\n\ndef iscycle(E, v, EXPLORED_NODES, EXPLORED_EDGES):\n EXPLORED_NODES.add(v)\n r = False\n for e in [x for x in E if v in x]:\n  if e in EXPLORED_EDGES: continue\n  if e[0] == v: w = e[1]\n  else:         w = e[0]\n  if w in EXPLORED_NODES:\n   return True\n  else:\n   EXPLORED_EDGES.add(e)\n   r = r or iscycle(E, w, EXPLORED_NODES, EXPLORED_EDGES)\n   if r: break\n return r\n\ndef process(E):\n return iscycle(E, 1, set(), set()) and 'NO' or 'YES'\n\ndef main():\n N, M = list(map(int, input().split()))\n E = []\n for m in range(M):\n  U, V = list(map(int, input().split()))\n  if U > V: U, V = V, U\n  E.append((U, V))\n print(process(E))\n\nmain()\n\n
t=int(input())\nwhile(t):\n s=input().split()\n m=int(s[0])\n p=float(s[1])\n if(m%2==0):\n  r=(1-p**m)/(p+1)\n else:\n  r=(1+p**m)/(p+1)\n print(1000000000*r,1000000000*(1-r))\n t-=1
def dfs(node):\n nonlocal adj,leaf\n val=0\n flag=0\n for i in adj[node]:\n  x= dfs(i)\n  val+=x\n  if x==0:\n   flag=1\n leaf+=val-val%3\n if val%3==0 and flag==0:\n  return 1\n else:\n  return 0\nfor _ in range(int(input())):\n n=int(input())\n adj=[[] for i in range(n+2)]\n arr=[int(i) for i in input().split()]\n leaf=0\n #print(adj)\n for i in range(2,n+1):\n  #print(i,arr[i-2])\n  adj[arr[i-2]].append(i)\n  \n dfs(1)\n print(n-leaf)
# cook your dish here\n\nimport collections\n\ndef shortestSubarray(A, K):\n  \n  \n  N = len(A)\n  P = [0]\n\n  for x in A:\n   P.append(P[-1] + x)\n\n  #Want smallest y-x with Py - Px >= K\n  ans = N+1 # N+1 is impossible\n  monoq = collections.deque() #opt(y) candidates, represented as indices of P\n  for y, Py in enumerate(P):\n   #Want opt(y) = largest x with Px <= Py - K\n   if not monoq: \n    if Py>=K: return 1\n   while monoq and Py <= P[monoq[-1]]:\n    monoq.pop()\n\n   while monoq and Py - P[monoq[0]] >= K:\n    ans = min(ans, y - monoq.popleft())\n\n   monoq.append(y)\n\n  return ans if ans < N+1 else -1\n  \n  \nfor t in range(int(input())):\n N, D = [int(x) for x in input().split()]\n \n A = [int(x) for x in input().split()] \n \n print(shortestSubarray(A, D))\n \n
# cook your dish here\nimport math\ndef isPos(num):\n if num%2==0:\n  for i in range(num,2*num,1):\n   if ((num**2)-((i/2)**2))**(1/2)==int(((num**2)-((i/2)**2))**(1/2)):\n    return 'YES'\n  return 'NO'\n else:\n  for i in range(num+1,2*num,1):\n   if ((num**2)-((i/2)**2))**(1/2)==int(((num**2)-((i/2)**2))**(1/2)):\n    return 'YES'\n  return 'NO'\n\ntest = int(input())\nfor __ in range(test):\n num=int(input())\n print(isPos(num))\n
# cook your dish here\nt=int(input())\nfor i in range(t):\n (n,k,e,m)=tuple(map(int,input().split()))\n scores=[]\n for j in range(n-1):\n  scores.append(sum(list(map(int,input().split()))))\n scores.sort(reverse=True);\n bsc=scores[k-1];\n msc=sum(list(map(int,input().split())))\n mini=bsc-msc+1\n if(mini<0):\n  print(0)\n elif(mini>m):\n  print("Impossible")\n else:\n  print(mini)\n
# # # # n = int(input())\r\n# # # # arr = list(map(int , input().split()))\r\n# # # # for _ in range(int(input())):\r\n# # # # 	l,r,mod = map(int , input().split())\r\n# # # # 	pro = 1\r\n# # # # 	for i in range(l - 1,r):\r\n# # # # 		pro *= arr[i]\r\n# # # # 	print(pro % mod) #sample testcases passed #TLE\r\n# # # import numpy #or use math\r\n# # # n = int(input())\r\n# # # arr = list(map(int , input().split()))\r\n# # # for _ in range(int(input())):\r\n# # # 	l,r,mod = map(int , input().split())\r\n# # # 	print(numpy.prod(arr[l - 1:r]) % mod) #sample cases passed, WA\r\n# # import math\r\n# # primes,dic,t = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97],{},0\r\n# # for i in primes:\r\n# #     dic[i] = t\r\n# #     t += 1\r\n# # def primeFactors(n,arr): \r\n# #     for i in range(2,int(math.sqrt(n)) + 1,2): \r\n# #         while(n % i == 0): \r\n# #             arr[dic[i]] += 1 \r\n# #             n /= i\r\n# #     if(n > 2):\r\n# #         arr[dic[n]] += 1\r\n# #     return arr\r\n# # n = int(input())\r\n# # A = list(map(int , input().split()))\r\n# # dp = [0]*len(primes)\r\n# # for i in range(1,n + 1):\r\n# #     r = [dp[i - 1]].copy()\r\n# #     dp.append(primeFactors(A[i - 1],r))\r\n# # for _ in range(int(input())):\r\n# #     li,ri,m=list(map(int,input().split()))\r\n# #     ans = 1\r\n# #     for i in range(len(primes)):\r\n# #         ans *= (pow(primes[i],dp[ri][i] - dp[li - 1][i],m)) % m\r\n# #     print(ans % m) #NZEC\r\n# import math\r\n# primes=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\r\n# dic={}\r\n# t=0\r\n# for i in primes:\r\n#     dic[i]=t\r\n#     t+=1\r\n# def primeFactors(n,arr): \r\n#     while(n % 2 == 0):\r\n#         arr[dic[2]] += 1 \r\n#         n /= 2\r\n#     for i in range(3,int(math.sqrt(n))+1,2): \r\n#         while(n % i == 0): \r\n#             arr[dic[i]] += 1 \r\n#             n /= i\r\n#     if(n > 2): \r\n#         arr[dic[n]] += 1\r\n#     return arr\r\n# N = int(input())\r\n# A = list(map(int , input().split()))\r\n# dp = [[0]*len(primes)]\r\n# for i in range(1,N + 1):\r\n#     r = dp[i - 1].copy()\r\n#     dp.append(primeFactors(A[i - 1],r))\r\n# for _ in range(int(input())):\r\n#     l,r,m = list(map(int , input().split()))\r\n#     ans = 1\r\n#     for i in range(len(primes)):\r\n#         ans *= (pow(primes[i],dp[r][i] - dp[l - 1][i],m)) % m\r\n#     print(ans % m)\r\nimport sys \r\nimport math\r\ninput = sys.stdin.readline\r\nprimes=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\r\ndic={}\r\nt=0\r\nfor i in primes:\r\n    dic[i]=t\r\n    t+=1\r\ndef primeFactors(n,arr): \r\n    while n % 2 == 0: \r\n        arr[dic[2]]+=1 \r\n        n = n / 2\r\n\r\n    for i in range(3,int(math.sqrt(n))+1,2): \r\n        while n % i== 0: \r\n            arr[dic[i]]+=1 \r\n            n = n / i \r\n\r\n    if n > 2: \r\n        arr[dic[n]]+=1\r\n    return arr\r\ndef main():\r\n    N=int(input())\r\n    A=list(map(int,input().split()))\r\n    tp=[0]*len(primes)\r\n    dp=[]\r\n    dp.append(tp)\r\n    for i in range(1,N+1):\r\n        # print(i)\r\n        r=dp[i-1].copy()\r\n        t=primeFactors(A[i-1],r)\r\n        dp.append(t)\r\n    t=int(input())\r\n    for _ in range(t):\r\n        l,r,m=list(map(int,input().split()))\r\n        if(m==1):\r\n            print(0)\r\n        else:\r\n            ans=1\r\n            for i in range(len(primes)):\r\n                ans=ans*(pow(primes[i],dp[r][i]-dp[l-1][i],m))%m\r\n            print(ans%m)\r\n    \r\ndef __starting_point():\r\n    main()\n__starting_point()
t = int(input())\nfor i in range(t):\n n = int(input())\n suffixes = {}\n xx = input().split()\n for x in range(n):\n  try:\n   a = suffixes[xx[x][-3:]]\n  except Exception as e:\n   a = []\n  a.append(xx[x])\n\n  suffixes.update({xx[x][-3:]: a})\n\n print("Case : %d" % (i + 1))\n for a in sorted(suffixes):\n  print("".join(b + " " for b in sorted(suffixes[a])).strip())
n=int(input())\narr=[int(x) for x in input().split()]\nl=[1]*n\nif sorted(arr)==arr:\n    print('0')\nelse:\n    for i in range(0,len(arr)):\n        for j in range(i):\n            if arr[i]>=arr[j] and l[i]<l[j]+1:\n                l[i]=l[j]+1\n    print(n-max(l))
import sys\nn, x, y = input().split(' ')\nn = int(n)\nx = int(x)\ny = int(y)\ncontests = {}\n\nfor i in range(n):\n s, e = input().split(' ')\n s = int(s)\n e = int(e)\n contests[(s, e)] = abs(s-e)\n\nv_time = input().split(' ')\nw_time = input().split(' ')\n\nv_time, w_time = list(map(int, v_time)), list(map(int, w_time))\nv_time.sort()\nw_time.sort()\n\n\nscore = sys.maxsize\n\ncontests = dict(sorted(contests.items(), key=lambda item: item[1]))\nfor k, v in contests.items():\n start=-1\n end = sys.maxsize\n for i in range(x):\n  if v_time[i] > k[0]:\n   break\n  start = v_time[i]\n for j in range(y):\n  if w_time[j] >= k[1]:\n   end = w_time[j]\n   break\n if start == -1:\n  continue\n score = min(score, (end-start+1))\n if score-1 <= v:\n  break\n\nprint(score)
testcases=int(input())\nresults=[]\nfor i in range(0,testcases):\n friends=int(input())\n l,b=list(map(int,input().split()))\n over=False\n if b>l:\n  temp=b\n  b=l\n  l=temp\n for counter in range(0,friends):\n  if l==b:\n   over=True\n   break\n  elif l>b:\n   l=l-b\n   if b>l:\n    temp=b\n    b=l\n    l=temp\n    \n if over:\n  results.append("No")\n else:\n  results.append("Yes "+str(l*b))\n\nfor i in range(0,testcases):\n print(results[i])\n
# cook your dish here\nfor i in range(int(input())):\n n = int(input())\n l = list(map(int,input().split()))\n s = 0\n l.sort(reverse = True)\n for i in range(0,n,2):\n  s = s+l[i]\n print(s)\n
import sys\n\ndef f(p):\n  votes = {}\n  for x in range(p):\n    str = sys.stdin.readline()\n    t = str.split()\n    votes[t[0]] = t[1]\n\n  ans = 0\n  for per in votes:\n    if votes[per] == "+":\n      ans= ans+1\n    else:\n      ans = ans-1\n\n  return ans\n\nx = sys.stdin.readline()\nfor t in range(int(x)):\n  p = sys.stdin.readline()\n  print(f(int(p)))\n
# cook your dish here\n"""\nInput:\nThe first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains three space-separated integers p, q and r.\nThe second line contains three space-separated integers a, b and c.\nOutput:\nFor each test case, print a single line containing one integer  the maximum required number of operations(if the conversion is possible), or else print "-1"\n"""\n\nT=int(input())\nwhile T>0:\n    T-=1 \n    p,q,r=list(map(int,input().split()))\n    a,b,c=list(map(int,input().split()))\n    #ds=list()\n    s=0\n    d1=a-p\n    if d1>0:\n        #ds.append(d1)\n        s+=d1\n    d2=b-q\n    if d2>0:\n        #ds.append(d2)\n        s+=d2\n    d3=c-r\n    if d3>0:\n        #ds.append(d3)\n        s+=d3\n    \n    if(d1==0 and d2==0 and d3==0):\n        print(0)\n    elif(d1<0 or d2<0 or d3<0):\n        print(-1)\n    else:\n        print(s)\n        \n    \n
from collections import Counter\r\nfrom math import factorial\r\ndef nc3(n):\r\n    a=factorial(n)\r\n    b=factorial(n-3)\r\n    return ((a)/(b*6))\r\ndef rem(s,k):\r\n    t=-1\r\n    x=-1\r\n    for i in range(len(s)):\r\n        if s[i][0]>2 and s[i][1]<=k:\r\n            if s[i][0]>3:\r\n                ch=(nc3(s[i][0])-nc3(s[i][0]-1))/s[i][1]\r\n            else:\r\n                ch=1/s[i][1]\r\n            if t<ch:\r\n                t=ch\r\n                x=i\r\n    return x\r\nt=int(input())\r\nfor x in range(t):\r\n    n,c,k=map(int,input().split())\r\n    l={}\r\n    for i in range(n):\r\n        a,b,e=map(int,input().split())\r\n        if e in l:\r\n            l[e].append(a)\r\n        else:\r\n            l[e]=[]\r\n            l[e].append(a)\r\n    v=list(map(int,input().split()))\r\n    s=[]\r\n    for i in range(1,c+1):\r\n        if i in l:\r\n            s+=[[len(l[i]),v[i-1]]]\r\n    s.sort(key = lambda x: x[0],reverse=True)\r\n    while True:\r\n        ma=rem(s,k)\r\n        if ma<=-1:\r\n            break\r\n        else:\r\n            s[ma][0]-=1\r\n            k=k-s[ma][1]\r\n    re=0\r\n    for i in s:\r\n        if i[0]>2:\r\n            re=re+nc3(i[0])\r\n    print(int(re))\r\n
for _ in range(int(input())):\n n=int(input())\n n1=0\n ans=1\n while(n>0):\n  d=int(n % 10)\n  if(d!=0):\n   if(d!=9 and d!=7 and d!=1):\n    n1=3\n   elif(d==1):\n    n1=1\n   else:\n    n1=4\n   ans=(int(ans)*int(n1))% (1000000007)\n   n/=10\n  else:\n   n/=10\n if(ans==1):\n  print("0")\n else:\n  print(ans %(1000000007))\n
import sys\nimport math\nr=int(input())\nfor v in range (0,r):\n n = int(input())\n x=1\n arr=list(map(int,input().strip().split(" ")))\n for i in range (0,n):\n  x=x*arr[i]\n  \n for i in range (2,100000000):\n  if(x%(pow(i,2))==0):\n   ans1=i\n   break\n \n \n print(ans1) \n
# cook your dish here\nT=int(input())\nMOD=int(1e9+7)\nfor t in range(T):\n    N,K=[int(a) for a in input().split()]\n    M=K//2\n    # ans= ((K%2)?( (N+M)*(N+M) + M ):( (N+M)*(N+M) - M) )\n    ans=(N+M)*(N+M) -M\n    if(K%2):\n        ans+=2*M\n    if(N==0):\n        ans=K*(K-1)\n    print(ans%MOD) 
for i in range(int(input())):\n n=int(input())\n c=[int(z) for z in input().split()]\n c.sort()\n c.reverse()\n b1,b2=0,0\n for i in range(n):\n  if b1<b2:\n   b1+=c[i]\n  elif b2<b1:\n   b2+=c[i]\n  else:\n   b1+=c[i]\n print(max(b1,b2))\n   \n
'''Well I found the bug, but I don't understand why it was doing that. I mean, as\nfar as I can tell, it shouldn't be a bug!\nNote to self: deleting from (supposedly) local lists through recursion is dangerous!'''\n\nclass Group(object):\n    def __init__(self,size,start,end,value):\n        self.size = size\n        self.start = start\n        self.end = end\n        self.value = value\n        \n    def __lt__(self,other):\n        return self.start < other.start\n    \n    def __str__(self):\n        return "%i: %i->%i, $%i" %(self.size,self.start,self.end,self.value)\n    \n    \ndef hash(car,i):\n    people = []\n    for group in car:\n        people.extend([group.end]*group.size)\n    people.sort()\n    return tuple(people+[i])\n    \n    \ndef optimize(groups,car,capacity,i):   \n    if i == len(groups):\n        return 0\n    \n    newcar = []\n    pos = groups[i].start\n    for group in car:\n        if group.end > pos:\n            newcar.append(group)\n        else:\n            capacity += group.size\n        \n    state = hash(newcar,i)\n    try:\n        return memo[state]\n    except:\n        v = optimize(groups,newcar,capacity,i+1) \n        if groups[i].size <= capacity:\n            w = optimize(groups,newcar+[groups[i]],capacity-groups[i].size,i+1) + groups[i].value\n        else:\n            w = 0\n            \n        if v > w:\n            ie[state] = -1\n        elif v < w:\n            ie[state] = 1\n        else:\n            ie[state] = 0\n                \n        ans = max(v,w)\n        memo[state] = ans\n        return ans\n    \ncases = int(input())\nfor case in range(cases):\n    memo = {}\n    ie = {}\n    groups = []\n    n,_,capacity = list(map(int,input().split()))\n    \n    for g in range(n):\n        size,start,end,value = list(map(int,input().split()))\n        groups.append(Group(size,start,end,value))\n    groups.sort()\n    print(optimize(groups,[],capacity,0))
# cook your dish here\nfrom sys import stdin\nfrom math import sqrt,ceil,log10\ndef get_sum(a,b,digits):\n    sum=((b+a)*(b-a+1))//2\n    return sum*digits\n\ndef solve():\n    mod=10**9+7\n    thehighlimiter={i: 10 ** i - 1 for i in range(12)}\n    thelowlimiter={i: 10**i for i in range(12)}\n    for _ in range(int(input())):\n        l,r=map(int, stdin.readline().strip().split())\n        low=len(str(l))\n        high=len(str(r))\n        ans=0\n        if low==high:\n            ans=get_sum(l,r,low)\n        else:\n            ans+=get_sum(l,((10**low)-1),low)\n            ans+=get_sum((10**(high-1)),r,high)\n            for i in range(low+1,high):\n                ans+=get_sum(10**(i-1),(10**i)-1,i)\n        print(ans%mod)\n\ndef __starting_point():\n    solve()\n\n__starting_point()
N,M,K=map(int,input().split())\nc=0\nfor i in range(N):\n T=list(map(int,input().split()))\n Q=T[-1]\n T.pop(-1)\n if Q<=10 and sum(T)>=M:\n  c+=1\nprint(c)
import math\nfor t in range(int(input())):\n n = int(input())\n temp = math.sqrt(n)\n if (temp == int(temp)):\n  print("YES")\n else:\n  print("NO")
# cook your dish here\nfor _ in range(int(input())):\n    n=int(input());li=list(map(int,input().split()));dli=dict();modi=0\n    for i in li:\n     if i not in dli:dli[i]=1\n     else:dli[i]+=1\n    op=sorted(list(dli))\n    if(len(dli)!=0):\n     while 1:\n      tmp=[]\n      for i in op:\n       if dli[i]==0:continue\n       tmp.append(i);dli[i]-=1\n      l=len(tmp);mn=l\n      for i in range(l):mn=min(mn,tmp[i]-1-i+l-1-i)\n      modi+=mn\n      if(l==0):break\n    print(modi)
# cook your dish here\nfor _ in range(int(input())):\n n=int(input())\n a=list(map(int,input().split()))\n even=[]\n odd=[]\n for i in a:\n  if(i & 1):\n   even.append(i)\n  else:\n   odd.append(i)\n print(len(even)*len(odd))
# cook your dish here\nfor _ in range(int(input())):\n    n = int(input())\n    m = n\n    x= 1\n    for i in range(n):\n        for j in range(m):\n            print(x, end = '')\n            x += 1\n        print()\n        m -= 1
t = input();\n\na = [0 for i in range(10001)]\n\ni = 0;\n\nwhile i < int(t):\n\n	n = input();\n\n	k = input();\n\n	assert(len(k.split(' ')) == int(n));\n\n	for each in k.split(' '):\n\n		a[int(each)] += 1;\n\n\n	V = 0;\n\n	C = a[V];\n\n	for j in range(10001):\n\n		if C < a[j]:\n\n			V = j;\n\n			C = a[V];\n\n		a[j] = 0;\n\n	i += 1;\n\n	print(V, C);\n
T=int(input())\nfor i in range(T):\n N=int(input())\n A=list(map(int,input().split()))[:N]\n l=[]\n for j in range(len(A)):\n  for k in range(j+1,len(A)):\n   l.append(A[j]+A[k])\n print(l.count(max(l))/((N*(N-1))/2))
T = int(input())\n\nM = 10 ** 9 + 7\n\nfor _ in range(T):\n N = int(input())\n\n A = list(map(int, input().split()))\n\n if N == 1:\n  print(0)\n  continue\n\n B = {}\n C = {}\n\n for i in range(N - 1):\n  u, v = input().split()\n  u = int(u) - 1\n  v = int(v) - 1\n\n  if u not in B:\n   B[u] = []\n\n  if v not in B:\n   B[v] = []\n\n  B[u].append(v)\n  B[v].append(u)\n\n total_leaves = 0\n\n for i in B:\n  if len(B[i]) == 1:\n   total_leaves += 1\n\n S = [0]\n\n visited = [False] * N\n\n parent = [-1] * N\n\n total_visits = [0] * N\n\n while len(S) > 0:\n  current = S.pop(len(S) - 1)\n\n  if visited[current]:\n   p = parent[current]\n   if p != -1:\n    total_visits[p] += total_visits[current]\n    if p not in C:\n     C[p] = {}\n    C[p][current] = total_visits[current]\n    if current not in C:\n     C[current] = {}\n    C[current][p] = total_leaves - C[p][current]\n  else:\n   S.append(current)\n   visited[current] = True\n   for i, j in enumerate(B[current]):\n    if not visited[j]:\n     parent[j] = current\n     S.append(j)\n   if len(B[current]) == 1:\n    total_visits[current] = 1\n    p = parent[current]\n    if p != -1:\n     if p not in C:\n      C[p] = {}\n     C[p][current] = 1\n\n D = {}\n for i in C:\n  sum1 = 0\n  for j in C[i]:\n   sum1 += C[i][j]\n  D[i] = sum1\n\n E = [0] * N\n for i in C:\n  sum1 = 0\n  for j in C[i]:\n   D[i] -= C[i][j]\n   sum1 += C[i][j] * D[i]\n  E[i] = sum1\n\n for i, j in enumerate(E):\n  if j == 0:\n   for k in C[i]:\n    E[i] = C[i][k]\n\n E.sort()\n E.reverse()\n A.sort()\n A.reverse()\n\n E = [x % M for x in E]\n A = [x % M for x in A]\n\n ans = 0\n for i, j in zip(E, A):\n  a = i * j\n  a %= M\n  ans += a\n  ans %= M\n\n print(ans)\n
from collections import defaultdict \ndef findSubarraySum(arr, n, Sum):  \n \n # Dictionary to store number of subarrays  \n # starting from index zero having   \n # particular value of sum.  \n prevSum = defaultdict(lambda : 0) \n \n res = 0 \n \n # Sum of elements so far.  \n currsum = 0 \n \n for i in range(0, n):   \n \n  # Add current element to sum so far.  \n  currsum += arr[i] \n \n  # If currsum is equal to desired sum,  \n  # then a new subarray is found. So  \n  # increase count of subarrays.  \n  if currsum == Sum:   \n   res += 1 \n \n  # currsum exceeds given sum by currsum  - sum. \n  # Find number of subarrays having   \n  # this sum and exclude those subarrays  \n  # from currsum by increasing count by   \n  # same amount.  \n  if (currsum - Sum) in prevSum: \n   res += prevSum[currsum - Sum] \n   \n \n  # Add currsum value to count of   \n  # different values of sum.  \n  prevSum[currsum] += 1 \n  \n return res \nn=int(input())\nlst=list(map(int,input().split()))\nif(n==1):\n if(lst[0]==0):\n  print(1)\n else:\n  print(0)\nelse:    \n print(findSubarraySum(lst,n,0)) \n
import numpy as np\n\ndef sort_it(array):\n    new_list = []\n    for i in range(len(array)):\n        start = 0\n        value = array[i][0]\n        last = len(new_list)\n        while start != last:\n            mid = (start + last) // 2\n            if new_list[mid][0] > value:\n                last = mid\n            else:\n                start = mid+1\n        new_list.insert(start,array[i])\n    return new_list\n\ntests = int(input())\nfor _ in range(tests):\n    n, m, q = [int(j) for j in input().split()]\n    challenges = [[0] * 3 for _ in range(m)]\n    combos = [[0] * 2 for _ in range(q)]\n    for i in range(m):\n        challenges[i] = [int(j) for j in input().split()]\n    for i in range(q):\n        combos[i] = [int(j) for j in input().split()]\n    \n    sorted_chalenges = np.zeros((2 * m, 3),dtype=np.intc)\n    for i in range(m):\n        sorted_chalenges[2*i] = [challenges[i][0]-1,challenges[i][2],i]\n        sorted_chalenges[2*i+1] = [challenges[i][1],-challenges[i][2],i]\n    sorted_chalenges = np.array(sort_it(sorted_chalenges))\n    types_of_players = np.zeros((m + 1, 2 * m + 1),dtype=np.intc)\n    player_type = np.zeros(n,dtype=np.intc)\n    last_player = 0\n    for i in range(2 * m):\n        start, value, chal = sorted_chalenges[i]\n        types_of_players[chal+1:,i+1:] += value\n        player_type[last_player:start] = i\n        last_player = start\n    player_type[last_player:] = 2 * m\n    \n    combo_types = np.zeros((q, 2 * m + 1),dtype = np.intc)\n    for i in range(q):\n        first, last = combos[i]\n        r, p = [types_of_players[first - 1], types_of_players[last]]\n        combo_types[i] = np.maximum(p-r,0)\n    output = np.sum(combo_types,axis=0)[player_type]\n    for i in range(n):\n        print(output[i], end = " ")\n    print("")\n
'''\nName : Jaymeet Mehta\ncodechef id :mj_13\nProblem : Avenir Strings\n'''\nfrom sys import stdin,stdout\ntest=int(stdin.readline())\nfor _ in range(test):\n N=int(stdin.readline())\n seq=list(input())\n fp,fp1,fl,fl1=0,0,0,1\n for i in range(N):\n  if fl!=int(seq[i])-0:\n   fp+=1\n  fl=1-fl\n for i in range(N):\n  if fl1!=int(seq[i])-0:\n   fp1+=1\n  fl1=1-fl1\n print(fp) if fp<fp1 else print(fp1)
#dt = {} for i in x: dt[i] = dt.get(i,0)+1\r\nimport sys;input = sys.stdin.readline\r\ninp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]\r\n\r\ndef kadane(arr, start, finish, n):\r\n    Sum = 0\r\n    maxSum = float('-inf')\r\n    i = None\r\n    finish[0] = -1\r\n    local_start = 0\r\n    for i in range(n):\r\n        Sum += arr[i]\r\n        if Sum < 0:\r\n            Sum = 0\r\n            local_start = i + 1\r\n        elif Sum > maxSum:\r\n            maxSum = Sum\r\n            start[0] = local_start\r\n            finish[0] = i\r\n\r\n    if finish[0] != -1:\r\n        return maxSum\r\n\r\n    maxSum = arr[0]\r\n    start[0] = finish[0] = 0\r\n\r\n    for i in range(1, n):\r\n        if arr[i] > maxSum:\r\n            maxSum = arr[i]\r\n            start[0] = finish[0] = i\r\n    return maxSum\r\n\r\ndef findMaxSum(M):\r\n    nonlocal ROW, COL\r\n    maxSum, finalLeft = float('-inf'), None\r\n    finalRight, finalTop, finalBottom = None, None, None\r\n    left, right, i = None, None, None\r\n\r\n    temp = [None] * ROW\r\n    Sum = 0\r\n    start = [0]\r\n    finish = [0]\r\n\r\n    for left in range(COL):\r\n        temp = [0] * ROW\r\n        for right in range(left, COL):\r\n            for i in range(ROW):\r\n                temp[i] += M[i][right]\r\n            Sum = kadane(temp, start, finish, ROW)\r\n            if Sum > maxSum:\r\n                maxSum = Sum\r\n                finalLeft = left\r\n                finalRight = right\r\n                finalTop = start[0]\r\n                finalBottom = finish[0]\r\n\r\n    for i in range(finalTop,finalBottom+1):\r\n        print(*M[i][finalLeft:finalRight+1])\r\n\r\n\r\nROW,COL = ip()\r\nM = [ip() for i in range(ROW)]\r\nfindMaxSum(M)\r\n\r\n\r\n    \r\n
#AUTHOR:: AMAN VERMA\ntry:\n for _ in range(int(input())):\n  row,column=list(map(int,input().split(" ")))\n  x_x,y_y=list(map(int,input().split(" ")))\n  ab=max((x_x-0),(row-x_x-1))\n  ba=max((y_y-0),(column-y_y-1))\n  print(ab+ba)\nexcept:\n pass\n
# cook your dish here\nt=int(input())\nwhile t>0:\n a=input().split(":")\n a1=int(a[0])\n a2=int(a[1])\n b1=a1%12 \n if a2%5!=0:\n  b2=(a2//5)*5+5\n else:\n  b2=a2\n \n c1=b1*30 \n \n extra=0.5*b2 \n c1+=extra\n c1%=360\n\n d1=(b2//5)*30 \n d1%=360 \n \n if c1>d1:\n  ans1=c1-d1 \n  ans2=360-ans1\n else:\n  ans1=d1-c1\n  ans2=360-ans1\n ans=min(ans1,ans2)\n if ans==int(ans):\n  ans3=int(ans)\n  y=str(ans3)+" degree"\n  print(y)\n else:\n  y=str(ans)+" degree"\n  print(y)\n \n t-=1\n \n  \n
# cook your dish here\nwhile True:\n	try:\n		m=int(input())\n		\n		n=int(m/2)\n		\n		a=m-n\n	\n		sum_even= int(2*(2*n*(n+1)*(2*n+1))/3)\n		\n		sum_odd= int(((4*a*a*a)-a)/3)\n		\n		result=sum_odd+sum_even\n		\n		if result%2==0:\n			print('Ravi')\n		else:\n			print('Jhon')\n	except:\n		break;
# cook your dish here\nfrom sys import stdin, stdout\nfrom math import ceil\n\n\ndef solve():\n    for _ in range(int(input())):\n        n, m = map(int, stdin.readline().split())\n        par = [i for i in range(n)]\n        for i in range(m):\n            ta, tb = map(int, stdin.readline().strip().split())\n            a, b = min(ta, tb), max(ta, tb)\n            for j in range(n):\n                if par[j] == par[b] and j != b:\n                    par[j] = par[a]\n            par[b] = par[a]\n\n        q = int(input())\n        while q:\n            q -= 1\n            x, y = map(int, stdin.readline().split())\n            if par[x] == par[y]:\n                print("YO")\n            else:\n                print("NO")\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()
# cook your dish here\n# cook your dish here\nt=int(input())\nfor _ in range(t):\n n,p,q=list(map(int,input().split(" ")))\n l=list(map(int,input().split(" ")))\n l.sort()\n s=sum(l)\n a=p+2*q\n b=0\n for i in l:\n  if(p==0):\n   if(i%2==0 and a>=i):\n    a=a-i\n    b=b+1\n  elif(q==0):\n   if(a>=i):\n    a=a-i\n    b=b+1\n  else:\n   if(i%2==0 and a>=i):\n    a=a-i\n    b=b+1\n   elif(i%2!=0 and p!=0 and a>=i):\n    a=a-i\n    b=b+1\n    p=p-1\n\n print(b) \n    \n   \n
# cook your dish here\nfor _ in range(int(input())):\n    n=list(map(int,input().split()))\n    print(n[0]*n[1])\n
for _ in range(int(input())):\n    n=int(input())\n    print((2*(pow(n,2)))-n+1)\n\n
# cook your dish here\nx= int(input())\nfor i in range(x):\n    y = list(map(str, input().split()))\n    j= 0\n    while j<len(y)-1:\n        print((y[j][0]).capitalize()+".", end=' ')\n        j+= 1\n    print(y[len(y)-1].capitalize())
import sys\n\nt = eval(input())\nfor j in range(t):\n n = eval(input())\n a = list(map(int, input().split()))\n ch = 0\n sm = 0 ; x = sum(a)\n s1 = [0] * n ; s2 = [0] * n\n for i in range(n):\n  sm += a[i]\n  s1[i] = sm\n  s2[i] = x\n  x -= a[i]\n if(sum(a) - a[0] == 0):\n  print(0)\n elif(sum(a) - a[n - 1] == 0):\n  print(n - 1)\n else:\n  for i in range(1, n - 1):\n   if(s1[i - 1] == s2[i + 1]):\n    print(i)\n    ch = 1\n    break\n  if(ch == 0):\n   if(n == 1):\n    print(0)\n   else:\n    print(-1)\n
def fastpow(base, power):\n result = 1\n while power > 0:\n  if power % 2 == 0:\n   power = power // 2\n\n   base = base * base\n  else:\n   power = power - 1\n   result = result * base\n   power = power // 2\n   base = base * base\n return result\n\nt=int(input())\nfor i in range(t):\n a=list(map(int,input().split()))\n n,r=a[0],a[1]\n w=(n*(fastpow(n-1,r)))%((10**9)+7)\n \n print(w)
for _ in range(int(input())):\n f,d=list(map(int,input().split()))\n arr=list(map(int,input().split()))\n risk=0\n days_risk=0\n days_norm=0\n if d==1:\n  print(f)\n else:\n  for a in arr:\n   if a>=80 or a<=9:\n    risk+=1\n  norm=f-risk\n  if risk%d==0:\n   days_risk=risk//d\n  else:\n   days_risk=(risk//d)+1\n  if norm%d==0:\n   days_norm=norm//d\n  else:\n   days_norm=(norm//d)+1\n  print(days_risk+days_norm)\n    \n    \n
for _ in range(int(input())):\n    n,k=[int(x) for x in input().split()]\n    a=list(map(int,input().split()))\n    dp=[0]*(max(a)+1)\n    for _ in range(n):\n        dp[a[_]]+=1\n    for _ in range(1,len(dp)):\n        if dp[_]>k:\n            print(_,end=" ")\n    print()
mod = 1000000007\r\nfac = [1,1]\r\nmaxn = (10**5)+5\r\nfor i in range(2,maxn):\r\n    x = (fac[-1]*i)%mod\r\n    fac.append(x)\r\n\r\npre = [1]\r\nfor i in range(2,maxn):\r\n    x = 2*i-1\r\n    x = (pre[-1]*x)%mod\r\n    pre.append(x)\r\n\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    x = fac[n]\r\n    y = pre[n-1]\r\n    print((x*y)%mod)
from sys import stdin,stdout\nfrom math import gcd\nnmbr=lambda:int(stdin.readline())\nlst=lambda:list(map(int, stdin.readline().split()))\n\nfor _ in range(nmbr()):\n n=nmbr()\n a=lst()\n g=a[0]\n ans=0\n for v in a[1:]:\n  g=gcd(v,g)\n for i in a:\n  ans+=i//g\n print(g,ans)
t=int(input())\nfor i in range(t):\n n,m=list(map(int,input().split()))\n a=list(map(int,input().split()))\n army=0\n if n>m:\n  \n  for i in range(0,m):\n   army+=a[i]\n   \n   \n  for j in range(m,n):\n   army=army-(a[j]/2)\n   if army<0:\n    print('DEFEAT')\n    break\n   else:\n    continue\n  else:\n   print('VICTORY')\n   \n if n<=m:\n  print('VICTORY')
# cook your dish here\nt=int(input())\nwhile t!=0:\n n,k=map(int,input().split())\n lst=[]\n for i in range(1,n+1):\n  lst.append(i)\n lst[k],lst[n-1]=lst[n-1],lst[k]\n for item in lst:\n  print(item,end=' ')\n t-=1
\r\nt = int(input())\r\n\r\nfor _ in range(t):\r\n    n,m = map(int,input().split())\r\n\r\n    if n==1:\r\n        print(m)\r\n    else:\r\n        \r\n        if n%2==0:\r\n            print((n//2)*m)\r\n            \r\n        else:\r\n            print(((n//2)+1)*m)
test = int(input())\nANS = list()\nfor i in range(test):\n n = int(input())\n items = sorted(list(map(int, input().split())))\n c = 1\n for j in range(len(items)):\n  if items[j] < 2000:\n   t = 2000 - items[j]\n   if t in items[j+1:]:\n    ANS.append("Accepted")\n    c = 2\n    break\n   else:\n    pass\n  else:\n   break\n if c==1:\n  ANS.append("Rejected")\nfor ans in ANS:\n print(ans)
a=eval(input())\nwhile(a):\n\n x=eval(input())\n b=list(map(int,input().split()))\n z=[0]*100\n k=1\n j=0\n c=0\n for i in b:\n  \n  if i==0:\n   \n   z.insert(i,k)\n   \n  else:\n   \n   if z[z.index(i)+1]==0:\n    \n    z.insert(j,k)\n   else:\n    m=z.index(i)\n    n=m+1\n    p=(len(z)-z.count(0))-n\n    c=c+min(n,p)\n    \n    z.insert(m+1,k)\n    \n    \n  k+=1\n  j+=1\n  m=0\n  n=0\n  p=0\n  \n print(c)\n \n    \n    \n    \n   \n  \n  \n \n \n  \n\n\n a-=1\n
t = int(input())\nwhile t>0:\n s = input().strip()\n if not s:\n  print('NO')\n\n dp = [0 for x in range(len(s) + 1)]\n dp[0] = 1\n dp[1] = 1 if 0 < int(s[0]) <= 9 else 0\n\n for i in range(2, len(s) + 1):\n  if 0 < int(s[i-1:i]) <= 9:\n   dp[i] += dp[i - 1]\n  if s[i-2:i][0] != '0' and int(s[i-2:i]) <= 26:\n   dp[i] += dp[i - 2]\n \n if dp[len(s)]%2 == 0:\n  print('YES')\n else:\n  print('NO')\n t -= 1
for _ in range(int(input())):\n p, idx = map(int, input().split())\n b = bin(idx)[2:]\n b = ('0' * (p - len(b)) + b)[::-1]\n print(int(b, 2))
try:\n t,m=input().split()\n t=int(t)\n m=list(m)\n letters=list("abcdefghijklmnopqrstuvwxyz")\n trans={}\n for i in range(len(letters)):\n  trans[letters[i]]=m[i]\n for i in range(t):\n  x=list(input())\n  y=""\n  for j in x:\n   if(j.isalpha()==True):\n    if(j.isupper()==True):\n     y+=trans[j.lower()].upper()\n    else:\n     y+=trans[j]\n   else:\n    if(j=='_'):\n     y+=" "\n    else:\n     y+=j\n  print(y)\n  \nexcept:pass
arr=[]\nn=int(input())\nfor i in range(n):\n    a=int(input())\n    arr.append(a)\n    arr.sort()\n    p=arr.index(a)\n    print((i-p)+1)
# cook your dish here\ndef isPrime(n) : \n  \n    # Corner cases \n    if (n <= 1) : \n        return False\n    if (n <= 3) : \n        return True\n  \n    # This is checked so that we can skip  \n    # middle five numbers in below loop \n    if (n % 2 == 0 or n % 3 == 0) : \n        return False\n  \n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n  \n    return True\nt=int(input())\nfor i in range(0,t):\n    n=int(input())\n    if n==1:\n        print("2")\n        continue\n    if isPrime(n):\n        print(n+1)\n        continue\n    if n%2==0:\n        k=n//2\n        min=2+k\n    else:\n        min=n+1\n    for j in range(2,(n//2)+1):\n        if n%j==0:\n            k=n//j\n            if k!=j:\n                l=j+k\n                if l<min:\n                    min=l\n    print(min)\n
T= int(input());\n\nfor i in range(T):\n n,k = list(map(int,input().split()));\n s=list(map(int,input()));\n\n if k==1:\n  s_0 ={};\n  s_1={};\n  c0=0;\n  c1=0;\n  for j in range(n):\n   if(j%2==0):\n    s_1[j]=1;\n    s_0[j]=0;\n   else:\n    s_1[j]=0;\n    s_0[j]=1;\n  for j in range(n):\n   if(s_0[j]-s[j]!=0):\n    c0+=1;\n   if(s_1[j]-s[j]!=0):\n    c1+=1;\n\n  if c0<c1:\n   print(c0);\n   p_s="";\n   for j in range(n):\n    p_s+=str(s_0[j]);\n   print(p_s);\n  else:\n   print(c1);\n   p_s="";\n   for j in range(n):\n    p_s+=str(s_1[j]);\n   print(p_s);\n\n else:\n  count=1;\n  c=s[0];\n  flips=0\n  for j in range(1,n):\n   if(s[j]==c):\n    count+=1;\n    #print count;\n    if count > k:\n     if(j+1<n and s[j]==s[j+1]):\n      if(s[j]==1):\n       s[j]=0;\n      else:\n       s[j]=1;\n     else:\n      if(s[j-1]==1):\n       s[j-1]=0;\n      else:\n       s[j-1]=1;\n     flips+=1;\n     count=1;\n\n\n   elif(s[j]!=c):\n    count=1;\n   c=s[j];\n\n  print(flips);\n  p_s="";\n  for j in range(n):\n   p_s+=str(s[j]);\n  print(p_s);
from math import log,pow\nn=int(input())\na=[]\nfor i in range(n):\n no=int(input())\n if(no%2==0):\n  a.append("0")\n elif(no==1):\n  a.append("1")\n elif(no==3):\n  a.append("3")\n else:\n  s="2"\n  lv=int(log(no,2))\n  clv=1\n  cno=3\n  while(cno!=no):\n   if(no<cno*pow(2,lv-clv)):\n    s=s+"1"\n    clv=clv+1\n    cno=(2*cno)-1\n   else:\n    s=s+"2"\n    clv=clv+1\n    cno=(2*cno)+1\n  a.append(s)\nfor i in a:\n print(i)\n \n
# cook your dish here\n\na,b=list(map(int,input().split()))\nls=[]\nfor i in range(a):\n ls.append(int(input()))\nls.sort()\nc=0;i=0\nwhile i<(a-1):\n if ls[i+1]-ls[i]<=b:\n  c=c+1\n  i=i+1\n i=i+1\nprint(c)\n
# cooking dish here\n\nfrom sys import stdin\nfrom collections import Counter\nread = stdin.readline\n\nfor testcase in range(int(read())):\n    length = int(read())\n    string = read().strip()\n    \n    counts = Counter(string)\n    \n    odd_counts = 0\n    \n    for count in list(counts.values()):\n        # print(count, counts)\n        odd_counts += count%2\n        \n    print(max(odd_counts-1, 0))\n
def g(x,y):\n d = x[0]>=y[0] and x[1]>=y[1] and x[2]>=y[2]\n e= x[0]>y[0] or x[1]>y[1] or x[2]>y[2]\n return d and e\nt=int(input())\nfor _ in range(t):\n a=list(map(int,input().split()))\n b=list(map(int,input().split()))\n c=list(map(int,input().split()))\n\n if g(a,b) and g(b,c):\n  print('yes')\n elif g(a,c) and g(c,b):\n  print('yes')\n elif g(b,a) and g(a,c):\n  print('yes')\n elif g(b,c) and g(c,a):\n  print('yes')\n elif g(c,a) and g(a,b):\n  print('yes')\n elif g(c,b) and g(b,a):\n  print('yes')\n else:\n  print('no')\n  \n
# cook your dish here\n\n \nt=int(input())\nfor _ in range(t):\n l = input()\n \n n= len(l)\n prod = 1\n for k in range(n//2):\n  i = l[k]\n  j = l[n-k-1]\n  if ((i!=j) and (i!='?' and j!="?") ):\n   prod=0\n   break\n  elif ((i==j) and (i=='?')):\n   prod*=26\n  prod = prod%10000009\n if n%2!=0:\n  if l[n//2]=="?":\n   prod*=26\n \n print(prod)
# cook your dish here\nimport math\nfor _ in range(int(input())):\n n=int(input())\n c=0\n while(n>0):\n  i=int(math.sqrt(n))\n  c+=1\n  n=n-i**2\n print(c)\n  \n
from sys import stdin\r\nfrom math import ceil, gcd\r\n\r\n# Input data\r\n#stdin = open("input", "r")\r\n\r\n\r\ndef dfs(src, visit):\r\n    visit[src] = 1\r\n    for nbr in d[src]:\r\n        if visit[nbr] == 0:\r\n            dfs(nbr, visit)\r\n\r\nfor _ in range(int(stdin.readline())):\r\n    n, m = list(map(int, stdin.readline().split()))\r\n    d = {}\r\n    for i in range(m):\r\n        u, v = list(map(int, stdin.readline().split()))\r\n        if u in d:\r\n            d[u].append(v)\r\n        else:\r\n            d[u] = [v]\r\n        if v in d:\r\n            d[v].append(u)\r\n        else:\r\n            d[v] = [u]\r\n    visited = {}\r\n    for i in range(n):\r\n        visited[i] = 0\r\n    ans = 0\r\n    for i in range(n):\r\n        if visited[i] == 0:\r\n            ans += 1\r\n            if i in d:\r\n                dfs(i, visited)\r\n    print(ans)\r\n
nr=int(input())\nd={}\nfor r in range(nr):\n s,v=list(map(str,input().split()))\n d[int(v)]=s\nq=int(input())\nlis=[]\nfor i in range(q):\n lis.append(input())\nl=list(d.keys())\nl.sort(reverse=True)\nans='NO'\n\n\nfor j in lis:\n ans='NO'\n for k in l:\n  if len(j)<=len(d[k]):\n   a=d[k]\n   if j==a[0:len(j)]:\n    ans=a\n    break\n print(ans) \n
def mod(a,b,c):\n x = 1\n y = a\n while(b>0):\n  if(b%2==1):\n   x = (x*y)%c\n  y = (y*y)%c\n  b /=2\n return x%c\nt = int(input())\nnum = 10**9+7\nfor i in range(t):\n n,m,q,k = list(map(int,input().split()))\n if m<=q:\n  print(0)\n else:\n  a1 = m-q\n  a2 = mod(q+1,n,num)\n  a3 = mod(q-1,n,num)\n  a4 = mod(q,n,num)\n  a5 = a2-2*a4+a3\n  ans = a1*a5\n  print(ans%num)
try:\n	n=int(input())\n	x=[*list(map(int, input().split()))]\n	y=[*list(map(int, input().split()))]\n	for i in y:\n		d=x.count(i)-y.count(i)\n		if d!=0:\n			print(i)\n			break\nexcept: pass\n
print
# cook your dish here\nfor i in range(int(input())):\n    x=int(input())\n    if x<10:\n        print("Thanks for helping Chef!")\n    else:\n        print("-1")\n
# cook your dish here\n# cook your dish here\nfor i in range(int(input())):\n    n,m,k=map(int,input().split())\n    l,ans = list(map(int,input().split())),0\n    for i in l:\n        r=i//m + 1;c=i%m\n        if(c==0):c=m;r-=1\n        ans+=r*(n+1-r)*c*(m+1-c)\n    ans/=((n+1)*(m+1)*n*m)//4\n    print(ans)
#!/usr/bin/env python\n\ndef main():\n N = int(input())\n C = 0\n for n in range(N):\n  S = input().strip()\n  Pi = S.split()[-1]\n  L = [Pi.count(k) for k in map(str, list(range(10)))]\n  if L[8] >= L[5] and L[5] >= L[3] and \\n   L[0] == 0 and L[1] == 0 and \\n   L[2] == 0 and L[4] == 0 and \\n   L[6] == 0 and L[7] == 0 and \\n   L[9] == 0: C += 1\n print(C)\n\nmain()\n\n
t = int(input())\n\nfor e in range(t):\n\n str = input()\n\n dict = {}\n\n for x in range(len(str)):\n  if str[x] in dict:\n   dict[str[x]] = -1\n  else:\n   dict[str[x]] = x\n\n shankyIndex = len(str)\n ankuIndex = -1\n for x in dict:\n  if dict[x] != -1:\n   if dict[x] < shankyIndex:\n    shankyIndex = dict[x]\n   if dict[x] > ankuIndex:\n    ankuIndex = dict[x]\n\n ankuLetter = 0\n shankyLetter = 0\n\n if ankuIndex != -1:\n  ankuLetter = str[ankuIndex]\n else:\n  print('PANDEY')\n  continue\n\n if shankyIndex != len(str):\n  shankyLetter = str[shankyIndex]\n else:\n  print('PANDEY')\n  continue\n\n if shankyLetter > ankuLetter:\n  print('SHANKY')\n elif ankuLetter > shankyLetter:\n  print('ANKU')\n else:\n  print('PANDEY')
def get(l,n):\n l1,l2 = [],[]\n i = 1\n h1,m1 = l[0]\n while (i < len(l)):\n  h2,m2 = l[i]\n  if (h1>h2):\n   if (m1 >= m2):\n    l1 += [(0,10**20)]\n    l2 += [(-1,-1)]\n   else:\n    d = (h1-h2)//(m2-m1)\n    if (((h1-h2)%(m2-m1)) == 0):\n     l1 += [(0,d-1)]\n     l2 += [(d+1,10**20)]\n    else:\n     l1 += [(0,d)]\n     l2 += [(d+1,10**20)]\n  elif(h1==h2):\n   if (m1 > m2):\n    l1 += [(1,10**20)]\n    l2 += [(-1,-1)]\n   elif(m1==m2):\n    l1 += [(-1,-1)]\n    l2 += [(-1,-1)]\n   else:\n    l2 += [(1,10**20)]\n    l1 += [(-1,-1)]\n  else:\n   if (m1 <= m2):\n    l2 += [(0,10**20)]\n    l1 += [(-1,-1)]\n   else:\n    d = (h2-h1)//(m1-m2)\n    if ((h2-h1)%(m1-m2) == 0):\n     l2 += [(0,d-1)]\n     l1 += [(d+1,10**20)]\n    else:\n     l2 += [(0,d)]\n     l1 += [(d+1,10**20)]\n  i += 1\n  h1,m1 = h2,m2\n return l1,l2\n \ndef intersect(k1,k2):\n k1,k2 = min(k1,k2),max(k1,k2)\n c1,c2 = k1\n c3,c4 = k2\n l = [c1,c2,c3,c4]\n l.sort()\n if (l[2]==c2):\n  return (c3,min(c2,c4))\n elif (l[3]==c2):\n  return k2\n else:\n  return (-1,-1)\n \n \n \ndef union(k1,k2):\n k1,k2 = min(k1,k2),max(k1,k2)\n c1,c2 = k1\n c3,c4 = k2\n l = [c1,c2,c3,c4]\n l.sort()\n if (c2==l[3]):\n  return ([c1,c2])\n elif(c2==l[2] or ((c3-c2) == 1)):\n  return([c1,c4])\n else:\n  return([c1,c2,c3,c4])\n \n \ndef aa(l1,l2,n):\n c1,c2 = 0,10**20\n i = 0\n n -= 1\n while (i < n):\n  if (i%2 == 0):\n   k1,k2 = l1[i]\n  else:\n   k1,k2 = l2[i]\n  i += 1\n  if ((k1,k2) == (-1,-1)):\n   return (-1,-1)\n  c1,c2 = intersect((c1,c2),(k1,k2))\n  if ((c1,c2) == (-1,-1)):\n   return (c1,c2)\n return (c1,c2)\n \n \ntest = int(input())\nwhile (test != 0):\n test -= 1\n n = int(input())\n l = []\n i = 0\n while (i < n):\n  c1,c2 = list(map(int,input().split()))\n  l += [(c1,c2)]\n  i += 1\n if (n == 1):\n  print(1)\n  print("0 Inf")\n else:\n  l1,l2 = (get(l,n))\n  k1,k2 = aa(l1,l2,n)\n  if ((k1,k2) == (-1,-1)):\n   k1,k2 = aa(l2,l1,n)\n   if ((k1,k2) == (-1,-1)):\n    print(0)\n   else:\n    print(1)\n    if (k2 == 10**20):\n     k2 = "Inf"\n    print(str(k1) + " " +str(k2))\n  else:\n   k3,k4 = aa(l2,l1,n)\n   if ((k3,k4) == (-1,-1)):\n    print(1)\n    if (k2 == 10**20):\n     k2 = "Inf"\n    print(str(k1) + " " +str(k2))\n   else:\n    p = union((k1,k2),(k3,k4))\n    if (len(p)==2):\n     c1,c2 = p\n     if (c2==10**20):\n      c2 = "Inf"\n     print(1)\n     print(str(c1) + " " +str(c2))\n    else:\n     c1,c2,c3,c4 = p\n     if (c4 == 10**20):\n      c4 = "Inf"\n     print(2)\n     print(str(c1) + " " +str(c2))\n     print(str(c3) + " " +str(c4))\n
for i in range(int(input())):\n a=input()\n c=a.count('m')\n d=a.count('s')\n t=0\n while t<len(a)-1:\n  if (a[t]=='m' and a[t+1]=='s') or (a[t]=='s' and a[t+1]=='m'):\n   d=d-1\n   t=t+2\n  else:\n   t=t+1\n if c>d:\n  print('mongooses')\n elif d>c:\n  print('snakes')\n else:\n  print('tie')\n
import sys\nimport os\n\ndef __starting_point():\n    start = 0\n    for line in sys.stdin:\n        if start == 0:\n            start = 1\n            continue\n        else:\n            try:\n                n = int(line.strip())\n                   \n               # print n   \n                   \n                q = n/7\n                rem = n%7\n                \n                \n                if rem==0:\n                    res = n\n                elif rem==1:\n                    res = (q-1)*7\n                elif rem==2:\n                    res = (q-2)*7 \n                elif rem==3:\n                    res = (q-3)*7\n                elif rem==4:\n                    res = q*7\n                elif rem==5:\n                    res = (q-1)*7\n                elif rem==6:\n                    res = (q-2)*7                                                                                \n                \n                if res < 0:\n                    print(-1)\n                else:\n                    print(res)\n                \n            except:\n                break\n            \n        \n            \n        \n__starting_point()
T = int(input())\nfor j in range(0,T):\n line1, line2 = input(), input()\n seq = line2.split()\n current_min = 1000001\n current_max = 0\n max_spread = 0\n for i in range(0,len(seq)):\n  current_value = int(seq[i])\n  if current_min > current_value:\n   current_min = current_value\n   current_max = current_value\n  elif current_max < current_value:\n   current_max = current_value\n   if max_spread < (current_max - current_min):\n    max_spread = current_max - current_min \n if max_spread > 0:\n  print(max_spread)\n else:\n  print("UNFIT")
p,s = [int(i) for i in input().split()]\nscores = {}\n\nfor j in range(1, p + 1):\n sc = [int(i) for i in input().split()]\n ns = [int(i) for i in input().split()]\n nsc = dict(list(zip(sc,ns)))\n ssc = sorted(sc)\n score = 0\n for a,b in zip(ssc[:-1], ssc[1:]):\n  if nsc[a] > nsc[b]:\n   score += 1\n if score in list(scores.keys()) :\n  scores[score].append(j)\n else :\n  scores[score] = [j]\n\ntotal_scores = sorted(list(scores.keys()))\nfinal_list = []\nfor val in total_scores :\n final_list += sorted(scores[val])\n\nfor val in final_list :\n print(val)\n
# cook your dish here\nd = {'january':31,'february':29,'march':31,\n 'april':30,'may':31,'june':30,'july':31,\n 'august':31,'september':30,'october':31,\n 'november':30,'december':31}\n \n#l=[[15,'january'],[31,'august'],[10,'october']]\nl2 = list(d.keys())\nfor _ in range(int(input())):\n l=input().split()\n l[0]=int(l[0])\n a = l[1]\n ind = l2.index(a)\n b = 183 - (d[l[1]] - l[0])\n while b!=0:\n  if ind!=11:\n   ind+=1\n  else:\n   ind = 0\n  if b<=d[l2[ind]]:\n   print(b,l2[ind])\n   break\n  b-=d[l2[ind]]
import sys\nimport math\n\ndef main(arr,k):\n    \n    ans=0\n    for i in range(len(arr)):\n        curr_min=float('inf')\n        for j in range(i,len(arr)):\n            curr_min=min(curr_min,arr[j])\n            \n            if curr_min==k:\n                ans+=1 \n    return ans\n        \n\nn=int(input())\narr=list(map(int,input().split()))\n\n\nfor i in range(int(input())):\n    \n    print(main(arr,int(input())))
s = input().lower()\r\nvow = ["a", "e", "i", "o", "u", "y"]\r\nans = ""\r\nfor ch in s:\r\n    if ch in vow:\r\n        continue\r\n    if ch.isalpha():\r\n        ans += "." + ch\r\nprint(ans)\r\n
import sys\nfor _ in range(0,eval(input())):   \n    d,inp,mp,n,q=set(),list(map(ord,list(sys.stdin.readline().strip()))),[x=='b' for x in list(sys.stdin.readline().strip())],eval(input()),ord('a')\n    inps = [inp[i:] for i in range(len(inp))]\n    inps.sort()\n    op,prev= 0,''\n    for ip in inps:\n        	i,ct=0,0\n        	while i < min(len(ip),len(prev)):\n        		if prev[i] != ip[i]:\n        			break\n        		if mp[ip[i]-q]:\n        			ct = ct+  1\n        		i = i+1\n        	while i < len(ip):\n        		if mp[ip[i]-q]:\n        			ct = ct + 1\n        		if ct > n:\n        			break\n        		op,i= op+1,i+1\n        	prev = ip\n    print(op)
import sys\n\ndef joseph(k, n=6):\n	if k==0:\n		k = 1\n	x = 0\n	for i in range(2,n+1):\n		x = (x+k)%i\n	return x\n\nFLAMES = ['FRIENDS', 'LOVE', 'ADORE', 'MARRIAGE', 'ENEMIES', 'SISTER']\n\nnCase = int(sys.stdin.readline())\nfor _ in range(nCase):\n	a = ''.join(sys.stdin.readline().split())\n	b = ''.join(sys.stdin.readline().split())\n	n = 0\n	for ch in set(a+b):\n		n += abs(a.count(ch)-b.count(ch))\n	print(FLAMES[joseph(n)])\n
t=int(input())\nfor i in range(0,t):\n n,k=map(int,input().split())\n a1,*a=map(int,input().split())\n a.insert(0,a1)\n j=0\n while j<n:\n  if a[j]%k==0:\n   print(1,end="")\n  else:\n   print(0,end="")\n  j+=1\n print("")
import numpy as np\r\nfrom numba import njit\r\ni8 = np.int64\r\n\r\n\r\n@njit\r\ndef solve(a, b, t, K, N):\r\n    t1 = t // K\r\n    d = t % K * 2\r\n    # b  a  a + d \r\n    x = 0\r\n    y = 0\r\n    ans = 0\r\n    for c in a:\r\n        while b[x] < c:\r\n            x += 1\r\n        while b[y] <= c + d:\r\n            y += 1\r\n        ans += y - x\r\n    ans += t1 * len(a) * (N - len(a)) * 2\r\n    return ans\r\n\r\n\r\ndef set_ini(DX, K):\r\n    a = DX[1][DX[0] == 1]\r\n    a = np.sort(a)\r\n    b = DX[1][DX[0] == 2]\r\n    b = np.sort(b)\r\n    b = np.hstack((b, b + K, b + 2 * K, [3 * K]))\r\n    return a, b\r\n\r\n\r\ndef main():\r\n    f = open('/dev/stdin', 'rb')\r\n    vin = np.fromstring(f.read(), i8, sep=' ')\r\n    N, Q, K = vin[0:3]\r\n    head = 3\r\n    DX = vin[head:head + 2*N].reshape(-1, 2).T\r\n    a, b = set_ini(DX, K)\r\n    head += 2 * N\r\n    T = vin[head: head + Q]\r\n    for t in T:\r\n        print(solve(a, b, t, K, N))\r\n\r\n\r\ndef __starting_point():\r\n    main()\n__starting_point()
from math import factorial\ndef Ncr(n,r):\n    if r<0:return 0\n    return factorial(n)/(factorial(n-r)*factorial(r))\ndef solve(m,n):\n    modulo=10**9+7\n    if m==n:\n        return (Ncr(2*n-1,n-1)+Ncr(2*n-2,n-2))%modulo\n    elif m>n:\n        return (Ncr(m+n,n)-Ncr(m+n-2,n-1))%modulo\n    else:\n        return (Ncr(m+n,m)-Ncr(m+n-2,m-1))%modulo\n        \nt=int(input())\nfor i in range(t):\n    inp=list(map(int,input()))\n    m=inp.count(4)\n    n=inp.count(7)\n    print(solve(m,n))\n
import itertools\nfrom collections import defaultdict as dfd\ndef sumPairs(arr, n):\n s = 0\n for i in range(n-1,-1,-1): \n  s += i*arr[i]-(n-1-i)*arr[i]\n return s\n\ndef subarrayXor(arr, n, m):\n ans = 0\n xorArr =[0 for _ in range(n)]\n mp = dfd(list)\n xorArr[0] = arr[0]\n for i in range(1, n): \n  xorArr[i] = xorArr[i - 1] ^ arr[i]\n for i in range(n):\n  mp[xorArr[i]].append(i)\n a = sorted(mp.items())\n #print(xorArr)\n #print(a)\n for i in a:\n  diffs=0\n  if(i[0]!=0):\n   l = len(i[1])-1\n   ans += sumPairs(i[1],len(i[1]))-((l*(l+1))//2)\n   \n  else:\n   l = len(i[1])-1\n   ans += sumPairs(i[1],len(i[1]))-((l*(l+1))//2)\n   ans += sum(i[1])\n return ans\n\nfor _ in range(int(input())):\n n = int(input())\n arr = list(map(int,input().split()))\n print(subarrayXor(arr,len(arr),0))
from math import *\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(d) for d in input().split()]\n    odd,even = 0,0\n    for i in range(n):\n     if bin(a[i]).count("1")%2 == 1:\n      odd += 1\n     else:\n      even +=1\n    total = 0\n    if odd >= 3 and even >= 2:\n     total += (odd*(odd-1)*(odd-2))//6\n     total += odd*(even*(even-1))//2\n    elif odd >= 3 and even < 2:\n     total +=  (odd*(odd-1)*(odd-2))//6\n    elif 0<odd < 3 and even >= 2:\n     total +=  odd*(even*(even-1))//2\n \n    print(total%(10**9+7))
import math\n\ndef lcm(a, b):\n    return (a*b)//gcd(a, b)\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a%b)    \n    \nfor _ in range(int(input())):\n    n = int(input())\n\n    na = math.ceil((2*n)/math.acos(-1))\n    nb = ((n+1)//2)**2\n\n    nlcm = lcm(na, nb)\n\n    oa = math.ceil(n/2)\n    ob = (n//2)*(n//2+1)\n\n    olcm = lcm(oa, ob)\n\n    if olcm > nlcm:\n        print("Nova's gonna kill me")\n    else:\n        print("YESS(sunglass emo)")\n\n# cook your dish here\n
for _ in range(int(input())):\n s=input()\n if len(s)<4:\n  print("NO")\n else:\n  if s[-4:]=="1000":\n   print("YES")\n  else:\n   print("NO")
def nCr(n,k):\n if(k>n):return 0\n k=min(k,n-k)\n num,den=1,1\n for i in range(k):\n  num*=(n-i)\n  den*=(i+1)\n return num/den\n\ndef Main():\n for cases in range(int(input())):\n  a,b=[int(x) for x in input().split()]\n  print(nCr(a,b))\n\nMain()
test=int(input())\nfor _ in range(test):\n n=int(input())\n ls=list(map(int,input().split()))\n ls.sort()\n s=0\n for i in range(n):\n  if s>=ls[i]:\n   s=s+1\n  else:\n   break\n print(s)
# cook your dish here\nfrom math import sqrt\nfor _ in range(int(input())):\n n=int(input())\n sum=(n*(n+1))//2\n #print(sum)\n if(sum%2!=0):\n  print(0)\n  continue\n m=(int((sqrt(1+4*(sum)))-1)//2)\n if(m*(m+1)//2==sum//2):\n  print((((m-1)*m)//2)+n-m+((n-m-1)*(n-m))//2)\n else:\n  print(n-m)\n
# cook your dish here\nt=int(input())\nfor i in range(t):\n a=0\n b=0\n N,K,x,y=map(int,input().split())\n if x==y:\n  a=N\n  b=N\n elif x>y:\n  if K%4==1:\n   a=N \n   b=y-x+N\n  elif K%4==2:\n   a=y-x+N\n   b=N\n  elif K%4==3:\n   a=0\n   b=x-y\n  else:\n   a=x-y\n   b=0\n else:\n  if K%4==1:\n   a=x-y+N \n   b=N\n  elif K%4==2:\n   a=N\n   b=x-y+N\n  elif K%4==3:\n   a=y-x\n   b=0\n  else:\n   a=0\n   b=y-x\n print(a,b)
import sys,io,os,math\nfrom math import ceil,log,gcd,inf\nfrom itertools import permutations\nmod=1000000007\nmod1=998244353\ndef printlist(n):\n    sys.stdout.write(" ".join(map(str,n)) + "\n")\nprintf=lambda n:sys.stdout.write(str(n)+"\n")\ndef printns(n):\n    sys.stdout.write(str(n))   \ndef intinp():\n    return int(sys.stdin.readline())\ndef strinp():\n    return sys.stdin.readline()\ndef arrinp():\n    return list(map(int,sys.stdin.readline().strip().split()))\ndef mulinp():\n    return list(map(int,sys.stdin.readline().strip().split()))\ndef flush():\n    return sys.stdout.flush()\ndef power_two(x):\n    return (1<<x)\ndef lcm(a,b):\n	return a*b//gcd(a,b)   \ndef solve():\n        n=intinp()\n        ans=str(n)\n        count=0\n        for i in ans:\n                count+=int(i)\n        if(n%count==0):\n                print('Yes')\n                return 0\n        print('No')\n\n\ndef main():\n    tc=intinp()\n    while(tc):\n        solve()\n        tc-=1	\n	\nmain()\n\n
\ndef interesting_nums(m):\n nums = []\n for x in range(m + 1, 2 * m + 1):\n  if x * m % (x - m) == 0:\n   nums.append(x)\n\n return nums\n\n\ndef main():\n\n T = int(input())\n\n for _ in range(T):\n  num_list = interesting_nums(int(input()))\n  print(len(num_list))\n\n  for num in num_list:\n   print(num)\n\n\nmain()
for __ in range(eval(input())):\n    x = eval(input())\n    a = list(map(int,input().split()))\n    key = eval(input())\n    query = eval(input())\n    maxvisited = x #maximum visted value\n    j = x-1\n    ans = []\n    val = 0\n    while j>=0:\n        if a[j]==key:\n            ans.append(val+1)\n            val = val +1\n        else: ans.append(val)\n        j-=1\n    ans.reverse()\n    #print ans\n    for ii in range(query):\n        W = eval(input())\n        print(ans[W], end=' ')\n        print(x-W, end=' ')\n        #print maxvisited, W\n        if maxvisited>W:\n            print(maxvisited-W+1)\n            maxvisited = W\n        else: print('1')\n
from itertools import permutations\nC = list(permutations(['A','B','C','D']))\nV = list(permutations([3,6,9,12]))\nP = list(permutations([25,50,75,100]))\nR = []\n\ndef test():\n d = {}\n n = int(input())\n for i in C[0]:\n  for j in V[0]:\n   d[i+str(j)] = 0\n for i in range(n):\n  x,y = input().split()\n  d[x+y] += 1\n ans = -1000000000\n for i in C:\n  for j in V:\n   for k in P:\n    c = 0\n    for l in range(4): \n     if d[i[l]+str(j[l])] == 0:\n      c -= 100\n     else:\n      c += (d[i[l]+str(j[l])]*k[l])\n    ans = max(ans,c)\n R.append(ans)\n print(ans)\n\ndef __starting_point():\n t = int(input())\n for i in range(t):\n  test()\n print(sum(R))\n\n__starting_point()
import sys\n\nrl=sys.stdin.readline\nT=int(rl())\nfor t in range(T):\n P=int(rl())\n T=(P+1)//2\n F=list(map(int,rl().split()))[1:]\n numtorn=int(rl())\n t=sum(range(1,P+1))-sum(F)\n K=T-numtorn\n print('%.4f' % (t*K/float(T)))\n \n
import math\nn = int(input())\na = sorted(map(int,input().split()))\nl = [0]*n\nfor i in range(n):\n l[i] = a[i] + l[i-1]\nfor q in range(int(input())):\n print(l[int(math.ceil(float(n)/(int(input())+1)))-1])
for _ in range(int(input())):\n N,M = list(map(int,input().split()))\n count,e,perm = 0,0,1\n while(True):\n  lim,start = N//(M**e),N//(M**(e + 1)) + 1\n  num = lim - start + 1\n  divs = num//M\n  if((start + divs*M) <= lim):\n   r = (start+divs*M)%M\n   if(r == 0 or (r + (lim - (start + divs*M)) >= M)):\n    divs += 1\n  cmon = num - divs\n  if(e % 2 == 0):\n   count += cmon*((e+2)//2)\n  else:\n   count += cmon*(e//2 + 1)\n   perm = (perm * pow((e + 3)//2,cmon ,998244353))%998244353\n  e += 1\n  if(start == 1):\n   break\n print(count,perm)\n
n = eval(input())\nr = list(map(int, input().split()))\n\ntree = dict()\ni = 1\nfor j in r:\n c = tree.get(j)\n if c:\n  tree[j].append(i)\n else:\n  tree[j] = [i]\n if not tree.get(i):\n  tree[i] = []\n i += 1\ns = []\nfor elem in tree:\n if not tree[elem]:\n  s.append(str(elem))\nprint(' '.join(s))
from sys import stdin\ndef gt(num):\n if num:\n  return num\n return 0\nfor __ in range(int(stdin.readline().split()[0])):\n n = int(stdin.readline().split()[0])\n a = list(map(int, stdin.readline().split()))\n cnta = dict()\n cnta.setdefault(0)\n cntb = dict()\n cntb.setdefault(0)\n for i in a:\n  cnta[i] = gt(cnta.get(i)) + 1\n asum = 0\n bsum = sum(a)\n ans = 0\n for i in range(n-1):\n  asum += a[i]\n  bsum -= a[i]\n  cnta[a[i]] = gt(cnta.get(a[i])) - 1\n  cntb[a[i]] = gt(cntb.get(a[i])) + 1\n  ans += gt(cnta.get(bsum-asum))\n  ans += gt(cntb.get(asum-bsum))\n print(ans)
t= int(input())\nwhile(t>0):\n    n = int(input())\n    m=0\n    m=n//(2**11)\n    n%=(2**11)\n    while(n>0):\n        num=n%2\n        m+=num\n        n//=2\n    print(m)\n    t-=1
# cook your dish here\nfrom difflib import get_close_matches \nimport sys, os\n\ndef closeMatches(patterns, word): \n return get_close_matches(word, patterns, 1, 0.9)[0]\n\ndef get_string(): \n return sys.stdin.readline().strip() \n\ndef get_ints(): \n return map(int, sys.stdin.readline().strip().split()) \nans = []\ntest = int(input())\nfor i in range(test):\n n,q = get_ints()\n #ans = []\n n = int(n)\n q = int(q)\n patterns=[]\n for j in range(n):\n  s = get_string()\n  patterns.append(s)\n for j in range(q):\n  word = get_string()\n  ans.append(closeMatches(patterns, word))\nfor j in ans:\n sys.stdout.write(j+"\n") 
from math import gcd\nfrom itertools import groupby\n\ndef gcd_split(seq):\n gcds= [int(gcd(a,b)==1) for a,b in zip(seq[1:],seq[:-1])]\n gcds.append(int(gcd(seq[0],seq[-1])==1))\n # print(gcds)\n if max(gcds)==0:\n  return -1\n else:\n  splits=[len(list(x))+1 for num,x in groupby(gcds) if num==0]\n  # print(splits)\n  if gcds[0]==gcds[-1]==0:\n   splits[0] += splits[-1]-1\n   splits = splits[:-1]\n  return splits\n\nfor _ in range(int(input())):\n N=int(input())\n A=[int(x) for x in input().split()]\n split = gcd_split(A)\n # print(split)\n \n res=[]\n if split!=-1:\n  for K in range(2,N+1):\n   temp=(x for x in split if x>=K)\n   ins = sum([(x//(K-1)-1 if x%(K-1)==0 else x//(K-1)) for x in temp])\n   if ins==0:\n    break\n   else:\n    res.append(ins)\n else:\n  for K in range(2,N+1):\n   ins = N//(K-1)+(N%(K-1)>0)\n   if ins==0:\n    break\n   else:\n    res.append(ins)\n \n res = res + [0]*(N-1 -len(res))\n print(*res)
MAX = 100005\ntree = [0] * MAX; \nlazy = [0] * MAX;\n \ndef updateRangeUtil(si, ss, se, us, ue, diff) :\n    if (lazy[si] != 0) :\n        tree[si] += lazy[si];\n        if (ss != se) :\n            lazy[si * 2 + 1] += lazy[si];\n            lazy[si * 2 + 2] += lazy[si];\n        lazy[si] = 0;\n \n    if (ss > se or ss > ue or se < us) :\n        return; \n \n    if (ss >= us and se <= ue) :\n        tree[si] += diff;\n        if (ss != se) :\n            lazy[si * 2 + 1] += diff;\n            lazy[si * 2 + 2] += diff;\n        return; \n \n    mid = (ss + se) // 2;\n    updateRangeUtil(si * 2 + 1, ss,mid, us, ue, diff);\n    updateRangeUtil(si * 2 + 2, mid + 1,se, us, ue, diff);\n    tree[si] = min(tree[si * 2 + 1],tree[si * 2 + 2]); \n \ndef updateRange(n, us, ue, diff) : \n    updateRangeUtil(0, 0, n - 1, us, ue, diff); \n \ndef getSumUtil(ss, se, qs, qe, si) :\n    if (lazy[si] != 0) :\n        tree[si] += lazy[si];\n        if (ss != se) :\n            lazy[si * 2 + 1] += lazy[si];\n            lazy[si * 2 + 2] += lazy[si];\n        lazy[si] = 0;\n \n    if (ss > se or ss > qe or se < qs) :\n        return 10e9; \n \n    if (ss >= qs and se <= qe) :\n        return tree[si]; \n \n    mid = (ss + se) // 2; \n    return min(getSumUtil(ss, mid, qs, qe, 2 * si + 1),getSumUtil(mid + 1, se, qs, qe, 2 * si + 2)); \n \ndef getSum(n, qs, qe) : \n    if (qs < 0 or qe > n - 1 or qs > qe) :\n        #print("Invalid Input", end = "");\n        return -1;\n \n    return getSumUtil(0, n - 1, qs, qe, 0); \n \ndef constructSTUtil(arr, ss, se, si) : \n    if (ss > se) :\n        return;\n    if (ss == se) :\n        tree[si] = arr[ss];\n        return; \n    mid = (ss + se) // 2;\n    constructSTUtil(arr, ss, mid, si * 2 + 1);\n    constructSTUtil(arr, mid + 1, se, si * 2 + 2);\n    tree[si] = min(tree[si * 2 + 1], tree[si * 2 + 2]); \n \ndef constructST(arr, n) :\n    constructSTUtil(arr, 0, n - 1, 0); \n \n# Driver code \nfor _ in range(int(input())):\n    tree = [0] * MAX; \n    lazy = [0] * MAX;\n    n=int(input());\n    y=int(input());\n    arr=[1]*n;\n    constructST(arr, n);\n    for xyz in range(y):\n        l,r=list(map(int,input().split()));\n        updateRange(n, l, r, getSum(n, l, r)%1000000007);\n    print((getSum(n, 0, n-1)%1000000007));\n
from collections import Counter\ntry:\n for _ in range(int(input())):\n  n=int(input())\n  s=input()\n  d1=dict(Counter(s))\n  \n  u,d,r,l=0,0,0,0\n  if 'U' in d1:\n   u=d1['U']\n  else:\n   u=0\n  if 'D' in d1:\n   d=d1['D']\n  else:\n   d=0\n  if 'R' in d1:\n   r=d1['R']\n  else:\n   r=0\n  if 'L' in d1:\n   l=d1['L']\n  else:\n   l=0\n  x=0\n  y=0\n  if l==r:\n   x=0\n  elif l>r:\n   x=-(l-r)\n  elif r>l:\n   x=r-l\n  if u==d:\n   y=0\n  elif d>u:\n   y=-(d-u)\n  elif u>d:\n   y=u-d\n  #  print(x,y)\n  if x==0 and y==0:\n   print(n)\n   continue\n  \n  print(n-(abs(x)+abs(y)))\nexcept:\n pass\n
t=int(input())\nfor _ in range(t):\n n,a,b,c,d,p,q,y=list(map(int,input().split()))\n l=list(map(int,input().split()))\n ans = abs((l[b-1]-l[a-1]))*p\n x=abs(l[c-1]-l[a-1])*p\n if x<=y:\n  x=y+abs(l[d-1]-l[c-1])*q+abs(l[b-1]-l[d-1])*p\n  ans=min(ans,x)\n print(ans)\n
t = int(input())\r\nfor i in range(t):\r\n    q = input().split()\r\n    n = int(q[0])\r\n    m = int(q[1])\r\n    k = int(q[2])\r\n    sumax = 0\r\n    b = []\r\n    for j in range(n):\r\n        a = [int(k) for k in input().split()]\r\n        b = b + [a]\r\n    for j in range(n):\r\n        su = 0\r\n        for x in range(k):\r\n            su = su +b[j][x]\r\n            if su > sumax:\r\n                sumax = su\r\n        for a in range(1, m-k+1):\r\n            su = su - b[j][a-1] +b[j][k+a-1]\r\n            if su > sumax:\r\n                sumax = su\r\n    for j in range(m):\r\n        su = 0\r\n        for x in range(k):\r\n            su = su + b[x][j]\r\n            if su > sumax:\r\n                sumax = su\r\n        for a in range(1, n-k+1):\r\n            su = su - b[a-1][j] + b[a+k-1][j]\r\n            if su > sumax:\r\n                sumax = su\r\n    print(sumax)\r\n            \r\n    \r\n
lst=[1, 2, 4, 8, 13, 21, 31, 45, 66, 81, 97, 123, 148, 182, 204, 252, 290, 361, 401, 475, 565, 593, 662, 775, 822, 916, 970, 1016, 1159, 1312, 1395, 1523, 1572, 1821, 1896, 2029, 2254, 2379, 2510, 2780, 2925, 3155, 3354, 3591, 3797, 3998, 4297, 4433, 4779, 4851, 5123, 5243, 5298, 5751, 5998, 6374, 6801, 6925, 7460, 7547, 7789, 8220, 8503, 8730, 8942, 9882, 10200, 10587, 10898, 11289, 11614, 11876, 12034, 12931, 13394, 14047, 14534, 14901, 15166, 15688, 15972, 16619, 17355, 17932, 18845, 19071, 19631, 19670, 20722, 21948, 22526, 23291, 23564, 23881, 24596, 24768, 25631, 26037, 26255, 27219, 28566, 29775, 30094, 31311, 32217, 32620, 32912, 34277, 35330, 35469, 36204, 38647, 39160, 39223, 39943, 40800, 41882, 42549, 43394, 44879, 45907, 47421, 47512, 48297, 50064, 50902, 52703, 52764, 54674, 55307, 56663, 58425, 59028, 60576, 60995, 62205, 63129, 64488, 66999, 67189, 68512, 68984, 70170, 71365, 75618, 76793, 77571, 79047, 80309, 83179, 84345, 87016, 87874, 88566, 89607, 91718, 92887, 93839, 95103, 97974, 99583, 101337, 102040, 103626, 104554, 106947, 107205, 108622, 111837, 112800, 113949, 114642, 116291, 117177, 121238, 125492, 126637, 129170, 130986, 131697, 134414, 134699, 136635, 139964, 143294, 144874, 146605, 147499, 148593, 150146, 152318, 152834, 156836, 157150, 160782, 163010, 163502, 164868, 170984, 172922, 174171, 177853, 180249, 182071, 185403, 188314, 190726, 190894, 193477, 196832, 199646, 201472, 202699, 205325, 206811, 208748, 214435, 217182, 218011, 225350, 226682, 229163, 231694, 233570, 234619, 235152, 238727, 240814, 247822, 253857, 254305, 260433, 261620, 262317, 266550, 269195, 271511, 274250, 274753, 280180, 284289, 290005, 293034, 295037, 296506, 298414, 302663, 305782, 308841, 317739, 321173, 323672, 324806, 329181, 331018, 336642, 340901, 343359, 347001, 348110, 348899, 362520, 366119, 368235, 370696, 371542, 377450, 380366, 382012, 382245, 384957, 387479, 390518, 391462, 399174, 403920, 411847, 412671, 416880, 417991, 422453, 433973, 434773, 440619, 441148, 443779, 446065, 456289, 458426, 462402, 470670, 474668, 475800, 481476, 482868, 498435, 501084, 508193, 511258, 514644, 524307, 527197, 535369, 536903, 538331, 542020, 555275, 564016, 566106, 567408, 572027, 582478, 583407, 585871, 593257, 596837, 598426, 599784, 607794, 610404, 621790, 624574, 627703, 633442, 640047, 648858, 659179, 663558, 667337, 672815, 673522, 686013, 691686, 693169, 694279, 696931, 703162, 711364, 723249, 729860, 731008, 739958, 740124, 744403, 753293, 768134, 770113, 773912, 779917, 787407, 794900, 797567, 800658, 813959, 814414, 827123, 829129, 839728, 847430, 850695, 851627, 862856, 880796, 884725, 889285, 896691, 897160, 904970, 909586, 915254, 922852, 935695, 937825, 938876, 959937, 961353, 964857, 970227, 976356, 980581, 986799, 1008106, 1009835, 1016906, 1020306, 1028612, 1033242, 1036012, 1042818, 1050881, 1051783, 1060844, 1086402, 1092043, 1096162, 1103456, 1123464, 1134057, 1136410, 1144080, 1145152, 1147774, 1156687, 1164278, 1166255, 1174751, 1187057, 1195316, 1201262, 1207345, 1212654, 1218610, 1225019, 1227887, 1240777, 1247071, 1258235, 1265462, 1274089, 1279515, 1288613, 1298980, 1306248, 1326918, 1333809, 1341190, 1343482, 1367480, 1372734, 1374779, 1384952, 1388147, 1394240, 1395346, 1409612, 1417336, 1418943, 1423296, 1446209, 1448494, 1462599, 1468933, 1474698, 1496110, 1502217, 1508335, 1513944, 1549693, 1552361, 1558304, 1567726, 1578307, 1593543, 1594370, 1596552, 1604567, 1611655, 1638201, 1657904, 1661549, 1668344, 1684653, 1700848, 1704061, 1712218, 1733148, 1744400, 1756959, 1766186, 1770297, 1774640, 1783782, 1790804, 1797186, 1819167, 1822095, 1835790, 1838687, 1840248, 1843265, 1858487, 1871701, 1874449, 1907155, 1933219, 1941873, 1953108, 1960964, 1970086, 1995385, 2005526, 2006388, 2012407, 2022419, 2027444, 2032071, 2046348, 2049691, 2081218, 2085045, 2107005, 2111011, 2117147, 2128804, 2130734, 2133565, 2163069, 2165643, 2183398, 2186582, 2200866, 2228833, 2238757, 2260397, 2287997, 2303690, 2306210, 2311079, 2319657, 2347177, 2348345, 2364629, 2380657, 2386691, 2392303, 2413369, 2429645, 2435861, 2445907, 2454603, 2461156, 2481207, 2493269, 2496558, 2526270, 2549274, 2559084, 2565601, 2571993, 2574622, 2589585, 2602736, 2606052, 2635578, 2636056, 2649712, 2667175, 2697913, 2705598, 2716472, 2726625, 2740640, 2748032, 2769317, 2773637, 2777175, 2796454, 2808141, 2818050, 2822209, 2828335, 2853048, 2858954, 2879003, 2898699, 2906226, 2928135, 2935468, 2950167, 2955230, 2959204, 2981209, 2999992, 3013106, 3016185, 3016728, 3033485, 3041287, 3046405, 3085842, 3097363, 3129048, 3137101, 3148974, 3153026, 3165425, 3172200, 3187649, 3208795, 3228028, 3239797, 3265353, 3281537, 3310390, 3330139, 3349916, 3351744, 3360950, 3366598, 3375910, 3382995, 3411775, 3438201, 3447140, 3453811, 3471520, 3485127, 3522748, 3569412, 3575690, 3578298, 3585562, 3593337, 3624737, 3626198, 3651501, 3667524, 3674434, 3675907, 3738616, 3754186, 3765841, 3786330, 3807381, 3818043, 3829535, 3831874, 3838373, 3862508, 3910613, 3942689, 3950184, 3954465, 3978469, 3992767, 4014701, 4032219, 4033924, 4065368, 4078004, 4089606, 4101646, 4119004, 4155098, 4166329, 4176904, 4182945, 4197748, 4211593, 4218728, 4253237, 4275441, 4288635, 4298689, 4301972, 4329866, 4357640, 4392330, 4403327, 4415543, 4434657, 4454780, 4460817, 4467239, 4489541, 4518764, 4526891, 4541320, 4560957, 4568090, 4582032, 4609341, 4631837, 4683082, 4688874, 4714962, 4728230, 4733954, 4744119, 4797763, 4819301, 4823437, 4850997, 4865482, 4886981, 4907820, 4931122, 4957782, 5005971, 5014678, 5031077, 5054902, 5059300, 5088659, 5119815, 5135680, 5153376, 5210102, 5213548, 5253584]\r\nfor _ in range(int(input())):\r\n    n=int(input())\r\n    sum=0\r\n    for i in range(n):\r\n        print(lst[i],end=" ")\r\n        sum+=lst[i]\r\n    print()\r\n    print(sum)
import math\nimport bisect\nfrom functools import reduce\nfrom collections import defaultdict\n# import sys\n# input = sys.stdin.readline\n\ndef inn():\n return int(input())\n\ndef inl():\n return list(map(int, input().split()))\n\nMOD = 10**9+7\nINF = inf = 10**18+5\n\nn = inn()\na = inl()\nk = []\nfor q in range(inn()):\n k.append(inn())\n\ngcdn = reduce(math.gcd, a)\nlim = max(k)+1\nans = defaultdict(int)\nans[1] = 0\n\nfor i in range(n):\n cur_gcd = a[i]\n for j in range(i, n):\n  cur_gcd = math.gcd(cur_gcd, a[j])\n  if cur_gcd==1 or cur_gcd//gcdn==1:\n   ans[cur_gcd] += (n-j)\n   break\n  ans[cur_gcd] += 1\n# print(ans)\n\nkeys = list(ans.keys())\nans1 = [0]*lim\nfor i in keys:\n for j in range(i, lim, i):\n  ans1[j] += ans[i]\n# print(ans1[:10])\nfor i in k:\n print(ans1[i])
for i in range(int(input())):\n n,k=list(map(int,input().split()))\n t=0\n if n%2!=0:\n  n-=1\n  t+=1\n t+=(n//k)\n if n%k!=0:\n  t+=1\n print(t)\n
def checkValidity(s):\n count = 0\n previous = ""\n\n for x in s:\n  if count == 0:\n   previous = x\n   count += 1\n  elif count == 1:\n   count = 0\n   if previous == x:\n    return "no"\n\n return "yes"\n\nt = int(input())\n\nfor _ in range(t):\n s = input()\n print(checkValidity(s))\n
# cook your dish here\ndef solve(l,r,c,row,col,po):\n    count=0\n    visited=set()\n    stack=set()\n    stack.add((l[row][col],row,col))\n    while stack:\n        ele=stack.pop()\n        visited.add((ele[1],ele[2]))\n        if ele[0]<po:\n            count+=1 \n            if ele[1]-1>=0 and (ele[1]-1,ele[2]) not in visited:\n                if l[ele[1]-1][ele[2]]<po:\n                    stack.add((l[ele[1]-1][ele[2]],ele[1]-1,ele[2]))\n            if ele[1]+1<r and (ele[1]+1,ele[2]) not in visited:\n                if l[ele[1]+1][ele[2]]<po:\n                    stack.add((l[ele[1]+1][ele[2]],ele[1]+1,ele[2]))\n            if ele[2]-1>=0 and (ele[1],ele[2]-1) not in visited:\n                if l[ele[1]][ele[2]-1]<po:\n                    stack.add((l[ele[1]][ele[2]-1],ele[1],ele[2]-1))\n            if ele[2]+1<c and (ele[1],ele[2]+1) not in visited:\n                if l[ele[1]][ele[2]+1]<po:\n                    stack.add((l[ele[1]][ele[2]+1],ele[1],ele[2]+1))\n    return count\nfor _ in range(int(input())):\n    r,c,q=map(int,input().split())\n    l=[]\n    for i in range(r):\n        a=list(map(int,input().split()))\n        l.append(a)\n    for i in range(q):\n        row,col,po=map(int,input().split())\n        print(solve(l,r,c,row-1,col-1,po))
# cook your dish here\n\nd = { 'D': 238, 'T': 244, 'M': 138, 'B': 279, 'C': 186 }\n\ns = list(input())\ntotalCal = 0\n\nfor i in range(len(s)):\n    if s[i] == 'D':\n        totalCal += d['D']\n    if s[i] == 'T':\n        totalCal += d['T']\n    if s[i] == 'M':\n        totalCal += d['M']\n    if s[i] == 'B':\n        totalCal += d['B']\n    if s[i] == 'C':\n        totalCal += d['C']\n\nR = totalCal // 50\nRm = totalCal % 50\nC = Rm // 5\nCm = Rm % 5\nx = totalCal - (R * 50 + C * 5)\n# print(totalCal - R * 50 + C * 5)\nW = int(x * 4 * 0.5)\n# print(R * 50 + C * 5 + W * 0.5)\nprint(R)\nprint(C)\nprint(W)
import math\nf = math.factorial\nfor u in range(eval(input())):\n n, q = list(map(int, input().split()))\n for j in range(q):\n  i,k = list(map(int, input().split()))\n  if k>i:\n   c=0\n   print(c)\n  else:\n   a=2**(n-i)\n   b=1\n   d=int(i-1)\n   e=1\n   h=1\n   g=1\n   #b=f(i-1)/f(k-1)/f(i-k)\n   if(k-1>i-k):\n    for z in range(i-k):\n     b=b*d\n     d=d-1\n     e=e*h\n     h=h+1\n    b=b/e\n   else:\n    for z in range(k-1):\n     b=b*d\n     d=d-1\n     e=e*g\n     g=g+1\n    b=b/e\n    \n     \n     \n   c=a*b\n   c=c%1000000007\n   print(c)
for t in range(int(input())):\n s = input()\n r = input()\n diff = list()\n index = list()\n cnt = 0\n for i in range(len(s)):\n  if s[i] != r[i]:\n   cnt += 1\n   index.append(i)\n for i in range(1, len(index)):\n  diff.append(index[i] - index[i - 1] - 1)\n diff.sort()\n fmin = cnt ** 2\n oper = cnt ; moves = cnt\n for i in diff:\n  moves += i\n  oper -= 1\n  fmin = min(fmin, moves * oper)\n print(fmin)
for _ in range(int(input())):\n s=input()\n n=len(s)\n t=0\n ans=0\n for i in range(n-1):\n  if(s[i]==s[i+1]):\n   t=t+1\n x=t\n for i in range(n):\n  t=x\n  if(i!=0):\n    if(s[i]==s[i-1]):\n     t=t-1\n    else:\n     t=t+1\n  y=t\n  for j in range(i,n):\n   t=y\n   try:\n    if(s[j]==s[j+1]):\n     t=t-1\n    else:\n     t=t+1\n   except:\n    pass\n   ans=ans+t\n print(ans)
from sys import stdout, stdin\nn,m,o = list(map(int, stdin.readline().split()))\nn= n+m+o\nl=[]\na=[]\nfor i in range(n):\n    b= int(stdin.readline())\n    if(b in l and b not in a):\n        l.append(b)\n        a.append(b)\n    elif(b not in l):\n        l.append(b)\n\n\na.sort()\nstdout.write(str(len(a)) + '\n')\nstdout.write(''.join([str(id) + '\n' for id in a]))\n    \n
t=int(input())\nfor _ in range(t):\n n=int(input())\n a=list(map(int,input().split()))\n a.sort()\n s=sum(a)\n if a[0]*(s-a[0])<=a[n-1]*(s-a[n-1]):\n  print(a[0]*(s-a[0]))\n else:\n  print(a[n-1]*(s-a[n-1]))
T=int(input())\nt=[]\nfor _ in range(T):\n N=int(input())\n t.append(N)\nN=max(t)+1\nl=[0 for i in range(N)]\np=1\na=1\nfor i in range(1,N):\n a=(a*i)%1000000007\n p=p*a%1000000007\n l[i]=p\nfor i in t:\n print(l[i])\n
# cook your dish here\ntry:\n for i in range(int(input())):\n  v1,t1,v2,t2,v3,t3=map(int,input().split())\n  ok = 0\n  if t1 <= t3 <= t2:\n   x, y = t2 - t3, t3 - t1\n   ok = x * v3 <= (x + y) * v1 and y * v3 <= (x + y) * v2\n  print('YES' if ok else 'NO')\n    \nexcept:\n pass
t=int(input())\nwhile t:\n t=t-1\n n,x=input().split()\n n=int(n)\n x=int(x)\n d,l=input().split()\n\n if d=='L':\n  p=x\n elif d=='R':\n  p=(n-x)+1\n\n if p%2==1:\n  if l=='H':\n   lang='H'\n  else:\n   lang='E'\n elif p%2==0:\n  if l=='H':\n   lang='E'\n  else:\n   lang='H'\n print(p,lang)
# cook your dish here\nfor _ in range(int(input())):\n    s=input()\n    while(s.count("abc")!=0):\n        s=s.replace("abc","")\n    print(s)    \n
from sys import stdin\nfrom collections import Counter\n\ndef func(arr,n,l):\n count=0\n k=l//n\n if n<len(arr):\n  for ele in arr[0:n]:\n   count+=max(0,k-ele)\n else:\n  for ele in arr:\n   count+=max(0,ele-k)\n return count \n\nfor _ in range(int(stdin.readline())):\n s=stdin.readline().strip()\n d=Counter(s)\n arr=sorted(list(d.values()),reverse=True)\n l=len(s)\n val=[1]\n for i in range(2,27):\n  if l%i==0:\n   val.append(i)\n\n ans = float('inf')\n for ele in val:\n  x = func(arr,ele,l)\n  if x < ans:\n   ans = x\n print(ans) \n
# cook your dish here\nfor t in range(int(input())):\n x1,x2,x3,v1,v2=[int(x)for x in input().rstrip().split()]\n t1=abs(x3-x1)/v1\n t2=abs(x3-x2)/v2\n if t1<t2:\n  print("Chef")\n elif t1>t2:\n  print("Kefa")\n elif t1==t2:\n  print("Draw")\n else:\n  pass\n
try:\n t=int(input())\n for i in range(t):\n  print("Case {}:".format(i+1), end=" ")\n  m, n = map(int,input().split())\n  x, y = map(int,input().split())\n  l = int(input())\n  a=input()\n  destx = a.count("R")-a.count("L")\n  desty = a.count("U")-a.count("D")\n  #print(destx, desty)\n \n  if (destx<0 or destx>m) or (desty<0 or desty>n):\n   result = "DANGER"\n  elif destx == x and desty == y:\n   result = "REACHED"\n  else:\n   result = "SOMEWHERE"\n \n  print(result)\nexcept:\n pass
def isSolvable( W, R):\r\n        LW, LR, F, ML, AW, V, LMap = len(W), len(R), set([w[0] for w in W+[R]]), max(map(len, W+[R])), W+[R], set(), {}\r\n        if LR < ML: return False\r\n        def dfs(d,i,c):\r\n            if d == ML: return c == 0\r\n            if i == len(W) + 1:\r\n                s = sum(LMap[w[-d-1]] if d < len(w) else 0 for w in W) + c\r\n                return dfs(d+1,0,s//10) if s % 10 == LMap[R[-d-1]] else False\r\n            if i < LW and d >= len(W[i]): return dfs(d,i+1,c)\r\n            ch = AW[i][-d-1]\r\n            if ch in LMap: return dfs(d,i+1,c)\r\n            for x in range((ch in F), 10):\r\n                if x not in V:\r\n                    LMap[ch], _ = x, V.add(x)\r\n                    if dfs(d,i+1,c): return True\r\n                    V.remove(LMap.pop(ch))\r\n        return dfs(0,0,0)\r\nn=int(input())\r\nW=[]\r\nfor i in range(n):\r\n    W.append(str(input()))\r\nR=input()    \r\na=(isSolvable(W,R))\r\nif a==True:\r\n    print("true")\r\nelse:\r\n    print("false")
t=int(input())\nfor i in range(t):\n n,k=map(int,input().split())\n m=list(map(int,input().split()))\n a=0\n for i in m:\n  if i>=k:\n   a=1\n   break\n if a==1:\n  print('YES')\n else:\n  print('NO')
def fun(a,cur,n,cnt):\n    if cur>=n-1:\n        return\n    for i in range(cur,n-1):\n        if i<n-2:\n            if a[i]>0 and a[i+1]>0:\n                a[i]-=1\n                a[i+1]-=1\n                a[i+2]+=1\n                cnt[0]=(cnt[0]+1)%1000000007\n                fun(a,i,n,cnt)\n                a[i]+=1\n                a[i+1]+=1\n                a[i+2]-=1\n        else:\n            if a[i]>0 and a[i+1]>0:\n                a[i]-=1\n                a[i+1]-=1\n                a.append(1)\n                cnt[0]=(cnt[0]+1)%1000000007\n                fun(a,i,n+1,cnt)\n                a[i]+=1\n                a[i+1]+=1\n                a.pop()\ntc=int(input())\nfor case in range(tc):\n    n=int(input())\n    a=list(map(int,input().split()))\n    cnt=[1]\n    fun(a,0,n,cnt)\n    print(cnt[0]%1000000007)\n    \n
t=int(input())\r\nfor i in range(t):\r\n     x,n=[int(g) for g in input().split()]\r\n     sal=0\r\n     day=x\r\n     while day<n:\r\n          sal=sal+day\r\n          day+=x\r\n     print(sal)\r\n
t = int(input())\nwhile t != 0:\n    M = 1000000007\n    n, m = list(map(int, input().split())) \n    ans = 1\n    tt = n//2\n    tt = tt * (tt + 1)\n    \n    ans = pow(m, tt, M)\n    \n    print(ans)\n    t -= 1\n    \n    \n
import sys\r\nfrom collections import defaultdict\r\nfrom copy import copy\r\n\r\nR = lambda t = int: t(eval(input()))\r\nRL = lambda t = int: [t(x) for x in input().split()]\r\nRLL = lambda n, t = int: [RL(t) for _ in range(n)]\r\n\r\ndef solve():\r\n    N, Q = RL()\r\n    P = RL()\r\n    B = RL()\r\n    phones = sorted(zip(P, B))\r\n    S = defaultdict(lambda : [])\r\n            \r\n    for p, b in phones:\r\n        for i in range(2**7):\r\n            if (i>>b) & 1:\r\n                S[i] += [p]\r\n    B = set(B)\r\n    I = [0] * len(B)\r\n\r\n    for _ in range(Q):\r\n        b, K = RL()\r\n        s = RL()\r\n        x = 0\r\n        for b in s:\r\n            x += 1<<b\r\n        if len(S[x]) < K:\r\n            print(-1)\r\n        else:\r\n            print(S[x][-K])\r\n            \r\n\r\nT = 1#R()\r\nfor t in range(1, T + 1):\r\n    solve()\r\n
from math import sqrt\n\nT = int(input())\nans = []\n\nfor _ in range(T):\n X = int(input())\n\n count = 0\n x = 0\n y = 0\n while(x<=X):\n  p = int(sqrt(y))\n  count += 1\n  if(p*p>y):\n   x = p\n   y += p**2\n  else:\n   x = p+1\n   y += (p+1)**2\n if(x<=X):\n  ans.append(count)\n else:\n  ans.append(count-1)\n\nfor i in ans:\n print(i)
def sort_str(s):\n    o = []\n    for c in s:\n        o.append(c)\n    o.sort()\n    return "".join(o)\ndef find_ana(s):\n    if len(s) <= 1:\n        return 0\n    h = {}\n    c = 0\n    for i in range(len(s)):\n       for j in range(i+1, len(s)+1):\n          t = sort_str(s[i:j])\n          if t in h:\n            c += h[t]\n            h[t] += 1\n          else:\n            h[t] = 1\n    return c\nt = int(input())\nfor _ in range(t):\n    print(find_ana(input()))
t=int(input())\n \ndef vsense(val,a,l):\n sense=0\n ctr=a\n for c in range(n):\n  if val[c]<=ctr:\n   sense+=-1\n  else:\n   sense+=1\n  ctr+=l\n return sense\n \nwhile t:\n n,l,a,b=list(map(int,input().split()))\n val=list(map(int,input().split()))\n val.sort()\n sense=0\n if b==a+n*l or vsense(val,a,l)<=0:\n  loc=a\n else:\n  st=a\n  end=b-n*l\n  while st<=end:\n   m=(st+end)/2\n   chk=vsense(val,m,l)\n   if chk==0:\n    loc=m\n    break\n   elif chk<0:\n    end=m-1\n   else:\n    loc=m\n    st=m+1\n ans=0\n st=loc\n for c in range(n):\n  ans+=abs(st-val[c])\n  st+=l\n print(ans)\n \n t-=1\n
\n\nimport fractions\nimport sys\n\nf = sys.stdin\n\nif len(sys.argv) > 1:\n    f = open(sys.argv[1], "rt")\n\n\nsum_cache = {}\n\ndef sum_func(x):\n    if x < 10:\n        return x\n\n    r = sum_cache.get(x)\n    if r is not None:\n        return r\n\n    xx = 0\n    while x > 0:\n        xx += x % 10\n        x /= 10\n\n    r = sum_func(xx)\n    sum_cache[x] = r\n\n    return r\n\ndef test():\n    for n in range(1):\n        print(n, sum_func(n))\n\n    print(sum_func(int(10**18 - 1)))\n\n#~ test()\n#~ sys.exit(1)\n\ncycle_table = [\n  # Cycle len, markers              # D_kfunc\n  [9, [1, 1, 1, 1, 1, 1, 1, 1, 1]], # 1\n  [9, [1, 1, 1, 1, 1, 1, 1, 1, 1]], # 2\n  [3, [1, 0, 0, 1, 0, 0, 1, 0, 0]], # 3\n  [9, [1, 1, 1, 1, 1, 1, 1, 1, 1]], # 4\n  [9, [1, 1, 1, 1, 1, 1, 1, 1, 1]], # 5\n  [3, [1, 0, 0, 1, 0, 0, 1, 0, 0]], # 6\n  [9, [1, 1, 1, 1, 1, 1, 1, 1, 1]], # 7\n  [9, [1, 1, 1, 1, 1, 1, 1, 1, 1]], # 8\n  [1, [1, 0, 0, 0, 0, 0, 0, 0, 0]], # 9\n]\n\nNUMBER = 9\n\ndef calc(A_1, D, L, R):\n    #~ print('calc ===', A_1, D, L, R)\n    A_L = A_1 + D * (L - 1)\n    A_L_kfunc = sum_func(A_L)\n    D_kfunc = sum_func(D)\n\n    #~ print(A_L, A_L_kfunc, D_kfunc)\n\n    n = R - L + 1\n\n    if D == 0:\n        return n * A_L_kfunc\n\n    cycle_len = cycle_table[D_kfunc - 1][0]\n    cycle_markers = list(cycle_table[D_kfunc - 1][1]) # copy\n    #~ print('cycle_len', cycle_len)\n\n    whole_part = n // cycle_len\n    remainder = n % cycle_len\n    #~ print('whole_part, remainder = ', whole_part, remainder)\n\n    counts = [whole_part * x for x in cycle_markers]\n    #~ print(counts)\n\n    pos = 0\n    for i in range(remainder):\n        counts[pos] += 1\n        pos = (pos + D_kfunc) % NUMBER\n\n    #~ print(counts)\n\n    r = 0\n    for i, x in enumerate(counts):\n        value = (A_L_kfunc - 1 + i) % NUMBER + 1\n        r += value * x\n\n    return r\n\ndef calc_dumb(A_1, D, L, R):\n    #~ print('dumb ===', A_1, D, L, R)\n    a = A_1 + D * (L - 1)\n\n    n = R - L + 1\n\n    r = 0\n\n    for i in range(n):\n        value = sum_func(a)\n        #~ print(a, value)\n        r += value\n        a += D\n\n    return r\n\ndef test1():\n    a1 = 1\n    L = 1\n    R = 1000\n    for d in range(100):\n        r1 = calc_dumb(a1, d, L, R)\n        r2 = calc(a1, d, L, R)\n        if r1 != r2:\n            print(a1, d, L, R, ":", r1, r2)\n\n\ndef test2():\n    a1 = 1\n    d = 9\n    L = 1\n    R = 9\n    r1 = calc_dumb(a1, d, L, R)\n    r2 = calc(a1, d, L, R)\n    print(r1, r2)\n\n#~ test1()\n#~ sys.exit(1)\n\nT = int(f.readline().strip())\n\nfor case_id in range(1, T+1):\n    A_1, D, L, R = list(map(int, f.readline().strip().split()))\n\n    r = calc(A_1, D, L, R)\n\n    print(r)\n
t=eval(input())\ndef func(k,n,x,dist,graph):\n if k==n:\n  x+=[dist[n]]\n  return\n for i in range(1,n+1):\n  if graph[k][i]!=0 and dist[i]==-1:\n   dist[i]=dist[k]+graph[k][i]\n   func(i,n,x,dist,graph)\n   dist[i]=-1\n   \nwhile t:\n graph=[[0 for i in range(11)]for j in range(11)]\n v,e=list(map(int,input().split()))\n for i in range(e):\n  x,y,w=list(map(int,input().split()))\n  graph[x][y]=w\n  graph[y][x]=w\n x=[]\n dist=[-1]*(v+1)\n dist[1]=0\n func(1,v,x,dist,graph)\n x.sort()\n val=x[0]\n ans=0\n for i in range(len(x)):\n  if val==x[i]:\n   ans+=1\n print(ans)\n t-=1\n
from collections import defaultdict\nfrom itertools import product\n\ndef solve(mouse,n,m):\n \n # shadow matrix will contains the count of mice which affect (i,j) position\n # if there is a mice at position (i,j) then in shadow matrix it will affect all four adjacent blocks \n shadow=[[0 for i in range(m)]for j in range(n)]\n for i,j in product(list(range(n)),list(range(m))):\n  if mouse[i][j]==1:\n   if i>0:\n    shadow[i-1][j]+=1\n   if j>0:\n    shadow[i][j-1]+=1\n   if i<n-1:\n    shadow[i+1][j]+=1\n   if j<m-1:\n    shadow[i][j+1]+=1\n \n # dp is a dictionary which contains a tuple of 3 values (i,j,0)=>we are coming at destination (i,j) from left side\n # (i,j,1)=> we are coming at destination (i,j) from top \n dp=defaultdict(int)\n \n # \n dp[(0,0,0)]=dp[(0,0,1)]=shadow[0][0]-mouse[0][0]\n \n # fill only first row\n # in first row we can only reach at (0,j) from (0,j-1,0) as we can't come from top.\n \n # so here we will assign count of mices which will affect current cell(shadow[0][i]) + previous result i.e,(0,j-1,0) and \n # if mouse is in the current cell than we have to subtract it bcoz we have add it twice i.e, when we enter at this block \n # and when we leave this block \n for i in range(1,m):\n  dp[(0,i,0)]=dp[(0,i,1)]=shadow[0][i]-mouse[0][i]+dp[(0,i-1,0)]\n \n # same goes for first column\n # we can only come at (i,0) from (i-1,0) i.e top\n for i in range(1,n):\n  dp[(i,0,0)]=dp[(i,0,1)]=shadow[i][0]-mouse[i][0]+dp[(i-1,0,1)]\n \n \n # for rest of the blocks \n # for a block (i,j) we have to add shadow[i][j] and subtract mouse[i][j] from it for double counting\n # now for each block we have two choices, either take its previous block with same direction or take previous block with different \n # direction and subtract corner double counted mouse. We have to take min of both to find optimal answer\n for i,j in product(list(range(1,n)),list(range(1,m))):\n  a=shadow[i][j]-mouse[i][j]\n  b=a\n  a+=min(dp[(i,j-1,0)],dp[(i,j-1,1)]-mouse[i-1][j])\n  b+=min(dp[(i-1,j,1)],dp[(i-1,j,0)]-mouse[i][j-1])\n  dp[(i,j,0)]=a\n  dp[(i,j,1)]=b\n  \n # what if [0][0] and [n-1][m-1] have mice, so we have to add them as we haven't counted them yet.\n \n return min(dp[(n-1,m-1,0)],dp[(n-1,m-1,1)])+mouse[0][0]+mouse[n-1][m-1]\n    \nfor _ in range(int(input())):\n n,m=list(map(int,input().split( )))\n mouse=[]\n for i in range(n):\n  x=input()\n  mouse.append(list(map(int,x)))\n print(solve(mouse,n,m))\n \n    \n    \n    \n    \n    \n    \n    \n    \n    \n
for _ in range(int(input())):\n l=list(map(str,input().split()))\n a=[(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]\n c=0\n for i in a:\n  if len(set([l[i[0]-1],l[i[1]-1],l[i[2]-1]]))==1:\n   c=1\n   break\n if c==1:\n  print("YES")\n else:\n  print("NO")\n
for _ in range(int(input())):\n n=int(input())\n a=[]\n b=[]\n for i in range(4*n-1):\n  c,d=list(map(int,input().split()))\n  a.append(c)\n  b.append(d)\n c1=0\n c2=0\n for i in a:\n  c1^=i\n for i in b:\n  c2^=i\n print(c1,c2)
for _ in range(int(input())):\n n, k = map(int, input().split())\n arr= list(map(int, input().split()))\n motu, tomu = [], []\n for i in range(n):\n  if i%2 == 0:\n   motu.append(arr[i])\n  else:\n   tomu.append((arr[i]))\n motu.sort(reverse=True)\n tomu.sort()\n for i in range(len(motu)):\n  if len(tomu)-1<i:\n   break\n  if k==0:\n   break\n  if tomu[i]<motu[i]:\n   tomu[i], motu[i] = motu[i], tomu[i]\n   k-=1\n if sum(tomu) > sum(motu):\n  print("YES")\n else:\n  print("NO")
dic = {}\n#num = "1"\n#def tonum(num):\n#   res=0\n#   for i in range(len(num)):\n#       res = 2*res + int(num[i])\n#   return res\n\n#for i in range(64):\n#   number = tonum(num)\n#   dic[num] = []\n#   num = num+"0"\n\nn = int(input())\nflag=0\nif n >= 68:\n inp = input()\n print("Yes")\nelse:\n inp = [int(x) for x in input().split()]\n for i in range(len(inp)-1):\n  for j in range(i+1,len(inp)):\n   xor = inp[i]^inp[j]\n   if xor in list(dic.keys()):\n    for pair in dic[xor]:\n     (x,y) = pair\n     if x != i and y!=j and x!=j and y!=i:\n      flag = 1\n      break\n\n    dic[xor].append((i,j))\n   else:\n    dic[xor] = []\n    dic[xor].append((i,j))\n   if flag is 1:\n    break\n  if flag is 1:\n   break\n\n if flag is 1:\n  print("Yes")\n else:\n  print("No")\n \n \n
from operator import add\nfrom functools import reduce\n\nchoices=[]\n\nfor x in range(1800):\n num_str = list(map (int, str (2**x)))\n suma = reduce (add, num_str)\n choices.append(suma)\nN=int(input())\n\nfor x in range(N):\n t=int(input())\n print(choices[t])\n
# cook your dish here\nclass node:\n	def __init__(self,a,b=0,c=0):\n		self.val=a\n		self.a=b\n		self.b=c\n\narr=[]\n\ndef finder(node,val):\n	if(arr[node].val==0):\n		return val\n	else:\n		a=finder(arr[node].a,val)\n		b=finder(arr[node].b,val)\n		if(arr[node].val==1):\n			return a+b-a*b\n		else:\n			return a*b\n\nt=int(input())\nwhile(t>0):\n	x=input()\n	n=int(input())\n	arr.append(node(0))\n	for i in range(0,n):\n		vals=input().split()\n		sz=len(vals)\n		for i in range(0,sz):\n			vals[i]=int(vals[i])\n		if(vals[0]==0):\n			next=node(0)\n			arr.append(next)\n		else:\n			next=node(vals[0],vals[1],vals[2])\n			arr.append(next)\n	lower=0.0\n	higher=1.0\n	eps=1e-9\n	while((higher-lower)>eps):\n		mid=(higher+lower)/2.0 \n		if(finder(n,mid)>0.5):\n			higher=mid\n		else:\n			lower=mid\n	print("%.5f" %(higher))\n	arr=[]\n	# print(higher)\n	t-=1
import sys\n\ndef GRIG(L):\n\n    LENT = len(L)\n    MINT = 1\n    GOT = 0\n\n    DY = [ [{x: 0 for x in range(0, 10)}, 0, 0] ]\n\n    for i in L:\n\n        DY.append([{x: 0 for x in range(0, 10)}, 0, 0])\n        GOT += 1\n\n        for j in range(0, GOT):\n\n            if DY[j][0][i] == 1:\n                DY[j][0][i] = 0\n                DY[j][1] -= 1\n            else:\n                DY[j][0][i] = 1\n                DY[j][1] += 1\n\n            DY[j][2] += 1\n\n            if DY[j][1] <= 1 and DY[j][2] > MINT:\n                MINT = DY[j][2]\n\n    return MINT\n\nTESTCASES = int(input().strip())\n\nfor i in range(0, TESTCASES):\n    \n    L = [int(x) for x in list(input().strip())]\n    \n    print(GRIG(L))\n
divisors = [1 , 2 , 3 , 4 , 6 , 8 , 9 , 10 , 12 , 16 , 18 , 20 , 24 , 30 , 32 , 36 , 40 , 48 , 60 , 64 , 72 , 80 , 84 , 90 , 96 , 100 , 108 , 120 , 128 , 144 , 160 , 168 , 180 , 192 , 200 , 216 , 224 , 240 , 256 , 288 , 320 , 336 , 360 , 384 , 400 , 432 , 448 , 480 , 504 , 512 , 576 , 600 , 640 , 672 , 720 , 768 , 800 , 864 , 896 , 960 , 1008 , 1024 , 1152 , 1200 , 1280 , 1344 , 1440 , 1536 , 1600 , 1680 , 1728 , 1792 , 1920 , 2016 , 2048 , 2304 , 2400 , 2688 , 2880 , 3072 , 3360 , 3456 , 3584 , 3600 , 3840 , 4032 , 4096 , 4320 , 4608 , 4800 , 5040 , 5376 , 5760 , 6144 , 6720 , 6912 , 7168 , 7200 , 7680 , 8064 , 8192 , 8640 , 9216 , 10080 , 10368 , 10752 , 11520 , 12288 , 12960 , 13440 , 13824 , 14336 , 14400 , 15360 , 16128 , 16384 , 17280 , 18432 , 20160 , 20736 , 21504 , 23040 , 24576 , 25920 , 26880 , 27648 , 28672 , 28800 , 30720 , 32256 , 32768 , 34560 , 36864 , 40320 , 41472 , 43008 , 46080 , 48384 , 49152 , 51840 , 53760 , 55296 , 57600 , 61440 , 62208 , 64512 , 65536 , 69120 , 73728 , 80640 , 82944 , 86016 , 92160 , 96768 , 98304 , 103680 , 107520 , 110592 , 115200 , 122880 , 124416 , 129024 , 131072 , 138240 , 147456 , 153600 , 161280 , 165888 , 172032 , 184320 , 193536 , 196608 , 207360 , 215040 , 221184 , 230400 , 245760]\nnumbers = [1 , 2 , 4 , 6 , 12 , 24 , 36 , 48 , 60 , 120 , 180 , 240 , 360 , 720 , 840 , 1260 , 1680 , 2520 , 5040 , 7560 , 10080 , 15120 , 20160 , 25200 , 27720 , 45360 , 50400 , 55440 , 83160 , 110880 , 166320 , 221760 , 277200 , 332640 , 498960 , 554400 , 665280 , 720720 , 1081080 , 1441440 , 2162160 , 2882880 , 3603600 , 4324320 , 6486480 , 7207200 , 8648640 , 10810800 , 14414400 , 17297280 , 21621600 , 32432400 , 36756720 , 43243200 , 61261200 , 73513440 , 110270160 , 122522400 , 147026880 , 183783600 , 245044800 , 294053760 , 367567200 , 551350800 , 698377680 , 735134400 , 1102701600 , 1396755360 , 2095133040 , 2205403200 , 2327925600 , 2793510720 , 3491888400 , 4655851200 , 5587021440 , 6983776800 , 10475665200 , 13967553600 , 20951330400 , 27935107200 , 41902660800 , 48886437600 , 64250746560 , 73329656400 , 80313433200 , 97772875200 , 128501493120 , 146659312800 , 160626866400 , 240940299600 , 293318625600 , 321253732800 , 481880599200 , 642507465600 , 963761198400 , 1124388064800 , 1606268664000 , 1686582097200 , 1927522396800 , 2248776129600 , 3212537328000 , 3373164194400 , 4497552259200 , 6746328388800 , 8995104518400 , 9316358251200 , 13492656777600 , 18632716502400 , 26985313555200 , 27949074753600 , 32607253879200 , 46581791256000 , 48910880818800 , 55898149507200 , 65214507758400 , 93163582512000 , 97821761637600 , 130429015516800 , 195643523275200 , 260858031033600 , 288807105787200 , 391287046550400 , 577614211574400 , 782574093100800 , 866421317361600 , 1010824870255200 , 1444035528936000 , 1516237305382800 , 1732842634723200 , 2021649740510400 , 2888071057872000 , 3032474610765600 , 4043299481020800 , 6064949221531200 , 8086598962041600 , 10108248702552000 , 12129898443062400 , 18194847664593600 , 20216497405104000 , 24259796886124800 , 30324746107656000 , 36389695329187200 , 48519593772249600 , 60649492215312000 , 72779390658374400 , 74801040398884800 , 106858629141264000 , 112201560598327200 , 149602080797769600 , 224403121196654400 , 299204161595539200 , 374005201994424000 , 448806242393308800 , 673209363589963200 , 748010403988848000 , 897612484786617600 , 1122015605983272000 , 1346418727179926400 , 1795224969573235200 , 2244031211966544000 , 2692837454359852800 , 3066842656354276800 , 4381203794791824000 , 4488062423933088000 , 6133685312708553600 , 8976124847866176000 , 9200527969062830400]\nt = int(input())\nfor x in range(0, t):\n    a = int(input())\n    i = 0\n    for y in divisors:\n        if y > a:\n            print("win", numbers[i])\n            break\n        i = i+1\n    else:\n        print("lose")\n
print(25)
t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = input().strip()\n    prev = a[0]\n    ans = -1\n    for i in a:\n        if prev == i:\n            ans += 1\n        prev = i\n    print(ans)\n
# cook your dish here\r\nfor _ in range(int(input())):\r\n    a,b,c=list(map(int, input().split()))\r\n    p=a*100+b\r\n    mx=p \r\n    ans, cnt = 0, 0\r\n    while True:\r\n        cnt+=1 \r\n        if p<c or cnt==10000:\r\n            break\r\n        \r\n        else:\r\n            p-=c \r\n            a=p//100\r\n            b=p%100\r\n            p=b*100+a\r\n            if p>mx:\r\n                mx=p\r\n                ans=cnt\r\n        \r\n    print(ans)   
test=int(input())\nfor i in range(test):\n N=input()\n X=[]\n list2=[]\n for x in N:\n  X.append(x)\n list1=[]\n list1=list(set(X))\n output=''\n for x in list1:\n  for y in X:\n   if int(x)>=6:\n    n=int(x)*10+int(y)\n    list2.append(n)\n for j in list1:\n  if int(j)>=6:\n   m=int(j)*10+int(j)\n   list2.remove(m)\n list2.sort()\n if len(list2)==0:\n  print(" ")\n else:\n  list2.sort()\n  for k in list2:\n   if chr(k) not in output and 64<k<91:\n    output+=chr(k)\n  print(output)\n \n
# cook your dish here\nt=int(input())\nfor _ in range(t):\n    n = int(input())\n    for i in range(n+1):\n        b = n\n        for space in range(n-i):\n            print(" ",end="")\n        for j in range(i+1):\n            print(b,end="")\n            b-=1\n        print()\n    for l in range(n):\n        a = n\n        for j1 in range(0,l+1):\n            print(" ",end="")\n        for k in range(n-l):\n            print(a,end="")\n            a-=1\n\n        print()
# cook your dish here\nt = int(input())\nwhile t:\n    x = int(input())\n    arr = [int(i) for i in input().split()]\n    total = 0\n    for i in arr:\n        if i % 6 == 0:\n            total += 6\n        else:\n            total += (i % 6)\n    print(total)\n    t -= 1
n=int(input())\nfor i in range(n):\n    k,x=map(int,input().split())\n    l=list(map(int,input().split()))\n    f,e,o=0,0,0\n    for i in l:\n     if(i%2==0):\n      e+=1\n     else:\n      o+=1\n    if(o<=x//2):\n     f=1\n    elif(e<=x//2):\n     if((k-x)%2!=0):\n      f=0\n     else:\n      f=1\n    else:\n     if(x%2==0):\n      f=1\n     else:\n      f=0\n    if(f==1):\n     print('Jesse')\n    else:\n     print('Walter')
from math import *\nfor t in range(int(input())):\n n = int(input())\n numberlist = list(map(int,input().split()))\n numberlist.sort()\n print(numberlist[0]* ( len(numberlist) -1))
a = int(input())\r\nfor i in range(a):\r\n	b = input()\r\n	if '5' in b or '0' in b:\r\n		print(1)\r\n		continue\r\n	print(0)
c=0\nfor i in range (int(input ())):\n	a, b=map(int, input().split())\n	c+=abs(a-b)+1\nprint(c%((10**9) +7)) 
n = int(input())\r\nl = [0] * n\r\nfor x in range(n):\r\n    l[x] = int(input())\r\nfor i in range(n):\r\n    z = 1\r\n    for j in range(1,l[i]+1):\r\n        for k in range(1,l[i]+1):\r\n            print(z,end='')\r\n            z += 2\r\n        print()
# cook your dish here\nl1=int(input())\nfor i in range(l1):\n    x=int(input())\n    y=list(map(int,input().split()))\n    z=list(map(int,input().split()))\n    if max(z)!=max(y):\n        print('YES')\n    else:\n        print('NO')
import sys\nsys.setrecursionlimit(10000000)\ndef mergeSortInversions(arr):\n  if len(arr) == 1:\n    return arr, 0\n  larr=len(arr)\n  a = arr[:larr//2]\n  b = arr[larr//2:]\n  a, ai = mergeSortInversions(a)\n  b, bi = mergeSortInversions(b)\n  c = []\n  i = 0\n  j = 0\n  inversions = 0 + ai + bi\n  la=len(a)\n  while i < la and j < len(b):\n    if a[i] <= b[j]:\n      c.append(a[i])\n      i += 1\n    else:\n      c.append(b[j])\n      j += 1\n      inversions += (la-i)\n  c += a[i:]\n  c += b[j:]\n  return c, inversions \nfor _ in range(int(input())):\n  n,d=list(map(int,input().split()))\n  p=[int(o) for o in input().split()]\n  array=[[] for i in range(d)]\n  flag=0\n  for i in range(n):\n    array[i%d].append(p[i])\n    if p[i]%((i%d)+1)!=0:\n      flag=1\n  \n \n  ans=0\n  dumarr=[0]*n\n  for i in range(d):\n    array[i],v=mergeSortInversions(array[i])\n    for j in range(len(array[i])):\n      dumarr[i+j*d]=array[i][j]\n    ans+=v\n  p=sorted(p)\n  # print(dumarr)\n  if dumarr==p:\n    print(ans)\n  else:\n    print(-1)\n
# cook your dish here\ndef finder(n):\n    cnt=0\n    for i in range(2,n+1):\n        a=n\n        while a!=0:\n            r=a%i\n            a=a//i\n        if r==1:\n            cnt+=1\n    return cnt\n\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    if n==0:\n        print(0)\n    elif n==1:\n        print('INFINITY')\n    else:\n        print(finder(n))\n    
# cook your dish here\nfor i in range(int(input())):\n    n,k=[int(i) for i in input().split()]\n    if(n%2==0):\n     if(k<(n*(n+1))//2 - 1  or  k>3*((n//2)**2) - 1):print(-1)\n     elif(k==(n*(n+1))//2 - 1):\n      for i in range(1,n+1):print(i,'',end='')\n      print()\n     else:\n      k,count,p,l,x = k-(n*(n+1))//2 + 1,0,0,[0 for i in range(n)],1\n      while(k>0):p+=2 ;k,count = k-n+p ,count+1\n      for i in range(n,n-count+1,-1):l[x]=i ;x+=2\n      k=-k ;l[2*count - 1 +k],p = n-count+1 ,1\n      for i in range(n):\n       if(l[i]==0):l[i]=p ;   p+=1 \n      for i in l:print(i,'',end='')\n      print()\n    else:\n     if(n==1):print(1) if(k==0) else print(-1)                \n     elif(k<(n*(n+1))//2 - 1  or k>3*(n//2)*(n//2 + 1)):print(-1)\n     elif(k==(n*(n+1))//2 - 1):\n      for i in range(1,n+1):print(i,'',end='')\n      print()\n     else:\n      k,count,p,l,x = k-(n*(n+1))//2 + 1,0,0,[0 for i in range(n)],1\n      while(k>0):  p+=2 ;  k,count = k-n+p ,count+1
t=int(input())\r\nfor _ in range(t):\r\n    n=int(input())\r\n    p=10**9+7\r\n    a=(pow(3,n+1,p)-1)\r\n    \r\n    b=(pow(2,n+1,p)-1)\r\n  \r\n    print((((3*a)//2)%p-(2*(b))%p+p)%p)
import sys\n\ndef _r(*conv) :\n r = [conv[i](x) for i, x in enumerate(input().strip().split(' '))]\n return r[0] if len(r) == 1 else r\n\ndef _ra(conv) :\n return list(map(conv, input().strip().split(' ')))\n\ndef _rl() :\n return list(input().strip())\n\ndef _rs() :\n return input().strip()\n\ndef _a(k, *v) :\n return all(x == k for x in v)\n\ndef _i(conv) :\n for line in sys.stdin :\n  yield conv(line)\n##################################################################\n\nn = _r(int)\nlookup = dict([(x, i) for i, x in enumerate(_ra(str))])\ng = [(set(), dict()) for _ in range(n)]\n\nm = _r(int)\nfor _ in range(m) :\n c1, c2, d = _r(str, str, int)\n i1 = lookup[c1]\n\n g[i1][0].add(c2)\n g[i1][1][c2] = d\n\n\nt = _r(int)\nfor _ in range(t) :\n k = _ra(str)[1:]\n \n failed = False\n if len(set(k)) != len(k) :\n  failed = True\n\n if not failed :\n  if k[0] not in lookup : \n   failed = True\n  else : \n   r = 0\n   v = g[lookup[k[0]]]\n\n   for i in range(1, len(k)) : \n    if k[i] not in v[0] : \n     failed = True\n     break\n\n    r += v[1][k[i]]\n    v = g[lookup[k[i]]]\n   \n   if not failed : \n    print(r)\n  \n if failed : \n  print('ERROR')\n
# cook your dish here\nimport math\nN = 10**6\nsum_arr = [0] * (N + 1) \ndef lprime():\n    arr = [0] * (N + 1) \n    arr[0] = 1\n    arr[1] = 1\n    for i in range(2, math.ceil(math.sqrt(N) + 1)): \n        if arr[i] == 0: \n            for j in range(i * i, N + 1, i): \n                arr[j] = 1\n      \n    curr_prime_sum = 0\n\n    for i in range(1, N + 1): \n        if arr[i] == 0: \n            curr_prime_sum += i \n        sum_arr[i] = curr_prime_sum \n        \nn=int(input())\nlprime()\nfor _ in range(n):\n    x=int(input())\n    print(sum_arr[x]%10)
# cook your dish here\nT = int(input())\n\nfor i in range(T):\n    N,data,D,People = int(input()),list(map(int,list(input()))),int(input()),list(map(int,input().split()))\n    \n    data.insert(0,"|"),data.append("|")\n    infected = []\n    for i in range(1,N+1):\n        if(data[i]==1):\n            infected.append(i)\n    \n    i = 0\n    while(i<D):\n        boundary = People[i] + i\n        data.insert(boundary,"|")\n        times = len(infected)\n        for p in range(times):\n            index = infected[p]\n            if(index>=boundary):\n                index+=1\n                infected[p]+=1\n            if(data[index]==1):\n                if(data[index+1]==0):\n                    data[index+1] = 1\n                    infected.append(index+1)\n                if(data[index-1]==0):\n                    data[index-1] = 1\n                    infected.append(index-1)\n            else:\n                infected.remove(index)\n                times-=1\n        i+=1\n        infected.sort()\n    \n    print(data.count(1))
t = int(input())\nfor z in range(t) :\n n,p = [int(x) for x in input().split()]\n a = [int(x) for x in input().split()] \n c = [x for x in a if x >= p//2]\n h = [x for x in a if x <= p//10]\n if len(c)==1 and len(h)==2 :\n  print("yes")\n else:\n  print("no")
for _ in range(int(input())):\n s,k=map(str,input().split())\n k=int(k)\n n="NOPE"\n al=[0]*26\n for ele in s:\n  al[ord(ele)-ord('a')]=1\n l=len(s)\n ans=[]\n # print(al)\n for i in range(26):\n  if len(ans)==l:\n   break\n  elif al[i]==1 and k>0:\n   k-=1\n   ans.append(chr(i+ord('a')))\n  elif al[i]==0:\n   ans.append(chr(i+ord('a')))\n \n if len(ans)!=l:\n  print(n)\n else:\n  print("".join(ans))
# cook your dish here\nt = int(input())\n\nres = []\nfor i in range(t):\n n = int(input())\n arr = [int(i) for i in input().split()]\n \n num_2 = 0\n num = 0\n \n for j in range(len(arr)):\n  if arr[j] == 2:\n   num_2 += 1\n   \n  if arr[j] > 2:\n   num += 1\n   \n res.append(num_2 * num + (num * (num - 1)) // 2)\n \nfor z in res:\n print(z)
factorials=[1]\n\nfor x in range(1,201):\n factorials.append(factorials[x-1]*x)\n \nx=int(input())\n\nfor x in range(x):\n n=int(input())\n print(factorials[n])
s=int(input())\nwhile(s>0):\n s-=1\n a=input()\n c=0\n for x in a:\n  c+=int(x)\n if(c<9 and len(a)!=1):\n  print(9-c%9)\n else:\n  print(min(9-c%9,c%9))\n
# cook your dish here\nt=int(input())\nfor _ in range(t):\n n,m = map(int,input().split())\n count=0\n for i in range(n,m+1):\n  p=str(i)\n  if p[-1]=='2' or p[-1]=='3' or p[-1]=='9':\n   count+=1\n print(count)
def merge(intervals,start,mid,end):\n al = mid-start+1\n bl = end-mid\n \n A = intervals[start:mid+1]\n B = intervals[mid+1:end+1]\n \n p=0;q=0;k=start;\n while(p<al and q<bl):\n  if(A[p]<B[q]):\n   intervals[k] = A[p]\n   k+=1;p+=1;\n  else:\n   intervals[k] = B[q]\n   k+=1;q+=1;\n \n while(p<al):\n  intervals[k] = A[p]\n  k+=1;p+=1;\n while(q<bl):\n  intervals[k] = B[q]\n  k+=1;q+=1;\n \n\ndef mergesort(intervals, start, end):\n if(start<end):\n  mid = int((start+end)/2)\n  mergesort(intervals,start,mid)\n  mergesort(intervals,mid+1,end)\n  merge(intervals,start,mid,end)\n\nt = int(input())\nfor _ in range(t):\n n,m,k = map(int, input().split())\n \n cities = [[0,[]] for i in range(n)]\n for i in range(m):\n  a,b = map(int, input().split())\n  cities[a-1][1].append(b-1)\n  cities[b-1][1].append(a-1)\n \n li = list(map(int, input().split()))\n \n def specialfunction():\n  mergesort(li,0,n-1)\n  if(k>len(li)):\n   print(-1)\n  else:\n   sum = 0\n   front = 0\n   rear = len(li)-1\n   for i in range(k):\n    if(i%2==0):\n     sum += li[rear]\n     rear -= 1\n    else:\n     sum += li[front]\n     front += 1\n   print(sum)\n \n if(m == 0):\n  specialfunction()\n  continue\n \n for i in range(n):\n  cities[i][0] = li[i]\n \n visited = [-1 for i in range(n)]\n count = 0\n museummonths = []\n def searchUnvisited():\n  for i in range(n):\n   if(visited[i] == -1):\n    return i\n  return -1\n \n def bfs(ind,count):\n  museumcount = 0\n  queue = []\n  queue.append(ind)\n  visited[ind] = 1\n  museumcount += cities[ind][0]\n  count += 1\n  front = 0\n  rear = 0\n  while(front<=rear):\n   noe = len(cities[ind][1])\n   for i in range(noe):\n    if(visited[cities[ind][1][i]] == -1):\n     queue.append(cities[ind][1][i])\n     rear += 1\n     count += 1\n     museumcount += cities[cities[ind][1][i]][0]\n     visited[cities[ind][1][i]] = 1\n   front += 1\n   try:\n    ind = queue[front]\n   except:\n    break\n  museummonths.append(museumcount)\n  return count\n \n while(count<n):\n  for i in range(n):\n   if(visited[i] == -1):\n    count = bfs(i,count)\n \n mergesort(museummonths,0,len(museummonths)-1)\n #print(museummonths)\n if(k>len(museummonths)):\n  print(-1)\n else:\n  sum = 0\n  front = 0\n  rear = len(museummonths)-1\n  for i in range(k):\n   if(i%2==0):\n    sum += museummonths[rear]\n    rear -= 1\n   else:\n    sum += museummonths[front]\n    front += 1\n  print(sum)
\n\nimport fractions\nimport sys\n\nf = sys.stdin\n\nif len(sys.argv) > 1:\n f = open(sys.argv[1], "rt")\n\n\ndef calc(N, M):\n if M != N:\n  return [(-1, -1)]\n r = [(i+1, ((i+1) % N)+1) for i in range(N)]\n return r\n\nT = int(f.readline().strip())\n\nfor case_id in range(1, T+1):\n N, M = list(map(int, f.readline().strip().split()))\n\n rr = calc(N, M)\n\n for a, b in rr:\n  print(a, b)\n
t=int(input())\nfor _ in range(t):\n n,m=[int(x) for x in input().split()]\n mat=[]\n ans=[]\n for i in range(n+2):\n  l=[]\n  p=[]\n  for j in range(m+2):\n   l.append(0)\n   p.append(1000000000)\n  mat.append(l)\n  ans.append(p)\n y=int(input())\n for i in range(y):\n  a,b=[int(x) for x in input().split()]\n  mat[a][b]=1\n  ans[a][b]=0\n y=int(input())\n for i in range(y):\n  a,b=[int(x) for x in input().split()]\n  mat[a][b]=1000000000\n  ans[a][b]=1000000000\n for i in range(1,n+1):\n  for j in range(1,m+1):\n   if mat[i][j]==1 or mat[i][j]==1000000000:\n    continue\n   else:\n    ans[i][j]=min(ans[i][j],ans[i][j-1]+1,ans[i-1][j]+1)\n for i in range(n,0,-1):\n  for j in range(m,0,-1):\n   if mat[i][j] == 1 or mat[i][j] == 1000000000:\n    continue\n   else:\n    ans[i][j]=min(ans[i][j],ans[i+1][j]+1,ans[i][j+1]+1)\n for i in range(1,n+1):\n  for j in range(m, 0, -1):\n   if mat[i][j] == 1 or mat[i][j] == 1000000000:\n    continue\n   else:\n    ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n for i in range(n, 0, -1):\n  for j in range(1,m+1):\n   if mat[i][j] == 1 or mat[i][j] == 1000000000:\n    continue\n   else:\n    ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n for i in range(1,n+1):\n  for j in range(1,m+1):\n   if mat[i][j]==1 or mat[i][j]==1000000000:\n    continue\n   else:\n    ans[i][j]=min(ans[i][j],ans[i][j-1]+1,ans[i-1][j]+1)\n for i in range(n,0,-1):\n  for j in range(m,0,-1):\n   if mat[i][j] == 1 or mat[i][j] == 1000000000:\n    continue\n   else:\n    ans[i][j]=min(ans[i][j],ans[i+1][j]+1,ans[i][j+1]+1)\n for i in range(1,n+1):\n  for j in range(m, 0, -1):\n   if mat[i][j] == 1 or mat[i][j] == 1000000000:\n    continue\n   else:\n    ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n for i in range(n, 0, -1):\n  for j in range(1,m+1):\n   if mat[i][j] == 1 or mat[i][j] == 1000000000:\n    continue\n   else:\n    ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n for i in range(1,n+1):\n  for j in range(1,m+1):\n   if mat[i][j]==1000000000:\n    print('X',end=" ")\n   elif ans[i][j]>=1000000000:\n    print('-1',end=" ")\n   else:\n    print(ans[i][j],end=" ")\n  print()
for _ in range(int(input())):\n    x,n = map(int,input().split())\n    reach = [0]*(x+1)\n    reach[0] = 1\n    i=1\n    while i**n<=x:\n        j = 1\n        while j+i**n<=x:\n            j+=1\n        j-=1\n        while j>=0:\n            if reach[j]>0:\n                reach[j+i**n]+=reach[j]\n            j-=1\n        i+=1\n    #print(reach)\n    print(reach[-1])
r=[0,1,1,2,1,4,2,6,1,8,4]\n\nn,m=[int(x) for x in input().split()]\nif m==1:\n while n%2!=1:\n  n=n/2\n if n==1:\n  print(1)\n else:    \n  print(n-1) \nelif (n+1)/2<m:\n print(m)\nelse:\n print(n-m)\n\n \n
def base5(n):\n    if n == 0: return\n    for x in base5(n // 5): yield x\n    yield n % 5\n\ndef seq(n):\n    return int(''.join(str(2 * x) for x in base5(n)) or '0')\n\nfor i in range(eval(input())):\n    k=eval(input())\n    while(i<k):\n        i=i+1\n    print(seq(i-1))\n
res=""\nfor _ in range(int(input())):\n ans=0\n c=int(input())\n for i in range(c):\n  n,m=list(map(int,input().split( )))\n  ans^=(n+m-2)%3\n if ans:\n  res+="MasterChef\n"\n else:\n  res+="Football\n"\nprint(res)\n  \n  \n
def dfs(ind,m,n,k):\n if(ind == m):\n  return [""]\n else:\n  temp = dfs(ind+1,m,n,k)\n  ans = []\n  if(len(temp)<k):\n   for i in temp:\n    for j in range(97,97+n):\n     ans += [chr(j)+i]\n  else:\n   for i in temp:\n    ans += ["z"+i]\n return ans\nn,m,k = list(map(int,input().split()))\np = []\nmr= []\nfor _ in range(m):\n inp = [int(x) for x in input().split()]\n mc = inp[0]\n mi = 0\n for j in range(1,n):\n  if(mc<inp[j]):\n   mc = inp[j]\n   mi = j\n p += [inp]\n mr += [mi]\nans = dfs(0,m,n,k)\nw = []\nfor i in ans:\n cst = 0\n s = ""\n for j in range(m):\n  if(i[j]!="z"):\n   s+=i[j]\n   cst += p[j][ord(i[j])-97]\n  else:\n   s += chr(mr[j]+97)\n w += [(-cst,s)]\nw.sort()\nprint(w[k-1][1])\n
while(True):\n \n n, m, x = map(int, input().split())\n\n if(n==0 and m==0 and x==0):  \n  break\n \n  \n money=0\n for i in range(n):\n  \n  money=money + (x+m*i)//n \n print(money) 
for _ in range(int(input())):\n n=int(input())\n a=list(map(int,input().split()))\n b=list(map(int,input().split()))\n a.sort()\n b.sort()\n s=0\n for i in range(n):\n  s+=min(a[i],b[i])\n print(s)
import sys\nsys.setrecursionlimit(100000)\n\nmemo = {}\ndef recurse(arr, T1, T2, k, i):\n if T1 >= k and T2 >= k:\n  return i\n\n if i >= len(arr):\n  return float('inf')\n\n if (T1, T2) in memo:\n  return memo[(T1, T2)]\n\n t1 = recurse(arr, T1 + arr[i], T2, k, i+1)\n t2 = recurse(arr, T1, T2 + arr[i], k, i+1) \n\n memo[(T1, T2)] = min(t1, t2)\n return memo[(T1, T2)]\n\nfor _ in range(int(input())):\n n, k = list(map(int, input().split()))\n lst = list(map(int, input().split()))\n\n lst.sort(reverse = True)\n memo = {}\n res = recurse(lst, 0, 0, k, 0)\n\n if res == float('inf'):\n  print(-1)\n else:\n  print(res)\n\n\n\n
# fast io\nimport sys\ndef fop(s): sys.stdout.write(str(s)+'\n')\ndef fip(): return sys.stdin.readline()\nfintinp = lambda : int(fip()) \ndef flistinp(func= int): return list(map(func,fip().split())) \ndef fnsepline(n,func=str): return [func(fip()) for _ in range(n)]\n#-------------------code------------------------\ndef even(x):\n x = bin(x).count('1')\n return x%2==0\n \nfor _ in range(fintinp()):\n q =fintinp()\n o = e =0 \n nums = set()\n for qn in range(q):\n  qn = fintinp()\n  if qn not in nums:\n   if even(qn): e+=1 \n   else: o+=1 \n   \n   for n in set(nums):\n    x = n^qn\n    if x not in nums:\n     if even(x): e+=1 \n     else: o+=1 \n     \n     nums.add(x)\n    \n  nums.add(qn)\n  print(e,o)\n
# cook your dish here\nn=int(input())\nfor _ in range(n):\n a=int(input())\n if(a%2==0):\n  f=(a//2)-1\n  s=a-f\n else:\n  f=(a//2)\n  s=a-f\n print(f,s)
import math\n\n\nt = int(input().strip())\n\nfor _ in range(t):\n n, m = list(map(int, input().strip().split()))\n a = []\n v = [-1] * 4\n\n for i in range(n):\n  a.append(input().strip())\n\n for i, ai in enumerate(a):\n  if ai.find('*') > -1:\n   v[2] = i\n   break\n\n if v[2] == -1:\n  print(0)\n else:\n\n  for i, ai in reversed(list(enumerate(a))):\n   if ai.find('*') > -1:\n    v[3] = i\n    break\n\n  for i in range(m):\n   x = [ai[i] for ai in a]\n   if '*' in x:\n    v[0] = i\n    break\n\n  for i in reversed(range(m)):\n   x = [ai[i] for ai in a]\n   if '*' in x:\n    v[1] = i\n    break\n\n  if v.count(v[0]) == len(v):\n   print(1)\n  else:\n   print(int(math.ceil(max(v[3] - v[2], v[1] - v[0]) / 2.0)) + 1)
for _ in range(int(input().strip())):\n    n = int(input().strip())\n    lst = []\n    for i in range(n):\n        lst.append(i+1)\n        lst.append(1)\n    #print(lst)\n    for i in range(n):\n        print(''.join(str(e) for e in lst))\n        for x in range(n):\n            lst[x * 2 + 1] += 1\n
test = int(input())\nfor _ in range(test):\n n, m = map(int, input().split())\n indexArray = list(map(int, input().split()))\n mini = min(indexArray)\n maxi = max(indexArray)\n result = n*[0]\n for i in range(n):\n  result[i] = max(maxi - i, i - mini)\n  print(result[i], end=" ")\n print()
from bisect import *\nfor x in range(eval(input())):\n n,k = list(map(int,input().split()))\n arr = list(map(int,input().split()))\n arr.sort()\n t = 1\n result = 0\n y = 0\n while y < n:\n  if arr[y]<t:\n   y += 1\n  elif arr[y]==t:\n   t = t*2\n   y += 1\n  else:\n   result += 1\n   t = t*2\n \n while t < 2**(k):\n  result += 1\n  t = t*2\n print(result)
for i in range(int(input())):\n n=int(input())\n s=0\n for i in range(n):\n  a,b,c=map(int,input().split())\n  d=(c/100)*a\n  e=a+d\n  f=e-((c/100)*e)\n  g=a-f\n  h=b*g\n  s=s+h\n print(s)
# cook your dish here\nfrom sys import stdin,stdout,setrecursionlimit\nfrom math import ceil\n\nmod = 1000000007\nt = int(stdin.readline())\nfor _ in range(t):\n    m,n = list(map(int,input().split()))\n    if m < n:\n        m,n = n,m\n\n    y = n-1\n    s1 = ((y*(y+1)) //2)%mod\n    s2 = ((y*(y+1)*(2*y+1)) //6)%mod\n    s3 = ((y*y*(y+1)*(y+1)) //4)%mod\n    \n   \n    ans = (m*n*s1 - (m+n)*s2+s3)%mod\n    # ans = (m*(m+1)*(2*m*n + 4*n + 2 - m*m - m)//12)\n            \n    print(ans)\n    \n
# cook your dish here\nfor _ in range(int(input())):\n d=dict()\n ls=[]\n for i in range(int(input())):\n  ls=list(map(int,input().split()))\n  if ls[0] in d:\n   d[ls[0]]=max(ls[1],d[ls[0]])\n  else:\n   d[ls[0]]=ls[1]\n # print(d)\n if len(d)<3:\n  print(0)\n else:\n  kd=list(d.values())\n  kd.sort()\n  # print(kd)\n  print(kd[-1]+kd[-2]+kd[-3])\n
t=int(input())\r\nfor _ in range(t):\r\n    xyz = input().strip()\r\n    \r\n    string = 0\r\n\r\n    for i in range(len(xyz)//2):\r\n        string  = string + (abs(ord(xyz[i])-ord(xyz[len(xyz)-i-1])))\r\n           \r\n    print(string)
t=int(input())\nx=[1,2,3,4,5,6,7]\nfor i in range(t):\n N=int(input())\n a=list(map(int,input().split())) \n rev=a[::-1] \n dup=set(a) \n if rev== a and list(dup) ==x:    \n  print("yes")\n else:\n  print("no")
l= []\nfor i in range(62):\n l.append(2**i)\nT = int(input())\n\nflag = 0\nfor t in range(T):\n L,R = [int(i) for i in input().split()]\n bL = bin(L)\n lL = len(bL)-2\n index = 1\n ans = 0\n temp = 0\n \n while(index<=lL):\n  temp = L%l[index]\n  if temp>=l[index-1]:\n   if(l[index]-temp<=R-L+1):\n    ans= (ans +(l[index-1])*(l[index]-temp))%1000000007\n   else :\n    ans=(ans+(l[index-1])*(R-L+1))%1000000007\n   \n   \n  index+=1\n print(ans)\n#    4378578345 584758454958\n# 18091037982636824985 8589934592 4429185025 4294967296\n
# cook your dish here\r\nimport sys\r\nn = 201\r\nv = [0 for i in range(n + 1)] \r\n\r\ndef gen():\r\n    for i in range(1, n + 1): \r\n        v[i] = i \r\n    \r\n    countDivision = [0 for i in range(n + 1)] \r\n    \r\n    for i in range(n + 1): \r\n        countDivision[i] = 2\r\n    \r\n    for i in range(2, n + 1, 1): \r\n          \r\n        \r\n        if (v[i] == i and countDivision[i] == 2): \r\n            for j in range(2 * i, n + 1, i): \r\n                if (countDivision[j] > 0): \r\n                    v[j] = int(v[j] / i) \r\n                    countDivision[j] -= 1\r\ntry:\r\n    t=int(sys.stdin.readline())\r\n    for _ in range(t):\r\n        gen()\r\n        x=int(sys.stdin.readline())\r\n        flag=0\r\n        for i in range(2,x//2+1):\r\n            if v[i]==1 and v[x-i]==1:\r\n                flag=1\r\n                #print(i,x-i)\r\n        if flag==1:\r\n            print("YES")\r\n        else:\r\n            print("NO")\r\nexcept:\r\n    pass\r\n
# cook your dish here\nfor _ in range(int(input())):\n n = int(input())\n k = n//4\n # a,b,c = map(int,input().split())\n a = sorted(map(int,input().split()))\n a60 = (a[k-1],a[k])\n a75 = (a[2*k-1],a[2*k])\n a90 = (a[3*k-1],a[3*k])\n if a60[0]==a60[1] or a75[0]==a75[1] or a90[0]==a90[1] :\n  print(-1)\n else :\n  print(a60[1],a75[1],a90[1])\n
# cook your dish here\nT=int(input())\nfor k in range(0,T):\n N=int(input())\n matrix=[]\n for i in range(0,N):\n  a=list(map(int, input().split()))\n  matrix.append(a)\n max_trace = []\n for i in range(0,N):\n  trace1=0\n  trace2=0\n  for j in range(0,i+1):\n   trace1+=matrix[j][N+j-i-1]\n   trace2+=matrix[N+j-i-1][j]\n   max_trace.append(trace1)\n   max_trace.append(trace2)\n print(max(max_trace))\n\n \n
import math\r\n\r\ndef main():\r\n  #print("enter i, k, s")\r\n  IN = '11 6 5'\r\n  z = IN.split()\r\n  z = input().split()\r\n  i = int(z[0])\r\n  k = int(z[1])\r\n  s = int(z[2])\r\n\r\n  #print("enter a_i and b_i")\r\n  IN = '4 5'\r\n  z = IN.split()\r\n  z = input().split()\r\n  a_i = int(z[0])\r\n  b_i = int(z[1])\r\n\r\n  #print( "i = %d   k = %d   s = %d " % (i, k, s)  )\r\n  #print( "a_i = %d   b_i = %d" % (a_i, b_i)  )\r\n\r\n  x = math.sqrt(2)\r\n  y = math.sqrt(3)\r\n  #print(x,y)\r\n\r\n  # Obtaining the k-th element when k >= i\r\n  if(i<=k):\r\n    diff = k-i\r\n    #if both k and i are odd or even\r\n    if(k-i)%2==0:\r\n      #print("#1")\r\n      ans =  (a_i + b_i) * math.pow(2,2*(k-i)-s)\r\n      #diff = int(diff/2) \r\n      #ans =  (a_i + b_i) * math.pow(2,4*diff-s)\r\n          \r\n    #if i and k are of different parities then obtaining first\r\n    # a_(i+1) and b_(i+1)\r\n    else:\r\n      #print("#2")\r\n      ans = (2*x*a_i + 2*x*y*b_i) * math.pow(2,2*(k-(i+1))-s )\r\n      diff = int(diff/2)\r\n      ans = (2*x*a_i + 2*x*y*b_i) * math.pow(2,4*diff - s)\r\n      #print("1: ", (2*x*a_i + 2*x*y*b_i))\r\n      #print("2: ", math.pow(2,4*diff - 2- s))  \r\n      #print("2 sol: ", math.pow(2,4*int(diff)-s))\r\n      #print("diff: ",diff)\r\n\r\n\r\n  # Obtaining the k_th element when k < i\r\n  else:\r\n    diff = i-k\r\n    #if both k and i are odd or even\r\n    if(i-k)%2==0:\r\n      #print("#3")\r\n      ans =  (a_i + b_i) / math.pow(2,2*(i-k)+s)\r\n      #diff =  int(diff/2)\r\n      #ans =  (a_i + b_i) / math.pow(2,4*diff+s)\r\n\r\n    #if i and k are of different parities then obtaining first\r\n    # a_(i+1) and b_(i+1)\r\n    else:\r\n      #print("#4")\r\n      ans = (2*x*a_i + 2*x*y*b_i) / math.pow(2,2*(i+1-k)+s)\r\n      diff = int(diff/2)\r\n      ans = (2*x*a_i + 2*x*y*b_i) / math.pow(2,4*diff + 4 + s)\r\n\r\n\r\n  print(ans)\r\n  \r\nmain()\r\n
t=int(input())\nMOD=(10**9)+7\nl=['a','e','i','o','u']\nfor i in range(t):\n s=input()\n k=[]\n for j in s:\n  if j in l:\n   k.append(1)\n  else:\n   k.append(0)\n r=bin(int(''.join(map(str, k)), 2) << 1)\n print((int(r,2)//2)%MOD)\n
t=int(input())\nfor _ in range(t):\n    n,m=map(int,input().split())\n    mat=[0 for i in range(n)]\n    #mat=[[0 for i in range(n)] for j in range(n)]\n    for i in range(m):\n     u,v=map(int,input().split())\n     u,v=(u-1),(v-1)\n     mat[u]|=(1<<v)\n     mat[v]|=(1<<u)\n    for i in range(n):\n     mat[i]|=(1<<i)    \n \n    goal=(2**n)-1\n    ans=n\n\n    for i in range(1,goal+1):\n     mvs=0\n     loc=0\n     for j in range(n):\n      if(i&(1<<j)):\n       loc|=mat[j]\n       mvs+=1\n     if(loc==goal):\n      ans=min(mvs,ans)\n    print(ans)
t = int(input())\n\nwhile(t>0):\n \n n=int(input())\n if(n<=0):\n  print(0)\n \n fact=1\n start=1\n for i in range(1,n+1):\n  fact*=start\n  start+=2\n print(fact)\n \n t=t-1\n
# cook your dish here\nx=input ()\ny=len (x)\nif y==1:\n print('1')\nelif y==2:\n print('2')\nelif y==3:\n print('3')\nelif y>3:\n print('More than 3 digits')
#-*- coding:utf-8 -*-\n\nimport sys\n\n\n# class Point:\n#     def __init__(self, x, y):\n#         self.x = x\n#         self.y = y\n\n#     def mul(self, k):\n#         return Point(k * self.x, k * self.y)\n\n#     def __add__(self, other):\n#         return Point(self.x + other.x, self.y + other.y)\n\n#     def __sub__(self, other):\n#         return self + (-other)\n\n#     def __neg__(self):\n#         return Point(-self.x, -self.y)\n\n#     def __eq__(self, other):\n#         return self.x == other.x and self.y == other.y\n\n#     def __getitem__(self, index):\n#         return (self.x, self.y)[index]\n\n#     def __str__(self):\n#         return "(%d;%d)" % (self.x, self.y)\n\n\nDIRS = dict(\n U=(0, 1),\n D=(0, -1),\n R=(1, 0),\n L=(-1, 0)\n)\nKOEF = 0.2\n\n\ndef div(a, b):\n return round(float(a) / b, 1)\n\n\n# class Moving:\n#     def __init__(self, x, y, dir):\n#         self.p = Point(x, y)\n#         self.dir = Point(*DIRS[dir.upper()])\n\n#     def collide(self, other):\n#         times = []\n#         for coord in range(2):\n#             d = abs(self.p[coord] - other.p[coord])\n#             d2 = abs((self.p + self.dir.mul(KOEF) - other.p)[coord])\n#             d3 = abs((other.p + other.dir.mul(KOEF) - self.p)[coord])\n#             d_next = abs((self.p + self.dir.mul(KOEF) - (other.p + other.dir.mul(KOEF)))[coord])\n#             if d2 > d or d3 > d:\n#                 return None\n\n#             speed = abs(d_next - d)\n#             if speed == 0:\n#                 if self.p[coord] != other.p[coord]:\n#                     return None\n#                 continue\n#             times.append( div(d, speed / KOEF) )\n\n#         if len(times) == 2 and times[0] != times[1]:\n#             return\n#         return times[0]\n\n\ndef collide_coord(ex, edx, x, dx):\n d = abs(ex - x)\n d2 = abs(ex + edx - x)\n d3 = abs(ex - x - dx)\n if d2 > d or d3 > d:\n  return False\n\n d_next = abs(ex + edx * KOEF - x - dx * KOEF)\n speed = abs(d_next - d)\n if speed == 0:\n  if ex != x:\n   return\n  return "all" # all\n else:\n  return div(d, speed / KOEF)\n\n\ndef main():\n t = int(input())\n for _ in range(t):\n  ex, ey, dir = sys.stdin.readline().strip().split()\n  ex = int(ex)\n  ey = int(ey)\n  edx, edy = DIRS[dir]\n\n  n = int(sys.stdin.readline())\n  min_time = float("+inf")\n  for _ in range(n):\n   x, y, dir = sys.stdin.readline().strip().split()\n   x = int(x)\n   y = int(y)\n   dx, dy = DIRS[dir]\n\n   tx = collide_coord(ex, edx, x, dx)\n   if tx is False:\n    continue\n   ty = collide_coord(ey, edy, y, dy)\n   if ty is False:\n    continue\n\n   if tx == "all":\n    min_time = min(min_time, ty)\n   elif ty == "all":\n    min_time = min(min_time, tx)\n   elif tx == ty:\n    min_time = min(min_time, tx)\n\n  print(min_time if min_time < 1000000 else "SAFE")\n\n\ndef __starting_point():\n main()\n\n__starting_point()
# cook your dish here\nfrom operator import itemgetter\ninp=list(map(int, input().split()))\nn, m, w, b = inp[:4]\nstops=[]\nfor i in range(w):\n stops.append((inp[4+2*i]-1,inp[5+2*i]-1,'w'))\nfor i in range(b):\n stops.append((inp[4+2*w+2*i]-1,inp[5+2*w+2*i]-1,'b'))\nstops.sort(key=itemgetter(1))\nstops.sort(key=itemgetter(0))\ncounter=0\nstop_rows=[[] for _ in range(n)]\nfor stop in stops:\n stop_rows[stop[0]].append(stop[1:])\nfor row in stop_rows:\n idx=0\n for i in range(len(row)):\n  if idx==row[i][0]:\n   idx+=1\n  else:\n   if row[i][1]=='w':\n    if i<len(row)-1:\n     num=row[i+1][0]-idx+1\n     counter+=((num*(num+1))>>1)-1\n     idx=row[i][0]+1\n     num=row[i+1][0]-row[i][0]+1\n     counter-=((num*(num+1))>>1)-1\n    else:\n     num=m-idx\n     counter+=((num*(num+1))>>1)-1\n     idx=row[i][0]+1\n     num=m-row[i][0]\n     counter-=((num*(num+1))>>1)-1\n   else:\n    num=row[i][0]-idx+1\n    counter+=((num*(num+1))>>1)-1\n    idx=row[i][0]+1\n num=m-idx\n counter+=(num*(num+1))>>1\nprint(counter)\n
def update_B(B, query):\n p, R = query\n for i in range(len(R)):\n  B[p][i] = R[i]\n  B[i][p] = R[i]\n\ndef get_A(B):\n N = len(B)\n A = [0] * N\n i = 0\n for j in range(N):\n  if B[0][j] != 0:\n   i = j\n   A[i] = -B[0][i]\n   break\n\n for j in range(i + 1, N):\n  if abs(A[i] - B[0][j]) == B[i][j]:\n   A[j] = B[0][j]\n  else:\n   A[j] = -B[0][j]\n\n return A\n\ndef print_list(A):\n print(' '.join([str(a) for a in get_A(B)]))\n\n\nN, Q = [int(x) for x in input().rstrip().split()]\nB = []\nfor i in range(N):\n B += [[int(x) for x in input().rstrip().split()]]\nqueries = []\nfor i in range(Q):\n p = int(input()) - 1\n arr = input().rstrip().split()\n queries += [(p, [int(x) for x in arr])]\n\nprint_list(get_A(B))\nfor q in queries:\n update_B(B, q)\n print_list(' '.join([str(a) for a in get_A(B)]))\n
# cook your dish here\nimport sys,collections\ninput=sys.stdin.readline\ndef main():\n T=int(input())\n for _ in range(T):\n  N,K=map(int,input().split())\n  Tree={}\n  for j in range(N):\n   Tree[j]=[]\n   \n  for i in range(N-1):\n   u,v=map(int,input().split())\n   Tree[u-1].append(v-1)\n   Tree[v-1].append(u-1)\n   \n  A=list(map(int,input().split()))\n \n  vis=[0 for i in range(N)] #to mark visited vertices 0 for visited and 1 for not visited\n  maxval=[[0,0] for i in range(N)] #Nx2 list where each i stores max value till now and its count \n  minval=[0 for i in range(N)] #Nx2 list where each i stores min value till now \n  lfnode=[] #list to store leaf nodes\n  \n  #Appending node 1\n  vis[0]=1\n  Q=collections.deque([0])\n  maxval[0][0],maxval[0][1]=A[0],1\n  minval[0]=A[0]\n \n  \n  while(len(Q)!=0):\n   a=Q.pop()\n   mv1=maxval[a][0]\n   mv2=minval[a]\n   \n   flag=0 #to check leaf node\n   \n   for i in Tree[a]:\n    if (vis[i]==0):\n     vis[i]=1\n     flag=1 #not a leaf node\n     v=A[i]\n     Q.append(i)\n \n     #Comparing maximum value of parent node\n     if (mv1<v):\n      maxval[i][0],maxval[i][1]=v,1\n      \n     elif(mv1==v):\n      maxval[i][0],maxval[i][1]=mv1,maxval[a][1]+1\n \n     else:\n      maxval[i][0],maxval[i][1]=maxval[a][0],maxval[a][1]\n \n      \n     #Comparing minimum value of parent node\n     if (mv2>v):\n      minval[i]=v\n     elif(v==mv2):\n      minval[i]=mv2\n     else:\n      minval[i]=minval[a]\n   \n \n   if (flag==0):\n    lfnode.append(a)\n \n  \n  flag=0 #For answer if 0 then NO else YES\n \n  K1=len(bin(K))-2 #length of K\n  \n  #print(lfnode,val)\n  for i in lfnode:\n   v1,v2=maxval[i][0],maxval[i][1]\n   \n   if (v1>K1 and v2%2==0):\n    flag=1\n   elif(v1==K1 and v2%2==1):\n    flag=1\n \n \n   v11=minval[i]\n   if (v11>K1 and v11!=v1):\n    flag=1\n   elif(v11==K1):\n    flag=1\n    \n   \n   if(flag==1):\n    break\n   \n  if (flag==1):\n   print("YES")\n  else:\n   print("NO")\nmain()
mod=10**9+7\ndef fibonacci(n):\n if n < 0:\n  raise ValueError("Negative arguments not implemented")\n return (_fib(n)[0]%mod + mod)%mod;\ndef _fib(n):\n if n == 0:\n  return (0, 1)\n else:\n  a, b = _fib(n // 2)\n  c = (a * (b * 2 - a))%mod\n  d = (a * a + b * b)%mod\n  if n % 2 == 0:\n   return (c, d)\n  else:\n   return (d, c + d)\ndef inv(n):\n return pow(n,mod-2,mod)\ndef brute(n,k):\n ret = 0\n for i in range(0,n+1):\n  ret+=fibonacci(i)*pow(k,i,mod)\n return ret%mod\ndef ans(n,k):\n k%=mod\n a = pow(k,n+1,mod)\n b=(a*k)%mod\n x = a*(fibonacci(n+1))+b*fibonacci(n)-k\n y = inv((k*k+k-1)%mod)\n return ((x*y)%mod+mod)%mod\nfor t in range(0,eval(input())):\n n,k = list(map(int,input().split()))\n print(ans(n,k))
import sys\nsys.setrecursionlimit(10**8)\n\nMOD = 10**9+7\n\nfac = [0]*(10**5+1)\ndef pre() :\n fac[0] = 1\n for i in range(1,10**5+1) :\n  fac[i] = fac[i-1]*i\n  fac[i] = fac[i]%MOD\n\ndef dfs(gp , vertex , visited , deg , ans) :\n visited[vertex] = 1\n stack = []\n stack.append(vertex)\n while len(stack)>0 :\n  vertex = stack.pop()\n  ans = ans%MOD * fac[deg[vertex]]%MOD\n  ans %= MOD\n  for i in gp[vertex] :\n   if not visited[i] :\n    visited[i] = 1\n    if vertex in gp[i] :\n     deg[i] -= 1\n    stack.append(i)\n return ans%MOD\n\npre()\nfor __ in range(eval(input())) :\n n = eval(input())\n deg = [0]*(n+1)\n st = [[] for __ in range(n+1)]\n for _ in range(n-1) :\n  a , b = list(map(int,sys.stdin.readline().split()))\n  st[a].append(b)\n  st[b].append(a)\n  deg[a] += 1\n  deg[b] += 1\n k = eval(input())\n visited = [0]*(n+1)\n print(dfs(st ,k,visited,deg , 1)%MOD)\n  \n
# cook your dish here\nfor _ in range(int(input())):\n    x, y= map(int, input().split())\n    if x<y:\n        print('<')\n    elif x>y:\n        print('>')\n    else:\n        print('=')
t = int(input())\nwhile(t):\n n = int(input())\n ar = list(map(int,input().strip().split(" ")))\n print(len([x for x in ar[1:len(ar)] if ar[0]<x]))\n t-=1\n
t=int(input())\nf=0\ny=0\nfor _ in range(t):\n n=int(input())\n seq=[int(x) for x in input().split()]\n prev=seq[0]\n for i in range(1,len(seq)):\n  if prev==seq[i]:\n   seq[i]=0\n  prev=seq[i] \n ans=0\n anss=0\n for el in seq:\n  if el!=0:\n   c=seq.count(el)\n   if ans<c:\n    ans=c\n    \n    anss=el\n   elif ans==c:\n    if el<anss:\n     anss=el\n    else:\n     anss=anss\n print(anss)
from sys import stdin,stdout\r\nfrom math import gcd\r\nfor _ in range(int(stdin.readline())):\r\n    # n=int(stdin.readline()) k-pieces\r\n    n,k=list(map(int,stdin.readline().split()))\r\n    a=list(map(int,stdin.readline().split()))\r\n    gr=[[0 for _ in range(n)]for _ in range(n)];ans=0;k-=1\r\n    for sz in range(n):\r\n        for i in range(n-sz):\r\n            j=i+sz\r\n            if sz==0:gr[i][j]=a[i]\r\n            else:\r\n                gr[i][j]=gcd(gr[i+1][j],gr[i][j-1])\r\n    # print(*gr,sep='\n')\r\n    dp=[[0 for _ in range(n)]for _ in range(k+1)]\r\n    for i in range(n):\r\n        dp[0][i]=gr[0][i]\r\n    for i in range(1,k+1):\r\n        for j in range(i,n):\r\n            for par in range(j-1,-1,-1):\r\n                dp[i][j]=max(dp[i][j],gr[par+1][j]+dp[i-1][par])\r\n    # print(*dp,sep='\n')\r\n    print(dp[k][n-1])\r\n\r\n
# cook your dish here\nn=int(input())\nl=[]\nfor i in range(n):\n    a=int(input())\n    l.append(a)\nfor i in l:\n    b = list(map(int, str(i)))\n    b.sort(reverse=True)\n    s = [str(i) for i in b]\n    r = int("".join(s))\n    print(r)
from sys import stdin\r\n\r\nfor _ in range(int(stdin.readline())):\r\n    n = int(stdin.readline())\r\n    n //= 2\r\n    k = 2 * int(n**0.5)\r\n    print(k)\r\n
# cook your dish here\nmod = 10**9 + 7\nfor i in range(int(input())):\n    n,k,m = tuple(map(int, input().split()))\n    a = list(map(int, input().split()))\n    ans = [0 for i in range(k+1)]\n    ans[0] = 1\n    curr_ending = 1\n    for i in range(n):\n     mod_a = a[i]%m\n     start = curr_ending - (curr_ending%m - mod_a)%m\n     if(mod_a == curr_ending%m and curr_ending<k):\n      curr_ending += 1\n     for i in range(start, 0, -m):\n      ans[i] += ans[i-1]\n      if(ans[i] > mod):\n       ans[i] = ans[i] - mod\n    print(ans[k])
import sys\n# import math as mt\n# from collections import Counter\n# from itertools import permutations\n# from functools import reduce\n# from heapq import nsmallest, nlargest, heapify, heappop, heappush, heapreplace\n\ndef get_inpt(): return sys.stdin.readline().strip()\ndef get_int(): return int(sys.stdin.readline().strip())\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\n\n# sys.setrecursionlimit(10**7)\n# INF = float('inf')\n# MOD1, MOD2 = 10**9+7, 998244353\n\nn, k = get_ints()\n\nfor _ in range(k):\n    \n    arr = get_array()\n    \n    for i in reversed(range(n-1)):\n        \n        if arr[i] < arr[i+1]:\n            \n            ind = i+1\n            minn = arr[i+1]\n            for j in range(i+1, n):\n                if arr[j] > arr[i]:\n                    minn = min(arr[j], minn)\n                    ind = j\n                    \n            arr[i], arr[ind] = arr[ind], arr[i]\n            \n            arr = arr[:i+1] + sorted(arr[i+1:])\n            \n            break\n    \n    print(*arr)
res = []\nfor _ in range(int(input())):\n lst = []\n flag = 0\n n = int(input())\n for i in range(n):\n  lst.append(list(map(int, input().split())))\n for i in lst:\n  for j in range(n-1):\n   if i[j] == i[j+1] == 1:\n    res.append("UNSAFE")\n    flag = 1\n    break\n  if flag != 0:\n   break\n for i in range(n-1):\n  for j in range(n):\n   if lst[i][j] == lst[i+1] == 1:\n    res.append("UNSAFE")\n    flag = 1\n    break\n  if flag != 0:\n   break\n if flag == 0:\n  res.append("SAFE")\nfor i in res:\n print(i)\n
# cook your dish here\nfrom collections import Counter\nfor i in range(int(input())):\n s=input().upper()\n res=Counter(s)\n if res["L"]>=2 and res["T"]>=2 and res["I"]>=2 and res["M"]>=2 :\n  if len(s)==9:\n   if res["E"] >=1 :\n    print("YES")\n   else:\n    print("NO")\n  elif len(s)>9:\n   if res["E"]>=2:\n    print("YES")\n   else:\n    print("NO")\n  else:\n   print("NO")\n else:\n  print("NO")\n    \n
T = int(input())\nfor _ in range(T):\n p,n=map(int,input().split())\n mod = 1000000007\n if p == 2:\n  print(n)\n else:\n  f=n\n  t=n\n  for i in range(p-2):\n   f=(f%mod*n)%mod\n   a=(f-t+mod)%mod\n   t=a\n  print(a)
import collections\n\nwhile True:\n d = input().strip()\n myCounter = collections.Counter(d)\n flag = 1\n\n for x in list(myCounter.keys()):\n  if myCounter[x] > 1:\n   flag = 0\n   break\n\n isAlp = sum([myCounter[x] for x in list(myCounter.keys()) if x.isalnum()])\n\n if flag and isAlp:\n  print("Valid")\n  break\n else:\n  print("Invalid")\n
for _ in range(int(input())):\r\n    n = int(input())\r\n    s = [str(i) for i in range(n,0,-1)]\r\n    for i in range(n):\r\n        print('*'*i+''.join(s))\r\n        del(s[0])
t = int(input())\nfor tc in range(t):\n seq = input()\n dollar = 0\n stamp = 0\n for ct in seq:\n  if stamp >= 6:\n   stamp -= 6\n   continue\n  elif ct == 'M':\n   dollar += 3\n  elif ct == 'L':\n   dollar += 4\n  stamp += 1\n print(dollar)\n\n\n
test=int(input())\nfor i in range(test):\n n,k=map(int,input().split())\n x=n-k\n for j in range(1,n+1):\n  if(j%2==0 and x>0):\n   print(-j,end=' ')\n   x-=1\n  elif(k<=0):\n   print(-j,end=' ')\n  else:\n   print(j,end=' ')\n   k-=1\n print()
import sys\n\nspoon = [ "SPOON", "spoon" ]\n\ndef main():\n try:\n  tc=int(input())\n  while tc>0:\n   tc=tc-1\n   [r,c] = input().split()\n   r=int(r)\n   c=int(c)\n   k=0\n   flag=0\n   matrix=[0]*r\n   i=0\n   while i<r:\n    matrix[i]=input()\n    i=i+1\n   \n   #Check row wise\n   for m in matrix:\n    for s in m:\n     if s==spoon[0][k] or s==spoon[1][k]:\n      k=k+1\n      if k==5:\n       flag=1\n       k=0\n       break\n     else:\n      k=0\n   \n   if flag==1:\n    print("There is a spoon!")\n    continue\n   \n   #Check column wise\n   i=0\n   k=0\n   while i<c:\n    j=0\n    while j<r:\n     if matrix[j][i]==spoon[0][k] or matrix[j][i]==spoon[1][k]:\n      k=k+1\n      if k==5:\n       flag=1\n       k=0\n       break\n     else:\n      k=0\n     j=j+1\n    i=i+1\n   \n   if flag==1:\n    print("There is a spoon!")\n    continue\n   \n   print("There is indeed no spoon!")\n \n except:\n  return 0\nmain()\n
from math import sqrt,gcd\n\nfor _ in range(int(input())):\n    n=int(input())\n    ar=[int(x) for x in input().split()]\n    g=ar[0]\n    for i in range(1,n):\n        g=gcd(g,ar[i])\n    \n    f=g\n    for i in range(2,int(sqrt(g))+1):\n        if g%i==0:\n            f=i\n            break\n    if g!=1:\n        print(f)\n    else:\n        print(-1)\n        \n        \n    
def left_span(arr,n):\n ans=[0]\n span=[0]\n for i in range(1,n):\n  \n  while span and arr[i]>arr[span[-1]]:\n   span.pop()\n  \n  if not span:\n   ans.append(0)\n   \n  else:\n   ans.append(span[-1]+1)\n  span.append(i)\n return ans\n\ndef right_span(arr,n):\n ans=[n+1]\n span=[n-1]\n for i in range(n-2,-1,-1):\n  \n  while span and arr[i]>=arr[span[-1]]:\n   span.pop()\n   \n  if not span:\n   ans.append(n+1)\n  else:\n   ans.append(span[-1]+1)\n  span.append(i)\n return ans[::-1]\nfrom collections import Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nn,q=list(map(int,input().split( )))\narr=list(map(int,input().split( )))\n\nleft=left_span(arr,n)\nright=right_span(arr,n)\nc=Counter()\nfor i in range(n):\n c[arr[i]]+=(right[i]-(i+1))*(i+1-left[i])\na=sorted(c)\nf=[]\nfor v in a:\n f.append(c[v])\nprefix_sum=[f[0]]\nn=len(f)\nfor i in range(1,n):\n prefix_sum.append(f[i]+prefix_sum[-1])\nr=[0]*q\nfor i in range(q):\n sign,k,player=list(map(str,input().split( )))\n k=int(k)\n if sign=="=":\n  if k in c:\n   res=c[k]\n  else:\n   res=0\n elif sign==">":\n  j=bisect_left(a,k)\n  if j==n:\n   res=0\n  elif a[j]==k:\n   res=prefix_sum[-1] - prefix_sum[j]\n  else:\n   if j>0:\n    res=prefix_sum[-1] - prefix_sum[j-1]\n   else:\n    res=prefix_sum[-1]\n else:\n  j=bisect_left(a,k)\n  if j==0:\n   res=0\n  else:\n   res=prefix_sum[j-1]\n \n if res%2==0:\n  if player=="D":\n   r[i]="C"\n  else:\n   r[i]="D"\n else:\n  r[i]=player\nprint(''.join(r))\n   \n  \n\n\n
n=int(input())\nl=[]\ncount=0\nwhile n:\n    n-=1\n    a,b,c=sorted(map(int,input().split()))\n    if (a,b,c) in l:\n        count-=1\n    else:\n        l.append((a,b,c))\n        count+=1\nprint(count)
# cook your dish here\nfrom collections import defaultdict\n\nclass sol():\n    def __init__(self,n,edges):\n        self.n = n\n        self.edges = edges\n        self.graph = self.create_graph()\n        self.precompute()\n        \n    def create_graph(self):\n        graph = defaultdict(list)\n        for e in self.edges:\n            u = e[0]\n            v = e[1]\n            w = e[2]\n            graph[u].append([v,w])\n            graph[v].append([u,w])\n        return graph\n        \n    def precompute(self):\n        self.maxiedges = [0]*6\n        self.B = [[0 for i in range(101)] for i in range(101)]\n        def func(u,v,l):\n            if l==2:\n                self.B[u][self.maxiedges[l]] += 1\n            else:\n                for j in self.graph[v]:\n                    self.maxiedges[l+1] = max(self.maxiedges[l],j[1])\n                    func(u,j[0],l+1)\n        for i in range(1,self.n+1):\n            func(i,i,0)\n            \n    def paths(self,X):\n        freq = 0\n        for u in range(1,self.n+1):\n            for x in range(X+1):\n                freq += 2*self.B[u][X]*self.B[u][x]\n            freq -= self.B[u][X]*self.B[u][X]\n        return freq\n        \nn, m = map(int, input().split())\nedges = []\nwhile m:\n    uvw = list(map(int, input().split()))\n    edges.append(uvw)\n    m -= 1\nq = int(input())\nGraph = sol(n,edges)\nwhile q:\n    query = int(input())\n    print(Graph.paths(query))\n    q -= 1\n
import sys\n \ndef findRoom(x,y,i):\n R = [(x,y)]\n GRID[x][y] = i\n for n in R:\n  GRID[n[0]][n[1]] = i\n  if n[0]>0 and GRID[n[0]-1][n[1]]==0 and H[n[0]-1][n[1]]:\n   GRID[n[0]-1][n[1]] = i\n   R.append((n[0]-1,n[1]))\n  if n[0]<N-1 and GRID[n[0]+1][n[1]]==0 and H[n[0]][n[1]]:\n   GRID[n[0]+1][n[1]] = i\n   R.append((n[0]+1,n[1]))\n  if n[1]>0 and GRID[n[0]][n[1]-1]==0 and V[n[0]][n[1]-1]:\n   GRID[n[0]][n[1]-1] = i\n   R.append((n[0],n[1]-1))\n  if n[1]<M-1 and GRID[n[0]][n[1]+1]==0 and V[n[0]][n[1]]:\n   GRID[n[0]][n[1]+1] = i\n   R.append((n[0],n[1]+1))\n\ndef roomPrice(r):\n wall_price_0 = wall_price_1 = 0\n for i in range(R):\n  if C[i][r] and T[i] != 1:\n   wall_price_0 += C[i][r]*K\n  else:\n   wall_price_1 += C[i][r]*K\n return [wall_price_0 + Rooms[r][0], wall_price_1 + Rooms[r][1]]\n\ndef total_price():\n price = 0\n for r in range(R):\n  for i in range(r):\n   if C[i][r] and T[i] != T[r]:\n    price += C[i][r]*K\n    price += Rooms[r][T[r]-1]\n return price\n\ndef solve(r):\n if r==R:\n  return 0\n wall_price_0 = 0\n wall_price_1 = 0\n for i in range(r):\n  if C[i][r] and T[i] != 1:\n   wall_price_0 += C[i][r]*K\n  else:\n   wall_price_1 += C[i][r]*K\n if T[r]!=0:\n  return [wall_price_0,wall_price_1][T[r]-1]+Rooms[r][T[r]-1]+solve(r+1) \n T[r] = 1\n result = solve(r+1)+wall_price_0+Rooms[r][0]\n T[r] = 2\n result = min(solve(r+1)+wall_price_1+Rooms[r][1], result)\n T[r] = 0\n return result\n \nf = sys.stdin\nN,M,W,K,R = list(map(int, f.readline().split(' ')))\nT = [0] * R\nGRID = list(map(list,[[0]*M]*N))\nH = list(map(list,[[1]*M]*N))\nV = list(map(list,[[1]*M]*N))\nWalls = []\nfor _ in range(W):\n x0,y0,x1,y1 = list(map(int, f.readline().split(' ')))\n x0 -= 1\n x1 -= 1\n y0 -= 1\n y1 -= 1\n if x0==x1:\n  V[x0][y0] = 0\n else:\n  H[x0][y0] = 0\n Walls.append([x0,y0,x1,y1]) \nRooms = []\nfor i in range(R):\n x,y,t1,t2 = list(map(int, f.readline().split(' ')))\n findRoom(x-1,y-1,i+1)\n Rooms.append([t1,t2])\nC = list(map(list,[[0]*R]*R))\nfor w in Walls:\n r1 = GRID[w[0]][w[1]]-1 \n r2 = GRID[w[2]][w[3]]-1\n C[r1][r2] += 1\n C[r2][r1] += 1\nStable = [False]*R\nfor r in range(R):\n walls_max_price = sum(C[r])*K\n if walls_max_price<=abs(Rooms[r][0]-Rooms[r][1]):\n  # If we choose the cheaper team, no matter what the next rooms are the walls we not overprice it.\n  T[r] = 1+(Rooms[r][0]>Rooms[r][1])\n  Stable[r] = True\ndef try_teams():\n for r in range(R):\n  if not Stable[r]:\n   T[r] = 1+(r&1)\n  change = True\n while change:\n  change = False\n  for r in range(R):\n   price = roomPrice(r)\n   if price[T[r]-1]>price[2-T[r]]:\n    T[r] = 3-T[r]\n    change = True\n print(total_price())\n#try_teams()  \nprint(solve(0))\n
try:\n\n for j in range(1,int(input())+1):\n  n,k = map(int,input().split())\n\n  if k>n:\n   c=0\n  else:\n   c = n-k+1\n\n  s = c*(c+1)//2\n  print('Case', str(j)+':',s)\nexcept:\n pass
n,m=map(int,input().split())\r\nl=[]\r\nleng=0\r\nfor i in range(n+m):\r\n    w=int(input())\r\n    if w==-1:\r\n        cm=0\r\n        mi=0\r\n        for j in range(leng):\r\n            if l[j]>cm:\r\n                cm=l[j]\r\n                mi=j\r\n        \r\n        print(cm)\r\n        l[mi]=-1\r\n    else:\r\n        l.append(w)\r\n        leng+=1
\nfor _ in range(int(input())):\n    n=int(input())\n    if(n<3):\n        print("B")\n    else:\n        if(n==3):\n            print("A")\n        elif(n%2):\n            print("B")\n        else:\n            print("B")\n\n\n\n\n\n\n\n\n
T=int(input())\nfor i in range(T):\n    n=int(input())\n    if n==1:\n        print("0")\n    else:\n        n=n-2\n        l=(n+1)*(2*n+3)*(n+2)/6\n        print(int(l))\n
# cook your dish here\n#t = int(input())\nfor i in range(int(input())):\n n,k = map(int,input().split())\n l = list(map(int,input().split()))\n l.sort(reverse = True)\n c = 0\n for i in l:\n  if i >= l[k-1]:\n   c += 1\n print(c)
#for _ in range(int(input())):\n#n,m = map(int,input().split())\n#n = int(input())\n#x = [int(w) for w in input().split()]\n#x = [int(input()) for _ in range(n)]\n#for i in range(n):\n#dt = {} for i in x:dt[i] = dt.get(i,0)+1\n#dt = {k:v for k,v in sorted(x.items(), key=lambda i: i[1])}\n\nfrom bisect import bisect_left as bs\nn = int(input())\nx = [int(input()) for _ in range(n)]\ndp = []\nmn = float('inf')\nidx = []\nmlen = float('-inf')\nsi,sj = 0,0\nsm = 0\ndef check(_sm,ind1,ind2,f):\n    nonlocal mn,si,sj,mlen\n    if _sm<abs(mn) or (_sm==abs(mn) and (idx[ind2]-idx[ind1])>mlen):\n        si,sj = idx[ind1]+1,idx[ind2]\n        mn = _sm*f\n        mlen = sj-si+1\n\nfor k,v in enumerate(x,1):\n    sm += v\n    ind = bs(dp,sm)\n    dp.insert(ind,sm)\n    idx.insert(ind,k)\n    check(abs(sm),0,ind,1)\n\n    if ind>0:\n        prev = ind-1\n        diff = dp[ind]-dp[prev]\n        while prev>0 and (dp[ind]-dp[prev-1])==diff:\n            prev -= 1\n        check(diff,prev,ind,1)\n    if ind < len(dp)-1:\n        nxt = ind+1\n        diff = dp[nxt]-dp[ind]\n        while nxt<len(dp)-1 and (dp[nxt+1]-dp[ind])==diff:\n            nxt += 1\n        check(diff,nxt,ind,-1)\nprint(mn)\nprint(si,sj)\n
from math import sqrt\n\nfor _ in range(int(input())):\n \n n, k = map(int, input().split())\n fact,i = [],1\n \n while i<=sqrt(n):\n\n  if n%i==0:\n   if (n // i != i):\n    fact.append(n//i)\n   \n   fact.append(i)\n   \n  i+=1\n  \n tot = (k*(k+1))//2\n mx = -1\n \n for i in fact:\n  if i>=tot:\n   mx = max(mx,n//i)\n   \n print(mx)
# cook your dish here\nfor j in range(int(input())):\n \n p,q,r,s =map(int,input().split())\n x=(s-p)\n y=(s-q)\n z=(s-r)\n print(y,z,x)
for _ in range(int(input())):\n n=int(input())\n f=list(map(int,input().split()))\n sum1=f[0]\n d=0\n i=1 \n while sum1!=0 and i<n:\n  sum1=sum1-1+f[i]\n  d+=1 \n  i+=1 \n print(d+sum1)\n
# cook your dish here\nimport bisect\nfor _ in range(int(input())):\n N,Q=list(map(int,input().strip().split(' ')))\n V=list(map(int,input().strip().split(' ')))\n VV=sorted(V)\n for ___ in range(Q):\n  x,y=list(map(int,input().strip().split(' ')))\n  x-=1\n  y-=1\n  ans1=abs(V[x]-V[y])+(y-x)\n  post1=bisect.bisect_left(VV,min(V[x],V[y]))\n  post2=bisect.bisect_right(VV,max(V[x],V[y]))\n  ans2=post2-post1\n  print(ans1,ans2)\n
# cook your dish here\nfor _ in range(0,int(input())):\n    n=input().strip()\n    x=n.count('4')\n    y=n.count('7')\n    print(len(n)-x-y)\n        
T = int(input())\nfor t in range(T):\n n, m = list(map(int, input().split()))\n c = list(map(int, input().split()))\n dp1 = [1e9]*((1 << n)+1)\n for i in range(n):\n  dp1[1 << i] = c[i] \n \n dp1[1 << (n-1)] = min(dp1[1 << (n-1)], sum(c))\n \n for i in range(m):\n  l = list(map(int, input().split()))\n  cost = l[0]\n  s = l[1]\n  items = l[2:]\n  mask = 0\n  for j in items:\n   mask = mask | (1 << (j-1))\n  dp1[mask] = min(dp1[mask], cost)\n \n for i in range((1<<n) - 1, -1, -1):\n  for j in range(n):\n   if i & (1<< j):\n    dp1[i ^ (1<<j)] = min(dp1[i ^ (1<<j)], dp1[i])\n \n dp2 = [1e9]*((1 << n) + 1)\n dp2[0] = 0\n for i in range(1 << n):\n  submask = i\n  while submask > 0:\n   dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\n   submask = (submask-1) & i\n \n print(dp2[(1 << n)-1])\n
# cook your dish here\nfor _ in range(int(input())):\n    A,B=list(map(int,input().split()))\n    l1=list(map(int,input().split()))\n    l2=list(map(int,input().split()))\n    for i in range(A*B):\n     if l1[i]<l2[i]:\n      l1[i]=0\n     else:\n      l2[i]=0\n    l1.sort(reverse=True)\n    l2.sort(reverse=True)\n \n    w,d,c=0,0,0\n    for j in range(A):\n     if l1[c]>l2[d]:\n      w+=1\n      c+=1\n      d+=B-1\n     else:\n      d+=B\n    print(w)\n   \n
t = int(input())\nfrom math import log, ceil, floor\nwhile t:\n t-=1 \n n,k = map(int ,input().split())\n v = floor(log(k, 2))\n block = 1 << v + 1 \n print(n / block * (1 + (k - 2 ** v) * 2 ))
t=eval(input())\nfor _ in range(t):\n i,j=list(map(int,input().split()))\n bi=bin(i)[2:]\n bj=bin(j)[2:]\n k=0\n while k<(min(len(bi),len(bj))):\n  if bi[k]!=bj[k]:\n   break\n  else:\n   k+=1\n print(len(bi)-k+len(bj)-k)\n \n
mod=10**9+7\ndef pow2(x):\n p,n=1,2\n while(x):\n  if(x & 1): p=((p%mod) * (n%mod))%mod\n\n  n=((n%mod) * (n%mod))%mod\n  x//=2\n\n return p\n\ndef count_bit(val):\n bit=0\n while(val):\n  bit+=1\n  val &=(val-1)\n return bit\n   \ndef answer():\n\n val=b[0]\n po2=0\n for i in range(1,len(b)):\n  if(val > b[i]):return 0\n  po2+=count_bit(val & b[i])\n  val=b[i]\n\n return pow2(po2)%mod\n\n\nfor T in range(int(input())):\n n=int(input())\n b=list(map(int,input().split()))\n\n print(answer())\n \n
import math\nn = int(input())\na=list(map(int,input().split()))\ndp = [0 for x in range(n)]\ndp[0] = a[0]\ndp[1] = a[1]\ndp[2] = a[2]\nfor x in range(3,n):\n    dp[x] = a[x] + min(dp[x-1],dp[x-2],dp[x-3])\n\nprint(min(dp[-3:]))\n
# cook your dish here\nn=int(input())\nlst=list(map(int,input().split()))\ndict1={}.fromkeys(lst,0)\nfor key in lst:\n dict1[key]+=1\nsum1=0\nfor key in dict1:\n sum1+=dict1[key]//2\n if(dict1[key]%2==1):\n  sum1+=1\nprint(sum1) 
line = input()\ntest = 0\n\nwhile line != "0":\n    test += 1\n    d = {'0':0,'1':0,'2':0,'3':0,'4':0,'5':0,'6':0,'7':0,'8':0,'9':0}\n    a = list(map(int,line.split()))\n    for i in range(min(a),max(a)+1):\n        for c in str(i):\n            d[c] += 1\n    pairs = list(d.items())\n    pairs.sort()        \n    print("Case %s: %s" % (test, " ".join(["%s:%s" % (k,v) for k,v in pairs])))\n    line = input()
from math import gcd\r\ndef compute_lcm(x, y):\r\n    lcm = (x*y)//gcd(x,y)\r\n    return lcm\r\n\r\ndef LCMofArray(a):\r\n    lcm = a[0]\r\n    for i in range(1,len(a)):\r\n        lcm = lcm*a[i]//gcd(lcm, a[i])\r\n    return lcm\r\n\r\nfor _ in range(int(input())):\r\n    lens = int(input())\r\n    arrs = [int(x) for x in input().split()]\r\n    rest = int(input())\r\n    print(LCMofArray(arrs) + rest)\r\n\r\n
#In the Name of God\r\nimport math\r\n\r\nx = input().split()\r\nn = int(x[0])\r\narr = []\r\ni = 1\r\nwhile(i<len(x)):\r\n	arr.append(float(x[i]))\r\n	i += 1\r\n	arr.append(int(x[i]))\r\n	i += 1\r\ni = 0\r\n\r\nans = []\r\nwhile(i<len(arr)):\r\n	x = arr[i]\r\n	i += 1\r\n	y = arr[i]\r\n	y = 10**y\r\n	i += 1\r\n	ans.append(x*y)\r\nfor i in range(len(ans)):\r\n	print("{:.2f}".format(ans[i]))\r\n
# cook your dish here\ndef getAns(num):\n    if num<10:return 2 \n    last=int(str(num)[0]);rem=int(str(num)[1:]);steps=2;p=len(str(num))-1\n    while True:\n     steps+=rem//last+1;rem=rem%last \n     if last>0:rem=rem+10**p-last\n     last=last-1\n     if last==0:\n      p=p-1;last=9\n      if(len(str(rem))==1):rem=0\n      else:rem=int(str(rem)[1:])\n     if rem==0:            break\n    return steps\nfor awa in range(int(input())):\n    k=int(input())\n    if(k==1):print(0)\n    elif(k==2):print(9)\n    elif(k==3):print(10)\n    else:\n     low,high,ans = 0,10**18,0\n     while(low<=high):\n      mid=(low+high)//2;temp=getAns(mid)\n      if int(temp)==k:ans=max(ans,mid);low=mid+1 \n      elif temp<k:low=mid+1 \n      else:high=mid-1 
for _ in range(int(input())):\n n = int(input())\n a = list(map(int,input().split()))\n ans = 0\n count = 0\n for i in a:\n  if i>0:\n   ans+=i\n   count+=1\n res = []\n for i in range(count):\n  if a[i]<=0:\n   res.append(i+1)\n for i in range(count,n):\n  if a[i]>0:\n   res.append(i+1)\n print(ans)\n print(len(res),*res)
import bisect\n\ndef pre(a):\n for p in range(n-1):\n  if(a[p]>=a[p+1]):\n   return p\n return n-1 \n \ndef suf(a):\n for s in range(1,n):\n  if(a[n-s]<=a[n-s-1]):\n   return n-s\n return 0\n \n \n\nt=int(input())\nfor _ in range(t):\n n=int(input())\n a=list(map(int,input().split()))\n \n p=pre(a)\n s=suf(a)\n \n b=a[s:n]\n count=0\n for i in range(p+1):\n  k=bisect.bisect(b,a[i])\n  k+=s\n  count+=n-k+1\n  \n if(s==0):\n  print((n*(n+1))//2-1)\n else:\n  print(count+n-s)\n
import math\nfor i in range(int(input())):\n n,x=list(map(int,input().split()))\n l=list(map(int,input().split()))\n l.sort()\n flag=0\n d=0\n \n for j in range(n):\n  \n  if l[j]>x:\n   for k in range(j,n):\n    \n    if x<l[k]:\n    \n    \n     d+=(math.ceil(math.log(l[k]/x)/math.log(2))+1)\n     \n    else:\n     d+=1\n     \n\n    x=l[k]*2\n    \n    \n    \n    \n    flag=1\n   \n   \n   break\n  \n if flag==1:\n  \n  print(j+d)\n else:\n  print(n)\n
# cook your dish here\ndef check_equal(a,b):\n index=0\n for i in a:\n  while index<len(b) and i != b[index]:\n   index+=1\n  if(index>=len(b)):\n   return False\n  index+=1 \n return True\ndef Dob_String(n):\n size=len(n)\n midpoint=size//2\n if(check_equal(n[0:midpoint],n[midpoint:size])):\n  return("YES")\n elif(size%2!=0 and check_equal(n[midpoint+1:size],n[0:midpoint+1])):\n  return("YES")\n else:\n  return("NO")\nT=int(input()) \nfor _ in range(T):\n n=input()\n if(len(n)>1):\n  print(Dob_String(n))\n else:\n  print("NO")
# cook your dish here\ndef __starting_point():\n try:\n  for _ in range (int(input())):\n   element = int(input())\n   l = list(map(int,input().split()))\n   a=min(l)\n   l.remove(a)\n   b=min(l)\n   print(a+b)\n except EOFError :\n  print('EOFError')\n\n__starting_point()
for _ in range(int(input())):\n code=input().strip()+'0'\n message=''\n asc=int(code[0])\n \n for i in range(len(code)-1):\n  \n  if int(str(asc)+code[i+1])>256:\n   message+=chr(asc)\n   asc=int(code[i+1])\n  else:    \n   asc=int(str(asc)+code[i+1])\n   \n print(message)\n
for _ in range(int(input())):\n n,w = map(int , input().split())\n sigma = 1\n #len(str(num)) == n and D[i] - D[i - 1] ... = w\n if(w > 9 or w < -9):\n  print(0)\n  continue\n sigma = pow(10,n - 2,1000000007)\n if(w >= 0):\n  sigma *= (9 - w)\n else:\n  sigma *= (w + 10)\n print(sigma % 1000000007)
import sys\nans=0\nn,m=list(map(int,input().split()))\naaaaa=100\nli=list(map(int,input().split()))\nnon_special,special=[],[]\nfor i in range(m):\n ans+=1\n f,p,s=list(map(str,input().split()))\n f=int(f)\n poww=pow(1,2)\n p=int(p)\n if f not in li:\n  ans+=1\n  non_special.append((p,s))\n  ans-=1\n else:\n  ans+=1\n  special.append((p,s))\n  \nnon_special.sort(reverse=True)\naaaa=pow(1,2)\nspecial.sort(reverse=True)\n\nfor temp in range(len(special)):\n ans+=1\n print(special[temp][1])\nfor temp in non_special:\n ans+=1\n print(temp[1])
from collections import defaultdict\nimport copy\n#def dfs(l,r,dct):\ndef dfs(l,r,dct):\n visit=[0 for i in range(n+1)]\n arr=[l]\n while(arr):\n  node=arr.pop()\n  if node==r:return True\n  visit[node]=1\n  for lnk in dct[node]:\n   if not visit[lnk]:\n    arr.append(lnk)\n return False\n \ndef ok(mid,cst):\n for i,j in edges:\n  cst[i][j]-=mid\n \n d=[10**9]*(n+1)\n d[l]=0\n for _ in range(n-1):\n  for i,j in edges:\n   d[j]=min(d[j],d[i]+cst[i][j])\n   \n if d[r]<=0:return 1\n for i,j in edges:\n  if d[j]>d[i]+cst[i][j] and dfs(l,i,dct) and dfs(j,r,dct):\n   return 1\n return 0\n \nfor _ in range(int(input())):\n n,m=map(int,input().split())\n dct=defaultdict(list)\n \n cost=[[1000 for i in range(n+1)] for j in range(n+1)]\n edges=[]\n for i in range(m):\n  a,b,w=map(int,input().split())\n  edges.append([a,b])\n  dct[a].append(b)\n  cost[a][b]=min(cost[a][b],w)\n \n l,r=map(int,input().split())\n if not dfs(l,r,dct):\n  print(-1)\n  continue\n #print(cost)\n lo=1\n hi=101\n for i in range(100):\n  cst=copy.deepcopy(cost)\n  mid=(lo+hi)/2\n  if ok(mid,cst):hi=mid-1\n  else:lo=mid+1\n print("%.7f"%mid)
from sys import *\ninput=stdin.readline\nfor u in range(int(input())):\n    s=int(input())\n    if(s%3==0):\n        print(1)\n    else:\n        print(0)\n
m= 1000000007\ndef mul(a,b):\n return [(a[0]*b[0]+a[1]*b[2])%m,\n   (a[0]*b[1]+a[1]*b[3])%m,\n   (a[2]*b[0]+a[3]*b[2])%m,\n   (a[2]*b[1]+a[3]*b[3])%m] \ndef f(n):\n if n==0:\n  return 0\n v1, v2, v3 = 1, 1, 0 \n for rec in bin(n)[3:]:\n  v2=v2%m\n  v1=v1%m\n  v3=v3%m\n  calc = (v2*v2)\n  v1, v2, v3 = (v1*v1+calc), ((v1+v3)*v2), (calc+v3*v3)\n  if rec=='1': v1, v2, v3 = v1+v2, v1, v2\n return [v1+1,v2,v2,v3+1]\n\ndef q(X,Y):\n nonlocal A\n s = [1,0,0,1]\n for v in A[X-1:Y]:\n  s = mul(s,f(v))\n return s[1]%m\n\nN,M = list(map(int,input().split()))\nA=list(map(int,input().split()))\nfor _ in range(M):\n [T,X,Y] = input().split()\n X,Y = int(X),int(Y)\n if T=='Q':\n  print(q(X,Y))\n else:\n  A[X-1]=Y
for _ in range(int(input())):\n    n=int(input())\n    arr=list(map(int,input().split()))\n    d=set()\n    for i in arr:\n        d.add(i)\n    for i in range(n):\n        if i in d:\n            print(i,end=" ")\n        else:\n            print(0,end=" ")\n    print()
from collections import Counter\nt=int(input())\nfor i in range(t):\n k=int(input())\n l=list(map(int,input().split()))\n a=Counter(l)\n b=list(a.keys())\n b.sort()\n for x in b:\n  s=str(x)+': '+str(a[x])\n  print(s)
# cook your dish here\ndef check(px,x):\n if px[1]==x[1]:\n  return (x[2]-px[2])<=(x[0]-px[0]) and (x[2]>=px[2])\n else:\n  return (x[2]-px[2]+1)<=(x[0]-px[0]) and (x[2]>=px[2])\n  \ndef checkdouble(px,x):\n if px[3]==x[3]:\n  return (x[4]-px[4])<=(x[0]-px[0]) and (x[4]>=px[4])\n else:\n  return (x[4]-px[4]+1)<=(x[0]-px[0]) and (x[4]>=px[4])\n  \n\nfor _ in range(int(input())):\n px=[0,1,1,2,1]\n g=True\n for _ in range(int(input())):\n  x=list(map(int,input().split()))\n  if x[1]==x[3] and x[2]==x[4]:\n   g=False\n  if not g:\n   continue\n  g=check(px,x)\n  if g:\n   g=checkdouble(px,x)\n  px=x\n if not g:\n  print("no")\n else:\n  print("yes")\n \n \n \n \n \n \n
A = [0] * 100001\nM = 1000000007\n\ndef nCk(n, k):\n if k ==0 or k ==n:\n  return 1\n r = (A[n-k]*A[k])%M\n x = (A[n]*pow(r, M-2, M))%M\n return x\n\nfor _ in range(int(input())):\n n, k = list(map(int, input().split()))\n for i in range(n-1):\n  u,v = input().split()\n summ = 0\n A[0] = 1\n for i in range(1, len(A)):\n  A[i] = (i*A[i-1])%M\n for i in range(min(n, k)):\n  b = nCk(k,i+1)\n  c = (nCk(n-1,i)*b)%M\n  c *= A[i+1]\n  summ += (c%M)\n  summ %= M\n print(summ)
# cook your dish here\ndef index(n,val):\n    while(val >= n):\n        val = val//2\n    return n - val\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int,input().split())) \n    new = [0 for i in range(n)]\n    for i in range(n):\n        if arr[i]<=n :\n            new[i] = arr[i] + arr[arr[i]-1]\n        else:\n            new[i] = arr[index(n,arr[i]) - 1]\n    print(*new)
t=[[1]]\ndef bell_numbers(start, stop):\n ## Swap start and stop if start > stop\n if stop < start: start, stop = stop, start\n if start < 1: start = 1\n if stop < 1: stop = 1\n c = 1 ## Bell numbers count\n while c <= stop:\n  if c >= start:\n   yield t[-1][0] ## Yield the Bell number of the previous row\n  row = [t[-1][-1]] ## Initialize a new row\n  for b in t[-1]:\n   row.append((row[-1] + b)%1000000007)\n  c += 1 ## We have found another Bell number\n  t.append(row) ## Append the row to the triangle\n\nar=[0]*1001\ni=0\nfor b in bell_numbers(1,1001):\n ar[i]=b\n i+=1\nT=eval(input())\nwhile T:\n N=eval(input())\n print(ar[N])\n T-=1\n
# cook your dish here\nfor _ in range(int(input())):\n    n=int(input())\n    lst=list(map(int,input().split()))\n    f=0\n    t=0\n    p=1\n    for i in lst:\n        if(i==5):\n            f+=1\n        elif(i==10):\n            if(f>0):\n                f-=1\n                t+=1\n            else:\n                p=0\n                break\n        else:\n            if(t>0):\n                t-=1\n            else:\n                if(f>1):\n                    f-=2\n                else:\n                    p=0\n                    break\n    if(p==1):\n        print("YES")\n    else:\n        print("NO")
# cook your dish here\nimport bisect\n\nfor _ in range(int(input())):\n w,k=map(str, input().split())\n k=int(k)\n n=len(w)\n w=list(w)\n w.sort()\n w.append('0')\n c=1\n l=0\n l1=[]\n l2=[]\n for i in range(1, n+1):\n  if w[i]==w[i-1]:\n   c+=1\n  else:\n   a=bisect.bisect_left(l1, c)\n   if a==l:\n    l1.append(c)\n    l2.append(1)\n    l+=1\n   elif l1[a]==c:\n    l2[a]=l2[a]+1\n   else:\n    l1.insert(a, c)\n    l2.insert(a, 1)\n    l+=1\n   c=1\n a=l1[-1]-l1[0]\n if a<=k:\n  print(0)\n else:\n  ans=n \n  for i in range(l):\n   temp=l2[i]*l1[i]\n   for j in range(i+1, l):\n    p=l1[j]-l1[i]\n    if p<=k:\n     temp+=(l2[j]*l1[j])\n    else:\n     p1=p-k\n     temp+=(l2[j]*(l1[j]-p1))\n   ans=min(ans, (n-temp))\n     \n  print(ans)
# cook your dish here\nfor _ in range(int(input())):\n n=int(input())\n ar=list(map(int,input().split()))\n odd=0\n even=0\n if n==1:\n  print(0)\n  continue\n for i in range(n):\n  if ar[i]%2==1:\n   odd+=1\n  else:\n   even+=1\n if odd>0:\n  vo=(odd-1)*2+even\n else:\n  vo=even\n if even>0:\n  ve=(even-1)*2+odd\n else:\n  ve=odd\n print(min(vo,ve))\n
for _ in range(eval(input())):\n    S1=input()\n    m1=len(S1)/2\n\n    S2=input()\n    m2=len(S2)/2\n    d1={}\n    d2={}\n    for i in range(len(S1)):\n        c=S1[i]\n        v=abs(m1-i)\n        if c in d1:\n            if v<d1[c][0]:\n                d1[c]=[v,i]\n        else:\n            d1[c]=[v,i]\n    for i in range(len(S2)):\n        c=S2[i]\n        v=abs(m2-i)\n        if c in d2:\n            if v<d2[c][0]:\n                d2[c]=[v,i]\n        else:\n            d2[c]=[v,i]\n\n    mini=999999999999999999999999999999999\n    for i in d1:\n        if i in d2:\n            L1=d1[i][1]\n            L3=len(S1)-L1-1\n            L2=d2[i][1]\n            L4=len(S2)-L2-1\n            v=abs(L1-L2)+abs(L2-L3)+abs(L3-L4)+abs(L4-L1)\n            if v<mini:\n                mini=v\n    print(mini)
# cook your dish here\nfrom itertools import accumulate\nn, k = map(int, input().split())\nlst = list(map(int, input().split()))\ntemp = (10**9)+7\nfor i in range(k):\n    lst = list(accumulate(lst))\nfor i in lst:\n    print(i%(temp), end = ' ')
"""\n4\n4\n4 3 1 2\n6\n1 2 2 1 3 1\n5\n10 1 2 10 5\n4\n1 2 1 2\n"""\ntests = int(input())\n\nfor _ in range(tests):\n\n n = int(input())\n ls = list(map(int, input().split()))\n\n if ls[0] < ls[1]:\n  ls[0] = -ls[0]\n\n if ls[-1] < ls[-2]:\n  ls[-1] = -ls[-1]\n\n for i in range(1, n - 1):\n  if ls[i] < ls[i - 1] and ls[i] < ls[i + 1]:\n   ls[i] = -ls[i]\n   '''\n      if i > 1 and ls[i - 2] < 0 and ls[i] - ls[i-2] >= ls[i-1]:\n       # There can be only one!\n       if -ls[i-2] < ls[i]:\n        # We win!\n        ls[i-2] = -ls[i-2]\n        ls[i] = -ls[i]\n        #else:\n        # They win!\n        # Do nothing\n      else:\n       # We both can go negative\n       ls[i] = -ls[i]\n      '''\n   \n #print(ls)\n \n ind = 1\n\n while ind < n - 1:\n\n  started = False\n  pos = []\n  while ind < n - 1 and ls[ind] + ls[ind - 1] + ls[ind + 1] <= 0:\n   if not started:\n    pos.append(ind - 1)\n    pos.append(ind + 1)\n    started = True\n   else:\n    pos.append(ind + 1)\n   ind += 2\n\n  #print(pos,ls)\n\n  if started:\n   rec = [0] * (len(pos) + 1)\n\n   for i in pos:\n    ls[i] = -ls[i]\n\n   rec[0] = 0\n   rec[1] = ls[pos[0]]\n\n   for i in range(2, len(pos) + 1):\n    rec[i] = max(rec[i - 1], ls[pos[i - 1]] + rec[i - 2])\n\n   itr = len(pos)\n   while itr > 0:\n    if itr == 1 or rec[itr] == ls[pos[itr - 1]] + rec[itr - 2]:\n     ls[pos[itr - 1]] = -ls[pos[itr - 1]]\n     itr -= 2\n    else:\n     itr -= 1\n\n  ind += 1\n\n for i in ls:\n  print(i, end = ' ')\n print() \n\n  \n\n
val = 10**9 + 7\ndef MOD(a,b):\n aans = a\n ans = 1\n while b>0:\n  ans = (ans*aans)%val\n  aans = (aans*aans)%val\n  b/=2\n return ans%val\n \n\n\nfor i in range(eval(input())):    \n n,d= list(map(int,input().split()))\n a=int(str(d)*n)\n sqr = str(a*a)\n ans =0\n count=0\n for ii in sqr :\n  ans= ans+int(ii)*23**count\n  count+=1\n  z=int(ii)*ans\n print(ans % (10**9+7))\n \n  \n
t = int(input())\n\nfor i in range(t):\n n, c = list(map(int,input().split()))\n\n pts = {}\n moves = 0\n\n for i in range(n):\n  x, y = list(map(int,input().split()))\n  if (y-x,x%c) in pts:\n   pts[(y-x,x%c)].append(x)\n  else:\n   pts[(y-x,x%c)] = [x]\n \n for i in pts:\n  arc = sorted(pts[i])\n  \n  for j in arc:\n   moves = moves + abs((j-arc[len(arc)//2]))//c\n \n print(len(pts),moves)\n\n\n   \n\n\n
tb=str(input())\ntb=list(tb)\nif("c" in tb or "k" in tb):\n print(0)\nelse:\n ans=1\n i=0\n while(i<len(tb)):\n  if(tb[i]=="g" or tb[i]=="f"):\n   my=tb[i]\n   i+=1\n   ct=1\n   while(i<len(tb) and tb[i]==my):\n    ct+=1\n    i+=1\n   if(ct>3):\n    ct+=1\n   ans*=ct\n  else:\n   i+=1\n print(ans)
# cook your dish here\nN=int(input())\nfor _ in range(N):\n    n=int(input())\n    arr=list(map(int,input().split()))[:n]\n    count=0\n    last=0\n    for i in range(n):\n        if(arr[i]!=0):\n            break\n        last=i\n        count+=1\n    for i in arr[-1:last:-1]:\n        if(i!=0):\n            break\n        count+=1\n    ans=n-count\n    if(ans==0):\n        print(1)\n    else:\n        print(ans)\n
from sys import stdin,stdout\n\n\n\n\ntotal_cost=0\ndef find(a):\n if par[a]==a:\n  return a\n else:\n  par[a]=find(par[a])\n  return par[a]\ndef union(a,b,c):\n a,b=find(a),find(b)\n nonlocal total_cost\n total_cost+=(rank[a]*rank[b]*c)\n if a!=b:\n  if rank[a]>rank[b]:\n   par[b]=a\n   rank[a]+=rank[b]\n  elif rank[b]>rank[a]:\n   par[a]=b\n   rank[b]+=rank[a]\n  else:\n   par[a]=b;\n   rank[b]+=rank[a]\n\nn=int(stdin.readline().strip())\npar=[i for i in range(n)]\nrank=[1 for i in range(n)]\nedges=[]\nfor i in range(n-1):\n u,v,c=stdin.readline().strip().split(' ')\n u,v,c=int(u)-1,int(v)-1,int(c)\n edges.append((c,u,v))\nedges.sort()\ntw=0\nfor i in edges:\n union(i[1],i[2],i[0])\n tw+=i[0]\n\nstdout.write(str(tw-(total_cost/((n*(n-1))/2))))
# cook your dish here\nfor _ in range(int(input())):\n    h,x=map(int,input().split())\n    if(h>=x):\n        print("Yes")\n    else:\n        print("No")
from math import sqrt \n\ntest = int(input())\nfor i in range(test):\n sum = 0\n max = int(input())\n if max==1:\n  sum = 0\n elif max==2:\n  sum += 2\n else:    \n  sum = sum + 2\n  for x in range(3,max+1):\n   half = int(sqrt(x)) + 1\n   if all(x%y!=0 for y in range(2,half)):\n    sum = sum + x\n print(sum) 
for _ in range(int(input())):\n k, n = input().split()\n\n while int(n) >= 5:\n  print(len(set(k)) ** 3)\n  break
for i in range(int(input())):\n yy=input()\n y=[int(e) for e in yy.split()]\n zz=input()\n z=[int(e) for e in zz.split()]\n count=0\n for i in z:\n  a=i+y[1]\n  if a%7==0:\n   count+=1\n print(count)
# cook your dish here\ntry:\n t = int(input())\n for i in range(t):\n  ar=list(map(int,input().split()))\n  if (ar[0]**2 + ar[1]**2 > ar[2]**2 + ar[3]**2):\n   print("B IS CLOSER")\n  else:\n   print("A IS CLOSER")\n  \n  \n  \nexcept:\n pass\n \n \n
def main():\n t= int(input())\n while(t!=0):\n  n,k = list(map(int , input().split()))\n  arr = list(map(int, input().split()))\n  freq = [0]*100001\n  k=k-1\n  st=0\n  end=0\n  currentCount=0\n  previousElement = 0\n  for i in range(n):\n   freq[arr[i]]+=1\n   if(freq[arr[i]]==1):\n    currentCount+=1\n\n   while(currentCount>k):\n    freq[arr[previousElement]]-=1\n    if(freq[arr[previousElement]]==0):\n     currentCount-=1\n\n    previousElement+=1\n\n   if(i-previousElement+1 >= end-st+1):\n    end=i\n    st=previousElement\n\n  print(end-st+1)\n  t=t-1\n\ndef __starting_point():\n main()\n\n\n\n\n\n__starting_point()
t=eval(input())\nwhile t>0:\n  t=t-1\n  f1,f2,r1,r2,r3,r4=list(map(int,input().split()))\n  p1,p2,p3,p4=list(map(float,input().split()))\n  s1=(1-p1)*(-f1)+(r2-f1)*(1-p2)*p1+p1*p2*(r1-f1)\n  s2=(1-p3)*(-f2)+(r3-f2)*(p3)*(1-p4)+p3*p4*(r3+r4-f2)\n  if s1>s2:\n    print('FIRST')\n  elif s1<s2:\n    print('SECOND')\n  else:\n    print('BOTH')\n    \n
t = int(input())\nwhile t > 0:\n\n s = int(input())\n\n while s % 10 == 0 : \n  s /= 10\n\n print(''.join(reversed(str(s))))\n\n t = t - 1
# cook your dish here\nfor _ in range(int(input())):\n n,k=map(int,input().split())\n c=[int(i) for i in input().split()]\n i=0\n m=0\n if(n==2 and k==5):\n  c1=c\n  c.sort()\n  d=dict()\n  for i in range(len(c)):\n   for j in range(len(c1)):\n    if(c[i]==c1[j]):\n     d[i]=j\n     c1[j]=-1\n     break\n   \n  while(m<n):\n   if (i==n):\n    print(d[n],k,d[n-1],0)\n    c[n]-=k\n    m+=1\n   else:\n    if(c[i]>=k):\n     print(d[i],k,d[i+1],0)\n     c[i]=c[i]-k\n     m+=1\n    elif(c[i]==0):\n     i+=1\n    else:\n     for j in range(i+1,n+1):\n      if(c[i]+c[j]>=k):\n       print(d[i],c[i],d[j],k-c[i])\n       c[j]-=k-c[i]\n       c[i]=0\n       m+=1\n       break\n  \n else:\n  while(m<n):\n   if (i==n):\n    print(n,k,n-1,0)\n    c[n]-=k\n    m+=1\n   else:\n    if(c[i]>=k):\n     print(i,k,i+1,0)\n     c[i]=c[i]-k\n     m+=1\n    elif(c[i]==0):\n     i+=1\n    else:\n     for j in range(i+1,n+1):\n      if(c[i]+c[j]>=k):\n       print(i,c[i],j,k-c[i])\n       c[j]-=k-c[i]\n       c[i]=0\n       m+=1\n       break
# cook your dish here\nfor _ in range (int(input())):\n    x1,y1,x2,y2=map(int,input().split())\n    av1=(x1+y1)/2\n    av2=(x2+y2)/2\n    if(av1>av2):\n        print(av1-av2," DEGREE(S) ABOVE NORMAL")\n    else:\n        print(av2-av1," DEGREE(S) BELOW NORMAL")
a,n,k = map(int,input().split())\nfor i in range(k):\n print(a%(n+1),end=' ')\n a=a//(n+1)
import sys,math\n\ndef main(filename):\n inputfile = open(filename,'rU')\n data = inputfile.readlines()\n T=data.pop(0)\n ans=[]\n ansstring=str()\n explored=[]\n for i in T:\n  if i in explored:\n   #print explored\n   for j in range(len(ans)):\n    if ans[j][0]==i:\n     ans[j][1] += 1\n  else:\n   ans.append([i,1])\n   explored.append(i)\n for i in ans:\n  ansstring += i[0]+str(i[1])\n print(ansstring) \n   \n\n\n inputfile.close()\n\ndef __starting_point():\n main(sys.argv[1])\n__starting_point()
# cook your dish here\nT = int(input())\n\nfor t in range(T):\n    N = int(input())\n    \n    print(int(((N-1)*(N))/2))
# cook your dish here\nt = int(input())\nfor _ in range(t):\n    n, k, d = list(map(int, input().split()))\n    x = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    lane = 3 - l[0]\n    switched = -float('inf')\n    ans = k\n    for i in range(n):\n     if l[i] == lane:\n      if switched + d < x[i] and x[i - 1] + 1 < x[i]:\n       lane = 3 - lane\n       switched = max(x[i - 1] + 1, switched + d)\n      else:\n       ans = x[i]\n       break\n    print(ans)\n
n=int(input())\na=list(map(int,input().split()))\nx=int(input())\nl=[]\nfor i in a:\n if i<0:\n  l.append(-i)\nl.sort()\nm=len(l)\nans=0\nif l:\n if x>n:\n  ans=sum(l)\n else:\n  ans=sum(l[m-x:])\nprint(ans)\n\n \n
T = int(input())\r\nfor _ in range(T):\r\n    N, K1, K2 = list(map(int, input().split()))\r\n    P1, P2, P3, P4 = list(map(int, input().split()))\r\n    ans = 0\r\n    arr = [0] * (1005)\r\n\r\n    length = len(arr)\r\n    for i in range(1,N+1):\r\n\r\n        j = 0\r\n        while j < length:\r\n            arr[j] += 1\r\n            j += i\r\n\r\n    for i in range(K1,K2+1):\r\n        if arr[i]==3:\r\n           ans += P1\r\n        elif arr[i]%2==1:\r\n            ans += P2\r\n        else:\r\n            ans += P3\r\n\r\n    print(ans)\r\n
for _ in range(int(input())):\n\n n, k = map(int, input().split())\n l = [*map(int, input())]\n\n count = [0] * (n + 1)\n\n for i in range(n - 1, -1, -1):\n  if l[i] == 1:\n   count[i] = count[i + 1] + 1\n\n x,y = 0,0\n for i in range(n):\n  if l[i] == 1:\n   x += 1\n  else:\n   try:\n    y = max(y, x + k + count[i + k])\n\n   except:\n    y = max(y, x + min(k, n - i))\n   x = 0\n  y = max(y,x)\n print(y)
def __starting_point():\n t=int(input())\n for _ in range(t):\n  n,p=input().split()\n  n,p=int(n),int(p)\n  s=input()\n  a,b=0,0\n  arr=[0]*n\n  for i in range(n):\n   arr[i]=s[i]\n  for c in s:\n   if c=='a':\n    a+=1\n   else:\n    b+=1\n  swap=0\n  for i in range(a):\n   if s[i]=='b':\n    swap+=1\n  tmpp=p\n  if p<=swap:\n   for i in range(n):\n    if p==0:\n     break\n    if arr[i]=='b':\n     arr[i]='a'\n     p-=1\n   p=tmpp\n   for i in range(n-1,-1,-1):\n    if p==0:\n     break\n    if arr[i]=='a':\n     arr[i]='b'\n     p-=1\n   for c in arr:\n    print(c,end="")\n   print()\n  else:\n   for i in range(n):\n    if i<a:\n     arr[i]='a'\n    else:\n     arr[i]='b'\n   p-=swap\n   for i in range(n):\n    if arr[i]=='b':\n     if s[i]=='b' and p>=2:\n      p-=2\n      arr[i]='a'\n     if s[i]=='a' and p>=1:\n      p-=1\n      arr[i]='a'\n   for c in arr:\n    print(c,end="")\n   print()\n__starting_point()
from math import factorial\n\nfor _ in range(int(input())):\n N,M=[int(a) for a in input().split()]\n print(float(N+M-1))
# cook your dish here\nimport sys\n\nmod_val = 1000000007\nrang = [0]*101\npow_cache = [0]*102\nmultisets = {}\n\n\ndef mod_pow(base, pow):\n result = 1\n while pow:\n  if pow&1:\n   result = (result*base) % mod_val\n  base = (base*base) % mod_val\n  pow = pow>>1\n return result\n\n\ndef precalculate():\n\n for i in range(1, 102):\n  pow_cache[i] = mod_pow(i, mod_val-2)\n\n\ndef cal_recurse(i, target_sum):\n if target_sum == 0:\n  return 1\n if i>=target_sum:\n  return 0\n if (i, target_sum) in multisets:\n  return multisets[(i, target_sum)]\n ans = cal_recurse(i+1, target_sum)\n max_pos = target_sum//(i+1)\n choose = rang[i+1]%mod_val\n for j in range(1, max_pos+1):\n  temp = choose*cal_recurse(i+1, target_sum-j*(i+1))\n  # temp%=mod_val\n  ans += temp\n  ans %= mod_val\n  choose *= rang[i+1]+j\n  # choose %= mod_val\n  choose *= pow_cache[j+1]\n  choose %= mod_val\n multisets[i, target_sum] = ans\n return ans\n\n\ndef calculate(target_sum, rang_index):\n populate(target_sum, rang_index)\n return cal_recurse(0, target_sum)\n\n\ndef populate(target_sum, rang_i):\n for i in range(1, target_sum+1):\n  rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3]*i)*i)*i\n\n\n_test_cases = int(input())\nprecalculate()\nfor _a_case in range(_test_cases):\n rang = [0]*101\n multisets = {}\n _rang_index = [int(i) for i in input().split(' ')]\n _target_sum = int(input())\n print(calculate(_target_sum, _rang_index))\n
arr = [0]*6\n\narr[1] = 250000*(0.05)\narr[2] = 250000*(0.10)\narr[3] = 250000*(0.15)\narr[4] = 250000*(0.20)\narr[5] = 250000*(0.25)\n\nfor _ in range(int(input())):\n n = int(input())\n\n tax = 0\n\n if n<=250000:\n  tax = 0\n\n elif 250000<n<=500000:\n  tax = sum(arr[:1])\n\n  rem = n - 250000\n\n  tax+= (rem)*(0.05)\n\n elif 500000<n<=750000:\n  tax = sum(arr[:2])\n\n  rem = n - 500000\n\n  tax+= (rem)*(0.10)\n\n elif 750000<n<=1000000:\n  tax = sum(arr[:3])\n\n  rem = n - 750000\n\n  tax+= (rem)*(0.15)\n\n elif 1000000<n<=1250000:\n  tax = sum(arr[:4])\n\n  rem = n - 1000000\n\n  tax+= (rem)*(0.20)\n \n elif 1250000<n<=1500000:\n  tax = sum(arr[:5])\n\n  rem = n - 1250000\n\n  tax+= (rem)*(0.25)\n \n elif n>1500000:\n  tax = sum(arr[:6])\n\n  rem = n - 1500000\n\n  tax+= (rem)*(0.30)\n \n res = int(n - tax)\n \n print(res)\n\n\n\n \n\n\n \n\n
N = int(input())\nl = []\nfor i in range(N):\n    l.append(input())\nfor j in range(N-1,-1,-1):\n    s = '` '+ l[j]\n    n = len(s)-1\n    y = s[n]\n    f = ''\n    while y != '`':\n        w = ''\n        while y != ' ':\n            if ord(y) in range(97,123) or ord(y) in range(65,91):\n                w += y\n            n -= 1\n            y = s[n]\n        wf = ''\n        n -= 1\n        y = s[n]\n        x = len(w)\n        for k in range(x):\n            wf += w[x-k-1]\n        f += wf+' '\n    print(f)
# cook your dish here\nfor h in range(int(input())):\n n,q=map(int,input().split())\n print(q*(n+q+1)/(q+1))
try:\n for _ in range(int(input())):\n  N, K = map(int, input().split())\n  cell = []\n  count = 0\n  l = []\n  for __ in range(N):\n   inserted = list(map(int, input().split()))\n   cell.append(inserted)\n\n\n\n  \n\n\n\n\n  cell.sort(key=lambda x: x[1])\n  time = {}\n\n  for number in cell:\n   if number[2] not in time:\n    time[number[2]] = number[1]\n\n    count += 1\n   elif number[0] >= time[number[2]]:\n    time[number[2]] = number[1]\n    count += 1\n\n\n\n\n\n  print(count)\n\n\nexcept:\n pass
a,b=map(int,input().split())\r\nprint(a+b)
for _ in range(int(input())):\n n = int(input())\n l = list(map(int,input().split()))\n ans = 1\n l1 = l[0]\n for i in range(1,n):\n  if l[i] <= l1:\n   l1 = l[i]\n   ans = ans + 1\n print(ans)
from math import *\ndef list_input():\n    return list(map(int,input().split()))\ndef map_input():\n    return list(map(int,input().split()))\ndef map_string():\n    return input().split()\ndef g(n):\n    return (n*(n+1)*(2*n+1))//6\ndef f(n):\n    ans = 0\n    for i in range(1,floor(sqrt(n))+1):\n     ans+=i*(i+floor(n/i))*(floor(n/i)+1-i)\n    return ans-g(floor(sqrt(n)))\nfor _ in range(int(input())):\n    n=int(input())\n    print(f(n)%1000000007)\n\n
# cook your dish here\nfor test in range(0,int(input())):\n A,B = map(int,input().split())\n diff = abs(A-B)\n count=0\n if not(A^B):\n  print(-1)\n else:\n  for i in range(1,int(diff**(1/2))+1):\n   if diff%i==0:\n    if diff/i==i:\n     count+=1 \n    else:\n     count+=2\n  print(count)
t = input()\nt = int(t)\n\nfor _ in range(t):\n n, m, x, y = input().split()\n n = int(n)\n m = int(m)\n x = int(x)\n y = int(y)\n n -= 1\n m -= 1\n flag = 0\n if n % x == 0 and m % y == 0:\n  flag = 1\n n -= 1\n m -= 1\n if n >= 0 and m >= 0:\n  if n % x == 0 and m % y == 0:\n   flag = 1\n \n if flag == 1:\n  print("Chefirnemo")\n else:\n  print("Pofik")
def mForMaxSeq(arr, n):\r\n    eim = dict()\r\n    for i in range(n):\r\n        if arr[i] in eim:\r\n            eim[arr[i]].append(i)\r\n        else:\r\n            eim[arr[i]] = [i]\r\n    \r\n    keys = sorted(eim.keys())\r\n    \r\n    # print(eim, keys)\r\n\r\n    connected = False\r\n    count = 0\r\n    pI = -1\r\n\r\n    nKeys = len(keys)\r\n    for i in range(nKeys-1):\r\n        \r\n        if not connected:\r\n            pI = eim[keys[i]][0]\r\n            \r\n            for idx in eim[keys[i+1]]:\r\n                if idx >pI:\r\n                    connected = True\r\n                    count += 1\r\n                    pI = idx\r\n                    break\r\n        else:\r\n            connected = False\r\n\r\n            for idx in eim[keys[i+1]]:\r\n                if idx > pI:\r\n                    connected = True\r\n                    count += 1\r\n                    pI = idx\r\n                    break\r\n\r\n    \r\n    return (nKeys - count)\r\n\r\n\r\ndef __starting_point():\r\n    for _ in range(int(input())):\r\n        n = int(input())\r\n        arr = list(map(int, input().split()))\r\n        \r\n        print(mForMaxSeq(arr, n))\r\n        \r\n        \r\n\n__starting_point()
def solve(S):\n a = set(S)\n return len(a)\n \n \nt = int(input())\n\nfor _ in range(t):\n s = input()\n print(solve(s))
import numpy as np\r\n\r\ndef solve(n,k,a,l,r):\r\n    shape = (n,n)\r\n    mat = np.zeros(shape, dtype=np.int64)\r\n    for i in range(n):\r\n        for j in range(l[i], r[i]):\r\n            mat[i][j]=1\r\n    \r\n    ans = np.eye(n,n, dtype=np.int64)\r\n    while(k>0):\r\n        if k%2 == 1:\r\n            ans = np.matmul(mat, ans)\r\n            ans%=2\r\n        mat = np.matmul(mat, mat)\r\n        mat%=2\r\n        k = k//2\r\n    result = []\r\n    for i in range(n):\r\n        aux = 0\r\n        for j in range(n):\r\n            if ans[i][j] == 1:\r\n                aux^=a[j]\r\n        result.append(aux)\r\n    return result\r\n        \r\n\r\n\r\n\r\n\r\nt = int(input())\r\nfor i in range(t):\r\n    s = input().split()\r\n    n = int(s[0])\r\n    k = int(s[1])\r\n    a = []\r\n    l = []\r\n    r = []\r\n    s = input().split()\r\n    for i in range(n):\r\n        a.append(int(s[i]))\r\n    for i in range(n):\r\n        s = input().split()\r\n        l.append(int(s[0])-1)\r\n        r.append(int(s[1]))\r\n    arr = solve(n,k-1,a,l,r)\r\n    s = ""\r\n    for e in arr:\r\n        s += str(e)\r\n        s +=" "\r\n    print(s)\r\n
# cook your dish here\nfor _ in range(int(input())):\n n,l,h=list(map(int,input().split()))\n print(n-l+1+2**(l)-2,1+2**(h)-2+2**(h-1)*(n-h))\n
n,k = map(int,input().split())\nprices = list(map(int,input().split()))\nprices.sort()\nsum,cnt = 0, 0\nfor price in prices:\n sum += price\n if sum <= k: cnt += 1\n else: break\nprint(cnt)
def add(A, B):\n cnt = 0\n while B > 0:\n  U = A ^ B\n  B = (A & B) * 2\n  A = U\n  cnt += 1\n return cnt\n\nfor _ in range(int(input())):\n print(add(int(input(),2), int(input(), 2)))
# cook your dish here\n# cook your dish here\ndef numDec(s):\n  if not s:\n   return 0\n\n  dp = [0 for _ in range(len(s) + 1)]\n\n  dp[0] = 1\n  dp[1] = 0 if s[0] == '0' else 1\n\n\n  for i in range(2, len(dp)):\n\n   if s[i-1] != '0':\n    dp[i] += dp[i-1]\n\n   two_digit = int(s[i-2 : i])\n   if two_digit >= 10 and two_digit <= 26:\n    dp[i] += dp[i-2]\n  return dp[len(s)]\n\nt = int(input())\n\nwhile(t):\n t-=1\n s = input()\n print(numDec(s)%1000000007)
import sys\ntest_cases = int(input())\nfor i in range(0,test_cases):\n count = input().split()\n #print count\n count_r = int(count[0])\n count_g = int(count[1])\n count_b = int(count[2])\n k = int(input())\n if k is 1:\n  total = 1\n else:   \n  total = 1\n  if count_r < k:\n   total = total + count_r\n  else:\n   total = total + (k-1)\n  if count_g < k:\n   total = total + count_g\n  else:\n   total = total + (k-1) \n  if count_b < k:\n   total = total + count_b\n  else:\n   total = total + (k-1)\n \n print(total)
from bisect import bisect\nn = 32000\ndef primeSeive(n):\n    prime = [True for i in range(n + 1)]\n    primes = []\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = False\n    prime[1] = False\n    for p in range(n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes\narr = primeSeive(n)\nfin = []\nfor i in arr:\n    fin.append(pow(i,4))\nfor _ in range(int(input())):\n    n = int(input())\n    print(bisect(fin,n))\n
# cook your dish here\nfrom sys import stdin, stdout\n\nfor _ in range(int(stdin.readline())):\n n, q = list(map(int, stdin.readline().split()))\n arr = list(map(int, stdin.readline().split()))[:n]\n od = ev = 0\n for i in arr:\n  if bin(i).count('1')%2==0:\n   ev += 1\n  else:\n   od += 1\n for _ in range(q):\n  p = int(stdin.readline())\n  if bin(p).count('1')%2==0:\n   stdout.write(str(ev) + " " + str(od) + "\n")\n  else:\n   stdout.write(str(od) + " " + str(ev) + "\n")\n\n
# cook your dish here\nt = int(input())\nfor _ in range(t):\n m,n = [int(d) for d in input().split()]\n\n if m == 1:\n  arr = []\n  if n%4 == 0:\n   print(2)\n   arr = [[1,1,2,2]*(n//4)]\n  elif n%4 == 1:\n   if n == 1:\n    print(1)\n    arr = [[1]]\n   else:\n    print(2)\n    arr = [[1,1,2,2]*(n//4) + [1]]\n  elif n%4 == 2:\n   if n == 2:\n    print(1)\n    arr = [[1,1]]\n   else:\n    print(2)\n    arr = [[1,1,2,2]*(n//4) + [1,1]]\n  elif n%4 == 3:\n   print(2)\n   arr = [[1,1,2,2]*(n//4) + [1,1,2]]\n\n elif m == 2:\n  if n%3 == 0:\n   print(3)\n   a1 = [1,2,3]*(n//3)\n   arr = [a1,a1]\n\n  elif n%3 == 1:\n   if n == 1:\n    print(1)\n    arr = [[1],[1]]\n   else:\n    print(3)\n    a1 = [1,2,3]*(n//3) + [1]\n    arr = [a1,a1]\n\n  elif n%3 == 2:\n   if n == 2:\n    print(2)\n    arr = [[1,2],[1,2]]\n   else:\n    print(3)\n    a1 = [1,2,3]*(n//3) + [1,2]\n    arr = [a1,a1]\n\n elif m == 3:\n  if n == 1:\n   print(2)\n   arr = [[1],[1],[2]]\n  elif n == 2:\n   print(3)\n   arr = [[1,1],[2,2],[3,3]]\n  elif n == 3:\n   print(4)\n   arr = [[1,3,4],[4,2,1],[4,2,1]]\n  elif n == 4:\n   print(4)\n   arr = [[1,3,4,2],[4,2,1,3],[4,2,1,3]]\n  else:\n   if n%4 == 0:\n    print(4)\n    a1 = [1,3,4,2]*(n//4)\n    a2 = [4,2,1,3]*(n//4)\n    arr = [a1,a2,a2]\n \n   elif n%4 == 1:\n    print(4)\n    a1 = [1,3,4,2]*(n//4) + [1]\n    a2 = [4,2,1,3]*(n//4) + [4]\n    arr = [a1,a2,a2]\n\n   elif n%4 == 2:\n    print(4)\n    a1 = [1,3,4,2]*(n//4) + [1,3]\n    a2 = [4,2,1,3]*(n//4) + [4,2]\n    arr = [a1,a2,a2]\n\n   elif n%4 == 3:\n    print(4)\n    a1 = [1,3,4,2]*(n//4) + [1,3,4]\n    a2 = [4,2,1,3]*(n//4) + [4,2,1]\n    arr = [a1,a2,a2]\n\n else:\n  if n == 1:\n   print(2)\n   a1 = [1,3,4,2]*(n//4) + [1]\n   a2 = [4,2,1,3]*(n//4) + [2]\n   arr = []\n   i = 0\n   j = 0\n   c = 0\n   c1 = 0\n   for i in range(m):\n    if j == 0 and c < 3:\n     arr.append(a1)\n     c = c + 1\n     if c == 2:\n      j = 1\n      c = 0\n    else:\n     arr.append(a2)\n     c1 = c1 + 1\n     if c1 == 2:\n      j = 0\n      c1 = 0\n  \n  elif n == 2:\n   print(3)\n   arr = []\n   a1 = [1,1]\n   a2 = [2,2]\n   a3 = [3,3]\n\n   if m%3 == 1:\n    arr = [a1,a2,a3]*(m//3) + [a1]\n   elif m%3 == 2:\n    arr = [a1,a2,a3]*(m//3) + [a1,a2]\n   elif m%3 == 0:\n    arr = [a1,a2,a3]*(m//3)\n\n  else:\n   print(4)\n   if n%4 == 0:\n    a1 = [1,3,4,2]*(n//4)\n    a2 = [4,2,1,3]*(n//4)\n    arr = []\n    i = 0\n    j = 0\n    c = 0\n    c1 = 0\n    for i in range(m):\n     if j == 0 and c < 3:\n      arr.append(a1)\n      c = c + 1\n      if c == 2:\n       j = 1\n       c = 0\n     else:\n      arr.append(a2)\n      c1 = c1 + 1\n      if c1 == 2:\n       j = 0\n       c1 = 0\n\n   elif n%4 == 1:\n    a1 = [1,3,4,2]*(n//4) + [1]\n    a2 = [4,2,1,3]*(n//4) + [4]\n    arr = []\n    i = 0\n    j = 0\n    c = 0\n    c1 = 0\n    for i in range(m):\n     if j == 0 and c < 3:\n      arr.append(a1)\n      c = c + 1\n      if c == 2:\n       j = 1\n       c = 0\n     else:\n      arr.append(a2)\n      c1 = c1 + 1\n      if c1 == 2:\n       j = 0\n       c1 = 0\n\n   elif n%4 == 2:\n\n    a1 = [1,3,4,2]*(n//4) + [1,3]\n    a2 = [4,2,1,3]*(n//4) + [4,2]\n    arr = []\n    i = 0\n    j = 0\n    c = 0\n    c1 = 0\n    for i in range(m):\n     if j == 0 and c < 3:\n      arr.append(a1)\n      c = c + 1\n      if c == 2:\n       j = 1\n       c = 0\n     else:\n      arr.append(a2)\n      c1 = c1 + 1\n      if c1 == 2:\n       j = 0\n       c1 = 0\n\n   elif n%4 == 3:\n\n    a1 = [1,3,4,2]*(n//4) + [1,3,4]\n    a2 = [4,2,1,3]*(n//4) + [4,2,1]\n    arr = []\n    i = 0\n    j = 0\n    c = 0\n    c1 = 0\n    for i in range(m):\n     if j == 0 and c < 3:\n      arr.append(a1)\n      c = c + 1\n      if c == 2:\n       j = 1\n       c = 0\n     else:\n      arr.append(a2)\n      c1 = c1 + 1\n      if c1 == 2:\n       j = 0\n       c1 = 0\n\n\n\n for i in range(m):\n  for j in range(n):\n   print(arr[i][j],end = " ")\n  print()\n\n\n\n\n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n
mod = 10 ** 9 + 7\nfrom collections import Counter\nchoice = {'1' : ['11', '21', '22'], '2' : ['11', '12', '21']}\ndef solve(a,b):\n n = len(a)\n if n == 1:\n  return 2\n dp = Counter([('11', '11')])\n for i in range(n-1):\n  new = Counter()\n  for x,y in (a[i], b[i]), (b[i], a[i]):\n   for p in choice[x]:\n    for q in choice[y]:\n     m = p[-1] + x \n     n = q[-1] + y\n     new[m,n] += dp[p,q]\n     new[m,n] %= mod\n  dp = new\n ans = 0 \n for i in '11', '21', :\n  for j in '11', '21':\n   ans += dp[i,j]\n return (ans * 2) % mod\n\n \nt = int(input())\nfor _ in range(t):\n a = input()\n b = input()\n print(solve(a,b))
for t in range(int(input())):\r\n    n=int(input())\r\n    print(bin(n).count("1")) 
nCr = [[0 for x in range(1001)] for x in range(1001)]\n \nfor i in range (0,1001):\n nCr[i][0]=1\n nCr[i][i]=1\nfor i in range (1,1001):\n for j in range (1,1001):\n  if i!=j:\n   nCr[i][j] = nCr[i-1][j] + nCr[i-1][j-1]\n \nt=eval(input())\nfor rajarshisarkar in range(0,t):\n s,n,m,k=list(map(int,input().split(' ')))\n foo=0.000000\n tot = float(nCr[s-1][n-1])\n if s==n:\n   print("1.000000\n")\n   continue\n if k>n:\n   print("0.000000\n")\n   continue\n if m>n:\n  wola=n\n else:\n  wola=m\n for i in range(k,wola):\n  foo+= ((nCr[m-1][i])*(nCr[s-m][n-i-1]))\n print("%f\n"% (float(foo/tot)))
# cook your dish here\nimport math\ndef swap(a,b):\n return b,a\n\nt = int(input())\nwhile(t!=0):\n z = list(map(int,input().strip().split(" ")))\n x=z[0]\n r=z[1]\n a=z[2]\n b=z[3]\n #p = math.pi\n peri = 2*r\n tp = x*peri\n \n if(a<b):\n  a,b=swap(a,b)\n t1 = tp/a\n d2 = t1* b\n dd = abs(tp-d2)\n \n if(dd%peri==0):\n  print(int(dd//peri)-1)\n else:\n  n = int(dd//peri)\n  print(n)\n t-=1
from decimal import Decimal\r\n\r\nT = int(input())\r\nfor _ in range(T):\r\n    N = int(input())\r\n    data = dict() \r\n    for __ in  range(N):\r\n        ci, pi = input().split() \r\n        data[ci] = pi\r\n    S = list(input())\r\n    for i in range(len(S)):\r\n        if S[i] in data.keys():\r\n            S[i] = data[S[i]] \r\n    ###\r\n    S = "".join(S)\r\n    if '.' in S:\r\n        S = S.strip('0').rstrip('.')\r\n    else:\r\n        S = S.lstrip('0')\r\n    print(S or '0')
\r\ndef issafe(r,c,r1,c1,graph):\r\n    if (graph[r][c] and graph[r1][c1]):\r\n        return True\r\n    return False\r\n    \r\n\r\nt=int(input())\r\nfor mmmmmm in range(t):\r\n    n,m=map(int,input().split())\r\n    x,y=map(int,input().split())\r\n    \r\n    graph=[[False]*(m+2) for _ in range(n+2)]\r\n\r\n    cost_graph=[[[-1,-1,-1] for __ in range(m)] for _ in range(n)]\r\n    \r\n    for i in range(n):\r\n        str1=input()\r\n        for j,val in enumerate(str1):\r\n            graph[i][j]=(val=='1')\r\n    \r\n    x=x-1\r\n    y=y-1\r\n    \r\n    set1=set()\r\n    set1.add((x,y,0))\r\n    cost_graph[x][y][0]=0\r\n    while(set1):\r\n       \r\n        set2=set()\r\n        \r\n        while(set1):\r\n            r,c,p=set1.pop()\r\n            \r\n            new_cost=cost_graph[r][c][p]+1\r\n            \r\n            if(p==0):\r\n                if issafe(r,c+1,r,c+2,graph):\r\n                    if cost_graph[r][c+1][1]==-1 or cost_graph[r][c+1][1]>new_cost:\r\n                        cost_graph[r][c+1][1]=new_cost\r\n                        set2.add((r,c+1,1))\r\n                        \r\n                if issafe(r+1,c,r+2,c,graph):\r\n                    if cost_graph[r+1][c][2]==-1 or cost_graph[r+1][c][2]>new_cost:\r\n                        cost_graph[r+1][c][2]=new_cost\r\n                        set2.add((r+1,c,2))\r\n                        \r\n                if issafe(r,c-2,r,c-1,graph):\r\n                    if cost_graph[r][c-2][1]==-1 or cost_graph[r][c-2][1]>new_cost:\r\n                        cost_graph[r][c-2][1]=new_cost\r\n                        set2.add((r,c-2,1))\r\n                        \r\n                if issafe(r-2,c,r-1,c,graph):\r\n                    if cost_graph[r-2][c][2]==-1 or cost_graph[r-2][c][2]>new_cost:\r\n                        cost_graph[r-2][c][2]=new_cost\r\n                        set2.add((r-2,c,2))\r\n                        \r\n            elif(p==1):\r\n                if issafe(r,c+2,r,c+2,graph):\r\n                    if cost_graph[r][c+2][0]==-1 or cost_graph[r][c+2][0]>new_cost:\r\n                        cost_graph[r][c+2][0]=new_cost\r\n                        set2.add((r,c+2,0))\r\n                        \r\n                if issafe(r+1,c,r+1,c+1,graph):\r\n                    if cost_graph[r+1][c][1]==-1 or cost_graph[r+1][c][1]>new_cost:\r\n                        cost_graph[r+1][c][1]=new_cost\r\n                        set2.add((r+1,c,1))\r\n                        \r\n                if issafe(r,c-1,r,c-1,graph):\r\n                    if cost_graph[r][c-1][0]==-1 or cost_graph[r][c-1][0]>new_cost:\r\n                        cost_graph[r][c-1][0]=new_cost\r\n                        set2.add((r,c-1,0))\r\n                        \r\n                if issafe(r-1,c,r-1,c+1,graph):\r\n                    if cost_graph[r-1][c][1]==-1 or cost_graph[r-1][c][1]>new_cost:\r\n                        cost_graph[r-1][c][1]=new_cost\r\n                        set2.add((r-1,c,1))\r\n                        \r\n            elif(p==2):\r\n                if issafe(r,c+1,r+1,c+1,graph):\r\n                    if cost_graph[r][c+1][2]==-1 or cost_graph[r][c+1][2]>new_cost:\r\n                        cost_graph[r][c+1][2]=new_cost\r\n                        set2.add((r,c+1,2))\r\n                        \r\n                if issafe(r+2,c,r+2,c,graph):\r\n                    if cost_graph[r+2][c][0]==-1 or cost_graph[r+2][c][0]>new_cost:\r\n                        cost_graph[r+2][c][0]=new_cost\r\n                        set2.add((r+2,c,0))\r\n                        \r\n                if issafe(r,c-1,r+1,c-1,graph):\r\n                    if cost_graph[r][c-1][2]==-1 or cost_graph[r][c-1][2]>new_cost:\r\n                        cost_graph[r][c-1][2]=new_cost\r\n                        set2.add((r,c-1,2))\r\n                        \r\n                if issafe(r-1,c,r-1,c,graph):\r\n                    if cost_graph[r-1][c][0]==-1 or cost_graph[r-1][c][0]>new_cost:\r\n                        cost_graph[r-1][c][0]=new_cost\r\n                        set2.add((r-1,c,0))\r\n        set1=set2\r\n        \r\n    for _ in range(n):\r\n        for __ in range(m):\r\n            print(cost_graph[_][__][0],end=" ")\r\n        print()\r\n        \r\n                        \r\n            \r\n                        \r\n                        \r\n        \r\n        \r\n        \r\n        \r\n    \r\n    \r\n        \r\n    \r\n    \r\n    
def matrix(L,row,col,c):\n d={}\n dp=[]\n for i in range(row+1):\n  temp=[]\n  for i in range(col+1):\n   temp.append([])\n  dp.append(temp)\n\n for i in range(row+1):\n  dp[i][0]=0\n for i in range(col+1):\n  dp[0][i]=0\n for i in range(1,row+1):\n  for j in range(1,col+1):\n   if L[i-1][j-1]==c:\n    dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1\n   else:\n    dp[i][j]=0\n   d[dp[i][j]]=d.get(dp[i][j],0)+1\n##    for i in xrange(row+1):\n##        for j in xrange(col+1):\n##            print dp[i][j],\n##        print\n return d\n\nfrom sys import stdin\nn,m,q=list(map(int,stdin.readline().split()))\nL=[]\nfor i in range(n):\n L.append(stdin.readline().strip())\nmale=matrix(L,n,m,'M')\nfemale=matrix(L,n,m,'F')\nfor i in range(q):\n query=stdin.readline().split()\n if query[1]=='F':\n  if female.get(int(query[0]),0)==0:\n   print('no')\n  else:\n   print('yes')\n else:\n  if male.get(int(query[0]),0)==0:\n   print('no')\n  else:\n   print('yes')\n
for _ in range(int(input())):\n s=str(input())\n n=len(s)\n k=s[::-1]\n a,b="",""\n for i in range(n):\n  if s[i]!=k[i]:\n   a+=s[i+1:]\n   b+=k[i+1:]\n   break\n  else:\n   a+=s[i]\n   b+=k[i]\n #print(a,b)\n if a==a[::-1] or b==b[::-1]:\n  print("YES")\n else:\n  print("NO")\n
s,n,s1,lis,new1=[],[],[],[],[]\nimport itertools\nq = int(input())\ns.append(input().split(' '))\ns1 = list([list(map(int,x)) for x in s])\nsum1 = sum(s1[0])\nif len(s1[0])%2!=0 :\n z = (len(s1[0])+1)//2\n n = list(itertools.combinations(s1[0],z))\n for j in range(len(n)) :\n   x = sum(n[j])\n   if x==sum1//2 :\n    lis = n[j]\n    break\n new1 = list(lis)\n sum2 = sum(new1)\n for j in range(len(lis)) :\n    y = lis[j]\n    s1[0].remove(y)\n sum3=sum(s1[0])\n if sum3>sum2 :\n  print(' '.join(map(str,s1[0])))\n  print(' '.join(map(str,new1)))\n else :\n  print(' '.join(map(str,new1)))\n  print(' '.join(map(str,s1[0])))\nelse :\n z = len(s1[0])//2\n n = list(itertools.combinations(s1[0],z))\n for j in range(len(n)) :\n   x = sum(n[j])\n   if x==sum1//2 :\n    lis = n[j]\n    break\n   #print lis,len(lis)\n new1 = list(lis)\n sum2 = sum(new1)\n for j in range(len(lis)) :\n    y = lis[j]\n    s1[0].remove(y)\n sum3 = sum(s1[0])\n if sum3>sum2  :\n  print(' '.join(map(str,s1[0])))\n  print(' '.join(map(str,new1)))\n else :\n  print(' '.join(map(str,new1)))\n  print(' '.join(map(str,s1[0])))
for _ in range(int(input())):\r\n    n = int(input())\r\n    ar = list(map(int,input().split()))\r\n    d = {}\r\n    for ele in ar:\r\n        if ele in d:\r\n            d[ele] += 1\r\n        else:\r\n            d[ele] = 1\r\n    m = 99999\r\n    count = 0\r\n    for ele in d:\r\n        count+=1\r\n        if m>d[ele]:\r\n            m = d[ele]\r\n    if count!=8:\r\n        print(0)\r\n    else:\r\n        print(m)\r\n
# cook your dish here\n# cook your dish here\nfor _ in range(int(input())):\n n=int(input())\n l=list(map(int, input().split()))\n l.insert(0, 0)\n l1=[0]*(n+1)\n l1[1]=l[1]\n for i in range(2, n+1):\n  l1[i]=max(l1[i-1]+l[i]*i, l1[i-2]+l[i-1]*i+l[i]*(i-1))\n  \n print(l1[-1]) 
\n\n\nt = int(input())\n\ndef gcd (a, b):\n if (b == 0): return a\n return gcd (b, a % b)\n\ndp = {}\n\ndef solve (p, k, g, s, m, x, y, n):\n if ((p, k, g) in dp): return dp[(p, k, g)];\n \n ans = 0\n\n if (p == n): \n  if k >= x and k <= y:\n   ans = g\n  else:\n   ans = 0 \n else:   \n  for i in range (p, n):\n   \n   if (i - p + 1 > m): break\n   \n   temp = solve (i + 1, k + 1, gcd(g, int(s[p:i + 1])), s, m, x, y, n)\n   if (temp > ans):\n    ans = temp\n    \n dp[(p, k, g)] = ans\n return ans\n \n\nwhile t != 0:\n dp = {}\n t -= 1\n n = int(input())\n s = input()\n m, x, y = list(map (int, input().split()))\n x += 1\n y += 1\n \n print(solve (0, 0, 0, s, m, x, y, n))\n \n
# cook your dish here\n# cook your dish here\nn=0;m=0;\nA=[];B=[];\nanscount=0;k=0;\n\ndef generate(n,m,l):\n nonlocal anscount\n if(len(l)==n+m):\n  X=l\n  i,j = 0,0\n  C=[0 for t in range(n+m)]\n  while((i+j)<(n+m)):\n   if(X[i+j] == 0):\n    C[i+j] = A[i]\n    i = i+1\n   else:\n    C[i+j] = B[j]\n    j = j+1\n  ans = len(C)\n  for i in range(1,len(C)):\n   if(C[i]==C[i-1]):\n    ans-=1\n  if(ans==k):\n   anscount+=1\n else:\n  if(l.count(1)<m):\n   generate(n,m,l+[1])\n   if(l.count(0)<n):\n    generate(n,m,l+[0])\n  else:\n   if(l.count(0)<n):\n    generate(n,m,l+[0])\nfor _ in range(int(input())):\n anscount=0\n n,m,k=list(map(int,input().split()))\n A=list(map(int,input().split()))\n B=list(map(int,input().split()))\n generate(n,m,[])\n print(anscount)\n
def getsum(N):\n	if N==1:\n		return 9\n	if N==2:\n		return 99\n	s = ""\n	for i in range(0,N):\n		s = s+'5'\n	s = int(s)\n	if N%2==0:\n		s = s*pow(9,N//2-1)\n	else:\n		s = s*pow(9,N//2)\n	return s%(pow(10,9)+7)\n\ndef main():\n	t = int(input())\n	for _ in range(0,t):\n		N = int(input())\n		result = getsum(N)\n		print(result)\ndef __starting_point():\n	main()\n\n__starting_point()
import sys\nT = int(sys.stdin.readline().strip())\nfor t in range(T):\n sys.stdin.readline().strip()\n st = '0'+sys.stdin.readline().strip()+'0'\n res = 0\n for i in range(1,len(st)-1):\n  if st[i] == st[i-1] == st[i+1] == '0':\n   res+=1\n print(res)\n
# cook your dish here\nt=int(input())\nfor i in range(t):\n    n=int(input())\n    nums=list(map(int,input().split()))\n    k=int(input())\n    an=nums[k-1]\n    cn=0\n    for i in range(n):\n        if(nums[i]<an):\n            cn+=1\n\n    print(cn+1)\n
# cook your dish here\nn,a=map(int,input().split())\nfor i in range(a):\n if(n%10==0):\n  n=n//10\n else:\n  n=n-1\n  \nprint(n)
t=int(input())\ncount=[]\n\nfor i in range(t) :\n s = input()\n a,b,c,n = s.split()\n n=int(n)\n d = int(a+b*n+c,2)\n count.append(0)\n while(d>0) :\n  d=(d&(d+1))-1\n  count[i]+=1\n\n\nfor i in range(t) :\n print(count[i])\n
t=int(input())\nfor i in range(t):\n n,m=list(map(int,input().split()))\n l=[0]+list(map(int,input().split()))\n s=0\n c=1\n m1=[]\n for i in range(n):\n  d,f,b=list(map(int,input().split()))\n  if(l[d]>0):\n   m1.append(d)\n   s+=f\n   l[d]-=1\n  else:\n   m1.append(0)\n   s+=b\n for i in range(n):\n  if(m1[i]==0):\n   for j in range(c,m+1):\n    if(l[j]>0):\n     m1[i]=j\n     l[j]-=1\n     c=j\n     break\n print(s)\n print(*m1)\n
# cook your dish here\nfrom sys import stdin,stdout\na,b=list(map(int,stdin.readline().split()))\nleft=[]\ntop=[]\nfor i in range(a):\n c,d=list(map(int,stdin.readline().split()))\n left.append(c)\n top.append(d)\nleft.sort()\ntop.sort()\nfrom bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nrow=0\ncol=0\ntotal=0\ncons_x=0\ncons_y=0\nfor i in range(len(left)):\n cons_x+=(abs(left[i]))\n cons_y+=(abs(top[i]))\ntotal=cons_x+cons_y\ncc=stdin.readline().rstrip()\nfor i in cc:\n if i=="R":\n  kk=br(left,col)\n  cons_x=(cons_x+kk-(a-kk))\n  col+=1\n if i=="L":\n  kk=bl(left,col)\n  cons_x=(cons_x+(a-kk)-kk)\n  col-=1\n if i=="U":\n  kk=br(top,row)\n  cons_y=(cons_y+kk-(a-kk))\n  row+=1\n if i=="D":\n  kk=bl(top,row)\n  cons_y=(cons_y+(a-kk)-kk)\n  row-=1\n stdout.write(str(cons_x+cons_y))\n stdout.write("\n")\n  \n\n
# cook your dish here\nimport heapq as hq\nfrom math import floor\nfor _ in range(int(input())):\n n,a,b,x,y,z=map(int,input().split())\n arr=[-int(i) for i in input().split()]\n days=((z-b-1)//y)\n ans=0\n hq.heapify(arr)\n curr=a+days*x\n while curr<z :\n  u=hq.heappop(arr)\n  u=-u\n  if u==0 :\n   break\n  else:\n   curr+=u\n   ans+=1\n   hq.heappush(arr,-(u//2))\n if curr>=z:\n  print(ans)\n else:\n  print("RIP")
# cook your dish here\nt=int(input())\nwhile(t>0):\n n=int(input())\n b=[int(x) for x in input().split()]\n p=[float(x) for x in input().split()]\n s=[0]*(10)\n yet=2\n mx=0\n for i in range(n):\n  st=bin(b[i])\n  rng=len(st)-2\n  if(rng+2>yet):\n   for ml in range(rng+2-yet):\n    s.append(0)\n  if(rng>mx):\n   mx=rng\n  for k in range(2,rng+2):\n   if(st[k]=='1'):\n    s[rng-k+1]=(s[rng-k+1]*(1-p[i]))+((1-s[rng-k+1])*(p[i]))\n   # else:\n   #     s[k-2]=(s[k-2]*1)\n # print(s)\n # print(mx)\n mult=1\n ans=0\n for i in range(0,mx):\n  ans+=mult*s[i]\n  mult=mult*2\n print("%.16f" % ans)\n t-=1
# cook your dish here\nfor _ in range(int(input())):\n    n,k = [int(v) for v in input().split()]\n    ans = (n//2)*(k+2)\n    if n%2 == 0:\n        ans = ans\n    else:\n        ans += 1 + 2*k\n    \n    print(ans)
m=1000000007\r\ndef gcd(a, b): \r\n    if (a == 0): \r\n        return b \r\n    return gcd(b % a, a)\r\ndef modexp(x, n): \r\n    if (n == 0) : \r\n        return 1\r\n    elif (n % 2 == 0) : \r\n        return modexp((x * x) % m, n // 2) \r\n    else : \r\n        return (x * modexp((x * x) % m,  \r\n                           (n - 1) / 2) % m)\r\ndef getFractionModulo(a, b): \r\n    c = gcd(a, b)\r\n    a = a // c \r\n    b = b // c \r\n    d = modexp(b, m - 2) \r\n    ans = ((a % m) * (d % m)) % m\r\n    return ans\r\nt=int(input())\r\nfor i in range(t):\r\n    n=int(input())\r\n    n=n-1\r\n    print(getFractionModulo(n-1,n+1))\r\n
t = int(input())\r\nfor i in range(t):\r\n    n = int(input())\r\n    A = []\r\n    for i in range(0, n):\r\n        A.append([int(i) for i in input().split()])\r\n    ones = sum([sum(i) for i in A])\r\n    compare = n\r\n    ans = 0\r\n    for i in range(0, n):\r\n        if ones <= compare:\r\n            ans = i\r\n            break\r\n        compare += 2*(n-1-i)\r\n    print(ans)
\nt = int(input())\n\nfor i in range(0,t):\n	a = input()\n	b = input()\n	\n	agts=bgts=afour=bfour=aseven=bseven=altf=bltf=afts=bfts=0;\n	\n	for j in a:\n		if j >= '7':\n			if j > '7':\n				agts += 1\n			else:\n				aseven += 1\n		elif j >= '4':\n			if j > '4':\n				afts += 1\n			else:\n				afour += 1\n		else:\n			altf += 1\n	\n	for j in b:\n		if j >= '7':\n			if j > '7':\n				bgts += 1\n			else:\n				bseven += 1\n		elif j >= '4':\n			if j > '4':\n				bfts += 1\n			else:\n				bfour += 1\n		else:\n			bltf += 1\n		\n	nseven = 0\n	nfour = 0\n	\n	if aseven > bfts:\n		aseven -= bfts;\n		nseven += bfts;\n		bfts = 0;\n	else:\n		bfts -= aseven;\n		nseven += aseven;\n		aseven = 0;\n	\n	if bseven > afts:\n		bseven -= afts;\n		nseven += afts;\n		afts = 0;\n	else:\n		afts -= bseven;\n		nseven += bseven;\n		bseven = 0;\n	\n	if aseven > bltf:\n		aseven -= bltf;\n		nseven += bltf;\n		bltf = 0;\n	else:\n		bltf -= aseven;\n		nseven += aseven;\n		aseven = 0;\n	\n	if bseven > altf:\n		bseven -= altf;\n		nseven += altf;\n		altf = 0;\n	else:\n		altf -= bseven;\n		nseven += bseven;\n		bseven = 0;\n	\n	if aseven > bfour:\n		aseven -= bfour;\n		nseven += bfour;\n		bfour = 0;\n	else:\n		bfour -= aseven;\n		nseven += aseven;\n		aseven = 0;\n	\n	if bseven > afour:\n		bseven -= afour;\n		nseven += afour;\n		afour = 0;\n	else:\n		afour -= bseven;\n		nseven += bseven;\n		bseven = 0;\n	\n	nseven += min(aseven,bseven)\n	\n	if afour > bltf:\n		afour -= bltf;\n		nfour += bltf;\n		bltf = 0\n	else:\n		bltf -= afour;\n		nfour += afour;\n		afour = 0;\n	\n	if bfour > altf:\n		bfour -= altf;\n		nfour += altf;\n		altf = 0\n	else:\n		altf -= bfour;\n		nfour += bfour;\n		bfour = 0;\n	\n	nfour += min(afour,bfour)\n	\n	print('7'*nseven + '4'*nfour)
# cook your dish here\n# cook your dish here\nimport numpy as np\nn, s, q = [int(j) for j in input().split()]\nedges = [int(j)-1 for j in input().split()]\ncosts = [int(j) for j in input().split()]\nspecial = [int(j)-1 for j in input().split()]\nqueries = [[0] * 3 for _ in range(q)]\nfor i in range(q):\n   queries[i] = [int(j)-1 for j in input().split()]\n\nedge_set = [[] for _ in range(n)]\nfor i in range(n-1):\n   edge_set[i+1].append(edges[i])\n   edge_set[edges[i]].append(i+1)\n\nstored = np.zeros((s,n,1001),dtype=bool)\nvisited = [[] for _ in range(s)]\nfor i in range(s):\n   s_vertex = special[i]\n   s_cost = costs[s_vertex]\n   s_visited = visited[i]\n   s_visited.append(s_vertex)\n   s_stored = stored[i]\n   s_stored[s_vertex][0] = True\n   s_stored[s_vertex][s_cost] = True\n   for edge in edge_set[s_vertex]:\n      s_visited.append(edge)\n      s_stored[edge] = np.array(s_stored[s_vertex])\n   for j in range(1,n):\n      vertex = s_visited[j]\n      cost = costs[vertex]\n      s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001-cost],s_stored[vertex][cost:1001])\n      for edge in edge_set[vertex]:\n         if edge not in s_visited:\n            s_visited.append(edge)\n            s_stored[edge] = np.array(s_stored[vertex])\n\nfor i in range(q):\n   first, second, max_cost = queries[i]\n   bool_array = np.zeros(max_cost+2,dtype=bool)\n   for j in range(s):\n      bool_array = np.logical_or(bool_array,np.logical_and(stored[j][first][:max_cost+2],stored[j][second][:max_cost+2]))\n   for j in range(max_cost+1,-1,-1):\n      if bool_array[j]:\n         print(2 * j)\n         break
import copy\r\nn=int(input())\r\na=[int(x) for x in input().split()]\r\nb=[int(x) for x in input().split()]\r\nc=[]\r\nd=[]\r\nlcs=[]\r\ndef lcsfn(a,c,corda,cordb):\r\n	for i in range(n+1):\r\n		d.append([0]*(n+1))\r\n		lcs.append([0]*(n+1))\r\n	for i in range(1,n+1):\r\n		for j in range(1,n+1):\r\n			if a[i-1]==c[j-1]:\r\n				lcs[i][j]=lcs[i-1][j-1]+1\r\n				d[i][j]='d'\r\n			elif lcs[i-1][j]>lcs[i][j-1]:\r\n				lcs[i][j]=lcs[i-1][j]\r\n				d[i][j]='u'\r\n			else:\r\n				lcs[i][j]=lcs[i][j-1]\r\n				d[i][j]='l'\r\n	i=n\r\n	j=n\r\n	cost=0\r\n	while i>=1 and j>=1:\r\n		if d[i][j]=='d':\r\n			corda.append(a[i-1])\r\n			cordb.append(b[j-1])\r\n			i-=1\r\n			j-=1\r\n			cost+=1\r\n		elif d[i][j]=='l':\r\n			j-=1\r\n		elif d[i][j]=='u':\r\n			i-=1\r\n	return cost\r\n\r\n\r\nma=-10**9\r\np1=[]\r\np2=[]\r\nfor i in range(-1000,1001):\r\n	c=[]\r\n	corda=[]\r\n	cordb=[]\r\n	for j in range(n):\r\n		c.append(b[j]+i)\r\n	p=lcsfn(a,c,corda,cordb)\r\n	if ma<p:\r\n		ma=p\r\n		p1=copy.deepcopy(corda)\r\n		p1=p1[::-1]\r\n		p2=copy.deepcopy(cordb)\r\n		p2=p2[::-1]\r\nprint(ma)\r\nprint(*p1)\r\nprint(*p2)\r\n\r\n
# cook your dish here\nfor _ in range(int(input())):\n    g=input()\n    h=g[::-1]\n    if h==g :\n        print(1)\n    else:\n        print(2)\n    
import math\ndef findnumber(l,n):\n    l.sort()\n    x = l[0] * l[-1]\n    vec = []\n    i = 2\n    while (i*i)<=x:\n        if x%i==0:\n            vec.append(i)\n            if x//i !=i:\n                vec.append(x//i)\n        i = i + 1\n    vec.sort()    \n    if len(vec)!=n:\n        return -1\n    else:\n        j = 0\n        for it in range(n):\n            if(l[j] != vec[it]):\n                return -1\n            else:\n                j += 1\n    return x\ndef __starting_point():\n    t = int(input())\n    while t:\n        n = int(input())\n        arr = list(map(int,input().split()))\n        n = len(arr)\n        print(findnumber(arr,n))\n        print()\n        t=t-1\n__starting_point()
# cook your dish here\ndef prime_factors(n):\n i = 2\n factors =set()\n while i * i <= n:\n  if n % i:\n   i += 1\n  else:\n   n //= i\n   factors.add(i)\n if n > 1:\n  factors.add(n)\n return factors\nfor _ in range(int(input())):\n n=int(input())\n a=list(map(int,input().split()))\n ans=0\n s=[]\n for i in range(n):\n  s.append(sum(prime_factors(a[i])))\n for i in range(n):\n  for j in range(n):\n   if i!=j and a[j]%a[i]==0 and s[j]%s[i]==0:\n    ans=ans+1\n print(ans)
import math\n\ndp = []\ndp.append(0)\nfor i in range(1,1000005):\n	dp.append(math.log(i) + dp[i-1])\n\nt = int(input())\nfor i in range(t):\n	n,m,p,k = input().split()\n	n = int(n)\n	m = int(m)\n	p = int(p)\n	k = int(k)\n\n	if p==0 or (n%2==0 and m%2==0):\n		ans = 1.0\n		print(ans)\n	elif n%2==1 and m%2==1:\n		ans=0.0\n		print(ans*100)\n	else:\n		P = 0\n		kln2 = k*math.log(2)\n		for i in range(p, k+1):\n			lnPi = dp[k] - dp[i] - dp[k-i] - kln2\n			Pi = pow(math.e, lnPi)\n			P += Pi\n		print(P)\n\n
# cook your dish here\nt=int(input())\nfor i in range(t):\n n=int(input())\n a=list(map(int,input().split()))\n print(min(a))
for _ in range(int(input())):\n n, k = map(int, input().split())\n a = list(map(int, input().split()))\n b = list(map(int, input().split()))\n\n a = [-1] + a[::-1]\n mx = a.index(max(a))\n dp = [0] * (n + 1)\n for i in range(1, n + 1):\n  for x in b:\n   if i - x < 0: continue\n   if i - x < mx <= i:\n    dp[i] = 1\n   else:\n    dp[i] |= not dp[i - x]\n\n print('Chef' if dp[-1] else 'Garry')
# cook your dish here\nfor _ in range(int(input())):\n    a=int(input())\n    print(a/2+2)
for i in range(int(input())):\n n,k=map(int,input().split())\n m=[]\n for j in range(n):\n  l=list(input())\n  m.append(l)\n a=0\n for k in range(k):\n  b=0\n  for p in range(n):\n   if m[p][k]=='1':\n    b+=1\n  if b>1:\n   a+=((b*(b-1))//2)\n print(a)
for _ in range(int(input())):\r\n	num=int(input())\r\n	arr=list(map(int,input().split()))\r\n	dp=[0]*num\r\n	dp[0]=1\r\n	ans=1\r\n	j=0\r\n	for i in range(1,num):\r\n		j=i+1\r\n		count=1\r\n		dp[i]=dp[i-1]%1000000007\r\n		if i-2>=0 and arr[i-2]==2:\r\n			dp[i]+=dp[i-2]%1000000007\r\n			if i-3>=0 and arr[i-3]==2:\r\n				dp[i]+=dp[i-3]\r\n		ans+=dp[i]%1000000007\r\n		if arr[i-1]==2 and i<num-1:\r\n			if i>=j or j==0:\r\n				j=i+1\r\n			while j<num and arr[j]==2:\r\n			   	j+=1\r\n			count=j-i\r\n			while j<len(arr) and arr[j]==2:\r\n				j+=1\r\n				count+=1\r\n			if j==num:\r\n				ans+=dp[i-1]*(count-1)%1000000007\r\n			elif count%2!=0:\r\n				if j<num-1 and arr[j+1]==2:\r\n					ans+=dp[i-1]*(count+1)%1000000007\r\n				else:\r\n					ans+=dp[i-1]*(count)%1000000007\r\n			elif count%2==0:\r\n				ans+=dp[i-1]*(count-1)%1000000007\r\n	print(ans%1000000007)\r\n\r\n\r\n
t= int(input())\nfor _ in range(t):\n n = int(input())\n ar = []\n y = []\n for i in range(n):\n  ar.append( list(map(int,input().split())) )\n  y.append(ar[-1][1])\n  ar[-1].append(i)\n \n y.sort()\n mny = y[0]\n mxy = y[-1]\n ar.sort()\n ssx,ssy,ssi = ar[0]\n bbx,bby,bbi = ar[-1]\n \n sbx,sby,sbi = ar[0]\n bsx,bsy,bsi = ar[-1]\n \n for i in range(len(ar)):\n  if ar[i][0]>ssx:\n   sbx,sby,sbi = ar[i-1]\n   break\n \n for i in range(len(ar)-1,-1,-1):\n  if ar[i][0]<bsx:\n   bsx,bsy,bsi = ar[i+1]\n   break \n \n if (ssy <=mny):\n  print(1)\n  print(ssi+1,'NE')\n  continue\n if (sby>=mxy):\n  print(1)\n  print(sbi+1,'SE')\n  continue\n if (bsy <=mny):\n  print(1)\n  print(bsi+1,'NW')\n  continue\n if (bby>=mxy):\n  print(1)\n  print(bbi+1,'SW')\n  continue \n \n print(2)\n if(ssy<bby):\n  print(ssi+1,'NE')\n  print(bbi+1,'SW')\n else:\n  print(ssi+1,'SE')\n  print(bbi+1,'NW')\n \n
# from math import log2\n# N = 10000\n# for i in range(1,N):\n#     # print(i)\n#     for m in range(i):\n#         if( (m^(m+1))==i ):\n#             print(i)\n#             print(m,m+1,bin(m)[2:])\n#             print()\n#             break\n#     # else:\n#         # print(-1)\n#         # print()\nT = int(input())\nans = []\n\nfor _ in range(T):\n N = int(input())\n\n # x = log2(N+1)\n if(N==1):\n  ans.append(2)\n elif('0' not in bin(N)[2:]):\n  ans.append(N//2)\n else:\n  ans.append(-1)\n\nfor i in ans:\n print(i)
# cook your dish here\n \nfor __ in range(int(input())):\n n=int(input())\n arr=list(map(int,input().split()))\n d={}\n s=set()\n flag=0\n for i in range(n):\n  if arr[i] in list(d.keys()):\n   d[arr[i]]+=1\n  else:\n   d[arr[i]]=1\n  curr_ele=arr[i]\n  if (curr_ele in s) and arr[i-1]!=arr[i]:\n   flag=1\n   break\n  else:\n   s.add(arr[i])\n c=list(d.values())\n if len(c)!=len(set(c)):\n  flag=1\n if flag==1:\n  print("NO")\n else:\n  print("YES")\n \n   \n  \n \n
# cook your dish here\n\nt = int(input())\n\nfor _ in range(t):\n	a,d,k,n,inc = map(int, input().strip().split())\n\n	res = a\n	for i in range(1, n):\n		if i%k == 0:\n			d += inc\n		res += d\n\n	print(res)
x=eval(input())\nfor x in range(0,x):\n	ans=0\n	d=input()\n	a=0\n	cont=0\n	for i in range(0,len(d)):\n		a+=len(d)-i\n		if d[i]=='7':\n			ans+=1+cont\n			cont+=1\n		else:\n			cont=0\n	ans=a-ans\n	print(ans)\n
# cook your dish here\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int,input().split()))\n    a.sort()\n    i=1\n    while(i<n):\n        a[i-1],a[i] = a[i],a[i-1]\n        i+=2\n    print(*a)\n
# cook your dish here\nfor _ in range(int(input())):\n    N, M = [int(x) for x in input().split()]\n    edges = [0]*M\n    dir = {}\n    nodes = [[] for j in range(N+1)]\n    ind = [0]*(N+1)\n    graph = {}\n    final_edges = []\n    for i in range(M):\n        u, v = [int(x) for x in input().split()]\n        nodes[u].append(v)\n        nodes[v].append(u)\n        dir[(u,v)]=1\n        dir[(v,u)] = 0\n        ind[v] += 1\n        graph[(u,v)] = graph[(v,u)] = i\n        final_edges.append([u,v])\n    if M%2!=0:\n        print(-1)\n        continue\n    for i in range(M):\n        u, v = final_edges[i]\n        if ind[u]%2!=0 and ind[v]%2!=0:\n            d = dir[(u,v)]\n            if d:\n                ind[u] += 1\n                ind[v] -= 1\n                dir[(u,v)] = 0\n                dir[(v,u)] = 1\n                edges[i] = abs(edges[i]-1)\n            else:\n                ind[u] -= 1\n                ind[v] += 1\n                dir[(u, v)] = 1\n                dir[(v, u)] = 0\n                edges[i] = abs(edges[i]-1)\n    s = []\n    for i in range(1, N+1):\n        if ind[i]%2:\n            s.append(i)\n    while s:\n        set1 = set()\n        for u in s:\n            if ind[u]%2:\n                v = nodes[u][0]\n                d = dir[(u,v)]\n                index = graph[(u, v)]\n                set1.add(v)\n                if d:\n                    ind[u] += 1\n                    ind[v] -= 1\n                    dir[(u, v)] = 1\n                    dir[(v, u)] = 1\n                    edges[index] = abs(edges[index]-1)\n                else:\n                    ind[u] -= 1\n                    ind[v] += 1\n                    dir[(u, v)] = 1\n                    dir[(v, u)] = 0\n                    edges[index] = abs(edges[index]-1)\n\n        s = set1\n    print(*edges)
#read input\ncases = int(input())\ncaselist = []\nfor i in range(0, cases):\n caselist.append(input())\n\n#iterate each case\nfor j in range(0, cases):\n\n #current case's parameters:\n current_input = caselist[j].split(' ')\n bots = int(current_input[0])\n switch = int(current_input[1])\n\n #generate botlist and cakelist\n botlist = list(range(switch, bots)) + list(range(0, switch))\n cakelist = [False] * bots\n\n\n counter = 0\n index = 0\n for i in range(0,bots):\n  if cakelist[index] == False:\n   cakelist[index] = True\n   counter += 1\n   index = botlist[index]\n  else:\n   break\n\n if counter == bots:\n  print("Yes")\n else:\n  print("No", counter)\n  \n\n \n
n, q, k = map(int, input().split())\narr = list(map(int, input().split()))\nquery = list(input())\nq_ = len(query)\nc1 = query.count('?')\nc = arr.count(0)\nif c == n:\n for i in range(c1):\n  print(0)\nelse:\n for i in range(q_):\n  if (i!=0) and (query[i] == '?' and query[i-1] == '?'):\n   print(max_c)\n  elif query[i] == '?':\n   max_c = cnt = 0\n   for j in range(n):\n    if (j != n - 1) and (arr[j] == 1 and arr[j + 1] == 1):\n     cnt += 1\n    else:\n     max_c = max(max_c, cnt + 1)\n     cnt = 0\n    if k < max_c:\n     max_c = k\n     break\n   print(max_c)\n  elif query[i] == '!':\n   temp = arr[n - 1]\n   del arr[n - 1]\n   arr.insert(0, temp)
import numpy as np\n\nN=10**6+1\nt=eval(input())\ninp = ()\n\nt1=ord('z')\n#bag=[[0  for _ in xrange(t1)] for _ in xrange(N+1)]\nbag=np.zeros((N+1,t1),dtype=np.int)\n#print bag\nwhile t:\n t-=1\n inp=input().split()\n t2=ord(inp[3]) - ord('a')\n t3=int(inp[1])\n t4=int(inp[2]) + 1\n if inp[0]=="1":\n  #print "enter"\n  bag[t3][t2]+=int(inp[2])\n\n\n if inp[0]=="2":\n  sum=0\n  for i in range(t3,t4):\n   sum+=bag[i][t2]\n  print(sum)\n\n#\n# for j in range(ord('z')-ord('a')):\n#     for i in range(N+1):\n#         if bag[i][j]!=0:\n#             print bag[i][j] ,i,j\n\n\n\n
n=eval(input())\ngrades=list(map(int,input().split()))\nm=eval(input())\nfor df in range(m):\n x,y=list(map(int,input().split()))\n arr=[]\n arr=grades[x-1:y]\n arr.sort()\n sum=0\n #arr.append(1000000)\n for nh in range(0,len(arr)-1,1):\n  sum=sum+(arr[nh+1]-arr[nh])**2\n  #print sum,len(arr),nh+1,nh\n print(sum)
import math\ndef GLR(x):\n summation_N = (x*(x+1))//2\n initial = x\n power = 0\n sum_A = 0\n while x>=1:\n  count = (x+1)//2\n  sum_A += count * 2**power\n  x = x - count\n  power += 1\n sum_B = summation_N - sum_A\n ans = sum_B - (int(math.log(initial,2))+1)\n return ans\n \nfor _ in range(int(input())):\n l,r = list(map(int,input().split()))\n if l==1:\n  print(GLR(r))\n else:\n  print((GLR(r) - GLR(l-1)))# cook your dish here\n
#Note that it's python3 Code. Here, we are using input() instead of raw_input().\n#You can check on your local machine the version of python by typing "python --version" in the terminal.\n\n(n, k) = list(map(int, input().split(' ')))\n\nans = 0\n\nfor i in range(n):\n	x = int(input())\n	if x % k == 0:\n		ans += 1\n\nprint(ans)	
# cook your dish here\nt=int(input())\nfor i in range(t):\n a=0\n n=int(input())\n while(n>0):\n  a += n*n\n  n=n-2\n print(a)\n
import math\n\n\nn,m = map(int, input().split())\nhyp = math.sqrt(1+m*m)\ncosx = 1/hyp\nsinx = m/hyp\n\npts = [[], []]\nfor i in range(n):\n    p = input().split()\n    px = int(p[0])\n    py = int(p[1])\n    pts[0].append(cosx*px+sinx*py)\n    pts[1].append(cosx*py-sinx*px)\n\nw = max(pts[0])-min(pts[0])\nl = max(pts[1])-min(pts[1])\n\nprint(2*l+2*w)
# cook your dish here\n\nl=[int(k) for k in input().split()]\ns=[int(k) for k in input().split()]\nx=l[1]*l[0]\nfor i in range(l[0]):\n    if(s[i]==1):\n        x+=l[2]\n    elif(s[i]==2):\n        x+=(l[2]*98/100)\n    elif(s[i]==3):\n        x+=(l[2]*96/100)\n    elif(s[i]==4):\n        x+=(l[2]*94/100)\n    elif(s[i]==5):\n        x+=(l[2]*92/100)\n    elif(s[i]==6):\n        x+=(l[2]*90/100)\nif(x>=300):\n    print("YES")\nelse:\n    print("NO")
from sys import stdin\nfrom fractions import Fraction\n\ninput = stdin.readline\n\nfor _ in range(int(input())):\n    a, b, n = list(map(int, input().split()))\n    ab = Fraction(a, b)\n\n    p = set()\n\n    for i in range(1, n+1):\n        for j in range(n, 0, -1):\n            x = Fraction(i, j)\n\n            if x > ab:\n                break\n\n            p.add(x)\n\n    x = sorted(p)[-2]\n\n    print(x.numerator, x.denominator)\n
# cook your dish here\ntry:\n    t=int(input()) \n    for i in range(t):\n        n=input() \n        n=n.lower()\n        a="berhampore"\n        b="serampore"\n        if a in n:\n            if b in n:\n                print("Both")\n            else:\n                print("GCETTB")\n        elif b in n:\n            if a in n:\n                print("Both")\n            else:\n                print("GCETTS")\n        else:\n            print("Others")\nexcept Exception as e:\n    pass
def ugcd(n):\r\n  ans = [[1]]\r\n  if(n==1):\r\n    return ans\r\n  elif(n%2==1):\r\n    ans = [[1, 2, n]]\r\n  else:\r\n    ans = [[1, 2]]\r\n  for k in range(1, int(n//2)):\r\n    ans.append([k*2+1, k*2+2])\r\n  return ans\r\nt = int(input())\r\nfor i in range(t):\r\n  n = int(input())\r\n  s = (ugcd(n))\r\n  print(len(s))\r\n  for j in range(len(s)):\r\n    print(len(s[j]), end=" ")\r\n    print(*s[j])
t=int(input())\nli1=[31,29,31,30,31,30,31,31,30,31,30,31]\nli2=[31,28,31,30,31,30,31,31,30,31,30,31]\nfor z in range(t):\n y,m,d=list(map(int,input().split(':')))\n if y%4 == 0:\n  if y%100 == 0:\n   if y%400 == 0:\n    li=li1\n   else:\n    li=li2\n  else:\n   li=li1\n else:\n  li=li2\n c=0\n if d%2 == 0:\n  while d%2 == 0:\n   c+=1\n   d+=2\n   if d>li[m-1]:\n    d=d%li[m-1]\n    m+=1\n else: \n  while d%2 != 0:\n   c+=1\n   d+=2\n   if d>li[m-1]:\n    d=d%li[m-1]\n    m+=1\n print(c)\n   \n
import sys\n\ndef powc(x,n,m):\n  res = 1\n  xx=x\n  while n:\n    if n&1:\n      res = (res*xx)%m\n    xx=xx*xx%m\n    n >>= 1\n  return res\n\ndef circles(u):\n  r = 0\n  S = [(u,-1,0)]\n  Visited[u] = 0\n  for s in S:\n    for e in V[s[0]]:\n      if e[0] != s[1]:\n        if Visited[e[0]]==-1: \n          Visited[e[0]] = s[2]^e[1]\n          S.append((e[0], s[0], s[2]^e[1])) \n        elif Visited[e[0]] != s[2]^e[1]:\n          return -1\n        else:\n          r += s[0]<e[0]\n  return r\n\nT = int(sys.stdin.readline())\nfor _ in range(T):\n  is_bad = False\n  empty = 0\n  n,Q = list(map(int, sys.stdin.readline().split()))\n  for _ in range(n-1):\n    sys.stdin.readline() \n  paths = []\n  V=list(map(list,[[]]*n))\n  for q in range(Q):\n    u,v,x = list(map(int, sys.stdin.readline().split()))\n    u-=1\n    v-=1\n    if (v,x^1) in V[u]:\n      is_bad = True\n    elif (v,x) in V[u]:\n      empty += 1\n    elif u!=v:\n      V[u].append((v,x))\n      V[v].append((u,x))\n    elif x==1:\n      is_bad = True\n    else:\n      empty += 1\n    paths.append((u,v,x))\n  if is_bad:\n    print(0)\n  elif n<=1:\n    print(1)\n  else:\n    Visited = [-1]*n\n    components = 0\n    for i in range(n):\n      if Visited[i]==-1:\n        components += 1\n        c = circles(i)\n        if c==-1:\n          is_bad = True\n          break\n        empty += c\n    if is_bad:\n      print(0)\n    else:\n      print(powc(2,n-1-(Q-empty),10**9+7)) \n
# cook your dish here\nn,q=map(int,input().split())\nls=[int(i) for i in input().split()]\ncur=0\ns=[0]\nfor i in ls:\n cur=cur^i\n s.append(cur)\nfor i in range(q):\n k=int(input())\n print(s[k%(n+1)])
# cook your dish here\ndef guessingGame (l):\n a = []\n m = 1000000001\n for i in range (len(l)):\n  k=int(l[i][1])\n  if (l[i][0]=='<' and l[i][2]=='Yes'):\n   a.append((1,1))\n   a.append((k,-1))\n   \n  if (l[i][0]=='<' and l[i][2]=='No'):\n   a.append((k,1))\n   a.append((m,-1))\n   \n  if (l[i][0]=='=' and l[i][2]=='Yes'):\n   a.append((k,1))\n   a.append((k+1,-1))\n\n  if (l[i][0]=='=' and l[i][2]=='No'):\n   a.append((1,1))\n   a.append((k,-1))\n   a.append((k+1,1))\n   a.append((m,-1))\n\n  if (l[i][0]=='>' and l[i][2]=='Yes'):\n   a.append((k+1,1))\n   a.append((m,-1))\n\n  if (l[i][0]=='>' and l[i][2]=='No'):\n   a.append((1,1))\n   a.append((k+1,-1))\n\n a.sort()\n w=0\n r=0\n\n for i in range (len(a)):\n  w+=a[i][1]\n  r=max(w,r)\n\n return len(l)-r\n  \n \ndef __starting_point():\n\n T = int(input())\n answer = []\n\n for _ in range (T):\n  e = int(input())\n  temp = []\n  for q_t in range (e):\n   q = list(map(str,input().rstrip().split()))\n   temp.append(q)\n  result = guessingGame(temp)\n  print(result)\n__starting_point()
# cook your dish here\ntry:\n    t=int(input())\n    for i in range(t):\n        s=input()\n        i=int(s,16)\n        print(i)\nexcept EOFError as e:\n    print(e)
try:\r\n    tc=int(input())\r\n    for _ in range(tc):\r\n        n=int(input())\r\n        st=""\r\n        b=1\r\n        for i in range(1,n+1):\r\n            b+=1\r\n            a=b\r\n            for j in range(1,n+1):\r\n                print(a,end='')\r\n                a+=1\r\n            print()        \r\nexcept:\r\n    pass
# cook your dish here\nfor _ in range(int(input())):\n s=input()\n count=0\n i=0\n while i<len(s)-1:\n  ch=s[i]\n  j=i+1 \n  while j<len(s) and s[j]==ch:\n   j+=1 \n  l=j-i\n  if i!=0 and j!=len(s) and s[i-1]==s[j] :\n   count+=1\n  count+=l*(l-1)//2\n  #print(s[i:j],count)\n  i=j\n print(count) \n
import sys\n\ndef spaces(a,n,m,k,visit1,visit2,dist,position):\n queue = [position]\n lastedit = []\n dist[position[0]][position[1]] = 0 \n while queue!=[]:\n  point = queue[0]\n  i = point[0]\n  j = point[1]\n  #print 'point',i,j\n  if visit1[i][j]==False:\n   visit1[i][j] = True\n   startx = max(i-k,0)\n   endx = min(i+k,n-1)\n   for x in range(startx,endx+1):\n    starty = max(0,j+abs(x-i)-k)\n    endy = min(m-1,j-abs(x-i)+k)\n    for y in range(starty,endy+1):\n     if (a[x][y]==0 and visit1[x][y]==False):\n      if visit2[x][y]==True:\n       lastedit.append([x,y])\n      #print x,y,\n      if dist[x][y]>dist[i][j]+1:\n       dist[x][y]=dist[i][j]+1\n       queue.append([x,y])\n  #print queue,dist\n  queue = queue[1:]\n  #print\n return lastedit\n\nfor t in range(int(input())):\n n,m,k1,k2 = list(map(int,input().split()))\n a = []\n for i in range(n):\n  a.append(list(map(int,input().split())))\n #print a\n value = sys.maxsize\n listing = []\n visit1 = [[False for i in range(m)]for j in range(n)]\n visit2 = [[False for i in range(m)]for j in range(n)]\n dist1 = [[sys.maxsize for i in range(m)]for j in range(n)]\n dist2 = [[sys.maxsize for i in range(m)]for j in range(n)]\n if k1>=k2:\n  spaces(a,n,m,k1,visit1,visit2,dist1,[0,0])\n else:\n  spaces(a,n,m,k2,visit1,visit2,dist1,[0,m-1])\n  listing = spaces(a,n,m,k1,visit2,visit1,dist2,[0,0])\n if k1>k2:\n  listing = spaces(a,n,m,k2,visit2,visit1,dist2,[0,m-1])\n #print visit1\n #sprint visit2\n if k1==k2:\n  if dist1[0][m-1]==sys.maxsize:\n   print('-1')\n  else:\n   print(int((dist1[0][m-1]+1)/2))\n else:\n  d = len(listing)\n  for i in range(d-1,-1,-1):\n   x = listing[i][0]\n   y = listing[i][1]\n   if visit1[x][y]==True and dist2[x][y]<value:\n    value = dist2[x][y]\n  if value!=sys.maxsize:\n   print(value)\n  else:\n   print('-1')\n\n\n\n\n   \n   \n
n=int(input())\r\na=[]\r\nb=[]\r\nfor i in range(1,1000001):\r\n    s = str(i)\r\n    p=1\r\n    flag=0\r\n    for e in s:\r\n        if e=='1':\r\n            flag=1\r\n        p=p*int(e)\r\n    if p==n:\r\n        if flag!=1:\r\n            a.append(i)\r\n        else:\r\n            b.append(i)\r\nprint(len(a),len(b))
#!/usr/bin/python\nimport sys\n\ndef __starting_point():\n t = int(input())\n for iteration in range(t):\n  r,c,m_inp,k_inp,j_inp = input().strip().split(" ")\n  r=int(r)\n  c=int(c)\n  m_inp=int(m_inp)\n  k_inp=int(k_inp)\n  j_inp=int(j_inp)\n\n  ans = ""\n  if (r*c) != (m_inp+k_inp+j_inp):\n   print("No")\n   continue\n  else:\n   flag = False\n   for i in range(6):\n    if flag:\n     break\n    if i==0:\n     m = m_inp\n     k = k_inp\n     j = j_inp\n    elif i==1:\n     m = j_inp\n     k = m_inp\n     j = k_inp\n    elif i==2:\n     m = k_inp\n     k = j_inp\n     j = m_inp\n    elif i==3:\n     m = m_inp\n     k = j_inp\n     j = k_inp\n    elif i==4:\n     m = k_inp\n     k = m_inp\n     j = j_inp\n    elif i==5:\n     m = j_inp\n     k = k_inp\n     j = m_inp\n    if m%r == 0:\n     r_remain_1 = r\n     c_remain_1 = c-(m/r)\n     \n     if k%r_remain_1 == 0:\n      r_remain_2 = r_remain_1\n      c_remain_2 = c_remain_1 - (k/r_remain_1)\n      if r_remain_2*c_remain_2 == j:\n       print("Yes")\n       flag = True\n       continue\n     if k%c_remain_1 == 0:\n      c_remain_2 = c_remain_1\n      r_remain_2 = r_remain_1 - (k/c_remain_1)\n      if r_remain_2*c_remain_2 == j:\n       print("Yes")\n       flag = True\n       continue\n     \n     if j%r_remain_1 == 0:\n      r_remain_2 = r_remain_1\n      c_remain_2 = c_remain_1 - (j/r_remain_1)\n      if r_remain_2*c_remain_2 == k:\n       print("Yes")\n       flag = True\n       continue\n     if j%c_remain_1 == 0:\n      c_remain_2 = c_remain_1\n      r_remain_2 = r_remain_1 - (j/c_remain_1)\n      if r_remain_2*c_remain_2 == k:\n       print("Yes")\n       flag = True\n       continue\n    \n    if m%c == 0:\n     c_remain_1 = c\n     r_remain_1 = r-(m/c) \n\n     if k%r_remain_1 == 0:\n      r_remain_2 = r_remain_1\n      c_remain_2 = c_remain_1 - (k/r_remain_1)\n      if r_remain_2*c_remain_2 == j:\n       print("Yes")\n       flag = True\n       continue\n     if k%c_remain_1 == 0:\n      c_remain_2 = c_remain_1\n      r_remain_2 = r_remain_1 - (k/c_remain_1)\n      if r_remain_2*c_remain_2 == j:\n       print("Yes")\n       flag = True\n       continue\n     \n     if j%r_remain_1 == 0:\n      r_remain_2 = r_remain_1\n      c_remain_2 = c_remain_1 - (j/r_remain_1)\n      if r_remain_2*c_remain_2 == k:\n       print("Yes")\n       flag = True\n       continue\n     if j%c_remain_1 == 0:\n      c_remain_2 = c_remain_1\n      r_remain_2 = r_remain_1 - (j/c_remain_1)\n      if r_remain_2*c_remain_2 == k:\n       print("Yes")\n       flag = True\n       continue\n   if not flag:\n    print("No")\n__starting_point()
T = int(input())\n\ndef call_me(N,A,X):\n max = 0\n ans = ''\n for i in A:\n  if i.count(X) > max:\n   max = i.count(X)\n   ans = i\n return ans\n\n\n\nfor i in range(T):\n N = int(input())\n A = list(map(str,input().split()))\n X = input()\n print(call_me(N,A,X))\n
x = input().split(" ")\ny = input()\nans = ''\nl = 1\nfor i in x:\n if i!=y and sorted(i) == sorted(y):\n  ans = ans + (str)(l)\n l=l+1\nans+='.'\nprint("The antidote is found in",ans)
# cook your dish here\nfrom collections import Counter\nfrom math import factorial\nfor _ in range(int(input())):\n s=input()\n c=Counter(s)\n k=factorial(len(s))\n for value in c.values():\n  if value>1:\n   k=k//factorial(value)\n print(k%(10**9+7))
for _1 in range(int(input())):\n n=int(input())\n s=input().strip()\n answer=s\n for i in range(len(s)):\n  c=s[i]\n  string=s[:i]+s[i+1:]\n  for j in range(len(string)+1):\n   answer=min(answer, string[:j]+c+string[j:])\n print(answer)
# cook your dish here\nfrom math import gcd\nfor _ in range(int(input())):\n    n,a,k,min_k,e = int(input()),[int(i) for i in input().split()],0,0,-1   \n    for j in range(n):\n     if(a[j] != -1):break            \n    for i in range(j,n):\n     if min_k==0:min_k,e = a[i],a[i]+1 \n     else:\n      if min_k < a[i]:min_k = a[i]                \n      if(a[i] == -1):pass\n      else:\n       if(a[i] == e):pass\n       else:\n        if( k == 0):k = e-a[i]\n        else:\n         new_k = e-a[i]\n         if(new_k < 0):k = -1\n         else:k = gcd(k,new_k)\n        if(k<min_k or k<0): k = -1; break\n      if k != 0 and a[i]!=-1: e = a[i]%k+1\n      else:e += 1             \n    if(k == -1):print("impossible")\n    elif k == 0 :print("inf")\n    else:print(k)  
# cook your dish here\np=int(input())\nfor z in range(p):\n n=int(input())\n a=[]\n for i in range(8):\n  a.append(0)\n for i in range(n):\n  x,y=list(map(int,input().split()))\n  if x<=8 and y>a[x-1]:\n   a[x-1]=y\n print(sum(a))\n
import math\ndef dist(w,x,y,z):\n return math.hypot(y - w, z - x)\n\nt = int(input())\nwhile (t>0):\n t = t -1\n n, m = list(map(int,input().split()))\n a = []\n for i in range(0,n):\n  x,y = list(map(int,input().split()))\n  a.append([x,y])\n for j in range(0,m):\n  p,q,r,s = list(map(int,input().split()))\n  nearest = -1\n  distance = 10000000000\n  for i in range(0,n):\n   way = dist(a[i][0],a[i][1],p,q)\n   if way < distance:\n    distance = way\n    nearest = i\n  print(nearest + 1)\n  a[nearest][0] = r\n  a[nearest][1] = s\n\n
t=int(input())\nfor i in range(t):\n s=input()\n zeroes=s.count('0')\n ones=s.count('1')\n if (len(s)%2==1 or zeroes==0 or ones==0):\n  ans= -1\n else:\n  ans=abs(zeroes-ones)//2\n print(ans) 
for i in range(int(input())):\n n = int(input())\n q = "1"+"0"*(n//2)\n print(1,q)
from math import gcd\r\nn, k = list(map(int, input().split()))\r\na = []\r\nfor i in range(k):\r\n    try:\r\n        a += list(map(int, input().split()))\r\n    except:\r\n        pass\r\nans = n\r\nfor i in range(1, 2**k):\r\n    b = bin(i)[2:].rjust(k, "0")\r\n    c = []\r\n    for j in range(k):\r\n        if(b[j] == '1'):\r\n            c.append(a[j])\r\n    lcm = c[0]\r\n    for j in c[1:]:\r\n        lcm *= j // gcd(lcm, j)\r\n    temp = ((n - 1) // lcm) + 1\r\n    if(b.count('1')&1):\r\n        ans -= temp\r\n    else:\r\n        ans += temp\r\nprint(ans)\r\n\r\n
for _ in range(int(input())):\n s = list(input().strip())\n\n i = 0\n\n while i < len(s) - 1:\n  if s[i].isalpha() or s[i] == ')':\n   if s[i + 1].isdigit():\n    if i + 2 >= len(s) or s[i + 2] == ')':\n     s = s[:i+1] + ['*', s[i+1]] + s[i+2:]\n    else:\n     s = s[:i+1] + ['*', s[i+1], '+'] + s[i+2:]\n    i += 1\n   elif s[i + 1].isalpha() or s[i + 1] == '(':\n    s = s[:i+1] + ['+'] + s[i+1:]\n\n  i += 1\n\n s = ''.join(s)\n\n s = s.strip('+')\n\n x = 2\n y = 4\n z = 10\n\n print(eval(s))\n
# cook your dish here\nfor _ in range(int(input())):\n n=int(input())\n l1=[]\n l2=[]\n \n for i in range(n):\n  s=input()\n  a=s[ :n//2].count('1')\n  b=s[n//2: ].count('1')\n  if a>b:\n   l1.append(a-b)\n   \n  elif a<b:\n   l2.append(b-a)\n   \n p=sum(l1)\n q=sum(l2)\n \n if p==q:\n  print(0)\n  \n elif p>q:\n  diff=p-q\n  flag=0\n  for i in range(diff//2, 0, -1):\n   a=diff-i\n   if (i in l1) or (a in l1):\n    print(abs(a-i))\n    flag=1\n    break\n   \n  if flag==0:\n   print(diff)\n   \n else:\n  diff=q-p\n  flag=0\n  for i in range(diff//2, 0, -1):\n   a=diff-i\n   if (i in l2) or (a in l2):\n    print(abs(a-i))\n    flag=1\n    break\n   \n  if flag==0:\n   print(diff)
for j in range(int(input())):\n input()\n a = list(map(int,input().split()))\n marks = 0\n backlok = 0\n top_marks = max(a)\n topper = []\n for i in range(len(a)):\n  if(a[i] >= 31):\n   marks+=a[i]\n  if(a[i]<31):\n   backlok+=1\n  if(a[i] == top_marks):\n   topper.append(i)\n print(backlok, "{:0.2f}".format(marks/len(a),2))\n topper.sort(reverse=True)\n for i in topper:\n  print(i," ")\n for i in a:\n  print(top_marks-i)\n\n
import sys\n\n# stdin = open("testdata.txt", "r")\nip = sys.stdin \n\ndef solve(C, n, x):\n if n==1:\n  return (1, 0)\n\n b1, b2 = 1, 1\n a , b = C[0], C[-1]\n while b1 + b2 < n:\n  if a < b*x:\n   a += C[b1]\n   b1 += 1\n  elif a > b*x:\n   b2 += 1\n   b += C[n-b2] \n  else:\n   if b1 >= b2:\n    a += C[b1]\n    b1 += 1\n   else:\n    b2 += 1\n    b += C[b2]\n return (b1, b2)\n\nt = int(ip.readline())\n\nfor _ in range(t):\n n = int(ip.readline())\n C = list(map(int, ip.readline().split()))\n x = int(ip.readline())\n\n ans = solve(C, n, x)\n print(*ans)
from itertools import permutations\n\nfor _ in range(int(input())):\n N,K=list(map(int,input().split()))\n arr=list(map(int,input().split()))\n arr1=[]\n arr2=[]\n for i in range(1,len(arr)+1):\n  arr1.append(i)\n indexzero=[]\n for i in range(0,len(arr)):\n  if(arr[i]==0):\n   indexzero.append(i)\n  else:\n   arr2.append(arr[i])\n # arr3 = [x for x in arr1 if x not in arr2]\n arr3= list(set(arr1)-set(arr2))\n result=permutations(arr3)\n perm=[]\n for i in result:\n  perm.append(i)\n step=0\n count=0\n for p in range(0,len(perm)):\n  temp=[]\n  for q in range(0,len(arr)):\n   if(arr[q]==0):\n    temp.append(perm[p][step])\n    step+=1 \n   else:\n    temp.append(arr[q])\n  k=0\n  step=0\n  for m in range(0,len(temp)-1):\n   if(temp[m]<temp[m+1]):\n    k+=1\n  if(k==K):\n   count+=1 \n print(count)\n   \n    \n  \n \n  \n \n   \n
a,b=[int(_) for _ in input().split()]\r\nif b==0:\r\n    print(a)\r\nelse:    \r\n    l=[]\r\n    a=str(a)\r\n    for i in range(len(a)):\r\n        l.append(a[i])\r\n    for i in range(len(l)):\r\n        if b==0:\r\n            break\r\n        if l[i]=='9':\r\n            continue\r\n        else:\r\n            l[i]='9'\r\n            b-=1\r\n    s=''\r\n    for i in l:\r\n        s+=i\r\n    print(s)    \r\n    \r\n
from math import ceil\r\nt=int(input())\r\nfor i in range(t):\r\n       p=int(input())\r\n       l=list(map(int,input().split()))\r\n       maxx=1\r\n       for i in range(len(l)):\r\n           maxx=max(maxx,l.count(l[i]))\r\n       if(maxx*2>p):\r\n           print(maxx)\r\n       else:\r\n           q=p-maxx*2\r\n           maxx+=ceil(q/2)\r\n           print(maxx)\r\n           \r\n       \r\n              \r\n\r\n
def permutate(arr):\n if len(arr) == 1:\n  yield arr\n for x in range(len(arr)):\n  for perm in permutate(arr[:x] + arr[x+1:]):\n   yield [arr[x]] + perm\n\nvals = [int(x) for x in input().split()]\n\nfounded = False\nfor val in permutate(vals):\n if (val[0] / float(val[1]) == val[2] / float(val[3])):\n  print("Possible")\n  founded = True \n  break\nif not founded:\n print("Impossible")\n
t = int(input())\nfor j in range(0, t):\n n = int(input())\n m = 100\n for i in range(0, n):\n  str = input()\n  p = min(str.count("a",0,len(str)),str.count("b",0,len(str)))\n  if (m > p):\n   m = p\n print(m)\n t = t-1
def outOfIndex(boys,girls,COST):\n if COST == 0:\n  return len(boys)\n else:\n  total_cost = [ abs(x-y) for x,y in zip(boys,girls)]\n  total_cost = sum(total_cost)\n  return total_cost\n\nfor _ in range(int(input())):\n COST = int(input())\n queue = input()\n B = queue.count('B')\n G = queue.count('G')\n boys=[]\n girls = []\n if (abs(B-G)>1):\n  print(-1)\n else:\n  if B > G:\n   for c in range(len(queue)):\n    if c%2!=0 and queue[c]=='B':\n     boys.append(c)\n    if c%2==0 and queue[c] =='G':\n     girls.append(c)\n   print(outOfIndex(boys,girls,COST))\n   boys.clear()\n   girls.clear()\n  elif B < G:\n   for c in range(len(queue)):\n    if c%2!=0 and queue[c]=='G':\n     girls.append(c)\n    if c%2==0 and queue[c] =='B':\n     boys.append(c)\n   print(outOfIndex(boys,girls,COST))\n   boys.clear()\n   girls.clear()\n  else:\n   for c in range(len(queue)):\n    if c%2!=0 and queue[c]=='B':\n     boys.append(c)\n    if c%2==0 and queue[c] =='G':\n     girls.append(c)\n   attempt1 = outOfIndex(boys,girls,COST)\n   boys.clear()\n   girls.clear()\n   for c in range(len(queue)):\n    if c%2!=0 and queue[c]=='G':\n     girls.append(c)\n    if c%2==0 and queue[c] =='B':\n     boys.append(c)\n   attempt2 = outOfIndex(boys,girls,COST)\n   print(min(attempt1,attempt2))\n   boys.clear()\n   girls.clear() \n
n=int(input())\r\nl=[0]*n\r\nfor i in range(n):\r\n    l[i]=int(input())\r\nl.sort()\r\ns=0\r\ni=n-1\r\nwhile i>=0:\r\n    x=2*l[i]\r\n    if l[-1]>=x:\r\n        j=i\r\n        while j<len(l):\r\n            if l[j]>=x:\r\n                l.pop(j)\r\n                l.pop(i)\r\n                s+=1\r\n                break\r\n            j+=1\r\n    i-=1\r\ns+=len(l)\r\nprint(s)
t=int(input())\nfor i in range(0,t):\n n=int(input())\n lis=list(map(int,input().split()))\n lis2=[]\n for j in range(0,10):\n  lis2.append(0)\n for j in range(0,len(lis)):\n  lis2[lis[j]]+=1;\n s=sum(lis)\n while s%3!=0:\n  if s%3==2:\n   if lis2[2]>=1:\n    lis2[2]-=1\n    s=s-2\n   elif lis2[5]>=1:\n    lis2[5]-=1\n    s=s-5\n   elif lis2[8]>=1:\n    lis2[8]-=1\n    s=s-8\n   elif lis2[1]>=2:\n    lis2[1]-=2\n    s=s-2\n   elif lis2[1]>=1 and lis2[4]>=1:\n    lis2[1]-=1\n    lis2[4]-=1\n    s=s-5\n   elif lis2[4]>=2:\n    lis2[4]-=2\n    s=s-8\n   elif lis2[1]>=1 and lis2[7]>=1:\n    lis2[1]-=1\n    lis2[7]-=1\n    s=s-8\n   elif lis2[4]>=1 and lis2[7]>=1:\n    lis2[4]-=1\n    lis2[7]-=1\n    s=s-11\n   elif lis2[7]>=2:\n    lis2[7]-=2\n    s=s-14\n  elif s%3==1:\n   if lis2[1]>=1:\n    lis2[1]-=1\n    s=s-1\n   elif lis2[4]>=1:\n    lis2[4]-=1\n    s=s-4\n   elif lis2[7]>=1:\n    lis2[7]-=1\n    s=s-7\n   elif lis2[2]>=2:\n    lis2[2]-=2\n    s=s-4\n   elif lis2[5]>=1 and lis2[2]>=1:\n    lis2[2]-=1\n    lis2[5]-=1\n    s=s-7\n   elif lis2[5]>=2:\n    lis2[5]-=2\n    s=s-10\n   elif lis2[2]>=1 and lis2[8]>=1:\n    lis2[2]-=1\n    lis2[8]-=1\n    s=s-10\n   elif lis2[8]>=1 and lis2[5]>=1:\n    lis2[8]-=1\n    lis2[5]-=1\n    s=s-13\n   elif lis2[8]>=2:\n    lis2[8]-=2\n    s=s-16\n lis3=[]\n for j in range(1,10):\n  if lis2[j]>=1:\n   for k in range(0,lis2[j]):\n    lis3.append(j)\n lis3.reverse()\n for k in range(0,lis2[0]):\n  lis3.append(0)\n sol=''\n for k in range(0,len(lis3)):\n  sol+=str(lis3[k])\n print(sol)
# cook your dish here\nMOD=10**9+7\nfor _ in range(int(input())):\n    s=input()\n    ind=1\n    level=1\n    for i in range(len(s)):\n        if s[i]=='l':\n            if level%2==1:\n                ind=ind*2\n            else:\n                ind=ind*2-1\n        if s[i]=='r':\n            if level%2==1:\n                ind=ind*2+2\n            else:\n                ind=ind*2+1\n        level+=1\n        ind%=MOD\n    print(ind)\n
for t in range(int(input())):\n n = int(input())\n mx = -1\n for i in range(n):\n  h, m, s = list(map(int,input().split(":")))\n  h %= 12\n  m %= 60\n  s %= 60\n  ha = h*30 + m*0.5 + s*0.5/60\n  ma = m*6 + s*0.1\n  sa = s*6\n  \n  hm1 = abs(ha - ma)\n  hm2 = 360 - hm1\n  hm3 = abs(hm1 - hm2)\n  hm = min(hm1, hm2, hm3)\n  \n  ms1 = abs(ma - sa)\n  ms2 = 360 - ms1\n  ms3 = abs(ms1 - ms2)\n  ms = min(ms1, ms2, ms3)\n  \n  sh1 = abs(sa - ha)\n  sh2 = 360 - sh1\n  sh3 = abs(sh1 - sh2)\n  sh = min(sh1, sh2, sh3)\n  \n  avg = (hm + ms + sh) / 3\n  if (mx < avg):\n   ans = i+1\n   mx = avg\n print(ans)
def Testcase():\n    h,x,y = [int(x) for x in input().strip().split()]\n    \n    h = h-1\n    yt = h//y +1\n    # print(yt)\n    flag=0\n    ans = 100000000009\n \n    for i in range(0,yt):\n        temp = x+i*y\n        if h%temp==0:\n            flag = 1\n            cl =i+int(h/temp)\n            # print(temp,cl)\n            ans = min(ans,cl)\n            # print(temp,ans,i)\n    print(ans if flag==1 else '-1')\n    \n    \nt = int(input())\nwhile t>0:\n    Testcase()\n    \n    t-=1
from sys import stdin,stdout\nimport math,bisect\nfrom collections import Counter,deque,defaultdict\nL=lambda:list(map(int, stdin.readline().strip().split()))\nM=lambda:list(map(int, stdin.readline().strip().split()))\nI=lambda:int(stdin.readline().strip())\nS=lambda:stdin.readline().strip()\nC=lambda:stdin.readline().strip().split()\ndef pr(a):return(" ".join(list(map(str,a))))\n#_________________________________________________#\n\n\ndef solve():\n n, m = M()\n a = []\n for i in range(n):\n  a += [L()]\n s = S()\n p, q = M()\n ans = [[0,0] for i in range(n+m)]\n for i in range(n):\n  for j in range(m):\n   if a[i][j]==0:\n    ans[i+j][0]+=1\n   else:\n    ans[i+j][1]+=1\n c = 0\n for i in range(n+m-1):\n  A,B,C,D = 0,0,0,0\n  if s[i]=='0':\n   A = ans[i][1]*p\n   B = q + ans[i][0]*p\n   c+=min(A,B)\n  else:\n   C = ans[i][0]*p\n   D = q + ans[i][1]*p\n   c+=min(C,D)\n print(c)\nfor _ in range(I()):\n solve()\n
try:\n    for i in range(int(input())):\n        s=input()\n        balance=0\n        max_balance=0\n        for i in s:\n            if i=='(':balance+=1\n            else:\n                balance-=1\n            max_balance=max(max_balance,balance)\n        print('('*max_balance,')'*max_balance,sep="")\nexcept Exception as e:\n    print(e)\n        
import os,sys\nfrom io import BytesIO, IOBase\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return list(map(int,input().split()))\ndef li(): return list(mi())\nimport math \n\nimport collections \n\ndef CountFrequency(arr): \n return collections.Counter(arr) \n\nfor i in range(1):\n n,q=mi()\n p=pow(2,n+1)-2 \n t=1 \n b=pow(2,n)\n s=n+1\n for i in range(q):\n  a=li()\n  if len(a)==2:\n   if a[1]==1 or a[1]==2:\n    p*=2 \n    p+=s\n    t*=2 \n    b*=2\n   else:\n    p*=2 \n    if a[1]==3:\n     p+=t\n     t=b \n     s*=2\n    else:\n     p+=b\n     b=t\n     s*=2\n  else:\n   print(p%1000000007)\n
t=int(input())\r\nfor _ in range(t):\r\n    S=set(input().strip())\r\n    n=int(input().strip())\r\n    a=set(input().strip().split(" "))\r\n    g=True\r\n    for i in S:\r\n        if(i not in a):\r\n            g=False\r\n    if(g):\r\n        print(1)\r\n    else:\r\n        print(0)
# cook your dish here\nimport math\nN=int(input())\nfor i in range(N):\n a,b=list(map(int,input().split()))\n c=a//math.gcd(a,b)*b//math.gcd(a,b)\n print(c)\n \n
for _ in range(int(input())):\n    n,s = int(input()),input().strip()\n    previ,num,_s,dic = s[0],0,[],{}\n    for i in s:\n     if previ == i:\n      num+=1\n      continue\n     _s.append((previ, num))\n     if previ not in dic or dic[previ]<num:dic[previ] = num\n     previ,num = i,1\n    _s.append((previ, num))\n    if previ not in dic or dic[previ]<num:dic[previ] = num\n    sum1 = sum(dic.values())\n    del dic, s\n    l,dicc = [i for (i, j) in _s],{}\n    congr = [(l[i], l[i+1]) for i in range(len(l)-1)]\n    for i in range(len(congr)):\n     if congr[i] not in dicc:dicc[congr[i]] = set()\n     dicc[congr[i]].add( (_s[i][1], _s[i+1][1]) )       \n    sum2,ll = 0,[]\n    for i in dicc.keys():\n     sortedset,deleted =  sorted(list(dicc[i])),[]\n     for k in range(1, len(sortedset)):\n      j = sortedset[k]         \n      if j[1]>sortedset[k-1][1]:\n       ind = k - 1
# cook your dish here\n\nT = int(input())\nl = list(map(int, input().strip().split(" ")))\n\ndepth = 0\nmax_depth = 0\nmax_depth_index = 0\n\nmax_l=0\nmax_l_index=0\nlast_zero=-1\n\nfor i in range(T):\n    if l[i] == 1:\n        depth += 1\n        if depth > max_depth:\n            max_depth = depth\n            max_depth_index = i + 1\n    else:\n        depth-=1\n        if depth == 0:\n            length = i - last_zero\n            if length > max_l:\n                max_l = length\n                max_l_index = last_zero + 2\n            last_zero = i\n        \nprint(max_depth, max_depth_index, max_l, max_l_index)\n\n"""\n2 4 6 9\n"""
import sys,os,io,time,copy,math,queue,bisect\nfrom collections import deque\nfrom functools import lru_cache\n\nif os.path.exists('input.txt'):\n sys.stdin = open('input.txt', 'r')\n sys.stdout = open('output.txt', 'w') \n\nsys.setrecursionlimit(100000000)\n\ndef main():\n n,m=map(int,input().split())\n mat=[]\n for _ in range(n):\n  s=input()\n  a=[]\n  for i in s:\n   a.append(int(i))\n  mat.append(a)\n  \n Q=int(input())\n ans=[[0 for i in range(m+1)] for j in range(n+1)]\n for i in range(Q):\n  x1,y1,x2,y2=map(int,input().split())\n  x1-=1\n  y1-=1\n  x2-=1\n  y2-=1\n  ans[x1][y1]+=1\n  ans[x2+1][y1]-=1\n  ans[x1][y2+1]-=1\n  ans[x2+1][y2+1]+=1\n for j in range(m+1):\n  for i in range(1,n+1):\n   ans[i][j]=ans[i-1][j]+ans[i][j]\n for i in range(n+1):\n  for j in range(1,m+1):\n   ans[i][j]=ans[i][j-1]+ans[i][j]\n \n for i in range(n):\n  for j in range(m):\n   mat[i][j]=(ans[i][j]+mat[i][j])%2\n for m in mat:\n  for i in m:\n   print(i,end="")\n  print("")\n\n  \nmain()\n
#dt = {} for i in x: dt[i] = dt.get(i,0)+1\r\nimport sys;input = sys.stdin.readline\r\ninp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]\r\n\r\nN = 100001\r\np = 998244353\r\nfactorialNumInverse = [0]*(N+1) \r\nnaturalNumInverse = [0]*(N+1)\r\nfact = [0]*(N+1)\r\n  \r\ndef InverseofNumber(p): \r\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\r\n    for i in range(2,N+1): \r\n        naturalNumInverse[i] = (naturalNumInverse[p % i] * (p - (p // i)) % p)\r\n  \r\ndef InverseofFactorial(p): \r\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\r\n    for i in range(2,N+1): \r\n        factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % p \r\n  \r\ndef factorial(p): \r\n    fact[0] = 1\r\n    for i in range(1, N + 1): \r\n        fact[i] = (fact[i - 1] * i) % p\r\n\r\ndef f(num,den1,den2):\r\n    # n C r = n!*inverse(r!)*inverse((n-r)!) \r\n    #ans = ((fact[N] * factorialNumInverse[R])% p * factorialNumInverse[N-R])% p\r\n    ans = ((fact[num]*factorialNumInverse[den1])%p*factorialNumInverse[den2])%p\r\n    return ans \r\n\r\nInverseofNumber(p) \r\nInverseofFactorial(p) \r\nfactorial(p)\r\n\r\nfor _ in range(inp()):\r\n    n,m,x1,y1,x2,y2 = ip()\r\n    tot = f(m+n,m,n)\r\n    a = f(m-y1+n-x1,m-y1,n-x1)\r\n    aa = f(x1+y1,x1,y1)\r\n    b = f(m-y2+n-x2,m-y2,n-x2)\r\n    bb = f(x2+y2,x2,y2)\r\n    c = f(y2-y1+x2-x1,y2-y1,x2-x1)\r\n    ans = (tot - a*aa - b*bb + c*aa*b)%p\r\n    print(ans)
# cook your dish here\nfor _ in range(int(input())):\n    n=int(input())\n    if n==1:\n        print("0")\n    else:\n        s=[]\n        for i in range(n):\n            s.append(str(i))\n        print(''.join(s))\n        p=1\n        for i in range(n-1):\n            s.pop(n-1)\n            s=[str(p)]+s\n            print(''.join(s))\n            p+=1\n
#for _ in range(int(input()):\n#n,m = map(int,input().split())\n#x = [int(w) for w in input().split()]\n#n = int(input())\n#x = [int(input()) for _ in range(n)]\n#for i in range(n):\n#dt = {} for i in x:dt[i] = dt.get(i,0)+1\n#dt = {k:v for k,v in sorted(x.items(), key=lambda i: i[1])}\n\nm,n = map(int,input().split())  # top,right,bottom,left\nx = []\nfor i in range(m):\n    x.append([])\n    for j in range(n):\n        clr = [w for w in input().split()]\n        x[i].append(clr)\n\nimport queue as Q                \ndp = [float('inf')]*m\nfor i in range(m):\n    dp[i] = [float('inf')]*n\ndp[m-1][n-1] = 0\npq = Q.PriorityQueue()\npq.put([dp[m-1][n-1],m-1,n-1])\nvisited = set()\nxx,yy = [-1,0,1,0],[0,1,0,-1] # top,right,bottom,left\nwhile not pq.empty():\n    pop = pq.get()\n    cx,cy = pop[1],pop[2]\n    if (cx,cy) not in visited:\n        visited.add((cx,cy))\n        for k in range(4):\n            nx,ny = cx+xx[k],cy+yy[k]\n            if 0<=nx<m and 0<=ny<n and (nx,ny) not in visited:\n                clr = x[cx][cy][k]\n                #print("*",nx,ny,"_",k,clr)\n                ind = x[nx][ny].index(clr)\n                cost = (k-(ind+2)%4)%4\n                #print(cost)\n                if dp[cx][cy]+cost < dp[nx][ny]:\n                    dp[nx][ny] = dp[cx][cy]+cost\n                    pq.put([dp[nx][ny],nx,ny])\n        #print("#############")\n#print(dp)\nprint(dp[0][0])
for _ in range(int(input())):\n s = input()\n c = 0\n for i in s:\n  if i.isalpha() and i.isupper():\n   c += 1\n print(c)\n
# cook your dish here\n# cook your dish here\nfor _ in range(int(input())) :\n n,k=map(int,input().split())\n #reading the string \n s=input()\n i,j=0,0\n q=0\n while(i<n and j<n) :\n  if(s[i]=='M') :\n   if(s[j]=='I') :\n    cnt=0\n    if(i>j) :\n     p=s[j:i]\n     cnt=p.count(':')\n    else :\n     p=s[i:j]\n     cnt=p.count(':')\n    t=k+1-abs(i-j)-cnt\n    if(t>0) :\n     q+=1\n     i+=1\n     j+=1\n    else:\n     if(i<j) :\n      i+=1\n     else:\n      j+=1\n   elif(s[j]=='X') :\n    j+=1\n    i=j\n   else:\n    j+=1\n  elif(s[i]=='X') :\n   i+=1\n   j=i\n  else:\n   i+=1\n print(q) 
cases = int(input())\nfor _ in range(cases):\n rows, cols = map(int, input().split())\n if (cols - 1) % 3 == 0 and (rows - 1) % 4 == 0: print('Vanya')\n elif (cols - 1) % 3 != 0 and (rows - 1) % 4 == 0: print('Tuzik')\n elif (cols - 1) % 3 == 0 and (rows - 1) % 4 != 0: print('Tuzik')\n else:\n  if (cols - 1) % 3 == 1 and (rows - 1) % 4 == 1: print('Vanya')\n  elif (cols - 1) % 3 == 2 and (rows - 1) % 4 == 2: print('Vanya')\n  else: print('Tuzik')
# cook your dish here\ntry:\n    X=list(map(int, input().split()))\nexcept:\n    X=[0,0]\nch=[]\nchnew=[]\npar={}\npar[1]=0\nfor i in range(X[0]+1):\n    ch.append([])\n    chnew.append([])\nfor i in range(X[0]-1):\n    Y=list(map(int, input().split()))\n    #par[Y[1]]=[Y[0],Y[2]]\n    ch[Y[0]].append([Y[1],Y[2]])\n    ch[Y[1]].append([Y[0],Y[2]])\ntre=[1]\nwhile(len(tre)):\n    cr=tre[-1]\n    tre=tre[:-1]\n    for i in ch[cr]:\n        chnew[cr].append(i)\n        par[i[0]]=[cr,i[1]]\n        tre.append(i[0])\n        for j in ch[i[0]]:\n            if(j[0]==cr):\n                ch[i[0]].remove(j)\n                break\nch=chnew\ndef goup(par,nd):\n    if(nd==1):\n        return 0\n    else:\n        p=par[nd]\n        ans=p[1]+goup(par,p[0])\n        return (max([ans,0]))\n\ndef godown(ch,nd):\n    ans=0\n    for i in ch[nd]:\n        ans=max([(i[1]+godown(ch,i[0])),ans])\n    return(ans)\n\nfor i in range(X[1]):\n    Z=list(map(int,input().split()))\n    r=Z[0]\n    s=Z[1]\n    nans=0\n    while(r!=s):\n        if(r>s):\n            nans=nans+par[r][1]\n            r=par[r][0]\n        else:\n            nans=nans+par[s][1]\n            s=par[s][0]\n    if((r==Z[0]) or (r==Z[1])):\n        if(Z[0]<Z[1]):\n            nans=nans+2*max(goup(par,Z[0]),godown(ch,Z[1]))\n        else:\n            nans=nans+2*max(goup(par,Z[1]),godown(ch,Z[0]))\n    else:\n        nans=nans+2*goup(par,r)\n    print(nans)
for _ in range(int(input())):\n    a,b,c,x,y,z = list(map(int,input().split()))\n    if a == 0 and b == 0 and c == 0 and x == 0 and y == 0 and z == 0:\n     print(0)\n     continue\n    ans = 0\n    if a == 0 and b == 0 and c == 0:\n     st = set((abs(x-a)%2,abs(y-b)%2,abs(z-c)%2))\n     if st == {0,1}:\n      ans = 1\n     else:\n      ans = 2\n    else:\n     if x == 0 and y == 0 and z == 0:\n      st = set((abs(x-a)%2,abs(y-b)%2,abs(z-c)%2))\n      if st == {0,1}:\n       ans = 1\n      else:\n       ans = 2\n     else:\n      st = set((abs(x-a)%2,abs(y-b)%2,abs(z-c)%2))\n      if st == {0,1}:\n       ans = 1 \n    print(ans)\n
for _ in range(int(input())):\n    string = input().rstrip()\n    start=(ord(string[0])-96)*100\n    sum=0\n    #print(start)\n    for i in range(len(string)):\n        sum+=start+(ord(string[i])-97)\n    print(sum%1000000007)
__author__ = 'Prateek'\n\nMOD = int(10**9+7)\n\ndef test():\n n,k=list(map(int,input().split()))\n l = k\n d =n-1\n ans = l-1\n ans = ans%MOD\n a = k-n\n term = (d+a)//d\n ll = (a%MOD - (((term-1)%MOD)*(d%MOD))%MOD)%MOD\n if ll < 0:\n  ll = (ll +MOD)%MOD\n m = ((term%MOD)*((a%MOD+ll%MOD)%MOD))%MOD\n m = (m*pow(2,MOD-2,MOD))%MOD\n ans += m\n ans = ans%MOD\n print(ans)\n\n\nif __author__ == 'Prateek':\n t = int(input())\n for _ in range(t):\n  test()\n
import sys\nimport math\n\ndef solution():\n T = int(input().strip())\n for _ in range(T):\n  x, k = list(map(float, input().strip().split(' ')))\n  original_x = x\n  if k == 1:\n   a = [float(input().strip())]\n   b = [float(input().strip())]\n  else:\n   a = list(map(float, input().strip().split(' ')))\n   b = list(map(float, input().strip().split(' ')))\n  for i in range(int(k)):\n   x = x + (a[i]/b[i])*(x)\n  percentage = ((x - original_x) / x)*100\n  print("%d"%(int(percentage)))\n\nsolution()
from math import sqrt\n\ndef isprime(n):\n    if (n % 2 == 0 and n > 2) or n == 1: return 0\n    else:\n        s = int(sqrt(n)) + 1\n        for i in range(3, s, 2):\n            if n % i == 0:\n                return 0\n        return 1\n\ndef find(N, K): \n    if (N < 2 * K): \n        return 0\n    if (K == 1): \n        return isprime(N) \n    if (K == 2): \n        if (N % 2 == 0): \n            return 1\n        return isprime(N - 2); \n    return 1\n\nfor _ in range(int(input())):\n    n, k = list(map(int, input().split()))\n    print(find(n, k))\n\n\n
# cook your dish here\nfor _ in range(int(input(''))):\n    n=int(input(''))\n    x=bin(n)\n    x=len(x)-2\n    if n==(2**(x-1)):\n        print(n)\n    else:\n        print(2**x)
# cook your dish here\nn=int(input())\nl=[int(i) for i in input().split()]\nxors=[]\nfor i in range(n):\n    for j in range(i+1,n):\n     xors.append([l[i]^l[j],(i,j)])\nxors.sort()\n\n#print(xors)\nupto=[0]*n \nfor i in range(len(xors)):\n    #a=xors[i][0]\n    b,c=xors[i][1][0],xors[i][1][1]\n    upto[c]=max(upto[c],upto[b]+1)\n \n#print(upto)\n \nprint(max(upto)+1)
# cook your dish here\nfrom operator import itemgetter\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    start=[]\n    end=[]\n    for i in range(n):\n        first, last = map (int, input().split())\n        start.append((first, i))\n        end.append((last, i))\n    score=[0]*n \n    start.sort(key=itemgetter(0))\n    end.sort(key=itemgetter(0), reverse=True)\n    for i in range(n-1):\n        score[start[i][1]]+=n-i-1\n        score[end[i][1]]+=n-i-1\n    print(' '.join([str(i) for i in score]))
def frequency(s,n):\n    f=[[0 for i in range(26)]for j in range(n+1)]\n    count=0\n    for i in range(n):\n        if s[i]!="#":\n            f[count][ord(s[i])-97]+=1\n        else:\n            count+=1\n            for j in range(26):\n                f[count][j]=f[count-1][j]\n    return (f,count)\n    \ndef solve(s):\n    n=len(s)\n    f,count=frequency(s,n)\n    if count<3:\n        return 0\n    ans=0\n    index=[]\n    for i in range(n-1,-1,-1):\n        if s[i]=="#":\n            index.append(i)\n    \n    for c in range(1,count-2+1):\n        if index[-2]==index[-1]+1 or index[-3]==index[-2]+1:\n            index.pop()\n            continue\n        left=max(f[c-1])\n        mid1=0\n        mid2=0\n        right=0\n        for j in range(26):\n            mid1=max(mid1,f[c][j]-f[c-1][j])\n            mid2=max(mid2,f[c+1][j]-f[c][j])\n            right=max(right,f[count][j]-f[c+1][j])\n        if left and mid1 and mid2 and right:\n            ans=max(ans,left+mid1+mid2+right)\n        index.pop()\n    return ans\n    \nfor _ in range(int(input())):\n    s=input()\n    ans=solve(s)\n    if ans:\n        print(ans+3)\n    else:\n        print(0)\n        \n        
# cook your dish here\nn=int(input())\nl=list(map(int,input().split()))\ntemp=[]\nfor item in l:\n    temp.append(item)\nif(n<=3):\n    print(sum(temp))\nelse:\n    for i in range(3,n):\n        temp[i]=l[i]+min(temp[i-1],temp[i-2],temp[i-3])\n    res=sum(l)-min(temp[n-1],temp[n-2],temp[n-3])\n    print(res)
ways=x=0\nval=10**9\nremi=((10**9)+7)\nt=int(input())\nfor i in range(t):\n n,k=list(map(int,input().split()))\n if t<=100 and n>=1 and k<=val:\n  x=(k-1)**(n-1)\n  ways=k*x\n  ways=ways%remi\n  print(ways)\n  x=ways=0\n else:\n  break
import sys\nt = int(sys.stdin.readline())\n\ndef identify(x, y):\n    rows[x][y] = '2'\n\n    r = 0\n    if x == 0:\n        r |= 1\n    elif rows[x-1][y] == '1':\n        r |= identify(x-1, y)\n    if x == 7:\n        r |= 4\n    elif rows[x+1][y] == '1':\n        r |= identify(x+1, y)\n    if y == 0:\n        r |= 2\n    elif rows[x][y-1] == '1':\n        r |= identify(x, y-1)\n    if y == 7:\n        r |= 8\n    elif rows[x][y+1] == '1':\n        r |= identify(x, y+1)\n    return r\n\nP = 21945\n\nwhile t:\n    t-=1\n    n = int(sys.stdin.readline())-3\n\n    rows = [list(sys.stdin.readline().strip()) for i in range(8)]\n    total = 0\n    for i in range(8):\n        for j in range(8):\n            if rows[i][j] == '1':\n                r = identify(i,j)\n                # print '\n'.join([''.join(ro) for ro in rows])\n                # print r\n                if n == 0:\n                    total += 1\n                    # print total\n                    continue\n                if r == 0:\n                    total += pow(2, 2*n, P)\n                elif r == 1 or r == 2 or r == 4 or r == 8:\n                    total += pow(2, 2*n-1, P)\n                    if r == 1 or r == 2:\n                        total += pow(2, n, P)\n                elif r == 5 or r == 10:\n                    total += pow(2, n, P)\n                elif r == 3 or r == 6 or r == 12 or r == 9:\n                    total += pow(2, 2*n-2, P)\n                    if r == 3:\n                        total += 3 + 2*pow(2, n-1, P) - 2\n                    elif r == 6 or r == 9:\n                        total += pow(2, n-1, P)\n                elif r == 15:\n                    total += 1\n                else:\n                    total += pow(2, n-1, P)\n                    if r == 11 or r == 7:\n                        total += 1\n                # print total\n    print(total % P)\n
# v = ["a","e","i","o","u"]\n# for _ in range(int(input())):\n#   n = int(input())\n#   a,b = [],[]\n#   for i in range(n):\n#       s = input()\n#       isa = True\n#       for j in range(1,len(s) - 1):\n#           if(s[j] in v):\n#               if(s[j - 1] not in v and s[j + 1] not in v):\n#                   isa = False\n#           else:\n#               if(s[j - 1] not in v or s[j + 1] not in v):\n#                   isa = False\n#           if(not isa):\n#               break\n#       if(s[0] not in v and s[1] not in v):\n#           isa = False\n#       if(s[-1] not in v and s[-2] not in v):\n#           isa = False\n#       if(isa):\n#           a.append(s)\n#       else:\n#           b.append(s)\n#   dicta,dictb = {},{}\n#   for i in a:\n#       freq = {}\n#       for j in i:\n#           if(j in freq):\n#               freq[j] += 1\n#           else:\n#               freq[j] = 1\n#       for j in freq:\n#           if(j not in dicta):\n#               dicta[j] = (1,freq[j])\n#           else:\n#               dicta[j] = (dicta[j][0] + 1,dicta[j][1] + freq[j])\n#   for i in b:\n#       freq = {}\n#       for j in i:\n#           if(j in freq):\n#               freq[j] += 1\n#           else:\n#               freq[j] = 1\n#       for j in freq:\n#           if(j not in dictb):\n#               dictb[j] = (1,freq[j])\n#           else:\n#               dictb[j] = (dictb[j][0] + 1,dictb[j][1] + freq[j])\n#   ans = 1\n#   for i in dicta:\n#       ans *= dicta[i][0]\n#   for i in dictb:\n#       ans /= dictb[i][0]\n#   x,y = 1,1\n#   for i in dictb:\n#       x *= dictb[i][1]\n#   for i in dicta:\n#       y *= dicta[i][1]\n#   alice,bob = len(a),len(b)\n#   for i in range(bob):\n#       while(alice > 0 and ans > 10**7):\n#           ans /= y\n#           alice -= 1\n#       ans *= x\n#       if(ans > 10**7 and alice == 0):\n#           break\n#   while(alice > 0):\n#       ans /= y\n#       if(ans < 1 and alice > 100):\n#           ans = 0\n#           break\n#       alice -= 1\n#   if(ans > 10**7):\n#       print("Infinity")\n#   else:\n#       print(ans)\n# #partailly correct [75 pts]\n#sys.stdin.readline() and sys.stdout.write() are faster I/O methods than input() and print()\nfrom sys import stdin\nz=['a','i','e','o','u']\nt=int(stdin.readline())\nwhile(t>0):\n t-=1\n n=int(stdin.readline())\n alice=[]\n bob=[]\n for j in range(n):\n  s=str(stdin.readline().strip("\n"))\n  # print(s)\n  isalice=True\n  for i in range(1,len(s)-1):\n   if(s[i] in z):\n    if(s[i-1] not in z and s[i+1] not in z):\n     isalice=False\n   else:\n    if(s[i-1] not in z or s[i+1] not in z):\n     isalice=False\n   if(not isalice):\n    break\n  if(s[0] not in z and s[1] not in z):\n   isalice=False\n  if(s[-1] not in z and s[-2] not in z):\n   isalice=False\n  if(isalice):\n   alice.append(s)\n  else:\n   bob.append(s)\n ali={}\n bo={}\n for i in alice:\n  d={}\n  for j in i:\n   if(j in d):\n    d[j]+=1\n   else:\n    d[j]=1\n  for j in d:\n   if j not in ali:\n    ali[j]=(1,d[j])\n   else:\n    ali[j]=(ali[j][0]+1,ali[j][1]+d[j])\n for i in bob:\n  d={}\n  for j in i:\n   if(j in d):\n    d[j]+=1\n   else:\n    d[j]=1\n  for j in d:\n   if j not in bo:\n    bo[j]=(1,d[j])\n   else:\n\n    bo[j]=(bo[j][0]+1,bo[j][1]+d[j])\n ans=1\n for i in ali:\n  ans*=ali[i][0]\n for i in bo:\n  ans=ans/bo[i][0]\n x=1\n y=1\n\n for i in bo:\n  x=x*bo[i][1]\n for i in ali:\n  y=y*ali[i][1]\n # print(x,y)\n alice=len(alice)\n bob=len(bob)\n for i in range(bob):\n  while(alice>0 and ans>10000000):\n   ans=ans/y\n   alice-=1\n  ans*=x\n  if(ans>10000000 and alice==0):\n   break\n while(alice>0):\n  ans=ans/y\n  if(ans<1 and alice>100):\n   ans=0\n   break\n  alice-=1\n if(ans>10000000):\n  print("Infinity")\n else:\n  print(ans)\n#AC\n
for j in range(int(input())):\n a=input()\n b=input()\n c,d=0,0\n a0=a.count("0")\n a1=a.count("1")\n if(a0==len(a) or a1==len(a)):\n  print("Unlucky Chef")\n else:\n  print("Lucky Chef")\n  for i in range(len(a)):\n   if(a[i]!=b[i]):\n    if(a[i]=="0"):\n     c+=1\n    else:\n     d+=1\n  print(max(c,d))
t=int(input())\nfor i in range(t):\n n,k=[int(i) for i in input().split()]\n l=input().split()\n for i in range(k):\n  if l.pop()=='H':\n   for ind,j in enumerate(l):\n    if j=='H':\n     l[ind]='T'\n    else:\n     l[ind]='H'\n print(sum([1 for i in l if i=='H']))
#cook your recipe\nfrom math import factorial\ntest_cases = int(input())\nfor _ in range(test_cases):\n   n = int(input())\n   sum1 = 0\n   final_sum = 0\n   num = list(map(int, input().split()))\n   rep_time = factorial(n - 1)\n   rep_count = dict()\n   for i in num:\n      if i in rep_count:\n         rep_count[i] +=1\n      else:\n         rep_count[i] =1\n   for j in rep_count:\n      if rep_count[j] ==1:\n         sum1 +=  j * factorial(n - rep_count[j])\n      else:\n         sum1 +=  j * factorial(n-1)/ factorial(n - rep_count[j])\n   \n   for k in range(n):\n      final_sum += sum1 * (10**k)\n\n   print(int(final_sum))
t = int(input())\nfor _ in range(t):\n    n = int(input())\n    for i in range(n):\n        for j in range(n):\n            if i>=j:\n                print(int((i+1)*(i+2)/2)-j,end='')\n        print()\n
n = int(input())\nx = [int(i) for i in input().split()]\nm = int(input())\nfor i in range(m):\n    a,b = map(int,input().split())\n    a -= 1\n    t = b-1\n    t1 = x[a]-b\n    if a-1>=0:\n        x[a-1] += t\n    if a+1<n:\n        x[a+1] += t1\n    x[a] = 0\nfor i in x:\n    print(i)
for t in range(int(input())):\n n = int(input())\n a = sorted(map(int,input().split()))\n ans = 1\n for i in range(n):\n  ans *= (a[i]-i)\n  ans %= (10**9+7)\n  if (ans == 0):\n   break\n print(ans) 
n,m,lk = list(map(int,input().split()))\nsp = [int(i)-1 for i in input().split()]\ndp = []\nfor i in range(n):\n dp += [[0]*n]\nfor i in range(n):\n for j in range(n):\n  if(i!=j):\n   dp[i][j]=10**18\nfor _ in range(m):\n x,y,z = list(map(int,input().split()))\n dp[x-1][y-1]=z\n dp[y-1][x-1]=z\nfor k in range(n):\n for i in range(n):\n  for j in range(n):\n   if(dp[i][j]>dp[i][k]+dp[k][j]):\n    dp[i][j]=dp[i][k]+dp[k][j]\ndist = 10**18\nfor i in range(lk):\n for j in range(i+1,lk):\n  dist = min(dist,dp[sp[i]][sp[j]])\nprint(dist)\n
t=int(input())\nwhile t>0 :\n	a=int(input())\n	b=int(input())\n	l=int(input())\n	x=0\n	y=0\n	z=0\n	a1=0\n	b1=0\n	c1=0\n	while(a//10!=0 or a%10!=0):\n		a1+=(a%10+((a//10)%10)*7+((a//100)%10)*49+((a//1000)%10)*343+((a//10000)%10)*2401+((a//100000)%10)*16807+((a//1000000)%10)*117649+((a//10000000)%10)*823543+((a//100000000)%10)*5764801+((a//1000000000)%10)*40353607)*(282475249**x)\n		x+=1\n		a//=10000000000\n \n	while (b//10!=0 or b%10!=0):\n		b1+=(b%10+((b//10)%10)*7+((b//100)%10)*49+((b//1000)%10)*343+((b//10000)%10)*2401+((b//100000)%10)*16807+((b//1000000)%10)*117649+((b//10000000)%10)*823543+((b//100000000)%10)*5764801+((b//1000000000)%10)*40353607)*(282475249**y)\n		y+=1\n		b//=10000000000\n	c=(a1//b1)%(7**l)\n	while z<l:\n		c1+=(c%7+((c//7)%7)*10+((c//49)%7)*100+((c//343)%7)*1000+((c//2401)%7)*10000+((c//16807)%7)*100000+((c//117649)%7)*1000000+((c//823543)%7)*10000000+((c//5764801)%7)*100000000+((c//40353607)%7)*1000000000)*(10000000000**(z//10))\n		c//=282475249\n		z+=10\n	print(c1)\n	t-=1
# cook your dish here\ndef solve(edges,ans):\n n = len(edges)\n visited = set()\n parents = [-1]*(n+1)\n dp = [0]*(n+1)\n stack = [1]\n w = float('inf')\n x = -1\n while stack:\n  node = stack[-1]\n  if node not in visited:\n   count = 0\n   for kid in edges[node]:\n    if parents[kid] == -1:\n     if kid != 1:\n      parents[kid] = node\n    else:\n     if kid != parents[node]:\n      if kid in visited:\n       count += 1\n      else:\n       stack.append(kid)\n\n   if node == 1:\n    count -= 1\n   if count == len(edges[node])-1:\n    stack.pop()\n    visited.add(node)\n    max_val = 0\n    for kid in edges[node]:\n     dp[node] += dp[kid]\n     max_val = max(max_val,dp[kid])\n\n    dp[node] += 1\n\n    max_val = max(max_val,n-dp[node])\n    if max_val < w:\n     w = max_val\n     x = node\n    elif max_val == w:\n     x = min(x,node)\n\n ans.append(str(x)+' '+str(w))\n  \ndef main():\n t = int(input())\n ans = []\n for i in range(t):\n  n = int(input())\n  edges = {}\n  for j in range(1,n+1):\n   edges[j] = []\n\n  for j in range(n-1):\n   x,y = list(map(int,input().split()))\n   edges[x].append(y)\n   edges[y].append(x)\n\n  solve(edges,ans)\n\n print('\n'.join(ans))\n\nmain()\n
# cook your dish here\ntest_cases = int(input())\nfor i in range(test_cases):\n no_of_elements = int(input())\n sequence = list(map(int, input().split()))\n d1 = sequence[1] - sequence[0]\n d2 = sequence[2] - sequence[1]\n d3 = (sequence[3] - sequence[0])/3\n d4 = (sequence[3] - sequence[1])/2\n d5 = (sequence[2] - sequence[0])/2\n\n if (d2 == d4):\n  d = d2\n\n elif(d3 == d5):\n  d = d3\n\n elif(d1 == d3):\n  d = d1\n\n elif(d1 == d5):\n  d = d1\n\n if (d == d1):\n  for i in range(no_of_elements):\n   sequence[i] = int(sequence[0] + i*d)\n else:\n  for i in range(no_of_elements):\n   sequence[i] = int(sequence[-1] - ((no_of_elements - i - 1)*d))\n\n for i in sequence:\n  print(i, end=" ")\n\n print('\n')\n\n\n
import math\r\ndef prime(aa):\r\n	f=0\r\n	for y in ar:\r\n		if aa%y==0:\r\n				return 0\r\n	return 1\r\nar=[]\r\nar.append(2)\r\npc=3\r\nte=int(input())\r\nfor _ in range(te):\r\n	a=int(input())\r\n	f=0\r\n	c=0\r\n	add=0\r\n	for x in ar:\r\n		try:\r\n			add=add+ar[x-1]\r\n		except:\r\n			while True:\r\n				if prime(pc)==1:\r\n					ar.append(pc)\r\n					if x<=len(ar):\r\n						break\r\n				pc+=1\r\n			pc+=1\r\n			add=add+ar[x-1]\r\n		c+=1\r\n		if c==a:\r\n			break\r\n	print(add)\r\n
# cook your dish here\ndef GCD(x, y):  \n   while y: \n    x, y = y, x % y  \n   return x \n\ndef LCM(x, y):\n   lcm = (x*y)//GCD(x,y)\n   return lcm\n\nt = int(input())\nwhile t>0:\n    x,y = list(map(int,input().split()))\n    print(GCD(x,y),LCM(x,y))  \n    t -=1\n
n = int(input())\nfor i in range(n):\n count = 0\n k = input()\n x = list(k)\n kk = input()\n y = list(kk)\n for j in y:\n  for jj in x:\n   if(j==jj):\n    count = count+1\n    break\n print(count)
for _ in range(int(input())):\n    n = int(input())\n    k = int(input())\n    if k%n==0:\n        print("YES")\n    else:\n        print("NO")\n
eps=1e-8\nt=int(input())\nfor ii in range(t):\n    n=int(input())\n    l=[int(i) for i in input().split() ]\n    b=[int(i) for i in input().split() ]\n    v=[int(i) for i in input().split() ]\n    c=[int(i) for i in input().split() ]\n    greatest_time=l[0]/v[0]\n    for i in range(1,n):\n        if v[i]>0:\n            greatest_time=min(greatest_time,(l[i]-b[i])/v[i])\n        elif v[i]<0:\n            greatest_time=min(greatest_time,-b[i]/v[i])\n    p = sum((b[i] - c[i]) ** 2 for i in range(n))\n    q = sum(2 * (b[i] - c[i]) * v[i] for i in range(n))\n    r = sum(vi ** 2 for vi in v)\n    func = lambda t: p/t/t + q/t + r\n    #ternary search\n    \n    def ternsearch():\n    \n        if b==c:\n            return(0)\n        \n        lo,hi=0,greatest_time\n        while hi-lo>eps:\n                d=(hi-lo)/3\n                m1=lo+d\n                m2=m1+d\n                if func(m1)<=func(m2):\n                    hi=m2\n                else:\n                    lo=m1\n                #print(hi,lo)\n                #print(func(lo)**(0.5))\n        return max(0,func(lo))**(0.5)\n    ans=ternsearch()\n    print('%.12f' % (ans,))\n    \n    \n\n                \n                \n\n
# cook your dish here\ntry:\n \n T = int(input())\n\n for i in range(T):\n  n = int(input())\n  s = input()\n  arr = [int(i) for i in input().strip().split(" ")]\n  res = 1\n  result = 0\n\n  for j in range(n-7):\n   res = 1\n   res1= 0\n   s1 = s[j:j+8]\n   for i in range(8):\n    if s1[i] == 'D':\n     res = res*2\n     res1 += arr[i]\n\n    elif s1[i] == 'T':\n     res = res*3\n     res1 = res1 + arr[i]\n    elif s1[i] == 'd':\n     res1 = res1 + arr[i]*2\n    elif s1[i] == 't':\n     res1 += arr[i]*3\n    else:\n     res1 += arr[i]\n   res = res*res1\n   result = max(res,result)\n  print(result)\nexcept EOFError:\n pass\n\n    \n    \n    \n \n  \n \n
# cook your dish here\n# cook your dish here\nfor _ in range(int(input())):\n n,m=list(map(int,input().split()))\n atomlist = ['']*n\n for k in range(m):\n  s=[]\n  s.extend(input().split()[1:])\n  #print(s)\n  for w in range(n):\n   if str(w) in s:\n    atomlist[w]+="1"\n   else:\n    atomlist[w]+="0"\n  #print(atomlist)\n print(len(set(atomlist)))\n
# cook your dish here\ndef solve():\n    n=int(input())\n    i=0\n    while i<n-1:\n        if i==0:\n            print("*",end="")\n        else:\n            print("*",end="")\n            for k in range(i-1):\n                print(" ",end="")\n            print("*",end="")\n        print()    \n        i+=1    \n    for i in range(n):\n        print("*",end="")\n    print()    \n\nt=int(input())\ni=0\nwhile(i<t):\n    solve()\n    \n    i+=1
for i in range(eval(input())):\n n,k=input().strip().split()\n n=int(n)\n k=int(k)\n print(int( ((n-k)&(int((k-1)/2)))==0))
# cook your dish here\ndef check(a,b,c):\n    if (a==0) or (b==0) or (c==0):\n        return "NO"\n    else:\n        i=3\n        while(i>0):\n            if (a*a)==(b*b)+(c*c):\n                return "YES"\n            else:\n                t=a\n                a=b\n                b=c\n                c=t\n                i-=1\n    return "NO"\ntry:\n    for _ in range(int(input())):\n        a,b,c=map(int,input().split())\n        print(check(a,b,c))\nexcept:\n    print(e)\n    pass
# cook your dish here\ntry:\n d1,v1,d2,v2,p=map(int, input().split())\n total=0\n while p>0:\n  total+=1\n  if total>=d1:\n   p=p-v1\n  if total>=d2:\n   p=p-v2\n print(total) \nexcept:\n pass
# cook your dish here\nT=int(input())\nfor _ in range(T):\n n=int(input())\n arr=list(map(int,input().split()))\n left=[-1 for i in range(n)]\n right=[-1 for i in range(n)]\n min1=float("inf")\n for i in range(n):\n  min1=min(arr[i],min1+1)\n  left[i]=min1\n min1=float("inf")\n for i in range(n-1,-1,-1):\n  min1=min(arr[i],min1+1)\n  right[i]=min1\n for i in range(n):\n  print(min(left[i],right[i]),end=" ")\n print("",end="\n")
# cook your dish here\nimport copy\nfor _ in range(int(input())):\n    k=int(input())\n    c=[]\n    d=[]\n    start=0\n\n    while True:\n        c=[]\n        for i in range(start):\n            c.append(" ")\n        for i in range(start,k+1):\n            c.append(str(i))\n        start+=1\n        d.append(c)\n\n        if start>k:\n            break\n\n    e=copy.copy(d[1:])\n    d.reverse()\n    d=d+e\n    ##print(d)\n    for i in range(len(d)):\n        print(''.join(d[i]))\n\n\n
# Python3 program to find XNOR\n# of two numbers\nimport math\n\n\ndef swap(a, b):\n temp = a\n a = b\n b = temp\n\n\n# log(n) solution\ndef xnor(a, b):\n # Make sure a is larger\n if (a < b):\n  swap(a, b)\n\n if (a == 0 and b == 0):\n  return 1;\n\n # for last bit of a\n a_rem = 0\n\n # for last bit of b\n b_rem = 0\n\n # counter for count bit and\n # set bit in xnor num\n count = 0\n\n # for make new xnor number\n xnornum = 0\n\n # for set bits in new xnor\n # number\n while (a != 0):\n\n  # get last bit of a\n  a_rem = a & 1\n\n  # get last bit of b\n  b_rem = b & 1\n\n  # Check if current two\n  # bits are same\n  if (a_rem == b_rem):\n   xnornum |= (1 << count)\n\n  # counter for count bit\n  count = count + 1\n\n  a = a >> 1\n  b = b >> 1\n\n return xnornum;\n\n\nt= int(input())\nfor o in range(t):\n a,b,n=map(int,input().split())\n c=a^b\n x=bin(c)\n x=x.split("b")\n x=x[1]\n x=len(x)\n d=xnor(a,b)\n p=[a,b,c];r=[a,b,d]\n k=n%3-1\n if p[k]>r[k]:\n  print(p[k])\n else :\n  print(r[k])
# cook your dish here\nimport re\nt=int(input())\nwhile(t>0):\n s=list(input().split(' '))\n if("not" in s):\n  print("Real Fancy")\n else:\n  print("regularly fancy")\n t=t-1
import sys\n\nn = int(sys.stdin.readline())\n\nfor _ in range(n):\n p1, p2, m = list(map(int, sys.stdin.readline().split()))\n\n l = min(p1, p2)\n\n #while(m > 0 and l > 0):\n #    k = min(l, m)\n #    l -= k\n #    m -= 1\n\n q = min(p1, p2)\n d = min((m * (m + 1)) / 2, q)\n\n print(p1 - d + p2 - d)
# cook your dish here\nfrom sys import stdin\nn, m = map(int,stdin.readline().split())\nforest=[]\nmatrix=[]\nfor _ in range(n):\n forest.append(list(map(int,stdin.readline().split())))\n matrix.append([0]*m)\nmatrix[0][0]=forest[0][0]\nfor j in range(1,m):\n matrix[0][j]=matrix[0][j-1]+forest[0][j]\nfor i in range(1,n):\n matrix[i][0]=matrix[i-1][0]+forest[i][0]\nfor i in range(1,n):\n for j in range(1,m):\n  matrix[i][j]=matrix[i-1][j]+matrix[i][j-1]-matrix[i-1][j-1]+forest[i][j]\nc=int(input())\nfor _ in range(c):\n x1, y1, x2, y2 = map(int,stdin.readline().split())\n x1-=1 \n y1-=1 \n x2-=1 \n y2-=1 \n appo=0\n if x1>0:\n  appo+=matrix[x1-1][y2]\n if y1>0:\n  appo+=matrix[x2][y1-1]\n if x1>0 and y1>0:\n  appo-=matrix[x1-1][y1-1]\n print(matrix[x2][y2]-appo)
from math import *\nt=int(input())\nfor i in range(t):\n m,b=input().split()\n m=int(m)\n b=int(b)\n print(2*gcd(m,b))
# cook your dish here\ntry:\n for t in range(int(input())):\n  n=int(input())\n  ans=n*n*n+((n-1)**2)\n  if ans<=10**9+7:\n   print(ans)\n  else:\n   print(ans)%(10**9+7)\nexcept:\n pass
for _ in range(int(input())):\n	n = int(input())\n	num = ""\n	val = 1\n	for i in range(n):\n		num += str(val)\n		if val == 1:\n			val = 0\n		else:\n			val = 1\n	for i in range(n):\n		print(num)\n		\n	\n
for _ in range(int(input())):\n length = int(input())\n S = input()\n R = input()\n if S.count("1") == R.count("1"):\n  print("YES")\n else:\n  print("NO")
"""\nCode chef problem DESTCELL, Destroy Cells\n"""\n\n\ndef find_destroyed_cells(cell_advance, n, m, k):\n row = 1\n col = 1\n destroyed_cells = {(1, 1)}\n while True:\n  row, col = cell_advance(row, col, n, m, k)\n  if row <= n and col <= m:\n   destroyed_cells.add((row, col))\n  else:\n   break\n return destroyed_cells\n\n\ndef cell_advance_hero1(row, col, n, m, k):\n return row + (col + k) // m, (col + k) % m + 1\n\n\ndef cell_advance_hero2(row, col, n, m, k):\n return (row + k) % n + 1, col + (row + k)//n\n\n\ndef main():\n t = int(input())\n for _ in range(t):\n  n, m = [int(s) for s in input().split(' ')]\n  counts = []\n  for k in range(n*m):\n   cells_h1 = find_destroyed_cells(cell_advance_hero1, n, m, k)\n   cells_h2 = find_destroyed_cells(cell_advance_hero2, n, m, k)\n\n   destroyed = len(cells_h1) + len(cells_h2) - len(cells_h1 & cells_h2)\n   counts.append(destroyed)\n  print(' '.join([str(c) for c in counts]))\n\n\nmain()\n
r = 1000000007\nt = int(input())\nfor i in range(t):\n n = int(input())\n print(pow(3,n,r) + pow(-1,n)*3)\n \n
fact = []\nfact.append(1)\nfor i in range(1,100001):\n fact.append((i*fact[i-1])%1000000007)\n \ndef power(a,b,p):\n x=1\n y=a\n while(b>0):\n  if(b%2 == 1):\n   x=(x*y)\n   if(x>p):\n    x=x%p\n  y=(y*y)\n  if(y>p):\n   y=y%p\n  b=b/2\n \n return x\n \ndef inverse(N,p):\n return power(N,p-2,p)\n \ndef combination(N,R,p):\n return (fact[N]*((inverse(fact[R],p)*inverse(fact[N-R],p))%p))%p\n \nT = int(input())\n \nfor i in range(T):\n N,K = [int(y) for y in input().split()]\n A = [int(arr) for arr in input().split()]\n numZ = 0;\n answer = 0;\n p = 1000000007\n for j in range(len(A)):\n  if(A[j] == 0):\n   numZ = numZ + 1\n N = N - numZ\n if(numZ > 0):\n  if(N > K):\n   temp = K;\n   while(temp >= 0):\n    answer = answer + combination(N,temp,p)\n    temp = temp - 1\n  else:\n   temp = N\n   while(temp >= 0):\n    answer = answer + combination(N,temp,p)\n    temp = temp - 1\n else:\n  if(N > K):\n   temp = K;\n   while(temp >= 0):\n    answer = answer + combination(N,temp,p)\n    temp = temp - 2\n  else:\n   temp = N\n   while(temp >= 0):\n    answer = answer + combination(N,temp,p)\n    temp = temp - 2\n print(answer%1000000007)
x=int(input())\nfor a in range(x):\n n=int(input())\n L=[str(n)]\n c=1\n while(len(L)!=n):\n  L.append(str(n+c))\n  if len(L)==n:\n   break\n  L.append(str(n-c))\n\n  c+=1\n\n a=" ".join(L)\n\n print(a)\n
t = int(input())\n\ndef conv(n):\n    k = bin(n)\n    k = k[2:]\n    z = len(k)\n    c = '1'*z\n    if c == k:\n     return False\n\ndef find(n):\n\n    x = bin(n)[2:]\n    str = ''\n    for i in x[::-1]:\n     if i == '0':\n      str+='1'\n      break\n     else:\n      str+='0'\n\n    return int(str[::-1],2)\n\nfor i in range(t):\n\n    n = int(input())
n = int(input())\nfor index in range(0, n):\n a, b = list(map(str, input().split()))\n a = int(a[::-1])\n b = int(b[::-1])\n a = str(a + b)\n a = int(a[::-1])\n print(a)
#import set\nt = eval(input())  \nwhile(t):\n    s = input()\n    set1 = set()\n    j = 0\n    for i in s[:-1]:\n        a = s[j:j+2]\n        set1.add(a)\n        j = j + 1\n    print(str(len(set1)) + '\n')\n    t= t-1\n \n
# Problem: http://www.codechef.com/JULY09/submit/CUBESUM/ \n# Author: Susam Pal\n\ndef computeA():\n X, Y, Z = [int(x) for x in input().split()]\n B = []\n for x in range(X):\n  B.append([])\n  for y in range(Y):\n   B[-1].append([int(t) for t in input().split()])\n   for z in range(Z):\n    result = B[x][y][z]\n    if x:\n     result -= B[x - 1][y][z]\n     if y:\n      result += B[x - 1][y - 1][z]\n      if z:\n       result -= B[x - 1][y - 1][z - 1]\n       \n    if y:\n     result -= B[x][y - 1][z]\n     if z:\n      result += B[x][y - 1][z - 1]\n    if z:\n     result -= B[x][y][z - 1]\n     if x:\n      result += B[x - 1][y][z - 1]\n    print(result, end=' ')\n   print()\n\ntest_cases = int(input())\nfor i in range(test_cases):\n computeA()\n
import sys\nsys.setrecursionlimit(1000000)\n\nmod = 10**9 + 7\nts = int(input())\nwhile ts > 0:\n n,q = list(map(int,input().split()))\n ncc = n-1\n par = [i for i in range(n)]\n rank = [1]*n\n xor = [0]*n\n flag = 1\n\n def find(a):\n  if par[a] == a:\n   return a\n  else:\n   temp = find(par[a])\n   xor[a]^=xor[par[a]]\n   par[a] = temp\n   return temp\n\n def union(a,b): \n  a,b = find(a),find(b)\n  if a ==b:\n   return \n  if rank[a] > rank[b]:\n   par[b] = a\n\n   rank[a]+=rank[b]\n  elif rank[a] < rank[b]:\n   par[a] = b\n   rank[b]+=rank[a]\n  else:\n   par[b] = a\n   rank[a]+=rank[b]\n  par[b] =a\n\n for _ in range(q):\n  \n  a,b,x = list(map(int,input().split()))\n  a-=1\n  b-=1\n  if flag == -1:\n   continue\n  para = find(a)\n  parb = find(b)\n\n  if para == parb and xor[a] ^ xor[b] != x:\n   flag = -1 \n   continue\n   # print("no")\n\n  if para != parb:\n   if rank[para] < rank[parb]:\n    xor[para] = xor[a] ^ xor[b] ^ x\n    par[para] = parb\n    rank[parb]+=rank[para]\n   else:\n    xor[parb] = xor[a] ^ xor[b] ^ x\n    par[parb] = para\n    rank[para]+=rank[parb]\n   ncc-=1\n   \n if flag != -1:\n  print("yes")\n else:\n  print("no")\n  \n ts-=1
for _ in range(int(input())):\n n=int(input())\n s=input()\n d={}\n for j in s:\n  if j not in d:\n   d[j]=1\n  else:\n   d[j]+=1\n f=0\n for j in d:\n  if(d[j]%2==1):\n   f=f+1\n if((n//2)%2==0 and f==0):\n  print("YES")\n  continue\n if((n//2)%2==1 and f<=2 and f%2==0):\n  print("YES")\n  continue\n print("NO")
t=int(input())\r\nfor _ in range(t):\r\n    size=int(input())\r\n    li=list(map(int,input().split()))\r\n    c = 0\r\n    for i in li:\r\n        if(i >=len(li)/2):\r\n            c += 1\r\n    print(c)\r\n
# cook your dish here\nimport sys\nimport math\nfrom collections import Counter\nfrom collections import OrderedDict \ndef inputt():\n    return sys.stdin.readline().strip()\ndef printt(n):\n    sys.stdout.write(str(n)+'\n')\ndef listt():\n    return [int(i) for i in inputt().split()]\ndef gcd(a,b): \n   return math.gcd(a,b) \n \ndef lcm(a,b): \n    return (a*b) / gcd(a,b) \nfrom collections import defaultdict   \n\ndef find_sub_string(str): \n    str_len = len(str) \n      \n    # Count all distinct characters. \n    dist_count_char = len(set([x for x in str])) \n  \n    ctr, start_pos, start_pos_index, min_len = 0, 0, -1, 9999999999\n    curr_count = defaultdict(lambda: 0) \n    for i in range(str_len): \n        curr_count[str[i]] += 1\n \n        if curr_count[str[i]] == 1: \n            ctr += 1\n  \n        if ctr == dist_count_char: \n            while curr_count[str[start_pos]] > 1: \n                if curr_count[str[start_pos]] > 1: \n                    curr_count[str[start_pos]] -= 1\n                start_pos += 1\n  \n            len_window = i - start_pos + 1\n            if min_len > len_window: \n                min_len = len_window \n                start_pos_index = start_pos \n    return str[start_pos_index: start_pos_index + min_len]\nt= int(inputt())\nfor _ in range(t):\n    j=[]\n    str1 =inputt()\n    s=find_sub_string(str1) \n    for i in s:\n        j.append(abs(97-ord(i))+1)\n    st = [str(i) for i in j]\n    print(''.join(st))     \n\n\n
# cook your dish here\n \nt = int(input())\n\nwhile t:\n m = int(input())\n print(int(m * (m + 1) * (2 * m + 1) / 6))\n \n \n t -= 1
# cook your dish here\nimport math\nT = int(input())\nfor _ in range(T):\n N, A, K = map(int, input().split(" "))\n total = (N-2) * 180\n diffT = total - N*A\n diffN = sum(range(1,N))\n r = (A*diffN+(K-1)*diffT)\n \n d = math.gcd(r, diffN)\n while d > 1:\n  r//=d\n  diffN//=d\n  d = math.gcd(r, diffN)\n print(r, diffN)
import sys\r\nfrom collections import defaultdict\r\ninput = sys.stdin.readline\r\nsys.setrecursionlimit(1000000)\r\n\r\narr=[int(x) for x in input().split()]\r\n\r\nif arr[0]==1:\r\n    print(0)\r\n    return\r\n\r\np=[None]\r\nfor i in range(1,arr[0]+1):\r\n    p.append(arr[i])\r\n    \r\na=[None]\r\nfor i in range(arr[0]+1,2*arr[0]+1):\r\n    a.append(arr[i])\r\n\r\ngraph=defaultdict(list)\r\n\r\nn=len(a)-1\r\nfor i in range(1,n+1):\r\n    if a[i]==-1:\r\n        source=i\r\n        continue\r\n    graph[a[i]].append((i,(p[a[i]]-p[i])))\r\n\r\ndef func(node):\r\n    nonlocal res\r\n    \r\n    if len(graph[node])==0:\r\n        return -10**9\r\n    \r\n    curr=-10**9\r\n    for child in graph[node]:\r\n        x=max(child[1],(func(child[0])+child[1]))\r\n        curr=max(curr,x)\r\n        res=max(curr,res)\r\n    \r\n    return curr    \r\n\r\nres=-10**9\r\ncurr=func(source)\r\nprint(res)        \r\n        \r\n        \r\n        \r\n
# cook your dish here\na = int(input())\nfor i in range(a):\n n = int(input())\n if n%2==0:\n  print('NO')\n else:\n  print('YES')\n  for i1 in range(n):\n   li = [0]*n\n   b = str()\n   for i2 in range((n-1)//2):\n    li[(i1+i2+1)%n]+=1\n   for i3 in range(len(li)):\n    b+=str(li[i3])\n   print(b)
def f(n):\n\n s = list(map(int, input().split()))\n low = []\n high = []\n\n for i in range(n - 1):\n  low.append(min(s[i], s[i+1]))\n  high.append(max(s[i], s[i+1]))\n low.sort()\n high.sort()\n curr = mx = 0\n i = j = 0\n n -= 1\n while i < n and j < n:\n  if low[i] < high[j]:\n   i += 1\n   curr += 1\n  else:\n   j += 1\n   curr -= 1\n  mx = max(mx, curr)\n\n return mx \n \nn = int(input())\nprint(f(n))
for _ in range(int(input())):\n m=int(input())\n n=int(input())\n o=int(input())\n ans=4*(m+n+o)-24\n if(ans <= 0):\n  print('0')\n else:\n  print(ans)\n
# cook your dish here\nfor a0 in range(int(input())):\n    n = int(input())\n    l = []\n    for i in range(1,n+1):\n        l.append(i)\n    \n    for j in range(n):\n        s = ""\n        for k in l:\n            s+=str(k)\n        print(s)\n        x = l[0]\n        l.pop(0)\n        l.append(x)\n
class Dsu:\n    def __init__(self, v, s):\n        self.par = s\n        self.v = v\n        self.dr = [1] * v\n        self.zero = [False] * v\n        self.speed = []\n        for i in range(v):\n            self.speed.append([])\n            self.speed[i].append(i)\n\n    def find(self, i):\n    #     if parent[i] == -1:\n    #         return i\n    #     else: return self.find_parent(parent, parent[i])\n        if i != self.par[i][0]:\n            org = self.par[i][0]\n            self.par[i][0] = self.find(self.par[i][0])\n            if self.zero[i] or self.zero[self.par[i][0]] or self.zero[org]:\n                self.zero[i] = self.zero[self.par[i][0]] = self.zero[org] = True\n            if org != self.par[i][0]:\n                self.speed[self.par[i][0]].append(i)\n        return self.par[i][0]\n\n    def union(self, x, y):\n        # def union(self, parent, x, y):\n        #     x_set = self.find_parent(parent, x)\n        #     y_set = self.find_parent(parent, y)\n        #     parent[x_set] = y_set\n        self.rx = self.find(x)\n        self.ry = self.find(y)\n        self.sign = -self.dr[x] * self.dr[y]\n        if self.rx != self.ry:\n            if (self.par[self.rx][1]<self.par[self.ry][1]):\n                mx=self.ry\n                mn=self.rx\n            if (self.par[self.rx][1]>self.par[self.ry][1]):\n                mx=self.rx\n                mn=self.ry\n            if self.par[self.rx][1] != self.par[self.ry][1]:\n                self.par[mn][0] = mx\n                if self.zero[mn] or self.zero[mx] or self.zero[x] or self.zero[y]:\n                    self.zero[mn] = self.zero[mx] = self.zero[x] = self.zero[y] = True\n                else:\n                    for i in range(len(self.speed[mn])):\n                        self.dr[self.speed[mn][i]] *= self.sign\n                        org = self.par[self.speed[mn][i]][0]\n                        if org != mx:\n                            self.par[self.speed[mn][i]][0] = mx\n                            self.speed[mx].append(self.speed[mn][i])\n                self.speed[mx].append(mn)\n\n            else:\n                self.par[self.ry][0] = self.rx\n                self.par[self.rx][1] += 1\n                if self.zero[self.rx] or self.zero[self.ry] or self.zero[x] or self.zero[y]:\n                    self.zero[self.rx] = self.zero[self.ry] = self.zero[x] = self.zero[y] = True\n                else:\n                    for i in range(len(self.speed[self.ry])):\n                        self.dr[self.speed[self.ry][i]] *= self.sign\n                        org = self.par[self.speed[self.ry][i]][0]\n                        if org != self.rx:\n                            self.par[self.speed[self.ry][i]][0] = self.rx\n                            self.speed[self.rx].append(self.speed[self.ry][i])\n                self.speed[self.rx].append(self.ry)\n        else:\n            return\n\n\ndef optwo(x, y, D):\n    if (D.find(x) == D.find(y) and D.dr[x] == D.dr[y]):\n            D.zero[x] = D.zero[y] = True\n    D.union(x, y)\n\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    else:\n        return gcd(b % a, a)\n\n\ndef opthree(x, y, v, D):\n    if (D.find(x) != D.find(y)) or (D.zero[D.par[y][0]]):\n        print(0)\n    else:\n        g = gcd(v * speed[x], speed[y])\n        flag=(D.dr[x] * D.dr[y])//abs(D.dr[x] * D.dr[y])\n        print(str(flag * v * speed[x] // g) + "/" + str(speed[y] // g))\n\n\nn, M = map(int, input().split())\nspeed = list(map(int, input().split()))\ns = []\nfor i in range(n):\n    s.append([i, 0])\nD = Dsu(n, s)\nfor i in range(M):\n    T = list(map(int, input().split()))\n    if (T[0] == 1):\n        speed[T[1] - 1] = T[2]\n    elif (T[0] == 2):\n        optwo(T[1] - 1, T[2] - 1, D)\n    elif (T[0] == 3):\n        opthree(T[1] - 1, T[2] - 1, T[3], D)\n
for _ in range(eval(input())):\n s = input()\n ans = 0\n for i in s:\n  if i.isdigit():\n   ans += int(i)\n print(ans) 
for _ in range(int(input())):\n n = int(input())\n arr = list(map(int,input().split()))\n\n if n<=62:\n  st = set()\n\n  for i in range(n):\n   curr = 0\n   for j in range(i,n):\n    curr = curr|arr[j]\n\n    st.add(curr)\n  \n  if len(st)==n*(n+1)//2:\n   print("YES")\n  else:\n   print("NO")\n   \n else:\n  print("NO")
import sys\nt=int(input())\nx=sys.stdin.readlines()\nl=[]\nfor s in x:\n    s=s.replace(".","")\n    s=s.replace("'","")\n    s=s.replace(",","")\n    s=s.replace(":","")\n    s=s.replace(";","")\n    lst=[str(i) for i in s.split()]\n    for j in lst:\n        l.append(j)\nm=[]\nfor y in l:\n    z=y.lower()\n    m.append(z)\nn=[]\nfor  k in m:\n    if(k in n):\n        continue\n    else:\n        n.append(k)\nprint(len(n))\nh=sorted(n)\nfor j in h:\n    print(j)
# cook your dish here\nt=int(input())\nMOD=1000000007\ndef mod(n, m=MOD):\n n%=m\n while n<0: n+=m\n return n\n\ndef power(n, p):\n res=1\n while p:\n  if p%2: res=mod(res*n)\n  p//=2\n  n=mod(n*n)\n return res\n\nwhile t:\n ma=input().split()\n x=int(ma[0])\n y=int(ma[1])\n s=int(ma[2])\n ma=input().split()\n u=int(ma[0])\n v=int(ma[1])\n if s%x==0 and ((s // x) & ((s // x) - 1) == 0):\n  inv=power(u, MOD-2)\n  print(mod(mod(mod(s//x)*v)*inv))\n else:\n  inv=power(v-u, MOD-2)\n  print(mod(mod(mod(s//y)*v)*inv))\n t-=1\n
# cook your dish here\nn = int(input())\ns = [i for i in input()]\ncount = 0\nfor i in range(1,n):\n    if s[i] == s[i-1]:\n        count += 1\n    else:\n        continue\nprint(count)\n
import sys\n\ndef _r(*conv) :\n r = [conv[i](x) for i, x in enumerate(input().strip().split(' '))]\n return r[0] if len(r) == 1 else r\n\ndef _ra(conv) :\n return list(map(conv, input().strip().split(' ')))\n\ndef _rl() :\n return list(input().strip())\n\ndef _rs() :\n return input().strip()\n\ndef _a(k, *v) :\n return all(x == k for x in v)\n\ndef _i(conv) :\n for line in sys.stdin :\n  yield conv(line)\n##################################################################\n\n\nfor _ in range(_r(int)) :\n n, sx, sy, ex, ey, bx, by = _ra(int)\n\n if sx != ex and sy != ey : \n  print(abs(sx - ex) + abs(sy - ey))\n else : \n  if sx == ex : \n   if sx == bx : \n    if (by > sy and by < ey) or (by < sy and by > ey) :\n     print(abs(sx - ex) + abs(sy - ey) + 2)\n    else :\n     print(abs(sx - ex) + abs(sy - ey))\n   else : \n    print(abs(sx - ex) + abs(sy - ey))\n  else :\n   if sy == by : \n    if (bx > sx and bx < ex) or (bx < sx and bx > ex) :\n     print(abs(sx - ex) + abs(sy - ey) + 2)\n    else : \n     print(abs(sx - ex) + abs(sy - ey))\n   else : \n    print(abs(sx - ex) + abs(sy - ey))\n\n\n
r,c,n = map(int , input().split());coordinates = [];coordinates_1,coordinates_2 = {},{}\r\nfor _ in range(n):\r\n	x,y = map(int , input().split())\r\n	coordinates.append([x,y])\r\nfor i in coordinates:\r\n    if(i[0] in coordinates_1): coordinates_1[i[0]] += 1\r\n    else: coordinates_1[i[0]] = 1\r\n    if(i[1] in coordinates_2): coordinates_2[i[1]] += 1\r\n    else: coordinates_2[i[1]] = 1\r\nprint(max(coordinates_1.values()) + max(coordinates_2.values()))
# cook your dish here\nfor _ in range(int(input())):\n    x, y= map(int, input().split())\n    print(max(x,y), x+y)
# cook your dish here\ntry:\n    n=int(input())\n    \n    list_n = list(range(1,n+1))\n    list_n_flag=[]\n    \n    fix_arr = list(map(int,input().split()))\n    \n    \n    k=1\n    res_list=[]\n    fin_list=[]\n    list_n_flag = list_n[k:] + list_n[:k]\n    res_list = [list_n[i] + fix_arr[i] for i in range(len(fix_arr))]\n    maxx = max(res_list)\n    fin_list.append(maxx)\n    while list_n!=list_n_flag:\n        \n        res_list = [list_n_flag[i] + fix_arr[i] for i in range(len(fix_arr))]\n        maxx = max(res_list)\n        fin_list.append(maxx)\n        list_n_flag = list_n_flag[k:] + list_n_flag[:k]\n        \n    print(*fin_list,sep=" ")\nexcept:\n    pass
r=int(input())\nc=0\nL=[]\nfor i in range(2*r+1,2*r**2+2):\n for j in range(i,r**4+2*r**2+2):\n  for k in range(j,r**4+3*r**2+2):\n   if 4*(i+j+k)*r**2==(i+j-k)*(i+k-j)*(j+k-i):\n    L.append([i,j,k])\n    c+=1\nprint(c)\nfor i in range(c):\n for j in range(3):\n  print(L[i][j], end=' ')\n print()\n \n
try:\n    t = int(input())\n    while t:\n        t -= 1\n        n = int(input())\n        arr = []\n        obj = {}\n        for i in range(n):\n            x,y = input().split()\n            y = int(y)\n            arr.append([x, y])\n            if y in obj: obj[y].append(x)\n            else: obj[y] = [x]\n        arr.sort(key = lambda i: i[1], reverse = True)\n        while len(arr) and len(obj[arr[-1][1]]) > 1:\n            arr.pop()\n        if len(arr) == 0:\n            print('Nobody wins.')\n        else:\n            print(arr.pop()[0])\nexcept:\n    pass
for _ in range(int(input())):\r\n    a=list(map(int,input().split()))\r\n    num=0\r\n    den=0\r\n    k=1\r\n    great=0\r\n    for i in a:\r\n        if i==-1:break\r\n        else:\r\n            if i>30:great+=1\r\n            if i%2==0:\r\n                num+=k*i\r\n                den+=k\r\n            k+=1\r\n    print(great,'%.2f'%(num/den))
n=int(input())\nfor i in range(n):\n a=list(map(int,input().split()))\n a.sort()\n if a[0]+a[1]>=a[2]-1:\n  print("Yes")\n else:\n  print("No")\n \n
arr = []\narr.append(1)\n_ = 1\nwhile _<=100002:\n arr.append(_*arr[_-1]%1589540031)\n _+=1\nfor _ in range(int(input())):\n print(arr[int(input())])
for i in range(int(input())):\n n=int(input())\n chef=0\n ans=[]\n for i in range(0,n):\n  l=list(map(int,input().split()))\n  c=l[0]\n  if c%2==0:\n   for i in range(1,len(l)//2+1):\n    chef=chef+l[i]\n   continue;\n  for i in range(1,len(l)//2):\n   chef=chef+l[i]\n  ans.append(l[len(l)//2])\n ans.sort(reverse=True)\n for i in range(len(ans)):\n  if i%2==0:\n   chef=chef+ans[i]\n print(chef)\n   \n  \n
# cook your dish here\nt= int(input())\nfor i in range(t):\n    cnt=0\n    n=int(input())\n    while(n>=100):\n        n-=100\n        cnt+=1\n    while(n>=50):\n        n-=50\n        cnt+=1\n    while(n>=10):\n        n-=10\n        cnt+=1\n    while(n>=5):\n        n-=5\n        cnt+=1\n    while(n>=2):\n        n-=2\n        cnt+=1\n    while(n>=1):\n        n-=1\n        cnt+=1\n    print(cnt)
T = int(input())\r\n\r\nans = []\r\nfor _ in range(T):\r\n	z = int(input())\r\n\r\n	for k in range(z):\r\n		s = input()\r\n\r\n	ans.append((z*(z+1))//2)\r\n\r\nfor ele in ans:\r\n	print(ele)
import itertools\nimport numpy as np\nb = np.zeros((100001), dtype=np.int)\ndef power2(a):\n	b[0] = 1\n	if b[a] > 0:\n		return b[a]\n	else:\n		for i in range(1,a+1):\n\n			b[i] = b[i-1]*2\n			if b[i] > (10**9+7):\n				b[i] = b[i]%(10**9+7)\n		return b[a]\n\n\ndef __starting_point():\n	t = eval(input())\n	for i in range(t):\n		s = input()\n		n = eval(input())\n		f_list = []\n		count = 0\n		for j in range(n):\n			f_list.append(input())\n		inp = ""\n		bin_list = []\n		for j in range(len(s)):\n			if s[j] == 'w':\n				inp = inp + '0'\n			else:\n				inp = inp + '1'\n		#print inp\n\n		a = np.zeros((1024), dtype=np.int)\n		for j in range(n):\n			s1 = ""\n			for k in range(len(f_list[j])):\n				if f_list[j][k]=='+':\n					s1 = s1 + '1'\n				else:\n					s1 = s1 + '0'\n			if n < 1024:\n				bin_list.append(s1)\n			p = int(s1,2)\n			if a[p] == 0:\n				count = count+1\n			a[p] = a[p]+1\n		count_2 = 0\n\n\n		#print a\n			\n		if n < 1024:\n			dp = np.zeros((n+1,1024) ,dtype=np.int64)\n			dp[0,0] = 1\n			for j in range(1,n+1):\n				for k in range(1024):\n				#print j-1\n				#print k^int(bin_list[j-1],2)\n\n					dp[j,k] = (dp[j-1][k] + dp[j-1][k^int(bin_list[j-1],2)])%(10**9+7)\n\n				#print dp\n			p = 1023 ^ int(inp,2)\n\n			print(dp[n,p]%(10**9+7))\n\n		else:\n\n			dp = np.zeros((1025,1024) ,dtype=np.int64)\n			dp[0,0] = 1\n			for j in range(1,1025):\n				count_2 = count_2 + 1\n				if a[j-1] > 0:\n					l = power2(a[j-1]-1)\n				for k in range(1024):\n				#print j-1\n				#print k^int(bin_list[j-1],2)\n					if a[j-1] > 0:\n						dp[j,k] = (((dp[j-1][k] + dp[j-1][k^(j-1)])%(10**9+7)) * l )%(10**9+7)\n					elif dp[j-1][k] > 0:\n						dp[j,k] = dp[j-1][k]\n\n				if count_2 == count:\n					break\n				#print dp\n			p = 1023 ^ int(inp,2)\n\n			print(dp[j,p]%(10**9+7))\n\n\n\n\n\n\n\n\n\n__starting_point()
import math\n\nfor i in range(int(input())):\n p,q=list(map(int,input().split()))\n c=0\n h=0\n \n while(q>=0):\n  if(q==0):\n   h+=1\n   break\n  \n  d=int(math.log2(q+1))\n  if(d==0):\n   h+=1\n   break\n  y=(2**d)-1\n  q-=y+1\n  if(q==-1):\n   h+=1\n   break\n  h+=1\n  \n while(p>=0):\n  if(p==0):\n   c+=1\n   break\n  else:\n   rem=int(math.log2(p+1))\n  \n   if(rem==0):\n    c+=1\n    break\n   \n   y=(2**rem)-1\n   p-=y+1\n   if(p==-1):\n    c+=1\n    break\n   c+=1\n\n if(c==h):\n  print(0,0)\n if(c<h):\n  print(1,h-c)\n if(c>h):\n  print(2,c-h)\n
import math\ndef divisors(n):\n arr = []\n for i in range(1,1+int(math.ceil(math.sqrt(n)))):\n  if n%i == 0:\n   arr.append(i)\n   arr.append(n//i)\n arr = list(sorted(set(arr)))\n return arr\ntry:\n t = int(input())\n while t:\n  t -= 1\n  a,m = map(int, input().split())\n  divs = divisors(m)\n  ans = []\n  for d in divs:\n   q = (m//d-1)/a\n   if q%1 == 0 and q>0:\n    ans.append((int(d*q)))\n  ans.sort()\n  print(len(ans))\n  for i in ans:\n   print(i, end = ' ')\n  print()\nexcept:\n pass
try:\n # cook your dish here\n t=int(input())\n for j in range(t):\n  n=int(input())\n  x=[]\n  p=[]\n  m=[]\n  for i in range(n):\n   X,P,M=list(map(str,input().split()))\n   x.append(X)\n   p.append(int(P))\n   m.append(int(M))\n   avg=sum(m)/n\n  for i in m:\n   if i<avg:\n    z=sorted([k for k in m if k<avg])\n    for i in range(len(z)):\n     print(x[m.index(z[i])],p[m.index(z[i])],m[m.index(z[i])])\n      \nexcept:\n pass
'''input\n1\n3\n1 2\n1 3\n1 2 3\n'''\nimport sys\nsys.setrecursionlimit(1000000)\nfor _ in range(eval(input())):\n C=[]\n n=eval(input())\n for i in range(n):\n  C.append([])\n for i in range(n-1):\n  a,b=[int(x)-1 for x in input().split()]\n  C[a].append(b)\n  C[b].append(a)\n cnt=0\n Co=[bin(int(x)).count("1") for x in input().split()]\n Q=[0]*(n+100)\n cur=0\n done=[0]*n\n done[0]=1\n H=[0]*n\n for i in range(n):\n  r=Q[i]\n  if H[r]&1 == Co[r]&1:\n   cnt+=1\n  for i in C[r]:\n   if done[i]==0:\n    done[i]=1\n    Q[cur+1]=i\n    cur+=1\n    H[i]=H[r]+1\n #dfs(0,-1)\n print(cnt*(n-cnt))\n\n
t=int(input())\r\nfor _ in range(t):\r\n    n=int(input())\r\n    arr=list(map(int,input().split()))\r\n    d={}\r\n    for i in range(n):\r\n        if arr[i] in d:\r\n            d[arr[i]].append(i)\r\n        else:\r\n            d[arr[i]]=[i]\r\n    q=int(input())\r\n    for i in range(q):\r\n        m=int(input())\r\n        if len(d[m])==1:\r\n            print(n)\r\n        elif len(d[m])==2:\r\n            print(min((d[m][1]-d[m][0]),((n-d[m][1])+d[m][0])))\r\n        else:\r\n            k=100000\r\n            for j in range(len(d[m])-1):\r\n                if (d[m][j+1]-d[m][j])<k:\r\n                    k=d[m][j+1]-d[m][j]\r\n                else:\r\n                    pass\r\n            print(min(k,((n-d[m][len(d[m])-1])+d[m][0])))\r\n            \r\n                \r\n
for __ in range(int(input())):\n n,p=list(map(int,input().split()))\n d=n%(n//2+1)\n if(d==0):\n  t=p*p*p\n else:\n  t=(p-d)*(p-d)+(p-d)*(p-n)+(p-n)*(p-n)\n print(t)\n
for t in range(int(input().strip())):\n n = int(input().strip())\n x = int(input().strip())\n arr = list(map(int, input().strip().split()))\n arr.sort()\n day = 1\n acc = 0\n isPossible = True\n for a in arr:\n  acc += 1\n  if acc > x:\n   day += 1\n   acc = 1\n  if day >= a:\n   isPossible = False\n   break\n\n print("Possible" if isPossible else "Impossible")\n
# Bartek Kostka\n#  You are not prepared!\n\n#include "bits/stdc++.h"\n\nn = int(input())\nW = {}\nfor i in range(n):\n    adr = input()\n    adr = adr.split("/")\n    if adr[-1] == '':\n        adr[-1] = '?'\n    domena = "/".join(adr[:3])\n    adres = "/".join(adr[3:])\n    #print(domena, adres)\n    if domena not in W:\n        W[domena] = set()\n    W[domena].add(adres)\n\nE = {}\nfor key, ele in list(W.items()):\n    #print(key, ele)\n    lele = "#".join(sorted(list(ele)))\n    if lele not in E:\n        E[lele] = []\n    E[lele].append(key)\n\nres = 0\nfor key, ele in list(E.items()):\n    if len(ele) > 1:\n        res += 1\n\nprint(res)\nfor key, ele in list(E.items()):\n    if len(ele) > 1:\n        print(" ".join(ele))\n
def getSum(dp, pos, s, e, type_):\n    if e < s:\n        return 0\n           \n    if type_=='D':\n        if e==m-1:\n            return dp[pos][s]\n        return dp[pos][s]-dp[pos][e+1]\n    else:\n        if e==n-1:\n            return dp[s][pos]\n        return dp[s][pos]-dp[e+1][pos]\n\nmod  = 10**9+7\nn, m = map(int, input().split())\na    = [list(list(map(lambda x: 1 if x=='R' else 0, input()))) for _ in range(n)] \n\nSD  = [[0]*m for _ in range(n)]\nSN  = [[0]*m for _ in range(n)]\ndpD = [[0]*m for _ in range(n)]\ndpN = [[0]*m for _ in range(n)]\n\nfor i in range(n-1, -1, -1):\n    for j in range(m-1, -1, -1):\n        if i == n-1:\n            SD[i][j]=a[i][j] \n        else:\n            SD[i][j]=SD[i+1][j]+a[i][j]\n\n        if j == m-1:\n            SN[i][j]=a[i][j]\n        else:    \n            SN[i][j]=SN[i][j+1]+a[i][j]\n            \nfor j in range(m-1,-1,-1):\n    if a[n-1][j]==1:\n        break\n    dpD[n-1][j]=1\n    dpN[n-1][j]=1\n    \nfor i in range(n-1,-1,-1):\n    if a[i][m-1]==1:\n        break\n    dpD[i][m-1]=1\n    dpN[i][m-1]=1\n    \nfor j in range(m-2, -1, -1):\n    if i==n-1:\n        break\n    dpD[n-1][j]+=dpD[n-1][j+1]\n    \nfor i in range(n-2,-1,-1):    \n    if j==m-1:\n        break\n    dpN[i][m-1]+=dpN[i+1][m-1]       \n    \nfor i in range(n-2,-1,-1):\n    for j in range(m-2,-1,-1):\n        s, e = j, m-SN[i][j]-1\n        #print(i, j, s, e, 'N')\n        dpN[i][j]  = getSum(dpD, i+1, s, e, 'D')\n        dpN[i][j]  = (dpN[i][j] + dpN[i+1][j]) % mod    \n    \n        s, e = i, n-SD[i][j]-1\n        #print(i, j, s, e, 'D')\n        dpD[i][j]  = getSum(dpN, j+1, s, e, 'N')\n\n    if i != 0:\n        for j in range(m-2,-1,-1):        \n            dpD[i][j] = (dpD[i][j] + dpD[i][j+1]) % mod    \n                        \nprint(dpD[0][0] % mod)            
a,b=map(int,input().split())\nprint(((b-1)*a*b//2+(a+1)*a*b*b*(b-1)//4)%1000000007)
l,r  = map(int, input().split(" "))\nif l == r:\n    print (l)\nelse:\n    print (2)
s=input()\nans = 0\nfor i in range(len(s)):\n  if s[i] == 'A':\n    ans += s[:i].count('Q') * s[i:].count('Q')\nprint(ans)
def determinant(m):\n    a = 0\n    if len(m) == 1:\n        a = m[0][0]\n    else:\n        for n in xrange(len(m)):\n            if (n + 1) % 2 == 0:\n                a -= m[0][n] * determinant([o[:n] + o[n+1:] for o in m[1:]])\n            else:\n                a += m[0][n] * determinant([o[:n] + o[n+1:] for o in m[1:]])\n                \n    return a
def sum_of_intervals(intervals):\n    s, top = 0, float("-inf")\n    for a,b in sorted(intervals):\n        if top < a: top    = a\n        if top < b: s, top = s+b-top, b\n    return s
def subsets_parity(n, k):\n    return 'EVEN' if ~n & k else 'ODD'
from collections import defaultdict\nfrom itertools import chain\nimport re\n\nPARSE = re.compile(r'[pP]\d+|q')\n\ndef magic_call_depth_number(prog):\n    \n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'): parse(it, m[0])\n            elif m[0]=='q':          return\n            else:                    pCmds[p].append(m[0].lower())\n    \n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen: yield d\n                else:         yield from travel(n, seen|{n}, d+1)\n    \n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable(travel(p, {p}) for p in pCmds['']))\n    \n    return [min(inf, default=0), max(inf, default=0)]\n
def primeFactors(n):\n    \n    factors = []\n    \n    while n % 2 == 0: \n        n /= 2\n        factors.append(2)\n        \n    for i in range(3, int(n**.5) + 1,2): \n        while n % i == 0: \n            n /= i\n            factors.insert(0, i)\n            \n    if n > 2: factors.insert(0, int(n))\n        \n    return factors\n        \ndef score(p):\n    \n    last, xp, s = p[0], p[0], 0\n    \n    for j in p[1:]:\n        if j == last:\n            xp *= j\n        else:\n            s += xp\n            xp, last = j, j\n    return (s + xp) * len(p)\n    \n\ndef prod(lst):\n    \n    res = 1\n    \n    for v in lst: res *= v\n    return res\n\ndef multiply_partitions(partition): return [prod(sub) for sub in partition]\n\ndef partition(collection):\n    \n    if len(collection) == 1:\n        yield [collection]\n        return\n\n    first = collection[0]\n    \n    for smaller in partition(collection[1:]):      \n        for n, subset in enumerate(smaller):\n            yield smaller[:n] + [[ first ] + subset]  + smaller[n+1:]\n        yield [ [ first ] ] + smaller\n\n\ndef find_spec_prod_part(n, com):  \n    \n    factors = primeFactors(n)\n    \n    if len(factors) == 1: return 'It is a prime number'\n    \n    fn = min if com == 'min' else max\n    mplist = []\n    best = [factors, score(factors)]\n    \n    for p in partition(factors):\n        mp = multiply_partitions(p)\n        \n        if mp in mplist or mp[0]==n:\n            continue            \n        mplist.append(mp)\n        best = fn(best, [mp, score(mp)], key=lambda x: x[1])\n    \n    return [sorted(best[0], reverse=True), best[1]]
def solution(string,markers):\n    parts = string.split('\n')\n    for s in markers:\n        parts = [v.split(s)[0].rstrip() for v in parts]\n    return '\n'.join(parts)
COLUMNS, ROWS = 'ABCDEFG', range(6)\nLINES = [{(COLUMNS[i+k], ROWS[j]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(len(ROWS))] \\n        + [{(COLUMNS[i], ROWS[j+k]) for k in range(4)}\n           for i in range(len(COLUMNS)) for j in range(len(ROWS) - 3)] \\n        + [{(COLUMNS[i+k], ROWS[j+k]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(len(ROWS) - 3)] \\n        + [{(COLUMNS[i+k], ROWS[j-k]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(3, len(ROWS))]\n\ndef who_is_winner(pieces_positions):\n    players = {}\n    board = dict.fromkeys(COLUMNS, 0)\n    for position in pieces_positions:\n        column, player = position.split('_')\n        pos = (column, board[column])\n        board[column] += 1\n        players.setdefault(player, set()).add(pos)\n        if any(line <= players[player] for line in LINES):\n            return player\n    return "Draw"
def longest_slide_down(p):\n    res = p.pop()\n    while p:\n        tmp = p.pop()\n        res = [tmp[i] + max(res[i],res[i+1])  for i in range(len(tmp))] \n    return res.pop()
words = {w: n for n, w in enumerate('zero one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen'.split())}\nwords.update({w: 10 * n for n, w in enumerate('twenty thirty forty fifty sixty seventy eighty ninety hundred'.split(), 2)})\nthousands = {w: 1000 ** n for n, w in enumerate('thousand million billion trillion quadrillion quintillion sextillion septillion octillion nonillion decillion'.split(), 1)}\ndef parse_int(strng):\n    num = group = 0\n    for w in strng.replace(' and ', ' ').replace('-', ' ').split():\n        if w == 'hundred': group *= words[w]\n        elif w in words: group += words[w]\n        else:\n            num += group * thousands[w]\n            group = 0\n    return num + group
from math import *\n\nDIGS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ndef converter(n, decimals=0, base=pi):\n    lst,n = ['-'*(n<0)], abs(n)\n    pMax  = max(0, n and int(log(n,base)))\n    \n    for p in reversed(range(-decimals,pMax+1)):\n        if p==-1: lst.append('.')\n        p   = base**p\n        d,n = n/p, n%p\n        lst.append(DIGS[int(d)])\n        \n    return ''.join(lst)
from collections import defaultdict\nimport re\n\nP = re.compile(r'\+?(-?\d*)(x\^?)?(\d*)')\n\ndef differentiate(eq, x):\n    \n    derivate = defaultdict(int)\n    for coef,var,exp in P.findall(eq):\n        exp  = int(exp or var and '1' or '0')\n        coef = int(coef!='-' and coef or coef and '-1' or '1')\n        \n        if exp: derivate[exp-1] += exp * coef\n    \n    return sum(coef * x**exp for exp,coef in derivate.items())
def decompose(n):\n    total = 0\n    answer = [n]\n    while len(answer):\n        temp = answer.pop()\n        total += temp ** 2\n        for i in range(temp - 1, 0, -1):\n            if total - (i ** 2) >= 0:\n                total -= i ** 2\n                answer.append(i)\n                if total == 0:\n                    return sorted(answer)\n    return None
from heapq import *\n\ndef n_linear(ms, n):\n    lst = [1] * (n+1)\n    q   = [(1+v,v,1) for v in ms]\n    heapify(q)\n    for i in range(1,n+1):\n        v,x,j  = heappop(q)\n        lst[i] = v\n        heappush(q, (lst[j]*x+1, x, j+1) )\n        while q[0][0]==lst[i]:\n            v,x,j = heappop(q)\n            heappush(q, (lst[j]*x+1, x, j+1) )\n    return lst[n]
def count_change(money, coins):\n    if money<0:\n        return 0\n    if money == 0:\n        return 1\n    if money>0 and not coins:\n        return 0\n    return count_change(money-coins[-1],coins) + count_change(money,coins[:-1])
def bowling_score(frames):\n    rolls = list(frames.replace(' ',''))\n    for i, hit in enumerate(rolls):\n        if hit == 'X':\n            rolls[i] = 10\n        elif hit == '/':\n            rolls[i] = 10 - rolls[i - 1]\n        else:\n            rolls[i] = int(hit)\n    score = 0\n    for i in range(10):\n        frame = rolls.pop(0)\n        if frame == 10:\n            score += frame + rolls[0] + rolls[1]    # Strike!\n        else:\n            frame += rolls.pop(0)\n            score += frame\n            if frame == 10:\n                score += rolls[0]                   # Spare!\n    return score
from fractions import Fraction as frac\ndef ber():\n    res, m = [], 0\n    while True:\n        res.append(frac(1, m+1))\n        for j in range(m, 0, -1):\n          res[j-1] = j*(res[j-1] - res[j])\n        yield res[0]\n        m += 1\ndef bernoulli_number(n):   \n    if n == 1: return Fraction(-1, 2)\n    if n % 2 == 1: return 0\n    bn2 = [ix for ix in zip(range(n + 2), ber())]\n    bn2 = [b for _, b in bn2]\n    return bn2[n]
sq_cub_rev_prime = (None, 89, 271, 325, 328, 890, 1025, 1055, 1081, 1129, 1169, 1241, 2657, 2710, 3112, 3121, 3149, 3244, 3250, 3263, 3280, 3335, 3346, 3403, 4193, 4222, 4231, 4289, 4291, 5531, 5584, 5653, 5678, 5716, 5791, 5795, 5836, 5837, 8882, 8900, 8926, 8942, 9664, 9794, 9875, 9962, 10178, 10250, 10393, 10429, 10499, 10550, 10577, 10651, 10679, 10717, 10718, 10739, 10756, 10762, 10810, 10844, 10895, 10898, 10943, 10996, 11035, 11039, 11084, 11137, 11159, 11164, 11182, 11191, 11290, 11351, 11371, 11575, 11690, 11695, 11707, 11722, 11732, 11795, 11827, 11861, 11885, 12109, 12124, 12242, 12268, 12304, 12361, 12362, 12410, 12433, 12436, 12535, 19144, 19267, 19271, 19273, 19385, 19433, 19442, 19451, 19501, 19564, 19597, 19603, 19631, 19637, 19766, 19846, 19865, 19871, 19909, 19927, 26464, 26491, 26570, 26579, 26621, 26704, 26944, 26965, 27001, 27029, 27052, 27100, 27101, 31120, 31210, 31223, 31237, 31261, 31327, 31331, 31351, 31463, 31469, 31490, 31534, 31561, 31657, 31726, 31739, 31784, 31807, 31883, 31928, 31978, 32066, 32072, 32213, 32255, 32308, 32431, 32440, 32446, 32500, 32539, 32564, 32573, 32630, 32656, 32708, 32749, 32759, 32800, 32888, 32969, 33059, 33254, 33325, 33338, 33350, 33404, 33460, 33475, 33509, 33568, 33575, 33701, 33833, 34030, 34112, 34159, 34163, 41351, 41429, 41473, 41501, 41608, 41639, 41839, 41879, 41930, 41933, 41992, 42029, 42089, 42103, 42121, 42179, 42220, 42235, 42310, 42326, 42385, 42463, 42466, 42524, 42575, 42607, 42682, 42782, 42839, 42890, 42910, 42982, 43045, 43049, 54986, 54991, 55073, 55310, 55492, 55589, 55598, 55603, 55651).__getitem__
LETTERS        = 'abcdefgh'                                                    # Defining some constants\nNUMBERS        = '87654321'\nW, B = WB      = 'Pp'\nEMPTY, CAPTURE = '.x'\nWHITEHOME      = '12'\nBLACKHOME      = '87'\nJUMP           = '54'\n\ndef pawn_move_tracker(moves):\n    board = {letter + number :                                                 # Representing board as\n             B if number == BLACKHOME[1] else                                  # a dictionary for easy\n             W if number == WHITEHOME[1] else EMPTY                            # access\n             for letter in LETTERS for number in NUMBERS}\n    whitemove = True                                                           # Move side switcher\n    for move in moves:\n        target    = move[-2:]                                                  # Finding target\n        mover     = move[0] + str(int(move[-1]) + 1 - whitemove * 2)           # Finding mover\n        if  move[-1] in JUMP[whitemove] and board[mover] == EMPTY:             # Mover for the jump\n            mover = move[0] + str(int(move[-1]) + 2 - whitemove * 4)\n        if (move[-1] in (BLACKHOME, WHITEHOME)[whitemove]           or         # Is the move valid?\n            board[target] != (EMPTY, WB[whitemove])[move[1] == CAPTURE] or\n            board[mover]  != WB[not whitemove]):\n            return "{} is invalid".format(move)\n        whitemove = not whitemove                                                  # Switching side\n        board[mover]  = EMPTY                                                      # Empty the source cell\n        board[target] = WB[whitemove]                                              # Fill the target\n    return [[board[letter + number] for letter in LETTERS] for number in NUMBERS]  # Return representation
def solve(n):\n    def length(n):\n        s = 0\n        for i in range(20):\n            o = 10 ** i - 1\n            if o > n: break\n            s += (n - o) * (n - o + 1) // 2\n        return s\n\n    def binary_search(k):\n        n = 0\n        for p in range(63, -1, -1):\n            if length(n + 2 ** p) < k: n += 2 ** p\n        return n\n\n    def sequence(n):\n        if n < 10: return n\n        for i in range(1, 19):\n            segment = i * 9 * 10 ** (i - 1)\n            if n <= segment:\n                return str(10 ** (i - 1) + (n - 1) // i)[(n - 1) % i]\n            else:\n                n -= segment\n    return int(sequence(n - length(binary_search(n))))
l = {j:i for i,j in enumerate('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz')}\nl_ = dict(enumerate('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'))\n\nis_polydivisible = lambda n, base:next((0 for i in range(1, len(n) + 1) if get_base(n[:i], base) % i),1)\nget_base = lambda n, base:sum(int(l[j]) * (base ** i) for i, j in enumerate(n[::-1]))\ndef get_polydivisible(n, base):\n    c = i = 0; r = ''\n    while c < n:\n        t = to_base(i, base)\n        if is_polydivisible(t, base) : c += 1 ;  r = t\n        i += 1\n    return ''.join(r) or '0'\n\ndef to_base(n, base):\n      li = []\n      while n:\n          n, b = divmod(n, base)\n          li.append(l_[b])\n      return li[::-1]
def proper_fractions(n):\n    phi = n > 1 and n\n    for p in range(2, int(n ** .5) + 1):\n        if not n % p:\n            phi -= phi // p\n            while not n % p:\n                n //= p\n    if n > 1: phi -= phi // n\n    return phi
from collections import Counter\n\ndef exchange_sort(sequence):\n    """Greedy algorithm based on permutation cycle decomposition:\n    1. Search for transposition placing TWO elements correctly.\n    2. Search iteratively for transposition placing ONE elements correctly."""\n    swaps, cnt = 0, Counter()\n    for a, b in zip(sequence, sorted(sequence)):\n        if cnt[b,a] > 0:\n            cnt[b,a] -= 1\n            swaps += 1\n        elif a != b:\n            cnt[a,b] += 1\n    # Special case: as there are only three keys at most,\n    # all remaining cycles will be 3-length cycles that\n    # need 2 transpositions to place 3 elements correctly.\n    return swaps + sum(cnt.values()) // 3 * 2
from functools import reduce\nfrom math import gcd\n\ndef survivor(a):\n    """Round Robin by Bocker & Liptak"""\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min(n[q] for q in range(r, a[0], d) if n[q] is not None)\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None: nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n\n    a.sort()\n    if len(a) < 1 or reduce(gcd, a) > 1: return -1\n    if a[0] == 1: return 0\n    return max(__residue_table(a)) - a[0]
def snail(array):\n    ret = []\n    if array and array[0]:\n        size = len(array)\n        for n in range((size + 1) // 2):\n            for x in range(n, size - n):\n                ret.append(array[n][x])\n            for y in range(1 + n, size - n):\n                ret.append(array[y][-1 - n])\n            for x in range(2 + n, size - n + 1):\n                ret.append(array[-1 - n][-x])\n            for y in range(2 + n, size - n):\n                ret.append(array[-y][n])\n    return ret\n
import math\n\ndef count(n):\n    if n is 0: return 0\n    x = int(math.log(n, 2))\n    return x * 2 ** (x - 1) + n - 2 ** x + 1 + count(n - 2 ** x)\n\ndef countOnes(left, right):\n    return count(right) - count(left - 1)
import re\n\nNEG, DOT, _, *DIGS = " "\nPOWS = "    ".split(' ')\nNUMS = {str(i):c for i,c in enumerate(DIGS)}\nfor n in range(10): NUMS[str(n+10)] = POWS[1] + DIGS[n]*bool(n)\n\n\ndef to_chinese_numeral(n):\n    ss = str(abs(n)).split('.')\n    return NEG*(n<0) + parse(ss[0]) + (len(ss)>1 and decimals(ss[1]) or '')\n\ndef decimals(digs): return DOT + ''.join(NUMS[d] for d in digs)\n\ndef parse(s):\n    if s in NUMS: return NUMS[s]\n    s = ''.join(reversed([ NUMS[d] + POWS[i]*(d!='0') for i,d in enumerate(reversed(s)) ]))\n    return re.sub(f'+$|(?<=)+', '', s)
from math import factorial as fac\n\ndef xCy(x, y):\n    return fac(x) // fac(y) // fac(x - y)\n    \ndef total_inc_dec(x):\n    return 1+sum([xCy(8+i,i) + xCy(9+i,i) - 10 for i in range(1,x+1)])\n
def middle_permutation(string):\n    s = sorted(string)\n    if len(s) % 2 ==0:        \n        return s.pop(len(s)//2-1) +''.join(s[::-1])\n    else:\n        return s.pop(len(s)//2) + middle_permutation(s)
def productsum(n):\n    pass # Your code here\n    \ndef productsum(kmax):\n    def prodsum2(p, s, c, start):\n        k = p - s + c     # product - sum + number of factors\n        if k < kmax:\n            if p < n[k]: n[k] = p\n            for i in range(start, kmax//p*2 + 1):\n                prodsum2(p*i, s+i, c+1, i)\n\n    kmax += 1\n    n = [2*kmax] * kmax\n    prodsum2(1, 1, 1, 2)\n\n    return sum(set(n[2:]))
def encode(s):\n    lst = sorted( s[i or len(s):] + s[:i or len(s)] for i in reversed(range(len(s))) )\n    return ''.join(ss[-1] for ss in lst), s and lst.index(s) or 0\n\ndef decode(s, n):\n    out, lst = [], sorted((c,i) for i,c in enumerate(s))\n    for _ in range(len(s)):\n        c,n = lst[n]\n        out.append(c)\n    return ''.join(out)
'''\n    Write a function that returns the longest contiguous palindromic substring in s. \n    In the event that there are multiple longest palindromic substrings, return the \n    first to occur.\n'''\n\ndef longest_palindrome(s, sep=" "):\n    # Interpolate some inert character between input characters\n    # so we only have to find odd-length palindromes\n    t = sep + sep.join(s) + sep\n\n    r = 0       # Rightmost index in any palindrome found so far ...\n    c = 0       # ... and the index of the centre of that palindrome.\n    spans = []  # Length of the longest substring in T[i:] mirrored in T[i::-1]\n\n    # Manacher's algorithm\n    for i,_ in enumerate(t):\n        span = min(spans[2*c-i], r-i-1) if i < r else 0\n        while span <= i < len(t)-span and t[i-span] == t[i+span]:\n            span += 1\n        r, c = max((r, c), (i+span, i))\n        spans.append(span)\n\n    span = max(spans)\n    middle = spans.index(span)\n\n    return t[middle-span+1:middle+span].replace(sep, "") 
import math\n\ndef gta(limit, *args):\n    return sum_up(limit, make_pattern(limit, *args)) \n\ndef binomial_coeff(n, k):\n    """N choose K"""\n    return math.factorial(n) / math.factorial(n-k)\n\ndef sum_up(limit, items):\n    """\n    Basic Idea: \n    \n    The number of cominations is simply N choose K. We calcuate this n-times up to the limit.\n    \n    To sum up all the digits we don't have to calculate the sum of each permuation, rather, we simply have to \n    realise that the digit "1" will appear N times.\n    \n        For example: [1,2,3], pick = 3.  \n        \n        If there are 6 combinations of length 3 for 3 numbers then each number much appear once in each combination. \n        Thus the sum is: (1 * 6) + (2 * 6) + (3 * 6)\n    \n        In cases where we have N numbers and need to pick K of them then that means not all numbers appear in all combinations.\n        It turns out combinations_total / (N / limit) gives us how many times N appears in the list of all combinations. \n        \n        For example: [1,2,3] pick 2\n        [1,2]\n        [2,1]\n        [1,3]\n        [3,1]\n        [2,3]\n        [3,2]\n        \n        We can see that 1 appears 4/6 times. \n        combinations_total = 6, N = 3, limit = 2.\n        \n        6 / (3/2) = 4\n    """\n    total = 0\n    for i in range(1, limit + 1):\n        combin = binomial_coeff(len(items), i)\n        ratio = len(items) / float(i) \n\n        for element in items:\n            total += (element * (combin / ratio))\n\n    return total\n    \ndef make_pattern(limit, *args):\n\n    seen = set()\n    pattern = []\n    items = list(map(str, args))\n    \n    k = 0\n    while len(pattern) < limit:    \n        for i in range(len(items)):\n            try:\n                v = items[i][k]\n            except IndexError:\n                pass\n            \n            if v not in seen:\n                seen.add(v)\n                pattern.append(int(v))\n                if len(pattern) == limit:\n                    break\n        k += 1\n    \n    return pattern
\ndef mix(s1, s2):\n    hist = {}\n    for ch in "abcdefghijklmnopqrstuvwxyz":\n        val1, val2 = s1.count(ch), s2.count(ch)\n        if max(val1, val2) > 1:\n            which = "1" if val1 > val2 else "2" if val2 > val1 else "="\n            hist[ch] = (-max(val1, val2), which + ":" + ch * max(val1, val2))\n    return "/".join(hist[ch][1] for ch in sorted(hist, key=lambda x: hist[x]))\n
from itertools import zip_longest\n\ndef normalize(lst, growing=0):\n    \n    def seeker(lst, d=1):\n        yield len(lst), d\n        for elt in lst:\n            if isinstance(elt,list):\n                yield from seeker(elt, d+1)\n    \n    def grower(lst, d=1):\n        return [ grower(o if isinstance(o,list) else [o]*size, d+1)\n                    if d != depth else o\n                 for o,_ in zip_longest(lst,range(size), fillvalue=growing) ]\n                 \n    size,depth = map(max, zip(*seeker(lst)))\n    return grower(lst)
from scipy.special import comb\n\ndef multiply(n, k):\n    r, d = 1, 2\n    while d * d <= n:\n        i = 0\n        while n % d == 0:\n            i += 1\n            n //= d\n        r *= comb(i + k - 1, k - 1, exact=True)\n        d += 1\n    if n > 1: \n        r *= k\n    return r
from scipy.special import comb\n\ndef almost_everywhere_zero(n, k):\n    if k == 0: return 1\n    first, *rest = str(n)\n    l = len(rest)\n    return 9**k*comb(l, k, exact=True) +\\n           (int(first)-1)*9**(k-1)*comb(l, k-1, exact=True) +\\n           almost_everywhere_zero(int("".join(rest) or 0), k-1)
from math import ceil\ndef b91decode(strng):\n    ret = ''\n    base91_alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '!', '#', '$',\n    '%', '&', '(', ')', '*', '+', ',', '.', '/', ':', ';', '<', '=',\n    '>', '?', '@', '[', ']', '^', '_', '`', '{', '|', '}', '~', '"']\n    strng_arr = [strng[i:i+2] for i in range(0, len(strng), 2)]\n    origin_bin = ''\n    for str in strng_arr:\n        num = 0\n        if len(str) == 1:\n            num += base91_alphabet.index(str[0])\n            origin_bin = bin(num)[2:] + origin_bin\n        else:\n            num += base91_alphabet.index(str[0])\n            num += base91_alphabet.index(str[1])*91\n            if num & 8191 > 88:\n                origin_bin = bin(num)[2:].zfill(13) + origin_bin\n            else:\n                origin_bin = bin(num)[2:].zfill(14) + origin_bin\n    origin_bin = origin_bin.zfill(int(ceil(len(origin_bin)/8.0))*8)\n    ret = [origin_bin[i:i+8] for i in range(0, len(origin_bin), 8)]\n    return ''.join(map(lambda x:chr(int(x, 2)), ret))[::-1]\n        \n            \n            \n    \ndef b91encode(strng):\n    base91_alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '!', '#', '$',\n    '%', '&', '(', ')', '*', '+', ',', '.', '/', ':', ';', '<', '=',\n    '>', '?', '@', '[', ']', '^', '_', '`', '{', '|', '}', '~', '"']\n    ret = ''\n    strng_bin = map(lambda x:bin(ord(x))[2:].zfill(8), list(strng))\n    strng_bin_r = ''\n    for i in range(len(strng_bin)):\n        strng_bin_r = strng_bin[i] + strng_bin_r\n    strng_bin_r = strng_bin_r[::-1]\n    index = 0\n    while index < len(strng_bin_r):\n        num = int(strng_bin_r[index:index+13][::-1], 2)\n        if num > 88:\n            index += 13\n            ret += base91_alphabet[num%91] + base91_alphabet[num/91]\n        else:\n            num = int(strng_bin_r[index:index+14][::-1], 2)\n            index += 14\n            ret += base91_alphabet[num%91] + base91_alphabet[num/91]\n    ret = ret[0:len(ret)-2]\n    if num > 90:\n        ret += base91_alphabet[num%91] + base91_alphabet[num/91]\n    else:\n        ret += base91_alphabet[num%91]\n    return ret
def one_square(n):\n    return round(n ** .5) ** 2 == n\n\ndef two_squares(n):\n    while n % 2 == 0: n //= 2\n    p = 3\n    while p * p <= n:\n        while n % (p * p) == 0:\n            n //= p * p\n        while n % p == 0:\n            if p % 4 == 3: return False\n            n //= p\n        p += 2\n    return n % 4 == 1\n\ndef three_squares(n):\n    while n % 4 == 0: n //= 4\n    return n % 8 != 7\n\ndef sum_of_squares(n):\n    if one_square(n): return 1\n    if two_squares(n): return 2\n    if three_squares(n): return 3\n    return 4
out = [1, 5, 6]\n\ndef green(n):\n  \n    f = 5\n    s = 6\n    q = 1\n\n    while n >= len(out):\n        q = 10 * q\n        f = f**2 % q\n        s = (1 - (s - 1)**2) % q\n        out.extend(sorted(j for j in [f, s] if j not in out))\n    return out[n-1]
import itertools\ndef next_bigger(n):\n    s = list(str(n))\n    for i in range(len(s)-2,-1,-1):\n        if s[i] < s[i+1]:\n            t = s[i:]\n            m = min([x for x in t if x>t[0]])\n            t.remove(m)\n            t.sort()\n            s[i:] = [m] + t\n            return int("".join(s))\n    return -1\n
def spinning_rings(inner_max, outer_max):\n    p = inner_max + 1\n    q = outer_max + 1\n    move = 1\n    while (-move) % p != move % q:\n        if (-move) % p >= q:\n            move = move // p * p + p - q + 1\n        elif move % q >= p:\n            move = move // q * q + q\n        elif (-move) % p > move % q and ((-move) % p + move % q) % 2 == 0:\n            move += ((-move) % p - move % q) // 2\n        else:\n            move = min((move - 1) // p * p + p, (move - 1) // q * q + q) + 1\n    return move
STATE_TO_COMMANDS = {\n  'CLOSED': {\n    'APP_PASSIVE_OPEN': 'LISTEN',\n    'APP_ACTIVE_OPEN': 'SYN_SENT'\n  },\n  'LISTEN': {\n    'RCV_SYN': 'SYN_RCVD',\n    'APP_SEND': 'SYN_SENT',\n    'APP_CLOSE': 'CLOSED'\n  },\n  'SYN_RCVD': {\n    'APP_CLOSE': 'FIN_WAIT_1',\n    'RCV_ACK': 'ESTABLISHED'\n  },\n  'SYN_SENT': {\n    'RCV_SYN': 'SYN_RCVD',\n    'RCV_SYN_ACK': 'ESTABLISHED',\n    'APP_CLOSE': 'CLOSED'\n  },\n  'ESTABLISHED': {\n    'APP_CLOSE': 'FIN_WAIT_1',\n    'RCV_FIN': 'CLOSE_WAIT'\n  },\n  'FIN_WAIT_1': {\n    'RCV_FIN': 'CLOSING',\n    'RCV_FIN_ACK': 'TIME_WAIT',\n    'RCV_ACK': 'FIN_WAIT_2'\n  },\n  'CLOSING': {\n    'RCV_ACK': 'TIME_WAIT'\n  },\n  'FIN_WAIT_2': {\n    'RCV_FIN': 'TIME_WAIT'\n  },\n  'TIME_WAIT': {\n    'APP_TIMEOUT': 'CLOSED'\n  },\n  'CLOSE_WAIT': {\n    'APP_CLOSE': 'LAST_ACK'\n  },\n  'LAST_ACK': {\n    'RCV_ACK': 'CLOSED'\n  }\n}\n\n\ndef traverse_TCP_states(events):\n  state = "CLOSED"  # initial state, always\n  for event in events:\n    if event not in STATE_TO_COMMANDS[state]:\n      return 'ERROR'\n    state = STATE_TO_COMMANDS[state][event]\n  return state
from itertools import combinations_with_replacement\n\ndef find_all(sum_dig, digs):\n    combs = combinations_with_replacement(list(range(1, 10)), digs)\n    target = [''.join(str (x) for x in list(comb)) for comb in combs if sum(comb) == sum_dig]\n    if not target:\n        return []\n    return [len(target), int(target[0]), int(target[-1])]\n
def solution(args):\n    out = []\n    beg = end = args[0]\n    \n    for n in args[1:] + [""]:        \n        if n != end + 1:\n            if end == beg:\n                out.append( str(beg) )\n            elif end == beg + 1:\n                out.extend( [str(beg), str(end)] )\n            else:\n                out.append( str(beg) + "-" + str(end) )\n            beg = n\n        end = n\n    \n    return ",".join(out)
times = [("year", 365 * 24 * 60 * 60), \n         ("day", 24 * 60 * 60),\n         ("hour", 60 * 60),\n         ("minute", 60),\n         ("second", 1)]\n\ndef format_duration(seconds):\n\n    if not seconds:\n        return "now"\n\n    chunks = []\n    for name, secs in times:\n        qty = seconds // secs\n        if qty:\n            if qty > 1:\n                name += "s"\n            chunks.append(str(qty) + " " + name)\n\n        seconds = seconds % secs\n\n    return ', '.join(chunks[:-1]) + ' and ' + chunks[-1] if len(chunks) > 1 else chunks[0]\n
def fibfusc(n, num_digits=None):\n    if n < 2: return (1 - n, n)\n    b = bin(n)[2:]\n    \n    x, y = fibfusc(int(b[0]))\n    for bit in b[1:]:\n        if bit == "1":\n            x, y = (-y*(2*x + 3*y), (x + 2*y)*(x + 4*y))\n        else:\n            x, y = ((x + y) * (x - y), y * (2*x + 3*y))\n        if num_digits:\n            x, y = x % 10 ** num_digits - 10**num_digits, y % 10 ** num_digits\n    return x, y\n
import re\n\ndef solve_runes(runes):\n    for d in sorted(set("0123456789") - set(runes)):\n        toTest = runes.replace("?",d)\n        if re.search(r'([^\d]|\b)0\d+', toTest): continue\n        l,r = toTest.split("=")\n        if eval(l) == eval(r): return int(d)\n    return -1
from itertools import combinations\n\ndef count_col_triang(a):\n    p, r = {}, {}\n    for xy, col in a:\n        p[col] = p.get(col, []) + [xy]\n    for k in p:\n        r[k] = sum(1 for c in combinations(p[k], 3) if triangle(*c))\n    mx = max(r.values())\n    return [len(a), len(p), sum(r.values()), sorted(k for k in r if r[k] == mx) + [mx] if mx else []]\n    \ndef triangle(a, b, c):  \n    return area(*[((p[0] - q[0])**2 + (p[1] - q[1])**2)**0.5 for p, q in [(a, b), (a, c), (b, c)]]) > 0.0\n\ndef area(a, b, c):\n    s = 0.5 * (a + b + c)\n    return round(max((s*((s-a)*(s-b)*(s-c))), 0.0)**0.5, 4)
def count_subsequences(needle, haystack):\n    count = [1] + [0] * len(needle)\n    for a in haystack:\n        count = [1] + [count[i] + count[i-1] * (a == b)\n                       for i, b in enumerate(needle, 1)]\n    return count[-1] % 10 ** 8
def string_func(s, n):\n    l, s = [s], list(s)\n    while True:\n        s[::2], s[1::2] = s[:len(s)//2-1:-1], s[:len(s)//2]\n        l.append(''.join(s))\n        if l[0] == l[-1]: del l[-1]; break\n    return l[n % len(l)]
from fractions import Fraction\n\ndef expand(x, digit):\n    step = 0\n    fact = 1\n    expo = Fraction(1)\n    n = 10 ** len(str(x).split('.')[-1])\n    x = Fraction(int(x * n), n)\n    while expo.numerator < 10 ** (digit - 1):\n        step += 1\n        fact *= step\n        expo += x ** step / fact\n    return [expo.numerator, expo.denominator]
ANSWERS = {\n    0: 1,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 5,\n    5: 7,\n    6: 11,\n    7: 15,\n    8: 22,\n    9: 30,\n    10: 42,\n    11: 56,\n    12: 77,\n    13: 101,\n    14: 135,\n    15: 176,\n    16: 231,\n    17: 297,\n    18: 385,\n    19: 490,\n    20: 627,\n    21: 792,\n    22: 1002,\n    23: 1255,\n    24: 1575,\n    25: 1958,\n    26: 2436,\n    27: 3010,\n    28: 3718,\n    29: 4565,\n    30: 5604,\n    31: 6842,\n    32: 8349,\n    33: 10143,\n    34: 12310,\n    35: 14883,\n    36: 17977,\n    37: 21637,\n    38: 26015,\n    39: 31185,\n    40: 37338,\n    41: 44583,\n    42: 53174,\n    43: 63261,\n    44: 75175,\n    45: 89134,\n    46: 105558,\n    47: 124754,\n    48: 147273,\n    49: 173525,\n    50: 204226,\n    51: 239943,\n    52: 281589,\n    53: 329931,\n    54: 386155,\n    55: 451276,\n    56: 526823,\n    57: 614154,\n    58: 715220,\n    59: 831820,\n    60: 966467,\n    61: 1121505,\n    62: 1300156,\n    63: 1505499,\n    64: 1741630,\n    65: 2012558,\n    66: 2323520,\n    67: 2679689,\n    68: 3087735,\n    69: 3554345,\n    70: 4087968,\n    71: 4697205,\n    72: 5392783,\n    73: 6185689,\n    74: 7089500,\n    75: 8118264,\n    76: 9289091,\n    77: 10619863,\n    78: 12132164,\n    79: 13848650,\n    80: 15796476,\n    81: 18004327,\n    82: 20506255,\n    83: 23338469,\n    84: 26543660,\n    85: 30167357,\n    86: 34262962,\n    87: 38887673,\n    88: 44108109,\n    89: 49995925,\n    90: 56634173,\n    91: 64112359,\n    92: 72533807,\n    93: 82010177,\n    94: 92669720,\n    95: 104651419,\n    96: 118114304,\n    97: 133230930,\n    98: 150198136,\n    99: 169229875,\n    100: 190569292,\n    101: 214481126,\n    102: 241265379,\n    103: 271248950,\n    104: 304801365,\n    105: 342325709,\n    106: 384276336,\n    107: 431149389,\n    108: 483502844,\n    109: 541946240,\n    110: 607163746,\n    111: 679903203,\n    112: 761002156,\n    113: 851376628,\n    114: 952050665,\n    115: 1064144451,\n    116: 1188908248,\n    117: 1327710076,\n    118: 1482074143,\n    119: 1653668665,\n    120: 1844349560,\n    121: 2056148051,\n    122: 2291320912,\n    123: 2552338241,\n    124: 2841940500,\n    125: 3163127352,\n    126: 3519222692,\n    127: 3913864295,\n    128: 4351078600,\n    129: 4835271870,\n    130: 5371315400,\n    131: 5964539504,\n    132: 6620830889,\n    133: 7346629512,\n    134: 8149040695,\n    135: 9035836076,\n    136: 10015581680,\n    137: 11097645016,\n    138: 12292341831,\n    139: 13610949895,\n    140: 15065878135,\n    141: 16670689208,\n    142: 18440293320,\n    143: 20390982757,\n    144: 22540654445,\n    145: 24908858009,\n    146: 27517052599,\n    147: 30388671978,\n    148: 33549419497,\n    149: 37027355200,\n    150: 40853235313,\n    151: 45060624582,\n    152: 49686288421,\n    153: 54770336324,\n    154: 60356673280,\n    155: 66493182097,\n    156: 73232243759,\n    157: 80630964769,\n    158: 88751778802,\n    159: 97662728555,\n    160: 107438159466,\n    161: 118159068427,\n    162: 129913904637,\n    163: 142798995930,\n    164: 156919475295,\n    165: 172389800255,\n    166: 189334822579,\n    167: 207890420102,\n    168: 228204732751,\n    169: 250438925115,\n    170: 274768617130,\n    171: 301384802048,\n    172: 330495499613,\n    173: 362326859895,\n    174: 397125074750,\n    175: 435157697830,\n    176: 476715857290,\n    177: 522115831195,\n    178: 571701605655,\n    179: 625846753120,\n    180: 684957390936,\n    181: 749474411781,\n    182: 819876908323,\n    183: 896684817527,\n    184: 980462880430,\n    185: 1071823774337,\n    186: 1171432692373,\n    187: 1280011042268,\n    188: 1398341745571,\n    189: 1527273599625,\n    190: 1667727404093,\n    191: 1820701100652,\n    192: 1987276856363,\n    193: 2168627105469,\n    194: 2366022741845,\n    195: 2580840212973,\n    196: 2814570987591,\n    197: 3068829878530,\n    198: 3345365983698,\n    199: 3646072432125,\n    200: 3972999029388,\n    201: 4328363658647,\n    202: 4714566886083,\n    203: 5134205287973,\n    204: 5590088317495,\n    205: 6085253859260,\n    206: 6622987708040,\n    207: 7206841706490,\n    208: 7840656226137,\n    209: 8528581302375,\n    210: 9275102575355,\n    211: 10085065885767,\n    212: 10963707205259,\n    213: 11916681236278,\n    214: 12950095925895,\n    215: 14070545699287,\n    216: 15285151248481,\n    217: 16601598107914,\n    218: 18028182516671,\n    219: 19573856161145,\n    220: 21248279009367,\n    221: 23061871173849,\n    222: 25025873760111,\n    223: 27152408925615,\n    224: 29454549941750,\n    225: 31946390696157,\n    226: 34643126322519,\n    227: 37561133582570,\n    228: 40718063627362,\n    229: 44132934884255,\n    230: 47826239745920,\n    231: 51820051838712,\n    232: 56138148670947,\n    233: 60806135438329,\n    234: 65851585970275,\n    235: 71304185514919,\n    236: 77195892663512,\n    237: 83561103925871,\n    238: 90436839668817,\n    239: 97862933703585,\n    240: 105882246722733,\n    241: 114540884553038,\n    242: 123888443077259,\n    243: 133978259344888,\n    244: 144867692496445,\n    245: 156618412527946,\n    246: 169296722391554,\n    247: 182973889854026,\n    248: 197726516681672,\n    249: 213636919820625,\n    250: 230793554364681,\n    251: 249291451168559,\n    252: 269232701252579,\n    253: 290726957916112,\n    254: 313891991306665,\n    255: 338854264248680,\n    256: 365749566870782,\n    257: 394723676655357,\n    258: 425933084409356,\n    259: 459545750448675,\n    260: 495741934760846,\n    261: 534715062908609,\n    262: 576672674947168,\n    263: 621837416509615,\n    264: 670448123060170,\n    265: 722760953690372,\n    266: 779050629562167,\n    267: 839611730366814,\n    268: 904760108316360,\n    269: 974834369944625,\n    270: 1050197489931117,\n    271: 1131238503938606,\n    272: 1218374349844333,\n    273: 1312051800816215,\n    274: 1412749565173450,\n    275: 1520980492851175,\n    276: 1637293969337171,\n    277: 1762278433057269,\n    278: 1896564103591584,\n    279: 2040825852575075,\n    280: 2195786311682516,\n    281: 2362219145337711,\n    282: 2540952590045698,\n    283: 2732873183547535,\n    284: 2938929793929555,\n    285: 3160137867148997,\n    286: 3397584011986773,\n    287: 3652430836071053,\n    288: 3925922161489422,\n    289: 4219388528587095,\n    290: 4534253126900886,\n    291: 4872038056472084,\n    292: 5234371069753672,\n    293: 5622992691950605,\n    294: 6039763882095515,\n    295: 6486674127079088,\n    296: 6965850144195831,\n    297: 7479565078510584,\n    298: 8030248384943040,\n    299: 8620496275465025,\n    300: 9253082936723602,\n    301: 9930972392403501,\n    302: 10657331232548839,\n    303: 11435542077822104,\n    304: 12269218019229465,\n    305: 13162217895057704,\n    306: 14118662665280005,\n    307: 15142952738857194,\n    308: 16239786535829663,\n    309: 17414180133147295,\n    310: 18671488299600364,\n    311: 20017426762576945,\n    312: 21458096037352891,\n    313: 23000006655487337,\n    314: 24650106150830490,\n    315: 26415807633566326,\n    316: 28305020340996003,\n    317: 30326181989842964,\n    318: 32488293351466654,\n    319: 34800954869440830,\n    320: 37274405776748077,\n    321: 39919565526999991,\n    322: 42748078035954696,\n    323: 45772358543578028,\n    324: 49005643635237875,\n    325: 52462044228828641,\n    326: 56156602112874289,\n    327: 60105349839666544,\n    328: 64325374609114550,\n    329: 68834885946073850,\n    330: 73653287861850339,\n    331: 78801255302666615,\n    332: 84300815636225119,\n    333: 90175434980549623,\n    334: 96450110192202760,\n    335: 103151466321735325,\n    336: 110307860425292772,\n    337: 117949491546113972,\n    338: 126108517833796355,\n    339: 134819180623301520,\n    340: 144117936527873832,\n    341: 154043597379576030,\n    342: 164637479165761044,\n    343: 175943559810422753,\n    344: 188008647052292980,\n    345: 200882556287683159,\n    346: 214618299743286299,\n    347: 229272286871217150,\n    348: 244904537455382406,\n    349: 261578907351144125,\n    350: 279363328483702152,\n    351: 298330063062758076,\n    352: 318555973788329084,\n    353: 340122810048577428,\n    354: 363117512048110005,\n    355: 387632532919029223,\n    356: 413766180933342362,\n    357: 441622981929358437,\n    358: 471314064268398780,\n    359: 502957566506000020,\n    360: 536679070310691121,\n    361: 572612058898037559,\n    362: 610898403751884101,\n    363: 651688879997206959,\n    364: 695143713458946040,\n    365: 741433159884081684,\n    366: 790738119649411319,\n    367: 843250788562528427,\n    368: 899175348396088349,\n    369: 958728697912338045,\n    370: 1022141228367345362,\n    371: 1089657644424399782,\n    372: 1161537834849962850,\n    373: 1238057794119125085,\n    374: 1319510599727473500,\n    375: 1406207446561484054,\n    376: 1498478743590581081,\n    377: 1596675274490756791,\n    378: 1701169427975813525,\n    379: 1812356499739472950,\n    380: 1930656072350465812,\n    381: 2056513475336633805,\n    382: 2190401332423765131,\n    383: 2332821198543892336,\n    384: 2484305294265418180,\n    385: 2645418340688763701,\n    386: 2816759503217942792,\n    387: 2998964447736452194,\n    388: 3192707518433532826,\n    389: 3398704041358160275,\n    390: 3617712763867604423,\n    391: 3850538434667429186,\n    392: 4098034535626594791,\n    393: 4361106170762284114,\n    394: 4640713124699623515,\n    395: 4937873096788191655,\n    396: 5253665124416975163,\n    397: 5589233202595404488,\n    398: 5945790114707874597,\n    399: 6324621482504294325,\n    400: 6727090051741041926,\n    401: 7154640222653942321,\n    402: 7608802843339879269,\n    403: 8091200276484465581,\n    404: 8603551759348655060,\n    405: 9147679068859117602,\n    406: 9725512513742021729,\n    407: 10339097267123947241,\n    408: 10990600063775926994,\n    409: 11682316277192317780,\n    410: 12416677403151190382,\n    411: 13196258966925435702,\n    412: 14023788883518847344,\n    413: 14902156290309948968,\n    414: 15834420884488187770,\n    415: 16823822787139235544,\n    416: 17873792969689876004,\n    417: 18987964267331664557,\n    418: 20170183018805933659,\n    419: 21424521360255636320,\n    420: 22755290216580025259,\n    421: 24167053021441363961,\n    422: 25664640213837714846,\n    423: 27253164546230421739,\n    424: 28938037257084798150,\n    425: 30724985147095051099,\n    426: 32620068617410232189,\n    427: 34629700713903575934,\n    428: 36760667241831527309,\n    429: 39020148000237259665,\n    430: 41415739207102358378,\n    431: 43955477170518116534,\n    432: 46647863284229267991,\n    433: 49501890409405150715,\n    434: 52527070729108240605,\n    435: 55733465144636286656,\n    436: 59131714309169618645,\n    437: 62733071376043079215,\n    438: 66549436566966297367,\n    439: 70593393646562135510,\n    440: 74878248419470886233,\n    441: 79418069346443402240,\n    442: 84227730407729499781,\n    443: 89322956321353645667,\n    444: 94720370257893471820,\n    445: 100437544171752847604,\n    446: 106493051905239118581,\n    447: 112906525199196103354,\n    448: 119698712782720205954,\n    449: 126891542690981418000,\n    450: 134508188001572923840,\n    451: 142573136155347404229,\n    452: 151112262071917313678,\n    453: 160152905244553715585,\n    454: 169723951046458040965,\n    455: 179855916453958267598,\n    456: 190581040442651931034,\n    457: 201933379285114688629,\n    458: 213948907032733069132,\n    459: 226665621435831345565,\n    460: 240123655613925192081,\n    461: 254365395758574199975,\n    462: 269435605212954994471,\n    463: 285381555241961986287,\n    464: 302253162872576636605,\n    465: 320103136152993290544,\n    466: 338987127249525432549,\n    467: 358963893768162876613,\n    468: 380095468763120598477,\n    469: 402447339861711475160,\n    470: 426088638015652413417,\n    471: 451092336355096099864,\n    472: 477535459708164115593,\n    473: 505499305314204629558,\n    474: 535069675351607262125,\n    475: 566337121865805599675,\n    476: 599397204782301852926,\n    477: 634350763653787028583,\n    478: 671304203896731807232,\n    479: 710369798236628238005,\n    480: 751666004194993125591,\n    481: 795317798414758232180,\n    482: 841457028742823649455,\n    483: 890222784951928088294,\n    484: 941761789114997698055,\n    485: 996228806608573411012,\n    486: 1053787078862455346513,\n    487: 1114608778936426484248,\n    488: 1178875491155735802646,\n    489: 1246778716001272919665,\n    490: 1318520401612270233223,\n    491: 1394313503224447816939,\n    492: 1474382572040363953132,\n    493: 1558964374994977806173,\n    494: 1648308547066172438760,\n    495: 1742678277747760981187,\n    496: 1842351033503159891466,\n    497: 1947619317987658064007,\n    498: 2058791472042884901563,\n    499: 2176192515439287461625,\n    500: 2300165032574323995027,\n    501: 2431070104309287327876,\n    502: 2569288288377098289281,\n    503: 2715220650772245313220,\n    504: 2869289850802400662045,\n    505: 3031941282464413132742,\n    506: 3203644275096202070012,\n    507: 3384893356244349844341,\n    508: 3576209579998154653671,\n    509: 3778141924035171537110,\n    510: 3991268758958164118300,\n    511: 4216199393504640098482,\n    512: 4453575699570940947378,\n    513: 4704073821002175842062,\n    514: 4968405970488126319775,\n    515: 5247322318923878793976,\n    516: 5541612982013113936133,\n    517: 5852110108921301661040,\n    518: 6179690078238084808000,\n    519: 6525275806549652788115,\n    520: 6889839175409542385648,\n    521: 7274403582551733377346,\n    522: 7680046623716094332553,\n    523: 8107902911527474124146,\n    524: 8559167038437716736150,\n    525: 9035096690829005915201,\n    526: 9537015921990240021538,\n    527: 10066318591787500106586,\n    528: 10624471981512075020731,\n    529: 11213020592521695111580,\n    530: 11833590138006300416410,\n    531: 12487891737367521803652,\n    532: 13177726323474524612308,\n    533: 13904989273245567335012,\n    534: 14671675272840783232475,\n    535: 15479883428970761068959,\n    536: 16331822638729701493803,\n    537: 17229817230617210720599,\n    538: 18176312890390861435034,\n    539: 19173882885687454484110,\n    540: 20225234604409151266221,\n    541: 21333216422211708570598,\n    542: 22500824915577356165493,\n    543: 23731212437346370138355,\n    544: 25027695072821279146420,\n    545: 26393760995005382968154,\n    546: 27833079238879849385687,\n    547: 29349508915133986374841,\n    548: 30947108885217475101876,\n    549: 32630147920163234060900,\n    550: 34403115367205050943160,\n    551: 36270732348871285128752,\n    552: 38237963520943177237554,\n    553: 40310029416409244587122,\n    554: 42492419404397720872600,\n    555: 44790905293907018009131,\n    556: 47211555614160398040338,\n    557: 49760750604354432757376,\n    558: 52445197947746313627407,\n    559: 55271949286085137715955,\n    560: 58248417552751868050007,\n    561: 61382395164161775318496,\n    562: 64682073111542943380454,\n    563: 68156060996536236172174,\n    564: 71813408056839596203570,\n    565: 75663625229609055443637,\n    566: 79716708303343130521599,\n    567: 83983162210640880002321,\n    568: 88474026517495817981253,\n    569: 93200902166643654187580,\n    570: 98175979536033971312388,\n    571: 103412067875563710992446,\n    572: 108922626189067392956037,\n    573: 114721795630860408658491,\n    574: 120824433490320564237125,\n    575: 127246148840551966562301,\n    576: 134003339931725153597473,\n    577: 141113233412529912746558,\n    578: 148593925468119890197615,\n    579: 156464424966082817448060,\n    580: 164744698707340387584240,\n    581: 173455718882380096095248,\n    582: 182619512839056823919887,\n    583: 192259215272078129526277,\n    584: 202399122950629095580175,\n    585: 213064752104884207160129,\n    586: 224282898599046831034631,\n    587: 236081701023305130945921,\n    588: 248490706844586261413858,\n    589: 261540941761240642265710,\n    590: 275264982414934173206642,\n    591: 289697032618827122974972,\n    592: 304873003269975366031783,\n    593: 320830596120295386610807,\n    594: 337609391590065169560935,\n    595: 355250940815002702558187,\n    596: 373798862128436852709430,\n    597: 393298942187883251157044,\n    598: 413799241966727832978027,\n    599: 435350207840317348270000,\n    600: 458004788008144308553622,\n    601: 481818554503286362923739,\n    602: 506849831053734861481872,\n    603: 533159827070679866278987,\n    604: 560812778053476538349420,\n    605: 589876092712502332463864,\n    606: 620420507127059714307352,\n    607: 652520246268116112057164,\n    608: 686253193233019826880477,\n    609: 721701066553229757379480,\n    610: 758949605954969709105721,\n    611: 798088766967999186006767,\n    612: 839212924798226411060795,\n    613: 882421087896683264554175,\n    614: 927817121679723721849795,\n    615: 975509982873756796925504,\n    616: 1025613964982134990453294,\n    617: 1078248955392080004474789,\n    618: 1133540704665979618906662,\n    619: 1191621108583631746910145,\n    620: 1252628503530795506440909,\n    621: 1316707975853817969920561,\n    622: 1384011685831426958558879,\n    623: 1454699206941558115141676,\n    624: 1528937881135168275063375,\n    625: 1606903190858354689128371,\n    626: 1688779148601189609516729,\n    627: 1774758704783877366657989,\n    628: 1865044174831202682776536,\n    629: 1959847686321528964669495,\n    630: 2059391647140527228529479,\n    631: 2163909235608484556362424,\n    632: 2273644913597837330081136,\n    633: 2388854963699932382735982,\n    634: 2509808051552031608082535,\n    635: 2636785814481962651219075,\n    636: 2770083477684418110395121,\n    637: 2910010499193691843303014,\n    638: 3056891244979232231862474,\n    639: 3211065695545980277248740,\n    640: 3372890185488482409685019,\n    641: 3542738177508596708707874,\n    642: 3721001072479541451508397,\n    643: 3908089057205582486668934,\n    644: 4104431991606013700457110,\n    645: 4310480337124871462076948,\n    646: 4526706128254173781044298,\n    647: 4753603989138067267826945,\n    648: 4991692197319220372390544,\n    649: 5241513796775816319683700,\n    650: 5503637762499727151307095,\n    651: 5778660218961559003723580,\n    652: 6067205714919484306343541,\n    653: 6369928557132709817142929,\n    654: 6687514205661440172553650,\n    655: 7020680733548749464953877,\n    656: 7370180353811425547662139,\n    657: 7736801016790889035132284,\n    658: 8121368081058512888507057,\n    659: 8524746061205131302394950,\n    660: 8947840456000332817673697,\n    661: 9391599660555044587641517,\n    662: 9857016966290401433259592,\n    663: 10345132652677367520056676,\n    664: 10857036174895938656583295,\n    665: 11393868451739000294452939,\n    666: 11956824258286445517629485,\n    667: 12547154728067493595502055,\n    668: 13166169969647255482980383,\n    669: 13815241802783448943206160,\n    670: 14495806619536377005379418,\n    671: 15209368375944215483241988,\n    672: 15957501720133631304230773,\n    673: 16741855262985451980947171,\n    674: 17564154997755650263621500,\n    675: 18426207875324210441995136,\n    676: 19329905542049511423199336,\n    677: 20277228247502764885900784,\n    678: 21270248929688765106878025,\n    679: 22311137485682880566295780,\n    680: 23402165235974892374954302,\n    681: 24545709591163085124246501,\n    682: 25744258930034131533263392,\n    683: 27000417698448800353553865,\n    684: 28316911738879831363625420,\n    685: 29696593860867277871605321,\n    686: 31142449663120060247020395,\n    687: 32657603618448918933404658,\n    688: 34245325433219728719773420,\n    689: 35909036693513349075724695,\n    690: 37652317810725762600765183,\n    691: 39478915279883795756623331,\n    692: 41392749264546866860893416,\n    693: 43397921522754943172592795,\n    694: 45498723689129703063649450,\n    695: 47699645928878027716139269,\n    696: 50005385980149860746062163,\n    697: 52420858601901549459658530,\n    698: 54951205445179608281719072,\n    699: 57601805366500810491219000,\n    700: 60378285202834474611028659,\n    701: 63286531028521032840985510,\n    702: 66332699915362724119980694,\n    703: 69523232218023552371152320,\n    704: 72864864407855341219969825,\n    705: 76364642479247406973532354,\n    706: 80029935953661656574123574,\n    707: 83868452507581852374822598,\n    708: 87888253251761884175130183,\n    709: 92097768690318501305952845,\n    710: 96505815389469697877049934,\n    711: 101121613386982294887579670,\n    712: 105954804374756131323439197,\n    713: 111015470688345108146850290,\n    714: 116314155138696524440183805,\n    715: 121861881722882938654960142,\n    716: 127670177252209281782740521,\n    717: 133751093937700984130081285,\n    718: 140117232974725477106760252,\n    719: 146781769170263852819573505,\n    720: 153758476658245881594406593,\n    721: 161061755750279477635534762,\n    722: 168706660971164630122439117,\n    723: 176708930330666271859881567,\n    724: 185085015885255746880625875,\n    725: 193852115645795752984189381,\n    726: 203028206889569986197651315,\n    727: 212632080937520072186590492,\n    728: 222683379460186024851577401,\n    729: 233202632378520643600875145,\n    730: 244211297428606706709925517,\n    731: 255731801462210865865001525,\n    732: 267787583558210323920375877,\n    733: 280403140023083872114273884,\n    734: 293604071362025285843562670,\n    735: 307417131305664218954016427,\n    736: 321870277981032622582593573,\n    737: 336992727319136467572139095,\n    738: 352815008795455957133215652,\n    739: 369369023603738655757458075,\n    740: 386688105367749941220651375,\n    741: 404807083500032850651734059,\n    742: 423762349321394151918928481,\n    743: 443591925059596733749014862,\n    744: 464335535850798483634138280,\n    745: 486034684872448271784326296,\n    746: 508732731741838107613602755,\n    747: 532474974320122372524707631,\n    748: 557308734067567635805394638,\n    749: 583283445101886813536239875,\n    750: 610450747117966916191771809,\n    751: 638864582333908382360557376,\n    752: 668581296635294279311393900,\n    753: 699659745096778286894322787,\n    754: 732161402067670820574405230,\n    755: 766150476015982127183457373,\n    756: 801694029333610862568750951,\n    757: 838862103313805798709299373,\n    758: 877727848520950325159242658,\n    759: 918367660781873199488134935,\n    760: 960861323037560814483873080,\n    761: 1005292153304074193879898920,\n    762: 1051747159001957690209588887,\n    763: 1100317197924192833923669753,\n    764: 1151097146124113726578727360,\n    765: 1204186073016375022219516992,\n    766: 1259687423996378387111229150,\n    767: 1317709210896221493178043552,\n    768: 1378364210608578997366598385,\n    769: 1441770172223648126550509165,\n    770: 1508050033038752490738311726,\n    771: 1577332143815074048889599022,\n    772: 1649750503671651735806603894,\n    773: 1725445005022910006140645612,\n    774: 1804561688982956164492944650,\n    775: 1887253011677361609828822380,\n    776: 1973678121921532286407950000,\n    777: 2064003150743712843868729636,\n    778: 2158401513250589964731360493,\n    779: 2257054223353982965849642005,\n    780: 2360150221898687182164777966,\n    781: 2467886718753771981901721670,\n    782: 2580469549453004933593920862,\n    783: 2698113546994164480174756373,\n    784: 2821042929432312216467202070,\n    785: 2949491703928193388274450292,\n    786: 3083704087940340693022764503,\n    787: 3223934948277725160271634798,\n    788: 3370450258759473520427114109,\n    789: 3523527577258789108163787100,\n    790: 3683456542940343404363084600,\n    791: 3850539394533563994343413787,\n    792: 4025091510519029370421431033,\n    793: 4207441972141088280734057870,\n    794: 4397934150197476827913759850,\n    795: 4596926316595586652827474186,\n    796: 4804792281705797515062559743,\n    797: 5021922058584382849328869242,\n    798: 5248722555182613689484387822,\n    799: 5485618295704258477069984050,\n    800: 5733052172321422504456911979,\n    801: 5991486228508002426815719537,\n    802: 6261402475301701333080509487,\n    803: 6543303741858946450905285538,\n    804: 6837714561722963378455094385,\n    805: 7145182096283051986707103605,\n    806: 7466277096963606051213804496,\n    807: 7801594907743960700949000443,\n    808: 8151756509675604512522473567,\n    809: 8517409609130970421571757565,\n    810: 8899229771588828461969917962,\n    811: 9297921602834531195851268718,\n    812: 9714219979529959777862768265,\n    813: 10148891331187245215547993864,\n    814: 10602734975663191221223594155,\n    815: 11076584510377034355391142064,\n    816: 11571309261543787320061392679,\n    817: 12087815793808125625662163707,\n    818: 12627049482760689878061744701,\n    819: 13189996152918959195978870030,\n    820: 13777683783859651786576215682,\n    821: 14391184287298069419105856949,\n    822: 15031615358023124634594092724,\n    823: 15700142401714084441377203063,\n    824: 16397980542787591098996821750,\n    825: 17126396715550358417594267021,\n    826: 17886711842065410771034749979,\n    827: 18680303100276877491522988120,\n    828: 19508606286081561360311437674,\n    829: 20373118273183778133458320225,\n    830: 21275399574724765449983360003,\n    831: 22217077010838260632179411313,\n    832: 23199846486451169343993151122,\n    833: 24225475883821531494697782922,\n    834: 25295808074486832813101046425,\n    835: 26412764055483014097178757689,\n    836: 27578346214889968804237171486,\n    837: 28794641731961759722351371983,\n    838: 30063826117310982372086476080,\n    839: 31388166898835484452139885750,\n    840: 32770027459303858556350798600,\n    841: 34211871031752548278772284453,\n    842: 35716264859093977687647313415,\n    843: 37285884524590579748861394570,\n    844: 38923518460115987806848673270,\n    845: 40632072639400673752129300324,\n    846: 42414575463747094337180792099,\n    847: 44274182847997609942310578598,\n    848: 46214183514849300594196193732,\n    849: 48238004505931946889525421000,\n    850: 50349216918401212177548479675,\n    851: 52551541876147039010384562987,\n    852: 54848856745079917639394818823,\n    853: 57245201602333536237114022805,\n    854: 59744785969613964515539259105,\n    855: 62351995821331449988466091712,\n    856: 65071400878573831543609957267,\n    857: 67907762200418949875852866531,\n    858: 70866040084540107092698343096,\n    859: 73951402289532005957331751320,\n    860: 77169232591877674590168543277,\n    861: 80525139690988018278755885205,\n    862: 84024966476277979232856334449,\n    863: 87674799670795146675673859587,\n    864: 91480979866491345649258758095,\n    865: 95450111966823518214883921610,\n    866: 99589076052990565170686659417,\n    867: 103905038690755971019484297576,\n    868: 108405464695475636367939373595,\n    869: 113098129373644577851404473535,\n    870: 117991131259998859170817958839,\n    871: 123092905369958432777075796052,\n    872: 128412236987976529870072690275,\n    873: 133958276013169939669531019316,\n    874: 139740551884446204479331411000,\n    875: 145768989108216487062234772851,\n    876: 152053923412691097170490155923,\n    877: 158606118553696417431847045996,\n    878: 165436783797931931934295220337,\n    879: 172557592110602218633091543840,\n    880: 179980699075416049556058362840,\n    881: 187718762576041099642814429720,\n    882: 195784963269243383580949581161,\n    883: 204193025881123335512830178821,\n    884: 212957241359090878236182734445,\n    885: 222092489913497780851227603386,\n    886: 231614264984172822820073009257,\n    887: 241538698168481624527315178361,\n    888: 251882585148964518765460484674,\n    889: 262663412660090356154504995095,\n    890: 273899386535208029575034561337,\n    891: 285609460876378579895067651923,\n    892: 297813368391435715163322531331,\n    893: 310531651944349233813920512829,\n    894: 323785697366761254448562966675,\n    895: 337597767580427105501057917306,\n    896: 351991038082228660789452118410,\n    897: 366989633845435601723754690835,\n    898: 382618667692977386826261193199,\n    899: 398904280200653395819254517900,\n    900: 415873681190459054784114365430,\n    901: 433555192876539531087229255477,\n    902: 451978294728708525214023001725,\n    903: 471173670120985588372050797999,\n    904: 491173254835220446432862090800,\n    905: 512010287492584845146484412308,\n    906: 533719361988531136324395159455,\n    907: 556336482009740068071399064008,\n    908: 579899117714618242279047917300,\n    909: 604446264662056374189988834755,\n    910: 630018505076433611630379753807,\n    911: 656658071540248718776792346785,\n    912: 684408913209287275550344075013,\n    913: 713316764648893234122621625751,\n    914: 743429217393715213042975617565,\n    915: 774795794337240928934816284899,\n    916: 807468027061529837515792402675,\n    917: 841499536221802614337232047468,\n    918: 876946115104959930393838357571,\n    919: 913865816485680423486405066750,\n    920: 952319042908502961911588247808,\n    921: 992368640529229737341624411924,\n    922: 1034079996654109332431762911842,\n    923: 1077521141120571341397403386532,\n    924: 1122762851668802145076610697775,\n    925: 1169878763459173895733432737528,\n    926: 1218945482896482311379736998403,\n    927: 1270042705928112564209840426896,\n    928: 1323253340989653981276400185806,\n    929: 1378663636778122744608506419570,\n    930: 1436363315039845896899358328033,\n    931: 1496445708567209282036578487803,\n    932: 1559007904605896258842021462474,\n    933: 1624150893881942976244820893255,\n    934: 1691979725465930503404211099660,\n    935: 1762603667699924360130192603237,\n    936: 1836136375421380008668856717532,\n    937: 1912696063727159213943851080855,\n    938: 1992405688530070149968413761596,\n    939: 2075393134169954709485716047155,\n    940: 2161791408351324312330912522447,\n    941: 2251738844689892053427982289844,\n    942: 2345379313161090374436414551558,\n    943: 2442862438754801545567295092897,\n    944: 2544343828652090726779455860435,\n    945: 2649985308251720770267133439311,\n    946: 2759955166386673475403099789409,\n    947: 2874428410083806869907819978392,\n    948: 2993587029233173241168779714732,\n    949: 3117620271547411926979127053250,\n    950: 3246724928206047105940972859506,\n    951: 3381105630594468612010288127863,\n    952: 3520975158562887897616477410546,\n    953: 3666554760646647127956344306190,\n    954: 3818074486705953843294627812035,\n    955: 3975773533460423034845675035419,\n    956: 4139900603411771887815710365915,\n    957: 4310714277666637214536144927329,\n    958: 4488483403190813123215639907302,\n    959: 4673487495046245204241629451110,\n    960: 4866017154182911354694265206413,\n    961: 5066374501379277964399166419563,\n    962: 5274873627947390097986152243705,\n    963: 5491841063841846500452896053582,\n    964: 5717616263835974099255567733750,\n    965: 5952552112453464578853008309794,\n    966: 6197015448369619941842104648894,\n    967: 6451387609023188709970129910797,\n    968: 6716064996207615136996693074302,\n    969: 6991459663439386169435859778910,\n    970: 7277999925931103886207676505429,\n    971: 7576130994027952290703815097177,\n    972: 7886315630998429231248733036419,\n    973: 8209034836103596418058528755338,\n    974: 8544788553903729460741526714750,\n    975: 8894096410797147287955714755082,\n    976: 9257498479823236816318777820416,\n    977: 9635556074800288403768986034253,\n    978: 10028852574908795418824727341746,\n    979: 10437994280872373856676062879735,\n    980: 10863611303931504965592652844878,\n    981: 11306358488849924787366667765407,\n    982: 11766916372239763961801564990016,\n    983: 12245992177539511607834487453052,\n    984: 12744320848028628464246059627690,\n    985: 13262666119314202551196742822008,\n    986: 13801821632778520931079437719552,\n    987: 14362612091531863067120268402228,\n    988: 14945894460472306341153073892017,\n    989: 15552559212113915719970799358900,\n    990: 16183531619906475296861224625027,\n    991: 16839773100833956878604913215477,\n    992: 17522282609145324707635966077022,\n    993: 18232098083140097717852712346115,\n    994: 18970297947002453464660671155990,\n    995: 19738002669751617842096992232436,\n    996: 20536376383452971700767593594021,\n    997: 21366628562913781584556907794729,\n    998: 22230015769169865076825741905555,\n    999: 23127843459154899464880444632250,\n    1000: 24061467864032622473692149727991,\n    1001: 25032297938763929621013218349796,\n    1002: 26041797385576000582369625213281,\n    1003: 27091486754099167408984061096127,\n    1004: 28182945621039436811282417218990,\n    1005: 29317814852360484763188469380980,\n    1006: 30497798951058731380716134731126,\n    1007: 31724668493728872881006491578226,\n    1008: 33000262659235183814081519827753,\n    1009: 34326491852926110526276105821510,\n    1010: 35705340429956356495500048880518,\n    1011: 37138869521411924622451440267117,\n    1012: 38629219967069644267226780200798,\n    1013: 40178615358763694337831877170404,\n    1014: 41789365198477765393682507986660,\n    1015: 43463868175432916528376380161993,\n    1016: 45204615566598118821992112719830,\n    1017: 47014194765213080671467587361162,\n    1018: 48895292942081479136595740785155,\n    1019: 50850700844567331975836762416180,\n    1020: 52883316738408211899530127054215,\n    1021: 54996150497646497195116039121846,\n    1022: 57192327848174163803231700285962,\n    1023: 59475094770587936660132803278445,\n    1024: 61847822068260244309086870983975,\n    1025: 64314010106747559065438412709786,\n    1026: 66877293730881687431325192921834,\n    1027: 69541447366121616918816177545634,\n    1028: 72310390310983979753319152713934,\n    1029: 75188192227619293524858181464065,\n    1030: 78179078837859260757658669457252,\n    1031: 81287437832327804842152878336251,\n    1032: 84517825000485590628268677129623,\n    1033: 87874970589764795726619149717517,\n    1034: 91363785902248291467082481888195,\n    1035: 94989370137655453801161398756590,\n    1036: 98757017491716010698603869808070,\n    1037: 102672224519343960454073227246547,\n    1038: 106740697772366151410092496101554,\n    1039: 110968361721914939732387042839470,\n    1040: 115361366975961956826368092270559,\n    1041: 119926098802850790583643914139778,\n    1042: 124669185972080868004022654618279,\n    1043: 129597509924003418690815024769614,\n    1044: 134718214280513689012974236132740,\n    1045: 140038714709261994367964528304147,\n    1046: 145566709154360370820516947589011,\n    1047: 151310188447031979898125505211430,\n    1048: 157277447310137702096803724432844,\n    1049: 163477095771019024080265786609550,\n    1050: 169918070997619096807349078318498,\n    1051: 176609649573385253852206425342508,\n    1052: 183561460227017093724267411668558,\n    1053: 190783497033705025399011223174627,\n    1054: 198286133105105766051740791002035,\n    1055: 206080134785924286913455951259466,\n    1056: 214176676375616994965530422655441,\n    1057: 222587355394399185288134561600051,\n    1058: 231324208413431926871476886628488,\n    1059: 240399727469780275150398352541295,\n    1060: 249826877087477024806306436682550,\n    1061: 259619111926794902903903858282467,\n    1062: 269790395084626208521306859330203,\n    1063: 280355217069693265922512204254601,\n    1064: 291328615477166797747643128851965,\n    1065: 302726195388153340970512449363108,\n    1066: 314564150520428320398942429589829,\n    1067: 326859285157739328217944658021195,\n    1068: 339629036885985812650521091739503,\n    1069: 352891500165597792693064105229860,\n    1070: 366665450770488753893927654278831,\n    1071: 380970371125047658469252263285168,\n    1072: 395826476571763477972460354798893,\n    1073: 411254742603244027745802489871124,\n    1074: 427276933093600703409672633110750,\n    1075: 443915629565423279460548833975619,\n    1076: 461194261529865886819548193737883,\n    1077: 479137137938708024340405275972933,\n    1078: 497769479788644748304553495300446,\n    1079: 517117453919499510741582247311995,\n    1080: 537208208049543370281513128274546,\n    1081: 558069907092647074919064078269009,\n    1082: 579731770803589829653889090465310,\n    1083: 602224112799502127836867703068534,\n    1084: 625578381007131993715400129218655,\n    1085: 649827199587396195485096741151797,\n    1086: 675004412390512738195023734124239,\n    1087: 701145127996910209394091171983043,\n    1088: 728285766401075776846633724874013,\n    1089: 756464107397538946738052845597325,\n    1090: 785719340730295196686468011045384,\n    1091: 816092118069154575020287144949660,\n    1092: 847624606878758096201928227674051,\n    1093: 880360546248341702038727418718373,\n    1094: 914345304752746677204951178080640,\n    1095: 949625940417679322961779585842763,\n    1096: 986251262864814583017230902369159,\n    1097: 1024271897715020987348060381346241,\n    1098: 1063740353330761125682320075116819,\n    1099: 1104711089981595892462307006170625,\n    1100: 1147240591519695580043346988281283,\n    1101: 1191387439655339764253910592315288,\n    1102: 1237212390925574690626025966996290,\n    1103: 1284778456452494990829233226377379,\n    1104: 1334150984591030161739618104847170,\n    1105: 1385397746569649033264079085023363,\n    1106: 1438589025231051837956193683375282,\n    1107: 1493797706983703451005350179037500,\n    1108: 1551099377078977592324977502565855,\n    1109: 1610572418332734533482318570551190,\n    1110: 1672298113414349146588255526290127,\n    1111: 1736360750830546535004742869861557,\n    1112: 1802847734735894350158767668809929,\n    1113: 1871849698706449115822481531031302,\n    1114: 1943460623617864164855763103650900,\n    1115: 2017777959774244383161311335135412,\n    1116: 2094902753439183950276117590000925,\n    1117: 2174939777925753277977786731439319,\n    1118: 2257997669407716887103312005936867,\n    1119: 2344189067619971039484826726136835,\n    1120: 2433630761622095504505007624351926,\n    1121: 2526443840805024325560621670846260,\n    1122: 2622753851327163276606626468293628,\n    1123: 2722690958172823755991785784326387,\n    1124: 2826390113032612069265970456163500,\n    1125: 2933991228212416784843441604124699,\n    1126: 3045639356784883554548008634432380,\n    1127: 3161484879204764376319516386806829,\n    1128: 3281683696617285755657387337131749,\n    1129: 3406397431096706053660787897070925,\n    1130: 3535793633060536116646611744883745,\n    1131: 3670045996113488118329838058723628,\n    1132: 3809334579584105681944821254585338,\n    1133: 3953846039026223475533484851711932,\n    1134: 4103773864966917551549475742004630,\n    1135: 4259318630192449100691154502765975,\n    1136: 4420688245873885709566584952625897,\n    1137: 4588098226844616747507844508037264,\n    1138: 4761771966352875646576237849731855,\n    1139: 4941941020623653451737160975884815,\n    1140: 5128845403576048431946742302750170,\n    1141: 5322733892054158457915227866236060,\n    1142: 5523864341942100491068450472029219,\n    1143: 5732504015546648477080676455520535,\n    1144: 5948929920644332374606657683899745,\n    1145: 6173429161603651508297858791951031,\n    1146: 6406299303007341112943259722223788,\n    1147: 6647848746214407376439536432805536,\n    1148: 6898397119316930779355317551024978,\n    1149: 7158275680962446691834888697663475,\n    1150: 7427827738529064471293660118664110,\n    1151: 7707409081157399483953096394984678,\n    1152: 7997388428160886234821473483000555,\n    1153: 8298147893354134143293856722998488,\n    1154: 8610083465857701451154337181278065,\n    1155: 8933605507957017621037375468973282,\n    1156: 9269139270613202791504126859283685,\n    1157: 9617125427244236129299819591578718,\n    1158: 9978020626416337178370164768812546,\n    1159: 10352298064107568778430054733760345,\n    1160: 10740448076228572334937735566562385,\n    1161: 11142978752109030998555590333304243,\n    1162: 11560416569682950887414131083801684,\n    1163: 11993307053131181401163436777097233,\n    1164: 12442215453765791987839842332792770,\n    1165: 12907727454968012800119940123354311,\n    1166: 13390449902019461518054086533162960,\n    1167: 13891011557695348536983250121102793,\n    1168: 14410063884518310798493113995825913,\n    1169: 14948281854602503175542820411276425,\n    1170: 15506364788049610799716682308517542,\n    1171: 16085037220891570656183958875514689,\n    1172: 16685049803609043819824168449851071,\n    1173: 17307180231290097851615771678718278,\n    1174: 17952234206530182283975172821446800,\n    1175: 18621046436212348314484589328413725,\n    1176: 19314481663345819649385158162679300,\n    1177: 20033435735181507108244024178275807,\n    1178: 20778836708864920831259413450679734,\n    1179: 21551645995930215818617016034137500,\n    1180: 22352859546983857840754489692613399,\n    1181: 23183509077972665661421886007454584,\n    1182: 24044663339478824029548767493555588,\n    1183: 24937429430533921473492651656959612,\n    1184: 25862954158495203059166455452470495,\n    1185: 26822425446580095904068198565803164,\n    1186: 27817073790709723558345700246365971,\n    1187: 28848173767368633057992125893483779,\n    1188: 29917045594246378653834785571179351,\n    1189: 31025056745487001593014803461929555,\n    1190: 32173623623434883211416744742294747,\n    1191: 33364213288829995905464566634140396,\n    1192: 34598345251472305106432161856883007,\n    1193: 35877593323444056632515580254383154,\n    1194: 37203587537049994338271609307035630,\n    1195: 38578016129709269105524749061283955,\n    1196: 40002627598109003613035027587346239,\n    1197: 41479232824008249429294178038617951,\n    1198: 43009707274162500911950054844789890,\n    1199: 44595993276923101114218051405894000,\n    1200: 46240102378152881298913555099661657,\n    1201: 47944117779189310556261099429006223,\n    1202: 49710196859679394486867802358932901,\n    1203: 51540573788206651013836802198036893,\n    1204: 53437562223729812777303406841914935,\n    1205: 55403558110955564979344325681437822,\n    1206: 57441042572873737644094937785113022,\n    1207: 59552584903793044889004529388335732,\n    1208: 61740845666328821093587961517238033,\n    1209: 64008579895911365238424857597692590,\n    1210: 66358640416504598253672231293216761,\n    1211: 68793981271349892486345394543503614,\n    1212: 71317661272679283934970057444157431,\n    1213: 73932847674475963853859804733408932,\n    1214: 76642819972498112301511348487927130,\n    1215: 79450973835924928534740056571220837,\n    1216: 82360825175131287067719845184002304,\n    1217: 85376014350249959857626768802856615,\n    1218: 88500310525337959944194241004565748,\n    1219: 91737616173126446538485123122674660,\n    1220: 95091971735501962459496140992085663,\n    1221: 98567560445040729668418191983592407,\n    1222: 102168713313097495533124764187939944,\n    1223: 105899914290136190948927875636615483,\n    1224: 109765805604181632042444034426405625,\n    1225: 113771193283469872120310539095739833,\n    1226: 117921052869579803514689801523449638,\n    1227: 122220535327540435729044764084697099,\n    1228: 126674973159627164610485151798391797,\n    1229: 131289886729786527240095013237443045,\n    1230: 136070990805862651658706033366694460,\n    1231: 141024201327040104811696041691045190,\n    1232: 146155642404167375009402954907061316,\n    1233: 151471653560883058451095421311451141,\n    1234: 156978797223733228787865722354959930,\n    1235: 162683866469743733376335192519362494,\n    1236: 168593893040195573779320686453020964,\n    1237: 174716155629645388794651866300906835,\n    1238: 181058188459536679140275000227478496,\n    1239: 187627790146061111217741961494883890,\n    1240: 194433032872253346998515292619988830,\n    1241: 201482271874637706375741021005730181,\n    1242: 208784155255090933098578892158986338,\n    1243: 216347634128942766400406396453655835,\n    1244: 224181973120705296790445342451587490,\n    1245: 232296761219203590802475861123264133,\n    1246: 240701923004274209788971782007579802,\n    1247: 249407730257605432130910077287592727,\n    1248: 258424813970713646981839124047488243,\n    1249: 267764176763484957967824140618533500,\n    1250: 277437205727159975794000686688315348,\n    1251: 287455685706103555386947650491244181,\n    1252: 297831813033180334721514504126791124,\n    1253: 308578209734051855476222280888835192,\n    1254: 319707938216222310789920115620477565,\n    1255: 331234516459188101998422700026723439,\n    1256: 343171933722591949005782567849433641,\n    1257: 355534666789845852070090701405470932,\n    1258: 368337696765269337188595637416276068,\n    1259: 381596526443390734228095202493032600,\n    1260: 395327198269680365975835178420652411,\n    1261: 409546312912626108164576640399383898,\n    1262: 424271048467724485839916892830607059,\n    1263: 439519180314644983035319377172158032,\n    1264: 455309101649532274915393819410766690,\n    1265: 471659844715141371979173526935980437,\n    1266: 488591102752254955447569352295355812,\n    1267: 506123252696611256922641286254645760,\n    1268: 524277378646375504218896129395592376,\n    1269: 543075296126019045035073055561928520,\n    1270: 562539577173328634024088141916141596,\n    1271: 582693576277154906994867051360796655,\n    1272: 603561457194424687753064451343608383,\n    1273: 625168220675887416175494833282535136,\n    1274: 647539733131042629585359752478706350,\n    1275: 670702756263704072335812679441391888,\n    1276: 694684977710697693392039019806832594,\n    1277: 719515042717266582828863521396088515,\n    1278: 745222586883866905899271646915240282,\n    1279: 771838270020186251303063741763018130,\n    1280: 799393811143400700904158178331205389,\n    1281: 827922024658910558926936487548336568,\n    1282: 857456857763058308684876665745077292,\n    1283: 888033429108637280324653641355847207,\n    1284: 919688068775347054572190680423598070,\n    1285: 952458359588743164917093657911776850,\n    1286: 986383179832665621554422059019604497,\n    1287: 1021502747401614623677846147487591813,\n    1288: 1057858665441074072255055670604124719,\n    1289: 1095493969525365696982675003469664810,\n    1290: 1134453176424250386882487822532585142,\n    1291: 1174782334511180318623311370757902964,\n    1292: 1216529075867847432892383159101984374,\n    1293: 1259742670141472479018316728428818781,\n    1294: 1304474080213136065603158197122179375,\n    1295: 1350776019737370796417180820702333527,\n    1296: 1398703012615213588677365804960180341,\n    1297: 1448311454464961662889458094993182194,\n    1298: 1499659676156986538068572255824972432,\n    1299: 1552808009481139790520320395733292300,\n    1300: 1607818855017534550841511230454411672,\n    1301: 1664756752283809987147800849591201736,\n    1302: 1723688452234384707674372422071320679,\n    1303: 1784682992189681523983975379146100758,\n    1304: 1847811773275862853601073393199008865,\n    1305: 1913148640458255774876416600453369682,\n    1306: 1980769965254371045106648307068906619,\n    1307: 2050754731215233987976941410834180457,\n    1308: 2123184622266649887649796215921782211,\n    1309: 2198144114005025303125952328225613580,\n    1310: 2275720568045462559712283145467243327,\n    1311: 2356004329523040680859896842728890474,\n    1312: 2439088827851495409213115816339495726,\n    1313: 2525070680846917026164254568053937634,\n    1314: 2614049802327600836872111661056230165,\n    1315: 2706129513304814950403979441635984290,\n    1316: 2801416656882996994241981980679918559,\n    1317: 2900021716991759392273170147031719072,\n    1318: 3002058941076075680836616507226015622,\n    1319: 3107646466875142011769945929778234485,\n    1320: 3216906453424662618200536823961141148,\n    1321: 3329965216421699826558324552595808770,\n    1322: 3446953368095762574438358199469775528,\n    1323: 3568005961734486838351757966808790919,\n    1324: 3693262641017091556254336031236632750,\n    1325: 3822867794313779335421691039194332368,\n    1326: 3956970714114397433384120384166003416,\n    1327: 4095725761754986283464866437718755283,\n    1328: 4239292537616325490949332681096528358,\n    1329: 4387836056974246172531213471126988170,\n    1330: 4541526931687319371792477450694975225,\n    1331: 4700541557913558825461268913956492487,\n    1332: 4865062310053998559115610911870100035,\n    1333: 5035277741127427794082646196764289585,\n    1334: 5211382789787193810929017395424321210,\n    1335: 5393578994197824268512706677957552625,\n    1336: 5582074712996280787878705083147454523,\n    1337: 5777085353569942323599828874448120571,\n    1338: 5978833607890937159258923653545207827,\n    1339: 6187549696154203668120613167259109435,\n    1340: 6403471618474669930531089742522848797,\n    1341: 6626845414907208756853259936695984136,\n    1342: 6857925434061555771629308454994509373,\n    1343: 7096974610593182332652154711768629954,\n    1344: 7344264751860200848154682253520601870,\n    1345: 7600076834045756410267481267000412856,\n    1346: 7864701308055034793828023244287340980,\n    1347: 8138438415506002236313232141990462682,\n    1348: 8421598515143296812402544776496284973,\n    1349: 8714502420015324706702901500511538625,\n    1350: 9017481745765587687202719206979752339,\n    1351: 9330879270400591290587334955958115107,\n    1352: 9655049305908367725798746534773552348,\n    1353: 9990358082113704664098849646925432237,\n    1354: 10337184143168612691406936474627379320,\n    1355: 10695918757089402353832391602114778863,\n    1356: 11066966338764988954966020552846311185,\n    1357: 11450744886874712432979257653673465667,\n    1358: 11847686435168064074325478460954986607,\n    1359: 12258237518573265193633495987026371935,\n    1360: 12682859654616659385819889316805008574,\n    1361: 13122029840650374087829702479479965035,\n    1362: 13576241067401694028191547060980833568,\n    1363: 14046002849374084164798517831067165046,\n    1364: 14531841772646818920248481411605550560,\n    1365: 15034302060637734370093170532411179780,\n    1366: 15553946158411737537905952886830918329,\n    1367: 16091355336136399592075372322853441977,\n    1368: 16647130312305245611392419213169232605,\n    1369: 17221891897369251284144496300865473815,\n    1370: 17816281658437585657529146257903261665,\n    1371: 18430962605729818628447970674590396131,\n    1372: 19066619901483662703451906966061889217,\n    1373: 19723961592044861669045607586672623550,\n    1374: 20403719363889095930868650315257219250,\n    1375: 21106649324349767740001100592550916016,\n    1376: 21833532807850282420908580590825862986,\n    1377: 22585177208464977793681819296712788065,\n    1378: 23362416839659197789401547387242312544,\n    1379: 24166113822086183031380235679888630795,\n    1380: 24997159000346486985219767235597236100,\n    1381: 25856472889644547994140059803514309099,\n    1382: 26745006653306882839626895694957692242,\n    1383: 27663743112157144914230446319916689190,\n    1384: 28613697786775039130057416743650633105,\n    1385: 29595919973698836617070193875375888205,\n    1386: 30611493856665016404478212802210021309,\n    1387: 31661539654013410832232951778996345076,\n    1388: 32747214803422179685312303680676279243,\n    1389: 33869715185174019207110095647396061120,\n    1390: 35030276385193261591559928994266853030,\n    1391: 36230174999132974647956742131787699078,\n    1392: 37470729978831867653000833781535492047,\n    1393: 38753304022502786601002774984625192104,\n    1394: 40079305010057880061198034072619085310,\n    1395: 41450187485020176719746625583516317963,\n    1396: 42867454184517379844972195257339462150,\n    1397: 44332657618901196005888853882051385939,\n    1398: 45847401702584520468158717245312104000,\n    1399: 47413343437739346154537960139775251600,\n    1400: 49032194652550394774839040691532998261,\n    1401: 50705723795773236966373450556265512689,\n    1402: 52435757789401123913939450130086135644,\n    1403: 54224183941301948277230817879517159495,\n    1404: 56072951919745741389655873424027752720,\n    1405: 57984075791803952210030966295696158116,\n    1406: 59959636127664498822125654803605200455,\n    1407: 62001782172971294457628166694777458740,\n    1408: 64112734091363688056165357762141754716,\n    1409: 66294785279460087023332346767177823090,\n    1410: 68550304756601011890673498202891728627,\n    1411: 70881739631740035679525259959146526016,\n    1412: 73291617649946553739726907624791770380,\n    1413: 75782549821062183481895201583751205263,\n    1414: 78357233133132880842076215608511229415,\n    1415: 81018453353321656721019131504035339537,\n    1416: 83769087919092159661630333467319344902,\n    1417: 86612108922541440552472192615179632742,\n    1418: 89550586190851013626818983550558814889,\n    1419: 92587690465918960312381724727166445110,\n    1420: 95726696686332376146505918443171660625,\n    1421: 98970987374939026118276437676742560264,\n    1422: 102324056135379743432459471263142178485,\n    1423: 105789511261048976512902596439531532566,\n    1424: 109371079460060057837671640558228717300,\n    1425: 113072609699904337559514844445146843472,\n    1426: 116898077175609399692092533607036637857,\n    1427: 120851587405321266865514819340648620862,\n    1428: 124937380457358912643772141796859437854,\n    1429: 129159835312916652764103424563956670300,\n    1430: 133523474368721196662101633251149823925,\n    1431: 138032968084085429989744342641002104875,\n    1432: 142693139776940493084095678732486636969,\n    1433: 147508970573571548730224671300676243591,\n    1434: 152485604516930928407097683383484266510,\n    1435: 157628353838555246722760639034336216136,\n    1436: 162942704399270720489853224525723269795,\n    1437: 168434321304033467550147269349447360294,\n    1438: 174109054696419141315515890296286539118,\n    1439: 179972945738449034728553750103340839325,\n    1440: 186032232781617921513478910563182232444,\n    1441: 192293357735172557401982780429019456969,\n    1442: 198762972637879108865432799270626669004,\n    1443: 205447946439712986100137659510287259781,\n    1444: 212355372000105810413242676805207816705,\n    1445: 219492573309591728816879034317080350983,\n    1446: 226867112941909191440813277312570747145,\n    1447: 234486799743834826784604048875528356971,\n    1448: 242359696770253388472695000770509170206,\n    1449: 250494129472202113601016657658116885375,\n    1450: 258898694145869442049569648660373941152,\n    1451: 267582266650777119653998333871688332247,\n    1452: 276554011405631474170238269248906446792,\n    1453: 285823390670594346502222808229127105074,\n    1454: 295400174124997022998049389765214784995,\n    1455: 305294448749801797154111873648107967492,\n    1456: 315516629024405747970164359073870491229,\n    1457: 326077467447680222173319384811207626600,\n    1458: 336988065393447621514574974879775699372,\n    1459: 348259884310914705271679879631949049780,\n    1460: 359904757280909011630794460361074410538,\n    1461: 371934900939102477916959218389244857418,\n    1462: 384362927777754206102413138268506970021,\n    1463: 397201858837862893052822862772992037235,\n    1464: 410465136803989050790556876831592919085,\n    1465: 424166639514388116438037562729473373486,\n    1466: 438320693899488240621648045435196959242,\n    1467: 452942090362151303283202948578566379295,\n    1468: 468046097613572904390385124958730619192,\n    1469: 483648477979107092056857426409232236010,\n    1470: 499765503188744811845488653259134061244,\n    1471: 516413970667431889729975411863080081224,\n    1472: 533611220340883210895592492267492392503,\n    1473: 551375151973035052959106187501778547015,\n    1474: 569724243051777714078869714336553502625,\n    1475: 588677567240126095472954965375170347997,\n    1476: 608254813410517219620274841577537789254,\n    1477: 628476305280471269092869681239382035111,\n    1478: 649363021668417110482089106581996800736,\n    1479: 670936617389064931646215631627734512060,\n    1480: 693219444808308092528746108408911793239,\n    1481: 716234576078254109447577888083725273959,\n    1482: 740005826073621415936329176309708825539,\n    1483: 764557776051394742131574284792974302805,\n    1484: 789915798056308219059157433980611758115,\n    1485: 816106080095422250986408555099636706156,\n    1486: 843155652105778433840074131252109568468,\n    1487: 871092412739856974449839116812405949463,\n    1488: 899945156994323847635597208986502059289,\n    1489: 929743604708340998940330812008055415670,\n    1490: 960518429958522963981451968247615571768,\n    1491: 992301291378458055449596203783102865285,\n    1492: 1025124863431572512298240504372933893698,\n    1493: 1059022868667002481099668362066093137208,\n    1494: 1094030110989052198741424671895432081910,\n    1495: 1130182509971758083662737515471154158801,\n    1496: 1167517136251048459523457118438435734632,\n    1497: 1206072248027988195015615498189010425646,\n    1498: 1245887328717627537181110407053143579875,\n    1499: 1287003125779035759903231323132670516000,\n    1500: 1329461690763193888825263136701886891117,\n    1501: 1373306420616547671126845059808771245199,\n    1502: 1418582100279183135137313919163744611210,\n    1503: 1465334946617783561814630036179107930696,\n    1504: 1513612653734759530017526259861629678205,\n    1505: 1563464439696213993716384678301014319431,\n    1506: 1614941094722713228367155822930278965324,\n    1507: 1668095030888183105149797247519563263487,\n    1508: 1722980333373639710221714255936544610213,\n    1509: 1779652813323895051112691937493275900640,\n    1510: 1838170062356853750560836014387165897751,\n    1511: 1898591508776536523215092101916644734126,\n    1512: 1960978475542532205781057345396110080746,\n    1513: 2025394240050193548750246784190116959083,\n    1514: 2091904095777554301862779830720186765825,\n    1515: 2160575415856657801620130127396601613839,\n    1516: 2231477718628751807313395954393627156678,\n    1517: 2304682735244622286166458817442330457493,\n    1518: 2380264479373211819043135033180865953593,\n    1519: 2458299319083597933290739975588639913960,\n    1520: 2538866050967394665741511337736337646822,\n    1521: 2622045976570688763353306228619701197220,\n    1522: 2707922981206731940550655607258234921458,\n    1523: 2796583615222784382740474040856321114152,\n    1524: 2888117177796744121961996863481080757250,\n    1525: 2982615803341503976179051696005120224577,\n    1526: 3080174550597354460133578989992600710402,\n    1527: 3180891494495199523837557418419727460583,\n    1528: 3284867820875874297854866890890114734440,\n    1529: 3392207924153452428300151849140308700620,\n    1530: 3503019508013107340706503153715459439135,\n    1531: 3617413689236849218690486699230663550120,\n    1532: 3735505104753300028632631618647052984126,\n    1533: 3857412022010595043668172932897782160438,\n    1534: 3983256452774513571402317362452698824910,\n    1535: 4113164270457046596687344259862579939532,\n    1536: 4247265331083807518632379721321456268679,\n    1537: 4385693598011986873811172464601561040968,\n    1538: 4528587270513945762405321738705440092603,\n    1539: 4676088916345038581429933773569294261235,\n    1540: 4828345608417856657751813260670405103571,\n    1541: 4985509065708793590462102906287902242693,\n    1542: 5147735798526653777473353718656776051935,\n    1543: 5315187258276961029029844229698454778001,\n    1544: 5488029991859677773715074283837789258005,\n    1545: 5666435800842220652541448314024017081118,\n    1546: 5850581905553958890153341953182905874297,\n    1547: 6040651114252811450773802339294340809537,\n    1548: 6236831997519121462431059121804263835744,\n    1549: 6439319068036685669987130768251283335700,\n    1550: 6648312965925656816271400679772663779731,\n    1551: 6864020649797022030147590897007762961557,\n    1552: 7086655593703494823378002063833638733692,\n    1553: 7316437990166946592699616833531354911573,\n    1554: 7553594959467950148686513765206276332400,\n    1555: 7798360765388617440490476800142578927168,\n    1556: 8050977037605691145961262617379106893607,\n    1557: 8311693000936800120986617647413681760089,\n    1558: 8580765711648916968128569908862807858077,\n    1559: 8858460301044367459544239649173485609090,\n    1560: 9145050226546241655095435675456471213374,\n    1561: 9440817530511750873400887128525102883050,\n    1562: 9746053107008968945969854946579275550253,\n    1563: 10061056976799496323982724378320247274070,\n    1564: 10386138570776897699583240005533846228720,\n    1565: 10721617022118294111300879958656795681727,\n    1566: 11067821467414245473548388055474400555521,\n    1567: 11425091357050045737330444087123696839842,\n    1568: 11793776775119777282986614097061549565288,\n    1569: 12174238769162940693809364157051309012420,\n    1570: 12566849690022197996332017608789608083314,\n    1571: 12971993542129749223451407990577313551957,\n    1572: 13390066344539111423681390555352209300441,\n    1573: 13821476503028593889295382128265725457026,\n    1574: 14266645193612571525140101316505187638875,\n    1575: 14726006757806758281011522810861817647486,\n    1576: 15200009110004083021400239371051767831673,\n    1577: 15689114157328479953978540694207577474781,\n    1578: 16193798232344933888778097136641377589301,\n    1579: 16714552539015476523707617004948193446275,\n    1580: 17251883612302523293667801378616630723938,\n    1581: 17806313791832981004049940595952236488989,\n    1582: 18378381710048954709565959117356034045626,\n    1583: 18968642795283648606471174187975250526914,\n    1584: 19577669790214200898277149916663590160135,\n    1585: 20206053286156727802917377116665528100452,\n    1586: 20854402273682788549513827814948445887987,\n    1587: 21523344710050833153156141436233019518750,\n    1588: 22213528103960970088758743797991090055558,\n    1589: 22925620118156604193077050587843661667620,\n    1590: 23660309190412159054931489112539937306848,\n    1591: 24418305173462226026373553546995875617627,\n    1592: 25200339994444087406536213435901662689794,\n    1593: 26007168334442658312725535116810982082161,\n    1594: 26839568328744494665699148030346372021260,\n    1595: 27698342288425638399643940633635778570228,\n    1596: 28584317443916730715736989648170031498488,\n    1597: 29498346711208035625096160181520548669694,\n    1598: 30441309481376795323275876211869020871017,\n    1599: 31414112434139702720919278494304352579875,\n    1600: 32417690376154241824102577250721959572183,\n    1601: 33453007104814231206634568834252067530087,\n    1602: 34521056298307127650200260789840693447039,\n    1603: 35622862432723524773564047600591620474611,\n    1604: 36759481727032834297334619181982868193810,\n    1605: 37932003116763385216396036596083684144149,\n    1606: 39141549257250138871243034824146893141432,\n    1607: 40389277557338916599575631087245664105779,\n    1608: 41676381244462492794128018619459154745923,\n    1609: 43004090462031141893576046232131339283625,\n    1610: 44373673400108265833414174147846823131033,\n    1611: 45786437460370592180018097454654125762209,\n    1612: 47243730456382146639125256475201485557926,\n    1613: 48746941850241791637271332996842921594539,\n    1614: 50297504026695610706485495279896144769485,\n    1615: 51896893605837832676324724372468638684687,\n    1616: 53546632795557357169752166455397628534844,\n    1617: 55248290784921291361962286829338022618145,\n    1618: 57003485179722265948521834701738678421349,\n    1619: 58813883481452695155464304054870553436360,\n    1620: 60681204611006611632952513664174735563434,\n    1621: 62607220478448273296879161314388228250413,\n    1622: 64593757600226437608809675150800761682315,\n    1623: 66642698765254062321100804776702438717922,\n    1624: 68755984751315254218264566880232672144875,\n    1625: 70935616093304583685847007991159666098679,\n    1626: 73183654904848448867540438473174344075670,\n    1627: 75502226754904045590148716826986516533057,\n    1628: 77893522600978716067675261669847531834806,\n    1629: 80359800780661049649804576562965921695475,\n    1630: 82903389063205132690374405132401276101050,\n    1631: 85526686762960833261150746165714536727005,\n    1632: 88232166916496002397533755182876654157205,\n    1633: 91022378525311020523414800627504843113662,\n    1634: 93899948866102260607570160618726171594330,\n    1635: 96867585870588824684642587049077568806146,\n    1636: 99928080576976385190854302771818195507418,\n    1637: 103084309655193176038845274579543287624753,\n    1638: 106339238008096180814672350296895542938848,\n    1639: 109695921450910408688484641855278054316360,\n    1640: 113157509471230885841519620824589853318260,\n    1641: 116727248071985676199747488789041121983568,\n    1642: 120408482699828936375465082551662467674163,\n    1643: 124204661261505763907840490901149694071182,\n    1644: 128119337230805474780434782661196752002675,\n    1645: 132156172848797007097973143732608413596901,\n    1646: 136318942420119455804633282594364118870621,\n    1647: 140611535708182363299559887896839185406573,\n    1648: 145037961432214389489427685180617331098024,\n    1649: 149602350869185430852497209043356597608875,\n    1650: 154308961563716222079735293780517268790662,\n    1651: 159162181149181008424137378091161149008138,\n    1652: 164166531283303096726173462843072095335410,\n    1653: 169326671701640055015539018518705699850330,\n    1654: 174647404392455113639317800019372440640580,\n    1655: 180133677896574006306024799468201257241780,\n    1656: 185790591735932160859341593488427864239206,\n    1657: 191623400974625892978847721669762887224010,\n    1658: 197637520916393159778610138707329017740693,\n    1659: 203838531942564585384018857484505756167480,\n    1660: 210232184494643970555920434333513855824223,\n    1661: 216824404205799439501151597527348613503086,\n    1662: 223621297185671858108005694276757667011704,\n    1663: 230629155463036280733315769829856728366831,\n    1664: 237854462590985052006674013310829555807395,\n    1665: 245303899419437913541037116166052239846061,\n    1666: 252984350039925153650180418719145316631826,\n    1667: 260902907907734605017003921684746498516403,\n    1668: 269066882146662257820916698151184555362272,\n    1669: 277483804041759534527674431707495428212025,\n    1670: 286161433725627991209904771339900788624872,\n    1671: 295107767063974496251592243518106809957385,\n    1672: 304331042746306921569506210339059205494747,\n    1673: 313839749587822198745641666552447374489321,\n    1674: 323642634048715381224461508374001874352425,\n    1675: 333748707977320256428395802157949938763484,\n    1676: 344167256583679214774724367914264615318981,\n    1677: 354907846650332656774577448740278805781989,\n    1678: 365980334987316359577499492665661423156220,\n    1679: 377394877138559089794329589034333523822720,\n    1680: 389161936347082504011271085636055422264324,\n    1681: 401292292786621190557291178310378056588836,\n    1682: 413797053067502749043669672231562125696658,\n    1683: 426687660024856256094871226711613620285845,\n    1684: 439975902797452509721828685778957458838000,\n    1685: 453673927205721269316833783775783610703320,\n    1686: 467794246437739506976775111608393022209053,\n    1687: 482349752052240657962887540925835136720740,\n    1688: 497353725307958208396664918548576500570384,\n    1689: 512819848828887897371554062220903289550130,\n    1690: 528762218615331555088826226879544901167527,\n    1691: 545195356410872371074704272735369048924689,\n    1692: 562134222435726415975597022642148002675881,\n    1693: 579594228497218762288102882601473336765100,\n    1694: 597591251488444805746508999799665944566660,\n    1695: 616141647286498628873307956507246249662412,\n    1696: 635262265061980727342758633558885467930686,\n    1697: 654970462011837401470060834112028353314761,\n    1698: 675284118527933869908522234215965152162520,\n    1699: 696221653814122968723573796976021441661750,\n    1700: 717802041964941442478681516751205185010007,\n    1701: 740044828519446608929091853958115568986164,\n    1702: 762970147504097887787893822256219849371554,\n    1703: 786598738978990637725956554797278124357808,\n    1704: 810951967102164263980984405643613443347625,\n    1705: 836051838727132970358751925465426223753244,\n    1706: 861921022549226171951777077723669881527186,\n    1707: 888582868816776806015468170319304987709289,\n    1708: 916061429623659935353293704664261165680563,\n    1709: 944381479800161498529884419450242134471605,\n    1710: 973568538419648201851756811932637866236071,\n    1711: 1003648890939014757529114525804772812444576,\n    1712: 1034649611991404349880377024889805948451966,\n    1713: 1066598588850232767185892564930056790115492,\n    1714: 1099524545584096492698787529446425808960485,\n    1715: 1133457067922710638072138797746330685194571,\n    1716: 1168426628854604371943988173648061076656356,\n    1717: 1204464614977899904017040550277724793430409,\n    1718: 1241603353626116601935133531509635427501801,\n    1719: 1279876140791574929056038110412443745546155,\n    1720: 1319317269869626093912245397158785002901753,\n    1721: 1359962061247603108750056330533001022811146,\n    1722: 1401846892763077891420050435782921418973709,\n    1723: 1445009231056717653171633051674494164837538,\n    1724: 1489487663845762650867366119648959070605125,\n    1725: 1535321933144897017630429081796659362863565,\n    1726: 1582552969462055408849028210050341395113316,\n    1727: 1631222926997501215103529967929557707274660,\n    1728: 1681375219875327721201833943152266777825092,\n    1729: 1733054559437372469717283290044275542482740,\n    1730: 1786306992630397874710969065930279993530728,\n    1731: 1841179941518278501517284167616876198477309,\n    1732: 1897722243951848075290887164802970670035779,\n    1733: 1955984195429997917538913727371549522655006,\n    1734: 2016017592186583869120124322228807307858970,\n    1735: 2077875775538691593667272042037771337062872,\n    1736: 2141613677532831241625032098057988491948517,\n    1737: 2207287867926682588244859017849269988676029,\n    1738: 2274956602545091757332316519809900057062533,\n    1739: 2344679873050131347512524469147852330603290,\n    1740: 2416519458166178053962910323080826683013954,\n    1741: 2490538976402136614754617183069000726495038,\n    1742: 2566803940314147020741857199436825485292885,\n    1743: 2645381812353354350387072647528700656565179,\n    1744: 2726342062344598291243970336667065409029860,\n    1745: 2809756226643193380147979076327264594704745,\n    1746: 2895697969018322254247325865029474629995508,\n    1747: 2984243143312953802987213049129995837626487,\n    1748: 3075469857931627124375487934417729522202013,\n    1749: 3169458542208911724615579730356050273697000,\n    1750: 3266292014712865596629588272103919719684547,\n    1751: 3366055553539366839888542445766361166135204,\n    1752: 3468836968654792543650918885868953010691040,\n    1753: 3574726676346161983924385238571158169261725,\n    1754: 3683817775839551051322373817401051497424420,\n    1755: 3796206128149322537872121900182662159228241,\n    1756: 3911990437222503807420937006192549828899684,\n    1757: 4031272333444480835500888704164496363681686,\n    1758: 4154156459574067047582172896269352052007031,\n    1759: 4280750559177948266124532321685590709003370,\n    1760: 4411165567636502893727652799725970383582718,\n    1761: 4545515705795050750500358651870382988186314,\n    1762: 4683918576336696329734155119529513589827658,\n    1763: 4826495262955104262123827190438060829061153,\n    1764: 4973370432407778155253526316242844344573385,\n    1765: 5124672439532710418254508515826522600609941,\n    1766: 5280533435313631955425559713040649796775465,\n    1767: 5441089478081518530016413892489308199319929,\n    1768: 5606480647942507023374562583725669127988521,\n    1769: 5776851164524941659873115036048663114937695,\n    1770: 5952349508140909502130662763236950728528684,\n    1771: 6133128544460338166089749412557583307068767,\n    1772: 6319345652798518839604562697210438023241550,\n    1773: 6511162858120786446819766577778364926946013,\n    1774: 6708746966871038378408979787060247103179750,\n    1775: 6912269706733805859936155115580770892194054,\n    1776: 7121907870442710074828422368434553047727682,\n    1777: 7337843463751340976339671250105665526337260,\n    1778: 7560263857685892761905455418833343917244062,\n    1779: 7789361945202278758472065509114228369126600,\n    1780: 8025336302373932563237571980294779250756300,\n    1781: 8268391354240084356595173268406241855198176,\n    1782: 8518737545447984082077112629884273268761094,\n    1783: 8776591515826329476185591848477738781761689,\n    1784: 9042176281031049610986292577509011838783245,\n    1785: 9315721418408596645489064435708989370524469,\n    1786: 9597463258226012911089716132158337004512929,\n    1787: 9887645080421270408475092400425112950304770,\n    1788: 10186517317031728481382143156507032880864866,\n    1789: 10494337760463026157910800552509870425432010,\n    1790: 10811371777765321805152346144711499265489879,\n    1791: 11137892531088517813516189325593809889812108,\n    1792: 11474181204492965595127263976240658672733891,\n    1793: 11820527237297139926370474832027317722017807,\n    1794: 12177228564148905369732416163985994571309670,\n    1795: 12544591862012275060173347722472359244046903,\n    1796: 12922932804266987528897386291108558284524280,\n    1797: 13312576322123804564848753689176255125112158,\n    1798: 13713856873564166596625513497299706749207160,\n    1799: 14127118720018736045636750699617456881311725,\n    1800: 14552716211005418005132948684850541312590849,\n    1801: 14991014076953676011289439394970540421861988,\n    1802: 15442387730448363289492676946827168544596921,\n    1803: 15907223576132871507960364168750022280398562,\n    1804: 16385919329518164710931105850817769087241385,\n    1805: 16878884344951220830025131180984215659580858,\n    1806: 17386539953003552219964871974446413826117272,\n    1807: 17909319807547825412134603270711842061393357,\n    1808: 18447670242798154252456532648116438246904907,\n    1809: 19002050640597405466197703977606842321053540,\n    1810: 19572933808242837304672225027800498209481360,\n    1811: 20160806367149596270203427106156960870472824,\n    1812: 20766169152660030143204019897118002904900168,\n    1813: 21389537625315443974415368124511782893607123,\n    1814: 22031442293915835855052489509763576677617505,\n    1815: 22692429150702307814484325155610270148732358,\n    1816: 23373060119006260978552660565770602425866730,\n    1817: 24073913513719160198707702330267411589158084,\n    1818: 24795584514946598972622146485353975132184526,\n    1819: 25538685655220618058549873928821959736691905,\n    1820: 26303847320654738379516399526912590943781620,\n    1821: 27091718266436968469332058999564180929593866,\n    1822: 27902966147067146894819024985472934375689121,\n    1823: 28738278061756389082181003004910619210874204,\n    1824: 29598361115418134291077518460315335403586750,\n    1825: 30483942995692340860959609721949330792795099,\n    1826: 31395772566456765282571775715588003409132613,\n    1827: 32334620478291992350263579043602637456626234,\n    1828: 33301279796379969106727880491661424703794769,\n    1829: 34296566646329244238310747147664839490574535,\n    1830: 35321320878433937019039707727760782467717785,\n    1831: 36376406750887666110543978036746824592455791,\n    1832: 37462713632488269058784695792011875893039111,\n    1833: 38581156725384149030225659607573893303383795,\n    1834: 39732677808428507338475836002967756141425565,\n    1835: 40918246001723570069537718918088365292496141,\n    1836: 42138858552953206373244111655326855421732185,\n    1837: 43395541646119076823784928057386091817027588,\n    1838: 44689351233312655065605577356497222364030752,\n    1839: 46021373890173147491957400810472661489846635,\n    1840: 47392727695699507038180086415408337440470086,\n    1841: 48804563137103411752378288723762455918172986,\n    1842: 50258064040409270440055764682612968116562013,\n    1843: 51754448527527040549257397842950059733038281,\n    1844: 53294970000543912137117431914902281880953875,\n    1845: 54880918154001741201408795026747551723720527,\n    1846: 56513620015948521242261975310131861303268895,\n    1847: 58194441018574179427502571579696887885537742,\n    1848: 59924786099263589386584792985885004002385100,\n    1849: 61706100832922923109471297093651456522575000,\n    1850: 63539872596459336786702846316806859551222764,\n    1851: 65427631766318517268030842666066129833124679,\n    1852: 67370952950009825188774721810114716943378422,\n    1853: 69371456252574676254257996014226320491002233,\n    1854: 71430808578980422724679205565325409535341535,\n    1855: 73550724973449352362958820460243849915161295,\n    1856: 75732969996760532083864127998517020593740791,\n    1857: 77979359142591108905489195759391328910134418,\n    1858: 80291760293993362744249170815935430293952943,\n    1859: 82672095221134305875868191384112819286758200,\n    1860: 85122341121455964860570648618210990142492639,\n    1861: 87644532203446685358824902714882088097498633,\n    1862: 90240761315246892123800470058435668367783935,\n    1863: 92913181619346739765141403639335218061558813,\n    1864: 95664008314668029507699782676107535163671365,\n    1865: 98495520407358668662814112828386043342039288,\n    1866: 101410062531664839123433827120996801871554118,\n    1867: 104410046822283945831589672011997862390810762,\n    1868: 107497954839640363519148716631132136446924023,\n    1869: 110676339549566018509524250906452596245408440,\n    1870: 113947827358908961175629034752466582068886470,\n    1871: 117315120208635333752283890034504840221064086,\n    1872: 120780997726033548383095326244127836720276225,\n    1873: 124348319437674093156601079636921240241787962,\n    1874: 128020027044824211921357710559027384266649000,\n    1875: 131799146763063790207250005304405120478900361,\n    1876: 135688791727897158862480183289001251910301886,\n    1877: 139692164468205234207238255169848532611147557,\n    1878: 143812559449433484718637448310794816419480218,\n    1879: 148053365688463686582704780998822076298210405,\n    1880: 152418069442171341962802939167993644252844977,\n    1881: 156910256971726023650131079907915129924767174,\n    1882: 161533617384748818044426030157299715901448409,\n    1883: 166291945557499506406187783344043042314534878,\n    1884: 171189145139326194380356742395417581059236130,\n    1885: 176229231641671815409487530302217850452007387,\n    1886: 181416335613995339496338175675291780004357523,\n    1887: 186754705909030660706666553292223320927706878,\n    1888: 192248713039873061921465120214608474899151280,\n    1889: 197902852631451912018290889751846175017276700,\n    1890: 203721748969018888548080806839085873409222663,\n    1891: 209710158646353589075380551065506324110555541,\n    1892: 215872974316462949034790068311792114803360768,\n    1893: 222215228547627476999327377660931337519227930,\n    1894: 228742097787726004875938672290676073251112495,\n    1895: 235458906439851487440117948662414751746035425,\n    1896: 242371131052313431017875037233367567350390976,\n    1897: 249484404626207844803286441041017222801266718,\n    1898: 256804521043823251651497040551112296246458295,\n    1899: 264337439621241331244215401011574782781334700,\n    1900: 272089289788583262011466359201428623427767364,\n    1901: 280066375901447845568248481717977121765830398,\n    1902: 288275182187185106927480861934498895209154826,\n    1903: 296722377829749335448869068867067104949579464,\n    1904: 305414822196978537321624475491324386207138350,\n    1905: 314359570214253084228181897886953506729950270,\n    1906: 323563877888595040544848710079341268243350278,\n    1907: 333035207987381310882223234930566921371066351,\n    1908: 342781235875958450915909855966319285240611144,\n    1909: 352809855518564809408156722848357746339640390,\n    1910: 363129185647086702371268910149149152584766993,\n    1911: 373747576102299648025575523786476989131026713,\n    1912: 384673614352373402423945044973430693054218643,\n    1913: 395916132193550721591800039752382776657876433,\n    1914: 407484212638044530444951338680763930621994820,\n    1915: 419387196994336597778328640988515637140928750,\n    1916: 431634692145202999016827948773519398239274548,\n    1917: 444236578028937695571550278721551746219224713,\n    1918: 457203015329395575643972370763403591173830810,\n    1919: 470544453380630393038248327984084169870052370,\n    1920: 484271638292061317700921219995285769876393805,\n    1921: 498395621300264386957594139661914904785275330,\n    1922: 512927767353652135411965358701027725220931707,\n    1923: 527879763936476202951968110645920036905758794,\n    1924: 543263630138763896173977941441058199308011100,\n    1925: 559091725978980633941148481298313317618632967,\n    1926: 575376761986396071222827176058084413124270202,\n    1927: 592131809050322598728023510231907577504041350,\n    1928: 609370308543590994569721078158344505753246979,\n    1929: 627106082727829397306582084065079630894972195,\n    1930: 645353345448318619933615779058934561872409372,\n    1931: 664126713126409278261223804893870154281524038,\n    1932: 683441216057704415059243252710086070145621992,\n    1933: 703312310024435417776917212697059694728111811,\n    1934: 723755888230689211116144545349876787252027480,\n    1935: 744788293569381118983800284897623329523811384,\n    1936: 766426331230110600455862693324715237997598939,\n    1937: 788687281657286442867926694461098498097562065,\n    1938: 811588913868164118077309502293768840003949925,\n    1939: 835149499140701056072067990291237777551833530,\n    1940: 859387825081405748983159033075649135425638325,\n    1941: 884323210083634058665255574996164926064666511,\n    1942: 909975518187071057883524303147934812769277935,\n    1943: 936365174349429389500998978473009079907862954,\n    1944: 963513180141695685953126594506747030515761180,\n    1945: 991441129878565264237073831290682236831192947,\n    1946: 1020171227196022316757683410004293870517496706,\n    1947: 1049726302088348378540247976304143049122065214,\n    1948: 1080129828417176195331669321286587690711167057,\n    1949: 1111405941905549479818145590739116367242780000,\n    1950: 1143579458630301665664240006110545368915059329,\n    1951: 1176675894026428898785508782184245465533665048,\n    1952: 1210721482417504396219216523662601652136179376,\n    1953: 1245743197086563215894590527223118960072913202,\n    1954: 1281768770902278683167516719540860443130307320,\n    1955: 1318826717515654486899160825985211020969456836,\n    1956: 1356946353142870071117550937780046987060960843,\n    1957: 1396157818950341697358512735475562356104045295,\n    1958: 1436492104058497734745724852296636956267964954,\n    1959: 1477981069181214654702422049514025480619599210,\n    1960: 1520657470918320177914639277247113472181645153,\n    1961: 1564554986719042364085227429425894281463674979,\n    1962: 1609708240534768479916261201915809290266567989,\n    1963: 1656152829179975566133060952832169077820577902,\n    1964: 1703925349420706097654088225457498186848567210,\n    1965: 1753063425810487348828764073209783931216955698,\n    1966: 1803605739294132404035202382553315081341190088,\n    1967: 1855592056600414568536728473961840601327835478,\n    1968: 1909063260445175620937659060948648856259756235,\n    1969: 1964061380567012302624155966071951926644451875,\n    1970: 2020629625618285067432170725261207144994992239,\n    1971: 2078812415934808833368620144510853807585221613,\n    1972: 2138655417208217715431844885515291279369574680,\n    1973: 2200205575085644913617857845505033592721522553,\n    1974: 2263511150722025533817142690940119270064496250,\n    1975: 2328621757311014594133664064174539456980750339,\n    1976: 2395588397621215290008835331658621643021314292,\n    1977: 2464463502565134245725579502592034085209328984,\n    1978: 2535300970829021467547395315846813198183591546,\n    1979: 2608156209592513548223075037746157905702847505,\n    1980: 2683086176367779880674969950590007819202341357,\n    1981: 2760149421988673761061033114268064448054050548,\n    1982: 2839406134781213852952373747778159055380262422,\n    1983: 2920918185947567114582770377976676661508796149,\n    1984: 3004749176196572544459946686955919368234128060,\n    1985: 3090964483654736576896042159262866214940589314,\n    1986: 3179631313092546273793802882159493889001969611,\n    1987: 3270818746501886244063493400323024051287288941,\n    1988: 3364597795061310125684361619251416376860936489,\n    1989: 3461041452526908153028282986522280729367368365,\n    1990: 3560224750087529486464584716859554522268776125,\n    1991: 3662224812724162303217742306542356590926722479,\n    1992: 3767120917114346857096063738777247515406335526,\n    1993: 3874994551123597548057533501867770741416429535,\n    1994: 3985929474926940257994009093217001343955328335,\n    1995: 4100011783804831583821441379839563991285227198,\n    1996: 4217329972658917930562969936711305445974785514,\n    1997: 4337975002294315534109569503386742455494341143,\n    1998: 4462040367516348205694592687945941817364967127,\n    1999: 4589622167090968789784046573687400867942870250,\n    2000: 4720819175619413888601432406799959512200344166,\n    2001: 4855732917379000237574365609687488912697273143,\n    2002: 4994467742183366148074839035447416380393781644,\n    2003: 5137130903316893622770745464235084139384928426,\n    2004: 5283832637599517075572081746564260420858901705,\n    2005: 5434686247639634059061258993904042430607990074,\n    2006: 5589808186334383050291570992756471405633041387,\n    2007: 5749318143678144230778676663789672984169195116,\n    2008: 5913339135941752405965378691599572441324623941,\n    2009: 6081997597286587859405678030809218670282246785,\n    2010: 6255423473879432172551153347179787953125682826,\n    2011: 6433750320575743037411316728215679204642749660,\n    2012: 6617115400240816052275556661314890288999332009,\n    2013: 6805659785780163657391920602286596663406217911,\n    2014: 6999528464952353007567067145415164276505069670,\n    2015: 7198870448039506994791503590601126801607534137,\n    2016: 7403838878452687162912842119176262318542314409,\n    2017: 7614591146351445269661694564912786246445478891,\n    2018: 7831289005358953156344654888013498638339711692,\n    2019: 8054098692456299826324570548607480763080403880,\n    2020: 8283191051141781691732068101840743191755759916,\n    2021: 8518741657943308344041302580996941768179250799,\n    2022: 8760930952374403498169602637389577451855415964,\n    2023: 9009944370426700552244228695797096011740585251,\n    2024: 9265972481694316138437595284729122693073711400,\n    2025: 9529211130228034799395854632912272457677896880,\n    2026: 9799861579219855238744997642818047729388291567,\n    2027: 10078130659621135236933601810787303619515113811,\n    2028: 10364230922800330115415428619787879783434758914,\n    2029: 10658380797349150440403847607713189208549844510,\n    2030: 10960804750148870398245267228037581609577682339,\n    2031: 11271733451811500913798689538973402825112404379,\n    2032: 11591403946613603138135282386492611425148475178,\n    2033: 11920059827043660471886625110700606109457615243,\n    2034: 12257951413087152938966999455842406831025654415,\n    2035: 12605335936376788660643906067688568691477294599,\n    2036: 12962477729338745637101954446070534143126297085,\n    2037: 13329648419469265315863347103932314055721954884,\n    2038: 13707127128879519866370496154104287110788727040,\n    2039: 14095200679250350101462435045670967566714006190,\n    2040: 14494163802342243065803242497250145705564482929,\n    2041: 14904319356209789989230727462504226498494263931,\n    2042: 15325978547273839186092526952960232758544597811,\n    2043: 15759461158408637244144834830819680263402565217,\n    2044: 16205095783205438232082764786847977319531548455,\n    2045: 16663220066578357477963673318612506891057322162,\n    2046: 17134180951882656619355889974597586372298980947,\n    2047: 17618334934720173062514849536736413843694654543,\n    2048: 18116048323611252751541173214616030020513022685,\n    2049: 18627697507717313357328883548487129542980353125,\n    2050: 19153669231803058848943059805108758933859747374,\n    2051: 19694360878632389188479682121479772827588278091,\n    2052: 20250180758997203961018562965051517467373563574,\n    2053: 20821548409583589567679943310731809893410960813,\n    2054: 21408894898885309715106534167513145969112337635,\n    2055: 22012663141380091963647773040348591535494857021,\n    2056: 22633308220189922777870335143856096247251187948,\n    2057: 23271297718452433681930253947266040250043569734,\n    2058: 23927112059636485682887466272819725468557276242,\n    2059: 24601244857041242112722641487525252331485884885,\n    2060: 25294203272724365584159904646608138971697036406,\n    2061: 26006508386111487092631615069752229687889047419,\n    2062: 26738695572545778772495897103306702147812265676,\n    2063: 27491314892043320887814631666080168776331811888,\n    2064: 28264931488526992879603605279805458570836160570,\n    2065: 29060125999818842393508123538658855855869573724,\n    2066: 29877494978678299986437859187588252356283557915,\n    2067: 30717651325181215594079225685922159612710890246,\n    2068: 31581224730742500897001026737587458361246031363,\n    2069: 32468862134093174645484430948409904593113694670,\n    2070: 33381228189530831120385246576357623531476650368,\n    2071: 34319005747770990684777087747947525376490393829,\n    2072: 35282896349735451425203004555804514075824949148,\n    2073: 36273620733622647942922713748119798292462316154,\n    2074: 37291919355614143333586997222803939193763027250,\n    2075: 38338552924580739339245889549713324449360541521,\n    2076: 39414302951161293776274047281093717842584188891,\n    2077: 40519972311597190003244878215733219997449415843,\n    2078: 41656385826715516924455731088372893657996361228,\n    2079: 42824390856464396526209228476474575762774879465,\n    2080: 44024857910414546084950481401735302373848095782,\n    2081: 45258681274652091016547586287700221970008068755,\n    2082: 46526779655498859083237494859206365034702358134,\n    2083: 47830096840507894753763929606166424148960110424,\n    2084: 49169602377193741528342591922356853935149504975,\n    2085: 50546292269969157794099110029993948769746687671,\n    2086: 51961189695772366269783089381199090558960547606,\n    2087: 53415345738881696537662435419712492307334180478,\n    2088: 54909840145427572963129830596638040418770704515,\n    2089: 56445782098125235102442269204682620745124030885,\n    2090: 58024311011765363351557172881384457469348901699,\n    2091: 59646597350013928176910703744766844433767270677,\n    2092: 61313843464087096107973721257849778294625405081,\n    2093: 63027284453881919316292784641070835053831354052,\n    2094: 64788189052158817856342546799691255570877518150,\n    2095: 66597860532387544551063529093372826237515675728,\n    2096: 68457637640884412378329010378860869685804024262,\n    2097: 70368895553885073626926030071097479233359907864,\n    2098: 72333046860214079886074787715712944920415424984,\n    2099: 74351542570229833233029956235268391407949627875,\n    2100: 76425873151741373195807749021080021459080291165,\n    2101: 78557569593611742891613633197716231871513782517,\n    2102: 80748204497781453174729297053600127492388932998,\n    2103: 82999393200464827976246067679320326020971457938,\n    2104: 85312794923291779902869927934730036659721510375,\n    2105: 87690113955187845526792666366851401712801134274,\n    2106: 90133100865806117918203480753613859038381596324,\n    2107: 92643553751346063460833585063932351673594098859,\n    2108: 95223319513616114811576859302283546424619314506,\n    2109: 97874295173219406337291510865301717288885200445,\n    2110: 100598429217765077170980775830078597915978709260,\n    2111: 103397722986031225236603653787203378188231402292,\n    2112: 106274232089029868642533106912359104776603150690,\n    2113: 109230067868949174578477633685673008965957469120,\n    2114: 112267398896973766514395710229044460157179222920,\n    2115: 115388452511010134752244464747991318862444784689,\n    2116: 118595516394371070307305070689995677519803374830,\n    2117: 121890940196500635216372474879596908517840948778,\n    2118: 125277137196849491653446187682001921308870438795,\n    2119: 128756586013039456106279781429309224204637155235,\n    2120: 132331832354485942225817194731144948296095338913,\n    2121: 136005490822677526183628341619662696228169437779,\n    2122: 139780246759343231332496879136294914183920566235,\n    2123: 143658858143770305041408732118198629930850140819,\n    2124: 147644157540568270666807354340091712330909224000,\n    2125: 151739054099208903158067016467162544501125246216,\n    2126: 155946535606706519753573960842521384418556790909,\n    2127: 160269670594838620141199867367375227901178121673,\n    2128: 164711610503343476443764262455655533446463188624,\n    2129: 169275591900568786145109713871008667212574145360,\n    2130: 173964938763083984897646967444489323060065487907,\n    2131: 178783064815808295968062329270497666350416021621,\n    2132: 183733475934247094438727208707795835845879643176,\n    2133: 188819772610470713392617031395550078686410106988,\n    2134: 194045652484512443040038057363040342445733893240,\n    2135: 199414912942906199650168544999618866932966543484,\n    2136: 204931453786129197483756438132982529754356479553,\n    2137: 210599279966760972657750340621024569609658319243,\n    2138: 216422504400217312716806872498425178952708753752,\n    2139: 222405350849966070103844047835296998593257719870,\n    2140: 228552156889181512949138540918848061266047740791,\n    2141: 234867376940844824665120188180587152072518199582,\n    2142: 241355585398350637585388084310633650150819331465,\n    2143: 248021479828733108998565670865001643954560554353,\n    2144: 254869884260680054932039940494913967190530868955,\n    2145: 261905752559560083345100350260758248905652921875,\n    2146: 269134171891745550301357546978902318483150550307,\n    2147: 276560366280573537433149830945908221546675684073,\n    2148: 284189700256347954756384460822072399114186994724,\n    2149: 292027682602848348780952829894171946286185196525,\n    2150: 300079970202875082019467410865495625479979094694,\n    2151: 308352371985426287572392634796034918345831989966,\n    2152: 316850852977169433649870812195036854291507911207,\n    2153: 325581538460939500937426146405250734530774231825,\n    2154: 334550718244066724977417207615678241114465752975,\n    2155: 343764851039409631696645200323540686552303329604,\n    2156: 353230568962043743490045985418104968175497835998,\n    2157: 362954682144632903677995273534058279957414924705,\n    2158: 372944183474588707707117294510467908715140736065,\n    2159: 383206253456204090418195791785818308423831594945,\n    2160: 393748265201029751587449904786884268416346918520,\n    2161: 404577789549846859589538794509144411672022826612,\n    2162: 415702600329676409598230534926593885982499170401,\n    2163: 427130679749354783768755297437892949499654467597,\n    2164: 438870223937296523272831771890659665602286473475,\n    2165: 450929648625159134260052749493609306300370136632,\n    2166: 463317594981220971649101966934064855005088490212,\n    2167: 476042935597381937471938911243959272191670950572,\n    2168: 489114780633797957215706040263930987465371910798,\n    2169: 502542484125264022730810437527574105649622691760,\n    2170: 516335650453567079927347553251246871212620557984,\n    2171: 530504140990139261462232960508189648909724886170,\n    2172: 545058080913453988432836606455557467047353067377,\n    2173: 560007866205722361999363584087410496745060913524,\n    2174: 575364170833565108914383039346175332072363129225,\n    2175: 591137954117456209042263051672264094963902965317,\n    2176: 607340468294858294890172396576637459876728673686,\n    2177: 623983266282097051667127111749751355541610352255,\n    2178: 641078209640152242143041148426227499209194350336,\n    2179: 658637476749676716333547258428298949880301221655,\n    2180: 676673571200691926609848235322274189175428592431,\n    2181: 695199330402549141183113024435698489390907024630,\n    2182: 714227934419889822186067591088150189762713935508,\n    2183: 733772915040486600160233205517764582904605949651,\n    2184: 753848165080998028345195047409661205734061410010,\n    2185: 774467947936825933802831039011913166290856798904,\n    2186: 795646907382423796556925927113569848920749045025,\n    2187: 817400077628568283525440629036885986580578161120,\n    2188: 839742893643273944545131128461036809985928936965,\n    2189: 862691201743203249313515607587263855592485446510,\n    2190: 886261270462600715344592984957682094231262687955,\n    2191: 910469801706960959527768615813845716032362752763,\n    2192: 935333942198826213870111109341848015258586306792,\n    2193: 960871295223299296636466125655717340185883228697,\n    2194: 987099932681053343467853379878084516482176109430,\n    2195: 1014038407456819902258601282188003020164821077713,\n    2196: 1041705766111542406799393149921058024912789843193,\n    2197: 1070121561906592696806185003711836723976318646033,\n    2198: 1099305868168664278558814578725663660095230751347,\n    2199: 1129279292004177556899411779284367814322107068750,\n    2200: 1160062988372259455129906418328374912794875140516,\n    2201: 1191678674525592817234330378465180518007035567938,\n    2202: 1224148644828669903250292851179037002332204681842,\n    2203: 1257495785963229293609758350537517985043490101070,\n    2204: 1291743592530906765707814604565428064732892610835,\n    2205: 1326916183063388353539586696826007823016666575690,\n    2206: 1363038316450618010620081932775702626766948267742,\n    2207: 1400135408797883233268006240578157606704308520406,\n    2208: 1438233550722879835539717164127729784341377881813,\n    2209: 1477359525104141972742451850876428128946776467300,\n    2210: 1517540825292515665993072463432902551892845533240,\n    2211: 1558805673797653668641491334803497135876242089678,\n    2212: 1601183041461816724044580259727354612842328867083,\n    2213: 1644702667133581285344348736857245137869671730074,\n    2214: 1689395077854376798567156661483099222514277324220,\n    2215: 1735291609571106892437555774714449031725527460139,\n    2216: 1782424428388448478757191595009703327418571383436,\n    2217: 1830826552374771058174587388568897962322872702465,\n    2218: 1880531873935975665104704330318867749822093808655,\n    2219: 1931575182771919095318938056959674511017686068185,\n    2220: 1983992189430464568754141912398798172706580941262,\n    2221: 2037819549474585022525115674537508812727151594151,\n    2222: 2093094888278340044956073813211683523416074682898,\n    2223: 2149856826467952296650447653773869417501164619869,\n    2224: 2208145006024624371311040214176565237134381870625,\n    2225: 2268000117066162685610486257867691977952149636083,\n    2226: 2329463925324911418747662088887963091854286975547,\n    2227: 2392579300339947019867081675868949317697298397221,\n    2228: 2457390244381942643492189138307718097264928854677,\n    2229: 2523941922129582344692758164350149756471869195790,\n    2230: 2592280691116887259141942758496845583141659899537,\n    2231: 2662454132971310608073787558386111506684369385813,\n    2232: 2734511085462965511444391934177140596906494183587,\n    2233: 2808501675385869578994261445169376899379754972068,\n    2234: 2884477352292623400907075579322579400861330771315,\n    2235: 2962490923104486707892612022451087039141493329190,\n    2236: 3042596587619376453548710860694923114675620792521,\n    2237: 3124849974940885736970186673957557524827120772983,\n    2238: 3209308180852011686602310843936272621314792055526,\n    2239: 3296029806157884531966398832249411659082252110525,\n    2240: 3385074996022409471869790373849802994298808805690,\n    2241: 3476505480324367989101580130555189921672623462046,\n    2242: 3570384615059176354982401320439389024740905215964,\n    2243: 3666777424813166614813801947045518673161561892966,\n    2244: 3765750646337939759592154130429553527537766985115,\n    2245: 3867372773253042492891322334008521298830352179629,\n    2246: 3971714101905938427653556222571377434088646307540,\n    2247: 4078846778418982139592272233327190495676444439866,\n    2248: 4188844846953860716858469962505733762730156946697,\n    2249: 4301784299224742745702713528067084946594634381000,\n    2250: 4417743125292169536796493320206228992803910550343,\n    2251: 4536801365670538316236136117174461033288094273661,\n    2252: 4659041164782862580763013973003868359053553220232,\n    2253: 4784546825797351362566231731168417844332785838733,\n    2254: 4913404866881227292111965728061869527659853830530,\n    2255: 5045704078908103627757617096847635981526636026359,\n    2256: 5181535584656163391837451036356625290841516214407,\n    2257: 5320992899535329981545125277691916180855473998805,\n    2258: 5464171993882588690437588095807084889323827738187,\n    2259: 5611171356865613078294130300389571289206397311350,\n    2260: 5762092062035869673687412904560243239930531635515,\n    2261: 5917037834573419710379575999541430738890622626340,\n    2262: 6076115120266708126452900640242923623341866228338,\n    2263: 6239433156271728550695355451490575993085942292134,\n    2264: 6407104043696079137218319509378718229702705761905,\n    2265: 6579242822054578576274630855578948789533455298734,\n    2266: 6755967545644295113522674510292835122483775946206,\n    2267: 6937399361888054675782970897485983723264323011797,\n    2268: 7123662591696737970806754341094737575112103730614,\n    2269: 7314884811901951462222340761939935289641834289395,\n    2270: 7511196939811964197947649707463044206175866380723,\n    2271: 7712733319945142389521924617582058172801542180874,\n    2272: 7919631812996487219317452100595913257543028088576,\n    2273: 8132033887094289430962576814720449927838393960827,\n    2274: 8350084711405357694774361105408889911972402015300,\n    2275: 8573933252148757415018198504928925593185861873742,\n    2276: 8803732371079513461579268567498022304249933730391,\n    2277: 9039638926505285189617314422998964084970595438542,\n    2278: 9281813876900616004271298745383250743059729594527,\n    2279: 9530422387184993604151073155371828079705355168950,\n    2280: 9785633937732631891816046069641124632254214557235,\n    2281: 10047622436183602390848394841406802515973193043806,\n    2282: 10316566332127702901769041143039403233989122380996,\n    2283: 10592648734734255132957468343310308444321456043571,\n    2284: 10876057533402872254341014560334244700946683620780,\n    2285: 11166985521512132864360358955503173717957792328653,\n    2286: 11465630523345040885726361109312137419668093929920,\n    2287: 11772195524272142592252579142228927699835475405262,\n    2288: 12086888804275213526126666074714236379441857513978,\n    2289: 12409924074896520730686758323108856061617655222490,\n    2290: 12741520619700810766902679602920740106349316265795,\n    2291: 13081903438339372702369995825105861818651826992639,\n    2292: 13431303394307778991751050067148151893379620506077,\n    2293: 13789957366491217272065156663906255405414311071587,\n    2294: 14158108404593693973445004415760318309772932242370,\n    2295: 14536005888549817728742960090051403934327801222156,\n    2296: 14923905692020358321733692442892587286459907678047,\n    2297: 15322070350075326847761463298913968554265401515217,\n    2298: 15730769231170936413643835624649288938501733002618,\n    2299: 16150278713529481654471379166675899361510665760775,\n    2300: 16580882366033921211442301450921091904365926280416,\n    2301: 17022871133751761754598643267756804218108498650480,\n    2302: 17476543528205726845562009156571175360531579106807,\n    2303: 17942205822511650658087298129211531345495818175057,\n    2304: 18420172251507067091174412069974707159021665744880,\n    2305: 18910765216997070947078996545777114475682919623589,\n    2306: 19414315498247211476154846356983916621521411447697,\n    2307: 19931162467856441629277246980513463599759674413041,\n    2308: 20461654313146490770914182133145338856645809727187,\n    2309: 21006148263207456404192932627622104852595304280970,\n    2310: 21565010821742923705373368869534441911701199887419,\n    2311: 22138618005861522471365237940368652982888104075000,\n    2312: 22727355590965521614482418924663783733921186781149,\n    2313: 23331619361890843810727406215610806254135308857160,\n    2314: 23951815370456759593096244705083096637451017834880,\n    2315: 24588360199587493406897494649744406335205727290057,\n    2316: 25241681234172046294108468111219387029991510514102,\n    2317: 25912216938832713390963025920891990759428674050912,\n    2318: 26600417142777051809706408361950504454660772072685,\n    2319: 27306743331912438295458811467722364839525869129400,\n    2320: 28031668948406848928849481174161195141360108410956,\n    2321: 28775679697884097775242882020060349688803476984805,\n    2322: 29539273864446490518541231137563989837057604952179,\n    2323: 30322962633722685585711432023667002655631855893969,\n    2324: 31127270424143511960418282768032077800615961592375,\n    2325: 31952735226653572764265207581869821725011637243487,\n    2326: 32799908953071669788426324706615644528794262188810,\n    2327: 33669357793318419597396187557448074241909961160527,\n    2328: 34561662581734899786701292837993789078148269659948,\n    2329: 35477419172721767722086620675579581559062365395875,\n    2330: 36417238825934036963035091771377814636876895938849,\n    2331: 37381748601272582004301821355152191840543933044480,\n    2332: 38371591763919473464910961559285225914454949449279,\n    2333: 39387428199670427009917909560877277324279071654230,\n    2334: 40429934840823983789090419362572880622618841036000,\n    2335: 41499806102893531791299424581039874366426784160676,\n    2336: 42597754332414930108684698464207986438238414531147,\n    2337: 43724510266129315639709919648795164529190983190550,\n    2338: 44880823501827658290753362113015735891775860228025,\n    2339: 46067462981150790416506320013365490407603364278280,\n    2340: 47285217484645973326080769865489605746387338228688,\n    2341: 48534896139388582534016509015707084448606794509814,\n    2342: 49817328939485198519236927086579980055136752412153,\n    2343: 51133367279782285645165745517535680609133370052296,\n    2344: 52483884503112733276871946748564813602003527319855,\n    2345: 53869776461420824806590383880147822175719204551469,\n    2346: 55291962091114697184508819760614991511857392669436,\n    2347: 56751384003004060684283391440819878903446789803099,\n    2348: 58249009087189871171927544609837628960380623034142,\n    2349: 59785829133281790377677305788784327434428364970750,\n    2350: 61362861466328639006942053695686748622617850877171,\n    2351: 62981149598856648513992946515066172932792511110884,\n    2352: 64641763899420155681002068750650481144652897951882,\n    2353: 66345802278079465613952539750862814246981008871159,\n    2354: 68094390889230939345801166300675543634997580023495,\n    2355: 69888684852224948030989898005576415781403878920995,\n    2356: 71729868990218182977254525351745038902483193889528,\n    2357: 73619158587717925895914811729724245783180985354842,\n    2358: 75557800167287273321320320811040130784252221919060,\n    2359: 77547072285891979874115998945868567670402747044445,\n    2360: 79588286351381543804941144999617740627898062871643,\n    2361: 81682787459609412105690788920445375282931841060492,\n    2362: 83831955252709738636327407566454519669269037443061,\n    2363: 86037204799060994583504133500298291142599767525961,\n    2364: 88299987495479913719532319572840702828357104994815,\n    2365: 90621791992202763126914659986946872015595738278003,\n    2366: 93004145141224771243446359569837640488487305606833,\n    2367: 95448612968582727407224954007027627693270062216153,\n    2368: 97956801671180298878693599735216669857785613237715,\n    2369: 100530358638770501129135789786132580428696541463525,\n    2370: 103170973501725013759939661850158896906366983382795,\n    2371: 105880379205235666714568162057607929186246674835477,\n    2372: 108660353110609438642727243903401536959027659486124,\n    2373: 111512718124334720773264584058717478384571245088082,\n    2374: 114439343855613415076071522953096149591716910973500,\n    2375: 117442147803070664704054798350668120890654926300513,\n    2376: 120523096571371667803183996442776155815729810091602,\n    2377: 123684207118493113105268436573489685721321552781151,\n    2378: 126927548034415307868377394917913546501247383867613,\n    2379: 130255240852020056553944404306572055559539047530145,\n    2380: 133669461390998803240347188535274022509125836065110,\n    2381: 137172441135595483551688849972013947996581871778170,\n    2382: 140766468647028954484433593096055372616292751308832,\n    2383: 144453891011460794882135190497537058556764977948995,\n    2384: 148237115324395707667015292482470242745754168289775,\n    2385: 152118610212423719809411357105042520067307779240520,\n    2386: 156100907393235880227548485941067592747534460439448,\n    2387: 160186603274868212495995174730244824826286924759060,\n    2388: 164378360595152301854136694694118079266206458932708,\n    2389: 168678910102375098323537690529566365095195830119715,\n    2390: 173091052278175313875346442702502205694341724313429,\n    2391: 177617659103729195986746184184236646145304254737028,\n    2392: 182261675870304487388520687355584130250935690880972,\n    2393: 187026123035288047490867195922886699634867141186408,\n    2394: 191914098124819930404162679326110679178204492902970,\n    2395: 196928777684194703542432119373410255613845416290627,\n    2396: 202073419277219465790162920942761564437025278844409,\n    2397: 207351363535747401800832745531222095970123079470866,\n    2398: 212766036260635806253027202800291886071043511130893,\n    2399: 218320950575408346303872686615815518603736687265550,\n    2400: 224019709133932919957689061390552862746031758458304,\n    2401: 229866006383458830949778967121025947053151071434926,\n    2402: 235863630884390155812442175854014517889393984836232,\n    2403: 242016467688206145276344061824939391497289921344319,\n    2404: 248328500774974299762177021852107412058234599633660,\n    2405: 254803815551937407606287486346848530864431251682411,\n    2406: 261446601414692355496335282873363983668020889836360,\n    2407: 268261154372515934523018586706764224652758295238166,\n    2408: 275251879739431193944393927980843975448015734231456,\n    2409: 282423294892647160394499527988292633580813431968720,\n    2410: 289780032100044965565638185282633831588088504297253,\n    2411: 297326841418424633617945474627449518623223932967198,\n    2412: 305068593664268994544312629723329236676843814611957,\n    2413: 313010283458824435839645487672681448751536128120719,\n    2414: 321157032349342507073515697424466804962980378707300,\n    2415: 329514092008371775927573078641257544141430283832310,\n    2416: 338086847513035826131406156272669425469096435441169,\n    2417: 346880820706280914339971199061511110032851886967137,\n    2418: 355901673642125591813707043622534952223283339280101,\n    2419: 365155212116994575920151188842851740380508864908970,\n    2420: 374647389289270354779812696943359199223073776527524,\n    2421: 384384309389248455327267290257609074709972871788879,\n    2422: 394372231521736030856900123129107963761511852907062,\n    2423: 404617573563588459702218138566029837845857058362469,\n    2424: 415126916158535023731030449746058156911457360217500,\n    2425: 425907006811702486258611691435747829051036619210903,\n    2426: 436964764086304546997571902667823798077679571339689,\n    2427: 448307281905025750783203518734071850525930124835870,\n    2428: 459941833958690501858441260833172834575927050017497,\n    2429: 471875878224871422129752689802003581309719671216145,\n    2430: 484117061599156426525236728117223720907832020184888,\n    2431: 496673224641860608784678055946833883950031191035725,\n    2432: 509552406443037374969583492229383313416835733059701,\n    2433: 522762849608713268897451362983651906277382721179854,\n    2434: 536313005371342643715460083111040042096768651944785,\n    2435: 550211538827551788032090316191702467148009553891765,\n    2436: 564467334306317355502338280181042531694130943361929,\n    2437: 579089500870801016601654991798984624538203584674550,\n    2438: 594087377957141194645081615027313378657219091976058,\n    2439: 609470541153583610086244251156702088407546864564250,\n    2440: 625248808123415184021445170239142357065496320226974,\n    2441: 641432244675250690988723453000798446534275367015717,\n    2442: 658031170984308451084537723836848917759126780943929,\n    2443: 675056167968400361774985057979390540476824195499264,\n    2444: 692518083822452741394297527894579793217444427279865,\n    2445: 710428040715467841255717203419691810125435835218542,\n    2446: 728797441653931534847387578562876222605215306007682,\n    2447: 747637977515770665320414243823232108546943571791584,\n    2448: 766961634259063882272862309538971496456501841189299,\n    2449: 786780700309812582901493233837104883069651992252500,\n    2450: 807107774133183849507621375104362485942528919417094,\n    2451: 827955771992745105077858611205558631300937454362243,\n    2452: 849337935902320652619232737317794449777545949179711,\n    2453: 871267841775213384980863950063063429886904651528812,\n    2454: 893759407775650814410526929963928966861696330836200,\n    2455: 916826902877433240978780331677009554236212353692084,\n    2456: 940484955634883423732306479679700600136395142799772,\n    2457: 964748563171321607096873785043308907920748393645865,\n    2458: 989633100390417258370972350733200785584553946028102,\n    2459: 1015154329415899462551538855668088513315200292902465,\n    2460: 1041328409265241672356796753836476758668568608962817,\n    2461: 1068171905763073500068056689718618672673472054705623,\n    2462: 1095701801700212541420510934836771894810436524644206,\n    2463: 1123935507244352919801698227500042488236652668362464,\n    2464: 1152890870608594412929146690100187865796230009117415,\n    2465: 1182586188984146757378861272237745685156851393567877,\n    2466: 1213040219743698104212153283094735988868458164856735,\n    2467: 1244272191922094708920237946746471334658921810675089,\n    2468: 1276301817981140870474529866246359687648227775992726,\n    2469: 1309149305865493979065272921268867078953610074980355,\n    2470: 1342835371356799383941072744632607586619060990003342,\n    2471: 1377381250733383747666895193431311551421473834674537,\n    2472: 1412808713743003709421434478836269410607157240633931,\n    2473: 1449140076896329138317020116671377802568526770518725,\n    2474: 1486398217089027121199419785627770438512228407175000,\n    2475: 1524606585560504203472825372845600976263733665501642,\n    2476: 1563789222197560394205351099996482830581156974888244,\n    2477: 1603970770191409168676519057930382172908445935119463,\n    2478: 1645176491056723265830534175841536314124424257900655,\n    2479: 1687432280021576600685684487181671811367617087501755,\n    2480: 1730764681797368211260238937556940484156749101230455,\n    2481: 1775200906738034957464112810216480762332001678674799,\n    2482: 1820768847398085810011063048337611865735620543349686,\n    2483: 1867497095499222138016227017428624557231848665351291,\n    2484: 1915414959315545554866069359053268627009894091487255,\n    2485: 1964552481487597746580633524928622127514294053468578,\n    2486: 2014940457275725421793253569605575859047900517862975,\n    2487: 2066610453263518227450300026070406061787487374956619,\n    2488: 2119594826522328312496888837397949369108992226003579,\n    2489: 2173926744248147339669532102906132397617461595649235,\n    2490: 2229640203882390293040946390903966696602633829194840,\n    2491: 2286770053728415559686499093247615980043870048333375,\n    2492: 2345352014075897634933772608434944801289607520822444,\n    2493: 2405422698845462573006497019894423614036351120521629,\n    2494: 2467019637766297143181469675691820929552138013921170,\n    2495: 2530181299099750724441152937967329319658147447405249,\n    2496: 2594947112922264451615392923126900249342712365881980,\n    2497: 2661357494981285189837685277991457183899724929972336,\n    2498: 2729453871138152742649660700418835108908145695065284,\n    2499: 2799278702412287477405614444445747930301938442180000,\n    2500: 2870875510641352469269629800993561138276373608937244,\n    2501: 2944288904772419516055596903431635682611440388817684,\n    2502: 3019564607799532159016586951616642980389816614848623,\n    2503: 3096749484363431362720513648966835225350796839944705,\n    2504: 3175891569029590968434327113853291229809825601961265,\n    2505: 3257040095261100652976951554528119114719453404725007,\n    2506: 3340245525103334116822171147466786507458445890183988,\n    2507: 3425559579597749814517587789768024144026745140376550,\n    2508: 3513035269942590955686749126214187667970579050845937,\n    2509: 3602726929418680979845445364711401806180203650663725,\n    2510: 3694690246098950482357992748748848483474524052004611,\n    2511: 3788982296360781887103496312666448565688651771156677,\n    2512: 3885661579220719274616818998490729558629719751838590,\n    2513: 3984788051511562939333648375836061468352863107532895,\n    2514: 4086423163922351728879727101483809741806177963555690,\n    2515: 4190629897922231281075551233411026977189480304097898,\n    2516: 4297472803589713195797719954967455347047259565521535,\n    2517: 4407018038369349240856665212333154882125704077589469,\n    2518: 4519333406778376182071537408268876717047377660539309,\n    2519: 4634488401086431042999613202320599056013666269808095,\n    2520: 4752554242991993841520963249414089899868727306156151\n}\n\ndef exp_sum(number):\n    if number < 0: return 0\n    return ANSWERS[number]
def simplify(poly):\n    # I'm feeling verbose today\n    \n    # get 3 parts (even if non-existent) of each term: (+/-, coefficient, variables)\n    import re\n    matches = re.findall(r'([+\-]?)(\d*)([a-z]+)', poly)\n    \n    # get the int equivalent of coefficient (including sign) and the sorted variables (for later comparison)\n    expanded = [[int(i[0] + (i[1] if i[1] != "" else "1")), ''.join(sorted(i[2]))] for i in matches]\n    \n    # get the unique variables from above list. Sort them first by length, then alphabetically\n    variables = sorted(list(set(i[1] for i in expanded)), key=lambda x: (len(x), x))\n    \n    # get the sum of coefficients (located in expanded) for each variable\n    coefficients = {v:sum(i[0] for i in expanded if i[1] == v) for v in variables}\n    \n    # clean-up: join them with + signs, remove '1' coefficients, and change '+-' to '-'\n    return '+'.join(str(coefficients[v]) + v for v in variables if coefficients[v] != 0).replace('1','').replace('+-','-')
from collections import deque\nimport re\n\nTOKENIZER = re.compile(r'(R+|F+|L+|\)|\()(\d*)')\n\ndef parseCode(code):\n    cmds = [[]]\n    for cmd,n in TOKENIZER.findall(code):\n        s,r = cmd[0], int(n or '1') + len(cmd)-1\n        if   cmd == '(': cmds.append([])\n        elif cmd == ')': lst = cmds.pop() ; cmds[-1].extend(lst*r)\n        else:            cmds[-1] += [(s, r)]\n    return cmds[0]\n\ndef execute(code):\n\n    pos, dirs = (0,0), deque([(0,1), (1,0), (0,-1), (-1,0)])\n    seens = {pos}\n    \n    for s,r in parseCode(code):\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple( z+dz for z,dz in zip(pos, dirs[0]) )\n                seens.add(pos)\n        else:\n            dirs.rotate( (r%4) * (-1)**(s == 'R') )\n    \n    miX, maX = min(x for x,y in seens), max(x for x,y in seens)\n    miY, maY = min(y for x,y in seens), max(y for x,y in seens)\n    \n    return '\r\n'.join( ''.join('*' if (x,y) in seens else ' ' for y in range(miY, maY+1)) \n                        for x in range(miX, maX+1) )
from collections import deque\n\n\ndef tree_by_levels(node):\n    if not node:\n        return []\n    res, queue = [], deque([node,])\n    while queue:\n        n = queue.popleft()\n        res.append(n.value)\n        if n.left is not None:\n            queue.append(n.left)\n        if n.right is not None:\n            queue.append(n.right)\n    return res
def count_divisors(n):\n  """Counts the integer points under the parabola xy = n.\n\n  Because the region is symmetric about x = y, it is only necessary to sum up\n  to that point (at n^{1/2}), and double it. By this method, a square region is\n  counted twice, and thus subtracted off the total.\n  """\n  r = int(n**(1/2))\n  return 2*sum(n // i for i in range(1, r+1)) - r*r
from itertools import count\n\nALL_MOVES  = [(1,1), (0,1), ( 1,0), (-1,0), (0,-1), (-1,1), ( 1,-1), (-1,-1)]       # Natural directions of moves for king or queen (one step)\nAMA_MOVES  = [(1,2), (2,1), (-1,2), (2,-1), (1,-2), (-2,1), (-1,-2), (-2,-1)]       # Knight moves for amazon queen\n\n\ndef amazon_check_mate(*args):\n\n    def posInBoard(x,y):  return 0 <= x < 8 and 0 <= y < 8\n    \n    def getCoveredPos(start, king=None):                                            # Working with the amazon queen is king is provided\n        covered = {start}\n        for m in (AMA_MOVES if king else ALL_MOVES):                                # All "one step" moves (either for queen or king)\n            pos = tuple( z+dz for z,dz in zip(start,m) )\n            if posInBoard(*pos): covered.add(pos)\n        \n        if king:                                                                    # Get long range moves, for queen only (meaning: if king is provided!)\n            for dx,dy in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0]+dx*n, start[1]+dy*n)\n                    if not posInBoard(*pos) or pos == king: break                   # Abort if not in board or if white king is on the way\n                    covered.add(pos)\n        \n        return covered\n    \n    \n    K, Q      = [(ord(s[0])-97, ord(s[1])-49) for s in args]                   # King and Queen positions as tuples\n    kCover    = getCoveredPos(K)                                                    # Positions protected by white king\n    fullCover = getCoveredPos(Q,K) | kCover                                         # All position protected by white pieces\n    freeQueen = Q not in kCover                                                     # Queen not protected by king\n    counts    = [0] * 4                                                             # Indexes: 2 * "is not check" + 1 * "safe position available around"\n    \n    for x in range(8):\n        for y in range(8):\n            black = (x,y)\n            \n            if black in kCover or black == Q: continue                              # No adjacent kings and no king copulating with an amazon...\n            \n            safePosAround = any( posInBoard(*neigh) and (neigh not in fullCover or neigh == Q and freeQueen)   # Neighbour is in board and is a safe place or is the queen and isn't protected by white king\n                                 for neigh in ((x+dx, y+dy) for dx,dy in ALL_MOVES) )\n                                    \n            counts[ 2*(black not in fullCover) + safePosAround ] += 1               # Update the correct index of "ans"\n            \n    return counts\n
def same_structure_as(original,other):\n    if isinstance(original, list) and isinstance(other, list) and len(original) == len(other):\n        for o1, o2 in zip(original, other):\n            if not same_structure_as(o1, o2): return False\n        else: return True\n    else: return not isinstance(original, list) and not isinstance(other, list)
from fractions import gcd\nfrom functools import reduce\n\ndef solution(a):\n    return reduce(gcd, a) * len(a)
unflatten=lambda m,d,c=0:m if c==d else unflatten(parse(m,[0,1][c&1]),d,c+1)\n\ndef parse(ar, lr):\n      sub, i = [], [0, len(ar) - 1][lr]\n      while 0 <= i < len(ar):\n          j, r = ar[i], lr == 1\n          if isinstance(j, list):\n              sub.append(parse(j, lr))\n              i += [1, -1][r]\n          else:\n              mod = j % len([ar[i:],ar[:i + 1]][r])\n              sub.append([j, ar[i:i + (mod * [1, -1][r]):[1, -1][r]][::[1, -1][r]]][mod>=3])\n              i += [mod,1][mod<3] * [1,-1][r]\n      return sub[::[1, -1][lr]]
def next_smaller(n):\n    s = list(str(n))\n    i = j = len(s) - 1\n    while i > 0 and s[i - 1] <= s[i]: i -= 1\n    if i <= 0: return -1\n    while s[j] >= s[i - 1]: j -= 1\n    s[i - 1], s[j] = s[j], s[i - 1]\n    s[i:] = reversed(s[i:])\n    if s[0] == '0': return -1\n    return int(''.join(s))
class Solution:\n    def isNStraightHand(self, hand: List[int], W: int) -> bool:\n        # 1, 2, 2, 3, 3, 4, 6, 7, 8\n        # 1 2 3\n        #   2 3 4\n        #         6 7 8\n        \n        # W length Q\n        # how many opened\n        # # of the element is current opened one\n        \n        q = deque()\n        opened = 0\n        last = 0\n        counter = Counter(hand)\n        for n in sorted(counter):\n            count = counter[n]\n            if n > last + 1 and opened > 0:\n                return False\n            \n            if n == last + 1 and count < opened:\n                return False\n            \n            \n            q.append(count - opened)\n            opened = count\n            \n            if len(q) == W:\n                opened -= q.popleft()\n            \n            last = n\n        return not opened
import sys\ndef main():\n    s = sys.stdin.readline\n    save = {' ': '%20', '!': '%21', '$': '%24', '%': '%25', '(': '%28', ')': '%29', '*': '%2a'}\n    string = s().strip()\n    while True:\n        output = []\n        if '#' in string:\n            return\n        for i in string:\n            if i in save:\n                output.append(save[i])\n            else:\n                output.append(i)\n        print(''.join(output))\n        string = s().strip()\n        \ndef __starting_point():\n    main()\n__starting_point()
# ------------------- fast io --------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = "x" in file.mode or "r" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b"\n") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode("ascii"))\n        self.read = lambda: self.buffer.read().decode("ascii")\n        self.readline = lambda: self.buffer.readline().decode("ascii")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip("\r\n")\n\n# ------------------- fast io --------------------\nfrom math import gcd, ceil\n\ndef prod(a, mod=10**9+7):\n    ans = 1\n    for each in a:\n        ans = (ans * each) % mod\n    return ans\n\ndef lcm(a, b): return a * b // gcd(a, b)\n\ndef binary(x, length=16):\n    y = bin(x)[2:]\n    return y if len(y) >= length else "0" * (length - len(y)) + y\n\nfor _ in range(int(input()) if True else 1):\n    n = int(input())\n    #n, k = map(int, input().split())\n    #a, b = map(int, input().split())\n    #c, d = map(int, input().split())\n    #a = list(map(int, input().split()))\n    #b = list(map(int, input().split()))\n    #s = input()\n    print(*[1]*n)
f={}\n\nf[-40] = '-319993.68'\nf[-41] = '-344598.60'\nf[-42] = '-370433.52'\nf[-43] = '-397528.44'\nf[-44] = '-425913.37'\nf[-45] = '-455618.29'\nf[-46] = '-486673.22'\nf[-47] = '-519108.14'\nf[-48] = '-552953.07'\nf[-49] = '-588238.00'\nf[-50] = '-624992.93'\nf[-29] = '-121939.61'\nf[-30] = '-134994.52'\nf[-31] = '-148949.43'\nf[-32] = '-163834.34'\nf[-33] = '-179679.26'\nf[-34] = '-196514.17'\nf[-35] = '-214369.08'\nf[-36] = '-233274.00'\nf[-37] = '-253258.92'\nf[-38] = '-274353.84'\nf[-39] = '-296588.76'\nf[-18] = '-29155.76'\nf[-19] = '-34290.64'\nf[-20] = '-39995.53'\nf[-21] = '-46300.42'\nf[-22] = '-53235.31'\nf[-23] = '-60830.20'\nf[-24] = '-69115.10'\nf[-25] = '-78120.00'\nf[-26] = '-87874.90'\nf[-27] = '-98409.80'\nf[-28] = '-109754.71'\nf[-8] = '-2557.17'\nf[-9] = '-3642.00'\nf[-10] = '-4996.84'\nf[-11] = '-6651.68'\nf[-12] = '-8636.54'\nf[-13] = '-10981.39'\nf[-14] = '-13716.26'\nf[-15] = '-16871.13'\nf[-16] = '-20476.00'\nf[-17] = '-24560.88'\nf[-18] = '-29155.76'\nf[3] = '136.73'\nf[2] = '41.41'\nf[1] = '6.00'\nf[0] = '0.00'\nf[-1] = '-4.00'\nf[-2] = '-38.59'\nf[-3] = '-133.27'\nf[-4] = '-318.00'\nf[-5] = '-622.76'\nf[-6] = '-1077.55'\nf[-7] = '-1712.35'\nf[14] = 'MAGNA NIMIS!'\nf[13] = 'MAGNA NIMIS!'\nf[12] = 'MAGNA NIMIS!'\nf[11] = 'MAGNA NIMIS!'\nf[10] = 'MAGNA NIMIS!'\nf[9] = 'MAGNA NIMIS!'\nf[8] = 'MAGNA NIMIS!'\nf[7] = 'MAGNA NIMIS!'\nf[6] = 'MAGNA NIMIS!'\nf[5] = 'MAGNA NIMIS!'\nf[4] = '322.00'\n\na=[]\nfor i in range(11):\n    a+=[int(input())]\nfor i in a[::-1]:\n    s=''\n    if i in f:\n        s=f[i]\n    else:\n        s='MAGNA NIMIS!'\n    print('f(%d) = %s'%(i, s))
class Solution:\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\n        dp = [0] * len(arr[0])\n        for r, row in enumerate(arr):\n            minNb = min(dp)\n            min1 = dp.index(minNb)\n            dp[min1] = float('inf')\n            min2 = dp.index(min(dp))\n            dp[min1] = minNb\n            \n            for c in range(len(row)):\n                if c != min1:\n                    row[c] += dp[min1]\n                else:\n                    row[c] += dp[min2]\n                #row[c] += min(dp[:c]+dp[c+1:])\n            dp = row[:]\n        return min(dp)
from functools import *\nclass Solution:\n    def stoneGameII(self, arr):\n        a =[]\n        s=0\n        n = len(arr)\n        for i in arr[::-1]:\n            s+=i\n            a.append(s)\n        a=a[::-1]\n        @lru_cache(None)\n        def fun(i,m):\n            if i+2*m>=n:return a[i]\n            mn = inf\n            for ii in range(1,2*m+1):\n                if ii>m:\n                    ans = fun(i+ii,ii)\n                else:\n                    ans=fun(i+ii,m)\n                if ans<mn:\n                    mn = ans\n            return a[i]-mn\n        return fun(0,1)\n                \n            \n
from math import sqrt\n\ndef get_distance(x1,y1,x2,y2):\n    return sqrt((x1-x2)**2 + (y1-y2)**2)\n\nT = int(input())\nans = []\n\nfor _ in range(T):\n    blank = input()\n    N = int(input())\n\n    C = [[] for i in range(10**4+1)]\n\n    for i in range(N):\n        x,y = [int(i) for i in input().split()]\n        C[x].append(y)\n\n    distance = 0\n    lastx = None\n    lasty = None\n    for i in range(10**4+1):\n        if(C[i]!=[]):\n            max_ci = max(C[i])\n            min_ci = min(C[i])\n            if(lastx!=None and lasty!=None):\n                distance += get_distance(lastx,lasty,i,max_ci)\n            distance += max_ci - min_ci\n            lastx = i\n            lasty = min_ci\n    # ans.append(round(distance,2))\n    ans.append("{:.2f}".format(distance))\n    # ans.append(distance)\n\nfor i in ans:\n    print(i)\n
import sys\n\nblocks = {}\n\nfor i in range(1, 10):\n    blocks[i] = [(0, 0)]\nfor i in range(2, 10, 2):\n    for j in range(1, i / 2 + 1):\n        blocks[i].append((j, 0))\n        blocks[i + 1].append((0, j))\n# print blocks\nblocks[10] = [(0, 0), (0, 1), (1, 0), (1, 1)]\nblocks[11] = [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]\nblocks[12] = [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\nblocks[13] = [(0, 2), (1, 2), (2, 0), (2, 1), (2, 2)]\nblocks[14] = [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\nblocks[15] = [(0, 0), (0, 1), (0, 2), (1, 0), (2, 0)]\nblocks[16] = [(0, 0), (0, 1), (1, 0)]\nblocks[17] = [(0, 0), (0, 1), (1, 1)]\nblocks[18] = [(0, 1), (1, 0), (1, 1)]\nblocks[19] = [(0, 0), (1, 0), (1, 1)]\n\ngrid = [['.'] * 10] * 10\n# print grid\n\nid1, id2, id3 = list(map(int, input().split()))\nwhile not (id1 == id2 == id3 == -1):\n    print('-1 -1 -1 -1 -1 -1 -1 -1 -1')\n    sys.stdout.flush()\n    id1, id2, id3 = list(map(int, input().split()))\n
#dt = {} for i in x: dt[i] = dt.get(i,0)+1\r\nimport sys;input = sys.stdin.readline\r\n#import io,os; input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline #for pypy\r\ninp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]\r\n\r\nfrom collections import deque\r\ndef getmax(x,n,k):\r\n    mx = []\r\n    dq = deque()\r\n    for i in range(k):\r\n        while dq and x[i] >= x[dq[-1]]:\r\n            dq.pop()\r\n        dq.append(i)\r\n    mx.append(x[dq[0]])\r\n    for i in range(k,n):\r\n        while dq and dq[0] <= i-k:\r\n            dq.popleft() \r\n        while dq and x[i] >= x[dq[-1]]:\r\n            dq.pop()\r\n        dq.append(i)\r\n        mx.append(x[dq[0]])\r\n    return mx\r\n\r\nn = inp()\r\nm = n+n\r\nA = ip()\r\nB = ip()\r\nA += A\r\nB += B\r\npre = [0]*(m+1)\r\nfor i in range(1,m+1):\r\n    pre[i] += pre[i-1] + B[i-1]\r\nplus = [0]*m\r\nminus = [0]*m\r\nfor i in range(m):\r\n    plus[i] = A[i]+pre[i]\r\n    minus[i] = A[i]-pre[i+1]\r\na = getmax(plus,m,n-1)\r\nans = float('-inf')\r\nfor i in range(n):\r\n    ans = max(ans,minus[i]+a[i+1])\r\nprint(max(ans,*A))
# cook your dish here\nn,m = map(int, input().split())\narr1 = list(map(int, input().split()))\narr2  = list(map(int, input().split()))\nmax1 = arr1.index(max(arr1))\nmin2 = arr2.index(min(arr2))\narr = []\nfor i in range(m):\n    arr.append([max1, i])\nfor i in range(n):\n    if i!=max1:\n        arr.append([i , min2])\nfor i in arr:\n    print(*i)
# cook your dish here\nfor _ in range(int(input())):\n    l,n,x=map(int,input().split())\n    m=[]\n    pw1 = (1 << 17);  \n    pw2 = (1 << 18);  \n    if (n == 1) :  \n        m.append(x)\n    elif (n == 2 and x == 0) : \n        m.append(-1)\n    elif (n == 2) : \n        m.append(x)\n        m.append(0)\n    else : \n        ans = 0;  \n        for i in range(1, n - 2) : \n            m.append(i)\n            ans = ans ^ i;     \n        if (ans == x) : \n            m.append(pw1+pw2)\n            m.append(pw1)\n            m.append(pw2)\n        else:\n            m.append(pw1)\n            m.append((pw1 ^ x) ^ ans)\n            m.append(0)\n    p=(m)*l\n    for i in range(0,l):\n        print(p[i],end=' ')\n    print()    \n        
#include<stdio.h>\nint rev(int k)\n{\nint j,res=0;\nwhile(k)\n{\nres=res*10+k%10;\nk/=10;\n}\nreturn res;\n}\nint main()\n{\nint j,a,b,m,k;\nwhile(scanf("%d",&m)!=EOF)\n{\nfor(j=1;j<=m;j++)\n{\nscanf("%d %d",&a,&b);\nk=rev(a)+rev(b);\nprintf("%d\n",rev(k));\n}\n}\nreturn 0;\n}\n
for _ in range(int(input())):\n    x,y=map(int,input().split())\n    if(x==y):\n        if(x==1):\n            print(1)\n        else:\n            n=0\n            for i in range(x-1):\n                n=i\n                for _ in range(y):\n                    print(n,end=' ')\n                    n=(n+1)%x\n                print()  \n            for i in range(x):\n                print(i,end=' ')\n            print( )\n    else:\n        l=[]\n        n=min(x,y)\n        m=max(x,y)\n        for _ in range(n):\n            l.append([])\n        v=n+1\n        for i in range(n):\n            u=i\n            for j in range(m):\n                if(j<=n):\n                    l[i].append(u)\n                    u=(u+1)%(n+1)\n                else:\n                    if(j>=v):\n                        l[i].append(j+1)\n                    else:\n                        l[i].append(j)\n            v=v+1\n        if(x>y):\n            for i in range(x):\n                for j in l:\n                    print(j[i],end=' ')\n                print( )\n        else:\n            for i in l:\n                for j in i:\n                    print(j,end=' ')\n                print( )
l=list(map(int,input()))\nt=-1\nx=-1\ny=-1\nfor i in range(len(l)):\n    s=l[i]\n    a=i+1\n    b=i+1\n    for j in range(i+1,len(l)):\n        if l[i]<l[j]:\n            s=s+l[j]\n            b=j+1\n        else:\n            break\n    if s>t:\n        t=s\n        x=a\n        y=b\nprint(t,end=":")\nprint(x,y,sep="-")
'''     J A I ~ S H R E E ~ R A M     '''\r\n\r\n# Title: cc-CKOJ20D.py\r\n# created on: 20-07-2020 at 20:46:04\r\n# Creator & Template : Udit Gupta "@luctivud"\r\n# https://github.com/luctivud\r\n# https://www.linkedin.com/in/udit-gupta-1b7863135/\r\n\r\n\r\nimport math; from collections import *\r\nimport sys; from functools import reduce\r\nfrom itertools import groupby\r\n\r\n# sys.setrecursionlimit(10**6)\r\n\r\ndef get_ints(): return map(int, input().strip().split())\r\ndef get_list(): return list(get_ints())\r\ndef get_string(): return list(input().strip().split())\r\ndef printxsp(*args): return print(*args, end="")\r\ndef printsp(*args): return print(*args, end=" ")\r\n\r\n\r\nDIRECTIONS = [[0, 1], [0, -1], [1, 0], [1, -1]] #up, down, right, left\r\nNEIGHBOURS = [(i, j) for i in range(-1, 2) for j in range(-1, 2) if (i!=0 or j!=0)]\r\n\r\n\r\nOrdUnicode_a = ord('a'); OrdUnicode_A = ord('A')\r\nCAPS_ALPHABETS = {chr(i+OrdUnicode_A) : i for i in range(26)}\r\nSMOL_ALPHABETS = {chr(i+OrdUnicode_a) : i for i in range(26)}\r\n\r\n\r\nMOD_JOHAN = int(1e9)+7; MOD_LIGHT = 998244353; INFINITY = float('inf')\r\nMAXN_EYEPATCH = int(1e5)+1; MAXN_FULLMETAL = 501\r\n\r\n# Custom input output is now piped through terminal commands.\r\n\r\ndef bfs(s):\r\n    queue = deque()\r\n    visited = set()\r\n    visited.add(1)\r\n    queue.append((1, 0))\r\n    while len(queue):\r\n        node, dep = queue.popleft()\r\n        dep += 1\r\n        for zen in tree[node]:\r\n            if zen not in visited:\r\n                visited.add(zen)\r\n                if dep & 1:\r\n                    global xorsum\r\n                    xorsum ^= li[zen]\r\n                queue.append((zen, dep))\r\n        # print(queue)\r\n        \r\n\r\n\r\n# for _testcases_ in range(int(input())): \r\nn = int(input())\r\nli = [0] + get_list()\r\ntree = defaultdict(list)\r\nfor _  in range(n-1):\r\n    a, b = get_ints()\r\n    tree[a].append(b)\r\n    tree[b].append(a)\r\nxorsum = 0\r\nbfs(1)\r\n# print(xorsum)\r\nprint("First" if xorsum else "Second")\r\n\r\n\r\n\r\n\r\n'''\r\nTHE LOGIC AND APPROACH IS MINE ( UDIT GUPTA )\r\nLink may be copy-pasted here, otherwise.\r\n'''\r\n
# cook your dish here\nt = int(input())\n\nwhile(t>0):\n    n = int(input())\n    k=1\n    while(k<=n):\n        print(k, end=' ')\n        k+=1\n    print('\n')\n    t-=1
from collections import deque\nfrom sys import stdin\nimport psyco\npsyco.full()\n\ngraph = [[]]\nWHITE, GRAY, BLACK = 0, 1, 2\n\ndef notoriety(x, f_count):\n    queue = deque([x])\n    d = [0 for i in range(f_count+1)]\n    p = [0 for i in range(f_count+1)]\n    color = [WHITE for i in range(f_count+1)]\n    while len(queue) > 0:\n        top = queue.pop()\n        for node in graph[top]:\n            if color[node] == WHITE:\n                queue.appendleft(node)\n                color[node], p[node], d[node] = GRAY, top, d[top] + 1\n        color[top] = BLACK\n    return sum(d)/(f_count*1.0)\n        \ndef main():\n    groups = int(stdin.readline())\n    for g in range(groups):\n        global graph\n        graph = [[]]\n        no_of_friends = int(stdin.readline())\n        for i in range(no_of_friends):\n            graph.append(list(map(int,stdin.readline().split())))\n        min_notoriety, popular = 10000000, -1 # yet another magic number\n        for f in range(1,no_of_friends+1):\n            curr_not = notoriety(f, no_of_friends)\n            if  curr_not < min_notoriety:\n                min_notoriety,popular = curr_not, f\n        assert popular != -1\n        print(popular, "%.6f" %min_notoriety)\n\ndef __starting_point():\n    main()\n\n__starting_point()
class PathNode:\n\n    def __init__(self, row, col, st_x, st_y, p_count=0):\n        self.x = row\n        self.y = col\n        self.pathCount = p_count\n\n    def __str__(self):\n        return str(self.x) + " | " + str(self.y) + " | " + str(self.pathCount)\n\n\nclass GraphUtil:\n    def __init__(self, mat, R,C, d):\n        self.mat = mat\n        self.R = R\n        self.C = C\n        self.d = d\n        self.tab = {}\n\n    def isValidMove(self, r, c, blockVal):\n        return r < self.R and c < self.C and self.mat[r][c] != blockVal\n\n    def possbilePathUtil(self, r, c, blockVal, step,direction):\n\n        if(not self.isValidMove(r, c, 0)):\n            return 0\n            \n        if (r == self.R - 1 and c == self.C - 1):\n            return 1\n\n        if ((r,c,step,direction) in self.tab):\n            return self.tab[(r,c,step,direction)]\n\n        result = 0\n        \n        if direction == 1:\n            if step < self.d:\n                result = (result + self.possbilePathUtil(r, c + 1, blockVal, step + 1,1)) % 20011\n            result = (result +  self.possbilePathUtil(r+1, c, blockVal, 1,2)) % 20011\n        else:\n            if step < self.d:\n                result = (result + self.possbilePathUtil(r + 1, c, blockVal, step + 1, 2)) % 20011\n            result = (result + self.possbilePathUtil(r, c + 1, blockVal, 1,1)) % 20011\n        \n        self.tab[(r,c,step,direction)] = result\n        \n        return result\n\n    def possbilePath(self):\n        if (not self.mat or len(self.mat) < 1):\n            return 0\n\n        return self.possbilePathUtil(0, 0, 0,0,2)\n\n\nnumbers = [int(n) for n in input().split()]\n\nmat = [[int(n) for n in input().split()] for r in range(0, numbers[0])]\n\nresult = GraphUtil(mat, numbers[0], numbers[1], numbers[2])\n\nprint(result.possbilePath())\n# print(result.count)# cook your dish here\n
for _ in range(int(input())):\n    n,k=[int(x) for x in input().split()]\n    if k%4==0:\n        for i in range(0,k,4):\n            print(i,i+1)\n            print(i+1,i+2)\n            print(i+2,i+3)\n            print(i+3,i)\n    elif k%4==1:\n        for i in range(4,k-1,4):\n            print(i,i+1)\n            print(i+1,i+2)\n            print(i+2,i+3)\n            print(i+3,i)\n        print(0,1)\n        print(1,2)\n        print(2,3)\n        print(3,(1<<n)-1)\n        print((1<<n)-1,0)\n    elif k%4==2:\n        for i in range(4,k-2,4):\n            print(i,i+1)\n            print(i+1,i+2)\n            print(i+2,i+3)\n            print(i+3,i)\n        print(0,1)\n        print(1,2)\n        print(2,3)\n        print(3,(1<<n)-2)\n        print((1<<n)-2,(1<<n)-1)\n        print((1<<n)-1,0)\n    elif k!=3:\n        n=1<<n\n        n-=1\n        for i in range(4,k-3,4):\n            print(i,i+1)\n            print(i+1,i+2)\n            print(i+2,i+3)\n            print(i+3,i)\n        print(2,3)\n        print(3,n-1)\n        print(n-1,0)\n        print(0,1)\n        print(1,n-2)\n        print(n-2,n)\n        print(n,2)\n    else:\n        print(0,1)\n        print(1,3)\n        print(3,00)\n
m=int(input())\nwhile m:\n    m-=1\n    n=int(input())\n    t=[i for i in input().split()]\n    print(''.join(t))
# import all important libraries and inbuilt functions\n\nfrom fractions import Fraction\nimport numpy as np\nimport sys,bisect,copyreg,copy,statistics,os\nfrom math import *\nfrom collections import Counter,defaultdict,deque,OrderedDict   \nfrom itertools import combinations,permutations,accumulate \nfrom numpy.linalg import matrix_power as mp\nfrom bisect import bisect_left,bisect_right,bisect,insort,insort_left,insort_right\nfrom statistics import mode\nfrom functools import reduce,cmp_to_key \nfrom io import BytesIO, IOBase\nfrom scipy.spatial import ConvexHull\nfrom heapq import *\nfrom decimal import *\nfrom queue import Queue,PriorityQueue\nfrom re import sub,subn\n\n# end of library import\n\n# map system version faults\nif sys.version_info[0] < 3:\n    from builtins import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n# template of many functions used in competitive programming can add more later \n# based on need we will use this commonly.\n\n# bfs in a graph\ndef bfs(adj,v): # a schema of bfs\n    visited=[False]*(v+1);q=deque()\n    while q:pass\n\n# definition of vertex of a graph\ndef graph(vertex): return [[] for i in range(vertex+1)]\n\ndef powermodulo(x, y, p) : \n    res = 1;x = x % p        \n    if (x == 0) : return 0  \n    while (y > 0) : \n        if ((y & 1) == 1) :   res = (res * x) % p \n        y = y >> 1 \n        x = (x * x) % p           \n    return res\n\ndef lcm(a,b): return (a*b)//gcd(a,b)\n\n# most common list in a array of lists\ndef most_frequent(List):return Counter(List).most_common(1)[0][0]\n\n# element with highest frequency\ndef most_common(List):return(mode(List))\n\n#In number theory, the Chinese remainder theorem states that \n#if one knows the remainders of the Euclidean division of an integer n by \n#several integers, then one can determine uniquely the remainder of the \n#division of n by the product of these integers, under the condition \n#that the divisors are pairwise coprime.\ndef chinese_remainder(a, p):\n    prod = reduce(op.mul, p, 1);x = [prod // pi for pi in p]\n    return sum(a[i] * powermodulo(x[i], p[i] - 2, p[i]) * x[i] for i in range(len(a))) % prod\n\n# make a matrix\ndef createMatrix(rowCount, colCount, dataList):   \n    mat = []\n    for i in range (rowCount):\n        rowList = []\n        for j in range (colCount):\n            if dataList[j] not in mat:rowList.append(dataList[j])\n        mat.append(rowList) \n    return mat\n\n# input for a binary tree\ndef readTree(): \n    v=int(inp());adj=[set() for i in range(v+1)]\n    for i in range(v-1):u1,u2=In(); adj[u1].add(u2);adj[u2].add(u1)\n    return adj,v\n    \n# sieve of prime numbers    \ndef sieve():\n    li=[True]*1000001;li[0],li[1]=False,False;prime=[]\n    for i in range(2,len(li),1):\n        if li[i]==True:\n            for j in range(i*i,len(li),i):li[j]=False    \n    for i in range(1000001):\n        if li[i]==True:prime.append(i)\n    return prime\n\n#count setbits of a number.\ndef setBit(n):\n    count=0\n    while n!=0:n=n&(n-1);count+=1\n    return count\n\n# sum of digits of a number\ndef digitsSum(n):\n    if n == 0:return 0\n    r = 0\n    while n > 0:r += n % 10;n //= 10\n    return r\n\n# ncr efficiently\ndef ncr(n, r):\n    r = min(r, n - r);numer = reduce(op.mul, list(range(n, n - r, -1)), 1);denom = reduce(op.mul, list(range(1, r + 1)), 1)\n    return numer // denom  # or / in Python 2\n\n#factors of a number\ndef factors(n):return list(set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\n\n#prime fators of a number\ndef prime_factors(n):\n    i = 2;factors = []\n    while i * i <= n:\n        if n % i:i += 1\n        else:n //= i;factors.append(i)\n    if n > 1:factors.append(n)\n    return len(set(factors))\n\ndef prefixSum(arr):\n    for i in range(1, len(arr)):arr[i] = arr[i] + arr[i-1]\n    return arr    \n\ndef binomial_coefficient(n, k):\n    if 0 <= k <= n:\n        ntok = 1;ktok = 1\n        for t in range(1, min(k, n - k) + 1):ntok *= n;ktok *= t;n -= 1\n        return ntok // ktok\n    else:return 0\n \ndef powerOfK(k, max):\n    if k == 1:return [1]\n    if k == -1:return [-1, 1] \n    result = [];n = 1\n    while n <= max:result.append(n);n *= k\n    return result\n\n# maximum subarray sum use kadane's algorithm\ndef kadane(a,size):\n    max_so_far = 0;max_ending_here = 0 \n    for i in range(0, size):\n        max_ending_here = max_ending_here + a[i]\n        if (max_so_far < max_ending_here):max_so_far = max_ending_here \n        if max_ending_here < 0:max_ending_here = 0\n    return max_so_far                                    \n                  \ndef divisors(n):\n    result = []\n    for i in range(1,ceil(sqrt(n))+1):\n        if n%i == 0:\n            if n/i == i:result.append(i)\n            else:result.append(i);result.append(n/i)\n    return result\n\ndef sumtilln(n): return ((n*(n+1))//2)\n\ndef isPrime(n) : \n	if (n <= 1) :return False\n	if (n <= 3) :return True\n	if (n % 2 == 0 or n % 3 == 0) :return False\n	for i in range(5,ceil(sqrt(n))+1,6):\n		if (n % i == 0 or n % (i + 2) == 0) :return False\n	return True\n\ndef isPowerOf2(n):\n    while n % 2 == 0:n //= 2\n    return (True if n == 1 else False)\n\ndef power2(n):\n    k = 0\n    while n % 2 == 0:k += 1;n //= 2\n    return k\n\ndef sqsum(n):return ((n*(n+1))*(2*n+1)//6)\n    \ndef cusum(n):return ((sumn(n))**2)\n\ndef pa(a):\n    for i in range(len(a)):print(a[i], end = " ")\n    print()\n\ndef pm(a,rown,coln):\n    for i in range(rown):\n        for j in range(coln):print(a[i][j],end = " ")\n        print()\n\ndef pmasstring(a,rown,coln):\n    for i in range(rown):\n        for j in range(coln):print(a[i][j],end = "")\n        print()\n        \ndef isPerfectSquare(n):return pow(floor(sqrt(n)),2) == n\n\ndef nC2(n,m):return (((n*(n-1))//2) % m)\n\ndef modInverse(n,p):return powermodulo(n,p-2,p)\n\ndef ncrmodp(n, r, p):  \n	num = den = 1\n	for i in range(r):num = (num * (n - i)) % p ;den = (den * (i + 1)) % p \n	return (num * powermodulo(den,p - 2, p)) % p \n\ndef reverse(string):return "".join(reversed(string))        \n\ndef listtostr(s):return ' '.join([str(elem) for elem in s]) \n\ndef binarySearch(arr, l, r, x): \n	while l <= r: \n		mid = l + (r - l) // 2; \n		if arr[mid] == x:return mid \n		elif arr[mid] < x:l = mid + 1\n		else:r = mid - 1\n	return -1\n\ndef isarrayodd(a):\n    r = True\n    for i in range(len(a)):\n        if a[i] % 2 == 0:\n            r = False\n            break\n    return r\n\ndef isPalindrome(s):return s == s[::-1] \n\ndef gt(x,h,c,t):return ((x*h+(x-1)*c)/(2*x-1))\n\ndef CountFrequency(my_list): \n    freq = {} \n    for item in my_list:freq[item] = (freq[item] + 1 if (item in freq) else 1)\n    return freq\n\ndef CountFrequencyasPair(my_list1,my_list2,freq): \n    for item in my_list1:freq[item][0] = (freq[item][0] + 1 if (item in freq) else 1)\n    for item in my_list2:freq[item][1] = (freq[item][1] + 1 if (item in freq) else 1)     \n    return freq \n \ndef binarySearchCount(arr, n, key):   \n    left = 0;right = n - 1;count = 0  \n    while (left <= right):  \n        mid = int((right + left) / 2) \n        if (arr[mid] <= key):count,left = mid + 1,mid + 1\n        else:right = mid - 1      \n    return count\n\ndef primes(n):\n  sieve,l = [True] * (n+1),[]\n  for p in range(2, n+1):\n    if (sieve[p]):\n      l.append(p)\n      for i in range(p, n+1, p):sieve[i] = False\n  return l\n\ndef Next_Greater_Element_for_all_in_array(arr): \n	s,n,reta,retb = list(),len(arr),[],[];arr1 = [list([0,i]) for i in range(n)]\n	for i in range(n - 1, -1, -1): \n		while (len(s) > 0 and s[-1][0] <= arr[i]):s.pop() \n		if (len(s) == 0):arr1[i][0] = -1					\n		else:arr1[i][0] = s[-1]	 \n		s.append(list([arr[i],i]))		\n	for i in range(n):reta.append(list([arr[i],i]));retb.append(arr1[i][0])\n	return reta,retb\n\ndef polygonArea(X,Y,n):   \n    area = 0.0;j = n - 1\n    for i in range(n):area += (X[j] + X[i]) * (Y[j] - Y[i]);j = i   \n    return abs(area / 2.0)\n \n#defining a LRU Cache\n# where we can set values and get values based on our requirement\nclass LRUCache: \n	# initialising capacity \n	def __init__(self, capacity: int): \n		self.cache = OrderedDict() \n		self.capacity = capacity \n\n	# we return the value of the key \n	# that is queried in O(1) and return -1 if we \n	# don't find the key in out dict / cache. \n	# And also move the key to the end \n	# to show that it was recently used. \n	def get(self, key: int) -> int: \n		if key not in self.cache:return -1\n		else:self.cache.move_to_end(key);return self.cache[key] \n\n	# first, we add / update the key by conventional methods. \n	# And also move the key to the end to show that it was recently used. \n	# But here we will also check whether the length of our \n	# ordered dictionary has exceeded our capacity, \n	# If so we remove the first key (least recently used) \n	def put(self, key: int, value: int) -> None: \n		self.cache[key] = value;self.cache.move_to_end(key) \n		if len(self.cache) > self.capacity:self.cache.popitem(last = False)\n\nclass segtree:\n    def __init__(self,n):\n        self.m = 1\n        while self.m < n:self.m *= 2\n        self.data = [0] * (2 * self.m)\n    def __setitem__(self,i,x):\n        x = +(x != 1);i += self.m;self.data[i] = x;i >>= 1\n        while i:self.data[i] = self.data[2 * i] + self.data[2 * i + 1];i >>= 1\n    def __call__(self,l,r):\n        l += self.m;r += self.m;s = 0\n        while l < r:\n            if l & 1:s += self.data[l];l += 1\n            if r & 1:r -= 1;s += self.data[r]\n            l >>= 1;r >>= 1\n        return s        \n\nclass FenwickTree:\n  def __init__(self, n):self.n = n;self.bit = [0]*(n+1)  \n  def update(self, x, d):\n    while x <= self.n:self.bit[x] += d;x += (x & (-x))  \n  def query(self, x):\n    res = 0\n    while x > 0:res += self.bit[x];x -= (x & (-x))\n    return res\n  def range_query(self, l, r):return self.query(r) - self.query(l-1)        \n# can add more template functions here\n    \n# end of template functions\n\n# To enable the file I/O i the below 2 lines are uncommented.\n# read from in.txt if uncommented\nif os.path.exists('in.txt'): sys.stdin=open('in.txt','r')\n# will print on Console if file I/O is not activated\n#if os.path.exists('out.txt'): sys.stdout=open('out.txt', 'w')\n\n# inputs template\n#for fast input we areusing sys.stdin\ndef inp(): return sys.stdin.readline().strip()\n\n#for fast output, always take string\ndef out(var): sys.stdout.write(str(var))  \n\n# cusom base input needed for the program\ndef I():return (inp())\ndef II():return (int(inp()))\ndef FI():return (float(inp()))\ndef SI():return (list(str(inp())))\ndef MI():return (map(int,inp().split()))\ndef LI():return (list(MI()))\ndef SLI():return (sorted(LI()))\ndef MF():return (map(float,inp().split()))\ndef LF():return (list(MF()))\n\n# end of inputs template\n\n# common modulo values used in competitive programming\nMOD = 998244353\nmod = 10**9+7\n\n# any particular user-defined functions for the code.\n# can be written here.  \ndef solve():\n    n,m = MI();ss = []\n    for _ in range(n):ss.append(list(I()) + ['#'])\n    ss.append(['#']*(m+1))\n    for i in range(n-1, -1, -1):\n        for j in range(m-1, -1, -1):\n            if ss[i+1][j] == '#' and ss[i][j+1] == '#' and (i,j) != (n-1, m-1):ss[i][j] = '#'\n    res = [ss[0][0]];cend = {(0,0)}\n    for _ in range(n+m-2):\n        ncend = set();mn = 'z'\n        for i,j in cend:\n            if ss[i+1][j] != '#' and ss[i+1][j] <= mn:ncend.add((i+1, j));mn = ss[i+1][j]\n            if ss[i][j+1] != '#' and ss[i][j+1] <= mn:ncend.add((i, j+1));mn = ss[i][j+1]\n        res.append(mn)\n        cend = {(i,j) for (i,j) in ncend if ss[i][j] == mn}\n\n    print(''.join(res))\n# end of any user-defined functions\n\n# main functions for execution of the program.\ndef __starting_point():  \n    # execute your program from here.\n    # start your main code from here\n        \n    # Write your code here\n    for _ in range(II()):solve()\n                    \n    # end of main code\n    # end of program\n\n# This program is written by :\n#   Shubham Gupta\n#   B.Tech (2019-2023)\n#   Computer Science and Engineering,\n#   Department of EECS\n#   Contact No:8431624358\n#   Indian Institute of Technology(IIT),Bhilai\n#   Sejbahar,\n#   Datrenga,\n#   Raipur,\n#   Chhattisgarh\n#   492015\n\n#   THANK YOU FOR \n#YOUR KIND PATIENCE FOR READING THE PROGRAM.    \n__starting_point()
def check_relative(i,j):\n    if is_relative[i]:return\n    if len(land[i].intersection(land[j]))>=k:\n        is_relative[i]=True\n        for ii in range(n):\n            check_relative(ii,i)\n\nn,k=map(int,input().split())\nland=[]\nis_relative=[True]+[False]*(n-1)\nfor i in range(n):\n    p,*q=input().split()\n    land.append(set(map(int,q)))\n\nfor i in range(n):\n    check_relative(i,0)\n        \nprint(is_relative.count(True))
# CHNGSS.py\n\nimport sys\nfrom random import *\n\nn,m,c = list(map(int,input().split()))\narr = [[1]*m for i in range(n)];\nsaved = 0;\nfor i in range(n):\n	for j in range(m):\n		print(1,(i+1),(i+1),(j+1),(j+1),1,25)\n		sys.stdout.flush()\n		a = int(input())\n		if a == 1 :\n			saved += 1;\n			arr[i][j] = randint(1,25);\n		else:\n			arr[i][j] = randint(25,50);\nprint(3);\nsys.stdout.flush()\nfor a in arr :\n	print(' '.join(map(str,a)));\n	sys.stdout.flush()\n# sys.exit(0);
print(302)\nprint("0 1000000")\ncoord, rad = 17321*2, 300\nfor i in range(300):\n    print(coord, rad)\n    coord, rad = coord+600, rad-1\nprint("1000000 1000000")\n
from math import *\n\nn = int(input())\nfor _ in range(n):\n    a = [int(i) for i in input().split()]\n    c = len(a)\n    avg = sum(a)/c\n    ulik = log(2*avg + 1)*(-c)\n    plik = 0\n    for k in a:\n        plik += log(avg)*k\n        plik += -avg\n        for i in range(1, k+1):\n            plik -= log(i)\n    isu = ulik > plik\n    ans = ["poisson", "uniform"][isu]\n    print(ans)\n
v = int(input())\neps = 170\n\ndef ans(a):\n    a.sort()\n    if len(a) % 2 == 0:\n        med = a[len(a)//2]\n    else:\n        med = (a[len(a)//2] + a[len(a)//2 - 1]) // 2\n\n    l = med - med // 2\n    r = med + med // 2\n\n    c1 = c2 = 0\n\n    for i in a:\n        if i >= l and i <= r:\n            c1 += 1\n        else:\n            c2 += 1\n\n    if abs(c1 - c2) <= eps:\n        return (med, "uniform")\n    else:\n        return (med, "poisson")\n\n    \n\nfor i in range(v):\n    cur = [int(i) for i in input().split()]\n    b = ans(cur)\n    if b[1] == "poisson":\n        print(b[0])\n    else:\n        print((max(cur) - min(cur)) // 2)\n        \n        \n
def __starting_point():\n    print(2001)\n    for i in range(1000):\n        print(str(i + 1) + ' ' + str(1) + ' ' + str(i + 1) + ' ' +str(2))\n    print(str(1) + " " + str(1) + " " +str(1) + " " + str(2))\n    for i in range(1000):\n        print(str(i + 1) + ' ' + str(1) + ' ' + str(i + 1) + ' ' +str(2))\n\n__starting_point()
def sampleVariance(V):\n    X = sum(V) / len(V)\n    S = 0.0\n    for x in V:\n        S += (X-x)**2\n\n    S /= (len(V)-1)\n    return (X, S)\n\n#That awkward moment when you realized that variance is sigma^2 but you just took the stat course this semester\nfor i in range(int(input())):\n    V = list(map(int, input().split()))\n    X, S = sampleVariance(V)\n\n    print("{}".format("uniform" if max(V) < 1.9*(S**0.5) else "poisson"))
import itertools\nclass Nonogram:\n    poss = {(1,1,1): set([(1,0,1,0,1)]),\n            (1,1):   set([(0,0,1,0,1),(0,1,0,1,0),(1,0,1,0,0),(0,1,0,0,1),(1,0,0,1,0),(1,0,0,0,1)]),\n            (1,2):   set([(1,0,1,1,0),(1,0,0,1,1),(0,1,0,1,1)]),\n            (1,3):   set([(1,0,1,1,1)]),\n            (2,1):   set([(1,1,0,1,0),(1,1,0,0,1),(0,1,1,0,1)]),\n            (2,2):   set([(1,1,0,1,1)]),\n            (3,1):   set([(1,1,1,0,1)]),\n            (1,):    set([(0,0,0,0,1),(0,0,0,1,0),(0,0,1,0,0),(0,1,0,0,0),(1,0,0,0,0)]),\n            (2,):    set([(0,0,0,1,1),(0,0,1,1,0),(0,1,1,0,0),(1,1,0,0,0)]),\n            (3,):    set([(0,0,1,1,1),(0,1,1,1,0),(1,1,1,0,0)]),\n            (4,):    set([(0,1,1,1,1),(1,1,1,1,0)]),\n            (5,):    set([(1,1,1,1,1)])}\n    \n    def __init__(self, clues):\n        self.h,self.w=(tuple(Nonogram.poss[clue] for clue in side) for side in clues)\n\n    def solve(self):\n        for r in itertools.product(*self.w):\n            if all(c in self.h[i] for i,c in enumerate(zip(*r))): return r\n
from collections import deque\n\ndef dbl_linear(n):\n    h = 1; cnt = 0; q2, q3 = deque([]), deque([])\n    while True:\n        if (cnt >= n):\n            return h\n        q2.append(2 * h + 1)\n        q3.append(3 * h + 1)\n        h = min(q2[0], q3[0])\n        if h == q2[0]: h = q2.popleft()\n        if h == q3[0]: h = q3.popleft()\n        cnt += 1\n\n
def doubles(maxk, maxn):\n    return sum([ sum([ (n+1)**(-2*k) for n in range(1, maxn+1) ])/k for k in range(1, maxk+1) ])
class DynamicConnectivity(object):\n    par = []\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def union(self, p, q):\n        if self.root(p) != self.root(q):\n            self.par[self.root(p)] = q\n\n    def root(self, p):\n        pp = p\n        while self.par[pp] != pp:\n            pp = self.par[pp]\n        return pp\n        \n    def connected(self, p, q):\n        return True if self.root(p)==self.root(q) else False\n
from operator import add, sub, mul, floordiv as div, and_, or_, xor\nOP = {'add':add, 'sub':sub, 'mul':mul, 'div':div, 'and':and_, 'or':or_, 'xor':xor}        \n\nclass Machine(object):    \n    def __init__(self, cpu):\n        self.cpu = cpu\n    \n    def execute(self, instruction):    \n        cmd, a, b = (instruction.replace(',', ' ') + ' 0 0').split()[:3]\n        v = self.cpu.read_reg(a) if a in 'abcd' else int(a)\n        \n        if   cmd == 'mov':  self.cpu.write_reg(b, v)\n        elif cmd == 'pop':  self.cpu.write_reg(a, self.cpu.pop_stack()) if a in 'abcd' else self.cpu.pop_stack()\n        elif cmd == 'push': self.cpu.write_stack(v)\n        elif cmd in ['pushr', 'pushrr']:\n            for r in ('abcd' if cmd == 'pushr' else 'dcba'): self.cpu.write_stack(self.cpu.read_reg(r))\n        elif cmd in ['popr', 'poprr']:\n            for r in ('abcd' if cmd == 'poprr' else 'dcba'): self.cpu.write_reg(r, self.cpu.pop_stack())\n        else:\n            r = self.cpu.pop_stack() if cmd[-1] != 'a' else self.cpu.read_reg('a')\n            for _ in range(v-1):\n                r = OP[cmd if cmd[-1] != 'a' else cmd[:-1]](r, self.cpu.pop_stack())\n            self.cpu.write_reg(b if b in 'abcd' else 'a', r)
import math\n\nclass Sudoku(object):\n    def __init__(self, board):\n        self.board = board\n        \n    def is_valid(self):\n        if not isinstance(self.board, list):\n            return False\n        n = len(self.board)\n        rootN = int(round(math.sqrt(n)))\n        if rootN * rootN != n:\n            return False\n        isValidRow = lambda r : (isinstance(r, list) and\n                                 len(r) == n and\n                                 all([type(x) == int for x in r]))\n        if not all(map(isValidRow, self.board)):\n            return False\n        oneToN = set(range(1, n + 1))\n        isOneToN = lambda l : set(l) == oneToN\n        tranpose = [[self.board[j][i] for i in range(n)] for j in range(n)]\n        squares = [[self.board[p+x][q+y] for x in range(rootN) \n                                         for y in range(rootN)] \n                                         for p in range(0, n, rootN)\n                                         for q in range(0, n, rootN)] \n        return (all(map(isOneToN, self.board)) and\n                all(map(isOneToN, tranpose)) and\n                all(map(isOneToN, squares)))\n
import re\n\ndef brainfuck_to_c(source):\n    # remove comments\n    source = re.sub('[^+-<>,.\[\]]', '', source)\n    \n    # remove redundant code\n    before = ''\n    while source != before:\n        before = source\n        source = re.sub('\+-|-\+|<>|><|\[\]', '', source)\n    \n    # check braces status\n    braces = re.sub('[^\[\]]', '', source)\n    while braces.count('[]'):\n        braces = braces.replace('[]', '')\n    if braces:\n        return 'Error!'\n    \n    # split code into commands\n    commands = re.findall('\++|-+|>+|<+|[.,\[\]]', source)\n    \n    # translate to C\n    output = []\n    indent = 0\n    for cmd in commands:\n        if cmd[0] in '+-<>':\n            line = ('%sp %s= %s;\n' %\n                ('*' if cmd[0] in '+-' else '',\n                 '+' if cmd[0] in '+>' else '-',\n                 len(cmd)))\n        elif cmd == '.':\n            line = 'putchar(*p);\n'\n        elif cmd == ',':\n            line = '*p = getchar();\n'\n        elif cmd == '[':\n            line = 'if (*p) do {\n'\n        elif cmd == ']':\n            line = '} while (*p);\n'\n            indent -= 1\n        output.append('  ' * indent + line)\n        if cmd == '[':\n            indent += 1\n    \n    return ''.join(output)
class PokerHand(object):\n    CARD = "23456789TJQKA"\n    RESULT = ["Loss", "Tie", "Win"]\n\n    def __init__(self, hand):\n        values = ''.join(sorted(hand[::3], key=self.CARD.index))\n        suits = set(hand[1::3])\n        is_straight = values in self.CARD\n        is_flush = len(suits) == 1\n        self.score = (2 * sum(values.count(card) for card in values)\n                      + 13 * is_straight + 15 * is_flush,\n                      [self.CARD.index(card) for card in values[::-1]])\n        \n    def compare_with(self, other):\n        return self.RESULT[(self.score > other.score) - (self.score < other.score) + 1]
def spidey_swings(building_params):\n    buildings = get_buildings(building_params)\n    end_position = get_total_length(buildings)\n    latch_positions = []\n    jump_position = 0\n    while is_not_possible_to_reach_the_end(buildings, jump_position, end_position):\n        candidate_jumps = [\n            building.get_variables_for_max_displacement(jump_position)\n            for building in buildings\n            if building.is_reachable(jump_position)\n        ]\n        candidate_jumps.sort(reverse=True)\n        _, latch_position, jump_position = candidate_jumps[0]\n        latch_positions.append(latch_position)\n\n    candidate_final_jumps = [\n        building.get_variables_aiming_end(jump_position, end_position)\n        for building in buildings\n        if (building.is_reachable(jump_position) and\n            building.is_possible_to_reach_the_end(jump_position, end_position))\n    ]\n    candidate_final_jumps.sort(reverse=True)\n    _, latch_position = candidate_final_jumps[0]\n    latch_positions.append(latch_position)\n\n    return latch_positions\n\n\ndef get_buildings(building_params):\n    pos = 0\n    buildings = []\n    for (height, width) in building_params:\n        building = Building(height, width, pos)\n        buildings.append(building)\n        pos += width\n    return buildings\n\n\ndef get_total_length(buildings):\n    return sum(building.width for building in buildings)\n\n\ndef is_not_possible_to_reach_the_end(buildings, jump_position, end_position):\n    return not any(building.is_possible_to_reach_the_end(jump_position, end_position)\n                   for building in buildings)\n\n\nclass Building:\n    def __init__(self, height, width, pos):\n        self.height = height\n        self.width = width\n        self.pos = pos\n\n    def max_rope_length(self):\n        return self.height - 20\n\n    def distance_to_rooftop(self):\n        return self.height - 50\n\n    def max_horizontal_displacement(self):\n        hypotenuse = self.max_rope_length()\n        vertical = self.distance_to_rooftop()\n        return (hypotenuse ** 2 - vertical ** 2) ** .5\n\n    def latch_pos_for_max_displacement(self, jump_pos):\n        if jump_pos < self.pos - self.max_horizontal_displacement():\n            return None\n        if jump_pos < self.pos + self.width - self.max_horizontal_displacement():\n            return int(jump_pos + self.max_horizontal_displacement())\n        if jump_pos < self.pos + self.width:\n            return int(self.pos + self.width)\n        return None\n\n    def rope_length_for_max_displacement(self, jump_pos):\n        horizontal = (self.latch_pos_for_max_displacement(jump_pos) - jump_pos)\n        vertical = self.distance_to_rooftop()\n        return (horizontal ** 2 + vertical ** 2) ** .5\n\n    def advanced_distance_for_max_displacement(self, jump_pos):\n        return (self.latch_pos_for_max_displacement(jump_pos) - jump_pos) * 2\n\n    def ratio_max_displacement_rope(self, jump_pos):\n        return (self.advanced_distance_for_max_displacement(jump_pos) /\n                self.rope_length_for_max_displacement(jump_pos))\n\n    def get_variables_for_max_displacement(self, pos):\n        latch_pos = self.latch_pos_for_max_displacement(pos)\n        next_jump_pos = pos + self.advanced_distance_for_max_displacement(pos)\n        ratio = self.ratio_max_displacement_rope(pos)\n        return ratio, latch_pos, next_jump_pos\n\n    def latch_pos_aiming_end(self, jump_pos, end_pos):\n        max_latch_pos = (jump_pos + end_pos) / 2\n        if jump_pos < self.pos - self.max_horizontal_displacement():\n            return None\n        if jump_pos <= max_latch_pos:\n            max_latch_pos = max(max_latch_pos, self.pos)\n            return int(max_latch_pos + .5)\n        return None\n\n    def rope_length_aiming_end(self, pos, end_pos):\n        horizontal = self.latch_pos_aiming_end(pos, end_pos) - pos\n        vertical = self.distance_to_rooftop()\n        return (horizontal ** 2 + vertical ** 2) ** .5\n\n    def ratio_aiming_end(self, pos, end_pos):\n        horizontal = end_pos - pos\n        rope = self.rope_length_aiming_end(pos, end_pos)\n        ratio = horizontal / rope\n        return ratio\n\n    def get_variables_aiming_end(self, pos, end_pos):\n        latch_pos = self.latch_pos_aiming_end(pos, end_pos)\n        ratio = self.ratio_aiming_end(pos, end_pos)\n        return ratio, latch_pos\n\n    def is_possible_to_reach_the_end(self, pos, end_pos):\n        if not self.is_reachable(pos):\n            return False\n        return pos + self.advanced_distance_for_max_displacement(pos) >= end_pos\n\n    def is_reachable(self, pos):\n        return self.latch_pos_for_max_displacement(pos) is not None\n
def rectangle_rotation(a, b):\n    a //= 2**0.5\n    b //= 2**0.5\n    r = (a + 1) * (b + 1) + a * b\n\n    return r + r % 2 - 1
def cut_log(p, n):\n    log = [0]\n    for _ in range(n):\n        log.append(max(pi + li for pi, li in zip(p[1:], log[::-1])))\n    return log[n]\n
'''\nsome useful information about memory allocation in operating system\n\n->There are various algorithms which are implemented by the Operating System in order to find out the holes(continuous empy blocks) \\n  in the linked list(array in this kata) and allocate them to the processes.\n\n->various algorithms used by operating system:\n    1. First Fit Algorithm => First Fit algorithm scans the linked list and whenever it finds the first big enough hole to store a process, it stops scanning and load the process into that hole.\n    \n    2. Next Fit Algorithm  => Next Fit algorithm is similar to First Fit algorithm except the fact that, Next fit scans the linked list from the node where it previously allocated a hole.\n                              ( if i have allocated memory of size 8 in previous turn and initial pointer is 3 \\n                                then in next turn os will start searching for next empty hole from position 11(3+8=11) )\n    \n    3. Best Fit Algorithm  => The Best Fit algorithm tries to find out the smallest hole possible in the list that can accommodate the size requirement of the process.\n    \n    4. Worst Fit Algorithm => it is opposite of Best Fit Algorithm meaning that \\n                              (The worst fit algorithm scans the entire list every time and tries to find out the biggest hole in the list which can fulfill the requirement of the process.)\n    \n    The first fit and best fit algorithms are the best algorithm among all\n\nPS. I HAVE IMPLEMENTED Best Fit Algorithm IN JAVASCRIPT AND IMPLEMENTED Next Fit Algorithm in PYTHON :)\n'''\n\n#Next fit Algorithm\nclass MemoryManager:\n    def __init__(self, memory):\n        self.storage = [True] * len(memory)\n        self.previous_allocated_index = 0\n        self.allocated = {}\n        self.data = memory\n\n    def allocate(self, size):\n        find_next = self.process_allocate(self.previous_allocated_index, len(self.data) - size + 1, size)  # start searching from previously allocated block\n        if find_next is not None : return find_next\n        from_start = self.process_allocate(0, self.previous_allocated_index - size + 1, size)              # if we cant find from last index then start searching from starting to previously allocated index\n        if from_start is not None : return from_start\n        raise IndexError('caused by insufficient space in storage')\n    \n    def process_allocate(self, initial, end, size):\n        for i in range(initial, end):  \n            if all(self.storage[i:i + size]):\n                self.previous_allocated_index = i\n                self.storage[i:i + size] = [False] * size\n                self.allocated[i] = i + size\n                return i\n    \n    def release(self, pointer):\n        if self.storage[pointer] : raise RuntimeError('caused by providing incorrect pointer for releasing memory')\n        size = self.allocated[pointer] - pointer\n        self.storage[pointer:size] = [True] * size\n        self.data[pointer:size] = [None] * size\n        del self.allocated[pointer]\n\n    def read(self, pointer):\n        if self.storage[pointer] : raise RuntimeError('caused by providing incorrect pointer for reading memory')\n        return self.data[pointer]\n\n    def write(self, pointer, value):\n        if self.storage[pointer] : raise RuntimeError('caused by providing incorrect pointer for writing memory')\n        self.data[pointer] = value
\ndef sum_for_list(lst):\n    factors = {i for k in lst for i in xrange(2, abs(k)+1) if not k % i}\n    prime_factors = {i for i in factors if not [j for j in factors-{i} if not i % j]}\n    return [[p, sum(e for e in lst if not e % p)] for p in sorted(prime_factors)]
class Warrior():\n    \n    def __init__(self):\n        self._experience = 100\n        self.rs = ["Pushover", "Novice", "Fighter", "Warrior", "Veteran", "Sage", "Elite", "Conqueror", "Champion", "Master", "Greatest"]\n        self.achievements = []\n    def training(self, train):\n        if(train[2] > self.level) : return "Not strong enough";\n        self._experience += train[1]\n        self.achievements.append(train[0])\n        return train[0]\n    def battle(self, lvl):\n        diff = lvl - self.level\n        if(0 >= lvl or lvl > 100): return "Invalid level"\n        if(diff >= 5 and (lvl // 10) > (self.level // 10)):\n            return "You've been defeated"\n        if(diff > 0) : \n            self._experience += 20 * diff * diff\n            return "An intense fight"\n        if(diff > -2):\n            self._experience += 5 if diff == -1 else 10\n            return "A good fight"\n        return "Easy fight"\n    @property\n    def level(self):\n        return self.experience //  100\n    @property\n    def rank(self):\n        return self.rs[self.experience // 1000]\n    @property\n    def experience(self):\n        return min(10000, self._experience)
class Cons:\n    def __init__(self, head, tail):\n        self.head = head\n        self.tail = tail\n\n    def to_array(self):\n        return [self.head] + (self.tail.to_array() if self.tail is not None else [])\n\n    @classmethod\n    def from_array(cls, arr):\n        if not arr:\n            return None\n        return Cons(arr.pop(0), Cons.from_array(arr) if arr else None)\n\n    def filter(self, fn):\n        return Cons.from_array(list(filter(fn, self.to_array())))\n\n    def map(self, fn):\n        return Cons.from_array(list(map(fn, self.to_array())))
def puzzle_solver(pieces, w, h):\n    memo, D, result = {}, {None: (None, None)}, [[None]*w for _ in range(h)]\n    \n    for (a, b), (c, d), id in pieces:\n        memo[(a, b, c)] = id\n        D[id] = (c, d)\n    \n    for i in range(h):\n        for j in range(w):\n            a, b = D[result[i-1][j]]\n            _, c = D[result[i][j-1]]\n            result[i][j] = memo[(a, b, c)]\n    \n    return list(map(tuple, result))
import sys\n\ndef count_calls(func, *args, **kwargs):\n    """Count calls in function func"""\n\n    calls = [ -1 ]\n    def tracer(frame, event, arg):\n        if event == 'call':\n            calls[0] += 1\n        return tracer\n    sys.settrace(tracer)\n  \n    rv = func(*args, **kwargs)\n  \n    return calls[0], rv\n
def hull_method(points):\n    sorted_points = sorted(points)\n    return half_hull(sorted_points) + half_hull(reversed(sorted_points))\n\ndef half_hull(sorted_points):\n    hull = []\n    for p in sorted_points:\n        while len(hull) > 1 and not is_ccw_turn(hull[-2], hull[-1], p):\n            hull.pop()\n        hull.append(p)\n    hull.pop()\n    return hull\n\ndef is_ccw_turn(p0, p1, p2):\n    return (p1[0] - p0[0]) * (p2[1] - p0[1]) - (p2[0] - p0[0]) * (p1[1] - p0[1]) > 0\n
def justify(text, width):\n    length = text.rfind(' ', 0, width+1)\n    if length == -1 or len(text) <= width: return text\n    line = text[:length]\n    spaces = line.count(' ')\n    if spaces != 0:\n        expand = (width - length) / spaces + 1\n        extra = (width - length) % spaces\n        line = line.replace(' ', ' '*expand)\n        line = line.replace(' '*expand, ' '*(expand+1), extra)\n    return line + '\n' + justify(text[length+1:], width)
from itertools import permutations\n\ndef equal_to_24(*aceg):\n    ops = '+-*/'\n    \n    for b in ops:\n        for d in ops:\n            for f in ops:\n                for (a,c,e,g) in permutations(aceg):\n                    for s in make_string(a,b,c,d,e,f,g):\n                        try:\n                            if eval(s + '== 24'):\n                                return s\n                        except:\n                            pass\n                            \n    return "It's not possible!"\n\ndef make_string(a,b,c,d,e,f,g):\n    return [f"(({a} {b} {c}) {d} {e}) {f} {g}",\n            f"({a} {b} {c}) {d} ({e} {f} {g})",\n            f"{a} {b} ({c} {d} ({e} {f} {g}))"]
from collections import Counter\nimport re\n\n\ndef top_3_words(text):\n    c = Counter(re.findall(r"[a-z']+", re.sub(r" '+ ", " ", text.lower())))\n    return [w for w,_ in c.most_common(3)]
MOVES = {(0,1), (0,-1), (1,0), (-1,0)}\n\ndef has_exit(maze):\n    posSet = {(x,y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k'}\n    if len(posSet) != 1:\n        raise ValueError("There shouldn't be more than one kate")\n    \n    seen = set(posSet)\n    while posSet:\n        x,y = posSet.pop()\n        if any(not (0 <= x+dx < len(maze) and 0 <= y+dy < len(maze[x+dx])) for dx,dy in MOVES):\n            return True\n        neighbors = {(x+dx, y+dy) for dx,dy in MOVES if 0 <= x+dx < len(maze) and 0 <= y+dy < len(maze[x+dx])\n                                                        and maze[x+dx][y+dy] == ' '\n                                                        and (x+dx, y+dy) not in seen}\n        posSet |= neighbors\n        seen   |= neighbors\n    return False
def zeroes (base, number):\n    pzeros = []\n    for p in range(2, base+1):\n        e = 0\n        while base % p == 0:\n            base /= p\n            e += 1\n        if e:\n            f, m = 0, number\n            while m:\n                m /= p\n                f += m\n            pzeros.append(f / e)\n    return min(pzeros)
import string\nfrom collections import OrderedDict\n\nclass RomanNumerals:\n  @classmethod\n  def to_roman(self, num):\n    conversions = OrderedDict([('M',1000), ('CM',900), ('D', 500), ('CD',400), ('C',100), ('XC',90), ('L',50), ('XL',40),\n                               ('X',10), ('IX',9), ('V',5), ('IV',4), ('I',1)])\n    out = ''\n    for key, value in conversions.items():\n      while num >= value:\n        out += key\n        num -= value\n    return out\n  \n  @classmethod\n  def from_roman(self, roman):\n    conversions = OrderedDict([('CM',900), ('CD',400), ('XC',90), ('XL',40), ('IX',9), ('IV',4), ('M',1000), ('D',500),\n                               ('C',100), ('L',50), ('X',10), ('V',5), ('I',1)])\n    out = 0\n    for key, value in conversions.items():\n      out += value * roman.count(key)\n      roman = string.replace(roman, key, "")\n    return out\n\n
def create_number_class(alphabet):\n    n = len(alphabet)\n\n    class Number(object):\n        def __init__(self, s):\n            if isinstance(s, str):\n                v = 0\n                for c in s:\n                    v = v * n + alphabet.index(c)\n            else:\n                v = s\n            self.value = v\n\n        def __add__(self, other):\n            return Number(self.value + other.value)\n\n        def __sub__(self, other):\n            return Number(self.value - other.value)\n\n        def __mul__(self, other):\n            return Number(self.value * other.value)\n\n        def __floordiv__(self, other):\n            return Number(self.value // other.value)\n\n        def __str__(self):\n            ret = []\n            v = int(self.value)\n            while v:\n                (v, r) = divmod(v, n)\n                ret.append(alphabet[r])\n            return ''.join(reversed(ret or alphabet[0]))\n\n        def convert_to(self, cls):\n            return cls(self.value)\n\n    return Number\n\n
class Machine:\n    def __init__(self):\n        self.cmd = dict()\n        self._actions = [lambda x: x + 1, lambda x: 0, lambda x: x / 2, lambda x: x * 100, lambda x: x % 2]\n\n    def command(self, cmd, num):\n        self.last_cmd = cmd\n        if cmd  in self.cmd:\n            return self._actions[self.cmd[cmd]](num)\n        else:\n            self.cmd[cmd] = 0\n        return self._actions[self.cmd[cmd]](num)\n\n    def response(self,res):\n        if res == False:\n            self.cmd[self.last_cmd] += 1
class Segment:  # Instead of an abstract class, make it the implementation for all three subclasses\n    def __init__(self, *coords):\n        self.control_points = coords  # IMHO a getter/setter is overkill here\n\n    def control_points_at(self, t):  # Helper function\n        p = self.control_points\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i+2] - v) * t for i, v in enumerate(p[:-2])]\n        return result\n\n    def point_at(self, t):\n        return tuple(self.control_points_at(t)[-2:])\n\n    def sub_segment(self, t):\n        return self.__class__(*self.control_points_at(t))\n\nclass Line(Segment): pass\nclass Quad(Segment): pass\nclass Cubic(Segment): pass
def blast_sequence(aliensStart,position):\n    \n    def moveAliens(aliens, furthest):\n        lst, shootPath = [], []\n        for x,y,s in aliens:\n            y += s\n            if not (0 <= y < N):                                           #Out of the grid: move down and reverse\n                x, s = x+1, -s\n                y = -y-1 if y < 0 else 2*N-y-1\n            (shootPath if y == Y else lst).append((x,y,s))\n            if x > furthest: furthest = x\n        return lst, shootPath, furthest\n    \n    def shootTarget(shootPath):\n        if shootPath:\n            z = max(shootPath, key=lambda a: (a[0], abs(a[2]), a[2]))     # Furthest, fastest, going right is considered the highest\n            shootPath.remove(z)                                           # MUTATION\n            shots.append(turn)                                            # MUTATION\n    \n    (X,Y), N = position, len(aliensStart[0])\n    aliens   = [(x,y,s) for x,r in enumerate(aliensStart) for y,s in enumerate(r) if s]\n    shots, furthest, turn = [], 0, -1\n    \n    while aliens and furthest < X:\n        turn += 1\n        aliens, shootPath, furthest = moveAliens(aliens, furthest)        # Move all the aliens, splitting them in 2 groups: those facing "my" ship (shootPath) and the others\n        shootTarget(shootPath)                                            # Extract the target in shootPath and pop it if possible (mutation). Mutate 'shots' list at the same time\n        aliens += shootPath                                               # Put the remaining aliens in the list\n    \n    return shots if not aliens else None
mod = 12345787\nmat = [([1,1],[0,1,3]),\n       ([2,1,-1],[0,2,6,11]),\n       ([2,3,-1,-1],[0,2,10,23,70]),\n       ([3,3,-4,-1,1],[0,3,15,42,155,533]),\n       ([3,6,-4,-5,1,1],[0,3,21,69,301,1223,5103])]\n\nfor i in range(100): [m.append(sum(k*m[-1-i] for i,k in enumerate(c))%mod) for c,m in mat]\n\ndef circular_limited_sums(max_n, max_fn): return mat[max_fn-1][1][max_n]
def path_finder(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack, length = [[0, 0]], len(matrix)\n    while len(stack):\n      x, y = stack.pop()\n      if matrix[x][y] == '.':\n        matrix[x][y] = 'x'\n        for x, y in (x, y-1), (x, y+1), (x-1, y), (x+1, y):\n          if 0 <= x < length and 0 <= y < length:\n            stack.append((x, y))\n    return matrix[length-1][length-1] == 'x'
def find_word(board, word):\n    grid = [l+[''] for l in board] + [[''] * (len(board[0]) + 1)]\n    def rc(x, y, i):\n        if i == len(word): return True\n        if grid[x][y] != word[i]: return False\n        grid[x][y] = ''\n        r = any(rc(x + u, y + v, i + 1)\n                for u in range(-1, 2)\n                for v in range(-1, 2))\n        grid[x][y] = word[i]\n        return r\n    return any(rc(x, y, 0)\n               for x in range(len(board))\n               for y in range(len(board[x])))
class PlayerMovement:\n    \n    PREC   = [8,        2,         4,        6]                                                                               # Order of precedence\n    I_KEYS = {8: 0,     2: 1,      4: 2,      6: 3}                                                                           # Index of the keys in self.pressed\n    MOVES  = {8: (0,1), 2: (0,-1), 4: (-1,0), 6: (1,0)}                                                                       # Moves directions\n\n    def __init__(self, x, y):\n        self.position  = Tile(x, y)                                                                                           # Current position\n        self.direction = 8                                                                                                    # Current direction of move\n        self.pressed   = [0,0,0,0]                                                                                            # Keys currently pressed or not (True/False)\n        self.stack     = []                                                                                                   # Stack representing the order of the pressed keys (according to pressing order AND precedence if multiple pressing at the same time)\n\n    def update(self):\n        state       = [Input.get_state(d) for d in self.PREC]                                                                 # State of the art at update time\n        \n        newPressed  =     [ d for i,d in enumerate(self.PREC) if not self.pressed[i] and state[i] ]                           # All keys freshly pressed\n        notReleased = next((d for d   in self.stack[::-1]  if self.pressed[self.I_KEYS[d]] and state[self.I_KEYS[d]]), None)  # Last key that has not been released yet (according to the order of the stack[::-1] because one search for the last pressed)\n        releasedLst =     [ d for i,d in enumerate(self.PREC) if self.pressed[i] and not state[i] ]                           # All keys freshly released\n        \n        if newPressed:                                                                                                        # If new key pressed:\n            self.direction = newPressed[0]                                                                                    #     Update direction with higher precedence\n            for t in newPressed[::-1]: self.stack.append(t)                                                                   #     append all the new kleys to the stack, lower preccedence first\n            \n        elif self.direction in releasedLst:                                                                                   # If the current direction has been released:\n            self.direction = notReleased or self.direction                                                                    #     upadte direction. If no pressed key remain, do not update\n                \n        elif notReleased:                                                                                                     # If current direction still pressed and no other key pressed in the meantime:\n            self.position  = Tile(*( z+dz for z,dz in zip([self.position.x, self.position.y], self.MOVES[notReleased]) ))     #     MOVE!\n            \n        self.pressed = state                                                                                                  # Archive current state of keys\n        for t in releasedLst: self.stack.remove(t)                                                                            # remove all the released keys from the stack, whatever their position in the stack is
import re\n\nclass Me(object):\n    def __init__(self): self.x, self.y, self.dx, self.dy = 0,0,-1,0\n    def move(self, n):  self.x += n*self.dx ; self.y += n*self.dy\n    def back(self):     self.dx *= -1 ; self.dy *= -1\n    def turn(self, d):  self.dx,self.dy = (self.dy * (-1)**(d=='l'), 0) if self.dy else (0, self.dx * (-1)**(d=='r'))\n    def where(self):    return [self.x, self.y]\n    def __str__(self):  return f'x,y={self.x},{self.y} (dx,dy={self.dx},{self.dy})'\n\nme = Me()\n\ndef i_am_here(path):\n    for v in re.findall(r'\d+|.', path):\n        if   v in 'RL': me.back()\n        elif v in 'rl': me.turn(v)\n        else:           me.move(int(v))\n    return me.where()
def two_by_n(n, k):\n    vv, vh, hv, hh = k-1, (k-1)*(k-2), k-2, (k-1)*(k-2) + 1\n    va, ha, vb, hb = 0, 0, 1, 1\n    for i in range(n - 1):\n        va, ha, vb, hb = vb, hb, vv*vb + vh*ha, hv*vb + hh*ha\n    return (k * vb + k*(k-1) * ha) % 12345787\n
from random import choice\n\ndef interpret(code):\n    code = [list(l) for l in code.split('\n')]\n    x, y = 0, 0\n    dx, dy = 1, 0\n    output = ''\n    stack = []\n    string_mode = False\n    \n    while True:\n        move = 1\n        i = code[y][x]\n        \n        if string_mode:\n            if i == '"':\n                string_mode = False\n            else:\n                stack.append(ord(i))\n        else:\n        \n            if i.isdigit(): stack.append(int(i))\n            elif i == '+': stack[-2:] = [stack[-2] + stack[-1]]\n            elif i == '-': stack[-2:] = [stack[-2] - stack[-1]]\n            elif i == '*': stack[-2:] = [stack[-2] * stack[-1]]\n            elif i == '/': stack[-2:] = [stack[-2] and stack[-2] / stack[-1]]\n            elif i == '%': stack[-2:] = [stack[-2] and stack[-2] % stack[-1]]\n            elif i == '!': stack[-1] = not stack[-1]\n            elif i == '`': stack[-2:] = [stack[-2] > stack[-1]]\n            elif i in '><^v?':\n                if i == '?':   i = choice('><^v')\n                if i == '>':   dx, dy =  1,  0\n                elif i == '<': dx, dy = -1,  0\n                elif i == '^': dx, dy =  0, -1\n                elif i == 'v': dx, dy =  0,  1\n            elif i == '_': dx, dy = (-1 if stack.pop() else 1), 0\n            elif i == '|': dx, dy = 0, (-1 if stack.pop() else 1)\n            elif i == '"': string_mode = True\n            elif i == ':': stack.append(stack[-1] if stack else 0)\n            elif i == '\\': stack[-2:] = stack[-2:][::-1]\n            elif i == '$': stack.pop()\n            elif i == '.': output += str(stack.pop())\n            elif i == ',': output += chr(stack.pop())\n            elif i == '#': move += 1\n            elif i == 'p':\n                ty, tx, tv = stack.pop(), stack.pop(), stack.pop()\n                code[ty][tx] = chr(tv)\n            elif i == 'g':\n                ty, tx = stack.pop(), stack.pop()\n                stack.append(ord(code[ty][tx]))\n            elif i == '@':\n                return output\n        \n        for _ in range(move):\n            x = (x + dx) % len(code[y])\n            y = (y + dy) % len(code)
from collections import defaultdict\nfrom functools import reduce\nimport re\n\nP_EQ = re.compile("(?P<eq>=)|(?P<coef>[+-]?\d*)(?P<var>[a-zA-Z]*)")\n\n\ndef solve(*equations):\n    \n    eqsMap = list(map(parse, equations))                         # Transform each string in a dict {'var': coef}\n    vars   = reduce(set.union, (set(e) for e in eqsMap))         # Extract all the variables\n    vars   = list(set(vars)-{''}) + ['']                         # Push the "constants" at the end of the list\n    \n    if len(vars)-1 > len(equations): return None                 # Not enough equations to solve the system\n    \n    m = [ [eqm[v] for v in vars] for eqm in eqsMap]              # Build the matrix\n    \n    return solveMatrix(m, vars)                                  # Solve using Gauss elimination\n    \n\ndef parse(eq):\n    rev, dct = 1, defaultdict(int)\n    for m in P_EQ.finditer(eq.replace(" ","")):\n        if m['eq']:\n            rev = -1\n        else:\n            gc, gv = m['coef'], m['var']\n            if gc or gv:\n                coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                dct[ m['var'] ] += coef * rev\n    return dct\n\n\ndef solveMatrix(m, vars):\n    \n    EPS    = 1e-10\n    pivots = {}                                                  # dict of the indexes of the pivots (avoid to have to move the raws)\n    toDo   = set(range(len(m)))                                  # set with the indexes of all the lines where the pivot will have to be sought for\n    \n    for y in range(len(vars)-1):                                 # "-1" to avoid the constants\n        \n        _,px = max( ((abs(m[x][y]),x) for x in toDo if abs(m[x][y]) > 0), default=(-1,-1))\n        \n        if px == -1: continue                                    # No pivot found\n        pivots[px] = y\n        toDo.remove(px)\n        \n        maxP, m[px][y] = m[px][y], 1\n        for j in range(y+1,len(vars)):                           # Update the line of the current pivot\n            m[px][j] /= maxP\n            if abs(m[px][j]) < EPS: m[px][j] = 0                 # Handle floating point errors\n        \n        for x in range(0,len(m)):                                # Update all the lines, doing the elimination\n            if x==px: continue                                   # Skip the line of the current pivot\n            \n            coef, m[x][y] = m[x][y], 0\n            for j in range(y+1,len(vars)):                       # Update the line of the current pivot\n                m[x][j] -= coef * m[px][j]\n                if abs(m[x][j]) < EPS: m[x][j] = 0               # Handle floating point errors, again...\n        \n    \n    solvedDct = {}\n    for x in range(len(m)):                                      # Build the solution dict\n        yP = pivots.get(x, None)\n        if yP is None: continue\n        \n        solvedDct[ vars[yP] ] = -m[x][-1]\n    \n    if len(solvedDct) == len(vars)-1: return solvedDct           # Valid only if all the variables have been used as pivots \n
from collections import deque\nmoves = ((1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1))\n\ndef knight(p1, p2):\n    x, y = ord(p2[0])-97, int(p2[1])-1\n    left, seen = deque([(ord(p1[0])-97, int(p1[1])-1, 0)]), set()\n    while left:\n        i, j, v = left.popleft()\n        if i==x and j==y: return v\n        if (i, j) in seen: continue\n        seen.add((i, j))\n        for a,b in moves:\n            if 0 <= i+a < 8 and 0 <= j+b < 8:\n                left.append((i+a, j+b, v+1))
class User ():    \n    def __init__ (self):\n        self.RANKS = [-8, -7, -6, -5, -4, -3, -2, -1, 1, 2, 3, 4, 5, 6, 7, 8]\n        self.rank = -8\n        self.rank_index = 0\n        self.progress = 0\n        \n    def inc_progress (self, rank):\n        rank_index = self.RANKS.index(rank)\n        \n        if rank_index == self.rank_index:\n            self.progress += 3\n        elif rank_index == self.rank_index - 1:\n            self.progress += 1\n        elif rank_index > self.rank_index:\n            difference = rank_index - self.rank_index\n            self.progress += 10 * difference * difference\n            \n        while self.progress >= 100:\n            self.rank_index += 1\n            self.rank = self.RANKS[self.rank_index]\n            self.progress -= 100    \n        \n        if self.rank == 8:\n            self.progress = 0\n            return
from heapq import *\n\nMOVES = tuple( (dx,dy) for dx in range(-1,2) for dy in range(-1,2) if dx or dy)\n\n\ndef shallowest_path(river):\n\n    lX,lY   = len(river), len(river[0])\n    pathDct = {}\n    cost    = [ [(float('inf'),float('inf'))]*lY for _ in range(lX) ]\n    for x in range(lX): cost[x][0] = (river[x][0],1)\n    \n    q = [ (river[x][0], lY==1, 1, (x,0)) for x in range(lX)]\n    heapify(q)\n    \n    while not q[0][1]:\n        c,_,steps,pos = heappop(q)\n        x,y = pos\n        for dx,dy in MOVES:\n            a,b = new = x+dx,y+dy\n            if 0<=a<lX and 0<=b<lY: \n                check = nC,nS = max(c, river[a][b]), steps+1\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b==lY-1, nS, new))\n    \n    path, pos = [], q[0][-1]\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]
def is_incrementing(number): return str(number) in '1234567890'\ndef is_decrementing(number): return str(number) in '9876543210'\ndef is_palindrome(number):   return str(number) == str(number)[::-1]\ndef is_round(number):        return set(str(number)[1:]) == set('0')\n\ndef is_interesting(number, awesome_phrases):\n    tests = (is_round, is_incrementing, is_decrementing,\n             is_palindrome, awesome_phrases.__contains__)\n       \n    for num, color in zip(range(number, number+3), (2, 1, 1)):\n        if num >= 100 and any(test(num) for test in tests):\n            return color\n    return 0
from collections import Counter\n\ndef runoff(voters):\n    while voters[0]:\n        poll = Counter(ballot[0] for ballot in voters)\n        winner, maxscore = max(poll.items(), key = lambda x: x[1])\n        minscore = min(poll.values())\n        if maxscore * 2 > len(voters):\n            return winner\n        voters = [[c for c in voter if poll[c] > minscore] for voter in voters]
from collections import defaultdict\nfrom itertools   import combinations\n\ndef norme(vect):          return sum( v**2 for v in vect )**.5\ndef vectorize(pt1, pt2):  return [b-a for a,b in zip(pt1, pt2)]\ndef isInCircle(d, r):     return d < r and (r-d)/r > 1e-10\ndef crossProd(v1, v2):    return [v1[0]*v2[1] - v1[1]*v2[0],\n                                  v1[1]*v2[2] - v1[2]*v2[1],\n                                  v1[2]*v2[0] - v1[0]*v2[2] ]\n\ndef biggest_triang_int(point_list, center, radius):\n    filteredPts = [ pt for pt in point_list if isInCircle(norme(vectorize(pt, center)), radius) ]\n    \n    dctTriangles = defaultdict(list)\n    for threePts in combinations(filteredPts, 3):\n        area = abs( norme(crossProd(vectorize(*threePts[:2]), vectorize(*threePts[1:]))) / 2.0 )\n        if area > 1e-8: dctTriangles[area].append(list(threePts))\n    \n    maxArea = max(dctTriangles.keys()) if dctTriangles else 0\n    return [] if not dctTriangles else [sum(map(len, dctTriangles.values())),\n                                        maxArea,\n                                        sorted(dctTriangles[maxArea]) if len(dctTriangles[maxArea]) > 1 else dctTriangles[maxArea][0] ]
def decodeBits(bits):\n    import re\n    \n    # remove trailing and leading 0's\n    bits = bits.strip('0')\n    \n    # find the least amount of occurrences of either a 0 or 1, and that is the time hop\n    time_unit = min(len(m) for m in re.findall(r'1+|0+', bits))\n    \n    # hop through the bits and translate to morse\n    return bits[::time_unit].replace('111', '-').replace('1','.').replace('0000000','   ').replace('000',' ').replace('0','')\n\ndef decodeMorse(morseCode):\n    return ' '.join(''.join(MORSE_CODE[l] for l in w.split()) for w in morseCode.split('   '))\n
class family:\n    def __init__(self): self.names = {}        \n    def male(self, n): return self.setsex(n, 'm')        \n    def female(self, n): return self.setsex(n, 'f')        \n    def is_male(self, n): return self.names[n]['sex'] == 'm' if n in self.names else False\n    def is_female(self, n): return self.names[n]['sex'] == 'f' if n in self.names else False\n    def get_parents_of(self, n): return sorted(self.names[n]['childof']) if n in self.names else []\n    def get_children_of(self, n): return sorted(self.names[n]['parentof']) if n in self.names else []\n    \n    def updatesex(self):\n        for n in [n for n in self.names if len(self.names[n]['childof']) == 2]:\n            for a, b in [self.names[n]['childof'], self.names[n]['childof'][::-1]]:\n                if self.names[a]['sex'] and not self.names[b]['sex']:\n                    self.names[b]['sex'] = 'f' if self.names[a]['sex'] == 'm' else 'm'\n                    self.updatesex()\n                \n    def setsex(self, name, sex):\n        if name not in self.names: self.names[name] = {'sex':'', 'parentof':[], 'childof':[]}\n        if not self.names[name]['sex']: \n            self.names[name]['sex'] = sex\n            self.updatesex()    \n        \n        return self.names[name]['sex'] == sex\n        \n    def set_parent_of(self, c, p):\n        # Create child and/or parent if they do not exist\n        for n in [c, p]:        \n            if n not in self.names: self.names[n] = {'sex':'', 'parentof':[], 'childof':[]}\n\n        if p in self.names[c]['childof']: return True\n        if c == p or len(self.names[c]['childof']) == 2: return False\n        \n        # descendants and ancestors     \n        for tree, direction, name in [(self.names[c]['parentof'], 'parentof', p), (self.names[p]['childof'], 'childof', c)]:\n            while tree:\n                if name in tree: return False\n                tree = [e for d in tree for e in self.names[d][direction]]\n\n        if len(self.names[c]['childof']) == 1:\n            old_p, new_sex = self.names[c]['childof'][0], self.names[p]['sex'] \n            \n            if new_sex + self.names[old_p]['sex'] in ['mm', 'ff']: return False                \n\n            # Check for clashing parents\n            # Get all couple and create a putative sex dictionary S\n            couples = {tuple(self.names[n]['childof']) for n in self.names if len(self.names[n]['childof']) > 1} | {tuple((old_p, p))}\n                \n            S = {p:new_sex or 'm'}\n            while any(parent in S for couple in couples for parent in couple):\n                newcouples = []\n                for a, b in couples:\n                    if a in S or b in S:\n                        if b not in S: S[b] = 'f' if S[a] == 'm' else 'm'\n                        if a not in S: S[a] = 'f' if S[b] == 'm' else 'm'\n                        if  S[a] == S[b]: return False                        \n                    else:\n                        newcouples.append((a, b))                      \n                couples = newcouples\n                \n        self.names[p]['parentof'] += [c]        \n        self.names[c]['childof'] += [p]        \n        self.updatesex()\n        return True
import numpy as np\ndef five_by_2n(n):\n    x=np.array([[1,1,1,1,1,1,1,1],[1,2,1,1,1,2,2,1],[1,1,2,1,1,1,2,1],[1,1,1,2,1,1,2,1],[1,1,1,1,2,1,2,2],[1,2,1,1,2,1,6,1],[1,2,1,1,2,1,6,1],[1,2,1,1,2,1,6,1]])\n    y=np.array([1,1,1,1,1,1,1,1])\n    z=y\n    for i in range(n-1):\n        z=np.mod(x@z,12345787*y)\n    return z.T@y%12345787
def combos(n, m = 1):\n    if n < m:return []\n    res = [[n]]\n    for i in xrange(m, n):\n        l = [i]\n        for j in combos(n - i, i):\n           res += [l + j]\n    return res
def collatz_steps(n, steps):\n    while True:\n        str = ''\n        result = n\n    \n        while bool(str != steps) ^ bool(str != steps[:len(str)]):\n            if result % 2 == 0:\n                result = result/2\n                str += 'D'\n            else:\n                result = (3*result + 1)/2\n                str += 'U'\n            \n        if str != steps: \n              n += 2**(len(str)-1)\n        else: \n              return n
def fusc(n):\n    a, b = 1, 0\n    for i in bin(n)[2:]:\n        if i == '1': b += a\n        else: a += b\n    return b\n
import re\n\nADDSUB, MULDIV = '+-', '*$'\n\ndef calculate(expression):\n    return "400: Bad request" if re.search(r'[^+*$\d.-]', expression) else parseAndEval(expression, ADDSUB)\n\ndef parseAndEval(expression, ops):\n    v = 0\n    for op,part in re.findall(r'([{0}])?([^{0}]+)'.format(ops), expression):\n        if not op:    v  = float(part) if ops == MULDIV else parseAndEval(part, MULDIV)\n        elif op=='*': v *= float(part)\n        elif op=='$': v /= float(part)\n        elif op=='+': v += parseAndEval(part, MULDIV)\n        elif op=='-': v -= parseAndEval(part, MULDIV)\n    return v
def rpg(field, actions):\n    p = Player(field)\n    try:\n        for m in actions:\n            if m=='A': p.attack()\n            elif m in 'HCK':  p.use(m)\n            elif m in '<^>v': p.rotate(m)\n            p.checkDmgsAndAlive()\n            if m=='F':        p.move()\n            \n    except Exception as e:\n        return None\n    return p.state()\n    \n\nclass Player:\n    DIRS = dict(list(zip('<>^v',((0,-1),(0,1),(-1,0),(1,0)))))\n\n    def __init__(self,field):\n        self.h, self.atk, self.d, self.bag, self.xps = 3,1,1,[],0\n        self.field = field\n        self.pngs  = {}\n        for x,r in enumerate(self.field):\n            for y,c in enumerate(r):\n                if c in self.DIRS: self.x,self.y,self.c=x,y,c ; self.dx,self.dy=self.DIRS[c]\n                elif c=='D':       self.pngs[(x,y)] = {'h':10, 'atk':3}\n                elif c=='E':       self.pngs[(x,y)] = {'h':1,  'atk':2}\n                elif c=='M':       self.pngs['M']   = {'coins':3}\n    \n    def state(self): return self.field, self.h, self.atk, self.d, sorted(self.bag)\n    \n    def rotate(self,c):\n        self.dx, self.dy = self.DIRS[c]\n        self.c = self.field[self.x][self.y] = c\n    \n    def move(self):\n        self.field[self.x][self.y] = ' '\n        self.x += self.dx\n        self.y += self.dy\n        c = self.field[self.x][self.y]\n        assert c not in '#ED-|M' and self.x>=0 and self.y>=0\n        if c!=' ': self.takeThis(c)\n        self.field[self.x][self.y] = self.c\n    \n    def checkAhead(self,what):\n        x,y = self.x+self.dx, self.y+self.dy\n        assert self.field[x][y] in what\n        return x,y\n    \n    def takeThis(self,c):\n        if c not in 'SX': self.bag.append(c)\n        if   c=='S': self.d += 1\n        elif c=='X': self.atk += 1\n        \n    def use(self,c):\n        self.bag.remove(c)\n        if c=='C':\n            x,y = self.checkAhead('M')\n            self.pngs['M']['coins'] -= 1\n            if not self.pngs['M']['coins']: self.field[x][y] = ' '\n        elif c=='H':\n            assert self.h<3\n            self.h = 3\n        elif c=='K':\n            x,y = self.checkAhead('|-')\n            self.field[x][y] = ' '\n        \n    def attack(self):\n        x,y = nmy = self.checkAhead('ED')\n        self.pngs[nmy]['h'] -= self.atk\n        if self.pngs[nmy]['h']<1:\n            del self.pngs[nmy]\n            self.field[x][y] = ' '\n            lvlUp,self.xps = divmod(self.xps+1,3)\n            self.atk += lvlUp\n        \n    def checkDmgsAndAlive(self):\n        for dx,dy in list(self.DIRS.values()):\n            nmy = self.x+dx, self.y+dy\n            if nmy in self.pngs:\n                self.h -= max(0,self.pngs[nmy]['atk'] - self.d)\n                assert self.h>0\n        \n
def crosstable(players, scores):\n    points, le = {j:sum(k or 0 for k in scores[i]) for i, j in enumerate(players)}, len(players)\n    SB = {j:sum(points[players[k]] / ([1, 2][l == 0.5]) for k, l in enumerate(scores[i]) if l) for i, j in enumerate(players)}\n\n    SORTED, li = [[i, players.index(i)] for i in sorted(players, key=lambda x: (-points[x], -SB[x], x.split()[1]))], []\n\n    ps = [format(i, '.1f') for i in points.values()]\n    Ss = [format(i, '.2f') for i in SB.values()]\n    \n    digit = len(str(le))\n    name = len(max(players, key=len))\n    pts = len(str(max(ps, key=lambda x: len(str(x)))))\n    sb = len(str(max(Ss, key=lambda x: len(str(x)))))\n\n    for i, j in enumerate(SORTED):\n        ten_ = [" ", "  "][le >= 10]\n        index = [str(i + 1), " "][points[j[0]] == points[SORTED[i - 1][0]] and SB[j[0]] == SB[SORTED[i - 1][0]]].rjust(digit)\n        name_ = j[0].ljust(name)\n        team = ten_.join(['1=0 '[[1, 0.5, 0, None].index(scores[j[1]][l])] or '_' for k, l in SORTED])\n        pt = str(format(points[j[0]], ".1f")).rjust(pts)\n        Sb = str(format(SB[j[0]], ".2f")).rjust(sb)\n        li.append(f'{index}  {name_}{["  ", "   "][le >= 10]}{team}  {pt}  {Sb}')\n    \n    fline = ' '.join(['#'.rjust(digit) + '  ' +\n                    'Player'.ljust(name) +\n                    ['  ', '   '][len(players) >= 10] +\n                    ''.join([[' ', '  '][i < 10 and le >= 10] + str(i) for i in range(1, le + 1)]).strip() + '  ' +\n                    'Pts'.center(pts) + '  ' +\n                    'SB'.center(sb - [0, 2][sb & 1])]).rstrip()\n    return '\n'.join([fline, '=' * len(max(li, key=len))] + li)
import collections\n\nclass Tower:\n    def __init__(self):\n        indicesOfAlienPath = []\n        shots = 0\n\nclass GameStats:\n    def __init__(self):\n        alienPath = collections.deque()\n        towers = []\n        waves = collections.deque()\n\nDirEOL = 0\nDirLeft = 1\nDirRight = 2\nDirUp = 3\nDirDown = 4\n\n\ndef tower_defense(grid, turrets, aliens):\n    game = FromBattlefield(grid, turrets, aliens)\n    numSurvivedAliens = 0\n    while AnalysisIsRunning(game.alienPath, game.remainingWaves):\n        game = PrepareRound(game)\n        game.alienPath = KillAliens(game.alienPath, game.towers)\n        numSurvivedAliens = numSurvivedAliens + CountAliensLeavingPath(game.alienPath)\n    return numSurvivedAliens\n\ndef FromBattlefield(grid, turrets, aliens):\n    coords = DeterminePathCoordinates(grid)\n    game = GameStats()\n    game.alienPath = collections.deque([0 for a in range(len(coords))])\n    game.towers = CreateTowers(grid, turrets, coords)\n    game.remainingWaves = collections.deque(aliens)\n    return game\n\ndef DeterminePathCoordinates(grid):\n    result = []\n    coord = GetCoordFor(grid, '0')\n    result.append(coord)\n    dir = LookForPath(grid, coord, DirEOL)\n    while dir != DirEOL:\n        coord = GetCoordinate(coord, dir)\n        result.append(coord)\n        dir = LookForPath(grid, coord, dir)\n    return result\n\ndef GetCoordFor(grid, id):\n    n = len(grid)\n    for row in range(n):\n        for col in range(n):\n            if grid[row][col] == id:\n                return (col, row)\n    return (0,0)\n\ndef LookForPath(grid, c, dir):\n    if IsOnPath(grid, (c[0]+1, c[1])) and dir != DirLeft:\n        return DirRight\n    elif IsOnPath(grid, (c[0]-1, c[1])) and dir != DirRight:\n        return DirLeft\n    elif IsOnPath(grid, (c[0], c[1]-1)) and dir != DirDown:\n        return DirUp\n    elif IsOnPath(grid, (c[0], c[1]+1)) and dir != DirUp:\n        return DirDown\n    return DirEOL\n\ndef GetCoordinate(orig, dir):\n    if dir == DirLeft:\n        return (orig[0]-1, orig[1])\n    elif dir == DirRight:\n        return (orig[0]+1, orig[1])\n    elif dir == DirUp:\n        return (orig[0], orig[1]-1)\n    elif dir == DirDown:\n        return (orig[0], orig[1]+1)\n    return orig\n\ndef IsOnPath(grid, c):\n    n = len(grid)\n    return c[1] < n and c[0] < n and c[1] >= 0 and c[0] >= 0 and (grid[c[1]][c[0]] == '1' or grid[c[1]][c[0]] == '0')\n\ndef CreateTowers(grid, turrets, alienPathCoords):\n    towers = []\n    for name in sorted(turrets.keys()):\n        towerCoords = GetCoordFor(grid, name)\n        pathIdxInRange = DetermineIndicesOfAlienPathInRange(alienPathCoords, towerCoords, turrets[name][0])\n        towers.append((pathIdxInRange, turrets[name][1]))\n    return towers\n\ndef DetermineIndicesOfAlienPathInRange(alienPathCoords, towerCoords, dist):\n    result = []\n    sqrDist = dist*dist\n    startY = max(0, towerCoords[1] - dist)\n    startX = max(0, towerCoords[0] - dist)\n    for y in range(startY, towerCoords[1] + dist+1):\n        for x in range(startX, towerCoords[0] + dist+1):\n            cur = (x, y)\n            if cur in alienPathCoords and SqrDistance(cur, towerCoords) <= sqrDist:\n                result.append(alienPathCoords.index(cur))\n    return sorted(result)\n\ndef SqrDistance(left, right):\n    y = left[1] - right[1]\n    x = left[0] - right[0]\n    return x*x + y*y\n\n\ndef AnalysisIsRunning(alienPath, waves):\n    return len(waves) > 0 or any(alienPath)\n\ndef PrepareRound(game):\n    game.alienPath.pop()\n    if len(game.remainingWaves) > 0:\n        game.alienPath.appendleft(game.remainingWaves.popleft())\n    else:\n        game.alienPath.appendleft(0)\n    return game\n\ndef KillAliens(alienPath, towers):\n    activeTowers = towers.copy()\n    while CanShootAgain(activeTowers):\n        alienPath, activeTowers = ShootWithTowers(alienPath, activeTowers)\n        activeTowers = FilterInactiveTowers(alienPath, activeTowers)\n    return alienPath\n\ndef CanShootAgain(towers):\n    return len(towers) > 0\n\ndef ShootWithTowers(alienPath, towers):\n    towersShot = []\n    for t in towers:\n        alienPath, t = ShootAliensInFormostPosition(alienPath, t)\n        towersShot.append(t)\n    return alienPath, towersShot\n\ndef ShootAliensInFormostPosition(alienPath, tower):\n    for idx in reversed(tower[0]):\n        if alienPath[idx] > 0:\n            shots = tower[1] - 1\n            alienPath[idx] = alienPath[idx] - 1\n            return alienPath, (tower[0], shots)\n    return alienPath, tower\n\ndef FilterInactiveTowers(alienPath, towers):\n    result = []\n    for t in towers:\n        if t[1] > 0 and AreAliensInRange(alienPath, t[0]):\n            result.append(t)\n    return result\n\ndef AreAliensInRange(alienPath, towerRange):\n    for idx in towerRange:\n        if alienPath[idx] > 0:\n           return True\n    return False\n\ndef CountAliensLeavingPath(alienPath):\n    return alienPath[-1]
def isqrt(num):\n    '''Compute int(sqrt(n)) for n integer > 0\n    O(log4(n)) and no floating point operation, no division'''\n    res, bit = 0, 1\n    while bit <= num:\n        bit <<= 2\n    bit >>= 2\n\n    while bit:\n        if num >= res + bit:\n            num -= res + bit\n            res += bit << 1\n        res >>= 1\n        bit >>= 2\n    return res\n\ndef factorize(n):\n    for q in 2, 3:\n        m = 0\n        while not n % q:\n            m += 1\n            n //= q\n        if m: yield q, m\n    \n    m, d, q, maxq = 0, 4, 1, isqrt(n)\n    while q <= maxq:\n        q, d = q + d, 6 - d\n        while not n % q:\n            m += 1\n            n //= q\n        if m:\n            yield q, m\n            m, d, q, maxq = 0, 4, 1, isqrt(n)\n    if n > 1: yield n, 1\n\ndef count_factor(n, f):\n    s = 0\n    while n >= f:\n        n //= f\n        s += n\n    return s\n\ntrailing_zeros = lambda n, b: min(count_factor(n, f)//m for f, m in factorize(b))
def mystery(n):\n    return n ^ (n >> 1)\n\ndef mystery_inv(n):\n    mask = n >> 1\n    while mask != 0:\n        n = n ^ mask\n        mask = mask >> 1\n    return n;\n\ndef name_of_mystery():\n    return "Gray code"
from heapq import *\nfrom itertools import starmap\nfrom collections import deque, namedtuple\n\nArmy    = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\n\ndef queue_battle(d, *args):\n    armies  = [ Army(i, deque(starmap(Soldier,enumerate(q))) ) for i,q in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]        # bullet[i] shoots at armies[i+1]\n    t       = 0\n    \n    while len(armies)>1:\n        t     += 1\n        alives = [1]*len(armies)\n        \n        for i,q in enumerate(bullets):\n            if q and q[0]<=t:    alives[ (i+1)%len(armies) ] = 0\n            while q and q[0]<=t: heappop(q)\n        \n        emptyArmies = False\n        for i,alive in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + d/armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        \n        if emptyArmies:\n            armies  = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n            \n    if not armies: return (-1,())\n    win = armies.pop()\n    return (win.i, tuple(soldier.i for soldier in win.q))
from itertools import product\n\nADJACENTS = ('08', '124', '2135', '326', '4157', '52468', '6359', '748', '85790', '968')\n\ndef get_pins(observed):\n    return [''.join(p) for p in product(*(ADJACENTS[int(d)] for d in observed))]
def least_bribes(bribes):\n    mem = {}\n    def s(n1, n2):\n        if n1 >= n2: return 0\n        if (n1, n2) in mem: return mem[n1, n2]\n        r = min(bribes[i] + max(s(n1, i), s(i + 1, n2)) for i in range(n1, n2))\n        mem[n1, n2] = r\n        return r\n    return s(0, len(bribes))
def valid(a):   \n    d = {}\n    day_length = len(a[0])\n    group_size = len(a[0][0])\n    golfers = {g for p in a[0] for g in p}\n    \n    for day in a:\n        if len(day) != day_length: return False\n        for group in day:\n            if len(group) != group_size: return False\n            for player in group:\n                if player not in golfers: return False\n                if player not in d:\n                    d[player] = set(group)\n                else:\n                    if len(d[player] & set(group)) > 1: return False\n                    else: d[player].add(group)\n    return True
def splitlist(l):\n  half = sum(l) // 2\n  sums = [(0, [])]\n  for i, n in enumerate(l):\n      sums = sums + [(m + n, a + [i]) for m, a in sums if m + n <= half]\n      if max(s[0] for s in sums) == half:\n          break\n  sums.sort(key=lambda v: abs(v[0] - half))\n  indices = sums[0][1]\n  return [n for i, n in enumerate(l) if i in indices], [n for i, n in enumerate(l) if i not in indices]\n
def handle(func, success, failure, *exceptions):\n    class manager:\n        def __enter__(self):\n            pass\n        def __exit__(self, type, value, traceback):\n            if isinstance(value, exceptions):\n                failure(func, value)\n                return True\n            return not value\n    with manager():\n        success(func, func())\n
def knights_tour(start, size):\n    \n    MOVES = [(-2,1), (-2,-1), (-1,-2), (1,-2), (2,-1), (2,1), (1,2), (-1,2)]\n    \n    def genNeighs(pos): return ((pos[0]+dx, pos[1]+dy) for dx,dy in MOVES if (pos[0]+dx, pos[1]+dy) in Warnsdorf_DP)\n        \n    def travel(pos):\n        neighs = sorted( (Warnsdorf_DP[n], n) for n in genNeighs(pos) )\n        for nSubNeighs,neigh in neighs:\n            del Warnsdorf_DP[neigh]\n            path.append(neigh)\n            subNeighs = list(genNeighs(neigh))\n            for n in subNeighs: Warnsdorf_DP[n] -= 1\n            travel(neigh)\n            if not Warnsdorf_DP:\n                break\n            else:\n                for n in subNeighs: Warnsdorf_DP[n] += 1\n                Warnsdorf_DP[path.pop()] = nSubNeighs\n    \n    \n    path, Warnsdorf_DP = [start], {(x,y): 0 for x in range(size) for y in range(size) if (x,y) != start}\n    for pos in Warnsdorf_DP: Warnsdorf_DP[pos] = sum(1 for _ in genNeighs(pos))\n    travel(start)\n    \n    return path
import itertools\n\ndef permutations(string):\n    return list("".join(p) for p in set(itertools.permutations(string)))
from collections import defaultdict\n\n\ndef setter(prep,k,v,supSetter):\n    if callable(v): \n        def wrap(*args):\n            f = prep.d[k][len(args)]\n            if isinstance(f,int): raise AttributeError()\n            return f(*args)\n        prep.d[k][v.__code__.co_argcount] = v\n        v = wrap\n    supSetter(k,v)\n        \n        \nclass Prep(dict):\n    def __init__(self):         self.d = defaultdict(lambda: defaultdict(int))\n    def __setitem__(self,k,v):  setter(self, k, v, super().__setitem__)\n\n\nclass Meta(type):\n    @classmethod\n    def __prepare__(cls,*args, **kwds): return Prep()\n    \n    def __new__(metacls, name, bases, prep, **kwargs):\n        prep['_Meta__DCT'] = prep\n        return super().__new__(metacls, name, bases, prep, **kwargs)\n    \n    def __setattr__(self,k,v): setter(self.__DCT, k, v, super().__setattr__)
from collections import defaultdict\n\ndef count(chessBoard):\n    # Initialize:\n    board = chessBoard.copy()\n    tally = defaultdict(int)\n\n    # Compute Longest square ending in bottom right corner of each element and tally up:\n    for i, row in enumerate(board):\n        for j, element in enumerate(row):\n            # Edge detection:\n            if i == 0 or j == 0:\n                continue\n\n            # Compute & Tally:\n            if element:\n                n = board[i][j] = min(board[i - 1][j], board[i][j - 1], board[i - 1][j - 1]) + 1\n                for x in range(n, 1, -1):\n                    tally[x] += 1\n\n    return tally
idx, n, seq = 2, 6, [1, 2, 4, 6]\nwhile n < 2 ** 41:\n    idx += 1\n    seq.extend(range(n + idx, n + (seq[idx] - seq[idx-1]) * idx + 1, idx))\n    n += (seq[idx] - seq[idx-1]) * idx\n\nfrom bisect import bisect\ndef find(n): return bisect(seq, n)
def add_point(ori,dis,c):\n    lastPoint = c[-1]\n    if ori == "N":\n        c.append((lastPoint[0],lastPoint[1]+dis))\n    elif ori == "S":\n        c.append((lastPoint[0],lastPoint[1]-dis))\n    elif ori == "E":\n        c.append((lastPoint[0]+dis,lastPoint[1]))\n    else: \n        c.append((lastPoint[0]-dis,lastPoint[1]))\n\ndef check_corner(l_o):\n    ini = l_o[0]\n    fin = l_o[-1]\n    if ini==fin: return False\n    if ini == "N" or ini =="S": ini = "V"\n    else: ini = "H"\n    if fin == "N" or fin =="S": fin = "V"\n    else: fin = "H"\n    if ini==fin: return False\n    return True\n\ndef check_intersect(rectas):\n    u=rectas[-1]\n    ux=[u[0][0],u[1][0]]\n    ux.sort()\n    uy=[u[0][1],u[1][1]]\n    uy.sort()\n\n    oriU = ""\n    if ux[0] == ux[1]: oriU = "V"\n    if uy[0] == uy[1]: oriU = "H"\n    \n    for r in rectas[:-2]:\n        rx=[r[0][0],r[1][0]]\n        rx.sort()\n        ry=[r[0][1],r[1][1]]\n        ry.sort()\n\n        oriR = ""\n        if rx[0] == rx[1]: oriR = "V"\n        if ry[0] == ry[1]: oriR = "H"\n\n        if oriU==oriR: \n            if oriU == "V" and ux[0]==rx[0]:\n                if ry[0] <= uy[0] <= ry[1] or ry[0] <= uy[1] <= ry[1] :\n                    return True\n                if uy[0] < ry[0] and uy[1] > ry[1]:\n                    return True \n\n            if oriU =="H" and uy[0]==ry[0]:\n                if rx[0] <= ux[0] <= rx[1] or rx[0] <= ux[1] <= rx[1] :\n                    return True\n                if ux[0] < rx[0] and ux[1] > rx[1]:\n                    return True \n        elif oriU =="V":\n            if uy[0]<=ry[0]<=uy[1]:\n                if rx[0] < ux[0] and rx[1] > ux[0]:\n                    return True\n        elif oriU =="H":\n            if ux[0]<=rx[0]<=ux[1]:\n                if ry[0] < uy[0] and ry[1] > uy[0]:\n                    return True  \n        else:\n            return False\n\ndef calc_area(camino):\n    parN=camino[-1][0]*camino[0][1] - camino[-1][1] * camino[0][0]\n    for p in range(1,len(camino)):\n        par=camino[p-1][0]*camino[p][1] - camino[p-1][1]*camino[p][0]\n        parN+=par\n    return abs(parN)/2\n\ndef mouse_path(s):\n    camino=[(0,0)]\n    distancia = 0\n    listaOrientaciones = ["E"]\n    rectas = []\n     \n    for c in s:\n        orientacion = listaOrientaciones[-1]\n        if c.isdigit():\n            distancia=distancia*10 + int(c)\n        else:\n            add_point(orientacion,distancia,camino)\n            rectas.append((camino[-2],camino[-1]))\n            if check_intersect(rectas): return None\n            if c == "L":\n                if orientacion == "N": listaOrientaciones.append("O")\n                elif orientacion == "S": listaOrientaciones.append("E") \n                elif orientacion == "E": listaOrientaciones.append("N")\n                else: listaOrientaciones.append("S")\n            else:\n                if orientacion == "N": listaOrientaciones.append("E")\n                elif orientacion == "S": listaOrientaciones.append("O") \n                elif orientacion == "E": listaOrientaciones.append("S")\n                else: listaOrientaciones.append("N")\n            distancia = 0\n    add_point(orientacion,distancia,camino)\n    rectas.append((camino[-2],camino[-1]))\n    if check_intersect(rectas): return None\n\n    if camino[-1] != (0,0): return None\n\n    if not check_corner(listaOrientaciones): return None\n\n    return calc_area(camino)
from functools import reduce\nfrom operator import mul\n\ndef insane_inc_or_dec(x):   \n    return (reduce(mul,[x + i + i * (i == 10) for i in range(1, 11)]) // 3628800 - 10 * x - 2) % 12345787    
#THanks to easter eggs kata ;*\n\ndef height(n, m):\n    if n >= m:\n        return (2 ** (min(n, m)) - 1)\n    f = 1\n    res = 0\n    for i in range(n):\n        f = f * (m - i) // (i + 1)\n        res += f\n    return res\n\ndef solve(emulator):\n    m = emulator.drops\n    n = emulator.eggs\n    h = 0\n    tryh = 0\n    while n and m:\n        tryh = height(n - 1, m - 1) + 1\n        if emulator.drop(h + tryh):\n            n -= 1\n        else:\n            h += tryh\n        m -= 1\n    return(h + 1)\n    # continue here\n
def partitions(n):\n    c = [[1]]\n    for x in range(1, n + 1):\n        c.append([0])\n        for m in range(1, x + 1):\n            c[x].append(c[x][m - 1] + c[x - m][min(m, x - m)])\n    return c[n][n]
def b(n):\n    if not n: return '0'\n    r = []\n    while n:\n        r.append(n % 2)\n        n = (n - n % 2) / -2\n    return ''.join(str(c) for c in r[::-1])\n\ndef d(n):\n    r = 0\n    for c in n: r = -2 * r + int(c)\n    return r\n\ndef skrzat(base, n):\n    if base == 'b': return 'From binary: %s is %d' % (n, d(n))\n    if base == 'd': return 'From decimal: %d is %s' % (n, b(n))\n    raise ValueError('unknown base')
from collections import Counter\n\ndef solution(tiles):\n    return "".join(\n        tile for tile in "123456789"\n            if tiles.count(tile) < 4\n            and list(meld(meld(meld(meld(pair(Counter(map(int, tiles+tile))))))))\n    )\n\ndef pair(c):\n    yield from (c - Counter([t,t]) for t in c if c[t] > 1)\n\ndef meld(C):\n    yield from (\n        c - m for c in C for t in [min(c.keys())]\n              for m in (Counter((t,t+d,t+d+d)) for d in (0,1))\n              if (c&m) == m)
from itertools import chain\n\ndef fit_bag(H, W, items):\n\n    def deploy(item):\n        X,Y    = len(item), len(item[0])\n        v      = (set(chain.from_iterable(item))-{0}).pop()\n        deltas = [(x,y) for x,r in enumerate(item) for y,n in enumerate(r) if n]\n        return (len(deltas), X*Y, max(X,Y), min(X,Y), X,Y,deltas,v)\n    \n    def dfs(i=0):\n        if i==len(items): yield bag\n        _,_,_,_,X,Y,deltas,v = items[i]\n        for x in range(H-X+1):\n            for y in range(W-Y+1):\n                if all(not bag[x+dx][y+dy] for dx,dy in deltas):\n                    for dx,dy in deltas: bag[x+dx][y+dy] = v\n                    yield from dfs(i+1)\n                    for dx,dy in deltas: bag[x+dx][y+dy] = 0\n    \n    bag   = [ [0]*W for _ in range(H) ]\n    items = sorted(map(deploy,items), reverse=True)\n    return next(dfs())
from collections import defaultdict\ndef shortestPath(gra, srs, des):\n    Q, paths, d = [[0, srs]], [], defaultdict(list)\n    while Q: \n        vrt = Q.pop(0)\n        if vrt[-1] == des: \n            paths.append(vrt)\n            continue\n        for v, c in gra[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0]+c] + vrt[1:] + [v])\n\n    for i in paths: d[i[0]].append(i[1:])   \n        \n    ml, f = len(min(d[min(d)], key = len)), []\n\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 2 else f
def path_finder(maze):\n    lst  = maze.split('\n')\n    X, Y = len(lst)-1, len(lst[0])-1\n    seen = {(x,y) for x,row in enumerate(lst) for y,c in enumerate(row) if c=='W'} | {(0,0)}\n    end, bag, turn = (X,Y), {(0,0)}, 0\n    \n    while bag and end not in bag:\n        bag = { (a,b) for a,b in {(x+dx,y+dy) for x,y in bag for dx,dy in ((0,1), (0,-1), (1,0), (-1,0))}\n                      if 0 <= a <= X and 0 <= b <= Y} - seen\n        seen |= bag\n        turn += 1\n    \n    return bool(bag) and turn
from heapq import heappush, heappop\n\ndef closure_gen(*s):\n    q = sorted(s)\n    m = set(s)\n    while q:\n        curr = heappop(q)\n        yield curr\n        for i in s:\n            t = curr * i\n            if t not in m:\n                heappush(q, t)\n                m.add(t)
from itertools import cycle\n\nclass VigenereCipher (object):\n    def __init__(self, key, alphabet):\n        self.key = key.decode('utf-8')\n        self.alphabet = alphabet.decode('utf-8')\n    \n    def cipher(self, mode, str):\n        return ''.join(self.alphabet[(self.alphabet.index(m) +\n                  mode * self.alphabet.index(k)) % len(self.alphabet)]\n                  if m in self.alphabet else m for m, k in zip(str.decode('utf-8'),\n                  cycle(self.key))).encode('utf-8')\n    \n    def encode(self, str): return self.cipher(1, str)\n    def decode(self, str): return self.cipher(-1, str)\n    \n
def validSolution(board):\n    boxes = validate_boxes(board)\n    cols = validate_cols(board)\n    rows = validate_rows(board)\n    return boxes and cols and rows\n\ndef validate_boxes(board):\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            nums = board[i][j:j+3] + board[i+1][j:j+3] + board[i+2][j:j+3]\n            if not check_one_to_nine(nums):\n                return False\n    return True\n\ndef validate_cols(board):\n    transposed = zip(*board)\n    for row in transposed:\n        if not check_one_to_nine(row):\n            return False\n    return True\n    \ndef validate_rows(board):\n    for row in board:\n        if not check_one_to_nine(row):\n            return False\n    return True\n            \n\ndef check_one_to_nine(lst):\n    check = range(1,10)\n    return sorted(lst) == check
class Funnel(object):\n    \n    SIZE = 5\n    \n    def __init__(self):\n        self.fun = [ [None] * (x+1) for x in range(self.SIZE) ]\n        \n    \n    def fill(self, *args):\n        genBlanks = ((x,y) for x,r in enumerate(self.fun) for y,v in enumerate(r) if v is None)\n        \n        for v,(x,y) in zip(args, genBlanks): \n            self.fun[x][y] = v\n    \n    \n    def drip(self):\n        y,cnt = 0, sum(v is not None for row in self.fun for v in row)\n        drop  = self.fun[0][0]\n        \n        for x in range(self.SIZE-1):\n            left  = cnt - sum( self.fun[xx][y+xx-x] is not None for xx in range(x,self.SIZE))\n            right = cnt - sum( self.fun[xx][y] is not None      for xx in range(x,self.SIZE))\n            \n            ySwp, cnt      = (y,left) if left >= right else (y+1,right)\n            self.fun[x][y] = self.fun[x+1][ySwp]\n            y = ySwp\n            if not cnt: break\n        \n        self.fun[x+1][y] = None\n        return drop\n        \n    \n    def __str__(self):\n        return '\n'.join( f'{" "*x}\\{" ".join( " " if v is None else str(v) for v in r)}/'\n                          for x,r in enumerate(reversed(self.fun)) )\n
from itertools import permutations, chain\n\ndef solve_puzzle (clues):\n    size = 4\n    for poss in permutations(permutations(list(range(1, size+1)), size), size):\n        for i in range(size):\n            if len(set(row[i] for row in poss)) < size:\n                break\n        else:\n            cols_top = [[row[i] for row in poss] for i in range(size)]\n            rows_right = [list(reversed(row)) for row in poss]\n            cols_btm = [[row[i] for row in reversed(poss)] for i in reversed(list(range(size)))]\n            rows_left = list(reversed(poss))\n            for i, row in enumerate(chain(cols_top, rows_right, cols_btm, rows_left)):\n                if not clues[i]:\n                    continue\n                visible = 0\n                for j, v in enumerate(row):\n                    visible += v >= max(row[:j+1])\n                if visible != clues[i]:\n                    break\n            else:\n                return poss\n
def roll_dice (rolls, sides, threshold):\n    dp = [0] * (rolls * sides + 1)\n    for i in range(1, sides+1):\n        dp[i] = 1\n\n    for _ in range(rolls-1):\n        for x in range((rolls * sides), 0, -1):\n            dp[x] = sum(dp[max(1, x-sides):x])\n\n    return sum(dp[threshold:]) / sum(dp[1:])
'''\nChallenge Fun #20: Edge Detection\nhttps://www.codewars.com/kata/58bfa40c43fadb4edb0000b5/train/python\n\nFor a rectangular image given in run-length encoding (RLE) as\ndescribed below, return a RLE of the image processed by replacing\neach pixel by the maximum absolute value of the difference between\nit and each neighboring pixel (a simple form of edge detection).\n\nFor a RLE encoding string "7 15 4 100 15 25 2 ...",\n    7      ----> image width\n    15 4   ----> a pair(color value + pixel count)\n    100 15 ----> a pair(color value + pixel count)\n    25 2   ----> a pair(color value + pixel count)\n    ...          ...\nwhere the image width is > 0 and the sum of all the pixel counts\nis a multiple of the width.\n\n--------------------\nDesign of solution\n\nRead the rle-encoded values into a buffer of rows of the given width,\nwith an important optimization trick. In the case of long runs of the\nsame value, where three or more rows would be filled with identical\ndata, store just three rows of data, and remember (using another data\nstructure) which is the middle of the three rows, and how many copies\nof it (the "row count") were in the original image. For example,\nsuppose the image width is 10, and the image has a run of 73 copies\nof the value 7, and the run starts with the last two values in row 34.\nThe buffer would look like this:\n\n        ...\n    34  [ some previous data ...  7, 7 ]\n    35  [ 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 ]\n    36  [ 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 ]\n    37  [ 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 ]\n    38  [ 7, ... start of new data ... ]\n        ...\n\nand elsewhere a note is made that row 36 has a row count of 5.\n\nWith long runs arranged this way, the edge-detection transformation\ncan be run on the buffer without having to worry about row counts.\nRow counts are used later, when encoding the transformed values back\ninto a run-length encoding.\n'''\nimport itertools\n\ndef edge_detection(image):\n    data = [int(datum) for datum in image.split(' ')]\n    width = data.pop(0)\n\n    (inbuf, rowcounts) = fill_buffer(width, data)\n    outbuf = detect_edges(inbuf)\n\n    outdata_list = encode(outbuf, rowcounts)\n    outdata = [str(datum) for datum in outdata_list]\n    return str(width) + ' ' + ' '.join(outdata)\n\n\ndef fill_buffer(width, data):\n    buf = []\n    rowcounts = dict()      # row: rowcount\n\n    row, row_ndx = [], 0\n    while data:\n        val, runlen = data.pop(0), data.pop(0)\n        if row == [] and runlen > 3 * width:\n            buf += [[val] * width] * 3\n            # There's a top, middle, and bottom row; middle has a row count\n            rowcounts[row_ndx + 1] = (runlen // width) - 2\n            row_ndx += 3\n            # Values from run that didn't fit in the above rows.\n            row = [val] * (runlen % width)\n            continue\n\n        take = min(runlen, width - len(row))\n        runlen -= take\n        row += [val] * take\n        if len(row) < width:\n            continue\n\n        # Here, row is full, with mixed values, and there may be some\n        # (many!) values left over from the last (val, runlen) pair that\n        # was read from data.\n        buf.append(row)\n        row_ndx += 1\n        row = []\n\n        if row == [] and runlen > 3 * width:\n            buf += [[val] * width] * 3\n            # There's a top, middle, and bottom row; middle has a row count\n            rowcounts[row_ndx + 1] = (runlen // width) - 2\n            row_ndx += 3\n            # Values from run that didn't fit in the above rows.\n            row = [val] * (runlen % width)\n            continue\n\n        while runlen > 0:\n            take = min(runlen, width - len(row))\n            runlen -= take\n            row += [val] * take\n            if len(row) == width:\n                buf.append(row)\n                row_ndx += 1\n                row = []\n\n    return buf, rowcounts\n\n\ndef pairs_from(iterable, fillvalue=None):\n    '''\n    Yields iterable's elements in pairs. If iterable is exhausted after\n    an odd number of elements, completes the last pair with fillvalue.\n    '''\n    # This is the 'grouper' recipe from the itertools documentation.\n    args = [iter(iterable)] * 2\n    return itertools.zip_longest(*args, fillvalue=fillvalue)\n\n\ndef detect_edges(inbuf):\n    length = len(inbuf)\n    width = len(inbuf[0])\n\n    outbuf = [([-1] * width).copy() for _ in range(length)]\n\n    # Single pixel\n    if 1 == width == length:\n        return [[0]]\n\n    # Single row\n    if 1 == length:\n        outbuf[0][0] = abs(inbuf[0][0] - inbuf[0][1])\n        outbuf[0][width - 1] = abs(inbuf[0][width - 2] - inbuf[0][width - 1])\n        for col in range(1, width - 1):\n            val = inbuf[0][col]\n            outbuf[0][col] = max(abs(val - inbuf[0][col - 1]),\n                                 abs(val - inbuf[0][col + 1]))\n        return outbuf\n\n    # Single column\n    if 1 == width:\n        outbuf[0][0] = abs(inbuf[0][0] - inbuf[1][0])\n        outbuf[length - 1][0] = abs(inbuf[length - 2][0] -\n                                    inbuf[length - 1][0])\n        for row in range(1, length - 1):\n            val - inbuf[row][0]\n            outbuf[row][0] = max(abs(val - inbuf[row - 1][0]),\n                                 abs(val - inbuf[row + 1][0]))\n        return outbuf\n\n    # At least a 2 x 2 image. Unroll what we'd rather do in loops and\n    # list comprehensions.\n\n    BOT = length - 1        # convenience; last data row\n    RT = width - 1          # convenience; last data column\n\n    # Corners\n    top_lf, top_rt = inbuf[0][0], inbuf[0][RT]\n    bot_lf, bot_rt = inbuf[BOT][0], inbuf[BOT][RT]\n    outbuf[0][0] = max(abs(top_lf - inbuf[0][1]),\n                       abs(top_lf - inbuf[1][0]),\n                       abs(top_lf - inbuf[1][1]))\n    outbuf[0][RT] = max(abs(top_rt - inbuf[0][RT - 1]),\n                        abs(top_rt - inbuf[1][RT - 1]),\n                        abs(top_rt - inbuf[1][RT]))\n    outbuf[BOT][0] = max(abs(bot_lf - inbuf[BOT - 1][0]),\n                         abs(bot_lf - inbuf[BOT - 1][1]),\n                         abs(bot_lf - inbuf[BOT][1]))\n    outbuf[BOT][RT] = max(abs(bot_rt - inbuf[BOT - 1][RT - 1]),\n                          abs(bot_rt - inbuf[BOT - 1][RT]),\n                          abs(bot_rt - inbuf[BOT][RT]))\n\n    # Top and bottom (except corners)\n    for col in range(1, RT):\n        val = inbuf[0][col]\n        outbuf[0][col] = max(abs(val - inbuf[0][col - 1]),\n                             abs(val - inbuf[0][col + 1]),\n                             abs(val - inbuf[1][col - 1]),\n                             abs(val - inbuf[1][col]),\n                             abs(val - inbuf[1][col + 1]))\n        val = inbuf[BOT][col]\n        outbuf[BOT][col] = max(abs(val - inbuf[BOT - 1][col - 1]),\n                               abs(val - inbuf[BOT - 1][col]),\n                               abs(val - inbuf[BOT - 1][col + 1]),\n                               abs(val - inbuf[BOT][col - 1]),\n                               abs(val - inbuf[BOT][col + 1]))\n\n    # Left edge (except corners)\n    for row in range(1, BOT):\n        val = inbuf[row][0]\n        outbuf[row][0] = max(abs(val - inbuf[row - 1][0]),\n                             abs(val - inbuf[row - 1][1]),\n                             abs(val - inbuf[row][1]),\n                             abs(val - inbuf[row + 1][0]),\n                             abs(val - inbuf[row + 1][1]))\n        val = inbuf[row][RT]\n        outbuf[row][RT] = max(abs(val - inbuf[row - 1][RT - 1]),\n                              abs(val - inbuf[row - 1][RT]),\n                              abs(val - inbuf[row][RT - 1]),\n                              abs(val - inbuf[row + 1][RT -1]),\n                              abs(val - inbuf[row + 1][RT]))\n\n    # Finallly! The interior\n    for row in range(1, BOT):\n        for col in range(1, RT):\n            val = inbuf[row][col]\n            outbuf[row][col] = max(abs(val - inbuf[row - 1][col - 1]),\n                                   abs(val - inbuf[row - 1][col]),\n                                   abs(val - inbuf[row - 1][col + 1]),\n                                   abs(val - inbuf[row][col - 1]),\n                                   abs(val - inbuf[row][col + 1]),\n                                   abs(val - inbuf[row + 1][col - 1]),\n                                   abs(val - inbuf[row + 1][col]),\n                                   abs(val - inbuf[row + 1][col + 1]),\n                                   )\n    # Now wasn't that fun?\n    return outbuf\n\n\ndef encode(buf, rowcounts):\n    width = len(buf[0])\n\n    # Initial list of (value, runlength) pairs. Not necessarily a\n    # run-length encoding, as successive values might be equal.\n    val_rl = list()\n\n    for row_ndx in range(len(buf)):\n        encoded_row = [(val, len(list(grp))) for\n               (val, grp) in itertools.groupby(buf[row_ndx])]\n        if row_ndx in rowcounts:\n            val_rl.append((encoded_row[0][0], width * rowcounts[row_ndx]))\n        else:\n            for (val, count) in encoded_row:\n                val_rl.append((val, count))\n\n    encoding = list()\n    # Now condense val_rl into a true run-length encoding.\n    (old_val, old_rl) = val_rl.pop(0)\n    for (val, rl) in val_rl:\n        if val == old_val:\n            old_rl += rl\n        else:\n            encoding += (old_val, old_rl)\n            (old_val, old_rl) = val, rl\n    encoding += (old_val, old_rl)\n\n    return encoding\n
from collections import Counter\n\ndef get_key_length(cipher_text, max_key_length):\n    avg_IC_by_keylen = {}\n    \n    for key_len in range(1, max_key_length+1):\n        ICs = []\n        \n        for i in range(key_len):\n            sub_str = cipher_text[i::key_len]\n            freq = Counter(sub_str)\n            IC = sum(v * (v-1) for k, v in freq.items()) / (len(sub_str) *  (len(sub_str)-1) )\n            ICs.append(IC)\n        \n        avg_IC_by_keylen[key_len] = sum(ICs) / key_len\n    \n    return max(avg_IC_by_keylen, key=avg_IC_by_keylen.get)
def balanced_parens(n): return list(dfs([],0,0,n))\n\ndef dfs(s, open, close, maxP):\n    if close==maxP:\n        yield "".join(s)\n        return\n    \n    if open > close:\n        s.append(')')\n        yield from dfs(s,open,close+1,maxP)\n        s.pop()\n    \n    if open < maxP:\n        s.append('(')\n        yield from dfs(s,open+1,close,maxP)\n        s.pop()
def prod(n):\n    ret = [{1.}]\n    for i in range(1, n+1):\n        ret.append({(i - x) * j for x, s in enumerate(ret) for j in s})\n    return ret[-1]\n\ndef part(n):\n    p = sorted(prod(n))\n    return "Range: %d Average: %.2f Median: %.2f" % \\n            (p[-1] - p[0], sum(p) / len(p), (p[len(p)//2] + p[~len(p)//2]) / 2)
def who_wins_beggar_thy_neighbour(*hands, special_cards='JQKA'):\n    hands = [list(reversed(hand)) for hand in hands]\n    player, deck_length = 0, sum(map(len, hands))\n    deal_start, deal_value, common = None, 0, []\n\n    while len(hands[player]) < deck_length:\n        # Deal ends and current player wins common pile\n        if deal_start == player:\n            hands[player] = common[::-1] + hands[player]\n            deal_start, deal_value, common = None, 0, []\n            continue\n        # Cards are drawn and deal begins if penalty occurs\n        for _ in range(min(deal_value or 1, len(hands[player]))):\n            card = hands[player].pop()\n            common.append(card)\n            if card[0] in special_cards:\n                deal_start, deal_value = player, special_cards.index(card[0]) + 1\n                break\n\n        player = (player + 1) % len(hands)\n\n    return player
import re \n\nclass Simplexer(object):\n\n    ORDERED_TOKENS = [ {"type": "integer",     "reg": r'\d+'},\n                       {"type": "boolean",     "reg": r'true|false'},\n                       {"type": "string",      "reg": r'\".*\"'},\n                       {"type": "operator",    "reg": r'[-+*/%\)\(=]'},\n                       {"type": "keyword",     "reg": r'if|else|for|while|return|func|break'},\n                       {"type": "whitespace",  "reg": r'\s+'},\n                       {"type": "identifier",  "reg": r'[$_a-zA-Z][$\w]*'}]\n    \n    PATTERN = re.compile(r'|'.join( "(?P<{}>{})".format(dct["type"], dct["reg"]) for dct in ORDERED_TOKENS ))\n    \n    def __init__(self, s): self.iterable = Simplexer.PATTERN.finditer(s)\n    \n    def __iter__(self):    return self\n                \n    def __next__(self):\n        for m in self.iterable:\n            for k,s in m.groupdict().items():\n                if s is None: continue\n                return Token(s,k)\n        raise StopIteration
from functools import total_ordering\n\n@total_ordering\nclass PokerHand(object):\n    CARDS = "AKQJT987654321"\n    RANKS = {card: idx for idx, card in enumerate(CARDS)}\n    \n    def score(self, hand):    \n        values, suits = zip(*hand.split())\n        idxs, ordered = zip(*sorted((self.RANKS[card], card) for card in values))\n        is_straight = ''.join(ordered) in self.CARDS\n        is_flush = len(set(suits)) == 1\n        return (-2 * sum(values.count(card) for card in values)\n                - 13 * is_straight - 15 * is_flush, idxs)\n    \n    def __init__(self, hand):\n        self.hand = hand\n        self.score = min(self.score(hand), self.score(hand.replace('A', '1')))\n    \n    def __repr__(self):  return self.hand\n    def __eq__(self, other): return self.score == other.score\n    def __lt__(self, other): return self.score < other.score
class CurryPartial:\n    def __init__(self, func, *args):\n        self.func = func\n        self.args = args\n    \n    def __call__(self, *args):\n        return CurryPartial(self.func, *(self.args + args))\n    \n    def __eq__(self, other):\n        try:\n            return self.func(*self.args) == other\n        except TypeError:\n            return CurryPartial(self.func, *self.args[:-1]) == other\n\ndef curry_partial(f,*initial_args):\n  "Curries and partially applies the initial arguments to the function"\n  return CurryPartial(f, *initial_args)
def dithering(width, height, x=0, y=0, c=1):\n    if width <= c and height <= c:\n        if x < width and y < height: yield x, y\n        return\n    for u, v in (0,0), (c,c), (c,0), (0,c):\n        for p, q in dithering(width, height, x+u, y+v, c+c): yield p, q
import numpy as np\n\ndef slope(p1, p2):\n    dx, dy = vectorize(p1, p2)\n    return dy/dx if dx else float("inf")\n\ndef vectorize(p1, p2):         return [b-a for a,b in zip(p1, p2)]\ndef getArea  (p1, p2, p3):     return np.cross(vectorize(p1, p2), vectorize(p1, p3)) / 2\ndef isConcave(p1, pivot, p2):  return getArea(pivot, p1, p2) >= 0\n\ndef convex_hull_area(points):\n    if len(points) < 3: return 0\n    \n    Z = min(points)                                                                      # Leftmost point in the graph (lowest if several ones at the same x)\n    q = sorted( (pt for pt in points if pt != Z),\n                key = lambda pt: (-slope(pt, Z), -np.linalg.norm(vectorize(Z, pt))))     # sorted points accordingly to the slope of the line formed by "pt" and "Z" (in reversed order)\n    \n    hull = [Z, q.pop()]                                                                  # Construct the convex hull (Graham Scan)\n    while q:\n        pt = q.pop()\n        while len(hull) > 1 and isConcave(hull[-2], hull[-1], pt):\n            hull.pop()\n        hull.append(pt)\n    \n    area = sum( getArea(Z, hull[i], hull[i+1]) for i in range(1, len(hull)-1) )          # Calculate area of the hull by adding the area of all the triangles formed by 2 consecutive points in the hull and having Z as summit\n    return round(area, 2)
from functools import reduce\n\nclass Datamining:\n\n    def __init__(self, train_set):\n        self.p = train_set[:5]\n    \n    def lagrange_interp(self, x):\n        return sum(reduce(lambda p,n: p*n, [(x-xi)/(xj-xi) for (i,(xi,yi)) in enumerate(self.p) if j!=i], yj) for (j,(xj,yj)) in enumerate(self.p))\n    \n    def predict(self, x):\n        return self.lagrange_interp(x)
from operator import xor\n\ndef choose_move(game_state):\n    """Chooses a move to play given a game state"""\n    x = reduce(xor, game_state)\n    for i, amt in enumerate(game_state):\n        if amt ^ x < amt:\n            return (i, amt - (amt ^ x))
from re import sub\n\nignoreList = ["THE", "OF", "IN", "FROM", "BY", "WITH", "AND",  "OR",  "FOR",  "TO",  "AT",  "A"]\n\ndef generate_bc(url, separator):\n    # remove leading http(s):// and trailing /\n    url = sub("https?://", "", url.strip("/"))\n    \n    # skip index files\n    url = sub("/index\..+$", "", url)\n    \n    # split url for processing\n    url = url.split("/")\n    \n    # remove file extensions, anchors and parameters\n    url[-1] = sub("[\.#\?].*", "", url[-1])\n    \n    # first element is always "home"\n    menu = ["HOME"]\n    # generate breadcrumb items\n    for item in url[1:]:\n        # replace dashes and set to uppercase\n        item = sub("-", " ", item.upper())\n        # create acronym if too long\n        if len(item) > 30:\n            item = "".join([w[0] for w in item.split() if w not in ignoreList])\n        menu.append(item)\n    \n    # generate paths\n    path = ["/"]\n    for i in range(len(url) - 1):\n        path.append(path[i] + url[i+1] + "/")\n    \n    # generate html code\n    html = []\n    for i in range(len(url) - 1):\n        html.append("<a href=\"" + path[i] + "\">" + menu[i] +"</a>")\n    html.append("<span class=\"active\">" + menu[-1] +"</span>")\n    \n    return separator.join(html)
from collections import deque\nclass Graph():\n\n    def __init__(self, vertices_num):\n        self.v = vertices_num\n\n    def adjmat_2_graph(self, adjm):\n        d = {f'A{i}': [] for i in range(self.v)}\n        for i, j in enumerate(adjm):\n            for k, l in enumerate(j):\n                if l : d[f'A{i}'].append((f'A{k}', l))\n        return d\n\n    def graph_2_mat(self, graph):\n        mat = [[0 for _ in range(self.v)] for _ in range(self.v)]\n        for i, j in graph.items():\n            for k, l in j:\n                mat[int(i[1])][int(k[1])] = l\n        return mat\n\n    def graph_2_list(self, graph):\n        return [[i, j] for i, j in sorted(graph.items())]\n\n    def list_2_graph(self, lst):\n        return {i: x for i, x in lst}\n\n    def mat_2_list(self, mat):\n        return self.graph_2_list(self.adjmat_2_graph(mat))\n\n    def list_2_mat(self, lst):\n        return self.graph_2_mat(self.list_2_graph(lst))\n\n    def find_all_paths(self, graph, start, end):\n        graph = {i: [k[0] for k in j] for i, j in graph.items()}\n        Q, paths = deque([[start, []]]), []\n        while Q:\n            node, path = Q.popleft()\n            path.append(node)\n\n            if node == end:\n                paths.append('-'.join(path))\n\n            for n in graph[node]:\n                if n not in path:\n                    Q.append([n, path[:]])\n        return sorted(paths, key=len)
from collections import deque\nfrom numpy import cross, dot\n\n\nMOVES = ((1,0), (-1,0), (0,1), (0,-1))\nDIRS  = (  'v',    '^',   '>',    '<')\n\n\ndef escape(maze):\n    \n    start = x,y = next( (x,y) for x,row in enumerate(maze) for y,c in enumerate(row) if c not in '# ' )\n    X, Y, dir   = len(maze), len(maze[0]), MOVES[ DIRS.index(maze[x][y]) ]\n    q, seens    = deque([(start, dir)]), {}\n    \n    if not x or x==X-1 or not y or y==Y-1: return []            # Already at the end, do nothing\n    \n    noPath = True\n    while q:\n        (x,y), dir = q.popleft()\n        for dx,dy in MOVES:\n            xx,yy = pos = (x+dx,y+dy)\n            \n            if 0 <= xx < X and 0 <= yy < Y and maze[xx][yy]==' ' and pos not in seens:\n                q.append( (pos, (dx,dy)) )\n                seens[pos] = ((x,y), dir, (dx,dy))              # data: (origin position, direction before origin, direction after origin)\n                if not xx or xx==X-1 or not yy or yy==Y-1:      # Escaped!\n                    q, noPath = [], False                       # reset the queue to stop it, "from the for loop"\n                    break\n                    \n    if noPath: return []                                        # No path, no chocolate...\n    \n    path = []\n    while pos != start:\n        pos, dir, nextDir = seens[pos]\n        scal = dot(dir, nextDir)                                # scalar prouct > 0  <=>  go ahead, otherwise, turn back\n        prod = cross(dir, nextDir)                              # cross product > 0  <=>  turn left, otherwise, turn right\n        if scal: path.append('FB' if scal < 0 else 'F')         # dot != 0 => both directions are colinear\n        else:    path.append('FL' if prod > 0 else 'FR')        # orthogonal directions, take a turn\n    \n    return list(''.join(path)[::-1])
def three_by_n(n):\n    A = [1, 2] + [0]*(n-1)\n    B = [0, 1] + [0]*(n-1)\n    C = [1, 0] + [0]*(n-1)\n    D = [0, 1] + [0]*(n-1)\n    for i in range(2, n+1):\n        A[i] = A[i-2] + 2*B[i-1] + 2*C[i-1] + 2*D[i] + 2*D[i-2]\n        B[i] = A[i-1] + B[i-2] + C[i-2] + D[i-1]\n        C[i] = C[i-2] + 2*D[i-1]\n        D[i] = C[i-1] + D[i-2]\n    return A[n] % 12345787
from math import factorial as fac\ncards = [\n    "AC", "2C", "3C", "4C", "5C", "6C", "7C", "8C", "9C", "TC", "JC", "QC", "KC",\n    "AD", "2D", "3D", "4D", "5D", "6D", "7D", "8D", "9D", "TD", "JD", "QD", "KD",\n    "AH", "2H", "3H", "4H", "5H", "6H", "7H", "8H", "9H", "TH", "JH", "QH", "KH",\n    "AS", "2S", "3S", "4S", "5S", "6S", "7S", "8S", "9S", "TS", "JS", "QS", "KS"\n]\nchars = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nchars_len = len(chars)\nfacs = [1]\nfor x in range(1, 53, 1): facs.append(facs[-1] * x)\n\nclass PlayingCards:\n    # Takes a String containing a message, and returns an array of Strings representing\n    # a deck of playing cards ordered to hide the message, or None if the message is invalid.\n    def encode(self, message):\n        mlen = len(message)\n        rem = 0\n        for i in range(mlen):\n            if message[i] not in chars: return None\n            rem = rem + chars_len ** (mlen - i - 1) * chars.index(message[i])\n        if rem >= facs[-1]: return None\n        for i in range(1, 53):\n            if rem < facs[i]: break\n        remaining_cards = cards[53 - i - 1:]\n        output_cards = cards[:53 - i - 1]\n        for j in range(i - 1, -1, -1):\n            idx = rem // facs[j]\n            output_cards.append(remaining_cards.pop(idx))\n            rem = rem % facs[j]\n        return output_cards\n\n    # Takes an array of Strings representing a deck of playing cards, and returns\n    # the message that is hidden inside, or None if the deck is invalid.\n    def decode(self, deck):\n        if len(deck) != 52: return None\n        remaining_cards = cards.copy()\n        rem = 0\n        for i in range(len(deck)):\n            if deck[i] not in remaining_cards: return None\n            idx = remaining_cards.index(deck[i])\n            rem = rem + facs[51 - i] * idx\n            remaining_cards.pop(idx)\n        output_message = []\n        if rem == 0 : return ''\n        while rem > 0:\n            output_message.insert(0, chars[rem % chars_len])\n            rem = rem // chars_len\n        return ''.join(output_message)
def is_prime(n):\n    return n == 2 or n % 2 != 0 and all(n % k != 0 for k in range(3, root(n) + 1, 2))\n\ndef root(p):\n    return int(p ** 0.5)\n\ndef statement1(s):\n    return not(s % 2 == 0 or is_prime(s - 2))\n\ndef statement2(p):\n    return sum(statement1(i + p / i) for i in range(2, root(p) + 1) if p % i == 0) == 1\n\ndef statement3(s):\n    return sum(statement2(i * (s - i)) for i in range(2, s / 2 + 1)) == 1\n\ndef is_solution(a, b):\n    return statement1(a + b) and statement2(a * b) and statement3(a + b)\n
def nQueen(n):\n    if n==2 or n==3: return []\n    r, odds, evens = n%6, list(range(1,n,2)), list(range(0,n,2))\n    if r==2:\n        evens[:2] = evens[:2][::-1]\n        evens.append(evens.pop(2))\n    if r==3:\n        odds.append(odds.pop(0))\n        evens.extend(evens[:2])\n        del evens[:2]\n    return odds+evens
def to_postfix (infix):\n    prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3, '(': 0}\n    postfix = []\n    stack = []\n    for ch in infix:\n        if ch in '0123456789':\n            postfix.append(ch)\n        elif ch in '(':\n            stack.append(ch)\n        elif ch in ')':\n            while stack and stack[-1] != '(':\n                postfix.append(stack.pop())\n            stack.pop()\n        else:\n            while stack and prec[stack[-1]] >= prec[ch]:\n                postfix.append(stack.pop())\n            stack.append(ch)\n            \n    while stack:\n        postfix.append(stack.pop())\n    return ''.join(postfix)
def hamming(n):\n    bases = [2, 3, 5]\n    expos = [0, 0, 0]\n    hamms = [1]\n    for _ in range(1, n):\n        next_hamms = [bases[i] * hamms[expos[i]] for i in range(3)]\n        next_hamm = min(next_hamms)\n        hamms.append(next_hamm)\n        for i in range(3):\n            expos[i] += int(next_hamms[i] == next_hamm)\n    return hamms[-1]
def get(cells, i, j):\n  return cells[i][j] if i > -1 and j > -1 and i < len(cells) and j < len(cells[0]) else 0\n\ndef num_neighbors(cells, i, j):\n  return (get(cells, i, j+1) + get(cells, i, j-1) + get(cells, i+1, j) +\n          get(cells, i-1, j) + get(cells, i-1, j-1) + get(cells, i-1, j+1) +\n          get(cells, i+1, j-1) + get(cells, i+1, j+1))\n\ndef next_cell(cell, i, j):\n  n = num_neighbors(cell, i, j)\n  return int(0 if n < 2 or n > 3 else 1 if cell[i][j] else n == 3)\n\ndef expand(cells):\n  row = [0]*(len(cells[0])+2)\n  return [row] + [[0] + r + [0] for r in cells] + [row]\n\ndef trim(cells):\n  while not any(cells[0]): del cells[0]\n  while not any(cells[-1]): del cells[-1]\n  while not any([row[0] for row in cells]): list(map(lambda x: x.pop(0), cells))\n  while not any([row[-1] for row in cells]): list(map(lambda x: x.pop(), cells))\n\ndef next_gen(cells):\n  cells = expand(cells)\n  cells = [[next_cell(cells, i, j) for j in range(len(cells[i]))] for i in range(len(cells))]\n  trim(cells)\n  return cells\n\ndef get_generation(cells, generations):\n  for i in range(generations):\n    cells = next_gen(cells)\n  if not cells:\n    return [[]]\n  return cells\n
def queens(fixQ, S):\n    \n    def areClashing(i,x):\n        j,y = qs[i],qs[x]\n        return j==y or abs(i-x)==abs(j-y)\n    \n    def dfs(i=0):\n        if i==iQ:      return dfs(i+1)\n        if i==len(qs): return 1\n        \n        for y in range(S):\n            qs[i]=y\n            if ( not any(areClashing(i,ii) for ii in range(i)) \n                 and (iQ<i or not areClashing(i,iQ))\n                 and dfs(i+1) ): return 1\n        \n        \n    iQ,yQ = ord(fixQ[0])-97, (int(fixQ[1]) or 10)-1\n    qs    = [yQ if i==iQ else 0 for i in range(S)]\n    dfs()\n    return ','.join( f"{ chr(x+97) }{ str(y+1)[-1] }" for x,y in enumerate(qs))
def find_prime_kPerm(n, k):\n    sieve = n // 2 * [True]\n    for i in range(3, int(n ** .5) + 1, 2):\n        if sieve[i // 2]:\n            sieve[i*i // 2 :: i] = ((n - i*i - 1) // (2*i) + 1) * [False]\n    cycles = {}\n    for i in range(1, n // 2):\n        if sieve[i]:\n            cycles.setdefault(tuple(sorted(str(2*i + 1))), set()).add(2*i + 1)\n    k_perms = [min(cycle) for cycle in cycles.values() if len(cycle) == k + 1]\n    return [len(k_perms), min(k_perms, default=0), max(k_perms, default=0)]
def interpreter(code, iterations, width, height):\n    code = "".join(c for c in code if c in "[news]*")\n    canvas = [ [0] * width for _ in range(height) ]\n    row = col = step = count = loop = 0\n    \n    while step < len(code) and count < iterations:\n        command = code[step]\n        \n        if loop:\n            if   command == "[": loop += 1\n            elif command == "]": loop -= 1\n        \n        elif command == "n": row = (row - 1) % height\n        elif command == "s": row = (row + 1) % height\n        elif command == "w": col = (col - 1) % width\n        elif command == "e": col = (col + 1) % width\n        elif command == "*": canvas[row][col] ^= 1\n        elif command == "[" and canvas[row][col] == 0: loop += 1\n        elif command == "]" and canvas[row][col] != 0: loop -= 1\n        \n        step += 1 if not loop else loop // abs(loop)\n        count += 1 if not loop else 0\n    \n    return "\r\n".join("".join(map(str, row)) for row in canvas)
from fractions import gcd\n\ndef min_price(nums):\n    nums.sort()\n    ns = [0] + [float('inf')] * (nums[0] - 1)\n    for c in nums[1:]:\n        d = gcd(nums[0], c)\n        for r in range(d):\n            n = min(ns[r::d], default=float('inf'))\n            if n < float('inf'):\n                for j in range(nums[0] // d):\n                    n += c\n                    p = n % nums[0]\n                    ns[p] = n = min(n, ns[p])\n    max_ = max(ns) or 1\n    return max_ - nums[0] + 1 if max_ < float('inf') else -1
from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    singles, pairs = [], []\n    \n    # group digits to pairs and singles\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    \n    # avoid trailing zeros\n    if pairs and pairs[0] == '0':\n        pairs = []\n    \n    # return largest possible palindrom\n    if not singles:\n        singles = ['']\n    return int( ''.join(pairs) + singles[0] + ''.join(pairs[::-1]) )\n\n\ndef numeric_palindrome(*args):\n    args = Counter(args)\n    candidates = set()\n    \n    # remove extra 0s and 1s\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    \n    args = list(args.elements())\n    \n    # check all possible products\n    for n in range(2, len(args)+1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add( largest_palindrom_from(product) )\n    \n    return max(candidates)
def recoverSecret(triplets):\n  r = list(set([i for l in triplets for i in l]))\n  for l in triplets:\n    fix(r, l[1], l[2])\n    fix(r, l[0], l[1])\n  return ''.join(r)\n  \ndef fix(l, a, b):\n   """let l.index(a) < l.index(b)"""\n   if l.index(a) > l.index(b):\n       l.remove(a)\n       l.insert(l.index(b), a)
class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        vis = [0 for i in range(len(friends))]\n        index = id\n        lis = set([id])\n        while level>0:\n            temp = []\n            for i in lis:\n                if vis[i] == 0:\n                    #print(i)\n                    temp += friends[i]\n                    vis[i] = 1\n            lis = set(temp)\n            level -= 1\n        dic = dict()\n        for i in lis:\n            if vis[i] == 0:\n                for j in watchedVideos[i]:\n                    if j in dic:\n                        dic[j]+=1\n                    else:\n                        dic[j] = 1\n        dic2 = dict()\n        for i in dic:\n            if dic[i] in dic2:\n                dic2[dic[i]].append(i)\n            else:\n                dic2[dic[i]] = [i]\n        lis = []\n        for i in sorted(dic2.keys()):\n            lis += sorted(dic2[i])\n        return lis\n
\n import re\n \n \n class Solution:\n     def calc(self, a, b, op):\n         if op == '+':\n             for k, v in b.items():\n                 a[k] = a.get(k, 0) + v\n             return a\n         elif op == '-':\n             for k, v in b.items():\n                 a[k] = a.get(k, 0) - v\n             return a\n         elif op == '*':\n             t = {}\n             for k1, v1 in a.items():\n                 for k2, v2 in b.items():\n                     t[tuple(sorted(k1+k2))] = t.get(tuple(sorted(k1+k2)), 0) + v1 * v2\n             return t\n \n     def basicCalculatorIV(self, expression, evalvars, evalints):\n         vars = {n:v for n,v in zip(evalvars, evalints)}\n         d = []  # operands\n         op = []\n         priority = {'(': 0, '+': 1, '-': 1, '*': 2}\n         for t in re.findall(r'\(|\)|[a-z]+|[0-9]+|[\+\-\*]', expression):\n             if t[0].isdigit():\n                 d.append({tuple():int(t)})\n             elif t[0].isalpha():\n                 if t in vars:\n                     d.append({tuple():vars[t]})\n                 else:\n                     d.append({(t,): 1})\n             elif t == '(':\n                 op.append(t)\n             elif t == ')':\n                 while op and op[-1] != '(':\n                     d.append(self.calc(d.pop(-2), d.pop(-1), op.pop()))\n                 op.pop()\n             elif t in '+-*':\n                 if not op or priority[t] > priority[op[-1]]:\n                     op.append(t)\n                 else:\n                     while op and priority[t] <= priority[op[-1]]:\n                         d.append(self.calc(d.pop(-2), d.pop(-1), op.pop()))\n                     op.append(t)\n         while op:\n             d.append(self.calc(d.pop(-2), d.pop(-1), op.pop()))\n \n         res = []\n         for k in sorted(d[0].keys(), key=lambda x: (-len(x), x)):\n             v = d[0][k]\n             if v != 0:\n                 if not k:\n                     res.append(str(v))\n                 else:\n                     res.append('%s*%s' % (v, '*'.join(k)))\n         return res\n
class Solution:\n    arr = []\n    \n    def simplifiedFractions(self, n: int) -> List[str]:\n        ans = []\n        \n        if len(Solution.arr) < 2:\n            Solution.arr = [[],[]]\n            \n        if n >= len(Solution.arr):\n            for d in range(len(Solution.arr), n + 1):\n                denominator = \"/\" + str(d)\n                Solution.arr.append([])\n                \n                for num in range(1, d):\n                    if gcd(num, d) == 1:\n                        Solution.arr[-1].append(str(num) + denominator)\n                    \n                    \n        for i in range(2, n + 1):\n            ans += Solution.arr[i]\n                \n        return ans\n                    \n                \n        
# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def eraseOverlapIntervals(self, intervals):\n         """\n         :type intervals: List[Interval]\n         :rtype: int\n         """\n         intervals = sorted(intervals, key = lambda x: x.end)\n         current_end = float('-inf')\n         cnt = 0\n         for interval in intervals:\n             if interval.start >= current_end:\n                 cnt += 1\n                 current_end = interval.end\n         return len(intervals) - cnt\n         
class Solution:\n     def productExceptSelf(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: List[int]\n         """\n         nums0 = nums.copy()\n         son = 1\n         if 0 in nums0:\n             nums0.remove(0)\n             for i in nums0:\n                 son *= i\n             \n             \n         pro = 1\n         for i in nums:\n             pro *= i\n         result = []\n         for i in nums:\n             if i == 0:\n                 result.append(son)\n             else:\n                 result.append(pro//i)\n         return result
class Solution:\n    def getFolderNames(self, names: List[str]) -> List[str]:\n        used, hashmap = set(), defaultdict(int)\n        result = []\n        for name in names:\n            k = hashmap[name]\n            current = name\n            while current in used:\n                k += 1\n                current = '%s(%d)' % (name, k)  # alternative to current = name+'('+str(k)+')'\n            hashmap[name] = k\n            result.append(current)\n            used.add(current)\n        return result\n
class StockSpanner:\n\n    def __init__(self):\n        self.s=[]\n        \n\n    def next(self, price: int) -> int:\n        stk=self.s\n        curr_span=1\n        \n        while stk and stk[-1][0]<=price: #curr_price is > stack[-1][0]\n            prev_price,prev_span=stk.pop()\n            curr_span+=prev_span\n        stk.append((price,curr_span))\n        return curr_span\n            \n            \n        \n            \n        \n        \n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n
from collections import defaultdict\nfrom bisect import bisect_left, bisect_right\n\nclass MajorityChecker:\n\n    def __init__(self, arr: List[int]):\n        self.num_idx_dict = defaultdict(list)\n        for idx, number in enumerate(arr):\n            self.num_idx_dict[number].append(idx)\n        self.candidates = sorted(self.num_idx_dict, key=lambda x: len(self.num_idx_dict[x]), reverse=True)\n        \n    def query(self, left: int, right: int, threshold: int) -> int:\n        for number in self.candidates:\n            if len(self.num_idx_dict[number]) < threshold:\n                return -1\n            left_idx = bisect_left(self.num_idx_dict[number], left)\n            right_idx = bisect_right(self.num_idx_dict[number], right)\n            \n            if right_idx - left_idx >= threshold:\n                return number\n        return -1\n
class Solution:\n    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\n        n = len(books)\n        dp = [inf] * (n+1)\n        dp[0] = 0\n        ret = inf\n        for i in range(1, n+1):\n            mx = 0\n            cur = 0\n            for j in range(i, 0, -1):\n                cur += books[j-1][0]\n                if cur > shelf_width:\n                    break\n                mx = max(mx, books[j-1][1])\n                dp[i] = min(dp[i], dp[j-1] + mx)\n        return dp[-1]\n
class Solution:\n     def exclusiveTime(self, n, logs):\n         """\n         :type n: int\n         :type logs: List[str]\n         :rtype: List[int]\n         """\n         fn_stk = []\n         excl_time = [0] * n\n         prev = 0\n         if n < 1 or not logs:\n             return fn_stk\n         fn, action, ts = logs[0].split(':')\n         fn_stk.append(int(fn))\n         for log in logs[1:]:\n             fn, action, ts = log.split(':')\n             fn, ts = int(fn), int(ts)\n             if action == 'start':\n                 if fn_stk: excl_time[fn_stk[len(fn_stk)-1]] += ts - prev\n                 prev = ts\n                 fn_stk.append(fn)\n             else:\n                 fid = fn_stk.pop()\n                 excl_time[fid] += (ts - prev + 1)\n                 prev = ts + 1\n         return excl_time\n                     \n                 \n                 \n             \n
class Solution:\n    def shiftingLetters(self, S: str, shifts: List[int]) -> str:\n        # cumulative sum from back\n        shifts[-1] = shifts[-1] % 26\n        \n        if len(shifts) >= 2:\n            for i in range(len(shifts) - 2, -1, -1):\n                shifts[i] += shifts[i + 1]\n                shifts[i] = shifts[i] % 26\n                \n        # shift characters\n        shifted_chars = []\n        \n        for i in range(len(S)):\n            shifted_ascii = (ord(S[i]) - 97 + shifts[i]) % 26 + 97\n            shifted_chars.append(chr(shifted_ascii))\n            \n        return \"\".join(shifted_chars)
class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def should_alert(t):\n            if len(t) < 3:\n                return False\n            \n            for i in range(len(t) - 2):\n                if t[i + 2] <= t[i] + 100:\n                    return True\n            return False\n        \n        time = collections.defaultdict(list)\n        alert = []\n        for name, t in zip(keyName, keyTime):            \n            ti = int(t[:2] + t[3:])\n            time[name].append(ti)\n        \n        ret = []\n        for name in time:\n            time[name].sort()\n            if should_alert(time[name]):\n                ret.append(name)\n    \n        ret.sort()\n        return ret
from collections import Counter\n \n \n class Solution:\n     def reorganizeString(self, S):\n         """\n         :type S: str\n         :rtype: str\n         """\n         if len(S) <= 1:\n             return S\n \n         chars = [char for char, count in Counter(S).most_common() for _ in range(count)]\n         h = math.ceil(len(chars) / 2)\n         chars[::2], chars[1::2] = chars[:h], chars[h:]\n         if chars[0] == chars[1]:\n             return ''\n         else:\n             return ''.join(chars)\n         \n         
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        nonlocal ls\n        ls=[]\n        di={0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e', 5: 'f', 6: 'g', 7: 'h', 8: 'i', 9: 'j', 10: 'k', 11: 'l', 12: 'm', 13: 'n', 14: 'o', 15: 'p', 16: 'q', 17: 'r', 18: 's', 19: 't', 20: 'u', 21: 'v', 22: 'w', 23: 'x', 24: 'y', 25: 'z'}\n        def helper(root,s):\n            if(root==None):\n                return None\n            nonlocal ls\n            if(root.left==None and root.right==None):\n                ls.append(di[root.val]+s)\n            \n            helper(root.left,di[root.val]+s)\n            helper(root.right,di[root.val]+s)\n            \n        helper(root,\"\")\n        print(ls)\n        # tem=sorted(ls)[0]\n        tem=sorted(ls)\n        return tem[0]\n        # ans=\"\"\n        # for i in tem:\n        #     ans+=str(di[int(i)])\n        # return ans\n            
class Solution:\n \n     def __init__(self, nums):\n         """\n         :type nums: List[int]\n         """\n         self.nums = nums\n         self.length = len(self.nums)\n         \n \n     def pick(self, target):\n         """\n         :type target: int\n         :rtype: int\n         """\n         first_idx = None\n         idx_count = 0\n         for i in range(self.length):\n             if self.nums[i] == target:\n                 if first_idx is None:\n                     first_idx = i\n                 idx_count += 1\n             elif first_idx is not None:\n                 break\n \n         if idx_count > 0:  \n             return int(idx_count * random.random() // 1) + first_idx\n \n \n # Your Solution object will be instantiated and called as such:\n # obj = Solution(nums)\n # param_1 = obj.pick(target)\n
# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def largestValues(self, root):\n         """\n         :type root: TreeNode\n         :rtype: List[int]\n         """\n         if not root:\n             return [] \n         q = [root]\n         r = []\n         while q:\n             r.append(max([i.val for i in q]))\n             q = [i for node in q for i in [node.left, node.right] if i]\n         return r
class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        return nums
class Solution:\n     def topKFrequent(self, words, k):\n         """\n         :type words: List[str]\n         :type k: int\n         :rtype: List[str]\n         """\n         from collections import Counter\n         count = Counter(words)\n         common = sorted(list(count.items()), key=lambda item: (-item[1], item[0]))[:k]\n         return [w for w, n in common]\n
# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def reorderList(self, head):\n         """\n         :type head: ListNode\n         :rtype: void Do not return anything, modify head in-place instead.\n         """\n         if not head:\n             return \n         fast, slow = head.next, head\n         while fast and fast.next:\n             fast = fast.next.next\n             slow = slow.next\n             \n         \n         p = slow.next\n         slow.next = None\n         node = None\n         while p:\n             nxt = p.next\n             p.next = node\n             node = p\n             p = nxt\n         \n         p = head\n         while node:\n             tmp = node.next\n             node.next = p.next\n             p.next = node\n             p = p.next.next\n             node = tmp\n             \n             
def bs(arr, val, key=lambda x:x):\n     l, r = 0, len(arr)-1\n     if key(arr[l])>val:\n         return l\n     if key(arr[r])<=val:\n         return r+1\n     while l+1<r:\n         m = (l+r)>>1\n         v = key(arr[m])\n         if v<=val:\n             l = m\n         else:\n             r = m\n     return r\n \n def bs_left(arr, val, key=lambda x:x):\n     l, r = 0, len(arr)-1\n     if key(arr[l])>=val:\n         return l\n     if key(arr[r])<val:\n         return r+1\n     while l+1<r:\n         m = (l+r)>>1\n         v = key(arr[m])\n         if v<val:\n             l = m\n         else:\n             r = m\n     return r\n             \n \n class Solution:\n     def findNumberOfLIS(self, nums):\n         if not nums: return 0\n         N = len(nums)\n         l, dp = 0, [[] for _ in range(N)]\n         for n in nums:\n             idx1 = bs_left(dp, n, lambda _:_[-1][0] if _ else sys.maxsize)\n             if idx1==l:\n                 l += 1\n             if idx1==0:\n                 dp[0].append([n, (dp[0][-1][1] if dp[0] else 0)+1])\n             else:\n                 idx2 = bs(dp[idx1-1], -n, lambda _:-_[0])\n                 dp[idx1].append([n, (dp[idx1][-1][1] if dp[idx1] else 0)+(dp[idx1-1][-1][1] if idx2==0 else (dp[idx1-1][-1][1]-dp[idx1-1][idx2-1][1]))])\n         return dp[l-1][-1][1]
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        \n        def lca(root=root):\n            if root:\n                n1, d1 = lca(root.left)\n                n2, d2 = lca(root.right)\n                if d1 == d2:\n                    return (root, d1 + 1)\n                else:\n                    return (n1, 1 + d1) if d1 > d2 else (n2, 1 + d2)\n            return (None, -1)\n        \n        return lca()[0]\n                        \n                        \n                \n                \n
class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \"\"\"\n        Brute force solution is to perform the sum for each position\n        (r, c). This would require K * K operations for each of m * n positions.\n        \n        Instead, assuming we compute sums left to right and top down, we can\n        use our previous solution to calculate the next one, subtracting the\n        sums that fell out of the window and adding the sums that are in.\n        \n        Pseudo code would be something like this:\n        \n        prevBlockSum = ...\n        for r in range(m):\n            for c in range(n):\n                if c - K > 0:\n                    prevBlockSum -= sum()\n        \"\"\"\n        m = len(mat)\n        n = len(mat[0])\n        \n        cum = []\n        prevSums = [0] * n\n        for r in range(m):\n            rowSum = 0\n            cumSums = []\n            for c in range(n):\n                rowSum += mat[r][c]\n                cumSums.append(prevSums[c] + rowSum)\n            cum.append(cumSums)\n            prevSums = cumSums\n        \n        out = []\n        for i in range(m):\n            blockSums = []\n            for j in range(n):\n                r = i + K if i + K < m else m - 1\n                c = j + K if j + K < n else n - 1\n                \n                blockSum = cum[r][c]\n                if i - K > 0:\n                    blockSum -= cum[i-K-1][c]\n                if j - K > 0:\n                    blockSum -= cum[r][j-K-1]\n                if i - K > 0 and j - K > 0:\n                    blockSum += cum[i-K-1][j-K-1]\n                blockSums.append(blockSum)\n            out.append(blockSums)\n        \n        return out
import math\n class Solution:\n     def smallestGoodBase(self, n):\n         n = int(n)\n         maxLength = int(math.log(n,2))\n         for m in range(maxLength, 1, -1):\n             k = int(n**m**-1)\n             if (k**(m+1) - 1)//(k - 1) == n:\n                 return str(k)\n         return str(n-1)\n         """\n         :type n: str\n         :rtype: str\n         """\n         
class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        if len(barcodes) < 2:\n            return barcodes\n        \n        sorted_codes = sorted(barcodes)\n        halfway = len(barcodes)//2\n        ans =  [0] * (halfway * 2)\n        ans[::2], ans[1::2] = sorted_codes[-halfway:], sorted_codes[:halfway]\n            \n        if len(barcodes) % 2 == 1:\n            prev = None\n            mid = sorted_codes[halfway]\n            for i in range(len(ans) - 1):\n                if ans[i] == mid:\n                    i += 1\n                elif ans[i] != prev:\n                    ans.insert(i, mid)\n                    break\n                prev = ans[i]\n        return ans\n
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        self.cnt=0\n        def helper(root,maxm):\n            if not root:\n                return\n            if root.val>=maxm:\n                self.cnt+=1\n                maxm=root.val\n            if root.left:\n                helper(root.left,maxm)\n            if root.right:\n                helper(root.right,maxm)\n        maxm=root.val\n        helper(root,maxm)\n        return self.cnt
class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        fullLake = {}\n        dry = {}\n\n        for day, lake in enumerate(rains):\n            if lake not in fullLake:\n                if lake:\n                    fullLake[lake]=day\n            else:\n                if lake:\n                    dry[fullLake[lake]] = day\n                    fullLake[lake]=day\n        heap=[]\n        for day, lake in enumerate(rains):\n            if heap and day >= heap[0][0]:\n                return []\n            if lake:\n                if day in dry:\n                    heapq.heappush(heap, (dry[day], lake))\n                rains[day] = -1\n            else:\n                if heap:\n                    rains[day] = heapq.heappop(heap)[1]\n                else:\n                    rains[day] = 1\n        return rains
class Solution:\n     def movesToChessboard(self, board):\n         """\n         :type board: List[List[int]]\n         :rtype: int\n         """\n         rows = [1]\n \n         for i in range(1, len(board)):\n             num = self.get_num(board[0], board[i])\n             if 0 <= num <= 1:\n                 rows.append(num)\n             else:\n                 return -1\n \n         r1 = self.swap_count(rows)\n         if r1 != -1:\n             r2 = self.swap_count(board[0])\n \n         if r1 == -1 or r2 == -1:\n             return -1\n         else:\n             return r1 + r2\n \n     def get_num(self, r1, r2):\n         eq = True\n         op = True\n \n         for i in range(len(r1)):\n             if r1[i] == r2[i]:\n                 op = False\n             else:\n                 eq = False\n \n         if eq:\n             return 1\n         elif op:\n             return 0\n         else:\n             return -1\n \n     def swap_count(self, bits):\n         n = len(bits)\n \n         ones = sum(bits)\n         zeros = n - ones\n \n         ones_in_even = 0\n         zeros_in_even = 0\n         for i in range(0, n, 2):\n             ones_in_even += bits[i]\n             zeros_in_even += (1 - bits[i])\n \n         if abs(ones - zeros) > 1:\n             return -1\n \n         # get rid of smaller ones\n         if n % 2 == 0:\n             return min(zeros_in_even, ones_in_even)\n         elif ones > zeros:\n             return zeros_in_even\n         else:\n             return ones_in_even
class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        conns = defaultdict(dict)\n        for i, j, n in edges:\n            conns[i][j] = n\n            conns[j][i] = n\n\n        heap = [(0, 0)]\n        visited = set()\n        ans = 0\n\n        while heap:\n            d, n = heapq.heappop(heap)\n            if n not in visited:\n                visited.add(n)\n                ans += 1\n                for m, inter in conns[n].items():\n                    if m in visited:\n                        ans += min(M-d, conns[n][m])\n                    else:\n                        if d+inter < M:\n                            heapq.heappush(heap, (d+inter+1, m))\n                            ans += inter\n                            conns[m][n] = 0\n                        else:\n                            ans += M-d\n                            conns[m][n] -= M-d\n\n        return ans
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\n        # solution with DFS\n        def dfs(node, depth):\n            if not node:\n                return node, depth\n            left, l_depth = dfs(node.left, depth + 1)\n            right,r_depth = dfs(node.right,depth + 1)\n            if l_depth > r_depth:\n                return left, l_depth\n            if r_depth > l_depth:\n                return right,r_depth\n            return node,l_depth\n        return dfs(root,0)[0]
class Solution:\n    def matrixScore(self, A: List[List[int]]) -> int:\n        \n        def bitFlip(row):\n            \n            for i,r in enumerate(row):\n                row[i] = 1-r\n                \n            return row\n        \n        # [print(a) for a in A]\n        #For any rows with a leading 0 flip them\n        for i,row in enumerate(A):\n            if row[0] == 0:\n                A[i] = bitFlip(row)\n        # print('After Flip')\n        # [print(a) for a in A]\n        \n        #For each col past the 0th flip it if has more zeros than 1s\n        for j in range(1,len(A[0])):\n            count = 0\n            for i in range(0,len(A)):\n                count += A[i][j]\n            if count <= len(A)//2:\n                for i in range(0,len(A)):\n                    A[i][j] = 1-A[i][j]\n                    \n        def score(row): #Returns the max score for this row\n\n#             mul = 1\n#             res = 0\n#             for r in reversed(row):\n#                 res += r*mul\n#                 mul *= 2\n            \n#             return res\n        \n            return sum([ r*2**i for i,r in enumerate(reversed(row))])\n          \n        return sum([ score(row) for row in A])\n            \n
class Solution:\n    def numsSameConsecDiff(self, n: int, k: int) -> List[int]:\n        # DFS (Depth-First Search)\n        # Time  complexity: O(N x 2^N) = O(N x 9 x 2^(N-1))\n        # Space compleixty: O(2^N) = O(9 x 2^(N-1)) + O(N)\n        # if n == 1:\n        #     return [i for i in range(10)]\n\n        # ans = []\n        # def dfs(n, num):\n        #     # base case\n        #     if n == 0:\n        #         return ans.append(num)\n\n        #     tail_digit = num % 10\n        #     # using set() to avoid duplicates when K == 0\n        #     next_digits = set([tail_digit + k, tail_digit - k])\n\n        #     for next_digit in next_digits:\n        #         if 0 <= next_digit < 10:\n        #             new_num = num * 10 + next_digit\n        #             dfs(n - 1, new_num)\n\n        # for num in range(1, 10):\n        #     dfs(n - 1, num)\n\n        # return list(ans)\n\n\n        # BFS (Breadth-First Search)\n        # Time  complexity: O(N x 2^N)\n        # Space complexity: O(2^N)\n        if n == 1:\n            return [i for i in range(10)]\n\n        # initialize the queue with candidates for the first level\n        queue = [digit for digit in range(1, 10)]\n\n        for level in range(n - 1):\n            next_queue = []\n            for num in queue:\n                tail_digit = num % 10\n                # using set() to avoid duplicates when K == 0\n                next_digits = set([tail_digit + k, tail_digit - k])\n\n                for next_digit in next_digits:\n                    if 0 <= next_digit < 10:\n                        new_num = num * 10 + next_digit\n                        next_queue.append(new_num)\n\n            # start the next level\n            queue = next_queue\n\n        return queue\n
import random\n         \n class RandomizedSet:\n \n     def __init__(self):\n         """\n         Initialize your data structure here.\n         """\n         self.dict = {}\n         self.list = []\n         \n \n     def insert(self, val):\n         """\n         Inserts a value to the set. Returns true if the set did not already contain the specified element.\n         :type val: int\n         :rtype: bool\n         """\n         if val in self.dict:\n             return False\n         self.dict[val] = len(self.list)\n         self.list.append(val)\n         return True\n         \n \n     def remove(self, val):\n         """\n         Removes a value from the set. Returns true if the set contained the specified element.\n         :type val: int\n         :rtype: bool\n         """\n         if val not in self.dict:\n             return False\n         self.list[self.dict[val]] = self.list[-1]\n         self.dict[self.list[-1]] = self.dict[val]\n         self.list.pop()\n         self.dict.pop(val)\n         return True\n \n     def getRandom(self):\n         """\n         Get a random element from the set.\n         :rtype: int\n         """\n         return random.choice(self.list)\n \n \n # Your RandomizedSet object will be instantiated and called as such:\n # obj = RandomizedSet()\n # param_1 = obj.insert(val)\n # param_2 = obj.remove(val)\n # param_3 = obj.getRandom()
class Solution:\n    def displayTable(self, orders: List[List[str]]) -> List[List[str]]:\n        answer = []\n        \n        if orders is None or len(orders) == 0 or len(orders[0]) == 0:\n            return answer\n        \n        items = set()\n        \n        for order in orders:\n            items.add(order[2])\n            \n        items = sorted(list(items))\n        answer.append([\"Table\"])\n        \n        for item in items:\n            answer[0].append(item)\n            \n        hashMap = collections.defaultdict(list)\n        itemIndex = self.convertItemToIndex(answer[0])\n        m = len(answer[0])\n        \n        for order in orders:\n            hashMap[int(order[1])].append(order[2])\n            \n        hashMap = {key : hashMap[key] for key in sorted(hashMap.keys())}\n        currentIndex = 1\n        \n        for key in hashMap.keys():\n            answer.append([\"0\"] * m)\n            answer[currentIndex][0] = str(key)\n            countMap = defaultdict(lambda: 0)\n            \n            for currentItem in hashMap[key]:\n                countMap[currentItem] += 1\n            \n            for currentItem in countMap.keys():\n                answer[currentIndex][itemIndex[currentItem]] = str(countMap[currentItem])\n            \n            currentIndex += 1\n            \n        return answer\n    \n    def convertItemToIndex(self, tempAns):\n        itemToIndex = {}\n        \n        for i, curr in enumerate(tempAns):\n            itemToIndex[curr] = i\n            \n        return itemToIndex\n            \n                    
class Solution:\n     def maxChunksToSorted(self, arr):\n         """\n         :type arr: List[int]\n         :rtype: int\n         """\n         cnt, sm, ism = 0, 0, 0\n         for i, num in enumerate(arr):\n             sm += num\n             ism += i\n             if sm == ism:\n                 cnt += 1\n         return cnt
class Solution:\n     def swimInWater(self, grid):\n         """\n         :type grid: List[List[int]]\n         :rtype: int\n         """\n         N = len(grid)\n         if N == 1:\n             return 0\n         \n         eleD = {}\n         for i in range(N):\n             for j in range(N):\n                 eleD[grid[i][j]] = (i,j)\n \n \n         C = [[0 for _ in range(N)] for _ in range(N)]\n         stack = set()\n         nextstack = set()\n         nextstack.add((0,0))\n         for t in range(grid[0][0],N*N):\n             if eleD[t] not in nextstack:\n                 continue\n             stack.add(eleD[t])\n             nextstack.remove(eleD[t])\n             while stack:\n                 (x,y) = stack.pop()\n                 if x == N-1 and y == N-1:\n                     return t\n                 C[x][y] = 1\n                 if x > 0:\n                     P = (x-1,y)\n                     if C[P[0]][P[1]] == 0:\n                         if grid[P[0]][P[1]] <= t:\n                             stack.add(P)\n                         else:\n                             nextstack.add(P)\n                 if y > 0:\n                     P = (x,y-1)\n                     if C[P[0]][P[1]] == 0:\n                         if grid[P[0]][P[1]] <= t:\n                             stack.add(P)\n                         else:\n                             nextstack.add(P)\n                 if x < N-1:\n                     P = (x+1,y)\n                     if C[P[0]][P[1]] == 0:\n                         if grid[P[0]][P[1]] <= t:\n                             stack.add(P)\n                         else:\n                             nextstack.add(P)\n                 if y < N-1:\n                     P = (x,y+1)\n                     if C[P[0]][P[1]] == 0:\n                         if grid[P[0]][P[1]] <= t:\n                             stack.add(P)\n                         else:\n                             nextstack.add(P)\n             print(t)\n                 \n                 \n \n         # eleD = {}\n         # for i in range(N):\n         #     for j in range(N):\n         #         eleD[grid[i][j]] = (i,j)\n         # res = grid\n         # for t in range(N*N):\n         #     (x,y) = eleD[t]\n         #     if x > 0:\n         #         if res[x-1][y] <= t:\n         #             temp = res[x-1][y]\n         #             for i in range(N):\n         #                 for j in range(N):\n         #                     if res[i][j] == temp:\n         #                         res[i][j] = t\n         #     if y > 0:\n         #         if res[x][y - 1] <= t:\n         #             temp = res[x][y - 1]\n         #             for i in range(N):\n         #                 for j in range(N):\n         #                     if res[i][j] == temp:\n         #                         res[i][j] = t\n         #     if x < N - 1:\n         #         if res[x + 1][y] <= t:\n         #             temp = res[x + 1][y]\n         #             for i in range(N):\n         #                 for j in range(N):\n         #                     if res[i][j] == temp:\n         #                         res[i][j] = t\n         #     if y < N - 1:\n         #         if res[x][y + 1] <= t:\n         #             temp = res[x][y + 1]\n         #             for i in range(N):\n         #                 for j in range(N):\n         #                     if res[i][j] == temp:\n         #                         res[i][j] = t\n         #     #print(t,res)\n         #     if res[0][0] == res[N-1][N-1]:\n         #         return t\n
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        if root == None:\n            return None\n        \n        maxlength = 0\n        stack = collections.deque()\n        if root.left:\n            stack.append((1, 1, root.left))\n        if root.right:\n            stack.append((1, 0, root.right))\n        while stack:\n            length, isleft, node = stack.pop()\n            if isleft:\n                if node.right:\n                    stack.append((length + 1, 0, node.right))\n                else:\n                    maxlength = max(maxlength, length)\n                if node.left:\n                    stack.append((1, 1, node.left))\n            else:\n                if node.left:\n                    stack.append((length + 1, 1, node.left))\n                else:\n                    maxlength = max(maxlength, length)\n  \n                if node.right:\n                    stack.append((1, 0, node.right))\n            \n        return maxlength\n            \n
class Solution:\n    def getStrongest(self, arr: List[int], k: int) -> List[int]:\n        arr.sort()\n        i, j = 0, len(arr) - 1\n        median = arr[(len(arr) - 1) // 2]\n        while len(arr) + i - j <= k:\n            if median - arr[i] > arr[j] - median:\n                i = i + 1\n            else:\n                j = j - 1\n        return arr[:i] + arr[j + 1:]
class Solution:\n  def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n    tree = dict()\n    for i, j in edges:\n      if i > j: i, j = j, i\n      tree.setdefault(i - 1, []).append(j - 1)\n\n    queue, time = [(0, 1)], 0  # node-prob\n    while queue and time <= t:  # bfs \n      tmp = []\n      for node, prob in queue:\n        if node == target - 1: return 0 if time < t and node in tree else prob\n        for n in tree.get(node, []): tmp.append((n, prob / len(tree[node])))\n      queue, time = tmp, time + 1\n    return 0 \n
from bisect import insort, bisect_left, bisect_right\nfrom math import ceil\n\nclass TweetCounts:\n\n    def __init__(self):\n        self.tweets={}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName not in self.tweets:\n            self.tweets[tweetName] = []\n        insort(self.tweets[tweetName], time)\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        entry = self.tweets[tweetName]\n        diff = endTime - startTime\n        factor = 86400\n        if freq == 'minute':\n            factor = 60\n        elif freq == 'hour':\n            factor = 3600\n        buckets = math.ceil((diff + 1) / factor)\n        ans = [0]*buckets\n        start = bisect_left(entry, startTime)\n        end = bisect_right(entry, endTime)\n        for i in range(start, end):\n            time = entry[i]\n            d = (time - startTime) // factor\n            ans[d] += 1\n        return ans\n        \n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n
class Solution:\n     def findMinDifference(self, timePoints):\n         """\n         :type timePoints: List[str]\n         :rtype: int\n         """\n         if len(timePoints) > 1440: return 0\n         timeNum = [0] * len(timePoints)\n         for i in range(len(timePoints)):\n             timeNum[i] = 60 * int(timePoints[i][:2]) + int(timePoints[i][3:])\n             \n         timeNum.sort()\n         minMin = 24 * 60\n         for i in range(len(timeNum) - 1):\n             minMin = min(minMin, timeNum[i + 1] - timeNum[i])\n         minMin = min(minMin, 24 * 60 + timeNum[0] - timeNum[-1])\n         return minMin
class DLL:\n     \n     def __init__(self, val, key):\n         self.val = val\n         self.key = key\n         self.next = None\n         self.prev = None\n \n class AllOne:\n \n     def __init__(self):\n         """\n         Initialize your data structure here.\n         """\n         self.hash = {}\n         self.head = None\n         self.tail = None\n \n     def inc(self, key):\n         """\n         Inserts a new key <Key> with value 1. Or increments an existing key by 1.\n         :type key: str\n         :rtype: void\n         """\n         self.print_dll()\n         dll = self.hash.get(key, None)\n         if not dll:\n             dll = DLL(1, key)\n             self.insert_dll(dll)\n             self.hash[key] = dll\n         else:\n             self.incr_dll(dll)  \n         \n \n     def dec(self, key):\n         """\n         Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\n         :type key: str\n         :rtype: void\n         """\n         self.print_dll()\n         dll = self.hash.get(key, None)\n         if not dll:return\n         self.decr_dll(dll)\n         if dll.val == 0:\n             del self.hash[key]\n         \n \n     def getMaxKey(self):\n         """\n         Returns one of the keys with maximal value.\n         :rtype: str\n         """\n         if self.head:\n             return self.head.key\n         return ""\n         \n \n     def getMinKey(self):\n         """\n         Returns one of the keys with Minimal value.\n         :rtype: str\n         """\n         if self.tail:\n             return self.tail.key\n         return ""\n         \n     def insert_dll(self, dll):\n         if self.tail:\n             self.tail.next = dll\n             self.tail.next.prev = self.tail\n             self.tail = dll\n         else:\n             self.head = dll\n             self.tail = dll\n         \n     def incr_dll(self, dll):\n         dll.val = dll.val + 1\n         while dll.prev and dll.val > dll.prev.val:\n             \n             prev = dll.prev\n             prev_prev = dll.prev.prev\n             next_node = dll.next\n             \n             dll.next = prev\n             prev.next = next_node\n             dll.prev = prev_prev\n             prev.prev = dll\n             \n             if prev_prev:\n                 prev_prev.next = dll\n             else:\n                 self.head = dll\n             \n             if next_node:\n                 next_node.prev = prev\n             else:\n                 self.tail = prev\n                 \n             \n     def decr_dll(self, dll):\n         dll.val = dll.val - 1\n         if dll.val == 0 :\n             if dll.prev:\n                 dll.prev.next = dll.next\n             else:\n                 self.head = dll.next\n                                 \n             if dll.next:\n                 dll.next.prev = dll.prev\n             else:\n                 self.tail = dll.prev\n         \n         elif dll.next and dll.val < dll.next.val:\n             next_node = dll.next\n             next_next = dll.next.next\n             prev = dll.prev\n             \n             dll.next = next_next\n             dll.prev = next_node\n             \n             next_node.next = dll\n             next_node.prev = prev\n             \n             if next_next:\n                 next_next.prev = dll\n             else:\n                 self.tail = dll\n             if prev:\n                 prev.next = next_node\n             else:\n                 self.head = next_node\n                 \n     def print_dll(self):\n         temp = self.head\n         # while temp:\n         #     print("%s %s" % (temp.key, str(temp.val)))\n         #     temp = temp.next\n         # print("End")\n \n \n             \n             \n                 \n \n \n \n # Your AllOne object will be instantiated and called as such:\n # obj = AllOne()\n # obj.inc(key)\n # obj.dec(key)\n # param_3 = obj.getMaxKey()\n # param_4 = obj.getMinKey()
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    def pruneTreeHelper(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        \n        left = self.pruneTreeHelper(root.left)\n        right = self.pruneTreeHelper(root.right)\n        \n        if not left:\n            root.left = None\n        \n        if not right:\n            root.right = None\n        \n        if root.val == 0 and root.right is None and root.left is None:\n            return None\n        else:\n            return root\n    \n    def pruneTree(self, root: TreeNode) -> TreeNode:\n        return self.pruneTreeHelper(root)
class SubrectangleQueries:\n\n    def __init__(self, rectangle: List[List[int]]):\n        self.initial_rectangle = rectangle\n        self.rectangles = []\n        \n\n    def updateSubrectangle(self, row1: int, col1: int, row2: int, col2: int, newValue: int) -> None:\n        self.rectangles.append((row1, col1, row2, col2, newValue))\n        \n\n    def getValue(self, row: int, col: int) -> int:\n        for row1, col1, row2, col2, value in reversed(self.rectangles):\n            if row1 <= row <= row2 and col1 <= col <= col2:\n                return value\n        return self.initial_rectangle[row][col]\n        \n\n\n# Your SubrectangleQueries object will be instantiated and called as such:\n# obj = SubrectangleQueries(rectangle)\n# obj.updateSubrectangle(row1,col1,row2,col2,newValue)\n# param_2 = obj.getValue(row,col)\n
import random\n class RandomizedCollection:\n \n     def __init__(self):\n         """\n         Initialize your data structure here.\n         """\n         self.val = []\n         self.idx = {}\n \n     def insert(self, val):\n         """\n         Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\n         :type val: int\n         :rtype: bool\n         """\n         self.val.append(val)\n         if val in self.idx:\n             self.idx[val].append(len(self.val) - 1)\n             return False\n         else:\n             self.idx[val] = [len(self.val) - 1]\n \n     def remove(self, val):\n         """\n         Removes a value from the collection. Returns true if the collection contained the specified element.\n         :type val: int\n         :rtype: bool\n         """\n         if val not in self.idx:\n             return False\n         #print(self.val, self.idx)\n         self.val[self.idx[val][-1]] = self.val[-1]\n         if self.idx[self.val[-1]][-1] != self.idx[val][-1]:\n             self.idx[self.val[-1]].pop()\n             self.idx[self.val[-1]].append(self.idx[val][-1])\n             self.idx[self.val[-1]].sort()\n         self.val.pop()\n         self.idx[val].pop()\n         if len(self.idx[val]) == 0:\n             del self.idx[val]\n         return True\n \n     def getRandom(self):\n         """\n         Get a random element from the collection.\n         :rtype: int\n         """\n         return random.choice(self.val)\n \n \n # Your RandomizedCollection object will be instantiated and called as such:\n # obj = RandomizedCollection()\n # param_1 = obj.insert(val)\n # param_2 = obj.remove(val)\n # param_3 = obj.getRandom()
# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def levelOrder(self, root):\n         """\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         """\n         queue, res = [root], []\n         while any(queue):\n             tmp = []\n             for _ in range(len(queue)):\n                 node = queue.pop(0)\n                 tmp.append(node.val)\n                 if node.left:\n                     queue.append(node.left)\n                 if node.right:\n                     queue.append(node.right)\n             res.append(tmp)\n         return res
class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        tree = [[] for _ in range(N)]\n        for i, j in edges:\n            tree[i].append(j)\n            tree[j].append(i)\n        \n        cnt = [1] * N\n        res = [0] * N\n        \n        def post_order(node, parent):\n            for i in tree[node]:\n                if i != parent:\n                    post_order(i, node)\n                    cnt[node] += cnt[i]\n                    res[node] += res[i] + cnt[i]\n                    \n        def pre_order(node, parent):\n            for i in tree[node]:\n                if i != parent:\n                    res[i] = res[node] - cnt[i] + (N - cnt[i])\n                    pre_order(i, node)\n        post_order(0, -1)\n        pre_order(0, -1)\n        \n        return res\n
class Solution:\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\n        clips.sort(key=lambda x: [x[0], -x[1]])\n        res = 0            \n        r = 0\n        new_r = 0\n        # print(clips)\n        for s, e in clips:\n            if s <= r:\n                new_r = max(new_r, e)\n            elif s > new_r:\n                return -1\n            else:\n                res += 1\n                r = new_r\n                # print(new_r)\n                new_r = max(new_r, e)\n            if new_r >= T:\n                break\n        if new_r < T:\n            return -1\n        if r < T and new_r >= T:\n            res += 1\n        return res\n
"""\n of course this is a dp problem.\n if we consider upper bound and lower bound for each sub tree, \n we will have a index-based solution over all posible numbers.\n \n each time we part a sub-tree into two parts, the question then becomes:\n how many possible boundaries can we find (start, end).\n """\n \n class Solution:\n     def generateTrees(self, n):\n         """\n         :type n: int\n         :rtype: List[TreeNode]\n         """\n         dp = dict()\n         ret = self.generate_recursively(list(range(1, n+1)), 0, n, dp)\n         if n == 0:\n             ret = []\n         return ret\n \n     # list is a sorted list of trees\n     def generate_recursively(self, l, start, end, dp):\n         ret = []\n         if end - start == 1:\n             ret = [TreeNode(l[start]),]\n         elif end - start <= 0:\n             ret = [None,]\n \n         # take each index as partition place\n         else:\n             for idx in range(0, end - start):\n                 left_nodes = dp[(start, start+idx)] if (start, start+idx) in dp.keys() else self.generate_recursively(l, start, start+idx, dp)\n                 right_nodes = dp[(start+idx+1, end)] if (start+idx+1, end) in dp.keys() else self.generate_recursively(l, start+idx+1, end, dp)\n \n                 for left in left_nodes:\n                     for right in right_nodes:\n                         root = TreeNode(l[start+idx])\n                         root.left = left \n                         # if left != '<E>' else None\n                         root.right = right \n                         # if right !='<E>' else None\n                         ret.append(root)\n         dp[(start, end)] = ret\n         return ret\n \n s = Solution()\n s.generateTrees(3)
class Solution:\n    def findTheCity(self, n, edges, threshold):\n        adj=[[] for _ in range(n)]\n        for u,v,w in edges:\n            adj[u].append((w,v))\n            adj[v].append((w,u))\n\n        ans=mn=100\n        for x in range(n):\n            cur=1\n            vis={x}\n            dist=[threshold+1]*n\n            hp=[(0,x)]\n            while hp:\n                d,u=heappop(hp)\n                if d>dist[u]:\n                    continue\n                for w,v in adj[u]:\n                    if d+w<dist[v]:\n                        vis.add(v)\n                        dist[v]=d+w\n                        heappush(hp,(d+w,v))\n            if len(vis)<=mn:\n                mn=len(vis)\n                ans=x\n        \n        return ans
# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def rob(self, root):\n         """\n         :type root: TreeNode\n         :rtype: int\n         """\n         def superrob(node):\n             # returns tuple of size two (now, later)\n             # now: max money earned if input node is robbed\n             # later: max money earned if input node is not robbed\n \n             # base case\n             if not node: return (0, 0)\n \n             # get values\n             left, right = superrob(node.left), superrob(node.right)\n \n             # rob now\n             now = node.val + left[1] + right[1]\n \n             # rob later\n             later = max(left) + max(right)\n \n             return (now, later)\n \n         return max(superrob(root))\n
# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution(object):\n         def validBST(self, root, min, max):\n             if root == None:\n                 return True\n             if root.val <= min or root.val >= max:\n                 return False\n             return self.validBST(root.left, min, root.val) and self.validBST(root.right, root.val, max)\n         def isValidBST(self, root):\n             return self.validBST(root, -21474836480, 21474836470)
class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n\n        queue = deque([(0, 0, True)])\n        dists = {(0, 0, True): 0}\n\n        while queue:\n            i, j, hor = queue.popleft()\n            if (i, j) == (m-1, n-2):\n                return dists[(i, j, hor)]\n            if hor:\n                if j+2 < n and not grid[i][j+2]:\n                    if (i, j+1, hor) not in dists:\n                        queue.append((i, j+1, hor))\n                        dists[(i, j+1, hor)] = dists[(i, j, hor)]+1\n                if i+1 < m and not grid[i+1][j] and not grid[i+1][j+1]:\n                    if (i+1, j, hor) not in dists:\n                        queue.append((i+1, j, hor))\n                        dists[(i+1, j, hor)] = dists[(i, j, hor)]+1\n                    if (i, j, not hor) not in dists:\n                        queue.append((i, j, not hor))\n                        dists[(i, j, not hor)] = dists[(i, j, hor)]+1\n            else:\n                if i+2 < m and not grid[i+2][j]:\n                    if (i+1, j, hor) not in dists:\n                        queue.append((i+1, j, hor))\n                        dists[(i+1, j, hor)] = dists[(i, j, hor)]+1\n                if j+1 < n and not grid[i][j+1] and not grid[i+1][j+1]:\n                    if (i, j+1, hor) not in dists:\n                        queue.append((i, j+1, hor))\n                        dists[(i, j+1, hor)] = dists[(i, j, hor)]+1\n                    if (i, j, not hor) not in dists:\n                        queue.append((i, j, not hor))\n                        dists[(i, j, not hor)] = dists[(i, j, hor)]+1\n        \n        return -1
class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        left, right, mid = set(), set(), set()\n        count = 0\n        for row, col in reservedSeats:\n  \n            # if row in left and row in right and row in mid:\n            #     continue\n            if col < 6 and col > 1:\n                left.add(row)\n            if col < 10 and col > 5:\n                right.add(row)\n            if col < 8 and col > 3:\n                mid.add(row)\n        for i in (left | right | mid):\n            if i not in mid:\n                count += 1\n            elif i not in left or i not in right:\n                count += 1\n        count += 2 * (n - len(left | right | mid))\n        return count
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: TreeNode):\n      self.dicts = {}\n      if root:\n        root.val = 0\n        stacks = [root]\n        self.dicts[0] = 1\n        while stacks:\n          new_stacks = []\n          for element in stacks:\n            if element.left: element.left.val = element.val*2 + 1; new_stacks.append(element.left);\\\n               self.dicts[element.left.val] = 1\n            if element.right: element.right.val = element.val*2 + 2; new_stacks.append(element.right);\\\n               self.dicts[element.right.val] = 1\n          stacks = new_stacks\n        #print (self.dicts)\n        \n        \n\n    def find(self, target: int) -> bool:\n        return target in self.dicts\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)
class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m = len(matrix)\n        n = len(matrix[0])\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if not matrix[i][j]:\n                    continue\n                if matrix[i][j-1] and matrix[i-1][j] and matrix[i-1][j-1]:\n                    matrix[i][j] = min(matrix[i][j-1], matrix[i-1][j], matrix[i-1][j-1]) + 1\n        \n        total = 0\n        for row in matrix:\n            total += sum(row)\n            \n        return total\n                \n
class Solution:\n     def fallingSquares(self, positions):\n         """\n         :type positions: List[List[int]]\n         :rtype: List[int]\n         """\n         height = [0]\n         pos = [0]\n         res = []\n         max_h = 0\n         for left, side in positions:\n             i = bisect.bisect_right(pos, left)\n             j = bisect.bisect_left(pos, left + side)\n             high = max(height[i - 1:j] or [0]) + side\n             pos[i:j] = [left, left + side]\n             height[i:j] = [high, height[j - 1]]\n             max_h = max(max_h, high)\n             res.append(max_h)\n         return res        
class Solution:\n    def minAreaRect(self, points):\n        pSet, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                if (p1x != p2x) and (p1y != p2y) and ((p1x, p2y) in pSet) and ((p2x, p1y) in pSet):\n                    ans = min(ans, abs((p1x - p2x) * (p1y - p2y)))\n        return ans if ans < float('inf') else 0\n    \nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(set(X[0])) == 1 or len(set(X[1])) == 1: return 0\n\n        pSet, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                area = abs((p2x-p1x)*(p2y-p1y))\n                if area > ans or area == 0:\n                    continue\n                if (p1x, p2y) in pSet and (p2x, p1y) in pSet:\n                    ans = area\n        return ans if ans < float('inf') else 0\n    \nfrom collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        Nr, Nc = len(set(X[0])), len(set(X[1]))\n        if Nr == 1 or Nc == 1: return 0\n\n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in list(columns.items()):\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = (r - lastc[(c1, c2)]) * (c2 - c1)\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0\n    \nfrom collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        Nr, Nc = len(set(X[0])), len(set(X[1]))\n        if Nr == 1 or Nc == 1: return 0\n        if Nr < Nc:\n            points = [[c, r] for (r, c) in points]\n            return self.minAreaRect(points)\n    \n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in list(columns.items()):\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = (r - lastc[(c1, c2)]) * (c2 - c1)\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0\n    \nfrom collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        d = defaultdict(set)\n        rset, cset, N, ans = set(), set(), len(points), float('inf')\n        for r, c in points:\n            rset.add(r)\n            cset.add(c)\n        Nr, Nc = len(rset), len(cset)\n        if Nr == 1 or Nc == 1:\n            return 0\n        elif Nr < Nc:\n            for r, c in points:\n                d[r].add(c)\n        else:\n            for r, c in points:\n                d[c].add(r)\n\n        A = sorted(d.keys())\n        for i, r1 in enumerate(A):\n            cols1 = d[r1]\n            for r2 in A[i+1:]:\n                cols2 = d[r2]\n                s = sorted(cols1 & cols2)\n                for c1, c2 in zip(s[:-1], s[1:]):\n                    area = (r1 - r2) * (c1 - c2)\n                    #ans = min(ans, area)\n                    if area < ans: ans = area\n        return ans if ans < float('inf') else 0\n
class Solution:\n    def pancakeSort(self, A: List[int]) -> List[int]:\n        n = len(A)\n        res = []\n        \n        for x in range(n, 1, -1):\n            idx = A.index(x)\n            res.extend([idx + 1, x])\n            A = A[idx::-1] + A[idx+1:]\n            A = A[x-1::-1]\n            \n        return res\n
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\n\nclass Solution:\n    def bfs(self, root, col_table):\n        min_col = 0\n        max_col = 0\n        queue = deque([(root, 0, 0)])\n        \n        while queue:\n            node, col, row = queue.popleft()\n            col_value = col_table.get(col, [])\n            col_value.append((row, node.val))\n            col_table[col] = col_value\n            min_col = min(min_col, col)\n            max_col = max(max_col, col)\n            if node.left:\n                queue.append((node.left, col - 1, row + 1))\n            if node.right:\n                queue.append((node.right, col + 1, row + 1))\n        return min_col, max_col\n                \n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        col_table = dict()\n        min_col, max_col = self.bfs(root, col_table)\n        \n        res = []\n        for col_idx in range(min_col, max_col + 1):\n            col_res = []\n            col = sorted(col_table[col_idx])\n            for i in range(len(col)):\n                col_res.append(col[i][1])\n            res.append(col_res)\n        return res
class Solution:\n    def braceExpansionII(self, expression: str) -> List[str]:\n     \n        stack,res,cur=[],[],['']\n        for v in expression:\n           \n            if v.isalpha():\n                cur=[c+v for c in cur]\n            elif v==',':\n                res+=cur\n                cur=['']\n            elif v=='{':\n                stack.append(res)\n                stack.append(cur)\n                res,cur=[],['']\n            elif v=='}':\n                preCur=stack.pop()\n                preRes=stack.pop()\n                cur=[p+c for p in preCur for c in res+cur]\n                res=preRes\n        return sorted(set(res+cur))
class Solution:\n    def minPushBox(self, grid: List[List[str]]) -> int:\n        m, n, g = len(grid), len(grid[0]), collections.defaultdict(list)\n        for i in range(m):\n            for j in range(n):\n                g[grid[i][j]] += [complex(i, j)]\n        \n        def f(b, s):\n            nonlocal time\n            time += 1\n            boxToTarget = b - target\n            return (abs((boxToTarget.real))+abs((boxToTarget).imag)+s, abs(boxToTarget), time)\n        \n        player, box, target, time = *g['S'], *g['B'], *g['T'], 1\n        floor = {player, box, target, *g['.']}\n        \n        alpha = [(f(box, 1), 1, player, box)]\n        directions, visited = (1, -1, 1j, -1j), set()   # \n        \n        # low dfn\n        low = dict.fromkeys(floor, 0)  # dict.fromkeyskeys\n        dfn = low.copy()\n        count = 0\n        index = {}\n        # tarjancurrIndex\n        def tarjan(currIndex, parentIndex):\n            nonlocal count\n            count += 1\n            dfn[currIndex] = low[currIndex] = count\n            index[count] = currIndex\n            for direction in directions:\n                nextIndex = currIndex + direction\n                if nextIndex in floor and nextIndex != parentIndex:\n                    if not low[nextIndex]:\n                        tarjan(nextIndex, currIndex)\n                    low[currIndex] = min(low[currIndex], low[nextIndex])\n        \n        #tarjanbox-1\n        tarjan(box, -1)\n        #print(low)\n        #print(dfn)\n        # \n        # 1\n        for currIndex in floor:  # \n            connect = [currIndex]\n            while dfn[connect[-1]] != low[connect[-1]]:\n                connect.append(index[low[connect[-1]]])\n            for w in connect[:-2]:\n                low[w] = low[connect[-1]]\n        #print(low)\n        \n        # \n        # -1\n        if not low[player] * low[target]:\n            return -1\n        \n        while alpha:\n            _, steps, currPlayer, currBox = heapq.heappop(alpha)\n            for direction in directions:\n                nextPlayer, nextBox = currBox - direction, currBox + direction\n                if nextBox in floor and nextPlayer in floor and (nextPlayer, currBox) not in visited and low[currPlayer] == low[nextPlayer]:\n                    if nextBox == target:\n                        return steps\n                    heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\n                    visited.add((nextPlayer, currBox))\n        return -1
class Solution:\n     def fullJustify(self, words, maxWidth):\n         """\n         :type words: List[str]\n         :type maxWidth: int\n         :rtype: List[str]\n         """\n         def make_str(buffer, length, last):\n             if last:\n                 return ' '.join(buffer) + ' ' * (maxWidth - length)\n             space = maxWidth - (length - len(buffer) + 1)\n             cnt = len(buffer) - 1\n             tmp = ''\n             if cnt == 0:\n                 tmp = buffer[0] + ' ' * space\n             else:\n                 spaces = [space // cnt] * cnt\n                 for i in range(space % cnt):\n                     spaces[i] += 1\n                 spaces.append(0)\n                 for s, b in zip(spaces, buffer):\n                     tmp += b + ' ' * s\n             return tmp\n \n         res = []\n         buffer = []\n         length = 0\n         for w in words:\n             lw = len(w)\n             if lw > maxWidth:\n                 continue\n             if len(buffer) == 0:\n                 buffer.append(w)\n                 length = lw\n             elif length + lw + 1 <= maxWidth:\n                 buffer.append(w)\n                 length = length + lw + 1\n             else:\n                 tmp = make_str(buffer, length, False)\n                 res.append(tmp)\n                 buffer = [w]\n                 length = lw\n         if len(buffer) > 0:\n             tmp = make_str(buffer, length, True)\n             res.append(tmp)\n \n         return res\n
class Solution:\n     def __init__(self):\n         self.k = 0\n         self.result = None\n \n     def kthSmallest(self, root, k):\n         """\n         :type root: TreeNode\n         :type k: int\n         :rtype: int\n         """\n         if root.left and self.k < k:\n             self.kthSmallest(root.left, k)\n         self.k += 1\n         if self.k == k:\n             self.result = root.val\n         if root.right and self.k < k:\n             self.kthSmallest(root.right, k)\n         return self.result
class Solution:\n    def beautifulArray(self, N: int) -> List[int]:\n        res = [1]\n        \n        while len(res) < N:\n            res = [i*2-1 for i in res]+ [i*2 for i in res]\n            \n        return [i for i in res if i <= N]
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport re\n\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        itera = re.finditer(r'(-*)(\\d+)', S)\n        \n        root = TreeNode(int(next(itera).group(2)))\n        \n        tofill = [root]\n        \n        for m in itera:\n            k = len(m.group(1))\n            if k == len(tofill):\n                node = TreeNode(int(m.group(2)))\n                tofill[-1].left = node\n                tofill.append(node)\n            else:\n                node = TreeNode(int(m.group(2)))\n                tofill[k-1].right = node\n                tofill[k:] = [node]\n        \n        return root
class Solution:\n    def sampleStats(self, count: List[int]) -> List[float]:\n        mn = -1\n        mx = 0\n        sm = 0\n        cnt = 0\n        mode_i = 0\n        mode_cnt = 0\n        indexes = collections.deque()\n        median_count = 0\n        \n        for i, c in enumerate(count):\n            sm += i * c\n            cnt += c\n            \n            mode_i = i if mode_cnt < c else mode_i\n            mode_cnt = c if mode_cnt < c else mode_cnt\n            \n            if c:\n                mx = i\n                if mn == -1:\n                    mn = i\n                while indexes and median_count + count[indexes[0]] < cnt / 2:\n                    median_count += count[indexes[0]]\n                    indexes.popleft()\n                indexes.append(i)\n                \n        median = 0\n        \n        if cnt % 2:\n            median = indexes[0]\n        elif count[indexes[0]] + median_count > cnt // 2:\n            median = indexes[0]\n        else:\n            median = (indexes[0] + indexes[1]) / 2\n            \n        return mn, mx, sm / cnt, median, mode_i
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: TreeNode) -> int:\n        self.res = 0\n        def helper(node, path_max, path_min):\n            if not node:\n                return 0\n            path_max = max(path_max, node.val)\n            path_min = min(path_min, node.val)\n            self.res = max(self.res, path_max - path_min)\n            helper(node.left, path_max, path_min)\n            helper(node.right, path_max, path_min)\n        if not root:\n            return 0\n        helper(root, root.val, root.val)\n        return self.res
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        stack = [root]\n        ans = -1000000\n        result = 1\n        level = 1\n        \n        while stack:\n            curr = 0\n            newStack = []\n            for x in stack:\n                curr += x.val\n                if x.left:\n                    newStack.append(x.left)\n                if x.right: \n                    newStack.append(x.right)\n            \n            stack = newStack\n            \n            if curr > ans:\n                ans = curr\n                result = level\n                \n            level += 1\n            \n        return result
class Solution:\n     # def canTransform(self, start, end):\n     #     """\n     #     :type start: str\n     #     :type end: str\n     #     :rtype: bool\n     #     """\n \n     def canTransform(self, start, end):\n         # For (i, x) and (j, y) in enumerate(start), enumerate(end)\n         # where x != 'X' and y != 'X',\n         # and where if one exhausts early, it's elements are (None, None),...\n         for (i, x), (j, y) in itertools.zip_longest(\n                 ((i, x) for i, x in enumerate(start) if x != 'X'),\n                 ((j, y) for j, y in enumerate(end) if y != 'X'),\n                 fillvalue = (None, None)):\n \n             # If not solid or accessible, return False\n             if x != y or (x == 'L' and i < j) or (x == 'R' and i > j):\n                 return False\n \n         return True\n         \n         \n         # tmps = start.replace("X","")\n         # tmpe = end.replace("X","")\n         # if tmps != tmpe:\n         #     return False\n         # sa, ta = [], []\n         # i = 0\n         # while (i < len(start)):\n         #     if start[i] == "L":\n         #         sa.append(i)\n         #     elif start[i] == "R":\n         #         sa.append(-i)\n         #     if end[i] == "L":\n         #         ta.append(i)\n         #     elif end[i] == "R":\n         #         ta.append(-i)\n         #     i += 1\n         # i = 0\n         # while(i < len(sa)):\n         #     if sa[i]<ta[i]:\n         #         return False\n         #     i += 1\n         # return True\n
class Solution:\n     def numRabbits(self, answers):\n         cnts = collections.Counter(answers)\n         return sum(-v % (k+1) + v for k, v in cnts.items())
class Solution:\n \n     def findFrequentTreeSum(self, root):\n         self.sums = []\n         if not root:\n             return []\n         self.traverse(root)\n         res = collections.Counter(self.sums)\n         frequent = max(res.values())\n         return [x for x in res if res[x] == frequent]\n \n \n     def traverse(self, root):\n         if not root:\n             return 0\n         \n         self_sum = root.val + self.traverse(root.left) + self.traverse(root.right)\n \n         self.sums.append(self_sum)\n         return self_sum\n
def fun(k):\n     n = 1 + 8*k\n     s = math.floor(n**0.5)-1\n     s = s//2\n     return s\n class Solution:\n     def reachNumber(self, target):\n         """\n         :type target: int\n         :rtype: int\n         """\n         if target<0:\n             target *= -1\n         L = [[3,2,1,1],[1,1,3,2]] \n         k = fun(target)\n         if k*(k+1)/2==target:\n             ans = 0\n         else:\n             ans = L[target%2][k%4]\n         #print(target,"->",k,k+ans)\n         return k+ans\n         
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(self, root, limit):\n        if root.left == root.right:\n            return None if root.val < limit else root\n        if root.left:\n            root.left = self.sufficientSubset(root.left, limit - root.val)\n        if root.right:\n            root.right = self.sufficientSubset(root.right, limit - root.val)\n        return root if root.left or root.right else None\n
class Solution:\n     def maxChunksToSorted(self, arr):\n         """\n         :type arr: List[int]\n         :rtype: int\n         """\n         res = 0\n         temp = sorted(arr)\n         sum1, sum2 = 0, 0\n         for i in range(0,len(arr)):\n             sum1 += arr[i]\n             sum2 += temp[i]\n             if(sum1 == sum2):\n                 res += 1\n         return res\n
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: TreeNode) -> int:\n        q = [root]\n        while q:\n            pre, q = q, [child for p in q for child in [p.left, p.right] if child]\n        return sum(node.val for node in pre)\n       \n            \n
class Solution:\n    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:\n        cell = 0\n        for c in cells:\n            cell = (cell << 1) | c\n        seendict = {}\n        index = 0\n        while True:\n            # print([int(x) for x in '{0:08b}'.format(cell)])\n            if cell in seendict:\n                if (N - index) % (index - seendict[cell]) == 0:\n                    return [int(x) for x in '{0:08b}'.format(cell)]\n            seendict[cell] = index\n            not_cell = (cell ^ 255) \n            cell = ((cell << 1) & (cell >> 1)) | ((not_cell << 1) & (not_cell >> 1))\n            index += 1
class Solution:\n     def intersectionSizeTwo(self, intervals):\n         """\n         :type intervals: List[List[int]]\n         :rtype: int\n         """\n         intervals.sort(key=lambda x: x[1])\n         if len(intervals) <= 1:\n             return len(intervals[0])\n         s = set()\n         prev_e = None\n         intersect = False\n         for e in intervals:\n             if not s:\n                 a = e[1] - 1\n                 b = e[1]\n                 s.add(a)\n                 s.add(b)\n                 continue\n             if e[0] <= a :\n                 intersect = True\n                 continue\n                 \n             if e[0] > a and  e[1] > b >= e[0] :\n                 intersect = True\n                 a = b\n                 b = e[-1]\n                 s.add(b)\n                 continue\n             a = e[1] - 1\n             b = e[1]\n             s.add(a)\n             s.add(b)\n         \n         if not intersect:\n             return 0\n         return len(s)\n
# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def swapPairs(self, head):\n         """\n         :type head: ListNode\n         :rtype: ListNode\n         """\n         i = 1\n         node = head\n         prev = None\n         prev2 = None\n         while node is not None:\n             if i % 2 == 0 and i != 1:\n                 if prev2 is not None:\n                     prev2.next = node\n                 prev.next = node.next\n                 node.next = prev\n                 if i == 2:\n                     head = node\n                 node = prev\n             prev2 = prev\n             prev = node\n             node = node.next\n             i += 1\n         return head
class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        def fun(g,i0,i1,n1,t1,f2,row,col):\n            if n1==t1:\n                if abs(f2[1]-i1)+abs(f2[0]-i0)==1:\n                    self.ans+=1\n            else:\n                if i1+1!=col and g[i0][i1+1]==0:\n                    g[i0][i1+1]=1\n                    fun(g,i0,i1+1,n1+1,t1,f2,row,col)\n                    g[i0][i1+1]=0\n                if i1!=0 and g[i0][i1-1]==0:\n                    g[i0][i1-1]=1\n                    fun(g,i0,i1-1,n1+1,t1,f2,row,col)\n                    g[i0][i1-1]=0\n                if i0+1!=row and g[i0+1][i1]==0:\n                    g[i0+1][i1]=1\n                    fun(g,i0+1,i1,n1+1,t1,f2,row,col)\n                    g[i0+1][i1]=0\n                if i0!=0 and g[i0-1][i1]==0:\n                    g[i0-1][i1]=1\n                    fun(g,i0-1,i1,n1+1,t1,f2,row,col)\n                    g[i0-1][i1]=0\n        \n        self.ans=0\n        i0,i1,t1=0,0,0\n        f2=[0,0]\n        row = len(grid)\n        col = len(grid[0])\n        for i in range(row):\n            for j in range(col):\n                if grid[i][j]==0:\n                    t1+=1\n                elif grid[i][j]==1:\n                    i0,i1 = i,j\n                elif grid[i][j]==2:\n                    f2 = [i,j]\n        fun(grid,i0,i1,0,t1,f2,row,col)\n        return self.ans
class Solution:\n     def findLadders(self, beginWord, endWord, wordList):\n         wordDict = set(wordList)\n         if endWord not in wordDict: return []\n         wordDict.discard(beginWord)\n         front, back = set([beginWord]), set([endWord])\n         length = 2\n         direction = 1\n         parents = collections.defaultdict(set)\n         \n         while front:\n             next_level = set()\n             for word in front:\n                 for index in range(len(beginWord)):\n                     p1, p2 = word[:index], word[index+1:]\n                     for ch in 'abcdefghijklmnopqrstuvwxyz':\n                         if word[index] != ch:\n                             next_word = p1 + ch + p2\n                             if next_word in wordDict:\n                                 next_level.add(next_word)\n                                 if direction == 1:\n                                     parents[next_word].add(word)\n                                 else:\n                                     parents[word].add(next_word)\n                             \n             if next_level & back:\n                 res = [[endWord]]\n                 while res and res[0][0] !=beginWord:\n                     res = [[p]+r for r in res for p in parents[r[0]]]\n                 return res\n                 \n             length += 1\n             front = next_level\n             if len(front) > len(back):\n                 direction *= -1\n                 front, back = back, front\n             wordDict -= front\n         return []\n         \n         \n         \n         \n         \n         \n         """\n         :type beginWord: str\n         :type endWord: str\n         :type wordList: List[str]\n         :rtype: List[List[str]]\n         """\n
class Solution:\n     def countBits(self, num):\n         """\n         :type num: int\n         :rtype: List[int]\n         """\n         ans = [0]\n         while len(ans) < num + 1:\n             ans += [1 + x for x in ans]\n         # len(ans) > num\n         return ans[:num+1]
from math import sqrt\n class NumArray(object):\n \n     def __init__(self, nums):\n         """\n         :type nums: List[int]\n         """\n         if nums:\n             k=int(sqrt(len(nums)))\n             add,i=[],0\n             while i<=len(nums)-k:\n                 add.append(sum(nums[i:i+k]))\n                 i+=k\n             if i!=len(nums):\n                 add.append(sum(nums[i:]))\n             self.nums,self.add,self.k=nums,add,k\n         \n \n     def update(self, i, val):\n         """\n         :type i: int\n         :type val: int\n         :rtype: void\n         """\n         self.add[i//self.k]+=val-self.nums[i]\n         self.nums[i]=val\n         \n         \n \n     def sumRange(self, i, j):\n         """\n         :type i: int\n         :type j: int\n         :rtype: int\n         """\n         def func(i):\n             return sum(self.add[:i//self.k])+sum(self.nums[(i//self.k)*self.k:i+1]) if i>=0 else 0\n         return func(j)-func(i-1)\n         \n \n \n # Your NumArray object will be instantiated and called as such:\n # obj = NumArray(nums)\n # obj.update(i,val)\n # param_2 = obj.sumRange(i,j)
class Solution:\n     def findCircleNum(self, M):\n         N = len(M)\n         students = set()\n         for i in range(N):\n             students.add(i)\n         \n         num_grp = 0\n         while students:\n             num_grp += 1\n             stack = [students.pop()]\n             while stack and students:\n                 student = stack.pop()\n                 for i in range(N):\n                     if M[student][i] == 1 and i in students:\n                         stack.append(i)\n                         students.discard(i)\n         return num_grp\n
class Solution:\n     def addOneRow(self, root, v, d):\n         """\n         :type root: TreeNode\n         :type v: int\n         :type d: int\n         :rtype: TreeNode\n         """\n         if root:\n             if d == 1:\n                 new_root = TreeNode(v)\n                 new_root.left = root\n                 \n                 return new_root \n \n             queue = [root]\n             level = 1\n             while queue and level < d:\n                 row = []\n                 for i in range(len(queue)):\n                     node = queue.pop(0)\n                     if level == d - 1:\n                         row.append(node)\n                     if node.left:\n                         queue.append(node.left)\n                     if node.right:\n                         queue.append(node.right)\n                 \n                 level += 1\n                                     \n             for node in row:\n                 old = node.left\n                 node.left = TreeNode(v)\n                 node.left.left = old\n \n                 old = node.right\n                 node.right = TreeNode(v)\n                 node.right.right = old\n         \n         return root\n             \n             \n
from functools import reduce\n class Solution:\n     def smallestRange(self, nums):\n         """\n         :type nums: List[List[int]]\n         :rtype: List[int]\n         """\n         k = len(nums)\n         idx = [0]*k\n         \n         dic = collections.defaultdict(list)\n         \n         for i in range(k):\n             dic[nums[i][0]].append(i)\n         \n         mi, ma = min(dic.keys()), max(dic.keys())\n         \n         ret = (mi, ma)\n         while True:\n             for i in dic[mi]:\n                 idx[i] += 1\n                 if idx[i]==len(nums[i]):\n                     return ret\n                 dic[nums[i][idx[i]]].append(i)\n             dic.pop(mi)\n             mi, ma = min(dic.keys()), max(dic.keys())\n             if ma-mi<ret[1]-ret[0]:\n                 ret = (mi, ma)\n         
# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n from collections import deque\n \n class Solution:\n     def findBottomLeftValue(self, root):\n         """\n         :type root: TreeNode\n         :rtype: int\n         """\n         self.queue = deque([])\n         self.queue.append(root)\n         return self.bfs()\n \n     def bfs(self):\n         while len(self.queue):\n             node = self.queue.popleft()\n             if node.right:\n                 self.queue.append(node.right)\n             if node.left:\n                 self.queue.append(node.left)\n         return node.val\n         
from copy import deepcopy\n from collections import deque\n def check(p1, p2):\n     if p1[0] == p2[0] or p1[1] == p2[1] or abs(p1[0] - p2[0]) == abs(p1[1] - p2[1]):\n         return True\n     return False\n \n def passAll(p1, points):\n     for x, y in enumerate(points):\n         if check(p1, (x, y)):\n             return False\n     return True\n \n def reconstruct(points, n):\n     a = [['.'] * n for _ in range(n)]\n     for x, y in enumerate(points):\n         a[x][y] = 'Q'\n     a = ["".join(i) for i in a]\n     return a\n \n class Solution:\n     def solveNQueens(self, n):\n         """\n         :type n: int\n         :rtype: int\n         """\n         return [[],\n                 [["Q"]],\n [],\n [],\n [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]],\n [["Q....","..Q..","....Q",".Q...","...Q."],["Q....","...Q.",".Q...","....Q","..Q.."],[".Q...","...Q.","Q....","..Q..","....Q"],[".Q...","....Q","..Q..","Q....","...Q."],["..Q..","Q....","...Q.",".Q...","....Q"],["..Q..","....Q",".Q...","...Q.","Q...."],["...Q.","Q....","..Q..","....Q",".Q..."],["...Q.",".Q...","....Q","..Q..","Q...."],["....Q",".Q...","...Q.","Q....","..Q.."],["....Q","..Q..","Q....","...Q.",".Q..."]],\n [[".Q....","...Q..",".....Q","Q.....","..Q...","....Q."],["..Q...",".....Q",".Q....","....Q.","Q.....","...Q.."],["...Q..","Q.....","....Q.",".Q....",".....Q","..Q..."],["....Q.","..Q...","Q.....",".....Q","...Q..",".Q...."]],\n [["Q......","..Q....","....Q..","......Q",".Q.....","...Q...",".....Q."],["Q......","...Q...","......Q","..Q....",".....Q.",".Q.....","....Q.."],["Q......","....Q..",".Q.....",".....Q.","..Q....","......Q","...Q..."],["Q......",".....Q.","...Q...",".Q.....","......Q","....Q..","..Q...."],[".Q.....","...Q...","Q......","......Q","....Q..","..Q....",".....Q."],[".Q.....","...Q...",".....Q.","Q......","..Q....","....Q..","......Q"],[".Q.....","....Q..","Q......","...Q...","......Q","..Q....",".....Q."],[".Q.....","....Q..","..Q....","Q......","......Q","...Q...",".....Q."],[".Q.....","....Q..","......Q","...Q...","Q......","..Q....",".....Q."],[".Q.....",".....Q.","..Q....","......Q","...Q...","Q......","....Q.."],[".Q.....","......Q","....Q..","..Q....","Q......",".....Q.","...Q..."],["..Q....","Q......",".....Q.",".Q.....","....Q..","......Q","...Q..."],["..Q....","Q......",".....Q.","...Q...",".Q.....","......Q","....Q.."],["..Q....","....Q..","......Q",".Q.....","...Q...",".....Q.","Q......"],["..Q....",".....Q.",".Q.....","....Q..","Q......","...Q...","......Q"],["..Q....","......Q",".Q.....","...Q...",".....Q.","Q......","....Q.."],["..Q....","......Q","...Q...","Q......","....Q..",".Q.....",".....Q."],["...Q...","Q......","..Q....",".....Q.",".Q.....","......Q","....Q.."],["...Q...","Q......","....Q..",".Q.....",".....Q.","..Q....","......Q"],["...Q...",".Q.....","......Q","....Q..","..Q....","Q......",".....Q."],["...Q...",".....Q.","Q......","..Q....","....Q..","......Q",".Q....."],["...Q...","......Q","..Q....",".....Q.",".Q.....","....Q..","Q......"],["...Q...","......Q","....Q..",".Q.....",".....Q.","Q......","..Q...."],["....Q..","Q......","...Q...","......Q","..Q....",".....Q.",".Q....."],["....Q..","Q......",".....Q.","...Q...",".Q.....","......Q","..Q...."],["....Q..",".Q.....",".....Q.","..Q....","......Q","...Q...","Q......"],["....Q..","..Q....","Q......",".....Q.","...Q...",".Q.....","......Q"],["....Q..","......Q",".Q.....","...Q...",".....Q.","Q......","..Q...."],["....Q..","......Q",".Q.....",".....Q.","..Q....","Q......","...Q..."],[".....Q.","Q......","..Q....","....Q..","......Q",".Q.....","...Q..."],[".....Q.",".Q.....","....Q..","Q......","...Q...","......Q","..Q...."],[".....Q.","..Q....","Q......","...Q...","......Q","....Q..",".Q....."],[".....Q.","..Q....","....Q..","......Q","Q......","...Q...",".Q....."],[".....Q.","..Q....","......Q","...Q...","Q......","....Q..",".Q....."],[".....Q.","...Q...",".Q.....","......Q","....Q..","..Q....","Q......"],[".....Q.","...Q...","......Q","Q......","..Q....","....Q..",".Q....."],["......Q",".Q.....","...Q...",".....Q.","Q......","..Q....","....Q.."],["......Q","..Q....",".....Q.",".Q.....","....Q..","Q......","...Q..."],["......Q","...Q...","Q......","....Q..",".Q.....",".....Q.","..Q...."],["......Q","....Q..","..Q....","Q......",".....Q.","...Q...",".Q....."]],\n [["Q.......","....Q...",".......Q",".....Q..","..Q.....","......Q.",".Q......","...Q...."],["Q.......",".....Q..",".......Q","..Q.....","......Q.","...Q....",".Q......","....Q..."],["Q.......","......Q.","...Q....",".....Q..",".......Q",".Q......","....Q...","..Q....."],["Q.......","......Q.","....Q...",".......Q",".Q......","...Q....",".....Q..","..Q....."],[".Q......","...Q....",".....Q..",".......Q","..Q.....","Q.......","......Q.","....Q..."],[".Q......","....Q...","......Q.","Q.......","..Q.....",".......Q",".....Q..","...Q...."],[".Q......","....Q...","......Q.","...Q....","Q.......",".......Q",".....Q..","..Q....."],[".Q......",".....Q..","Q.......","......Q.","...Q....",".......Q","..Q.....","....Q..."],[".Q......",".....Q..",".......Q","..Q.....","Q.......","...Q....","......Q.","....Q..."],[".Q......","......Q.","..Q.....",".....Q..",".......Q","....Q...","Q.......","...Q...."],[".Q......","......Q.","....Q...",".......Q","Q.......","...Q....",".....Q..","..Q....."],[".Q......",".......Q",".....Q..","Q.......","..Q.....","....Q...","......Q.","...Q...."],["..Q.....","Q.......","......Q.","....Q...",".......Q",".Q......","...Q....",".....Q.."],["..Q.....","....Q...",".Q......",".......Q","Q.......","......Q.","...Q....",".....Q.."],["..Q.....","....Q...",".Q......",".......Q",".....Q..","...Q....","......Q.","Q......."],["..Q.....","....Q...","......Q.","Q.......","...Q....",".Q......",".......Q",".....Q.."],["..Q.....","....Q...",".......Q","...Q....","Q.......","......Q.",".Q......",".....Q.."],["..Q.....",".....Q..",".Q......","....Q...",".......Q","Q.......","......Q.","...Q...."],["..Q.....",".....Q..",".Q......","......Q.","Q.......","...Q....",".......Q","....Q..."],["..Q.....",".....Q..",".Q......","......Q.","....Q...","Q.......",".......Q","...Q...."],["..Q.....",".....Q..","...Q....","Q.......",".......Q","....Q...","......Q.",".Q......"],["..Q.....",".....Q..","...Q....",".Q......",".......Q","....Q...","......Q.","Q......."],["..Q.....",".....Q..",".......Q","Q.......","...Q....","......Q.","....Q...",".Q......"],["..Q.....",".....Q..",".......Q","Q.......","....Q...","......Q.",".Q......","...Q...."],["..Q.....",".....Q..",".......Q",".Q......","...Q....","Q.......","......Q.","....Q..."],["..Q.....","......Q.",".Q......",".......Q","....Q...","Q.......","...Q....",".....Q.."],["..Q.....","......Q.",".Q......",".......Q",".....Q..","...Q....","Q.......","....Q..."],["..Q.....",".......Q","...Q....","......Q.","Q.......",".....Q..",".Q......","....Q..."],["...Q....","Q.......","....Q...",".......Q",".Q......","......Q.","..Q.....",".....Q.."],["...Q....","Q.......","....Q...",".......Q",".....Q..","..Q.....","......Q.",".Q......"],["...Q....",".Q......","....Q...",".......Q",".....Q..","Q.......","..Q.....","......Q."],["...Q....",".Q......","......Q.","..Q.....",".....Q..",".......Q","Q.......","....Q..."],["...Q....",".Q......","......Q.","..Q.....",".....Q..",".......Q","....Q...","Q......."],["...Q....",".Q......","......Q.","....Q...","Q.......",".......Q",".....Q..","..Q....."],["...Q....",".Q......",".......Q","....Q...","......Q.","Q.......","..Q.....",".....Q.."],["...Q....",".Q......",".......Q",".....Q..","Q.......","..Q.....","....Q...","......Q."],["...Q....",".....Q..","Q.......","....Q...",".Q......",".......Q","..Q.....","......Q."],["...Q....",".....Q..",".......Q",".Q......","......Q.","Q.......","..Q.....","....Q..."],["...Q....",".....Q..",".......Q","..Q.....","Q.......","......Q.","....Q...",".Q......"],["...Q....","......Q.","Q.......",".......Q","....Q...",".Q......",".....Q..","..Q....."],["...Q....","......Q.","..Q.....",".......Q",".Q......","....Q...","Q.......",".....Q.."],["...Q....","......Q.","....Q...",".Q......",".....Q..","Q.......","..Q.....",".......Q"],["...Q....","......Q.","....Q...","..Q.....","Q.......",".....Q..",".......Q",".Q......"],["...Q....",".......Q","Q.......","..Q.....",".....Q..",".Q......","......Q.","....Q..."],["...Q....",".......Q","Q.......","....Q...","......Q.",".Q......",".....Q..","..Q....."],["...Q....",".......Q","....Q...","..Q.....","Q.......","......Q.",".Q......",".....Q.."],["....Q...","Q.......","...Q....",".....Q..",".......Q",".Q......","......Q.","..Q....."],["....Q...","Q.......",".......Q","...Q....",".Q......","......Q.","..Q.....",".....Q.."],["....Q...","Q.......",".......Q",".....Q..","..Q.....","......Q.",".Q......","...Q...."],["....Q...",".Q......","...Q....",".....Q..",".......Q","..Q.....","Q.......","......Q."],["....Q...",".Q......","...Q....","......Q.","..Q.....",".......Q",".....Q..","Q......."],["....Q...",".Q......",".....Q..","Q.......","......Q.","...Q....",".......Q","..Q....."],["....Q...",".Q......",".......Q","Q.......","...Q....","......Q.","..Q.....",".....Q.."],["....Q...","..Q.....","Q.......",".....Q..",".......Q",".Q......","...Q....","......Q."],["....Q...","..Q.....","Q.......","......Q.",".Q......",".......Q",".....Q..","...Q...."],["....Q...","..Q.....",".......Q","...Q....","......Q.","Q.......",".....Q..",".Q......"],["....Q...","......Q.","Q.......","..Q.....",".......Q",".....Q..","...Q....",".Q......"],["....Q...","......Q.","Q.......","...Q....",".Q......",".......Q",".....Q..","..Q....."],["....Q...","......Q.",".Q......","...Q....",".......Q","Q.......","..Q.....",".....Q.."],["....Q...","......Q.",".Q......",".....Q..","..Q.....","Q.......","...Q....",".......Q"],["....Q...","......Q.",".Q......",".....Q..","..Q.....","Q.......",".......Q","...Q...."],["....Q...","......Q.","...Q....","Q.......","..Q.....",".......Q",".....Q..",".Q......"],["....Q...",".......Q","...Q....","Q.......","..Q.....",".....Q..",".Q......","......Q."],["....Q...",".......Q","...Q....","Q.......","......Q.",".Q......",".....Q..","..Q....."],[".....Q..","Q.......","....Q...",".Q......",".......Q","..Q.....","......Q.","...Q...."],[".....Q..",".Q......","......Q.","Q.......","..Q.....","....Q...",".......Q","...Q...."],[".....Q..",".Q......","......Q.","Q.......","...Q....",".......Q","....Q...","..Q....."],[".....Q..","..Q.....","Q.......","......Q.","....Q...",".......Q",".Q......","...Q...."],[".....Q..","..Q.....","Q.......",".......Q","...Q....",".Q......","......Q.","....Q..."],[".....Q..","..Q.....","Q.......",".......Q","....Q...",".Q......","...Q....","......Q."],[".....Q..","..Q.....","....Q...","......Q.","Q.......","...Q....",".Q......",".......Q"],[".....Q..","..Q.....","....Q...",".......Q","Q.......","...Q....",".Q......","......Q."],[".....Q..","..Q.....","......Q.",".Q......","...Q....",".......Q","Q.......","....Q..."],[".....Q..","..Q.....","......Q.",".Q......",".......Q","....Q...","Q.......","...Q...."],[".....Q..","..Q.....","......Q.","...Q....","Q.......",".......Q",".Q......","....Q..."],[".....Q..","...Q....","Q.......","....Q...",".......Q",".Q......","......Q.","..Q....."],[".....Q..","...Q....",".Q......",".......Q","....Q...","......Q.","Q.......","..Q....."],[".....Q..","...Q....","......Q.","Q.......","..Q.....","....Q...",".Q......",".......Q"],[".....Q..","...Q....","......Q.","Q.......",".......Q",".Q......","....Q...","..Q....."],[".....Q..",".......Q",".Q......","...Q....","Q.......","......Q.","....Q...","..Q....."],["......Q.","Q.......","..Q.....",".......Q",".....Q..","...Q....",".Q......","....Q..."],["......Q.",".Q......","...Q....","Q.......",".......Q","....Q...","..Q.....",".....Q.."],["......Q.",".Q......",".....Q..","..Q.....","Q.......","...Q....",".......Q","....Q..."],["......Q.","..Q.....","Q.......",".....Q..",".......Q","....Q...",".Q......","...Q...."],["......Q.","..Q.....",".......Q",".Q......","....Q...","Q.......",".....Q..","...Q...."],["......Q.","...Q....",".Q......","....Q...",".......Q","Q.......","..Q.....",".....Q.."],["......Q.","...Q....",".Q......",".......Q",".....Q..","Q.......","..Q.....","....Q..."],["......Q.","....Q...","..Q.....","Q.......",".....Q..",".......Q",".Q......","...Q...."],[".......Q",".Q......","...Q....","Q.......","......Q.","....Q...","..Q.....",".....Q.."],[".......Q",".Q......","....Q...","..Q.....","Q.......","......Q.","...Q....",".....Q.."],[".......Q","..Q.....","Q.......",".....Q..",".Q......","....Q...","......Q.","...Q...."],[".......Q","...Q....","Q.......","..Q.....",".....Q..",".Q......","......Q.","....Q..."]],\n [["Q........","..Q......",".....Q...",".......Q.",".Q.......","...Q.....","........Q","......Q..","....Q...."],["Q........","..Q......","......Q..",".Q.......",".......Q.","....Q....","........Q","...Q.....",".....Q..."],["Q........","..Q......",".......Q.",".....Q...","........Q",".Q.......","....Q....","......Q..","...Q....."],["Q........","...Q.....",".Q.......",".......Q.",".....Q...","........Q","..Q......","....Q....","......Q.."],["Q........","...Q.....",".....Q...","..Q......","........Q",".Q.......",".......Q.","....Q....","......Q.."],["Q........","...Q.....",".....Q...",".......Q.",".Q.......","....Q....","..Q......","........Q","......Q.."],["Q........","...Q.....","......Q..","..Q......",".......Q.",".Q.......","....Q....","........Q",".....Q..."],["Q........","...Q.....","......Q..","........Q",".Q.......","....Q....",".......Q.",".....Q...","..Q......"],["Q........","...Q.....",".......Q.","..Q......","........Q","......Q..","....Q....",".Q.......",".....Q..."],["Q........","....Q....",".Q.......",".....Q...","........Q","..Q......",".......Q.","...Q.....","......Q.."],["Q........","....Q....","......Q..",".Q.......",".....Q...","..Q......","........Q","...Q.....",".......Q."],["Q........","....Q....","......Q..","........Q","..Q......",".......Q.",".Q.......","...Q.....",".....Q..."],["Q........","....Q....","......Q..","........Q","...Q.....",".Q.......",".......Q.",".....Q...","..Q......"],["Q........","....Q....","........Q",".Q.......",".....Q...",".......Q.","..Q......","......Q..","...Q....."],["Q........","....Q....","........Q",".....Q...","...Q.....",".Q.......",".......Q.","..Q......","......Q.."],["Q........",".....Q...",".Q.......","........Q","......Q..","...Q.....",".......Q.","..Q......","....Q...."],["Q........",".....Q...","...Q.....",".Q.......","......Q..","........Q","..Q......","....Q....",".......Q."],["Q........",".....Q...","...Q.....",".Q.......",".......Q.","..Q......","........Q","......Q..","....Q...."],["Q........",".....Q...",".......Q.","..Q......","......Q..","...Q.....",".Q.......","........Q","....Q...."],["Q........",".....Q...",".......Q.","....Q....",".Q.......","...Q.....","........Q","......Q..","..Q......"],["Q........",".....Q...","........Q","....Q....",".Q.......",".......Q.","..Q......","......Q..","...Q....."],["Q........","......Q..","...Q.....",".....Q...","........Q",".Q.......","....Q....","..Q......",".......Q."],["Q........","......Q..","...Q.....",".......Q.","..Q......","....Q....","........Q",".Q.......",".....Q..."],["Q........","......Q..","...Q.....",".......Q.","..Q......","........Q",".....Q...",".Q.......","....Q...."],["Q........","......Q..","....Q....",".......Q.",".Q.......","........Q","..Q......",".....Q...","...Q....."],["Q........",".......Q.","...Q.....",".Q.......","......Q..","........Q",".....Q...","..Q......","....Q...."],["Q........",".......Q.","....Q....","..Q......",".....Q...","........Q",".Q.......","...Q.....","......Q.."],["Q........",".......Q.","....Q....","..Q......","........Q","......Q..",".Q.......","...Q.....",".....Q..."],[".Q.......","...Q.....","Q........","......Q..","........Q",".....Q...","..Q......","....Q....",".......Q."],[".Q.......","...Q.....","......Q..","Q........","..Q......","........Q",".....Q...",".......Q.","....Q...."],[".Q.......","...Q.....",".......Q.","..Q......","........Q",".....Q...","Q........","....Q....","......Q.."],[".Q.......","...Q.....","........Q","......Q..","..Q......","Q........",".....Q...",".......Q.","....Q...."],[".Q.......","...Q.....","........Q","......Q..","....Q....","..Q......","Q........",".....Q...",".......Q."],[".Q.......","....Q....","......Q..","Q........","..Q......",".......Q.",".....Q...","...Q.....","........Q"],[".Q.......","....Q....","......Q..","...Q.....","Q........","..Q......","........Q",".....Q...",".......Q."],[".Q.......","....Q....","......Q..","........Q","..Q......",".....Q...","...Q.....","Q........",".......Q."],[".Q.......","....Q....","......Q..","........Q","...Q.....",".......Q.","Q........","..Q......",".....Q..."],[".Q.......","....Q....",".......Q.","Q........","..Q......",".....Q...","........Q","......Q..","...Q....."],[".Q.......","....Q....",".......Q.","Q........","........Q",".....Q...","..Q......","......Q..","...Q....."],[".Q.......","....Q....",".......Q.",".....Q...","........Q","..Q......","Q........","...Q.....","......Q.."],[".Q.......","....Q....",".......Q.",".....Q...","........Q","..Q......","Q........","......Q..","...Q....."],[".Q.......","....Q....","........Q","...Q.....","Q........",".......Q.",".....Q...","..Q......","......Q.."],[".Q.......",".....Q...","Q........","..Q......","......Q..","........Q","...Q.....",".......Q.","....Q...."],[".Q.......",".....Q...","Q........","......Q..","...Q.....",".......Q.","..Q......","....Q....","........Q"],[".Q.......",".....Q...","Q........","......Q..","....Q....","..Q......","........Q","...Q.....",".......Q."],[".Q.......",".....Q...","Q........","........Q","....Q....",".......Q.","...Q.....","......Q..","..Q......"],[".Q.......",".....Q...","..Q......","Q........",".......Q.","...Q.....","........Q","......Q..","....Q...."],[".Q.......",".....Q...","........Q","..Q......","....Q....",".......Q.","...Q.....","Q........","......Q.."],[".Q.......","......Q..","....Q....","Q........","........Q","...Q.....",".....Q...",".......Q.","..Q......"],[".Q.......","......Q..","....Q....",".......Q.","Q........","...Q.....",".....Q...","..Q......","........Q"],[".Q.......","......Q..","........Q",".....Q...","..Q......","Q........","...Q.....",".......Q.","....Q...."],[".Q.......",".......Q.","Q........","...Q.....","......Q..","........Q",".....Q...","..Q......","....Q...."],[".Q.......",".......Q.","....Q....","..Q......","........Q",".....Q...","...Q.....","Q........","......Q.."],[".Q.......",".......Q.",".....Q...","........Q","..Q......","Q........","...Q.....","......Q..","....Q...."],[".Q.......","........Q","....Q....","..Q......",".......Q.","...Q.....","......Q..","Q........",".....Q..."],[".Q.......","........Q",".....Q...","..Q......","....Q....",".......Q.","Q........","...Q.....","......Q.."],[".Q.......","........Q",".....Q...","..Q......","......Q..","...Q.....","Q........",".......Q.","....Q...."],[".Q.......","........Q",".....Q...","...Q.....","......Q..","Q........","..Q......","....Q....",".......Q."],["..Q......","Q........","...Q.....","......Q..","........Q",".Q.......","....Q....",".......Q.",".....Q..."],["..Q......","Q........",".....Q...",".......Q.","....Q....",".Q.......","...Q.....","........Q","......Q.."],["..Q......","Q........","......Q..",".Q.......",".......Q.",".....Q...","...Q.....","........Q","....Q...."],["..Q......","Q........","......Q..","....Q....",".......Q.",".Q.......","...Q.....",".....Q...","........Q"],["..Q......","Q........",".......Q.","...Q.....","........Q","......Q..","....Q....",".Q.......",".....Q..."],["..Q......","Q........","........Q","......Q..","....Q....",".Q.......",".......Q.",".....Q...","...Q....."],["..Q......","....Q....",".Q.......",".......Q.","Q........","...Q.....","......Q..","........Q",".....Q..."],["..Q......","....Q....",".Q.......",".......Q.","Q........","......Q..","...Q.....",".....Q...","........Q"],["..Q......","....Q....","......Q..","Q........","...Q.....",".Q.......",".......Q.",".....Q...","........Q"],["..Q......","....Q....",".......Q.",".Q.......","........Q",".....Q...","Q........","......Q..","...Q....."],["..Q......","....Q....",".......Q.",".Q.......","........Q","......Q..","Q........","...Q.....",".....Q..."],["..Q......","....Q....","........Q",".Q.......","...Q.....","......Q..","Q........",".......Q.",".....Q..."],["..Q......","....Q....","........Q","...Q.....","Q........","......Q..",".Q.......",".....Q...",".......Q."],["..Q......",".....Q...",".Q.......","......Q..","Q........","...Q.....",".......Q.","....Q....","........Q"],["..Q......",".....Q...",".Q.......","........Q","....Q....","Q........",".......Q.","...Q.....","......Q.."],["..Q......",".....Q...",".......Q.","Q........","...Q.....","......Q..","....Q....",".Q.......","........Q"],["..Q......",".....Q...",".......Q.","Q........","....Q....","........Q",".Q.......","...Q.....","......Q.."],["..Q......",".....Q...",".......Q.",".Q.......","...Q.....","........Q","......Q..","....Q....","Q........"],["..Q......",".....Q...",".......Q.","....Q....","Q........","........Q","......Q..",".Q.......","...Q....."],["..Q......",".....Q...",".......Q.","....Q....",".Q.......","........Q","......Q..","...Q.....","Q........"],["..Q......",".....Q...","........Q","Q........",".......Q.","...Q.....",".Q.......","......Q..","....Q...."],["..Q......",".....Q...","........Q",".Q.......","....Q....","......Q..","...Q.....","Q........",".......Q."],["..Q......",".....Q...","........Q",".Q.......",".......Q.","Q........","...Q.....","......Q..","....Q...."],["..Q......",".....Q...","........Q","....Q....",".......Q.","Q........","...Q.....",".Q.......","......Q.."],["..Q......",".....Q...","........Q","......Q..","Q........","...Q.....",".Q.......","....Q....",".......Q."],["..Q......",".....Q...","........Q","......Q..",".Q.......","...Q.....",".......Q.","Q........","....Q...."],["..Q......",".....Q...","........Q","......Q..","...Q.....","Q........",".......Q.",".Q.......","....Q...."],["..Q......","......Q..",".Q.......","...Q.....",".......Q.","Q........","....Q....","........Q",".....Q..."],["..Q......","......Q..",".Q.......",".......Q.","....Q....","........Q","Q........",".....Q...","...Q....."],["..Q......","......Q..",".Q.......",".......Q.",".....Q...","...Q.....","Q........","....Q....","........Q"],["..Q......","......Q..","...Q.....",".Q.......","........Q","....Q....","Q........",".......Q.",".....Q..."],["..Q......","......Q..","...Q.....",".Q.......","........Q",".....Q...","Q........","....Q....",".......Q."],["..Q......","......Q..","...Q.....",".......Q.","....Q....","........Q","Q........",".....Q...",".Q......."],["..Q......","......Q..","........Q","Q........","....Q....",".Q.......",".......Q.",".....Q...","...Q....."],["..Q......","......Q..","........Q","...Q.....",".Q.......","....Q....",".......Q.",".....Q...","Q........"],["..Q......",".......Q.",".Q.......","...Q.....","........Q","......Q..","....Q....","Q........",".....Q..."],["..Q......",".......Q.","...Q.....","......Q..","........Q",".Q.......","....Q....","Q........",".....Q..."],["..Q......",".......Q.",".....Q...","Q........","........Q",".Q.......","....Q....","......Q..","...Q....."],["..Q......",".......Q.",".....Q...","...Q.....","........Q","Q........","....Q....","......Q..",".Q......."],["..Q......",".......Q.",".....Q...","........Q",".Q.......","....Q....","Q........","...Q.....","......Q.."],["..Q......","........Q",".Q.......","....Q....",".......Q.","Q........","......Q..","...Q.....",".....Q..."],["..Q......","........Q","...Q.....","Q........",".......Q.",".....Q...",".Q.......","......Q..","....Q...."],["..Q......","........Q","...Q.....",".Q.......",".......Q.",".....Q...","Q........","......Q..","....Q...."],["..Q......","........Q","...Q.....",".......Q.","....Q....",".Q.......",".....Q...","Q........","......Q.."],["..Q......","........Q",".....Q...",".Q.......","....Q....","......Q..","Q........","...Q.....",".......Q."],["..Q......","........Q",".....Q...","...Q.....","Q........","......Q..","....Q....",".Q.......",".......Q."],["..Q......","........Q",".....Q...",".......Q.",".Q.......","...Q.....","Q........","......Q..","....Q...."],["...Q.....","Q........","..Q......",".....Q...","........Q",".Q.......",".......Q.","....Q....","......Q.."],["...Q.....","Q........","....Q....",".Q.......","........Q","......Q..","..Q......",".......Q.",".....Q..."],["...Q.....","Q........","....Q....",".......Q.",".Q.......","......Q..","..Q......",".....Q...","........Q"],["...Q.....","Q........","....Q....","........Q",".Q.......",".....Q...",".......Q.","..Q......","......Q.."],["...Q.....","Q........","......Q..","........Q",".Q.......",".....Q...",".......Q.","..Q......","....Q...."],["...Q.....","Q........","........Q",".....Q...","..Q......","......Q..",".Q.......",".......Q.","....Q...."],["...Q.....",".Q.......","....Q....",".......Q.","Q........","..Q......",".....Q...","........Q","......Q.."],["...Q.....",".Q.......","......Q..","..Q......","Q........",".......Q.","....Q....","........Q",".....Q..."],["...Q.....",".Q.......","......Q..","........Q","Q........","....Q....",".......Q.",".....Q...","..Q......"],["...Q.....",".Q.......","......Q..","........Q","Q........",".......Q.","....Q....","..Q......",".....Q..."],["...Q.....",".Q.......",".......Q.","..Q......","........Q","......Q..","....Q....","Q........",".....Q..."],["...Q.....",".Q.......","........Q","..Q......",".....Q...",".......Q.","Q........","....Q....","......Q.."],["...Q.....",".Q.......","........Q","....Q....","Q........",".......Q.",".....Q...","..Q......","......Q.."],["...Q.....",".....Q...","Q........","....Q....",".Q.......",".......Q.","..Q......","......Q..","........Q"],["...Q.....",".....Q...","Q........","........Q","....Q....",".......Q.",".Q.......","......Q..","..Q......"],["...Q.....",".....Q...","Q........","........Q","......Q..","..Q......",".......Q.",".Q.......","....Q...."],["...Q.....",".....Q...","..Q......","........Q",".Q.......","....Q....",".......Q.","Q........","......Q.."],["...Q.....",".....Q...","..Q......","........Q",".Q.......",".......Q.","....Q....","......Q..","Q........"],["...Q.....",".....Q...","..Q......","........Q","......Q..","Q........",".......Q.",".Q.......","....Q...."],["...Q.....",".....Q...",".......Q.",".Q.......","....Q....","Q........","........Q","......Q..","..Q......"],["...Q.....",".....Q...",".......Q.",".Q.......","....Q....","......Q..","........Q","Q........","..Q......"],["...Q.....",".....Q...",".......Q.",".Q.......","......Q..","Q........","..Q......","....Q....","........Q"],["...Q.....",".....Q...",".......Q.","..Q......","Q........","......Q..","....Q....",".Q.......","........Q"],["...Q.....",".....Q...","........Q","..Q......","Q........",".......Q.",".Q.......","....Q....","......Q.."],["...Q.....","......Q..","Q........","..Q......","........Q",".....Q...",".......Q.","....Q....",".Q......."],["...Q.....","......Q..","Q........",".....Q...","........Q",".Q.......",".......Q.","....Q....","..Q......"],["...Q.....","......Q..","Q........",".......Q.","....Q....",".Q.......","........Q","..Q......",".....Q..."],["...Q.....","......Q..","..Q......",".....Q...","........Q","Q........",".......Q.","....Q....",".Q......."],["...Q.....","......Q..","..Q......",".......Q.",".Q.......","....Q....","........Q",".....Q...","Q........"],["...Q.....","......Q..","..Q......",".......Q.",".....Q...","Q........","........Q",".Q.......","....Q...."],["...Q.....","......Q..","..Q......",".......Q.",".....Q...",".Q.......","........Q","....Q....","Q........"],["...Q.....","......Q..","....Q....",".Q.......","........Q","Q........","..Q......",".......Q.",".....Q..."],["...Q.....","......Q..","....Q....",".Q.......","........Q","Q........",".....Q...",".......Q.","..Q......"],["...Q.....","......Q..","....Q....",".Q.......","........Q",".....Q...",".......Q.","..Q......","Q........"],["...Q.....","......Q..","........Q",".Q.......","....Q....",".......Q.","Q........","..Q......",".....Q..."],["...Q.....","......Q..","........Q",".Q.......",".....Q...","Q........","..Q......","....Q....",".......Q."],["...Q.....","......Q..","........Q",".....Q...","..Q......","Q........",".......Q.","....Q....",".Q......."],["...Q.....",".......Q.","Q........","....Q....","......Q..",".Q.......",".....Q...","..Q......","........Q"],["...Q.....",".......Q.","....Q....","..Q......","Q........",".....Q...",".Q.......","........Q","......Q.."],["...Q.....",".......Q.","....Q....","..Q......","Q........","......Q..",".Q.......",".....Q...","........Q"],["...Q.....","........Q","..Q......",".....Q...",".Q.......","......Q..","....Q....","Q........",".......Q."],["...Q.....","........Q","....Q....","..Q......","Q........",".....Q...",".......Q.",".Q.......","......Q.."],["...Q.....","........Q","....Q....","..Q......","Q........","......Q..",".Q.......",".......Q.",".....Q..."],["...Q.....","........Q","....Q....",".......Q.","Q........","..Q......",".....Q...",".Q.......","......Q.."],["....Q....","Q........",".....Q...","...Q.....",".Q.......",".......Q.","..Q......","........Q","......Q.."],["....Q....","Q........",".......Q.","...Q.....",".Q.......","......Q..","........Q",".....Q...","..Q......"],["....Q....","Q........",".......Q.",".....Q...","..Q......","......Q..",".Q.......","...Q.....","........Q"],["....Q....",".Q.......","...Q.....","Q........","......Q..","........Q","..Q......",".....Q...",".......Q."],["....Q....",".Q.......","...Q.....","........Q","......Q..","..Q......","Q........",".....Q...",".......Q."],["....Q....",".Q.......",".....Q...","Q........","..Q......","......Q..","........Q","...Q.....",".......Q."],["....Q....",".Q.......",".....Q...","........Q","..Q......",".......Q.","...Q.....","......Q..","Q........"],["....Q....",".Q.......",".....Q...","........Q","......Q..","...Q.....","Q........","..Q......",".......Q."],["....Q....",".Q.......",".......Q.","Q........","...Q.....","......Q..","........Q",".....Q...","..Q......"],["....Q....",".Q.......",".......Q.","Q........","......Q..","........Q","..Q......",".....Q...","...Q....."],["....Q....",".Q.......",".......Q.","..Q......","......Q..","...Q.....","Q........","........Q",".....Q..."],["....Q....",".Q.......",".......Q.","..Q......","......Q..","........Q","Q........",".....Q...","...Q....."],["....Q....",".Q.......","........Q","Q........",".....Q...",".......Q.","..Q......","......Q..","...Q....."],["....Q....",".Q.......","........Q",".....Q...","..Q......","......Q..","...Q.....","Q........",".......Q."],["....Q....","..Q......","Q........",".....Q...",".Q.......","........Q","......Q..","...Q.....",".......Q."],["....Q....","..Q......","Q........",".....Q...",".......Q.",".Q.......","...Q.....","......Q..","........Q"],["....Q....","..Q......","Q........","......Q..",".Q.......",".......Q.",".....Q...","...Q.....","........Q"],["....Q....","..Q......",".....Q...","........Q",".Q.......",".......Q.","Q........","...Q.....","......Q.."],["....Q....","..Q......",".....Q...","........Q","......Q..","Q........","...Q.....",".Q.......",".......Q."],["....Q....","..Q......",".....Q...","........Q","......Q..",".Q.......","...Q.....",".......Q.","Q........"],["....Q....","..Q......",".....Q...","........Q","......Q..","...Q.....","Q........",".......Q.",".Q......."],["....Q....","..Q......",".......Q.","...Q.....",".Q.......","........Q",".....Q...","Q........","......Q.."],["....Q....","..Q......",".......Q.","...Q.....","......Q..","........Q",".Q.......",".....Q...","Q........"],["....Q....","..Q......",".......Q.",".....Q...",".Q.......","........Q","Q........","...Q.....","......Q.."],["....Q....","..Q......",".......Q.",".....Q...",".Q.......","........Q","......Q..","Q........","...Q....."],["....Q....","..Q......","........Q","...Q.....",".Q.......",".......Q.",".....Q...","Q........","......Q.."],["....Q....","..Q......","........Q",".....Q...",".......Q.",".Q.......","...Q.....","Q........","......Q.."],["....Q....","......Q..","Q........","...Q.....",".Q.......",".......Q.",".....Q...","........Q","..Q......"],["....Q....","......Q..","Q........",".....Q...",".......Q.",".Q.......","...Q.....","........Q","..Q......"],["....Q....","......Q..",".Q.......","...Q.....",".......Q.","Q........","..Q......","........Q",".....Q..."],["....Q....","......Q..",".Q.......","...Q.....",".......Q.","Q........","........Q",".....Q...","..Q......"],["....Q....","......Q..",".Q.......",".....Q...","..Q......","Q........",".......Q.","...Q.....","........Q"],["....Q....","......Q..",".Q.......",".....Q...",".......Q.","Q........","...Q.....","........Q","..Q......"],["....Q....","......Q..","...Q.....","Q........","..Q......",".....Q...","........Q",".Q.......",".......Q."],["....Q....","......Q..","...Q.....","Q........","..Q......",".......Q.",".....Q...",".Q.......","........Q"],["....Q....","......Q..","...Q.....","Q........","..Q......","........Q",".....Q...",".......Q.",".Q......."],["....Q....","......Q..","...Q.....","Q........",".......Q.",".Q.......","........Q",".....Q...","..Q......"],["....Q....","......Q..","........Q","..Q......",".......Q.",".Q.......","...Q.....",".....Q...","Q........"],["....Q....","......Q..","........Q","...Q.....",".Q.......",".......Q.",".....Q...","..Q......","Q........"],["....Q....","......Q..","........Q","...Q.....",".......Q.","Q........","..Q......",".....Q...",".Q......."],["....Q....",".......Q.","Q........","...Q.....","......Q..","..Q......",".....Q...","........Q",".Q......."],["....Q....",".......Q.","Q........","........Q","...Q.....",".Q.......","......Q..","..Q......",".....Q..."],["....Q....",".......Q.",".Q.......","......Q..","..Q......","Q........","........Q","...Q.....",".....Q..."],["....Q....",".......Q.",".Q.......","......Q..","..Q......",".....Q...","........Q","Q........","...Q....."],["....Q....",".......Q.",".Q.......","........Q","..Q......","Q........","......Q..","...Q.....",".....Q..."],["....Q....",".......Q.",".Q.......","........Q",".....Q...","..Q......","Q........","...Q.....","......Q.."],["....Q....",".......Q.","...Q.....","Q........","..Q......",".....Q...","........Q","......Q..",".Q......."],["....Q....",".......Q.","...Q.....","Q........","......Q..",".Q.......",".....Q...","..Q......","........Q"],["....Q....",".......Q.","...Q.....","........Q","......Q..","..Q......","Q........",".....Q...",".Q......."],["....Q....",".......Q.",".....Q...","Q........","..Q......","......Q..","........Q","...Q.....",".Q......."],["....Q....",".......Q.",".....Q...","........Q","..Q......","Q........","......Q..","...Q.....",".Q......."],["....Q....","........Q",".Q.......","...Q.....","......Q..","..Q......",".......Q.",".....Q...","Q........"],["....Q....","........Q",".Q.......",".....Q...",".......Q.","..Q......","Q........","...Q.....","......Q.."],["....Q....","........Q","...Q.....",".....Q...",".......Q.",".Q.......","......Q..","Q........","..Q......"],[".....Q...","Q........","....Q....",".Q.......","........Q","......Q..","...Q.....",".......Q.","..Q......"],[".....Q...","Q........","....Q....","......Q..","........Q","..Q......",".......Q.",".Q.......","...Q....."],[".....Q...","Q........","....Q....","......Q..","........Q","...Q.....",".Q.......",".......Q.","..Q......"],[".....Q...","Q........","......Q..","...Q.....",".......Q.","..Q......","....Q....","........Q",".Q......."],[".....Q...",".Q.......","....Q....","......Q..","........Q","..Q......",".......Q.","...Q.....","Q........"],[".....Q...",".Q.......","....Q....","......Q..","........Q","...Q.....",".......Q.","Q........","..Q......"],[".....Q...",".Q.......","........Q","....Q....","..Q......",".......Q.","...Q.....","......Q..","Q........"],[".....Q...","..Q......","Q........","...Q.....","......Q..","........Q",".Q.......","....Q....",".......Q."],[".....Q...","..Q......","Q........",".......Q.","...Q.....","........Q","......Q..","....Q....",".Q......."],[".....Q...","..Q......","Q........",".......Q.","....Q....",".Q.......","........Q","......Q..","...Q....."],[".....Q...","..Q......","....Q....",".......Q.","Q........","...Q.....",".Q.......","......Q..","........Q"],[".....Q...","..Q......","....Q....",".......Q.","Q........","........Q","...Q.....",".Q.......","......Q.."],[".....Q...","..Q......","....Q....",".......Q.","Q........","........Q","......Q..",".Q.......","...Q....."],[".....Q...","..Q......","......Q..",".Q.......","...Q.....",".......Q.","Q........","....Q....","........Q"],[".....Q...","..Q......","......Q..",".Q.......","...Q.....","........Q","Q........",".......Q.","....Q...."],[".....Q...","..Q......","......Q..",".Q.......",".......Q.","....Q....","Q........","...Q.....","........Q"],[".....Q...","..Q......","......Q..","...Q.....","Q........","........Q",".Q.......","....Q....",".......Q."],[".....Q...","..Q......","........Q",".Q.......","....Q....",".......Q.","Q........","......Q..","...Q....."],[".....Q...","..Q......","........Q","...Q.....","Q........",".......Q.",".Q.......","....Q....","......Q.."],[".....Q...","..Q......","........Q","......Q..","Q........","...Q.....",".Q.......","....Q....",".......Q."],[".....Q...","...Q.....","Q........","......Q..","........Q",".Q.......",".......Q.","....Q....","..Q......"],[".....Q...","...Q.....",".Q.......","......Q..","........Q","..Q......","....Q....",".......Q.","Q........"],[".....Q...","...Q.....",".Q.......",".......Q.","..Q......","........Q","......Q..","....Q....","Q........"],[".....Q...","...Q.....",".Q.......",".......Q.","....Q....","..Q......","Q........","........Q","......Q.."],[".....Q...","...Q.....",".Q.......",".......Q.","....Q....","........Q","Q........","..Q......","......Q.."],[".....Q...","...Q.....","......Q..","Q........","..Q......","........Q",".Q.......",".......Q.","....Q...."],[".....Q...","...Q.....","......Q..","Q........",".......Q.",".Q.......","....Q....","..Q......","........Q"],[".....Q...","...Q.....","......Q..","Q........",".......Q.","....Q....",".Q.......","........Q","..Q......"],[".....Q...","...Q.....","........Q","Q........","..Q......","......Q..",".Q.......",".......Q.","....Q...."],[".....Q...","...Q.....","........Q","Q........","....Q....",".Q.......",".......Q.","..Q......","......Q.."],[".....Q...","...Q.....","........Q","....Q....",".......Q.",".Q.......","......Q..","..Q......","Q........"],[".....Q...",".......Q.","Q........","....Q....","........Q",".Q.......","...Q.....","......Q..","..Q......"],[".....Q...",".......Q.","Q........","......Q..","...Q.....",".Q.......","........Q","....Q....","..Q......"],[".....Q...",".......Q.",".Q.......","......Q..","Q........","..Q......","....Q....","........Q","...Q....."],[".....Q...",".......Q.","..Q......","Q........","........Q",".Q.......","....Q....","......Q..","...Q....."],[".....Q...",".......Q.","..Q......","Q........","........Q","....Q....",".Q.......","...Q.....","......Q.."],[".....Q...",".......Q.","..Q......","......Q..","........Q",".Q.......","....Q....","Q........","...Q....."],[".....Q...",".......Q.","....Q....",".Q.......","........Q","......Q..","...Q.....","Q........","..Q......"],[".....Q...","........Q","Q........","...Q.....","......Q..","..Q......",".......Q.",".Q.......","....Q...."],[".....Q...","........Q","..Q......","Q........",".......Q.","...Q.....",".Q.......","......Q..","....Q...."],[".....Q...","........Q","....Q....","Q........",".......Q.","...Q.....",".Q.......","......Q..","..Q......"],[".....Q...","........Q","....Q....",".Q.......",".......Q.","..Q......","......Q..","...Q.....","Q........"],[".....Q...","........Q","....Q....",".......Q.","Q........","..Q......","......Q..",".Q.......","...Q....."],[".....Q...","........Q","......Q..","...Q.....","Q........",".......Q.",".Q.......","....Q....","..Q......"],["......Q..","Q........","...Q.....",".Q.......",".......Q.",".....Q...","........Q","..Q......","....Q...."],["......Q..","Q........","...Q.....",".....Q...","........Q","..Q......","....Q....",".......Q.",".Q......."],["......Q..","Q........","...Q.....",".......Q.","....Q....","..Q......","........Q",".....Q...",".Q......."],["......Q..","Q........",".....Q...",".Q.......","....Q....",".......Q.","...Q.....","........Q","..Q......"],["......Q..","Q........",".....Q...",".......Q.",".Q.......","...Q.....","........Q","..Q......","....Q...."],["......Q..","Q........",".....Q...","........Q",".Q.......","...Q.....",".......Q.","..Q......","....Q...."],["......Q..","Q........",".......Q.","....Q....",".Q.......","........Q","..Q......",".....Q...","...Q....."],["......Q..",".Q.......","...Q.....","Q........",".......Q.","....Q....","........Q",".....Q...","..Q......"],["......Q..",".Q.......","...Q.....",".....Q...","Q........","........Q","....Q....","..Q......",".......Q."],["......Q..",".Q.......","...Q.....","........Q","Q........",".......Q.","....Q....","..Q......",".....Q..."],["......Q..",".Q.......",".....Q...","..Q......","Q........",".......Q.","....Q....","........Q","...Q....."],["......Q..",".Q.......",".......Q.",".....Q...","Q........","..Q......","....Q....","........Q","...Q....."],["......Q..","..Q......","Q........",".....Q...",".......Q.","....Q....",".Q.......","...Q.....","........Q"],["......Q..","..Q......","Q........","........Q","....Q....",".......Q.",".Q.......","...Q.....",".....Q..."],["......Q..","..Q......",".....Q...",".Q.......","....Q....","Q........","........Q","...Q.....",".......Q."],["......Q..","..Q......",".....Q...",".......Q.","Q........","...Q.....","........Q","....Q....",".Q......."],["......Q..","..Q......",".....Q...",".......Q.","Q........","....Q....","........Q",".Q.......","...Q....."],["......Q..","..Q......",".......Q.",".Q.......","...Q.....",".....Q...","........Q","....Q....","Q........"],["......Q..","..Q......",".......Q.",".Q.......","....Q....","Q........","........Q","...Q.....",".....Q..."],["......Q..","..Q......",".......Q.",".....Q...",".Q.......","........Q","....Q....","Q........","...Q....."],["......Q..","...Q.....","Q........","..Q......",".....Q...","........Q",".Q.......",".......Q.","....Q...."],["......Q..","...Q.....","Q........","..Q......",".......Q.",".....Q...",".Q.......","........Q","....Q...."],["......Q..","...Q.....","Q........","..Q......","........Q",".....Q...",".......Q.","....Q....",".Q......."],["......Q..","...Q.....","Q........","....Q....",".Q.......","........Q",".....Q...",".......Q.","..Q......"],["......Q..","...Q.....","Q........",".......Q.",".Q.......","........Q",".....Q...","..Q......","....Q...."],["......Q..","...Q.....","Q........",".......Q.","....Q....","..Q......",".....Q...","........Q",".Q......."],["......Q..","...Q.....","Q........","........Q",".Q.......",".....Q...",".......Q.","..Q......","....Q...."],["......Q..","...Q.....",".Q.......","....Q....",".......Q.","Q........","..Q......",".....Q...","........Q"],["......Q..","...Q.....",".Q.......","....Q....","........Q","Q........","..Q......",".......Q.",".....Q..."],["......Q..","...Q.....",".Q.......",".......Q.",".....Q...","Q........","..Q......","....Q....","........Q"],["......Q..","...Q.....",".Q.......","........Q","....Q....","Q........",".......Q.",".....Q...","..Q......"],["......Q..","...Q.....",".Q.......","........Q",".....Q...","..Q......","....Q....",".......Q.","Q........"],["......Q..","...Q.....",".......Q.","Q........","....Q....","........Q",".Q.......",".....Q...","..Q......"],["......Q..","...Q.....",".......Q.","..Q......","........Q",".....Q...",".Q.......","....Q....","Q........"],["......Q..","....Q....","Q........",".....Q...","........Q","..Q......",".......Q.","...Q.....",".Q......."],["......Q..","....Q....","Q........",".......Q.",".....Q...","..Q......","........Q",".Q.......","...Q....."],["......Q..","....Q....",".Q.......",".......Q.","Q........","..Q......","........Q",".....Q...","...Q....."],["......Q..","....Q....",".Q.......",".......Q.","Q........","...Q.....","........Q","..Q......",".....Q..."],["......Q..","....Q....","..Q......","........Q",".....Q...",".......Q.",".Q.......","...Q.....","Q........"],["......Q..","....Q....",".......Q.",".Q.......","........Q","..Q......",".....Q...","...Q.....","Q........"],["......Q..","....Q....",".......Q.",".Q.......","........Q",".....Q...","..Q......","Q........","...Q....."],["......Q..","........Q","Q........","..Q......","....Q....",".......Q.",".Q.......","...Q.....",".....Q..."],["......Q..","........Q",".Q.......",".....Q...","Q........","..Q......","....Q....",".......Q.","...Q....."],["......Q..","........Q","..Q......","....Q....",".Q.......",".......Q.",".....Q...","...Q.....","Q........"],["......Q..","........Q","..Q......",".......Q.",".Q.......","...Q.....",".....Q...","Q........","....Q...."],["......Q..","........Q","...Q.....",".Q.......","....Q....",".......Q.",".....Q...","Q........","..Q......"],["......Q..","........Q",".....Q...","..Q......","Q........",".......Q.","....Q....",".Q.......","...Q....."],[".......Q.","Q........","...Q.....",".....Q...","..Q......","........Q","......Q..","....Q....",".Q......."],[".......Q.","Q........","...Q.....","......Q..","..Q......",".....Q...","........Q",".Q.......","....Q...."],[".......Q.","Q........","...Q.....","......Q..","....Q....",".Q.......","........Q",".....Q...","..Q......"],[".......Q.","Q........","....Q....","......Q..",".Q.......",".....Q...","..Q......","........Q","...Q....."],[".......Q.",".Q.......","...Q.....","Q........","......Q..","........Q",".....Q...","..Q......","....Q...."],[".......Q.",".Q.......","....Q....","......Q..","Q........","...Q.....",".....Q...","........Q","..Q......"],[".......Q.",".Q.......","........Q",".....Q...","..Q......","Q........","...Q.....","......Q..","....Q...."],[".......Q.","..Q......","Q........","...Q.....","......Q..","........Q",".....Q...",".Q.......","....Q...."],[".......Q.","..Q......","....Q....",".Q.......","........Q",".....Q...","...Q.....","......Q..","Q........"],[".......Q.","..Q......","....Q....","........Q","Q........",".....Q...","...Q.....",".Q.......","......Q.."],[".......Q.","...Q.....","Q........","......Q..","....Q....",".Q.......",".....Q...","........Q","..Q......"],[".......Q.","...Q.....","......Q..","........Q",".Q.......",".....Q...","Q........","..Q......","....Q...."],[".......Q.","...Q.....","........Q","Q........","....Q....",".Q.......",".....Q...","..Q......","......Q.."],[".......Q.","...Q.....","........Q","..Q......","....Q....","......Q..","Q........",".....Q...",".Q......."],[".......Q.","...Q.....","........Q","..Q......",".....Q...",".Q.......","......Q..","....Q....","Q........"],[".......Q.","...Q.....","........Q","......Q..","..Q......","Q........",".....Q...",".Q.......","....Q...."],[".......Q.","....Q....","Q........",".....Q...","........Q",".Q.......","...Q.....","......Q..","..Q......"],[".......Q.","....Q....",".Q.......","...Q.....","Q........","......Q..","........Q","..Q......",".....Q..."],[".......Q.","....Q....",".Q.......","...Q.....","Q........","......Q..","........Q",".....Q...","..Q......"],[".......Q.","....Q....",".Q.......","........Q","Q........","...Q.....","......Q..","..Q......",".....Q..."],[".......Q.","....Q....",".Q.......","........Q","......Q..","...Q.....","Q........","..Q......",".....Q..."],[".......Q.","....Q....","..Q......","Q........",".....Q...",".Q.......","........Q","......Q..","...Q....."],[".......Q.","....Q....","..Q......","Q........","......Q..","...Q.....",".....Q...","........Q",".Q......."],[".......Q.","....Q....","..Q......",".....Q...","........Q","......Q..","Q........","...Q.....",".Q......."],[".......Q.","....Q....","..Q......","........Q","......Q..",".Q.......","...Q.....",".....Q...","Q........"],[".......Q.",".....Q...","Q........","..Q......","....Q....","......Q..","........Q","...Q.....",".Q......."],[".......Q.",".....Q...","Q........","..Q......","......Q..","........Q","...Q.....",".Q.......","....Q...."],[".......Q.",".....Q...",".Q.......","......Q..","Q........","...Q.....","........Q","....Q....","..Q......"],[".......Q.",".....Q...","..Q......","........Q","......Q..","Q........","...Q.....",".Q.......","....Q...."],[".......Q.",".....Q...","........Q","..Q......","Q........","...Q.....","......Q..","....Q....",".Q......."],["........Q",".Q.......","....Q....","......Q..","Q........","..Q......",".......Q.",".....Q...","...Q....."],["........Q",".Q.......","....Q....","......Q..","...Q.....","Q........",".......Q.",".....Q...","..Q......"],["........Q",".Q.......",".....Q...",".......Q.","..Q......","Q........","...Q.....","......Q..","....Q...."],["........Q","..Q......","....Q....",".Q.......",".......Q.","Q........","......Q..","...Q.....",".....Q..."],["........Q","..Q......",".....Q...",".Q.......","......Q..","Q........","...Q.....",".......Q.","....Q...."],["........Q","..Q......",".....Q...",".Q.......","......Q..","....Q....","Q........",".......Q.","...Q....."],["........Q","..Q......",".....Q...","...Q.....","Q........",".......Q.","....Q....","......Q..",".Q......."],["........Q","...Q.....","Q........","....Q....",".......Q.",".Q.......","......Q..","..Q......",".....Q..."],["........Q","...Q.....",".Q.......","....Q....",".......Q.",".....Q...","Q........","..Q......","......Q.."],["........Q","...Q.....",".Q.......","......Q..","..Q......",".....Q...",".......Q.","Q........","....Q...."],["........Q","...Q.....",".....Q...",".......Q.",".Q.......","......Q..","Q........","..Q......","....Q...."],["........Q","...Q.....",".....Q...",".......Q.","..Q......","Q........","......Q..","....Q....",".Q......."],["........Q","...Q.....",".......Q.","Q........","..Q......",".....Q...",".Q.......","......Q..","....Q...."],["........Q","....Q....","Q........","...Q.....",".....Q...",".......Q.",".Q.......","......Q..","..Q......"],["........Q","....Q....","Q........",".......Q.","...Q.....",".Q.......","......Q..","..Q......",".....Q..."],["........Q","....Q....","..Q......","Q........",".....Q...",".......Q.",".Q.......","...Q.....","......Q.."],["........Q","....Q....","..Q......","Q........","......Q..",".Q.......",".......Q.",".....Q...","...Q....."],["........Q","....Q....","..Q......",".......Q.","...Q.....","......Q..","Q........",".....Q...",".Q......."],["........Q","....Q....",".......Q.","...Q.....","Q........","......Q..",".Q.......",".....Q...","..Q......"],["........Q",".....Q...",".Q.......","......Q..","Q........","..Q......","....Q....",".......Q.","...Q....."],["........Q",".....Q...","..Q......","Q........",".......Q.","....Q....",".Q.......","...Q.....","......Q.."],["........Q",".....Q...","..Q......","......Q..",".Q.......",".......Q.","....Q....","Q........","...Q....."],["........Q",".....Q...","...Q.....",".Q.......",".......Q.","....Q....","......Q..","Q........","..Q......"],["........Q",".....Q...","...Q.....","......Q..","Q........",".......Q.",".Q.......","....Q....","..Q......"],["........Q",".....Q...",".......Q.",".Q.......","...Q.....","Q........","......Q..","....Q....","..Q......"],["........Q","......Q..",".Q.......","...Q.....","Q........",".......Q.","....Q....","..Q......",".....Q..."],["........Q","......Q..","..Q......",".......Q.",".Q.......","....Q....","Q........",".....Q...","...Q....."],["........Q","......Q..","...Q.....",".Q.......",".......Q.",".....Q...","Q........","..Q......","....Q...."]]\n ][n]\n         #return [0, 1, 0, 0, 2, 10, 4, 40, 92, 352, 724, 2680,14200, 73712, 365596][n]\n         return self.dfs(deque(), 0, n)\n     def dfs(self, points, x,n):\n         res = []\n         # print(x, n, points)\n         for j in range(n):\n             n_pos = (x, j)\n             if passAll(n_pos, points):\n                 points.append(j)\n                 if len(points) == n:\n                     res.append(reconstruct(points, n))\n                 else:\n                     res += self.dfs(points, x + 1, n)\n                 points.pop()\n         return res\n             \n             \n         \n \n # class Solution:\n #     def totalNQueens(self, n):\n #         """\n #         :type n: int\n #         :rtype: int\n #         """\n #         return self.dfs([], 0, n)\n #     def dfs(self, points, x,n):\n #         res = []\n #         # print(x, n, points)\n #         for j in range(n):\n #             n_pos = (x, j)\n #             if passAll(n_pos, points):\n #                 n_points = deepcopy(points)\n #                 n_points.append(n_pos)\n #                 if len(n_points) == n - 1:\n #                     res.append(reconstruct(n_points, n))\n #                 else:\n #                     res += self.dfs(n_points, x + 1, n)\n #         return res\n             \n             \n         
# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def pathSum(self, root, sum):\n         """\n         :type root: TreeNode\n         :type sum: int\n         :rtype: List[List[int]]\n         """\n         ans = []\n         buffer = []\n         self.helper(ans, root, sum, buffer)\n         return ans\n     def helper(self, ans, root, sum, buffer):\n         """\n         recursive method travesal to the bottom of the tree\n         and add the path that path's sum equals the given sum into the result\n         \n         :type ans: List[List[int]]\n         :type root: TreeNode\n         :type sum: int\n         :type buffer: List[int]\n         :rtype None\n         """\n         if not root: return\n         sum -= root.val\n         buffer.append(root.val)\n         if not (root.left or root.right) and sum == 0: ans.append([x for x in buffer])\n         self.helper(ans, root.left, sum, buffer)\n         self.helper(ans, root.right, sum, buffer)\n         buffer.pop()
class Solution:\n     def isValidSudoku(self, board):\n         """\n         :type board: List[List[str]]\n         :rtype: bool\n         """\n         dic_row = [{},{},{},{},{},{},{},{},{}]\n         dic_col = [{},{},{},{},{},{},{},{},{}]\n         dic_box = [{},{},{},{},{},{},{},{},{}]\n \n         for i in range(len(board)):\n             for j in range(len(board)):\n                 num = board[i][j]\n                 if num == ".":\n                     continue\n                 if num not in dic_row[i] and num not in dic_col[j] and num not in dic_box[3*(i//3)+(j//3)]:\n                     dic_row[i][num] = 1\n                     dic_col[j][num] = 1\n                     dic_box[3*(i//3)+(j//3)][num] = 1\n                 else:\n                     return False\n \n         return True\n             \n
# Definition for singly-linked list.\n # class ListNode(object):\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution(object):\n     def splitListToParts(self, root, k):\n         """\n         :type root: ListNode\n         :type k: int\n         :rtype: List[ListNode]\n         """\n         if not root:\n             return [None for _ in range(k)]\n         \n         if k == 1:\n             return [root]\n         \n         count_nodes = 1\n         start = root\n         while start.next:\n             start = start.next\n             count_nodes += 1\n         \n         buckets = [0 for _ in range(k)]\n         for i in range(len(buckets)):\n             import math\n             \n             curr = math.ceil(count_nodes / k)\n             count_nodes -= curr\n             k -= 1\n             buckets[i] = curr\n             \n             if count_nodes == 0:\n                 break\n \n         def split_ll(root, result, index, buckets):\n             if index == len(buckets):\n                 return\n             if not root:\n                 result.append(None)\n                 return split_ll(root, result, index + 1, buckets)\n             \n             end = root\n             curr_count = 1\n             while curr_count < buckets[index]:\n                 end = end.next\n                 curr_count += 1\n             \n             start = root\n             root = end.next\n             end.next = None\n             \n             result.append(start)\n             return split_ll(root, result, index + 1, buckets)\n         \n         result = []\n         split_ll(root, result, 0, buckets)\n         return result\n             \n
class Solution:\n     def validTicTacToe(self, board):\n         """\n         :type board: List[str]\n         :rtype: bool\n         """\n         def win(board,w):\n             for i in range(3):\n                 if board[i] == w*3:\n                     return True\n             for i in range(3):\n                 if board[0][i] == w and board[1][i] == w and board[2][i] == w:\n                     return True\n             sign = True\n             for i in range(3):\n                 if board[i][i] != w:\n                     sign = False\n             if sign:\n                 return True\n             \n             sign = True\n             for i in range(3):\n                 if board[i][2-i] != w:\n                     sign = False\n             if sign:\n                 return True\n         \n         Xnum = 0\n         Onum = 0\n         for ss in board:\n             for s in ss:\n                 if s == 'X':\n                     Xnum += 1\n                 if s == 'O':\n                     Onum += 1\n         if win(board,'X'):\n             if Xnum == Onum + 1:\n                 return True\n             else:\n                 return False\n         if win(board,"O"):\n             if Xnum == Onum:\n                 return True\n             else:\n                 return False\n         if Xnum == Onum or Xnum == Onum + 1:\n             return True\n         else:\n             return False\n
from heapq import heappush, heappop\n \n class Solution:\n     def kSmallestPairs(self, nums1, nums2, k):\n         """\n         :type nums1: List[int]\n         :type nums2: List[int]\n         :type k: int\n         :rtype: List[List[int]]\n         """\n         heap = []\n         def push(i, j):\n             if i < len(nums1) and j < len(nums2):\n                 heappush(heap, (nums1[i] + nums2[j], i, j))\n         push(0,0)\n         res = []\n         while heap and len(res) < k:\n             _, i, j = heappop(heap)\n             res.append([nums1[i], nums2[j]])\n             push(i, j+1)\n             if j == 0:\n                 push(i+1, 0)\n         return res
from itertools import accumulate\nclass Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        xors = [0]\n        for a in arr:\n            xors.append(a^xors[-1])\n        return [xors[i]^xors[j+1] for i,j in queries]\n    \n
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        ans, to_delete = [], set(to_delete)\n        def search(root, is_root):\n            if not root: return None\n            root_deleted = root.val in to_delete\n            if is_root and not root_deleted:\n                ans.append(root)\n            root.left = search(root.left, root_deleted)\n            root.right = search(root.right, root_deleted)\n            return None if root_deleted else root\n        search(root, True)\n        return ans
class Solution:\n    def shortestBridge(self, A: List[List[int]]) -> int:\n        m, n = len(A), len(A[0])\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        queue = deque()\n        boundary = set()\n        found = False\n        for i in range(m):\n            for j in range(n):\n                if A[i][j] == 1:\n                    A[i][j] = 2\n                    queue.append((i, j))\n                    while queue:\n                        ci, cj = queue.popleft()\n                        for di, dj in dirs:\n                            ni, nj = ci + di, cj + dj\n                            if 0 <= ni < m and 0 <= nj < n:\n                                if A[ni][nj] == 1:\n                                    A[ni][nj] = 2\n                                    queue.append((ni, nj))\n                                elif A[ni][nj] == 0:\n                                    boundary.add((ci, cj))\n                    found = True\n                    break\n            if found:\n                break\n                \n        queue = deque(boundary)\n        steps = 0\n        while queue:\n            for _ in range(len(queue)):\n                i, j = queue.popleft()\n                for di, dj in dirs:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < m and 0 <= nj < n:\n                        if A[ni][nj] == 0:\n                            A[ni][nj] = 2\n                            queue.append((ni, nj))\n                        elif A[ni][nj] == 1:\n                            return steps\n            steps += 1
class Solution:\n     def widthOfBinaryTree(self, root):\n         """\n         :type root: TreeNode\n         :rtype: int\n         """\n         if not root:\n             return 0\n         s=1\n         a=[[root,1]]\n         while 1:\n             b=[]\n             for p in a:\n                 if p[0].left:\n                     b.append([p[0].left,2*p[1]-1])\n                 if p[0].right:\n                     b.append([p[0].right,2*p[1]])\n             a=b\n             if a:\n                 s=max(s,a[-1][1]-a[0][1]+1)\n             else:\n                 break\n         return s
class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        for i in range(len(grid)):\n            grid[i].insert(0, 0)\n            grid[i].append(0)\n        grid.insert(0, [0 for i in range(len(grid[0]))])\n        grid.append([0 for i in range(len(grid[0]))])\n        islands = []\n        max_length = 1\n        for i in range(1, len(grid) - 1):\n            for j in range(1, len(grid[0]) - 1):\n                if grid[i][j] != 1:\n                    continue\n                island_id = len(islands)\n                length = 0\n                connect_length = 0\n                queue = [(i, j)]\n                grid[i][j] = 2 + island_id\n                while queue:\n                    x, y = queue.pop()\n                    for dx, dy in directions:\n                        this_grid = grid[x + dx][y + dy]\n                        if this_grid == 1:\n                            grid[x + dx][y + dy] = 2 + island_id\n                            queue.append((x + dx, y + dy))\n                        elif isinstance(this_grid, list):\n                            new_connect = 0\n                            already = False\n                            for old_island_id in this_grid:\n                                if old_island_id != island_id:\n                                    new_connect += islands[old_island_id]\n                                else:\n                                    already = True\n                            if not already:\n                                connect_length = max(connect_length, new_connect)\n                                this_grid.append(island_id)\n                        else:\n                            grid[x + dx][y + dy] = [island_id]\n                    length += 1\n                islands.append(length)\n                max_length = max(max_length, length + connect_length + 1)\n        return min(max_length, (len(grid) - 2) * (len(grid[0]) - 2))
class Solution:\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\n        l=len(str(low))\n        f=len(str(high))\n        s=len(str(low)[0])\n        a=[]\n        for i in range(l,f+1):\n            while True:\n                t=''\n                if i+s>10:\n                    break\n                for j in range(s,i+s):\n                    t+=str(j)\n                if int(t)>high:\n                    break\n                if int(t)<low:\n                    s+=1\n                    continue\n                s+=1\n                a.append(t)\n            s=1\n        return a
class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        dist = [float(\"inf\")] * n\n        remain = set()\n        for i in range(0,n):\n            remain.add(i)\n        dist[0] = 0\n        remain.discard(0)\n        curr = 0\n        res = 0\n        while len(remain) > 0:\n            lo = float(\"inf\")\n            loind = -1\n            # curr is the next lowest\n            a,b = points[curr]\n            for r in remain:\n                x,y = points[r]\n                tempdist = abs(x-a) + abs(y-b)\n                if tempdist < dist[r]:\n                    dist[r] = tempdist\n                tempdist = dist[r]\n                \n                if tempdist < lo:\n                    lo = tempdist\n                    loind = r\n            \n            res += lo\n            \n            curr = loind\n            # remove curr from remain\n            remain.discard(curr)\n            \n        return res\n            
class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        points.sort(key = lambda x: x[0]*x[0] + x[1]*x[1])\n        return points[:K]
from math import sqrt\n class Solution:\n     def largestDivisibleSubset(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: List[int]\n         """\n         nums.sort()\n         l, prev = {}, {}  # length, previous number(largest divisor in nums)\n         max_l, end_number = 0, None\n         \n         for i in nums:\n             tmp_l, tmp_prev = 0, None\n             for j in range(1, 1 + int(sqrt(i))):\n                 if i % j == 0:\n                     tmp = i // j\n                     if tmp in prev and l[tmp] > tmp_l:\n                         tmp_l, tmp_prev = l[tmp], tmp\n                     if j in prev and l[j] > tmp_l:\n                         tmp_l, tmp_prev = l[j], j                    \n                     \n             tmp_l += 1\n             prev[i], l[i] = tmp_prev, tmp_l\n             \n             if tmp_l > max_l:\n                 max_l, end_number = tmp_l, i\n         \n         ans = []\n         while end_number is not None:\n             ans.append(end_number)\n             end_number = prev[end_number]\n         \n         return ans
class Solution:\n     def reconstructQueue(self, people):\n         """\n         :type people: List[List[int]]\n         :rtype: List[List[int]]\n         """\n         people.sort(key = lambda x: (-x[0], x[1]))\n         queue = []\n         for p in people:\n             queue.insert(p[1], p)\n         return queue\n \n
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\n        def getnode(root):\n            if not root:\n                return None\n            elif root.val == target.val:\n                return root\n            else:\n                return getnode(root.left) or getnode(root.right)\n        return getnode(cloned)
# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def countNodes(self, root):\n         """\n         :type root: TreeNode\n         :rtype: int\n         """\n         node = root\n         depth = 0\n         while node:\n             depth += 1\n             node = node.left\n         \n         if depth <= 1:\n             return depth\n         \n         lo, hi = 0, 2**(depth-2)\n         while lo < hi:\n             l = depth-3\n             mi = (lo+hi)//2\n             node = root\n             while l >= 0:\n                 d = mi & 2**l\n                 node = node.right if d > 0 else node.left\n                 l -= 1\n             if node.left and node.right:\n                 lo = mi+1\n             elif not node.left and not node.right:\n                 hi = mi\n             else:\n                 break\n         l, node = depth-3, root\n         while l >= 0:\n             d = mi & 2**l\n             node = node.right if d > 0 else node.left\n             l -= 1\n         return 2**(depth-1)-1 + 2*mi + int(node.left is not None) + int(node.right is not None)
class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])\n        memo = [[0 for j in range(cols)] for i in range(rows)]\n        ans = 0\n        \n        if grid[0][0] == 1:\n            memo[0][0] = (1,1)\n            ans = 1\n        else:\n            memo[0][0] = (0,0)\n        \n        for i in range(1,rows):\n            if grid[i][0] == 0:\n                memo[i][0] = (0,0)\n            else:\n                memo[i][0] = (memo[i-1][0][0]+1,1)\n                ans = 1\n        \n        for j in range(1,cols):\n            if grid[0][j] == 0:\n                memo[0][j] = (0,0)\n            else:\n                memo[0][j] = (1,memo[0][j-1][1]+1)\n                ans = 1\n            \n        for i in range(1,rows):\n            for j in range(1,cols):\n                if grid[i][j] == 0:\n                    memo[i][j] = (0,0)\n                else:\n                    memo[i][j] = (memo[i-1][j][0]+1, memo[i][j-1][1]+1)\n                    ans = 1\n        \n        for i in range(rows-1,0,-1):\n            for j in range(cols-1,0,-1):\n                l_min = min(memo[i][j][0],memo[i][j][1])\n                \n                while l_min>ans:\n                    if memo[i][j-l_min+1][0]>=l_min and memo[i-l_min+1][j][1]>=l_min:\n                        ans = l_min\n                    l_min -= 1\n        return ans*ans\n
# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def kth(self, v, k):\n         for i in range(k-1):\n             if not v:\n                 return None\n             v=v.next\n         return v\n     \n     def reverseKGroup(self, head, k):\n         """\n         :type head: ListNode\n         :type k: int\n         :rtype: ListNode\n         """\n         if k==1:\n             return head\n         kthnode=self.kth(head, k)\n         v=head\n         head=kthnode if kthnode else head\n         i=0\n         tmphead=v\n         while kthnode:\n             vprev=kthnode.next\n             for i in range(k):\n                 v.next, v, vprev = vprev, v.next, v\n                 kthnode=None if not kthnode else kthnode.next\n             tmphead.next=kthnode if kthnode else v\n             tmphead=v\n         return head
# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def sortList(self, head):\n         """\n         :type head: ListNode\n         :rtype: ListNode\n         """\n         arr = []\n         p = head\n         while p:\n             arr.append(p.val)\n             p = p.next\n             \n         arr.sort()\n         p = head\n         for el in arr:\n             p.val = el\n             p = p.next\n         \n         return head
class Solution:\n     def nextGreatestLetter(self, letters, target):\n         """\n         :type letters: List[str]\n         :type target: str\n         :rtype: str\n         """\n         \n         if ord(letters[-1]) <= ord(target):\n             return letters[0]\n         \n         li = 0\n         ri = len(letters) - 1\n         \n         while li <= ri:\n             if li == ri:\n                 return letters[li]\n             \n             mi = li + (ri - li)//2\n             \n             if ord(letters[mi]) > ord(target):\n                 ri = mi\n             else:\n                 li = mi + 1
class Solution:\n    def prevPermOpt1(self, A: List[int]) -> List[int]:\n        n = len(A)\n        if n == 1: return A\n        \n        tidx = -1\n        for i in range(n-2, -1, -1):\n            if A[i] > A[i+1]:\n                tidx = i\n                break\n        \n        if tidx < 0: return A\n        \n        sidx = -1\n        for j in range(n-1, tidx, -1):\n            if A[j] == A[j-1]: continue\n            if A[j] < A[tidx]: \n                sidx = j\n                break\n        \n        A[tidx], A[sidx] = A[sidx], A[tidx]\n        \n        return A
class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        dcosts = sorted(costs, key=lambda i: i[0] - i[1])\n        n = len(costs) // 2\n        acost = sum(c[0] for c in dcosts[:n])\n        bcost = sum(c[1] for c in dcosts[n:])\n        return acost + bcost
'''\n\"aabcaca\"\n 0123456\n  x\n \ndevide conquer\nstampstringOn\nstampmatchmatch \nstampmatchmatchmatch  stamp\n\noffset****b** offset3stampmatch\n\nnwin*M^2 mstampmatchstampmatch1\nmatch\n\n\n'''\nclass Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        ans = []\n        offset = 0\n        while target!='':\n            x = target.find(stamp)\n            if x==-1:\n                return []\n            ans.append(x+offset)\n            \n            can_stamp,indices = self.moveLeft(stamp,target[:x],offset)\n            if not can_stamp:\n                return []\n            ans.extend(indices)\n            \n            offset,target,indices = self.moveRight(stamp,target[x+len(stamp):],\n                                                offset+x+len(stamp))\n            ans.extend(indices)\n            \n        return ans[::-1]\n        \n        \n    \n    def moveLeft(self,stamp,s,offset):\n        ans = []\n        while s:\n            for ind in range(1,len(stamp)):\n                additional = 0\n                if ind>len(s):\n                    if offset == 0:\n                        continue\n                        \n                    additional = ind - len(s)\n                    \n                if stamp[additional:ind]==s[-ind:]:\n                    ans.append(offset+len(s)-ind)\n                    s=s[:-ind]\n                    break\n            else:\n                return False,[]\n        return True,ans\n        \n    \n    def moveRight(self,stamp,s,offset):\n        ans = []\n        while s:\n            for ind in range(1,len(stamp)):\n                if stamp[-ind:]==s[:ind]:\n                    ans.append(offset+ind-len(stamp))\n                    offset+=ind\n                    s=s[ind:]\n                    break\n            else:\n                return offset,s,ans\n        return offset,s,ans\n
# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n 	def currentmax(self,root):\n 		leftval = 0\n 		if root.left != None:\n 			leftval = self.currentmax(root.left)\n 			leftval = 0 if leftval < 0 else leftval\n 		rightval = 0\n 		if root.right != None:\n 			rightval = self.currentmax(root.right)\n 			rightval = 0 if rightval < 0 else rightval\n 		currentnode = leftval + rightval + root.val\n 		if self.flag == 0:\n 			self.ans = currentnode\n 			self.flag = 1\n 		else:\n 			self.ans = self.ans if self.ans > currentnode else currentnode\n 		return root.val + (leftval if leftval > rightval else rightval)\n 	def maxPathSum(self, root):\n 		self.ans = 0\n 		self.flag = 0\n 		self.currentmax(root)\n 		return self.ans
class Solution(object):\n     loc=0\n     lastloc=-1\n     f=''\n     def getNext(self,formular,locked=False):\n         stype=0 # 0:null, 1:numeric, 2/20: Elem, 3: parenthesis\n         ret=0\n         if self.loc==self.lastloc: return (0,0)\n         i=self.loc\n         while i <len(formular):\n             if stype in (0,1) and  formular[i].isnumeric():\n                 ret=int(formular[i])+ret*10\n                 stype=1\n             elif stype==0 and formular[i].isupper():\n                 stype=20\n                 ret=formular[i]\n             elif stype in (20,2) and formular[i].islower():\n                 stype=2\n                 ret+=formular[i]\n             elif stype==0 and formular[i] in "()":\n                 stype=3+"()".index(formular[i])\n                 ret=formular[i]\n             else: break\n             i+=1\n         if not locked:\n             self.lastloc=self.loc\n             self.loc=i\n         return (stype,ret)\n     \n     def countOfAtoms(self, formula):\n         stk=[]\n         cnt={}\n         r=''\n         self.loc=0\n         n=self.getNext(formula)\n         while n!=(0,0):\n             if n[0] in (2,3,20):\n                 stk.append([n[1],1])\n             elif n[0]==1:\n                 stk[-1][1]=n[1]\n             elif n[0]==4:\n                 time=1\n                 i=-1\n                 if self.getNext(formula,True)[0]==1:\n                     time=self.getNext(formula)[1]\n                 while stk[i][0]!='(':\n                     stk[i][1]*=time\n                     i-=1\n                 stk[i][0]='$'\n             n=self.getNext(formula)\n         while any(stk):\n             n=stk.pop()\n             if n[0]!='$':\n                 cnt[n[0]]=cnt.get(n[0],0)+n[1]\n         for i in sorted(cnt.keys()):\n             r+="%s%d"%(i,cnt[i]) if cnt[i]>1 else i\n         return r
from collections import defaultdict\n \n class Solution:\n     def findItinerary(self, tickets):\n         """\n         :type tickets: List[List[str]]\n         :rtype: List[str]\n         """\n         \n         graph = defaultdict(list)\n         for from_, to_ in tickets:\n             graph[from_].append(to_)\n         \n         for each in graph:\n             graph[each].sort()\n         \n         res = []\n         self.dfs(graph, "JFK", res)\n         return res[::-1]\n     \n     \n     def dfs(self, graph, from_, results):\n         \n         while graph[from_]:\n             curr = graph[from_].pop(0)\n             self.dfs(graph, curr, results)\n         \n         results.append(from_)
class Solution:\n     def findOrder(self, numCourses, prerequisites):\n         """\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: List[int]\n         """\n         n = numCourses  \n         graph = {}\n         for post, pre in prerequisites:\n             if pre in graph:\n                 graph[pre].append(post)\n             else:\n                 graph[pre] = [post]\n         \n         WHITE = 0 # never explored. NOT CHECKED\n         GREY = 1 # in the stack, exploring. CHECKING\n         BLACK = 2 # finished explored and we know for a fact there's no loop originated from this. CHECKED\n         state = [WHITE for _ in range(0, n)]\n         \n         res = []\n         \n         def dfs(i):\n             state[i] = GREY\n             for child in graph.get(i, []):\n                 if state[child] == GREY:\n                     return False\n                 elif state[child] == WHITE:\n                     if not dfs(child):\n                         return False\n             state[i] = BLACK\n             res.insert(0, i)\n             return True\n         \n         for i in range(0, n):\n             if state[i] != BLACK:\n                 if not dfs(i):\n                     return []\n         return res\n
class TimeMap:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.store = {}\n        self.times = {}\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        if key not in self.store: \n            self.store[key] = [value]\n            self.times[key] = [timestamp]\n        else:\n            self.store[key].append(value)\n            self.times[key].append(timestamp)\n        \n\n    def get(self, key: str, timestamp: int) -> str:\n        if key not in self.store: return \"\"\n        else:\n            lst = self.times[key]\n            \n            if timestamp < lst[0]: return \"\"\n            elif timestamp >=lst[-1]: return self.store[key][-1]\n            else:\n                l = 0\n                r = len(lst)-1\n                while l < r:\n                    mid = (l+r)//2\n                    if lst[mid] < timestamp: r = mid\n                    elif lst[mid] == timestamp: return self.store[key][mid]\n                    else: l = mid\n                        \n                \n            \n            return self.store[key][r]\n                \n\n\n# Your TimeMap object will be instantiated and called as such:\n# obj = TimeMap()\n# obj.set(key,value,timestamp)\n# param_2 = obj.get(key,timestamp)
from heapq import heapify, heappush, heappop \nclass DinnerPlates:\n        # index * cap ->  access start of stack at index\n        # index * cap + (cap - 1)  -> access last element of stack at index\n        \n    def __init__(self, capacity: int):\n        self.stack = [] # just one array to simulate all the stacks\n        self.cap = capacity \n        self.idx = [] # min-heap to track empty indicies\n        \n    def push(self, val: int) -> None:\n        if len(self.idx) > 0:\n            while len(self.idx) > 0:\n                i = heappop(self.idx) \n                # Given that we just push index but don't validate the cache while\n                # poping we need to check if this index is within current limits\n                if i < len(self.stack):\n                    self.stack[i] = val\n                    return \n                \n        # we didn't find empty spaces so we add to the end\n        self.stack.append(val)\n\n    def pop(self) -> int:\n        n = len(self.stack) - 1\n        if n < 0:\n            return -1\n        \n        while n > -1:\n            if self.stack[n] != -1:\n                v = self.stack[n]\n                self.stack[n] = -1\n                # Add the empty index to the heap\n                heappush(self.idx , n)\n                return v\n            else:\n                # Because those appear at the end the list we free those memory spaces so\n                # later pop operations are optimized\n                del(self.stack[n])\n            n -= 1\n            \n        # All stacks are empty\n        return -1\n        \n        \n\n    def popAtStack(self, index: int) -> int:\n        # additional check that is [optional] just to skip any effort \n        # if index is already out of current limits\n        count = len(self.stack) // self.cap\n        if index > count:\n            return -1\n        \n        # capture the boundaries of this stack\n        leftptr = (index * self.cap) \n        rightptr = leftptr + self.cap - 1\n        if rightptr > (len(self.stack) - 1): # edge case\n            rightptr = (len(self.stack) - 1)\n            \n        # traverse within the stack at this index until we empty it or we find an occupied location    \n        while self.stack[rightptr] == -1 and rightptr >= leftptr:\n            rightptr -=1\n            \n        # if it isn't empty it means we found occupied position\n        if rightptr >= leftptr:\n            v = self.stack[rightptr]\n            self.stack[rightptr] = -1\n            # Add the empty index to the heap\n            heappush(self.idx , rightptr)\n            return v\n        else:\n            return -1\n
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        \n        def dfs(node):\n            if not node:\n                return 2\n            left = dfs(node.left)\n            right = dfs(node.right)\n            \n            if left == 0 or right == 0:\n                self.res += 1\n                return 1\n            if left == 1 or right == 1:\n                return 2\n            else:\n                return 0\n            \n        self.res = 0\n        return (dfs(root) == 0) + self.res\n\n
class Solution:\n     def countSmaller(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: List[int]\n         """\n         s = sorted(nums)\n         c = []\n         for n in nums:\n             p = bisect.bisect_left(s, n)\n             c.append(p)\n             s.pop(p)\n         return c\n
class Transaction:\n    def __init__(self, name, time, amount, city):\n        self.name = name\n        self.time = int(time)\n        self.amount = int(amount)\n        self.city = city\n        \n    def array(self):\n        return f\"{self.name},{self.time},{self.amount},{self.city}\"\n\nfrom collections import defaultdict\nclass Solution:\n    def invalidTransactions(self, transactions):\n        transactions = [Transaction(*transaction.split(',')) for transaction in transactions]\n        transactions.sort(key=lambda t: t.time) # O(nlogn) time\n\n        trans_indexes = defaultdict(list)\n        for i, t in enumerate(transactions): # O(n) time\n            trans_indexes[t.name].append(i)\n\n        res = []\n        for name, indexes in trans_indexes.items(): # O(n) time\n            left = right = 0\n            for i, t_index in enumerate(indexes):\n                t = transactions[t_index]\n                if (t.amount > 1000):\n                    res.append(\"{},{},{},{}\".format(t.name, t.time, t.amount, t.city))\n                    continue\n                while left <= t_index and transactions[indexes[left]].time < t.time - 60: # O(60) time\n                    left += 1\n                while right <= len(indexes)-2 and transactions[indexes[right+1]].time <= t.time + 60: # O(60) time\n                    right += 1\n                for i in range(left,right+1): # O(120) time\n                    if transactions[indexes[i]].city != t.city:\n                        res.append(t.array())\n                        break\n\n        return res\n
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\n        # time O(n); space O(n)\n        vals = deque(preorder)\n        \n        def build(min_val, max_val):\n            if vals and min_val < vals[0] < max_val:\n                val = vals.popleft()\n                node = TreeNode(val)\n                node.left = build(min_val, val)\n                node.right = build(val, max_val)\n                \n                return node\n        \n        return build(float('-inf'), float('inf'))
import collections\nimport itertools\n\n\ndef prime_factors(n):\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            n /= i\n            yield i\n        else:\n            i += 1\n\n    if n > 1:\n        yield n\n\n\ndef prod(iterable):\n    result = 1\n    for i in iterable:\n        result *= i\n    return result\n\n\ndef get_divisors(n):\n    pf = prime_factors(n)\n\n    pf_with_multiplicity = collections.Counter(pf)\n\n    powers = [\n        [factor ** i for i in range(count + 1)]\n        for factor, count in list(pf_with_multiplicity.items())\n    ]\n\n    for prime_power_combo in itertools.product(*powers):\n        yield prod(prime_power_combo)\n\nclass Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        d1 = sorted(list(get_divisors(num+1)))\n        d2 = sorted(list(get_divisors(num+2)))\n        \n        if len(d1) % 2 == 1:\n            mid = d1[int((len(d1) - 1)/2)]\n            return [int(mid), int(mid)]\n        \n        if len(d2) % 2 == 1:\n            mid = d2[int((len(d2) - 1)/2)]\n            return [int(mid), int(mid)]\n        \n        l1, r1 = d1[int(len(d1)/2)],d1[int(len(d1)/2)-1]\n        l2, r2 = d2[int(len(d2)/2)],d2[int(len(d2)/2)-1]\n        \n        if abs(l1-r1) < abs(l2-r2):\n            return [int(l1),int(r1)]\n        else:\n            return [int(l2),int(r2)]\n
class Solution:\n     def asteroidCollision(self, asteroids):\n         """\n         :type asteroids: List[int]\n         :rtype: List[int]\n         """\n         l=len(asteroids)\n         if l<2:\n             return asteroids\n         ans=[]\n         stack=[]\n         for a in asteroids:\n             if a>0:\n                 stack.append(a)\n             else:\n                 a=-a\n                 equal_flag=False\n                 while stack:\n                     cur=stack.pop()                  \n                     if cur==a:\n                         equal_flag=True\n                         break\n                     elif cur>a:\n                         stack.append(cur)\n                         break              \n                 if equal_flag:\n                     continue            \n                 if not stack:\n                     ans.append(-a)\n         return ans+stack\n             \n
# """\n # This is the interface that allows for creating nested lists.\n # You should not implement it, or speculate about its implementation\n # """\n #class NestedInteger:\n #    def __init__(self, value=None):\n #        """\n #        If value is not specified, initializes an empty list.\n #        Otherwise initializes a single integer equal to value.\n #        """\n #\n #    def isInteger(self):\n #        """\n #        @return True if this NestedInteger holds a single integer, rather than a nested list.\n #        :rtype bool\n #        """\n #\n #    def add(self, elem):\n #        """\n #        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n #        :rtype void\n #        """\n #\n #    def setInteger(self, value):\n #        """\n #        Set this NestedInteger to hold a single integer equal to value.\n #        :rtype void\n #        """\n #\n #    def getInteger(self):\n #        """\n #        @return the single integer that this NestedInteger holds, if it holds a single integer\n #        Return None if this NestedInteger holds a nested list\n #        :rtype int\n #        """\n #\n #    def getList(self):\n #        """\n #        @return the nested list that this NestedInteger holds, if it holds a nested list\n #        Return None if this NestedInteger holds a single integer\n #        :rtype List[NestedInteger]\n #        """\n \n class Solution:\n     def deserialize(self, s):\n         """\n         :type s: str\n         :rtype: NestedInteger\n         """\n         \n         root_ni = NestedInteger()\n         \n         ni_stack = collections.deque()\n         current_ni = root_ni\n         \n         active_number = None\n         is_positive = True\n         \n         for i, c in enumerate(s):\n             if c == '-':\n                 is_positive = False\n                 active_number = 0\n \n             elif c.isdigit():\n                 # Check if the previous was a digit as well.\n                 if active_number is None:\n                     active_number = int(c)\n                 else:\n                     active_number = int(c) + active_number * 10\n \n             else:\n                 if active_number is not None:\n                     if not is_positive:\n                         active_number *= -1\n \n                     current_ni.add(active_number)\n                     active_number = None\n                     is_positive = True\n \n                 if c == '[' and i > 0:\n                     ni_stack.append(current_ni)\n                     current_ni = NestedInteger()\n \n                 elif c == ']' and len(ni_stack) > 0:\n                     ni_stack[-1].add(current_ni)\n                     current_ni = ni_stack.pop()\n \n         if active_number is not None:\n             if not is_positive:\n                 active_number *= -1\n \n             if not current_ni.getList():\n                 current_ni.setInteger(active_number)\n             else:\n                 current_ni.add(active_number)\n             \n         return root_ni\n         \n         
class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        #reverse trie\n        self.trie = {}\n        self.stream = deque([])\n\n        for word in set(words):\n            node = self.trie       \n            for ch in word[::-1]:\n                if not ch in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['$'] = word\n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        \n        node = self.trie\n        for ch in self.stream:\n            if '$' in node:\n                return True\n            if not ch in node:\n                return False\n            node = node[ch]\n        return '$' in node\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n
class Cashier:\n\n    def __init__(self, n: int, discount: int, products: List[int], prices: List[int]):\n        \n        self.n = n\n        self.count = 0\n        self.discount = discount\n        self.products = {}\n        \n        for i in range(0, len(products)):\n            \n            self.products[products[i]] = prices[i]\n\n    def getBill(self, product: List[int], amount: List[int]) -> float:\n        \n        self.count += 1\n        \n        subtotal = 0\n        \n        for i in range(0, len(product)):\n            \n            subtotal += self.products[product[i]] * amount[i]\n            \n        if self.count == self.n:\n            \n            subtotal = subtotal - (self.discount * subtotal) / 100\n            self.count = 0\n        \n        return subtotal\n\n# Your Cashier object will be instantiated and called as such:\n# obj = Cashier(n, discount, products, prices)\n# param_1 = obj.getBill(product,amount)\n
class Solution(object):\n    def isSubPath(self, h, r0):\n        h_vals = []\n        while h:\n            h_vals.append(str(h.val))\n            h = h.next\n        h_str = ('-'.join(h_vals)) + '-'  # serialized list\n\n        st = [(r0, '-')]  # DFS stack\n\n        while st:\n            r, pre = st.pop()\n            if not r:\n                continue\n\n            pre = pre + str(r.val) + '-'\n            if pre.endswith(h_str):\n                return True\n\n            st.append((r.left, pre))\n            st.append((r.right, pre))\n\n        return False
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\n        def count(node):\n            if not node:\n                return 0\n            return 1 + count(node.left) + count(node.right)\n        xNode = [0, 0]\n        def process(node):\n            if node:\n                if node.val == x:\n                    xNode[0] = count(node.left)\n                    xNode[1] = count(node.right)\n                else:\n                    process(node.left)\n                    process(node.right)\n            return\n        \n        process(root)\n        player2 = max(xNode[0], xNode[1], n - (xNode[0] + xNode[1] + 1)) # the maximum nodes I can color\n        return player2 > n // 2
class Solution:\n     def complexNumberMultiply(self, a, b):\n         """\n         :type a: str\n         :type b: str\n         :rtype: str\n         """\n         a = a.split('+')\n         b = b.split('+')\n         a[1] = a[1][:-1]\n         b[1] = b[1][:-1]\n         a = list(map(int, a))\n         b = list(map(int, b))\n         print((a, b))\n         r = a[0]*b[0] - a[1]*b[1]\n         i = a[1]*b[0] + a[0]*b[1]\n         print((r, i))\n         return "{0}+{1}i".format(r, i)\n
# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def zigzagLevelOrder(self, root):\n         """\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         """\n         if root is None:\n             return []\n         \n         res = []\n         level_num = 1\n         level = [root]\n         \n \n         while len(level) != 0:\n             level_size = len(level)\n             level_res = [None]*level_size\n             for i in range(level_size):\n                 curr = level.pop(0)\n                 level_res[i] = curr.val\n                 if curr.left is not None:\n                     level.append(curr.left)\n                 if curr.right is not None:\n                     level.append(curr.right)\n             if level_num % 2:\n                 res.append(level_res)\n             else:\n                 level_res.reverse()\n                 res.append(level_res)\n             level_num += 1\n             \n         return res\n         \n         \n         \n         
class Solution:\n     def isToeplitzMatrix(self, matrix):\n         """\n         :type matrix: List[List[int]]\n         :rtype: bool\n         """\n         if not matrix:\n             return False\n         colSize = len(matrix[0]) - 1\n         for row in range(len(matrix) - 1):\n             if matrix[row][:colSize] != matrix[row+1][1:colSize+1]:\n                 return False\n         return True
class Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        res = []\n        level = 0\n        nodes_count = 0\n        while nodes_count < label:\n            nodes_count += 2**level\n            level += 1\n        while label != 0:\n            res.append(label)\n            level_max = (2**level) - 1\n            level_min = 2**(level-1)\n            label = (level_max + level_min - label) // 2\n            level -= 1\n        return res[::-1]\n\n
class ThroneInheritance:\n\n    def __init__(self, kingName: str):\n        self.graph = collections.defaultdict(list)\n        self.deaths = set()\n        self.root = kingName\n        \n\n    def birth(self, parentName: str, childName: str) -> None:\n        self.graph[parentName].append(childName)\n\n    def death(self, name: str) -> None:\n        self.deaths.add(name)\n        \n    def inorder(self, root, res):\n        if root not in self.deaths:\n            res.append(root)\n        children = self.graph[root]\n        for child in children:\n            self.inorder(child, res)\n\n    def getInheritanceOrder(self) -> List[str]:\n        res = []\n        self.inorder(self.root, res)\n        return res\n\n\n# Your ThroneInheritance object will be instantiated and called as such:\n# obj = ThroneInheritance(kingName)\n# obj.birth(parentName,childName)\n# obj.death(name)\n# param_3 = obj.getInheritanceOrder()\n
class Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        \n        def getArea(width):\n            res = 0\n            prev_low = 0\n            for low, high in intervals:\n                low = max(prev_low, low)\n                if high > low:\n                    res += (high - low)*width\n                    prev_low = high\n            return res\n\n        MOD = 10**9 + 7\n        # convert list of rectangles to events\n        events = []\n        for x1, y1, x2, y2 in rectangles:\n            events.append((x1, 0, y1, y2)) #in\n            events.append((x2, 1, y1, y2)) #out\n        events.sort(key = lambda x : (x[0], x[1]))\n        \n        # sweep to calculate area\n        intervals = []\n        area = 0\n        prev_x = 0\n        for event in events:\n            cur_x, type, low, high = event\n            area += getArea(cur_x - prev_x)\n            if type == 1:\n                intervals.remove((low, high))\n            else:\n                intervals.append((low, high))\n                intervals.sort()   \n            prev_x = cur_x\n                \n        \n        return area % MOD
class Solution:\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\n        original = set(wordlist)\n        insensitive = {w.lower(): w for w in reversed(wordlist)}\n        vowels = {}\n        for c in reversed(wordlist):\n            w = c.lower()\n            t = w.replace('a', '_').replace('e', '_').replace('i', '_').replace('o', '_').replace('u', '_')\n            vowels[t] = c\n        results = []\n        for q in queries:\n            if q in original:\n                results.append(q)\n                continue\n            low = q.lower()\n            if low in insensitive:\n                results.append(insensitive[low])\n                continue\n            # vowel replace\n            t = low.replace('a', '_').replace('e', '_').replace('i', '_').replace('o', '_').replace('u', '_')\n            if t in vowels:\n                results.append(vowels[t])\n                continue\n            results.append(\"\")\n        return results
# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: ListNode) -> List[int]:\n        if head==None:\n            return 0\n        temp=head\n        arr=[]\n        stack=[]\n        while temp:\n            arr.append(temp.val)\n            temp=temp.__next__\n        output=[0]*len(arr)\n        for i in range(len(arr)):\n            while stack and arr[stack[-1]]<arr[i]:\n                output[stack.pop()]=arr[i]\n            stack.append(i)\n        return output\n        \n       \n            \n                \n                \n
class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        # 1st step\n        # construct a mask for each word\n        # note that there may be duplicate mask for different words\n        # so we need a dict to count the number\n        orda = ord('a') # 97\n        mask = defaultdict(int) # word mask\n        \n        for w in words:\n            m = 0\n            for c in w:\n                m |= 1 << (ord(c) - orda)\n            mask[m] += 1\n        \n        # 2nd step\n        # for each puzzle, construct the corresponding mask for each possible valid word, check whether the word is in mask\n        res = []\n        for p in puzzles:\n            ones = []\n            # separate current puzzle into ones, 'bdeg' -> 0b1011010 -> [0b10(b), 0b1000(d), 0b10000(e), 0b1000000(g)]\n            for c in p:\n                ones.append(1 << (ord(c) - orda))\n            \n            # generate all valid words for the current puzzle\n            # equivalent to generate all subsets of ones[1:]\n            # reuse code from [78. Subsets]\n            valid = [ones[0]] # valid word must contains the first char of current puzzle\n            for i in range(1,7): # bfs to generate all valid words\n                valid.extend([ones[i] + v for v in valid])\n            \n            # for each valid word, check whether it's in mask\n            novw = 0 # number of valid words for current puzzle\n            for v in valid:\n                if v in mask:\n                    novw += mask[v]\n            res.append(novw)\n        return res
class Solution:\n    def peopleIndexes(self, favoriteCompanies: List[List[str]]) -> List[int]:\n        result = []\n        fcSet = [set(fc) for fc in favoriteCompanies]\n        n = len(favoriteCompanies)\n        for i, fcs1 in enumerate(fcSet):\n            for j, fcs2 in enumerate(fcSet):\n                if i==j:\n                    continue\n                if fcs1<fcs2:\n                    break\n            else:\n                result.append(i)\n        return result
class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        result = []\n        i = j = 0\n        \n        while i < len(A) and j < len(B):\n            low = max(A[i][0], B[j][0])\n            high = min(A[i][1], B[j][1])\n            \n            if low <= high:\n                result.append([low, high])\n                \n            if A[i][1] > B[j][1]:\n                j += 1\n            elif A[i][1] < B[j][1]:\n                i += 1\n            else:\n                i += 1\n                j += 1\n                \n        return result
class Solution:\n     def calc(self, part):\n         part += "+" ## added tmp symbol in the end to sum last item within the loop\n         start = x = n = 0\n         coeff = 1\n         for end, char in enumerate(part):\n             # print("charIdx:", equation[end], "char: ", char, char == "+" or char == "-", "slice: ", equation[start:end])\n             if char == "+" or char == "-":\n                 var = part[start:end]\n                 if var == "":\n                     continue\n                 if "x" in var:\n                     var = var[:-1]\n                     if var in ["", "+"]:\n                         var = 1\n                     elif var == "-":\n                         var = -1\n                     x += int(var) * coeff\n                     start = end\n                 else:\n                     n += int(var) * coeff\n                     start = end\n         return x, n\n     \n     def solveEquation(self, equation):\n         """\n         :type equation: str\n         :rtype: str\n         """\n         # how big is N\n         # time vs. space complexity?\n         \n         # split by "=" to left and right; time complexity: O(N)\n         # sums Xs and consts on both sides (left and right)\n         # take a difference b/w the sides' sums\n         # simplify dividing by X's coeff\n         # if x==0 and n==0 on the other - infinite\n         # if x==0 and a constant on the other - no solution\n         # if x on one side, and a constant on the other - solution\n         \n         # test: 2-x+2x-x-x+1=x\n         # test2: "x+5-3+x=6+x-2"\n         # test2: "+5-3+x=6+x-2"\n         # -x=-1\n         \n         left, right = equation.split("=")\n         x1, n1 = self.calc(left) # O(leftN)\n         x2, n2 = self.calc(right) # O(rightN)\n         x, n = x1 - x2, n1 - n2\n         n = n / x if (x != 0) else n\n         x = 1 if (x != 0) else x\n         if x == 0 and n != 0:\n             return "No solution"\n         if x == 0 and n == 0:\n             return "Infinite solutions"\n         return "x={}".format(int(-n))\n         \n         # time complexity O(N)\n
class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        dict_ = {}\n        for row in matrix:\n            curr_tuple = tuple(row)\n            dict_[curr_tuple] = 1 + dict_.get(curr_tuple,0)\n        visited = set()\n        max_same = 0\n        for row in matrix:\n            curr_tuple = tuple(row)\n            if curr_tuple in visited:\n                continue\n            visited.add(curr_tuple)\n            inverse = [1] * len(row)\n            for i in range (len(row)):\n                if row[i]:\n                    inverse[i] = 0\n            curr_inv = tuple(inverse)\n            visited.add(curr_inv)\n            curr_sum = 0\n            curr_sum = dict_[curr_tuple]\n            if curr_inv in dict_:\n                curr_sum += dict_[curr_inv]\n            if curr_sum > max_same:\n                max_same = curr_sum\n        return max_same\n
from collections import defaultdict, deque\n from heapq import merge\n from itertools import islice\n \n class Twitter:\n \n     def __init__(self):\n         """\n         Initialize your data structure here.\n         """\n         self.id2tweets = defaultdict(deque)\n         self.id2follows = defaultdict(set)\n         self.uid = 0\n \n     def postTweet(self, userId, tweetId):\n         """\n         Compose a new tweet.\n         :type userId: int\n         :type tweetId: int\n         :rtype: void\n         """\n         self.id2tweets[userId].appendleft((self.uid, tweetId))\n         self.uid -= 1\n         #print(userId, 'POST', tweetId, self.id2tweets)\n \n     def getNewsFeed(self, userId):\n         """\n         Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\n         :type userId: int\n         :rtype: List[int]\n         """\n         #print('GET', userId, self.id2tweets, self.id2follows)\n         tweets = heapq.merge(*(self.id2tweets[u] for u in self.id2follows[userId] | {userId}))\n         return [tweet_id for _, tweet_id in islice(tweets, 10)]\n \n     def follow(self, followerId, followeeId):\n         """\n         Follower follows a followee. If the operation is invalid, it should be a no-op.\n         :type followerId: int\n         :type followeeId: int\n         :rtype: void\n         """\n         self.id2follows[followerId].add(followeeId)\n         #print(followerId, 'FOLLOW', followeeId, self.id2follows)\n \n     def unfollow(self, followerId, followeeId):\n         """\n         Follower unfollows a followee. If the operation is invalid, it should be a no-op.\n         :type followerId: int\n         :type followeeId: int\n         :rtype: void\n         """\n         self.id2follows[followerId].discard(followeeId)\n         #print(followerId, 'UNFOLLOW', followeeId, self.id2follows)\n \n # Your Twitter object will be instantiated and called as such:\n # obj = Twitter()\n # obj.postTweet(userId,tweetId)\n # param_2 = obj.getNewsFeed(userId)\n # obj.follow(followerId,followeeId)\n # obj.unfollow(followerId,followeeId)
class Solution:\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\n        s = set(A)\n        letters_required = {}\n        for i in B:\n            for j in i:\n                count = i.count(j)\n                if j not in letters_required or count > letters_required[j]:\n                    letters_required[j] = count\n\n        for i in A:\n            for j in letters_required:\n                if i.count(j) < letters_required[j]:\n                    s.remove(i)\n                    break\n        return list(s)
class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        ans = 1\n        for x, y in points: \n            angles = []\n            for x1, y1 in points: \n                if (x1 != x or y1 != y) and (d:=sqrt((x1-x)**2 + (y1-y)**2)) <= 2*r: \n                    angle = atan2(y1-y, x1-x)\n                    delta = acos(d/(2*r))\n                    angles.append((angle-delta, +1)) #entry\n                    angles.append((angle+delta, -1)) #exit\n            angles.sort(key=lambda x: (x[0], -x[1]))\n            val = 1\n            for _, entry in angles: \n                ans = max(ans, val := val+entry)\n        return ans \n\n\n\n        \n#https://www.geeksforgeeks.org/angular-sweep-maximum-points-can-enclosed-circle-given-radius/    \n#        class Solution {\n#    public int numPoints(int[][] points, int r) {\n#        int count = 1;\n#        for(int i = 0; i < points.length; i++) {\n#            Map<Double, Integer> angles = new HashMap<>();\n#            for(int j = 0; j < points.length; j++) {\n#                if (i != j) {\n#                    if (points[i][0] != points[j][0] || points[i][1] != points[j][1]) {\n#                        int d = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\n#                        double angle = Math.atan2(points[j][1] - points[i][1], points[j][0] - points[i][0]);\n#                        double delta = acos(d / (2 * r));\n#                        double entry = angle - delta;\n#                        double exit = angle + delta;\n#                        map.put(entry, map.getOrDefault(entry, 0) + 1);\n#                        map.put(exit, map.getOrDefault(exit, 0) - 1);\n#                    }\n#                }\n#            }\n#            Map<String, Integer> result = angles.entrySet().stream()\n#                .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))\n#                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,\n#                        (oldValue, newValue) -> oldValue, LinkedHashMap::new));\n#            \n#        }\n#        return count;\n#    }\n#}\n
class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        height = len(grid)\n        width = len(grid[0])\n        max_path = 0\n        \n        # generator for legal indices to check\n        def index_gen(index):\n            i,j = index\n            if i > 0 and grid[i-1][j] > 0:\n                yield (i-1, j)\n            if i < height - 1 and grid[i+1][j] > 0:\n                yield (i+1, j)\n            if j > 0 and grid[i][j-1] > 0:\n                yield (i, j-1)\n            if j < width - 1 and grid[i][j+1] > 0:\n                yield (i, j+1)\n        \n        # if a node branches off in 2 directions it can't be a leaf\n        def is_viable(index):\n            non_zero = 0\n            neighbors = [grid[a][b] for a,b in index_gen(index)]\n            for x in neighbors:\n                if x != 0:\n                    non_zero += 1\n            return non_zero < 2\n        \n        def dfs(index, count):\n            nonlocal max_path\n            count += grid[index[0]][index[1]]\n            max_path = max(max_path, count)\n            grid[index[0]][index[1]] *= -1   # clever idea from George Zhou to mark visited\n            for direction in index_gen(index):\n                dfs(direction, count)\n            grid[index[0]][index[1]] *= -1   # unmark node when done with this path\n                    \n        for i in range(height):\n            for j in range(width):\n                if grid[i][j] != 0 and is_viable((i,j)):\n                    dfs((i,j), 0)\n    \n        # if there are no 'leaf' nodes, then every node is accessible\n        return max_path if max_path > 0 else sum(sum(row) for row in grid )\n
# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def deleteDuplicates(self, head):\n         """\n         :type head: ListNode\n         :rtype: ListNode\n         """\n         if not head or not head.next:\n             return head\n         fakehead = ListNode(0)\n         fakehead.next = head\n         prev = fakehead\n         slow = head\n         fast = head.next\n         while fast:\n             if fast.val == slow.val:\n                 while fast and fast.val == slow.val:\n                     fast = fast.next\n                 slow = prev\n             else:\n                 prev = slow\n                 slow = slow.next\n                 slow.val = fast.val\n                 fast = fast.next\n         slow.next = None\n         return fakehead.next\n         
# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:\n        if root and root.val > val:\n            root.right = self.insertIntoMaxTree(root.right, val)\n            return root\n        node = TreeNode(val)\n        node.left = root\n        return node
class Solution:\n     def reverseBetween(self, head, m, n):\n         """\n         :type head: ListNode\n         :type m: int\n         :type n: int\n         :rtype: ListNode\n         """\n         if head is None or head.__next__ is None or m == n: return head\n         h = ListNode(-1)\n         h.next = head\n         fast = slow = h\n         for _ in range(n - m + 1):\n             fast = fast.__next__\n             \n         for _ in range(m - 1):\n             fast = fast.__next__\n             slow = slow.__next__\n             \n         prev = fast.__next__\n         curr = slow.__next__\n         while prev != fast:\n             temp = curr.__next__\n             curr.next = prev\n             prev = curr\n             curr = temp\n         slow.next = prev\n         \n         return h.__next__\n
# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     # @return a ListNode\n     def removeNthFromEnd(self, head, n):\n         dummy=ListNode(0); dummy.next=head\n         p1=p2=dummy\n         for i in range(n): p1=p1.next\n         while p1.next:\n             p1=p1.next; p2=p2.next\n         p2.next=p2.next.next\n         return dummy.next\n             \n             \n         
class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        \n\n        def fulfill_skills(skills, person):\n            remaining_skills = deque()\n            for skill in skills:\n                if skill not in people[person]:\n                    remaining_skills.appendleft(skill)\n            return remaining_skills\n\n        # BFS by # of people\n        # can reduce expansion by searching rarest skills first\n\n        # map required skills to people\n        # has_skill[\"java\"] == a list of people (int index into people) who have that skill\n        has_skill = dict()\n        for person, skills in enumerate(people):\n            for skill in skills:\n                experts = has_skill.get(skill, [])\n                experts.append(person)\n                has_skill[skill] = experts\n\n\n        # sort skills by rarity\n        rare_skills = [(len(people), skill)  for (skill, people) in list(has_skill.items())]\n        rare_skills.sort()\n        rare_skills = [skill for _, skill in rare_skills]\n\n\n        for i in range(1, 17):\n            # stack holds pairs:\n            #   (skills, team)\n            stack = [ (deque(rare_skills), []) ]\n            while stack:\n                skills, team = stack.pop()\n                # print(skills, team)\n                if not skills:\n                    return team\n\n                if len(team) + 1 > i:\n                    continue\n                # choose a member to fulfill next rarest skill\n                skill = skills[0]\n                for person in has_skill[skill]:\n                    remaining_skills = fulfill_skills(skills, person)\n                    stack.append( (remaining_skills, team + [person]) )\n            # print(f\"i {i} failed\")\n\n        return -1\n
class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        pr=[i for i in range(len(s))]\n        def union(x,y):\n            p1=find(x)\n            p2=find(y)\n            if p1!=p2:\n                pr[p1]=p2\n        def find(x):\n            while pr[x]!=x:\n                pr[x]=pr[pr[x]]\n                x=pr[x]\n            return x\n        \n        for i in pairs:\n            union(i[0],i[1])\n            \n        from collections import defaultdict\n        dp=defaultdict(list)\n        for i in range(len(s)):\n            ld=find(i)\n            dp[ld].append(i)\n        ans=[0]*len(s)\n        for i in dp:\n            dp[i].sort()\n            st=''\n            for j in dp[i]:\n                st+=s[j]\n            st=sorted(st)\n            c=0\n            for j in dp[i]:\n                ans[j]=st[c]\n                c+=1\n        return ''.join(ans)\n        \n        \n        \n        \n        \n        \n                \n
class Solution:\n     def FindValid(self):\n         a="123456789"\n         d,val={},{}\n         for i in range(9):\n             for j in range(9):\n                 temp=self.board[i][j]\n                 if temp!='.':\n                     d[("r",i)]=d.get(("r",i),[])+[temp]\n                     d[("c",j)]=d.get(("c",j),[])+[temp]\n                     d[(i//3,j//3)]=d.get((i//3,j//3),[])+[temp]\n                 else:\n                     val[(i,j)]=[]\n         for (i,j) in list(val.keys()):\n             invalid=d.get(("r",i),[])+d.get(("c",j),[])+d.get((i//3,j//3),[])\n             val[(i,j)]=[ele for ele in a if  ele not in invalid]\n         return val\n     def CheckingSolution(self,ele,Pos,Updata):\n         self.board[Pos[0]][Pos[1]]=ele\n         del self.val[Pos]\n         i,j=Pos\n         for invalid in list(self.val.keys()):\n             if ele in self.val[invalid]:\n                 if invalid[0]==i or invalid[1]==j or (invalid[0]//3,invalid[1]//3)==(i//3,j//3):\n                     Updata[invalid]=ele\n                     self.val[invalid].remove(ele)\n                     if len(self.val[invalid])==0:\n                         return False\n         return True\n     def Sudo(self,Pos,Updata):\n         self.board[Pos[0]][Pos[1]]="."\n         for i in Updata:\n             if i not in self.val:\n                 self.val[i]=Updata[i]\n             else:\n                 self.val[i].append(Updata[i])\n     def FindSolution(self):\n         if len(self.val)==0:\n             return True\n         Pos=min(list(self.val.keys()),key=lambda x:len(self.val[x]))\n         nums=self.val[Pos]\n         for ele in nums:\n             updata={Pos:self.val[Pos]}\n             if self.CheckingSolution(ele,Pos,updata):\n                 if self.FindSolution():\n                     return True\n             self.Sudo(Pos,updata)\n         return False\n \n     def solveSudoku(self, board):\n         """\n         :type board: List[List[str]]\n         :rtype: void Do not return anything, modify board in-place instead.\n         """\n         self.board=board\n         self.val=self.FindValid()\n         self.FindSolution()\n
# O(M*N*K)\nclass Solution:\n    def shortestPath(self, grid: List[List[int]], k: int) -> int:\n        rows, cols = len(grid), len(grid[0])\n        steps, min_steps = 0, rows + cols - 2\n        if k >= min_steps - 1:\n            return min_steps\n\n        visited = [[-1] * cols for _ in range(rows)]\n        visited[0][0] = k\n        q = deque([(0, 0, k)])\n        while q:\n            steps += 1\n            prev_min = min_steps\n            for _ in range(len(q)):\n                r, c, p = q.popleft()\n                for dx, dy in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                    x, y = c + dx, r + dy\n                    if x < 0 or x >= cols or y < 0 or y >= rows:\n                        continue\n                    kk = p-grid[y][x]\n                    if kk <= visited[y][x]: # have visited here on a better path.\n                        continue\n                    # early stop if there's shortcut (-1 because goal cell != 1)\n                    # But only applies when, comming from\n                    to_target = rows - y + cols - x - 2  # rows-r-1 + cols-c-1\n                    if kk >= to_target-1 and visited[y][x] == -1: #to_target == prev_min-1:\n                        return steps + to_target\n                    q.append((y, x, kk))\n                    visited[y][x] = kk\n                    min_steps = min(min_steps, to_target)\n        return -1\n
class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n#         mine\n#         res = collections.defaultdict(list)\n#         res_return = []\n#         for i,j in enumerate(groupSizes):\n#             res[j].append(i)\n        \n#         for j in res:\n#             temp = [res[j][0:j]]\n#             if len(res[j])>j:\n#                 # print(j,res[j][1])\n#                 # sub_nums = int(len(res[j])/j)\n#                 for num in range(j,len(res[j]),j):\n#                     temp = temp + [res[j][num:num+j]]\n#                     # print(temp)\n#                 res[j]=temp\n#             res_return = res_return+temp\n#         # print(res)\n#         # print(res_return)\n#         return res_return\n\n        # other perple\n        groups = defaultdict(list)\n        result = []\n        for index, size in enumerate(groupSizes):\n            groups[size].append(index)\n            if len(groups[size]) == size:\n                result.append(groups.pop(size))\n        return result
# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def addValueToList(self, root, lst):\n         if root is not None:\n             lst.append(root.val)\n             self.addValueToList(root.left, lst)\n             self.addValueToList(root.right, lst)\n \n     def minDiffInBST(self, root):\n         """\n         :type root: TreeNode\n         :rtype: int\n         """\n         values = []\n         self.addValueToList(root, values)\n         sorted_values = sorted(values)\n         max_diff = sorted_values[-1] - sorted_values[0]\n         for i in range(len(values)-1):\n             if sorted_values[i+1] - sorted_values[i] < max_diff:\n                 max_diff = sorted_values[i+1] - sorted_values[i]\n         return max_diff
class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        if not queries:\n            return []\n        p = list(range(1, m+1))\n        res = []\n        for i in queries:\n            z = p.index(i)\n            res.append(z)\n            del p[z]\n            p.insert(0,i)\n        return res\n            \n
class BrowserHistory:\n\n    def __init__(self, homepage: str):\n        \n        self.hashM = {}\n        self.maxIndex, self.currIndex = 0, 0\n        self.hashM[self.currIndex] = homepage\n\n    def visit(self, url: str) -> None:\n        \n        self.hashM[self.currIndex + 1] = url\n        self.currIndex = self.currIndex + 1\n        self.maxIndex = self.currIndex\n        return(url)\n        \n    def back(self, steps: int) -> str:\n        \n        if self.currIndex - steps < 0:\n            \n            self.currIndex = 0\n            \n        else:\n            \n            self.currIndex = self.currIndex - steps\n            \n        return(self.hashM[self.currIndex])\n\n    def forward(self, steps: int) -> str:\n        \n        if self.currIndex + steps > self.maxIndex:\n            \n            self.currIndex = self.maxIndex\n            \n        else:\n            \n            self.currIndex = self.currIndex + steps\n            \n        return(self.hashM[self.currIndex])\n        \n\n\n# Your BrowserHistory object will be instantiated and called as such:\n# obj = BrowserHistory(homepage)\n# obj.visit(url)\n# param_2 = obj.back(steps)\n# param_3 = obj.forward(steps)\n
class Solution:\n     def dominantIndex(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         if len(nums) <= 1:\n             return 0\n         m = max(nums)\n         ind = nums.index(m)\n         del nums[ind]\n         m_2 = max(nums)\n         return ind if m >= 2*m_2 else -1
class Solution:\n     def shoppingOffers(self, price, special, needs):\n         """\n         :type price: List[int]\n         :type special: List[List[int]]\n         :type needs: List[int]\n         :rtype: int\n         """\n         def dfs(curr, special, needs):\n             p=curr+sum(p*needs[i] for i,p in enumerate(price))\n             for si in range(len(special)):\n                 s = special[si]\n                 if all(n>=s[i] for i,n in enumerate(needs)):\n                     p=min(p, dfs(curr+s[-1], special[si:], [n-s[i] for i,n in enumerate(needs)]))\n                 # else: p=min(p, dfs(curr, special[si+1:], needs))\n             return p\n         return dfs(0, special, needs)
def get_tree_height(node, parent_node_height):\n     if node is None:\n         return 0\n     node.height = parent_node_height + 1\n     if node.left is None and node.right is None:\n         return 1\n     return max(get_tree_height(node.left, node.height), get_tree_height(node.right, node.height)) + 1\n \n def fill_in_array(result, node, root_index, width):\n     if node is None:\n         return\n     result[node.height - 1][root_index] = str(node.val)\n     new_width = width // 2\n     fill_in_array(result, node.left, root_index - new_width // 2 - 1, new_width)\n     fill_in_array(result, node.right, root_index + new_width // 2 + 1, new_width)\n \n class Solution:\n     def printTree(self, root):\n         """\n         :type root: TreeNode\n         :rtype: List[List[str]]\n         """\n         height = get_tree_height(root, 0)\n         rows = height\n         cols = 0\n         for i in range(height):\n             cols = cols * 2 + 1\n         result = [[""] * cols for _ in range(rows)]\n         fill_in_array(result, root, cols // 2, cols)\n         return result
class Solution:\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n        if len(edges) == 0:\n            return 0 if n == 0 else -1\n        p = [i for i in range(n)]\n        def getP(ind):\n            nonlocal p\n            if p[ind] == ind:\n                return ind\n            else:\n                res = getP(p[ind])\n                p[ind] = res\n                return res\n        cnt = 0\n        for t,u,v in edges:\n            if t == 3:\n                pu,pv = getP(u-1), getP(v-1)\n                if pu != pv:\n                    p[pv] = pu\n                    cnt += 1\n        if cnt != (n - 1):\n            pa = list(p)\n            for t,u,v in edges:\n                if t == 1:\n                    pu,pv = getP(u-1), getP(v-1)\n                    if pu != pv:\n                        p[pv] = pu\n                        cnt += 1\n            targetP = getP(0)\n            for v in range(n):\n                if getP(v) != targetP:\n                    return -1\n            p = pa\n            for t,u,v in edges:\n                if t == 2:\n                    pu,pv = getP(u-1), getP(v-1)\n                    if pu != pv:\n                        p[pv] = pu\n                        cnt += 1\n            targetP = getP(0)\n            for v in range(n):\n                if getP(v) != targetP:\n                    return -1\n        return len(edges) - cnt
class Solution:\n    def numSubmat(self, mat: List[List[int]]) -> int:\n        n, m = len(mat), len(mat[0])\n        heights = [0] * m\n        res = 0\n        for i in range(0, n):\n            stack = []\n            count = 0\n            for j in range(0, m):\n                if mat[i][j] == 1:\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            for index, height in enumerate(heights):\n                while stack and height < heights[stack[-1]]:\n                    curr = stack.pop()\n                    left = stack[-1] if stack else -1\n                    count -= (heights[curr] - height) * (curr - left)\n                count += height\n                res += count\n                stack.append(index)\n        return res\n            \n
class Solution(object):\n    def splitIntoFibonacci(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(S)\n        for i in range(1, 11):\n            for j in range(1, 11):\n                if i + j >= n:\n                    break\n                L = self.buildFibo(S, i, j)\n                if L:\n                    return L\n        return []\n    \n    def buildFibo(self, s, i, j):\n        a = s[:i]\n        b = s[i:i+j]\n        if a[0] == '0' and i > 1:\n            return []\n        if b[0] == '0' and j > 1:\n            return []\n        \n        offset = i + j\n        n = len(s)\n        x, y = int(a), int(b)\n        arr = [x, y]\n        while offset < n:\n            z = x + y\n            if z > 2147483647:\n                return []\n            \n            c = str(z)\n            k = len(c)\n            if offset + k > n or s[offset:offset+k] != c:\n                return []\n            offset += k\n            arr.append(z)\n            x, y = y, z\n        return arr
class Solution:\n    def removeSubfolders(self, folder):\n    \n        folders = folder\n    \n        folders.sort()\n        output = []\n        parent = ' '\n    \n        for folder in folders:\n            if not folder.startswith(parent):\n                output.append(folder)\n                parent = folder + '/'\n    \n        return output
# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def sumNumbers(self, root):\n         """\n         :type root: TreeNode\n         :rtype: int\n         """\n         def dfs(node, cur_num):\n             if node is None: return 0\n             my_num = cur_num * 10 + node.val\n             if node.left is None and node.right is None: return my_num\n             return dfs(node.left, my_num) + dfs(node.right, my_num)\n         \n         return dfs(root,0)
class Solution:\n     def nearestPalindromic(self, num):\n         """\n         :type n: str\n         :rtype: str\n         """\n         K = len(num)\n         candidates = set([10**K + 1, 10**(K-1) - 1])\n         Prefix = int(num[:(K+1)//2])\n \n         for start in map(str, [Prefix-1, Prefix, Prefix+1]):\n             candidates.add(start + [start, start[:-1]][K & 1][::-1])\n \n         candidates.discard(num)\n \n         return str(min(candidates, key=lambda x: (abs(int(x) - int(num)), int(x))))\n
class Solution:\n     def maximalSquare(self, matrix):\n         """\n         :type matrix: List[List[str]]\n         :rtype: int\n         """\n         if not matrix:\n             return 0\n \n         m, n = len(matrix), len(matrix[0])\n         dp = [int(matrix[i][0]) for i in range(m)]\n         vmax = max(dp)    \n         pre = 0   \n         for j in range(1, n):\n             pre, dp[0] = int(matrix[0][j-1]), int(matrix[0][j])\n             for i in range(1, m):\n                 cur = dp[i]\n                 dp[i] = 0 if matrix[i][j] == '0' else (min(dp[i-1], dp[i], pre) + 1) \n                 pre = cur\n             vmax = max(vmax, max(dp))\n         return vmax ** 2
# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def splitBST(self, root,target):\n         """\n         :type root: TreeNode\n         :type V: int\n         :rtype: List[TreeNode]\n         """\n         \n         def split_bst_recur(root, target):\n             if not root:\n                 return (None, None)\n             \n             if not root.left and not root.right:\n                 if root.val <= target:\n                     return (root, None)\n                 else:\n                     return(None, root)\n             \n             if root.val > target:\n                 l, r = split_bst_recur(root.left, target)\n                 root.left = r\n                 return (l, root)\n             else:\n                 l, r = split_bst_recur(root.right, target)\n                 root.right = l\n                 return (root, r)\n         \n         if not root:\n             return [[],[]]\n         \n         l, r = split_bst_recur(root, target)\n         return [l, r]\n             \n
class Solution:\n     def isIdealPermutation(self, A):\n         """\n         :type A: List[int]\n         :rtype: bool\n         """\n         # tle\n         # for i in range(len(A)-2):\n             # if A[i] > min(A[i+2:]):\n                 # return False\n         # return True\n                 \n         # ac\n         for i in range(len(A)):\n             if abs(A[i] - i) > 1:\n                 return False\n         return True
# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def postorderTraversal(self, root):\n         """\n         :type root: TreeNode\n         :rtype: List[int]\n         """\n         if root==None:\n             return []\n         stack=[]\n         stack_left=[1]\n         while stack_left!=[]:\n             stack.append(root.val)\n             if root.left!=None and root.right==None:\n                 root=root.left\n             elif root.left==None and root.right!=None:\n                 root=root.right\n             elif root.left!=None and root.right!=None:\n                 stack_left.append(root.left)\n                 root=root.right\n             else:\n                 if stack_left==[1]:\n                     stack_left=[]\n                 else:\n                     root=stack_left.pop()\n         #print(stack)\n         stack.reverse()\n         return stack\n         
class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.add = []\n        self.limit = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.limit:\n            self.stack.append(x)\n            self.add.append(0)\n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        result = self.stack.pop()\n        left = self.add.pop()\n        if len(self.add) > 0:\n            self.add[-1] += left\n        return result + left\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) > 0:\n            if k > len(self.stack):\n                self.add[-1] += val\n                return\n            self.add[k-1] += val\n        \n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n
class MagicDictionary:\n \n     def __init__(self):\n         """\n         Initialize your data structure here.\n         """\n         self.l = []\n \n     def buildDict(self, dict):\n         """\n         Build a dictionary through a list of words\n         :type dict: List[str]\n         :rtype: void\n         """\n         self.l= dict\n \n     def search(self, word):\n         """\n         Returns if there is any word in the trie that equals to the given word after modifying exactly one character\n         :type word: str\n         :rtype: bool\n         """\n         def diffnumber(a,b):\n             count = 0\n             for i in range(len(a)):\n                 if a[i] !=b[i]:\n                     count +=1\n             return count\n         for x in self.l:\n             if len(x) == len(word) and diffnumber(x,word) ==1:\n                 return True\n         return False\n                 \n                 \n         \n \n \n # Your MagicDictionary object will be instantiated and called as such:\n # obj = MagicDictionary()\n # obj.buildDict(dict)\n # param_2 = obj.search(word)\n
class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        count = 0 \n        for i in range(1,len(grid)-1):\n            for j in range(1,len(grid[0])-1):\n                if grid[i][j] ==0 and self.dfs(grid,i,j):\n                    count+=1\n        return count \n    def dfs(self,grid,i,j):\n        if grid[i][j]==1:\n            return True\n        if i<=0 or j<=0 or i>=len(grid)-1 or j>= len(grid[0])-1:\n            return False\n        grid[i][j]=1\n        up= self.dfs(grid,i+1,j)\n        down= self.dfs(grid,i-1,j)\n        left= self.dfs(grid,i,j-1)\n        right= self.dfs(grid,i,j+1)\n        return up and down and left and right
class Solution:\n    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:\n        out = []\n        for word in words:\n            pat_dict = dict()\n            used = set()\n            if len(word) == len(pattern):\n                can_be = True\n                for i in range(len(word)):\n                    if word[i] not in pat_dict:\n                        if pattern[i] not in used:\n                            pat_dict[word[i]] = pattern[i]\n                            used.add(pattern[i])\n                        else:\n                            can_be = False\n                            break\n                    else:\n                        if pat_dict[word[i]] != pattern[i]:\n                            can_be = False\n                            break\n                if can_be == True:\n                    out.append(word)\n        return out
class Solution:\n    def largestTimeFromDigits(self, A: List[int]) -> str:\n        max_time = -1\n        # enumerate all possibilities, with the permutation() func\n        for h, i, j, k in itertools.permutations(A):\n            hour = h*10 + i\n            minute = j*10 + k\n            if hour < 24 and minute < 60:\n                max_time = max(max_time, hour * 60 + minute)\n        \n        if max_time == -1:\n            return \"\"\n        else:\n            return \"{:02d}:{:02d}\".format(max_time // 60, max_time % 60)
class Skiplist:\n    def __init__(self):\n        self.skip_list={}\n        \n\n    def search(self, target: int) -> bool:\n        if(target in self.skip_list):\n            if(self.skip_list[target]>0):\n                return True\n        return False\n        \n\n    def add(self, num: int) -> None:\n        if(num in self.skip_list):\n            self.skip_list[num]+=1\n        else:\n            self.skip_list[num]=1\n        \n\n    def erase(self, num: int) -> bool:\n        if(num in self.skip_list):\n            if(self.skip_list[num]>0):\n                self.skip_list[num]-=1\n                return True\n        return False
class Solution:\n  def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\n    count = [0] * (len(nums) + 1)\n    for start, end in requests:\n      count[start] += 1\n      count[end + 1] -= 1\n    for i in range(1, len(nums) + 1):\n      count[i] += count[i - 1]\n    count.pop()\n\n    res = 0\n    for n, times in zip(sorted(nums), sorted(count)):\n      res += n * times\n\n    return res % (10 ** 9 + 7)\n    \n
class Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        if not dislikes:\n            return True\n        group = [None] * (N + 1)\n        group[dislikes[0][0]] = 1\n        group[dislikes[0][1]] = -1\n        group1 = set([1])\n        group2 = set()\n        counter = 2\n        for i, j in dislikes[1:]:\n            if group[i] and group[j]:\n                if group[i] == group[j]:\n                    return False\n                if group[i] in group1:\n                    if group[j] in group1 or -group[j] in group2:\n                        return False\n                    group2.add(group[j])\n                elif group[i] in group2:\n                    if group[j] in group2 or -group[j] in group1:\n                        return False\n                    group1.add(group[j])\n                elif group[j] in group1:\n                    if group[i] in group1 or -group[i] in group2:\n                        return False\n                    group2.add(group[i])\n                elif group[j] in group2:\n                    if group[i] in group2 or -group[i] in group1:\n                        return False\n                    group1.add(group[i])\n            elif not group[i] and not group[j]:\n                group[i], group[j] = counter, -counter\n                counter += 1\n            elif group[i]:\n                group[j] = -group[i]\n            elif group[j]:\n                group[i] = -group[j]\n        return True
import math\nclass ProductOfNumbers:\n\n    def __init__(self):\n        self.numbers = [1]\n        self.lastZero = 0\n\n    def add(self, num: int) -> None:\n        if num != 0:\n            self.numbers.append(self.numbers[-1] * num)\n        else:\n            self.numbers = [1]\n            \n\n    def getProduct(self, k: int) -> int:\n        if k < len(self.numbers):\n            return self.numbers[-1] // self.numbers[-k - 1]\n        else:\n            return 0\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n
# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def buildTree(self, preorder, inorder):\n         """\n         :type preorder: List[int]\n         :type inorder: List[int]\n         :rtype: TreeNode\n         """\n         def build(stop):\n             if preorder and inorder[-1] != stop:\n                 root = TreeNode(preorder.pop())\n                 root.left = build(root.val)\n                 inorder.pop()\n                 root.right = build(stop)\n                 return root\n             return None # can be skipped\n         \n         preorder.reverse()\n         inorder.reverse()\n         return build(None)
class Solution:\n     def searchMatrix(self, matrix, target):\n         """\n         :type matrix: List[List[int]]\n         :type target: int\n         :rtype: bool\n         """\n         m = len(matrix)\n         if m == 0:\n             return False\n         n = len(matrix[0])\n         if n == 0:\n             return False\n         row, col = 0, n-1\n         while row < m and col >= 0:\n             if matrix[row][col] == target:\n                 return True\n             elif matrix[row][col] > target:\n                 col -= 1\n             else:\n                 row += 1\n         return False\n
class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        res = [i ^ (i >> 1) for i in range(1 << n)]\n        \n        idx = res.index(start)\n        return res[idx:] + res[:idx]
import heapq\n class Solution(object):\n     def pourWater(self, heights, V, K):\n         """\n         :type heights: List[int]\n         :type V: int\n         :type K: int\n         :rtype: List[int]\n         """\n \n         heap = []\n         heapq.heappush(heap, (heights[K], -1, 0))\n         l, r = K - 1, K + 1\n         lh, rh = [], []\n \n         for i in range(V):\n             while l >= 0 and heights[l] <= heights[l + 1]:\n                 heapq.heappush(lh, (heights[l], -l))\n                 l -= 1\n \n             while r < len(heights) and heights[r] <= heights[r - 1]:\n                 heapq.heappush(rh, (heights[r], r))\n                 r += 1\n \n             if lh and lh[0][0] < heights[K]:\n                 h, i = heapq.heappop(lh)\n                 heights[-i] += 1\n                 heapq.heappush(lh, (h + 1, i))\n                 continue\n \n             if rh and rh[0][0] < heights[K]:\n                 h, i = heapq.heappop(rh)\n                 heights[i] += 1\n                 heapq.heappush(rh, (h + 1, i))\n                 continue\n \n             heights[K] += 1\n \n         return heights\n
class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        \n        \n        G = [[[], []] for i in range(n)]\n        for i, j in red_edges: G[i][0].append(j)\n        for i, j in blue_edges: G[i][1].append(j)\n        res = [[0, 0]] + [[n * 2, n * 2] for i in range(n - 1)]\n        bfs = [[0, 0], [0, 1]]\n        for i, c in bfs:\n            # print(i, c)\n            for j in G[i][c]:\n                if res[j][c] == n * 2:\n                    res[j][c] = res[i][1 - c] + 1\n                    bfs.append([j, 1 - c])\n            # print(bfs)\n        return [x if x < n * 2 else -1 for x in map(min, res)]
class Solution:\n    def longestAwesome(self, s: str) -> int:\n        cum = [0]\n        firsts = {0: -1}\n        lasts = {0: -1}\n        for i, c in enumerate(s):\n            cum.append(cum[-1] ^ (1 << (ord(c) - 48)))\n            if cum[-1] not in firsts:\n                firsts[cum[-1]] = i\n            lasts[cum[-1]] = i\n        mx = 1\n        for k in firsts:\n            mx = max(mx, lasts[k] - firsts[k])\n            for off in range(10):\n                o = k ^ (1 << off)\n                if o in firsts:\n                    mx = max(mx, lasts[o] - firsts[k])\n        return mx
class Solution:\n     def findLongestChain(self, pairs):\n         """\n         :type pairs: List[List[int]]\n         :rtype: int\n         """\n         pairs = sorted(pairs,key=lambda x:x[1])\n         res = 1\n         first = pairs[0]\n         for i in pairs[1:]:\n             if first[-1] < i[0]:\n                 res += 1\n                 first = i\n         return res\n
class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        sloc = sorted([(x,i) for i,x in enumerate(locations)])\n        froutes = [[0]*n for _ in range(fuel+1) ]\n        st,fn = -1,-1\n        for i in range(n):\n            if sloc[i][1] == start:\n                st = i\n            if sloc[i][1] == finish:\n                fn = i\n        froutes[fuel][st] = 1\n        f0 = fuel\n        while fuel > 0:\n            for i, cnt in enumerate(froutes[fuel]):\n                if cnt > 0:\n                    for j in range(i-1, -1, -1):\n                        dist = sloc[i][0] - sloc[j][0]\n                        if dist <= fuel:\n                            froutes[fuel - dist][j] += cnt\n                        else:\n                            break\n                    for j in range(i+1, n):\n                        dist = sloc[j][0] - sloc[i][0]\n                        if dist <= fuel:\n                            froutes[fuel - dist][j] += cnt\n                        else:\n                            break\n            fuel -= 1\n        res = 0\n        for i in range(f0+1):\n            res += froutes[i][fn]\n        return res % (10**9+7)
class CombinationIterator:\n    def __init__(self, characters: str, combinationLength: int):\n        self.nextCombIt = combinations(characters, combinationLength)\n        self.nextComb = next(self.nextCombIt, None)\n\n    def __next__(self) -> str:\n        nextComb = self.nextComb\n        self.nextComb = next(self.nextCombIt, None)\n        return ''.join(nextComb)\n\n    def hasNext(self) -> bool:\n        return self.nextComb is not None\n
import re\n \n \n class Solution:\n     def removeComments(self, source):\n         """\n         :type source: List[str]\n         :rtype: List[str]\n         """\n         lines = re.sub('//.*|/\*(.|\n)*?\*/', '', '\n'.join(source)).split('\n')\n         return [line for line in lines if line]\n                 
# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        s=set(G)\n        prev_in=False\n        c=0\n        while head:\n            if head.val in s:\n                if not prev_in:\n                    c+=1 \n                prev_in=True\n            else:           \n                prev_in=False\n            head=head.__next__\n        return c\n
class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        d = defaultdict(int)\n        \n        for a, b, c in trips:\n            d[b] += a\n            d[c] -= a\n        \n        k = 0\n        for t in sorted(d.keys()):\n            k += d[t]\n            if k > capacity:\n                return False\n        return True
class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \"\"\"\n        Just move along unvisited (-1) nodes and remark them as 0 on the queue while visiting others on the path and finish them as 1. If you meet them again on the queue while visiting (being 0) it means you completed a cycle, in other words it is not safe and return back without adding.\n        \"\"\"\n        visited, result = [-1] * len(graph), []\n        \n        def explore(i):\n            visited[i] = 0\n            for v in graph[i]:\n                if visited[v] == 0 or (visited[v]==-1 and explore(v)): return True\n            visited[i] = 1\n            result.append(i)\n            return False\n        \n        for i in range(len(graph)):\n            if visited[i] == -1: explore(i)\n\n        return sorted(result)\n            
class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: (x[0], -x[1]))\n        \n        prev_end = result = 0\n        for _, end in intervals:\n            if end > prev_end:\n                result += 1; prev_end = end\n                \n        return result
import collections\n \n solved_boards = {((1,2,3),(4,5,0)): 0}\n class Solution:\n     def slidingPuzzle(self, board):\n         """\n         :type board: List[List[int]]\n         :rtype: int\n         """\n         asked = tuple(tuple(row) for row in board)\n         queue = collections.deque([((1,2,3),(4,5,0))])\n         while queue:\n             tboard = queue.popleft()\n             for next_board in next_boards(tboard):\n                 if next_board in solved_boards:\n                     continue\n                 solved_boards[next_board] = solved_boards[tboard] + 1\n                 queue.append(next_board)\n         return solved_boards.get(asked, -1)\n     \n def next_boards(board):\n     board = [list(row) for row in board]\n     zy, zx = find_zero(board)\n     for dy, dx in ((-1, 0), (0, 1), (1, 0), (0, -1)):\n         nzy, nzx = zy + dy, zx +dx\n         if nzy in range(2) and nzx in range(3):\n             board[zy][zx],board[nzy][nzx] = board[nzy][nzx],board[zy][zx]\n             yield tuple(tuple(row) for row in board)\n             board[zy][zx],board[nzy][nzx] = board[nzy][nzx],board[zy][zx]\n \n def find_zero(board):\n     for y, row in enumerate(board):\n         for x, e in enumerate(row):\n             if e == 0:\n                 return y,x
# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        \n        seen={}\n        seen[0]=dummy=ListNode(0)\n        dummy.next=head\n        prev=0\n        \n        while head:\n            prev+=head.val\n            seen[prev]=head\n            head=head.__next__\n        head=dummy\n        prev=0\n        \n        while head:\n            prev+=head.val\n            head.next=seen[prev].__next__\n            head=head.__next__\n        return dummy.__next__\n        \n        \n
import heapq\nn,m,a,b=map(int,input().split())\ngraph={i:[] for i in range(n)}\nfor i in range(m):\n    u,v,w=map(int,input().split())\n    graph[u-1].append((v-1,w))\n    graph[v-1].append((u-1,w))\ncomponents=[-1]*n\ncomp=-1\nfor i in range(n):\n    if components[i]==-1:\n        comp+=1\n        components[i]=comp\n        prev=[]\n        layer=[i]\n        while layer!=[]:\n            newlayer=[]\n            for guy in layer:\n                for guy1 in graph[guy]:\n                    if guy1[1]==a and components[guy1[0]]==-1:\n                        newlayer.append(guy1[0])\n                        components[guy1[0]]=comp\n            prev=layer[:]\n            layer=newlayer[:]\nuseless=[]\nfor guy in graph:\n    for neigh in graph[guy]:\n        if components[guy]==components[neigh[0]] and neigh[1]==b:\n            useless.append((guy,neigh))\nfor guy in useless:\n    graph[guy[0]].remove(guy[1])\ncounts=[0]*(comp+1)\nfor i in range(n):\n    counts[components[i]]+=1\nbad=[]\nfor i in range(comp+1):\n    if counts[i]<=3:\n        bad.append(i)\n        for j in range(n):\n            if components[j]==i:\n                components[j]=-1\nfor guy in bad[::-1]:\n    for i in range(n):\n        if components[i]>guy:\n            components[i]-=1\ncomp-=len(bad)\ncomp+=1\ndists=[[float("inf") for i in range(2**comp)] for j in range(n)]\ndists[0][0]=0\npq=[]\nheapq.heappush(pq,[0,0,0])\nremaining=n\nvisited=[0]*n\nwhile len(pq)>0 and remaining>0:\n    dist,vert,mask=heapq.heappop(pq)\n    if visited[vert]==0:\n        visited[vert]=1\n        remaining-=1\n    for neigh in graph[vert]:\n        if neigh[1]==b:\n            if components[vert]==components[neigh[0]] and components[vert]!=-1:\n                continue\n            if components[neigh[0]]!=-1:\n                if mask & (2**components[neigh[0]])>0:\n                    continue\n            if components[vert]!=-1:\n                maskn=mask+2**(components[vert])\n            else:\n                maskn=mask\n        else:\n            maskn=mask\n        if dist+neigh[1]<dists[neigh[0]][maskn]:\n            dists[neigh[0]][maskn]=dist+neigh[1]\n            heapq.heappush(pq,[dist+neigh[1],neigh[0],maskn])\noptimal=[str(min(dists[i])) for i in range(n)]\nprint(" ".join(optimal))
X, D = list(map(int, input().split()))\ncn = 1\nadd0 = 1 if (X&1) else 0\nans = []\nfor i in range(30,0,-1):\n	if not (X & (1<<i)): continue\n	ans += [cn]*i\n	add0 += 1\n	cn += D\nfor i in range(add0):\n	ans.append(cn)\n	cn += D\nprint(len(ans))\nprint(' '.join(map(str, ans)))\n
str = input()\nl = len(str)\na = [0] * (2 * l)\npos = [[] for i in range(26)]\nfor i, c in enumerate(str):\n    t = ord(c) - ord('a')\n    a[i] = t\n    a[i + l] = t\n    pos[t].append(i)\nans = 0\nfor c in range(26):\n    cur = 0\n    for k in range(1, l):\n        cnt = [0] * 26\n        for i in pos[c]:\n            cnt[a[i + k]] += 1\n        cur = max(cur, len(list([x for x in cnt if x == 1])))\n    ans += cur\nprint(ans / l)\n
from bisect import *\nfrom math import *\n\nn = int(input())\na, b, c, d = list(map(int,input().replace('/',' ').split()))\n\nalpha = atan2(c,d) - atan2(a,b)\ntan_alpha = tan(alpha)\n\nlis = []\n\nfor x,y in sorted((y/tan_alpha - x,y) for x,y in [ (x,y) for x,y in [(b*x + a*y,-a*x + b*y) for x, y in [list(map(int,input().split())) for _ in range(n)] if a*x - b*y <= 0 and d*y - c*x <= 0]]):\n    pos = bisect_left(lis,-y)\n    if pos == len(lis):\n        lis.append(-y)\n    else:\n        lis[pos] = -y\n\nprint(len(lis))\n\n
x = input ()\n\nflag = 0\ns = 0\n\nfor each_item in x:\n    if each_item == '0':\n        if flag == 0:\n            flag = 1;\n            continue\n        else:\n            print (each_item, end = '')\n    else:\n        if (s == len (x) - 1 and flag == 0) :\n            continue\n        print (each_item, end = '')\n    s = s + 1\n
X = [[], ['0', '1'], ['00', '01', '10', '11'], ['001', '010', '011', '100', '101', '110'], ['0010', '0011', '0100', '0101', '0110', '1001', '1010', '1011', '1100', '1101'], ['00100', '00101', '00110', '01001', '01011', '01100', '01101', '10010', '10011', '10100', '10110', '11001', '11010', '11011'], ['001001', '001011', '001100', '001101', '010010', '010011', '010110', '011001', '011010', '011011', '100100', '100101', '100110', '101001', '101100', '101101', '110010', '110011', '110100', '110110'], ['0010011', '0011001', '0011010', '0011011', '0100101', '0101100', '0101101', '0110011', '1001100', '1010010', '1010011', '1011010', '1100100', '1100101', '1100110', '1101100'], ['00110011', '01011010', '01100110', '10011001', '10100101', '11001100']]\ns = input()\nN = len(s)\nans = (N-1)*(N-2)//2\nfor i in range(N):\n    for j in range(i+3, min(i+9, N+1)):\n        if s[i:j] in X[j-i]:\n            ans -= 1\nprint(ans)\n
def gcd(a, b):\n    while b > 0:\n        a, b = b, a % b\n    return a\n\nn = int(input())\nA = list(map(int, input().split()))\n\nGCD = A[0]\nfor x in A[1:]:\n    GCD = gcd(GCD, x)\nnum = max(A) // GCD - n\nif num % 2 == 0:\n    print("Bob")\nelse:\n    print("Alice")\n\n
import sys\nfrom itertools import *\nfrom math import *\ndef solve():\n    n, m = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    ss, ll = 0, int(2.2e10)\n    while ss < ll:\n        avg = (ss + ll) // 2\n        works = True\n        hidx = 0\n        pidx = 0\n        while hidx < len(h) and pidx < len(p):\n            leftget = p[pidx]\n            curpos = h[hidx]\n            if curpos - leftget > avg:\n                works = False\n                break\n            getbacktime = max(0, 2*(curpos - leftget))\n            alsotoright = max(0, avg - getbacktime)\n            leftime = max(0, curpos - leftget)\n            remtime = max(0, (avg - leftime) // 2)\n            furthestright = curpos + max(alsotoright, remtime)\n            while pidx < len(p) and p[pidx] <= furthestright: pidx += 1\n            hidx += 1\n        if pidx != len(p): works = False\n        if works: ll = avg\n        else: ss = avg + 1\n    print(ss)\n\n\nif sys.hexversion == 50594544 : sys.stdin = open("test.txt")\nsolve()
from sys import stdin\n\n#stdin = open('input.txt')\n\nn = int(stdin.readline())\n\nseq = [int(x) for x in stdin.readline().split()]\ncarry = seq[0]\nresult = [carry]\n\nmark = False\ncur_len = 0\nmax_len = 0\n\ni = 1\nwhile i < len(seq) - 1:\n    if mark:\n        if seq[i] != seq[i + 1]:\n            cur_len += 1\n        else:\n            if cur_len > max_len:\n                max_len = cur_len\n\n            if seq[i] == carry:\n                result.extend([carry]*cur_len)\n            else:\n                result.extend([carry]*(cur_len//2))\n                result.extend([seq[i]]*(cur_len//2))\n\n            result.append(seq[i])\n            mark = False\n            cur_len = 0\n    elif seq[i] != seq[i - 1] and seq[i] != seq[i + 1]:\n        mark = True\n        cur_len = 1\n        carry = seq[i - 1]\n    else:\n        result.append(seq[i])\n\n    i += 1\n\nif mark:\n    if cur_len > max_len:\n            max_len = cur_len\n\n    if seq[i] == carry:\n        result.extend([carry]*cur_len)\n    else:\n        result.extend([carry]*(cur_len//2))\n        result.extend([seq[i]]*(cur_len//2))\n\nresult.append(seq[i])\n\nprint((max_len + 1)//2)\nfor x in result:\n    print(x, end=' ')
import random\n\nn = int(input())\nv = []\na = []\nfor i in range(n):\n    a.append(i)\n\nfor _ in range(0, n):\n    x, y = list(map(int, input().split()))\n    v.append([x, y, x*x+y*y])\n\nwhile 1>0:\n    x = 0\n    y = 0\n    ans = [0]*n\n    random.shuffle(a)\n    for i in range(n):\n        if (x+v[a[i]][0])**2+(y+v[a[i]][1])**2 <= (x-v[a[i]][0])**2+(y-v[a[i]][1])**2:\n            x += v[a[i]][0]\n            y += v[a[i]][1]\n            ans[a[i]] = 1\n        else:\n            x -= v[a[i]][0]\n            y -= v[a[i]][1]\n            ans[a[i]] = -1\n    if x*x+y*y <= 1500000**2:\n        print(*ans)\n        break\n\n
\nx = int(input())\ny = list(map(int, input().split(' ')))\n\ny[0] = 1\ny[x-1] = 1\n\nz = y[:]\nfor i in range(1, x):\n    z[i] = min(z[i], z[i-1] + 1)\n\nw = y[:]\nfor i in range(x-2, -1, -1):\n    w[i] = min(w[i], w[i+1]+1)\n\nans = 0\nfor i in range(x):\n    ans = max(ans, min(z[i], w[i]))\n\nprint(ans)\n
n=int(input())\nq=[]\nfor i in range(max(0,n-100),n+1):\n	j=i\n	res=i\n	while j:\n		res+=j%10\n		j//=10\n	if res==n:\n		q.append(i)\nprint(len(q))\nfor i in q:\n	print(i)
n = int(input())\nif n%4 > 1:\n  print(-1)\nelse:\n  a = [n+1>>1]*n\n  for i in range(n//4):\n    j = i*2\n    a[j], a[j+1], a[-2-j], a[-1-j] = j+2, n-j, j+1, n-1-j\n  print(' '.join(map(str, a)))
#!/usr/bin/env python3\n\nimport re\n\ntry:\n    while True:\n        s = input()\n        m = re.search(r"[^a]", s)\n        if m is None:\n            print(s[:-1], end="z\n")\n        else:\n            j = s.find('a', m.end())\n            if j == -1:\n                j = len(s)\n            print(end=s[:m.start()])\n            for i in range(m.start(), j):\n                print(end=chr((ord(s[i]) - 98) % 26 + 97))\n            print(s[j:])\n\nexcept EOFError:\n    pass\n
mod = 1000000007\n\ndef sum(x, y, k, add) :\n    if k < add : return 0\n    up = x + add\n    if up > k : up = k\n    add = add + 1\n    return y * ( ( (add + up) * (up - add + 1) // 2 ) % mod ) % mod\n\ndef solve(x, y, k, add = 0) :\n    if x == 0 or y == 0 : return 0\n    if x > y :\n        x, y = y, x\n    pw = 1\n    while (pw << 1) <= y :\n        pw <<= 1\n    if pw <= x :\n        return ( sum(pw, pw, k, add)\\n                 + sum(pw, x + y - pw - pw, k, add + pw)\\n                 + solve(x - pw, y - pw, k, add) ) % mod\n    else :\n        return ( sum(pw, x, k, add)\\n                 + solve(x, y - pw, k, add + pw) ) % mod\n\nq = int(input())\nfor i in range(0, q) :\n    x1, y1, x2, y2, k = list(map(int, input().split()))    \n    ans = ( solve(x2, y2, k)\\n            - solve(x1 - 1, y2, k)\\n            - solve(x2, y1 - 1, k)\\n            + solve(x1 - 1, y1 - 1, k) ) % mod\n    if ans < 0 : ans += mod\n    print(ans)\n
import sys\n\nn = int(input())\n\nv = [ list(map(int, input().split())) for i in range(n)]\n\nres = []\n\nfor i in range(n):\n	if v[i][2] >= 0:\n		res.append(i + 1)\n		dec = 0\n		for j in range(i + 1, n):\n			if v[j][2] >= 0:\n				if v[i][0] > 0:\n					v[j][2] -= v[i][0]\n					v[i][0] -= 1\n				v[j][2] -= dec\n				if v[j][2] < 0: dec += v[j][1]\n\nprint(len(res))\nprint(" ".join(map(str, res)))
import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nW=[0]+list(map(int,input().split()))\nE=[tuple(map(int,input().split())) for i in range(m)]\nS=int(input())\n\nELIST=[[] for i in range(n+1)]\nEW=[0]*(n+1)\n\nfor x,y in E:\n    ELIST[x].append(y)\n    ELIST[y].append(x)\n\n    EW[x]+=1\n    EW[y]+=1\n\n\nfrom collections import deque\nQ=deque()\nUSED=[0]*(n+1)\n\nfor i in range(1,n+1):\n    if EW[i]==1 and i!=S:\n        USED[i]=1\n        Q.append(i)\n\nEW[S]+=1<<50\nUSED[S]=1\n\nwhile Q:\n    x=Q.pop()\n    EW[x]-=1\n\n    for to in ELIST[x]:\n        if USED[to]==1:\n            continue\n        EW[to]-=1\n\n        if EW[to]==1 and USED[to]==0:\n            Q.append(to)\n            USED[to]=1\n\n#print(EW)\nLOOP=[]\n\nANS=0\nfor i in range(1,n+1):\n    if EW[i]!=0:\n        ANS+=W[i]\n        LOOP.append(i)\n\nSCORE=[0]*(n+1)\nUSED=[0]*(n+1)\n\nfor l in LOOP:\n    SCORE[l]=ANS\n    USED[l]=1\n\nQ=deque(LOOP)\n\nwhile Q:\n    x=Q.pop()\n\n    for to in ELIST[x]:\n        if USED[to]==1:\n            continue\n\n        SCORE[to]=W[to]+SCORE[x]\n        Q.append(to)\n        USED[to]=1\n\nprint(max(SCORE))\n
n = int(input())\n\nxs = [int(x) for x in input().split()]\n\nseen = {}\n\nres = 0\n\nwhile xs:\n    j = xs.index(xs[0], 1)\n    res += j - 1\n    xs = xs[1:j] + xs[j+1:]\n\nprint(res)\n
n,m=map(int,input().split());a=list(map(int,input().split()));p=0;t=[0]*3\nfor i in range(n):\n    if(a[i]<a[p]):p=i   \nif(n==2):print('0\n1 1\n')\nelse:\n    a.sort();t[0]=min(a[0]+a[1]+m,a[1]+a[2]);t[1]=max(a[0]+a[n-1]+m,a[n-2]+a[n-1]);t[2]=(a[n-2]+a[n-1])-(a[0]+a[1])\n    if(t[1]-t[0]>t[2]):p=n\n    else:t[2]=t[1]-t[0]\n    print(t[2]) \n    for i in range(n):print(int(i==p)+1,end=' ')
n = int(input())\na = list(map(int, input().split()))\nr = n-2\nfor d in a:\n    r += d\nprint(max(max(a), r//(n-1)))\n
import math\n#import fractions\nfrom functools import reduce\n\nn = int(input())\nodd = -1\nbeads = [int(x) for x in input().split()]\nfor i in range(n):\n    if beads[i]%2:\n        if odd >= 0:\n            print(0)\n            print(''.join(chr(ord('a') + i)*beads[i] for i in range(n)))\n            break\n        else:\n            odd = i\nelse:\n    gcd = reduce(lambda x,y: math.gcd(x,y), beads)\n    print(gcd)\n    if odd >= 0:\n        s = ''.join(chr(ord('a') + i)*(beads[i]//(2*gcd)) for i in range(n) if i != odd)\n        p = s + chr(ord('a') + odd)*(beads[odd]//gcd) + s[::-1]\n        print(p*gcd)\n    else:\n        s = ''.join(chr(ord('a') + i)*(beads[i]//gcd) for i in range(n))\n        p = s + s[::-1]\n        print(p*(gcd//2))\n
def main():\n    n, m = list(map(int, input().split()))\n    l = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = list(map(int, input().split()))\n        l[u].append(v)\n        l[v].append(u)\n    res = [0] * (n + 1)\n    for u, x in enumerate(res):\n        if not x:\n            x, nxt = -1, [u]\n            while nxt:\n                x, cur, nxt = -x, nxt, []\n                for u in cur:\n                    if l[u]:\n                        res[u] = x\n                        for v in l[u]:\n                            if not res[v]:\n                                nxt.append(v)\n                            elif res[v] == x:\n                                print(-1)\n                                return\n    for x in -1, 1:\n        l = [u for u in range(1, n + 1) if res[u] == x]\n        print(len(l))\n        print(' '.join(map(str, l)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n,m=map(int,input().split())\nif n==1and m==1:print('YES\n1')\nelif n==3and m==3:\n    print('YES')\n    print(6, 1, 8)\n    print(7,5,3)\n    print(2,9,4)\nelif n<4and m<4:print('NO')\nelif n==1 or m==1:\n    t=max(n,m)\n    a=[i for i in range(2,t+1,2)]\n    a+=[i for i in range(1,t+1,2)]\n    print('YES')\n    for i in a:print(i,end="");print([' ','\n'][m==1],end='')\nelse:\n    a=[]\n    for j in range(n):\n        a.append([int(i)+int(m*j) for i in range(1,m+1)])\n    if n<=m:\n        for j in range(1,m,2):\n            t=a[0][j]\n            for i in range(1,n):\n                a[i-1][j]=a[i][j]\n            a[n-1][j]=t\n        for i in range(1,n,2):\n            r,s=a[i][0],a[i][1]\n            for j in range(2,m):\n                a[i][j-2]=a[i][j]\n            a[i][m-2],a[i][m-1]=r,s\n    else:\n        for j in range(1,m,2):\n            r,s=a[0][j],a[1][j]\n            for i in range(2,n):\n                a[i-2][j]=a[i][j]\n            a[n-2][j], a[n-1][j] = r, s\n        for i in range(1,n,2):\n            t=a[i][0]\n            for j in range(1,m):\n                a[i][j-1]=a[i][j]\n            a[i][m-1]=t\n    print('YES')\n    for i in range(n):\n        print(*a[i])
from math import sqrt\nn = int(input())\nk = int(sqrt(n))\nb = []\nlast = 0\nwhile last < n:\n    b.append([last + j for j in range(k)])\n    last = b[-1][-1] + 1\nk = len(b)\nfor i in range(k - 1, -1, -1):\n    for j in b[i]:\n        if j < n:\n            print(1 + j, end=' ')\nprint()\n
n = input()\nread = input()\np = []\nfor x in read.split():\n    p.append((float)(x))\n    \nv = 0.0\nl = 0.0\nfor item in p:\n    v = v*(1-item) + item*(v + 2*l + 1)\n    l = (l + 1)*item\nprint(v)\n
def main():\n    n = int(input())\n    result = []\n    for i in range(2, n + 1):\n        j = 2\n        while j * j <= i:\n            if i % j == 0:\n                break\n            j += 1\n        else:\n            j = i\n            while j <= n:\n                result.append(j)\n                j *= i\n    \n    print(len(result))\n    print(' '.join(str(i) for i in result))\n    \n    \n    \nmain()\n
n, d = map(int, input().split())\na = [0] + list(map(int, input().split())) + [0]\nx = []\ny = []\nfor i in range(n):\n  xx, yy = map(int, input().split())\n  x += [xx]\n  y += [yy]\nb = [-1] * n\nb[0] = 0\nc = True\nwhile c:\n  c = False\n  for i in range(n):\n    for j in range(1, n):\n      if i != j and b[i] != -1:\n        t = b[i] + (abs(x[i] - x[j]) + abs(y[i] - y[j])) * d - a[j]\n        if b[j] == -1 or t < b[j]:\n          b[j] = t\n          c = True\nprint(b[-1])
t = input()\na, b = [i for i, d in enumerate(t, 1) if d == 'l'], [i for i, d in enumerate(t, 1) if d == 'r']\na.reverse()\nprint('\n'.join(map(str, b)))\nprint('\n'.join(map(str, a)))
\ndef solve(s):\n    n = len(s)\n\n    for i in range(n):\n        s2 = s[i:] + s[:i]\n        # print(s2)\n        if s != s2 and s2[::-1] == s2:\n            return 1\n\n    for i in range( (n // 2) + 1, n):\n        if s[i] != s[0]:\n            return 2\n        # print(s[i])\n    return "Impossible"\n\ns = input()\nprint(solve(s))\n
def main():\n    n = int(input())\n    ans = [0] * (2 * n)\n    for i in range(n):\n        a = 2 * i + 1\n        b = 2 * i + 2\n        if i & 1:\n            ans[i] = a\n            ans[i + n] = b\n        else:\n            ans[i] = b\n            ans[i + n] = a\n    ans *= 2\n    curr = sum(ans[:n])\n    mi = curr\n    ma = curr\n    for i in range(n, 4 * n):\n        curr -= ans[i - n]\n        curr += ans[i]\n        mi = min(mi, curr)\n        ma = max(ma, curr)\n    if ma - mi > 1:\n        print("NO")\n    else:\n        print("YES")\n        print(*ans[:2*n])\n    return 0\n\nmain()
from collections import defaultdict\nfrom collections import deque\nfrom functools import reduce\nn, x, y = [int(x) for x in input().split()]\nE = defaultdict(set)\nfor i in range(n-1):\n    u, v = [int(x) for x in input().split()]\n    E[u].add(v)\n    E[v].add(u)\n\nif x > y:\n    for v in E:\n        if len(E[v]) == n-1:\n            print((n-2)*y + x)\n            break\n        elif len(E[v]) > 1:\n            print((n-1)*y)\n            break\nelse:\n    visited = {v : False for v in E}\n    stack = [1]\n    topsorted = deque()\n    while stack:\n        v = stack.pop()\n        if visited[v]: continue\n        visited[v] = True\n        topsorted.appendleft(v)\n        stack.extend(E[v])\n    chopped = set()\n    ans = 0\n    for v in topsorted:\n        ans += max(0, len(E[v])-2)\n        if len(E[v]) > 2:\n            S = E[v].intersection(chopped)\n            S1 = {S.pop(), S.pop()}\n            for u in E[v]:\n                if not u in S1:\n                    E[u].remove(v)\n            E[v].clear()\n            E[v].update(S1)\n        chopped.add(v)\n    print(ans*y + (n-1-ans)*x)\n        \n
def main():\n    import sys\n    input = sys.stdin.readline\n\n    N, M = list(map(int, input().split()))\n    L = list(map(int, input().split()))\n\n    if sum(L) < N:\n        print(-1)\n        return\n\n    ans = [0] * M\n    left = N\n    for i in range(M-1, -1, -1):\n        if left - L[i] >= i:\n            ans[i] = left - L[i] + 1\n            left -= L[i]\n        else:\n            if i+L[i]-1 >= N:\n                print(-1)\n                return\n            ans[i] = i+1\n            left = i\n    print(*ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\ndef LI(): return list(map(int, input().split()))\ndef II(): return int(input())\ndef LS(): return input().split()\ndef S(): return input()\n\n\ndef main():\n    n = II()\n    d = collections.defaultdict(set)\n    for _ in range(n-1):\n        a,b = LI()\n        d[a].add(b)\n        d[b].add(a)\n\n    memo = [-1] * (n+1)\n    def path(t,s):\n        ps = set()\n        dt = list(d[t])\n        for k in dt:\n            if memo[k] < 0:\n                continue\n            ps.add(memo[k])\n\n        if s == -1 and len(ps) == 2:\n            memo[t] = sum(ps) + 2\n            return memo[t]\n\n        if len(ps) > 1:\n            return -t\n\n        if len(ps) == 0:\n            memo[t] = 0\n            return 0\n\n        memo[t] = list(ps)[0] + 1\n        return memo[t]\n\n    def _path(tt,ss):\n        f = [False] * (n+1)\n        q = [(tt,ss)]\n        tq = []\n        qi = 0\n        while len(q) > qi:\n            t,s = q[qi]\n            for k in d[t]:\n                if k == s or memo[k] >= 0:\n                    continue\n                q.append((k,t))\n            qi += 1\n        for t,s in q[::-1]:\n            r = path(t,s)\n            if r < 0:\n                return r\n        return memo[tt]\n\n    t = _path(1,-1)\n    if t < 0:\n        t = _path(-t,-1)\n\n    if t > 0:\n        while t%2 == 0:\n            t//=2\n        return t\n\n    return -1\n\nprint(main())\n
h = int(input())\na = list(map(int, input().split()))\n\nw, q = [], []\np = r = 0\n\nfor i in a:\n    for j in range(i):\n        w.append(r)\n        q.append(r - (j and p > 1))\n\n    p = i\n    r += i\n\nif w == q:\n    print('perfect')\nelse:\n    print('ambiguous')\n    print(*w)\n    print(*q)\n
import sys\ninput = sys.stdin.readline\n\nn = int(input())\nx = []\ny = []\nfor i in range(n):\n    xi, yi = map(int, input().split())\n    x.append(xi)\n    y.append(yi)\nmin_x = min(x)\nmax_x = max(x)\nmin_y = min(y)\nmax_y = max(y)\nanswer = 0\nfor i in range(n):\n    dx = max(max_x - x[i], x[i] - min_x)\n    dy = max(max_y - y[i], y[i] - min_y)\n    answer = max(answer, dx + dy)\nprint(2*answer, end = ' ')\nfor i in range(4, n + 1):\n    print(2*(max_x - min_x + max_y - min_y), end = ' ')
MOD = 998244353\nBOUND = 19\n \nn, m = list(map(int, input().split()))\nl = list(map(int,input().split()))\n \nbasis = []\nfor p in range(m-1,-1,-1):\n    p2 = pow(2,p)\n    nex = -1\n    for i in range(n):\n        if l[i] >= p2:\n            nex = l[i]\n            break\n    if nex != -1:\n        basis.append(nex)\n        for i in range(n):\n            if l[i] >= p2:\n                l[i] ^= nex\n        \nextra = n - len(basis)\n\ndef add(a, b):\n    out = [0] * (max(len(a), len(b)))\n    for i in range(len(a)):\n        out[i] = a[i]\n    for i in range(len(b)):\n        out[i] += b[i]\n        out[i] %= MOD\n    return out\n    \n \ndef addSh(a, b):\n    out = [0] * (max(len(a) + 1, len(b)))\n    for i in range(len(a)):\n        out[i + 1] = a[i]\n    for i in range(len(b)):\n        out[i] += b[i]\n        out[i] %= MOD\n    return out\n \ni = 0\ncurr = dict()\ncurr[0] = [1]\nfor p in range(m-1,-1,-1):\n    p2 = pow(2,p)\n    if i < len(basis) and basis[i] >= p2:\n        currN = dict(curr)\n        for v in curr:\n            if v ^ basis[i] not in currN:\n                currN[v ^ basis[i]] = [0]\n            currN[v ^ basis[i]] = add(curr[v], currN[v ^ basis[i]])\n        curr = currN\n        i += 1\n \n    currN = dict(curr)\n    for v in curr:\n        if v >= p2:\n            if v ^ p2 not in currN:\n                currN[v ^ p2] = [0]\n            currN[v ^ p2] = addSh(curr[v], currN[v ^ p2])\n            del currN[v]\n    curr = currN  \n \nout = curr[0]\nwhile len(out) < m + 1:\n    out.append(0)\nfor i in range(m + 1):\n    out[i] *= pow(2, extra, MOD)\n    out[i] %= MOD\nprint(' '.join(map(str,out)))\n
import sys\ninput = sys.stdin.readline\n\nn,k=list(map(int,input().split()))\nif k==0:\n    print(0)\n    return\n\nA=sorted(map(int,input().split()))\n\n# DP[UL][n][left]\n# [left*pow(2,n),left*pow(2,n)+pow(2,n)),\n# \n# UL=0: upperlower\n# UL=1: upper\n# UL=2: lower\n# .\n\nDP=[[[0]*((1<<n)+2) for i in range(n+1)] for UL in range(3)]\n\nfor i in range(k):\n    if A[i]%2==1:\n        DP[1][1][A[i]]=1\n        DP[2][1][A[i]]=1\n    else:\n        DP[1][1][A[i]-1]=1\n        DP[2][1][A[i]-1]=1\n\n    if i<k-1 and A[i]%2==1 and A[i+1]==A[i]+1:\n        DP[0][1][A[i]]=1\n        \nfor i in range(2,n+1):\n    for left in range(1,(1<<n)+1,1<<i):\n\n        if DP[0][i-1][left]:\n            DP[0][i][left]=max(DP[0][i-1][left] + DP[0][i-1][left+(1<<(i-1))] + 3,DP[0][i-1][left] + DP[1][i-1][left+(1<<(i-1))] + 3,\\n                               DP[0][i-1][left] + DP[2][i-1][left+(1<<(i-1))] + 3)\n            \n        if DP[0][i-1][left+(1<<(i-1))]:\n            DP[0][i][left]=max(DP[0][i][left], DP[0][i-1][left] + DP[0][i-1][left+(1<<(i-1))] + 3,\\n                               DP[1][i-1][left] + DP[0][i-1][left+(1<<(i-1))] + 3,DP[2][i-1][left] + DP[0][i-1][left+(1<<(i-1))] + 3)\n\n        if DP[1][i-1][left]:\n            DP[1][i][left]=max(DP[1][i][left], DP[1][i-1][left] + 1)\n            DP[2][i][left]=max(DP[2][i][left], DP[1][i-1][left] + 2)\n\n        if DP[2][i-1][left]:\n            DP[2][i][left]=max(DP[2][i][left], DP[2][i-1][left] + 2)\n\n        if DP[1][i-1][left+(1<<(i-1))]:\n            DP[1][i][left]=max(DP[1][i][left], DP[1][i-1][left+(1<<(i-1))] + 1)\n            DP[2][i][left]=max(DP[2][i][left], DP[1][i-1][left+(1<<(i-1))] + 2)\n\n        if DP[2][i-1][left+(1<<(i-1))]:\n            DP[2][i][left]=max(DP[2][i][left], DP[2][i-1][left+(1<<(i-1))] + 2)\n\n\n        if DP[1][i-1][left] and DP[1][i-1][left+(1<<(i-1))]:\n            DP[0][i][left]=max(DP[0][i][left], DP[1][i-1][left] + DP[1][i-1][left+(1<<(i-1))] + 2)\n\n        if DP[1][i-1][left] and DP[2][i-1][left+(1<<(i-1))]:\n            DP[0][i][left]=max(DP[0][i][left], DP[1][i-1][left] + DP[2][i-1][left+(1<<(i-1))] + 3)\n\n        if DP[2][i-1][left] and DP[1][i-1][left+(1<<(i-1))]:\n            DP[0][i][left]=max(DP[0][i][left], DP[2][i-1][left] + DP[1][i-1][left+(1<<(i-1))] + 3)\n\n        if DP[2][i-1][left] and DP[2][i-1][left+(1<<(i-1))]:\n            DP[2][i][left]=max(DP[2][i][left], DP[2][i-1][left] + DP[2][i-1][left+(1<<(i-1))] + 2)\n\n\n"""                          \nfor i in range(n+1):\n    print(DP[0][i])\nprint()\nfor i in range(n+1):\n    print(DP[1][i])\nprint()\nfor i in range(n+1):\n    print(DP[2][i])\nprint()\nfor i in range(n+1):\n    print(DP[0][0][i])\n"""\nprint(max(DP[0][n][1],DP[1][n][1],DP[2][n][1])+1)\n
# python3\nimport sys\nfrom collections import namedtuple\n\n\ndef readline(): return list(map(int, input().split()))\n\n\ndef readlines():\n    for line in sys.stdin.readlines():\n        yield list(map(int, line.split()))\n\n\nclass State(namedtuple('State', 'payload time floor')):\n    def hook(self, pivot, a, b):\n        lo, up = min(pivot, a, self.floor), max(pivot, a, self.floor)\n        return tuple(x for x in self.payload if x < lo or up < x) + (b,), \\n            self.time + abs(self.floor - pivot) + abs(pivot - a)\n\n    def choices_to_take_next(self, a, b):\n        floor = self.floor\n\n        payload, time = self.hook(floor, a, b)\n        if len(payload) < 5:\n            yield payload, time\n            if floor > a:\n                pivots = (x for x in self.payload if x > floor)\n            elif floor == a:\n                pivots = ()\n            else:\n                pivots = (x for x in self.payload if x < floor)\n        else:\n            pivots = self.payload\n\n        for pivot in pivots:\n            yield self.hook(pivot, a, b)\n\n\ndef time_to_get_free(payload, floor):\n    if payload:\n        lo, up = min(payload), max(payload)\n        return abs(lo-up) + min(abs(floor-lo), abs(floor-up))\n    else:\n        return 0\n\n\ndef main():\n    n, = readline()\n\n    floor = 1\n    positions = {(): 0}  # empty elevator, time = 0\n    for (a, b) in readlines():\n        max_acceptable_time = min(positions.values()) + 16 - abs(floor - a)\n\n        new_positions = dict()\n        for payload, time in list(positions.items()):\n            state = State(payload, time, floor)\n            for npayload, ntime in state.choices_to_take_next(a, b):\n                if ntime <= max_acceptable_time:\n                    npayload = tuple(sorted(npayload))\n                    if new_positions.setdefault(npayload, ntime) > ntime:\n                        new_positions[npayload] = ntime\n\n        positions = new_positions\n        floor = a\n\n    return min(t + time_to_get_free(p, floor) for p, t in list(positions.items())) \\n        + 2 * n\n\n\nprint(main())\n
import sys\n\nn, m = [int(x) for x in input().split()]\n\nadj_for = [[] for _ in range(n)]\nadj_back = [[] for _ in range(n)]\n\nfor _ in range(m):\n    a, b = [int(x) for x in sys.stdin.readline().split()]\n    a -= 1\n    b -= 1\n    adj_for[a].append(b)\n    adj_back[b].append(a)\n\n\nlens = [len(adj_back[i]) for i in range(n)]\nstack = [x for x in range(n) if lens[x] == 0]\ntoposort = [x for x in range(n) if lens[x] == 0]\n\nwhile len(stack):\n    cur = stack.pop()\n    for nb in adj_for[cur]:\n        lens[nb] -= 1\n        if lens[nb] == 0:\n            toposort.append(nb)\n            stack.append(nb)\n\nif len(toposort) != n:\n    print(-1)\n    return\n\nmin_above = list(range(n))\nmin_below = list(range(n))\n\nfor i in toposort:\n    for j in adj_back[i]:\n        if min_above[j] < min_above[i]:\n            min_above[i] = min_above[j]\n\nfor i in reversed(toposort):\n    for j in adj_for[i]:\n        if min_below[j] < min_below[i]:\n            min_below[i] = min_below[j]\n\nqt = ["A" if min_below[i] == min_above[i] == i else "E" for i in range(n)]\n\n# qt = [None for x in range(n)]\n# \n# for i in range(n):\n#     if qt[i] is not None:\n#         continue\n#     qt[i] = 'A'\n#     stack_for = [i]\n#     while len(stack_for):\n#         cur = stack_for.pop()\n#         for nb in adj_for[cur]:\n#             if qt[nb] is None:\n#                 qt[nb] = 'E'\n#                 stack_for.append(nb)\n# \n# \n#     stack_back = [i]\n#     while len(stack_back):\n#         cur = stack_back.pop()\n#         for nb in adj_back[cur]:\n#             if qt[nb] is None:\n#                 qt[nb] = 'E'\n#                 stack_back.append(nb)\n# \nprint(len([x for x in qt if x == 'A']))\nprint("".join(qt))\n
import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nA=list(map(int,input().split()))\n\n\nMIN=0\nMAX=m\n\nwhile MIN!=MAX:\n    x=(MIN+MAX)//2\n    #print(x,MIN,MAX)\n    #print()\n\n    M=0\n    for a in A:\n        #print(a,M)\n        if a<=M and a+x>=M:\n            continue\n        elif a>M and a+x>=m and (a+x)%m>=M:\n            continue\n        elif a>M:\n            M=a\n        else:\n            MIN=x+1\n            break\n    else:\n        MAX=x\n\nprint(MIN)\n
n, h = map(int,input().split())\nunit = h*h/n\nfor i in range(1,n):\n    print((unit*i)**0.5, end=' ')
def main():\n    n, l = int(input()), list(map(int, input().split()))\n    if not (n & 1):\n        l.append(0)\n    l.append(150001)\n    i, b, c, fails0, fails1 = 0, 0, 150001, [], []\n    try:\n        while True:\n            a, b, c = b, c, l[i]\n            if a >= b or b <= c:\n                if len(fails0) + len(fails1) > 5:\n                    print(0)\n                    return\n                fails1.append(i - 1)\n            i += 1\n            a, b, c = b, c, l[i]\n            if a <= b or b >= c:\n                if len(fails0) + len(fails1) > 5:\n                    print(0)\n                    return\n                fails0.append(i - 1)\n            i += 1\n    except IndexError:\n        fails, res = fails0 + fails1, 0\n    for i in fails:\n        a = l[i]\n        for j in range(n):\n            f = fails1 if j & 1 else fails0\n            f.append(j)\n            l[i], l[j] = l[j], a\n            if (all(l[b - 1] > l[b] < l[b + 1] for b in fails0) and\n                    all(l[b - 1] < l[b] > l[b + 1] for b in fails1)):\n                res += 1 if j in fails else 2\n            l[j] = l[i]\n            del f[-1]\n        l[i] = a\n    print(res // 2)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
def main():\n    n, a, b, t = list(map(int, input().split()))\n    a1 = a + 1\n    b += a1\n    l, res = [b if c == "w" else a1 for c in input()], []\n    l[0] = x = l[0] - a\n    if t <= x:\n        print(int(t == x))\n        return\n    f = res.append\n    for dr in 0, 1:\n        if dr:\n            l[1:] = l[-1:-n:-1]\n        tot = t\n        for hi, x in enumerate(l):\n            tot -= x\n            if tot < 0:\n                break\n        else:\n            print(n)\n            return\n        f(hi)\n        tot += x\n        hi -= 1\n        tot -= hi * a\n        lo = n\n        while True:\n            while lo > 0 <= tot:\n                lo -= 1\n                tot -= l[lo]\n            f(n + hi - lo)\n            if not (lo and hi):\n                break\n            while tot <= 0 < hi:\n                tot += l[hi] + a\n                hi -= 1\n    print(max(res))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n = int(input())\narr = []\nfor i in range(n):\n    l,r = map(int, input().split())\n    arr.append([l,r])\n    \nlts = []\nfor i in range(n):\n    if arr[i][0] == 0:\n        l = i\n        j = i\n        while arr[j][1] != 0:\n            j = arr[j][1] - 1\n        r = j\n        lts.append([l,r])\n\nfor i in range(1, len(lts)):\n    arr[lts[i-1][1]][1] = lts[i][0] + 1\n    arr[lts[i][0]][0] = lts[i-1][1] + 1\n    \nfor i in range(n):\n    print(arr[i][0], arr[i][1])
from sys import stdin, stdout\n\nn,k = list(map(int,stdin.readline().rstrip().split()))\n\nprint(2+(n-2)//k+(n-3)//k)\n\nconnectionsList = []\n# Leaf node is 1. Make this node have connections to k children\nfor i in range(k):\n    connectionsList.append((str(1),str(i+2)))\n\n\nfor i in range(k+2,n+1):\n    connectionsList.append((str(i-k),str(i)))\n\nfor conn in connectionsList:\n    print(' '.join(conn))\n
n, m = map(int, input().split())\np, d = [0] * (n + 2), [0] * (n + 2)\nfor i in range(m):\n    l, r, x = map(int, input().split())\n    while l < x:\n        if d[l]:\n            k = d[l]\n            d[l] = x - l\n            l += k\n        else:\n            d[l], p[l] = x - l, x\n            l += 1\n    l += 1\n    r += 1\n    while d[r]: r += d[r]\n    while l < r:\n        if d[l]:\n            k = d[l]\n            d[l] = r - l\n            l += k\n        else:\n            d[l], p[l] = r - l, x\n            l += 1\nprint(' '.join(map(str, p[1: -1])))
n = int(input())\nt = [0, 0] + list(map(int, input().split()))\na, b = [0] * (n + 1), [0] * (n + 1)\na[1] = b[1] = -1\n    \ndef f(s, a, b, l):\n    nonlocal t\n    l.reverse()\n    j, n = 0, len(l)\n    while True:\n        s += t[l[j]]\n        a[l[j]] = s\n        j += 1\n        if j == n: return\n        s += t[l[j]]\n        b[l[j]] = s\n        j += 1\n        if j == n: return\n\ndef g(i, k):\n    nonlocal a, b\n    l = []\n    if k:\n        a[i] = -1\n        l.append(i)\n        i += t[i]\n    while True:\n        if i > n: return f(0, a, b, l)                \n        if b[i] > 0: return f(b[i], a, b, l)                \n        if b[i] == -1: return\n        b[i] = -1\n        l.append(i)\n        i -= t[i]\n        if i < 1: return f(0, b, a, l)\n        if a[i] > 0: return f(a[i], b, a, l)\n        if a[i] == -1: return\n        a[i] = -1\n        l.append(i)\n        i += t[i]\n        \nfor i in range(2, n + 1):\n    if a[i] == 0: g(i, True)        \n    if b[i] == 0: g(i, False)\n\nfor i in range(1, n):\n    if b[i + 1] > 0: t[i] = i + b[i + 1]\n    else: t[i] = -1\n\nprint('\n'.join(map(str, t[1: n])))
def main():\n    n, k = map(int, input().split())\n    a, b, c, d = (list(map(int, input().split())) for _ in 'abcd')\n    ss, tt, n2, res = [*b, *c[::-1]], [*a, *d[::-1]], n * 2, []\n    yx = [*[(2, i + 1) for i in range(n)], *[(3, i) for i in range(n, 0, -1)]]\n\n    def park():\n        for i, s, t, (y, x) in zip(range(n2), ss, tt, yx):\n            if s == t != 0:\n                ss[i] = 0\n                res.append(f'{s} {(1, 4)[y == 3]} {x}')\n\n    def rotate():\n        start = ss.index(0)\n        for i in range(start - n2, start - 1):\n            s = ss[i] = ss[i + 1]\n            if s:\n                y, x = yx[i]\n                res.append(f'{s} {y} {x}')\n        ss[start - 1] = 0\n\n    park()\n    if all(ss):\n        print(-1)\n        return\n    while any(ss):\n        rotate()\n        park()\n    print(len(res), '\n'.join(res), sep='\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
import sys\n\nn, k = map(int, sys.stdin.readline().split())\nnums = list(map(int, sys.stdin.readline().split()))\ntotal = sum(nums)\navg = int(total / n)\n\ndef check1(nums, target, K):\n    for x in nums:\n        if K < 0:\n            return False\n        if x < target:\n            K -= target - x\n    return K >= 0\n\ndef check2(nums, target, K):\n    for x in nums:\n        if K < 0:\n            return False\n        if x > target:\n            K -= x - target\n    return K >= 0\n\nl1, r1 = min(nums), avg + 1\nwhile l1 + 1 < r1:\n    mid = (l1 + r1) >> 1\n    if check1(nums, mid, k):\n        l1 = mid\n    else:\n        r1 = mid\n\nif check2(nums, avg + (0 if total % n == 0 else 1), k):\n    r2 = avg + (0 if total % n == 0 else 1)\nelse:\n    l2, r2 = avg + (0 if total % n == 0 else 1), max(nums)\n    while l2 + 1 < r2:\n        mid = (l2 + r2) >> 1\n        if check2(nums, mid, k):\n            r2 = mid\n        else:\n            l2 = mid\n\nprint(r2 - l1)
import sys\ndef calc(b0, b1, q):\n    if q == 0:\n        return b0 ^ b1\n    if q == 1:\n        return b0 | b1\n    if q == 2:\n        return b0 & b1\nn, m = list(map(int,sys.stdin.readline().split()))\narr1 = {}\nopt = ['XOR', 'OR', 'AND']\narr2 = []\nfor j in range(n):\n    a, b = list(map(str,sys.stdin.readline().split(" := ")))\n    b = b.split()\n    if len(b) == 1:\n        s = b[0]\n        arr1[a] = s\n    else:\n        c = b[0]\n        d = b[2]\n        q = opt.index(b[1])\n        arr2.append((a, c, d, q))\n \nmins = ''\nmaxs = ''\nd0 = {'?':0}\nd1 = {'?':1}\nfor i in range(m):\n    for a, b in list(arr1.items()):\n        d0[a] = int(b[i])\n        d1[a] = int(b[i])\n    s0 = 0\n    s1 = 0\n    for a, c, d, q in arr2:\n        b00 = d0[c]\n        b01 = d0[d]\n        b10 = d1[c]\n        b11 = d1[d]\n        c0 = calc(b00, b01, q)\n        c1 = calc(b10, b11, q)\n        s0 += (1 if c0 else 0)\n        s1 += (1 if c1 else 0)\n        d0[a] = c0\n        d1[a] = c1\n    if s1 < s0:\n        mins += "1"\n    else:\n        mins += "0"\n    if s1 > s0:\n        maxs += "1"\n    else:\n        maxs += "0"\nsys.stdout.write("{0}\n{1}".format(mins,maxs))\n\n\n\n    \n\n
"""\nCodeforces Contest 260 Div 1 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef main():\n    n,k = read()\n    s = set()\n    for i in range(n): s.add(read(0))\n    s = list(s)\n    s.sort()\n    s = treeify(s)\n    res = solve(s)\n    if res == 0: # neither: second player win\n        print("Second")\n    if res == 1: # odd: first player win if k is odd\n        print("First" if k % 2 else "Second")\n    if res == 2: # even: second player win\n        print("Second")\n    if res == 3: # both: first player win\n        print("First")\n\ndef treeify(s):\n    res = [[] for _ in range(26)]\n    for i in s:\n        if i: res[ord(i[0]) - 97].append(i[1:])\n    fin = []\n    for i in range(26):\n        if res[i]: fin.append(treeify(res[i]))\n    return fin\n\ndef solve(s, parity=2):\n    for i in range(len(s)):\n        if isinstance(s[i], list): s[i] = solve(s[i], 3-parity)\n    if not s: return parity # no possible move: current parity\n    if 0 in s: return 3 # any neither: both\n    if 1 in s and 2 in s: return 3 # any odd and any even: both\n    if 1 in s: return 1 # any odd: odd\n    if 2 in s: return 2 # any even: even\n    return 0 # all both: neither\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return map(int, inputs.split())\n\ndef write(s="\n"):\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nmain()
from heapq import heappush,heappop,heapify\nn,k=map(int,input().split())\n*l,=map(int,input().split())\nq=[(-l[i],i)for i in range(k)];heapify(q)\na=[0]*n\ns=0\nfor i in range(k,n):\n    heappush(q,(-l[i],i))\n    x,j=heappop(q)\n    s-=x*(i-j)\n    a[j]=i+1\nfor i in range(n,n+k):\n    x,j=heappop(q)\n    s-=x*(i-j)\n    a[j]=i+1\nprint(s)\nprint(' '.join(map(str,a)))
n, m = list(map(int, input().split()))\nused = [1] * 2 * n\nfor i in range(m):\n	x, y = list(map(int, input().split()))\n	used[x - 1] = used[n + y - 1] = 0\n	\nif n % 2 and used[n // 2]:\n	used[n // 2 + n] = 0\nres = sum(used)\nfor i in [0, n - 1, n, 2 * n - 1]:\n	res -= used[i]\nprint(res)\n\n
n,m=map(int,input().split())\nb=list(map(int,input().split()))\ng=list(map(int,input().split()))\nif max(b)>min(g):\n    print(-1)\nelse:\n    maxi=0\n    maxi2=0\n    for guy in b:\n        if guy>maxi:\n            maxi2,maxi=maxi,guy\n        elif guy>maxi2:\n            maxi2=guy\n    sumi=m*sum(b)+sum(g)-m*maxi+maxi-maxi2\n    if maxi in g:\n        sumi-=(maxi-maxi2)\n    print(sumi)
def main():\n    n = int(input())\n    edges = []\n    for _ in range(n - 1):\n        u, v = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        edges.append((u, v))\n\n    colors = list(map(int, input().split()))\n    suspect = [(u, v) for (u, v) in edges if colors[u] != colors[v]]\n\n    if len(suspect) == 0:\n        print("YES")\n        print(1)\n    else:\n        cands = set(suspect[0])\n        for u, v in suspect:\n            cands &= set([u, v])\n\n        if len(cands) == 0:\n            print("NO")\n        else:\n            print("YES")\n            e = list(cands)[0]\n            print(e + 1)\n\nmain()\n
MOD = 10**9+7\n\ns = input()\nn = int(input())\nqs = [['',s]]+[input().split('->') for i in range(n)]\n\nds = {}\nfor i in range(10):\n    ds[str(i)] = (10,i)\n\nfor i in range(n,-1,-1):\n    out = 0\n    mul = 1\n    for d in qs[i][1]:\n        out = (out * ds[d][0] + ds[d][1]) % MOD\n        mul = (mul * ds[d][0]) % MOD\n    ds[qs[i][0]] = (mul,out)\n\nprint(ds[''][1])\n
#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\n    atexit.register(lambda :sys.stdout.close())     #idle  atexit\n    \nN, = getIntList()\n\ns1 = input() +'0'\ns2 = input() +'0'\n\nres = 0\n\ni = 0\nwhile i<N:\n    if s1[i] != s2[i]:\n        if s1[i+1] == s2[i] and s2[i+1] == s1[i]:\n            res+=1\n            i+=2\n            continue\n        res+=1\n    i+=1\nprint(res)\n\n    \n\n\n\n\n\n\n
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\n# so the ending sequence is b...ba...a\n\n# find length of ending sequence\n\nextra=0\nneed=0\nfor ch in input().strip():\n    if ch=='a':\n        need=(need*2+1)%1000000007\n    else:\n        extra=(extra+need)%1000000007\n\nprint(extra)
import heapq\nn = int(input())\nd = list(map(int,input().split()))\npq = [-d[0]]\nheapq.heapify(pq)\nans = 0\nfor i in range(1,n):\n    temp = i - d[i]\n    heapq.heappush(pq,temp)\n    if heapq.nsmallest(1,pq)[0] < temp:\n        ans += temp - heapq.nsmallest(1,pq)[0]\n        heapq.heappushpop(pq,temp)\nprint(ans)\n
n = int(input())\ninp = input()\nseq = inp.split(' ')\nseq = [ abs(int(x)) for x in seq ]\nMax = max(seq)\nnxt = [0] * n\ncnt = [0] * n\npos = [n] * (Max+1)\nfor i in range(n-1, -1, -1):\n    nxt[i] = pos[seq[i]]\n    pos[seq[i]] = i\nfor i in range(0, Max+1):\n    j = pos[i]\n    while(j<n):\n        front = sum(cnt[0:j])\n        back  = sum(cnt[j+1:n])\n        if(front < back):\n            seq[j] = 0 - seq[j]\n        j = nxt[j]\n    j = pos[i]\n    while(j < n):\n        cnt[j] = 1\n        j = nxt[j]\n#for i in range(0, n-1):\n#    print(seq[i], sep=' ')\n#print(seq[n-1])\ninv = 0\nfor i in range(len(seq)):\n    for j in range(i+1, len(seq)):\n        if(seq[i] > seq[j]):\n            inv += 1\nprint(inv)\n
def f(m):\n    nonlocal dp, sdp\n    l = 0\n    for i in range(n):\n        while l < n and v[l] < v[i] - m:\n            l += 1\n        if l - 1 > i - k:\n            dp[i] = False\n        else:\n            dp[i] = (sdp[i - k + 1] != sdp[l - 1])\n        sdp[i + 1] = sdp[i] + (1 if dp[i] else 0)\n    return dp[n - 1]\n\nn, k = list(map(int, input().split()))\ndp = [False for i in range(n + 2)]\nsdp = [0 for i in range(n + 2)]\ndp[-1] = True\nsdp[0] = 1\nv = list(map(int, input().split()))\nv.sort()\nle = -1\nr = v[-1] - v[0]\nwhile r - le > 1:\n    m = (r + le) // 2\n    if f(m):\n        r = m\n    else:\n        le = m  \nprint(r)\n
import sys\ninput = sys.stdin.readline\n\ndef solve(ax,ay,bx,by,cx,cy):\n    x = ax+bx+cx\n    y = ay+by+cy\n    x -= x//3+1\n    y -= y//3+1\n    if x==y:\n        return x if 0 <= x <= 1 else abs(x)+1\n    else:\n        return max(abs(x), abs(y))\n\nT = int(input())\nfor _ in range(T):\n    ax,ay,bx,by,cx,cy = map(int,input().split())\n    print(solve(ax,ay,bx,by,cx,cy))
def main():\n    mod = 10**9+7\n    inv_n = [0]*1001\n    nCr = [[1]*(i+1) for i in range(1001)]\n    for i in range(1001):\n        inv_n[i] = pow(i, mod-2, mod)\n    for i in range(2, 1001):\n        for j in range(1, i):\n            nCr[i][j] = (nCr[i-1][j-1]+nCr[i-1][j]) % mod\n    n, a, b, c, d = list(map(int, input().split()))\n    dp = [0]*(n+1)\n    dp[0] = 1\n\n    for A in range(b, a-1, -1):\n        dp2 = [i for i in dp]\n        for N in range(n-c*A, -1, -1):\n            e = dp[N]\n            if e:\n                temp = 1\n                for C in range(1, c):\n                    temp = temp*nCr[n-N-(C-1)*A][A]*inv_n[C] % mod\n                for C in range(c, min(d, (n-N)//A)+1):\n                    temp = temp*nCr[n-N-(C-1)*A][A]*inv_n[C] % mod\n                    dp2[N+C*A] = (dp2[N+C*A]+temp*e) % mod\n        dp = dp2\n    print((dp[-1]))\n\n\nmain()\n
rd = lambda: list(map(int, input().split()))\n\ndef root(x):\n  if f[x]!=x: f[x] = root(f[x])\n  return f[x]\n\nn, m = rd()\nN = list(range(n))\nf = list(N)\nlang = [0]*n\nfor i in N: lang[i] = set(rd()[1:])\nfor i in N:\n  for j in N[:i]:\n    rj = root(j)\n    if lang[rj].intersection(lang[i]):\n      f[rj] = i\n      lang[i] = lang[i].union(lang[rj])\nprint(sum(1 for i in N if i==root(i)) - (sum(map(len, lang))>0))\n
import sys\nreadline = sys.stdin.readline\n\nN, Q = list(map(int, readline().split()))\nstate = [[False]*(N+2) for _ in range(2)]\n\ncnt = 0\n\nAns = [None]*Q\nfor qu in range(Q):\n    r, c = list(map(int, readline().split()))\n    r -= 1\n    c -= 1\n    state[r][c] = not state[r][c]\n    res = state[r-1][c-1] + state[r-1][c] + state[r-1][c+1]  \n    if state[r][c]:\n        cnt += res\n    else:\n        cnt -= res\n    Ans[qu] = 'No' if cnt else 'Yes'\nprint('\n'.join(Ans))\n
n, k = [int(c) for c in input().split()]\na = []\nfor i in range(k):\n    ak = [int(c) for c in input().split()]\n    a.append(ak[1:])\n\ntotal = k - 1\n\nfor ak in a:\n    if ak[0] == 1:\n        j = 1\n        while j <= len(ak) - 1:\n            if ak[j] != ak[j-1] + 1:\n                break\n            j += 1\n        total += 2*(len(ak) - j)\n    else:\n        total += 2*(len(ak) - 1)\n\nprint(total)
import os\nimport random\nimport sys\nfrom typing import List, Dict\n\n\nclass Int:\n    def __init__(self, val):\n        self.val = val\n\n    def get(self):\n        return self.val + 111\n\nclass Unique:\n    def __init__(self):\n        self.s = set()\n\n    def add(self, val : int):\n        self.s.add(val)\n\n    def __contains__(self, item : int) -> bool:\n        return self.s.__contains__(item)\n\ndef ceil(top : int, bottom : int) -> int:\n    return (top + bottom - 1) // bottom\n\ndef concat(l : List[int]):\n    return "".join(map(str, l))\n\ndef get(d : Dict[int, str], val : int) -> Dict[int, str]:\n    return d[val]\n\n\n#guy who wants small moves first\n#then guy who wants large moves\n\n#so lets say we have 4 positions\n# 1, 2, 3, 4\n#small wants to ban edges, because if he bans 2 or 3 he is fucked\n#so he bans 1\n# and we have 2, 3, 4\n# then large bans middle so we have 2, 4 and the ans is 2\n# 0, 1, 2, 3, 4, 5, 6, 7\n# 0, 1, 2, 3, 4, 5, 6\n# 0, 1, 2, 3, 5, 6\n# 0, 1, 2, 3, 5\n# 0, 1, 3, 5\n# 0, 1, 3\n# 0, 3\n\n\n# 0, 1, 2, 3, 4, 5, 6, 7\n# 0, 4\n\n# # 0, 3\n\n\n#1 5 9 19 21 22\n#  5 9 19 21 22\n#  5 19 21 22\n#  19 21 22\n\n\n# 0, 1, 3, 7, 15\n# 0, 1, 7, 15\n# 0, 1, 7\n# 0, 7\ndef slowsolve(a):\n    a.sort()\n    small = True\n    while len(a) > 2:\n        if small:\n            if a[1] - a[0] > a[-1] - a[-2]:\n                a.pop(0)\n            else:\n                a.pop()\n            small = False\n        else:\n            a.pop(len(a) // 2)\n            small = True\n\n    return a[1] - a[0]\n\n\ndef solve(a):\n    a.sort()\n    candelete = len(a) // 2 - 1\n    res = 10 ** 18\n    for leftdelete in range(0, candelete + 1):\n        leftrem = leftdelete\n        rightrem = leftdelete + candelete + 1\n        res = min(res, a[rightrem] - a[leftrem])\n    return res\n\n\n\ndef prt(l): return print(' '.join(l))\ndef rv(): return map(int, input().split())\ndef rl(n): return [list(map(int, input().split())) for _ in range(n)]\nif os.path.exists("test.txt"): sys.stdin = open("test.txt")\n\nn, = rv()\na, = rl(1)\n\n# a = sorted([random.randrange(10**2) for _ in range(6)])\n# print(a)\n# print(solve(a), slowsolve(a))\nprint(solve(a))
n = int(input())\nt = [list(map(int, input().split())) for q in range(n)]\nt[0][0] = 0\nn += 1\nu = [-1e7] * n\nv = [0] * n\nfor i, (j, a) in list(enumerate(t, 1))[::-1]:\n    u[i] = max(u[i], v[i] + a)\n    v[j], u[j] = max(v[j] + v[i], u[j] + u[i]), max(v[j] + u[i], u[j] + v[i])\nprint(u[1])
import sys\nreadline = sys.stdin.readline\n\nfrom collections import Counter \n\ndef getpar(Edge, p):\n    N = len(Edge)\n    par = [0]*N\n    par[0] = -1\n    par[p]  -1\n    stack = [p]\n    visited = set([p])\n    while stack:\n        vn = stack.pop()\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            stack.append(vf)\n    return par\n\ndef topological_sort_tree(E, r):\n    Q = [r]\n    L = []\n    visited = set([r])\n    while Q:\n        vn = Q.pop()\n        L.append(vn)\n        for vf in E[vn]:\n            if vf not in visited:\n                visited.add(vf)\n                Q.append(vf)\n    return L\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for i, v in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\n\n        \n\nN = int(readline())\nWe = list(map(int, readline().split()))\nEdge = [[] for _ in range(N)]\nCost = Counter()\ngeta = N+1\nfor _ in range(N-1):\n    a, b, c = list(map(int, readline().split()))\n    a -= 1\n    b -= 1\n    Edge[a].append(b)\n    Edge[b].append(a)\n    Cost[b*geta+a] = c\n    Cost[a*geta+b] = c\nP = getpar(Edge, 0)\nL = topological_sort_tree(Edge, 0)\nC = getcld(P)\n\n\ndp = [0]*N\ncandi = [[0, 0] for _ in range(N)]\nans = 0\nfor l in L[::-1][:-1]:\n    dp[l] += We[l]\n    p = P[l]\n    k = dp[l] - Cost[l*geta + p]\n    if k > 0:\n        dp[p] = max(dp[p], k)\n        candi[p].append(k)\n    \n    res = max(candi[l])\n    candi[l].remove(res)\n    ans = max(ans, We[l] + res + max(candi[l]))\n\nres = max(candi[0])\ncandi[0].remove(res)\nans = max(ans, We[0] + res + max(candi[0]))\nprint(ans) \n
n=int(input())\nL=list(map(int,input().split()))\nif n==1:\n    print(1,1)\n    print(0)\n    print(1,1)\n    print(0)\n    print(1,1)\n    print(-L[0])\nelse:\n    print(1,n-1)\n    for i in range(n-1):print(L[i]*(n-1),end=' ')\n    print()\n    print(n,n)\n    print(-L[n-1])\n    print(1,n)\n    for i in range(n-1):print(-L[i]*n,end=' ')\n    print(0)
#!/usr/bin/env pypy3\n\nimport math\n\ndef make_nCr_mod(max_n=2*10**5 + 100, mod=10**9 + 7):\n    fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)\n    fact[0] = 1\n    for i in range(max_n):\n        fact[i + 1] = fact[i] * (i + 1) % mod\n\n    inv_fact[-1] = pow(fact[-1], mod - 2, mod)\n    for i in reversed(range(max_n)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def nCr_mod(n, r):\n        res = 1\n        while n or r:\n            a, b = n % mod, r % mod\n            if a < b:\n                return 0\n            res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod\n            n //= mod\n            r //= mod\n        return res\n\n    return nCr_mod\n\nnCr_mod = make_nCr_mod()\n\nMODULUS = 10**9+7\n\ninput()\nA = input().split(' ')\nA = list(map(int, A))\n\nif len(A) == 1:\n    print(A[0])\n    return\n\nif len(A) % 2 == 1:\n    new_A = []\n    next_plus = True\n    for i in range(len(A) - 1):\n        if next_plus:\n            new_A += [A[i] + A[i+1]]\n        else:\n            new_A += [A[i] - A[i+1]]\n        next_plus = not next_plus\n    A = new_A\n\nif len(A) % 4 == 2:\n    new_A = []\n    for i in range(len(A) // 2):\n        new_A += [A[2*i] + A[2*i+1]]\n    A = new_A\nelse:\n    new_A = []\n    for i in range(len(A) // 2):\n        new_A += [A[2*i] - A[2*i+1]]\n    A = new_A\n\n# binomial sum\n\nN = len(A)-1\n\nret = 0\n\nfor i in range(N+1):\n    ret += A[i]*nCr_mod(N, i)\n    ret = ret % MODULUS\n\nprint(ret)
from collections import Counter\nn = int(input())\npoints = Counter([tuple(map(int, input().split(' '))) for i in range(n)])\n\nx, y = Counter([k for k, v in points.elements()]), Counter([v for k, v in points.elements()])\n\nans = sum([v*(v-1)//2 for k, v in list(x.items())])+sum([v*(v-1)//2 for k, v in list(y.items())])-sum([v*(v-1)//2 for k, v in list(points.items())])\nprint(ans)\n
from sys import*\n#\ndef check(u, d, l, r):\n    used = [pointsx[i][1] for i in range(l)]\n    used += [pointsx[-1 - i][1] for i in range(r)]\n    used += [pointsy[i][1] for i in range(u)]\n    used += [pointsy[-1 - i][1] for i in range(d)]\n    if len(set(used)) > k:\n        return DOHERA\n    dx = pointsx[-1 - r][0] - pointsx[l][0]\n    dy = pointsy[-1 - d][0] - pointsy[u][0]\n    dx += dx & 1\n    dy += dy & 1\n    dx = max(2, dx)\n    dy = max(2, dy)\n    return dx * dy\n#\n(n, k) = list(map(int, input().split()))\npointsx = []\npointsy = []\nDOHERA = 10 ** 228\nfor i in range(n):\n    a = list(map(int, input().split()))\n    pointsx += [(a[0] + a[2], i)]\n    pointsy += [(a[1] + a[3], i)]\n(pointsx, pointsy) = (sorted(pointsx), sorted(pointsy))\nans = DOHERA\nfor u in range(0, k + 1):\n    for d in range(0, k + 1):\n        for l in range(0, k + 1):\n            for r in range(0, k + 1):\n                if l + r  <= k and u + d <= k:\n                    ans = min(ans, check(u, d, l, r))\nprint(ans // 4)\n\n\n\n# Made By Mostafa_Khaled\n
def maximum_xor_secondary(sequence):\n    stack, answer = [], 0\n    for x in sequence:\n        while stack:\n            answer = max(answer, stack[-1] ^ x)\n            if stack[-1] > x:\n                break\n            else:\n                stack.pop()\n        stack.append(x)\n\n    return answer\n\n\nsize, num = input(), [int(x) for x in input().split()]\n\n\nprint(maximum_xor_secondary(num))\n\n\n\n\n\n# Made By Mostafa_Khaled\n
INF = 10 ** 18 + 179\n[n, k], a = [list(map(int, input().split())) for x in range(2)]\na.sort()\ndp, l = [[0] * (k - n % k + 1) for x in range(n % k + 1)], n // k\nfor i in range(n % k + 1):\n    for j in range(k - n % k + 1):\n        pos = i * (l + 1) + j * l\n        dp[i][j] = min((dp[i - 1][j] + a[pos - 1] - a[pos - l - 1] if i else INF), \\n                       (dp[i][j - 1] + a[pos - 1] - a[pos - l] if j else INF)) if (i or j) else 0\nprint(dp[n % k][k - n % k])\n
rd = lambda: list(map(int, input().split()))\n\nrd()\na = sorted(rd(), reverse=True)\nb = sorted(rd(), reverse=True)\nif len(a) > len(b): print("YES"); return\nfor i in range(len(a)):\n  if a[i] > b[i]: print("YES"); return\nprint("NO")
n = int(input())\np = [tuple(map(int, input().split())) for i in range(n)]\n\ndef d(a, b):\n    return (a[0]-b[0], a[1]-b[1], a[2]-b[2], a[3]-b[3], a[4]-b[4])\n\ndef m(a, b):\n    t = 0\n    for i in range(5):\n        t += a[i] * b[i]\n    return t\n\ngood_points = []\nfor i in range(n):\n    good = True\n\n    for j in range(n):\n        if j == i:\n            continue\n        \n        ab = d(p[j], p[i])\n\n        for k in range(j + 1, n):\n            if k == i:\n                continue\n            \n            ac = d(p[k], p[i])\n            \n            if m(ab, ac) > 0:\n                good = False\n                break\n        \n        if not good:\n            break\n    \n    if good:\n        good_points.append(i)\n\nprint(len(good_points))\nfor i in good_points:\n    print(i + 1)\n
from collections import defaultdict\n\ndef solve(n, a, b, xs):\n    group = [None] * n\n    id_ = {x: i for i, x in enumerate(xs)}\n    if a == b:\n        for x in xs:\n            if a - x not in id_:\n                return False\n        group = [0] * n\n    else:\n        for i, x in enumerate(xs):\n            if group[i] is not None:\n                continue\n            y = a - x\n            z = b - x\n            f1 = y in id_ and group[id_[y]] is None\n            f2 = z in id_ and group[id_[z]] is None\n            if f1 + f2 == 0:\n                return False\n            elif f1 + f2 == 1:\n                g = int(f2)\n                # End of link\n                link = []\n                t = a if f1 else b\n                while x in id_:\n                    link.append(x)\n                    x = t - x\n                    if x + x == t:\n                        break\n                    t = a + b - t\n                # print(link)\n                if len(link) % 2 == 0:\n                    for i, x in enumerate(link):\n                        group[id_[x]] = g\n                elif link[0] * 2 == (b, a)[g]:\n                    for i, x in enumerate(link):\n                        group[id_[x]] = 1 - g\n                elif link[-1] * 2 == (a, b)[g]:\n                    for i, x in enumerate(link):\n                        group[id_[x]] = g\n                else:\n                    # Found invalid link, answer is "NO"\n                    return False\n\n    return group\n\nn, a, b = list(map(int, input().split()))\nxs = list(map(int, input().split()))\ngroup = solve(n, a, b, xs)\nif isinstance(group, list):\n    print('YES')\n    print(' '.join(map(str, group)))\nelse:\n    print('NO')\n
def main():\n    n = int(input())\n    a = list(map(int, (x for x in input())))\n    b = list(map(int, (x for x in input())))\n    x = [0] * (n - 1)\n    x[0] = b[0] - a[0]\n    for i in range(1, n - 1):\n        x[i] = b[i] - a[i] - x[i - 1]\n    if a[n - 1] + x[n - 2] != b[n - 1]:\n        print(-1)\n        return\n    cnt = sum(map(abs, x))  # prevbug: ftl\n    print(cnt)\n    cnt = min(cnt, 10 ** 5)\n    index = 0\n\n    def handle_zero_nine(cur_zero):\n        nonlocal cnt\n        nxt = index + 1\n        # cur_zero = True prevbug: preserved this line\n        while True:\n            if cur_zero and a[nxt + 1] != 9:\n                break\n            if not cur_zero and a[nxt + 1] != 0:\n                break\n            nxt += 1\n            cur_zero = not cur_zero\n        while nxt > index:\n            if cnt == 0:\n                break\n            if cur_zero:\n                print(nxt + 1, 1)\n                a[nxt] += 1\n                a[nxt + 1] += 1\n            else:\n                print(nxt + 1, -1)\n                a[nxt] -= 1\n                a[nxt + 1] -= 1\n            nxt -= 1\n            cnt -= 1\n            # print(a)\n            cur_zero = not cur_zero\n\n    while cnt > 0:\n        if a[index] == b[index]:\n            index += 1\n            continue\n        elif a[index] > b[index] and a[index + 1] == 0:\n            handle_zero_nine(True)\n        elif a[index] < b[index] and a[index + 1] == 9:\n            handle_zero_nine(False)\n        elif a[index] > b[index]:\n            print(index + 1, -1)\n            a[index] -= 1\n            a[index + 1] -= 1\n            cnt -= 1\n            # print(a)\n        elif a[index] < b[index]:\n            print(index + 1, 1)\n            a[index] += 1\n            a[index + 1] += 1\n            cnt -= 1\n            # print(a)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
q = int(input())\n\n\n\ndef full_way(u):\n    res = set()\n\n    while u >= 1:\n        res.add(u)\n        u //= 2\n\n    return res\n\n\ndef get_way(u, v):\n    res1 = full_way(u)\n    res2 = full_way(v)\n\n    m = max(res1 & res2)\n\n    res = set()\n    for x in res1 | res2:\n        if x > m:\n            res.add(x)\n\n    return res\n\n\nd = {}\n\nfor i in range(q):\n    a  = input().split()\n\n    if a[0] == '1':\n        v, u, w = map(int, a[1:])\n        for x in get_way(u, v):\n            if x not in d:\n                d[x] = 0\n            d[x] += w\n    else:\n        v, u = map(int, a[1:])\n        res = 0\n        for x in get_way(u, v):\n            if x in d:\n                res += d[x]\n        print(res)
import sys\n\nn_discounts = int(sys.stdin.readline())\ndiscount_values = [int(x) for x in sys.stdin.readline().split()]\nn_items = int(sys.stdin.readline())\nitem_values = [int(x) for x in sys.stdin.readline().split()]\n\nmin_discount_req = 10000000\nfor discount_value in discount_values:\n    min_discount_req = min(min_discount_req, discount_value)\nitem_values.sort(reverse=True)\n\nindex = 0\noverall_price = 0\nwhile index < n_items:\n    n_left = min(min_discount_req, n_items - index)\n    for i in range(n_left):\n        overall_price += item_values[index+i]\n    index += n_left + 2\n\nprint(overall_price)\n    \n
from math import pi\nfrom cmath import exp\ndef fft(a, lgN, rot=1): # rot=-1 for ifft\n  N = 1<<lgN\n  assert len(a)==N\n  rev = [0]*N\n  for i in range(N):\n    rev[i] = (rev[i>>1]>>1)+(i&1)*(N>>1)\n  A = [a[rev[i]] for i in range(N)]\n  h = 1\n  while h<N:\n    w_m = exp((0+1j) * rot * (pi / h))\n    for k in range(0, N, h<<1):\n      w = 1\n      for j in range(h):\n        t = w * A[k+j+h]\n        A[k+j+h] = A[k+j]-t\n        A[k+j] = A[k+j]+t\n        w *= w_m\n    h = h<<1\n  return A if rot==1 else [x/N for x in A]\n\n\nimport sys\nints = (int(x) for x in sys.stdin.read().split())\n\nn, x = (next(ints) for i in range(2))\nr = [next(ints) for i in range(n)]\nac = [0]*(n+1)\nfor i in range(n): ac[i+1] = (r[i]<x) + ac[i]\n\n# Multiset addition\nmin_A, min_B = 0, -ac[-1]\nmax_A, max_B = ac[-1], 0\nN, lgN, m = 1, 0, 2*max(max_A-min_A+1, max_B-min_B+1)\nwhile N<m: N,lgN = N<<1,lgN+1\na, b = [0]*N, [0]*N\nfor x in ac:\n  a[x-min_A] += 1\n  b[-x-min_B] += 1\nc = zip(fft(a, lgN), fft(b, lgN))\nc = fft([x*y for x,y in c], lgN, rot=-1)\nc = [round(x.real) for x in c][-min_A-min_B:][:n+1]\nc[0] = sum((x*(x-1))//2 for x in a)\nprint(*c, *(0 for i in range(n+1-len(c))), flush=True)
MOD = 998244353\n\nn = int(input())\n\na = list(map(int, input().split()))\ntot = sum(a)\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\n\nl = [0, pow(n, tot, MOD) - 1]\n\nfor i in range(1, tot):\n    aC = i\n    cC = (n - 1) * (tot - i)\n    curr = (aC + cC) * l[-1]\n    curr -= tot * (n - 1)\n    curr -= aC * l[-2]\n    curr *= inv(cC)\n    curr %= MOD\n    l.append(curr)\n\nout = 0\nfor v in a:\n    out += l[tot - v]\n    out %= MOD\n\nzero = l[tot]\nout -= (n - 1) * zero\nout *= inv(n)\nprint(out % MOD)\n
n, m = map(int, input().split())\na = [10**9 for _ in range(n)]\nextra = [0 for _ in range(n)]\nquery = list()\nfor _ in range(m):\n     t, l, r, x = map(int, input().split())\n     l -= 1\n     r -= 1\n     query.append((t, l, r, x))\n     if t == 1:\n          for j in range(l, r + 1):\n               extra[j] += x\n     else:\n          for j in range(l, r + 1):\n               a[j] = min(a[j], x - extra[j])\nextra = a.copy()\nfor t, l, r, x in query:\n     if t == 1:\n          for j in range(l, r + 1):\n               a[j] += x\n     else:\n          val = -10**9\n          for j in range(l, r + 1):\n               val = max(val, a[j])\n          if not val == x:\n               print('NO')\n               return\n\nprint('YES')\nfor x in extra:\n     print(x, end=' ')\n          
import heapq\n\ndef coor_neighbor(coor, dxs, dys):\n    x, y = coor\n    for dx in dxs:\n        for dy in dys:\n            yield x + dx, y + dy\n\n\ndef coor_bottoms(coor):\n    return coor_neighbor(coor, (-1, 0, 1), (-1, ))\n\n\ndef coor_tops(coor):\n    return coor_neighbor(coor, (-1, 0, 1), (1, ))\n\n\ndef coor_sibs(coor):\n    return coor_neighbor(coor, (-2, -1, 1, 2), (0, ))\n\n\nclass Figure:\n\n    def __init__(self, coors):\n        self._coors = dict()\n        self._stables_min = []\n        self._stables_max = []\n        self._pushed = set()\n        self._dropped = set()\n\n        cubes = dict()\n        self._bots = dict()\n        self._tops = dict()\n        for idx, coor in enumerate(coors):\n            cubes[coor] = idx\n            self._coors[idx] = coor\n            self._bots[idx] = set()\n            self._tops[idx] = set()\n\n        coor_set = set(coors)\n        for idx, coor in enumerate(coors):\n            for bottom in coor_bottoms(coor):\n                if bottom in coor_set:\n                    self._bots[idx].add(cubes[bottom])\n            for top in coor_tops(coor):\n                if top in coor_set:\n                    self._tops[idx].add(cubes[top])\n\n        for idx in self._coors:\n            if self.isdroppable(idx):\n                self.push(idx)\n\n    def sibs(self, idx):\n        for top_idx in self._tops[idx]:\n            for sib_idx in self._bots[top_idx]:\n                if sib_idx not in self._dropped:\n                    yield sib_idx\n\n    def bottom_count(self, idx):\n        return len(self._bots[idx])\n\n    def isdroppable(self, idx):\n        return all(len(self._bots[top_idx]) > 1 for top_idx in self._tops[idx])\n\n    def push(self, idx):\n        if idx not in self._pushed:\n            heapq.heappush(self._stables_min, idx)\n            heapq.heappush(self._stables_max, -idx)\n            self._pushed.add(idx)\n\n    def unpush(self, idx):\n        if idx in self._pushed:\n            self._pushed.remove(idx)\n\n    def drop(self, idx):\n        if idx not in self._pushed:\n            return False\n        self._pushed.remove(idx)\n        self._dropped.add(idx)\n\n        for bot_idx in self._bots[idx]:\n            self._tops[bot_idx].remove(idx)\n        for top_idx in self._tops[idx]:\n            self._bots[top_idx].remove(idx)\n\n        coor = self._coors[idx]\n        for bot_idx in self._bots[idx]:\n            if self.isdroppable(bot_idx):\n                self.push(bot_idx)\n        for sib_idx in self.sibs(idx):\n            if not self.isdroppable(sib_idx):\n                self.unpush(sib_idx)\n        return True\n\n    def drop_min(self):\n        while True:\n            if not self._stables_min:\n                return None\n            min_idx = heapq.heappop(self._stables_min)\n            if self.drop(min_idx):\n                return min_idx\n\n    def drop_max(self):\n        while True:\n            if not self._stables_max:\n                return None\n            max_idx = - heapq.heappop(self._stables_max)\n            if self.drop(max_idx):\n                return max_idx\n\n    def __bool__(self):\n        return len(self._coors) != len(self._dropped)\n\n\ndef input_tuple():\n    return tuple(map(int, input().split()))\n\n\ndef result_add(result, base, num):\n    return (result * base + num) % (10 ** 9 + 9)\n\n\nN = int(input())\ncoors = [input_tuple() for _ in range(N)]\n\nfigure = Figure(coors)\nresult = 0\nwhile True:\n    if not figure:\n        break\n    result = result_add(result, N, figure.drop_max())\n    if not figure:\n        break\n    result = result_add(result, N, figure.drop_min())\nprint(result)\n
from sys import stdin, stdout\n\nK = 20\n\ndef findAllStrings(s):\n    n = len(s)\n    sDict = {}\n    for i in range(1,K+1):\n        sDict[i]=set()\n        for x in range(n-i+1):\n            sDict[i].add(s[x:x+i])\n    return sDict\n\nn = int(stdin.readline().rstrip())\nstringDicts = []\nstringEnd = []\nstringBegin = []\n\nfor i in range(n):\n    s = stdin.readline().rstrip()\n    stringDicts.append(findAllStrings(s))\n    if len(s)<K:\n        stringEnd.append(s)\n        stringBegin.append(s)\n    else:\n        stringEnd.append(s[-20:])\n        stringBegin.append(s[:20])\n\nm = int(stdin.readline().rstrip())\n\nfor _ in range(m):\n    a,b = list(map(int,stdin.readline().rstrip().split()))\n    a-=1\n    b-=1\n    \n    sDict1 = findAllStrings(stringEnd[a]+stringBegin[b])\n    sDict2 = stringDicts[a]\n    sDict3 = stringDicts[b]\n    sDict={}\n    for i in range(1,K+1):\n        sDict[i] = sDict1[i]|sDict2[i]|sDict3[i]\n    stringDicts.append(sDict)\n    for i in range(1,K+1):\n        if len(sDict[i])!=2**i:\n            print(i-1)\n            break\n                \n    if len(stringBegin[a])<K and len(stringBegin[a])+len(stringBegin[b])<K:\n        stringBegin.append(stringBegin[a]+stringBegin[b])\n    elif len(stringBegin[a])<K:\n        s = stringBegin[a]+stringBegin[b]\n        stringBegin.append(s[:K])\n    else:\n        stringBegin.append(stringBegin[a])\n        \n    if len(stringEnd[b])<K and len(stringEnd[a])+len(stringEnd[b])<K:\n        stringEnd.append(stringEnd[a]+stringEnd[b])\n    elif len(stringEnd[b])<K:\n        s = stringEnd[a]+stringEnd[b]\n        stringEnd.append(s[-K:])\n    else:\n        stringEnd.append(stringEnd[b])\n\n
import sys\ninput = sys.stdin.readline\n\n\nfrom collections import deque\nN, Q = list(map(int, input().split()))\nque = deque([int(a) for a in input().split()])\nma = max(que)\n\nX = []\nk = -1\nc = 0\nwhile c <= k+N+5:\n    a = deque.popleft(que)\n    b = deque.popleft(que)\n    \n    X.append((a, b))\n    c += 1\n    if a > b:\n        a, b = b, a\n    if k < 0 and b == ma:\n        k = c\n    deque.appendleft(que, b)\n    deque.append(que, a)\n\nfor _ in range(Q):\n    i = int(input()) - 1\n    if i <= k:\n        print(*X[i])\n    else:\n        i = (i-k)%(N-1)+k\n        print(*X[i])\n\n
3\n\nimport sys\n\nn, l, r, ql, qr = list(map(int, sys.stdin.readline().strip().split()))\nw = [int(x) for x in sys.stdin.readline().strip().split()]\n\ns = [0]\nfor i in range(0, n):\n    s.append(s[-1] + w[i])\n\ndef cost(left):\n    right = n - left\n    diff = left - right\n    bonus = 0\n    if diff > 0: # left part is larger\n        bonus = ql * (diff - 1)\n    elif diff < 0: # right part is larger\n        bonus = qr * (-diff - 1)\n    return bonus + l * s[left] + r * (s[n] - s[left])\n\nbest = cost(0)\nfor left in range(1, n+1):\n    c = cost(left)\n    if c < best:\n        best = c\n\nprint(best)\n
n = int(input())\nC = list(map(int, input().split()))\n\ndp = [[0]*n for _ in range(n)]\nfor i in range(n) :\n    dp[i][i] = 1\n\nfor i in range(n-2, -1, -1) :\n    for j in range(i+1, n) :\n        dp[i][j] = 1 + dp[i+1][j]\n        if C[i] == C[i+1] : dp[i][j] = min( dp[i][j], 1 + (dp[i+2][j] if i+2 < n else 0) )\n        for k in range(i+2, j) :\n            if C[i] == C[k] : dp[i][j] = min( dp[i][j], dp[i+1][k-1] + dp[k+1][j] )\n        if C[i] == C[j] and j-i > 1:\n            dp[i][j] = min( dp[i][j], dp[i+1][j-1] )\n\nprint( dp[0][n-1] )\n\n            \n        \n
from operator import __or__, __and__, __xor__\nfrom sys import stdin, stdout\nn, b, c = int(stdin.readline()), 0, 1023\nm = {'|': __or__, '&': __and__, '^': __xor__}\nfor i in range(n):\n    t, v = [i for i in stdin.readline().split()]\n    b = m[t](b, int(v))\n    c = m[t](c, int(v))\nx, o, a = 0, 0, 1023\nfor i in range(10):\n    if ((b >> i) & 1) and ((c >> i) & 1):\n        o |= 1 << i\n    elif not ((b >> i) & 1) and not ((c >> i) & 1):\n        a -= 1 << i\n    elif ((b >> i) & 1) and not ((c >> i) & 1):\n        x |= 1 << i\nstdout.write('3\n| ' + str(o) + '\n^ ' + str(x) + '\n& ' + str(a))\n        \n
from itertools import combinations_with_replacement \nfrom collections import deque\n\n#sys.stdin = open("input_py.txt","r")\n\nn, m = map(int, input().split())\nG = [ [] for i in range(n)]\n\nfor i in range(m):\n    x, y = map(int, input().split())\n    x-=1; y-=1\n    G[x].append(y)\n    G[y].append(x)\n\ndef BFS(s):\n    dist = [-1 for i in range(n)]\n    dist[s] = 0\n    Q = deque()\n    Q.append(s)\n    while len(Q) > 0:\n        v = Q.popleft()\n        for to in G[v]:\n            if dist[to] < 0:\n                dist[to] = dist[v] + 1\n                Q.append(to)\n    return dist \n\n\nDist = [BFS(i) for i in range(n)]\n\ns1, t1, l1 = map(int, input(). split())\ns2, t2, l2 = map(int, input(). split())\ns1-=1; t1-=1; s2-=1; t2-=1\nif Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n    print(-1)\n    return\n\nrest = Dist[s1][t1] + Dist[s2][t2]\n\nfor i in range(n):\n    for j in range(n):\n        if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2 :\n            rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n        if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2 :\n            rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\nprint(m-rest)
import sys\ninput = sys.stdin.readline\n\ns = input()\n\nM = int(input())\n\n\ndef next_pow_2(n):\n    p = 1\n    while p < n:\n        p <<= 1\n    return p\n\n\ndef represented_range(node, size):\n    l = node\n    r = node\n    while l < size:\n        l = 2*l\n        r = 2*r + 1\n    return l-size, r-size\n\n\nclass SegTree:\n    def __init__(self, size):\n        self.size = next_pow_2(size)\n        self.answer = [0] * (2*self.size)\n        self.opened = [0] * (2*self.size)\n        self.closed = [0] * (2*self.size)\n\n    # O(size * (O(func) + O(init))\n    def build(self, s):\n        for i in range(self.size):\n            self.answer[self.size + i] = 0\n            self.opened[self.size + i] = 1 if i < len(s) and s[i] == '(' else 0\n            self.closed[self.size + i] = 1 if i < len(s) and s[i] == ')' else 0\n\n        for i in range(self.size - 1, 0, -1):\n            matched = min(self.opened[2*i], self.closed[2*i+1])\n            self.answer[i] = self.answer[2*i] + self.answer[2*i+1] + matched\n            self.opened[i] = self.opened[2*i] + self.opened[2*i+1] - matched\n            self.closed[i] = self.closed[2*i] + self.closed[2*i+1] - matched\n\n    # O(log(size)), [l,r]\n    def query(self, l, r):\n        l += self.size\n        r += self.size\n\n        eventsR = []\n        answer = 0\n        opened = 0\n        while l <= r:\n            if l & 1:\n                matched = min(self.closed[l], opened)\n                answer += self.answer[l] + matched\n                opened += self.opened[l] - matched\n                l += 1\n            if not (r & 1):\n                eventsR.append((self.answer[r], self.opened[r], self.closed[r]))\n                r -= 1\n            l >>= 1\n            r >>= 1\n\n        for i in range(len(eventsR)-1, -1, -1):\n            a, o, c = eventsR[i]\n            matched = min(c, opened)\n            answer += a + matched\n            opened += o - matched\n\n        return answer\n\n\nseg = SegTree(len(s))\nseg.build(s)\n\nfor i in range(M):\n    l, r = [int(_) for _ in input().split()]\n    print(2*seg.query(l-1, r-1))\n
n = int(input())\nif n % 2:\n    print("contest")\nelse:\n    print("home")
n = int(input())\nfrom bisect import bisect_left\n\n\na = list(map(int, input().split()))\nss = []\nms = []\nfor i in range(n):\n    k = a[i]\n    ind = bisect_left(ms, -k)\n    if ind == len(ms):\n        ss.append([])\n        ms.append(0)\n    ss[ind].append(k)\n    ms[ind] = -k\n\nfor s in ss:\n    print(' '.join([str(i) for i in s]))
def main():\n    import sys\n    input = sys.stdin.readline\n    \n    n = int(input())\n    arr = input()\n    \n    one = arr.count('n')\n    zero = arr.count('z')\n    \n    ans = [1] * one + [0] * zero\n    \n    print(*ans)\n    \n    return 0\n\nmain()\n
input()\nA = list(map(int, input().split(' ')))\nroot=-1\nfor i,a in enumerate(A) :\n    if i == a-1 :\n        root = i\n        break\nv = [False]*len(A)\nif root>-1 :\n    v[root]=True\nans= 0\nfor i,a in enumerate(A) :\n    if v[i] :\n        continue\n    v[i]= True\n    l=[i]\n    a-=1\n    while not v[a] :\n        l.append(a)\n        v[a]=True\n        a=A[a]-1\n    if a in l: #new cycle\n        if root==-1:\n            A[a]=a+1\n            root=a\n            ans+=1\n        else :\n            A[a]=root+1\n            ans+=1\nprint(ans)\nprint(' '.join(map(str,A)))\n
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\nn=int(input())\nb=list(map(int,input().split()))\nbb=sorted(b)\nc={bb[i]:i for i in range(n)}\na=[c[b[i]] for i in range(n)]\nvis=[0]*n\n\nout=[]\nfor i in range(n):\n    if vis[i]: continue\n    vis[i]=1\n    newlist=[i]\n    while a[newlist[-1]]!=i:\n        newlist.append(a[newlist[-1]])\n        vis[newlist[-1]]=1\n    out.append(newlist)\n\nprint(len(out))\nfor i in out:\n    print(" ".join([str(x+1) for x in [len(i)-1]+i]))\n
n = int(input())\nedges = [[int(x) for x in input().split()] for i in range(n-1)]\nedges = sorted(edges)\nuse_count = [0]+[int(input()) for i in range(n)]\nlo,hi = 0,10000\ndef getpar(par,u):\n    if par[par[u]] == par[u]:\n        return par[u]\n    par[u] = getpar(par,par[u])\n    return par[u]\ndef unite(par,sz,use,u,v):\n    u = getpar(par,u)\n    v = getpar(par,v)\n    par[u] = v\n    sz[v] += sz[u]\n    use[v] += use[u]\ndef solve(fp):\n    par = [i for i in range(n+1)]\n    sz = [1 for i in range(n+1)]\n    use = [use_count[i] for i in range(n+1)]\n    for edge in edges:\n        if edge[2] < fp:\n            unite(par,sz,use,edge[0],edge[1])\n    total_use = sum(use_count)\n    for i in range(n+1):\n        p = getpar(par,i)\n        if(p == i):\n            if(total_use - use[p] < sz[p]):\n                return False\n    return True\nwhile lo < hi:\n    mid = (lo+hi+1)//2\n    if solve(mid):\n        lo = mid\n    else:\n        hi = mid-1\nprint(lo)\n
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\nn,m=list(map(int,input().split()))\n\nparty=[[] for _ in range(m+5)]\npc=sorted([list(map(int,input().split())) for _ in range(n)],key=lambda x:x[1])\nchoose=[0]*n\n\nfor i in range(n):\n    party[pc[i][0]].append(i)\n\n\n\nwant=10**18\nfor i in range(1,n+1):\n    p1=len(party[1])\n    # want all other parties to have <i voters\n    for j in range(2,m+5):\n        if len(party[j])<i: continue\n        for k in range(len(party[j])-i+1):\n            p1+=1\n            choose[party[j][k]]=1\n    # want party 1 to have >=i voters\n    want2=0\n    for j in range(n):\n        if p1<i and choose[j]==0 and pc[j][0]!=1:\n            choose[j]=1\n            p1+=1\n        if choose[j]==1:\n            want2+=pc[j][1]\n    if want>want2:\n        want=want2\n    #print(i,want2)\n    # reset\n    choose=[0]*n\n\nprint(want)\n
3\n\nimport sys\n\ndef __starting_point():\n    \n    n, k = list(map(int, sys.stdin.readline().split()))\n    l = []\n    i = 1\n    j = k + 1\n    while i <= j:\n        l.append(str(i))\n        i += 1\n        if j > i:\n            l.append(str(j))\n            j -= 1\n    for i in range(k+2, n+1):\n        l.append(str(i))\n    \n    print(' '.join(l))\n\n\n__starting_point()
n = int(input())\nl = list(map(int, input().split()))\n\nstack = []\nfor v in l:\n    currVal = v\n    currSize = 1\n    div = v\n    \n    while stack:\n        nex, nexS, nDiv = stack[-1]\n\n        if div < nDiv:\n            currSize += nexS\n            currVal += nex\n            stack.pop()\n\n            div = currVal / currSize\n        else:\n            break\n    stack.append((currVal, currSize, div))\n\nout = []\nfor a, b, d in stack:\n    thingy = str(d)\n    for _ in range(b):\n        out.append(thingy)\n        \nprint('\n'.join(out))\n
import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nN, M = list(map(int, input().split()))\nD = [{} for _ in range(N)]\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    D[a][b] = 1\n    D[b][a] = 1\n\nL = [i-1 for i in range(N)]\nR = [i+1 for i in range(N)]\n\nF = [0] * N\nfor i in range(N):\n    if F[i]: continue\n    f = 1\n    while f:\n        f = 0\n        j = R[i]\n        while j < N:\n            if j in D[i]:\n                j = R[j]\n                continue\n            F[j] = 1\n            A = [a for a in D[i] if a not in D[j]]\n            if A: f = 1\n            for a in A:\n                if a in D[i]: del D[i][a]\n                if i in D[a]: del D[a][i]\n            A = [a for a in D[j] if a not in D[i]]\n            if A: f = 1\n            for a in A:\n                if a in D[j]: del D[j][a]\n                if j in D[a]: del D[a][j]\n\n            if R[j] < N: L[R[j]] = L[j]\n            if L[j] >= 0: R[L[j]] = R[j]\n            j = R[j]\n\nprint(N - sum(F) - 1)\n
k = int(input())\np = [['0'] * 100 for j in range(100)]\ng = lambda n: n * (n * n - 1) // 6\ni = n = 0\nwhile g(n + 1) <= k: n += 1\nwhile i < n + 1:\n    for j in range(i): p[i][j] = p[j][i] = '1'\n    i += 1\nk -= g(n)\ng = lambda n: n * n - n >> 1\nwhile k:\n    n = 0\n    while g(n + 1) <= k: n += 1\n    for j in range(n): p[i][j] = p[j][i] = '1'\n    k -= g(n)\n    i += 1\nprint(i)\nfor j in range(i): print(''.join(p[j][:i]))
#!/usr/bin/env python\n# 556D_fug.py - Codeforces.com 556D Fug quiz\n#\n# Copyright (C) 2015 Sergey\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an "AS IS" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n"""\nInput\n\nThe first line contains integers n and m - the number of islands and bridges.\n\nNext n lines each contain two integers li and ri - the coordinates of the\nisland endpoints.\n\nThe last line contains m integer numbers a1..am - the lengths of the bridges\nthat Andrewid got.\nOutput\n\nIf it is impossible to place a bridge between each pair of adjacent islands\nin the required manner, print on a single line "No" (without the quotes)\n, otherwise print in the first line "Yes" (without the quotes), and in the\nsecond line print n-1 numbers b1, bn-1, which mean that between islands\ni and i+1 there must be used a bridge number bi.\n\nIf there are multiple correct answers, print any of them. Note that in this\nproblem it is necessary to print "Yes" and "No" in correct case\n"""\n\n# Standard libraries\nimport unittest\nimport sys\nimport re\n\n# Additional libraries\nimport heapq\n\n\n###############################################################################\n# Fug Class\n###############################################################################\n\n\nclass Fug:\n    """ Fug representation """\n\n    def __init__(self, args):\n        """ Default constructor """\n        self.list = args[0]\n        self.alist = args[1]\n        self.gn = len(self.list) - 1\n\n        # Sorted list of bridges\n        self.asrt = sorted((n, i) for i, n in enumerate(self.alist))\n\n        # List of gaps between islands\n        self.gaps = [()]*self.gn\n        prevli = self.list[0]\n        for i in range(self.gn):\n            li = self.list[i+1]\n            min = li[0] - prevli[1]\n            max = li[1] - prevli[0]\n            self.gaps[i] = (min, max, i)\n            prevli = li\n\n        # Sorted list of gaps between islands\n        self.gsrt = sorted(self.gaps)\n\n        self.gmin = [n[0] for n in self.gsrt]\n        self.result = [None]*self.gn\n        self.heap = []\n\n    def iterate(self):\n\n        j = 0\n        for (b, i) in self.asrt:\n\n            # Traverse gmin array\n            while j < self.gn and self.gmin[j] <= b:\n                it = self.gsrt[j]\n                heapq.heappush(self.heap, (it[1], it[0], it[2]))\n                j += 1\n\n            # Update result and remove the element from lists\n            if self.heap:\n                (mmax, mmin, mi) = self.heap[0]\n                if mmin <= b and mmax >= b:\n                    self.result[mi] = i + 1\n                    heapq.heappop(self.heap)\n\n            yield\n\n    def calculate(self):\n        """ Main calcualtion function of the class """\n\n        for it in self.iterate():\n            pass\n\n        answer = ""\n        for (i, n) in enumerate(self.result):\n            if n is None:\n                return "No"\n            answer += (" " if i > 0 else "") + str(n)\n\n        return "Yes\n" + answer\n\n\n###############################################################################\n# Executable code\n###############################################################################\n\n\ndef get_inputs(test_inputs=None):\n\n    it = iter(test_inputs.split("\n")) if test_inputs else None\n\n    def uinput():\n        """ Unit-testable input function wrapper """\n        if it:\n            return next(it)\n        else:\n            return input()\n\n    # Getting string inputs. Place all uinput() calls here\n    num = [int(s) for s in uinput().split()]\n    list = [[int(s) for s in uinput().split()] for i in range(num[0])]\n    alist = [int(s) for s in uinput().split()]\n\n    # Decoding inputs into a list\n    inputs = [list, alist]\n\n    return inputs\n\n\ndef calculate(test_inputs=None):\n    """ Base class calculate method wrapper """\n    return Fug(get_inputs(test_inputs)).calculate()\n\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_sample_tests(self):\n        """ Quiz sample tests. Add \n to separate lines """\n\n        # Sample test 1\n        test = "4 4\n1 4\n7 8\n9 10\n12 14\n4 5 3 8"\n        self.assertEqual(calculate(test), "Yes\n2 3 1")\n        self.assertEqual(\n            get_inputs(test),\n            [[[1, 4], [7, 8], [9, 10], [12, 14]], [4, 5, 3, 8]])\n\n        # My tests\n        test = "5 5\n1 1\n2 7\n8 8\n10 10\n16 16\n1 1 5 6 2"\n        self.assertEqual(calculate(test), "Yes\n1 2 5 4")\n\n        # Other tests\n        test = "2 2\n11 14\n17 18\n2 9"\n        self.assertEqual(calculate(test), "No")\n\n        # Other tests\n        test = (\n            "2 1\n1 1\n1000000000000000000 1000000000000000000" +\n            "\n999999999999999999")\n        self.assertEqual(calculate(test), "Yes\n1")\n\n        test = ("5 9\n1 2\n3 3\n5 7\n11 13\n14 20\n2 3 4 10 6 2 6 9 5")\n        self.assertEqual(calculate(test), "Yes\n1 6 3 2")\n\n        size = 100000\n        test = str(size) + " " + str(size) + "\n"\n        x = size*1000\n        for i in range(size):\n            x += 2\n            test += str(x) + " " + str(x+1) + "\n"\n        for i in range(size):\n            test += str(2) + " "\n        self.assertEqual(calculate(test)[0], "Y")\n\n    def test_Fug_class__basic_functions(self):\n        """ Fug class basic functions testing """\n\n        # Constructor test\n        d = Fug([[[1, 5], [7, 8], [9, 10], [12, 14]], [4, 5, 3, 8]])\n        self.assertEqual(d.list[0][0], 1)\n        self.assertEqual(d.alist[0], 4)\n\n        # Sort bridges\n        self.assertEqual(d.asrt[0], (3, 2))\n\n        # Sort Gaps\n        self.assertEqual(d.gaps[0], (2, 7, 0))\n        self.assertEqual(d.gsrt[0], (1, 3, 1))\n\n        iter = d.iterate()\n        next(iter)\n        self.assertEqual(d.gmin, [1, 2, 2])\n        self.assertEqual(d.heap, [(5, 2, 2), (7, 2, 0)])\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == "-ut":\n        unittest.main(argv=[" "])\n\n    # Print the result string\n    print(calculate())\n\n__starting_point()
#      \nimport collections, atexit, math, sys\nfrom functools import cmp_to_key\n#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\nimport bisect \ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\n\ndef memo(func):  \n    cache={}  \n    def wrap(*args):  \n        if args not in cache:  \n            cache[args]=func(*args)  \n        return cache[args]  \n    return wrap\n\n@memo\ndef comb (n,k):\n    if k==0: return 1\n    if n==k: return 1\n    return comb(n-1,k-1) + comb(n-1,k)\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\n    atexit.register(lambda :sys.stdout.close())     #idle  atexit\n    \nN, = getIntList()\n\nzz = getIntList()\nzz.sort()\nresult = (zz[N-1] - zz[0]) * (zz[2*N-1] - zz[N])\n\ndif = zz[2*N-1] - zz[0]\n\nfor i in range(N):\n    nd = zz[i+N-1] - zz[i]\n    result = min(result, nd*dif)\n\nprint(result)\n\n\n\n\n\n\n\n
3\nn = int(input())\na = [True] * (n + 2)\nfor i in range(2, n + 2):\n    if not a[i]:\n        continue\n    j =  i * i\n    while j < n + 2:\n        a[j] = False\n        j += i\nif n <= 2:\n    print(1)\nelse:\n    print(2)\nprint(' '.join('1' if x else '2' for x in a[2:]))\n
p, n = [], int(input())\na = b = 0\nfor i in range(n):\n    t = list(map(int, input().split()))\n    k = t[0] // 2 + 1\n    a += sum(t[1: k])\n    if t[0] & 1:\n        p.append(t[k])\n        b += sum(t[k + 1: ])\n    else: b += sum(t[k: ])\np.sort(reverse = True)\nprint(a + sum(p[0 :: 2]), b + sum(p[1 :: 2]))
\ndef main():\n    s = input()\n    l = len(s)\n    \n    pretty_count = 0\n    for i in range(l):\n        left_paren_count = 0\n        right_paren_count = 0\n        wild_count = 0\n        for j in range(i, l):\n            if s[j] == '(':\n                left_paren_count += 1\n            elif s[j] == ')':\n                right_paren_count += 1\n            else: \n                wild_count += 1\n                \n            if left_paren_count + wild_count < right_paren_count:\n                break\n            if left_paren_count < wild_count + right_paren_count:\n                # Should fix one '?' as '('\n                wild_count -= 1\n                left_paren_count += 1\n                if wild_count < 0:\n                    break\n            if left_paren_count == wild_count + right_paren_count:\n                pretty_count += 1\n    print(pretty_count)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
import sys\n\ns1, s2 = input().split()\nn = int(input())\n\nfor _ in range(n):\n    print(s1, s2)\n    killed, new = input().split()\n    if s1 == killed:\n        s1 = new\n    else:\n        s2 = new\n\nprint(s1, s2)\n
def i1():\n return int(input())\ndef i2():\n return [int(i) for i in input().split()]\nq=i1()\nimport math\ny=[]\nfor i in range(q):\n y.append(i2())\n\nfor a,b in y:\n x=a*b\n c=int(math.sqrt(x))\n if c**2==x:\n    c-=1\n z=2*c\n if c>0 and (x//c)==c:\n   z-=1\n if c>0 and x%c==0 and (x//c-1)==c:\n   z-=1\n if a<=c:\n   z-=1\n if b<=c:\n   z-=1\n print(z)
n = int(input())\na = [int(x) for x in input().split()]\nl = [0] * (10**6 + 100)\nfor x in a:\n	l[x] += 1\ncur = 0\nans = 0\nfor x in l:\n	cur += x\n	if cur % 2:\n		ans += 1\n	cur //= 2\nprint(ans)\n
import itertools\nimport bisect\n\nn, A, cf, cm, m = [int(x) for x in input().split()]\nskills = [int(x) for x in input().split()]\nsorted_skills = list(sorted((k, i) for i, k in enumerate(skills)))\nbottom_lift = [0 for i in range(n)]\nfor i in range(1, n):\n    bottom_lift[i] = bottom_lift[i-1] + i * (sorted_skills[i][0] - sorted_skills[i-1][0])\nroot_lift = [0 for i in range(n+1)]\nfor i in range(1, n+1):\n    root_lift[i] = root_lift[i-1] + A - sorted_skills[n-i][0]\n\nmax_level = -1\nfor i in range(n+1):\n    money_left = m - root_lift[i]\n    if money_left < 0: break\n    k = min(bisect.bisect(bottom_lift, money_left), n-i)\n    money_left -= bottom_lift[k-1]\n    min_level = min(A, sorted_skills[k-1][0] + money_left//k) if k > 0 else A\n    level = cf*i + cm*min_level\n    if max_level < level:\n        max_level = level\n        argmax = i\n        argmax_min_level = min_level\n        argmax_k = k\n\nans = [0 for i in range(n)]\nfor i, skill in enumerate(sorted_skills):\n    if i < argmax_k:\n        ans[skill[1]] = argmax_min_level\n    elif i >= n - argmax:\n        ans[skill[1]] = A\n    else:\n        ans[skill[1]] = skill[0]\n\nprint(max_level)\nfor a in ans:\n    print(a, end = ' ')\n    \n
n = int(input())\nl = list(map(int, input().split()))\n\ninv = 0\nout = 0\nmult = 1\nfor i in range(32):\n    curr = dict()\n    opp = 0\n    same = 0\n\n    for v in l:\n        if v ^ 1 in curr:\n            if v & 1:\n                opp += curr[v ^ 1]\n            else:\n                same += curr[v ^ 1]\n            \n        if v not in curr:\n            curr[v] = 0\n        curr[v] += 1\n\n    for i in range(n):\n        l[i] >>= 1\n\n    if same <= opp:\n        inv += same\n    else:\n        inv += opp\n        out += mult\n    mult *= 2\nprint(inv, out)\n    \n    \n
3\n\nimport sys\n\nclass CumTree:\n    \n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n        self.count = 0\n        if a == b:\n            return\n        mid = (a + b) // 2\n        self.levo = CumTree(a, mid)\n        self.desno = CumTree(mid+1, b)\n        \n    def manjsi(self, t):\n        if self.a >= t:\n            return 0\n        if self.b < t:\n            return self.count\n        return self.levo.manjsi(t) + self.desno.manjsi(t)\n    \n    def vstavi(self, t):\n        if self.a <= t <= self.b:\n            self.count += 1\n            if self.a == self.b:\n                return\n            self.levo.vstavi(t)\n            self.desno.vstavi(t)\n        \nn = int(sys.stdin.readline())\np = [int(x) for x in sys.stdin.readline().strip().split()]\n\nct = CumTree(1, 4096)\n\nvsota = 0\nwhile len(p) > 0:\n    x = p.pop()\n    vsota += ct.manjsi(x)\n    ct.vstavi(x)\n\nk, d = vsota // 2, vsota % 2\nprint("%f" % (4*k + d))\n
"""\nCodeforces Round 254 Div 1 Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0:\n        return inputs\n    if mode == 1:\n        return inputs.split()\n    if mode == 2:\n        return [int(x) for x in inputs.split()]\n\ndef write(s="\n"):\n    if isinstance(s, list): s = " ".join(map(str,s))\n    s = str(s)\n    print(s, end="")\n\n################################################### SOLUTION\nn,m = read()\nv = read()\nbest = 0\nfor i in range(m):\n    a,b,c = read()\n    temp = (v[a-1] + v[b-1]) / c\n    best = max(best, temp)\nprint(best)
def Search(L,aa,x):\n    a=aa\n    b=len(L)\n    while(b-a>1):\n        i=(b+a)//2\n        if(L[i]>x):\n            b=i\n        elif(L[i]<x):\n            a=i\n        else:\n            return (i+1)-aa-1\n    return b-aa-1\n\nimport math\n\nn,d=list(map(int,input().split()))\n\nP=list(map(int,input().split()))\nans=0\nfor i in range(n):\n    x=Search(P,i,P[i]+d)\n    if(x>1):\n        ans+=((x)*(x-1))//2\nprint(ans)\n
m = int(input())\ns = input().strip()\n\nsa = [0] * len(s)\nfor i in range(len(s)):\n	sa[i] = ord(s[i]) - ord('a')\n\nsa = [-1] + sa + [-1]\n\ndef check_value(sa, m, threshold):\n	prev_ind = 0\n	for i in range(len(sa)):\n		if sa[i] <= threshold:\n			if i - prev_ind <= m:\n				prev_ind = i\n			else:\n				return False\n	return True\n\ndef get_indexes(sa, threshold):\n	seq = [i for i in range(len(sa)) if sa[i] <= threshold]\n	# seq = []\n	# for i in range(len(sa)):\n	# 	if sa[i] < threshold:\n	# 		seq[i].append(sa[i], i)\n	return seq\n\ndef filter_indexes(sa, seq, el, m):\n	new_seq = [0]\n	for i in range(1, len(seq) - 1):\n		if sa[seq[i]] != el or (sa[seq[i]] == el and seq[i+1] - new_seq[-1] > m):\n			new_seq.append(seq[i])\n	return new_seq[1:]\n\n\nthreshold = -1\nwhile (not check_value(sa, m, threshold)):\n	# print(threshold, get_indexes(sa, threshold))\n	threshold += 1\n# print(threshold, get_indexes(sa, threshold), sa)\n\nseq = get_indexes(sa, threshold)\nseq = filter_indexes(sa, seq, threshold, m)\n\ns = ''.join(sorted([chr(ord('a') + sa[x]) for x in seq]))\nprint(s)
def read_data():\n    n = int(input())\n    hs = list(map(int, input().split()))\n    return n, hs\n\n\ndef solve(n, hs):\n    left = get_left_index(n, hs)\n    right = get_right_index(n, hs)\n    vals = [[] for i in range(n)]\n    for h, l, r in zip(hs, left, right):\n        vals[r - l - 2].append(h)\n    min_hs = []\n    min_h = - float('inf')\n    for val in vals[::-1]:\n        for v in val:\n            min_h = max(min_h, v)\n        min_hs.append(min_h)\n    print(* min_hs[::-1])\n\n\ndef get_left_index(n, hs):\n    left = []\n    stack = []\n    for i, h in enumerate(hs):\n        while stack and hs[stack[-1]] >= h:\n            del stack[-1]\n        if stack:\n            left.append(stack[-1])\n        else:\n            left.append(-1)\n        stack.append(i)\n    return left\n\n\ndef get_right_index(n, hs):\n    hs.reverse()\n    tmp = get_left_index(n, hs)\n    hs.reverse()\n    tmp.reverse()\n    right = [n - 1 - a for a in tmp]\n    return right\n\nn, hs = read_data()\nsolve(n, hs)
n = int(input())\narr = [int(input()) for i in range(n)]\nb = [0 for i in range(n)]\ns = 0\nfor i in range(n):\n    j = int((arr[i] << 1) ** 0.5)\n    if j * (j + 1) > (arr[i] << 1):\n        j -= 1\n    s ^= j\nif s != 0:\n    print('NO')\nelse:\n    print('YES')\n
__author__ = 'Think'\nn=int(input())\naints=[int(i) for i in input().split()]\npermutes=[int(i)-1 for i in input().split()]\nresults=[0]\n\nrebuilt={}\nm=0\nfor numby in range(n-1, 0, -1):\n	p=permutes[numby]\n	below=False\n	above=False\n	if p-1 in rebuilt:\n		below=True\n	if p+1 in rebuilt:\n		above=True\n	if above and below:\n		bsum, bottom=rebuilt[p-1]\n		asum, top=rebuilt[p+1]\n		new=bsum+asum+aints[p]\n		rebuilt[bottom]=(new, top)\n		rebuilt[top]=(new, bottom)\n	elif above or below:\n		if above:\n			other=p+1\n		else:\n			other=p-1\n		psum, prev=rebuilt[other]\n		new=psum+aints[p]\n		rebuilt[prev]=(new, p)\n		rebuilt[p]=(new, prev)\n	else:\n		new=aints[p]\n		rebuilt[p]=(new, p)\n	m=max(new, m)\n	results.append(m)\nfor numby in range(n-1, -1, -1):\n	print(results[numby])\n\n\n
n = int(input())\na, b = [0] * (n + 2), [0] * (n + 2)\ns, l = 0, 1\np = [0] * n\nfor i in range(n):\n    t = list(map(int, input().split()))\n    if t[0] == 1:\n        b[t[1] - 1] += t[2]\n        s += t[1] * t[2]\n    elif t[0] == 2:\n        a[l] = t[1]\n        l += 1\n        s += t[1]\n    else:\n        l -= 1\n        s -= a[l] + b[l]\n        b[l - 1] += b[l]\n        b[l] = 0\n    p[i] = str(s / l)\nprint('\n'.join(p))
# -*- coding: utf-8 -*-\nfrom time import perf_counter\nfrom sys import stdin\n\ndef run(n, s):\n    m = 0\n    small = n // 2\n    for big in range(n-1, (n+1)//2-1, -1):\n        while small >= 0 and s[small] > s[big] / 2:\n            small -= 1\n        if small == -1:\n            break\n        #print(small, big)\n        small -= 1\n        m += 1\n    print(n-m)\n\ndef run2(n, s):\n    r = n - 1\n    l = n // 2 - 1\n    result = 0\n    while l >= 0:\n        if s[l] * 2 <= s[r]:\n            result += 1\n            r -= 1\n        l -= 1\n    print(n - result)\n\nn = int(input())\ns = sorted([int(x) for x in stdin.read().strip().split('\n')])\nrun(n, s)\n
from bisect import bisect_left, insort_left\na = []\nn = int(input())\nfor _ in range(n):\n    #print(a)\n    s, d = list(map(int, input().split()))\n    if len(a) == 0:\n        print(s, s+d - 1)\n        a.append((s, s + d - 1))\n        continue\n    p = bisect_left(a, (s, s + d - 1))\n    #print('p', p)\n    ok = True\n    if p > 0 and a[p-1][1] >= s:\n        ok = False\n    if p < len(a) and a[p][0] <= s + d - 1:\n        ok = False\n    if ok:\n        insort_left(a, (s, s + d - 1))\n        print(s, s + d - 1)\n    else:\n        ok = False\n        for i in range(len(a)):\n            if i == 0:\n                if a[0][0] > d:\n                    print(1,d)\n                    a = [(1, d)] + a\n                    ok = True\n                    break\n            else:\n                if a[i - 1][1] + d < a[i][0]:\n                    print(a[i - 1][1] + 1, a[i - 1][1] + d)\n                    insort_left(a, (a[i - 1][1] + 1, a[i - 1][1] + d))\n                    ok = True\n                    break\n        if not ok:\n            print(a[-1][1] + 1, a[-1][1] + d)\n            insort_left(a, (a[-1][1] + 1, a[-1][1] + d))\n
def evens(A):\n    n = len(A)\n    l = n//2-1; r = n//2\n    if len(A)%2 == 1: l+= 1\n    ans = [max(A[l], A[r])]\n    while r < n-1:\n        l-= 1; r+= 1\n        ans.append(max(ans[-1], A[l], A[r]))\n    return ans\n\ndef interleave(A, B):\n    q = []\n    for i in range(len(B)): q+= [A[i], B[i]]\n    if len(A) != len(B): q.append(A[-1])\n    return q\n\nn = int(input())\nA = list(map(int,input().split()))\nM = [min(A[i],A[i+1]) for i in range(n-1)]\nansA = evens(A)\nansM = evens(M) if n>1 else []\nif n%2 == 0: print(*interleave(ansA, ansM[1:]), max(A))\nelse: print(*interleave(ansM, ansA[1:]), max(A))
from collections import defaultdict, deque\n \nadj = defaultdict(lambda: defaultdict(lambda: 0))\ndef bfs(graph, inicio, destino, parent):\n    parent.clear()\n    queue = deque()\n    queue.append([inicio, float("Inf")])\n    parent[inicio] = -2\n    while (len(queue)):\n        current, flow = queue.popleft()\n        for i in adj[current]:\n            if parent[i] == -1 and graph[current][i] > 0:\n                parent[i] = current\n                flow = min(flow, graph[current][i])\n                if i == destino:\n                    return flow\n                queue.append((i, flow))\n    return 0\n \n \ndef maxflow(graph, inicio, destino):\n    flow = 0\n    parent = defaultdict(lambda: -1)\n    while True:\n        t = bfs(graph, inicio, destino, parent)\n        if t:\n            flow += t\n            current = destino\n            while current != inicio:\n                prev = parent[current]\n                graph[prev][current] -= t\n                graph[current][prev] += t\n                current = prev\n        else:\n            break\n    return flow\n \n \nn, m, x = [int(i) for i in input().split()]\n\nfor _ in range(m):\n    t = [int(i) for i in input().split()]\n    adj[t[0]][t[1]] = t[2]\n \n \ndef check(k):\n    meh = defaultdict(lambda: defaultdict(lambda: 0))\n    for i in adj:\n        for j in adj[i]:\n            ww = adj[i][j] // k\n            meh[i][j] = ww\n    flow = maxflow(meh, 1, n)\n    return flow\n \n \nlo = 1 / x\nhi = check(1)\n \nfor _ in range(70):\n    mid = (hi + lo) / 2\n    if hi-lo<0.0000000001:\n        break\n    if check(mid)>=x:\n        lo = mid\n    else:\n        hi = mid\nprint(format(lo * x, '.9f'))
# http://codeforces.com/problemset/problem/848/B\nfrom collections import defaultdict\n\n\ndef get_dest(start, w, h):\n    if start[0] == 1:\n        return (str(start[1]), str(h))\n    else:\n        return (str(w), str(start[1]))\n\n\nn, w, h = [int(x) for x in input().split()]\ndancers = []\ngroups = defaultdict(list)\ndestinations = [None for x in range(n)]\nfor ii in range(n):\n    g, p, t = [int(x) for x in input().split()]\n    dancers.append((g, p, t))\n    groups[p-t].append(ii)\n\n\nfor gg in list(groups.values()):\n    V, H = [], []\n    for ii in gg:\n        dancer = dancers[ii]\n        if dancer[0] == 1:\n            V.append(dancer)\n        else:\n            H.append(dancer)\n    V.sort(key=lambda x: -x[1])\n    H.sort(key=lambda x: x[1])\n    table = {orig: get_dest(new, w, h) for orig, new in zip(V+H, H+V)}\n    for ii in gg:\n        destinations[ii] = table[dancers[ii]]\n\n# print(destinations)\nfor dd in destinations:\n    print(" ".join(dd))\n
\ndef Sieve(n): \n    ret = []\n    divlis = [-1] * (n+1) \n    \n    flag = [True] * (n+1)\n    flag[0] = False\n    flag[1] = False\n\n    ind = 2\n    while ind <= n:\n\n        if flag[ind]:\n            ret.append(ind)\n\n            ind2 = ind ** 2\n\n            while ind2 <= n:\n                flag[ind2] = False\n                divlis[ind2] = ind\n                ind2 += ind\n\n        ind += 1\n\n    return ret,divlis\n\n\nsev,divlis = Sieve(210000)\n\nn = int(input())\na = list(map(int,input().split()))\n\ndic = {}\n\nfor i in range(n):\n\n    nd = {}\n\n    na = a[i]\n    while divlis[na] != -1:\n\n        if divlis[na] not in nd:\n            nd[divlis[na]] = 0\n        nd[divlis[na]] += 1\n\n        na //= divlis[na]\n\n    if na != 1:\n        if na not in nd:\n            nd[na] = 1\n        else:\n            nd[na] += 1\n\n    for x in nd:\n        if x not in dic:\n            dic[x] = []\n        dic[x].append(nd[x])\n\nans = 1\n\nfor i in dic:\n\n    if len(dic[i]) < n-1:\n        #print (i,"a")\n        continue\n    \n    dic[i].sort()\n\n    if len(dic[i]) == n:\n        ans *= i ** dic[i][1]\n        #print (i,"b")\n    else:\n        ans *= i ** dic[i][0]\n        #print (i,"c")\n\nprint (ans)\n
class DisjointSet(object):\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.num = n  # number of disjoint sets\n\n    def union(self, x, y):\n        self._link(self.find_set(x), self.find_set(y))\n\n    def _link(self, x, y):\n        if x == y:\n            return\n        self.num -= 1\n        if self.rank[x] > self.rank[y]:\n            self.parent[y] = x\n        else:\n            self.parent[x] = y\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n\n    def find_set(self, x):\n        xp = self.parent[x]\n        if xp != x:\n            self.parent[x] = self.find_set(xp)\n        return self.parent[x]\n\n\ndef solve():\n    n, m = list(map(int, input().split()))\n    ds = DisjointSet(n * 2)\n    for i in range(m):\n        a, b, c = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        aA = a * 2\n        aB = aA + 1\n        bA = b * 2\n        bB = bA + 1\n        if c == 0:\n            if ds.find_set(aA) == ds.find_set(bA):\n                return 0\n            ds.union(aA, bB)\n            ds.union(aB, bA)\n        else:\n            if ds.find_set(aA) == ds.find_set(bB):\n                return 0\n            ds.union(aA, bA)\n            ds.union(aB, bB)\n    return pow(2, (ds.num // 2) - 1, 10**9 + 7)\n\n\nprint(solve())\n
__author__ = 'Pavel Mavrin'\n\nn = int(input())\na = [int(x) for x in input().split()]\n\ns = 0\nres = 0\nfor i in a:\n    if i == 0:\n        res += s\n    else:\n        s += 1\n\nprint(res)\n
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\nmii=lambda:list(map(int,input().split()))\n\nn,m=mii()\na=[0 for _ in range(n)]\nc=[123456 for _ in range(n)]\nfor _ in range(m):\n    u,v=mii()\n    u%=n\n    v%=n\n    if v<u: v+=n\n    a[u]+=1\n    if c[u]>v: c[u]=v\n\nans=[]\nfor i in list(range(1,n))+[0]:\n    out=0\n    for j in range(i,n):\n        if not a[j]: continue\n        tmp=(j-i)+(a[j]-1)*n+(c[j]-j)\n        out=max(out,tmp)\n        #print(1,i,j,tmp)\n    for j in range(i):\n        if not a[j]: continue\n        tmp=(j+n-i)+(a[j]-1)*n+(c[j]-j)\n        out=max(out,tmp)\n        #print(2,i,j,tmp)\n    ans.append(out)\nprint(" ".join(map(str,ans)))\n
3\n\nimport sys\nfrom functools import lru_cache\n\nMOD = 1000000007\n\ncnk = [[1 for i in range(1001)] for j in range(1001)]\nfor i in range(1, 1001):\n    for j in range(1, i):\n        cnk[i][j] = cnk[i - 1][j - 1] + cnk[i - 1][j]\n\n\nk = int(input())\ncs = [int(input()) for i in range(k)]\n\nans = 1\nsm = 0\nfor c in cs:\n    sm += c\n    ans = (ans * cnk[sm - 1][c - 1]) % MOD\n\nprint(ans)\n
m = 1000000007\nn = int(input())\na = list(map(int, input().split()))\nprint(pow(2,n-1,m)-1 - sum(pow(2,a.count(x),m)-1 for x in set(a) if x != -1) % m)
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\n\ndef main():\n    n = I()\n    aa = [LI() for _ in range(n-1)]\n    e = collections.defaultdict(set)\n    for a,b in aa:\n        e[a].add(b)\n        e[b].add(a)\n\n    q = [[(1,-1)]]\n    qi = 0\n    while 1:\n        t = q[qi]\n        nq = []\n        for i,p in t:\n            for c in e[i]:\n                if c == p:\n                    continue\n                nq.append((c,i))\n        if len(nq) < 1:\n            break\n        q.append(nq)\n        qi += 1\n\n    gm = [1]\n    for i in range(1,n+1):\n        gm.append(i*gm[-1]%mod)\n\n    m = {}\n    def f(i, p):\n        t = 1\n        r = 1\n        for c in e[i]:\n            if c == p:\n                continue\n            # print('c',c)\n            r *= m[c]\n            r %= mod\n            t += 1\n\n        if p == -1:\n            r *= gm[t-1]\n            r *= n\n        else:\n            r *= gm[t]\n        r %= mod\n        m[i] = r\n        # print('r',i,p,r)\n        # print('g',gm[t],t)\n        return r\n\n    for qt in q[::-1]:\n        for i,p in qt:\n            # print('ip', i,p)\n            f(i,p)\n\n    r = f(1,-1)\n\n    return r\n\n\nprint(main())\n\n
strings = int(input())\n\ncount = [0 for x in range(7)]\n\nfor k in range(strings):\n    s = input()\n    for index in range(7):\n        if s[index] == '1':\n            count[index] += 1\n\nprint(max(count))\n
from collections import defaultdict, deque\n\nn = int(input())\nadj = [[] for _ in range(n)]\nv = [0] * n\nl = list(map(int, input().split()))\nfor i, f in enumerate(l):\n    adj[f - 1].append(i + 1)\n\ns = list(map(int, input().split()))\n\nQ = deque([(0, s[0], s[0])])\nans = 0\nflag = False\npossible = True\nwhile Q and possible:\n    # print(Q)\n    flag = not flag\n    for _ in range(len(Q)):\n        cur, v, curs = Q.popleft()\n        if v < 0:\n            possible = False\n            ans = -1\n            break\n        ans += v\n        if flag:\n            for i in adj[cur]:\n                if len(adj[i]) <= 1:\n                    Q.append((i, 0, curs))\n                else:\n                    temp = min([s[k] for k in adj[i]])\n                    Q.append((i, temp - curs, temp))\n        else:\n            for i in adj[cur]:\n                Q.append((i, s[i] - curs, s[i]))\nprint(ans)\n
from time import time\n\n\nopposite = {\n    'N': 'S',\n    'S': 'N',\n    'E': 'W',\n    'W': 'E'\n}\notr = str.maketrans(opposite)\n\nbits = {\n    'N': 0,\n    'S': 1,\n    'E': 2,\n    'W': 3,\n}\n\nQ = 4294967291\n\n\ndef combine(h, v, q):\n    return (h<<2 | v) % q\n\n\ndef combinel(h, v, q, s):\n    return (v*s + h) % q\n\n\ndef flip(s):\n    return ''.join(reversed(s.translate(otr)))\n\n\ndef solvable(p1, p2):\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(list(range(len(p1)))):\n        n1 = bits[p1[i]]\n        n2 = bits[opposite[p2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and p1[i:] == flip(p2[i:]):\n            return False\n        s = (s<<2) % Q\n    return True\n\n\ndef __starting_point():\n    n = int(input())\n    p1 = input()\n    p2 = input()\n    print('YES' if solvable(p1, p2) else 'NO')\n\n__starting_point()
import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nA = list(map(int, readline().split()))\nBW = [0, 0]\nfor i in range(N):\n    a = A[i]\n    BW[i%2] += a//2\n    BW[(i+1)%2] += -(-a//2)\nprint(min(BW))\n
n, k = map(int, input().split())\nt = set(map(int, input().split()))\ny = x = min(t)\nt = list(t)\nwhile True:\n    for i in t:\n        if i % x > k: x = i // (i // x + 1)\n    if y == x: break\n    y = x\nprint(y)
print('YES' if input().count('1')+1>>1<<1 >= input().count('1') else 'NO')
\nimport sys\nfrom sys import stdin\n\ndef modfac(n, MOD):\n \n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n    return factorials, invs\n\n\ndef modnCr(n,r,mod,fac,inv): \n    return fac[n] * inv[n-r] * inv[r] % mod\n\nmod = 998244353\n\nn = int(stdin.readline())\na = list(map(int,stdin.readline().split()))\na.sort()\nfac,inv = modfac(2*n+10,mod)\n\nprint( (modnCr(2*n,n,mod,fac,inv) * (sum(a[n:]) - sum(a[:n]))) % mod )\n
n = int(input())\n\nb = list(map(int, input().split()))\n\nm, M = min(b), max(b)\nif m == M:\n    if M == 0:\n        print('YES')\n        print(' '.join(['1' for i in range(n)]))\n    else:\n        print('NO')\nelse:\n    print('YES')\n\n    pos = list([i for i in range(n) if b[i] == M and b[i - 1] < M])[0]\n\n    a = [0 for i in range(n)]\n\n    a[pos] = M\n    a[pos - 1] = (M << 1) + b[pos - 1]\n\n    for i in range(2, n):\n        a[pos - i] = a[pos - i + 1] + b[pos - i]\n\n    print(*a)\n
import sys\nreadline = sys.stdin.readline        \ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0]*N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return par, order\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for i, v in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\n\n\nN = int(readline())\nroot = None\nEdge = [[] for _ in range(N)]\nCr = [None]*N\nfor a in range(N):\n    b, c = list(map(int, readline().split()))\n    b -= 1\n    if b == -1:\n        root = a\n    else:\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Cr[a] = c\n\nP, L = parorder(Edge, root)\n        \ndp = [0]*N\n\nfor l in L[:0:-1]:\n    p = P[l]\n    dp[p] += 1+dp[l]\n\nif any(d < c for d, c in zip(dp, Cr)):\n    print('NO')\nelse:\n    print('YES')\n    A = [None]*N\n    dp2 = [[] for _ in range(N)]\n    for l in L[:0:-1]:\n        p = P[l]\n        dp2[l] = dp2[l][:Cr[l]] + [l] + dp2[l][Cr[l]:]\n        dp2[p].extend(dp2[l])\n    dp2[root] = dp2[root][:Cr[root]] + [root] + dp2[root][Cr[root]:]        \n    Ans = [None]*N\n    for i in range(N):\n        Ans[dp2[root][i]] = i+1\n    print(' '.join(map(str, Ans)))\n
n=int(input())\na=[]\nfor i in range(n):\n  a.append(list(map(int,input().split())))\nans = [0]*n\nfor i in range(n):\n  for j in range(n):\n    if j!=i:\n      ans[i] |= a[i][j]\n  print(ans[i],end = ' ')\n
from bisect import *\n\nn, tc, td = [int(i) for i in input().split()]\nfc = []\nfd = []\nmbc = 0\nmbd = 0\nfor _ in range(n):\n    b, p, ft = input().split()\n    b, p = int(b), int(p)\n    f = (p, b)\n    if ft == 'C':\n        if p <= tc:\n            fc.append(f)\n            mbc = max(mbc, b)\n    else:\n        if p <= td:\n            fd.append(f)\n            mbd = max(mbd, b)\n\nfc = sorted(fc)\nfd = sorted(fd)\n\ndef pick2(fc, tc):\n    bf = []\n    maxb = 0\n    ans = 0\n    for f in fc:\n        p, b = f\n        maxpp = tc - p\n        ii = bisect_left(bf, (maxpp+1, 0)) - 1\n        if ii >= 0:\n            pp, bb = bf[ii]\n            ans = max(ans, bb + b)\n        if b > maxb:\n            bf.append(f)\n            maxb = b\n    return ans\n\nans = mbc + mbd if mbc > 0 and mbd > 0 else 0\nans = max(ans, pick2(fc, tc))\nans = max(ans, pick2(fd, td))\n\nprint(ans)\n
\ndef main():\n    k = int(input())\n    n = []\n    a = []\n    for i in range(k):\n        line = [int(x) for x in input().split()]\n        ni = line[0]\n        ai = []\n        n.append(ni)\n        a.append(ai)\n        for j in range(ni):\n            ai.append(line[1 + j])\n    answer, c, p = solve(k, n, a)\n    if answer:\n        print("Yes")\n        for i in range(k):\n            print(c[i], p[i] + 1)\n    else:\n        print("No")\n\n\ndef solve(k, n, a):\n    asum, sums = calc_sums(k, n, a)\n    if asum % k != 0:\n        return False, None, None\n    tsum = asum / k\n    num_map = build_num_map(k, n, a)\n    masks = [None]*(1 << k)\n    simple = [False]*(1 << k)\n    for i in range(k):\n        for j in range(n[i]):\n            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, dict())\n            if found:\n                simple[mask] = True\n                masks[mask] = path\n    for i in range(1 << k):\n        if not simple[i]:\n            continue\n        mask = i\n        zeroes_count = 0\n        for u in range(k):\n            if (1 << u) > mask:\n                break\n            if (mask & (1 << u)) == 0:\n                zeroes_count += 1\n        for mask_mask in range(1 << zeroes_count):\n            mask_child = 0\n            c = 0\n            for u in range(k):\n                if (1 << u) > mask:\n                    break\n                if (mask & (1 << u)) == 0:\n                    if (mask_mask & (1 << c)) != 0:\n                        mask_child = mask_child | (1 << u)\n                    c += 1\n            if masks[mask_child] and not masks[mask_child | mask]:\n                masks[mask_child | mask] = {**masks[mask_child], **masks[mask]}\n                if (mask_child | mask) == ((1 << k) - 1):\n                    c = [-1] * k\n                    p = [-1] * k\n                    d = masks[(1 << k) - 1]\n                    for key, val in list(d.items()):\n                        c[key] = val[0]\n                        p[key] = val[1]\n                    return True, c, p\n    if masks[(1 << k) - 1]:\n        c = [-1] * k\n        p = [-1] * k\n        d = masks[(1 << k) - 1]\n        for key, val in list(d.items()):\n            c[key] = val[0]\n            p[key] = val[1]\n        return True, c, p\n    return False, None, None\n\n\ndef build_num_map(k, n, a):\n    result = dict()\n    for i in range(k):\n        for j in range(n[i]):\n            result[a[i][j]] = (i, j)\n    return result\n\n\ndef find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):\n    if (mask & (1 << i)) != 0:\n        if i == i_origin and j == j_origin:\n            return True, mask, path\n        else:\n            return False, None, None\n    mask = mask | (1 << i)\n    a_needed = tsum - (sums[i] - a[i][j])\n    if a_needed not in num_map:\n        return False, None, None\n    i_next, j_next = num_map[a_needed]\n    path[i_next] = (a[i_next][j_next], i)\n    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)\n\n\ndef calc_sums(k, n, a):\n    sums = [0] * k\n    for i in range(k):\n        for j in range(n[i]):\n            sums[i] = sums[i] + a[i][j]\n    asum = 0\n    for i in range(k):\n        asum = asum + sums[i]\n    return asum, sums\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
s = input()\nt = input()\n\nn = len(s)\nm = len(t)\n\nt = t + '$' + s\n\np = [0] * (n + m + 1)\nk = 0\nfor i in range(1, n + m + 1):\n    while k > 0 and t[k] != t[i]:\n        k = p[k - 1]\n    if t[k] == t[i]:\n        k += 1\n    p[i] = k\n\nans = [0] * n\nsums = [0] * (n + 1)\ncurs = 0\nwas = False\nj = 0\nMOD = 10 ** 9 + 7\nfor i in range(n):\n    if p[i + m + 1] == m:\n        if not was:\n            was = True\n            curs = 1\n        while j <= i - m:\n            curs = (curs + sums[j] + 1) % MOD\n            j += 1\n    ans[i] = curs\n    sums[i] = (sums[i - 1] + ans[i]) % MOD\n\nprint(sum(ans) % MOD)\n
import sys\nreadline = sys.stdin.readline\n\nN, D, M = map(int, readline().split())\nA = list(map(int, readline().split()))\nAm = [a for a in A if a > M]\nAo = [a for a in A if a <= M]\nAm.sort(reverse = True)\nAo.sort(reverse = True)\nCam = Am[:]\nCao = Ao[:]\n\nfor i in range(1, len(Cam)):\n    Cam[i] += Cam[i-1]\nfor i in range(1, len(Cao)):\n    Cao[i] += Cao[i-1]\n\nk = -(-N//(D+1))\nans = sum(Am[:k])\nlcam = len(Cam)\nCam = [0] + Cam\nfor i in range(len(Cao)):\n    k = min(lcam, -(-(N-(i+1))//(D+1)))\n    ans = max(ans, Cao[i] + Cam[k])\n\n\nprint(ans)
n,r1,r2,r3,D = map(int,input().split())\n\nstate = [0,0] # after odd number of 2 (1st), or not (2nd)\n\na = list(map(int,input().split()))\n\n# First element\n\n# Choosing P~P + A\n\nstate[0] = r1 * a[0] + r3\n\n# Choosing L + P later or all P\n\nstate[1] = min(r2 + r1 + D, r1 * (a[0] + 2) + D)\n\n# Second to Second Last element\n\nfor i in range(1,n-1):\n    newState = [-1,-1]\n    newState[0] = min(state[1] + D + r1 * a[i] + r3, state[0] + r1 * a[i] + r3,\n                        state[1] + r2 + r1 + D, state[1] + r1 * (a[i] + 2) + D)\n    newState[1] = min(state[0] + r2 + r1 + D, state[0] + r1 * (a[i] + 2) + D)\n    state = newState\n\n# Last Element\n\nans = min(state[0] + r1 * a[-1] + r3, state[0] + 2 * D + r2 + r1, state[0] + 2 * D + r1 * (a[-1] + 2),\n            state[1] + r1 * a[-1] + r3, state[1] + r2 + r1 + D, state[1] + r1 * (a[-1] + 2) + D)\n\nprint(ans + D * (n-1))
import sys\n\ndef binpow(a, n, p):\n    res = 1\n    while n > 0:\n        if n % 2 == 1:\n            res = (res * a) % p\n        a = (a * a) % p\n        n >>= 1\n    return res\n\ndef main():\n    result = []\n    \n    t = int(sys.stdin.readline())\n    for line in sys.stdin.readlines():\n        p, q, b = list(map(int, line.split()))\n        for i in range(6):\n            b = (b * b) % q\n        result.extend(list("Finite\n" if (p * b) % q == 0 else list("Infinite\n")))\n    sys.stdout.write("".join(result))\n\nmain()\n
n, m = map(int, input().split())\na = set(map(int, input().split()))\n \ny = 2 ** n\nmk = [0] * (2 * y)\ncur = 0\nfor x in a:\n    if mk[x]: continue\n    mk[x] = 1\n    st = [x]\n    while st:\n        u = st.pop()\n        if u < y:\n            if not mk[y + u]:\n                mk[y + u] = 1\n                st.append(y + u)\n        else:\n            for b in range(n):\n                v = u | 1 << b\n                if u < v and not mk[v]:\n                    mk[v] = 1\n                    st.append(v)\n            v = y - 1 - (u - y)\n            if v in a and not mk[v]:\n                mk[v] = 1\n                st.append(v)\n    cur += 1\n    \nprint(cur)
import sys\ninput = sys.stdin.readline\n\nMOD = 987654103\n\nn = int(input())\nt = input()\n\nplace = []\nf1 = []\ne1 = []\n\ns = []\ncurr = 0\ncount1 = 0\nfor i in range(n):\n    c = t[i]\n    if c == '0':\n        if count1:\n            e1.append(i - 1)\n            if count1 & 1:\n                s.append(1)\n                curr += 1\n                e1.append(-1)\n                f1.append(-1)\n            count1 = 0\n        else:\n            f1.append(-1)\n            e1.append(-1)\n\n        place.append(curr)\n        curr += 1\n        s.append(0)\n    else:\n        if count1 == 0:\n            f1.append(i)\n        count1 += 1\n        place.append(curr)\n\nif count1:\n    if count1 & 1:\n        s.append(1)\n    else:\n        s.append(0)\n    curr += 1\n    e1.append(n - 1)\n\n    e1.append(-1)\n    f1.append(-1)\nplace.append(curr)\n\npref = [0]\nval = 0\nfor i in s:\n    val *= 3\n    val += i + 1\n    val %= MOD\n    pref.append(val)\n        \n\nq = int(input())\nout = []\nfor _ in range(q):\n    l1, l2, leng = list(map(int, input().split()))\n    l1 -= 1\n    l2 -= 1\n\n    starts = (l1, l2)\n    hashes = []\n    for start in starts:\n        end = start + leng - 1\n\n        smap = place[start]\n        emap = place[end]\n        if t[end] == '1':\n            emap -= 1\n        if s[smap] == 1:\n            smap += 1\n\n        prep = False\n        app = False\n\n        if t[start] == '1':\n            last = e1[place[start]]\n            last = min(last, end)\n            count = last - start + 1\n            if count % 2:\n                prep = True\n        if t[end] == '1':\n            first = f1[place[end]]\n            first = max(first, start)\n            count = end - first + 1\n            if count % 2:\n                app = True\n\n        preHash = 0\n        length = 0\n        if smap <= emap:\n            length = emap - smap + 1\n            preHash = pref[emap + 1]\n            preHash -= pref[smap] * pow(3, emap - smap + 1, MOD)\n            preHash %= MOD\n\n\n        if length == 0 and prep and app:\n            app = False\n\n        #print(preHash, prep, app, length)\n        if prep:\n            preHash += pow(3, length, MOD) * 2\n            length += 1\n        if app:\n            preHash *= 3\n            preHash += 2\n        #print(preHash)\n\n        preHash %= MOD\n        hashes.append(preHash)\n        \n    if hashes[0] == hashes[1]:\n        out.append('Yes')\n    else:\n        out.append('No')\n\nprint('\n'.join(out))\n\n    \n
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\nn,s=list(map(int,input().split()))\n\na=list(map(int,input().split()))\na.sort()\nmed=a[n//2]\n\nans=0\nif med>s:\n    for i in range(n//2+1):\n        if a[i]>s:\n            ans+=a[i]-s\nelif med<s:\n    for i in range(n//2,n):\n        if s>a[i]:\n            ans+=s-a[i]\nprint(ans)\n\n
# \ndef prime_decomposition(n):\n    i = 2\n    table = []\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            table.append(i)\n        i += 1\n    if n > 1:\n        table.append(n)\n    return table\nimport sys\ninput = sys.stdin.readline\nN = int(input())\nA = list(map(int, input().split()))\n# \nsu = sum(A)\nif su == 1:\n    print(-1)\n    return\nprimes = list(set(prime_decomposition(su)))\nans = float("inf")\nIdx1 = [i for i, a in enumerate(A) if a]\n\nfor p in primes:\n    an = 0\n    half = p // 2\n    for t in zip(*[iter(Idx1)]*p):\n        idx = t[half]\n        an += sum(abs(i-idx) for i in t)\n    ans = min(ans, an)\nprint(ans)\n
#!/usr/bin/env python3\n\nfrom collections import defaultdict\n\nDEBUG = False\n\n\ndef main():\n    if DEBUG:\n        test()\n\n    n = int(input())\n\n    paths = cycles(n)\n\n    print(len(paths))\n    for p in paths:\n        print('%d %s' % (len(p), ' '.join([str(v) for v in p])))\n\n\ndef cycles(n):\n    """Builds a set of cycles for a fully connected graph with n vertices."""\n    if n % 2 == 0:\n        return even(n)\n    else:\n        return odd(n)\n\n\ndef even(n):\n    """Builds a set of cycles that a graph with even vertices."""\n    assert n % 2 == 0\n\n    # Base case for complete graph such that V = {1, 2, 3, 4}.\n    cycles = [[1, 2, 3], [2, 3, 4], [3, 4, 1], [4, 1, 2]]\n\n    for i in range(6, n + 1, 2):\n        a, b = i, i - 1\n\n        # Use edges (a, 1), (a, 0), (b, 1), (b, 0), (a, b) exactly twice each.\n        cycles += [[a, 1, b], [a, 2, b], [a, 1, b, 2]]\n\n        # Similar to odd(...) as we are left with 2n - 2 edges to use\n        # connected to i - 4 of the vertices V' = {3 ... i - 2}. Notice that\n        # |V'| is even so we can apply the same strategy as in odd(...).\n        for k in range(3, i - 1, 2):\n            c, d = k, k + 1\n            cycles += [[a, c, b, d]] * 2\n\n    return cycles\n\n\ndef odd(n):\n    """Builds a set of cycles that a graph with odd vertices."""\n    assert n % 2 == 1\n\n    # Base case for complete graph such that V = {1, 2, 3}.\n    cycles = [[1, 2, 3]] * 2\n\n    for i in range(5, n + 1, 2):\n        a, b = i, i - 1\n        # Say the new vertices are {a, b}. Since the graph is fully connected\n        # adding these 2 vertices results in 2n + 1 more edges. We use a length\n        # 3 cycle a -> b -> 1 > a twice to use up 3 of these edges.\n        cycles += [[a, b, 1]] * 2\n\n        # At this point we are left with 2n + 1 - 3 = 2n - 2 edges to use\n        # connected to i - 3 of the vertices V' = {2 ... i - 2}. Notice that\n        # |V'| is even. To use these edges and cover vertices V' we take pairs\n        # c, d in V' and create two of each path a -> c -> b -> d -> a.\n        for k in range(2, i - 1, 2):\n            c, d = k, k + 1\n            cycles += [[a, c, b, d]] * 2\n\n    return cycles\n\n\ndef test():\n    """Checks the cycles(...) solver for a bunch of inputs."""\n    print('Testing...')\n\n    for n in range(3, 300, 21):\n        check(n, cycles(n))\n\n    print('Tests pass!')\n\n\ndef check(n, paths):\n    """Checks the solution for errors."""\n    # Check that all vertices are covered.\n    vertices = set(sum(paths, list()))\n    assert vertices == set(range(1, n + 1))\n\n    # Check that each edge is used exactly twice.\n    counts = defaultdict(int)\n\n    for p in paths:\n        assert len(p) == 3 or len(p) == 4\n        assert len(set(p)) == len(p)\n\n        for i in range(len(p)):\n            key = tuple(sorted([p[i - 1], p[i]]))\n            counts[key] += 1\n\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            assert counts[(i, j)] == 2\n\ndef __starting_point():\n    main()\n\n__starting_point()
k, q = list(map(int, input().split()))\nt = [0] * (k + 1)\nt[1] = 1\nd = [0]\nn = i = 1\nwhile i < 1001:\n    if 2000 * t[k] > i - 1e-7:\n        d.append(n)\n        i += 1\n    else:\n        t = [0] + [(j * t[j] + (k - j + 1) * t[j - 1]) / k for j in range(1, k + 1)]\n        n += 1\nfor i in range(q): print(d[int(input())])\n
def main():\n    n, m = list(map(int, input().split()))\n    aa = []\n    for _ in range(n):\n        row = list(map(int, input().split()))\n        row.append(0)\n        aa.append(row)\n    aa.append([0] * (m + 1))\n    d1, d2, d3, d4 = ([[0] * (m + 1) for _ in range(n + 1)] for _ in (1, 2, 3, 4))\n    for i in range(n):\n        for j in range(m):\n            d1[i][j] = max(d1[i - 1][j], d1[i][j - 1]) + aa[i][j]\n    for i in range(n):\n        for j in range(m - 1, -1, -1):\n            d2[i][j] = max(d2[i - 1][j], d2[i][j + 1]) + aa[i][j]\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            d3[i][j] = max(d3[i + 1][j], d3[i][j - 1]) + aa[i][j]\n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            d4[i][j] = max(d4[i + 1][j], d4[i][j + 1]) + aa[i][j]\n    print((max(\n        max(d1[i][j - 1] + d2[i - 1][j] + d3[i + 1][j] + d4[i][j + 1] for i in range(1, n - 1) for j in range(1, m - 1)),\n        max(d1[i - 1][j] + d2[i][j + 1] + d3[i][j - 1] + d4[i + 1][j] for i in range(1, n - 1) for j in range(1, m - 1)))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n = int(input())\nans = 'YES\n'\nfor i in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    res = (x1 & 1) * 2 + (y1 & 1) + 1\n    ans += str(res) + '\n'\nprint(ans)
def main():\n    from heapq import heapify, heapreplace\n    input()\n    s = set(map(int, input().split()))\n    xx = [-x for x in s]\n    heapify(xx)\n    while True:\n        x = -xx[0]\n        while x != 1:\n            x //= 2\n            if x not in s:\n                s.add(x)\n                heapreplace(xx, -x)\n                break\n        else:\n            break\n    print(' '.join(str(-x) for x in xx))\n\ndef __starting_point():\n    main()\n\n__starting_point()
def comp(x):\n    for i in range(2, x):\n        if x % i == 0:\n            return True\n    return False\n\nN = int(input())\n\nif N == 4:\n    print('YES', '1', '3', '2', '4', sep = '\n')\nelif comp(N):\n    print('NO')\nelse:\n    print('YES', '1', sep = '\n')\n    if N > 1:\n        for i in range(2, N):\n            print((i - 1) * pow(i, N - 2, N) % N)\n        print(N)\n    \n
from collections import defaultdict\n\n\ndef __starting_point():\n    n, T = [int(_) for _ in input().split()]\n    data = defaultdict(list)\n    for i in range(n):\n        t, q = [int(_) for _ in input().split()]\n        data[T - t].append(q)\n\n    prev_level = []\n    for level_id in range(1, T + 1):\n        level = sorted(data[T - level_id] + prev_level, reverse=True) \n        if T - level_id <= 10:\n            max_size = 2 ** (T - level_id)\n            level = level[:max_size]\n        if len(level) % 2 == 1:\n            level.append(0)\n        prev_level = [\n            level[i] + level[i + 1]\n            for i in range(0, len(level), 2)\n        ]\n    print(prev_level[0])\n\n__starting_point()
import sys\nn,k = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\ntot = sum(arr)\nif tot % k != 0:\n	print('No')\n	return\ntot //= k\nidx,cur = 0,0\nans = []\nfor i in range(n):\n	cur += arr[i]\n	idx += 1\n	if cur == tot:\n		ans.append(idx)\n		idx = 0\n		cur = 0\n	elif cur > tot:\n		print('No')\n		return\nif sum(ans) != n:\n	print('No')\n	return\nprint('Yes')\nfor an in ans:\n	print(an,end=' ')
f = lambda: map(int, input().split())\nn, m, w = f()\nwb = [(0, 0)] + list(zip(f(), f()))\nt = list(range(n + 1))\n\n\ndef g(x):\n    if x == t[x]: return x\n    t[x] = g(t[x])\n    return t[x]\n\n\nfor i in range(m):\n    x, y = f()\n    x, y = g(x), g(y)\n    if x != y: t[y] = x\n\np = [[] for j in range(n + 1)]\nfor i in range(1, n + 1): p[g(i)].append(i)\n\nd = [1] + [0] * w\nfor q in p:\n    if len(q) > 1:\n        WB = [wb[i] for i in q]\n        SW = sum(q[0] for q in WB)\n        SB = sum(q[1] for q in WB)\n\n        for D in range(w, -1, -1):\n            if d[D]:\n                if D + SW <= w: d[D + SW] = max(d[D + SW], d[D] + SB)\n                for W, B in WB:\n                    if D + W <= w: d[D + W] = max(d[D + W], d[D] + B)\n\n    elif len(q) == 1:\n        W, B = wb[q[0]]\n        for D in range(w - W, -1, -1):\n            if d[D]: d[D + W] = max(d[D + W], d[D] + B)\n\nprint(max(d) - 1)
maxn=50+10\ng=[None]*maxn\ndp=[None]*maxn\nc=[None]*maxn\nsize=[0]*maxn\n\nfor i in range(0,maxn):\n    c[i]=[0]*maxn\n    c[i][0]=1\n    for j in range(1,i+1):\n        c[i][j]=c[i-1][j-1]+c[i-1][j]\n\nn=int(input())\nfor i in range(1,n+1):\n    g[i]=[]\nfor i in range(1,n):\n    u,v=input().split()\n    u=int(u)\n    v=int(v)\n    g[u].append(v)\n    g[v].append(u)\n\ndef mul(a,b,x,y):\n    tmp=[0]*(x+y+1)\n    for i in range(0,x+1):\n        for j in range(0,y+1):\n            tmp[i+j]+=a[i]*b[j]*c[i+j][i]*c[x+y-i-j][x-i]\n    return tmp\ndef dfs(pos,fa):\n    nonlocal dp\n    nonlocal size\n    dp[pos]=[1]\n    size[pos]=0\n    for ch in g[pos]:\n        if ch != fa:\n            dfs(pos=ch,fa=pos)\n            dp[pos]=mul(dp[pos],dp[ch],size[pos],size[ch])\n            size[pos]+=size[ch]\n    if fa:\n        size[pos]+=1\n        tmp=[0]*(size[pos]+1)\n        for i in range(0,size[pos]+1):\n            for j in range(0,size[pos]):\n                if j<i:\n                    tmp[i]+=dp[pos][i-1]\n                else:\n                    tmp[i]+=dp[pos][j]*0.5\n        dp[pos]=tmp\n\nfor i in range(1,n+1):\n    dfs(pos=i,fa=0)\n    tmp=dp[i][0]\n    for j in range(1,n):\n        tmp/=j\n    print(tmp)
import sys\nreadline = sys.stdin.readline\n\nMOD = 10**9+7\nS = readline().strip().split('1')\nif len(S) == 1:\n    print(len(S[0]))\nelse:\n    S = [len(s)+1 for s in S]\n    ans = S[0]*S[-1]\n    S = S[1:-1]\n    \n    dp = [0]*(max(S)+2)\n    dp[0] = 1\n    for ai in S:\n        res = 0\n        rz = 0\n        for i in range(ai+1):\n            res = (res + dp[i])%MOD\n            rz = (rz + (ai-i)*dp[i])%MOD\n            dp[i] = 0\n        dp[0] = rz\n        dp[ai] = res\n    aaa = 0\n    for d in dp:\n        aaa = (aaa+d)%MOD\n    print(aaa*ans%MOD)\n
import sys\ninput = sys.stdin.readline\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split())) + [0]*500000\n    ans_S = 0\n    a[n] = a[0] + m\n    s = [0]*600600\n    for i in range(n):\n        s[i] = a[i + 1] - a[i]\n    s[n] = -1\n    for i in range(n):\n        s[2*n - i] = s[i]\n    for i in range(2*n + 1, 3*n + 1):\n        s[i] = s[i - n]\n    l, r = 0, 0\n    z = [0]*600600\n    for i in range(1, 3*n + 1):\n        if i < r:\n            z[i] = z[i - l]\n        while i + z[i] <= 3*n and (s[i + z[i]] == s[z[i]]):\n            z[i] += 1\n        if i + z[i] > r:\n            l = i\n            r = i + z[i]\n    ans = []\n    for i in range(n + 1, 2*n + 1):\n        if z[i] < n:\n            continue\n        ans_S += 1\n        ans.append((a[0] + a[2*n - i + 1]) % m)\n    ans.sort()\n    print(ans_S)\n    print(*ans)\n    return\n\ndef __starting_point():\n    main()\n__starting_point()
def init_factorials(N, mod):\n    f = 1\n    fac = [1] * N\n    for i in range(1, N):\n        f *= i\n        f %= mod\n        fac[i] = f\n    return fac\n\ndef init_inv(N, mod, fac):\n    b = bin(mod-2)[2:][-1::-1]\n    ret = 1\n    tmp = fac[N]\n    if b[0] == '1':\n        ret = fac[N]\n    for bi in b[1:]:\n        tmp *= tmp\n        tmp %= mod\n        if bi == '1':\n            ret *= tmp\n            ret %= mod\n    inv = [1] * (N + 1)\n    inv[N] = ret\n    for i in range(N-1, 0, -1):\n        ret *= i + 1\n        ret %= mod\n        inv[i] = ret\n    return inv\n\n\ndef f(r, c, mod, fac, inv):\n    return (fac[r + c] * inv[r] * inv[c]) % mod\n\n\ndef read_data():\n    h, w, n = list(map(int, input().split()))\n    blacks = []\n    for i in range(n):\n        r, c = list(map(int, input().split()))\n        blacks.append((r, c))\n    return h, w, n, blacks\n\ndef solve(h, w, n, blacks):\n    mod = 10**9 + 7\n    fac = init_factorials(h + w + 10, mod)\n    inv = init_inv(h + w + 5, mod, fac)\n    ans = (fac[h+w-2]*inv[h-1]*inv[w-1]) % mod\n    eb = [(r + c, r, c) for r, c in blacks]\n    eb.sort()\n    blacks = [(r, c) for rc, r, c in eb]\n    g = [f(r-1, c-1, mod, fac, inv) for r, c in blacks]\n    hw = h+w\n    for i, (r, c) in enumerate(blacks):\n        gi = g[i]\n        rc = r + c\n        ans -= gi*fac[hw-rc]*inv[h-r]*inv[w-c]\n        ans %= mod\n        for j, (rj, cj) in enumerate(blacks[i+1:], i+1):\n            if r <= rj and c <= cj:\n                g[j] -= gi*fac[rj+cj-rc]*inv[rj-r]*inv[cj-c]\n                g[j] %= mod\n    return ans\n\nh, w, n, blacks = read_data()\nprint(solve(h, w, n, blacks))\n
f = lambda: list(map(int, input().split()))[1:]\nn = int(input())\ns, p, q = [], [], []\nfor x in [0, 1]:\n    r = f()\n    s.append(r)\n    t = [len(r)] * n\n    t[0] = 0\n    p.append(t)\n    q.append((x, 0))\nwhile q:\n    x, i = q.pop()\n    y = 1 - x\n    for d in s[y]:\n        j = (i - d) % n\n        if p[y][j] < 1: continue\n        p[y][j] = -1\n        for d in s[x]:\n            k = (j - d) % n\n            if p[x][k] < 1: continue\n            p[x][k] -= 1\n            if p[x][k] == 0: q.append((x, k))\nfor x in [0, 1]:\n    print(*[['Lose', 'Loop', 'Win'][min(q, 1)] for q in p[x][1:]])
def read_data():\n    n, q = map(int, input().split())\n    As = list(map(int, input().split()))\n    LRs = []\n    for i in range(q):\n        L, R = list(map(int, input().split()))\n        LRs.append((L, R))\n    return n, q, As, LRs\n\ndef solve(n, q, As, LRs):\n    difs = calc_difs(As)\n    Ls = get_Ls(difs)\n    Rs = get_Rs_allow_ties(difs)\n    for L, R in LRs:\n        print(calc(L-1, R-2, Ls, Rs, difs))\n\n    \ndef calc_difs(As):\n    difs = [abs(a0 - a1) for a0, a1 in zip(As, As[1:])]\n    return difs\n\n\ndef get_Ls(Vs):\n    L = []\n    st = []\n    for i, v in enumerate(Vs):\n        while st and Vs[st[-1]] < v:\n            st.pop()\n        if st:\n            L.append(st[-1] + 1)\n        else:\n            L.append(0)\n        st.append(i)\n    return L\n\ndef get_Ls_allow_ties(Vs):\n    L = []\n    st = []\n    for i, v in enumerate(Vs):\n        while st and Vs[st[-1]] <= v:\n            st.pop()\n        if st:\n            L.append(st[-1] + 1)\n        else:\n            L.append(0)\n        st.append(i)\n    return L\n\ndef get_Rs(Vs):\n    n = len(Vs)\n    revVs = Vs[::-1]\n    revRs = get_Ls(revVs)\n    revRs.reverse()\n    return [n - 1 - R for R in revRs]\n\n\ndef get_Rs_allow_ties(Vs):\n    n = len(Vs)\n    revVs = Vs[::-1]\n    revRs = get_Ls_allow_ties(revVs)\n    revRs.reverse()\n    return [n - 1 - R for R in revRs]\n\ndef calc(L, R, Ls, Rs, difs):\n    ans = 0\n    for i in range(L, R + 1):\n        ans += difs[i] * (i - max(Ls[i], L) + 1) * (min(Rs[i], R) - i + 1)\n    return ans\n\nn, q, As, LRs = read_data()\nsolve(n, q, As, LRs)
import sys\nfrom array import array  # noqa: F401\n\nn = int(input())\nmatrix = [array('i', list(map(int, input().split()))) for _ in range(n)]\naa = tuple([int(x) - 1 for x in input().split()])\nans = [''] * n\n\nfor i in range(n-1, -1, -1):\n    x = aa[i]\n\n    for a in range(n):\n        for b in range(n):\n            if matrix[a][b] > matrix[a][x] + matrix[x][b]:\n                matrix[a][b] = matrix[a][x] + matrix[x][b]\n\n    val, overflow = 0, 0\n    for a in aa[i:]:\n        for b in aa[i:]:\n            val += matrix[a][b]\n        if val > 10**9:\n            overflow += 1\n            val -= 10**9\n\n    ans[i] = str(10**9 * overflow + val)\n\nprint(' '.join(ans))\n
def check(num1, num2, p, k):\n    v = num1 + num2\n    v *= num1 * num1 + num2 * num2\n    v %= p\n    v += p\n    v %= p\n    return v == k % p\n\ndef __starting_point():\n\n    n, p, k = (int(x) for x in input().split())\n    idx___number = [int(x) for x in input().split()]\n\n    idx___precount = [((pow(x, 4, p) - k * x) % p + p) % p for x in idx___number]\n\n    met_precount___vals = {}\n    ans = 0\n    for number, precount in zip(idx___number[::-1], idx___precount[::-1]):\n        if precount not in met_precount___vals:\n            met_precount___vals[precount] = []\n        else:\n            for val in met_precount___vals[precount]:\n                if check(number, val, p, k):\n                    ans += 1\n        met_precount___vals[precount].append(number)\n    print(ans)\n\n__starting_point()
import heapq\n\ndef sum_sqaure(a, k):\n    q, r = divmod(a, k)\n    return q**2 * (k-r) + (q+1)**2 * r\n\ndef diff(a, k):\n    return sum_sqaure(a, k+1) - sum_sqaure(a, k)\n\nn, k = map(int, input().split())\nnums = list(map(int, input().split()))\n\ncurr = sum(sum_sqaure(a, 1) for a in nums)\nQ = [(diff(a, 1), a, 1) for a in nums]\nheapq.heapify(Q)\nfor __ in range(k - n):\n    d, a, i = heapq.heappop(Q)\n    curr += d\n    heapq.heappush(Q, (diff(a, i+1), a, i+1))\nprint(curr)
import sys\n\ndef dfs(tree, root, priv_root, cur_lvl, priv_lvl, diff, pick_list):\n    if not tree:\n        return\n    stack = [(root, priv_root, cur_lvl, priv_lvl)]\n    while stack:\n        (root, priv_root, cur_lvl, priv_lvl) = stack.pop()\n        if cur_lvl ^ diff[root]:\n            cur_lvl ^= 1\n            pick_list.append(str(root))\n        stack += [(vertex, root, priv_lvl, cur_lvl)\n                for vertex in tree[root] if vertex != priv_root]\n\ndef main():\n    n = int(input())\n    tree = dict()\n    for _ in range(n - 1):\n        (u, v) = list(map(int, input().split()))\n        tree[u] = tree.get(u, set()) | set([v])\n        tree[v] = tree.get(v, set()) | set([u])\n    init = [0] + list(map(int, input().split()))\n    goal = [0] + list(map(int, input().split()))\n    diff = [i ^ j for (i, j) in zip(init, goal)]\n    pick_list = list()\n\n    dfs(tree, 1, 0, 0, 0, diff, pick_list)\n\n    num = len(pick_list)\n    print(num)\n    if num:\n        print('\n'.join(pick_list))\n\ndef __starting_point():\n    return(main())\n\n__starting_point()
def prime(n):\n    m = int(n ** 0.5) + 1\n    t = [1] * (n + 1)\n    for i in range(3, m):\n        if t[i]: t[i * i :: 2 * i] = [0] * ((n - i * i) // (2 * i) + 1)\n    return [2] + [i for i in range(3, n + 1, 2) if t[i]]\n\ndef gcd(a, b):\n    c = a % b\n    return gcd(b, c) if c else b\n\np = prime(31650)\ndef g(n):\n    m = int(n ** 0.5)\n    for j in p:\n        if n % j == 0: return True\n        if j > m: return False\n\ndef f(n):\n    a, b = n, n + 1\n    while g(a): a -= 1\n    while g(b): b += 1\n    p, q = (b - 2) * a + 2 * (n - b + 1), 2 * a * b\n    d = gcd(p, q)\n    print(str(p // d) + '/' + str(q // d))\n\nfor i in range(int(input())): f(int(input()))\n
from itertools import starmap\n\n\ndef main():\n    n, q = list(map(int, input().split()))\n\n    a = list(range(n + 1))\n    flipped = False\n    start = 0\n    end = n\n\n    for _ in range(q):\n        cmd, *args = list(map(int, input().split()))\n\n        if cmd == 1:\n            p = args[0]\n            if p > end-start-p:\n                flipped = not flipped\n                p = end-start-p\n            if flipped:\n                a[end-p:end-2*p:-1] = starmap(\n                    lambda a, b: a+n-b,\n                    list(zip(a[end-p:end-2*p:-1], a[end-p:end]))\n                )\n                end -= p\n            else:\n                start += p\n                a[start:start+p] = starmap(\n                    lambda a, b: a-b,\n                    list(zip(a[start:start+p], a[start:start-p:-1]))\n                )\n        else:\n            l, r = args\n            if flipped:\n                l, r = end-start-r, end-start-l\n            print(a[start + r] - a[start + l])\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()
n, p, q = input(), set(), set()\nfor i in map(int, input().split()):\n    q = set(i | j for j in q)\n    q.add(i)\n    p.update(q)\nprint(len(p))
buck = [[0, 0] for i in range(2201)]\nm = int(input())\nfor i in range(m):\n    a = int(input())\n    ok = True\n    br = 0\n    for j in range(2200, -1, -1):\n        if a & (1 << j):\n            if(buck[j][0]):\n                a  ^= buck[j][0]\n                br ^= buck[j][1]\n            else:\n                ok = False\n                buck[j][0] = a\n                buck[j][1] = br | (1 << i)\n                break\n    if not ok:\n        print("0")\n    else:\n        lst = []\n        for j in range(2201):\n            if br & (1 << j):\n                lst.append(j)\n        print(len(lst), end = ' ')\n        for j in lst:\n            print(j, end = ' ')\n        print('\n', end='')\n
import heapq\n\nn = int(input())\n\nbuy = []  # negative\nsell = []\nunknown = []\n\nres = 1\nfor i in range(n):\n    cmd, amount = input().strip().split()\n    amount = int(amount)\n    if cmd == 'ADD':\n        if sell and sell[0] < amount:\n            heapq.heappush(sell, amount)\n        elif buy and -buy[0] > amount:\n            heapq.heappush(buy, -amount)\n        else:\n            unknown.append(amount)\n    else:\n        if (sell and amount > sell[0]) or (buy and amount < -buy[0]):\n            print(0)\n            return\n        if sell and amount == sell[0]:\n            heapq.heappop(sell)\n        elif buy and amount == -buy[0]:\n            heapq.heappop(buy)\n        else:\n            res = res * 2 % 1000000007\n        for x in unknown:\n            if x < amount:\n                heapq.heappush(buy, -x)\n            elif x > amount:\n                heapq.heappush(sell, x)\n        unknown = []\nres = res * (len(unknown) + 1) % 1000000007\nprint(res)\n
n = int(input())\ns = list(map(int,input().split(' ')))\na = []\nfor i in range(max(s)):\n    a.append([])    \nfor i in range(len(s)):\n    a[s[i]-1].append(i)\na = list([x for x in a if x != []])\nif len(a) > 1:\n    for i in range(1,len(a)):\n        if len(a[i]) > 1:\n            s = a[i-1][-1]\n            if s > a[i][0] and s < a[i][-1]:\n                for j in range(1,len(a[i])):\n                    if s < a[i][j]:\n                        a[i] = a[i][j:] + a[i][:j]\n                        break\nt = []\nfor i in a:\n    t += i\nc = 0\nx = t[0] + 1\ni = n-1\nwhile i > 0:\n    if t[i] < t[i-1]:\n        k = t[i] - t[i-1] + n\n    else:\n        k = t[i] - t[i-1]\n    c += k\n    x -= c//n \n    i -= 1\nprint(c+x)\n\n\n\n\n
inp = input().split(' ')\nval=[];\n\ntotNums = int(inp[0]); totOpt = int(inp[1]);\ninp = input().split(' '); #assert(len(inp) == totNums);\nfor it in inp: val.append(int(it))\n\ndp = [[0.0 for _ in range(0,totNums)] for __ in range(0,totNums)]\nfor i in range(0,totNums):\n    for j in range(0,totNums):\n        if val[i]>val[j]: dp[i][j] = 1.0\n\nwhile totOpt>0:\n    totOpt -= 1\n\n    inp = input().split(' ')\n    fr = int(inp[0])-1; to = int(inp[1])-1;\n\n    for i in range(0,totNums):\n        if i!=fr and i!=to:\n            dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2;\n            dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2;\n\n    dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2;\n\nans = 0.0\nfor i in range(0,totNums):\n    for j in range(i+1,totNums):\n        ans += dp[i][j]\n\nprint('%.10f'%ans)\n
q, b, c = list(map(int, input().split()))\nn = int(input())\na = list(map(int, input().split()))\nans = 0\nfor i in a:\n	if b < i < c:\n		ans += 1\nprint(ans)\n
def solve():\n    n1, m, a, d = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    from bisect import insort\n    from math import floor\n    insort(t, a * n1)\n    pred = 0\n    k = 0\n    kpred = 0\n    n = 0\n    step = d // a + 1\n    sol = 0\n    fl = 0\n    for i in t:\n        if (i > pred):\n            if fl == 0:\n                n = (i - pred + (pred % a)) // a\n                if n != 0:\n                    k += (n // step) * step - step * (n % step == 0) + 1\n                    if k > n1:\n                        k = n1\n                        fl = 1\n                # print(k)\n                if (k * a + d >= i) and (n != 0):\n                    pred = k * a + d\n                else:\n                    pred = i + d\n                    k = floor(pred // a)\n                    sol += 1\n                # if n==0:\n                k = min(floor(pred // a), n1)\n                sol += n // step + (n % step != 0)\n            else:\n                sol += 1\n                pred = i + d\n        if i == a * n1:\n            fl = 1\n            # print(i,pred,sol,n,step,k, fl)\n    print(sol)\nsolve()
n = int(input())\n\na = list(map(int, input().split()))\n\nlp,rp = [0 for i in range(n)],[0 for i in range(n)]\nlnr, rnr = [a[i] for i in range(n)],[a[i] for i in range(n)]\nmx = a[0]\nfor i in range(1,n):\n    if a[i] > mx:\n        mx = a[i]\n        lp[i] = lp[i-1]\n    else:\n        mx += 1\n        lp[i] = lp[i-1] + mx - a[i]\n        lnr[i] = mx\n\nmx = a[-1]\nfor i in range(n-2,-1,-1):\n    if a[i] > mx:\n        mx = a[i]\n        rp[i] = rp[i+1]\n    else:\n        mx += 1\n        rp[i] = rp[i+1] + mx - a[i]\n        rnr[i] = mx\n        \nans = min(rp[0], lp[-1])\nfor i in range(1,n-1):\n    ca = lp[i-1] + rp[i+1]\n    if max(lnr[i-1], rnr[i+1]) + 1 > a[i]:\n        ca += max(lnr[i-1], rnr[i+1]) + 1 - a[i]\n    ans = min(ans, ca)\nprint(ans)
oleg = input()\nigor = input()\noleg = sorted(list(oleg))\nigor = sorted(list(igor))\nn = len(oleg)\noleg_turns = (n + 1) // 2\nigor_turns = n // 2\nmin_oleg_id = 0\nmin_igor_id = n - igor_turns\nans = ['?'] * n\nmax_oleg_id = oleg_turns - 1 \nmax_igor_id = n - 1\ncurr_turn = 'o'\nnext_turn = {'o' : 'i', 'i' : 'o'}\nl_ans = 0\nr_ans = n - 1\nwhile r_ans >= l_ans:\n    if curr_turn == 'o':\n        if oleg[min_oleg_id] < igor[max_igor_id]:\n            ans[l_ans] = oleg[min_oleg_id]\n            l_ans += 1\n            min_oleg_id += 1\n        else:\n            ans[r_ans] = oleg[max_oleg_id]\n            r_ans += -1\n            max_oleg_id += -1\n        curr_turn = 'i'\n    else:\n        if igor[max_igor_id] > oleg[min_oleg_id]:\n            ans[l_ans] = igor[max_igor_id]\n            l_ans += 1\n            max_igor_id += -1\n        else:\n            ans[r_ans] = igor[min_igor_id]\n            r_ans += -1\n            min_igor_id += 1\n        curr_turn = 'o'\nstrans = ''.join(ans)\nprint(strans)\n
import sys\nmod = 10**9 + 7\n\nfor _ in range(int(input())):\n    x = int(input())\n    s = list(map(int, input()))\n    ans = len(s)\n    for i in range(1, x+1):\n        ans = (i + (ans-i) * s[i-1]) % mod\n        r = len(s)\n        for _ in range(s[i-1]-1):\n            if len(s) < x:\n                s += s[i:r]\n            else:\n                break\n\n    print(ans)\n
n, _q = map(int, input().split())\nmni = [-1] * 200001\nmxi = [-1] * 200001\ncnt = [0] * 200001\nnd = 0\na = list(map(int, input().split()))\nfor i, v in enumerate(a):\n    if mni[v] == -1: mni[v] = i; nd += 1\n    mxi[v] = i\n    cnt[v] += 1\nr = 0\nz = 0\ncurrmax = 0\nfor i, v in enumerate(a):\n    if i == mni[v]: z += 1\n    if i == mxi[v]: z -= 1\n    currmax = max(currmax, cnt[v])\n    if z == 0: r += currmax; currmax = 0\nprint(n - r)
n, m = list(map(int, input().split()))\ng = [[] for _ in range(n)]\nfor i in range(m):\n    p, q = list(map(int, input().split()))\n    g[p - 1].append(q - 1)\n    g[q - 1].append(p - 1)\n\ncomp = [-1] * n\ndef shortest(root):\n    dist = [-1] * n\n    q = [0] * n\n    left, right = 0, 1\n    q[left] = root\n    dist[root] = 0\n    good = True\n    while left < right:\n        x = q[left]\n        left = left + 1\n        for i in g[x]:\n            if dist[i] is -1: \n                dist[i] = 1 + dist[x]\n                q[right] = i\n                right = right + 1\n            elif dist[i] == dist[x]:\n                good = False \n    far = 0\n    for i in dist: \n        if far < i:\n            far = i\n    return good, far, dist\n\narr = [0] * n\ngood = True\nfor i in range(n):\n    _, opt, dist = shortest(i)\n    if _ is False: good = False\n    if comp[i] is -1:\n        for j in range(n): \n            if dist[j] is not -1: comp[j] = i\n    if arr[comp[i]] < opt: \n        arr[comp[i]] = opt\n\nif good is False: print('-1')\nelse: print(sum(arr))\n\n
MOD = 1000000007\n\nn = int(input())\np = [int(x) for x in input().split()]\nx = [int(x) for x in input().split()]\n\nchildren = [[] for x in range(n)]\n\nfor i in range(1,n):\n    children[p[i-1]].append(i)\n\n#print(children)\n\ncount = [(0,0) for i in range(n)]\nfor i in reversed(list(range(n))):\n    prod = 1\n    for ch in children[i]:\n        prod *= count[ch][0]+count[ch][1]\n    if x[i]:\n        count[i] = (0,prod % MOD)\n    else:\n        tot = 0\n        for ch in children[i]:\n            cur = count[ch][1]*prod // (count[ch][0]+count[ch][1])\n            tot += cur\n        count[i] = (prod % MOD, tot % MOD)\n\nprint(count[0][1])\n
"""\nCodeforces Round 257 Div 1 Problem C\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0:\n        return inputs\n    if mode == 1:\n        return inputs.split()\n    if mode == 2:\n        return [int(x) for x in inputs.split()]\n\ndef write(s="\n"):\n    if isinstance(s, list): s = " ".join(map(str,s))\n    s = str(s)\n    print(s, end="")\n\n################################################### SOLUTION\n\n# croft algorithm to generate primes\n# from pyprimes library, not built-in, just google it\nfrom itertools import compress\nimport itertools\ndef croft():\n    """Yield prime integers using the Croft Spiral sieve.\n\n    This is a variant of wheel factorisation modulo 30.\n    """\n    # Implementation is based on erat3 from here:\n    #   http://stackoverflow.com/q/2211990\n    # and this website:\n    #   http://www.primesdemystified.com/\n    # Memory usage increases roughly linearly with the number of primes seen.\n    # dict ``roots`` stores an entry x:p for every prime p.\n    for p in (2, 3, 5):\n        yield p\n    roots = {9: 3, 25: 5}  # Map d**2 -> d.\n    primeroots = frozenset((1, 7, 11, 13, 17, 19, 23, 29))\n    selectors = (1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0)\n    for q in compress(\n            # Iterate over prime candidates 7, 9, 11, 13, ...\n            itertools.islice(itertools.count(7), 0, None, 2),\n            # Mask out those that can't possibly be prime.\n            itertools.cycle(selectors)\n            ):\n        # Using dict membership testing instead of pop gives a\n        # 5-10% speedup over the first three million primes.\n        if q in roots:\n            p = roots[q]\n            del roots[q]\n            x = q + 2*p\n            while x in roots or (x % 30) not in primeroots:\n                x += 2*p\n            roots[x] = p\n        else:\n            roots[q*q] = q\n            yield q\n\nn, = read()\ncr = croft()\nprimes = []\nfor i in cr:\n    if i < n:\n        primes.append(i)\n    else:\n        break\nprimes.reverse()\n\nused = [0] * (n+1)\nres = []\nfor p in primes:\n    k = n//p\n    tmp = []\n    while k:\n        if not used[k*p]:\n            tmp.append(k*p)\n            used[k*p] = 1\n        if len(tmp) == 2:\n            res.append(tmp)\n            tmp = []\n        k -= 1\n    if tmp == [p] and p > 2 and p*2 <= n and len(res) and res[-1][1] == p*2:\n        res[-1][1] = p\n        used[p*2] = 0\n        used[p] = 1\n\nprint(len(res))\nfor i in res:\n    print(" ".join(map(str, i)))
from sys import stdin\n\n\ndef main():\n    cnt = [0] * 2 ** 18\n    t = str.maketrans("0123456789", "0101010101")\n    _, *l = stdin.read().splitlines()\n    for sign, s in map(str.split, l):\n        if sign == '?':\n            print(cnt[int(s, 2)])\n        else:\n            cnt[int(s.translate(t), 2)] += 1 if sign == '+' else -1\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int,input().split()))\n    sumA = sum(a)\n    TWins = False\n    for elem in a:\n        if elem > sumA // 2:\n            TWins = True\n            break\n    if TWins or sumA % 2 != 0:\n        print("T")\n    else:\n        print("HL")
n = int(input())\nans = 0\nstk = []\nfor v in map(int, input().split()):\n    last = 0\n    while len(stk) and stk[-1][0] < v and stk[-1][1]:\n        last = max(last, stk[-1][1])\n        del stk[-1]\n\n    if not len(stk) or stk[-1][0] < v:\n        stk.append((v, 0))\n    else:\n        stk.append((v, last + 1)); ans = max(ans, last + 1)\nprint(ans)\n
def main():\n    input()\n    aa = sorted(map(int, input().split()))\n    maxa = max(aa)\n    m = [False] * (maxa + 1)\n    x = []\n    b = 0\n    for a in aa:\n        if b != a:\n            m[a] = True\n            for i in range(b, a):\n                x.append(b)\n            b = a\n    x.append(b)\n    ans = 0\n    for i in range(maxa - 1, 1, -1):\n        if i < ans:\n            break\n        if m[i]:\n            for j in range(1, maxa // i + 1):\n                ans = max(ans, x[min(i * (j + 1) - 1, maxa)] % i)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()
n = int(input())\npos_blast = [list(map(int, input().split())) for _ in range(n)]\nMAX_N = max(pos_blast, key=lambda x: x[0])[0] + 2\npower = [0 for _ in range(MAX_N)]\ntower = [False for _ in range(MAX_N)]\ncan_destroy = [0 for _ in range(MAX_N)]\nfor pos, blast in pos_blast:\n    pos += 1\n    tower[pos] = True\n    power[pos] = blast\nfor i in range(1, MAX_N):\n    if not tower[i]:\n        can_destroy[i] = can_destroy[i-1]\n    else:\n        can_destroy[i] = can_destroy[max(0, i - power[i] - 1)] + 1\nprint(n - max(can_destroy))\n
def main():\n    n = int(input())\n    scores = []\n    for i in range(n):\n        a = list(map(int, input().split()))\n        tot = sum(a)\n        scores.append((-tot, i))\n\n    scores.sort()\n    for i in range(n):\n        if scores[i][1] == 0:\n            print(i + 1)\n\nmain()\n
n = int(input())\npos,tree,ans,sz = list(map(int,input().split())) if n > 1 else [],[],[],[]\nfor i in range(n):\n  tree.append([])\n  ans.append(0.0)\n  sz.append(0)\n\nfor i in range(n-1):\n  tree[pos[i]-1].append(i+1)\n\nfor i in range(n)[::-1]:\n  sz[i] = 1\n  for to in tree[i]:\n    sz[i] += sz[to]\n\nfor i in range(n):\n  for to in tree[i]:\n    ans[to] = ans[i] + 1 + (sz[i]-1-sz[to]) * 0.5\n\nst = lambda i: str(i+1)\nprint(' '.join(list(map(st,ans))))
from collections import Counter\n\nn = int(input())\na = list(map(int, input().split()))\nc = Counter(a)\n\nres = 0\ncur = 0\nfor i in sorted(c.keys()):\n  d = min(c[i], cur)\n  cur -= d\n  res += d\n  cur += c[i]\n\nprint(res)
n, m = list(map(int, input().split()))\ns = input()\np = c = 0\nfor i in range(1, n):\n    if s[i] == s[i - 1]:\n        c += n * (m - 1)\n        p = i\n    elif s[i] != s[i - 2]:\n        p = i - 1\n    c += i - p\nans = n * n * (m - 1) - c\nprint(ans)\n
a = input()\nb = a[::-1]\nprint(a + b)
n = int(input())\ns = set()\n\n\nfor a in range(n):\n    name = input()\n\n    name = name.replace('u', 'oo')\n\n    while (name.count('kh') > 0):\n        name = name.replace('kh', 'h')\n    s.add(name)\n\nprint(len(s))\n
import sys\ninput = sys.stdin.readline\n\nn, k = list(map(int, input().split()))\n\nbegin = [-1] * n\nend = [-1] * n\nhurt = [-1] * n\n\nadj = [[] for i in range(n)]\nfor _ in range(n-1):\n    u ,v = list(map(int, input().split()))\n    adj[u-1].append(v-1)\n    adj[v-1].append(u-1)\n\nhurt[0] = 1\nbegin[0] = 0\nstack = [0]\ncurr = 1\nwhile stack:\n    nex = stack[-1]\n    if adj[nex]:\n        v = adj[nex].pop()\n        if begin[v] == -1:\n            begin[v] = curr\n            curr += 1\n            stack.append(v)\n            hurt[v] = len(stack)\n    else:\n        end[nex] = curr\n        stack.pop()\n\ndesc = [end[i] - begin[i]-hurt[i] for i in range(n)]\ndesc.sort(reverse = True)\nout = 0\nfor i in range(n - k):\n    out += desc[i]\nprint(out)\n
import sys\ninput = sys.stdin.readline \n\n\nn = int(input())\na = list(map(int, input().split()))\nb = a\n\nans = 0\nfor k in range(29):\n    a0 = []\n    a1 = []\n    a0a = a0.append\n    a1a = a1.append\n    \n    b0 = []\n    b1 = []\n    b0a = b0.append\n    b1a = b1.append\n    for i in a:\n        if i&(1<<k): a1a(i)\n        else: a0a(i)\n    for i in b:\n        if i&(1<<k): b1a(i)\n        else: b0a(i)\n    \n    a = a0+a1\n    b = b0+b1\n    mask = (1<<(k+1))-1\n    \n    aa = [i&mask for i in a]\n    bb = [i&mask for i in b]\n    \n    res = 0\n    p1 = 1<<k\n    p2 = mask+1\n    p3 = p1+p2\n\n    j1 = j2 = j3 = 0   \n    for jj, ai in enumerate(reversed(aa)):\n        while j1 < n and ai+bb[j1] < p1:\n            j1 += 1\n        while j2 < n and ai+bb[j2] < p2:\n            j2 += 1\n        while j3 < n and ai+bb[j3] < p3:\n            j3 += 1\n        res += max(n, n - jj) - max(j3, n - jj)\n        res += max(j2, n - jj) - max(j1, n - jj)\n    ans |= (res & 1) << k\n    \nprint(ans)    \n
import sys\nn = int(sys.stdin.readline())\na = [int(x) for x in sys.stdin.readline().split()]\n\neps = 1e-12\n\ndef f(x):\n    mx = a[0] - x\n    tsmx = 0.0\n    mn = a[0] - x\n    tsmn = 0.0\n    for ai in a:\n        tsmx = max(tsmx + ai - x, ai - x)\n        mx = max(tsmx, mx)\n        tsmn = min(tsmn + ai - x, ai - x)\n        mn = min(tsmn, mn)\n\n    return abs(mx), abs(mn)\n\nl = min(a)\nr = max(a)\nf1, f2 = f(l)\nfor i in range(0, 90):\n    m = (l + r) / 2\n    f1, f2 = f(m)\n    if f1 > f2:\n        l = m\n    else:\n        r = m\n\nA, B = f(l)\nprint(min(A,B))
import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\n\nBIT=[0]*(n+1)\n\ndef update(v,w):\n    while v<=n:\n        BIT[v]+=w\n        v+=(v&(-v))\n\ndef getvalue(v):\n    ANS=0\n    while v!=0:\n        ANS+=BIT[v]\n        v-=(v&(-v))\n    return ANS\n\nfor i in range(1,n+1):\n    update(i,i)\n\nANS=[-1]*n\n\nfor i in range(n-1,-1,-1):\n    MIN=0\n    MAX=n\n    k=A[i]\n\n    while True:\n        x=(MIN+MAX+1)//2\n\n\n        if getvalue(x)>k:\n            if getvalue(x-1)==k:\n                ANS[i]=x\n                break\n            else:\n                MAX=x\n        else:\n            MIN=x\n\n    update(x,-x)\n\n            \nprint(*ANS)\n
def main():\n    n = int(input())\n    a = [[int(i) for i in input().split()] for j in range(n)]\n    \n    result = [-1] * n\n    for i in range(n - 1):\n        for j in range(n):\n            d = set(a[j][k] for k in range(n) if result[k] == -1 and j != k)\n            if len(d) == 1:\n                result[j] = d.pop()\n    result[result.index(-1)] = n\n    \n    print(' '.join(str(i) for i in result))\n    \nmain()
import sys\ninput = sys.stdin.readline\nimport heapq\n\nmod=998244353\n\nn,m=list(map(int,input().split()))\n\nE=[[] for i in range(n+1)]\nE2=[[] for i in range(n+1)]\n\nfor i in range(m):\n    x,y=list(map(int,input().split()))\n    E[x].append(y)\n    E2[y].append(x)\n\nTIME=[1<<29]*(n+1)\nTIME[1]=0\n\ndef shuku(x,y):\n    return (x<<20)+y\n\nQ=[]\nANS=[]\n\nfor k in range(n+1):\n    NQ=[]\n\n    if k<=1:\n        heapq.heappush(Q,shuku(0,1))\n\n    if k%2==0:\n        while Q:\n            #print(Q)\n            x=heapq.heappop(Q)\n            time=x>>20\n            town=x-(time<<20)\n\n            #print(x,time,town)\n\n            if TIME[town]<time:\n                continue\n\n            for to in E[town]:\n                if TIME[to]>time+1:\n                    TIME[to]=time+1\n                    heapq.heappush(Q,shuku(TIME[to],to))\n                    heapq.heappush(NQ,shuku(TIME[to],to))\n\n    else:\n        while Q:\n            x=heapq.heappop(Q)\n            time=x>>20\n            town=x-(time<<20)\n\n            #print(x,time,town)\n\n            if TIME[town]<time:\n                continue\n\n            for to in E2[town]:\n                if TIME[to]>time+1:\n                    TIME[to]=time+1\n                    heapq.heappush(Q,shuku(TIME[to],to))\n                    heapq.heappush(NQ,shuku(TIME[to],to))\n\n    #print(k,TIME)\n\n    Q=NQ\n    ANS.append(TIME[n])\n\n    if k>=100 and TIME[n]!=1<<29:\n        break\n\nA=ANS[0]\nfor k in range(1,len(ANS)):\n    if ANS[k]==1<<29:\n        continue\n\n    if ANS[k-1]==1<<29:\n        A=(ANS[k]+pow(2,k,mod)-1)%mod\n\n    if k<60 and ANS[k-1]-ANS[k]>pow(2,k-1):\n        A=(ANS[k]+pow(2,k,mod)-1)%mod\n\nprint(A)\n    \n\n\n    \n    \n        \n                    \n                \n\n        \n
def main():\n    import sys\n    from array import array\n    from collections import deque\n    input = sys.stdin.readline\n\n    H, W, Q = list(map(int, input().split()))\n    grid = array('b', [0] * (H*W))\n    #flg_0 = 0\n    #flg_1 = 0\n    for h in range(H):\n        line = input().rstrip('\n')\n        """\n        if "0" in line:\n            flg_0 = 1\n        if "1" in line:\n            flg_1 = 1\n        """\n        for w in range(W):\n            if line[w] == "1":\n                grid[h*W + w] ^= 1\n\n    """\n    if flg_0 == 0:\n        for _ in range(Q):\n            print(1)\n        return\n    if flg_1 == 0:\n        for _ in range(Q):\n            print(0)\n        return\n    """\n\n    que = deque()\n    start_change = [-1] * (H*W)\n    d = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    for h in range(H):\n        for w in range(W):\n            same = 0\n            hw = h*W+w\n            for dh, dw in d:\n                h_new, w_new = h+dh, w+dw\n                hw_new = h_new * W + w_new\n                if 0 <= h_new < H and 0 <= w_new < W:\n                    if grid[hw] == grid[hw_new]:\n                        same = 1\n                        break\n            if same:\n                que.append(hw)\n                start_change[hw] = 0\n\n    while que:\n        hw = que.popleft()\n        h, w = divmod(hw, W)\n        for dh, dw in d:\n            h_new, w_new = h + dh, w + dw\n            hw_new = h_new * W + w_new\n            if 0 <= h_new < H and 0 <= w_new < W:\n                if start_change[hw_new] == -1:\n                    start_change[hw_new] = start_change[hw] + 1\n                    que.append(hw_new)\n\n    for _ in range(Q):\n        h, w, p = list(map(int, input().split()))\n        h -= 1\n        w -= 1\n        hw = h*W + w\n        if start_change[hw] == -1:\n            print(grid[hw])\n            continue\n        if p <= start_change[hw]:\n            print(grid[hw])\n        else:\n            if (p - start_change[hw]) % 2 == 0:\n                print(grid[hw])\n            else:\n                print(grid[hw] ^ 1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n = int(input())\na = list(map(int, input().split()))\np = [0] * (n + 1)\nans = [1] * (n + 1)\nind = n\nfor i in range(n):\n    p[a[i] - 1] = 1\n    while ind > 0 and p[ind - 1] == 1:\n        ind -= 1\n    ans[i + 1] = 1 + (i + 1) - (n - ind)\nprint(' '.join(map(str, ans)))
n=int(input())\nta,tb,da,db=[0]*4\nfor i in range (n):\n    t,x,y=list(map(int,input().split()))\n    if t==1:\n        ta+=(x+y)\n        da+=y\n    if (t==2):\n        tb+=(x+y)\n        db+=y       \nif (ta-da>=0.5*ta):\n    print ('LIVE')\nelse :\n    print ('DEAD')\nif (tb-db>=0.5*tb):\n    print ('LIVE')\nelse :\n    print ('DEAD')    \n    \n
#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == "\n":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    n = I()\n    a = LI()\n    a.sort()\n    f = [1]*n\n    p = 0\n    ans = 0\n    while p < n:\n        while p < n and not f[p]:\n            p += 1\n        if p == n:\n            break\n        ans += 1\n        for i in range(n):\n            if a[i]%a[p] == 0:\n                f[i] = 0\n    print(ans)\n    return\n\n#B\ndef B():\n    n = I()\n    s = list(map(int, input()))\n    g = LIR(n)\n    ans = sum(s)\n    for t in range(30000):\n        for i in range(n):\n            ai,bi = g[i]\n            if t < bi:\n                continue\n            if (t-bi)%ai == 0:\n                s[i] ^= 1\n        su = sum(s)\n        if ans < su:\n            ans = su\n    print(ans)\n    return\n\n#C\ndef C():\n    t = I()\n    for _ in range(t):\n        n = I()\n        s = list(map(int, input()))\n        mi = [s[-1]]\n        for i in s[:-1][::-1]:\n            mi.append(min(mi[-1],i))\n        mi = mi[::-1]\n        ans = [None]*n\n        for i in range(n):\n            if mi[i] == s[i]:\n                ans[i] = 1\n            else:\n                ans[i] = 2\n        q = [s[i] for i in range(n) if ans[i] > 1]\n        p = [q[i] for i in range(len(q))]\n        p.sort()\n        if p == q:\n            print(*ans,sep = "")\n        else:\n            print("-")\n    return\n\n#D\ndef D():\n    def root(x):\n        if x == par[x]:\n            return x\n        par[x] = root(par[x])\n        return par[x]\n\n    def unite(x,y):\n        x = root(x)\n        y = root(y)\n        if rank[x] < rank[y]:\n            par[x] = y\n        else:\n            par[y] = x\n            if rank[x] == rank[y]:\n                rank[x] += 1\n\n    n,k = LI()\n    par = [i for i in range(n)]\n    rank = [0]*n\n    for i in range(k):\n        x,y = LI()\n        x -= 1\n        y -= 1\n        if root(x) != root(y):\n            unite(x,y)\n    size = [0]*n\n    for i in range(n):\n        size[root(i)] += 1\n    ans = 0\n    for i in size:\n        if i > 0:\n            ans += i-1\n    print(k-ans)\n    return\n\n#E\ndef E():\n\n    return\n\n#F\ndef F():\n\n    return\n\n#G\ndef G():\n\n    return\n\n#H\ndef H():\n\n    return\n\n#Solve\ndef __starting_point():\n    D()\n\n__starting_point()
n = int(input())\ng = [[] for i in range(n)]\nfor i in range(n-1):\n    u,v = [int(i)-1 for i in input().split()]\n    g[u].append(v)\n    g[v].append(u)\n\nleaf = [len(i)==1 for i in g]\nroot = -1\nmx = n-1\nfor i in range(n):\n    if leaf[i]:\n        root = i\n    leafs = 0\n    for j in g[i]:\n        if leaf[j]:\n            leafs += 1\n    if leafs > 1:\n        mx -= leafs-1\n\nstack = [(root, -1, 0)]\neven = True\nwhile len(stack)>0:\n    i, j, d = stack.pop()\n    if leaf[i] and d%2 == 1:\n        even = False\n        break\n    for k in g[i]:\n        if k != j:\n            stack.append((k,i,d+1))\nmn = 1 if even else 3\n\nprint(mn,mx)\n
import sys\n\ninput=sys.stdin.readline\n\nn=int(input())\nb=list(map(int,input().split()))\nope=[[] for i in range(n)]\nQ=int(input())\nfor i in range(Q):\n    l,r=list(map(int,input().split()))\n    ope[r-1].append(l-1)\n\nres=b.count(0)\n\nData=[(-1)**((b[i]==1)+1) for i in range(n)]\nfor i in range(1,n):\n    Data[i]+=Data[i-1]\nData=[0]+Data\n\nfor i in range(n):\n    ope[i].sort(reverse=True)\n\n# N: \nN=n+1\nN0 = 2**(N-1).bit_length()\ndata = [None]*(2*N0)\nINF = (-2**31, -2**31)\n# [l, r+1)v\n# v(t, value) (t)\ndef update(l, r, v):\n    L = l + N0; R = r + N0\n    while L < R:\n        if R & 1:\n            R -= 1\n            if data[R-1]:\n                data[R-1] = max(v,data[R-1])\n            else:\n                data[R-1]=v\n\n        if L & 1:\n            if data[L-1]:\n                data[L-1] = max(v,data[L-1])\n            else:\n                data[L-1]=v\n            L += 1\n        L >>= 1; R >>= 1\n# a_i\ndef _query(k):\n    k += N0-1\n    s = INF\n    while k >= 0:\n        if data[k]:\n            s = max(s, data[k])\n        k = (k - 1) // 2\n    return s\n# \ndef query(k):\n    return _query(k)[1]\n\nfor i in range(n+1):\n    update(i,i+1,(-Data[i],-Data[i]))\nif ope[0]:\n    update(1,2,(0,0))\n\nfor i in range(1,n):\n    val=query(i)\n    update(i+1,i+2,(val+Data[i]-Data[i+1],val+Data[i]-Data[i+1]))\n    for l in ope[i]:\n        val=query(l)\n        update(l+1,i+2,(val,val))\n\n\n\nprint((n-(res+query(n)+Data[n])))\n
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\nmii=lambda:list(map(int,input().split()))\n\nfor _ in range(int(input())):\n    n,x=mii()\n    has=0\n    a=0\n    for i in mii():\n        if x==i: has=1\n        a=max(a,i)\n    if has:\n        print(1)\n    else:\n        print(max(2,(x-1)//a+1))\n
import sys\n[n, q] = map(int, sys.stdin.readline().strip().split())\nqis = [int(sys.stdin.readline().strip()) for _ in range(q)]\n\ndef query(n, q):\n	d = 2 * n - q\n	while d % 2 == 0:\n		d //= 2\n	return (n - d // 2)\n\nfor qi in qis:\n	print (query(n, qi))
T = int(input())\nfor t in range(T):\n    a, b, n = [int(i) for i in input().split()]\n    if n%3 == 2:\n        print(a^b)\n    elif n%3 == 1:\n        print(b)\n    else:\n        print(a)\n
\n\nclass Graph:\n    def __init__(self, n_vertices, edges, directed=True, weighted=False):\n        self.n_vertices = n_vertices\n        self.edges = edges\n        self.directed = directed\n        self.weighted = weighted\n\n    @property\n    def adj(self):\n        try:\n            return self._adj\n        except AttributeError:\n            adj = [[] for _ in range(self.n_vertices)]\n            def d_w(e):\n                adj[e[0]].append((e[1],e[2]))\n            def ud_w(e):\n                adj[e[0]].append((e[1],e[2]))\n                adj[e[1]].append((e[0],e[2]))\n            def d_uw(e):\n                adj[e[0]].append(e[1])\n            def ud_uw(e):\n                adj[e[0]].append(e[1])\n                adj[e[1]].append(e[0])\n            helper = (ud_uw, d_uw, ud_w, d_w)[self.directed+self.weighted*2]\n            for e in self.edges:\n                helper(e)\n            self._adj = adj\n            return adj\n\nclass RootedTree(Graph):\n    def __init__(self, n_vertices, edges, root_vertex):\n        self.root = root_vertex\n        super().__init__(n_vertices, edges, False, False)\n\n    @property\n    def parent(self):\n        try:\n            return self._parent\n        except AttributeError:\n            adj = self.adj\n            parent = [None]*self.n_vertices\n            parent[self.root] = -1\n            stack = [self.root]\n            for i in range(self.n_vertices):\n                v = stack.pop()\n                for u in adj[v]:\n                    if parent[u] is None:\n                        parent[u] = v\n                        stack.append(u)\n            self._parent = parent\n            return parent\n\n    @property\n    def children(self):\n        try:\n            return self._children\n        except AttributeError:\n            children = [None]*self.n_vertices\n            for v,(l,p) in enumerate(zip(self.adj,self.parent)):\n                children[v] = [u for u in l if u != p]\n            self._children = children\n            return children\n\n    @property\n    def dfs_order(self):\n        try:\n            return self._dfs_order\n        except AttributeError:\n            order = [None]*self.n_vertices\n            children = self.children\n            stack = [self.root]\n            for i in range(self.n_vertices):\n                v = stack.pop()\n                order[i] = v\n                for u in children[v]:\n                    stack.append(u)\n            self._dfs_order = order\n            return order\n\nfrom functools import reduce\nfrom itertools import accumulate,chain\ndef rerooting(rooted_tree, merge, identity, finalize):\n    N = rooted_tree.n_vertices\n    parent = rooted_tree.parent\n    children = rooted_tree.children\n    order = rooted_tree.dfs_order\n\n    # from leaf to parent\n    dp_down = [None]*N\n    for v in reversed(order[1:]):\n        dp_down[v] = finalize(reduce(merge,\n            (dp_down[c] for c in children[v]),\n            identity))\n\n    # from parent to leaf\n    dp_up = [None]*N\n    dp_up[0] = identity\n    for v in order:\n        if len(children[v]) == 0:\n            continue\n        temp = (dp_up[v],)+tuple(dp_down[u] for u in children[v])+(identity,)\n        left = tuple(accumulate(temp,merge))\n        right = tuple(accumulate(reversed(temp[2:]),merge))\n        for u,l,r in zip(children[v],left,reversed(right)):\n            dp_up[u] = finalize(merge(l,r))\n\n    res = [None]*N\n    for v,l in enumerate(children):\n        res[v] = reduce(merge,\n                    (dp_down[u] for u in children[v]),\n                    identity)\n        res[v] = finalize(merge(res[v], dp_up[v]))\n\n    return res\n\ndef solve(T):\n    MOD = 10**9 + 7\n    def merge(x,y):\n        return (x*y)%MOD\n    def finalize(x):\n        return x+1\n\n    return [v-1 for v in rerooting(T,merge,1,finalize)]\n\n\ndef __starting_point():\n    N = int(input())\n    edges = [(i+1,p-1) for i,p in enumerate(map(int,input().split()))]\n    T = RootedTree(N, edges, 0)\n    print(*solve(T))\n\n__starting_point()
\n\n#===============================================================================================\n#importing some useful libraries.\n\n\n\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\nfrom functools import cmp_to_key\n\n# from itertools import *\nfrom heapq import *\nfrom math import gcd, factorial,floor,ceil,sqrt\n\nfrom copy import deepcopy\nfrom collections import deque\n\n\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom bisect import bisect\n\n#==============================================================================================\n#fast I/O region\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = "x" in file.mode or "r" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b"\n") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode("ascii"))\n        self.read = lambda: self.buffer.read().decode("ascii")\n        self.readline = lambda: self.buffer.readline().decode("ascii")\n\n\ndef print(*args, **kwargs):\n    """Prints the values to a stream, or to sys.stdout by default."""\n    sep, file = kwargs.pop("sep", " "), kwargs.pop("file", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop("end", "\n"))\n    if kwargs.pop("flush", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n# inp = lambda: sys.stdin.readline().rstrip("\r\n")\n\n#===============================================================================================\n### START ITERATE RECURSION ###\nfrom types import GeneratorType\ndef iterative(f, stack=[]):\n  def wrapped_func(*args, **kwargs):\n    if stack: return f(*args, **kwargs)\n    to = f(*args, **kwargs)\n    while True:\n      if type(to) is GeneratorType:\n        stack.append(to)\n        to = next(to)\n        continue\n      stack.pop()\n      if not stack: break\n      to = stack[-1].send(to)\n    return to\n  return wrapped_func\n#### END ITERATE RECURSION ####\n\n#===============================================================================================\n#some shortcuts\n\ndef inp(): return sys.stdin.readline().rstrip("\r\n") #for fast input\ndef out(var): sys.stdout.write(str(var))  #for fast output, always take string\ndef lis(): return list(map(int, inp().split()))\ndef stringlis(): return list(map(str, inp().split()))\ndef sep(): return list(map(int, inp().split()))\ndef strsep(): return list(map(str, inp().split()))\n# def graph(vertex): return [[] for i in range(0,vertex+1)]\ndef zerolist(n): return [0]*n\ndef nextline(): out("\n")  #as stdout.write always print sring.\ndef testcase(t):\n    for pp in range(t):\n        solve(pp)\ndef printlist(a) :\n    for p in range(0,len(a)):\n        out(str(a[p]) + ' ')\ndef google(p):\n    print('Case #'+str(p)+': ',end='')\ndef lcm(a,b): return (a*b)//gcd(a,b)\ndef power(x, y, p) :\n    y%=(p-1)  #not so sure about this. used when y>p-1. if p is prime.\n    res = 1     # Initialize result\n    x = x % p  # Update x if it is more , than or equal to p\n    if (x == 0) :\n        return 0\n    while (y > 0) :\n        if ((y & 1) == 1) : # If y is odd, multiply, x with result\n            res = (res * x) % p\n\n        y = y >> 1      # y = y/2\n        x = (x * x) % p\n    return res\ndef ncr(n,r): return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))\ndef isPrime(n) :\n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) :\n        if (n % i == 0 or n % (i + 2) == 0) :\n            return False\n        i = i + 6\n    return True\ninf = pow(10,20)\nmod = 10**9+7\n#===============================================================================================\n# code here ;))\ndef djkistra(g,st,dist,lol,vis): #g contains b,dist(a to b) and dist is initiaalised by 10**9 initiallly\n    pq = []\n    dist[st] = 0\n    heappush(pq,(0,st))\n    while(len(pq) != 0):\n        curr = heappop(pq)[1]\n        for i in range(0,len(g[curr])):\n            b = g[curr][i][0]\n            w = g[curr][i][1]\n            if(dist[b] > dist[curr] + w):\n                dist[b] = dist[curr]+w\n                heappush(pq,(dist[b],b))\n\n\ndef modif_djkistra(g,dist,usedtrains):\n    h = []\n    for i in range(len(g)):\n        if(dist[i] != inf):\n            heappush(h,(dist[i],i))\n    while(len(h) != 0):\n        d,curr = heappop(h)\n        if(d != dist[curr]): #dublicate train with larger length\n            continue\n        for to,newd in g[curr]:\n            if(newd+d<=dist[to]):\n                usedtrains[to] = False\n                if(dist[to] > newd+d):\n                    heappush(h,(newd+d,to))\n                dist[to] = newd+d\n\ndef solve(case):\n    n,m,k = sep()\n    dist = [inf]*n;dist[0] = 0\n    g = [[] for i in range(n)]\n    for i in range(m):\n        a,b,c = sep()\n        a-=1\n        b-=1\n        g[a].append((b,c))\n        g[b].append((a,c))\n    have = []\n    usedtrain = [False]*n\n    for i in range(k):\n        a,b = sep()\n        a-=1\n        dist[a] = min(dist[a],b)\n        # g[0].append((a,b))\n        # g[a].append((0,b))\n        have.append(a)\n        usedtrain[a] = True\n    modif_djkistra(g,dist,usedtrain)\n    cnt = 0\n    have = list(set(have))\n    for i in range(n):\n        if(usedtrain[i]):\n            cnt+=1\n    # print(cnt)\n    print(k - cnt)\n\n\n\n\n\n\ntestcase(1)\n# testcase(int(inp()))\n\n\n\n\n\n\n\n\n\n
import sys\ns=sys.stdin.readline().split()[0]\n\nm=int(sys.stdin.readline())\n\nNumx=[]\nNumy=[]\nNumz=[]\nx=0\ny=0\nz=0\nfor i in range(len(s)):\n    if(s[i]=='x'):\n        x+=1\n    if(s[i]=='y'):\n        y+=1\n    if(s[i]=='z'):\n        z+=1\n    Numx.append(x)\n    Numy.append(y)\n    Numz.append(z)\n    \n\nAns=""\nfor M in range(m):\n    s,e=list(map(int,sys.stdin.readline().split()))\n    if(e-s+1<=2):\n        Ans+="YES\n"\n        continue\n    s-=1\n    e-=1\n    x=Numx[e]\n    y=Numy[e]\n    z=Numz[e]\n    if(s!=0):\n        x-=Numx[s-1]\n        y-=Numy[s-1]\n        z-=Numz[s-1]\n    if(x==y==z):\n        Ans+="YES\n"\n        continue\n    L=[x,y,z]\n    L.sort()\n    if(L[0]==L[1] and L[2]==L[1]+1):\n        Ans+="YES\n"\n        continue\n    if(L[1]==L[2] and L[0]==L[1]-1):\n        Ans+="YES\n"\n    else:\n        Ans+="NO\n"\nsys.stdout.write(Ans)\n    \n        \n\n        \n
import sys\n\nn, m = list(map(int, sys.stdin.readline().split()))\nd = list(map(int, sys.stdin.readline().split()))\ngph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    u, v = list(map(int, sys.stdin.readline().split()))\n    u -= 1\n    v -= 1\n    gph[u].append((v, _))\n    gph[v].append((u, _))\n    \nt = -1\nif d.count(1) % 2 == 1:\n    if -1 not in d:\n        print(-1)\n        return\n    t = d.index(-1)\n\nans = [False] * m\nvis = [False] * n\ned = [(-1, -1)] * n\nrets = [(d[u] == 1) or (u == t) for u in range(n)]\n\nstk = [[0, iter(gph[0])]]\nwhile len(stk) > 0:\n    u = stk[-1][0]\n    vis[u] = True\n    try:\n        while True:\n            v, i = next(stk[-1][1])\n            if not vis[v]:\n                ed[v] = (u, i)\n                stk.append([v, iter(gph[v])])\n                break\n    except StopIteration:\n        p, e = ed[u]\n        if p >= 0 and rets[u]:\n            rets[p] = not rets[p]\n            ans[e] = True\n        stk.pop()\n        pass\n    \nprint(ans.count(True))\nprint("\n".join([str(i+1) for i in range(m) if ans[i]]))\n#1231\n
n=int(input())\na=list(map(int,input().split()))\nq=int(input())\nchanges=[0]*q\nfor i in range(q):\n    changes[-i-1]=tuple(map(int,input().split()))\nfinal=[-1]*n\ncurr=0\nfor guy in changes:\n    if guy[0]==1:\n        if final[guy[1]-1]==-1:\n            final[guy[1]-1]=max(guy[2],curr)\n    else:\n        curr=max(curr,guy[1])\nfor i in range(n):\n    if final[i]==-1:\n        final[i]=max(curr,a[i])\nfinal=[str(guy) for guy in final]\nprint(" ".join(final))
n, q = map(int, input().split())\ns = '!' + input()\n\nnxt = [[n + 1] * (n + 2) for _ in range(26)]\nfor i in range(n - 1, -1, -1):\n    c = ord(s[i + 1]) - 97\n    for j in range(26):\n        nxt[j][i] = nxt[j][i + 1]\n    nxt[c][i] = i + 1\n\nw = [[-1], [-1], [-1]]\nidx = lambda i, j, k: i * 65536 + j * 256 + k\ndp = [0] * (256 * 256 * 256)\ndef calc(fix=None):\n    r = list(map(range, (len(w[0]), len(w[1]), len(w[2]))))\n    if fix is not None: r[fix] = range(len(w[fix]) - 1, len(w[fix]))\n    for i in r[0]:\n        for j in r[1]:\n            for k in r[2]:\n                dp[idx(i, j, k)] = min(nxt[w[0][i]][dp[idx(i - 1, j, k)]] if i else n + 1,\n                                       nxt[w[1][j]][dp[idx(i, j - 1, k)]] if j else n + 1,\n                                       nxt[w[2][k]][dp[idx(i, j, k - 1)]] if k else n + 1)\n                if i == j == k == 0: dp[idx(i, j, k)] = 0\n\nout = []\nfor _ in range(q):\n    t, *r = input().split()\n    if t == '+':\n        i, c = int(r[0]) - 1, ord(r[1]) - 97\n        w[i].append(c)\n        calc(i)\n    else:\n        i = int(r[0]) - 1\n        w[i].pop()\n    req = dp[idx(len(w[0]) - 1, len(w[1]) - 1, len(w[2]) - 1)]\n    out.append('YES' if req <= n else 'NO')\n\nprint(*out, sep='\n')
import sys\nfrom itertools import accumulate \nclass Lazysegtree:\n    #RAQ\n    def __init__(self, A, intv, initialize = True, segf = min):\n        # 1-indexed \n        self.N = len(A)\n        self.N0 = 2**(self.N-1).bit_length()\n        self.intv = intv\n        self.segf = segf\n        self.lazy = [0]*(2*self.N0)\n        if initialize:\n            self.data = [intv]*self.N0 + A + [intv]*(self.N0 - self.N)\n            for i in range(self.N0-1, 0, -1):\n                self.data[i] = self.segf(self.data[2*i], self.data[2*i+1]) \n        else:\n            self.data = [intv]*(2*self.N0)\n\n    def _ascend(self, k):\n        k = k >> 1\n        c = k.bit_length()\n        for j in range(c):\n            idx = k >> j\n            self.data[idx] = self.segf(self.data[2*idx], self.data[2*idx+1]) \\n            + self.lazy[idx]\n            \n    def _descend(self, k):\n        k = k >> 1\n        idx = 1\n        c = k.bit_length()\n        for j in range(1, c+1):\n            idx = k >> (c - j)\n            ax = self.lazy[idx]\n            if not ax:\n                continue\n            self.lazy[idx] = 0\n            self.data[2*idx] += ax\n            self.data[2*idx+1] += ax\n            self.lazy[2*idx] += ax\n            self.lazy[2*idx+1] += ax\n    \n    def query(self, l, r):\n        L = l+self.N0\n        R = r+self.N0\n        Li = L//(L & -L)\n        Ri = R//(R & -R)\n        self._descend(Li)\n        self._descend(Ri - 1)\n        \n        s = self.intv                                                              \n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.segf(s, self.data[R])\n            if L & 1:\n                s = self.segf(s, self.data[L])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n    \n    def add(self, l, r, x):\n        L = l+self.N0\n        R = r+self.N0\n\n        Li = L//(L & -L)\n        Ri = R//(R & -R)\n        \n        while L < R :\n            if R & 1:\n                R -= 1\n                self.data[R] += x\n                self.lazy[R] += x\n            if L & 1:\n                self.data[L] += x\n                self.lazy[L] += x\n                L += 1\n            L >>= 1\n            R >>= 1\n        \n        self._ascend(Li)\n        self._ascend(Ri-1)\n    \n    def binsearch(self, l, r, check, reverse = False):\n        L = l+self.N0\n        R = r+self.N0\n        Li = L//(L & -L)\n        Ri = R//(R & -R)\n        self._descend(Li)\n        self._descend(Ri-1)\n        SL, SR = [], []\n        while L < R:\n            if R & 1:\n                R -= 1\n                SR.append(R)\n            if L & 1:\n                SL.append(L)\n                L += 1\n            L >>= 1\n            R >>= 1\n        \n        if reverse:\n            for idx in (SR + SL[::-1]):\n                if check(self.data[idx]):\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                ax = self.lazy[idx]\n                self.lazy[idx] = 0\n                self.data[2*idx] += ax\n                self.data[2*idx+1] += ax\n                self.lazy[2*idx] += ax\n                self.lazy[2*idx+1] += ax\n                idx = idx << 1\n                if check(self.data[idx+1]):\n                    idx += 1\n            return idx - self.N0\n        else:\n            for idx in (SL + SR[::-1]):\n                if check(self.data[idx]):\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                ax = self.lazy[idx]\n                self.lazy[idx] = 0\n                self.data[2*idx] += ax\n                self.data[2*idx+1] += ax\n                self.lazy[2*idx] += ax\n                self.lazy[2*idx+1] += ax\n                idx = idx << 1\n                if not check(self.data[idx]):\n                    idx += 1\n            return idx - self.N0\n    def provfunc(self):\n        idx =  1\n        if self.data[1] >= 0:\n            return -1\n        while idx < self.N0:\n            ax = self.lazy[idx]\n            self.lazy[idx] = 0\n            self.data[2*idx] += ax\n            self.data[2*idx+1] += ax\n            self.lazy[2*idx] += ax\n            self.lazy[2*idx+1] += ax\n            idx = idx << 1\n            if self.data[idx+1] < 0:\n                idx += 1\n        return idx - self.N0\n\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\ntable = [0]*(10**6+1)\nfor a in A:\n    table[a] -= 1\nfor b in B:\n    table[b] += 1\ntable = list(accumulate(table[::-1]))[::-1]\nT = Lazysegtree(table, 0, True, min)\nQ = int(input())\nAns = [None]*Q\nfor q in range(Q):\n    t, i, x = list(map(int, sys.stdin.readline().split()))\n    i -= 1\n    if t == 1:\n        T.add(0, x+1, -1)\n        T.add(0, A[i]+1, 1)\n        A[i] = x\n    else:\n        T.add(0, x+1, 1)\n        T.add(0, B[i]+1, -1)\n        B[i] = x\n    Ans[q] = T.provfunc()\n\nprint('\n'.join(map(str, Ans)))        \n
n=int(input())\na=[]\nfor i in range(n):\n    a.append(list(map(int,input().split())))\nm=int(input())\nb=list(map(lambda x:int(x)-1,input().split()))\nc=[]\nnow=0\nk=0\nans=[]\nfor i in range(n):\n    t=a[i]\n    last=now\n    if t[0]==1:\n        now+=1\n        if len(c)<100000: c.append(t[1])\n        if k<m and b[k]==now-1: \n            ans.append(t[1])\n            k+=1\n    else:\n        now+=t[1]*t[2]\n        while t[2]:\n            if len(c)<100000: c.extend(c[:t[1]])\n            else: break\n            t[2]-=1\n        while k<m and last<=b[k]<now:\n            ans.append(c[(b[k]-last)%t[1]])\n            k+=1    \nfor i in range(m):\n    print(ans[i],end=' ')\n
def dfs(x, y):\n    vis.append((x, y))\n    y += 1\n    nonlocal flag\n    if flag or str.isalpha(grid[x][y]):\n        return\n    if y >= n - 1:\n        flag = True\n        return\n    \n    # stay idle\n    if not str.isalpha(grid[x][y + 1]) and not str.isalpha(grid[x][y + 2]) and (x, y + 2) not in vis:\n        dfs(x, y + 2)\n\n    # move down\n    if x > 0 and  not str.isalpha(grid[x - 1][y]) and not str.isalpha(grid[x - 1][y + 1]) and not str.isalpha(grid[x - 1][y + 2]) and (x - 1, y + 2) not in vis:\n        dfs(x - 1, y + 2)\n\n    #move up\n    if x < 2 and not str.isalpha(grid[x + 1][y]) and not str.isalpha(grid[x + 1][y + 1]) and not str.isalpha(grid[x + 1][y + 2]) and (x + 1, y + 2) not in vis:\n        dfs(x + 1, y + 2)\n    \n\nT = int(input())\nfor loop in range(T):\n    n, k = [ int(i) for i in input().split() ]\n    grid = list()\n    grid.append(input() + "    ")\n    grid.append(input() + "    ")\n    grid.append(input() + "    ")\n    vis = list()\n    flag = False\n    for i in  range(3):\n        if grid[i][0] == 's':\n            grid[i] = " " + grid[i][1:]\n            dfs(i, 0)\n            break\n    if flag:\n        print("YES")\n    else:\n        print("NO")
# import atexit\n# import io\n# import sys\n#\n# _INPUT_LINES = sys.stdin.read().splitlines()\n# input = iter(_INPUT_LINES).__next__\n# _OUTPUT_BUFFER = io.StringIO()\n# sys.stdout = _OUTPUT_BUFFER\n#\n#\n# @atexit.register\n# def write():\n#     sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\nimport bisect\nfrom datetime import datetime\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    n -= 1\n\n    timestamps = []\n    raw = []\n    while True:\n        s = ""\n        try:\n            s = input()\n        except:\n            print(-1)\n            return\n\n        d = datetime.strptime(s[0:19], "%Y-%m-%d %H:%M:%S")\n        timestamps.append(int(d.timestamp()))\n        raw.append(s[0:19])\n        idx = bisect.bisect_left(timestamps, timestamps[-1] - n)\n        if len(timestamps) - idx == m:\n            print(raw[-1])\n            return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n = int(input())\na = [int(x) for x in input().strip()]\nb = [int(x) for x in input().strip()]\np, q, r, s = 0, 0, 0, 0\nfor i in range(n):\n    if a[i] * 2 + b[i] == 0:\n        p += 1\n    if a[i] * 2 + b[i] == 1:\n        q += 1\n    if a[i] * 2 + b[i] == 2:\n        r += 1\n    if a[i] * 2 + b[i] == 3:\n        s += 1\nprint(p*r + p*s + q*r)\n
import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**9)\nfrom collections import deque\n\nclass Node:\n    def __init__(self,depth):\n        self.depth=depth\n        self.left=None\n        self.right=None\n\ndef insert(node,s):\n    n=node\n    for i in range(len(s)):\n        t=s[i]\n        if t=='0':\n            if n.left is None:\n                n.left=Node(i+1)\n            n=n.left\n        else:\n            if n.right is None:\n                n.right=Node(i+1)\n            n=n.right\n\nclass Trie:\n    def __init__(self):\n        self.root=Node(0)\n    def insert(self,s:str):\n        insert(self.root,s)\n\nn,l=map(int,input().split())\nS=[input().strip() for _ in range(n)]\ntrie=Trie()\nfor s in S:\n    trie.insert(s)\nData=[]\nq=deque([trie.root])\n\ndef dfs(node):\n    if node.right is None and node.left is None:\n        return\n    if node.right is None or node.left is None:\n        Data.append(l-node.depth)\n    if node.right:\n        q.append(node.right)\n    if node.left:\n        q.append(node.left)\n\nwhile q:\n    dfs(q.popleft())\nxor=0\n\ndef Grundy(n):\n    ret=1\n    while n%2==0:\n        n//=2\n        ret*=2\n    return ret\n\nfor i in Data:\n    xor^=Grundy(i)\nprint('Alice' if xor else 'Bob')
class SegmentTree:\n    def __init__(self, data, default=0, func=max):\n        """initialize the segment tree with data"""\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(list(range(_size))):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        """func of data[start, stop)"""\n        start += self._size\n        stop += self._size\n\n        res_left = res_right = self._default\n        while start < stop:\n            if start & 1:\n                res_left = self._func(res_left, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res_right = self._func(self.data[stop], res_right)\n            start >>= 1\n            stop >>= 1\n\n        return self._func(res_left, res_right)\n\n    def __repr__(self):\n        return "SegmentTree({0})".format(self.data)\n\n\nn = int(input())\ns = input()\n\npref = []\ncurr = 0\nfor c in s:\n    if c == '1':\n        curr += 1\n    else:\n        curr = 0\n    pref.append(curr)\n\nsuff = []\ncurr = 0\nfor c in s[::-1]:\n    if c == '1':\n        curr += 1\n    else:\n        curr = 0\n    suff.append(curr)\nsuff.reverse()\n    \n\nst = SegmentTree(suff)\n\nout = 0\nadd = 0\nfor i in range(n):\n    if s[i] == '1':\n        lo = -1\n        hi =  i - pref[i] + 1\n        while hi - lo > 1:\n            t = (lo + hi) // 2\n            if st.query(t, i - pref[i] + 1) >= pref[i]:\n                lo = t\n            else:\n                hi = t\n        add += (i - lo)\n    #print(add)\n    out += add\nprint(out)\n    \n
n, k = map(int, input().split())\na = [0] * n\nb = ['0'] * n\nc = []\ns = input()\nfor i in range(n):\n    if k != 0:\n        if s[i] == '(':\n            c.append(i)\n        else:\n            d = c.pop()\n            a[i] = 1\n            a[d] = 1\n            k -= 2\nfor i in range(n):\n    if a[i] == 1:\n        print(s[i], end = '')\n
from collections import deque\n\ndef solve(adj, m, k, uv):\n    n = len(adj)\n    nn = [len(a) for a in adj]\n    q = deque()\n    for i in range(n):\n        if nn[i] < k:\n            q.append(i)\n    while q:\n        v = q.popleft()\n        for u in adj[v]:\n            nn[u] -= 1\n            if nn[u] == k-1:\n                q.append(u)\n    res = [0]*m\n    nk = len([1 for i in nn if i >= k])\n    res[-1] = nk\n    for i in range(m-1, 0, -1):\n        u1, v1 = uv[i]\n\n        if nn[u1] < k or nn[v1] < k:\n            res[i - 1] = nk\n            continue\n        if nn[u1] == k:\n            q.append(u1)\n            nn[u1] -= 1\n        if not q and nn[v1] == k:\n            q.append(v1)\n            nn[v1] -= 1\n\n        if not q:\n            nn[u1] -= 1\n            nn[v1] -= 1\n            adj[u1].remove(v1)\n            adj[v1].remove(u1)\n\n        while q:\n            v = q.popleft()\n            nk -= 1\n            for u in adj[v]:\n                nn[u] -= 1\n                if nn[u] == k - 1:\n                    q.append(u)\n        res[i - 1] = nk\n    return res\n\nn, m, k = map(int, input().split())\na = [set() for i in range(n)]\nuv = []\nfor i in range(m):\n    u, v = map(int, input().split())\n    a[u - 1].add(v - 1)\n    a[v - 1].add(u - 1)\n    uv.append((u-1, v-1))\n\nres = solve(a, m, k, uv)\nprint(str(res)[1:-1].replace(' ', '').replace(',', '\n'))
def sub(a, s):\n    pa = 0\n    ps = 0\n    while pa < len(a) and ps < len(s):\n        if a[pa] == s[ps]:\n            ps += 1\n            pa += 1\n        else:\n            pa += 1\n\n    return ps == len(s)\n\ndef subword(t, ord_ar, n):\n    t_copy = []\n    for i in range(len(ord_ar)):\n        if ord_ar[i] >= n:\n            t_copy.append(t[i])\n    return t_copy\n\ndef check(t, p, ord_ar, n):\n    s = subword(t, ord_ar, n)\n    return sub(s, p)\n\ndef bin_s(l, r, f):\n    while r > l + 1:\n        m = (r + l) // 2\n        if f(m):\n            l = m\n        else:\n            r = m\n    return l\n\n\n\ndef main():\n    t = input().strip()\n    p = input().strip()\n    ord_ar = [0]*len(t)\n    \n    seq = list(map(int, input().strip().split()))\n    for i,x in enumerate(seq):\n        ord_ar[x-1] = i\n\n    ans = bin_s(0, len(t), lambda n: check(t, p, ord_ar, n))\n    print(ans)\n\nmain()\n
n = int(input())\n\np = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\n\ns = []\nfor i in range(n):\n    s.append([p[i], a[i], b[i]])\n\ns = sorted(s)\n\nm = int(input())\nc = [int(i) for i in input().split()]\n\nidx = [0]*4\n\nans = []\n\nfor i in range(m):\n    ci = c[i]\n    while idx[ci] < n:\n        if s[idx[ci]][1] == ci or s[idx[ci]][2] == ci:\n            s[idx[ci]][1] = 0\n            s[idx[ci]][2] = 0\n            ans.append(s[idx[ci]][0])\n            break\n        idx[ci]+=1\n    if idx[ci] == n:\n        ans.append(-1)\n\nprint(*ans)\n
import sys \ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\nt = int(input())\n\nfor _ in range(t):\n    r, c = list(map(int, input().split()))\n    s = [list(input()) for i in range(r)]\n    cnt_a = 0\n    flag_kado = False\n    flag_hen = False\n    flag_hen2 = False\n    if s[0][0] == "A" or s[0][c-1] == "A" or s[r-1][0] == "A" or s[r-1][c-1] == "A":\n        flag_kado = True\n    \n    for i in range(r):\n        tmp = 0\n        for j in range(c):\n            if s[i][j] == "A":\n                if i == 0 or j == 0 or i == r-1 or j == c-1:\n                    flag_hen2 = True\n                tmp += 1\n        cnt_a += tmp\n        if tmp == c and (i == 0 or i == r-1):\n            flag_hen = True\n        elif tmp == c:\n            flag_kado = True\n\n    for i in range(c):\n        tmp = 0\n        for j in range(r):\n            if s[j][i] == "A":\n                tmp += 1\n        if tmp == r and (i == 0 or i == c-1):\n            flag_hen = True\n        elif tmp == r:\n            flag_kado = True\n  \n\n    if cnt_a == c*r:\n        print(0)\n    elif flag_hen:\n        print(1)\n    elif flag_kado:\n        print(2)\n    elif flag_hen2:\n        print(3)\n    elif cnt_a != 0:\n        print(4)\n    else:\n        print("MORTAL")\n
"""\nCodeforces Round 372 Div 1 Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.5.2\n"""\n\n################################################### SOLUTION\n\ndef main():\n    n, = read()\n    curr = 2\n    for lv in range(1, n+1):\n        tgt = (lv*(lv+1))**2\n        print((tgt - curr) // lv)\n        curr = lv*(lv+1)\n    return\n\n#################################################### HELPERS\n\ndef read(typ=int):\n    # None: String, non-split\n    # Not None: Split\n    input_line = input().strip()\n    if typ is None:\n        return input_line\n    return list(map(typ, input_line.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())\n
\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\ndef main():\n    pass\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = "x" in file.mode or "r" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b"\n") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode("ascii"))\n        self.read = lambda: self.buffer.read().decode("ascii")\n        self.readline = lambda: self.buffer.readline().decode("ascii")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip("\r\n")\n\nMOD = 10 ** 9 + 7\n\nmemo = dict()\ndef solve(m):\n    if m not in memo:\n        if m < 0:\n            memo[m] = 0\n        if m == 0:\n            memo[m] = 1\n        half = m//2\n        memo[m] = (solve(half) + solve(half - 1) + solve(half - 2) + solve(half - 3)) % MOD\n    return memo[m]\n    \n\nt = int(input())\nout = []\nfor m in map(int, input().split()):\n    #out.append(solve(m))\n    v = m//2\n    u = v//2\n    w = (v-u)\n    out.append((u*w+u+w+1)%MOD)\nprint('\n'.join(map(str,out)))\n
import sys\nfrom collections import deque\ndef solve():\n    sys.setrecursionlimit(10**6)\n    readline = sys.stdin.readline\n    writelines = sys.stdout.writelines\n    N = int(readline())\n    G = [[] for i in range(N)]\n    for i in range(N-1):\n        u, v = map(int, readline().split())\n        G[u-1].append(v-1)\n        G[v-1].append(u-1)\n\n    # Euler tour technique\n    S = []\n    FS = [0]*N; LS = [0]*N\n    depth = [0]*N\n    stk = [-1, 0]\n    it = [0]*N\n    while len(stk) > 1:\n        v = stk[-1]\n        i = it[v]\n        if i == 0:\n            FS[v] = len(S)\n            depth[v] = len(stk)\n        if i < len(G[v]) and G[v][i] == stk[-2]:\n            it[v] += 1\n            i += 1\n        if i == len(G[v]):\n            LS[v] = len(S)\n            stk.pop()\n        else:\n            stk.append(G[v][i])\n            it[v] += 1\n        S.append(v)\n\n    L = len(S)\n    lg = [0]*(L+1)\n    # Sparse Table\n    for i in range(2, L+1):\n        lg[i] = lg[i >> 1] + 1\n    st = [[L]*(L - (1 << i) + 1) for i in range(lg[L]+1)]\n    st[0][:] = S\n    b = 1\n    for i in range(lg[L]):\n        st0 = st[i]\n        st1 = st[i+1]\n        for j in range(L - (b<<1) + 1):\n            st1[j] = (st0[j] if depth[st0[j]] <= depth[st0[j+b]] else st0[j+b])\n        b <<= 1\n\n    INF = 10**18\n    ans = []\n    Q = int(readline())\n    G0 = [[]]*N\n    P = [0]*N\n    deg = [0]*N\n    KS = [0]*N\n    A = [0]*N\n    B = [0]*N\n    for t in range(Q):\n        k, *vs = map(int, readline().split())\n        for i in range(k):\n            vs[i] -= 1\n            KS[vs[i]] = 1\n        vs.sort(key=FS.__getitem__)\n        for i in range(k-1):\n            x = FS[vs[i]]; y = FS[vs[i+1]]\n            l = lg[y - x + 1]\n            w = st[l][x] if depth[st[l][x]] <= depth[st[l][y - (1 << l) + 1]] else st[l][y - (1 << l) + 1]\n            vs.append(w)\n        vs.sort(key=FS.__getitem__)\n        stk = []\n        prv = -1\n        for v in vs:\n            if v == prv:\n                continue\n            while stk and LS[stk[-1]] < FS[v]:\n                stk.pop()\n            if stk:\n                G0[stk[-1]].append(v)\n            G0[v] = []\n            it[v] = 0\n            stk.append(v)\n            prv = v\n        que = deque()\n        prv = -1\n        P[vs[0]] = -1\n        for v in vs:\n            if v == prv:\n                continue\n            for w in G0[v]:\n                P[w] = v\n            deg[v] = len(G0[v])\n            if deg[v] == 0:\n                que.append(v)\n            prv = v\n\n        while que:\n            v = que.popleft()\n            if KS[v]:\n                a = 0\n                for w in G0[v]:\n                    ra = A[w]; rb = B[w]\n                    if depth[v]+1 < depth[w]:\n                        a += min(ra, rb+1)\n                    else:\n                        a += ra\n                A[v] = INF\n                B[v] = a\n            else:\n                a = 0; b = c = INF\n                for w in G0[v]:\n                    ra = A[w]; rb = B[w]\n                    a, b, c = a + ra, min(a + rb, b + ra), min(b + rb, c + min(ra, rb))\n                A[v] = min(a, b+1, c+1)\n                B[v] = b\n\n            p = P[v]\n            if p != -1:\n                deg[p] -= 1\n                if deg[p] == 0:\n                    que.append(p)\n        v = min(A[vs[0]], B[vs[0]])\n        if v >= INF:\n            ans.append("-1\n")\n        else:\n            ans.append("%d\n" % v)\n        for v in vs:\n            KS[v] = 0\n\n    writelines(ans)\nsolve()
def main():\n    def countchildren(graph,vert,memo,pard=None):\n        dumi=0\n        for child in graph[vert]:\n            if child!=pard:\n                if len(graph[child])==1:\n                    memo[child]=0\n                else:\n                    memo[child]=countchildren(graph,child,memo,vert)[0]\n                dumi+=memo[child]+1\n        return((dumi,memo))\n    n=int(input())\n    neigh=[]\n    for i in range(n):\n        neigh.append([])\n    for i in range(n-1):\n        a,b=map(int,input().split())\n        neigh[a-1].append(b-1)\n        neigh[b-1].append(a-1)\n    same=1\n    layer=[0]\n    pars=[None]\n    j=0\n    while layer!=[]:\n        j+=1\n        newlayer=[]\n        newpars=[]\n        for i in range(len(layer)):\n            for vert in neigh[layer[i]]:\n                if vert!=pars[i]:\n                    newlayer.append(vert)\n                    newpars.append(layer[i])\n        layer=newlayer\n        pars=newpars\n        if j%2==0:\n            same+=len(layer)\n    bipartite=same*(n-same)\n    info=countchildren(neigh,0,[None]*n)[1]\n    dist=0\n    for guy in info:\n        if guy!=None:\n           dist+=(guy+1)*(n-guy-1)\n    print((dist+bipartite)//2)\n\nimport sys\nimport threading\nsys.setrecursionlimit(2097152)\nthreading.stack_size(134217728)\nmain_thread=threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()
import sys\nreadline = sys.stdin.readline\nclass UF():\n    def __init__(self, num):\n        self.par = [-1]*num\n        self.weight = [0]*num\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            stack = []\n            while self.par[x] >= 0:\n                stack.append(x)\n                x = self.par[x]\n            for xi in stack:\n                self.par[xi] = x\n            return x\n    \n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            if self.par[rx] > self.par[ry]:\n                rx, ry = ry, rx\n            self.par[rx] += self.par[ry]\n            self.par[ry] = rx\n            self.weight[rx] += self.weight[ry]\n        return rx\n\nN, K = list(map(int, readline().split()))\nS = list(map(int, readline().strip()))\n\nA = [[] for _ in range(N)]\n\nfor k in range(K):\n    BL = int(readline())\n    B = list(map(int, readline().split()))\n    for b in B:\n        A[b-1].append(k)\n\ncnt = 0\nT = UF(2*K)\nused = set()\nAns = [None]*N\ninf = 10**9+7\nfor i in range(N):\n    if not len(A[i]):\n        Ans[i] = cnt\n        continue\n    kk = 0\n    if len(A[i]) == 2:    \n        x, y = A[i]\n        if S[i]:\n            rx = T.find(x)\n            ry = T.find(y)\n            if rx != ry:\n                rx2 = T.find(x+K)\n                ry2 = T.find(y+K)\n                sp = min(T.weight[rx], T.weight[rx2]) + min(T.weight[ry], T.weight[ry2])\n                if x not in used:\n                    used.add(x)\n                    T.weight[rx] += 1\n                if y not in used:\n                    used.add(y)\n                    T.weight[ry] += 1\n                rz = T.union(rx, ry)\n                rz2 = T.union(rx2, ry2)\n                sf = min(T.weight[rz], T.weight[rz2])\n                kk = sf - sp\n        else:\n            rx = T.find(x)\n            ry2 = T.find(y+K)\n            sp = 0\n            if rx != ry2:\n                ry = T.find(y)\n                rx2 = T.find(x+K)\n                sp = min(T.weight[rx], T.weight[rx2]) + min(T.weight[ry], T.weight[ry2])\n                if x not in used:\n                    used.add(x)\n                    T.weight[rx] += 1\n                if y not in used:\n                    used.add(y)\n                    T.weight[ry] += 1\n                rz = T.union(rx, ry2)\n                rz2 = T.union(rx2, ry)\n                sf = min(T.weight[rz], T.weight[rz2])\n                kk = sf - sp\n    else:\n        if S[i]:\n            x = A[i][0]\n            rx = T.find(x)\n            rx2 = T.find(x+K)\n            sp = min(T.weight[rx], T.weight[rx2])\n            T.weight[rx] += inf\n            sf = min(T.weight[rx], T.weight[rx2])\n            kk = sf - sp\n        else:\n            x = A[i][0]\n            rx = T.find(x)\n            rx2 = T.find(x+K)\n            sp = min(T.weight[rx], T.weight[rx2])\n            T.weight[rx2] += inf\n            if x not in used:\n                used.add(x)\n                T.weight[rx] += 1\n            sf = min(T.weight[rx], T.weight[rx2])\n            kk = sf-sp\n    Ans[i] = cnt + kk\n    cnt = Ans[i]            \nprint('\n'.join(map(str, Ans)))\n            \n
import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nclass Binary_Indexed_Tree():\n    def __init__(self, n):\n        self.n = n\n        self.data = [0]*(n+1)\n\n    def add(self, i, x):\n        while i <= self.n:\n            self.data[i] += x\n            i += i & -i\n\n    def get(self, i):\n        return self.sum_range(i, i)\n\n    def sum(self, i):\n        ret = 0\n        while i:\n            ret += self.data[i]\n            i &= i-1\n        return ret\n\n    def sum_range(self, l, r):\n        return self.sum(r)-self.sum(l-1)\n\n    def lower_bound(self, w):\n        if w<=0:\n            return 0\n        i = 0\n        k = 1<<(self.n.bit_length())\n        while k:\n            if i+k <= self.n and self.data[i+k] < w:\n                w -= self.data[i+k]\n                i += k\n            k >>= 1\n        return i+1\n\nn = int(input())\na = list(map(int, input().split()))\nd = {j:i for i,j in enumerate(a)}\nBIT1 = Binary_Indexed_Tree(n)\nBIT2 = Binary_Indexed_Tree(n)\nBIT3 = Binary_Indexed_Tree(n)\n\ntentou = 0\nans = []\nfor i in range(n):\n    tmp = 0\n    p = d[i+1]\n    inv_p = n-p\n    tentou += BIT1.sum(inv_p)\n    BIT1.add(inv_p, 1)\n\n    BIT2.add(p+1, 1)\n    BIT3.add(p+1, p+1)\n    m = i//2+1\n    mean = BIT2.lower_bound(i//2+1)\n    tmp = 0\n    if i%2 == 0:\n        tmp -= m*(m-1)\n    else:\n        tmp -= m*m\n    tmp += tentou\n    left = BIT3.sum_range(1, mean)\n    right = BIT3.sum_range(mean, n)\n    if i%2 == 0:\n        left = mean*m - left\n        right = right - mean*m\n    else:\n        left = mean*m - left\n        right = right - mean*(m+1)\n    tmp += left + right\n    ans.append(tmp)\nprint(*ans)\n\n
def popcount(n):\n	res = 0\n	while n > 0:\n		res += n & 1\n		n >>= 2\n\ndef A(l, r):\n	r += 1\n	t = 1 << 64\n	while t & (l ^ r) == 0:\n		t >>= 1\n	res = l | (t - 1)\n	#print(t, res)\n	return res\n\ndef __starting_point():\n	"""assert(A(1, 2) == 1)\n	assert(A(2, 4) == 3)\n	assert(A(1, 10) == 7)\n	assert(A(13, 13) == 13)\n	assert(A(1, 7) == 7)"""\n\n	n = int(input())\n	for _ in range(n):\n		l, r = list(map(int, input().split()))\n		res = A(l, r)\n		print(res)\n\n__starting_point()
def mat(shape, inital_val=None):\n    if len(shape) > 1:\n        return [mat(shape[1:], inital_val) for _ in range(shape[0])]  \n    else:\n        return [inital_val] * shape[0]\n            \ndef main():\n    n, m = [int(x) for x in input().split()]\n    graph = [{} for _ in range(n)]\n    for _ in range(m):\n        v, u, c = input().split()\n        graph[int(v) - 1][int(u) - 1] = c\n    \n    winner_table = mat([n, n, 26])\n    \n    def get_winner(u, v, char_to_beat):\n        """\n        Args:\n            u: The position of current turn's player. \n            v: The position of next turn's player.\n            char_to_beat: The character played in the previous round.\n        Returns:\n            'A' if current turn's player wins, 'B' otherwise.\n        """\n        char_idx = ord(char_to_beat) - ord('a')\n        if not winner_table[u][v][char_idx]:\n            winner = 'B'\n            for w, c in list(graph[u].items()):\n                if c >= char_to_beat and get_winner(v, w, c) == 'B':\n                    winner = 'A'\n                    break\n            winner_table[u][v][char_idx] = winner\n        return winner_table[u][v][char_idx]\n    \n    for i in range(n):\n        print(''.join(get_winner(i, j, 'a') for j in range(n)))\n    \n\ndef __starting_point():\n    main()\n\n__starting_point()
n = int(input())\nr = [[] for i in range(n + 1)]\nr[1] = [0]\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    r[a].append(b)\n    r[b].append(a)\nt = list(map(int, input().split()))\nu, v = [0] * (n + 1), [0] * (n + 1)\nfor i, j in enumerate(t, 1):\n    if j < 0: u[i] = - j\n    else: v[i] = j\nt, p = [1], [0] * (n + 1)\nwhile t:\n    a = t.pop()\n    for b in r[a]:\n        if p[b]: continue\n        p[b] = a\n        t.append(b)\nk = [len(t) for t in r]\nt = [a for a in range(2, n + 1) if k[a] == 1]\nx, y = [0] * (n + 1), [0] * (n + 1)\nwhile t:\n    a = t.pop()\n    b = p[a]\n    x[b] = max(x[b], u[a])\n    y[b] = max(y[b], v[a])\n    k[b] -= 1\n    if k[b] == 1:\n        t.append(b)\n        if u[b] > 0:\n            if x[b] - y[b] > u[b]:\n                u[b], v[b] = x[b], x[b] - u[b]\n            else: u[b], v[b] = y[b] + u[b], y[b]\n        else:\n            if y[b] - x[b] > v[b]:\n                u[b], v[b] = y[b] - v[b], y[b]\n            else: u[b], v[b] = x[b], x[b] + v[b]\nprint(u[1] + v[1])
MOD=10**9+7\nN,C=map(int, input().split())\nA=list(map(int, input().split()))\nB=list(map(int, input().split()))\nP=[[1] for _ in range(401)]\nfor _ in range(1,401):\n    for i in range(1,401):\n        P[i].append(P[i][-1]*i%MOD)\nR=[[] for _ in range(N)]\nfor i,AB in enumerate(zip(A, B)):\n    AA,BB=AB\n    for a in range(401):\n        tmp=0\n        for x in range(AA,BB+1):\n            tmp+=P[x][a]\n            tmp%=MOD\n        R[i].append(tmp)\ndp=[[0]*(C+1) for _ in range(N+1)]\ndp[0][0]=1\nfor n in range(1,N+1):\n    for k in range(C+1):\n        for l in range(k+1):\n            dp[n][k]+=dp[n-1][k-l]*R[n-1][l]\n            dp[n][k]%=MOD\nprint(dp[N][C])
import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = (tuple(int(x) for x in row.split()) for row in sys.stdin.readlines())\n\n# x1,2,...,N\n# yN+1,N+2,...,N+N\n\ngraph = [set() for _ in range(N+N+1)]\nfor x,y in ball:\n    graph[x].add(y+N)\n    graph[y+N].add(x)\n\nvisited = [False] * (N+N+1)\ncomponents = []\nfor x in range(1,N+N+1):\n    if visited[x]:\n        continue\n    V = set([x])\n    E = []\n    q = [x]\n    visited[x] = True\n    while q:\n        y = q.pop()\n        for z in graph[y]:\n            if y < z:\n                E.append((y,z))\n            if visited[z]:\n                continue\n            V.add(z)\n            visited[z] = True\n            q.append(z)\n    components.append((V,E))\n\ndef make_get_pattern(V):\n    deg1 = [x for x in V if len(graph[x]) == 1]\n    get = {}\n    while deg1:\n        x = deg1.pop()\n        if not graph[x]:\n            continue\n        y = graph[x].pop()\n        se = graph[y]; se.remove(x)\n        if len(se) == 1: deg1.append(y)\n        if x < y:\n            get[(x,y)] = 0\n        else:\n            get[(y,x)] = 1\n    for x in V:\n        if graph[x]:\n            y = graph[x].pop()\n            break\n    # \n    graph[y].remove(x)\n    if x > y: x,y = y,x\n    get[(x,y)] = 2\n    while graph[x]:\n        y = graph[x].pop()\n        graph[y].remove(x)\n        if x < y:\n            get[(x,y)] = 3\n        else:\n            get[(y,x)] = 2\n        x = y\n    return get\n\ndef F(V,E):\n    # V is connected\n    if len(E) != len(V):\n        return 0\n    ret = 0\n    E.sort()\n    get = make_get_pattern(V)\n    den1,den2 = 1,1\n    dp1 = {x:0 for x in V}\n    dp2 = {x:0 for x in V}\n    for x,y in E:\n        if get[(x,y)] == 0:\n            k1 = dp1[x] + 1; k2 = dp2[x] + 1\n        elif get[(x,y)] == 1:\n            k1 = dp1[y] + 1; k2 = dp2[y] + 1\n        elif get[(x,y)] == 2:\n            k1 = dp1[x] + 1; k2 = dp2[y] + 1\n        else:\n            k1 = dp1[y] + 1; k2 = dp2[x] + 1\n        dp1[x] += k1; dp1[y] += k1\n        dp2[x] += k2; dp2[y] += k2\n        den1 *= k1; den2 *= k2\n        den1 %= MOD; den2 %= MOD\n    return sum(pow(x,MOD-2,MOD) for x in (den1,den2))\n\nprob = 1\nfor c in components:\n    prob *= F(*c)\n    prob %= MOD\n\nanswer = prob\nfor n in range(1,N+N+1):\n    answer *= n\n    answer %= MOD\nprint(answer)
from bisect import bisect\nfrom collections import defaultdict\n\n\nclass Bit:\n    def __init__(self, n, MOD):\n        self.size = n\n        self.tree = [0] * (n + 1)\n        self.depth = n.bit_length()\n        self.mod = MOD\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s % self.mod\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] = (self.tree[i] + x) % self.mod\n            i += i & -i\n\n    def debug_print(self):\n        for i in range(1, self.size + 1):\n            j = (i & -i).bit_length()\n            print(('  ' * j, self.tree[i]))\n\n    def lower_bound(self, x):\n        sum_ = 0\n        pos = 0\n        for i in range(self.depth, -1, -1):\n            k = pos + (1 << i)\n            if k <= self.size and sum_ + self.tree[k] < x:\n                sum_ += self.tree[k]\n                pos += 1 << i\n        return pos + 1, sum_\n\n\nn, m = list(map(int, input().split()))\nxxx = list(map(int, input().split()))\nyyy = list(map(int, input().split()))\nab = defaultdict(set)\ncoordinates = set()\n\nfor x in xxx:\n    if x < yyy[0] or yyy[-1] < x:\n        continue\n    i = bisect(yyy, x)\n    a = x - yyy[i - 1]\n    b = yyy[i] - x\n    ab[a].add(b)\n    coordinates.add(b)\n\n# Bitindex1"0"1\ncor_dict = {b: i for i, b in enumerate(sorted(coordinates), start=2)}\ncdg = cor_dict.get\nMOD = 10 ** 9 + 7\nbit = Bit(len(coordinates) + 1, MOD)\nbit.add(1, 1)\n\nfor a in sorted(ab):\n    bbb = sorted(map(cdg, ab[a]), reverse=True)\n    for b in bbb:\n        bit.add(b, bit.sum(b - 1))\n\nprint((bit.sum(bit.size)))\n
# seishin.py\nN = int(input())\nP = [list(map(int, input().split())) for i in range(N)]\n\nfrom heapq import heappush, heappop\n\nl0, r0 = P[0]\n\nL = [-l0+1]\nR = [l0-1]\ns = t = 0\n\nres = 0\nfor i in range(N-1):\n    l0, r0 = P[i]\n    l1, r1 = P[i+1]\n    s += (r1 - l1); t += (r0 - l0)\n    if -s-L[0] <= l1-1 <= t+R[0]:\n        heappush(L, -l1+1-s)\n        heappush(R, l1-1-t)\n    elif l1-1 < -s-L[0]:\n        heappush(L, -l1+1-s)\n        heappush(L, -l1+1-s)\n        p = -heappop(L)-s\n        heappush(R, p-t)\n        res += (p - (l1-1))\n    elif t+R[0] < l1-1:\n        heappush(R, l1-1-t)\n        heappush(R, l1-1-t)\n        p = heappop(R) + t\n        heappush(L, -p-s)\n        res += ((l1-1) - p)\nprint(res)
from sys import stdin, stdout\n\nrd = lambda: list(map(int, stdin.readline().split()))\n\nn, m, k = rd()\na = rd()\nb = [rd() for _ in range(m)]\nx = [0]*(m+1)\ny = [0]*(n+1)\n\nfor _ in range(k):\n  l, r = rd()\n  x[l-1] += 1\n  x[r  ] -= 1\n\ns = 0\nfor i in range(m):\n  l, r, d = b[i]\n  s += x[i]\n  y[l-1] += s*d\n  y[r  ] -= s*d\n\ns = 0\nfor i in range(n):\n  s += y[i]\n  a[i] += s\nprint(' '.join(map(str, a)))
from sys import stdin\nfrom heapq import heappop,heappush\ndef main():\n	n,k = map(int,stdin.readline().split())\n	X = list(map(int,stdin.readline().split()))\n	A = int(stdin.readline().strip())\n	C = list(map(int,stdin.readline().split()))\n	l  = list()\n	i = 0;g = k;ans = 0;flag = True\n	while i < n and flag:\n		heappush(l,C[i])\n		if X[i] > g:\n			while len(l)!= 0 and X[i] > g:\n				ans+= heappop(l)\n				g+= A\n			if len(l) == 0 and X[i] > g:\n				flag = False\n		i+=1\n	if flag:\n		print(ans)\n	else:\n		print(-1)\nmain()
# https://codeforces.com/problemset/problem/280/C\nfrom collections import defaultdict, deque\nimport sys\n\nnodes = int(sys.stdin.readline())\nedges = defaultdict(list)\nfor line in sys.stdin:\n    a, b = line.split()\n    a = int(a)\n    b = int(b)\n    edges[a].append(b)\n    edges[b].append(a)\nbfs = deque([(1, 1)])\ndepths = {}\nwhile bfs:\n    nid, depth = bfs.popleft()\n    if nid in depths:\n        continue\n    depths[nid] = depth\n    for n2 in edges[nid]:\n        bfs.append((n2, depth + 1))\nprint(sum(1.0 / d for d in sorted(depths.values(), reverse=True)))
mod = 1000000007\neps = 10**-9\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    def PrimeDecomposition(N):\n        ret = {}\n        n = int(N ** 0.5)\n        for d in range(2, n + 1):\n            while N % d == 0:\n                if d not in ret:\n                    ret[d] = 1\n                else:\n                    ret[d] += 1\n                N //= d\n            if N == 1:\n                break\n        if N != 1:\n            ret[N] = 1\n        return ret\n\n    for _ in range(int(input())):\n        p, q = list(map(int, input().split()))\n        if p % q != 0:\n            print(p)\n            continue\n        prime = PrimeDecomposition(q)\n        C = {}\n        mi = p\n        for pr in prime:\n            C = 0\n            tmp = p\n            while tmp % pr == 0:\n                C += 1\n                tmp //= pr\n            mi = min(mi, pr ** (C - prime[pr] + 1))\n        print(p // mi)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
for __ in range(int(input())):\n    a, b, c, d = list(map(int, input().split()))\n    if a == c or b == d:\n        print(abs(a - c) + abs(b - d))\n    else:\n        print(abs(a - c) + abs(b - d) + 2)
n, m, k = list(map(int,input().split()))\ndm, dp = {}, {}\nvis = {}\nsensors = []\nborder = set()\nfor el in [(0, m), (n, 0), (0, 0), (n, m)]:\n    border.add(el)\n\nfor _ in range(k):\n    x, y = list(map(int, input().split()))\n    if not (x - y) in dm:\n        dm[x - y] = []\n    dm[x - y].append((x, y))\n    if not (x + y) in dp:\n        dp[x + y] = []\n    dp[x + y].append((x, y))\n    vis[(x, y)] = -1\n    sensors.append((x,y))\n\nx, y = 0, 0\ntime = 0\nmove = (1,1)\nwhile True:\n    if move == (1,1):\n        v = min(n - x, m - y)\n        nxt = (x + v, y + v)\n        if nxt[0] == n:\n            move = (-1, 1)\n        else:\n            move = (1, -1)\n        if (x - y) in dm:\n            for sensor in dm[x - y]:\n                if vis[sensor] == -1:\n                    #print('doing', sensor)\n                    vis[sensor] = time + sensor[0] - x\n        time += v\n\n    elif move == (-1,-1):\n        v = min(x, y)\n        nxt = (x - v, y - v)\n        if nxt[0] == 0:\n            move = (1, -1)\n        else:\n            move = (-1, 1)\n        if (x - y) in dm:\n            for sensor in dm[x - y]:\n                if vis[sensor] == -1:\n                    #print('doing', sensor)\n                    vis[sensor] = time + x - sensor[0]\n        time += v\n\n    elif move == (-1,1):\n        v = min(x, m - y)\n        nxt = (x - v, y + v)\n        if nxt[0] == 0:\n            move = (1, 1)\n        else:\n            move = (-1, -1)\n        if (x + y) in dp:\n            for sensor in dp[x + y]:\n                if vis[sensor] == -1:\n                    #print('doing', sensor)\n                    vis[sensor] = time + x - sensor[0]\n        time += v\n\n    else:\n        v = min(n - x, y)\n        nxt = (x + v, y - v)\n        if nxt[0] == n:\n            move = (-1, -1)\n        else:\n            move = (1, 1)\n        if (x + y) in dp:\n            for sensor in dp[x + y]:\n                if vis[sensor] == -1:\n                    #print('doing', sensor)\n                    vis[sensor] = time + sensor[0] - x\n        time += v\n\n    if nxt in border:\n        break\n    else:\n        border.add(nxt)\n\n    x, y = nxt\n    #print('bum', x, y)\n\nfor i in range(k):\n    #print(sensors[i])\n    print(vis[sensors[i]])\n
import sys\n\nn, m = list(map(int, sys.stdin.readline().strip().split()))\nL = [0 for i in range (0, n)]\nH = [[] for i in range (0, n)]\nfor i in range (0, m):\n    x, y = list(map(int, sys.stdin.readline().strip().split()))\n    x = x - 1\n    y = y - 1\n    if x > y:\n        x, y = y, x\n    L[y] = L[y] + 1\n    H[x].append(y)\nans = 0\nfor i in range (0, n):\n    ans = ans + L[i] * len(H[i])\nprint(ans)\nq = int(sys.stdin.readline().strip())\nfor i in range (0, q):\n    v = int(sys.stdin.readline().strip()) - 1\n    ans = ans - L[v] * len(H[v])\n    L[v] = L[v] + len(H[v])\n    while len(H[v]) > 0:\n        w = H[v].pop()\n        H[w].append(v)\n        L[w] = L[w] - 1\n        ans = ans + L[w] - len(H[w]) + 1\n    print(ans)\n
#!/usr/bin/env python3\n"""\nCreated on Wed Feb 28 11:47:12 2018\n\n@author: mikolajbinkowski\n"""\nimport sys\n\nN = int(input())\n\nstring_count = {}\nfor _ in range(N):\n    s = str(input())\n    char_count = {}\n    for c in s:\n        char_count[c] = char_count.get(c, 0) + 1\n    s0 = []\n    for a in 'abcdefghijklmnopqrstuvwxyz':\n        if char_count.get(a, 0) % 2 == 1:\n            s0.append(a)\n    s1 = ''.join(s0)\n    string_count[s1] = string_count.get(s1, 0) + 1\n\npairs = 0\nfor s, v in list(string_count.items()):\n    pairs += v * (v-1) // 2\n    for i in range(len(s)):\n        pairs += v * string_count.get(s[:i] + s[i+1:], 0)\n\nprint(pairs)\n\n        \n    \n
corr = lambda x, y: 1 <= x <= n and 1 <= y <= m\n\nT = int(input())\na = []\nwhile T:\n    a.append(T % 6)\n    T //= 6\nL = len(a)\nn = m = L * 2 + 2\nans = [(1, 2, 2, 2), (2, 1, 2, 2)]\nf = [[1] * 9 for i in range(7)]\nf[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\nf[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\np = [0] * 9\np[1] = 3, 1, 3, 2\np[2] = 4, 1, 4, 2\np[3] = 4, 2, 5, 2\np[4] = 4, 3, 5, 3\np[5] = 1, 3, 2, 3\np[6] = 1, 4, 2, 4\np[7] = 2, 4, 2, 5\np[8] = 3, 4, 3, 5\nfor i in range(L):\n    bit = a[L - i - 1]\n    for j in range(1, 9):\n        if not f[bit][j]: continue\n        x1, y1, x2, y2 = p[j]; D = 2 * i\n        x1 += D; y1 += D; x2 += D; y2 += D\n        if corr(x2, y2): ans.append((x1, y1, x2, y2))\nfor i in range(L - 1):\n    x1, y1 = 5 + i * 2, 1 + i * 2\n    x2, y2 = 1 + i * 2, 5 + i * 2\n    ans.append((x1, y1, x1 + 1, y1))\n    ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n    ans.append((x2, y2, x2, y2 + 1))\n    ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\nprint(n, m)\nprint(len(ans))\n[print(*i) for i in ans]\n
#!/usr/bin/env	python\n#-*-coding:utf-8 -*-\nimport sys,collections\nn,q=list(map(int,input().split()))\nM=collections.defaultdict(collections.deque)\nQ=collections.deque()\nL=[]\ns=n=m=0\nfor _ in range(q):\n	y,x=list(map(int,input().split()))\n	if 2>y:\n		s+=1\n		Q.append(x)\n		M[x].append(n)\n		n+=1\n	elif 3>y:\n		y=M.get(x)\n		if y:\n			s-=len(y)\n			del M[x]\n	else:\n		while x>m:\n			z=Q.popleft()\n			y=M.get(z)\n			if y and y[0]<x:\n				s-=1\n				y.popleft()\n				if not y:del M[z]\n			m+=1\n	L.append(s)\nsys.stdout.write('\n'.join(map(str,L)))\n
ii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\nfrom collections import Counter as C\nn = ii()\na = li()\noe = [C(), C()]\noe[1][0] = 1\nx = 0\nans = 0\nfor i in range(n):\n    x ^= a[i]\n    ans += oe[i % 2][x]\n    oe[i % 2][x] += 1\nprint(ans)
import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nANS=[]\n\nfor i in range(1,n//2+1):\n    for j in range(1,m+1):\n        sys.stdout.write("".join((str(i)," ",str(j),"\n")))\n        sys.stdout.write("".join((str(n-i+1)," ",str(m-j+1),"\n")))\n\n\n\nif n%2==1:\n    for j in range(1,m//2+1):\n        sys.stdout.write("".join((str(n//2+1)," ",str(j),"\n")))\n        sys.stdout.write("".join((str(n//2+1)," ",str(m-j+1),"\n")))\n\n    if m%2==1:\n        sys.stdout.write("".join((str(n//2+1)," ",str(m//2+1),"\n")))\n\n
import sys\ninput = lambda: sys.stdin.readline().rstrip()\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = [ord(a) - 97 for a in input()]\n    B = [ord(a) - 97 for a in input()]\n    X = [[0] * 20 for _ in range(20)]\n    for a, b in zip(A, B):\n        X[a][b] = 1\n        if a > b:\n            print(-1)\n            break\n    else:\n        ans = 0\n        for i in range(20):\n            for j in range(i+1, 20):\n                if X[i][j]:\n                    ans += 1\n                    for jj in range(j+1, 20):\n                        if X[i][jj]:\n                            X[j][jj] = 1\n                    break\n        print(ans)\n
N=100001\nfac=[0 for i in range(N)]\nfor i in range(1,N):\n    for j in range(i,N,i):\n        fac[j]+=1\ndef gcd(a,b):\n        if a<b:\n            a,b=b,a\n        while b>0:\n            a,b=b,a%b\n        return a\ndef ctt(A,B,C):\n    la=fac[A]\n    lb=fac[B]\n    lc=fac[C]\n    ab=gcd(A,B)\n    ac=gcd(A,C)\n    bc=gcd(B,C)\n    abc=gcd(ab,C)\n    dupabc=fac[abc]\n    dupac=fac[ac]-dupabc\n    dupbc=fac[bc]-dupabc\n    dupab=fac[ab]-dupabc\n    lax=la-dupabc-dupab-dupac\n    lbx=lb-dupabc-dupab-dupbc\n    lcx=lc-dupabc-dupac-dupbc\n    ctx=lax*lbx*lcx\n    ctx+=lax*lbx*(lc-lcx)\n    ctx+=lax*lcx*(lb-lbx)\n    ctx+=lcx*lbx*(la-lax)\n    ctx+=lax*((lb-lbx)*(lc-lcx)-(dupabc+dupbc)*(dupabc+dupbc-1)/2)\n    ctx+=lbx*((la-lax)*(lc-lcx)-(dupabc+dupac)*(dupabc+dupac-1)/2)\n    ctx+=lcx*((la-lax)*(lb-lbx)-(dupabc+dupab)*(dupabc+dupab-1)/2)\n    ctx+=dupab*dupac*dupbc\n    ctx+=dupab*dupac*(dupab+dupac+2)/2\n    ctx+=dupab*dupbc*(dupab+dupbc+2)/2\n    ctx+=dupbc*dupac*(dupbc+dupac+2)/2\n    ctx+=dupabc*(dupab*dupac+dupab*dupbc+dupbc*dupac)\n    ctx+=dupabc*(dupab*(dupab+1)+(dupbc+1)*dupbc+(dupac+1)*dupac)/2\n    ctx+=(dupabc+1)*dupabc*(dupab+dupac+dupbc)/2\n    ctx+=(dupabc*dupabc+dupabc*(dupabc-1)*(dupabc-2)/6)\n    return int(ctx)\nn=int(input())\nfor _ in range(n):\n    a,b,c = map(int,input().split())\n    print(ctt(a,b,c))\nreturn
from sys import stdin\n\ndef bitadd(a,w,bit):\n \n    x = a\n    while x <= (len(bit)-1):\n        bit[x] += w\n        x += x & (-1 * x)\n \ndef bitsum(a,bit):\n \n    ret = 0\n    x = a\n    while x > 0:\n        ret += bit[x]\n        x -= x & (-1 * x)\n    return ret\n\nclass RangeBIT:\n\n    def __init__(self,N,indexed):\n        self.bit1 = [0] * (N+2)\n        self.bit2 = [0] * (N+2)\n        self.mode = indexed\n\n    def bitadd(self,a,w,bit):\n \n        x = a\n        while x <= (len(bit)-1):\n            bit[x] += w\n            x += x & (-1 * x)\n \n    def bitsum(self,a,bit):\n \n        ret = 0\n        x = a\n        while x > 0:\n            ret += bit[x]\n            x -= x & (-1 * x)\n        return ret\n    \n    def add(self,l,r,w):\n\n        l = l + (1-self.mode)\n        r = r + (1-self.mode)\n        self.bitadd(l,-1*w*l,self.bit1)\n        self.bitadd(r,w*r,self.bit1)\n        self.bitadd(l,w,self.bit2)\n        self.bitadd(r,-1*w,self.bit2)\n\n    def sum(self,l,r):\n        l = l + (1-self.mode)\n        r = r + (1-self.mode)\n        ret =  self.bitsum(r,self.bit1) + r * self.bitsum(r,self.bit2)\n        ret -= self.bitsum(l,self.bit1) + l * self.bitsum(l,self.bit2)\n\n        return ret\n\nn,q = list(map(int,stdin.readline().split()))\na = list(map(int,stdin.readline().split()))\n\nqs = [ [] for i in range(n+1) ]\nans = [None] * q\n\nfor loop in range(q):\n    x,y = list(map(int,stdin.readline().split()))\n    l = x+1\n    r = n-y\n    qs[r].append((l,loop))\n\nBIT = [0] * (n+1)\n\nfor r in range(1,n+1):\n\n    b = r-a[r-1]\n\n    if b >= 0:\n\n        L = 1\n        R = r+1\n        while R-L != 1:\n            M = (L+R)//2\n\n            if bitsum(M,BIT) >= b:\n                L = M\n            else:\n                R = M\n\n        if bitsum(L,BIT) >= b:\n            bitadd(1,1,BIT)\n            bitadd(L+1,-1,BIT)\n\n\n    for ql,qind in qs[r]:\n        ans[qind] = bitsum(ql,BIT)\n\nfor i in ans:\n    print (i)\n
import random\nimport math\n\ndef set_color(game, color):\n    color_count[game[0]][game[2]] -= 1\n    color_count[game[1]][game[2]] -= 1\n    game[2] = color\n    color_count[game[0]][game[2]] += 1\n    color_count[game[1]][game[2]] += 1\n\ndef fix(node):\n    minimum = math.inf\n    maximum = 0\n\n    for i in range(k):\n        minimum = min(minimum, color_count[node][i])\n        maximum = max(maximum, color_count[node][i])\n\n    if maximum - minimum <= 2:\n        return False\n\n    rand = 0\n    for game in games:\n        if (game[0] == node or game[1] == node) and color_count[node][game[2]] == maximum:\n            rand = r(1,k)\n            set_color(game, rand % k)\n            return True\n\n    return False\n\nn, m, k = list(map(int,input().split()))\ngames = [[0 for _ in range(4)] for _ in range(m)]\ncolor_count = [[0 for _ in range(k)] for _ in range(n)]\nanswers = [0 for _ in range(m)]\n_ = list(map(int,input().split()))\n\ncolor = 0\nr = lambda x,y : random.randint(x,y)\nfor i in range(m):\n    a, b = list(map(int,input().split()))\n    color = r(1,k) % k\n    games[i] = [a-1,b-1,color,i]\n    color_count[games[i][0]][color] += 1\n    color_count[games[i][1]][color] += 1\n\nbad = True\n\nwhile bad:\n    random.shuffle(games)\n    bad = False\n\n    for i in range(n):\n        while(fix(i)):\n            bad = True\n\nfor game in games:\n    answers[game[3]] = game[2] + 1\n\nfor i in range(m):\n    print(answers[i])\n        \n\n    \n
from collections import deque\n\ndef rollingmax(x, y, r, a):\n    k = 2 * r + 1\n    d = deque()\n    lx = len(x)\n    for i in range(lx + r):\n        if i < lx:\n            while d and d[-1][1] <= x[i]:\n                d.pop()\n            d.append((i, x[i]))\n        while d and d[0][0] <= i - k:\n            d.popleft()\n        if i >= r:\n            y[i - r] = d[0][1] - abs(i - r - a)\n\nn, m, d = [int(x) for x in input().split()]\na, ball, t0 = [int(x) for x in input().split()]\nf = [-abs(i - a) for i in range(1, n + 1)]\ng = [0] * n\nfor _ in range(m - 1):\n    a, b, t = [int(x) for x in input().split()]\n    ball += b\n    r = min(n - 1, (t - t0) * d)\n    t0 = t    \n    rollingmax(f, g, r, a - 1)\n    f, g = g, f\n\nprint(max(f) + ball)    \n\n
import sys\ninput = sys.stdin.readline\n\ndef main():\n    R, C, N = map(int, input().split())\n    xyxy = [list(map(int, input().split())) for i in range(N)]\n\n    r = []\n\n    for i in range(N):\n        x1, y1, x2, y2 = xyxy[i]\n        # \n        if ((x1 == 0 or x1 == R) or (y1 == 0 or y1 == C)) and ((x2 == 0 or x2 == R) or (y2 == 0 or y2 == C)):\n            # \n            if x1 == 0:\n                r.append((y1, i))\n            elif x1 == R:\n                r.append((C - y1 + C + R, i))\n            elif y1 == 0:\n                r.append((R - x1 + C * 2 + R, i))\n            else:\n                r.append((x1 + C, i))\n            # 2\n            if x2 == 0:\n                r.append((y2, i))\n            elif x2 == R:\n                r.append((C - y2 + C + R, i))\n            elif y2 == 0:\n                r.append((R - x2 + C * 2 + R, i))\n            else:\n                r.append((x2 + C, i))\n    \n    r = sorted(r)\n    # print(r)\n    stack = []\n    for i in range(len(r)):\n        if len(stack) > 0:\n            if stack[-1] == r[i][1]:\n                stack.pop()\n            else:\n                stack.append(r[i][1])\n        else:\n            stack.append(r[i][1])\n    \n    if len(stack) > 0:\n        print("NO")\n    else:\n        print("YES")\n            \n\n\n\ndef __starting_point():\n    main()\n__starting_point()
#!/usr/bin/env python3\n\n\nM = 998244353\n\ndef powmod(a, x, m = M):\n    y = 1\n    while 0 < x:\n        if x % 2 == 1:\n            y *= a\n            y %= m\n        x //= 2\n        a = a ** 2\n        a %= m\n\n    return y\n\n\ndef solve(s):\n    n = len(s)\n\n    nb = nc = 0\n    ch = s[0]\n    if ch == 'b':\n        nb += 1\n    elif ch == 'c':\n        nc += 1\n    sf = True\n    tf = True\n    left = ch\n    for ch in s[1:]:\n        if ch == 'b':\n            nb += 1\n        elif ch == 'c':\n            nc += 1\n        if ch == left:\n            sf = False\n        else:\n            tf = False\n        left = ch\n\n\n    if tf:\n        return 1\n    if n == 3:\n        if (nb + nc * 2) % 3:\n            return 7 if sf else 6\n        else:\n            return 3\n    if n % 3:\n        return (powmod(3, n - 1) + M - powmod(2, n - 1) + (1 if sf else 0)) % M\n    else:\n        if (nb + nc * 2) % 3:\n            return (powmod(3, n - 1) + M - (powmod(2, n - 1) - powmod(2, n // 3 - 1)) + (1 if sf else 0)) % M\n        else:\n            return (powmod(3, n - 1) + M - (powmod(2, n // 3) + 4 * powmod(8, n // 3 - 1)) + (1 if sf else 0)) % M\n\ndef main():\n    s = input()\n\n    print((solve(s)))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()
# ARC090E\n\ndef hoge():\n    M = 10**9 + 7\n    import sys\n    input = lambda : sys.stdin.readline().rstrip()\n\n    n, m = map(int, input().split())\n    s, t = map(int, input().split())\n    s -= 1\n    t -= 1\n    from collections import defaultdict\n    ns = defaultdict(set)\n    for i in range(m):\n        u, v, d = map(int, input().split())\n        ns[u-1].add((v-1, d))\n        ns[v-1].add((u-1, d))\n    \n    def _dijkstra(N, s, Edge):\n        import heapq\n        geta = 10**15\n        inf = geta\n        dist = [inf] * N\n        dist[s] = 0\n        Q = [(0, s)]\n        dp = [0]*N\n        dp[s] = 1\n        while Q:\n            dn, vn = heapq.heappop(Q)\n            if dn > dist[vn]:\n                continue\n            for vf, df in Edge[vn]:\n                if dist[vn] + df < dist[vf]:\n                    dist[vf] = dist[vn] + df\n                    dp[vf] = dp[vn]\n                    heapq.heappush(Q, (dn + df,vf))\n                elif dist[vn] + df == dist[vf]:\n                    dp[vf] = (dp[vf] + dp[vn]) % M\n        return dist, dp\n\n    def dijkstra(start):\n        import heapq\n        vals = [None] * n\n        nums = [None] * n\n        nums[start] = 1\n        h = [(0, start)] # (, )\n        vals[start] = 0\n        while h:\n            val, u = heapq.heappop(h)\n            for v, d in ns[u]:\n                if vals[v] is None or vals[v]>val+d:\n                    vals[v] = val+d\n                    nums[v] = nums[u]\n                    heapq.heappush(h, (vals[v], v))\n                elif vals[v] is not None and vals[v]==val+d:\n                    nums[v] = (nums[v] + nums[u]) % M\n        return vals, nums\n    \n    vals1, nums1 = dijkstra(s)\n    vals2, nums2 = dijkstra(t)\n    \n    T = vals1[t]\n\n    c1 = 0 # \n    c2 = 0 # ()\n    \n    for u in range(n):\n        if 2*vals1[u]==T and 2*vals2[u]==T:\n            c1 = (c1 + pow((nums1[u] * nums2[u]), 2, M)) % M\n        for v,d in ns[u]:\n            if (vals1[u]+d+vals2[v]==T) and (2*vals1[u] < T < 2*(vals1[u] + d)):\n                c2 = (c2 + (nums1[u] * nums2[v])**2) % M\n    print((nums1[t]*nums2[s] - (c1+c2)) % M)\nhoge()
import sys\n\n\ndef solve(ppp):\n    section_start = -1\n    moved_left_max = 0\n    moved_right_max = 0\n    prev = True\n\n    for i, p in enumerate(ppp, start=1):\n        if i == p:\n            if prev:\n                moved_left_max = 0\n                moved_right_max = 0\n                section_start = -1\n            prev = True\n        else:\n            if not prev:\n                if moved_left_max > i - 1:\n                    return False\n\n                moved_left_max = 0\n                moved_right_max = 0\n                section_start = i\n\n            if section_start == -1:\n                section_start = i\n\n            if i > p:\n                if section_start > p:\n                    return False\n                if moved_right_max > p:\n                    return False\n                moved_right_max = p\n            else:\n                if moved_left_max > p:\n                    return False\n                moved_left_max = p\n\n            prev = False\n    return True\n\n\nn, *ppp = list(map(int, sys.stdin))\nprint(('Yes' if solve(ppp) else 'No'))\n
import sys\n\ninput=sys.stdin.readline\n\nN,M=list(map(int,input().split()))\n\n# N: \nINF = 2**31-1\n\nLV = (M+2-1).bit_length()\nN0 = 2**LV\ndata = [0]*(2*N0)\nlazy = [0]*(2*N0)\n\ndef gindex(l, r):\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & -L).bit_length()\n    rc = 0 if r & 1 else (R & -R).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if L < R and lc <= i:\n            yield L\n        L >>= 1; R >>= 1\n\n# \ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i-1]\n        if not v:\n            continue\n        lazy[2*i-1] += v; lazy[2*i] += v\n        data[2*i-1] += v; data[2*i] += v\n        lazy[i-1] = 0\n\n# [l, r)x\ndef update(l, r, x):\n    *ids, = gindex(l, r)\n    propagates(*ids)\n\n    L = N0 + l; R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R-1] += x; data[R-1] += x\n        if L & 1:\n            lazy[L-1] += x; data[L-1] += x\n            L += 1\n        L >>= 1; R >>= 1\n    for i in ids:\n        data[i-1] = min(data[2*i-1], data[2*i])\n\n# [l, r)\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l; R = N0 + r\n\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = min(s, data[R-1])\n        if L & 1:\n            s = min(s, data[L-1])\n            L += 1\n        L >>= 1; R >>= 1\n    return s\n\nfor i in range(1,M+1):\n    update(0,i+1,1)\n\nadd=M-N\nhito=[]\nfor i in range(N):\n    L,R=list(map(int,input().split()))\n    hito.append((L,R))\nhito.sort()\n#test=[query(i,i+1) for i in range(M+2)]\n#print(test)\nfor l,r in hito:\n    update(0,r+1,-1)\n    #test=[query(i,i+1) for i in range(M+2)]\n    #print(test)\n    m=query(l+1,M+2)+l\n    add=min(m,add)\n\nprint((max(-add,0)))\n
import sys\nfrom collections import deque\n\ninput=sys.stdin.readline\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor i in range(N-1):\n    x,y=list(map(int,input().split()))\n    edge[x-1].append(y-1)\n    edge[y-1].append(x-1)\n\nc=input()[:N]\n\ndeg=[len(edge[i]) for i in range(N)]\nleaf=set([])\nfor i in range(N):\n    if deg[i]==1 and c[i]=="B":\n        leaf.add(i)\n\nban=set([])\nwhile leaf:\n    v=leaf.pop()\n    ban.add(v)\n    deg[v]=0\n    for nv in edge[v]:\n        deg[nv]-=1\n        if deg[nv]==1 and c[nv]=="B":\n            leaf.add(nv)\n\nfor i in range(N):\n    edge[i]=[nv for nv in edge[i] if nv not in ban]\n\nroot=-1\nfor i in range(N):\n    if i not in ban:\n        root=i\n\nparent=[-2]*N\ndeq=deque([(root,-1)])\nnode=[]\nwhile deq:\n    v,pv=deq.popleft()\n    parent[v]=pv\n    node.append(v)\n    for nv in edge[v]:\n        if nv!=pv:\n            deq.append((nv,v))\n\nnode=node[::-1]\n\nfor i in range(N):\n    edge[i]=[nv for nv in edge[i] if nv!=parent[i]]\n\ncheck=True\nfor i in range(N):\n    check&=(deg[i]<=0)\nif check:\n    print((int(c[root]=="W")))\n    return\n\ncond=[0]*N\nfor v in range(N):\n    if (deg[v]%2==1 and c[v]=="B") or (deg[v]%2==0 and c[v]=="W"):\n        cond[v]+=1\n    else:\n        cond[v]-=1\n\nlower=[0]*N\nfor v in node:\n    res=0\n    for nv in edge[v]:\n        res=max(res,lower[nv])\n    res+=1+cond[v]\n    lower[v]=res\n\nupper=[0]*N\nnode=node[::-1]\nfor v in node:\n    n=len(edge[v])\n    if n>1:\n        left=[0]*n\n        right=[0]*n\n        for i in range(n-1):\n            nv=edge[v][i]\n            left[i]=max(left[i-1],lower[nv]+2+cond[v])\n        nv=edge[v][-1]\n        upper[nv]=left[n-2]+cond[nv]\n        right[n-1]=lower[nv]+2+cond[v]\n        for i in range(n-2,0,-1):\n            nv=edge[v][i]\n            upper[nv]=max(left[i-1],right[i+1])+cond[nv]\n            right[i]=max(right[i+1],lower[nv]+2+cond[v])\n        if edge[v][0]!=pv:\n            nv=edge[v][0]\n            upper[nv]=right[1]+cond[nv]\n    if v!=root:\n        for nv in edge[v]:\n            upper[nv]=max(upper[nv],upper[v]+1+cond[nv])\n\nbase=sum(deg[i] for i in range(N))+sum(cond[i]==1 for i in range(N))\n#print(deg)\n#print(base)\n#print(lower)\n#print(upper)\n#print(base)\nprint((base-max(max(upper),max(lower))))\n
import sys\nsys.setrecursionlimit(10**6)\nn = int(input())\np = list(map(int, input().split()))\nc = [[] for _ in range(n)]\nis_leaf = [True for _ in range(n)]\nfor i in range(n):\n	p[i] -= 1\n	c[p[i]].append(i)\n	is_leaf[p[i]] = False\n\nif sum(is_leaf) == 0:\n	if n%2 == 0:\n		print("POSSIBLE")\n	else:\n		print("IMPOSSIBLE")\n	return\n\nfor i in range(n):\n	if is_leaf[i]:\n		cur = i\n		break\n\nvisited_set = {cur}\nvisited_list = [cur]\nwhile p[cur] not in visited_set:\n	visited_list.append(p[cur])\n	visited_set.add(p[cur])\n	cur = p[cur]\n\nroot = p[cur]\n\ngrundy = [-1 for _ in range(n)]\ng_set = [set() for _ in range(n)]\n\ndef dfs(x):\n	res = 0\n	for v in c[x]:\n		dfs(v)\n		g_set[x].add(grundy[v])\n	while res in g_set[x]:\n		res += 1\n	grundy[x] = res\n	return res\n\nloop = [False for _ in range(n)]\nloop[root] = True\nind = len(visited_list)-1\nwhile visited_list[ind] != root:\n	loop[visited_list[ind]] = True\n	ind -= 1\n#print(loop)\n\nfor i in range(n):\n	if loop[i]:\n		for x in c[i]:\n			if not loop[x]:\n				dfs(x)\n				g_set[i].add(grundy[x])\n\ncand = []\nnum = 0\nwhile num in g_set[root]:\n	num += 1\ncand.append(num)\nnum += 1\nwhile num in g_set[root]:\n	num += 1\ncand.append(num)\n\nfor x in cand:\n	cur = root\n	grundy[root] = x\n	while True:\n		num = 0\n		while num in g_set[p[cur]] or num == grundy[cur]:\n			num += 1\n		grundy[p[cur]] = num\n		if p[cur] == root:\n			break\n		cur = p[cur]\n	if grundy[root] == x:\n		#print(grundy)\n		print("POSSIBLE")\n		return\n\nprint("IMPOSSIBLE")
from collections import deque\n\nN, M = list(map(int, input().split()))\nadj = [[1 for _ in range(N + 1)] for _ in range(N + 1)]\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    adj[a][b] = 0\n    adj[b][a] = 0\nadj_inv = [[] for _ in range(N + 1)]\nfor i in range(1, N+1):\n    for j in range(i+1, N+1):\n        if adj[i][j] == 1:\n            adj_inv[i].append(j)\n            adj_inv[j].append(i)\n\nseen = [0] * (N+1)\nnum = []\nfor i in range(1, N+1):\n    if seen[i] == 0:\n        plus = 0\n        minus = 0\n        que = deque()\n        que.append(i)\n        seen[i] = 1\n        plus += 1\n        while que:\n            v = que.pop()\n            u_list = adj_inv[v]\n            for u in u_list:\n                if seen[u] == 0:\n                    que.append(u)\n                    seen[u] = -seen[v]\n                    if seen[u] == 1:\n                        plus += 1\n                    else:\n                        minus += 1\n                else:\n                    if seen[u] == seen[v]:\n                        print((-1))\n                        return\n        num.append((min(plus, minus), max(plus, minus)))\n\nmin_sum = 0\nadd = []\nfor i in range(len(num)):\n    min_sum += num[i][0]\n    add.append(num[i][1] - num[i][0])\n\ndp = [[0 for _ in range((N // 2) + 1)] for _ in range(len(add) + 1)]\ndp[0][min_sum] = 1\nfor i in range(len(add)):\n    for j in range(min_sum, (N // 2) + 1):\n        if dp[i][j] == 1:\n            if j + add[i] <= (N // 2):\n                dp[i+1][j+add[i]] = 1\n            dp[i+1][j] = 1\n\ndp_last = dp[-1]\nfor i in range(len(dp_last)-1, -1, -1):\n    if dp_last[i] == 1:\n        N1 = i\n        break\n\nprint(((N1 * (N1 - 1)) // 2 + ((N - N1) * (N - N1 - 1)) // 2))\n
# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nn,X,Y,Z = list(map(int,read().split()))\n\nN = 1<<(X+Y+Z)\nNX = 1<<X\nNY = 1<<(X+Y)\nNZ = 1<<(X+Y+Z)\n\nMX = (1<<X) - 1\nMY = (1<<(Y+X)) - (1<<X)\nMZ = (1<<(X+Y+Z)) - (1<<(Y+X))\n\nMMX = MX<<1\nMMY = MY<<1\nMMZ = MZ<<1\n\ndp = [0]*N\ndp[1] = 1\n\nMOD = 10**9+7\n\nfor _ in range(n):\n    ndp = [0]*N\n    #cnt = 0\n    #bad = 0\n    for mask in range(N):\n        if dp[mask]==0: continue\n        mx = mask&MX\n        my = mask&MY\n        mz = mask&MZ\n        \n        for j in range(1,11):\n            nmx = mx << j\n            nmx &= MMX\n\n            nmy = my << j\n            nmy &= MMY\n\n            nmz = mz << j\n            nmz &= MMZ\n\n            nmask = nmx|nmy|nmz|1\n            if not nmask&(1<<(X+Y+Z)):\n                ndp[nmask] += dp[mask]\n                ndp[nmask] %= MOD\n\n    dp = ndp\n    #print(sum(dp),"sum")\n\nans = (pow(10,n,MOD)-sum(dp))\nprint((ans%MOD))\n\n\n
import sys\nreadline = sys.stdin.readline\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1]*n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n    \n    def unite(self, u, v):\n        u, v = self.root(u), self.root(v)\n        if u==v:\n            return False\n        if self.size[u] > self.size[v]:\n            u, v = v, u\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u)==self.root(v)\n\nn, m = map(int, readline().split())\nP = list(map(lambda x:int(x)-1, readline().split()))\nuf = UnionFind(n)\nfor _ in range(m):\n    x, y = map(lambda x:int(x)-1, readline().split())\n    uf.unite(x,y)\n\nans = 0\nfor i in range(n):\n    if uf.is_connected(i, P[i]):\n        ans += 1\nprint(ans)
#!/usr/bin/env python3\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    ans = 0\n    for k in range(30):\n        C = [x & ((1 << (k+1)) - 1) for x in A]\n        D = [x & ((1 << (k+1)) - 1) for x in B]\n        C.sort()\n        D.sort()\n        # print(f'k = {k}')\n        # print(f'C = {C}')\n        # print(f'D = {D}')\n        p, q, r = 0, 0, 0\n        for i in range(N-1, -1, -1):\n            while p < N:\n                if C[i] + D[p] >= 1 << k: break\n                p += 1\n            while q < N:\n                if C[i] + D[q] >= 2 << k: break\n                q += 1\n            while r < N:\n                if C[i] + D[r] >= 3 << k: break\n                r += 1\n            x = ((q - p) + (N - r)) % 2\n            # print(p, q, r, x)\n            ans = ans ^ (x << k)\n    print(ans)\n\nmain()\n
t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    l = [int(x) for x in input().split()]\n    vals = [(x + i) % n for i, x in enumerate(l)]\n    print("YES" if len(set(vals)) == n else "NO")\n
n, r = [int(x) for x in input().split()]\n\nn = 2 ** n\n\nxs = [int(x) for x in input().split()]\n\ns = sum(xs)\n\nres = [0 for _ in range(r+1)]\nfor i in range(r):\n    res[i] = s / n\n    i, val = [int(x) for x in input().split()]\n    s += val - xs[i]\n    xs[i] = val\nres[r] = s / n\nprint("\n".join(map(str, res)))\n
import sys\ninput = sys.stdin.readline\n\nMOD = 10 ** 9 + 7\n\nt = int(input())\nfor _ in range(t):\n    n, p = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    if p == 1:\n        print(n % 2)\n    else:\n        l.sort(reverse = True)\n        curr = l[0]\n        out = 0\n        real = True\n\n        for v in l:\n            if v < curr:\n                diff = curr - v\n                if 10 ** (7/diff) < p and out > 0:\n                    real = False\n                out *= pow(p, diff, MOD)\n                if out > 10 ** 7:\n                    real = False\n                out %= MOD\n\n                curr = v\n            if out > 0 or not real:\n                out -= 1\n            else:\n                out += 1\n            out %= MOD\n\n        out *= pow(p, curr, MOD)\n        print(out % MOD)\n
rnd_mod = 1234567890133\nrnd_x = 987654321098\ndef rnd():\n    nonlocal rnd_x\n    rnd_x = rnd_x**2 % rnd_mod\n    return (rnd_x>>5) % (1<<20)\ndef randrange(a):\n    return rnd() % a\n\nT = int(input())\nfor _ in range(T):\n    N, M = list(map(int, input().split()))\n    X = []\n    for __ in range(N):\n        X.append([int(a) for a in input().split()])\n    Y = [[X[i][j] for i in range(N)] for j in range(M)]\n    ma = 0\n    for t in range(577):\n        for i in range(M):\n            a = randrange(N)\n            Y[i] = [Y[i][j-a] for j in range(N)]\n        ma = max(ma, sum([max([Y[i][j] for i in range(M)]) for j in range(N)]))\n    print(ma)\n
import sys\n				\ninp = [int(x) for x in sys.stdin.read().split()]\n\nn, m, q = inp[0], inp[1], inp[2]\n\np = [inp[idx] for idx in range(3, n + 3)]\n\nindex_arr = [0] * (n + 1)\nfor i in range(n):	index_arr[p[i]] = i\n\na = [inp[idx] for idx in range(n + 3, n + 3 + m)]\n\nleftmost_pos = [m] * (n + 1)\nnext = [-1] * m\n\nfor i in range(m - 1, -1, -1):\n	index = index_arr[a[i]]\n	right_index = 0 if index == n - 1 else index + 1\n	right = p[right_index]\n	next[i] = leftmost_pos[right]\n	leftmost_pos[a[i]] = i\n	\nlog = 0\nwhile (1 << log) <= n: log += 1\nlog += 1\ndp = [[m for _ in range(m + 1)] for  _ in range(log)]\n\nfor i in range(m):\n	dp[0][i] = next[i]\n\nfor j in range(1, log):\n	for i in range(m):\n		dp[j][i] = dp[j - 1][dp[j - 1][i]]\n\nlast = [0] * m\nfor i in range(m):\n	p = i\n	len = n - 1\n	for j in range(log - 1, -1, -1):\n		if (1 << j) <= len:\n			p = dp[j][p]\n			len -= (1 << j)\n	last[i] = p\n	\nfor i in range(m - 2, -1, -1):\n	last[i] = min(last[i], last[i + 1])\n	\ninp_idx = n + m + 3\nans = []\nfor i in range(q):\n	l, r = inp[inp_idx] - 1, inp[inp_idx + 1] - 1\n	inp_idx += 2\n	if last[l] <= r:\n		ans.append('1')\n	else:\n		ans.append('0')\nprint(''.join(ans))
n = int(input())\nrows = [input().split() for _ in range(n)]\nrows = [(int(x),int(y)) for x,y in rows]\npoints = {}\nfor x,y in rows:\n    if x in points:\n        points[x] = max(y, points[x])\n    else:\n        points[x] = y\npoints = sorted(points.items(),key=lambda point: point[0])\n\n\ndef above(p,p1,p2):\n    """\n    x1 < x2\n    y1 = x1^2 + bx1 + c\n    y2 = x2^2 + bx2 + c\n    y >? x^2 + bx + c\n\n    y2 - y1 = x2^2 - x1^2 + bx2 - bx1\n    b = (y2 - y1 - x2^2 + x1^2) / (x2 - x1)\n    b * (x2 - x1) = y2 - y1 - x2^2 + x1^2\n\n    c = y1 - x1^2 - bx1\n    c * (x2 - x1) = (y1 - x1^2) * (x2 - x1) - x1 * (y2 - y1 - x2^2 + x1^2)\n\n    y * (x2 - x1) >? (x^2 + bx + c) * (x2 - x1)\n    y * (x2 - x1) >?\n        x^2 * (x2 - x1)\n        + x * (y2 - y1 - x2^2 + x1^2)\n        + (y1 - x1^2) * (x2 - x1) - x1 * (y2 - y1 - x2^2 + x1^2)\n    """\n    x,y = p\n    x1,y1 = p1\n    x2,y2 = p2\n\n    x_2 = x**2\n    x12 = x1**2\n    x22 = x2**2\n    x2_x1 = x2 - x1\n    eq_b = y2 - y1 - x22 + x12\n\n    term_y = y * x2_x1\n    term_x2 = x_2 * x2_x1\n    term_x = x * eq_b\n    term_c = (y1 - x12) * x2_x1 - (x1 * eq_b)\n\n    return term_y >= term_x2 + term_x + term_c\n\n#print(above(points[2],points[0],points[1]))\n\n\nUs = []\nfor i, p in enumerate(points):\n    while len(Us) >= 2:\n        p1, p2 = Us[-2:]\n        if above(p,p1,p2):\n            Us.pop()\n        else:\n            break\n    Us.append(p)\n\nout = len(Us) - 1\nprint(out)
import os\nimport sys\nfrom io import BytesIO, IOBase\n\n\ndef main():\n    pass\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = "x" in file.mode or "r" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b"\n") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode("ascii"))\n        self.read = lambda: self.buffer.read().decode("ascii")\n        self.readline = lambda: self.buffer.readline().decode("ascii")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip("\r\n")\n\nprimes = []\nprime = [True] * (10 ** 6  +5)\nprime[0] = False\n\nfor i in range(2, 10 ** 6):\n    if prime[i]:\n        for j in range(2 * i, 10 ** 6 + 5, i):\n            prime[j] = False\n\npref = [0]\nfor i in range(1, 10 ** 6 + 5):\n    pref.append(pref[-1])\n    if prime[i]:\n        pref[-1] += 1\n    s = round(i ** .5)\n    if  s * s == i and prime[s] and i != 1:\n        pref[-1] -= 1\n\nn = int(input())\nl = list(map(int, input().split()))\nout = []\nfor v in l:\n    out.append(pref[v])\nprint('\n'.join(map(str,out)))\n
import sys\nreadline = sys.stdin.readline\nfrom itertools import accumulate\nfrom collections import Counter\nfrom bisect import bisect as br, bisect_left as bl\nclass PMS:\n    #1-indexed\n    def __init__(self, A, B, issum = False):\n        #A,B\n        self.X, self.comp = self.compress(B)\n        self.size = len(self.X)\n        self.tree = [0] * (self.size + 1)\n        self.p = 2**(self.size.bit_length() - 1)\n        self.dep = self.size.bit_length()\n        \n        CA = Counter(A)\n        S = [0] + list(accumulate([CA[self.X[i]] for i in range(self.size)]))\n        for i in range(1, 1+self.size):\n            self.tree[i] = S[i] - S[i - (i&-i)]\n        if issum:\n            self.sumtree = [0] * (self.size + 1)\n            Ssum = [0] + list(accumulate([CA[self.X[i]]*self.X[i] for i in range(self.size)]))\n            for i in range(1, 1+self.size):\n                self.sumtree[i] = Ssum[i] - Ssum[i - (i&-i)]\n    \n    def compress(self, L):\n        #\n        L2 = list(set(L))\n        L2.sort()\n        C = {v : k for k, v in enumerate(L2, 1)}\n        # 1-indexed\n        return L2, C\n    \n    def leng(self):\n        #\n        return self.count(self.X[-1])\n    \n    def count(self, v):\n        #v(B)\n        i = self.comp[v]\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n    \n    def less(self, v):\n        #v(B)\n        i = bl(self.X, v)\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n    \n    def leq(self, v):\n        #v(B)\n        i = br(self.X, v)\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n \n    def add(self, v, x):\n        #vx,x,i\n        i = self.comp[v]\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\n    def get(self, i):\n        # i\n        if i <= 0:\n            return -1\n        s = 0\n        k = self.p\n        for _ in range(self.dep):\n            if s + k <= self.size and self.tree[s+k] < i:\n                s += k\n                i -= self.tree[s]\n            k //= 2\n        return self.X[s]\n    \n    def gets(self, v):\n        #vindex\n        v1 = v\n        s = 0\n        k = self.p\n        for _ in range(self.dep):\n            if s + k <= self.size and self.sumtree[s+k] < v:\n                s += k\n                v -= self.sumtree[s]\n            k //= 2\n        if s == self.size:\n            return self.leng()\n        return self.count(self.X[s]) + (v1 - self.countsum(self.X[s]))//self.X[s]\n    \n    def addsum(self, i, x):\n        #sumadd\n        self.add(i, x)\n        x *= i\n        i = self.comp[i]\n        while i <= self.size:\n            self.sumtree[i] += x\n            i += i & -i\n    \n    def countsum(self, v):\n        #v(B)sum\n        i = self.comp[v]\n        s = 0\n        while i > 0:\n            s += self.sumtree[i]\n            i -= i & -i\n        return s\n    \n    def getsum(self, i):\n        #isum\n        x = self.get(i)\n        return self.countsum(x) - x*(self.count(x) - i)\n    \nN, Q = map(int, readline().split())\nP = list(map(int, readline().split()))\nMOD = 998244353\nT = [100*pow(pi, MOD-2, MOD)%MOD for pi in P]\n\nAT = [None]*N\nAT[0] = T[0]\nfor i in range(1, N):\n    AT[i] = (AT[i-1]+1)*T[i]%MOD\nAM = [None]*N\nAMi = [None]*N\nAM[0] = T[0]\nfor i in range(1, N):\n    AM[i] = AM[i-1]*T[i]%MOD\nAMi[N-1] = pow(AM[N-1], MOD-2, MOD)\nfor i in range(N-2, -1, -1):\n    AMi[i] = AMi[i+1]*T[i+1]%MOD\nAT += [0]\nAM += [1]\nAMi += [1]\n\nAns = [None]*Q\nkk = set([0, N])\nPM = PMS([0, N], list(range(N+1)))\nans = AT[N-1]\nfor qu in range(Q):\n    f = int(readline()) - 1\n    if f not in kk:\n        kk.add(f)\n        PM.add(f, 1)\n        fidx = PM.count(f)\n        fm = PM.get(fidx-1)\n        fp = PM.get(fidx+1)\n        am = (AT[f-1] - AM[f-1]*AMi[fm-1]*AT[fm-1])%MOD\n        ap = (AT[fp-1] - AM[fp-1]*AMi[f-1]*AT[f-1])%MOD\n        aa = (AT[fp-1] - AM[fp-1]*AMi[fm-1]*AT[fm-1])%MOD\n        ans = (ans - aa + am + ap)%MOD\n    else:\n        kk.remove(f)\n        fidx = PM.count(f)\n        fm = PM.get(fidx-1)\n        fp = PM.get(fidx+1)\n        PM.add(f, -1)\n        am = (AT[f-1] - AM[f-1]*AMi[fm-1]*AT[fm-1])%MOD\n        ap = (AT[fp-1] - AM[fp-1]*AMi[f-1]*AT[f-1])%MOD\n        aa = (AT[fp-1] - AM[fp-1]*AMi[fm-1]*AT[fm-1])%MOD\n        ans = (ans + aa - am - ap)%MOD\n    Ans[qu] = ans\nprint('\n'.join(map(str, Ans)))
class BIT():\n    """O(logN)\n    add: [begin, end)val\n    get_val: i(0-indexed)\n    """\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def get_val(self, i):\n        i = i + 1\n        s = 0\n        while i <= self.n:\n            s += self.bit[i]\n            i += i & -i\n        return s\n\n    def _add(self, i, val):\n        while i > 0:\n            self.bit[i] += val\n            i -= i & -i\n\n    def add(self, i, j, val):\n        self._add(j, val)\n        self._add(i, -val)\n\n\nfrom collections import deque\nimport sys\ninput = sys.stdin.readline\n\n\ndef eular_tour(tree: list, root: int):\n    """\n    pos[begin[pos], end[pos])\n    """\n    n = len(tree)\n    res = []\n    begin = [-1] * n\n    end = [-1] * n\n    visited = [False] * n\n    visited[root] = True\n    q = deque([root])\n    while q:\n        pos = q.pop()\n        res.append(pos)\n        end[pos] = len(res)\n        if begin[pos] == -1:\n            begin[pos] = len(res) - 1\n        for next_pos in tree[pos]:\n            if visited[next_pos]:\n                continue\n            else:\n                visited[next_pos] = True\n                q.append(pos)\n                q.append(next_pos)\n\n    return res, begin, end\n\nn, q = map(int, input().split())\ninit_cost = list(map(int, input().split()))\ninfo = [list(map(int, input().split())) for i in range(n-1)]\nquery = [list(map(int, input().split())) for i in range(q)]\n\ntree = [[] for i in range(n)]\nfor i in range(n-1):\n    a, b = info[i]\n    a -= 1\n    b -= 1\n    tree[a].append(b)\n    tree[b].append(a)\n\nres, begin, end = eular_tour(tree, 0)\neven_res = []\nodd_res = []\nfor i in range(len(res)):\n    if i % 2 == 0:\n        even_res.append(res[i])\n    else:\n        odd_res.append(res[i])\n\neven_bit = BIT(len(even_res))\nodd_bit = BIT(len(odd_res))\n\nfor i in range(q):\n    if query[i][0] == 1:\n        _, pos, cost = query[i]\n        pos -= 1\n        if begin[pos] % 2 == 0:\n            even_bit.add(begin[pos] // 2, (end[pos] + 1) // 2, cost)\n            odd_bit.add(begin[pos] // 2, end[pos] // 2, -cost)    \n        else:\n            odd_bit.add(begin[pos] // 2, end[pos] // 2, cost) \n            even_bit.add((begin[pos] + 1) // 2, end[pos] // 2, -cost) \n    else:\n        _, pos = query[i]\n        pos -= 1\n        if begin[pos] % 2 == 0:\n            ans = even_bit.get_val(begin[pos] // 2)\n        else:\n            ans = odd_bit.get_val(begin[pos] // 2)\n        print(ans + init_cost[pos])
n =int(input())\nw=[]\nh=[]\nc=[]\ncntw={}\ncnth={}\ngcdC=0\ncntC=0\ndef insert1(a,b,c):\n	if not a in b :\n		b[a]=c\n	else :\n		b[a]=b[a]+c\n\ndef gcd(a,b): \n	if a % b == 0 :\n		return b\n	else :\n		return gcd(b,a%b)\n\nfor i in range(0, n):\n	a,b,d = map(int,input().split())\n	w.append(a)\n	h.append(b)\n	c.append(d)\n	insert1(a,cntw,d)\n	insert1(b,cnth,d)\n	cntC += d\n	if gcdC == 0 :\n		gcdC = d\n	else :\n		gcdC = gcd(gcdC, d)\n\nfor i in range(0, n):\n	if cntw[w[i]] * cnth[h[i]] != cntC * c[i]:\n		print (0)\n		return\n\nans = 0\ni = 1\nwhile (i * i <= gcdC) :\n	if gcdC % i == 0 :\n		ans += 1\n		if i * i != gcdC :\n			ans += 1\n	i += 1\n\nprint (ans)
from sys import stdin\nfrom collections import deque\ndef NC_Dij(lis,start):\n\n    ret = [float("inf")] * len(lis)\n    ret[start] = 0\n    \n    q = deque([start])\n    plis = [i for i in range(len(lis))]\n\n    while len(q) > 0:\n        now = q.popleft()\n\n        for nex in lis[now]:\n\n            if ret[nex] > ret[now] + 1:\n                ret[nex] = ret[now] + 1\n                plis[nex] = now\n                q.append(nex)\n\n    return ret,plis\n\ntt = int(stdin.readline())\n\nfor loop in range(tt):\n\n    n,a,b,da,db = list(map(int,stdin.readline().split()))\n    N = n\n    a -= 1\n    b -= 1\n    lis = [ [] for i in range(n)]\n\n    for i in range(n-1):\n        u,v = list(map(int,stdin.readline().split()))\n        u -= 1\n        v -= 1\n        lis[u].append(v)\n        lis[v].append(u)\n\n    if 2*da >= db:\n        print ("Alice")\n        continue\n\n    fa,tmp = NC_Dij(lis,a)\n    if fa[b] <= da:\n        print ("Alice")\n        continue\n\n    mv = 0\n    for i in range(N):\n        if fa[i] > fa[mv]:\n            mv = i\n\n    fv,tmp = NC_Dij(lis,mv)\n    if max(fv) <= 2*da:\n        print ("Alice")\n    else:\n        print ("Bob")\n    \n
import sys\nreadline = sys.stdin.readline\n\nS = list([ord(x)-97 for x in readline().strip()])\nN = len(S)\ntable = [[0]*26 for _ in range(N)]\nfor i in range(N):\n    table[i][S[i]] = 1\nfor i in range(1, N):\n    for j in range(26):\n        table[i][j] += table[i-1][j]\n\nQ = int(readline())\nAns = [None]*Q\nfor qu in range(Q):\n    l, r = list(map(int, readline().split()))\n    l -= 1\n    r -= 1 \n    if l == r or S[l] != S[r]:\n        Ans[qu] = True\n        continue\n    K = [table[r][j] - table[l][j] for j in range(26)]\n    if len([k for k in K if k]) <= 2:\n        Ans[qu] = False\n    else:\n        Ans[qu] = True\nprint('\n'.join(['Yes' if s else 'No' for s in Ans]))\n
for __ in range(int(input())):\n    n = int(input())\n    s = list(map(int, input()))\n    r = [0] * n\n    for i in range(10):\n        left_lim = 0\n        for j, c in enumerate(s):\n            if c < i: left_lim = j + 1\n        prv = [-1, -1, -1]\n        flg = True\n        for j, c in enumerate(s):\n            r[j] = 1 if c < i or (c == i and j >= left_lim) else 2\n            if c < prv[r[j]]: flg = False; break\n            prv[r[j]] = c\n        if flg:\n            print(''.join(map(str, r)))\n            break\n    if not flg:\n        print('-')
k,n = map(int,input().split())\nif k %2 ==0:\n  ans = []\n  ans.append(k//2)\n  for i in range(n-1):\n    ans.append(k)\n  print(*ans)\nelse:\n  ans = []\n  for i in range(n):\n    ans.append(k//2+1)\n  sage = (n)//2\n  for i in range(sage):\n    if ans[-1] == 1:\n      ans.pop()\n    else:\n      ans[-1] -= 1\n      while len(ans) < n:\n        ans.append(k)\n  print(*ans)
import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nfrom collections import deque\nN = int(input())\nX = [[] for i in range(N)]\nfor i in range(N-1):\n    x, y = map(int, input().split())\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n\nY = [(-10**9, 10**9) for _ in range(N)]\nK = int(input())\nfor _ in range(K):\n    v, p = map(int, input().split())\n    Y[v-1] = (p, p)\n\nP = [-1] * N\nQ = deque([0])\nR = []\nwhile Q:\n    i = deque.popleft(Q)\n    R.append(i)\n    for a in X[i]:\n        if a != P[i]:\n            P[a] = i\n            X[a].remove(i)\n            deque.append(Q, a)\n\n\ndef calc():\n    for i in R[::-1]:\n        e, o = 0, 0\n        l, r = Y[i]\n        if r != 10 ** 9:\n            if l % 2:\n                o = 1\n            else:\n                e = 1\n        for j in X[i]:\n            a, b = Y[j]\n            if b == 10**9: continue\n            if a % 2:\n                e = 1\n            else:\n                o = 1\n            l = max(l, a - 1)\n            r = min(r, b + 1)\n        if (e and o) or (l > r):\n            print("No")\n            return 0\n        elif e or o:\n            Y[i] = (l, r)\n    \n    for i in R[1:]:\n        if Y[P[i]][0] - 1 >= Y[i][0]:\n            Y[i] = (Y[P[i]][0] - 1, 0)\n        else:\n            Y[i] = (Y[P[i]][0] + 1, 0)\n    \n    print("Yes")\n    for i in range(N):\n        print(Y[i][0])\n\ncalc()
import bisect\ndef inpl(): return [int(i) for i in input().split()]\n\nX = int(input())\nK = int(input())\nr = [0] + inpl()\nstu = [()]*(K+1)\nstu[0] = (X, 0, 0)\nfor i, v in enumerate(r[1:], 1):\n    s, t, u = stu[i-1]\n    if i%2:\n        rs = r[i-1] - r[i]\n        ap = - rs - t\n        if ap >= s:\n            stu[i] = 0, 0, 0\n        elif ap >= u:\n            stu[i] = s, t+rs, ap\n        else:\n            stu[i] = s, t+rs, u\n    else:\n        rs = r[i] - r[i-1]\n        ap = X - rs - t\n        if ap >= s:\n            stu[i] = s, t+rs, u\n        elif ap >= u:\n            stu[i] = ap, t+rs, u\n        else:\n            stu[i] = X, 0, X\nQ = int(input())\nfor _ in range(Q):\n    ti, a = inpl()\n    x = bisect.bisect_right(r, ti)\n    ti -= r[x-1]\n    s, t, u = stu[x-1]\n    if a >= s:\n        R = s + t\n    elif a >= u:\n        R = a + t\n    else:\n        R = u + t\n    if x % 2:\n        print(max(0, R - ti))\n    else:\n        print(min(X, R + ti))
A = [ord(a)-97 for a in input()]\nN = len(A)\nX = [0] * 26\nY = [0] * (N + 2)\nNE = [0] * N\nR = [N] * 26\ns = 0\nt = 1\nfor i in range(N)[::-1]:\n    a = A[i]\n    if X[a] == 0:\n        X[a] = 1\n        s += 1\n        if s == 26:\n            s = 0\n            X = [0] * 26\n            t += 1\n    Y[i] = t\n    NE[i] = R[a]\n    R[a] = i\n\nANS = []\nii = 0\nfor i, a in enumerate(A):\n    if i == ii:\n        for j in range(26):\n            if Y[R[j]+1] < Y[i]:\n                ANS.append(j)\n                ii = R[j]+1\n                break\n    R[a] = NE[i]\n\nprint("".join([chr(a+97) for a in ANS]))
import sys\ndef input():\n	return sys.stdin.readline()[:-1]\n\nH, W = map(int, input().split())\ns = [input() for _ in range(H)]\nans = max(H, W)\n\ndef max_rect(a):\n	res = 0\n	stack = [a[0]]\n	for i in range(1, W-1):\n		new_pos = i\n		while stack and stack[-1] % 10000 >= a[i]:\n			pos, hght = stack[-1] // 10000, stack[-1] % 10000\n			res = max(res, (i - pos + 1) * (hght + 1))\n			new_pos = pos\n			stack.pop()\n		stack.append(new_pos * 10000 + a[i])\n	while stack:\n		pos, hght = stack[-1] // 10000, stack[-1] % 10000\n		res = max(res, (W - pos) * (hght + 1))\n		stack.pop()\n	return res\n\ndp = [[0 for _ in range(W-1)] for _ in range(H-1)]\n\nfor j in range(W-1):\n	if not ((s[0][j] == s[1][j]) ^ (s[0][j+1] == s[1][j+1])):\n		dp[0][j] = 1\nans = max(ans, max_rect(dp[0]))\n\nfor i in range(1, H-1):\n	for j in range(W-1):\n		if not ((s[i][j] == s[i+1][j]) ^ (s[i][j+1] == s[i+1][j+1])):\n			dp[i][j] = dp[i-1][j] + 1\n	ans = max(ans, max_rect(dp[i]))\n\nprint(ans)
from collections import defaultdict\nN = int(input())\nC = defaultdict(int)\nfor i in range(N):\n  D = int(input())\n  C[D] = i + 1\nE = []\nH = [1] * (N + 1)\nDD = sorted([[k, v] for k, v in C.items()], reverse=True)\nAdj = [[] for i in range(N)]\nfor D, n in DD[:-1]:\n  try:\n    p = C[D - N + 2 * H[n]]\n    if n == p:\n      raise Error\n    E.append([n, p])\n    Adj[n - 1].append(p - 1)\n    Adj[p - 1].append(n - 1)\n    H[p] += H[n]\n  except:\n    print(-1)\n    break\nelse:\n  dist = [N] * N\n  dist[DD[-1][1] - 1] = 0\n  Q = [DD[-1][1] - 1] + [N] * N\n  tail = 1\n  for i in range(N):\n    s = Q[i]\n    if s == N:\n      print(-1)\n      break\n    for adj in Adj[s]:\n      if dist[adj] == N:\n        dist[adj] = dist[s] + 1\n        Q[tail] = adj\n        tail += 1\n  else:\n    if sum(dist) == DD[-1][0]:\n      for e in E:\n        print(e[0], e[1])\n    else:\n      print(-1)
w=list(input());n=len(w);t=-1\ndef Z(s):\n    m=len(s);z=[0]*m;c=0;f=[1]*m;\n    for i in range(1,m):\n        if i+z[i-c]<c+z[c]:z[i]=z[i-c]\n        else:\n            j=max(0,c+z[c]-i)\n            while i+j<n and s[j]==s[i+j]:j=j+1\n            z[i]=j;c=i\n    for p in range(1,m):\n        for k in range(2,z[p]//p+2):f[k*p-1]=0\n    return f\nfor j in range(1,n//2+1):\n    if n%j==0 and w[:n-j]==w[j:]:t=j;break;\nif t==-1:print ('1\n1')\nelif t==1:print (n);print((1))\nelse:\n    zl=Z(w)\n    w.reverse()\n    zr=Z(w)\n    cnt=0\n    for i in range(0,n-1):\n        if zl[i] and zr[n-2-i]:cnt=cnt+1\n    print((2));print(cnt);\n
j=n=1<<int(input())\na=[[0,int(s)]for s in input().split()]\nwhile j>1:j>>=1;a=[sorted(a[i]+a[i^j]*(i&j>0))[-2:]for i in range(n)]\nfor s,f in a[1:]:j=max(j,s+f);print(j)
import sys\ndef input():\n	return sys.stdin.readline()[:-1]\n\nn = int(input())\nd = []\nM, m = 0, 10**30\nM_of_m, m_of_M = 0, 10**30\nfor _ in range(n):\n	x, y = map(int, input().split())\n	g, l = max(x, y), min(x, y)\n	d.append([l, g])\n	M = max(M, g)\n	m = min(m, l)\n	M_of_m = max(M_of_m, l)\n	m_of_M = min(m_of_M, g)\nans1 = (M - m_of_M) * (M_of_m - m)\n\nM_other, m_other = M_of_m, m\nm_reversed = 10**30\ngap = M_other - m_other\nd.sort(key=min)\nfor i in range(n-1):\n	M_other = max(M_other, d[i][1])\n	m_reversed = min(m_reversed, d[i][1])\n	m_other = min(m_reversed, d[i+1][0])\n	gap = min(gap, M_other - m_other)\nM_other = max(M_other, d[n-1][1])\nm_reversed = min(m_reversed, d[i][1])\ngap = min(gap, M_other - m_reversed)\nans2 = (M - m) * gap\n\n#print(ans1, ans2)\nprint(min(ans1, ans2))
#from collections import deque,defaultdict\nprintn = lambda x: print(x,end='')\ninn = lambda : int(input())\ninl   = lambda: list(map(int, input().split()))\ninm   = lambda:      map(int, input().split())\nins = lambda : input().strip()\nDBG = True # and False\nBIG = 10**18\nR = 10**9 + 7\n#R = 998244353\n\ndef ddprint(x):\n  if DBG:\n    print(x)\n\nn = inn()\na = []\nb = []\nxb = 10**9+1\nfor i in range(n):\n    aa,bb = inm()\n    a.append(aa)\n    b.append(bb)\n    if aa>bb and xb>bb:\n        xb = bb\n        xi = i\nif n==-2 and a[0]==1:\n    3/0\nprint(0 if xb>10**9 else sum(a)-b[xi])\n
import collections\n\n\nclass Bit():\n    def __init__(self, l):\n        self.size = l\n        self.bit = [0] * (self.size+1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.bit[i] += x\n            i += i & -i\n\n    def __str__(self):\n        return str(self.bit)\n\n\nS = str(input())\nN = len(S)\nindex = collections.defaultdict(list)\n\nfor i, c in enumerate(S):\n    index[c].append(i)\n\nctr = N // 2\nB = [0] * N\nflag = 0\nP = []\n\nfor c, k in list(index.items()):\n    cnt = len(k)\n    if cnt % 2:\n        if flag == 1:\n            print((-1))\n            return\n        flag = 1\n        B[k[cnt // 2]] = ctr + 1\n    for i in range(cnt // 2):\n        l, r = k[i], k[-(i+1)]\n        P.append((l, r))\n\nP.sort()\n\nfor i, (l, r) in enumerate(P):\n    B[l], B[r] = i + 1, N - i\n\nans = 0\nbit = Bit(N)\nfor i, b in enumerate(B):\n    ans += i - bit.sum(b)\n    bit.add(b, 1)\n\nprint(ans)\n
class dsu:\n    def __init__(self, n=0):\n        self._n = n\n        self.parent_or_size = [-1] * n\n    \n    def merge(self, a: int, b: int) -> int:\n        x = self.leader(a)\n        y = self.leader(b)\n        if x == y:\n            return x\n        if self.parent_or_size[x] > self.parent_or_size[y]:\n            x, y = y, x\n        self.parent_or_size[x] += self.parent_or_size[y]\n        self.parent_or_size[y] = x\n        return x\n    \n    def same(self, a: int, b: int) -> bool:\n        return self.leader(a) == self.leader(b)\n    \n    def leader(self, a: int) -> int:\n        x = a\n        while self.parent_or_size[x] >= 0:\n            x = self.parent_or_size[x]\n        while a != x:\n            self.parent_or_size[a], a = x, self.parent_or_size[a]\n        return x\n    \n    def size(self, a: int) -> int:\n        return -self.parent_or_size[self.leader(a)]\n    \n    def groups(self):\n        g = [[] for _ in range(self._n)]\n        for i in range(self._n):\n            g[self.leader(i)].append(i)\n        return list(c for c in g if c)\n\nn, m = list(map(int, input().split()))\nvdata = [] # (required, gain)\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    vdata.append((max(a - b, 0), b))\nto = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = list(map(int, input().split()))\n    u -= 1; v -= 1\n    to[u].append(v)\n    to[v].append(u)\ns = dsu(n)\ndp = vdata.copy() # (extra, tot_gain)\nvisited = [False] * n\nfor u in sorted(list(range(n)), key=lambda i: vdata[i][0]):\n    req, gain = vdata[u]\n    frm = {u}\n    for v in to[u]:\n        if visited[v]:\n            frm.add(s.leader(v))\n    mnextra = 10 ** 18\n    for v in frm:\n        e, g = dp[v]\n        e += max(req - (e + g), 0)\n        if e < mnextra:\n            mnextra, mni = e, v\n    extra, tot_gain = mnextra, sum(dp[v][1] for v in frm)\n    for v in frm:\n        s.merge(u, v)\n    dp[s.leader(u)] = extra, tot_gain\n    visited[u] = True\nans = sum(dp[s.leader(0)])\nprint(ans)\n
N,T = list(map(int,input().split()))\nA = list(map(int,input().split()))\n\ncummax = [A[-1]]\nfor a in reversed(A[:-1]):\n    cummax.append(max(cummax[-1], a))\ncummax.reverse()\n\nmaxgain = n = 0\nfor buy,sell in zip(A,cummax):\n    gain = sell - buy\n    if gain > maxgain:\n        maxgain = gain\n        n = 1\n    elif gain == maxgain:\n        n += 1\nprint(n)\n
import sys\ninput = sys.stdin.readline\nimport numpy as np\nfrom heapq import heappush, heappop\n\nN = int(input())\nA = np.array(input().split(), dtype=np.int32)\na_to_i = {a:i for i,a in enumerate(A)}\n\n# sparse table RMQ\n# parity\n\nU = len(A).bit_length()\nsp = [None,A]\nfor i in range(2,U):\n    L = 1 << (i-1)\n    sp.append(np.minimum(sp[-1][:-L], sp[-1][L:]))\n\ndef RMQ(x,y):\n    # x[x,y]\n    d = y - x\n    if d <= 1:\n        return A[x]\n    n = d.bit_length()\n    return min(sp[n-1][x], sp[n-1][y+2-(1<<(n-1))])\n\ndef F(x,y):\n    # 2\n    # \n    x1 = RMQ(x,y-1)\n    i1 = a_to_i[x1]\n    x2 = RMQ(i1+1,y)\n    i2 = a_to_i[x2]\n    task = ((x,y) for x,y in ((x,i1-1), (i1+1,i2-1), (i2+1,y)) if y > x)\n    return x1,x2,task\n\nq = [(None,None,((0,N-1),))]\nanswer = []\nwhile q:\n    x,y,task = heappop(q)\n    answer.append(x)\n    answer.append(y)\n    for left,right in task:\n        heappush(q,F(left,right))\n\nprint(' '.join(map(str,answer[2:])))
# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nn, = list(map(int, readline().split()))\np = [-1] + [*list(map(int, readline().split()))]\n\nMOD = 10**9+7\nchild = [[] for i in range(n+1)]\ntot = [None for i in range(n+1)]\none = [None for i in range(n+1)]\ndep = [0]*(n+1)\np2 = [1]*(n+1)\nfor i in range(n):\n    p2[i+1] = p2[i]*2%MOD\n\nfor v in range(n,-1,-1):\n    if dep[v]==0:\n        tot[v] = []\n        one[v] = []\n    else:\n        child[v].sort(key=lambda i: dep[i])\n        one[v] = one[child[v][-1]]\n        tot[v] = tot[child[v][-1]]\n        #one_sum = [0]*(dep[v])\n        #zero_sum = [0]*(dep[v])\n        child[v].pop()\n        if child[v]:\n            zero = [p2[tot[v][j]]-one[v][j] for j in range(-len(one[child[v][-1]]),0)]\n        for c in child[v]:\n            for j in range(-len(one[c]),0):\n                z = p2[tot[c][j]]-one[c][j]\n                one[v][j] = (one[v][j]*z+zero[j]*one[c][j])%MOD\n                zero[j] = zero[j]*z%MOD\n                tot[v][j] += tot[c][j]\n\n    tot[v].append(1)\n    one[v].append(1)\n\n    child[p[v]].append(v)\n    dep[p[v]] = max(dep[p[v]],dep[v]+1)        \n\n    #print(v,tot[v],one[v])\n        \n#print("tot",tot[0])\n#print("one",one[0])\n\nans = 0\nfor i,j in zip(tot[0],one[0]):\n    ans += pow(2,n+1-i,MOD)*j%MOD\n\nprint((ans%MOD))\n#print(sum(tot[0]))\n
# \nfrom collections import deque\nimport sys\n\ndef MI(): return list(map(int, sys.stdin.readline().split()))\n\nclass water:\n    def __init__(self, t, v):\n        self.v = v\n        self.tv = v * t\n\n    def __le__(self, other):\n        return self.v * other.tv - self.tv * other.v >= 0\n\n    def __isub__(self, other):\n        t = self.tv / self.v\n        self.v -= other\n        self.tv = t * self.v\n        return self\n\n    def __iadd__(self, other):\n        self.v+=other.v\n        self.tv+=other.tv\n        return self\n\ndef main():\n    n, l = MI()\n    dam = deque()\n    t, v = MI()\n    print(t)\n    dam.append(water(t, v))\n    # stvtvvlvt\n    stv = t * v\n    for _ in range(n-1):\n        t, v = MI()\n        # \n        dam.appendleft(water(t, v))\n        over = v\n        stv += t * v\n        # \n        # \n        while dam[-1].v <= over:\n            w = dam.pop()\n            over -= w.v\n            stv -= w.tv\n        # \n        stv -= dam[-1].tv  # \n        dam[-1] -= over  # \n        stv += dam[-1].tv  # \n        # \n        print((stv / l))\n        # \n        while len(dam)>1 and dam[0] <= dam[1]:\n            w = dam.popleft()\n            dam[0] += w\n\nmain()\n
n, d = list(map(int, input().split()))\nD = list(map(int, input().split()))\nA = [0]*(n+1)\nP = [0]*(n+1)\n\nP[0] = pos = d\nfor i, x in enumerate(D):\n    if x <= 2*pos:\n        pos = abs(x-pos)\n    P[i+1] = pos\n    if pos == 0:\n        break\n\nfor i in range(n-1, -1, -1):\n    if D[i] <= 2*A[i+1]+1:\n        A[i] = A[i+1] + D[i]\n    else:\n        A[i] = A[i+1]\n\nq = input()\nQ = list(map(int, input().split()))\nfor i in Q:\n    if P[i-1] <= A[i] and pos == 0:\n        print("NO")\n    else:\n        print("YES")\n
#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\nfrom collections import deque\nINF = 10**9\n\nn, m = map(int, input().split())\npqc = []\n\nseen = set()\nfor i in range(n):\n    seen.add((i, 0))\nfor _ in range(m):\n    p, q, c = map(int, input().split())\n    p -= 1; q -= 1\n    pqc.append((p, q, c))\n    seen.add((p, c))\n    seen.add((q, c))\ncomp = dict()\nfor i, node in enumerate(seen):\n    comp[node] = i\n\nedge = [[] for _ in range(len(comp))]\nfor key in comp.keys():\n    v, c = key\n    if c != 0:\n        frm = comp[(v, c)]\n        too = comp[(v, 0)]\n        edge[frm].append((too, 0))\n        edge[too].append((frm, 1))\n\nfor p, q, c in pqc:\n    frm = comp[(p, c)]\n    too = comp[(q, c)]\n    edge[frm].append((too, 0))\n    edge[too].append((frm, 0))\n\nclass BFS:\n    def __init__(self, adj):\n        self.adj = adj\n        self.dist = [INF] * len(adj)\n        self.q = deque()\n\n    def calc(self, start):\n        self.dist[start] = 0\n        self.q.append((0, start))\n        while len(self.q) != 0:\n            prov_cost, src = self.q.popleft()\n            if self.dist[src] < prov_cost:\n                continue\n            for dest, cost in self.adj[src]:\n                if self.dist[dest] > self.dist[src] + cost:\n                    self.dist[dest] = self.dist[src] + cost\n                    if cost == 1:\n                        self.q.append((self.dist[dest], dest))\n                    else:\n                        self.q.appendleft((self.dist[dest], dest))\n        return self.dist\n\nbfs = BFS(edge)\nbfs.calc(comp[(0, 0)])\nans = bfs.dist[comp[(n-1, 0)]]\nif ans == INF:\n    print(-1)\nelse:\n    print(ans)
N=int(input())\nM=len(input())\nO=10**9+7\nD=[pow(-~O//2,M,O)]+[0]*N\nfor _ in'_'*N:D=[D[0]+D[1]]+[(i+2*j)%O for i,j in zip(D[2:]+[0],D[:-1])]\nprint(D[M])
import sys\nfrom collections import deque\n\n\ndef diameter(n, links):\n    q = deque([(0, -1)])\n    v = 0\n    while q:\n        v, p = q.popleft()\n        q.extend((u, v) for u in links[v] if u != p)\n\n    q = deque([(v, -1)])\n    w = 0\n    parents = [-1] * n\n    while q:\n        w, p = q.popleft()\n        parents[w] = p\n        q.extend((u, w) for u in links[w] if u != p)\n    parents_rev = [-1] * n\n    p = w\n    while parents[p] != -1:\n        parents_rev[parents[p]] = p\n        p = parents[p]\n    return v, w, parents, parents_rev\n\n\ndef construct(s, links, parents, parents_rev):\n    v = s\n    result = []\n    while v != -1:\n        pv, rv = parents[v], parents_rev[v]\n        child_count = 0\n        for u in links[v]:\n            if u == pv or u == rv:\n                continue\n            if len(links[u]) != 1:\n                return False\n            child_count += 1\n        my_value = len(result) + 1\n        result.extend(list(range(my_value + 1, my_value + child_count + 1)))\n        result.append(my_value)\n        v = parents[v]\n    return result\n\n\ndef solve(n, links):\n    d1, d2, parents, parents_rev = diameter(n, links)\n    result1 = construct(d1, links, parents_rev, parents)\n    if result1 is False:\n        return [-1]\n    result2 = construct(d2, links, parents, parents_rev)\n    return min(result1, result2)\n\n\nn = int(input())\nlinks = [set() for _ in range(n)]\nINF = 10 ** 9\n\nfor line in sys.stdin:\n    v, w = list(map(int, line.split()))\n    v -= 1\n    w -= 1\n    links[v].add(w)\n    links[w].add(v)\n\nprint((*solve(n, links)))\n
N, a, b = list(map(int, input().split())); a -= 1; b -= 1\nP = []\nQ = []\nfor i in range(N):\n    x, y = list(map(int, input().split()))\n    P.append((x-y, x+y, i))\n    Q.append((x+y, x-y, i))\n\nd = max(abs(P[a][0] - P[b][0]), abs(P[a][1] - P[b][1]))\n\n*parent, = list(range(N))\ndef root(x):\n    if x == parent[x]:\n        return x\n    y = parent[x] = root(parent[x])\n    return y\ndef unite(x, y):\n    px = root(x); py = root(y)\n    if px < py:\n        parent[py] = px\n    else:\n        parent[px] = py\nC = [0]*N\nD = [0]*N\n\ndef check(P0, i0, j0):\n    return abs(P0[i0][0] - P0[j0][0]) == abs(P0[i0][1] - P0[j0][1])\n\ndef solve(P0):\n    P = P0[:]\n    P.sort()\n\n    s = t = 0; prev = -1\n    for i in range(N):\n        x, y, i0 = P[i]\n        while t < N and P[t][0] < x-d or (P[t][0] == x-d and P[t][1] <= y+d): t += 1\n        while s < N and (P[s][0] < x-d or (P[s][0] == x-d and P[s][1] < y-d)): s += 1\n        if s < t:\n            j0 = P[s][2]\n            unite(i0, j0)\n            if check(P0, i0, j0):\n                D[i0] += 1\n            else:\n                C[i0] += 1\n            if s < t-1:\n                j0 = P[t-1][2]\n                if check(P0, i0, j0):\n                    D[i0] += 1\n                    C[i0] += t-s-2\n                else:\n                    C[i0] += t-s-1\n            for j in range(max(prev, s), t-1):\n                unite(P[j][2], P[j+1][2])\n            prev = t-1\nsolve(P)\nsolve(Q)\n\nS = T = 0\nr = root(a)\nfor i in range(N):\n    if root(i) == r:\n        S += C[i]; T += D[i]\nprint((S + T//2))\n
import sys\nstdin=sys.stdin\n\nip=lambda: int(sp())\nfp=lambda: float(sp())\nlp=lambda:list(map(int,stdin.readline().split()))\nsp=lambda:stdin.readline().rstrip()\nyp=lambda:print('Yes')\nnp=lambda:print('No')\n\nn,a,b=lp()\nx=lp()\nans=0\nfor i in range(n-1):\n  ans+=min(b,a*(x[i+1]-x[i]))\nprint(ans)
import sys\ninput = sys.stdin.readline\nfrom collections import deque\ndef slidemax(X, k):\n    q = deque([])\n    ret = []\n    for i in range(len(X)):\n        while q and q[-1][1] <= X[i]:\n            q.pop()\n        deque.append(q, (i+k, X[i]))\n        if q[0][0] == i:\n            deque.popleft(q)\n        if i >= k-1:\n            ret.append(q[0][1])\n    return ret\n \nN, W = list(map(int, input().split()))\nA = [0] * W\ns = 0\nfor _ in range(N):\n    l, *B = list(map(int, input().split()))\n    if l*2 < W:\n        C = slidemax([0]*(l-1)+B+[0]*(l-1), l)\n        m = max(B + [0])\n        s += m\n        for i in range(l-1):\n            A[i] += C[i] - m\n            A[-i-1] += C[-i-1] - m\n    else:\n        C = slidemax([0]*(W-l)+B+[0]*(W-l), W - l + 1)\n        A = [a+c for a, c in zip(A, C)]\n\nprint(*[a+s for a in A])\n
d = [-1] * 1000001\nfor t in range(int(input())):\n    n, a = int(input()), list(map(int, input().split()))\n    a.sort()\n    for i in range(n):\n        for j in range(i + 1, n):  d[a[j] - a[i]] = t\n    i = 1\n    while any(d[i * j] == t for j in range(1, n)): i += 1\n    print("YES\n" + ' '.join(str(j * i + 1) for j in range(n)))
r, c = list(map(int, input().split()))\nif r == 3:\n    print('>vv')\n    print('^<.')\n    print('^.<')\n    print('1 3')\nelif r == 5:\n    print('>...v')\n    print('v.<..')\n    print('..^..')\n    print('>....')\n    print('..^.<')\n    print('1 1')\nelif r == 100:\n    for i in range(25):\n        print('>'*50+'.>'*24+'.v')\n        print('^'+'<.'*25+'<'*49)\n        print('v.'+'<.'*24+'<'*50)\n        print('>'*49+'.>'*25+'^')\n    print('1 1')\nelse:\n    d = []\n    d[1] = 1\n
import math\nimport sys\n\ninput = sys.stdin.readline\n\ndef main():\n\n\n\n    MAX_N = int(1e6) + 1\n\n    dp = [0 for i in range(MAX_N)]\n    vals = [[] for i in range(10)]\n\n    for i in range(10):\n        dp[i] = i\n        vals[i].append(i)\n\n\n    for i in range(10, MAX_N):\n        prod = 1\n        for j in str(i):\n            if j != '0':\n                prod *= int(j)\n\n        dp[i] = dp[prod]\n        vals[dp[prod]].append(i)\n\n    q = int(input())\n\n    for i in range(len(vals)):\n        vals[i] = sorted(vals[i])\n\n    for i in range(q):\n        l,r, k = [int(x) for x in input().split(' ')]\n        posl = -1\n        posr = -1\n        for j in range(25, -1, -1):\n            jump = 2**j\n\n            if posl + jump < len(vals[k]) and vals[k][posl+jump] < l:\n                posl += jump\n\n            if posr + jump < len(vals[k]) and vals[k][posr+jump] <= r:\n                posr += jump\n\n        print(posr - posl)\n\ndef __starting_point():\n    main()\n\n\n__starting_point()
from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop,heapify\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\nfrom itertools import accumulate\nfrom functools import lru_cache\n\nM = mod = 998244353\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\n').split()]\ndef st():return input().rstrip('\n')\ndef val():return int(input().rstrip('\n'))\ndef li2():return [i for i in input().rstrip('\n')]\ndef li3():return [int(i) for i in input().rstrip('\n')]\n\n\n\n\nn, q = li()\n\n\nqueue = [-1] * 20\n\nans = [[-1] * 20 for i in range(n + 1)]\nl = li()\nfor i, curr in enumerate(l):\n\n    for j in range(20):\n        if curr >> j & 1:\n            for k in range(20):        \n                ans[i][k] = max(ans[i][k], ans[queue[j]][k])\n            ans[i][j] = i\n    \n    for j in range(20):queue[j] = max(queue[j], ans[i][j])\n\n\nqueries = []\nfor i in range(q):queries.append(li())    \nfor i in range(q):\n    a, b = queries[i]\n    a -= 1\n    b -= 1\n\n    currans = 0\n\n    for j in range(20):\n        if (l[a] >> j) & 1 and ans[b][j] >= a:\n            currans = 1\n            break\n    print('Shi' if currans else 'Fou')
n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = [0] * n\nstk = [0]\nfor i in range(1, n):\n    while len(stk) > 1 and c[stk[1]] - c[stk[0]] <= a[i] * (b[stk[0]] -\n            b[stk[1]]):\n        del stk[0]\n    c[i] = c[stk[0]] + a[i] * b[stk[0]]\n    while len(stk) > 1 and ((c[stk[-1]] - c[stk[-2]]) * (b[stk[-1]] - b[i]) >\n            (b[stk[-2]] - b[stk[-1]]) * (c[i] - c[stk[-1]])):\n        del stk[-1]\n    stk.append(i)\nprint(c[n - 1])\n
n = int(input())\n*a, = map(int, input().split())\ndp = [[0 for i in range(n + 1)] for j in range(n + 1)]\nfor i in range(n):\n    dp[0][i] = a[i]\nfor i in range(1, n):\n    for j in range(n - i + 1):\n        dp[i][j] = dp[i - 1][j] ^ dp[i - 1][j + 1]\nfor i in range(1, n):\n    for j in range(n - i):\n        dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i - 1][j + 1])\nfor i in range(int(input())):\n    l, r = map(int, input().split())\n    print(dp[r - l][l - 1])
import sys\ninput = sys.stdin.readline\n\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    l = list(map(int, input().split()))\n    \n    stack = []\n    out = [-1] * n\n    curr = 0\n    works = True\n    for i in range(n):\n        while stack and stack[-1][0] == i:\n            _, j = stack.pop()\n            curr += 1\n            out[j] = curr\n        \n        nex = l[i] - 1\n        if nex == -2:\n            curr += 1\n            out[i] = curr\n        else:\n            if stack and nex > stack[-1][0]:\n                works = False\n            else:\n                stack.append((nex, i))\n    \n    while stack:\n        _, j = stack.pop()\n        curr += 1\n        out[j] = curr\n    \n    if works:\n        print(*out)\n    else:\n        print(-1)
import sys\ninput = lambda: sys.stdin.readline().rstrip()\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = [int(a) for a in input().split()]\n    X = [0] * 30\n    for a in A:\n        for i in range(30):\n            if a & (1 << i):\n                X[i] += 1\n    for i in range(30)[::-1]:\n        if X[i] % 2:\n            if X[i] == 1:\n                print("WIN")\n            elif N % 2 == 0:\n                print("WIN")\n            elif X[i] % 4 == 1:\n                print("WIN")\n            else:\n                print("LOSE")\n            break\n    else:\n        print("DRAW")\n
import sys\ninput = sys.stdin.readline\n\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    ans = 0\n    for i in range(n - 1):\n        diff = a[i] - a[i + 1]\n        if diff <= 0:\n            continue\n        else:\n            ans = max(len(bin(diff)) - 2, ans)\n            a[i + 1] = a[i]\n    print(ans)\n
n, k = list(map(int, input().split()))\nc, m, l, r = 0, 0, [], 0\nfor e in [int(i) for i in input().split()]:\n    d = m - c * (n - c - 1) * e\n    r+= 1\n    if d < k:\n        n -= 1\n        l += [r]\n    else:\n        m += c * e\n        c += 1\nl.sort()\nfor e in l: print(e)\n        \n        \n
import sys\nreadline = sys.stdin.readline\n\nT = int(readline())\nMOD =  998244353\nAns = [None]*T\nfor qu in range(T):\n    N, K = map(int, readline().split())\n    A = [0] + list(map(int, readline().split())) + [0]\n    B = list(map(int, readline().split()))\n    C = [None]*(N+1)\n    for i in range(1, N+1):\n        C[A[i]] = i\n    ans = 1\n    for b in B[::-1]:\n        bi = C[b]\n        res = 0\n        if A[bi-1]:\n            res += 1\n        if A[bi+1]:\n            res += 1\n        A[bi] = 0\n        ans = ans*res%MOD\n    Ans[qu] = ans\nprint('\n'.join(map(str, Ans))) 
"""\n    Author      : Arif Ahmad\n    Date        : \n    Algo        : \n    Difficulty  : \n"""\nfrom sys import stdin, stdout, setrecursionlimit\nimport threading\n\n\ndef main():\n    m = int(stdin.readline().strip())\n    a = [int(_) for _ in stdin.readline().strip().split()]\n    b = [int(_) for _ in stdin.readline().strip().split()]\n\n    c = []\n    for i, v in enumerate(b):\n        c.append((v, i))\n\n    a = sorted(a, reverse=True)\n    c = sorted(c)\n\n    ans = [0 for i in range(m)]\n    j = 0\n    for v, i in c:\n        ans[i] = a[j]\n        j += 1\n\n    stdout.write(' '.join(str(_) for _ in ans))\n    \n\n\ndef __starting_point():\n    # the following 4 lines of code are required to increase \n    # the recursion limit and stack size\n    # * if is cause any problem, comment out the lines, \n    # * and just call main()\n    setrecursionlimit(10**6)\n    threading.stack_size(134217728) # 128MB\n    thread = threading.Thread(target=main)\n    thread.start()\n\n__starting_point()
from cmath import rect\nimport sys\nimport math\nfrom functools import reduce\n\nclass SegmentTree():\n    def __init__(self, L, function = lambda x,y: x+y):\n        self.function = function\n        N = self.size = len(L)\n        M = 1 << N.bit_length()\n        self.margin = 2*M - N\n        self.L = [None for i in range(self.margin)] + L\n        for i in range(M-1, 0, -1):\n            x, y = self.L[i<<1], self.L[i<<1|1]\n            self.L[i] = None if x is None or y is None else function(x, y)\n    def modify(self, pos, value):\n        p = pos + self.margin\n        self.L[p] = value \n        while p > 1:\n            x, y = self.L[p], self.L[p^1]\n            if p&1: x, y = y, x\n            self.L[p>>1] = None if x is None or y is None else self.function(x, y)\n            p>>=1\n    def query(self, left, right):\n        l, r = left + self.margin, right + self.margin\n        stack = []\n        void = True\n        while l < r:\n            if l&1:\n                if void:\n                    result = self.L[l]\n                    void = False\n                else:\n                    result = self.function(result, self.L[l])\n                l+=1\n            if r&1:\n                r-=1\n                stack.append(self.L[r])\n            l>>=1\n            r>>=1\n        init = stack.pop() if void else result\n        return reduce(self.function, reversed(stack), init)\n\ndef degrect(r, phi):\n    return rect(r, math.radians(phi))\n\ndef vsum(u, v): #u = (x + y*1j, phi)\n    return (u[0] + v[0]*degrect(1, u[1]), (u[1] + v[1])%360)\n\ndef solve(f):\n    n, m = [int(x) for x in f.readline().split()]\n    segments = [[1,0] for i in range(n)]\n    arm = SegmentTree([(1,0) for i in range(n)], vsum)\n    for line in f:\n        q, i, a = [int(x) for x in line.split()]\n        if q == 1:\n            segments[i-1][0] += a\n        else:\n            segments[i-1][1] -= a\n        arm.modify(i-1, (degrect(segments[i-1][0], segments[i-1][1]), segments[i-1][1]))\n        query = arm.query(0,n)[0]\n        print(query.real, query.imag)\n\nsolve(sys.stdin)\n
import sys\nimport math\n\nn = int(input())\n\nx = [0]*n\ny = [0]*n\n\nfor i in range(n):\n    x[i], y[i] = list(map(int, input().split()))\n\nsx = sum(x)\nsy = sum(y)\n    \nfor i in range(n):\n    x[i] = n * x[i] - sx\n    y[i] = n * y[i] - sy\n\nm = int(input())\n\nd = [0]*n\ne = [0]*n\n\nHD = 0\n\ndef check(a, b):\n    nonlocal HD\n    HE = 0\n    for i in range(n):\n        HE ^= hash((a-x[i])*(a-x[i])+(b-y[i])*(b-y[i]))\n    return HD == HE\n\ndef sqrt(x):\n    nn = int(x)\n    if nn == 0:\n        return 0\n    fa, fb = divmod(nn.bit_length(), 2)\n    x = 2**(fa+fb)\n    while True:\n        y = (x + nn//x)//2\n        if y >= x:\n            return x\n        x = y\n\ndef hash(x):\n    return x * 9991 + 43\n\npans = []\n\ndef solve():\n    nonlocal d\n    d = list(map(int, input().split()))\n    c = 0\n    d = [p * n * n for p in d]\n    for i in range(n):\n        c += d[i] - x[i] * x[i] - y[i] * y[i]\n\n    assert(c % n == 0)\n    c //= n\n    ans = []\n    ax = x[0]\n    ay = y[0]\n    if ax is 0 and ay is 0:\n        ax = x[1]\n        ay = y[1]\n    rev = 0\n    if ay == 0:\n        ay = ax\n        ax = 0\n        rev = 1\n    d.sort()\n    nonlocal HD\n    HD = 0\n    for p in d:\n        HD ^= hash(p)\n    old = -1\n    for p in d:\n        if (p == old):\n            continue\n        old = p\n        a = c + ax * ax + ay * ay - p\n        if (a % 2 != 0):\n            continue\n        a //= 2\n        A = ax * ax + ay * ay\n        B = a * ax\n        C = a * a - ay * ay * c\n        D = B * B - A * C\n        if (D < 0):\n            continue\n        sD = sqrt(D)\n        if D != sD * sD:\n            continue\n        if (B + sD) % A == 0:\n            qx = (B + sD) // A\n            qy = (a - ax * qx) // ay\n            if rev:\n                t = qx\n                qx = qy\n                qy = t\n            if ((qx + sx) % n == 0 and (qy + sy) % n == 0 and check(qx, qy)):\n                qx = (qx + sx) // n\n                qy = (qy + sy) // n\n                ans.append([qx, qy])\n        if sD == 0:\n            continue\n        if (B - sD) % A == 0:\n            qx = (B - sD) // A\n            qy = (a - ax * qx) // ay\n            if rev:\n                t = qx\n                qx = qy\n                qy = t\n            if ((qx + sx) % n == 0 and (qy + sy) % n == 0 and check(qx, qy)):\n                qx = (qx + sx) // n\n                qy = (qy + sy) // n\n                ans.append([qx, qy])\n                \n    ans.sort()\n    buf=[]\n    buf.append(len(ans))\n    for p in ans:\n            buf.append(p[0])\n            buf.append(p[1])\n    nonlocal pans\n    pans.append(" ".join(map(str,buf)))\n\nwhile m > 0:\n    m -= 1\n    solve()\n    \nsys.stdout.write("\n".join(pans))\n       \n
def main():\n    import sys\n    from array import array\n    input = sys.stdin.readline\n\n    class Bit:\n        def __init__(self, n):\n            self.size = n\n            self.size_bit_length = n.bit_length()\n            self.tree = array('h', [0] * (n+1))\n\n        def reset(self):\n            self.tree = array('h', [0] * (self.size+1))\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << (self.size_bit_length - 1)\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n\n    N, M = list(map(int, input().split()))\n    dist = [0] + list(map(int, input().split()))\n    for i in range(N-1):\n        dist[i+1] += dist[i]\n    B = [0] * (M * N)\n    for i in range(N):\n        BB = list(map(int, input().split()))\n        for j in range(M):\n            B[j * N + i] = BB[j] * (N+1) + i+1\n\n    imos = []\n    for i in range(N+1):\n        imos.append([0] * (N+1 - i))\n    bit = Bit(N)\n    for m in range(M):\n        bit.reset()\n        for bi in sorted(B[m*N: (m+1) * N], reverse=True):\n            b, i = divmod(bi, N+1)\n            k = bit.sum(i)\n            l = bit.lower_bound(k)\n            r = bit.lower_bound(k+1)\n            imos[l+1][i - (l+1)] += b\n            if i != N:\n                imos[i+1][0] -= b\n            if r != N+1:\n                imos[l+1][r - (l+1)] -= b\n            if i != N and r != N+1:\n                imos[i+1][r - (i+1)] += b\n            bit.add(i, 1)\n\n    for i in range(1, N+1):\n        for j in range(i+1, N+1):\n            imos[i][j - i] += imos[i][j-1-i]\n    for i in range(2, N + 1):\n        for j in range(i, N + 1):\n            imos[i][j-i] += imos[i - 1][j - (i-1)]\n    ans = 0\n    for i in range(1, N + 1):\n        for j in range(i, N + 1):\n            ans = max(ans, imos[i][j-i] - (dist[j - 1] - dist[i - 1]))\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
#!/usr/bin/env python3\n\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\ndef main():\n    n = int(input())\n    adj_list = [[] for i in range(n)]\n    for i in range(n - 1):\n        a1, b1 = list(map(int, sys.stdin.readline().split()))\n        adj_list[a1 - 1].append(b1 - 1)\n        adj_list[b1 - 1].append(a1 - 1)\n    path = list(reversed(dfs(0, -1, adj_list, n)))\n    assert len(path) >= 2\n    fpath = len(path) - len(path) // 2\n    cut = set(path[fpath - 1:fpath + 1])\n    f = dfs2(0, -1, adj_list, n, cut)\n    s = dfs2(n - 1, -1, adj_list, n, cut)\n    assert f + s == n\n    print(("Fennec" if f > s else "Snuke"))\n\ndef dfs(now, prev, adj_list, n):\n    if now == n - 1:\n        return [now]\n    for next in adj_list[now]:\n        if next == prev:\n            continue\n        p = dfs(next, now, adj_list, n)\n        if p is not None:\n            p.append(now)\n            return p\n\ndef dfs2(now, prev, adj_list, n, cut):\n    size = 1\n    for next in adj_list[now]:\n        if next == prev:\n            continue\n        if {now, next} == cut:\n            continue\n        s = dfs2(next, now, adj_list, n, cut)\n        size += s\n    return size\n\ndef __starting_point():\n    main()\n\n__starting_point()
S = input()\nSA = [0]\nn = 0\nfor c in S:\n    if c=='A': n+=1\n    SA.append(n)\n\nT = input()\nTA = [0]\nn = 0\nfor c in T:\n    if c=='A': n+=1\n    TA.append(n)\n\n\nq = int(input())\nfor _ in range(q):\n    a, b, c, d = list(map(int, input().split()))\n\n    nSA = SA[b]-SA[a-1]\n    nSB = b-a+1-nSA\n    nTA = TA[d]-TA[c-1]\n    nTB = d-c+1-nTA\n\n    print(('YES' if (nSA-nSB)%3 == (nTA-nTB)%3 else 'NO'))\n
from collections import defaultdict\n\nN = int(input())\na = [int(i) for i in input().split()]\n\nb = defaultdict(lambda : [float('inf'), 0])\nfor i in range(N) :\n    b[a[i]][0] = min(b[a[i]][0], i)\n    b[a[i]][1] += 1\n\n# [value, first_appearance, count]\nc = [(0, 0, 0)]\nfor k, v in b.items() :\n    c.append((k, v[0], v[1]))\nc.sort()\n\nret = [0] * N\npre_v, pre_i, pre_c = c.pop()\nwhile c :\n    cur_v, cur_i, cur_c = c.pop()\n    ret[pre_i] += (pre_v - cur_v) * pre_c\n    cur_c += pre_c\n    pre_v, pre_i, pre_c = cur_v, min(pre_i, cur_i), cur_c\n    \nfor r in ret :\n    print(r)
import sys\ninput = sys.stdin.readline\n\ndef main():\n  n, m = map(int, input().split())\n  LR = [list(map(int, input().split())) for _ in range(n)]\n  \n  BIT = [0]*(m+2)\n  def add(i, a):\n    while i <= m+1:\n      BIT[i] += a\n      i += i&(-i)\n  def bit_sum(i):\n    res = 0\n    while i > 0:\n      res += BIT[i]\n      i -= i&(-i)\n    return res\n  \n  for l, r in LR:\n    add(l, 1)\n    add(r+1, -1)\n  \n  S = sorted([(r-l+1, l, r) for l, r in LR])\n  cnt = 0\n  L = []\n  for i in range(m, 0, -1):\n    while S and S[-1][0] == i:\n      c, l, r = S.pop()\n      cnt += 1\n      add(l, -1)\n      add(r+1, 1)\n    res = cnt\n    for j in range(0, m+1, i):\n      res += bit_sum(j)\n    L.append(res)\n  print(*L[::-1], sep="\n")\n\ndef __starting_point():\n  main()\n__starting_point()
def fx(s,n,xsum):\n	sub=[[None for x in range(n+2)]for y in range(xsum+2)]\n	for i in range(n+1):\n		sub[0][i]=True\n	for i in range(1,xsum+1):\n		sub[i][0]=False\n	for i in range(1,xsum+1):\n		for j in range(1,n+1):\n			sub[i][j]=sub[i][j-1]\n			if i>=s[j-1]:\n				sub[i][j]=sub[i][j] or sub[i-s[j-1]][j-1]\n	if sub[xsum][n]:\n		print('Yes')\n	else:\n		print('No')\n		\nn,t=list(map(int,input().split()))\na=list(map(int,input().split()))\nfor _ in range(t):\n	q=list(map(int,input().split()))\n	if q[0]==1:\n		a[q[1]-1]=q[2]\n		continue\n	if q[0]==2:\n		w=a[q[1]-1:q[2]]\n		a[q[1]-1:q[2]]=w[::-1]\n		continue\n	if q[0]==3:\n		e=a[q[1]-1:q[2]]\n		if q[3]<min(e) or q[3]>sum(e):\n			print('No')\n			continue\n		if q[3] in e:\n			print('Yes')\n			continue\n		fx(e,len(e),q[3])
mod =(10**9)+7\nn,m = list(map(int,input().split()))\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\ndp = []\nfor i in range(n):\n    dp += [[0]*m]\ndp[-1][-1]=1\nfor i in range(n-2,-1,-1):\n    dp[i][-1]=1\n    for j in range(m-1):\n        x = (a[i]+b[j])-(b[j+1])\n        temp = 0\n        for k in range(i+1,n):\n            if(a[k]>=x):\n                temp += dp[k][j+1]\n        dp[i][j]=temp\nans = 0\nfor i in range(n):\n    ans += dp[i][0]\nprint(ans%mod)\n        \n
s = input()\n\nif s[0] == '0' or s[-2] == '0' or s[-1] == '1':  # 's' should be like "1xx...x0"\n    print((-1))\nelif s[:-1] != s[-2::-1]:\n    print((-1))\nelse:\n    half = len(s) // 2\n    one_indices = [i+1 for i in range(1, half) if s[i] == '1'] # not including 0 or larger than n//2\n\n    parents = [0] * (len(s) + 1)\n    parent_index = 1\n    for index in one_indices:\n        for i in range(parent_index, index):\n            parents[i] = index\n        parent_index = index\n\n    root = parent_index + 1\n    parents[parent_index] = root\n    for index in range(root + 1, len(s) + 1):\n        parents[index] = root\n\n    for node, parent in enumerate(parents):\n        if parent == 0: # This means node is 0 or the root of the tree.\n            continue\n        print((node, parent))\n
from sys import stdin\nimport itertools\ninput = stdin.readline\ndef getint(): return int(input())\ndef getints(): return list(map(int, input().split()))\ndef getint1(): return list([int(x) - 1 for x in input().split()])\ndef getstr(): return input()[:-1]\n\n\ndef solve():\n    n, a, b = getint1()\n    n += 1\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = getint1()\n        adj[u].append(v)\n        adj[v].append(u)\n    # dfs 1\n    max_child = [[-1] * 3 for _ in range(n)]\n    stack = [(a, -1, 1)]  # (node, parent)\n    while stack:\n        u, p, flag = stack.pop()\n        if p != -1 and len(adj[u]) < 2:\n            max_child[u][0] = 1\n            continue\n        if flag == 1:\n            stack.append((u, p, 0))\n            for v in adj[u]:\n                if v == p:\n                    continue\n                stack.append((v, u, 1))\n        else:\n            for v in adj[u]:\n                if v == p:\n                    continue\n                len_v = max_child[v][0] + 1\n                if len_v > max_child[u][0]:\n                    max_child[u][2] = max_child[u][1]\n                    max_child[u][1] = max_child[u][0]\n                    max_child[u][0] = len_v\n                elif len_v > max_child[u][1]:\n                    max_child[u][2] = max_child[u][1]\n                    max_child[u][1] = len_v\n                elif len_v > max_child[u][2]:\n                    max_child[u][2] = len_v\n    # end of dfs 1\n    # dfs 2\n    body = []\n    ret = [False] * n\n    max_parent = [-1] * n\n    stack.clear()\n    stack = [(a, -1, 0)]  # (node, parent, max len from parent)\n    while stack:\n        u, p, mxp = stack.pop()\n        if mxp >= 0:\n            stack.append((u, p, -1))\n            if p != -1 and len(adj[u]) < 2:\n                continue\n            max_parent[u] = mxp + 1\n            chlen = [max_parent[u], -3]\n            for v in adj[u]:\n                if v == p:\n                    continue\n                len_v = max_child[v][0] + 1\n                if len_v > chlen[0]:\n                    chlen[1] = chlen[0]\n                    chlen[0] = len_v\n                elif len_v > chlen[1]:\n                    chlen[1] = len_v\n            for v in adj[u]:\n                if v == p:\n                    continue\n                stack.append(\n                    (v, u, chlen[int(max_child[v][0] + 1 == chlen[0])]))\n        else:\n            is_body = (u == b)\n            if not is_body:\n                for v in adj[u]:\n                    if v != p and ret[v]:\n                        is_body = True\n                        break\n            if is_body:\n                body.append(u)\n            ret[u] = is_body\n    del ret\n    # end of dfs2\n    ok = False\n    body_len = len(body)\n    can_turn = [False] * n\n    for i in range(n):\n        if 3 <= sum(1 for l in max_child[i] + [max_parent[i]] if l >= body_len):\n            can_turn[i] = True\n            ok = True\n    if not ok:\n        print("NO")\n        return\n    treelen = [1] * body_len\n    # print(body)\n    for i in range(body_len):\n        cur = body[i]\n        pre = -1 if i == 0 else body[i - 1]\n        nxt = -1 if i + 1 == body_len else body[i + 1]\n        for v in adj[cur]:\n            if v == pre or v == nxt:\n                continue\n            treelen[i] = max(treelen[i], max_child[v][0] + 1)\n            if can_turn[v]:\n                can_turn[cur] = True\n                continue\n            # dfs 3\n            stack = [(v, cur)]\n            while stack and not can_turn[cur]:\n                u, p = stack.pop()\n                for w in adj[u]:\n                    if w == p:\n                        continue\n                    if can_turn[w]:\n                        can_turn[cur] = True\n                        break\n                    stack.append((w, u))\n            stack.clear()\n            # end of dfs 3\n        # print(i, cur, can_turn[cur])\n    # use two pointer to find if we can enter the turing point\n    # print(body_len, treelen)\n    l = 0\n    r = body_len - 1\n    lmax = treelen[r] - 1\n    rmin = body_len - treelen[l]\n    ok = (can_turn[body[l]] or can_turn[body[r]])\n    while not ok and (l < lmax or rmin < r):\n        if l < lmax:\n            l += 1\n            rmin = min(rmin, l + (body_len - treelen[l]))\n        if rmin < r:\n            r -= 1\n            lmax = max(lmax, r - (body_len - treelen[r]))\n        if can_turn[body[l]] or can_turn[body[r]]:\n            ok = True\n    ##\n    print("YES" if ok else "NO")\n    return\n    # end of solve\n\n\ndef __starting_point():\n    # solve()\n    # for t in range(getint()):\n    #     print('Case #', t + 1, ': ', sep='')\n    #     solve()\n    for _ in range(getint()):\n        solve()\n\n__starting_point()
import sys\ninput = sys.stdin.readline\n\nfrom collections import deque\n\nt=int(input())\nfor testcaess in range(t):\n    n,m,a,b=list(map(int,input().split()))\n    E=[[] for i in range(n+1)]\n\n    for i in range(m):\n        x,y=list(map(int,input().split()))\n        E[x].append(y)\n        E[y].append(x)\n\n    USE1=[0]*(n+1)\n\n    Q=deque()\n    Q.append(a)\n\n    USE1[a]=1\n\n    while Q:\n        x=Q.pop()\n\n        for to in E[x]:\n            if to==b:\n                continue\n            if USE1[to]==0:\n                USE1[to]=1\n                Q.append(to)\n\n    USE2=[0]*(n+1)\n\n    Q=deque()\n    Q.append(b)\n\n    USE2[b]=1\n\n    while Q:\n        x=Q.pop()\n\n        for to in E[x]:\n            if to==a:\n                continue\n            if USE2[to]==0:\n                USE2[to]=1\n                Q.append(to)\n\n    #print(USE1,USE2)\n\n    ANS1=0\n    ANS2=0\n\n    for i in range(n+1):\n        if i==a or i==b:\n            continue\n        if USE1[i]==1 and USE2[i]==0:\n            ANS1+=1\n        elif USE1[i]==0 and USE2[i]==1:\n            ANS2+=1\n\n    print(ANS1*ANS2)\n        \n\n    \n\n    \n
import sys\ninput = sys.stdin.readline\nout = []\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    n -= 1\n    rem = n % 3\n    n //= 3\n    \n    s = []\n    if n:\n        n -= 1\n        while n >= 0:\n            s.append([['00','00','00'],['01','10','11'],['10','11','01'],['11','01','10']][n % 4][rem])\n            n //= 4\n            n -= 1\n\n    s.append(['1','10','11'][rem])\n\n    s.reverse()\n\n    out.append(int(''.join(s),2))\nprint('\n'.join(map(str,out)))\n    \n
import sys\nreadline = sys.stdin.readline\n\nT = int(readline())\nAns = [None]*T\nfor qu in range(T):\n    S = [1 if s == 'A' else 0 for s in readline().strip()]\n    stack = []\n    for s in S:\n        if s:\n            stack.append(s)\n        else:\n            if stack and stack[-1] == 1:\n                stack.pop()\n            else:\n                stack.append(s)\n    stack2 = []\n    for s in stack:\n        if s:\n            stack2.append(s)\n        else:\n            if stack2 and stack2[-1] == 0:\n                stack2.pop()\n            else:\n                stack2.append(s)\n    Ans[qu] = len(stack2)\n\nprint('\n'.join(map(str, Ans)))\n
import sys\ninput= sys.stdin.readline\nt = int(input())\nout = []\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int,input().split()))\n\n    smol = l[0]\n    works = True\n    for i in range(1, n):\n        if l[i] == l[i-1] + 1:\n            pass\n        else:\n            if l[i] > smol:\n                works = False\n                break\n        smol = min(smol, l[i])\n\n    if works:\n        out.append('Yes')\n    else:\n        out.append('No')\nprint('\n'.join(out))\n
n = int(input())\nl = [int(x) - 1 for x in input().split()]\nparity = 0\nexplore = set(l)\nwhile len(explore) > 0:\n    x = explore.pop()\n    tmp = x\n    found = [x]\n    while l[tmp] != x:\n        tmp = l[tmp]\n        found.append(tmp)\n    for i in found[1:]:\n        explore.remove(i)\n    parity ^= (len(found) - 1) % 2\n\nif parity == n % 2:\n    print("Petr")\nelse:\n    print("Um_nik")
import sys\ninput = sys.stdin.readline\nfrom collections import Counter\n\nt=int(input())\nfor testcases in range(t):\n    n=int(input())\n    P=list(map(int,input().split()))\n    C=Counter(P)\n    PLIST=sorted(set(P),reverse=True)\n\n    g=C[PLIST[0]]\n    s=0\n    b=0\n\n    sflag=1\n\n    for i in PLIST[1:]:\n\n        if sflag:\n            if s<=g:\n                s+=C[i]\n            else:\n                sflag=0\n                bflag=1\n                b+=C[i]\n\n        elif bflag:\n            if b<=g:\n                b+=C[i]\n            elif g+s+b+C[i]<=n//2:\n                b+=C[i]\n            else:\n                break\n\n        #print(i,g,s,b)\n\n    if g+s+b<=n//2:\n        print(g,s,b)\n    else:\n        print(0,0,0)\n            \n            \n            \n
import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nt=int(input())\nfor tests in range(t):\n    n=int(input())\n\n    a=input().strip()\n    b=input().strip()\n\n\n    Q=deque(a)\n\n    L=[]\n    while Q:\n        L.append(Q.popleft())\n\n        if Q:\n            L.append(Q.pop())\n\n    ANS=[]\n    for i in range(n):\n        if i%2==0:\n            if L[i]==b[-1-i]:\n                ANS.append(1)\n        else:\n            if L[i]!=b[-1-i]:\n                ANS.append(1)\n\n        ANS.append(n-i)\n\n    print(len(ANS),*ANS)\n            \n\n    \n
import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nt=int(input())\nfor tests in range(t):\n    n=int(input())\n\n    a=input().strip()\n    b=input().strip()\n\n\n    Q=deque(a)\n\n    L=[]\n    while Q:\n        L.append(Q.popleft())\n\n        if Q:\n            L.append(Q.pop())\n\n    ANS=[]\n    for i in range(n):\n        if i%2==0:\n            if L[i]==b[-1-i]:\n                ANS.append(1)\n        else:\n            if L[i]!=b[-1-i]:\n                ANS.append(1)\n\n        ANS.append(n-i)\n\n    print(len(ANS),*ANS)\n            \n\n    \n
t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    l = [int(x) for x in input().split()]\n    cur = l[0]\n    cll = 1\n    blocks = []\n    for x in l[1:]:\n        if x > cur:\n            blocks.append(cll)\n            cur = x\n            cll = 1\n        else:\n            cll += 1\n    blocks.append(cll)\n\n    poss = [[False]*(n+1) for _ in range(len(blocks) + 1)]\n    poss[0][0] = True\n    for i, b in enumerate(blocks):\n        for j in range(n+1):\n            poss[i+1][j] = poss[i][j]\n            if b <= j:\n                poss[i+1][j] |= poss[i][j-b]\n\n    # print()\n    # print(blocks)\n    # for r in poss:\n    #     print(r)\n    print("YES" if poss[len(blocks)][n] else "NO")\n
import sys\nreadline = sys.stdin.readline\n\nclass Segtree:\n    def __init__(self, A, intv, initialize = True, segf = max):\n        self.N = len(A)\n        self.N0 = 2**(self.N-1).bit_length()\n        self.intv = intv\n        self.segf = segf\n        if initialize:\n            self.data = [intv]*self.N0 + A + [intv]*(self.N0 - self.N)\n            for i in range(self.N0-1, 0, -1):\n                self.data[i] = self.segf(self.data[2*i], self.data[2*i+1]) \n        else:\n            self.data = [intv]*(2*self.N0)\n        \n    def update(self, k, x):\n        k += self.N0\n        self.data[k] = x\n        while k > 0 :\n            k = k >> 1\n            self.data[k] = self.segf(self.data[2*k], self.data[2*k+1])\n    \n    def query(self, l, r):\n        L, R = l+self.N0, r+self.N0\n        s = self.intv\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.segf(s, self.data[R])\n            if L & 1:\n                s = self.segf(s, self.data[L])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n    \n    def binsearch(self, l, r, check, reverse = False):\n        L, R = l+self.N0, r+self.N0\n        SL, SR = [], []\n        while L < R:\n            if R & 1:\n                R -= 1\n                SR.append(R)\n            if L & 1:\n                SL.append(L)\n                L += 1\n            L >>= 1\n            R >>= 1\n        \n        if reverse:\n            for idx in (SR + SL[::-1]):\n                if check(self.data[idx]):\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                if check(self.data[2*idx+1]):\n                    idx = 2*idx + 1\n                else:\n                    idx = 2*idx\n            return idx - self.N0\n        else:\n            for idx in (SL + SR[::-1]):\n                if check(self.data[idx]):\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                if check(self.data[2*idx]):\n                    idx = 2*idx\n                else:\n                    idx = 2*idx + 1\n            return idx - self.N0\n\nTc = int(readline())\nAns = [None]*Tc\n\nfor qu in range(Tc):\n    N, M, K = list(map(int, readline().split()))\n    A = list(map(int, readline().split()))\n    Ai = A[::-1]\n    table = [None]*M\n    for i in range(M):\n        j = (M-1)-i\n        table[i] = max(A[i], Ai[j])\n    inf = 10**9+7\n    T = Segtree(table, inf, initialize = True, segf = min)\n    ans = min(table)\n    K = min(K, M-1)\n    R = M-1-K\n    for ki in range(K+1):\n        ans = max(ans, T.query(ki, ki+R+1))\n    Ans[qu] = ans\nprint('\n'.join(map(str, Ans)))\n        \n    \n
import sys\n\ninput = sys.stdin.readline\n\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int,input().split()))\n    for i in range(n-1,0,-1):\n        a[i] -= a[i-1]\n\n    minus = 0\n    for i in range(1,n):\n        if a[i]<0:\n            minus -= a[i]\n\n    if a[0] - minus >=0:\n        print("YES")\n    else:\n        print("NO")\n
t = int(input())\nfor _ in range(t):\n    d, m = list(map(int, input().split()))\n    d += 1\n    out = 1\n    curr = 2\n    while curr < d:\n        out *= (curr // 2) + 1\n        out %= m\n        curr *= 2\n    out *= (d - curr // 2 + 1)\n    print((out - 1) % m)\n
import sys\ninput = sys.stdin.readline\n\nT = int(input())\nfor _ in range(T):\n    N, M = list(map(int, input().split()))\n    X = [[] for i in range(3*N)]\n    for i in range(M):\n        x, y = list(map(int, input().split()))\n        x, y = min(x,y), max(x,y)\n        X[x-1].append((y-1, i+1))\n    \n    MAT = []\n    IND = []\n    DONE = [0] * 3*N\n    for i in range(3*N):\n        if DONE[i]: continue\n        for j, ind in X[i]:\n            if DONE[j] == 0:\n                MAT.append(ind)\n                DONE[i] = 1\n                DONE[j] = 1\n                break\n        else:\n            IND.append(i+1)\n\n    if len(MAT) >= N:\n        print("Matching")\n        print(*MAT[:N])\n    else:\n        print("IndSet")\n        print(*IND[:N])\n\n\n
mod = 998244353\nf0 = [ [0 for i in range(11)] for j in range(2010) ]\nf1 = [ [0 for i in range(11)] for j in range(2010) ]\nfac = [0 for i in range(2010)]\ntab = [0 for i in range(11)]\nC = [ [0 for i in range(2010)] for j in range(2010) ]\n\ndef Init() :\n    fac[0] = 1\n    for i in range(2010) :\n        if i > 0 : fac[i] = fac[i - 1] * i % mod\n        C[i][0] = 1\n        for j in range(1, 2010) :\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod\n\ndef len(x) :\n    res = 0\n    while x > 0 :\n        res += 1\n        x = x // 10\n    return res\n            \ndef solve() :\n    n = int(input())\n    f0[0][0] = f1[0][0] = 1\n    a = list(map(int, input().split()))\n    c0, c1 = 0, 0\n    s0, s1 = 0, 0\n    for nu in a :\n        m = nu % 11\n        if len(nu) & 1 :\n            c1 += 1\n            s1 += m\n            for i in range(11) :\n                f1[c1][i] = 0\n            for i in range(c1 - 1, -1, -1) :\n                for j in range(11) :\n                    if f1[i][j] == 0 : continue\n                    f1[i + 1][(j + m) % 11] += f1[i][j]\n                    f1[i + 1][(j + m) % 11] %= mod\n        else :\n            c0 += 1\n            s0 += m\n            for i in range(11) :\n                f0[c0][i] = 0\n            for i in range(c0 - 1, -1, -1) :\n                for j in range(11) :\n                    if f0[i][j] == 0 : continue\n                    f0[i + 1][(j + m) % 11] += f0[i][j]\n                    f0[i + 1][(j + m) % 11] %= mod\n    s1 %= 11\n    s0 %= 11\n    part = c1 // 2\n    for i in range(11) :\n        tab[i] = 0\n    for i in range(11) :\n        tab[(i + i + 11 - s1) % 11] = f1[c1 - part][i]\n    for i in range(11) :\n        tab[i] = tab[i] * fac[part] % mod * fac[c1 - part] % mod\n\n    ans = 0\n    if c1 == 0 :\n        ans = f0[c0][0] * fac[c0]\n    elif c0 == 0 :\n        ans = tab[0]\n    else :\n        for i in range(c0 + 1) :\n            for j in range(11) :\n                if f0[i][j] == 0 : continue\n                # print(f0[i][j], tab[(j + j + 11 - s0) % 11] \\n                # , fac[i] % mod * fac[c0 - i] % mod, C[j + (c1 - part) - 1][(c1 - part) - 1] % mod * C[part + c0 - i][part] % mod )\n                ans = ( ans \\n                        + fac[i] % mod * fac[c0 - i] % mod \\n                        * f0[i][j] * tab[(j + j + 11 - s0) % 11] % mod \\n                        * C[i + (c1 - part) - 1][(c1 - part) - 1] % mod \\n                        * C[part + c0 - i][part]\n ) % mod\n    print(ans)\n\nInit()\nT = int(input())\nfor ttt in range(T) : solve()
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\nmii=lambda:list(map(int,input().split()))\n\nfor _ in range(int(input())):\n    n,d=mii()\n    a=list(mii())\n    ans=0\n    for i in range(n):\n        while d>=i and a[i]:\n            a[i]-=1\n            ans+=1\n            d-=i\n    print(ans)\n
import sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    n, k = list(map(int, input().split()))\n    s = input()\n    l = ['']*k\n    works = True\n    for i in range(n):\n        c = s[i]\n        if c != '?':\n            if l[i%k] == c or l[i%k] == '':\n                l[i%k] = c\n            else:\n                works = False\n                break\n    if works:\n        smol = 0\n        big = k\n        for c in l:\n            if c == '0':\n                big -= 1\n            elif c == '1':\n                smol += 1\n        goal = k//2\n        if smol <= goal <= big:\n            print('YES')\n        else:\n            print('NO')\n    else:\n        print('NO')\n
N = int(input())\nX = list(map(int, input().split()))\nL = int(input())\n\ndef one_step(i):\n  goal = X[i] + L\n  \n  # find largest j s.t. X[j] <= X[i] + L\n  low = 0\n  high = N\n  while high - low > 1:\n    mid = (high + low)//2\n    if X[mid] <= goal:\n      low = mid\n    else:\n      high = mid\n  \n  return low\n\nonesteps = [one_step(i) for i in range(N)]\n\ndef double(layer):\n  return [layer[layer[i]] for i in range(N)]\n\nNUM_LAYERS = 20\nlayers = [onesteps]\nfor _ in range(NUM_LAYERS):\n  layers.append(double(layers[-1]))\n  \ndef query(a, b):\n  if a > b:\n    a, b = b, a\n  \n  ans = 0\n  while a < b:\n    ind = 0\n    while layers[ind + 1][a] < b:\n      ind += 1\n    ans += 2 ** ind\n    a = layers[ind][a]\n  return ans\n  \nQ = int(input())\nfor _ in range(Q):\n  a, b = map(int, input().split())\n  a -= 1\n  b -= 1\n  print(query(a, b))
import sys\nfrom math import log\n\nk = float(sys.stdin.readline())\nanswer = int(log(2.0, 2.0/k))\nprint(2*answer)\n\nm = 2 ** (1.0/answer)\n# m = 2.0/k\nthesum = 0\nfor i in range(answer):\n thesum += m**i\n# print [m**i/thesum for i in xrange(answer)]\nloaves = [1]\n\ndef maxIndex(list):\n max = -1\n mi = -1\n for i, x in enumerate(list):\n  if x > max:\n   max = x\n   mi = i\n return mi\n\ndesired = [m**i/thesum for i in range(answer)]\ndesired.reverse()\n# print desired\ncuts = []\nwhile len(desired) > 1:\n cuts.append(desired[-1])\n lastsum = desired[-1] + desired[-2]\n del desired[-2:]\n desired[0:0] = [lastsum]\n\n# print cuts\n\nwhile cuts:\n length = cuts.pop()\n i = maxIndex(loaves)\n print(i, length)\n loaves[i] -= length\n loaves.append(length)\n # print loaves\n\n# print loaves\nfor i in range(answer):\n i = maxIndex(loaves[:answer])\n x = loaves[i]/2.0\n print(i, x)\n loaves.append(x)\n loaves[i] -= x\n# print loaves\n
\n"""\n#this code is a precomputation part.\n#it takes about 2 hours.\nclass Graph:\n  def __init__(self,n):\n    self.edge=[[0 for j in xrange(n)] for i in xrange(n)]\n    self.n=n\n\n  def addedge(self,i,j,m=1):\n    assert i!=j and 0<=i<self.n and 0<=j<self.n\n    self.edge[i][j]+=m\n    self.edge[j][i]+=m\n\n  def deledge(self,i,j,m=1):\n    assert i!=j and 0<=i<self.n and 0<=j<self.n\n    self.edge[i][j]-=m\n    self.edge[j][i]-=m\n\n  def strongconnect(self):\n    ret = True\n    n=self.n\n    for i in xrange(n):\n      for j in xrange(i+1,n):\n        if self.edge[i][j]:\n          self.deledge(i,j)\n          ret=self.connect()\n          self.addedge(i,j)\n          if ret==False:return ret\n    return True\n\n  def connect(self):\n    n=self.n\n    edge=self.edge\n    z=[0 for _ in xrange(n)]\n    def f(i):\n      assert 0<=i<n\n      if z[i]==1:return\n      z[i]=1\n      for j in xrange(n):\n        if edge[i][j]:f(j)\n    f(0)\n    return sum(z)==n\n\n  def Nconnect(self):\n    n=self.n\n    edge=self.edge\n    z=[0 for _ in xrange(n)]\n    def f(i):\n      assert 0<=i<n\n      if z[i]==1:return\n      z[i]=1\n      for j in xrange(n):\n        if edge[i][j]:f(j)\n    ret=0\n    for ver in xrange(n):\n      if z[ver]==0:\n        ret+=1\n        f(ver)\n    return ret\n\ndef search(nv,ne):\n  graph=Graph(nv)\n  init=( graph, (0,0), ne)\n  def f(state):\n    ret=0\n    g,(i,j),e=state\n    if e==0:\n      if g.strongconnect():\n        return fact(ne)\n      else:return 0\n\n    if e<g.Nconnect():\n      return 0\n    for i2 in xrange(nv):\n      for j2 in xrange(i2+1,nv):\n        if (i2,j2)>(i,j):\n          for k in xrange(1,e+1):\n            g.addedge(i2,j2,k)\n            ret += f((g,(i2,j2),e-k)) / fact(k)\n            g.deledge(i2,j2,k)\n    return ret\n  return f(init)\n\ndef fact(n):\n  assert n>=0\n  ret=1\n  for i in xrange(n):ret*=i+1\n  return ret\n\ndef comb(a,b):\n  return fact(a+b)/fact(a)/fact(b)\n  pass\n\nnnn=17\nsve=dict( ( (v,e),search(v,e) )  for v in xrange(nnn+1) for e in xrange(nnn+1) if e>=v and e+v<=nnn)\nsve[(1,0)]=1\nprint sve\n"""\n\n\noutput="""\n{(6, 9): 10559808000, (0, 7): 0, (1, 6): 0, (0, 10): 0, (3, 7): 2142, (2, 5): 1, (1, 11): 0, (5, 8): 48094200, (6, 7): 6350400, (5, 5): 1440, (6, 10): 247973140800, (0, 17): 0, (0, 4): 0, (1, 1): 0, (4, 10): 57808440, (2, 6): 1, (5, 11): 84587745000, (4, 5): 2160, (0, 1): 0, (3, 12): 531366, (1, 12): 0, (2, 11): 1, (7, 8): 482630400, (0, 14): 0, (3, 11): 177078, (1, 15): 0, (8, 9): 45113241600, (4, 12): 2148847272, (2, 12): 1, (1, 16): 0, (1, 5): 0, (0, 11): 0, (3, 6): 690, (2, 2): 1, (1, 10): 0, (6, 11): 4928158065600, (0, 5): 0, (1, 0): 1, (0, 8): 0, (4, 11): 354158640, (3, 5): 210, (2, 7): 1, (5, 10): 7639380000, (4, 6): 25560, (5, 7): 2835000, (0, 2): 0, (1, 3): 0, (4, 8): 1433544, (2, 8): 1, (0, 15): 0, (3, 10): 58986, (1, 14): 0, (4, 13): 12970756656, (2, 13): 1, (1, 4): 0, (0, 12): 0, (3, 9): 19626, (2, 3): 1, (1, 9): 0, (2, 14): 1, (6, 8): 336268800, (0, 6): 0, (1, 7): 0, (0, 9): 0, (3, 4): 54, (2, 4): 1, (5, 9): 644550480, (4, 7): 206640, (6, 6): 43200, (5, 6): 104400, (7, 7): 1814400, (0, 16): 0, (0, 3): 0, (3, 14): 4782882, (1, 2): 0, (4, 9): 9265200, (3, 3): 6, (2, 9): 1, (5, 12): 900380296200, (4, 4): 72, (7, 10): 2379856852800, (0, 0): 1, (3, 13): 1594242, (1, 13): 0, (2, 10): 1, (7, 9): 44808422400, (0, 13): 0, (3, 8): 6510, (1, 8): 0, (8, 8): 101606400, (2, 15): 1}\n"""\nsve=eval( "".join( output.split("\n") ) )\n\n\ndef fact(n):\n  assert n>=0\n  ret=1\n  for i in range(n):ret*=i+1\n  return ret\n\ndef comb(a,b):\n  return fact(a+b)/fact(a)/fact(b)\n  pass\n\n"python 2.5 cannot use fractions."\n"I used fractions for local computation."\n#import fractions\n#fr=fractions.Fraction(1)\nmemo_ff={}\ndef powpoly(x,t):\n  ret=[1]+[0]*( len(x)-1 )\n  n=len(x)\n  for _ in range(t):\n    ret2=[0 for _ in range(n)]\n    for i in range(n):\n      for j in range(n):\n        if i+j<n:\n          ret2[i+j]+=ret[i]*x[j]\n    ret=ret2\n  return ret\n\ndef ing(x):\n  n=len(x)\n  assert x[0]==0\n  ret=[0 for _ in range(n)]\n  for t in range(0,n):\n    ret2=powpoly(x,t)\n    for i in range(n):\n      ret[i]+=fr*ret2[i]/fact(t)\n  return ret\n\n\ndef ff(Y):\n  if Y in memo_ff:\n    return memo_ff[Y]\n  t=Y[0]\n  if t==0:\n    n=Y[1]\n    ret=0\n    for (v,e) in sve:\n      if v+e>n or v==0:continue\n      val=sve[(v,e)]\n      for l1 in range(n-v+1):\n        l2=n-v-l1\n        p1=ff((2,l1,e))\n        p2=ff((3,l2,v))\n        a = fr * val * fact(n-1) / fact(v-1) / fact(l1) / fact(l2) * p1 * p2 / fact(e)\n        ret += a\n  elif t==1:\n    n=Y[1]\n    ret=0\n    for (v,e) in sve:\n      val=sve[(v,e)]\n      e-=1\n      if e==-1 or v+e>n or v==0:continue\n      for l1 in range(n-v+1):\n        l2=n-v-l1\n        p1=ff((2,l1,e))\n        p2=ff((3,l2,v))\n        ret += fr * val * fact(n) / fact(v) / fact(l1) / fact(l2) * p1 * p2 / fact(e)\n  elif t==2:\n    n=Y[1]\n    e=Y[2]\n    F=[ fr*i*ff((0,i))/fact(i) for i in range(n+1) ]\n    Fa=powpoly(F,e)\n    ret=Fa[n]*fact(n)\n  elif t==3:\n    n=Y[1]\n    v=Y[2]\n    G=[v*fr*ff((1,i))/fact(i) for i in range(n+1)]\n    Ga=ing(G)\n    ret = Ga[n]*fact(n)\n  memo_ff[Y]=ret\n  return ret\n\nmemo={}\n\ndef g(Y):\n  if Y in memo:\n    return memo[Y]\n  k,c=Y\n  if c==0:\n    return ff((0,k))\n  if 2*c>=k:return 0\n  ret=0\n  for k1 in range(1,18):\n    for k2 in range(1,18):\n      k3=k-k1-k2\n      if k3<=0:break\n      for c1 in range(18):\n        if 2*c1>=k1:break\n        for c2 in range(18):\n          if 2*c2>=k2:break\n          c3=c-1-c1-c2\n          if 2*c3>=k3:continue\n          ret += g((k1,c1)) * g((k2,c2)) * g((k3,c3)) * fact(k1+k2+k3)/fact(k1)/fact(k2)/fact(k3)*k1*k2*k3\n  r=ret/(6*c)\n  memo[Y]=r\n  return r\n\n\ndef ans(n):\n  return sum(g((n,i)) for i in range(n))\n\n\ndef brute(n):\n  m=[(i1,i2,i3) for i1 in range(n) for i2 in range(i1+1,n) for i3 in range(i2+1,n)]\n  init=[]\n  memob={}\n  def f(vs):\n    ret=0\n    if vs:\n      g=Graph(n)\n      for v in vs:\n        i1,i2,i3=v\n        g.addedge(i1,i2)\n        g.addedge(i1,i3)\n      a=g.Nconnect()\n      for notv in vs:\n        g=Graph(n)\n        for v in vs:\n          if v==notv:continue\n          i1,i2,i3=v\n          g.addedge(i1,i2)\n          g.addedge(i1,i3)\n        if g.Nconnect()==a:\n          return 0\n      if a==1:return 1\n    ret = 0\n    for v in m:\n      if len(vs)==0 or v>vs[-1]:\n        ret += f(vs+[v])\n    return ret\n  return f(init)\n\ndef brute2(n):\n  m=[(i1,i2,i3) for i1 in range(n) for i2 in range(i1+1,n) for i3 in range(i2+1,n)]\n  init=[]\n  def f(vs):\n    ret=0\n    if vs:\n      g=Graph(n)\n      for v in vs:\n        i1,i2,i3=v\n        g.addedge(i1,i2)\n        g.addedge(i1,i3)\n      a=g.Nconnect()\n      for notv in vs:\n        g=Graph(n)\n        for v in vs:\n          if v==notv:continue\n          i1,i2,i3=v\n          g.addedge(i1,i2)\n          g.addedge(i1,i3)\n        if g.Nconnect()==a or ( a==1 and g.Nconnect()==3):\n          return 0\n      if a==1:\n        return 1\n    ret = 0\n    for v in m:\n      if len(vs)==0 or v>vs[-1]:\n        ret += f(vs+[v])\n    return ret\n  return f(init)\n\ndef main():\n  t=eval(input())\n  #z=[int(ans(i)) for i in xrange(18)] it takes about 10 seconds\n  z=[0, 1, 0, 1, 6, 25, 495, 5586, 93268, 2052513, 43258365, 1167393700, 34010847486,\n      1078391538159, 38595111963499, 1476893151785520, 61479081902937000, 2761923686066698561]\n  for _ in range(t):\n    print(z[eval(input())])\n#test()\nmain()\n
import decimal;\nfrom decimal import *;\n\ndef solve(a, b, min1, min2, min3, min4, x, y):\n	if a > b:\n		return [];\n	solMin1 = (a/y+b)/(y-1/y);\n	solMin2 = (b/y+a)/(y-1/y);\n	solMin1 *= (x*y);\n	solMin2 *= (x*y);\n\n	if solMin1 >= min1 and solMin1 <= min2 and solMin2 >= min3 and solMin2 <= min4:\n		# Solution found\n		return [a, solMin1, b, solMin2];\n	return [];\n\ndef integerPart(x):\n	return Decimal(str(x).split(".")[0]);\n\ndef fractionalPart(x):\n	t = str(x).split(".");\n	if len(t) > 0:\n		return "." + t[1];\n	return 0;\n\ngetcontext().prec = 30;\nfor i in range(eval(input())):\n	(x,y) = input().split();\n	(a,b,c,d,e,f,g,h) = input().split();\n	x=Decimal(x);y=Decimal(y);a=Decimal(a);b=Decimal(b);c=Decimal(c);d=Decimal(d);e=Decimal(e);f=Decimal(f);g=Decimal(g);h=Decimal(h);\n\n	if a > g or (a == g and b > h):\n		print("-1");\n		continue;\n\n	solutionh = Decimal("-1");\n	solutionm = Decimal("-1");\n	diff = Decimal("-10000000000000000");\n\n	solution1 = [];solution2=[];solution3=[];solution4=[];solution5=[];solution6=[];solution7=[];solution8=[];solution9=[];\n	solution10 = [];solution11=[];solution12=[];solution13=[];solution14=[];\n	l1 = 0;\n	if g == e:\n		l1 = f;\n	solution1 = solve(a+0,g+0,b,x*y,l1,h,x,y);\n	if a < y - 1 and len(solution1) == 0:\n		solution2 = solve(a+1,g+0,0,x*y,l1,h,x,y);\n	if g >= 1 and len(solution1) == 0 and len(solution2) == 0:\n		solution4 = solve(a+0,g-1,b,x*y,0,x*y,x,y);\n	if g-e >= 2 and c-a>=2 :\n		solution5 = solve(a+1,g-1,0,x*y,0,x*y,x,y);\n	\n	if len(solution1) == 0 and len(solution2) == 0 and len(solution4) == 0:\n		solution10 = solve(a, e, 0, x*y, 0, x*y, x, y);\n		solution11 = solve(c, e, 0, x*y, 0, x*y, x, y);\n		solution12 = solve(c, g, 0, x*y, 0, x*y, x, y);\n	if a < y - 1 and len(solution1) == 0 and len(solution2) == 0 and len(solution4) == 0 and c - a >= 2:\n		solution13 = solve(a + 1, e, 0, x*y, 0, x*y, x, y);\n	if g >= 1 and len(solution1) == 0 and len(solution2) == 0 and len(solution4) == 0 and g - e >= 2:\n		solution14 = solve(c, g - 1, 0, x*y, 0, x*y, x, y);\n\n\n	if len(solution1) > 0:\n		if solution1[0] < c or (solution1[0] == c and solution1[1] <= d):\n			if solution1[2] > e or (solution1[2] == e and solution1[3] >= f):\n				t = (solution1[2]-solution1[0])*x*y + (solution1[3]-solution1[1]);\n				if t > diff:\n					diff = t;\n					solutionh = solution1[0];\n					solutionm = solution1[1];\n	if len(solution2) > 0:\n		if solution2[0] < c or (solution2[0] == c and solution2[1] <= d):\n			if solution2[2] > e or (solution2[2] == e and solution2[3] >= f):\n				t = (solution2[2]-solution2[0])*x*y + (solution2[3]-solution2[1]);\n				if t > diff:\n					diff = t;\n					solutionh = solution2[0];\n					solutionm = solution2[1];\n	if len(solution4) > 0:\n		if solution4[0] < c or (solution4[0] == c and solution4[1] <= d):\n			if solution4[2] > e or (solution4[2] == e and solution4[3] >= f):\n				t = (solution4[2]-solution4[0])*x*y + (solution4[3]-solution4[1]);\n				if t > diff:\n					diff = t;\n					solutionh = solution4[0];\n					solutionm = solution4[1];\n	if len(solution5) > 0:\n		if solution5[0] < c or (solution5[0] == c and solution5[1] <= d):\n			if solution5[2] > e or (solution5[2] == e and solution5[3] >= f):\n				t = (solution5[2]-solution5[0])*x*y + (solution5[3]-solution5[1]);\n				if t > diff:\n					diff = t;\n					solutionh = solution5[0];\n					solutionm = solution5[1];\n	if len(solution10) > 0:\n		if solution10[0] > a or (solution10[0] == a and solution10[1] >= b):\n			if solution10[0] < c or (solution10[0] == c and solution10[1] <= d):\n				if solution10[2] > e or (solution10[2] == e and solution10[3] >= f):\n					if solution10[2] < g or (solution10[2] == g and solution10[3] <= h):\n						t = (solution10[2]-solution10[0])*x*y + (solution10[3]-solution10[1]);\n						if t > diff:\n							diff = t;\n							solutionh = solution10[0];\n							solutionm = solution10[1];\n	if len(solution11) > 0:\n		if solution11[0] > a or (solution11[0] == a and solution11[1] >= b):\n			if solution11[0] < c or (solution11[0] == c and solution11[1] <= d):\n				if solution11[2] > e or (solution11[2] == e and solution11[3] >= f):\n					if solution11[2] < g or (solution11[2] == g and solution11[3] <= h):\n						t = (solution11[2]-solution11[0])*x*y + (solution11[3]-solution11[1]);\n						if t > diff:\n							diff = t;\n							solutionh = solution11[0];\n							solutionm = solution11[1];\n	if len(solution12) > 0:\n		if solution12[0] > a or (solution12[0] == a and solution12[1] >= b):\n			if solution12[0] < c or (solution12[0] == c and solution12[1] <= d):\n				if solution12[2] > e or (solution12[2] == e and solution12[3] >= f):\n					if solution12[2] < g or (solution12[2] == g and solution12[3] <= h):\n						t = (solution12[2]-solution12[0])*x*y + (solution12[3]-solution12[1]);\n						if t > diff:\n							diff = t;\n							solutionh = solution12[0];\n							solutionm = solution12[1];\n	if len(solution13) > 0:\n		if solution13[0] > a or (solution13[0] == a and solution13[1] >= b):\n			if solution13[0] < c or (solution13[0] == c and solution13[1] <= d):\n				if solution13[2] > e or (solution13[2] == e and solution13[3] >= f):\n					if solution13[2] < g or (solution13[2] == g and solution13[3] <= h):\n						t = (solution13[2]-solution13[0])*x*y + (solution13[3]-solution13[1]);\n						if t > diff:\n							diff = t;\n							solutionh = solution13[0];\n							solutionm = solution13[1];\n	if len(solution14) > 0:\n		if solution14[0] > a or (solution14[0] == a and solution14[1] >= b):\n			if solution14[0] < c or (solution14[0] == c and solution14[1] <= d):\n				if solution14[2] > e or (solution14[2] == e and solution14[3] >= f):\n					if solution14[2] < g or (solution14[2] == g and solution14[3] <= h):\n						t = (solution14[2]-solution14[0])*x*y + (solution14[3]-solution14[1]);\n						if t > diff:\n							diff = t;\n							solutionh = solution14[0];\n							solutionm = solution14[1];\n	\n	limit1 = (y-1/y)*(f/(x*y))-e/y;\n	if limit1 <= a + 1:\n		limit1 = a + 1;\n	limit1 = Decimal(str(int(limit1)));\n	limit2 = (y-1/y)*(d/(x*y))-c/y;\n	if limit2 >= g-1:\n		limit2=g-1;\n	limit2 = Decimal(str(int(limit2)));\n\n	if limit1 >= a + 1 and limit1 <= c-1:\n		solutionNew = solve(limit1, e, 0, x*y, 0, x*y, x, y);\n		if len(solutionNew) > 0:\n			if solutionNew[0] > a or (solutionNew[0] == a and solutionNew[1] >= b):\n				if solutionNew[0] < c or (solutionNew[0] == c and solutionNew[1] <= d):\n					if solutionNew[2] > e or (solutionNew[2] == e and solutionNew[3] >= f):\n						if solutionNew[2] < g or (solutionNew[2] == g and solutionNew[3] <= h):\n							t = (solutionNew[2]-solutionNew[0])*x*y + (solutionNew[3]-solutionNew[1]);\n							if t > diff:\n								diff = t;\n								solutionh = solutionNew[0];\n								solutionm = solutionNew[1];\n	if limit1 + 1 >= a + 1 and limit1 + 1 <= c-1:\n		solutionNew = solve(limit1 + 1, e, 0, x*y, 0, x*y, x, y);\n		if len(solutionNew) > 0:\n			if solutionNew[0] > a or (solutionNew[0] == a and solutionNew[1] >= b):\n				if solutionNew[0] < c or (solutionNew[0] == c and solutionNew[1] <= d):\n					if solutionNew[2] > e or (solutionNew[2] == e and solutionNew[3] >= f):\n						if solutionNew[2] < g or (solutionNew[2] == g and solutionNew[3] <= h):\n							t = (solutionNew[2]-solutionNew[0])*x*y + (solutionNew[3]-solutionNew[1]);\n							if t > diff:\n								diff = t;\n								solutionh = solutionNew[0];\n								solutionm = solutionNew[1];\n	if limit2 >= e + 1 and limit2 <= g-1:\n		solutionNew = solve(c, limit2, 0, x*y, 0, x*y, x, y);\n		if len(solutionNew) > 0:\n			if solutionNew[0] > a or (solutionNew[0] == a and solutionNew[1] >= b):\n				if solutionNew[0] < c or (solutionNew[0] == c and solutionNew[1] <= d):\n					if solutionNew[2] > e or (solutionNew[2] == e and solutionNew[3] >= f):\n						if solutionNew[2] < g or (solutionNew[2] == g and solutionNew[3] <= h):\n							t = (solutionNew[2]-solutionNew[0])*x*y + (solutionNew[3]-solutionNew[1]);\n							if t > diff:\n								diff = t;\n								solutionh = solutionNew[0];\n								solutionm = solutionNew[1];\n	if limit1 - 1 >= e + 1 and limit2 - 1 <= g-1:\n		solutionNew = solve(c, limit2 - 1, 0, x*y, 0, x*y, x, y);\n		if len(solutionNew) > 0:\n			if solutionNew[0] > a or (solutionNew[0] == a and solutionNew[1] >= b):\n				if solutionNew[0] < c or (solutionNew[0] == c and solutionNew[1] <= d):\n					if solutionNew[2] > e or (solutionNew[2] == e and solutionNew[3] >= f):\n						if solutionNew[2] < g or (solutionNew[2] == g and solutionNew[3] <= h):\n							t = (solutionNew[2]-solutionNew[0])*x*y + (solutionNew[3]-solutionNew[1]);\n							if t > diff:\n								diff = t;\n								solutionh = solutionNew[0];\n								solutionm = solutionNew[1];\n\n	if solutionh == -1 or diff < 0:\n		print("-1");\n	else:\n		tz = solutionm;\n		solutionm *= 100;\n		try:\n			r1 = integerPart(solutionm);\n			r1 = str(r1);\n			r1 = Decimal(r1);\n			r2 = solutionm - r1;\n			if r2 >= Decimal(".5"):\n				r1 += Decimal("1");\n			t1 = (r1 - r1%100)/100;\n			t2 = r1%100;\n			t1 = int(t1);\n			if t2 == 0:\n				t2 = "00";\n			elif t2 < 10:\n				t2 = "0" + str(t2);\n			else:\n				t2 = str(t2);\n		except:\n			exit(0);\n		#print str(solutionh)+":%.2f"%(solutionm);\n		print(str(solutionh)+":%d.%s"%(t1, t2));\n
s=""\nL=[]\ns=input()\nk=0\nr=0\nc=0\nif s[0]=='h':\n    L.append('http://')\n    c=4\n    s=s[c:]\nelif s[0]=='f':\n    L.append('ftp://')\n    c=3\n    s=s[c:]\nr=s.find('ru',1)\nL.append(s[:r])\nL.append('.ru')\n\nk=r+2\n\nif k<len(s):\n    L.append('/')\n    L.append(s[k:])\n   \nprint(''.join(L))\n\n
n, a = int(input()), [int(i) for i in input().split()]\nb, m = a[:], dict()\nb.sort()\nfor i in range(len(b) - 1):\n    m[b[i]] = b[i + 1]\nm[b[-1]] = b[0]\nfor i in range(len(a)):\n    a[i] = m[a[i]]\nif len(set(b)) == n:\n    print(*a)\nelse:\n    print(-1)\n
s = input()\nn = int(input())\na = [input() for i in range(n)]\nfor i in range(n):\n    for j in range(n):\n        if a[i] == s or a[i][1] + a[j][0] == s:\n            print("YES")\n            return\nprint("NO")\n
\nimport numpy as np\nN,K = list(map(int,input().split()))\nA=np.array(list(map(int,input().split())))\nmod = 998244353\n\nfact = [1]*(K+1)\nfor i in range(1,K+1):\n    fact[i]=i*fact[i-1]%mod\ninv_fact = [pow(f,mod-2,mod) for f in fact]\n\n# r = [sum(pow(aa,t,mod) for aa in A)%mod for t in range(K+1)]##\nr = [0]*(K+1)\nr[0] = N\ntemp = np.ones(N,dtype="int32")\nfor i in range(1,K+1):\n    temp = temp*A%mod\n    r[i] = int(np.sum(temp))%mod\n\ninv2 = pow(2,mod-2,mod)\nfor x in range(1,K+1):\n    ans = sum((fact[x]*inv_fact[t]*inv_fact[x-t] *r[x-t]*r[t]) %mod \n               for t in range(x+1))%mod\n    ans-= r[x]*pow(2,x,mod) %mod\n    print(((ans*inv2)%mod))\n\n
n,k=map(int,input().split())\nmod=998244353\ndp=[0]*(n+1)\ndp[0]=1\nfor i in range(1,n+1):\n  for j in range(i,-1,-1):\n    dp[j]=dp[j-1]\n    if 2*j<=i:\n      dp[j]+=dp[2*j]\n    dp[j]%=mod\nprint(dp[k])
from functools import reduce\n\ndef modpow(a, n, m):\n    if n == 0:\n        return 1\n    tmp = modpow(a, n // 2, m)\n    if n % 2 == 0:\n        return tmp * tmp % m\n    else:\n        return tmp * tmp * a % m\n\ndef modinv(a, m):\n    return modpow(a, m - 2, m)\n\nn, m = [int(_) for _ in input().split(' ')]\ns = sum([int(_) for _ in input().split(' ')])\n\nM = 1_000_000_007\nproduct = lambda x1, x2: x1 * x2 % M\n\nprint((reduce(product, list(range(m - s + 1, m + n + 1))) * modinv(reduce(product, list(range(1, s + n + 1))), M) % M))\n
def main():\n    import sys\n    input = sys.stdin.readline\n\n    import heapq\n    def dijkstra_heap(s,g,edge):\n        #s\n        d = [10**20] * (n+2)\n        used = [True] * (n+2) #True:\n        d[s] = 0\n        used[s] = False\n        edgelist = []\n        sx,sy,sr=edge[s][0],edge[s][1],edge[s][2]\n        for i in range(n+2):\n            x,y,r=edge[i][0],edge[i][1],edge[i][2]\n            dist=((x-sx)**2+(y-sy)**2)**(1/2)\n            heapq.heappush(edgelist,(max(dist-r-sr,0),i))\n        while len(edgelist):\n            minedge = heapq.heappop(edgelist)\n            #\n            v = minedge[1]\n            if not used[v]:\n                continue\n            d[v] = minedge[0]\n            used[v] = False\n            bx,by,br=edge[v][0],edge[v][1],edge[v][2]\n            for i in range(n+2):\n                x,y,r=edge[i][0],edge[i][1],edge[i][2]\n                dist=((x-bx)**2+(y-by)**2)**(1/2)\n                if used[i]:\n                    heapq.heappush(edgelist,(max(dist-r-br,0)+d[v],i))\n            if not used[g]:\n                break\n        return d[g]\n\n    sx,sy,gx,gy = map(int,input().split()) #n:w:\n    n=int(input())\n    edge=[(sx,sy,0),(gx,gy,0)]\n    for i in range(2,n+2):\n        x,y,r=map(int,input().split())\n        edge.append((x,y,r))\n    print(dijkstra_heap(0,1,edge))\n\ndef __starting_point():\n    main()\n__starting_point()
N,K,M=map(int,input().split());R=range;T=[[1]]\nfor i in R(1,N):\n	q=K*i\n	if i>~i+N:T+=[y:=T[-1][:len(T[~i+N])]]\n	else:T+=[y:=T[-1][:]+[0]*q]\n	p=len(y)-i\n	for j in R(p):y[j+i]+=y[j]%M\n	for j in R(p-q):y[~j]-=y[~j-i-q]%M\nfor i in R(N):print(sum(T[i][j]*T[~i+N][j]for j in R(len(T[i])))*-~K%M-1)
k=str(input())\nl=len(k)\npaths=[]\nfor i in range(l):\n	paths.append([1]*i+[int(k[i])]+[10]*(l-i-1))\nlens = [sum(p) for p in paths]\nn = sum(lens)+2\nm = ['']*n\nm[0] = 'N'*2\nfor i in range(len(paths)):\n	m[0] += 'Y'*paths[i][0]+'N'*(lens[i]-paths[i][0])\nm[1] = 'N'\nfor i in range(len(paths)):\n	m[1] += 'N'*(lens[i]-paths[i][-1])+'Y'*paths[i][-1]\nind=2\nfor p in paths:\n	for i in range(len(p)-1):\n		for j in range(p[i]):\n			m[ind] = 'N'*(p[i]-j)+'Y'*(p[i+1])+'N'*n\n			ind+=1\n	for j in range(p[-1]):\n		m[ind] = 'N'*n\n		ind+=1\nm2=['']*n\nfor i in range(n):\n	m2[i] = ''\n	for j in range(i):\n		m2[i]+=m2[j][i]\n	m2[i]+=m[i][:n-i]\nprint(len(m2))\nfor s in m2:\n	print(s)\n
from collections import defaultdict as dd\nfrom collections import deque\nimport bisect\nimport heapq\n\ndef ri():\n    return int(input())\n\ndef rl():\n    return list(map(int, input().split()))\n\n\ndef solve():\n    n = ri()\n    output = [0] * (n)\n\n    Q = [(-n, 0 ,n - 1)]\n    for i in range(1, n + 1):\n        prev = heapq.heappop(Q)\n        lo, hi = prev[1], prev[2]\n        mid = (lo + hi) // 2\n        output[mid] = i\n        if mid > lo:\n            heapq.heappush(Q, (-(mid - 1 - lo), lo, mid - 1))\n        if hi > mid:\n            heapq.heappush(Q, (-(hi - 1 - mid), mid + 1, hi))\n    print(*output)\n\n\n\n\n\nmode = 'T'\n\nif mode == 'T':\n    t = ri()\n    for i in range(t):\n        solve()\nelse:\n    solve()\n
def main():\n    import sys\n    input = sys.stdin.readline\n    \n    def solve():\n        n = int(input())\n        maxx = 10**5\n        minx = -10**5\n        maxy = 10**5\n        miny = -10**5\n        \n        for _ in range(n):\n            x, y, f1, f2, f3, f4 = map(int, input().split())\n            if not f1:\n                minx = max(minx, x)\n            if not f2:\n                maxy = min(maxy, y)\n            if not f3:\n                maxx = min(maxx, x)\n            if not f4:\n                miny = max(miny, y)\n        \n        if minx > maxx or miny > maxy:\n            print(0)\n        else:\n            print(1, minx, miny)\n        \n    \n    for _ in range(int(input())):\n        solve()\n    \n    return 0\n\nmain()
\nT = int(input())\n\nfor _ in range(T):\n    a = int(input())\n    hh = sorted(map(int, input().split()))\n    ans = 10**10\n    for h1, h2 in zip(hh[:-1], hh[1:]):\n        ans = min(ans, h2 - h1)\n\n    print(ans)\n
import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    n, m, a, b, c = list(map(int,input().split()))\n    p = list(map(int, input().split()))\n    p.sort()\n    \n    pref = [0]\n    curr = 0\n    for i in range(m):\n        curr += p[i]\n        pref.append(curr)\n\n    adj = [[] for i in range(n)]\n    for _ in range(m):\n        u, v = list(map(int,input().split()))\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n        \n    aD = [-1] * n\n    bD = [-1] * n\n    cD = [-1] * n\n\n    for i in range(3):\n        q = deque()\n        q.append(([a,b,c][i]-1,0))\n        l = [aD,bD,cD][i]\n        l[q[0][0]] = 0\n        while q:\n            v, d = q.popleft()\n            for nex in adj[v]:\n                if l[nex] == -1:\n                    l[nex] = d + 1\n                    q.append((nex,d+1))\n    poss = []\n    for i in range(n):\n        if aD[i] + bD[i] + cD[i] <= m:\n            poss.append(pref[aD[i] + bD[i] + cD[i]] + pref[bD[i]])\n    print(min(poss))\n            \n
import sys\ninput = sys.stdin.readline\n\ndef dfs(x,S):\n    #print(x,S)\n    for i in range(len(S)):\n        if x in S[i]:\n            S[i].remove(x)\n\n    #print(x,S)\n        \n    LEN1=0\n    for s in S:\n        if len(s)==1:\n            LEN1+=1\n            ne=list(s)[0]\n        if LEN1==2:\n            return [-1]\n    if LEN1==1:\n        return [ne]+dfs(ne,S)\n    else:\n        return [-1]\n    \n        \nimport copy    \n\nt=int(input())\nfor tests in range(t):\n    n=int(input())\n    A=tuple(set(list(map(int,input().split()))[1:]) for i in range(n-1))\n\n    for i in range(1,n+1):\n        ANS=[i]+dfs(i,copy.deepcopy(A))\n        #print(i,ANS)\n        if -1 in ANS[:n]:\n            continue\n        else:\n            #print(ANS[:n])\n            USE=[0]*(n-1)\n\n            flag=1\n\n            for i in range(n-1,0,-1):\n                SET=set()\n                for j in range(i,-1,-1):\n                    SET.add(ANS[j])\n                    if SET in A:\n                        break\n                else:\n                    flag=0\n                    break\n\n            if flag:\n                print(*ANS[:n])\n                break\n    \n\n        \n
for _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    m = 10 ** 9\n    c = 0\n    for i in range(n - 1, -1, -1):\n        if A[i] <= m:\n            m = A[i]\n        else:\n            c += 1\n    print(c)
q = int(input())\nfor _ in range(q) :\n  n = int(input())\n  s = input()\n  t = input()\n\n  x = set(s)\n  y = set(t)\n\n  if x != y :\n    print("NO")\n    continue\n\n  if len(x) == n :\n    a = [0] * n\n    for i, c in enumerate(t) :\n      a[i] = s.find(c)\n\n    yeet = 0\n    vis = [False] * n\n    for i in range(n) :\n      if vis[i] :\n        continue\n      j = i\n      cyc = 0\n      while not vis[j] :\n        cyc += 1\n        vis[j] = True\n        j = a[j]\n      # print('>> ', i, cyc)\n      yeet += (cyc - 1) % 2\n      yeet %= 2\n\n    if yeet == 0 :\n      print("YES")\n    else :\n      print("NO")\n    continue\n\n  print("YES")\n
t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    \n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ma = min(a)\n    mb = min(b)\n    \n    ops = 0\n    for xa, xb in zip(a, b):\n        da = xa - ma\n        db = xb - mb\n        ops += max(da, db)\n        \n    print(ops)\n
# @author \n\nimport sys\n\nclass GCandyBoxHardVersion:\n    def solve(self):\n        q = int(input())\n        for _ in range(q):\n            n = int(input())\n            a = [0] * n\n            f = [0] * n\n            for i in range(n):\n                a[i], f[i] = [int(_) for _ in input().split()]\n\n            d = {key: [0, 0] for key in a}\n            for i in range(n):\n                d[a[i]][f[i]] += 1\n            rev_d = {sum(key): [] for key in list(d.values())}\n            for x in d:\n                rev_d[d[x][0] + d[x][1]] += [d[x]]\n\n            for x in rev_d:\n                rev_d[x].sort(key=lambda item:item[1])\n\n            # print(rev_d)\n\n            cur = max(rev_d)\n            cnt = max(rev_d)\n            nb_candies = 0\n            given_away = 0\n            while 1:\n                if cnt == 0 or cur == 0:\n                    break\n                if cur > cnt:\n                    cur -= 1\n                    continue\n\n                if cnt not in rev_d or not rev_d[cnt]:\n                    cnt -= 1\n                    continue\n\n                mx_f = -1\n                v = -1\n                for max_cnt in range(cur, cnt + 1):\n                    if max_cnt in rev_d and rev_d[max_cnt] and rev_d[max_cnt][-1][1] > mx_f:\n                        v = max_cnt\n                        mx_f = rev_d[max_cnt][-1][1]\n                to_take = rev_d[v].pop()\n                # rev_d[cnt] -= 1\n                nb_candies += cur\n                given_away += min(to_take[1], cur)\n                cur -= 1\n                # rev_d[cnt - cur] += 1\n            print(nb_candies, given_away)\n\nsolver = GCandyBoxHardVersion()\ninput = sys.stdin.readline\n\nsolver.solve()\n
#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == "\n":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    def f(a,b):\n        if a == b:\n            return len(d[a])\n        da = d[a]\n        db = d[b]\n        res = 0\n        for x in range(len(da) >> 1):\n            l = da[x]\n            r = da[-1-x]\n            i = bisect.bisect_left(db,l)\n            j = bisect.bisect_left(db,r)\n            y = max(0,j-i)\n            s = 2*(x+1)+y\n            if res < s:\n                res = s\n        return res\n\n    t = I()\n    for _ in range(t):\n        n = I()\n        a = LI()\n        m = max(a)\n        d = [[] for i in range(m)]\n        for i in range(n):\n            ai = a[i]-1\n            d[ai].append(i)\n        ans = 1\n        for a in range(m):\n            if not d[a]:\n                continue\n            for b in range(m):\n                if not d[b]:\n                    continue\n                res = f(a,b)\n                if ans < res:\n                    ans = res\n        print(ans)\n    return\n\n#Solve\ndef __starting_point():\n    solve()\n\n__starting_point()
for __ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    ar.reverse()\n    ans = n - 1\n    flag = False\n    for i in range(1, n):\n        if ar[i] < ar[i - 1]:\n            flag = True\n        if flag:\n            if ar[i] > ar[i - 1]:\n                break\n        ans -= 1\n    print(ans)
import math\nfor _ in range(int(input())):\n    n=int(input())\n    if n==1:\n        print(0)\n    else:\n        k=int(n**(0.5))\n        if k*k<n:\n            k+=1\n        # print(n,k)    \n        ans=k-1\n        if k*(k-1)>=n:\n            ans+=(k-2)\n        else:\n            ans+=(k-1)\n        print(ans)    
import sys\ndef input():\n	return sys.stdin.readline()[:-1]\n\nt = int(input())\nfor _ in range(t):\n	n, k = map(int, input().split())\n	a = list(map(int, input().split()))\n	cum = [0 for _ in range(2*k+2)]\n	for i in range(n//2):\n		x, y = a[i], a[n-i-1]\n		cum[2] += 2\n		cum[min(x, y)+1] -= 1\n		cum[x+y] -= 1\n		cum[x+y+1] += 1\n		cum[max(x, y)+k+1] += 1\n		cum[2*k+1] -= 2\n	ans = n\n	for i in range(2, 2*k+1):\n		cum[i] += cum[i-1]\n		ans = min(ans, cum[i])\n	print(ans)
ans = []\nfor _ in range(int(input())):\n    n = int(input())\n    s = list(input())\n    t = list(input())\n    lvl = 0\n    X = [s, t]\n    f = 1\n    for i in range(n):\n        if s[i] in '3456' and t[i] in '3456':\n            lvl = 1 - lvl\n        elif X[lvl][i] in '3456':\n            f = 0\n            ans.append('NO')\n            break\n    if f and lvl == 1:\n        ans.append('YES')\n    elif f:\n        ans.append('NO')\nprint('\n'.join(ans))\n
from operator import itemgetter\nimport sys\ninput = sys.stdin.readline\n\nMAX_A = 200\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    ruiseki = [[0] * MAX_A for i in range(n + 1)]\n    for i in range(n):\n        for j in range(MAX_A):\n            ruiseki[i + 1][j] = ruiseki[i][j]\n            if a[i] - 1 == j:\n                ruiseki[i + 1][j] += 1\n\n    ans = 0\n    for num in set(a):\n        l = 0\n        r = n - 1\n        cnt = 0\n        while True:\n            while True:\n                if a[l] != num:\n                    l += 1\n                else:\n                    break\n            while True:\n                if a[r] != num:\n                    r -= 1\n                else:\n                    break\n            if l == r:\n                ans = max(ans, cnt + 1)\n                break\n            elif l > r:\n                break\n            cnt += 1\n            tmp_max = 0\n            for j in range(MAX_A):\n                tmp_max = max(tmp_max, ruiseki[r][j] - ruiseki[l + 1][j])\n            ans = max(ans, cnt * 2 + tmp_max)\n            l += 1\n            r -= 1\n    print(ans)
from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop,heapify\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\nM = mod = 998244353\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\n').split()]\ndef st():return input().rstrip('\n')\ndef val():return int(input().rstrip('\n'))\ndef li2():return [i for i in input().rstrip('\n')]\ndef li3():return [int(i) for i in input().rstrip('\n')]\n\nfor _ in range(val()):\n    n, k = li()\n    d = defaultdict(set)\n    for i in range(n-1):\n        a, b = li()\n        d[a].add(b)\n        d[b].add(a)\n    thistime = 1\n    he = deque()\n    visited = {}\n    for i in d:\n        if len(d[i]) == 1:\n            visited[i] = 1\n            he.append(i)\n    ans = 0\n    counts = defaultdict(int)\n    # print(he)\n\n    while he:\n        i = he.popleft()\n        for j in list(d[i]):\n            counts[j] += 1\n            d[i].remove(j)\n            d[j].remove(i)\n            if counts[j] == k:\n                thistime = 1\n                ans += 1\n                counts[j] = 0\n                if len(d[j]) == 1:\n                    if j not in visited:he.append(j)\n                    visited[j] = 1\n                    # print(j, he)\n    print(ans)
import sys\ninput = sys.stdin.readline\nimport bisect\n\nt=int(input())\nfor tests in range(t):\n    n=int(input())\n    A=list(map(int,input().split()))\n\n    compression_dict={a: ind for ind, a in enumerate(sorted(set(A)))}\n    A=[compression_dict[a] for a in A]\n\n    Q=[0]*n\n     \n    for i in range(n):\n        Q[A[i]]=i\n     \n    count=1\n    Ans=0\n    #print(A,Q)\n    for i in range(1,n):\n        if Q[i]>Q[i-1]:\n            count+=1\n        else:\n            Ans=max(count,Ans)\n            count=1\n\n    Ans=max(count,Ans)\n     \n    print(n-Ans)\n\n    \n
n = int(input())\nfor _ in range(n):\n    s = input()\n    l,r,u,d = [s.count(i) for i in 'LRUD']\n    lr = min(l, r)\n    ud = min(u, d)\n    res = ""\n    if lr == 0 and ud == 0:\n        res = ""\n    elif lr == 0:\n        res = "UD"\n    elif ud == 0:\n        res = 'LR'\n    else:\n        res = 'R' * lr + 'U' * ud + 'L' * lr + 'D' * ud\n    print(len(res))\n    print(res)
import sys\n\ninput=sys.stdin.readline\n\n#t=1\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    s=input().rstrip()\n    s=[s[-i-1] for i in range(n)]\n    ans=[]\n    zero=[]\n    one=[]\n    res=[-1]*n\n    pos=0\n    while s:\n        b=s.pop()\n        if b=="0":\n            if not one:\n                new=1\n                ans.append(new)\n                res[pos]=len(ans)\n                zero.append(len(ans)-1)\n            else:\n                id=one.pop()\n                ans[id]+=1\n                res[pos]=id+1\n                zero.append(id)\n        else:\n            if not zero:\n                new=1\n                ans.append(new)\n                res[pos]=len(ans)\n                one.append(len(ans)-1)\n            else:\n                id=zero.pop()\n                ans[id]+=1\n                res[pos]=id+1\n                one.append(id)\n        pos+=1\n    print(len(ans))\n    print(*res)\n
import sys\ninput = sys.stdin.readline\nrInt = lambda: int(input())\nmInt = lambda: map(int, input().split())\nrLis = lambda: list(map(int, input().split()))\n\nouts = []\n\nt = rInt()\nfor _ in range(t):\n    n, k = mInt()\n    s = input()\n\n    pref = [0]\n    for c in s:\n        if c == '1':\n            pref.append(pref[-1] + 1)\n        else:\n            pref.append(pref[-1])\n\n    best = pref[-1]\n\n    dp = []\n    for i in range(n):\n        cost = pref[i]\n        if i >= k:\n            case2 = dp[i - k] + pref[i] - pref[i - k + 1]\n            if case2 < cost:\n                cost = case2\n        if s[i] == '0':\n            cost += 1\n\n        dp.append(cost)\n        actual = cost + pref[-1] - pref[i + 1]\n        if actual < best:\n            best = actual\n\n    outs.append(best)\n\n\nprint(*outs, sep = '\n')\n
for i in range(int(input())):\n    s='R' + input() + 'R'\n    prev=0\n    ma=-1\n    for i in range(1,len(s)):\n        if s[i]=='R':\n            ma=max(ma,i-prev)\n            prev=i\n    print(ma)        \n        \n
def isvalid(s):\n    nonlocal l\n    for i in l:\n        count=0\n        for j in range(len(i)):\n            if(s[j]!=i[j]):\n                count+=1\n        if(count>1):\n            return 0\n    return 1\nt=int(input())\nfor you in range(t):\n    l=input().split()\n    n=int(l[0])\n    m=int(l[1])\n    l=[]\n    for i in range(n):\n        s=input()\n        l.append(s)\n    poss=0\n    ans=0\n    for i in range(m):\n        copy=[x for x in l[0]]\n        for j in range(26):\n            copy[i]=chr(97+j)\n            if(isvalid(copy)):\n                poss=1\n                ans=copy\n                break\n        if(poss==1):\n            break\n    if(poss):\n        for i in ans:\n            print(i,end="")\n        print()\n    else:\n        print(-1)
\nT = int(input())\n\nfor _ in range(T):\n    a, b = list(map(int, input().split()))\n    print(max(max(a, b), min(a, b) * 2)**2)\n
from sys import stdin\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int,input().split()))\n    id = list(zip(l,list(range(n))))\n    id.sort()\n    val, pos = zip(*id)\n    blok = []\n    cur = [pos[0]]\n    for i in range(1,n):\n        if val[i] == val[i-1]:\n            cur.append(pos[i])\n        else:\n            cur.sort()\n            blok.append(cur)\n            cur = [pos[i]]\n    cur.sort()\n    blok.append(cur)\n    best = 0\n    m = len(blok)\n    for j in range(m):\n        best = max(len(blok[j]), best)\n    i = 0\n    while True:\n        if i >= m-2:\n            break\n        cyk = min(blok[i+1])\n        j = -1\n        while j+1 < len(blok[i]) and blok[i][j+1] < cyk:\n            j += 1\n        su = (j+1)\n        ii = i+2\n        while ii < m:\n            if min(blok[ii]) > max(blok[ii-1]):\n                su += len(blok[ii-1])\n                ii += 1\n            else:\n                break\n        if ii == m:\n            su += len(blok[-1])\n            best = max(best, su)\n        else:\n            xxx = max(blok[ii-1])\n            su += len(blok[ii-1])\n            inde = len(blok[ii])-1\n            while inde >= 0 and blok[ii][inde] >= xxx:\n                su += 1\n                inde -= 1\n            best = max(best,su)\n        i = max(i+1, ii-1)\n    for i in range(1,m):\n        b1 = blok[i];b0 = blok[i-1];l0,l1,i1 = len(b0),len(b1),0\n        for ind in range(l0):\n            while True:\n                if i1 < l1 and b1[i1] <= b0[ind]:i1 += 1\n                else:break\n            if l1 == i1:break\n            best = max(best, (ind+1)+(l1-i1))\n    print(n-best)
import sys\ninput = sys.stdin.readline\n\ndef search(i,j):\n    L=[]\n\n    c=0\n\n    while CHECK[i][j]==1<<30:\n        L.append((i,j))\n        \n        CHECK[i][j]=c\n\n        if MAP2[i][j]=="U":\n            i-=1\n        elif MAP2[i][j]=="D":\n            i+=1\n        elif MAP2[i][j]=="R":\n            j+=1\n        else:\n            j-=1\n\n        c+=1\n\n    if (i,j) in L:\n        x=CHECK[i][j]\n        y=CHECK[L[-1][0]][L[-1][1]]\n        loop=abs(x-y)+1\n\n        for x,y in L:\n            CHECK[x][y]%=loop\n            LOOP[x][y]=loop\n\n    else:\n        loop=LOOP[i][j]\n        c=CHECK[i][j]\n\n        for x,y in L[::-1]:\n            c=(c-1)%loop\n            CHECK[x][y]=c\n            LOOP[x][y]=loop\n\ndef search2(i,j):\n    Q=[(i,j)]\n    ANS=[0]*LOOP[i][j]\n\n    while Q:\n        x,y=Q.pop()\n\n        if USE[x][y]==1:\n            continue\n        \n        USE[x][y]=1\n        if MAP[x][y]=="0":\n            ANS[CHECK[x][y]]=1\n\n        if MAP2[x][y]=="U":\n            Q.append((x-1,y))\n        elif MAP2[x][y]=="D":\n            Q.append((x+1,y))\n        elif MAP2[x][y]=="R":\n            Q.append((x,y+1))\n        else:\n            Q.append((x,y-1))\n\n\n        if 0<=x+1<n and 0<=y<m and MAP2[x+1][y]=="U":\n            Q.append((x+1,y))\n            \n        if 0<=x-1<n and 0<=y<m and MAP2[x-1][y]=="D":\n            Q.append((x-1,y))\n            \n        if 0<=x<n and 0<=y+1<m and MAP2[x][y+1]=="L":\n            Q.append((x,y+1))\n            \n        if 0<=x<n and 0<=y-1<m and MAP2[x][y-1]=="R":\n            Q.append((x,y-1))\n\n    return LOOP[i][j],sum(ANS)\n\n\nt=int(input())\nfor tests in range(t):\n    n,m=list(map(int,input().split()))\n    MAP=[input().strip() for i in range(n)]\n    MAP2=[input().strip() for i in range(n)]\n\n    CHECK=[[1<<30]*m for i in range(n)]\n    LOOP=[[1<<30]*m for i in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if CHECK[i][j]==1<<30:\n                search(i,j)\n\n                #print(i,j)\n\n    #print(CHECK)\n    #print(LOOP)\n\n    USE=[[0]*m for i in range(n)]\n\n    ANSM=0\n    ANSC=0\n\n    for i in range(n):\n        for j in range(m):\n            if USE[i][j]==0:\n                x,y=search2(i,j)\n                ANSM+=x\n                ANSC+=y\n    print(ANSM,ANSC)\n                \n            \n    \n    \n
t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(*set(a))
import math\nfrom decimal import Decimal\nimport heapq\nimport copy\nimport heapq\nfrom collections import deque\ndef na():\n	n = int(input())\n	b = [int(x) for x in input().split()]\n	return n,b\n \n	\ndef nab():\n	n = int(input())\n	b = [int(x) for x in input().split()]\n	c = [int(x) for x in input().split()]\n	return n,b,c\n \n		\ndef dv():\n	n, m = list(map(int, input().split()))\n	return n,m\n \n \ndef da():\n	n, m = list(map(int, input().split()))\n	a = list(map(int, input().split()))\n	return n,m, a \n \n \ndef dva():\n	\n	n, m = list(map(int, input().split()))\n	a = [int(x) for x in input().split()]\n	b = [int(x) for x in input().split()]\n	return n,m,b\n \n \ndef eratosthenes(n): \n	sieve = list(range(n + 1))\n	for i in sieve:\n		if i > 1:\n			for j in range(i + i, len(sieve), i):\n				sieve[j] = 0\n	return sorted(set(sieve))\n \n \ndef lol(lst,k):\n	k=k%len(lst)\n	ret=[0]*len(lst)\n	for i in range(len(lst)):\n		if i+k<len(lst) and i+k>=0:\n			ret[i]=lst[i+k]\n		if i+k>=len(lst):\n			ret[i]=lst[i+k-len(lst)]\n		if i+k<0:\n			ret[i]=lst[i+k+len(lst)]\n	return(ret)\ndef nm():\n	n = int(input())\n	b = [int(x) for x in input().split()]\n	m = int(input())\n	c = [int(x) for x in input().split()]\n	return n,b,m,c\n \n \ndef dvs():\n	n = int(input())\n	m = int(input())\n	return n, m \n \n\ndef fact(n):\n	tc = []\n	ans = {}\n	d = 2\n	while d * d <= n:\n		if n % d == 0:\n			tc.append(d)\n			n //= d\n		else:\n			d += 1\n	if n > 1:\n		tc.append(n)\n	for i in tc:\n		ans[i] = ans.get(i, 0) + 1\n	return ans\n\n\nfor i in range(int(input())):\n	s = int(input())\n	ans = 0\n	while s >= 10:\n		d = s // 10\n		ans += d * 10\n		s += d\n		s -= d * 10\n	ans += s\n	print(ans)\n
import sys\ninput = sys.stdin.readline\nT = int(input())\nfor _ in range(T):\n    N, M = list(map(int, input().split()))\n    E = [[] for aa in range(N)]\n    for __ in range(M):\n        a, b = list(map(int, input().split()))\n        E[a-1].append(b-1)\n        E[b-1].append(a-1)\n    \n    D = [-1] * N\n    D[0] = 0\n    d = 0\n    post = [0]\n    EVEN = [1]\n    ODD = []\n    while post:\n        d += 1\n        pre = post\n        post = []\n        for i in pre:\n            for e in E[i]:\n                if D[e] < 0:\n                    D[e] = d\n                    post.append(e)\n                    if d % 2:\n                        ODD.append(e+1)\n                    else:\n                        EVEN.append(e+1)\n    if len(ODD) < len(EVEN):\n        print(len(ODD))\n        print(*ODD)\n    else:\n        print(len(EVEN))\n        print(*EVEN)\n
from sys import stdin\nimport math\n\nrgb = 'RGB'\n\nfor query in range(int(stdin.readline())):\n    n, k = list(map(int, stdin.readline().split()))\n    s = stdin.readline()\n\n    ans = math.inf\n    for start in range(3):\n        dp = [0 for i in range(n + 1)] \n        for i in range(n):\n            cur = rgb[(start + i) % len(rgb)]\n            dp[i + 1] = dp[i] + int(s[i] != cur)\n        for i in range(n - k + 1):\n            ans = min(ans, dp[i + k] - dp[i])\n    print(ans)\n\n\n
import sys\ninput = sys.stdin.readline\n\nQ = int(input())\nfor _ in range(Q):\n    N = int(input())\n    A = [int(a) for a in input().split()]\n    X = {}\n    for a in A:\n        if a in X:\n            X[a] += 1\n        else:\n            X[a] = 1\n    Y = []\n    for x in X:\n        Y.append(X[x])\n    Y = sorted(Y)[::-1]\n    prev = Y[0] + 1\n    su = 0\n    for i in range(len(Y)):\n        ne = min(prev-1, Y[i])\n        if ne <= 0:\n            break\n        su += ne\n        prev = ne\n    print(su)\n\n
t = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list([int(x)- 1 for x in input().split()])\n    out = []\n\n    ll = [(l[i], i) for i in range(n)]\n    ll.sort()\n\n    swap = (-1,-1)\n    for i in range(n - 1):\n        if ll[i][0] == ll[i + 1][0]:\n            swap = (ll[i][1],ll[i+1][1])\n\n    newl = [0]*n\n    for i in range(n):\n        newl[ll[i][1]] = i\n\n    l = newl\n\n    swapN = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if l[i] > l[j]:\n                swapN += 1\n\n    #print(l)\n    if swapN & 1:\n        l[swap[0]],l[swap[1]] = l[swap[1]],l[swap[0]]\n    #print(l)\n\n    def shift(i):\n        out.append(i + 1)\n        l[i],l[i+1],l[i+2] = l[i+2],l[i],l[i+1]\n\n    works = True\n    done = False\n\n    while not done:\n    \n        for i in range(n):\n            if l[i] != i:\n                break\n        else:\n            done = True\n\n        if done:\n            break\n\n        for find in range(i + 1, n):\n            if l[find] == i:\n                break\n\n        while find - i >= 2:\n            find -= 2\n            shift(find)\n\n        if find - i == 1:\n            if find <= n - 2:\n                shift(find - 1)\n                shift(find - 1)\n            else:\n                works = False\n                break\n\n    #print(l)\n    if works:\n        print(len(out))\n        print(' '.join(map(str,out)))\n    else:\n        print(-1)\n    #print('---')\n        \n    \n
for _ in range(int(input())):\n    n, m = list(map(int, input().split()))\n    A = []\n    x = 1\n    while True:\n        if (m * x) % 10 not in A:\n            A.append((m * x) % 10)\n        else:\n            break\n        x += 1\n    s = sum(A)\n    n //= m\n    print(s * (n // len(A)) + sum(A[:n % len(A)]))\n
def read_int():\n    return int(input())\n\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\n\nt = read_int()\nfor case_num in range(t):\n    n = read_int()\n    mat = []\n    for i in range(n):\n        mat.append(input())\n    ok = True\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] == '0':\n                continue\n            cok = j == n - 1 or i == n - 1\n            if not cok:\n                cok = mat[i][j + 1] == '1' or mat[i + 1][j] == '1'\n            if not cok:\n                ok = False\n                break\n        if not ok:\n            break\n    print('YES' if ok else 'NO')\n
for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    st = 0\n    fans = 0\n    for x in s:\n        if x == ')':\n            st -= 1\n        else:\n            st += 1\n        if st < 0:\n            fans += 1\n            st = 0\n    print(fans)
for _ in range(int(input())):\n    n=int(input())\n    s=input()\n    a=""\n    b=""\n    flag=1\n    for i in s:\n        if flag:\n            if i=="2":\n                a+="1"\n                b+="1"\n            elif i=="1":\n                a+="1"\n                b+="0"\n                flag=0\n            else:\n                a+="0"\n                b+="0"\n        else:\n            if i=="2":\n                a+="0"\n                b+="2"\n            elif i=="1":\n                a+="0"\n                b+="1"\n                flag=0\n            else:\n                a+="0"\n                b+="0"\n    print(a)\n    print(b)
# coding: utf-8\n# Your code here!\n\ndef solve(s, c):\n    if(len(s)==1):\n        if s[0]==c:\n            return 0\n        else:\n            return 1\n    ans1 = sum([i!=c for i in s[:len(s)//2]]) + solve(s[len(s)//2:],chr(ord(c)+1))\n    ans2 = sum([i!=c for i in s[len(s)//2:]]) + solve(s[:len(s)//2],chr(ord(c)+1))\n    return min(ans1, ans2)\n    \n    \nfor _ in range(int(input())):\n    input()\n    print(solve(input(),'a'))
def read_int():\n    return int(input())\n\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\n\nt = read_int()\nfor case_num in range(t):\n    n, m = read_ints()\n    a = []\n    for i in range(n):\n        a.append(int(input(), 2))\n    a.sort()\n    k = 2 ** m - n\n    ans = (k - 1) // 2\n    for ai in a:\n        if ai <= ans:\n            ans += 1\n    binary = '{:b}'.format(ans)\n    print(binary.rjust(m, '0'))\n
import sys\n\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep="\n")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef maketo():\n    atoi=[[] for _ in range(n)]\n    for i,a in enumerate(aa):\n        if a<1 or a>n:return True\n        atoi[a-1].append(i)\n        if len(atoi[a-1])>2:return True\n    for a in range(n):\n        u,v=atoi[a]\n        if u+n==v:continue\n        to[u].append((v+n)%(n*2))\n        to[v].append((u+n)%(n*2))\n    return False\n\ndef dfs(u):\n    flap[u%n]=(u>=n)*1\n    cur[u>=n].append(u%n+1)\n    stack=[u]\n    while stack:\n        u=stack.pop()\n        for v in to[u]:\n            if flap[v%n]==-1:\n                flap[v % n]=(v>=n)*1\n                cur[v >= n].append(v % n+1)\n                stack.append(v)\n            elif flap[v % n]!=(v>=n)*1:return True\n    return False\n\nfor _ in range(II()):\n    n=II()\n    aa=LI()+LI()\n    to=[[] for _ in range(n*2)]\n\n    if maketo():\n        print(-1)\n        continue\n    #print(to)\n\n    ans = []\n    flap=[-1]*n\n    ng=False\n    for u in range(n):\n        #u+=n\n        if flap[u%n]!=-1:continue\n        cur=[[],[]]\n        ng=dfs(u)\n        if len(cur[0])<len(cur[1]):ans+=cur[0]\n        else:ans+=cur[1]\n        #print(u,flap,cur,ans)\n        if ng:break\n\n    if ng:print(-1)\n    else:\n        print(len(ans))\n        print(*ans)\n
from sys import stdin, stdout\nimport functools\nimport sys,os,math\n\n#sys.setrecursionlimit(10**6)\n\nT = int(input())\nfor _ in range(T):\n    N, M = list(map(int, input().split()))\n    DS = [0] * (N + 1)\n    ES = []\n    g = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        t, u, v = list(map(int, input().split()))\n        ES.append([t ,u ,v])\n        if t == 1:\n            DS[u] += 1\n        g[u].append(len(ES) - 1)\n        g[v].append(len(ES) - 1)\n\n    q = []\n    for u in range(1, N+1):\n        if DS[u] == 0:\n            q.append(u)\n\n    while len(q) > 0:\n        u = q.pop()\n        if DS[u] > 0:\n            continue\n\n        for e in g[u]:\n            t, u0, v0 = ES[e]\n            if t == 1:\n                if v0 == u:\n                    DS[u0] -= 1\n                    if DS[u0] == 0:\n                        q.append(u0)\n            elif t == 0:\n                v = v0 if u0 == u else u0\n                ES[e] = [1, v, u]\n    \n    md = max(DS)\n    if md > 0:\n        print("NO")\n    else:\n        print("YES")\n        for e in ES:\n            print(e[1], e[2])\n\n        \n\n
import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = [int(a) for a in input().split()]\n    \n    if max(A) == min(A):\n        print(1)\n        print(*([1] * N))\n    elif N % 2 == 0:\n        print(2)\n        print(*([1, 2] * (N // 2)))\n    else:\n        for i in range(N):\n            if A[i-1] == A[i]:\n                print(2)\n                print(*(([1, 2] * N)[:i][::-1] + ([1, 2] * N)[:N-i]))\n                break\n        else:\n            print(3)\n            print(*([3] + [1, 2] * (N // 2)))\n\n
class Solution:\n     def wordPattern(self, pattern, str):\n         """\n         :type pattern: str\n         :type str: str\n         :rtype: bool\n         """\n         # d['a'] = word\n         #pattern_arr = list(pattern)\n         str_arr = str.split()\n         pattern_dict = {}\n         str_dict = {}\n         \n         pattern_tokenize = []\n         token_p = 0\n         \n         str_tokenize = []\n         token_s = 0\n         \n         for char in pattern:\n             if char not in list(pattern_dict.keys()):\n                 pattern_dict[char] = token_p\n                 token_p += 1\n                 pattern_tokenize.append(token_p)\n             else:\n                 pattern_tokenize.append(pattern_dict[char])\n                 \n         for word in str_arr:\n             if word not in list(str_dict.keys()):\n                 str_dict[word] = token_s\n                 token_s += 1\n                 str_tokenize.append(token_s)\n             else:\n                 str_tokenize.append(str_dict[word])\n             \n         return (pattern_tokenize == str_tokenize)\n         \n         \n
class Solution:\n     def reverseWords(self, s):\n         """\n         :type s: str\n         :rtype: str\n         """\n         rev_str = s[::-1]\n         rev_arr = rev_str.split()\n         final = rev_arr[::-1]\n         \n         return ' '.join(map(str, final))\n \n
class Solution:\n     def checkPerfectNumber(self, num):\n         """\n         :type num: int\n         :rtype: bool\n         """\n         perfect = set([6, 28, 496, 8128, 33550336, 8589869056])\n         return num in perfect
class Solution:\n    def findKthPositive(self, arr: List[int], k: int) -> int:\n        lo, hi = 0, len(arr) - 1\n        while lo < hi:\n            mid = hi - (hi - lo) // 2\n            # mid = lo + (hi - lo) // 2\n            missing = arr[mid] - mid - 1\n            if missing < k:\n                lo = mid\n            else:\n                hi = mid - 1\n\n        if arr[lo] - lo - 1 >= k:\n            return k\n        else:\n            return k + lo + 1
class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        \n        obstacles = set([tuple(x) for x in obstacles])\n        \n        face = 0 # NESW = 0123\n        x,y = 0,0\n        max_dist = 0\n        for command in commands:\n            if command==-2:\n                face = (face-1)%4\n            elif command==-1:\n                face = (face+1)%4\n            else:\n                if face==0:\n                    for i in range(1, command+1):\n                        if (x,y+i) in obstacles:\n                            i -= 1\n                            break\n                    y += i\n                    \n                elif face==1:\n                    for i in range(1, command+1):\n                        if (x+i,y) in obstacles:\n                            i -= 1\n                            break\n                    x += i\n                    \n                elif face==2:\n                    for i in range(1, command+1):\n                        if (x,y-i) in obstacles:\n                            i -= 1\n                            break\n                    y -= i\n                    \n                else:\n                    for i in range(1, command+1):\n                        if (x-i,y) in obstacles:\n                            i -= 1\n                            break\n                    x -= i\n                    \n                max_dist = max(max_dist, x**2+y**2)\n                \n        return max_dist
class Solution:\n    def peakIndexInMountainArray(self, arr: List[int]) -> int:\n        l,r = 0,len(arr)-1\n        while l<=r:\n            m = (l+r)//2\n            if (arr[m]>=arr[m-1])and (arr[m]>=arr[m+1]):\n                return m\n            else:\n                if arr[m-1]>arr[m]:\n                    r = m-1\n                else:\n                    l = m+1\n
class Solution:\n    def subtractProductAndSum(self, n: int) -> int:\n        stringInt = str(n)\n        product = 1\n        sum = 0\n        for i in stringInt:\n            product *= int(i)\n            sum += int(i)    \n        return product - sum
class Solution:\n     def firstUniqChar(self, s):\n         """\n         :type s: str\n         :rtype: int\n         """\n         if not s:\n             return -1\n         elif len(s) == 1:\n             return 0\n \n         result = len(s)\n         for ch in range(ord('a'), ord('z') + 1):\n             if s.find(chr(ch)) == -1:\n                 continue\n             if s.find(chr(ch)) == s.rfind(chr(ch)):\n                 result = min(result, s.find(chr(ch)))\n         return result if result < len(s) else -1
class Solution:\n    def maximum69Number (self, num: int) -> int:\n        numString = str(num)\n        numLength = len(numString)\n        firstIndex = numString.find('6')\n        if firstIndex == -1:\n            return num\n        else:\n            return num+3*10**(numLength-firstIndex-1)
class Solution:\n    def isLongPressedName(self, name: str, typed: str) -> bool:\n        name=list(name)\n        typed= list(typed)\n        \n        while name:\n            i, j=0,0\n            n=name[0]\n            while name and name[0]==n:\n                i+=1\n                name.pop(0)\n            while typed and typed[0]==n:\n                j+=1\n                typed.pop(0)\n                \n            if j<i:\n                return False \n        if typed:\n            return False\n    \n        return True\n                \n                \n
class Solution:\n     def thirdMax(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         nums = sorted(list(set(nums)))\n         if len(nums)<3:\n             return max(nums)\n         else:\n             return nums[-3]\n \n             \n
from string import ascii_lowercase\nclass Solution:\n    def removeDuplicates(self, S: str) -> str:\n        \n        dup = {2*ch for ch in ascii_lowercase}\n        \n        prev_length = -1\n        \n        while prev_length!=len(S):\n            prev_length = len(S)\n            for d in dup:\n                S = S.replace(d,'')\n        \n        return S
class Solution:\n     def largestPalindrome(self, n):\n         """\n         :type n: int\n         :rtype: int\n         """\n         A = [0,9,987,123,597,677,1218,877,475]\n         return A[n]
class Solution:\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\n        da = defaultdict(set)\n        db = defaultdict(set)\n        dc = defaultdict(set)\n        for i in range(len(arr)-1):\n            for j in range(i+1,len(arr)):\n                dis = abs(arr[j]-arr[i])\n                if dis <= a: da[i].add(j)\n                if dis <= b: db[i].add(j)\n                if dis <= c: dc[i].add(j)\n        count = 0\n        for i in range(len(arr)-2):\n            for j in da[i]:\n                for k in db[j]:\n                    if k in dc[i]:  count += 1\n        return count
class Solution:\n     def searchInsert(self, nums, target):\n         """\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         """\n \n         num=[i for i in nums if i<target]\n         return len(num)
class Solution:\n     def isPerfectSquare(self, num):\n         """\n         :type num: int\n         :rtype: bool\n         """\n         n = num**0.5\n         if n == int(n):\n             return True\n         else:\n             return False
class Solution:\n     def convertToBase7(self, num):\n         """\n         :type num: int\n         :rtype: str\n         """\n         if num < 0:\n             return '-' + str(self.convertToBase7(-num))\n         elif num < 7:\n             return str(num)\n         else:\n             return str(self.convertToBase7(num//7)) + str(num % 7)
class Solution:\n     def containsDuplicate(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: bool\n         """\n         num_set = set(nums)\n         if len(nums) == len(num_set):\n             return False\n         return True\n
class Solution:\n     def repeatedStringMatch(self, A, B):\n         """\n         :type A: str\n         :type B: str\n         :rtype: int\n         """\n         \n         if not set(B).issubset(set(A)):\n             return -1\n         \n         max_rep = len(B) // len(A) + 3\n         A_new = A\n         \n         for i in range(1,max_rep):\n             if B in A_new:\n                 return i\n             A_new += A\n         return -1
class Solution:\n     def isAnagram(self, s, t):\n         """\n         :type s: str\n         :type t: str\n         :rtype: bool\n         """\n         # dic = {}\n         # for item in s:\n         #     if item not in dic:\n         #         dic[item] = 1\n         #     else:\n         #         dic[item] += 1\n         # for i in t:\n         #     if i not in dic:\n         #         return False\n         #     else:\n         #         dic[i] -= 1\n         # return all(value == 0 for value in dic.values())\n         \n         # fastest way till now with reference to the others' submissions\n         if len(s) != len(t):\n             return False\n         if s == t:\n             return True\n         for i in map(chr, range(97, 123)):\n             if s.count(i) != t.count(i):\n                 return False\n         return True
class Solution:\n     def majorityElement(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         n=len(nums)\n         if n==1 :\n             return nums[0]\n         if n%2 :\n             find = set(nums[0:(n//2)+1]) & set(nums[n//2:])\n         else:\n             find = set(nums[0:n//2]) & set(nums[n//2:])\n         \n         for i in find:\n             if nums.count(i)>n//2:\n                 return i
class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        if nums[0] > nums[1]:\n            largest = nums[0]\n            second_largest = nums[1]\n        else:\n            largest = nums[1]\n            second_largest = nums[0]\n        for i in range(2,len(nums)):\n            if nums[i] > largest:\n                second_largest = largest\n                largest = nums[i]\n            elif nums[i] > second_largest:\n                second_largest = nums[i]\n        return (largest-1) * (second_largest -1)\n                \n                \n                \n
class Solution:\n    def minStartValue(self, nums: List[int]) -> int:\n        res = 1\n        for ind,n in enumerate(nums):\n            temp = 1-sum(nums[:ind+1])\n            if(temp > res):\n                res = temp\n        return res
class Solution:\n     def addStrings(self, num1, num2):\n         """\n         :type num1: str\n         :type num2: str\n         :rtype: str\n         """\n         if len(num1) < len(num2):\n             num1, num2 = num2, num1\n         addon = 0\n         res = ""\n         l = len(num2)\n         for i in range(l):\n             s =  ord(num2[l - i - 1]) + ord(num1[len(num1) - i - 1]) - 2 * ord("0") + addon\n             addon = s // 10\n             res = chr(s % 10 + ord("0")) + res\n         for i in range(l, len(num1)):\n             s = ord(num1[len(num1) - i - 1]) - ord("0") + addon \n             addon = s // 10\n             res = chr(s % 10 + ord("0")) + res\n         if addon > 0:\n             res = "1" + res\n         return res\n             \n
class Solution:\n     def countSegments(self, s):\n         """\n         :type s: str\n         :rtype: int\n         """\n         return len(s.split())
class Solution:\n    def smallestRangeI(self, A: List[int], K: int) -> int:\n        if len(A) == 1:\n            return 0\n        _min = min(A)\n        _max = max(A)\n        if _max - K <= _min + K:\n            return 0\n        return _max - _min - 2*K
class Solution:\n     def findMaxConsecutiveOnes(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         if nums == []:\n             return 0\n         \n         count = 0\n         countMax =0\n         for ele in nums:\n             if ele == 1:\n                 count += 1\n             else:\n                 if count > countMax:\n                     countMax = count\n                 count = 0\n         \n         if count > countMax:\n             countMax = count\n         \n         return countMax\n
class Solution:\n     def singleNumber(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         l = len(nums)\n         if l == 1:\n             return nums[0]\n         \n         # Attempt 1 - 80%\n         # nums.sort()\n         # i = 0\n         # while i < l:\n         #     if i+1 == l:\n         #         return nums[i]\n         #     elif nums[i] != nums[i+1]:\n         #         #either i or i+1\n         #         if nums[i+2] == nums[i+1]:\n         #             return nums[i]\n         #     else:  \n         #         i+=2\n         \n         # Attempt 2 - 100%\n         result = 0\n         for num in nums:\n             result ^= num\n         return result\n
class Solution:\n    def isBoomerang(self, points: List[List[int]]) -> bool:\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        x3, y3 = points[2]\n        \n        return (y2 - y1) * (x3 - x1) != (y3 - y1) * (x2 - x1)\n
class Solution:\n     def hasAlternatingBits(self, n):\n         """\n         :type n: int\n         :rtype: bool\n         """\n         \n         if n % 2 == 0:\n             n = n >> 1\n         \n         cnt = 0\n         a = n\n         while (a>0):\n             cnt += 1\n             a = a >> 1\n         \n         if cnt % 2 == 0:\n             return False\n         \n         c = 1\n         for i in range(1, cnt):\n             c = c << 1\n             if i % 2 == 0:\n                 c += 1\n                 \n         return c == n\n
class Solution:\n     def findPairs(self, nums, k):\n         """\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         """\n         # import collections\n         # unique_nums = set(nums)\n         # count = 0\n         # new_nums = collections.Counter(nums)\n         # if k == 0:\n         #     for i in unique_nums:\n         #         if new_nums[i] > 1:\n         #             count +=1\n         #     return count\n         # elif k < 0:\n         #     return 0\n         # elif k > 0:\n         #     for i in unique_nums:\n         #         if i+k in unique_nums:\n         #             count += 1\n         #     return count\n         \n # counter\n         # import collections\n         # count = 0\n         # list_nums = set(nums)\n         # if k == 0:\n         #     nums = collections.Counter(nums)\n         #     for each in nums:\n         #         if nums[each] > 1:\n         #             count += 1\n         #     return count\n         # elif k < 0:\n         #     return 0\n         # elif k > 0:\n         #     for i in list_nums:\n         #         if i + k in list_nums:\n         #             count += 1\n         #     return count\n         \n # dict\n \n         count = 0\n         if k < 0 :\n             return count\n         if k == 0:\n             new_nums = collections.defaultdict(int)\n             for i in nums:\n                 new_nums[i] +=1\n             for value in new_nums:\n                 if new_nums[value] > 1:\n                     count += 1\n             return count\n         if k > 0 :\n             nums = set(nums)\n             for i in nums:\n                 if i+k in nums:\n                     count += 1\n             return count\n \n #         if k < 0:\n #             return 0\n #         if k == 0:\n #             dict = collections.defaultdict(int)\n #             for i in nums:\n #                 dict[i] += 1\n #             ans = 0\n #             for value in dict.values():\n #                 if value > 1:\n #                     ans += 1\n #             return ans\n #         nums = set(nums)\n #         ans = 0\n #         for item in nums:\n #             if item+k in nums:\n #                 ans += 1\n #         return ans\n
class Solution:\n     def calPoints(self, ops):\n         """\n         :type ops: List[str]\n         :rtype: int\n         """\n         sum = 0\n         for i in range (len(ops)):\n             op = ops[i]\n             if self.isInt(op):\n                sum = sum + int(op)\n             elif op == 'C':\n                 for j in range(i-1 ,-1,-1):\n                     if self.isInt(ops[j]):\n                         sum = sum - int(ops[j])\n                         ops[j] = 'x'\n                         break\n             elif op == 'D':\n                 for j in range(i-1 ,-1,-1):\n                     if self.isInt(ops[j]):\n                         ops[i] = str(int(ops[j]) * 2)\n                         sum = sum + int(ops[i])\n                         break\n             elif op == '+':\n                 for j in range(i-1 , -1,-1):\n                     if self.isInt(ops[j]):\n                         for k in range(j-1, -1,-1):\n                             if self.isInt(ops[k]):\n                                 ops[i] = str(int(ops[j]) + int(ops[k]))\n                                 sum = sum + int(ops[i])\n                                 break\n                         break\n                         \n         return sum\n     \n     \n     def isInt(self,x):\n         try:\n             return type(int(x)) == int\n         except ValueError:\n             return False
class Solution:\n     def licenseKeyFormatting(self, S, K):\n         """\n         :type S: str\n         :type K: int\n         :rtype: str\n         """\n #         count_dash = 0\n #         for item in S:\n #             if item == '-':\n #                 count_dash += 1\n                 \n #         S_len = len(S) - count_dash\n         \n #         ans = ''\n #         second_from = 0\n         \n #         frist_group = S_len % K\n #         if frist_group != 0:\n #             count = 0\n #             for i in range(len(S)):\n #                 if S[i] != '-':\n #                     ans = ans + S[i].upper()\n #                     count += 1\n #                 if count == frist_group:\n #                     second_from = i + 1\n #                     ans += '-'\n #                     break\n #         count_k = 0\n #         for j in range(second_from,len(S)):\n #             if S[j] != '-':\n #                 ans = ans + S[j].upper()\n #                 count_k += 1\n #             if count_k == K:\n #                 ans = ans + '-'\n #                 count_k = 0\n         \n #         return ans[:-1]\n         S = S.replace('-', '')[::-1].upper()\n         return '-'.join([S[i:i+K] for i in range(0, len(S), K)])[::-1]\n
class Solution:\n     def isOneBitCharacter(self, bits):\n         """\n         :type bits: List[int]\n         :rtype: bool\n         """\n         \n         """\n         i = 0\n         while i < len(bits)-1:\n             if bits[i] == 1:\n                 i += 2\n                 \n             else: # bits[i] is 0\n                 i += 1\n         # index: 0,1,2,..., L-2, L-1, where L denotes len(bits)\n         if i == len(bits): # i comes from i+=2 case, bits[L-2] is 1, current i is one more of the last index, i.e. len(bits)\n             return False   # ...10\n         \n         else:              # i comes from i+=1 case, bits[L-2] is 0, current i is the last index, len(bits)-1\n             return True    # ...00\n         """\n         \n         # Approach 2, much faster, scan from the back, till see a zero or exhaust the list\n         # count how many one's there is.\n         # Reason: ????...???0xxxx0  Only xxxx0 matters.  After a 0, start the process again.\n         # 0 always marks the end of the earlier bits.\n         count = 0\n         i = len(bits)-2 # s[len(s)-1] the last item in s is always 0.\n         while i>=0 and bits[i] is not 0:\n             count += 1\n             i -= 1\n         \n         if (count % 2) == 0:\n             return True\n         else:\n             return False\n         \n             \n             \n
class Solution:\n    def generateTheString(self, n: int) -> str:\n        \n        \n        \n        if n%2 == 0:\n            \n            return ''.join(['a']*(n-1) + ['b'])\n    \n        else:\n            if n == 1:\n                return 'a'\n            else:\n                return ''.join(['a']*(n-2) + ['bc'])
class Solution:\n     def isPalindrome(self, s):\n         """\n         :type s: str\n         :rtype: bool\n         """\n         cleanlist = [c for c in s.lower() if c.isalnum()]\n         return cleanlist == cleanlist[::-1]
import queue\n\n\nclass Solution:\n    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\n        streak = 0\n        \n        for i in range(len(arr)-m):\n            if arr[i] == arr[i+m]:\n                streak +=1\n            else:\n                streak = 0\n            if streak == (k-1)*m:\n                return True\n            \n        return False
class Solution:\n     def lengthOfLastWord(self, s):\n         """\n         :type s: str\n         :rtype: int\n         """\n         x = s.split()\n         return len(x[-1]) if len(x) > 0 else 0
class Solution:\n     def strStr(self, haystack, needle):\n         """\n         :type haystack: str\n         :type needle: str\n         :rtype: int\n         """\n         if haystack == "" and needle == "":\n             return 0\n         if needle == "":\n             return 0\n         if haystack == "" or needle == "" or len(haystack.split(needle)) == 1:\n             return -1\n         return len(haystack.split(needle)[0])\n
class Solution:\n     \n     dictionary = {}\n     def climbStairs(self, n):\n         """\n         :type n: int\n         :rtype: int\n         """\n         number = 0\n         if n == 0 or n == 1:\n             return 1\n         if n in self.dictionary:\n             return self.dictionary[n]\n         else:\n             number += self.climbStairs(n - 1) + self.climbStairs(n - 2)\n             self.dictionary[n] = number\n         return number
class Solution:\n    def makeGood(self, s: str) -> str:\n        \n        stack=[]\n        \n        for i in s:\n            if (stack!=[] and i.lower()==stack[-1].lower() and i!=stack[-1] ) :\n                stack.pop()\n            else:\n                stack.append(i)\n        return ''.join(stack)\n                \n            \n
class Solution:\n    def sortString(self, s: str) -> str:\n        sforward = sorted(s)\n        sbackward = sforward[-1]\n        \n        suniq = ''\n        \n        for i in s:\n            if i not in suniq:\n                suniq += i\n\n        suniq = sorted(suniq)\n        \n        max_count = 0\n        \n        for i in suniq:\n            if s.count(i) > max_count:\n                max_count = s.count(i)\n        \n        \n        chr_count = [0 for i in range(len(suniq))]\n           \n        \n\n        s_sort = ''\n        \n        for j in range(max_count):\n            \n            \n            for i in range(len(suniq)):\n                if chr_count[i] < s.count(suniq[i]):\n                    s_sort += suniq[i]\n                    chr_count[i] += 1\n                else:\n                    continue\n                    \n            suniq = suniq[::-1]\n            chr_count = chr_count[::-1]\n            \n        \n        return s_sort        \n            \n
class Solution:\n    def maxNumberOfBalloons(self, text: str) -> int:\n        memo = defaultdict(int)\n        for t in text:\n            if t in 'balon':\n                memo[t] += 1\n        count_once = min(memo['b'], memo['a'], memo['n'])\n        count_twice = min(memo['l'], memo['o'])\n        return min(count_once, count_twice // 2)
class Solution:\n    def binaryGap(self, n: int) -> int:\n        maxDist = 0\n        currDist = 0\n        while n:\n            if n & 1 and currDist != 0:\n                maxDist = max(maxDist, currDist)\n                currDist = 1\n            elif n & 1:\n                currDist = 1\n            elif not n & 1 and currDist != 0:\n                currDist+=1\n            n >>= 1\n        return maxDist
class Solution:\n     def detectCapitalUse(self, word):\n         """\n         :type word: str\n         :rtype: bool\n         """\n         if len(word) == 0:\n             return True\n         elif word.isupper() or word.islower():\n             return True\n         elif len(word) > 1:\n             return word.istitle()\n         else:\n             return False
class Solution:\n     def findLHS(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         count = collections.Counter(nums)\n         ret = 0\n         for i in count:\n             if i+1 in count:\n                 ret = max(ret, count[i]+count[i+1])\n        \n         return ret\n                 \n
class Solution:\n     def reverseVowels(self, s):\n         """\n         :type s: str\n         :rtype: str\n         """\n         vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n         char_list = list(s)\n         first, last = 0, len(char_list) - 1\n         while first < last:\n             while first < last and char_list[first] not in vowels:\n                 first += 1\n             while first < last and char_list[last] not in vowels:\n                 last -= 1\n             if first >= last:\n                 break\n             char_list[first], char_list[last] = char_list[last], char_list[first]\n             first += 1\n             last -=1\n         return "".join(char_list)
class Solution:\n     def longestPalindrome(self, s):\n         """\n         :type s: str\n         :rtype: int\n         """\n         re = 0\n         set_s = set(s)\n         flag = False\n         for x in set_s:\n             if s.count(x) % 2 == 0:\n                 re += s.count(x)\n             elif s.count(x) >= 3 :\n                 re += s.count(x)-1\n                 flag =True\n             elif s.count(x) == 1:\n                 flag =True\n         if flag == True :\n             re += 1\n         return re\n                 \n
class Solution:\n    def removePalindromeSub(self, s: str) -> int:\n        # 'a' 1\n        # 'aa' 1\n        # 'ab' 2\n        # 'abb' 2\n        # 'aabb' 2\n        # 'abba' 1\n        # 'abaaba'\n        \n        if len(s) == 0:\n            return 0\n        if s == s[::-1]:\n            return 1\n        return 2
class Solution:\n    def average(self, salary: List[int]) -> float:\n        salary.sort()\n        del salary[0]\n        del salary[-1]\n        return sum(salary)/len(salary)
class Solution:\n     def canConstruct(self, ransomNote, magazine):\n         """\n         :type ransomNote: str\n         :type magazine: str\n         :rtype: bool\n         """\n         ransome = set(ransomNote)\n         for i in ransome:\n             if ransomNote.count(i) > magazine.count(i):\n                 return False\n         return True\n         \n             \n         \n
class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        while True:\n            if len(stones) == 1:\n                return stones[0]\n            if len(stones) == 0:\n                return 0\n            stones.sort()\n            x = stones.pop()\n            y = stones.pop()\n            if y != x:\n                stones.append(x-y)\n            \n
class Solution:\n     def isHappy(self, n):\n         """\n         :type n: int\n         :rtype: bool\n         """\n         former = set()\n         while True:\n             h = 0\n             while n > 0:\n                 d = n % 10\n                 h += (d*d)\n                 n = n // 10\n             if h == 1:\n                 return True\n             elif h in former:\n                 return False\n             n = h\n             former.add(n)
class Solution:\n     def convertToTitle(self, n):\n         """\n         :type n: int\n         :rtype: str\n         """\n         ans = ''\n         a = 0\n           \n         while n>0:\n             if a>0:\n                 n = n//26\n             p = n%26\n             if p==0:\n                 p=26\n             ans += chr(64+p)\n             n -= p\n             a += 1\n             \n         return ans[::-1]
class Solution:\n    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int: \n        res=0\n        for start,end in zip(startTime,endTime):\n            if(queryTime>=start and queryTime<=end):\n                res+=1\n        return res
class Solution:\n    def backspaceCompare(self, S1, S2):\n        i1 = len(S1) - 1 \n        i2 = len(S2) - 1\n        \n        while i1 >= 0 or i2 >= 0:\n            c1 = ''\n            c2 = ''\n            if i1 >= 0:\n                c1, i1 = self.getChar(S1, i1)\n            if i2 >= 0:\n                c2, i2 = self.getChar(S2, i2)\n            if c1 != c2:\n                return False\n        return True\n        \n    \n    def getChar(self, s, i):\n        char = ''\n        count = 0\n        while i >= 0 and not char:\n            if s[i] == '#':\n                count += 1\n            elif count == 0:\n                char = s[i]\n            else:\n                count -= 1\n            i -= 1\n        return char, i\n\n
class Solution:\n     def pivotIndex(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         left, right = 0, sum(nums)\n         for index, num in enumerate(nums):\n             right -= num\n             if left == right:\n                 return index\n             left += num\n         return -1
class Solution:\n    def balancedStringSplit(self, s: str) -> int:\n        lCount = rCount = 0\n        retVal = 0\n        \n        for char in s:\n            if char == 'R':\n                rCount += 1\n            else:\n                lCount += 1\n                \n            if rCount == lCount:\n                retVal += 1\n                lCount = rCount = 0\n        return retVal\n
class Solution:\n     def toHex(self, num):\n         """\n         :type num: int\n         :rtype: str\n         """\n         if num==0:\n             return "0"\n         res,n=[],0\n         nums=['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f']\n         while n<8 and num!=0:\n             res.insert(0,nums[num%16])\n             num=num//16\n             n+=1\n         s=""\n         for i in res:\n             s+=i\n         return s\n
class Solution:\n     def maxSubArray(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         # i = 0\n         # i_keep = 0\n         # j = 1\n         # j_keep = 1\n         # max_sum = nums[0]-1\n         # while j < len(nums) and i < j:\n         #     temp_sum = sum(nums[i:j])\n         #     if temp_sum >= max_sum:\n         #         i_keep = i\n         #         j_keep = j\n         #         max_sum = temp_sum\n         #     elif i == j-1:\n         #         i += 1\n         #         j += 1\n         #     j += 1\n         # return max_sum\n         \n         # brute force\n         # max_sum = nums[0]\n         # for i in range(len(nums)):\n         #     for j in range(i,len(nums)+1):\n         #         temp_sum = sum(nums[i:j])\n         #         if temp_sum > max_sum and i != j:\n         #             max_sum = temp_sum\n         # return max_sum\n \n         # outer loop only\n         max_sum = csum = nums[0]\n         for num in nums[1:]:\n             if num >= csum + num:\n                 csum = num\n             else:\n                 csum += num\n             \n             if csum > max_sum:\n                 max_sum = csum\n         \n         return max_sum\n                 \n         \n
class Solution:\n     def isPowerOfTwo(self, n):\n         """\n         :type n: int\n         :rtype: bool\n         """\n         if n < 0:\n             return False\n         \n         hasOne = False\n         while n > 0:\n             if n & 1:\n                 if hasOne == True:\n                     return False\n                 else:\n                     hasOne = True\n                     \n             n = n >> 1\n         \n         return hasOne
class Solution:\n     def titleToNumber(self, s):\n         """\n         :type s: str\n         :rtype: int\n         """\n         r, t = 0, 1\n         for i in s:\n             r = r*26 +(ord(i)-64)\n             #t *= 26\n         return r
class Solution:\n    def validMountainArray(self, A: List[int]) -> bool:\n        if len(A) <= 2:\n            return False\n        else:\n            if A[1] < A[0]:\n                return False\n            is_up = True\n            curr = A[0]\n            for n in A[1:]:\n                if n  == curr:\n                    return False\n                if n < curr:\n                    is_up = False\n                    curr = n\n                if n > curr:\n                    if is_up:\n                        curr = n\n                    else:\n                        return False\n            return not is_up\n
class Solution:\n     def countPrimes(self, x):\n         x = max(0, x - 1)\n         if type(x) is not int: x = int(x)\n         if x < 6: return [0, 0, 1, 2, 2, 3][x]\n     \n         def Phi(m, b):\n             if not b:\n                 return m\n             if not m:\n                 return 0\n             if m >= 800:\n                 return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n             t = b * 800 + m\n             if not Phi_memo[t]:\n                 Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n             return Phi_memo[t]\n         \n         \n         root2 = int(x**(1. / 2))\n         root3 = int(x**(1. / 3))\n         top = x // root3 + 1\n         sieve = [0, 0] + [1] * (top - 2)\n         pi = [0, 0]\n         primes = []\n         t = 0\n         for i in range(2, top):\n             if sieve[i] == 1:\n                 t += 1\n                 primes.append(i)\n                 sieve[i::i] = [0] * len(sieve[i::i])\n             pi.append(t)\n         a, b = pi[root3 + 1], pi[root2 + 1]\n         Phi_memo = [0] * ((a + 1) * 800)\n         return Phi(x, a) + a - 1 - sum(pi[x // p] - pi[p] + 1 for p in primes[a:b])
class Solution:\n    def divisorGame(self, N: int) -> bool:\n        return N%2 == 0\n
class Solution:\n    def diagonalSum(self, mat: List[List[int]]) -> int:\n        rows = len(mat)\n        columns = len(mat[0])\n        sum_ = 0\n        for r, c1, c2 in zip(list(range(rows)), list(range(columns)), list(range(columns - 1, -1, -1))):\n            sum_ += mat[r][c1]\n            if c1 != c2:\n                sum_ += mat[r][c2]\n        return sum_\n
# class Solution:\n#     def specialArray(self, nums: List[int]) -> int:\n#         nums.sort(reverse=True)\n#         left, right = 0, len(nums)\n#         while left < right:\n#             mid = left + (right - left) // 2\n#             if mid < nums[mid]:\n#                 left = mid + 1\n#             else:\n#                 right = mid       \n#         return -1 if left < len(nums) and left == nums[left] else left\nclass Solution:\n    def specialArray(self, a: List[int]) -> int:\n        n, i = len(a), 0\n        a.sort(reverse=True)        \n        l, r  = 0, n\n        while l < r:\n            m = l + (r-l) // 2\n            if m < a[m]:\n                l  = m + 1\n            else:\n                r = m\n        return -1 if l < n and l == a[l] else l\n
class Solution:\n    def tictactoe(self, moves: List[List[int]]) -> str:\n        # player one and two moves\n        player_a, player_b = moves[0::2], moves[1::2]\n\n        # possible wins\n        possible_wins = {\n            0: [[0, 0], [1, 1], [2, 2]],\n            1: [[0, 0], [1, 0], [2, 0]],\n            2: [[0, 1], [1, 1], [2, 1]],\n            3: [[0, 2], [1, 2], [2, 2]],\n            4: [[0, 0], [0, 1], [0, 2]],\n            5: [[1, 0], [1, 1], [1, 2]],\n            6: [[2, 0], [2, 1], [2, 2]],\n            7: [[0, 2], [1, 1], [2, 0]]\n        }\n\n        # count player one and two correct moves\n        for possible_win in list(possible_wins.values()):\n            count_a = 0\n            for move in player_a:\n                if move in possible_win:\n                    count_a += 1\n                if count_a == 3:\n                    return 'A'\n\n            count_b = 0\n            for move in player_b:\n                if move in possible_win:\n                    count_b += 1\n                if count_b == 3:\n                    return 'B'\n\n        return 'Draw' if len(player_a) + len(player_b) == 9 else 'Pending'\n
class Solution:\n    def checkIfExist(self, arr: List[int]) -> bool:\n        found = {}\n        for num in arr:\n            if num * 2 in found:\n                return True\n            if num % 2 == 0 and num / 2 in found:\n                return True\n            found[num] = True\n        return False
class Solution:\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\n        set1={}\n        \n        sum1=0\n        for i in dominoes:\n\n            ri=list(reversed(i))\n            i=tuple(i)\n            ri=tuple(ri)\n            if i in set1.keys():\n                sum1+=set1[i]\n                set1[i]+=1\n            elif ri in set1.keys():\n                sum1+=set1[ri]\n                set1[ri]+=1\n            else:\n                set1[i]=1\n        return sum1
class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        if len(nums) < 3:\n            return max(nums)\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        \n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-2] + nums[i], dp[i-1])\n        return max(dp)
class Solution:\n     def checkRecord(self, s):\n         count = 0\n         for i in range(0,len(s)):\n             if s[i] == "A":\n                 count += 1\n                 if count == 2:\n                     return False\n             elif i >= 2 and s[i] == "L" and s[max(i-1,0)] == "L" and s[max(i-2,0)] == "L":\n                 return False\n         return True\n
class Solution:\n    def modifyString(self, s: str) -> str:\n        if len(s) == 0:\n            return s\n        string = ['#']\n        string.extend(list(s))\n        string.append('#')\n        for i in range(1,len(string)-1):\n            if string[i] == '?':\n                for j in range(97,123):\n                    if string[i-1] != chr(j) and string[i+1] != chr(j):\n                        string[i] = chr(j)\n                        break\n   \n        ret = ''.join(string[1:-1])\n        return ret\n
class Solution:\n     def mySqrt(self, x):\n         """\n         :type x: int\n         :rtype: int\n         """\n         return int(x**0.5)
class Solution:\n    def minDeletionSize(self, A: List[str]) -> int:        \n        return sum([list(col) != sorted(col) for col in zip(*A)])\n            \n
class Solution:\n     def addDigits(self, num):\n         """\n         :type num: int\n         :rtype: int\n         """\n         if num == 0:\n             return 0\n         return 1 + (num - 1) % 9
class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        return len(set(''.join(sorted(s[0::2])) + ''.join(sorted(s[1::2])) for s in A))\n            \n
class Solution:\n     def findTheDifference(self, s, t):\n         """\n         :type s: str\n         :type t: str\n         :rtype: str\n         """\n         sums=sum([ord(i) for i in s]), sum([ord(i) for i in t])\n         return chr(sum([ord(i) for i in t])-sum([ord(i) for i in s])) 
class Solution:\n     def judgeCircle(self, moves):\n         """\n         :type moves: str\n         :rtype: bool\n         """\n         return moves.count('U') == moves.count('D') and moves.count('L') == moves.count('R')
class Solution:\n    def minCostToMoveChips(self, position: List[int]) -> int:\n        d = {}\n        a = 0\n        b = 0\n        for i in position:\n            if i not in d:\n                d[i]=1\n            else:\n                d[i]+=1\n        for i in d:\n            if i%2==0:\n                a +=d[i]\n            else:\n                b+=d[i]\n        return min(a,b)
class Solution:\n     def arrayPairSum(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         nums.sort()\n         return sum(nums[::2])
class Solution:\n     def canPlaceFlowers(self, flowerbed, n):\n         """\n         :type flowerbed: List[int]\n         :type n: int\n         :rtype: bool\n         """\n         p = flowerbed.count(1)\n         m = int(len(flowerbed) / 2)\n         if p+n <= m+1:\n             pos = 0\n             while pos < len(flowerbed):\n                 if n == 0:\n                     print(n)\n                     return True\n                 else:\n                     if pos+1 < len(flowerbed):\n                         if flowerbed[pos] == 0 and flowerbed[pos+1] == 0:\n                             print(pos)\n                             n-=1\n                             pos+=2\n                         elif flowerbed[pos] == 1:\n                             pos += 2\n                         else:\n                             pos +=3\n                     else:\n                         if flowerbed[pos] == 0:\n                             n-=1\n                             pos+=2\n             if n == 0:\n                 return True\n             else:\n                 return False\n         else:\n             return False
from collections import defaultdict\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        occurences = defaultdict(int)\n        for i in arr:\n            occurences[i] += 1\n        for i in occurences.values():\n            if list(occurences.values()).count(i) > 1:\n                return False\n        return True
class Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -> str:\n        contender = ''\n        for i in str1:\n            contender += i\n            if str1.count(contender) * len(contender) == len(str1) and str2.count(contender) * len(contender) == len(str2):\n                break\n        orig = contender\n        ans = None\n        while len(contender) <= len(str1) and len(contender) <= len(str2):\n            t1 = str1.replace(contender, '')\n            t2 = str2.replace(contender, '')\n            if len(t1) == len(t2) == 0:\n                ans = contender\n            contender += orig\n        return ans if ans else ''
class Solution:\n    def countOdds(self, low: int, high: int) -> int:\n        if low %2 != 0:\n            low -=1\n        if high %2 != 0:\n            high +=1 \n            \n        return (high-low) // 2
class Solution:\n    def numberOfSteps (self, num: int) -> int:\n        steps = 0\n        while num > 0:\n            if num % 2 == 0:\n                num /= 2\n            else:\n                num -= 1\n            steps += 1\n        return steps\n
class Solution:\n     def repeatedSubstringPattern(self, s):\n         return s in (s + s)[1:-1]\n
class Solution:\n  \n    def findNumbers(self, nums: List[int]) -> int:\n        def has_even_digits(number: int):\n            if number < 10:\n                return False\n            elif number < 100:\n                return True\n            elif number < 1000:\n                return False\n            elif number < 10000:\n                return True\n            elif number < 100000:\n                return False\n            return True\n\n        return sum([1 for num in nums if has_even_digits(num)])\n
class Solution:\n     def maxProfit(self, prices):\n         """\n         :type prices: List[int]\n         :rtype: int\n         """\n         n = len(prices)\n         if n <=1:\n             return 0\n         else:\n             minprice = prices[0]\n             res = 0\n             for i in range(1,n):\n                 if prices[i] - minprice > res:\n                     res = prices[i] - minprice\n                 if prices[i]<minprice:\n                     minprice = prices[i]\n \n             return res\n                     \n             \n         \n
class Solution:\n    def xorOperation(self, n: int, start: int) -> int:\n        \n        if n == 0:\n            return 0\n        \n        i = 1\n        res = start\n        while i != n:\n            res = res ^ (2*i + start)\n            i += 1\n        return res\n
class Solution:\n    def buddyStrings(self, A: str, B: str) -> bool:\n        if len(A)!=len(B):\n            return False\n        if len(A)<2:\n            return False\n        if A==B:\n            cnt = Counter(A)\n            return bool([v for v in cnt.values() if v>1])\n        diffs = []\n        for i, a in enumerate(A):\n            if a!=B[i]:\n                diffs.append(i)\n        if len(diffs) == 2:\n            i,j = diffs\n            return A[i]==B[j] and A[j]==B[i]\n        \n        return False
class Solution:\n    def minOperations(self, logs: List[str]) -> int:\n        \n        t=0\n        for i in logs:\n            if i=='../':\n                t=t-1\n            elif i=='./':\n                t=t\n            else:\n                t=t+1\n            if t<0:\n                t=0\n        return t
class Solution:\n     def maximumProduct(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         import heapq\n         a, b = heapq.nlargest(3, nums), heapq.nsmallest(2, nums)\n         return max(a[0]*a[1]*a[2], a[0]*b[0]*b[1])
class Solution:\n    def defangIPaddr(self, address: str) -> str:\n        return address.replace('.', '[.]')\n
class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        return sorted(target) == sorted(arr)
class Solution:\n    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:\n        diff_year = (year - 1971) % 7 + int((year - 1968)/4)\n        print(('year:', (year - 1971), ':', (year - 1971)%7))\n        print(('num leaps:', int((year - 1968)/4)))\n        print(('diff_year:', diff_year))\n        months = {1:0, 2:3,3:3,4:6,5:1,6:4,7:6,8:2,9:5,10:0,11:3,12:5}\n        print(('month add:', months[month]))\n        if year == 2100:\n            leap = -1\n        elif month <=2 and (year - 1968)%4 == 0:\n            leap = -1\n        else:\n            leap = 0\n        weekdate = (diff_year + months[month] + day + leap -1)%7\n        print(('day:', day))\n        print(weekdate)\n        weekdays = {5:'Wednesday', 6:'Thursday', 7:'Friday',0:'Friday', \n                    1:'Saturday', 2:'Sunday', 3: 'Monday', 4:'Tuesday'}\n        return weekdays[weekdate]\n        \n
class Solution:\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\n        flag = False\n        odd = 0\n        i = 0\n        while i < len(arr):\n            if arr[i] % 2 == 1:\n                if not flag:\n                    flag = True\n                    odd += 1\n                    i += 1\n                else:\n                    odd += 1\n                    i += 1\n            else:\n                if not flag:\n                    i += 1\n                else:\n                    flag = False\n                    odd = 0\n                    i+= 1\n                    \n            if odd == 3:\n                return True\n            \n        return False\n            \n                    \n
class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        char_map = {char: i for i, char in enumerate(order)}\n        for j in range(1, len(words)):\n            prev, curr = words[j - 1], words[j]\n\n            k = 0\n            while k < min(len(prev), len(curr)):\n                if prev[k] == curr[k]:\n                    k += 1\n                elif char_map[prev[k]] > char_map[curr[k]]:\n                    return False\n                else:\n                    break\n            if k >= len(curr):\n                return False\n        return True
class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        def findGCD(a,b):\n            if b ==0:\n                return a\n            return findGCD(b, a%b)\n            \n        hash_cards = {}\n        for card in deck:\n            if card in hash_cards:\n                hash_cards[card]+=1\n            else:\n                hash_cards[card]=1\n        value_ = list(hash_cards.values())\n        res = value_[0]\n        for x in value_[1:]:\n            res = findGCD(res,x)\n        if res <2:\n            return False\n        return True\n        \n
class Solution:\n    def maxPower(self, s: str) -> int:\n        n = len(s) \n        count = 0\n        res = s[0] \n        cur_count = 1\n  \n        # Traverse string except  \n        # last character \n        for i in range(n): \n          \n            # If current character  \n            # matches with next \n            if (i < n - 1 and \n                s[i] == s[i + 1]): \n                cur_count += 1\n  \n            # If doesn't match, update result \n            # (if required) and reset count \n            else: \n                if cur_count > count: \n                    count = cur_count \n                    res = s[i] \n                cur_count = 1\n        return count \n       \n        \n        \n
class Solution:\n     def reverseStr(self, s, k):\n         """\n         :type s: str\n         :type k: int\n         :rtype: str\n         """\n         for idx in range(0, len(s), 2*k):\n             s = s[:idx] + s[idx:idx+k][::-1] + s[idx+k:]\n         return s
class Solution:\n     def maxProfit(self, prices):\n         profits = 0 \n         ln = len(prices)\n         if not ln:\n             return 0\n         elif ln == 2:\n             return (prices[1]-prices[0]) if prices[1] > prices[0] else 0\n         lastPrice = prices[0]\n         for price in prices:\n             if lastPrice < price:\n                 profits+= (price-lastPrice)\n             lastPrice = price\n         return profits\n                 \n
class Solution:\n     def findLUSlength(self, a, b):\n         """\n         :type a: str\n         :type b: str\n         :rtype: int\n         """\n         return max(len(a),len(b)) if a != b else -1
class Solution:\n    def sumOddLengthSubarrays(self, arr: List[int]) -> int:\n    \n    #    last = len(arr)\n    #    total = 0\n     #   for start in range(len(arr)):\n     #       end = start\n     #       while end < last:\n     #           total += sum(arr[start:end+1])\n     #           end += 2   '''\n     #       return total\n    \n        total = 0\n        for i in range(len(arr)):\n            totalisubarrays = (len(arr) - i) * (i+1) #this represent total number of subarrays in list that has either i as start or end.\n            if totalisubarrays % 2 == 1:\n                totalisubarrays += 1\n            oddisubarrays = totalisubarrays//2\n            total += arr[i]*oddisubarrays\n        return total\n        \n
class Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])
class Solution:\n     def isIsomorphic(self, s1, s2):\n         return len(set(zip(s1, s2))) == len(set(s1)) == len(set(s2))\n
class Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        d={}\n        for i in chars:\n            if i in d:\n                d[i]+=1\n            else:\n                d[i]=1\n        l=0\n        for i in words:\n            flag = True\n            for j in i:\n                if j in d:\n                    if i.count(j)>d[j]:\n                        flag=False\n                        break\n                else:\n                    flag = False\n                    break\n            if flag:\n                l+=len(i)\n        return l
class Solution:\n    def heightChecker(self, heights: List[int]) -> int:\n        max_val = max(heights)\n        \n        freq = [0] * (max_val + 1)\n        for num in heights:\n            freq[num] += 1\n        for num in range(1,len(freq)):\n            freq[num] += freq[num-1]\n        places = [0] * len(heights)\n        for num in heights:\n            places[freq[num] - 1] = num\n            freq[num] -= 1\n        return sum(a != b for a , b in zip(places,heights))
class Solution:\n     def minMoves(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         minx=min(nums)\n         sums=sum(nums)\n         return sums-len(nums)*minx\n
class Solution:\n     def canWinNim(self, n):\n         """\n         :type n: int\n         :rtype: bool\n         """\n         return (n%4 != 0)
class Solution:\n    def repeatedNTimes(self, A: List[int]) -> int:\n        dict_ = dict()\n        \n        for a in A:\n            if a in dict_:\n                return a\n            else:\n                dict_[a] = 1\n
class Solution:\n    def numUniqueEmails(self, emails: List[str]) -> int:\n        s = [];\n        for email in emails:\n            for i in range(len(email)):\n                if email[i]=='@':\n                    localname = email[:i];\n                    domainname = email[i:];\n                    local = '';\n                    for x in localname:\n                        if x=='+':\n                            break;\n                        local += x;\n                    local = local.replace('.','');\n                    s.append(local+domainname);\n                    break;\n        return len(set(s));
class Solution:\n     def findNthDigit(self, n):\n         """\n         :type n: int\n         :rtype: int\n         """\n         i=count=9\n         while count < n:\n             i *= 10\n             count += i * len(str(i))\n         div, mod = divmod(n-(count-i*len(str(i))), len(str(i)))\n         print(i, count, div, mod)\n         target = (i//9-1) + div\n         if mod == 0:\n             print(target, int(str(target)[-1]))\n             return int(str(target)[-1])\n         else:\n             return int(str(target+1)[mod-1])
class Solution:\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\n        count=0\n        for i in arr1:\n            flag=0\n            for j in arr2:\n                if abs(i-j)<=d:\n                    flag=1\n                    break\n            if flag == 0:\n                count+=1\n        return count
class Solution:\n    def toGoatLatin(self, S: str) -> str:\n        result = ''\n        vowel = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        aAppend = 'a'\n        newWord = ''\n        maAppend = ''\n        lastC = ''\n        for c in S:\n            lastC = c\n            fullAppend = maAppend + aAppend\n            if c == ' ':\n                result += newWord + fullAppend + ' '\n                aAppend += 'a'\n                newWord = ''\n                maAppend = ''\n                continue\n            if maAppend == '' and c in vowel:\n                maAppend = 'ma'\n                newWord += c\n                continue\n            if maAppend == '' and (not c in vowel):\n                maAppend = c + 'ma'\n                continue\n\n            newWord += c\n        if lastC != ' ':\n            result += newWord + maAppend + aAppend\n\n        return result
class Solution:\n     def containsNearbyDuplicate(self, nums, k):\n         """\n         :type nums: List[int]\n         :type k: int\n         :rtype: bool\n         """\n         s=set(nums)\n         if len(s)==len(nums):return False\n         d=dict()\n         for num in nums:\n             d[num]=d.get(num,0)+1\n         for num in d:\n             if d[num]>1:\n                 index1=-1\n                 index2=-1\n                 for i in range(len(nums)):\n                     if nums[i]==num and index1==-1:index1=i\n                     elif nums[i]==num and index2==-1:index2=i\n                     elif nums[i]==num and index1!=-1 and index2!=-1:\n                         index1=index2\n                         index2=i\n                     print(index2,index1)\n                     if index1!=-1 and index2!=-1 and abs(index2-index1)<=k:return True\n         return False
class Solution:\n    def tribonacci(self, n: int) -> int:\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        ans = [0] * (n+1)\n        ans[0] = 0 \n        ans[1] = 1 \n        ans[2] = 1 \n        \n        for i in range(3, n+1):\n            ans[i] = ans[i-1] + ans[i-2] + ans[i-3]\n        return ans[n]
class Solution:\n     def checkPossibility(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: bool\n         """\n         possibility_flag = False\n         for i in range(1, len(nums)):\n             if nums[i] < nums[i-1]:\n                 if possibility_flag:\n                     return False\n                 possibility_flag = True\n                 if (i-2 < 0 or i-2 >= 0 and nums[i-2] < nums[i]) or (i+1 >= len(nums) or i+1 < len(nums) and nums[i+1] > nums[i-1]):\n                     pass\n                 else:\n                     return False\n         return True\n \n
class Solution:\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\n        for i, w in enumerate(sentence.split(), 1):\n            if w.startswith(searchWord):\n                return i\n        return -1\n
class Solution:\n     def reverse(self, x):\n         """\n         :type x: int\n         :rtype: int\n         """\n         if x < 0:\n             y = -1 * int(str(-x)[::-1])\n         else:\n             y = int(str(x)[::-1])  \n             \n         if y > 2**31 or y < -2**31:\n             y = 0\n         return y
class Solution:\n    def reformat(self, s: str) -> str:\n        n = [str(i) for i in range(0, 10)]\n        a, b = [], []\n        for i in s:\n            if i in n:\n                b.append(i)\n            else:\n                a.append(i)\n        if abs(len(a) - len(b)) > 1:\n            return ''\n        r = ''\n        if len(a) == len(b):\n            while a:\n                r += a.pop()\n                r += b.pop()\n        elif len(a) > len(b):\n            while b:\n                r += a.pop()\n                r += b.pop()\n            r += a[0]\n        else:\n            while a:\n                r += b.pop()\n                r += a.pop()\n            r += b[0]\n        return r
class Solution:\n     def countAndSay(self, n):\n         s = '1'\n         \n         for _ in range(n-1):\n             let, temp, count = s[0], "", 0\n             for l in s:\n                 if let == l:\n                     count += 1\n                 else:\n                     temp += str(count) + let\n                     let = l\n                     count = 1\n             temp += str(count) + let\n             s = temp\n         return s\n
class Solution:\n     def findShortestSubArray(self, nums):\n         \n         diction = {}\n         \n         for i in nums:\n             if i not in diction:\n                 diction[i] = 1\n             else:\n                 diction[i] += 1\n             \n         degree = max(list(diction.values()))\n         \n         if degree == 1:\n             return 1\n         \n         max_value = []\n         \n         for i in diction:\n             if diction[i] == degree:\n                 max_value.append(i)\n         \n         min_length = 10000000000\n         \n         for i in max_value:\n             head = 0\n             tail = 0\n             for j in range(len(nums)):\n                 if nums[j] == i:\n                     head = j\n                     break\n             for j in range(len(nums)-1,-1,-1):\n                 if nums[j] == i:\n                     tail = j\n                     break\n             if min_length > tail - head + 1:\n                 min_length = tail - head + 1\n         \n         return min_length
class Solution:\n     def findLengthOfLCIS(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         if len(nums) < 1:\n             return 0\n         cur_len = 1\n         max_len = 1\n         for i in range(1,len(nums)):\n             if nums[i] > nums[i-1]:\n                 cur_len = cur_len + 1\n             else:\n                 cur_len = 1\n                 \n             if cur_len > max_len:\n                 max_len = cur_len\n         return max_len\n
class Solution:\n     def hammingDistance(self, x, y):\n         """\n         :type x: int\n         :type y: int\n         :rtype: int\n         """\n         x = x ^ y\n         y = 0\n         while (x):\n             y += 1\n             x &= x-1\n         return y\n
class Solution:\n     def trailingZeroes(self, n):\n         """\n         :type n: int\n         :rtype: int\n         """\n         n_fives = 0\n         while n > 0:\n             n = n // 5\n             n_fives += n\n         return n_fives
class Solution:\n     def getSum(self, a, b):\n         max = 0x7FFFFFFF\n         mask = 0xFFFFFFFF\n         while b != 0:\n             a, b = (a ^ b) & mask, ((a & b) << 1) & mask\n         return a if a <= max else ~(a ^ mask)
class Solution:\n     def longestCommonPrefix(self, strs):\n         """\n         :type strs: List[str]\n         :rtype: str\n         """ \n         strs = strs\n         import os \n         return os.path.commonprefix(strs)\n     \n     \n #         for x in strs:\n #            if prefix in x:\n #                 print x\n         \n
import itertools\n\nclass Solution:\n  def numSpecial(self, mat: List[List[int]]) -> int:\n    rr = [i for i, r in enumerate(mat) if sum(r) == 1]\n    cc = [i for i, c in enumerate(zip(*mat)) if sum(c) == 1]\n    return sum(1 for i, j in itertools.product(rr, cc) if mat[i][j] == 1)
class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        \n        arr = [0] * 60\n        \n        for t in time:\n            arr[t % 60] += 1\n        \n        \n        res = 0\n        for i in range(31):\n            if i == 0 or i == 30:\n                res += (arr[i] * (arr[i]-1)) // 2\n            else:\n                res += arr[60-i] * arr[i]\n        \n        return res
class Solution:\n     def findUnsortedSubarray(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         left = 1\n         size = len(nums)\n         if size == 0:\n             return 0\n         while left < size and nums[left - 1] <= nums[left]:\n             left += 1\n         if left == size:\n             return 0\n         left -= 1\n         right = size - 1\n         while right > 0 and nums[right] >= nums[right - 1]:\n             right -= 1\n         sub = nums[left : right + 1]\n         min_ = min(sub)\n         max_ = max(sub)\n         for i in range(left):\n             if nums[i] > min_:\n                 left = i\n                 break\n         for i in range(size - 1, right, -1):\n             if nums[i] < max_:\n                 right = i\n                 break\n         return right - left + 1\n
class Solution:\n    def thousandSeparator(self, n: int) -> str:\n        arr = []\n        i, count = 0, 0\n        num = str(n)\n        while i < len(num):\n            if count != 3:\n                arr.append(num[~i])\n                i += 1\n                count += 1\n            else:\n                arr.append('.')\n                count = 0\n                \n        return ''.join(arr[::-1])\n
class Solution:\n     def arrangeCoins(self, n):\n         """\n         :type n: int\n         :rtype: int\n         """\n         #brute force:\n         #m = i (i+1) / 2 \n         #i = 0\n         #while True:\n         #    row = i * (i+1) / 2\n         #    if n - row < 0:\n         #        return i - 1\n         #    i += 1\n             \n         # 2m = i (i+1)  \n         # i**2 + i - 2m = 0\n         # i = -1 + sqr(8m) / 2\n         return int((math.sqrt(8*n + 1)-1)/2 ) \n         \n
class Solution:\n    def maxScore(self, s: str) -> int:\n        maxi=0\n        for i in range(1,len(s)):\n            a=s[:i]\n            b=s[i:]\n            maxi=max(a.count('0')+b.count('1'),maxi)\n        return maxi
class Solution:\n     def validPalindrome(self, s):\n         """\n         :type s: str\n         :rtype: bool\n         """\n         if s == s[::-1]:\n             return True\n         r = s[::-1]\n         for i in range(0, len(s)):\n             if r[i] == s[i]:\n                 continue\n             else:\n                 break\n         r = r[:i] + r[i+1:]\n         if r == r[::-1]:\n             return True\n         s = s[:i] + s[i+1:]\n         return s == s[::-1]
class Solution:\n    def findLucky(self, arr: List[int]) -> int:\n        c=collections.Counter(arr)\n        maxi=-1\n        for i in c:\n            if i==c[i]:\n                maxi=max(maxi,i)\n        return maxi
class Solution:\n    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:\n        \n        if start > destination: \n            start, destination = destination, start \n            \n        sum1 = sum(distance[start:destination])\n        sum2 = sum(distance) - sum1 \n        \n        return min(sum1, sum2)
class Solution:\n    memory = {}\n    largest = [0]\n    trackerForLargest = {}\n    largestSize = [0]\n    numGroups = [0]\n    \n    def countLargestGroup(self, n: int) -> int:\n        if n > self.largest[0]:\n            for num in range(self.largest[0] + 1, n + 1):\n                curr = num\n                currSum = 0\n                while curr != 0:\n                    currSum += curr%10\n                    curr //= 10\n                \n                if currSum not in self.trackerForLargest:\n                    self.trackerForLargest[currSum] = []\n                \n                self.trackerForLargest[currSum].append(num)\n                \n                if len(self.trackerForLargest[currSum]) == self.largestSize[0]:\n                    self.numGroups[0] += 1\n                elif len(self.trackerForLargest[currSum]) > self.largestSize[0]:\n                    self.numGroups[0] = 1\n                    self.largestSize[0] = len(self.trackerForLargest[currSum])\n                \n                self.memory[num] = self.numGroups[0]\n            \n            self.largest[0] = n\n        \n        return self.memory[n]
class Solution:\n     def missingNumber(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         if 0 not in nums:\n             return 0\n         array=sorted(nums)\n         for i in range(len(array)):\n             try:\n                 dif=array[i+1]-array[i]\n                 if dif!=1:\n                     return array[i]+1\n             except:\n                 return array[-1]+1\n
class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        \n        A.sort(reverse=True)\n        la=len(A)\n        for i in range(la-2):\n            if A[i]<A[i+1]+A[i+2]:\n                return A[i]+A[i+1]+A[i+2]\n        return 0
class Solution:\n     def isPowerOfFour(self, num):\n         """\n         :type num: int\n         :rtype: bool\n         """\n         return num != 0 and num & (num -1) == 0 and num & 0x55555555 == num
class Solution:\n    def isMonotonic(self, A: List[int]) -> bool:\n        if not A: return True\n        increasing = True\n        index = 0\n        while index<len(A)-1 and A[index] == A[index+1]:\n            index+=1\n        if index == len(A)-1:\n            return True\n        if A[index] > A[index+1]:\n            increasing = False\n        for i in range(len(A)-1):\n            if increasing:\n                if A[i] > A[i+1]:\n                    return False\n            else:\n                if A[i] < A[i+1]:\n                    return False\n        return True
class Solution:\n    def reverseOnlyLetters(self, S: str) -> str:\n        stack = [char for char in S if char.isalpha()]\n        result = ''\n        for char in S:\n            if char.isalpha():\n                temp = stack.pop()\n                result += temp\n            else:\n                result += char\n        return result
class Solution:\n    def projectionArea(self, grid: List[List[int]]) -> int:\n        ans=0\n        for i in range(len(grid)):\n            row=0\n            col=0\n            for j in range(len(grid[i])):\n                if(grid[i][j]):\n                    ans+=1\n                row=max(row,grid[i][j])\n                col=max(col,grid[j][i])\n            ans+=row+col\n        return ans
class Solution:\n    def numRookCaptures(self, board: List[List[str]]) -> int:\n        count=0;\n        for i in range(len(board)):\n            for j in range(len(board[i])):\n                if board[i][j]=='R':\n                    d=1;\n                    #\n                    while 0<=i-d:\n                        if board[i-d][j]=='B':\n                            break;\n                        elif board[i-d][j]=='p':\n                            count+=1;\n                            break;\n                        else:\n                            d+=1;\n                    d=1;\n                    #\n                    while i+d<=len(board)-1:\n                        if board[i+d][j]=='B':\n                            break;\n                        elif board[i+d][j]=='p':\n                            count+=1;\n                            break;\n                        else:\n                            d+=1;\n                    d=1;\n                    #\n                    while 0<=j-d:\n                        if board[i][j-d]=='B':\n                            break;\n                        elif board[i][j-d]=='p':\n                            count+=1;\n                            break;\n                        else:\n                            d+=1;\n                    d=1;\n                    #\n                    while j+d<=len(board[i])-1:\n                        if board[i][j+d]=='B':\n                            break;\n                        elif board[i][j+d]=='p':\n                            count+=1;\n                            break;\n                        else:\n                            d+=1;\n        return count;\n
class Solution:\n    def numIdenticalPairs(self, nums: List[int]) -> int:\n        my_count = 0\n        my_dict = {}\n        for n in nums:\n            my_count += my_dict.get(n,0)\n            my_dict[n] = my_dict.get(n,0) +1\n        return my_count\n           \n\n
class Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        count = 0\n        for arr in grid:\n            for num in arr:\n                if num < 0:\n                    count +=1\n        return count
class Solution:\n     def isUgly(self, num):\n         """\n         :type num: int\n         :rtype: bool\n         """\n         if num < 1:\n             return False\n         while num % 2 == 0:\n             num = num / 2\n         while num % 3 == 0:\n             num = num / 3\n         while num % 5 == 0:\n             num = num / 5\n         if num == 1:\n             return True\n         else:\n             return False
class Solution:\n    def reorderSpaces(self, text: str) -> str:\n        s = text.split()\n        if len(s) == 1: \n            text = ''.join(s) + ' '*text.count(' ')\n            return text\n        count = text.count(' ')//(len(s)-1)\n        extra = text.count(' ')%(len(s)-1)\n        result = ''\n        num = 0\n        for c in s:\n            result += c\n            num += 1\n            if num <= (len(s)-1):\n                result += ' '*count\n        qqqqqqqqq = [3]*100000\n        if extra != 0:\n            result += ' '*extra\n        return result
class Solution:\n                \n    def lemonadeChange(self, bills: List[int]) -> bool:               \n        n5=0\n        n10=0            \n        for i in bills:\n            if i == 5:\n                n5 +=1\n            elif i == 10:\n                if n5<=0:\n                    return False\n                else:\n                    n5 -=1\n                    n10 +=1\n            else:\n                if n10>0 and n5 >0:\n                    n10 -=1\n                    n5 -=1\n                elif n5>=3:\n                    n5-=3\n                else:\n                    return False\n        else:\n            return True\n        \n#         five = ten = 0\n#         for i in bills:\n#             if i == 5: \n#                 five += 1\n#             elif i == 10: \n#                 five, ten = five - 1, ten + 1\n#             elif ten > 0: \n#                 five, ten = five - 1, ten - 1\n#             else: \n#                 five -= 3\n            \n#             if five < 0: return False\n#         return True\n            \n            \n        \n                \n
class Solution:\n     def isValid(self, s):\n         """\n         :type s: str\n         :rtype: bool\n         """\n         stack = []\n         dict = {"]":"[", "}":"{", ")":"("}\n         \n         for i in s:\n             if i in dict.values():\n                 stack.append(i)\n             elif i in dict.keys():\n                 if stack == [] or dict[i] != stack.pop():\n                     return False\n             else:\n                 return False\n         return not stack
class Solution:\n    def findSpecialInteger(self, arr: List[int]) -> int:\n        count = 0\n        num = arr[0]\n        for x in arr:\n            if x == num:\n                count = count+ 1\n            elif x != num and ((count / len(arr))>0.25):\n                return num\n            else:\n                num = x\n                count = 1\n        return arr[len(arr)-1]
class Solution:\n    def numPrimeArrangements(self, n: int) -> int:\n        primes = [True] * (n + 1)\n        for prime in range(2, int(math.sqrt(n)) + 1):\n            if primes[prime]:\n                for composite in range(prime * prime, n + 1, prime):\n                    primes[composite] = False\n        cnt = sum(primes[2:])\n        return math.factorial(cnt) * math.factorial(n - cnt) % (10**9 + 7)        
class Solution:\n     def longestWord(self, words):\n         """\n         :type words: List[str]\n         :rtype: str\n         """\n         \n         result = "";\n         wordSet = set(words);\n         for word in words:\n             if (len(word) > len(result) or len(word) == len(result) and word < result) and all(word[ : i] in wordSet for i in range(1, len(word))):\n                 result = word;\n                 \n         return result;
n = int(input())\ns = set(map(int, input().split())) \nn = int(input())\nfor i in range(n):\n    cmd = list(input().split(' '))\n    if (len(cmd) == 1):\n        s.pop()\n    else:\n        value = int(cmd[1])\n        s.discard(value)\nprint((sum(s)))\n
import re\ns = input()\nres = re.search(r'([A-Za-z0-9])\1',s)\nif res == None:\n    print((-1))\nelse:\n    print((res.group(1)))\n
import itertools\nar1 = list(map(int,input().split()))\nar2 = list(map(int,input().split()))\ncross = list(itertools.product(ar1,ar2))\nfor i in cross:\n    print(i,end=' ')\n
n = int(input().strip())\nw = (n-1) * 2 + ((n * 2) - 1)\n#upper half\nfor i in range(1,n,1):\n    number_of_letter = (i*2) - 1\n    s = ''\n    letter_value = 97 + n - 1\n    for i in range(0,number_of_letter):\n        if(i != 0):\n            s += '-' \n        s += chr(letter_value) \n        if(i<(number_of_letter-1) / 2):\n            letter_value = letter_value - 1\n        else:\n            letter_value = letter_value + 1            \n    print((s.center(w,'-')))\n    \n    \n#bottom half\nfor i in range(n,0,-1):\n    number_of_letter = (i*2) - 1\n    s = ''\n    letter_value = 97 + n - 1\n    for i in range(0,number_of_letter):\n        if(i != 0):\n            s += '-' \n        s += chr(letter_value) \n        if(i<(number_of_letter-1) / 2):\n            letter_value = letter_value - 1\n        else:\n            letter_value = letter_value + 1            \n    print((s.center(w,'-')))\n
for i in range(int(input())): #More than 4 lines will result in 0 score. Blank lines won't be counted. \n    a = int(input()); A = set(input().split()) \n    b = int(input()); B = set(input().split())\n    print(((A & B) == A))\n
from fractions import Fraction\nfrom functools import reduce\ndef product(fracs):\n    t = Fraction(reduce(lambda x,y : x*y,fracs))\n    return t.numerator, t.denominator\ndef __starting_point():\n    fracs = []\n    for _ in range(int(input())):\n        fracs.append(Fraction(*list(map(int, input().split()))))\n    result = product(fracs)\n    print((*result))\n\n'''\n3\n1 2\n3 4\n10 6\n'''\n\n__starting_point()
x = int(input())\nshoe_size = list(map(int,input().split()))\nn = int(input())\nsell = 0\nfor i in range(n):\n    s, p = list(map(int,input().split()))\n    if s in shoe_size:\n        sell = sell + p\n        shoe_size.remove(s)\nprint(sell)\n
import itertools\ns = input().strip()\ns_unique_element = list(set(s))\ngroup = []\nkey = []\nfor k,g in itertools.groupby(s):\n    group.append(list(g))\n    key.append(k)\nfor i in range(len(group)):\n    group_length = len(group[i])\n    k = int(key[i])\n    print(tuple((group_length,k)),end=' ')\n
import numpy\nnp_ar1 = numpy.array(list(map(int,input().split())))\nnp_ar2 = numpy.array(list(map(int,input().split())))\nprint((numpy.inner(np_ar1,np_ar2)))\nprint((numpy.outer(np_ar1,np_ar2)))\n
import re, email.utils\nn = int(input())\nfor t in range(n):\n    s = input()\n    parsed_email = email.utils.parseaddr(s)[1].strip()\n    match_result = bool(re.match(r'(^[A-Za-z][A-Za-z0-9\._-]+)@([A-Za-z]+)\.([A-Za-z]{1,3})$',parsed_email))\n    if match_result == True:\n        print(s)\n
#Replace all ______ with rjust, ljust or center. \n\nthickness = int(input()) #This must be an odd number\nc = 'H'\n\n#Top Cone\nfor i in range(thickness):\n    print(((c*i).rjust(thickness-1)+c+(c*i).ljust(thickness-1)))\n\n#Top Pillars\nfor i in range(thickness+1):\n    print(((c*thickness).center(thickness*2)+(c*thickness).center(thickness*6)))\n\n#Middle Belt\nfor i in range((thickness+1)//2):\n    print(((c*thickness*5).center(thickness*6)))    \n\n#Bottom Pillars\nfor i in range(thickness+1):\n    print(((c*thickness).center(thickness*2)+(c*thickness).center(thickness*6)))    \n\n#Bottom Cone\nfor i in range(thickness):\n    print((((c*(thickness-i-1)).rjust(thickness)+c+(c*(thickness-i-1)).ljust(thickness)).rjust(thickness*6)))  \n
import datetime\nimport calendar\nm,d,y=list(map(int,input().split()))\ninput_date = datetime.date(y,m,d)\nprint((calendar.day_name[input_date.weekday()].upper()))\n
n = int(input())\nar = list(map(int,input().split()))\nar = sorted(ar)\nif(ar[0]<=0):\n    print(False)\nelse:\n    chk = False\n    for i in ar:\n        s = str(i)\n        if (s==s[::-1]):\n            chk = True\n            break\n    print(chk)\n
n = int(input())\ncountry_set = set()\nfor i in range(n):\n    country_name = input()\n    country_set.add(country_name)\nprint((len(country_set)))\n
s = input()\ns_ar = s.split(' ')\nfinal_ar = []\nspace = ' '\nfor w in s_ar:\n    final_ar.append(w.capitalize())\nprint((space.join(final_ar)))\n
n=int(input())\nar=range(1,n+1)\nfor i in ar:\n    print(i,end="")\n
def mutate_string(string, position, character):\n    return string[:position]+character+string[position+1:]\n\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\na=int(input())\nb=int(input())\nc=int(input())\nprint((pow(a,b)))\nprint((pow(a,b,c)))\n
import numpy\nn = int(input())\nar1 = []\nar2 = []\nfor i in range(n):\n    tmp = list(map(int,input().split()))\n    ar1.append(tmp)\nnp_ar1 = numpy.array(ar1)\nfor i in range(n):\n    tmp = list(map(int,input().split()))\n    ar2.append(tmp)\nnp_ar2 = numpy.array(ar2)\nprint((numpy.dot(np_ar1,np_ar2)))\n
import re, sys\nn = int(input())\nfor line in sys.stdin:\n    remove_and = re.sub(r'(?<= )(&&)(?= )',"and",line)\n    remove_or = re.sub(r'(?<= )(\|\|)(?= )',"or",remove_and)\n    print(remove_or,end='')\n
from html.parser import HTMLParser\n\nclass MyHTMLParser(HTMLParser):\n    def handle_starttag(self, tag, attrs):\n        print(tag)\n        for at in attrs:\n            print(("-> {} > {}".format(at[0], at[1])))\n    def handle_startendtag(self, tag, attrs):\n        print(tag)\n        for at in attrs:\n            print(("-> {} > {}".format(at[0], at[1])))\n\nhtml = ""\nfor i in range(int(input())):\n    html += input().rstrip()\n    html += '\n'\n    \nparser = MyHTMLParser()\nparser.feed(html)\nparser.close()\n
import textwrap\ns = input()\nw = int(input().strip())\nprint((textwrap.fill(s,w)))\n
import re\nn = int(input())\nfor t in range(n):\n    credit = input().strip()\n    credit_removed_hiphen = credit.replace('-','')\n    valid = True\n    length_16 = bool(re.match(r'^[4-6]\d{15}$',credit))\n    length_19 = bool(re.match(r'^[4-6]\d{3}-\d{4}-\d{4}-\d{4}$',credit))    \n    consecutive = bool(re.findall(r'(?=(\d)\1\1\1)',credit_removed_hiphen))\n    if length_16 == True or length_19 == True:\n        if consecutive == True:\n            valid=False\n    else:\n        valid = False       \n    if valid == True:\n        print('Valid')\n    else:\n        print('Invalid')\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\nfrom collections import OrderedDict\n\nn=int(input())\nar={}\nval_ar=[]\nfor i in range(0,n):\n    tmp_name=input()\n    tmp_marks=float(input())\n    ar[tmp_name]=tmp_marks\n    val_ar.append(tmp_marks)\n  \nset_val=set(val_ar)\nval_ar=list(set_val)\nval_ar.sort()\nsec_mark=val_ar[1]\n##print sec_mark    \nfinal_ar=[]\nfor i in ar:\n    if(sec_mark==ar[i]):\n        final_ar.append(i)\n\nfinal_ar.sort()\nfor i in final_ar:\n    print(i)\n
import numpy\nar = list(map(float,input().split()))\nnp_ar = numpy.array(ar,float)\nprint((np_ar[::-1]))\n
s = input()\ns = sorted(s,key = lambda x:(x.isdigit() and int(x)%2==0, x.isdigit(),x.isupper(),x.islower(),x))\nprint(*(s),sep = '')\n
import numpy\nn,m = list(map(int,input().split()))\nar1 = []\nar2 = []\nfor i in range(n):\n    tmp = list(map(int,input().split()))\n    ar1.append(tmp)\nfor i in range(n):\n    tmp = list(map(int,input().split()))\n    ar2.append(tmp)\nnp_ar1 = numpy.array(ar1)\nnp_ar2 = numpy.array(ar2)\nprint((np_ar1 + np_ar2))\nprint((np_ar1 - np_ar2))\nprint((np_ar1 * np_ar2))\nprint((np_ar1 // np_ar2))\nprint((np_ar1 % np_ar2))\nprint((np_ar1 ** np_ar2))\n
import numpy\nn,m,p=list(map(int,input().split()))\n\nar1 = []\nar2 = []\nfor i in range(n):\n    tmp = list(map(int,input().split()))\n    ar1.append(tmp)\nfor i in range(m):\n    tmp = list(map(int,input().split()))\n    ar2.append(tmp)    \nnp_ar1 = numpy.array(ar1)\nnp_ar2 = numpy.array(ar2)\nprint((numpy.concatenate((np_ar1,np_ar2),axis = 0)))\n
from itertools import *\ns,n = input().split()\nn = int(n) + 1\ns = sorted(s)\nfor i in range(1,n):\n    for j in combinations(s,i):\n        print((''.join(j)))\n
import numpy\nn,m = list(map(int,input().split()))\nprint((numpy.eye(n,m,k=0)))\n
def is_leap(year):\n    leap = False\n    if (year % 400 == 0):\n        leap = True\n    elif year % 4 == 0 and year % 100 !=0:\n        leap = True    \n    return leap\n
import re\ns = input().strip()\nk = input().strip()\ns_len = len(s)\nfound_flag = False\nfor i in range(s_len):\n    match_result = re.match(k,s[i:])\n    if match_result:\n        start_index = i+match_result.start()\n        end_index = i+match_result.end()-1\n        print((start_index,end_index))\n        found_flag = True\nif found_flag == False:\n    print('(-1, -1)')\n
from html.parser import HTMLParser\nclass CustomHTMLParser(HTMLParser):\n    def handle_comment(self, data):\n        number_of_line = len(data.split('\n'))\n        if number_of_line>1:\n            print('>>> Multi-line Comment')\n        else:\n            print('>>> Single-line Comment')\n        if data.strip():\n            print(data)\n\n    def handle_data(self, data):\n        if data.strip():\n            print(">>> Data")\n            print(data)\n\nparser = CustomHTMLParser()\n\nn = int(input())\n\nhtml_string = ''\nfor i in range(n):\n    html_string += input().rstrip()+'\n'\n    \nparser.feed(html_string)\nparser.close()\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\nfname=input()\nlname=input()\nprint(("Hello "+fname+" "+lname+"! You just delved into python."))\n
n = int(input())\nfor i in range(n):\n    a,b=input().split()\n    try:\n        print((int(a)//int(b)))\n    except Exception as e:\n        print(("Error Code: "+str(e)))\n
import numpy\nn,m = list(map(int,input().split()))\nar = []\nfor i in range(n):\n    tmp = list(map(int,input().split()))\n    ar.append(tmp)\nnp_ar = numpy.array(ar)\nprint((numpy.max(numpy.min(np_ar,axis=1))))\n
import numpy\nar = list(map(int,input().split()))\nnp_ar = numpy.array(ar)\nprint((numpy.reshape(np_ar,(3,3))))\n
import numpy\nnp_ar = numpy.array(list(map(float,input().split())),float)\nprint((numpy.floor(np_ar)))\nprint((numpy.ceil(np_ar)))\nprint((numpy.rint(np_ar)))\n
def minion_game(string):\n    n=len(string)\n    player1,player2=0,0\n    for i in range(0,n):\n        if(string[i] in 'AEIOU'):\n            player1+=n-i\n        else:\n            player2+=n-i\n    if(player1>player2):\n        return 'Kevin '+ str(player1)\n    elif(player1==player2):\n        return 'Draw'\n    else:\n        return 'Stuart '+str(player2)
from collections import Counter, OrderedDict\nclass OrderedCounter(Counter,OrderedDict):\n    pass\n\nword_ar = []\nn = int(input())\nfor i in range(n):\n    word_ar.append(input().strip())\nword_counter = OrderedCounter(word_ar)\nprint(len(word_counter))\nfor word in word_counter:\n    print(word_counter[word],end=' ')\n
import cmath\nz = complex(input())\np = cmath.polar(z)\nprint((p[0]))\nprint((p[1]))\n
n = input()\nar = list(map(int,input().split(' ')))\nar=set(ar)\nprint((sum(ar) / len(ar)))\n
n = int(input().strip())\nw = len(str(bin(n))[2:])\nfor i in range(1,n+1,1):\n    o = str(oct(i))[2:]\n    h = str(hex(i))[2:]\n    h = h.upper()\n    b = str(bin(i))[2:]\n    d = str(i)\n    print(('{:>{width}} {:>{width}} {:>{width}} {:>{width}}'.format(d,o,h,b,width=w)))\n
A  = set(input().split())\nn = int(input())\ncheck = True\nfor i in range(n):\n    s = set(input().split())\n    if (s&A != s) or (s == A):\n        check = False\n        break\nprint(check)\n
for i in range(1,int(input())): #More than 2 lines will result in 0 score. Do not leave a blank line also\n    print((10**i//9 * i))\n
import numpy\nn,m=list(map(int,input().split()))\nar = []\nfor i in range(n):\n    tmp = list(map(int,input().split()))\n    ar.append(tmp)\nnp_ar = numpy.array(ar)\ns = numpy.sum(np_ar,axis=0)\nprint((numpy.prod(s)))\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\na=int(input())\nb=int(input())\nd=divmod(a,b)\nprint((d[0]))\nprint((d[1]))\nprint(d)\n
import numpy\nn,m = list(map(int,input().split()))\nar = []\nfor i in range(n):\n    row = list(map(int,input().split()))\n    ar.append(row)\n\nnp_ar = numpy.array(ar)\nprint((numpy.transpose(np_ar)))\nprint((np_ar.flatten()))\n
import numpy\nn,m = list(map(int,input().split()))\nar = []\nfor i in range(n):\n    tmp = list(map(int,input().split()))\n    ar.append(tmp)\nnp_ar = numpy.array(ar)\nprint((numpy.mean(np_ar,axis=1)))\nprint((numpy.var(np_ar,axis=0)))\nprint((numpy.std(np_ar,axis=None)))\n
import itertools\ns,n = list(map(str,input().split(' ')))\ns = sorted(s)\nfor p in list(itertools.permutations(s,int(n))):\n    print((''.join(p)))\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\nn=int(input())\nnum_str_ar=input().strip().split()\n\nnum_ar=list(map(int,num_str_ar))\nset_tmp=set(num_ar)\nfinal_ar=list(set_tmp)\nfinal_ar.sort()\nprint((final_ar[-2]))\n
import numpy\np = numpy.array(list(map(float,input().split())),float)\nx = float(input())\nprint((numpy.polyval(p,x)))\n
#!/bin/python3\n\nimport sys\nfrom collections import Counter\n\ndef __starting_point():\n    s = input().strip()\n    best = Counter(s)\n    sortit = sorted(list(best.items()), key = lambda x: (-x[1], x[0]))[:3]\n        \n    print(("\n".join(x[0]+" "+str(x[1]) for x in sortit)))\n\n__starting_point()
#!/usr/bin/env python3\n\nimport re\n\ndef __starting_point():\n    out = list(re.split('[.,]', input()))\n    print("\n".join(filter(lambda x: re.match('[0-9]+',x), out)))\n__starting_point()
# Enter your code here. Read input from STDIN. Print output to STDOUT\nprint(("-").join(input().strip().split()))\n
e = int(input())\neng = set(map(int,input().split()))\nf = int(input())\nfre = set(map(int,input().split()))\nprint((len(eng & fre)))\n
import numpy\nn_ar = list(map(int,input().split()))\nn = tuple(n_ar)\nprint((numpy.zeros(n,dtype=numpy.int)))\nprint((numpy.ones(n,dtype=numpy.int)))\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\na=int(input())\nfor i in range(0,a):\n    print((i*i))\n
n = input()\neng = set(map(int,input().split()))\nb = input()\nfre = set(map(int,input().split()))\nprint((len(eng.union(fre))))\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\na=int(input())\nb=int(input())\nc=int(input())\nd=int(input())\nprint((pow(a,b)+pow(c,d)))\n
import re\nn = int(input())\nfor i in range(n):\n    s = input()    \n    search_result = re.search(r'^[+-]?\d*\.\d+$',s)\n    print((bool(search_result)))\n
#!/usr/bin/env python3\n\ndef __starting_point():\n    x, k = map(int, input().strip().split())\n    string = input().strip()\n    \n    if eval(string) == k:\n        print(True)\n    else:\n        print(False)\n__starting_point()
# Enter your code here. Read input from STDIN. Print output to STDOUT\nar=[]\nn=int(input())\nfor i in range(0,n):\n    tmp_str=input()\n    tmp_str_ar=tmp_str.strip().split(" ")\n    cmd=tmp_str_ar[0]\n    if(cmd=="print"):\n        print(ar)\n    elif(cmd=="sort"):\n        ar.sort()\n    elif(cmd=="reverse"):\n        ar.reverse()\n    elif(cmd=="pop"):\n        ar.pop()\n    elif(cmd=="count"):\n        val=int(tmp_str_ar[1])\n        ar.count(val)\n    elif(cmd=="index"):\n        val=int(tmp_str_ar[1])\n        ar.index(val)\n    elif(cmd=="remove"):\n        val=int(tmp_str_ar[1])\n        ar.remove(val)  \n    elif(cmd=="append"):\n        val=int(tmp_str_ar[1])\n        ar.append(val)          \n    elif(cmd=="insert"):\n        pos=int(tmp_str_ar[1])\n        val=int(tmp_str_ar[2])\n        ar.insert(pos,val)\n
import re\nn = int(input())\nupper_check = r'.*([A-Z].*){2,}'\ndigit_check = r'.*([0-9].*){3,}'\nalphanumeric_and_length_check = r'([A-Za-z0-9]){10}$'\nrepeat_check = r'.*(.).*\1'\nfor i in range(n):\n    uid_string = input().strip()\n    upper_check_result = bool(re.match(upper_check,uid_string))\n    digit_check_result = bool(re.match(digit_check,uid_string))\n    alphanumeric_and_length_check_result = bool(re.match(alphanumeric_and_length_check,uid_string))\n    repeat_check_result = bool(re.match(repeat_check,uid_string))    \n    if upper_check_result and digit_check_result and alphanumeric_and_length_check_result and not repeat_check_result:\n        print('Valid')\n    else:\n        print('Invalid')\n
def __starting_point():\n    a = int(input())\n    b = int(input())\n    \n    print((a//b))\n    print((a/b))\n\n__starting_point()
import collections\nn = int(input())\nd = collections.deque()\nfor i in range(n):\n    cmd = list(input().strip().split())\n    opt = cmd[0]\n    if opt == 'pop':\n        d.pop()\n    elif opt == 'popleft':\n        d.popleft()\n    elif opt == 'append':\n        d.append(int(cmd[1]))\n    elif opt == 'appendleft':\n        d.appendleft(int(cmd[1]))\nfor i in d:\n    print(i,end=' ')\n\n        \n
k = int(input())\nroom_number_list = list(map(int,input().split()))\nroom_number_set = set(room_number_list)\nroom_number_list_sum = sum(room_number_list)\nroom_number_set_sum = sum(room_number_set) * k\ndiff = room_number_set_sum - room_number_list_sum\nfor i in room_number_set:\n    if diff == ((k-1)*i):\n        print(i)\n        break\n
from collections import Counter\nn, m = list(map(int,input().split()))\nar = list(map(int,input().split()))\nar_set = set(ar)\nar_counter = Counter(ar)\nset_a = set(map(int,input().split()))\nset_b = set(map(int,input().split()))\nintersect_ar_a = list(ar_set&set_a)\nintersect_ar_b = list(ar_set&set_b)\nresult = 0\nfor element in intersect_ar_a:\n    result += ar_counter[element]\nfor element in intersect_ar_b:\n    result -= ar_counter[element]\n    \nprint(result)\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\na=int(input())\nb=int(input())\nprint((a+b))\nprint((a-b))\nprint((a*b))\n
N, M = list(map(int,input().split())) # More than 6 lines of code will result in 0 score. Blank lines are not counted.\nfor i in range(1,N,2): \n    print((int((M-3*i)/2)*'-'+(i*'.|.')+int((M-3*i)/2)*'-'))\nprint((int((M-7)/2)*'-'+'WELCOME'+int((M-7)/2)*'-'))\nfor i in range(N-2,-1,-2): \n    print((int((M-3*i)/2)*'-'+(i*'.|.')+int((M-3*i)/2)*'-'))\n
import re\np = input().strip()\nrange_check = bool(re.match(r'^[1-9][0-9]{5}$',p))\nrepeat_check = len(re.findall(r'(?=([0-9])[0-9]\1)',p))\nprint((range_check == True and repeat_check<2))\n
n = int(input())\na = set(map(int,input().split()))\nN = int(input())\nfor i in range(N):\n    cmd = input().split()\n    opt = cmd[0]\n    s = set(map(int,input().split()))\n    if (opt == 'update'):\n        a |= s\n    elif (opt == 'intersection_update'):\n        a &= s\n    elif (opt == 'difference_update'):\n        a -= s\n    elif (opt == 'symmetric_difference_update'):\n        a ^= s\nprint((sum(a)))\n
from itertools import combinations\nn = int(input())\nar = input().split()\nk = int(input())\ncomb_list = list(combinations(ar,k))\na_list = [e for e in comb_list if 'a' in e]\nprint((len(a_list) / len(comb_list)))\n
from collections import defaultdict\nd = defaultdict(list)\nn,m=list(map(int,input().split()))\nfor i in range(n):\n    w = input()\n    d[w].append(str(i+1))\nfor j in range(m):\n    w = input()\n    print((' '.join(d[w]) or -1))\n
import re\nfrom html.parser import HTMLParser\n\nclass MyHTMLParser(HTMLParser):\n    def handle_starttag(self, tag, attrs):\n        print("Start".ljust(6) + ":", tag)\n        for at in attrs:\n            print("-> {} > {}".format(at[0], at[1]))\n    def handle_endtag(self, tag):\n        print("End".ljust(6) + ":", tag)\n    def handle_startendtag(self, tag, attrs):\n        print("Empty".ljust(6) + ":", tag)\n        for at in attrs:\n            print("-> {} > {}".format(at[0], at[1]))\n\ndef __starting_point():\n    parser = MyHTMLParser()\n    n = int(input().strip())\n    for _ in range(n):\n        line = input()\n        parser.feed(line)\n__starting_point()
for i in range(1,int(input())+1): #More than 2 lines will result in 0 score. Do not leave a blank line also\n    print(((10**i//9)**2))\n
import itertools\n\nk, m = list(map(int,input().split()))\n\nmain_ar = []\nfor i in range(k):\n    ar = list(map(int,input().split()))\n    main_ar.append(ar[1:])\n\nall_combination = itertools.product(*main_ar)\nresult = 0\nfor single_combination in all_combination:   \n    result = max(sum([x*x for x in single_combination])%m,result)\nprint(result)\n
import collections, re\nn = int(input())\nitem_od = collections.OrderedDict()\nfor i in range(n):\n    record_list = re.split(r'(\d+)$',input().strip())\n    item_name = record_list[0]\n    item_price = int(record_list[1])\n    if item_name not in item_od:\n        item_od[item_name]=item_price\n    else:\n        item_od[item_name]=item_od[item_name]+item_price\n            \nfor i in item_od:\n    print((i+str(item_od[i])))\n
n, m = map(int,input().split())\nar = []\nfor i in range(n):\n    ar.append(list(map(int,input().split())))\nk = int(input())\nar = sorted(ar,key = lambda x:x[k])\nfor i in ar:\n    [print(x,end=' ') for x in i]\n    print('')\n
import numpy\nn = int(input())\nar = []\nfor i in range(n):\n    tmp = list(map(float,input().split()))\n    ar.append(tmp)\nnp_ar = numpy.array(ar,float)\nprint((numpy.linalg.det(np_ar)))\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\ns=input()\nss=input()\ncnt=0\nlen_s=len(s)\nlen_ss=len(ss)\nfor i in range(0,len_s):\n    tmp=s[i:i+len_ss]\n    if(tmp==ss):\n        cnt=cnt+1\nprint(cnt)\n
n, x = list(map(int,input().split()))\nar = [0 for i in range(n)]\nfor i in range(x):\n    temp_ar=list(map(float,input().split()))\n    for j in range(n):\n        ar[j] += temp_ar[j]\nfor i in range(n):\n    print((ar[i]/x))\n
import math\nab = float(input())\nbc = float(input())\nac = math.sqrt((ab*ab)+(bc*bc))\nbm = ac / 2.0\nmc = bm\n#let, \nb = mc\nc = bm\na = bc\n#where b=c\nangel_b_radian = math.acos(a / (2*b))\nangel_b_degree = int(round((180 * angel_b_radian) / math.pi))\noutput_str = str(angel_b_degree)+''\nprint(output_str)\n
import re\nn, m = list(map(int,input().split()))\ncharacter_ar = [''] * (n*m)\nfor i in range(n):\n    line = input()\n    for j in range(m):\n        character_ar[i+(j*n)]=line[j]\ndecoded_str = ''.join(character_ar)\nfinal_decoded_str = re.sub(r'(?<=[A-Za-z0-9])([ !@#$%&]+)(?=[A-Za-z0-9])',' ',decoded_str)\nprint(final_decoded_str) \n
input()\n
from collections import deque\ncas = int(input())\nfor t in range(cas):\n    n = int(input())\n    dq = deque(list(map(int,input().split())))\n    possible = True\n    element = (2**31)+1\n    while dq:\n        left_element = dq[0]\n        right_element = dq[-1]\n        if left_element>=right_element and element>=left_element:\n            element = dq.popleft()\n        elif right_element>=left_element and element>=right_element:\n            element = dq.pop()\n        else:\n            possible = False\n            break\n    if possible:\n        print('Yes')\n    else:\n        print('No')   \n
import datetime\ncas = int(input())\nfor t in range(cas):\n    timestamp1 = input().strip()\n    timestamp2 = input().strip()\n    time_format = "%a %d %b %Y %H:%M:%S %z"\n    time_second1 = datetime.datetime.strptime(timestamp1,time_format)\n    time_second2 = datetime.datetime.strptime(timestamp2,time_format)\n    print((int(abs((time_second1-time_second2).total_seconds()))))\n
def swap_case(s):\n    newstring = ""\n    \n    for item in s:\n        if item.isupper():\n            newstring += item.lower()\n        else:\n            newstring += item.upper()\n            \n    return newstring\n
e = int(input())\neng = set(map(int,input().split())) \nf = int(input())\nfre = set(map(int,input().split()))\nprint((len(eng ^ fre)))\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\ninputStr=input()\nresalnum = False\nresalpha = False\nresdigit = False\nreslower = False\nresupper = False\nfor i in inputStr:\n    if(i.isalnum()):\n        resalnum=True\n    if(i.isalpha()):\n        resalpha=True\n    if(i.isdigit()):\n        resdigit=True\n    if(i.islower()):\n        reslower=True\n    if(i.isupper()):\n        resupper=True\n    \nprint(resalnum)\nprint(resalpha)\nprint(resdigit)\nprint(reslower)\nprint(resupper)\n
from itertools import *\ns,n = input().split()\nn = int(n)\ns = sorted(s)\nfor j in combinations_with_replacement(s,n):\n    print((''.join(j)))\n
import re\nn = int(input())\nfor t in range(n):\n    s = input()\n    match_result = re.findall(r'(#[0-9A-Fa-f]{3}|#[0-9A-Fa-f]{6})(?:[;,.)]{1})',s)\n    for i in match_result:\n        if i != '':\n            print(i)\n
import re\nn = int(input())\nfor i in range(n):\n    s = input()\n    try:\n        re.compile(s)\n        print(True)\n    except Exception as e:\n        print(False)\n
e = int(input())\neng = set(map(int,input().split())) \nf = int(input())\nfre = set(map(int,input().split()))\nprint((len(eng - fre)))\n
def __starting_point():\n    print("Hello, World!")\n\n__starting_point()
n,l = map(int,input().split())\na = []\nfor i in range(n):\n  a.append(input())\n  \na.sort()\nprint("".join(str(i) for i in a))
def prod2sum(a, b, c, d):\n    e = sorted([abs(a*d-b*c), abs(a*c+b*d)])\n    f = sorted([abs(a*c-b*d), abs(a*d+b*c)])\n    if e == f:\n        return [e]\n    else:\n        return sorted([e, f])\n\n
def count_squares(lines):\n    def s(i, j, z):\n        try:\n            return (\n                '+' == lines[i+z][j] == lines[i][j+z] == lines[i+z][j+z]\n                and all(lines[i][c]   in '-+' for c in range(j+1, j+z))\n                and all(lines[i+z][c] in '-+' for c in range(j+1, j+z))\n                and all(lines[r][j]   in '|+' for r in range(i+1, i+z))\n                and all(lines[r][j+z] in '|+' for r in range(i+1, i+z))\n            )\n        except IndexError:\n            return 0\n    return sum(\n        x == '+' and sum(s(i, j, z) for z in range(1, min(len(lines)-i, len(row)-j)))\n        for i, row in enumerate(lines[:-1])\n        for j, x in enumerate(row[:-1])\n    )\n
BINGO = {ord(c)-64 for c in "BINGO"}\n\ndef bingo(lst): \n    return "WIN" if set(lst) >= BINGO else "LOSE"
def michael_pays(cost):\n    return round(cost if cost < 5 else max(cost*2/3, cost-10), 2)
def duck_shoot(ammo, aim, ducks):\n    return ducks.replace('2', 'X', int(ammo * aim))
import re\n\nSPLITTER = re.compile(r"[\s-]")\n\ndef birdify(lst):\n    return ''.join(x[:4//len(lst)] for x in lst) + ('' if len(lst)!=3 else lst[-1][1])\n\ndef bird_code(arr):\n    return [birdify(SPLITTER.split(name)).upper() for name in arr]
def make_string(s):\n    return ''.join(a[0] for a in s.split())\n
def convert_bits(a,b):\n    return bin(a^b).count("1")
def last_chair(n):\n    return n - 1
def args_to_string(args):\n    L = []\n    for arg in args:\n        if isinstance(arg, str):\n            L.append(arg)\n        elif len(arg) == 1:\n            L.append(arg[0])\n        elif len(arg[0]) == 1:\n            L.append('-' + ' '.join(arg))\n        else:\n            L.append('--' + ' '.join(arg))\n    return ' '.join(L)
import re\n\ndef find_codwars(url):\n    return bool(re.match(r''\n        '^(https?://)?'   # http(s)://\n        '([a-z]+\.)*'     # subdomains\n        'codwars\.com'    # codwars.com\n        '([/?].*)?$'      # directories or querystrings\n        , url))
def shoot(results):\n    pete = phil = 0\n    \n    for shots, double in results:\n        pete += shots["P1"].count("X") * (1 + double)\n        phil += shots["P2"].count("X") * (1 + double)\n    \n    return "Pete Wins!" if pete > phil else "Phil Wins!" if phil > pete else "Draw!"
def addsup(a1, a2, a3):\n  return [[x,y,x+y] for x in a1 for y in a2 if x+y in a3]
def solve(s):\n    v = sum(s[i] != s[-1-i] for i in range((len(s))//2) )\n    return v == 1 or not v and len(s)%2
def meeting(rooms):\n    try:\n        return rooms.index('O')\n    except ValueError:\n        return 'None available!'\n
from itertools import accumulate\n\ndef spacey(a):\n    return list(accumulate(a))
'''\nVasyl Zakharuk\nPython Core 355\nCodewars Kata: Will you make it?\n''' \ndef zero_fuel(distance_to_pump, mpg, fuel_left):\n    if fuel_left >= distance_to_pump / mpg:\n        print("We got to the pump")\n        return True\n    else:\n        print("We pushed the car to the pump(((")\n        return False\nprint(zero_fuel(50,25,2))
def step_through_with(s):\n    return any(m == n for m, n in zip(s, s[1:]))
from operator import mul\nfrom functools import reduce\n\ndef genSequence(n):\n    yield n\n    while True:\n        n += reduce(mul, [int(d) for d in str(n) if d != '0']) if n > 9 else n\n        yield n\n\ndef extract(seq, v):\n    return sorted(seq).index(v)\n\ndef convergence(n):\n    gen1, genN = genSequence(1), genSequence(n)\n    seq1, seqN = {next(gen1)}, {next(genN)}\n    while True:\n        a,b = next(gen1), next(genN)\n        seq1.add(a)\n        seqN.add(b)\n        if a in seqN: return extract(seqN, a)\n        if b in seq1: return extract(seqN, b)
def look_and_say_and_sum(N):\n    l=[1]\n    for n in range(N-1):\n        result = [1,l[0]]\n        for i in range(1,len(l)):\n            if l[i]==result[-1]:\n                result[-2] += 1\n            else:\n                result += [1,l[i]] \n        l=result\n    return sum(l)\n
def cat_mouse(x,j):\n    d, c, m = x.find('D'), x.find('C'), x.find('m')\n    if -1 in [d, c, m]:\n        return 'boring without all three'\n    if abs(c - m) <= j:\n        return 'Protected!' if c < d < m or m < d < c else 'Caught!' \n    return 'Escaped!'
def color_probability(color, texture):\n    marbles = {"smooth": {"red": 1, "yellow": 1, "green": 1, "total": 3}, "bumpy": {"red": 4, "yellow": 2, "green": 1, "total": 7}}\n    return "{}".format(marbles[texture][color] / marbles[texture]["total"])[:4]
def passer_rating(att, yds, comp, td, ints):\n    limit = lambda x: min(max(x, 0), 2.375)\n    \n    att = float(att)    # for python 2 compatibility\n    \n    A = ((comp / att) - .3) * 5\n    B = ((yds / att) - 3) * .25\n    C = (td / att) * 20\n    D = 2.375 - ((ints / att) * 25)\n    \n    A, B, C, D = map(limit, (A, B, C, D))\n    \n    return round( (A + B + C + D) / 6 * 100, 1 )
def two_sort(lst):\n    return '***'.join(min(lst))
def bad_apples(apples):\n    lst, notFull = [], []\n    for a,b in apples:\n        if (bool(a) ^ bool(b)) and notFull:  lst[notFull.pop()].append(a or b)                  # One bad and partially full box already present: fill it (as second element)\n        elif a and b:                        lst.append([a,b])                                  # 2 good ones: keep as they are\n        elif a or b:                         notFull.append(len(lst)) ; lst.append([a or b])    # 1 good but no partial box: archive\n    if notFull: lst.pop(notFull.pop())                                                          # If 1 not full box remains: remove it\n    return lst
from itertools import groupby\n\ndef find_needed_guards(islands):\n    return sum(sum(1 for _ in g)>>1 for k,g in groupby(islands) if not k)
import re\n\nH, W     = 6, 8\nKEYBOARD = "abcde123fghij456klmno789pqrst.@0uvwxyz_/* "\nMAP      = {c: (i//W, i%W) for i,c in enumerate(KEYBOARD)}\n\n\ndef manhattan(*pts):\n    dxy = [abs(z2-z1) for z1,z2 in zip(*pts)]\n    return 1 + sum( min(dz, Z-dz) for dz,Z in zip(dxy, (H,W)) )\n\ndef toggle(m):\n    ups, end = m.groups()\n    return f'*{ups.lower()}*{end}'                    # Toggle Shift ON if uppercase presents, and then OFF if lowercase after (or end of the string)\n\n\ndef tv_remote(words):\n    reWords = re.sub(r'([A-Z][^a-z]*)([a-z]?)', toggle, words).rstrip('*')                # Strip any useless toggle OFF at the end\n    return sum( manhattan(MAP[was], MAP[curr]) for was,curr in zip('a'+reWords, reWords))\n
def no_order(equation):\n    equation = equation.replace(' ', '')\n    equation = equation.replace('+', ')+')\n    equation = equation.replace('-', ')-')\n    equation = equation.replace('*', ')*')\n    equation = equation.replace('/', ')//')\n    equation = equation.replace('%', ')%')\n    equation = equation.replace('^', ')**')\n    equation = '('*equation.count(')') + equation\n    try : return eval(equation)\n    except : pass
def hamster_me(code, message):\n    code, dct = sorted(set(code)), {}\n    for c1,c2 in zip(code, code[1:] + [chr(ord("z") + ord(code[0]) - ord("a"))]):\n        for n in range(ord(c1), ord(c2)+1):\n            dct[chr( (n-97)%26 + 97 )] = c1 + str(n-ord(c1)+1)\n    return ''.join(dct[c] for c in message)
import math\n\ndef race(v1, v2, g):\n    if v2 < v1: return None\n    seconds = 0.1\n    while (v1/3600) * seconds + g >= (v2/3600) * seconds:\n        seconds += 0.05\n    hours = seconds / 3600\n    hoursRest = seconds % 3600\n    minutes = hoursRest / 60\n    seconds = hoursRest % 60\n    return [math.floor(hours), math.floor(minutes), math.floor(seconds)]\n
import math\n\ndef bouncing_ball(initial, proportion):\n    return math.ceil(math.log(initial, 1/proportion))
def est_subsets(arr):\n    return 2**len(set(arr)) - 1
def split_the_bill(x):\n    diff = sum(x.values())/float(len(x))\n    return {k: round(x[k]-diff, 2) for k in x}
def ordering_beers(beers):\n    assert 0 <= beers < 100\n    \n    units = ["", "jeden", "dwa", "trzy", "cztery", "piec", "szesc" , "siedem", "osiem", "dziewiec",\n            "dziesiec", "jedenascie", "dwanascie", "trzynascie", "czternascie", "pietnascie", "szesnascie", "siedemnascie", "osiemnascie", "dziewietnascie"]\n    tens  = ["", "", "dwadziescia", "trzydziesci", "czterdziesci", "piecdziesiat", "szescdziesiat", "siedemdziesiat", "osiemdziesiat", "dziewiecdziesiat"]\n    \n    if beers == 0:\n        order = "Woda mineralna"\n    elif beers == 1:\n        order = "Jedno piwo"\n    elif beers < 20:\n        order = units[beers] + " piw"\n    else:\n        order = tens[beers // 10] + " " * bool(beers % 10) + units[beers % 10] + " piw"\n    \n    if beers % 10 in [2, 3, 4] and beers not in [12, 13, 14]:\n        order += "a"\n    \n    return order.capitalize() + " poprosze"
abc = "abcdefghijklmnopqrstuvwxyz"\n\ndef keyword_cipher(s, keyword, key=""):\n    for c in keyword + abc:\n        if c not in key:\n            key += c\n    return s.lower().translate(str.maketrans(abc, key))
def changer(s):\n    return s.lower().translate(str.maketrans('abcdefghijklmnopqrstuvwxyz', 'bcdEfghIjklmnOpqrstUvwxyzA'))
def format_words(words):\n    return ', '.join(word for word in words if word)[::-1].replace(',', 'dna ', 1)[::-1] if words else ''
from itertools import count\n\n# Couldn't find the pattern of why it's 1 or 8, I'm sad :(\ndef repeat_sequence_len(n):\n    memo = {}\n    for i in count():\n        if n in memo: return i - memo[n]\n        memo[n] = i\n        n = sum(d*d for d in map(int, str(n)))
employees = [{'first_name': 'Ollie', 'last_name': 'Hepburn', 'role': 'Boss'}, {'first_name': 'Morty', 'last_name': 'Smith', 'role': 'Truck Driver'}, {'first_name': 'Peter', 'last_name': 'Ross', 'role': 'Warehouse Manager'}, {'first_name': 'Cal', 'last_name': 'Neil', 'role': 'Sales Assistant'}, {'first_name': 'Jesse', 'last_name': 'Saunders', 'role': 'Admin'}, {'first_name': 'Anna', 'last_name': 'Jones', 'role': 'Sales Assistant'}, {'first_name': 'Carmel', 'last_name': 'Hamm', 'role': 'Admin'}, {'first_name': 'Tori', 'last_name': 'Sparks', 'role': 'Sales Manager'}, {'first_name': 'Peter', 'last_name': 'Jones', 'role': 'Warehouse Picker'}, {'first_name': 'Mort', 'last_name': 'Smith', 'role': 'Warehouse Picker'}, {'first_name': 'Anna', 'last_name': 'Bell', 'role': 'Admin'}, {'first_name': 'Jewel', 'last_name': 'Bell', 'role': 'Receptionist'}, {'first_name': 'Colin', 'last_name': 'Brown', 'role': 'Trainee'}]\ndef find_employees_role(name):\n    \n    for employee in employees:\n        if employee['first_name'] + ' ' + employee['last_name'] == name:\n            return employee['role']\n        \n    return "Does not work here!"
def remove_parentheses(s):\n    lvl,out = 0,[]\n    for c in s:\n        lvl += c=='('\n        if not lvl: out.append(c)\n        lvl -= c==')'    \n    return ''.join(out)
import re\n\n\ndef solve(s):\n    return max(map(int,re.findall(r"(\d+)", s)))
def bubble(l):\n    ret = []\n    for i in range(len(l) - 1, 0, -1):\n        for j in range(i):\n            if l[j] > l[j + 1]:\n                l[j], l[j + 1] = l[j + 1], l[j]\n                ret.append(l[:])\n    return ret
def remove_nth_element(a, n):\n    return a[:n] + a[n+1:]
def paul(x):\n    points = {'life': 0, 'eating': 1, 'kata': 5, 'Petes kata': 10}\n    misery = sum(map(points.get, x))\n    return ['Miserable!', 'Sad!', 'Happy!', 'Super happy!']\\n            [(misery<40)+(misery<70)+(misery<100)]
def pair_of_shoes(a):\n    return sorted(s for lr, s in a if lr == 1) == sorted(s for lr, s in a if lr == 0)
def prime_string(s):\n    return (s + s).find(s, 1) == len(s)
def solution(s):\n    return ''.join(' ' + c if c.isupper() else c for c in s)\n
def sum_arrays(*args):\n    if all(x == [] for x in args) or all(x == [0] for x in args):\n        return []\n    elif any(x == [] for x in args):\n        return max(args)\n    else:\n        s = sum(int(''.join(map(str, x))) for x in args)\n        minus = s < 0\n    return [int(x) * -1 if minus and i == 0 else int(x)\n                        for i, x in enumerate(list(str(abs(s))))]\n
words = "zero one two three four five six seven eight nine" + \\n" ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty" + \\n" thirty forty fifty sixty seventy eighty ninety"\nwords = words.split(" ")\n\ndef number2words(n):\n    if n < 20:\n        return words[n]\n    elif n < 100:\n        return words[18 + n // 10] + ('' if n % 10 == 0 else '-' + words[n % 10])\n    elif n < 1000:\n        return number2words(n // 100) + " hundred" + (' ' + number2words(n % 100) if n % 100 > 0 else '')\n    elif n < 1000000:\n        return number2words(n // 1000) + " thousand" + (' ' + number2words(n % 1000) if n % 1000 > 0 else '')
def black_or_white_key(key_press_count):\n    return "black" if (key_press_count - 1) % 88 % 12 in [1, 4, 6, 9, 11] else "white"\n
points = [0, 40, 100, 300, 1200]\n\ndef get_score(arr) -> int:\n    cleared = 0\n    score = 0\n    for lines in arr:\n        level = cleared // 10\n        score += (level+1) * points[lines]\n        cleared += lines\n    return score
from collections import Counter\n\ndef create_anagram(s, t):\n    return sum((Counter(s) - Counter(t)).values())
def square_sum(numbers):\n    return sum(x ** 2 for x in numbers)
def almost_increasing_sequence(sequence):\n    save, first = -float('inf'), True\n    for i,x in enumerate(sequence):\n        if x > save: save = x\n        elif first:\n            if i == 1 or x > sequence[i-2]: save = x\n            first = False\n        else: return False\n    return True
def generate_integers(m, n): \n    return list(range(m,n+1))
def pass_the_bill(total, conservative, reformist):\n    ind = total - conservative - reformist\n    majority = total//2 + 1\n    if conservative > majority:\n        return 0\n    elif conservative + ind < majority:\n        return -1\n    else:\n        return majority - conservative
def last_man_standing(n):\n    dir, lst = -1, range(2,n+1,2)\n    while len(lst) != 1:\n        lst = lst[len(lst)%2 or dir == 1 ::2]\n        dir = -dir\n    return lst[0]
from collections import deque\n\ndef yes_no(arr):\n    d, result = deque(arr), []\n    while d:\n        result.append(d.popleft())\n        d.rotate(-1)\n    return result
def take_umbrella(weather, rain_chance):\n    # Your code here.\n    return (weather=='cloudy' and rain_chance>0.20) or weather=='rainy' or (weather=='sunny' and rain_chance>0.5)
def scrabble_score(st): \n    x = 0\n    for y in st:\n        if 'a' in y.lower():\n            x += 1\n        if 'e' in y.lower():\n            x += 1\n        if 'i' in y.lower():\n            x += 1\n        if 'o' in y.lower():\n            x += 1\n        if 'u' in y.lower():\n            x += 1\n        if 'l' in y.lower():\n            x += 1\n        if 'n' in y.lower():\n            x += 1\n        if 'r' in y.lower():\n            x += 1\n        if 's' in y.lower():\n            x += 1\n        if 't' in y.lower():\n            x += 1\n        if 'd' in y.lower():\n            x += 2\n        if 'g' in y.lower():\n            x += 2\n        if 'b' in y.lower():\n            x += 3\n        if 'c' in y.lower():\n            x += 3\n        if 'm' in y.lower():\n            x += 3\n        if 'p' in y.lower():\n            x += 3\n        if 'f' in y.lower():\n            x += 4\n        if 'h' in y.lower():\n            x += 4\n        if 'v' in y.lower():\n            x += 4\n        if 'w' in y.lower():\n            x += 4\n        if 'y' in y.lower():\n            x += 4\n        if 'k' in y.lower():\n            x += 5\n        if 'j' in y.lower():\n            x += 8\n        if 'x' in y.lower():\n            x += 8\n        if 'q' in y.lower():\n            x += 10\n        if 'z' in y.lower():\n            x += 10\n    return x
def outcome(n, s, k):    \n    if n == 1: return 1 if 0 < k <= s else 0\n    return sum(outcome(n - 1, s, k - j - 1) for j in range(s)) if k > 0 else 0
def loneliest(n):\n    a = list(map(int, str(n)))\n    b = [(sum(a[max(0, i - x):i+x+1]) - x, x) for i, x in enumerate(a)]\n    return (min(b)[0], 1) in b
INITIAL = [0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292]\n\ndef solve(n):\n    return INITIAL[n] if n < 12 else 292 + (49 * (n-11))
import re\n\nWATER_PATTERN = re.compile(r"water|wet|wash", re.I)\nSLIME_PATTERN = re.compile(r"\bI don't know\b|slime", re.I)\n\n\ndef bucket_of(said):\n    water = WATER_PATTERN.search(said)\n    slime = SLIME_PATTERN.search(said)\n\n    if water:\n        return 'sludge' if slime else 'water'\n\n    return 'slime' if slime else 'air'\n
def counter_effect(hit_count):\n    return [[i for i in range(int(hit_count[x]) + 1)] for x in range(4)]
def encode(s, t=str.maketrans("aeiou", "12345")):\n    return s.translate(t)\n    \ndef decode(s, t=str.maketrans("12345", "aeiou")):\n    return s.translate(t)
def scf(lst):\n    return next((k for k in range(2, 1 + min(lst, default=1)) if all(n % k == 0 for n in lst)), 1)\n
import re\ndef timed_reading(max_length, text):\n    return sum(len(i) <= max_length for i in re.findall('\w+', text))
def add(*args):\n    return sum((i+1)*v for i,v in enumerate(args))
def solution(digits):\n    numlist = [int(digits[i:i+5]) for i in range(0,len(digits)-4)]\n    return max(numlist)
def pyramid(n):\n    return '\n'.join("/{}\\".format(" _"[r==n-1] * r*2).center(2*n).rstrip() for r in range(n)) + '\n'
def remove_url_anchor(url):\n  return url.split('#')[0]
N = ['zero','one','two','three','four','five','six','seven','eight','nine']\n\ndef average_string(s):\n    try:\n        return N[sum(N.index(w) for w in s.split()) // len(s.split())]\n    except (ZeroDivisionError, ValueError):\n        return 'n/a'
def kebabize(s):\n    return ''.join(c if c.islower() else '-' + c.lower() for c in s if c.isalpha()).strip('-')
def gimme(inputArray):\n    # Implement this function\n    return inputArray.index(sorted(inputArray)[1])
def square_it(digits):\n    s = str(digits)\n    n = len(s)**0.5\n    if n != int(n):\n        return "Not a perfect square!"\n    n = int(n)\n    return "\n".join(s[i*n:i*n+n] for i in range(int(n)))
from collections import Counter\nfrom string import ascii_lowercase\n\ndef missing_alphabets(s):\n    c = Counter(s)\n    m = max(c.values())\n    return ''.join(letter * (m - c[letter]) for letter in ascii_lowercase)
def egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n\n\ndef inverseMod(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        return None\n    else:\n        return x % m\n    \n\n
def find_jane(n):\n    return (n - 1) // 2
def tickets(people):\n  till = {100.0:0, 50.0:0, 25.0:0}\n\n  for paid in people:\n    till[paid] += 1\n    change = paid-25.0\n    \n    for bill in (50,25):\n      while (bill <= change and till[bill] > 0):\n        till[bill] -= 1\n        change -= bill\n\n    if change != 0:\n      return 'NO'\n        \n  return 'YES'
from datetime import timedelta, datetime\ndef day_and_time(mins):\n    return "{:%A %H:%M}".format(datetime(2017, 1, 1) + timedelta(minutes = mins))
from collections import Counter\n\ndef blocks(s):\n    sort = lambda c: (c.isdigit(), c.isupper(), c)\n    answer, counter = [], Counter(s)\n    while counter:\n        block = ''.join(sorted(counter, key=sort))\n        answer.append(block)\n        counter = counter - Counter(block)\n    return '-'.join(answer)
def last(s):\n    return sorted(s.split(), key=lambda x: x[-1])
from itertools import combinations\nfrom math import hypot\n\ndef peaceful_yard(yard, d):\n  cats = ((i, j) for i,r in enumerate(yard) for j,c in enumerate(r) if c in 'LMR')\n  return all(hypot(q[0] - p[0], q[1] - p[1]) >= d for p,q in combinations(cats, 2))
def jumping_number(number):\n    arr = list(map(int, str(number)))\n    return ('Not!!', 'Jumping!!')[all(map(lambda a, b: abs(a - b) == 1, arr, arr[1:]))]
from functools import cmp_to_key\n\ncmp = lambda a, b: int('%i%i' % (b, a)) - int('%i%i' % (a, b))\nlargest_arrangement = lambda n: int(''.join(str(i) for i in sorted(n, key = cmp_to_key(cmp))))
def near_flatten(a):\n    r = []\n    for x in a:\n        if isinstance(x[0], int): r.append(x)\n        else: r.extend(near_flatten(x))\n    return sorted(r)
def i_tri(s):\n    total = 2.4 + 112 + 26.2\n    to_go = '%.2f to go!' % (total - s)\n    \n    return ( 'Starting Line... Good Luck!' if s == 0 else\n            {'Swim': to_go} if s < 2.4 else\n            {'Bike': to_go} if s < 2.4 + 112 else\n            {'Run':  to_go} if s < total - 10 else\n            {'Run': 'Nearly there!'} if s < total else\n            "You're done! Stop running!" )
def cube_odd(arr):\n    return sum( n**3 for n in arr if n % 2 ) if all(type(n) == int for n in arr) else None
def wheat_from_chaff(values):\n    i, j = 0, len(values)-1\n    while True:\n        while i < j and values[i] < 0: i += 1\n        while i < j and values[j] > 0: j -= 1\n        if i >= j: return values\n        values[i], values[j] = values[j], values[i]
def russian_peasant_multiplication(x, y):\n    product = 0\n    while y != 0:\n        if y % 2 == 1:\n            product += x\n        x += x\n        y //= 2\n        \n    return product
def scramble(string, array):\n    return "".join(v for _, v in sorted(zip(array, string)))
from statistics import mean\nfrom math import floor\n\ndef sum_average(arr):\n    return floor(sum(map(mean, arr)))
from operator import add, mul, floordiv as fdiv, pow\n\ndef poohbear(s):\n    \n    def updateMem(func, v): mem[p] = func(mem.get(p, 0), v) % 256\n\n    braces, stack = {}, []\n    for i,c in enumerate(s):\n        if c == 'W': stack.append(i)\n        if c == 'E':\n            braces[i] = stack[-1]\n            braces[stack.pop()] = i\n    \n    mem, copy, output = {}, 0, []\n    p, i = 0, 0\n    while i < len(s):\n        cmd = s[i]\n        if   cmd == '>':  p += 1\n        elif cmd == '<':  p -= 1\n        elif cmd == 'p':  mem[p] = copy\n        elif cmd == 'c':  copy = mem.get(p, 0)\n        elif cmd == 'W':  i = i if bool(mem.get(p, 0)) else braces[i]\n        elif cmd == 'E':  i = braces[i] if mem.get(p, 0) else i\n        elif cmd == 'P':  output.append(chr(mem.get(p, 0)))\n        elif cmd == 'N':  output.append(str(mem.get(p, 0)))\n        elif cmd == '+':  updateMem(add,  1)\n        elif cmd == '-':  updateMem(add, -1)\n        elif cmd == 'L':  updateMem(add,  2)\n        elif cmd == 'I':  updateMem(add, -2)\n        elif cmd == 'T':  updateMem(mul,  2)\n        elif cmd == 'V':  updateMem(fdiv, 2)\n        elif cmd == 'Q':  updateMem(pow,  2)\n        elif cmd == 'U':  updateMem(lambda a,b: int(pow(a, b)), .5)\n        elif cmd == 'A':  updateMem(add,  copy)\n        elif cmd == 'B':  updateMem(add, -copy)\n        elif cmd == 'Y':  updateMem(mul,  copy)\n        elif cmd == 'D':  updateMem(fdiv, copy)\n        i += 1\n        \n    return ''.join(output)
def tower_of_hanoi(rings):\n    return 2**rings - 1
def check_vowel(s,i):\n    return 0 <= i < len(s) and s[i] in "aieouAEIOU"
from itertools import combinations\n\n\ndef isRect(a,b,c):\n    X,Y,Z = sorted( sum( (q-p)**2 for p,q in zip(p1,p2)) for p1,p2 in [(a,b), (a,c), (b,c)] )\n    return X+Y == Z\n\ndef count_rect_triang(points):\n    return sum( isRect(*c) for c in combinations(set(map(tuple, points)), 3) )
def namelist(names):\n    if len(names) > 1:\n        return '{} & {}'.format(', '.join(name['name'] for name in names[:-1]), \n                                names[-1]['name'])\n    elif names:\n        return names[0]['name']\n    else:\n        return ''
def solve(lst):\n    a, b, c = lst[0] < lst[1], lst[1] < lst[2], lst[-1] < lst[0]\n    m = a if a == b else c\n    return ('R' if c == m else '') + ('A' if m else 'D')
from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef make_sequences(n):\n    return 1 + sum(map(make_sequences, range(1, n//2+1)))
def word_search(query, seq):\n    return [x for x in seq if query.lower() in x.lower()] or ["None"]
def summary_ranges(nums):\n    ret, s = [], float('-inf')\n    for e, n in zip([s] + nums, nums + [-s]):\n        if n - e > 1:\n            ret.append(['{}', '{}->{}'][s<e].format(s,e))\n            s = n\n    return ret[1:]
def is_kiss(words):\n    wordsL = words.split(' ')\n    l = len(wordsL)\n    for word in wordsL:\n        if len(word) > l: return "Keep It Simple Stupid"\n    return "Good work Joe!"
lm = ['.-', '-...', '-.-.', '-..', '.', '..-.', '--.', '....', '..', '.---', '-.-', '.-..', '--', '-.', '---', '.--.', '--.-', '.-.', '...', '-', '..-', '...-', '.--', '-..-', '-.--', '--..', '-----', '.----', '..---', '...--', '....-', '.....', '-....', '--...', '---..', '----.']\nll = "abcdefghijklmnopqrstuvwxyz0123456789"\nrepldict = {'.-': 'a', '-...': 'b'}\n\nfor i in range(2, len((ll))):\n    repldict.update({lm[i]: ll[i]})\nprint(repldict)\n\ndef decode(encoded):\n    if encoded ==" " or encoded =="":\n        return encoded\n    words = encoded.split("  ")\n    engwords = []\n    for word in words:\n        engword = []\n        letters = word.split(" ")\n        for letter in letters:\n            engword.append(repldict.get(letter))\n        engword.append(" ")\n        engwords.append("".join(engword))\n    r = "".join(engwords)\n    return r[0:len(r)-1]
def multiple_of_index(l):\n    return [l[i] for i in range(1, len(l)) if l[i] % i == 0]
from bisect import bisect\n\nmemo = {3: [3105, 7425, 30105, 31050, 37125, 42741, 44172, 71253, 72441, 74142, 74250, 74628, 74925, 82755, 85725],\n        4: [7128, 8712, 67128, 70416, 71208, 71280, 71328, 71928, 72108, 78912, 79128, 80712, 86712, 87120, 87132, 87192, 87912, 95832],\n        5: [],\n        6: [8316, 83160, 83916, 84510, 89154, 91152],\n        7: [9513, 81816, 83181, 90321, 91203, 93513, 94143, 95130, 95193, 95613]}\n\ndef search_permMult(nMax, k):\n    return bisect(memo[k], nMax)
import re;\ndef check_password(s):\n    if re.search('^(?=.*?[a-z])(?=.*?[A-Z])(?=.*?\d)(?=.*?[!@#$%^&*?])[a-zA-Z\d!@#$%^&*?]{8,20}$', s) :\n        return 'valid'\n    else:\n        return 'not valid'
def decode(number):\n    return ', '.join(\n        str(int(w, 2)) if i % 2 else\n        ''.join( chr(int(w[x:x+3])-4) for x in range(0, len(w), 3) )\n        for i, w in enumerate( str(number).strip('98').split('98') )\n        )
from itertools import chain, zip_longest\n\ndef interleave(*args):\n    return list(chain.from_iterable(zip_longest(*args)))
def total_licks(env):\n    d = 252\n    vm = 0\n    for k,v in env.items():\n        d+=v\n        if v > vm:\n            vm, km = v, k\n    return 'It took ' + str(d) + ' licks to get to the tootsie roll center of a tootsie pop.' + (' The toughest challenge was ' + km + '.' if vm > 0 else '')
from math import sqrt\ndef length_of_line(array):\n   x1, y1, x2, y2 = array[0][0], array[0][1], array[1][0], array[1][1]\n   return '{:.2f}'.format((sqrt((x2-x1)**2 + (y2-y1)**2)))
def scoreboard(string):\n    scores = {'nil': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    return [scores[x] for x in string.split() if x in scores]
import math\ndef sol_equa(n):\n    res = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            j = n // i\n            if (i + j) % 2 == 0 and (j - i) % 4 == 0:\n                x = (i + j) // 2\n                y = (j - i) // 4\n                res.append([x, y])\n            \n    return res\n
from bisect import bisect_right as bisect\n\nRES = [[] for _ in range(11)]\n\nfor c in range(1,1001):\n    c3 = c**3\n    nSol = sum( ((c3-a**2)**.5).is_integer() for a in range(1,int((c3//2)**.5+1)))\n    if 0 < nSol < 11: RES[nSol].append(c)\n    \n\ndef find_abc_sumsqcube(c_max, nSol):\n    return RES[nSol][:bisect(RES[nSol], c_max)]
import re\n\ndef compare(a, b):\n    return a if specificity(a) > specificity(b) else b\n  \ndef specificity(s):\n    return [len(re.findall(r, s)) for r in (r'#\w+', r'\.\w+', r'(^| )\w+')]
def check_concatenated_sum(n, r):\n    return abs(n) == sum(int(e*r) for e in str(abs(n)) if r) 
import re\n\ndef is_matched(read):\n    total = sum([int(num) for num in re.findall(r'\d+', read[0])])\n    \n    if read[0] == str(len(read[1])) + 'M':\n        return True\n    elif len(read[1]) != total:\n        return 'Invalid cigar'\n    else:\n        return False\n
def solve(n):\n    zoznam   =  [int(i) for i in range (2,n+1)]\n    res=[1]\n    while zoznam != []:\n        res.append(zoznam[0])\n        del zoznam[0::zoznam[0]]    \n    return sum(res)
def decipher(cipher):\n    out = ""\n    while cipher:\n        l = 2 if cipher[0] == "9" else 3\n        out += chr(int(cipher[:l]))\n        cipher = cipher[l:]\n    return out
SWAP = {'i': '1', 'I': '1', 'o': '0', 'O': '0', 's': '5', 'S': '5'}\n\n\ndef make_password(phrase):\n    return ''.join(SWAP.get(a[0], a[0]) for a in phrase.split())\n
def hofstadter_Q(n):\n    try:\n        return hofstadter_Q.seq[n]\n    except IndexError:\n        ans = hofstadter_Q(n - hofstadter_Q(n - 1)) + hofstadter_Q(n - hofstadter_Q(n - 2))\n        hofstadter_Q.seq.append(ans)\n        return ans\nhofstadter_Q.seq = [None, 1, 1]
def mystery_solved(n):\n    """\nRecreated mystery function from bytecode using the dis module.\n   How to print the bytecode: import dis\n                              print(dis.dis(mystery)) \n    Apparently,                \n    the function is a wrong implementation of the 5n+1 problem ->  \n    https://math.stackexchange.com/questions/14569/the-5n1-problem\n    http://www.sciencedirect.com/science/article/pii/S0304414905001602\n    """\n    c=0\n    while(n != 1 and n != 13 and n < 1000000): # Should have "n != 17" too.\n              c=c+1\n              # Without the line below the function hangs for some n > 0.\n              if(n==17): return -1\n              if (n&1): \n                     n=n+n+n+n+n+1 # n = 5n+1  \n                     continue\n              n=n>>1 # n = n/2\n    return c\n    \ndef wrap_mystery(n): return mystery_solved(n)
def calculate_years(principal, interest, tax, desired):\n    years = 0\n    \n    while principal < desired:\n        principal += (interest * principal) * (1 - tax)\n        years += 1\n        \n    return years\n
def is_balanced(s, caps):\n    stack = []\n    openers, closers = caps[::2], caps[1::2]\n    for char in s:\n        if char in openers:\n            if char in closers and stack and stack[-1] == char:\n                stack.pop()\n            else:\n                stack.append(char)\n        elif char in closers:\n            if not stack or openers[closers.index(char)] != stack[-1]:\n                return False\n            else:\n                stack.pop()\n    return not stack
def likes(names):\n    n = len(names)\n    return {\n        0: 'no one likes this',\n        1: '{} likes this', \n        2: '{} and {} like this', \n        3: '{}, {} and {} like this', \n        4: '{}, {} and {others} others like this'\n    }[min(4, n)].format(*names[:3], others=n-2)
def commas(num):\n    return "{:,.3f}".format(num).rstrip("0").rstrip(".")
def solve(s):\n    s1 = s[::-1]\n    s2 = ''\n    for i in s1:\n        if i.isalpha():\n            s2 += i\n        elif i.isdigit():\n            s2 = s2*int(i)\n    return s2[::-1]
def faro_cycles(n):\n    x, cnt = 2, 1\n    while x != 1 and n > 3:\n        cnt += 1\n        x = x*2 % (n-1)\n    return cnt
def fib_rabbits(n, b):\n    (i, a) = (1, 0)\n    for m in range(n):\n        (i, a) = (a * b, a + i)\n    return a\n
def time(distance,boat_speed,stream):\n    return round(distance/(boat_speed+int(stream.split()[-1])),2) if stream[0]=="D" else round(distance/(boat_speed-int(stream.split()[-1])), 2)
AVAILABLE_METHODS = {\n    'even' : lambda x: x / 2,\n    'odd': lambda x: 3 * x + 1\n}\n\ndef generator(x):\n    temp = x\n    temp_num = 0\n    while temp > 1:\n        if temp % 2 == 0:\n            temp = AVAILABLE_METHODS['even'](temp)\n        else:\n            temp = AVAILABLE_METHODS['odd'](temp)\n        temp_num += 1\n        yield temp_num\n\ndef longest_collatz(input_array):\n    answer_list = [sum([item for item in generator(dig)]) for dig in input_array]\n    print(max(answer_list), answer_list)\n    return input_array[(answer_list.index(max(answer_list)))]
import operator\n\ndef calc(expr):\n    OPERATORS = {'+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.truediv}\n    stack = [0]\n    for token in expr.split(" "):\n        if token in OPERATORS:\n            op2, op1 = stack.pop(), stack.pop()\n            stack.append(OPERATORS[token](op1,op2))\n        elif token:\n            stack.append(float(token))\n    return stack.pop()
def get_grade(s1, s2, s3):\n    m = (s1 + s2 + s3) / 3.0\n    if 90 <= m <= 100:\n        return 'A'\n    elif 80 <= m < 90:\n        return 'B'\n    elif 70 <= m < 80:\n        return 'C'\n    elif 60 <= m < 70:\n        return 'D'\n    return "F"\n
#fix this code!\ndef spam(number):\n    return 'hue' * number
from fractions import Decimal, gcd\nfrom operator import mul\nfrom functools import reduce\n\nlcm = lambda a, b=1: a * b // gcd(a, b)\n\ndef parameter(n):\n    digits = Decimal(n).as_tuple().digits\n    return lcm(sum(digits), reduce(mul, digits))
import datetime\nimport calendar\n\ndef day(date):\n    return calendar.day_name[datetime.datetime.strptime(date,"%Y%m%d").weekday()]
def inverse_slice(items, a, b):\n    return items[:a] + items[b:]
def even_chars(st):\n    if len(st) < 2 or len(st)> 100:\n        return 'invalid string'\n    else:\n        return [st[i] for i in range(1, len(st), 2)]\n
def bmi(weight, height):\n    bmi = weight / height ** 2\n    if bmi <= 18.5:\n        return "Underweight"\n    elif bmi <= 25:\n        return "Normal"\n    elif bmi <= 30:\n        return "Overweight"\n    else:\n        return "Obese"
from itertools import groupby\n\ndef dup(arry):\n    return ["".join(c for c, grouper in groupby(i)) for i in arry]
def trigrams(phrase):\n    phrase = phrase.replace(" ", "_")\n    return " ".join([phrase[i:i+3]for i in range(len(phrase)-2)])\n
def unusual_lex_order(a):\n    return sorted(a, key=lambda k: k[::-1])
from math import floor\ndef group_size(S, D):\n    return floor((2*D+S*(S-1))**.5+.5)
def calculate_age(year_of_birth, current_year):\n    diff = abs(current_year - year_of_birth)\n    plural = '' if diff == 1 else 's'\n    if year_of_birth < current_year:\n        return 'You are {} year{} old.'.format(diff, plural)\n    elif year_of_birth > current_year:\n        return 'You will be born in {} year{}.'.format(diff, plural)\n    return 'You were born this very year!'
def cockroach_speed(s):\n    return s // 0.036
def areYouPlayingBanjo(name):\n    return name + (' plays' if name[0].lower() == 'r' else ' does not play') + " banjo";
def mobile_keyboard(s):\n    lookup = {\n        c: i \n        for s in "1,2abc,3def,4ghi,5jkl,6mno,7pqrs,8tuv,9wxyz,*,0,#".split(",") \n        for i, c in enumerate(s, start=1)\n    }\n    return sum(lookup[c] for c in s)
def to_alternating_case(string):\n    return string.swapcase()
def beasts(heads, tails):\n    orthus = (5 * tails - heads) / 3\n    hydra = tails - orthus\n    return [orthus, hydra] if orthus >= 0 and hydra >= 0 else 'No solutions'
from math import sin, radians\n\ndef find_time_to_break(bearing_A, bearing_B):\n    a = radians(abs(bearing_A - bearing_B) / 2)\n    return 40 / (3 * sin(a)) if a else float("inf")
def pattern(n, x=1, y=1, *args):\n    if n < 1:\n        return ""\n    result = []\n    for i in range(1, n + 1):\n        line = " " * (i - 1) + str(i % 10) + " " * (n - i)\n        result.append((line + line[::-1][1:]) + (line[1:] + line[::-1][1:]) * (x - 1))\n    return "\n".join((result + result[::-1][1:]) + (result[1:] + result[::-1][1:]) * (y - 1))\n
def per(n):\n    r = []\n    while n>=10:\n        p=1\n        for i in str(n):\n            p=p*int(i)\n        r.append(p)\n        n = p\n    return r
from fractions import gcd\n\ndef DPC_sequence(s):\n    n=1\n    for i,c in enumerate(s,1):\n        if c=='D':\n            n=(n*i)//gcd(n,i)\n        elif c=='P':\n            if gcd(n,i)!=1: return -1\n        elif c=='C':\n            if gcd(n,i) in (1,i): return -1\n    return n\n
def custom_christmas_tree(chars, n):\n    from itertools import cycle\n    it = cycle(chars)\n    tree = [' '.join(next(it) for j in range(i)).center(2 * n).rstrip() for i in range(1, n + 1)]\n    tree.extend('|'.center(2 * n).rstrip() for _ in range(n // 3))\n    return '\n'.join(tree)
def productFib(prod):\n  a, b = 0, 1\n  while prod > a * b:\n    a, b = b, a + b\n  return [a, b, prod == a * b]
def whose_turn(positions):\n    return sum(ord(c) for c in positions.replace(";", "")) % 2 == 0
from math import log2\n\ndef consecutive_ducks(n):\n    return not log2(n).is_integer()
def polybius(text):\n    letmap = { "A" : "11","B" : "12","C" : "13","D" : "14","E" : "15",\n               "F" : "21","G" : "22","H" : "23","I" : "24","J" : "24", "K" : "25",\n               "L" : "31","M" : "32","N" : "33","O" : "34","P" : "35",\n               "Q" : "41","R" : "42","S" : "43","T" : "44","U" : "45",\n               "V" : "51","W" : "52","X" : "53","Y" : "54","Z" : "55", " " : " "}\n    enc=""\n    for i in range(0,len(text)):\n        enc = enc + letmap[text[i].upper()]\n\n    return enc
def digitize(n):\n    return [int(x) for x in str(n)[::-1]]
def solve(arr):\n    return [ sum(c == chr(97+i) for i,c in enumerate(w[:26].lower())) for w in arr ]
from re import compile\n\nREGEX1 = compile(r"0+|1+").findall\nREGEX2 = compile(r"(0+) (0+)").findall\nbinary = "{:07b}".format\n\ndef send(s):\n    temp = ''.join(binary(ord(c)) for c in s)\n    return ' '.join("0 " + '0'*len(x) if x[0] == '1' else "00 " + x for x in REGEX1(temp))\n\ndef receive(s):\n    temp = ''.join(y if x == '00' else '1'*len(y) for x,y in REGEX2(s))\n    return ''.join(chr(int(temp[i:i+7], 2)) for i in range(0, len(temp), 7))
def pattern(n):\n    return '\n'.join([str(i) * i for i in range(2, n + 1, 2)])\n
def switcher(arr):\n    d = {str(i): chr(123-i) for i in range(1,27)}\n    d.update({'27':'!'})\n    d.update({'28':'?'})\n    d.update({'29':' '})\n    d.update({'0':''})\n    return ''.join([d[str(i)] for i in arr])
def is_triangular(t):\n    x = int((t*2)**0.5)\n    return t == x*(x+1)/2
def compress(sentence):\n    ref = []\n    for i in sentence.lower().split():\n        if i not in ref:\n            ref.append(i)\n    return ''.join([str(ref.index(n)) for n in sentence.lower().split()])
def calculate(s):\n    return str(sum(int(n) for n in s.replace("minus", "plus-").split("plus")))\n    \n    # I heard here and there that using eval is a very bad practice\n    #return str(eval(s.replace("plus", "+").replace("minus", "-")))\n
def DNA_strand(dna):\n    pairs = [("A", "T"), ("C", "G")]\n    replacing_rules = pairs_to_dict(pairs)\n    return "".join(list([replacing_rules[a] for a in dna]))\n\n\ndef pairs_to_dict(pairs):\n    d = {}\n    for pair in pairs:  # Add two replacing rules for each pair\n        d[pair[0]] = pair[1]\n        d[pair[1]] = pair[0]\n    return d\n
def duplicate_encode(word):\n    return "".join(["(" if word.lower().count(c) == 1 else ")" for c in word.lower()])
def memoized(f):\n    cache = {}\n    def wrapped(k):\n        v = cache.get(k)\n        if v is None:\n            v = cache[k] = f(k)\n        return v\n    return wrapped\n\n@memoized\ndef fibonacci(n):\n    if n in [0, 1]:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)
def spot_diff(s1, s2):\n  return [i for i in range(len(s1)) if s1[i] != s2[i]]
def trim(beard):\n    return [[h.replace("J", "|") for h in b] for b in beard[:-1]] + [["..."]*len(beard[0])]
WORDS = (\n    (90, 'ninety'), (80, 'eighty'), (70, 'seventy'), (60, 'sixty'),\n    (50, 'fifty'), (40, 'forty'), (30, 'thirty'), (20, 'twenty'),\n    (19, 'nineteen'), (18, 'eighteen'), (17, 'seventeen'), (16, 'sixteen'),\n    (15, 'fifteen'), (14, 'fourteen'), (13, 'thirteen'), (12, 'twelve'),\n    (11, 'eleven'), (10, 'ten'), (9, 'nine'), (8, 'eight'), (7, 'seven'),\n    (6, 'six'), (5, 'five'), (4, 'four'), (3, 'three'), (2, 'two'), (1, 'one')\n)\n\n\ndef name_that_number(num):\n    result = []\n    for word_value, word_name in WORDS:\n        quo, num = divmod(num, word_value)\n        if quo:\n            result.append(word_name)\n    return ' '.join(result) or 'zero'
def duplicates(array):\n    seen = []\n    dups = []\n    for char in array:\n        if char not in seen:\n             seen.append(char)\n        elif char not in dups:\n             dups.append(char)\n    \n    return dups\n
def encode(s):\n    return ' '.join( w[-2::-1] + w[-1] for w in s.split() )
def even_magic(n):\n    return [ [ n*n-(y*n+x) if x%4==y%4 or (x%4+y%4)%4==3 else y*n+x+1 for x in range(n)] for y in range(n) ]
def pyramid(n):\n    return [[1]*x for x in range(1, n+1)]
def switch_it_up(n):\n    return ['Zero','One','Two','Three','Four','Five','Six','Seven','Eight','Nine'][n]
from math import log\n\ndef power_law(p1, p2, x3):\n    (x1, y1), (x2, y2) = p1, p2\n    x1 += 1e-9; y1 += 1e-9\n    return round(y1 * (y2 / y1) ** log(x3 / x1, x2 / x1))
def array_madness(a,b):\n    return sum(x ** 2 for x in a) > sum(x **3 for x in b)
def db_sort(arr): \n    return sorted(arr, key=lambda x: (isinstance(x,str),x))
def largest_pair_sum(numbers): \n    return sum(sorted(numbers)[-2:])
def array_equalization(a, k):\n    totals, ends = {}, {}\n    for i, n in enumerate(a):\n        if n not in ends: totals[n], ends[n] = 0, -1\n        if i < ends[n]: continue\n        count = (i - ends[n] - 1 + k - 1) // k\n        totals[n] += count\n        ends[n] = max(i, ends[n] + count * k)\n    return min(t + (len(a) - ends[n] - 1 + k - 1) // k\n               for n, t in totals.items() if ends[n] < len(a))
def sect_sort(lst, start, length=0):\n    end = start + length if length else len(lst)\n    return lst[:start] + sorted(lst[start:end]) + lst[end:]
def symmetric_point(p, q):\n    return [2*q[0] - p[0], 2*q[1] - p[1]]
def solve(a, b):\n    primes = "2357111317192329313741434753596167717379838997101103107109113127131137139149151157163167173179181191193197199211223227229233239241251257263269271277281283293307311313317331337347349353359367373379383389397401409419421431433439443449457461463467479487491499503509521523541547557563569571577587593599601607613617619631641643647653659661673677683691701709719727733739743751757761769773787797809811821823827829839853857859863877881883887907911919929937941947953967971977983991997100910131019102110311033103910491051106110631069108710911093109711031109111711231129115111531163117111811187119312011213121712231229123112371249125912771279128312891291129713011303130713191321132713611367137313811399140914231427142914331439144714511453145914711481148314871489149314991511152315311543154915531559156715711579158315971601160716091613161916211627163716571663166716691693169716991709172117231733174117471753175917771783178717891801181118231831184718611867187118731877187918891901190719131931193319491951197319791987199319971999200320112017202720292039205320632069208120832087208920992111211321292131213721412143215321612179220322072213222122372239224322512267226922732281228722932297230923112333233923412347235123572371237723812383238923932399241124172423243724412447245924672473247725032521253125392543254925512557257925912593260926172621263326472657265926632671267726832687268926932699270727112713271927292731274127492753276727772789279127972801280328192833283728432851285728612879288728972903290929172927293929532957296329692971299930013011301930233037304130493061306730793083308931093119312131373163316731693181318731913203320932173221322932513253325732593271329933013307331333193323332933313343334733593361337133733389339134073413343334493457346134633467346934913499351135173527352935333539354135473557355935713581358335933607361336173623363136373643365936713673367736913697370137093719372737333739376137673769377937933797380338213823383338473851385338633877388138893907391139173919392339293931394339473967398940014003400740134019402140274049405140574073407940914093409941114127412941334139415341574159417742014211421742194229423142414243425342594261427142734283428942974327433743394349435743634373439143974409442144234441444744514457446344814483449345074513451745194523454745494561456745834591459746034621463746394643464946514657466346734679469147034721472347294733475147594783478747894793479948014813481748314861487148774889490349094919493149334937494349514957496749694973498749934999500350095011502150235039505150595077508150875099510151075113511951475153516751715179518951975209522752315233523752615273527952815297530353095323533353475351538153875393539954075413541754195431543754415443544954715477547954835501550355075519552155275531555755635569557355815591562356395641564756515653565756595669568356895693570157115717573757415743574957795783579158015807581358215827583958435849585158575861586758695879588158975903592359275939595359815987600760116029603760436047605360676073607960896091610161136121613161336143615161636173619761996203621162176221622962476257626362696271627762876299630163116317632363296337634363536359636163676373637963896397642164276449645164696473648164916521652965476551655365636569657165776581659966076619663766536659666166736679668966916701670367096719673367376761676367796781679167936803682368276829683368416857686368696871688368996907691169176947694969596961696769716977698369916997700170137019702770397043705770697079710371097121712771297151715971777187719372077211721372197229723772437247725372837297730773097321733173337349735173697393741174177433745174577459747774817487748974997507751775237529753775417547754975597561757375777583758975917603760776217639764376497669767376817687769176997703771777237727774177537757775977897793781778237829784178537867787378777879788379017907791979277933793779497951796379938009801180178039805380598069808180878089809381018111811781238147816181678171817981918209821982218231823382378243826382698273828782918293829783118317832983538363836983778387838984198423842984318443844784618467850185138521852785378539854385638573858185978599860986238627862986418647866386698677868186898693869987078713871987318737874187478753876187798783880388078819882188318837883988498861886388678887889389238929893389418951896389698971899990019007901190139029904190439049905990679091910391099127913391379151915791619173918191879199920392099221922792399241925792779281928392939311931993239337934193439349937193779391939794039413941994219431943394379439946194639467947394799491949795119521953395399547955195879601961396199623962996319643964996619677967996899697971997219733973997439749976797699781978797919803981198179829983398399851985798599871988398879901990799239929993199419949996799731000710009100371003910061100671006910079100911009310099101031011110133101391014110151101591016310169101771018110193102111022310243102471025310259102671027110273102891030110303103131032110331103331033710343103571036910391103991042710429104331045310457104591046310477104871049910501105131052910531105591056710589105971060110607106131062710631106391065110657106631066710687106911070910711107231072910733107391075310771107811078910799108311083710847108531085910861108671088310889108911090310909109371093910949109571097310979109871099311003110271104711057110591106911071110831108711093111131111711119111311114911159111611117111173111771119711213112391124311251112571126111273112791128711299113111131711321113291135111353113691138311393113991141111423114371144311447114671147111483114891149111497115031151911527115491155111579115871159311597116171162111633116571167711681116891169911701117171171911731117431177711779117831178911801118071181311821118271183111833118391186311867118871189711903119091192311927119331193911941119531195911969119711198111987120071201112037120411204312049120711207312097121011210712109121131211912143121491215712161121631219712203122111222712239122411225112253122631226912277122811228912301123231232912343123471237312377123791239112401124091241312421124331243712451124571247312479124871249112497125031251112517125271253912541125471255312569125771258312589126011261112613126191263712641126471265312659126711268912697127031271312721127391274312757127631278112791127991280912821128231282912841128531288912893128991290712911129171291912923129411295312959129671297312979129831300113003130071300913033130371304313049130631309313099131031310913121131271314713151131591316313171131771318313187132171321913229132411324913259132671329113297133091331313327133311333713339133671338113397133991341113417134211344113451134571346313469134771348713499135131352313537135531356713577135911359713613136191362713633136491366913679136811368713691136931369713709137111372113723137291375113757137591376313781137891379913807138291383113841138591387313877138791388313901139031390713913139211393113933139631396713997139991400914011140291403314051140571407114081140831408714107141431414914153141591417314177141971420714221142431424914251142811429314303143211432314327143411434714369143871438914401144071441114419144231443114437144471444914461144791448914503145191453314537145431454914551145571456114563145911459314621146271462914633146391465314657146691468314699147131471714723147311473714741147471475314759147671477114779147831479714813148211482714831148431485114867148691487914887148911489714923149291493914947149511495714969149831501315017150311505315061150731507715083150911510115107151211513115137151391514915161151731518715193151991521715227152331524115259152631526915271152771528715289152991530715313153191532915331153491535915361153731537715383153911540115413154271543915443154511546115467154731549315497155111552715541155511555915569155811558315601156071561915629156411564315647156491566115667156711567915683157271573115733157371573915749157611576715773157871579115797158031580915817158231585915877158811588715889159011590715913159191592315937159591597115973159911600116007160331605716061160631606716069160731608716091160971610316111161271613916141161831618716189161931621716223162291623116249162531626716273163011631916333163391634916361163631636916381164111641716421164271643316447164511645316477164811648716493165191652916547165531656116567165731660316607166191663116633166491665116657166611667316691166931669916703167291674116747167591676316787168111682316829168311684316871168791688316889169011690316921169271693116937169431696316979169811698716993170111702117027170291703317041170471705317077170931709917107171171712317137171591716717183171891719117203172071720917231172391725717291172931729917317173211732717333173411735117359173771738317387173891739317401174171741917431174431744917467174711747717483174891749117497175091751917539175511756917573175791758117597175991760917623176271765717659176691768117683177071771317729177371774717749177611778317789177911780717827178371783917851178631788117891179031790917911179211792317929179391795717959179711797717981179871798918013180411804318047180491805918061180771808918097181191812118127181311813318143181491816918181181911819918211182171822318229182331825118253182571826918287182891830118307183111831318329183411835318367183711837918397184011841318427184331843918443184511845718461184811849318503185171852118523185391854118553185831858718593186171863718661186711867918691187011871318719187311874318749187571877318787187931879718803188391885918869188991891118913189171891918947189591897318979190011900919013190311903719051190691907319079190811908719121191391914119157191631918119183192071921119213192191923119237192491925919267192731928919301193091931919333193731937919381193871939119403194171942119423194271942919433194411944719457194631946919471194771948319489195011950719531195411954319553195591957119577195831959719603196091966119681196871969719699197091971719727197391975119753197591976319777197931980119813198191984119843198531986119867198891989119913199191992719937199491996119963199731997919991199931999720011200212002320029200472005120063200712008920101201072011320117201232012920143201472014920161201732017720183202012021920231202332024920261202692028720297203232032720333203412034720353203572035920369203892039320399204072041120431204412044320477204792048320507205092052120533205432054920551205632059320599206112062720639206412066320681206932070720717207192073120743207472074920753207592077120773207892080720809208492085720873208792088720897208992090320921209292093920947209592096320981209832100121011210132101721019210232103121059210612106721089211012110721121211392114321149211572116321169211792118721191211932121121221212272124721269212772128321313213172131921323213412134721377213792138321391213972140121407214192143321467214812148721491214932149921503215172152121523215292155721559215632156921577215872158921599216012161121613216172164721649216612167321683217012171321727217372173921751217572176721773217872179921803218172182121839218412185121859218632187121881218932191121929219372194321961219772199121997220032201322027220312203722039220512206322067220732207922091220932210922111221232212922133221472215322157221592217122189221932222922247222592227122273222772227922283222912230322307223432234922367223692238122391223972240922433224412244722453224692248122483225012251122531225412254322549225672257122573226132261922621226372263922643226512266922679226912269722699227092271722721227272273922741227512276922777227832278722807228112281722853228592286122871228772290122907229212293722943229612296322973229932300323011230172302123027230292303923041230532305723059230632307123081230872309923117231312314323159231672317323189231972320123203232092322723251232692327923291232932329723311233212332723333233392335723369233712339923417234312344723459234732349723509235312353723539235492355723561235632356723581235932359923603236092362323627236292363323663236692367123677236872368923719237412374323747237532376123767237732378923801238132381923827238312383323857238692387323879238872389323899239092391123917239292395723971239772398123993240012400724019240232402924043240492406124071240772408324091240972410324107241092411324121241332413724151241692417924181241972420324223242292423924247242512428124317243292433724359243712437324379243912440724413244192442124439244432446924473244812449924509245172452724533245472455124571245932461124623246312465924671246772468324691246972470924733247492476324767247812479324799248092482124841248472485124859248772488924907249172491924923249432495324967249712497724979249892501325031250332503725057250732508725097251112511725121251272514725153251632516925171251832518925219252292523725243252472525325261253012530325307253092532125339253432534925357253672537325391254092541125423254392544725453254572546325469254712552325537255412556125577255792558325589256012560325609256212563325639256432565725667256732567925693257032571725733257412574725759257632577125793257992580125819258412584725849258672587325889259032591325919259312593325939259432595125969259812599725999260032601726021260292604126053260832609926107261112611326119261412615326161261712617726183261892620326209262272623726249262512626126263262672629326297263092631726321263392634726357263712638726393263992640726417264232643126437264492645926479264892649726501265132653926557265612657326591265972662726633266412664726669266812668326687266932669926701267112671326717267232672926731267372675926777267832680126813268212683326839268492686126863268792688126891268932690326921269272694726951269532695926981269872699327011270172703127043270592706127067270732707727091271032710727109271272714327179271912719727211272392724127253272592727127277272812728327299273292733727361273672739727407274092742727431274372744927457274792748127487275092752727529275392754127551275812758327611276172763127647276532767327689276912769727701277332773727739277432774927751277632776727773277792779127793277992780327809278172782327827278472785127883278932790127917279192794127943279472795327961279672798327997280012801928027280312805128057280692808128087280972809928109281112812328151281632818128183282012821128219282292827728279282832828928297283072830928319283492835128387283932840328409284112842928433284392844728463284772849328499285132851728537285412854728549285592857128573285792859128597286032860728619286212862728631286432864928657286612866328669286872869728703287112872328729287512875328759287712878928793288072881328817288372884328859288672887128879289012890928921289272893328949289612897929009290172902129023290272903329059290632907729101291232912929131291372914729153291672917329179291912920129207292092922129231292432925129269292872929729303293112932729333293392934729363293832938729389293992940129411294232942929437294432945329473294832950129527295312953729567295692957329581295872959929611296292963329641296632966929671296832971729723297412975329759297612978929803298192983329837298512986329867298732987929881299172992129927299472995929983299893001130013300293004730059300713008930091300973010330109301133011930133301373013930161301693018130187301973020330211302233024130253302593026930271302933030730313303193032330341303473036730389303913040330427304313044930467304693049130493304973050930517305293053930553305573055930577305933063130637306433064930661306713067730689306973070330707307133072730757307633077330781308033080930817308293083930841308513085330859308693087130881308933091130931309373094130949309713097730983310133101931033310393105131063310693107931081310913112131123311393114731151311533115931177311813118331189311933121931223312313123731247312493125331259312673127131277313073131931321313273133331337313573137931387313913139331397314693147731481314893151131513315173153131541315433154731567315733158331601316073162731643316493165731663316673168731699317213172331727317293174131751317693177131793317993181731847318493185931873318833189131907319573196331973319813199132003320093202732029320513205732059320633206932077320833208932099321173211932141321433215932173321833218932191322033221332233322373225132257322613229732299323033230932321323233232732341323533235932363323693237132377323813240132411324133242332429324413244332467324793249132497325033250732531325333253732561325633256932573325793258732603326093261132621326333264732653326873269332707327133271732719327493277132779327833278932797328013280332831328333283932843328693288732909329113291732933329393294132957329693297132983329873299332999330133302333029330373304933053330713307333083330913310733113331193314933151331613317933181331913319933203332113322333247332873328933301333113331733329333313334333347333493335333359333773339133403334093341333427334573346133469334793348733493335033352133529335333354733563335693357733581335873358933599336013361333617336193362333629336373364133647336793370333713337213373933749337513375733767337693377333791337973380933811338273382933851338573386333871338893389333911339233393133937339413396133967339973401934031340333403934057340613412334127341293414134147341573415934171341833421134213342173423134253342593426134267342733428334297343013430334313343193432734337343513436134367343693438134403344213442934439344573446934471344833448734499345013451134513345193453734543345493458334589345913460334607346133463134649346513466734673346793468734693347033472134729347393474734757347593476334781348073481934841348433484734849348713487734883348973491334919349393494934961349633498135023350273505135053350593506935081350833508935099351073511135117351293514135149351533515935171352013522135227352513525735267352793528135291353113531735323353273533935353353633538135393354013540735419354233543735447354493546135491355073550935521355273553135533355373554335569355733559135593355973560335617356713567735729357313574735753357593577135797358013580335809358313583735839358513586335869358793589735899359113592335933359513596335969359773598335993359993600736011360133601736037360613606736073360833609736107361093613136137361513616136187361913620936217362293624136251362633626936277362933629936307363133631936341363433635336373363833638936433364513645736467364693647336479364933649736523365273652936541365513655936563365713658336587365993660736629366373664336653366713667736683366913669736709367133672136739367493676136767367793678136787367913679336809368213683336847368573687136877368873689936901369133691936923369293693136943369473697336979369973700337013370193702137039370493705737061370873709737117371233713937159371713718137189371993720137217372233724337253372733727737307373093731337321373373733937357373613736337369373793739737409374233744137447374633748337489374933750137507375113751737529375373754737549375613756737571375733757937589375913760737619376333764337649376573766337691376933769937717377473778137783377993781137813378313784737853378613787137879378893789737907379513795737963379673798737991379933799738011380393804738053380693808338113381193814938153381673817738183381893819738201382193823138237382393826138273382813828738299383033831738321383273832938333383513837138377383933843138447384493845338459384613850138543385573856138567385693859338603386093861138629386393865138653386693867138677386933869938707387113871338723387293873738747387493876738783387913880338821388333883938851388613886738873388913890338917389213892338933389533895938971389773899339019390233904139043390473907939089390973910339107391133911939133391393915739161391633918139191391993920939217392273922939233392393924139251392933930139313393173932339341393433935939367393713937339383393973940939419394393944339451394613949939503395093951139521395413955139563395693958139607396193962339631396593966739671396793970339709397193972739733397493976139769397793979139799398213982739829398393984139847398573986339869398773988339887399013992939937399533997139979399833998940009400134003140037400394006340087400934009940111401234012740129401514015340163401694017740189401934021340231402374024140253402774028340289403434035140357403614038740423404274042940433404594047140483404874049340499405074051940529405314054340559405774058340591405974060940627406374063940693406974069940709407394075140759407634077140787408014081340819408234082940841408474084940853408674087940883408974090340927409334093940949409614097340993410114101741023410394104741051410574107741081411134111741131411414114341149411614117741179411834118941201412034121341221412274123141233412434125741263412694128141299413334134141351413574138141387413894139941411414134144341453414674147941491415074151341519415214153941543415494157941593415974160341609416114161741621416274164141647416514165941669416814168741719417294173741759417614177141777418014180941813418434184941851418634187941887418934189741903419114192741941419474195341957419594196941981419834199942013420174201942023420434206142071420734208342089421014213142139421574216942179421814218742193421974220942221422234222742239422574228142283422934229942307423234233142337423494235942373423794239142397424034240742409424334243742443424514245742461424634246742473424874249142499425094253342557425694257142577425894261142641426434264942667426774268342689426974270142703427094271942727427374274342751427674277342787427934279742821428294283942841428534285942863428994290142923429294293742943429534296142967429794298943003430134301943037430494305143063430674309343103431174313343151431594317743189432014320743223432374326143271432834329143313433194332143331433914339743399434034341143427434414345143457434814348743499435174354143543435734357743579435914359743607436094361343627436334364943651436614366943691437114371743721437534375943777437814378343787437894379343801438534386743889438914391343933439434395143961439634396943973439874399143997440174402144027440294404144053440594407144087440894410144111441194412344129441314415944171441794418944201442034420744221442494425744263442674426944273442794428144293443514435744371443814438344389444174444944453444834449144497445014450744519445314453344537445434454944563445794458744617446214462344633446414464744651446574468344687446994470144711447294474144753447714477344777447894479744809448194483944843448514486744879448874489344909449174492744939449534495944963449714498344987450074501345053450614507745083451194512145127451314513745139451614517945181451914519745233452474525945263452814528945293453074531745319453294533745341453434536145377453894540345413454274543345439454814549145497455034552345533455414555345557455694558745589455994561345631456414565945667456734567745691456974570745737457514575745763457674577945817458214582345827458334584145853458634586945887458934594345949459534595945971459794598946021460274604946051460614607346091460934609946103461334614146147461534617146181461834618746199462194622946237462614627146273462794630146307463094632746337463494635146381463994641146439464414644746451464574647146477464894649946507465114652346549465594656746573465894659146601466194663346639466434664946663466794668146687466914670346723467274674746751467574676946771468074681146817468194682946831468534686146867468774688946901469194693346957469934699747017470414705147057470594708747093471114711947123471294713747143471474714947161471894720747221472374725147269472794728747293472974730347309473174733947351473534736347381473874738947407474174741947431474414745947491474974750147507475134752147527475334754347563475694758147591475994760947623476294763947653476574765947681476994770147711477134771747737477414774347777477794779147797478074780947819478374784347857478694788147903479114791747933479394794747951479634796947977479814801748023480294804948073480794809148109481194812148131481574816348179481874819348197482214823948247482594827148281482994831148313483374834148353483714838348397484074840948413484374844948463484734847948481484874849148497485234852748533485394854148563485714858948593486114861948623486474864948661486734867748679487314873348751487574876148767487794878148787487994880948817488214882348847488574885948869488714888348889489074894748953489734898948991490034900949019490314903349037490434905749069490814910349109491174912149123491394915749169491714917749193491994920149207492114922349253492614927749279492974930749331493334933949363493674936949391493934940949411494174942949433494514945949463494774948149499495234952949531495374954749549495594959749603496134962749633496394966349667496694968149697497114972749739497414974749757497834978749789498014980749811498234983149843498534987149877498914991949921499274993749939499434995749991499934999950021500235003350047500515005350069500775008750093501015011150119501235012950131501475015350159501775020750221502275023150261502635027350287502915031150321503295033350341503595036350377503835038750411504175042350441504595046150497505035051350527505395054350549505515058150587505915059350599506275064750651506715068350707507235074150753507675077350777507895082150833508395084950857508675087350891508935090950923509295095150957509695097150989509935100151031510435104751059510615107151109511315113351137511515115751169511935119751199512035121751229512395124151257512635128351287513075132951341513435134751349513615138351407514135141951421514275143151437514395144951461514735147951481514875150351511515175152151539515515156351577515815159351599516075161351631516375164751659516735167951683516915171351719517215174951767517695178751797518035181751827518295183951853518595186951871518935189951907519135192951941519495197151973519775199152009520215202752051520575206752069520815210352121521275214752153521635217752181521835218952201522235223752249522535225952267522895229152301523135232152361523635236952379523875239152433524535245752489525015251152517525295254152543525535256152567525715257952583526095262752631526395266752673526915269752709527115272152727527335274752757527695278352807528135281752837528595286152879528835288952901529035291952937529515295752963529675297352981529995300353017530475305153069530775308753089530935310153113531175312953147531495316153171531735318953197532015323153233532395326753269532795328153299533095332353327533535335953377533815340153407534115341953437534415345353479535035350753527535495355153569535915359353597536095361153617536235362953633536395365353657536815369353699537175371953731537595377353777537835379153813538195383153849538575386153881538875389153897538995391753923539275393953951539595398753993540015401154013540375404954059540835409154101541215413354139541515416354167541815419354217542515426954277542875429354311543195432354331543475436154367543715437754401544035440954413544195442154437544435444954469544935449754499545035451754521545395454154547545595456354577545815458354601546175462354629546315464754667546735467954709547135472154727547515476754773547795478754799548295483354851548695487754881549075491754919549415494954959549735497954983550015500955021550495505155057550615507355079551035510955117551275514755163551715520155207552135521755219552295524355249552595529155313553315533355337553395534355351553735538155399554115543955441554575546955487555015551155529555415554755579555895560355609556195562155631556335563955661556635566755673556815569155697557115571755721557335576355787557935579955807558135581755819558235582955837558435584955871558895589755901559035592155927559315593355949559675598755997560035600956039560415605356081560875609356099561015611356123561315614956167561715617956197562075620956237562395624956263562675626956299563115633356359563695637756383563935640156417564315643756443564535646756473564775647956489565015650356509565195652756531565335654356569565915659756599566115662956633566595666356671566815668756701567115671356731567375674756767567735677956783568075680956813568215682756843568575687356891568935689756909569115692156923569295694156951569575696356983569895699356999570375704157047570595707357077570895709757107571195713157139571435714957163571735717957191571935720357221572235724157251572595726957271572835728757301573295733157347573495736757373573835738957397574135742757457574675748757493575035752757529575575755957571575875759357601576375764157649576535766757679576895769757709577135771957727577315773757751577735778157787577915779357803578095782957839578475785357859578815789957901579175792357943579475797357977579915801358027580315804358049580575806158067580735809958109581115812958147581515815358169581715818958193581995820758211582175822958231582375824358271583095831358321583375836358367583695837958391583935840358411584175842758439584415845158453584775848158511585375854358549585675857358579586015860358613586315865758661586795868758693586995871158727587335874158757587635877158787587895883158889588975890158907589095891358921589375894358963589675897958991589975900959011590215902359029590515905359063590695907759083590935910759113591195912359141591495915959167591835919759207592095921959221592335923959243592635927359281593335934159351593575935959369593775938759393593995940759417594195944159443594475945359467594715947359497595095951359539595575956159567595815961159617596215962759629596515965959663596695967159693596995970759723597295974359747597535977159779597915979759809598335986359879598875992159929599515995759971599815999960013600176002960037600416007760083600896009160101601036010760127601336013960149601616016760169602096021760223602516025760259602716028960293603176033160337603436035360373603836039760413604276044360449604576049360497605096052160527605396058960601606076061160617606236063160637606476064960659606616067960689607036071960727607336073760757607616076360773607796079360811608216085960869608876088960899609016091360917609196092360937609436095360961610016100761027610316104361051610576109161099611216112961141611516115361169612116122361231612536126161283612916129761331613336133961343613576136361379613816140361409614176144161463614696147161483614876149361507615116151961543615476155361559615616158361603616096161361627616316163761643616516165761667616736168161687617036171761723617296175161757617816181361819618376184361861618716187961909619276193361949619616196761979619816198761991620036201162017620396204762053620576207162081620996211962129621316213762141621436217162189621916220162207622136221962233622736229762299623036231162323623276234762351623836240162417624236245962467624736247762483624976250162507625336253962549625636258162591625976260362617626276263362639626536265962683626876270162723627316274362753627616277362791628016281962827628516286162869628736289762903629216292762929629396296962971629816298362987629896302963031630596306763073630796309763103631136312763131631496317963197631996321163241632476327763281632996331163313633176333163337633476335363361633676337763389633916339763409634196342163439634436346363467634736348763493634996352163527635336354163559635776358763589635996360163607636116361763629636476364963659636676367163689636916369763703637096371963727637376374363761637736378163793637996380363809638236383963841638536385763863639016390763913639296394963977639976400764013640196403364037640636406764081640916410964123641516415364157641716418764189642176422364231642376427164279642836430164303643196432764333643736438164399644036443364439644516445364483644896449964513645536456764577645796459164601646096461364621646276463364661646636466764679646936470964717647476476364781647836479364811648176484964853648716487764879648916490164919649216492764937649516496964997650036501165027650296503365053650636507165089650996510165111651196512365129651416514765167651716517365179651836520365213652396525765267652696528765293653096532365327653536535765371653816539365407654136541965423654376544765449654796549765519655216553765539655436555165557655636557965581655876559965609656176562965633656476565165657656776568765699657016570765713657176571965729657316576165777657896580965827658316583765839658436585165867658816589965921659276592965951659576596365981659836599366029660376604166047660676607166083660896610366107661096613766161661696617366179661916622166239662716629366301663376634366347663596636166373663776638366403664136643166449664576646366467664916649966509665236652966533665416655366569665716658766593666016661766629666436665366683666976670166713667216673366739667496675166763667916679766809668216684166851668536686366877668836688966919669236693166943669476694966959669736697767003670216703367043670496705767061670736707967103671216712967139671416715367157671696718167187671896721167213672176721967231672476726167271672736728967307673396734367349673696739167399674096741167421674276742967433674476745367477674816748967493674996751167523675316753767547675596756767577675796758967601676076761967631676516767967699677096772367733677416775167757677596776367777677836778967801678076781967829678436785367867678836789167901679276793167933679396794367957679616796767979679876799368023680416805368059680716808768099681116811368141681476816168171682076820968213682196822768239682616827968281683116832968351683716838968399684376844368447684496847368477684836848968491685016850768521685316853968543685676858168597686116863368639686596866968683686876869968711687136872968737687436874968767687716877768791688136881968821688636887968881688916889768899689036890968917689276894768963689936900169011690196902969031690616906769073691096911969127691436914969151691636919169193691976920369221692336923969247692576925969263693136931769337693416937169379693836938969401694036942769431694396945769463694676947369481694916949369497694996953969557695936962369653696616967769691696976970969737697396976169763697676977969809698216982769829698336984769857698596987769899699116992969931699416995969991699977000170003700097001970039700517006170067700797009970111701177012170123701397014170157701637017770181701837019970201702077022370229702377024170249702717028970297703097031370321703277035170373703797038170393704237042970439704517045770459704817048770489705017050770529705377054970571705737058370589706077061970621706277063970657706637066770687707097071770729707537076970783707937082370841708437084970853708677087770879708917090170913709197092170937709497095170957709697097970981709917099770999710117102371039710597106971081710897111971129711437114771153711617116771171711917120971233712377124971257712617126371287712937131771327713297133371339713417134771353713597136371387713897139971411714137141971429714377144371453714717147371479714837150371527715377154971551715637156971593715977163371647716637167171693716997170771711717137171971741717617177771789718077180971821718377184371849718617186771879718817188771899719097191771933719417194771963719717198371987719937199972019720317204372047720537207372077720897209172101721037210972139721617216772169721737221172221722237222772229722517225372269722717227772287723077231372337723417235372367723797238372421724317246172467724697248172493724977250372533725477255172559725777261372617726237264372647726497266172671726737267972689727017270772719727277273372739727637276772797728177282372859728697287172883728897289372901729077291172923729317293772949729537295972973729777299773009730137301973037730397304373061730637307973091731217312773133731417318173189732377324373259732777329173303733097332773331733517336173363733697337973387734177342173433734537345973471734777348373517735237352973547735537356173571735837358973597736077360973613736377364373651736737367973681736937369973709737217372773751737577377173783738197382373847738497385973867738777388373897739077393973943739517396173973739997401774021740277404774051740717407774093740997410174131741437414974159741617416774177741897419774201742037420974219742317425774279742877429374297743117431774323743537435774363743777438174383744117441374419744417444974453744717448974507745097452174527745317455174561745677457374587745977460974611746237465374687746997470774713747177471974729747317474774759747617477174779747977482174827748317484374857748617486974873748877489174897749037492374929749337494174959750117501375017750297503775041750797508375109751337514975161751677516975181751937520975211752177522375227752397525375269752777528975307753237532975337753477535375367753777538975391754017540375407754317543775479755037551175521755277553375539755417555375557755717557775583756117561775619756297564175653756597567975683756897570375707757097572175731757437576775773757817578775793757977582175833758537586975883759137593175937759417596775979759837598975991759977600176003760317603976079760817609176099761037612376129761477615776159761637620776213762317624376249762537625976261762837628976303763337634376367763697637976387764037642176423764417646376471764817648776493765077651176519765377654176543765617657976597766037660776631766497665176667766737667976697767177673376753767577677176777767817680176819768297683176837768477687176873768837690776913769197694376949769617696376991770037701777023770297704177047770697708177093771017713777141771537716777171771917720177213772377723977243772497726177263772677726977279772917731777323773397734777351773597736977377773837741777419774317744777471774777747977489774917750977513775217752777543775497755177557775637756977573775877759177611776177762177641776477765977681776877768977699777117771377719777237773177743777477776177773777837779777801778137783977849778637786777893778997792977933779517796977977779837799978007780177803178041780497805978079781017812178137781397815778163781677817378179781917819378203782297823378241782597827778283783017830778311783177834178347783677840178427784377843978467784797848778497785097851178517785397854178553785697857178577785837859378607786237864378649786537869178697787077871378721787377877978781787877879178797788037880978823788397885378857788777888778889788937890178919789297894178977789797898979031790397904379063790877910379111791337913979147791517915379159791817918779193792017922979231792417925979273792797928379301793097931979333793377934979357793677937979393793977939979411794237942779433794517948179493795317953779549795597956179579795897960179609796137962179627796317963379657796697968779691796937969779699797577976979777798017981179813798177982379829798417984379847798617986779873798897990179903799077993979943799677997379979799877999779999800218003980051800718007780107801118014180147801498015380167801738017780191802078020980221802318023380239802518026380273802798028780309803178032980341803478036380369803878040780429804478044980471804738048980491805138052780537805578056780599806038061180621806278062980651806578066980671806778068180683806878070180713807378074780749807618077780779807838078980803808098081980831808338084980863808978090980911809178092380929809338095380963809898100181013810178101981023810318104181043810478104981071810778108381097811018111981131811578116381173811818119781199812038122381233812398128181283812938129981307813318134381349813538135981371813738140181409814218143981457814638150981517815278153381547815518155381559815638156981611816198162981637816478164981667816718167781689817018170381707817278173781749817618176981773817998181781839818478185381869818838189981901819198192981931819378194381953819678197181973820038200782009820138202182031820378203982051820678207382129821398214182153821638217182183821898219382207822178221982223822318223782241822618226782279823018230782339823498235182361823738238782393824218245782463824698247182483824878249382499825078252982531825498255982561825678257182591826018260982613826198263382651826578269982721827238272782729827578275982763827818278782793827998281182813828378284782883828898289182903829138293982963829818299783003830098302383047830598306383071830778308983093831018311783137831778320383207832198322183227832318323383243832578326783269832738329983311833398334183357833838338983399834018340783417834238343183437834438344983459834718347783497835378355783561835638357983591835978360983617836218363983641836538366383689837018371783719837378376183773837778379183813838338384383857838698387383891839038391183921839338393983969839838398784011840178404784053840598406184067840898412184127841318413784143841638417984181841918419984211842218422384229842398424784263842998430784313843178431984347843498437784389843918440184407844218443184437844438444984457844638446784481844998450384509845218452384533845518455984589846298463184649846538465984673846918469784701847138471984731847378475184761847878479384809848118482784857848598486984871849138491984947849618496784977849798499185009850218502785037850498506185081850878509185093851038510985121851338514785159851938519985201852138522385229852378524385247852598529785303853138533185333853618536385369853818541185427854298543985447854518545385469854878551385517855238553185549855718557785597856018560785619856218562785639856438566185667856698569185703857118571785733857518578185793858178581985829858318583785843858478585385889859038590985931859338599185999860118601786027860298606986077860838611186113861178613186137861438616186171861798618386197862018620986239862438624986257862638626986287862918629386297863118632386341863518635386357863698637186381863898639986413864238644186453864618646786477864918650186509865318653386539865618657386579865878659986627866298667786689866938671186719867298674386753867678677186783868138683786843868518685786861868698692386927869298693986951869598696986981869938701187013870378704187049870718708387103871078711987121871338714987151871798718187187872118722187223872518725387257872778728187293872998731387317873238733787359873838740387407874218742787433874438747387481874918750987511875178752387539875418754787553875578755987583875878758987613876238762987631876418764387649876718767987683876918769787701877198772187739877438775187767877938779787803878118783387853878698787787881878878791187917879318794387959879618797387977879918800188003880078801988037880698807988093881178812988169881778821188223882378824188259882618828988301883218832788337883398837988397884118842388427884638846988471884938849988513885238854788589885918860788609886438865188657886618866388667886818872188729887418874788771887898879388799888018880788811888138881788819888438885388861888678887388883888978890388919889378895188969889938899789003890098901789021890418905189057890698907189083890878910189107891138911989123891378915389189892038920989213892278923189237892618926989273892938930389317893298936389371893818938789393893998941389417894318944389449894598947789491895018951389519895218952789533895618956389567895918959789599896038961189627896338965389657896598966989671896818968989753897598976789779897838979789809898198982189833898398984989867898918989789899899098991789923899398995989963899778998389989900019000790011900179001990023900319005390059900679007190073900899010790121901279014990163901739018790191901979019990203902179022790239902479026390271902819028990313903539035990371903739037990397904019040390407904379043990469904739048190499905119052390527905299053390547905839059990617906199063190641906479065990677906799069790703907099073190749907879079390803908219082390833908419084790863908879090190907909119091790931909479097190977909899099791009910199103391079910819109791099911219112791129911399114191151911539115991163911839119391199912299123791243912499125391283912919129791303913099133191367913699137391381913879139391397914119142391433914539145791459914639149391499915139152991541915719157391577915839159191621916319163991673916919170391711917339175391757917719178191801918079181191813918239183791841918679187391909919219193991943919519195791961919679196991997920039200992033920419205192077920839210792111921199214392153921739217792179921899220392219922219222792233922379224392251922699229792311923179233392347923539235792363923699237792381923839238792399924019241392419924319245992461924679247992489925039250792551925579256792569925819259392623926279263992641926479265792669926719268192683926939269992707927179272392737927539276192767927799278992791928019280992821928319284992857928619286392867928939289992921929279294192951929579295992987929939300193047930539305993077930839308993097931039311393131931339313993151931699317993187931999322993239932419325193253932579326393281932839328793307933199332393329933379337193377933839340793419934279346393479934819348793491934939349793503935239352993553935579355993563935819360193607936299363793683937019370393719937399376193763937879380993811938279385193871938879388993893939019391193913939239393793941939499396793971939799398393997940079400994033940499405794063940799409994109941119411794121941519415394169942019420794219942299425394261942739429194307943099432194327943319434394349943519437994397943999442194427944339443994441944479446394477944839451394529945319454194543945479455994561945739458394597946039461394621946499465194687946939470994723947279474794771947779478194789947939481194819948239483794841948479484994873948899490394907949339494994951949619499394999950039500995021950279506395071950839508795089950939510195107951119513195143951539517795189951919520395213952199523195233952399525795261952679527395279952879531195317953279533995369953839539395401954139541995429954419544395461954679547195479954839550795527955319553995549955619556995581955979560395617956219562995633956519570195707957139571795723957319573795747957739578395789957919580195803958139581995857958699587395881958919591195917959239592995947959579595995971959879598996001960139601796043960539605996079960979613796149961579616796179961819619996211962219622396233962599626396269962819628996293963239632996331963379635396377964019641996431964439645196457964619646996479964879649396497965179652796553965579658196587965899660196643966619666796671966979670396731967379673996749967579676396769967799678796797967999682196823968279684796851968579689396907969119693196953969599697396979969899699797001970039700797021970399707397081971039711797127971519715797159971699717197177971879721397231972419725997283973019730397327973679736997373973799738197387973979742397429974419745397459974639749997501975119752397547975499755397561975719757797579975839760797609976139764997651976739768797711977299777197777977879778997813978299784197843978479784997859978619787197879978839791997927979319794397961979679797397987980099801198017980419804798057980819810198123981299814398179982079821398221982279825198257982699829798299983179832198323983279834798369983779838798389984079841198419984299844398453984599846798473984799849198507985199853398543985619856398573985979862198627986399864198663986699868998711987139871798729987319873798773987799880198807988099883798849988679886998873988879889398897988999890998911989279892998939989479895398963989819899398999990139901799023990419905399079990839908999103991099911999131991339913799139991499917399181991919922399233992419925199257992599927799289993179934799349993679937199377993919939799401994099943199439994699948799497995239952799529995519955999563995719957799581996079961199623996439966199667996799968999707997099971399719997219973399761997679978799793998099981799823998299983399839998599987199877998819990199907999239992999961999719998999991100003100019100043100049100057100069100103100109100129100151100153100169100183100189100193100207100213100237100267100271100279100291100297100313100333100343100357100361100363100379100391100393100403100411100417100447100459100469100483100493100501100511100517100519100523100537100547100549100559100591100609100613100621100649100669100673100693100699100703100733100741100747100769100787100799100801100811100823100829100847100853100907100913100927100931100937100943100957100981100987100999101009101021101027101051101063101081101089101107101111101113101117101119101141101149101159101161101173101183101197101203101207101209101221101267101273101279101281101287101293101323101333101341101347101359101363101377101383101399101411101419101429101449101467101477101483101489101501101503101513101527101531101533101537101561101573101581101599101603101611101627101641101653101663101681101693101701101719101723101737101741101747101749101771101789101797101807101833101837101839101863101869101873101879101891101917101921101929101939101957101963101977101987101999102001102013102019102023102031102043102059102061102071102077102079102101102103102107102121102139102149102161102181102191102197102199102203102217102229102233102241102251102253102259102293102299102301102317102329102337102359102367102397102407102409102433102437102451102461102481102497102499102503102523102533102539102547102551102559102563102587102593102607102611102643102647102653102667102673102677102679102701102761102763102769102793102797102811102829102841102859102871102877102881102911102913102929102931102953102967102983103001103007103043103049103067103069103079103087103091103093103099103123103141103171103177103183103217103231103237103289103291103307103319103333103349103357103387103391103393103399103409103421103423103451103457103471103483103511103529103549103553103561103567103573103577103583103591103613103619103643103651103657103669103681103687103699103703103723103769103787103801103811103813103837103841103843103867103889103903103913103919103951103963103967103969103979103981103991103993103997104003104009104021104033104047104053104059104087104089104107104113104119104123104147104149104161104173104179104183104207104231104233104239104243104281104287104297104309104311104323104327104347104369104381104383104393104399104417104459104471104473104479104491104513104527104537104543104549104551104561104579104593104597104623104639104651104659104677104681104683104693104701104707104711104717104723104729104743104759104761104773104779104789104801104803104827104831104849104851104869104879104891104911104917104933104947104953104959104971104987104999105019105023105031105037105071105097105107105137105143105167105173105199105211105227105229105239105251105253105263105269105277105319105323105331105337105341105359105361105367105373105379105389105397105401105407105437105449105467105491105499105503105509105517105527105529105533105541105557105563105601105607105613105619105649105653105667105673105683105691105701105727105733105751105761105767105769105817105829105863105871105883105899105907105913105929105943105953105967105971105977105983105997106013106019106031106033106087106103106109106121106123106129106163106181106187106189106207106213106217106219106243106261106273106277106279106291106297106303106307106319106321106331106349106357106363106367106373106391106397106411106417106427106433106441106451106453106487106501106531106537106541106543106591106619106621106627106637106649106657106661106663106669106681106693106699106703106721106727106739106747106751106753106759106781106783106787106801106823106853106859106861106867106871106877106903106907106921106937106949106957106961106963106979106993107021107033107053107057107069107071107077107089107099107101107119107123107137107171107183107197107201107209107227107243107251107269107273107279107309107323107339107347107351107357107377107441107449107453107467107473107507107509107563107581107599107603107609107621107641107647107671107687107693107699107713107717107719107741107747107761107773107777107791107827107837107839107843107857107867107873107881107897107903107923107927107941107951107971107981107999108007108011108013108023108037108041108061108079108089108107108109108127108131108139108161108179108187108191108193108203108211108217108223108233108247108263108271108287108289108293108301108343108347108359108377108379108401108413108421108439108457108461108463108497108499108503108517108529108533108541108553108557108571108587108631108637108643108649108677108707108709108727108739108751108761108769108791108793108799108803108821108827108863108869108877108881108883108887108893108907108917108923108929108943108947108949108959108961108967108971108991109001109013109037109049109063109073109097109103109111109121109133109139109141109147109159109169109171109199109201109211109229109253109267109279109297109303109313109321109331109357109363109367109379109387109391109397109423109433109441109451109453109469109471109481109507109517109519109537109541109547109567109579109583109589109597109609109619109621109639109661109663109673109717109721109741109751109789109793109807109819109829109831109841109843109847109849109859109873109883109891109897109903109913109919109937109943109961109987110017110023110039110051110059110063110069110083110119110129110161110183110221110233110237110251110261110269110273110281110291110311110321110323110339110359110419110431110437110441110459110477110479110491110501110503110527110533110543110557110563110567110569110573110581110587110597110603110609110623110629110641110647110651110681110711110729110731110749110753110771110777110807110813110819110821110849110863110879110881110899110909110917110921110923110927110933110939110947110951110969110977110989111029111031111043111049111053111091111103111109111119111121111127111143111149111187111191111211111217111227111229111253111263111269111271111301111317111323111337111341111347111373111409111427111431111439111443111467111487111491111493111497111509111521111533111539111577111581111593111599111611111623111637111641111653111659111667111697111721111731111733111751111767111773111779111781111791111799111821111827111829111833111847111857111863111869111871111893111913111919111949111953111959111973111977111997112019112031112061112067112069112087112097112103112111112121112129112139112153112163112181112199112207112213112223112237112241112247112249112253112261112279112289112291112297112303112327112331112337112339112349112361112363112397112403112429112459112481112501112507112543112559112571112573112577112583112589112601112603112621112643112657112663112687112691112741112757112759112771112787112799112807112831112843112859112877112901112909112913112919112921112927112939112951112967112979112997113011113017113021113023113027113039113041113051113063113081113083113089113093113111113117113123113131113143113147113149113153113159113161113167113171113173113177113189113209113213113227113233113279113287113327113329113341113357113359113363113371113381113383113417113437113453113467113489113497113501113513113537113539113557113567113591113621113623113647113657113683113717113719113723113731113749113759113761113777113779113783113797113809113819113837113843113891113899113903113909113921113933113947113957113963113969113983113989114001114013114031114041114043114067114073114077114083114089114113114143114157114161114167114193114197114199114203114217114221114229114259114269114277114281114299114311114319114329114343114371114377114407114419114451114467114473114479114487114493114547114553114571114577114593114599114601114613114617114641114643114649114659114661114671114679114689114691114713114743114749114757114761114769114773114781114797114799114809114827114833114847114859114883114889114901114913114941114967114973114997115001115013115019115021115057115061115067115079115099115117115123115127115133115151115153115163115183115201115211115223115237115249115259115279115301115303115309115319115321115327115331115337115343115361115363115399115421115429115459115469115471115499115513115523115547115553115561115571115589115597115601115603115613115631115637115657115663115679115693115727115733115741115751115757115763115769115771115777115781115783115793115807115811115823115831115837115849115853115859115861115873115877115879115883115891115901115903115931115933115963115979115981115987116009116027116041116047116089116099116101116107116113116131116141116159116167116177116189116191116201116239116243116257116269116273116279116293116329116341116351116359116371116381116387116411116423116437116443116447116461116471116483116491116507116531116533116537116539116549116579116593116639116657116663116681116687116689116707116719116731116741116747116789116791116797116803116819116827116833116849116867116881116903116911116923116927116929116933116953116959116969116981116989116993117017117023117037117041117043117053117071117101117109117119117127117133117163117167117191117193117203117209117223117239117241117251117259117269117281117307117319117329117331117353117361117371117373117389117413117427117431117437117443117497117499117503117511117517117529117539117541117563117571117577117617117619117643117659117671117673117679117701117703117709117721117727117731117751117757117763117773117779117787117797117809117811117833117839117841117851117877117881117883117889117899117911117917117937117959117973117977117979117989117991118033118037118043118051118057118061118081118093118127118147118163118169118171118189118211118213118219118247118249118253118259118273118277118297118343118361118369118373118387118399118409118411118423118429118453118457118463118471118493118529118543118549118571118583118589118603118619118621118633118661118669118673118681118687118691118709118717118739118747118751118757118787118799118801118819118831118843118861118873118891118897118901118903118907118913118927118931118967118973119027119033119039119047119057119069119083119087119089119099119101119107119129119131119159119173119179119183119191119227119233119237119243119267119291119293119297119299119311119321119359119363119389119417119419119429119447119489119503119513119533119549119551119557119563119569119591119611119617119627119633119653119657119659119671119677119687119689119699119701119723119737119747119759119771119773119783119797119809119813119827119831119839119849119851119869119881119891119921119923119929119953119963119971119981119983119993120011120017120041120047120049120067120077120079120091120097120103120121120157120163120167120181120193120199120209120223120233120247120277120283120293120299120319120331120349120371120383120391120397120401120413120427120431120473120503120511120539120551120557120563120569120577120587120607120619120623120641120647120661120671120677120689120691120709120713120721120737120739120749120763120767120779120811120817120823120829120833120847120851120863120871120877120889120899120907120917120919120929120937120941120943120947120977120997121001121007121013121019121021121039121061121063121067121081121123121139121151121157121169121171121181121189121229121259121267121271121283121291121309121313121321121327121333121343121349121351121357121367121369121379121403121421121439121441121447121453121469121487121493121501121507121523121531121547121553121559121571121577121579121591121607121609121621121631121633121637121661121687121697121711121721121727121763121787121789121843121853121867121883121889121909121921121931121937121949121951121963121967121993121997122011122021122027122029122033122039122041122051122053122069122081122099122117122131122147122149122167122173122201122203122207122209122219122231122251122263122267122273122279122299122321122323122327122347122363122387122389122393122399122401122443122449122453122471122477122489122497122501122503122509122527122533122557122561122579122597122599122609122611122651122653122663122693122701122719122741122743122753122761122777122789122819122827122833122839122849122861122867122869122887122891122921122929122939122953122957122963122971123001123007123017123031123049123059123077123083123091123113123121123127123143123169123191123203123209123217123229123239123259123269123289123307123311123323123341123373123377123379123397123401123407123419123427123433123439123449123457123479123491123493123499123503123517123527123547123551123553123581123583123593123601123619123631123637123653123661123667123677123701123707123719123727123731123733123737123757123787123791123803123817123821123829123833123853123863123887123911123923123931123941123953123973123979123983123989123997124001124021124067124087124097124121124123124133124139124147124153124171124181124183124193124199124213124231124247124249124277124291124297124301124303124309124337124339124343124349124351124363124367124427124429124433124447124459124471124477124489124493124513124529124541124543124561124567124577124601124633124643124669124673124679124693124699124703124717124721124739124753124759124769124771124777124781124783124793124799124819124823124847124853124897124907124909124919124951124979124981124987124991125003125017125029125053125063125093125101125107125113125117125119125131125141125149125183125197125201125207125219125221125231125243125261125269125287125299125303125311125329125339125353125371125383125387125399125407125423125429125441125453125471125497125507125509125527125539125551125591125597125617125621125627125639125641125651125659125669125683125687125693125707125711125717125731125737125743125753125777125789125791125803125813125821125863125887125897125899125921125927125929125933125941125959125963126001126011126013126019126023126031126037126041126047126067126079126097126107126127126131126143126151126173126199126211126223126227126229126233126241126257126271126307126311126317126323126337126341126349126359126397126421126433126443126457126461126473126481126487126491126493126499126517126541126547126551126583126601126611126613126631126641126653126683126691126703126713126719126733126739126743126751126757126761126781126823126827126839126851126857126859126913126923126943126949126961126967126989127031127033127037127051127079127081127103127123127133127139127157127163127189127207127217127219127241127247127249127261127271127277127289127291127297127301127321127331127343127363127373127399127403127423127447127453127481127487127493127507127529127541127549127579127583127591127597127601127607127609127637127643127649127657127663127669127679127681127691127703127709127711127717127727127733127739127747127763127781127807127817127819127837127843127849127859127867127873127877127913127921127931127951127973127979127997128021128033128047128053128099128111128113128119128147128153128159128173128189128201128203128213128221128237128239128257128273128287128291128311128321128327128339128341128347128351128377128389128393128399128411128413128431128437128449128461128467128473128477128483128489128509128519128521128549128551128563128591128599128603128621128629128657128659128663128669128677128683128693128717128747128749128761128767128813128819128831128833128837128857128861128873128879128903128923128939128941128951128959128969128971128981128983128987128993129001129011129023129037129049129061129083129089129097129113129119129121129127129169129187129193129197129209129221129223129229129263129277129281129287129289129293129313129341129347129361129379129401129403129419129439129443129449129457129461129469129491129497129499129509129517129527129529129533129539129553129581129587129589129593129607129629129631129641129643129671129707129719129733129737129749129757129763129769129793129803129841129853129887129893129901129917129919129937129953129959129967129971130003130021130027130043130051130057130069130073130079130087130099130121130127130147130171130183130199130201130211130223130241130253130259130261130267130279130303130307130337130343130349130363130367130369130379130399130409130411130423130439130447130457130469130477130483130489130513130517130523130531130547130553130579130589130619130621130631130633130639130643130649130651130657130681130687130693130699130729130769130783130787130807130811130817130829130841130843130859130873130927130957130969130973130981130987131009131011131023131041131059131063131071131101131111131113131129131143131149131171131203131213131221131231131249131251131267131293131297131303131311131317131321131357131363131371131381131413131431131437131441131447131449131477131479131489131497131501131507131519131543131561131581131591131611131617131627131639131641131671131687131701131707131711131713131731131743131749131759131771131777131779131783131797131837131839131849131861131891131893131899131909131927131933131939131941131947131959131969132001132019132047132049132059132071132103132109132113132137132151132157132169132173132199132229132233132241132247132257132263132283132287132299132313132329132331132347132361132367132371132383132403132409132421132437132439132469132491132499132511132523132527132529132533132541132547132589132607132611132619132623132631132637132647132661132667132679132689132697132701132707132709132721132739132749132751132757132761132763132817132833132851132857132859132863132887132893132911132929132947132949132953132961132967132971132989133013133033133039133051133069133073133087133097133103133109133117133121133153133157133169133183133187133201133213133241133253133261133271133277133279133283133303133319133321133327133337133349133351133379133387133391133403133417133439133447133451133481133493133499133519133541133543133559133571133583133597133631133633133649133657133669133673133691133697133709133711133717133723133733133769133781133801133811133813133831133843133853133873133877133919133949133963133967133979133981133993133999134033134039134047134053134059134077134081134087134089134093134129134153134161134171134177134191134207134213134219134227134243134257134263134269134287134291134293134327134333134339134341134353134359134363134369134371134399134401134417134437134443134471134489134503134507134513134581134587134591134593134597134609134639134669134677134681134683134699134707134731134741134753134777134789134807134837134839134851134857134867134873134887134909134917134921134923134947134951134989134999135007135017135019135029135043135049135059135077135089135101135119135131135151135173135181135193135197135209135211135221135241135257135271135277135281135283135301135319135329135347135349135353135367135389135391135403135409135427135431135433135449135461135463135467135469135479135497135511135533135559135571135581135589135593135599135601135607135613135617135623135637135647135649135661135671135697135701135719135721135727135731135743135757135781135787135799135829135841135851135859135887135893135899135911135913135929135937135977135979136013136027136033136043136057136067136069136093136099136111136133136139136163136177136189136193136207136217136223136237136247136261136273136277136303136309136319136327136333136337136343136351136361136373136379136393136397136399136403136417136421136429136447136453136463136471136481136483136501136511136519136523136531136537136541136547136559136573136601136603136607136621136649136651136657136691136693136709136711136727136733136739136751136753136769136777136811136813136841136849136859136861136879136883136889136897136943136949136951136963136973136979136987136991136993136999137029137077137087137089137117137119137131137143137147137153137177137183137191137197137201137209137219137239137251137273137279137303137321137339137341137353137359137363137369137383137387137393137399137413137437137443137447137453137477137483137491137507137519137537137567137573137587137593137597137623137633137639137653137659137699137707137713137723137737137743137771137777137791137803137827137831137849137867137869137873137909137911137927137933137941137947137957137983137993137999138007138041138053138059138071138077138079138101138107138113138139138143138157138163138179138181138191138197138209138239138241138247138251138283138289138311138319138323138337138349138371138373138389138401138403138407138427138433138449138451138461138469138493138497138511138517138547138559138563138569138571138577138581138587138599138617138629138637138641138647138661138679138683138727138731138739138763138793138797138799138821138829138841138863138869138883138889138893138899138917138923138937138959138967138977139021139033139067139079139091139109139121139123139133139169139177139187139199139201139241139267139273139291139297139301139303139309139313139333139339139343139361139367139369139387139393139397139409139423139429139439139457139459139483139487139493139501139511139537139547139571139589139591139597139609139619139627139661139663139681139697139703139709139721139729139739139747139753139759139787139801139813139831139837139861139871139883139891139901139907139921139939139943139967139969139981139987139991139999140009140053140057140069140071140111140123140143140159140167140171140177140191140197140207140221140227140237140249140263140269140281140297140317140321140333140339140351140363140381140401140407140411140417140419140423140443140449140453140473140477140521140527140533140549140551140557140587140593140603140611140617140627140629140639140659140663140677140681140683140689140717140729140731140741140759140761140773140779140797140813140827140831140837140839140863140867140869140891140893140897140909140929140939140977140983140989141023141041141061141067141073141079141101141107141121141131141157141161141179141181141199141209141221141223141233141241141257141263141269141277141283141301141307141311141319141353141359141371141397141403141413141439141443141461141481141497141499141509141511141529141539141551141587141601141613141619141623141629141637141649141653141667141671141677141679141689141697141707141709141719141731141761141767141769141773141793141803141811141829141833141851141853141863141871141907141917141931141937141941141959141961141971141991142007142019142031142039142049142057142061142067142097142099142111142123142151142157142159142169142183142189142193142211142217142223142231142237142271142297142319142327142357142369142381142391142403142421142427142433142453142469142501142529142537142543142547142553142559142567142573142589142591142601142607142609142619142657142673142697142699142711142733142757142759142771142787142789142799142811142837142841142867142871142873142897142903142907142939142949142963142969142973142979142981142993143053143063143093143107143111143113143137143141143159143177143197143239143243143249143257143261143263143281143287143291143329143333143357143387143401143413143419143443143461143467143477143483143489143501143503143509143513143519143527143537143551143567143569143573143593143609143617143629143651143653143669143677143687143699143711143719143729143743143779143791143797143807143813143821143827143831143833143873143879143881143909143947143953143971143977143981143999144013144031144037144061144071144073144103144139144161144163144167144169144173144203144223144241144247144253144259144271144289144299144307144311144323144341144349144379144383144407144409144413144427144439144451144461144479144481144497144511144539144541144563144569144577144583144589144593144611144629144659144667144671144701144709144719144731144737144751144757144763144773144779144791144817144829144839144847144883144887144889144899144917144931144941144961144967144973144983145007145009145021145031145037145043145063145069145091145109145121145133145139145177145193145207145213145219145253145259145267145283145289145303145307145349145361145381145391145399145417145423145433145441145451145459145463145471145477145487145501145511145513145517145531145543145547145549145577145589145601145603145633145637145643145661145679145681145687145703145709145721145723145753145757145759145771145777145799145807145819145823145829145861145879145897145903145931145933145949145963145967145969145987145991146009146011146021146023146033146051146057146059146063146077146093146099146117146141146161146173146191146197146203146213146221146239146249146273146291146297146299146309146317146323146347146359146369146381146383146389146407146417146423146437146449146477146513146519146521146527146539146543146563146581146603146609146617146639146647146669146677146681146683146701146719146743146749146767146777146801146807146819146833146837146843146849146857146891146893146917146921146933146941146953146977146983146987146989147011147029147031147047147073147083147089147097147107147137147139147151147163147179147197147209147211147221147227147229147253147263147283147289147293147299147311147319147331147341147347147353147377147391147397147401147409147419147449147451147457147481147487147503147517147541147547147551147557147571147583147607147613147617147629147647147661147671147673147689147703147709147727147739147743147761147769147773147779147787147793147799147811147827147853147859147863147881147919147937147949147977147997148013148021148061148063148073148079148091148123148139148147148151148153148157148171148193148199148201148207148229148243148249148279148301148303148331148339148361148367148381148387148399148403148411148429148439148457148469148471148483148501148513148517148531148537148549148573148579148609148627148633148639148663148667148669148691148693148711148721148723148727148747148763148781148783148793148817148829148853148859148861148867148873148891148913148921148927148931148933148949148957148961148991148997149011149021149027149033149053149057149059149069149077149087149099149101149111149113149119149143149153149159149161149173149183149197149213149239149249149251149257149269149287149297149309149323149333149341149351149371149377149381149393149399149411149417149419149423149441149459149489149491149497149503149519149521149531149533149543149551149561149563149579149603149623149627149629149689149711149713149717149729149731149749149759149767149771149791149803149827149837149839149861149867149873149893149899149909149911149921149939149953149969149971149993150001150011150041150053150061150067150077150083150089150091150097150107150131150151150169150193150197150203150209150211150217150221150223150239150247150287150299150301150323150329150343150373150377150379150383150401150407150413150427150431150439150473150497150503150517150523150533150551150559150571150583150587150589150607150611150617150649150659150697150707150721150743150767150769150779150791150797150827150833150847150869150881150883150889150893150901150907150919150929150959150961150967150979150989150991151007151009151013151027151049151051151057151091151121151141151153151157151163151169151171151189151201151213151237151241151243151247151253151273151279151289151303151337151339151343151357151379151381151391151397151423151429151433151451151471151477151483151499151507151517151523151531151537151549151553151561151573151579151597151603151607151609151631151637151643151651151667151673151681151687151693151703151717151729151733151769151771151783151787151799151813151817151841151847151849151871151883151897151901151903151909151937151939151967151969152003152017152027152029152039152041152063152077152081152083152093152111152123152147152183152189152197152203152213152219152231152239152249152267152287152293152297152311152363152377152381152389152393152407152417152419152423152429152441152443152459152461152501152519152531152533152539152563152567152597152599152617152623152629152639152641152657152671152681152717152723152729152753152767152777152783152791152809152819152821152833152837152839152843152851152857152879152897152899152909152939152941152947152953152959152981152989152993153001153059153067153071153073153077153089153107153113153133153137153151153191153247153259153269153271153277153281153287153313153319153337153343153353153359153371153379153407153409153421153427153437153443153449153457153469153487153499153509153511153521153523153529153533153557153563153589153607153611153623153641153649153689153701153719153733153739153743153749153757153763153817153841153871153877153887153889153911153913153929153941153947153949153953153991153997154001154027154043154057154061154067154073154079154081154087154097154111154127154153154157154159154181154183154211154213154229154243154247154267154277154279154291154303154313154321154333154339154351154369154373154387154409154417154423154439154459154487154493154501154523154543154571154573154579154589154591154613154619154621154643154667154669154681154691154699154723154727154733154747154753154769154787154789154799154807154823154841154849154871154873154877154883154897154927154933154937154943154981154991155003155009155017155027155047155069155081155083155087155119155137155153155161155167155171155191155201155203155209155219155231155251155269155291155299155303155317155327155333155371155377155381155383155387155399155413155423155443155453155461155473155501155509155521155537155539155557155569155579155581155593155599155609155621155627155653155657155663155671155689155693155699155707155717155719155723155731155741155747155773155777155783155797155801155809155821155833155849155851155861155863155887155891155893155921156007156011156019156041156059156061156071156089156109156119156127156131156139156151156157156217156227156229156241156253156257156259156269156307156319156329156347156353156361156371156419156421156437156467156487156491156493156511156521156539156577156589156593156601156619156623156631156641156659156671156677156679156683156691156703156707156719156727156733156749156781156797156799156817156823156833156841156887156899156901156913156941156943156967156971156979157007157013157019157037157049157051157057157061157081157103157109157127157133157141157163157177157181157189157207157211157217157219157229157231157243157247157253157259157271157273157277157279157291157303157307157321157327157349157351157363157393157411157427157429157433157457157477157483157489157513157519157523157543157559157561157571157579157627157637157639157649157667157669157679157721157733157739157747157769157771157793157799157813157823157831157837157841157867157877157889157897157901157907157931157933157951157991157999158003158009158017158029158047158071158077158113158129158141158143158161158189158201158209158227158231158233158243158261158269158293158303158329158341158351158357158359158363158371158393158407158419158429158443158449158489158507158519158527158537158551158563158567158573158581158591158597158611158617158621158633158647158657158663158699158731158747158749158759158761158771158777158791158803158843158849158863158867158881158909158923158927158941158959158981158993159013159017159023159059159073159079159097159113159119159157159161159167159169159179159191159193159199159209159223159227159233159287159293159311159319159337159347159349159361159389159403159407159421159431159437159457159463159469159473159491159499159503159521159539159541159553159563159569159571159589159617159623159629159631159667159671159673159683159697159701159707159721159737159739159763159769159773159779159787159791159793159799159811159833159839159853159857159869159871159899159911159931159937159977159979160001160009160019160031160033160049160073160079160081160087160091160093160117160141160159160163160169160183160201160207160217160231160243160253160309160313160319160343160357160367160373160387160397160403160409160423160441160453160481160483160499160507160541160553160579160583160591160603160619160621160627160637160639160649160651160663160669160681160687160697160709160711160723160739160751160753160757160781160789160807160813160817160829160841160861160877160879160883160903160907160933160967160969160981160997161009161017161033161039161047161053161059161071161087161093161123161137161141161149161159161167161201161221161233161237161263161267161281161303161309161323161333161339161341161363161377161387161407161411161453161459161461161471161503161507161521161527161531161543161561161563161569161573161591161599161611161627161639161641161659161683161717161729161731161741161743161753161761161771161773161779161783161807161831161839161869161873161879161881161911161921161923161947161957161969161971161977161983161999162007162011162017162053162059162079162091162109162119162143162209162221162229162251162257162263162269162277162287162289162293162343162359162389162391162413162419162439162451162457162473162493162499162517162523162527162529162553162557162563162577162593162601162611162623162629162641162649162671162677162683162691162703162709162713162727162731162739162749162751162779162787162791162821162823162829162839162847162853162859162881162889162901162907162917162937162947162971162973162989162997163003163019163021163027163061163063163109163117163127163129163147163151163169163171163181163193163199163211163223163243163249163259163307163309163321163327163337163351163363163367163393163403163409163411163417163433163469163477163481163483163487163517163543163561163567163573163601163613163621163627163633163637163643163661163673163679163697163729163733163741163753163771163781163789163811163819163841163847163853163859163861163871163883163901163909163927163973163979163981163987163991163993163997164011164023164039164051164057164071164089164093164113164117164147164149164173164183164191164201164209164231164233164239164249164251164267164279164291164299164309164321164341164357164363164371164377164387164413164419164429164431164443164447164449164471164477164503164513164531164569164581164587164599164617164621164623164627164653164663164677164683164701164707164729164743164767164771164789164809164821164831164837164839164881164893164911164953164963164987164999165001165037165041165047165049165059165079165083165089165103165133165161165173165181165203165211165229165233165247165287165293165311165313165317165331165343165349165367165379165383165391165397165437165443165449165457165463165469165479165511165523165527165533165541165551165553165559165569165587165589165601165611165617165653165667165673165701165703165707165709165713165719165721165749165779165799165811165817165829165833165857165877165883165887165901165931165941165947165961165983166013166021166027166031166043166063166081166099166147166151166157166169166183166189166207166219166237166247166259166273166289166297166301166303166319166349166351166357166363166393166399166403166409166417166429166457166471166487166541166561166567166571166597166601166603166609166613166619166627166631166643166657166667166669166679166693166703166723166739166741166781166783166799166807166823166841166843166847166849166853166861166867166871166909166919166931166949166967166973166979166987167009167017167021167023167033167039167047167051167071167077167081167087167099167107167113167117167119167149167159167173167177167191167197167213167221167249167261167267167269167309167311167317167329167339167341167381167393167407167413167423167429167437167441167443167449167471167483167491167521167537167543167593167597167611167621167623167627167633167641167663167677167683167711167729167747167759167771167777167779167801167809167861167863167873167879167887167891167899167911167917167953167971167987168013168023168029168037168043168067168071168083168089168109168127168143168151168193168197168211168227168247168253168263168269168277168281168293168323168331168347168353168391168409168433168449168451168457168463168481168491168499168523168527168533168541168559168599168601168617168629168631168643168673168677168697168713168719168731168737168743168761168769168781168803168851168863168869168887168893168899168901168913168937168943168977168991169003169007169009169019169049169063169067169069169079169093169097169111169129169151169159169177169181169199169217169219169241169243169249169259169283169307169313169319169321169327169339169343169361169369169373169399169409169427169457169471169483169489169493169501169523169531169553169567169583169591169607169627169633169639169649169657169661169667169681169691169693169709169733169751169753169769169777169783169789169817169823169831169837169843169859169889169891169909169913169919169933169937169943169951169957169987169991170003170021170029170047170057170063170081170099170101170111170123170141170167170179170189170197170207170213170227170231170239170243170249170263170267170279170293170299170327170341170347170351170353170363170369170371170383170389170393170413170441170447170473170483170497170503170509170537170539170551170557170579170603170609170627170633170641170647170669170689170701170707170711170741170749170759170761170767170773170777170801170809170813170827170837170843170851170857170873170881170887170899170921170927170953170957170971171007171023171029171043171047171049171053171077171079171091171103171131171161171163171167171169171179171203171233171251171253171263171271171293171299171317171329171341171383171401171403171427171439171449171467171469171473171481171491171517171529171539171541171553171559171571171583171617171629171637171641171653171659171671171673171679171697171707171713171719171733171757171761171763171793171799171803171811171823171827171851171863171869171877171881171889171917171923171929171937171947172001172009172021172027172031172049172069172079172093172097172127172147172153172157172169172171172181172199172213172217172219172223172243172259172279172283172297172307172313172321172331172343172351172357172373172399172411172421172423172427172433172439172441172489172507172517172519172541172553172561172573172583172589172597172603172607172619172633172643172649172657172663172673172681172687172709172717172721172741172751172759172787172801172807172829172849172853172859172867172871172877172883172933172969172973172981172987172993172999173021173023173039173053173059173081173087173099173137173141173149173177173183173189173191173207173209173219173249173263173267173273173291173293173297173309173347173357173359173429173431173473173483173491173497173501173531173539173543173549173561173573173599173617173629173647173651173659173669173671173683173687173699173707173713173729173741173743173773173777173779173783173807173819173827173839173851173861173867173891173897173909173917173923173933173969173977173981173993174007174017174019174047174049174061174067174071174077174079174091174101174121174137174143174149174157174169174197174221174241174257174259174263174281174289174299174311174329174331174337174347174367174389174407174413174431174443174457174467174469174481174487174491174527174533174569174571174583174599174613174617174631174637174649174653174659174673174679174703174721174737174749174761174763174767174773174799174821174829174851174859174877174893174901174907174917174929174931174943174959174989174991175003175013175039175061175067175069175079175081175103175129175141175211175229175261175267175277175291175303175309175327175333175349175361175391175393175403175411175433175447175453175463175481175493175499175519175523175543175573175601175621175631175633175649175663175673175687175691175699175709175723175727175753175757175759175781175783175811175829175837175843175853175859175873175891175897175909175919175937175939175949175961175963175979175991175993176017176021176023176041176047176051176053176063176081176087176089176123176129176153176159176161176179176191176201176207176213176221176227176237176243176261176299176303176317176321176327176329176333176347176353176357176369176383176389176401176413176417176419176431176459176461176467176489176497176503176507176509176521176531176537176549176551176557176573176591176597176599176609176611176629176641176651176677176699176711176713176741176747176753176777176779176789176791176797176807176809176819176849176857176887176899176903176921176923176927176933176951176977176983176989177007177011177013177019177043177091177101177109177113177127177131177167177173177209177211177217177223177239177257177269177283177301177319177323177337177347177379177383177409177421177427177431177433177467177473177481177487177493177511177533177539177553177589177601177623177647177677177679177691177739177743177761177763177787177791177797177811177823177839177841177883177887177889177893177907177913177917177929177943177949177953177967177979178001178021178037178039178067178069178091178093178103178117178127178141178151178169178183178187178207178223178231178247178249178259178261178289178301178307178327178333178349178351178361178393178397178403178417178439178441178447178469178481178487178489178501178513178531178537178559178561178567178571178597178601178603178609178613178621178627178639178643178681178691178693178697178753178757178781178793178799178807178813178817178819178831178853178859178873178877178889178897178903178907178909178921178931178933178939178951178973178987179021179029179033179041179051179057179083179089179099179107179111179119179143179161179167179173179203179209179213179233179243179261179269179281179287179317179321179327179351179357179369179381179383179393179407179411179429179437179441179453179461179471179479179483179497179519179527179533179549179563179573179579179581179591179593179603179623179633179651179657179659179671179687179689179693179717179719179737179743179749179779179801179807179813179819179821179827179833179849179897179899179903179909179917179923179939179947179951179953179957179969179981179989179999180001180007180023180043180053180071180073180077180097180137180161180179180181180211180221180233180239180241180247180259180263180281180287180289180307180311180317180331180337180347180361180371180379180391180413180419180437180463180473180491180497180503180511180533180539180541180547180563180569180617180623180629180647180667180679180701180731180749180751180773180779180793180797180799180811180847180871180883180907180949180959181001181003181019181031181039181061181063181081181087181123181141181157181183181193181199181201181211181213181219181243181253181273181277181283181297181301181303181361181387181397181399181409181421181439181457181459181499181501181513181523181537181549181553181603181607181609181619181639181667181669181693181711181717181721181729181739181751181757181759181763181777181787181789181813181837181871181873181889181891181903181913181919181927181931181943181957181967181981181997182009182011182027182029182041182047182057182059182089182099182101182107182111182123182129182131182141182159182167182177182179182201182209182233182239182243182261182279182297182309182333182339182341182353182387182389182417182423182431182443182453182467182471182473182489182503182509182519182537182549182561182579182587182593182599182603182617182627182639182641182653182657182659182681182687182701182711182713182747182773182779182789182803182813182821182839182851182857182867182887182893182899182921182927182929182933182953182957182969182981182999183023183037183041183047183059183067183089183091183119183151183167183191183203183247183259183263183283183289183299183301183307183317183319183329183343183349183361183373183377183383183389183397183437183439183451183461183473183479183487183497183499183503183509183511183523183527183569183571183577183581183587183593183611183637183661183683183691183697183707183709183713183761183763183797183809183823183829183871183877183881183907183917183919183943183949183959183971183973183979184003184007184013184031184039184043184057184073184081184087184111184117184133184153184157184181184187184189184199184211184231184241184259184271184273184279184291184309184321184333184337184351184369184409184417184441184447184463184477184487184489184511184517184523184553184559184567184571184577184607184609184627184631184633184649184651184669184687184693184703184711184721184727184733184753184777184823184829184831184837184843184859184879184901184903184913184949184957184967184969184993184997184999185021185027185051185057185063185069185071185077185089185099185123185131185137185149185153185161185167185177185183185189185221185233185243185267185291185299185303185309185323185327185359185363185369185371185401185429185441185467185477185483185491185519185527185531185533185539185543185551185557185567185569185593185599185621185641185651185677185681185683185693185699185707185711185723185737185747185749185753185767185789185797185813185819185821185831185833185849185869185873185893185897185903185917185923185947185951185957185959185971185987185993186007186013186019186023186037186041186049186071186097186103186107186113186119186149186157186161186163186187186191186211186227186229186239186247186253186259186271186283186299186301186311186317186343186377186379186391186397186419186437186451186469186479186481186551186569186581186583186587186601186619186629186647186649186653186671186679186689186701186707186709186727186733186743186757186761186763186773186793186799186841186859186869186871186877186883186889186917186947186959187003187009187027187043187049187067187069187073187081187091187111187123187127187129187133187139187141187163187171187177187181187189187193187211187217187219187223187237187273187277187303187337187339187349187361187367187373187379187387187393187409187417187423187433187441187463187469187471187477187507187513187531187547187559187573187597187631187633187637187639187651187661187669187687187699187711187721187751187763187787187793187823187843187861187871187877187883187897187907187909187921187927187931187951187963187973187987188011188017188021188029188107188137188143188147188159188171188179188189188197188249188261188273188281188291188299188303188311188317188323188333188351188359188369188389188401188407188417188431188437188443188459188473188483188491188519188527188533188563188579188603188609188621188633188653188677188681188687188693188701188707188711188719188729188753188767188779188791188801188827188831188833188843188857188861188863188869188891188911188927188933188939188941188953188957188983188999189011189017189019189041189043189061189067189127189139189149189151189169189187189199189223189229189239189251189253189257189271189307189311189337189347189349189353189361189377189389189391189401189407189421189433189437189439189463189467189473189479189491189493189509189517189523189529189547189559189583189593189599189613189617189619189643189653189661189671189691189697189701189713189733189743189757189767189797189799189817189823189851189853189859189877189881189887189901189913189929189947189949189961189967189977189983189989189997190027190031190051190063190093190097190121190129190147190159190181190207190243190249190261190271190283190297190301190313190321190331190339190357190367190369190387190391190403190409190471190507190523190529190537190543190573190577190579190583190591190607190613190633190639190649190657190667190669190699190709190711190717190753190759190763190769190783190787190793190807190811190823190829190837190843190871190889190891190901190909190913190921190979190997191021191027191033191039191047191057191071191089191099191119191123191137191141191143191161191173191189191227191231191237191249191251191281191297191299191339191341191353191413191441191447191449191453191459191461191467191473191491191497191507191509191519191531191533191537191551191561191563191579191599191621191627191657191669191671191677191689191693191699191707191717191747191749191773191783191791191801191803191827191831191833191837191861191899191903191911191929191953191969191977191999192007192013192029192037192043192047192053192091192097192103192113192121192133192149192161192173192187192191192193192229192233192239192251192259192263192271192307192317192319192323192341192343192347192373192377192383192391192407192431192461192463192497192499192529192539192547192553192557192571192581192583192587192601192611192613192617192629192631192637192667192677192697192737192743192749192757192767192781192791192799192811192817192833192847192853192859192877192883192887192889192917192923192931192949192961192971192977192979192991193003193009193013193031193043193051193057193073193093193133193139193147193153193163193181193183193189193201193243193247193261193283193301193327193337193357193367193373193379193381193387193393193423193433193441193447193451193463193469193493193507193513193541193549193559193573193577193597193601193603193607193619193649193663193679193703193723193727193741193751193757193763193771193789193793193799193811193813193841193847193859193861193871193873193877193883193891193937193939193943193951193957193979193993194003194017194027194057194069194071194083194087194093194101194113194119194141194149194167194179194197194203194239194263194267194269194309194323194353194371194377194413194431194443194471194479194483194507194521194527194543194569194581194591194609194647194653194659194671194681194683194687194707194713194717194723194729194749194767194771194809194813194819194827194839194861194863194867194869194891194899194911194917194933194963194977194981194989195023195029195043195047195049195053195071195077195089195103195121195127195131195137195157195161195163195193195197195203195229195241195253195259195271195277195281195311195319195329195341195343195353195359195389195401195407195413195427195443195457195469195479195493195497195511195527195539195541195581195593195599195659195677195691195697195709195731195733195737195739195743195751195761195781195787195791195809195817195863195869195883195887195893195907195913195919195929195931195967195971195973195977195991195997196003196033196039196043196051196073196081196087196111196117196139196159196169196171196177196181196187196193196201196247196271196277196279196291196303196307196331196337196379196387196429196439196453196459196477196499196501196519196523196541196543196549196561196579196583196597196613196643196657196661196663196681196687196699196709196717196727196739196751196769196771196799196817196831196837196853196871196873196879196901196907196919196927196961196991196993197003197009197023197033197059197063197077197083197089197101197117197123197137197147197159197161197203197207197221197233197243197257197261197269197273197279197293197297197299197311197339197341197347197359197369197371197381197383197389197419197423197441197453197479197507197521197539197551197567197569197573197597197599197609197621197641197647197651197677197683197689197699197711197713197741197753197759197767197773197779197803197807197831197837197887197891197893197909197921197927197933197947197957197959197963197969197971198013198017198031198043198047198073198083198091198097198109198127198139198173198179198193198197198221198223198241198251198257198259198277198281198301198313198323198337198347198349198377198391198397198409198413198427198437198439198461198463198469198479198491198503198529198533198553198571198589198593198599198613198623198637198641198647198659198673198689198701198719198733198761198769198811198817198823198827198829198833198839198841198851198859198899198901198929198937198941198943198953198959198967198971198977198997199021199033199037199039199049199081199103199109199151199153199181199193199207199211199247199261199267199289199313199321199337199343199357199373199379199399199403199411199417199429199447199453199457199483199487199489199499199501199523199559199567199583199601199603199621199637199657199669199673199679199687199697199721199729199739199741199751199753199777199783199799199807199811199813199819199831199853199873199877199889199909199921199931199933199961199967199999200003200009200017200023200029200033200041200063200087200117200131200153200159200171200177200183200191200201200227200231200237200257200273200293200297200323200329200341200351200357200363200371200381200383200401200407200437200443200461200467200483200513200569200573200579200587200591200597200609200639200657200671200689200699200713200723200731200771200779200789200797200807200843200861200867200869200881200891200899200903200909200927200929200971200983200987200989201007201011201031201037201049201073201101201107201119201121201139201151201163201167201193201203201209201211201233201247201251201281201287201307201329201337201359201389201401201403201413201437201449201451201473201491201493201497201499201511201517201547201557201577201581201589201599201611201623201629201653201661201667201673201683201701201709201731201743201757201767201769201781201787201791201797201809201821201823201827201829201833201847201881201889201893201907201911201919201923201937201947201953201961201973201979201997202001202021202031202049202061202063202067202087202099202109202121202127202129202183202187202201202219202231202243202277202289202291202309202327202339202343202357202361202381202387202393202403202409202441202471202481202493202519202529202549202567202577202591202613202621202627202637202639202661202667202679202693202717202729202733202747202751202753202757202777202799202817202823202841202859202877202879202889202907202921202931202933202949202967202973202981202987202999203011203017203023203039203051203057203117203141203173203183203207203209203213203221203227203233203249203279203293203309203311203317203321203323203339203341203351203353203363203381203383203387203393203417203419203429203431203449203459203461203531203549203563203569203579203591203617203627203641203653203657203659203663203669203713203761203767203771203773203789203807203809203821203843203857203869203873203897203909203911203921203947203953203969203971203977203989203999204007204013204019204023204047204059204067204101204107204133204137204143204151204161204163204173204233204251204299204301204311204319204329204331204353204359204361204367204371204377204397204427204431204437204439204443204461204481204487204509204511204517204521204557204563204583204587204599204601204613204623204641204667204679204707204719204733204749204751204781204791204793204797204803204821204857204859204871204887204913204917204923204931204947204973204979204983205019205031205033205043205063205069205081205097205103205111205129205133205141205151205157205171205187205201205211205213205223205237205253205267205297205307205319205327205339205357205391205397205399205417205421205423205427205433205441205453205463205477205483205487205493205507205519205529205537205549205553205559205589205603205607205619205627205633205651205657205661205663205703205721205759205763205783205817205823205837205847205879205883205913205937205949205951205957205963205967205981205991205993206009206021206027206033206039206047206051206069206077206081206083206123206153206177206179206183206191206197206203206209206221206233206237206249206251206263206273206279206281206291206299206303206341206347206351206369206383206399206407206411206413206419206447206461206467206477206483206489206501206519206527206543206551206593206597206603206623206627206639206641206651206699206749206779206783206803206807206813206819206821206827206879206887206897206909206911206917206923206933206939206951206953206993207013207017207029207037207041207061207073207079207113207121207127207139207169207187207191207197207199207227207239207241207257207269207287207293207301207307207329207331207341207343207367207371207377207401207409207433207443207457207463207469207479207481207491207497207509207511207517207521207523207541207547207551207563207569207589207593207619207629207643207653207661207671207673207679207709207719207721207743207763207769207797207799207811207821207833207847207869207877207923207931207941207947207953207967207971207973207997208001208003208009208037208049208057208067208073208099208111208121208129208139208141208147208189208207208213208217208223208231208253208261208277208279208283208291208309208319208333208337208367208379208387208391208393208409208433208441208457208459208463208469208489208493208499208501208511208513208519208529208553208577208589208591208609208627208631208657208667208673208687208697208699208721208729208739208759208787208799208807208837208843208877208889208891208907208927208931208933208961208963208991208993208997209021209029209039209063209071209089209123209147209159209173209179209189209201209203209213209221209227209233209249209257209263209267209269209299209311209317209327209333209347209353209357209359209371209381209393209401209431209441209449209459209471209477209497209519209533209543209549209563209567209569209579209581209597209621209623209639209647209659209669209687209701209707209717209719209743209767209771209789209801209809209813209819209821209837209851209857209861209887209917209927209929209939209953209959209971209977209983209987210011210019210031210037210053210071210097210101210109210113210127210131210139210143210157210169210173210187210191210193210209210229210233210241210247210257210263210277210283210299210317210319210323210347210359210361210391210401210403210407210421210437210461210467210481210487210491210499210523210527210533210557210599210601210619210631210643210659210671210709210713210719210731210739210761210773210803210809210811210823210827210839210853210857210869210901210907210911210913210923210929210943210961210967211007211039211049211051211061211063211067211073211093211097211129211151211153211177211187211193211199211213211217211219211229211231211241211247211271211283211291211297211313211319211333211339211349211369211373211403211427211433211441211457211469211493211499211501211507211543211559211571211573211583211597211619211639211643211657211661211663211681211691211693211711211723211727211741211747211777211781211789211801211811211817211859211867211873211877211879211889211891211927211931211933211943211949211969211979211997212029212039212057212081212099212117212123212131212141212161212167212183212203212207212209212227212239212243212281212293212297212353212369212383212411212419212423212437212447212453212461212467212479212501212507212557212561212573212579212587212593212627212633212651212669212671212677212683212701212777212791212801212827212837212843212851212867212869212873212881212897212903212909212917212923212969212981212987212999213019213023213029213043213067213079213091213097213119213131213133213139213149213173213181213193213203213209213217213223213229213247213253213263213281213287213289213307213319213329213337213349213359213361213383213391213397213407213449213461213467213481213491213523213533213539213553213557213589213599213611213613213623213637213641213649213659213713213721213727213737213751213791213799213821213827213833213847213859213881213887213901213919213929213943213947213949213953213973213977213989214003214007214009214021214031214033214043214051214063214069214087214091214129214133214141214147214163214177214189214211214213214219214237214243214259214283214297214309214351214363214373214381214391214399214433214439214451214457214463214469214481214483214499214507214517214519214531214541214559214561214589214603214607214631214639214651214657214663214667214673214691214723214729214733214741214759214763214771214783214787214789214807214811214817214831214849214853214867214883214891214913214939214943214967214987214993215051215063215077215087215123215141215143215153215161215179215183215191215197215239215249215261215273215279215297215309215317215329215351215353215359215381215389215393215399215417215443215447215459215461215471215483215497215503215507215521215531215563215573215587215617215653215659215681215687215689215693215723215737215753215767215771215797215801215827215833215843215851215857215863215893215899215909215921215927215939215953215959215981215983216023216037216061216071216091216103216107216113216119216127216133216149216157216173216179216211216217216233216259216263216289216317216319216329216347216371216373216379216397216401216421216431216451216481216493216509216523216551216553216569216571216577216607216617216641216647216649216653216661216679216703216719216731216743216751216757216761216779216781216787216791216803216829216841216851216859216877216899216901216911216917216919216947216967216973216991217001217003217027217033217057217069217081217111217117217121217157217163217169217199217201217207217219217223217229217241217253217271217307217309217313217319217333217337217339217351217361217363217367217369217387217397217409217411217421217429217439217457217463217489217499217517217519217559217561217573217577217579217619217643217661217667217681217687217691217697217717217727217733217739217747217771217781217793217823217829217849217859217901217907217909217933217937217969217979217981218003218021218047218069218077218081218083218087218107218111218117218131218137218143218149218171218191218213218227218233218249218279218287218357218363218371218381218389218401218417218419218423218437218447218453218459218461218479218509218513218521218527218531218549218551218579218591218599218611218623218627218629218641218651218657218677218681218711218717218719218723218737218749218761218783218797218809218819218833218839218843218849218857218873218887218923218941218947218963218969218971218987218989218993219001219017219019219031219041219053219059219071219083219091219097219103219119219133219143219169219187219217219223219251219277219281219293219301219311219313219353219361219371219377219389219407219409219433219437219451219463219467219491219503219517219523219529219533219547219577219587219599219607219613219619219629219647219649219677219679219683219689219707219721219727219731219749219757219761219763219767219787219797219799219809219823219829219839219847219851219871219881219889219911219917219931219937219941219943219953219959219971219977219979219983220009220013220019220021220057220063220123220141220147220151220163220169220177220189220217220243220279220291220301220307220327220333220351220357220361220369220373220391220399220403220411220421220447220469220471220511220513220529220537220543220553220559220573220579220589220613220663220667220673220681220687220699220709220721220747220757220771220783220789220793220807220811220841220859220861220873220877220879220889220897220901220903220907220919220931220933220939220973221021221047221059221069221071221077221083221087221093221101221159221171221173221197221201221203221209221219221227221233221239221251221261221281221303221311221317221327221393221399221401221411221413221447221453221461221471221477221489221497221509221537221539221549221567221581221587221603221621221623221653221657221659221671221677221707221713221717221719221723221729221737221747221773221797221807221813221827221831221849221873221891221909221941221951221953221957221987221989221999222007222011222023222029222041222043222059222067222073222107222109222113222127222137222149222151222161222163222193222197222199222247222269222289222293222311222317222323222329222337222347222349222361222367222379222389222403222419222437222461222493222499222511222527222533222553222557222587222601222613222619222643222647222659222679222707222713222731222773222779222787222791222793222799222823222839222841222857222863222877222883222913222919222931222941222947222953222967222977222979222991223007223009223019223037223049223051223061223063223087223099223103223129223133223151223207223211223217223219223229223241223243223247223253223259223273223277223283223291223303223313223319223331223337223339223361223367223381223403223423223429223439223441223463223469223481223493223507223529223543223547223549223577223589223621223633223637223667223679223681223697223711223747223753223757223759223781223823223829223831223837223841223843223849223903223919223921223939223963223969223999224011224027224033224041224047224057224069224071224101224113224129224131224149224153224171224177224197224201224209224221224233224239224251224261224267224291224299224303224309224317224327224351224359224363224401224423224429224443224449224461224467224473224491224501224513224527224563224569224579224591224603224611224617224629224633224669224677224683224699224711224717224729224737224743224759224771224797224813224831224863224869224881224891224897224909224911224921224929224947224951224969224977224993225023225037225061225067225077225079225089225109225119225133225143225149225157225161225163225167225217225221225223225227225241225257225263225287225289225299225307225341225343225347225349225353225371225373225383225427225431225457225461225479225493225499225503225509225523225527225529225569225581225583225601225611225613225619225629225637225671225683225689225697225721225733225749225751225767225769225779225781225809225821225829225839225859225871225889225919225931225941225943225949225961225977225983225989226001226007226013226027226063226087226099226103226123226129226133226141226169226183226189226199226201226217226231226241226267226283226307226313226337226357226367226379226381226397226409226427226433226451226453226463226483226487226511226531226547226549226553226571226601226609226621226631226637226643226649226657226663226669226691226697226741226753226769226777226783226789226799226813226817226819226823226843226871226901226903226907226913226937226943226991227011227027227053227081227089227093227111227113227131227147227153227159227167227177227189227191227207227219227231227233227251227257227267227281227299227303227363227371227377227387227393227399227407227419227431227453227459227467227471227473227489227497227501227519227531227533227537227561227567227569227581227593227597227603227609227611227627227629227651227653227663227671227693227699227707227719227729227743227789227797227827227849227869227873227893227947227951227977227989227993228013228023228049228061228077228097228103228113228127228131228139228181228197228199228203228211228223228233228251228257228281228299228301228307228311228331228337228341228353228359228383228409228419228421228427228443228451228457228461228469228479228509228511228517228521228523228539228559228577228581228587228593228601228611228617228619228637228647228677228707228713228731228733228737228751228757228773228793228797228799228829228841228847228853228859228869228881228883228887228901228911228913228923228929228953228959228961228983228989229003229027229037229081229093229123229127229133229139229153229157229171229181229189229199229213229217229223229237229247229249229253229261229267229283229309229321229343229351229373229393229399229403229409229423229433229459229469229487229499229507229519229529229547229549229553229561229583229589229591229601229613229627229631229637229639229681229693229699229703229711229717229727229739229751229753229759229763229769229771229777229781229799229813229819229837229841229847229849229897229903229937229939229949229961229963229979229981230003230017230047230059230063230077230081230089230101230107230117230123230137230143230149230189230203230213230221230227230233230239230257230273230281230291230303230309230311230327230339230341230353230357230369230383230387230389230393230431230449230453230467230471230479230501230507230539230551230561230563230567230597230611230647230653230663230683230693230719230729230743230761230767230771230773230779230807230819230827230833230849230861230863230873230891230929230933230939230941230959230969230977230999231001231017231019231031231041231053231067231079231107231109231131231169231197231223231241231269231271231277231289231293231299231317231323231331231347231349231359231367231379231409231419231431231433231443231461231463231479231481231493231503231529231533231547231551231559231563231571231589231599231607231611231613231631231643231661231677231701231709231719231779231799231809231821231823231827231839231841231859231871231877231893231901231919231923231943231947231961231967232003232007232013232049232051232073232079232081232091232103232109232117232129232153232171232187232189232207232217232259232303232307232333232357232363232367232381232391232409232411232417232433232439232451232457232459232487232499232513232523232549232567232571232591232597232607232621232633232643232663232669232681232699232709232711232741232751232753232777232801232811232819232823232847232853232861232871232877232891232901232907232919232937232961232963232987233021233069233071233083233113233117233141233143233159233161233173233183233201233221233231233239233251233267233279233293233297233323233327233329233341233347233353233357233371233407233417233419233423233437233477233489233509233549233551233557233591233599233609233617233621233641233663233669233683233687233689233693233713233743233747233759233777233837233851233861233879233881233911233917233921233923233939233941233969233983233993234007234029234043234067234083234089234103234121234131234139234149234161234167234181234187234191234193234197234203234211234217234239234259234271234281234287234293234317234319234323234331234341234343234361234383234431234457234461234463234467234473234499234511234527234529234539234541234547234571234587234589234599234613234629234653234659234673234683234713234721234727234733234743234749234769234781234791234799234803234809234811234833234847234851234863234869234893234907234917234931234947234959234961234967234977234979234989235003235007235009235013235043235051235057235069235091235099235111235117235159235171235177235181235199235211235231235241235243235273235289235307235309235337235349235369235397235439235441235447235483235489235493235513235519235523235537235541235553235559235577235591235601235607235621235661235663235673235679235699235723235747235751235783235787235789235793235811235813235849235871235877235889235891235901235919235927235951235967235979235997236017236021236053236063236069236077236087236107236111236129236143236153236167236207236209236219236231236261236287236293236297236323236329236333236339236377236381236387236399236407236429236449236461236471236477236479236503236507236519236527236549236563236573236609236627236641236653236659236681236699236701236707236713236723236729236737236749236771236773236779236783236807236813236867236869236879236881236891236893236897236909236917236947236981236983236993237011237019237043237053237067237071237073237089237091237137237143237151237157237161237163237173237179237203237217237233237257237271237277237283237287237301237313237319237331237343237361237373237379237401237409237467237487237509237547237563237571237581237607237619237631237673237683237689237691237701237707237733237737237749237763237767237781237791237821237851237857237859237877237883237901237911237929237959237967237971237973237977237997238001238009238019238031238037238039238079238081238093238099238103238109238141238151238157238159238163238171238181238201238207238213238223238229238237238247238261238267238291238307238313238321238331238339238361238363238369238373238397238417238423238439238451238463238471238477238481238499238519238529238531238547238573238591238627238639238649238657238673238681238691238703238709238723238727238729238747238759238781238789238801238829238837238841238853238859238877238879238883238897238919238921238939238943238949238967238991239017239023239027239053239069239081239087239119239137239147239167239171239179239201239231239233239237239243239251239263239273239287239297239329239333239347239357239383239387239389239417239423239429239431239441239461239489239509239521239527239531239539239543239557239567239579239587239597239611239623239633239641239671239689239699239711239713239731239737239753239779239783239803239807239831239843239849239851239857239873239879239893239929239933239947239957239963239977239999240007240011240017240041240043240047240049240059240073240089240101240109240113240131240139240151240169240173240197240203240209240257240259240263240271240283240287240319240341240347240349240353240371240379240421240433240437240473240479240491240503240509240517240551240571240587240589240599240607240623240631240641240659240677240701240707240719240727240733240739240743240763240769240797240811240829240841240853240859240869240881240883240893240899240913240943240953240959240967240997241013241027241037241049241051241061241067241069241079241093241117241127241141241169241177241183241207241229241249241253241259241261241271241291241303241313241321241327241333241337241343241361241363241391241393241421241429241441241453241463241469241489241511241513241517241537241543241559241561241567241589241597241601241603241639241643241651241663241667241679241687241691241711241727241739241771241781241783241793241807241811241817241823241847241861241867241873241877241883241903241907241919241921241931241939241951241963241973241979241981241993242009242057242059242069242083242093242101242119242129242147242161242171242173242197242201242227242243242257242261242273242279242309242329242357242371242377242393242399242413242419242441242447242449242453242467242479242483242491242509242519242521242533242551242591242603242617242621242629242633242639242647242659242677242681242689242713242729242731242747242773242779242789242797242807242813242819242863242867242873242887242911242923242927242971242989242999243011243031243073243077243091243101243109243119243121243137243149243157243161243167243197243203243209243227243233243239243259243263243301243311243343243367243391243401243403243421243431243433243437243461243469243473243479243487243517243521243527243533243539243553243577243583243587243589243613243623243631243643243647243671243673243701243703243707243709243769243781243787243799243809243829243839243851243857243863243871243889243911243917243931243953243973243989244003244009244021244033244043244087244091244109244121244129244141244147244157244159244177244199244217244219244243244247244253244261244291244297244301244303244313244333244339244351244357244367244379244381244393244399244403244411244423244429244451244457244463244471244481244493244507244529244547244553244561244567244583244589244597244603244619244633244637244639244667244669244687244691244703244711244721244733244747244753244759244781244787244813244837244841244843244859244861244873244877244889244897244901244939244943244957244997245023245029245033245039245071245083245087245107245129245131245149245171245173245177245183245209245251245257245261245269245279245291245299245317245321245339245383245389245407245411245417245419245437245471245473245477245501245513245519245521245527245533245561245563245587245591245593245621245627245629245639245653245671245681245683245711245719245723245741245747245753245759245771245783245789245821245849245851245863245881245897245899245909245911245941245963245977245981245983245989246011246017246049246073246097246119246121246131246133246151246167246173246187246193246203246209246217246223246241246247246251246271246277246289246317246319246329246343246349246361246371246391246403246439246469246473246497246509246511246523246527246539246557246569246577246599246607246611246613246637246641246643246661246683246689246707246709246713246731246739246769246773246781246787246793246803246809246811246817246833246839246889246899246907246913246919246923246929246931246937246941246947246971246979247001247007247031247067247069247073247087247099247141247183247193247201247223247229247241247249247259247279247301247309247337247339247343247363247369247381247391247393247409247421247433247439247451247463247501247519247529247531247547247553247579247591247601247603247607247609247613247633247649247651247691247693247697247711247717247729247739247759247769247771247781247799247811247813247829247847247853247873247879247889247901247913247939247943247957247991247993247997247999248021248033248041248051248057248063248071248077248089248099248117248119248137248141248161248167248177248179248189248201248203248231248243248257248267248291248293248299248309248317248323248351248357248371248389248401248407248431248441248447248461248473248477248483248509248533248537248543248569248579248587248593248597248609248621248627248639248641248657248683248701248707248719248723248737248749248753248779248783248789248797248813248821248827248839248851248861248867248869248879248887248891248893248903248909248971248981248987249017249037249059249079249089249097249103249107249127249131249133249143249181249187249199249211249217249229249233249253249257249287249311249317249329249341249367249377249383249397249419249421249427249433249437249439249449249463249497249499249503249517249521249533249539249541249563249583249589249593249607249647249659249671249677249703249721249727249737249749249763249779249797249811249827249833249853249857249859249863249871249881249911249923249943249947249967249971249973249989250007250013250027250031250037250043250049250051250057250073250091250109250123250147250153250169250199250253250259250267250279250301250307250343250361250403250409250423250433250441250451250489250499250501250543250583250619250643250673250681250687250693250703250709250721250727250739250741250751250753250777250787250793250799250807250813250829250837250841250853250867250871250889250919250949250951250963250967250969250979250993251003251033251051251057251059251063251071251081251087251099251117251143251149251159251171251177251179251191251197251201251203251219251221251231251233251257251261251263251287251291251297251323251347251353251359251387251393251417251429251431251437251443251467251473251477251483251491251501251513251519251527251533251539251543251561251567251609251611251621251623251639251653251663251677251701251707251737251761251789251791251809251831251833251843251857251861251879251887251893251897251903251917251939251941251947251969251971251983252001252013252017252029252037252079252101252139252143252151252157252163252169252173252181252193252209252223252233252253252277252283252289252293252313252319252323252341252359252383252391252401252409252419252431252443252449252457252463252481252509252533252541252559252583252589252607252611252617252641252667252691252709252713252727252731252737252761252767252779252817252823252827252829252869252877252881252887252893252899252911252913252919252937252949252971252979252983253003253013253049253063253081253103253109253133253153253157253159253229253243253247253273253307253321253343253349253361253367253369253381253387253417253423253427253433253439253447253469253481253493253501253507253531253537253543253553253567253573253601253607253609253613253633253637253639253651253661253679253681253703253717253733253741253751253763253769253777253787253789253801253811253819253823253853253867253871253879253901253907253909253919253937253949253951253969253987253993253999254003254021254027254039254041254047254053254071254083254119254141254147254161254179254197254207254209254213254249254257254279254281254291254299254329254369254377254383254389254407254413254437254447254461254489254491254519254537254557254593254623254627254647254659254663254699254713254729254731254741254747254753254773254777254783254791254803254827254831254833254857254869254873254879254887254899254911254927254929254941254959254963254971254977254987254993255007255019255023255043255049255053255071255077255083255097255107255121255127255133255137255149255173255179255181255191255193255197255209255217255239255247255251255253255259255313255329255349255361255371255383255413255419255443255457255467255469255473255487255499255503255511255517255523255551255571255587255589255613255617255637255641255649255653255659255667255679255709255713255733255743255757255763255767255803255839255841255847255851255859255869255877255887255907255917255919255923255947255961255971255973255977255989256019256021256031256033256049256057256079256093256117256121256129256133256147256163256169256181256187256189256199256211256219256279256301256307256313256337256349256363256369256391256393256423256441256469256471256483256489256493256499256517256541256561256567256577256579256589256603256609256639256643256651256661256687256699256721256723256757256771256799256801256813256831256873256877256889256901256903256931256939256957256967256981257003257017257053257069257077257093257099257107257123257141257161257171257177257189257219257221257239257249257263257273257281257287257293257297257311257321257339257351257353257371257381257399257401257407257437257443257447257459257473257489257497257501257503257519257539257561257591257611257627257639257657257671257687257689257707257711257713257717257731257783257791257797257837257857257861257863257867257869257879257893257903257921257947257953257981257987257989257993258019258023258031258061258067258101258107258109258113258119258127258131258143258157258161258173258197258211258233258241258253258277258283258299258317258319258329258331258337258353258373258389258403258407258413258421258437258443258449258469258487258491258499258521258527258539258551258563258569258581258607258611258613258617258623258631258637258659258673258677258691258697258703258707258721258733258737258743258763258779258787258803258809258827258847258871258887258917258919258949258959258967258971258977258983258991259001259009259019259033259099259121259123259151259157259159259163259169259177259183259201259211259213259219259229259271259277259309259321259339259379259381259387259397259411259421259429259451259453259459259499259507259517259531259537259547259577259583259603259619259621259627259631259639259643259657259667259681259691259697259717259723259733259751259771259781259783259801259813259823259829259837259841259867259907259933259937259943259949259967259991259993260003260009260011260017260023260047260081260089260111260137260171260179260189260191260201260207260209260213260231260263260269260317260329260339260363260387260399260411260413260417260419260441260453260461260467260483260489260527260539260543260549260551260569260573260581260587260609260629260647260651260671260677260713260717260723260747260753260761260773260791260807260809260849260857260861260863260873260879260893260921260941260951260959260969260983260987260999261011261013261017261031261043261059261061261071261077261089261101261127261167261169261223261229261241261251261271261281261301261323261329261337261347261353261379261389261407261427261431261433261439261451261463261467261509261523261529261557261563261577261581261587261593261601261619261631261637261641261643261673261697261707261713261721261739261757261761261773261787261791261799261823261847261881261887261917261959261971261973261977261983262007262027262049262051262069262079262103262109262111262121262127262133262139262147262151262153262187262193262217262231262237262253262261262271262303262313262321262331262337262349262351262369262387262391262399262411262433262459262469262489262501262511262513262519262541262543262553262567262583262597262621262627262643262649262651262657262681262693262697262709262723262733262739262741262747262781262783262807262819262853262877262883262897262901262909262937262949262957262981263009263023263047263063263071263077263083263089263101263111263119263129263167263171263183263191263201263209263213263227263239263257263267263269263273263287263293263303263323263369263383263387263399263401263411263423263429263437263443263489263491263503263513263519263521263533263537263561263567263573263591263597263609263611263621263647263651263657263677263723263729263737263759263761263803263819263821263827263843263849263863263867263869263881263899263909263911263927263933263941263951263953263957263983264007264013264029264031264053264059264071264083264091264101264113264127264133264137264139264167264169264179264211264221264263264269264283264289264301264323264331264343264349264353264359264371264391264403264437264443264463264487264527264529264553264559264577264581264599264601264619264631264637264643264659264697264731264739264743264749264757264763264769264779264787264791264793264811264827264829264839264871264881264889264893264899264919264931264949264959264961264977264991264997265003265007265021265037265079265091265093265117265123265129265141265151265157265163265169265193265207265231265241265247265249265261265271265273265277265313265333265337265339265381265399265403265417265423265427265451265459265471265483265493265511265513265541265543265547265561265567265571265579265607265613265619265621265703265709265711265717265729265739265747265757265781265787265807265813265819265831265841265847265861265871265873265883265891265921265957265961265987266003266009266023266027266029266047266051266053266059266081266083266089266093266099266111266117266129266137266153266159266177266183266221266239266261266269266281266291266293266297266333266351266353266359266369266381266401266411266417266447266449266477266479266489266491266521266549266587266599266603266633266641266647266663266671266677266681266683266687266689266701266711266719266759266767266797266801266821266837266839266863266867266891266897266899266909266921266927266933266947266953266957266971266977266983266993266999267017267037267049267097267131267133267139267143267167267187267193267199267203267217267227267229267233267259267271267277267299267301267307267317267341267353267373267389267391267401267403267413267419267431267433267439267451267469267479267481267493267497267511267517267521267523267541267551267557267569267581267587267593267601267611267613267629267637267643267647267649267661267667267671267677267679267713267719267721267727267737267739267749267763267781267791267797267803267811267829267833267857267863267877267887267893267899267901267907267913267929267941267959267961268003268013268043268049268063268069268091268123268133268153268171268189268199268207268211268237268253268267268271268283268291268297268343268403268439268459268487268493268501268507268517268519268529268531268537268547268573268607268613268637268643268661268693268721268729268733268747268757268759268771268777268781268783268789268811268813268817268819268823268841268843268861268883268897268909268913268921268927268937268969268973268979268993268997268999269023269029269039269041269057269063269069269089269117269131269141269167269177269179269183269189269201269209269219269221269231269237269251269257269281269317269327269333269341269351269377269383269387269389269393269413269419269429269431269441269461269473269513269519269527269539269543269561269573269579269597269617269623269641269651269663269683269701269713269719269723269741269749269761269779269783269791269851269879269887269891269897269923269939269947269953269981269987270001270029270031270037270059270071270073270097270121270131270133270143270157270163270167270191270209270217270223270229270239270241270269270271270287270299270307270311270323270329270337270343270371270379270407270421270437270443270451270461270463270493270509270527270539270547270551270553270563270577270583270587270593270601270619270631270653270659270667270679270689270701270709270719270737270749270761270763270791270797270799270821270833270841270859270899270913270923270931270937270953270961270967270973271003271013271021271027271043271057271067271079271097271109271127271129271163271169271177271181271211271217271231271241271253271261271273271277271279271289271333271351271357271363271367271393271409271429271451271463271471271483271489271499271501271517271549271553271571271573271597271603271619271637271639271651271657271693271703271723271729271753271769271771271787271807271811271829271841271849271853271861271867271879271897271903271919271927271939271967271969271981272003272009272011272029272039272053272059272093272131272141272171272179272183272189272191272201272203272227272231272249272257272263272267272269272287272299272317272329272333272341272347272351272353272359272369272381272383272399272407272411272417272423272449272453272477272507272533272537272539272549272563272567272581272603272621272651272659272683272693272717272719272737272759272761272771272777272807272809272813272863272879272887272903272911272917272927272933272959272971272981272983272989272999273001273029273043273047273059273061273067273073273083273107273113273127273131273149273157273181273187273193273233273253273269273271273281273283273289273311273313273323273349273359273367273433273457273473273503273517273521273527273551273569273601273613273617273629273641273643273653273697273709273719273727273739273773273787273797273803273821273827273857273881273899273901273913273919273929273941273943273967273971273979273997274007274019274033274061274069274081274093274103274117274121274123274139274147274163274171274177274187274199274201274213274223274237274243274259274271274277274283274301274333274349274357274361274403274423274441274451274453274457274471274489274517274529274579274583274591274609274627274661274667274679274693274697274709274711274723274739274751274777274783274787274811274817274829274831274837274843274847274853274861274867274871274889274909274931274943274951274957274961274973274993275003275027275039275047275053275059275083275087275129275131275147275153275159275161275167275183275201275207275227275251275263275269275299275309275321275323275339275357275371275389275393275399275419275423275447275449275453275459275461275489275491275503275521275531275543275549275573275579275581275591275593275599275623275641275651275657275669275677275699275711275719275729275741275767275773275783275813275827275837275881275897275911275917275921275923275929275939275941275963275969275981275987275999276007276011276019276037276041276043276047276049276079276083276091276113276137276151276173276181276187276191276209276229276239276247276251276257276277276293276319276323276337276343276347276359276371276373276389276401276439276443276449276461276467276487276499276503276517276527276553276557276581276587276589276593276599276623276629276637276671276673276707276721276739276763276767276779276781276817276821276823276827276833276839276847276869276883276901276907276917276919276929276949276953276961276977277003277007277021277051277063277073277087277097277099277157277163277169277177277183277213277217277223277231277247277259277261277273277279277297277301277309277331277363277373277411277421277427277429277483277493277499277513277531277547277549277567277577277579277597277601277603277637277639277643277657277663277687277691277703277741277747277751277757277787277789277793277813277829277847277859277883277889277891277897277903277919277961277993277999278017278029278041278051278063278071278087278111278119278123278143278147278149278177278191278207278209278219278227278233278237278261278269278279278321278329278347278353278363278387278393278413278437278459278479278489278491278497278501278503278543278549278557278561278563278581278591278609278611278617278623278627278639278651278671278687278689278701278717278741278743278753278767278801278807278809278813278819278827278843278849278867278879278881278891278903278909278911278917278947278981279001279007279023279029279047279073279109279119279121279127279131279137279143279173279179279187279203279211279221279269279311279317279329279337279353279397279407279413279421279431279443279451279479279481279511279523279541279551279553279557279571279577279583279593279607279613279619279637279641279649279659279679279689279707279709279731279751279761279767279779279817279823279847279857279863279883279913279919279941279949279967279977279991280001280009280013280031280037280061280069280097280099280103280121280129280139280183280187280199280207280219280223280229280243280249280253280277280297280303280321280327280337280339280351280373280409280411280451280463280487280499280507280513280537280541280547280549280561280583280589280591280597280603280607280613280627280639280673280681280697280699280703280711280717280729280751280759280769280771280811280817280837280843280859280871280879280883280897280909280913280921280927280933280939280949280957280963280967280979280997281023281033281053281063281069281081281117281131281153281159281167281189281191281207281227281233281243281249281251281273281279281291281297281317281321281327281339281353281357281363281381281419281423281429281431281509281527281531281539281549281551281557281563281579281581281609281621281623281627281641281647281651281653281663281669281683281717281719281737281747281761281767281777281783281791281797281803281807281833281837281839281849281857281867281887281893281921281923281927281933281947281959281971281989281993282001282011282019282053282059282071282089282091282097282101282103282127282143282157282167282221282229282239282241282253282281282287282299282307282311282313282349282377282383282389282391282407282409282413282427282439282461282481282487282493282559282563282571282577282589282599282617282661282671282677282679282683282691282697282703282707282713282767282769282773282797282809282827282833282847282851282869282881282889282907282911282913282917282959282973282977282991283001283007283009283027283051283079283093283097283099283111283117283121283133283139283159283163283181283183283193283207283211283267283277283289283303283369283397283403283411283447283463283487283489283501283511283519283541283553283571283573283579283583283601283607283609283631283637283639283669283687283697283721283741283763283769283771283793283799283807283813283817283831283837283859283861283873283909283937283949283957283961283979284003284023284041284051284057284059284083284093284111284117284129284131284149284153284159284161284173284191284201284227284231284233284237284243284261284267284269284293284311284341284357284369284377284387284407284413284423284429284447284467284477284483284489284507284509284521284527284539284551284561284573284587284591284593284623284633284651284657284659284681284689284701284707284723284729284731284737284741284743284747284749284759284777284783284803284807284813284819284831284833284839284857284881284897284899284917284927284957284969284989285007285023285031285049285071285079285091285101285113285119285121285139285151285161285179285191285199285221285227285251285281285283285287285289285301285317285343285377285421285433285451285457285463285469285473285497285517285521285533285539285553285557285559285569285599285611285613285629285631285641285643285661285667285673285697285707285709285721285731285749285757285763285767285773285781285823285827285839285841285871285937285949285953285977285979285983285997286001286009286019286043286049286061286063286073286103286129286163286171286199286243286249286289286301286333286367286369286381286393286397286411286421286427286453286457286459286469286477286483286487286493286499286513286519286541286543286547286553286589286591286609286613286619286633286651286673286687286697286703286711286721286733286751286753286763286771286777286789286801286813286831286859286873286927286973286981286987286999287003287047287057287059287087287093287099287107287117287137287141287149287159287167287173287179287191287219287233287237287239287251287257287269287279287281287291287297287321287327287333287341287347287383287387287393287437287449287491287501287503287537287549287557287579287597287611287629287669287671287681287689287701287731287747287783287789287801287813287821287849287851287857287863287867287873287887287921287933287939287977288007288023288049288053288061288077288089288109288137288179288181288191288199288203288209288227288241288247288257288283288293288307288313288317288349288359288361288383288389288403288413288427288433288461288467288481288493288499288527288529288539288551288559288571288577288583288647288649288653288661288679288683288689288697288731288733288751288767288773288803288817288823288833288839288851288853288877288907288913288929288931288947288973288979288989288991288997289001289019289021289031289033289039289049289063289067289099289103289109289111289127289129289139289141289151289169289171289181289189289193289213289241289243289249289253289273289283289291289297289309289319289343289349289361289369289381289397289417289423289439289453289463289469289477289489289511289543289559289573289577289589289603289607289637289643289657289669289717289721289727289733289741289759289763289771289789289837289841289843289847289853289859289871289889289897289937289951289957289967289973289987289999290011290021290023290027290033290039290041290047290057290083290107290113290119290137290141290161290183290189290201290209290219290233290243290249290317290327290347290351290359290369290383290393290399290419290429290441290443290447290471290473290489290497290509290527290531290533290539290557290593290597290611290617290621290623290627290657290659290663290669290671290677290701290707290711290737290761290767290791290803290821290827290837290839290861290869290879290897290923290959290963290971290987290993290999291007291013291037291041291043291077291089291101291103291107291113291143291167291169291173291191291199291209291217291253291257291271291287291293291299291331291337291349291359291367291371291373291377291419291437291439291443291457291481291491291503291509291521291539291547291559291563291569291619291647291649291661291677291689291691291701291721291727291743291751291779291791291817291829291833291853291857291869291877291887291899291901291923291971291979291983291997292021292027292037292057292069292079292081292091292093292133292141292147292157292181292183292223292231292241292249292267292283292301292309292319292343292351292363292367292381292393292427292441292459292469292471292477292483292489292493292517292531292541292549292561292573292577292601292627292631292661292667292673292679292693292703292709292711292717292727292753292759292777292793292801292807292819292837292841292849292867292879292909292921292933292969292973292979292993293021293071293081293087293093293099293107293123293129293147293149293173293177293179293201293207293213293221293257293261293263293269293311293329293339293351293357293399293413293431293441293453293459293467293473293483293507293543293599293603293617293621293633293639293651293659293677293681293701293717293723293729293749293767293773293791293803293827293831293861293863293893293899293941293957293983293989293999294001294013294023294029294043294053294059294067294103294127294131294149294157294167294169294179294181294199294211294223294227294241294247294251294269294277294289294293294311294313294317294319294337294341294347294353294383294391294397294403294431294439294461294467294479294499294509294523294529294551294563294629294641294647294649294659294673294703294731294751294757294761294773294781294787294793294799294803294809294821294829294859294869294887294893294911294919294923294947294949294953294979294989294991294997295007295033295037295039295049295073295079295081295111295123295129295153295187295199295201295219295237295247295259295271295277295283295291295313295319295333295357295363295387295411295417295429295433295439295441295459295513295517295541295553295567295571295591295601295663295693295699295703295727295751295759295769295777295787295819295831295837295843295847295853295861295871295873295877295879295901295903295909295937295943295949295951295961295973295993296011296017296027296041296047296071296083296099296117296129296137296159296183296201296213296221296237296243296249296251296269296273296279296287296299296347296353296363296369296377296437296441296473296477296479296489296503296507296509296519296551296557296561296563296579296581296587296591296627296651296663296669296683296687296693296713296719296729296731296741296749296753296767296771296773296797296801296819296827296831296833296843296909296911296921296929296941296969296971296981296983296987297019297023297049297061297067297079297083297097297113297133297151297161297169297191297233297247297251297257297263297289297317297359297371297377297391297397297403297421297439297457297467297469297481297487297503297509297523297533297581297589297601297607297613297617297623297629297641297659297683297691297707297719297727297757297779297793297797297809297811297833297841297853297881297889297893297907297911297931297953297967297971297989297991298013298021298031298043298049298063298087298093298099298153298157298159298169298171298187298201298211298213298223298237298247298261298283298303298307298327298339298343298349298369298373298399298409298411298427298451298477298483298513298559298579298583298589298601298607298621298631298651298667298679298681298687298691298693298709298723298733298757298759298777298799298801298817298819298841298847298853298861298897298937298943298993298999299011299017299027299029299053299059299063299087299099299107299113299137299147299171299179299191299197299213299239299261299281299287299311299317299329299333299357299359299363299371299389299393299401299417299419299447299471299473299477299479299501299513299521299527299539299567299569299603299617299623299653299671299681299683299699299701299711299723299731299743299749299771299777299807299843299857299861299881299891299903299909299933299941299951299969299977299983299993300007300017300023300043300073300089300109300119300137300149300151300163300187300191300193300221300229300233300239300247300277300299300301300317300319300323300331300343300347300367300397300413300427300431300439300463300481300491300493300497300499300511300557300569300581300583300589300593300623300631300647300649300661300667300673300683300691300719300721300733300739300743300749300757300761300779300787300799300809300821300823300851300857300869300877300889300893300929300931300953300961300967300973300977300997301013301027301039301051301057301073301079301123301127301141301153301159301177301181301183301211301219301237301241301243301247301267301303301319301331301333301349301361301363301381301403301409301423301429301447301459301463301471301487301489301493301501301531301577301579301583301591301601301619301627301643301649301657301669301673301681301703301711301747301751301753301759301789301793301813301831301841301843301867301877301897301901301907301913301927301933301943301949301979301991301993301997301999302009302053302111302123302143302167302171302173302189302191302213302221302227302261302273302279302287302297302299302317302329302399302411302417302429302443302459302483302507302513302551302563302567302573302579302581302587302593302597302609302629302647302663302681302711302723302747302759302767302779302791302801302831302833302837302843302851302857302873302891302903302909302921302927302941302959302969302971302977302983302989302999303007303011303013303019303029303049303053303073303089303091303097303119303139303143303151303157303187303217303257303271303283303287303293303299303307303313303323303337303341303361303367303371303377303379303389303409303421303431303463303469303473303491303493303497303529303539303547303551303553303571303581303587303593303613303617303619303643303647303649303679303683303689303691303703303713303727303731303749303767303781303803303817303827303839303859303871303889303907303917303931303937303959303983303997304009304013304021304033304039304049304063304067304069304081304091304099304127304151304153304163304169304193304211304217304223304253304259304279304301304303304331304349304357304363304373304391304393304411304417304429304433304439304457304459304477304481304489304501304511304517304523304537304541304553304559304561304597304609304631304643304651304663304687304709304723304729304739304751304757304763304771304781304789304807304813304831304847304849304867304879304883304897304901304903304907304933304937304943304949304961304979304981305017305021305023305029305033305047305069305093305101305111305113305119305131305143305147305209305219305231305237305243305267305281305297305329305339305351305353305363305369305377305401305407305411305413305419305423305441305449305471305477305479305483305489305497305521305533305551305563305581305593305597305603305611305621305633305639305663305717305719305741305743305749305759305761305771305783305803305821305839305849305857305861305867305873305917305927305933305947305971305999306011306023306029306041306049306083306091306121306133306139306149306157306167306169306191306193306209306239306247306253306259306263306301306329306331306347306349306359306367306377306389306407306419306421306431306437306457306463306473306479306491306503306511306517306529306533306541306563306577306587306589306643306653306661306689306701306703306707306727306739306749306763306781306809306821306827306829306847306853306857306871306877306883306893306899306913306919306941306947306949306953306991307009307019307031307033307067307079307091307093307103307121307129307147307163307169307171307187307189307201307243307253307259307261307267307273307277307283307289307301307337307339307361307367307381307397307399307409307423307451307471307481307511307523307529307537307543307577307583307589307609307627307631307633307639307651307669307687307691307693307711307733307759307817307823307831307843307859307871307873307891307903307919307939307969308003308017308027308041308051308081308093308101308107308117308129308137308141308149308153308213308219308249308263308291308293308303308309308311308317308323308327308333308359308383308411308423308437308447308467308489308491308501308507308509308519308521308527308537308551308569308573308587308597308621308639308641308663308681308701308713308723308761308773308801308809308813308827308849308851308857308887308899308923308927308929308933308939308951308989308999309007309011309013309019309031309037309059309079309083309091309107309109309121309131309137309157309167309173309193309223309241309251309259309269309271309277309289309293309311309313309317309359309367309371309391309403309433309437309457309461309469309479309481309493309503309521309523309539309541309559309571309577309583309599309623309629309637309667309671309677309707309713309731309737309769309779309781309797309811309823309851309853309857309877309899309929309931309937309977309989310019310021310027310043310049310081310087310091310111310117310127310129310169310181310187310223310229310231310237310243310273310283310291310313310333310357310361310363310379310397310423310433310439310447310459310463310481310489310501310507310511310547310553310559310567310571310577310591310627310643310663310693310697310711310721310727310729310733310741310747310771310781310789310801310819310823310829310831310861310867310883310889310901310927310931310949310969310987310997311009311021311027311033311041311099311111311123311137311153311173311177311183311189311197311203311237311279311291311293311299311303311323311329311341311347311359311371311393311407311419311447311453311473311533311537311539311551311557311561311567311569311603311609311653311659311677311681311683311687311711311713311737311743311747311749311791311803311807311821311827311867311869311881311897311951311957311963311981312007312023312029312031312043312047312071312073312083312089312101312107312121312161312197312199312203312209312211312217312229312233312241312251312253312269312281312283312289312311312313312331312343312349312353312371312383312397312401312407312413312427312451312469312509312517312527312551312553312563312581312583312589312601312617312619312623312643312673312677312679312701312703312709312727312737312743312757312773312779312799312839312841312857312863312887312899312929312931312937312941312943312967312971312979312989313003313009313031313037313081313087313109313127313129313133313147313151313153313163313207313211313219313241313249313267313273313289313297313301313307313321313331313333313343313351313373313381313387313399313409313471313477313507313517313543313549313553313561313567313571313583313589313597313603313613313619313637313639313661313669313679313699313711313717313721313727313739313741313763313777313783313829313849313853313879313883313889313897313909313921313931313933313949313961313969313979313981313987313991313993313997314003314021314059314063314077314107314113314117314129314137314159314161314173314189314213314219314227314233314239314243314257314261314263314267314299314329314339314351314357314359314399314401314407314423314441314453314467314491314497314513314527314543314549314569314581314591314597314599314603314623314627314641314651314693314707314711314719314723314747314761314771314777314779314807314813314827314851314879314903314917314927314933314953314957314983314989315011315013315037315047315059315067315083315097315103315109315127315179315181315193315199315223315247315251315257315269315281315313315349315361315373315377315389315407315409315421315437315449315451315461315467315481315493315517315521315527315529315547315551315559315569315589315593315599315613315617315631315643315671315677315691315697315701315703315739315743315751315779315803315811315829315851315857315881315883315893315899315907315937315949315961315967315977316003316031316033316037316051316067316073316087316097316109316133316139316153316177316189316193316201316213316219316223316241316243316259316271316291316297316301316321316339316343316363316373316391316403316423316429316439316453316469316471316493316499316501316507316531316567316571316577316583316621316633316637316649316661316663316681316691316697316699316703316717316753316759316769316777316783316793316801316817316819316847316853316859316861316879316891316903316907316919316937316951316957316961316991317003317011317021317029317047317063317071317077317087317089317123317159317171317179317189317197317209317227317257317263317267317269317279317321317323317327317333317351317353317363317371317399317411317419317431317437317453317459317483317489317491317503317539317557317563317587317591317593317599317609317617317621317651317663317671317693317701317711317717317729317731317741317743317771317773317777317783317789317797317827317831317839317857317887317903317921317923317957317959317963317969317971317983317987318001318007318023318077318103318107318127318137318161318173318179318181318191318203318209318211318229318233318247318259318271318281318287318289318299318301318313318319318323318337318347318349318377318403318407318419318431318443318457318467318473318503318523318557318559318569318581318589318601318629318641318653318671318677318679318683318691318701318713318737318743318749318751318781318793318809318811318817318823318833318841318863318881318883318889318907318911318917318919318949318979319001319027319031319037319049319057319061319069319093319097319117319127319129319133319147319159319169319183319201319211319223319237319259319279319289319313319321319327319339319343319351319357319387319391319399319411319427319433319439319441319453319469319477319483319489319499319511319519319541319547319567319577319589319591319601319607319639319673319679319681319687319691319699319727319729319733319747319757319763319811319817319819319829319831319849319883319897319901319919319927319931319937319967319973319981319993320009320011320027320039320041320053320057320063320081320083320101320107320113320119320141320143320149320153320179320209320213320219320237320239320267320269320273320291320293320303320317320329320339320377320387320389320401320417320431320449320471320477320483320513320521320533320539320561320563320591320609320611320627320647320657320659320669320687320693320699320713320741320759320767320791320821320833320839320843320851320861320867320899320911320923320927320939320941320953321007321017321031321037321047321053321073321077321091321109321143321163321169321187321193321199321203321221321227321239321247321289321301321311321313321319321323321329321331321341321359321367321371321383321397321403321413321427321443321449321467321469321509321547321553321569321571321577321593321611321617321619321631321647321661321679321707321709321721321733321743321751321757321779321799321817321821321823321829321833321847321851321889321901321911321947321949321961321983321991322001322009322013322037322039322051322057322067322073322079322093322097322109322111322139322169322171322193322213322229322237322243322247322249322261322271322319322327322339322349322351322397322403322409322417322429322433322459322463322501322513322519322523322537322549322559322571322573322583322589322591322607322613322627322631322633322649322669322709322727322747322757322769322771322781322783322807322849322859322871322877322891322901322919322921322939322951322963322969322997322999323003323009323027323053323077323083323087323093323101323123323131323137323149323201323207323233323243323249323251323273323333323339323341323359323369323371323377323381323383323413323419323441323443323467323471323473323507323509323537323549323567323579323581323591323597323599323623323641323647323651323699323707323711323717323759323767323789323797323801323803323819323837323879323899323903323923323927323933323951323957323987324011324031324053324067324073324089324097324101324113324119324131324143324151324161324179324199324209324211324217324223324239324251324293324299324301324319324329324341324361324391324397324403324419324427324431324437324439324449324451324469324473324491324497324503324517324523324529324557324587324589324593324617324619324637324641324647324661324673324689324697324707324733324743324757324763324773324781324791324799324809324811324839324847324869324871324889324893324901324931324941324949324953324977324979324983324991324997325001325009325019325021325027325043325051325063325079325081325093325133325153325163325181325187325189325201325217325219325229325231325249325271325301325307325309325319325333325343325349325379325411325421325439325447325453325459325463325477325487325513325517325537325541325543325571325597325607325627325631325643325667325673325681325691325693325697325709325723325729325747325751325753325769325777325781325783325807325813325849325861325877325883325889325891325901325921325939325943325951325957325987325993325999326023326057326063326083326087326099326101326113326119326141326143326147326149326153326159326171326189326203326219326251326257326309326323326351326353326369326437326441326449326467326479326497326503326537326539326549326561326563326567326581326593326597326609326611326617326633326657326659326663326681326687326693326701326707326737326741326773326779326831326863326867326869326873326881326903326923326939326941326947326951326983326993326999327001327007327011327017327023327059327071327079327127327133327163327179327193327203327209327211327247327251327263327277327289327307327311327317327319327331327337327343327347327401327407327409327419327421327433327443327463327469327473327479327491327493327499327511327517327529327553327557327559327571327581327583327599327619327629327647327661327667327673327689327707327721327737327739327757327779327797327799327809327823327827327829327839327851327853327869327871327881327889327917327923327941327953327967327979327983328007328037328043328051328061328063328067328093328103328109328121328127328129328171328177328213328243328249328271328277328283328291328303328327328331328333328343328357328373328379328381328397328411328421328429328439328481328511328513328519328543328579328589328591328619328621328633328637328639328651328667328687328709328721328753328777328781328787328789328813328829328837328847328849328883328891328897328901328919328921328931328961328981329009329027329053329059329081329083329089329101329111329123329143329167329177329191329201329207329209329233329243329257329267329269329281329293329297329299329309329317329321329333329347329387329393329401329419329431329471329473329489329503329519329533329551329557329587329591329597329603329617329627329629329639329657329663329671329677329683329687329711329717329723329729329761329773329779329789329801329803329863329867329873329891329899329941329947329951329957329969329977329993329999330017330019330037330041330047330053330061330067330097330103330131330133330139330149330167330199330203330217330227330229330233330241330247330271330287330289330311330313330329330331330347330359330383330389330409330413330427330431330433330439330469330509330557330563330569330587330607330611330623330641330643330653330661330679330683330689330697330703330719330721330731330749330767330787330791330793330821330823330839330853330857330859330877330887330899330907330917330943330983330997331013331027331031331043331063331081331099331127331141331147331153331159331171331183331207331213331217331231331241331249331259331277331283331301331307331319331333331337331339331349331367331369331391331399331423331447331451331489331501331511331519331523331537331543331547331549331553331577331579331589331603331609331613331651331663331691331693331697331711331739331753331769331777331781331801331819331841331843331871331883331889331897331907331909331921331937331943331957331967331973331997331999332009332011332039332053332069332081332099332113332117332147332159332161332179332183332191332201332203332207332219332221332251332263332273332287332303332309332317332393332399332411332417332441332447332461332467332471332473332477332489332509332513332561332567332569332573332611332617332623332641332687332699332711332729332743332749332767332779332791332803332837332851332873332881332887332903332921332933332947332951332987332989332993333019333023333029333031333041333049333071333097333101333103333107333131333139333161333187333197333209333227333233333253333269333271333283333287333299333323333331333337333341333349333367333383333397333419333427333433333439333449333451333457333479333491333493333497333503333517333533333539333563333581333589333623333631333647333667333673333679333691333701333713333719333721333737333757333769333779333787333791333793333803333821333857333871333911333923333929333941333959333973333989333997334021334031334043334049334057334069334093334099334127334133334157334171334177334183334189334199334231334247334261334289334297334319334331334333334349334363334379334387334393334403334421334423334427334429334447334487334493334507334511334513334541334547334549334561334603334619334637334643334651334661334667334681334693334699334717334721334727334751334753334759334771334777334783334787334793334843334861334877334889334891334897334931334963334973334987334991334993335009335021335029335033335047335051335057335077335081335089335107335113335117335123335131335149335161335171335173335207335213335221335249335261335273335281335299335323335341335347335381335383335411335417335429335449335453335459335473335477335507335519335527335539335557335567335579335591335609335633335641335653335663335669335681335689335693335719335729335743335747335771335807335809335813335821335833335843335857335879335893335897335917335941335953335957335999336029336031336041336059336079336101336103336109336113336121336143336151336157336163336181336199336211336221336223336227336239336247336251336253336263336307336317336353336361336373336397336403336419336437336463336491336499336503336521336527336529336533336551336563336571336577336587336593336599336613336631336643336649336653336667336671336683336689336703336727336757336761336767336769336773336793336799336803336823336827336829336857336863336871336887336899336901336911336929336961336977336983336989336997337013337021337031337039337049337069337081337091337097337121337153337189337201337213337217337219337223337261337277337279337283337291337301337313337327337339337343337349337361337367337369337397337411337427337453337457337487337489337511337517337529337537337541337543337583337607337609337627337633337639337651337661337669337681337691337697337721337741337751337759337781337793337817337837337853337859337861337867337871337873337891337901337903337907337919337949337957337969337973337999338017338027338033338119338137338141338153338159338161338167338171338183338197338203338207338213338231338237338251338263338267338269338279338287338293338297338309338321338323338339338341338347338369338383338389338407338411338413338423338431338449338461338473338477338497338531338543338563338567338573338579338581338609338659338669338683338687338707338717338731338747338753338761338773338777338791338803338839338851338857338867338893338909338927338959338993338999339023339049339067339071339091339103339107339121339127339137339139339151339161339173339187339211339223339239339247339257339263339289339307339323339331339341339373339389339413339433339467339491339517339527339539339557339583339589339601339613339617339631339637339649339653339659339671339673339679339707339727339749339751339761339769339799339811339817339821339827339839339841339863339887339907339943339959339991340007340027340031340037340049340057340061340063340073340079340103340111340117340121340127340129340169340183340201340211340237340261340267340283340297340321340337340339340369340381340387340393340397340409340429340447340451340453340477340481340519340541340559340573340577340579340583340591340601340619340633340643340649340657340661340687340693340709340723340757340777340787340789340793340801340811340819340849340859340877340889340897340903340909340913340919340927340931340933340937340939340957340979340999341017341027341041341057341059341063341083341087341123341141341171341179341191341203341219341227341233341269341273341281341287341293341303341311341321341323341333341339341347341357341423341443341447341459341461341477341491341501341507341521341543341557341569341587341597341603341617341623341629341641341647341659341681341687341701341729341743341749341771341773341777341813341821341827341839341851341863341879341911341927341947341951341953341959341963341983341993342037342047342049342059342061342071342073342077342101342107342131342143342179342187342191342197342203342211342233342239342241342257342281342283342299342319342337342341342343342347342359342371342373342379342389342413342421342449342451342467342469342481342497342521342527342547342553342569342593342599342607342647342653342659342673342679342691342697342733342757342761342791342799342803342821342833342841342847342863342869342871342889342899342929342949342971342989343019343037343051343061343073343081343087343127343141343153343163343169343177343193343199343219343237343243343253343261343267343289343303343307343309343313343327343333343337343373343379343381343391343393343411343423343433343481343489343517343529343531343543343547343559343561343579343583343589343591343601343627343631343639343649343661343667343687343709343727343769343771343787343799343801343813343817343823343829343831343891343897343901343913343933343939343943343951343963343997344017344021344039344053344083344111344117344153344161344167344171344173344177344189344207344209344213344221344231344237344243344249344251344257344263344269344273344291344293344321344327344347344353344363344371344417344423344429344453344479344483344497344543344567344587344599344611344621344629344639344653344671344681344683344693344719344749344753344759344791344797344801344807344819344821344843344857344863344873344887344893344909344917344921344941344957344959344963344969344987345001345011345017345019345041345047345067345089345109345133345139345143345181345193345221345227345229345259345263345271345307345311345329345379345413345431345451345461345463345473345479345487345511345517345533345547345551345571345577345581345599345601345607345637345643345647345659345673345679345689345701345707345727345731345733345739345749345757345769345773345791345803345811345817345823345853345869345881345887345889345907345923345937345953345979345997346013346039346043346051346079346091346097346111346117346133346139346141346147346169346187346201346207346217346223346259346261346277346303346309346321346331346337346349346361346369346373346391346393346397346399346417346421346429346433346439346441346447346453346469346501346529346543346547346553346559346561346589346601346607346627346639346649346651346657346667346669346699346711346721346739346751346763346793346831346849346867346873346877346891346903346933346939346943346961346963347003347033347041347051347057347059347063347069347071347099347129347131347141347143347161347167347173347177347183347197347201347209347227347233347239347251347257347287347297347299347317347329347341347359347401347411347437347443347489347509347513347519347533347539347561347563347579347587347591347609347621347629347651347671347707347717347729347731347747347759347771347773347779347801347813347821347849347873347887347891347899347929347933347951347957347959347969347981347983347987347989347993348001348011348017348031348043348053348077348083348097348149348163348181348191348209348217348221348239348241348247348253348259348269348287348307348323348353348367348389348401348407348419348421348431348433348437348443348451348457348461348463348487348527348547348553348559348563348571348583348587348617348629348637348643348661348671348709348731348739348757348763348769348779348811348827348833348839348851348883348889348911348917348919348923348937348949348989348991349007349039349043349051349079349081349093349099349109349121349133349171349177349183349187349199349207349211349241349291349303349313349331349337349343349357349369349373349379349381349387349397349399349403349409349411349423349471349477349483349493349499349507349519349529349553349567349579349589349603349637349663349667349697349709349717349729349753349759349787349793349801349813349819349829349831349837349841349849349871349903349907349913349919349927349931349933349939349949349963349967349981350003350029350033350039350087350089350093350107350111350137350159350179350191350213350219350237350249350257350281350293350347350351350377350381350411350423350429350431350437350443350447350453350459350503350521350549350561350563350587350593350617350621350629350657350663350677350699350711350719350729350731350737350741350747350767350771350783350789350803350809350843350851350869350881350887350891350899350941350947350963350971350981350983350989351011351023351031351037351041351047351053351059351061351077351079351097351121351133351151351157351179351217351223351229351257351259351269351287351289351293351301351311351341351343351347351359351361351383351391351397351401351413351427351437351457351469351479351497351503351517351529351551351563351587351599351643351653351661351667351691351707351727351731351733351749351751351763351773351779351797351803351811351829351847351851351859351863351887351913351919351929351931351959351971351991352007352021352043352049352057352069352073352081352097352109352111352123352133352181352193352201352217352229352237352249352267352271352273352301352309352327352333352349352357352361352367352369352381352399352403352409352411352421352423352441352459352463352481352483352489352493352511352523352543352549352579352589352601352607352619352633352637352661352691352711352739352741352753352757352771352813352817352819352831352837352841352853352867352883352907352909352931352939352949352951352973352991353011353021353047353053353057353069353081353099353117353123353137353147353149353161353173353179353201353203353237353263353293353317353321353329353333353341353359353389353401353411353429353443353453353459353471353473353489353501353527353531353557353567353603353611353621353627353629353641353653353657353677353681353687353699353711353737353747353767353777353783353797353807353813353819353833353867353869353879353891353897353911353917353921353929353939353963354001354007354017354023354031354037354041354043354047354073354091354097354121354139354143354149354163354169354181354209354247354251354253354257354259354271354301354307354313354317354323354329354337354353354371354373354377354383354391354401354421354439354443354451354461354463354469354479354533354539354551354553354581354587354619354643354647354661354667354677354689354701354703354727354737354743354751354763354779354791354799354829354833354839354847354869354877354881354883354911354953354961354971354973354979354983354997355007355009355027355031355037355039355049355057355063355073355087355093355099355109355111355127355139355171355193355211355261355297355307355321355331355339355343355361355363355379355417355427355441355457355463355483355499355501355507355513355517355519355529355541355549355559355571355573355591355609355633355643355651355669355679355697355717355721355723355753355763355777355783355799355811355819355841355847355853355867355891355909355913355933355937355939355951355967355969356023356039356077356093356101356113356123356129356137356141356143356171356173356197356219356243356261356263356287356299356311356327356333356351356387356399356441356443356449356453356467356479356501356509356533356549356561356563356567356579356591356621356647356663356693356701356731356737356749356761356803356819356821356831356869356887356893356927356929356933356947356959356969356977356981356989356999357031357047357073357079357083357103357107357109357131357139357169357179357197357199357211357229357239357241357263357271357281357283357293357319357347357349357353357359357377357389357421357431357437357473357503357509357517357551357559357563357569357571357583357587357593357611357613357619357649357653357659357661357667357671357677357683357689357703357727357733357737357739357767357779357781357787357793357809357817357823357829357839357859357883357913357967357977357983357989357997358031358051358069358073358079358103358109358153358157358159358181358201358213358219358223358229358243358273358277358279358289358291358297358301358313358327358331358349358373358417358427358429358441358447358459358471358483358487358499358531358541358571358573358591358597358601358607358613358637358667358669358681358691358697358703358711358723358727358733358747358753358769358783358793358811358829358847358859358861358867358877358879358901358903358907358909358931358951358973358979358987358993358999359003359017359027359041359063359069359101359111359129359137359143359147359153359167359171359207359209359231359243359263359267359279359291359297359299359311359323359327359353359357359377359389359407359417359419359441359449359477359479359483359501359509359539359549359561359563359581359587359599359621359633359641359657359663359701359713359719359731359747359753359761359767359783359837359851359869359897359911359929359981359987360007360023360037360049360053360071360089360091360163360167360169360181360187360193360197360223360229360233360257360271360277360287360289360293360307360317360323360337360391360407360421360439360457360461360497360509360511360541360551360589360593360611360637360649360653360749360769360779360781360803360817360821360823360827360851360853360863360869360901360907360947360949360953360959360973360977360979360989361001361003361013361033361069361091361093361111361159361183361211361213361217361219361223361237361241361271361279361313361321361327361337361349361351361357361363361373361409361411361421361433361441361447361451361463361469361481361499361507361511361523361531361541361549361561361577361637361643361649361651361663361679361687361723361727361747361763361769361787361789361793361799361807361843361871361873361877361901361903361909361919361927361943361961361967361973361979361993362003362027362051362053362059362069362081362093362099362107362137362143362147362161362177362191362203362213362221362233362237362281362291362293362303362309362333362339362347362353362357362363362371362377362381362393362407362419362429362431362443362449362459362473362521362561362569362581362599362629362633362657362693362707362717362723362741362743362749362753362759362801362851362863362867362897362903362911362927362941362951362953362969362977362983362987363017363019363037363043363047363059363061363067363119363149363151363157363161363173363179363199363211363217363257363269363271363277363313363317363329363343363359363361363367363371363373363379363397363401363403363431363437363439363463363481363491363497363523363529363533363541363551363557363563363569363577363581363589363611363619363659363677363683363691363719363731363751363757363761363767363773363799363809363829363833363841363871363887363889363901363911363917363941363947363949363959363967363977363989364027364031364069364073364079364103364127364129364141364171364183364187364193364213364223364241364267364271364289364291364303364313364321364333364337364349364373364379364393364411364417364423364433364447364451364459364471364499364513364523364537364541364543364571364583364601364607364621364627364643364657364669364687364691364699364717364739364747364751364753364759364801364829364853364873364879364883364891364909364919364921364937364943364961364979364993364997365003365017365021365039365063365069365089365107365119365129365137365147365159365173365179365201365213365231365249365251365257365291365293365297365303365327365333365357365369365377365411365413365419365423365441365461365467365471365473365479365489365507365509365513365527365531365537365557365567365569365587365591365611365627365639365641365669365683365689365699365747365749365759365773365779365791365797365809365837365839365851365903365929365933365941365969365983366001366013366019366029366031366053366077366097366103366127366133366139366161366167366169366173366181366193366199366211366217366221366227366239366259366269366277366287366293366307366313366329366341366343366347366383366397366409366419366433366437366439366461366463366467366479366497366511366517366521366547366593366599366607366631366677366683366697366701366703366713366721366727366733366787366791366811366829366841366851366853366859366869366881366889366901366907366917366923366941366953366967366973366983366997367001367007367019367021367027367033367049367069367097367121367123367127367139367163367181367189367201367207367219367229367231367243367259367261367273367277367307367309367313367321367357367369367391367397367427367453367457367469367501367519367531367541367547367559367561367573367597367603367613367621367637367649367651367663367673367687367699367711367721367733367739367751367771367777367781367789367819367823367831367841367849367853367867367879367883367889367909367949367957368021368029368047368059368077368083368089368099368107368111368117368129368141368149368153368171368189368197368227368231368233368243368273368279368287368293368323368327368359368363368369368399368411368443368447368453368471368491368507368513368521368531368539368551368579368593368597368609368633368647368651368653368689368717368729368737368743368773368783368789368791368801368803368833368857368873368881368899368911368939368947368957369007369013369023369029369067369071369077369079369097369119369133369137369143369169369181369191369197369211369247369253369263369269369283369293369301369319369331369353369361369407369409369419369469369487369491369539369553369557369581369637369647369659369661369673369703369709369731369739369751369791369793369821369827369829369833369841369851369877369893369913369917369947369959369961369979369983369991369997370003370009370021370033370057370061370067370081370091370103370121370133370147370159370169370193370199370207370213370217370241370247370261370373370387370399370411370421370423370427370439370441370451370463370471370477370483370493370511370529370537370547370561370571370597370603370609370613370619370631370661370663370673370679370687370693370723370759370793370801370813370837370871370873370879370883370891370897370919370949371027371029371057371069371071371083371087371099371131371141371143371153371177371179371191371213371227371233371237371249371251371257371281371291371299371303371311371321371333371339371341371353371359371383371387371389371417371447371453371471371479371491371509371513371549371561371573371587371617371627371633371639371663371669371699371719371737371779371797371831371837371843371851371857371869371873371897371927371929371939371941371951371957371971371981371999372013372023372037372049372059372061372067372107372121372131372137372149372167372173372179372223372241372263372269372271372277372289372293372299372311372313372353372367372371372377372397372401372409372413372443372451372461372473372481372497372511372523372539372607372611372613372629372637372653372661372667372677372689372707372709372719372733372739372751372763372769372773372797372803372809372817372829372833372839372847372859372871372877372881372901372917372941372943372971372973372979373003373007373019373049373063373073373091373127373151373157373171373181373183373187373193373199373207373211373213373229373231373273373291373297373301373327373339373343373349373357373361373363373379373393373447373453373459373463373487373489373501373517373553373561373567373613373621373631373649373657373661373669373693373717373721373753373757373777373783373823373837373859373861373903373909373937373943373951373963373969373981373987373999374009374029374039374041374047374063374069374083374089374093374111374117374123374137374149374159374173374177374189374203374219374239374287374291374293374299374317374321374333374347374351374359374389374399374441374443374447374461374483374501374531374537374557374587374603374639374641374653374669374677374681374683374687374701374713374719374729374741374753374761374771374783374789374797374807374819374837374839374849374879374887374893374903374909374929374939374953374977374981374987374989374993375017375019375029375043375049375059375083375091375097375101375103375113375119375121375127375149375157375163375169375203375209375223375227375233375247375251375253375257375259375281375283375311375341375359375367375371375373375391375407375413375443375449375451375457375467375481375509375511375523375527375533375553375559375563375569375593375607375623375631375643375647375667375673375703375707375709375743375757375761375773375779375787375799375833375841375857375899375901375923375931375967375971375979375983375997376001376003376009376021376039376049376063376081376097376099376127376133376147376153376171376183376199376231376237376241376283376291376297376307376351376373376393376399376417376463376469376471376477376483376501376511376529376531376547376573376577376583376589376603376609376627376631376633376639376657376679376687376699376709376721376729376757376759376769376787376793376801376807376811376819376823376837376841376847376853376889376891376897376921376927376931376933376949376963376969377011377021377051377059377071377099377123377129377137377147377171377173377183377197377219377231377257377263377287377291377297377327377329377339377347377353377369377371377387377393377459377471377477377491377513377521377527377537377543377557377561377563377581377593377599377617377623377633377653377681377687377711377717377737377749377761377771377779377789377801377809377827377831377843377851377873377887377911377963377981377999378011378019378023378041378071378083378089378101378127378137378149378151378163378167378179378193378223378229378239378241378253378269378277378283378289378317378353378361378379378401378407378439378449378463378467378493378503378509378523378533378551378559378569378571378583378593378601378619378629378661378667378671378683378691378713378733378739378757378761378779378793378809378817378821378823378869378883378893378901378919378929378941378949378953378967378977378997379007379009379013379033379039379073379081379087379097379103379123379133379147379157379163379177379187379189379199379207379273379277379283379289379307379319379333379343379369379387379391379397379399379417379433379439379441379451379459379499379501379513379531379541379549379571379573379579379597379607379633379649379663379667379679379681379693379699379703379721379723379727379751379777379787379811379817379837379849379853379859379877379889379903379909379913379927379931379963379979379993379997379999380041380047380059380071380117380129380131380141380147380179380189380197380201380203380207380231380251380267380269380287380291380299380309380311380327380329380333380363380377380383380417380423380441380447380453380459380461380483380503380533380557380563380591380621380623380629380641380651380657380707380713380729380753380777380797380803380819380837380839380843380867380869380879380881380909380917380929380951380957380971380977380983381001381011381019381037381047381061381071381077381097381103381167381169381181381209381221381223381233381239381253381287381289381301381319381323381343381347381371381373381377381383381389381401381413381419381439381443381461381467381481381487381509381523381527381529381533381541381559381569381607381629381631381637381659381673381697381707381713381737381739381749381757381761381791381793381817381841381853381859381911381917381937381943381949381977381989381991382001382003382021382037382061382069382073382087382103382117382163382171382189382229382231382241382253382267382271382303382331382351382357382363382373382391382427382429382457382463382493382507382511382519382541382549382553382567382579382583382589382601382621382631382643382649382661382663382693382703382709382727382729382747382751382763382769382777382801382807382813382843382847382861382867382871382873382883382919382933382939382961382979382999383011383023383029383041383051383069383077383081383083383099383101383107383113383143383147383153383171383179383219383221383261383267383281383291383297383303383321383347383371383393383399383417383419383429383459383483383489383519383521383527383533383549383557383573383587383609383611383623383627383633383651383657383659383681383683383693383723383729383753383759383767383777383791383797383807383813383821383833383837383839383869383891383909383917383923383941383951383963383969383983383987384001384017384029384049384061384067384079384089384107384113384133384143384151384157384173384187384193384203384227384247384253384257384259384277384287384289384299384301384317384331384343384359384367384383384403384407384437384469384473384479384481384487384497384509384533384547384577384581384589384599384611384619384623384641384673384691384697384701384719384733384737384751384757384773384779384817384821384827384841384847384851384889384907384913384919384941384961384973385001385013385027385039385057385069385079385081385087385109385127385129385139385141385153385159385171385193385199385223385249385261385267385279385289385291385321385327385331385351385379385391385393385397385403385417385433385471385481385493385501385519385531385537385559385571385573385579385589385591385597385607385621385631385639385657385661385663385709385739385741385771385783385793385811385817385831385837385843385859385877385897385901385907385927385939385943385967385991385997386017386039386041386047386051386083386093386117386119386129386131386143386149386153386159386161386173386219386227386233386237386249386263386279386297386299386303386329386333386339386363386369386371386381386383386401386411386413386429386431386437386471386489386501386521386537386543386549386569386587386609386611386621386629386641386647386651386677386689386693386713386719386723386731386747386777386809386839386851386887386891386921386927386963386977386987386989386993387007387017387031387047387071387077387083387089387109387137387151387161387169387173387187387197387199387203387227387253387263387269387281387307387313387329387341387371387397387403387433387437387449387463387493387503387509387529387551387577387587387613387623387631387641387659387677387679387683387707387721387727387743387749387763387781387791387799387839387853387857387911387913387917387953387967387971387973387977388009388051388057388067388081388099388109388111388117388133388159388163388169388177388181388183388187388211388231388237388253388259388273388277388301388313388319388351388363388369388373388391388403388459388471388477388481388483388489388499388519388529388541388567388573388621388651388657388673388691388693388697388699388711388727388757388777388781388789388793388813388823388837388859388879388891388897388901388903388931388933388937388961388963388991389003389023389027389029389041389047389057389083389089389099389111389117389141389149389161389167389171389173389189389219389227389231389269389273389287389297389299389303389357389369389381389399389401389437389447389461389479389483389507389513389527389531389533389539389561389563389567389569389579389591389621389629389651389659389663389687389699389713389723389743389749389761389773389783389791389797389819389839389849389867389891389897389903389911389923389927389941389947389953389957389971389981389989389999390001390043390067390077390083390097390101390107390109390113390119390151390157390161390191390193390199390209390211390223390263390281390289390307390323390343390347390353390359390367390373390389390391390407390413390419390421390433390437390449390463390479390487390491390493390499390503390527390539390553390581390647390653390671390673390703390707390721390727390737390739390743390751390763390781390791390809390821390829390851390869390877390883390889390893390953390959390961390967390989390991391009391019391021391031391049391057391063391067391073391103391117391133391151391159391163391177391199391217391219391231391247391249391273391283391291391301391331391337391351391367391373391379391387391393391397391399391403391441391451391453391487391519391537391553391579391613391619391627391631391639391661391679391691391693391711391717391733391739391751391753391757391789391801391817391823391847391861391873391879391889391891391903391907391921391939391961391967391987391999392011392033392053392059392069392087392099392101392111392113392131392143392149392153392159392177392201392209392213392221392233392239392251392261392263392267392269392279392281392297392299392321392333392339392347392351392363392383392389392423392437392443392467392473392477392489392503392519392531392543392549392569392593392599392611392629392647392663392669392699392723392737392741392759392761392767392803392807392809392827392831392837392849392851392857392879392893392911392923392927392929392957392963392969392981392983393007393013393017393031393059393073393077393079393083393097393103393109393121393137393143393157393161393181393187393191393203393209393241393247393257393271393287393299393301393311393331393361393373393377393383393401393403393413393451393473393479393487393517393521393539393541393551393557393571393577393581393583393587393593393611393629393637393649393667393671393677393683393697393709393713393721393727393739393749393761393779393797393847393853393857393859393863393871393901393919393929393931393947393961393977393989393997394007394019394039394049394063394073394099394123394129394153394157394169394187394201394211394223394241394249394259394271394291394319394327394357394363394367394369394393394409394411394453394481394489394501394507394523394529394549394571394577394579394601394619394631394633394637394643394673394699394717394721394727394729394733394739394747394759394787394811394813394817394819394829394837394861394879394897394931394943394963394967394969394981394987394993395023395027395039395047395069395089395093395107395111395113395119395137395141395147395159395173395189395191395201395231395243395251395261395273395287395293395303395309395321395323395377395383395407395429395431395443395449395453395459395491395509395513395533395537395543395581395597395611395621395627395657395671395677395687395701395719395737395741395749395767395803395849395851395873395887395891395897395909395921395953395959395971396001396029396031396041396043396061396079396091396103396107396119396157396173396181396197396199396203396217396239396247396259396269396293396299396301396311396323396349396353396373396377396379396413396427396437396443396449396479396509396523396527396533396541396547396563396577396581396601396619396623396629396631396637396647396667396679396703396709396713396719396733396833396871396881396883396887396919396931396937396943396947396953396971396983396997397013397027397037397051397057397063397073397093397099397127397151397153397181397183397211397217397223397237397253397259397283397289397297397301397303397337397351397357397361397373397379397427397429397433397459397469397489397493397517397519397541397543397547397549397567397589397591397597397633397643397673397687397697397721397723397729397751397753397757397759397763397799397807397811397829397849397867397897397907397921397939397951397963397973397981398011398023398029398033398039398053398059398063398077398087398113398117398119398129398143398149398171398207398213398219398227398249398261398267398273398287398303398311398323398339398341398347398353398357398369398393398407398417398423398441398459398467398471398473398477398491398509398539398543398549398557398569398581398591398609398611398621398627398669398681398683398693398711398729398731398759398771398813398819398821398833398857398863398887398903398917398921398933398941398969398977398989399023399031399043399059399067399071399079399097399101399107399131399137399149399151399163399173399181399197399221399227399239399241399263399271399277399281399283399353399379399389399391399401399403399409399433399439399473399481399491399493399499399523399527399541399557399571399577399583399587399601399613399617399643399647399667399677399689399691399719399727399731399739399757399761399769399781399787399793399851399853399871399887399899399911399913399937399941399953399979399983399989400009400031400033400051400067400069400087400093400109400123400151400157400187400199400207400217400237400243400247400249400261400277400291400297400307400313400321400331400339400381400391400409400417400429400441400457400471400481400523400559400579400597400601400607400619400643400651400657400679400681400703400711400721400723400739400753400759400823400837400849400853400859400871400903400927400931400943400949400963400997401017401029401039401053401057401069401077401087401101401113401119401161401173401179401201401209401231401237401243401279401287401309401311401321401329401341401347401371401381401393401407401411401417401473401477401507401519401537401539401551401567401587401593401627401629401651401669401671401689401707401711401743401771401773401809401813401827401839401861401867401887401903401909401917401939401953401957401959401981401987401993402023402029402037402043402049402053402071402089402091402107402131402133402137402139402197402221402223402239402253402263402277402299402307402313402329402331402341402343402359402361402371402379402383402403402419402443402487402503402511402517402527402529402541402551402559402581402583402587402593402601402613402631402691402697402739402751402757402761402763402767402769402797402803402817402823402847402851402859402863402869402881402923402943402947402949402991403001403003403037403043403049403057403061403063403079403097403103403133403141403159403163403181403219403241403243403253403261403267403289403301403309403327403331403339403363403369403387403391403433403439403483403499403511403537403547403549403553403567403577403591403603403607403621403649403661403679403681403687403703403717403721403729403757403783403787403817403829403831403849403861403867403877403889403901403933403951403957403969403979403981403993404009404011404017404021404029404051404081404099404113404119404123404161404167404177404189404191404197404213404221404249404251404267404269404273404291404309404321404323404357404381404387404389404399404419404423404429404431404449404461404483404489404497404507404513404527404531404533404539404557404597404671404693404699404713404773404779404783404819404827404837404843404849404851404941404951404959404969404977404981404983405001405011405029405037405047405049405071405073405089405091405143405157405179405199405211405221405227405239405241405247405253405269405277405287405299405323405341405343405347405373405401405407405413405437405439405473405487405491405497405499405521405527405529405541405553405577405599405607405611405641405659405667405677405679405683405689405701405703405709405719405731405749405763405767405781405799405817405827405829405857405863405869405871405893405901405917405947405949405959405967405989405991405997406013406027406037406067406073406093406117406123406169406171406177406183406207406247406253406267406271406309406313406327406331406339406349406361406381406397406403406423406447406481406499406501406507406513406517406531406547406559406561406573406577406579406583406591406631406633406649406661406673406697406699406717406729406739406789406807406811406817406837406859406873406883406907406951406969406981406993407023407047407059407083407119407137407149407153407177407179407191407203407207407219407221407233407249407257407263407273407287407291407299407311407317407321407347407357407359407369407377407383407401407437407471407483407489407501407503407509407521407527407567407573407579407587407599407621407633407639407651407657407669407699407707407713407717407723407741407747407783407789407791407801407807407821407833407843407857407861407879407893407899407917407923407947407959407969407971407977407993408011408019408041408049408071408077408091408127408131408137408169408173408197408203408209408211408217408223408229408241408251408263408271408283408311408337408341408347408361408379408389408403408413408427408431408433408437408461408469408479408491408497408533408539408553408563408607408623408631408637408643408659408677408689408691408701408703408713408719408743408763408769408773408787408803408809408817408841408857408869408911408913408923408943408953408959408971408979408997409007409021409027409033409043409063409069409081409099409121409153409163409177409187409217409237409259409261409267409271409289409291409327409333409337409349409351409369409379409391409397409429409433409441409463409471409477409483409499409517409523409529409543409573409579409589409597409609409639409657409691409693409709409711409723409729409733409753409769409777409781409813409817409823409831409841409861409867409879409889409891409897409901409909409933409943409951409961409967409987409993409999410009410029410063410087410093410117410119410141410143410149410171410173410203410231410233410239410243410257410279410281410299410317410323410339410341410353410359410383410387410393410401410411410413410453410461410477410489410491410497410507410513410519410551410561410587410617410621410623410629410651410659410671410687410701410717410731410741410747410749410759410783410789410801410807410819410833410857410899410903410929410953410983410999411001411007411011411013411031411041411049411067411071411083411101411113411119411127411143411157411167411193411197411211411233411241411251411253411259411287411311411337411347411361411371411379411409411421411443411449411469411473411479411491411503411527411529411557411563411569411577411583411589411611411613411617411637411641411667411679411683411703411707411709411721411727411737411739411743411751411779411799411809411821411823411833411841411883411919411923411937411941411947411967411991412001412007412019412031412033412037412039412051412067412073412081412099412109412123412127412133412147412157412171412187412189412193412201412211412213412219412249412253412273412277412289412303412333412339412343412387412397412411412457412463412481412487412493412537412561412567412571412589412591412603412609412619412627412637412639412651412663412667412717412739412771412793412807412831412849412859412891412901412903412939412943412949412967412987413009413027413033413053413069413071413081413087413089413093413111413113413129413141413143413159413167413183413197413201413207413233413243413251413263413267413293413299413353413411413417413429413443413461413477413521413527413533413537413551413557413579413587413597413629413653413681413683413689413711413713413719413737413753413759413779413783413807413827413849413863413867413869413879413887413911413923413951413981414013414017414019414031414049414053414061414077414083414097414101414107414109414131414157414179414199414203414209414217414221414241414259414269414277414283414311414313414329414331414347414361414367414383414389414397414413414431414433414451414457414461414467414487414503414521414539414553414559414571414577414607414611414629414641414643414653414677414679414683414691414697414703414707414709414721414731414737414763414767414769414773414779414793414803414809414833414857414871414889414893414899414913414923414929414949414959414971414977414991415013415031415039415061415069415073415087415097415109415111415133415141415147415153415159415171415187415189415201415213415231415253415271415273415319415343415379415381415391415409415427415447415469415477415489415507415517415523415543415553415559415567415577415603415607415609415627415631415643415651415661415669415673415687415691415697415717415721415729415759415783415787415799415801415819415823415861415873415879415901415931415937415949415951415957415963415969415979415993415999416011416023416071416077416089416107416147416149416153416159416167416201416219416239416243416249416257416263416281416291416333416359416387416389416393416399416401416407416413416417416419416441416443416459416473416477416491416497416501416503416513416531416543416573416579416593416621416623416629416659416677416693416719416761416797416821416833416839416849416851416873416881416887416947416957416963416989417007417017417019417023417037417089417097417113417119417127417133417161417169417173417181417187417191417203417217417227417239417251417271417283417293417311417317417331417337417371417377417379417383417419417437417451417457417479417491417493417509417511417523417541417553417559417577417581417583417617417623417631417643417649417671417691417719417721417727417731417733417737417751417763417773417793417811417821417839417863417869417881417883417899417931417941417947417953417959417961417983417997418007418009418027418031418043418051418069418073418079418087418109418129418157418169418177418181418189418199418207418219418259418273418279418289418303418321418331418337418339418343418349418351418357418373418381418391418423418427418447418459418471418493418511418553418559418597418601418603418631418633418637418657418667418699418709418721418739418751418763418771418783418787418793418799418811418813418819418837418843418849418861418867418871418883418889418909418921418927418933418939418961418981418987418993418997419047419051419053419057419059419087419141419147419161419171419183419189419191419201419231419249419261419281419291419297419303419317419329419351419383419401419417419423419429419443419449419459419467419473419477419483419491419513419527419537419557419561419563419567419579419591419597419599419603419609419623419651419687419693419701419711419743419753419777419789419791419801419803419821419827419831419873419893419921419927419929419933419953419959419999420001420029420037420041420047420073420097420103420149420163420191420193420221420241420253420263420269420271420293420307420313420317420319420323420331420341420349420353420361420367420383420397420419420421420439420457420467420479420481420499420503420521420551420557420569420571420593420599420613420671420677420683420691420731420737420743420757420769420779420781420799420803420809420811420851420853420857420859420899420919420929420941420967420977420997421009421019421033421037421049421079421081421093421103421121421123421133421147421159421163421177421181421189421207421241421273421279421303421313421331421339421349421361421381421397421409421417421423421433421453421459421469421471421483421493421501421517421559421607421609421621421633421639421643421657421661421691421697421699421703421709421711421717421727421739421741421783421801421807421831421847421891421907421913421943421973421987421997422029422041422057422063422069422077422083422087422089422099422101422111422113422129422137422141422183422203422209422231422239422243422249422267422287422291422309422311422321422339422353422363422369422377422393422407422431422453422459422479422537422549422551422557422563422567422573422581422621422627422657422689422701422707422711422749422753422759422761422789422797422803422827422857422861422867422869422879422881422893422897422899422911422923422927422969422987423001423013423019423043423053423061423067423083423091423097423103423109423121423127423133423173423179423191423209423221423229423233423251423257423259423277423281423287423289423299423307423323423341423347423389423403423413423427423431423439423457423461423463423469423481423497423503423509423541423547423557423559423581423587423601423617423649423667423697423707423713423727423749423751423763423769423779423781423791423803423823423847423853423859423869423883423887423931423949423961423977423989423991424001424003424007424019424027424037424079424091424093424103424117424121424129424139424147424157424163424169424187424199424223424231424243424247424261424267424271424273424313424331424339424343424351424397424423424429424433424451424471424481424493424519424537424547424549424559424573424577424597424601424639424661424667424679424687424693424709424727424729424757424769424771424777424811424817424819424829424841424843424849424861424867424889424891424903424909424913424939424961424967424997425003425027425039425057425059425071425083425101425107425123425147425149425189425197425207425233425237425251425273425279425281425291425297425309425317425329425333425363425377425387425393425417425419425423425441425443425471425473425489425501425519425521425533425549425563425591425603425609425641425653425681425701425713425779425783425791425801425813425819425837425839425851425857425861425869425879425899425903425911425939425959425977425987425989426007426011426061426073426077426089426091426103426131426161426163426193426197426211426229426233426253426287426301426311426319426331426353426383426389426401426407426421426427426469426487426527426541426551426553426563426583426611426631426637426641426661426691426697426707426709426731426737426739426743426757426761426763426773426779426787426799426841426859426863426871426889426893426913426917426919426931426941426971426973426997427001427013427039427043427067427069427073427079427081427103427117427151427169427181427213427237427241427243427247427249427279427283427307427309427327427333427351427369427379427381427403427417427421427423427429427433427439427447427451427457427477427513427517427523427529427541427579427591427597427619427621427681427711427717427723427727427733427751427781427787427789427813427849427859427877427879427883427913427919427939427949427951427957427967427969427991427993427997428003428023428027428033428039428041428047428083428093428137428143428147428149428161428167428173428177428221428227428231428249428251428273428297428299428303428339428353428369428401428411428429428471428473428489428503428509428531428539428551428557428563428567428569428579428629428633428639428657428663428671428677428683428693428731428741428759428777428797428801428807428809428833428843428851428863428873428899428951428957428977429007429017429043429083429101429109429119429127429137429139429161429181429197429211429217429223429227429241429259429271429277429281429283429329429347429349429361429367429389429397429409429413429427429431429449429463429467429469429487429497429503429509429511429521429529429547429551429563429581429587429589429599429631429643429659429661429673429677429679429683429701429719429727429731429733429773429791429797429817429823429827429851429853429881429887429889429899429901429907429911429917429929429931429937429943429953429971429973429991430007430009430013430019430057430061430081430091430093430121430139430147430193430259430267430277430279430289430303430319430333430343430357430393430411430427430433430453430487430499430511430513430517430543430553430571430579430589430601430603430649430663430691430697430699430709430723430739430741430747430751430753430769430783430789430799430811430819430823430841430847430861430873430879430883430891430897430907430909430921430949430957430979430981430987430999431017431021431029431047431051431063431077431083431099431107431141431147431153431173431191431203431213431219431237431251431257431267431269431287431297431311431329431339431363431369431377431381431399431423431429431441431447431449431479431513431521431533431567431581431597431603431611431617431621431657431659431663431671431693431707431729431731431759431777431797431801431803431807431831431833431857431863431867431869431881431887431891431903431911431929431933431947431983431993432001432007432023432031432037432043432053432059432067432073432097432121432137432139432143432149432161432163432167432199432203432227432241432251432277432281432287432301432317432323432337432343432349432359432373432389432391432401432413432433432437432449432457432479432491432499432503432511432527432539432557432559432569432577432587432589432613432631432637432659432661432713432721432727432737432743432749432781432793432797432799432833432847432857432869432893432907432923432931432959432961432979432983432989433003433033433049433051433061433073433079433087433093433099433117433123433141433151433187433193433201433207433229433241433249433253433259433261433267433271433291433309433319433337433351433357433361433369433373433393433399433421433429433439433453433469433471433501433507433513433549433571433577433607433627433633433639433651433661433663433673433679433681433703433723433729433747433759433777433781433787433813433817433847433859433861433877433883433889433931433943433963433967433981434009434011434029434039434081434087434107434111434113434117434141434167434179434191434201434209434221434237434243434249434261434267434293434297434303434311434323434347434353434363434377434383434387434389434407434411434431434437434459434461434471434479434501434509434521434561434563434573434593434597434611434647434659434683434689434699434717434719434743434761434783434803434807434813434821434827434831434839434849434857434867434873434881434909434921434923434927434933434939434947434957434963434977434981434989435037435041435059435103435107435109435131435139435143435151435161435179435181435187435191435221435223435247435257435263435277435283435287435307435317435343435349435359435371435397435401435403435419435427435437435439435451435481435503435529435541435553435559435563435569435571435577435583435593435619435623435637435641435647435649435653435661435679435709435731435733435739435751435763435769435779435817435839435847435857435859435881435889435893435907435913435923435947435949435973435983435997436003436013436027436061436081436087436091436097436127436147436151436157436171436181436217436231436253436273436279436283436291436307436309436313436343436357436399436417436427436439436459436463436477436481436483436507436523436529436531436547436549436571436591436607436621436627436649436651436673436687436693436717436727436729436739436741436757436801436811436819436831436841436853436871436889436913436957436963436967436973436979436993436999437011437033437071437077437083437093437111437113437137437141437149437153437159437191437201437219437237437243437263437273437279437287437293437321437351437357437363437387437389437401437413437467437471437473437497437501437509437519437527437533437539437543437557437587437629437641437651437653437677437681437687437693437719437729437743437753437771437809437819437837437849437861437867437881437909437923437947437953437959437977438001438017438029438047438049438091438131438133438143438169438203438211438223438233438241438253438259438271438281438287438301438313438329438341438377438391438401438409438419438439438443438467438479438499438517438521438523438527438533438551438569438589438601438611438623438631438637438661438667438671438701438707438721438733438761438769438793438827438829438833438847438853438869438877438887438899438913438937438941438953438961438967438979438983438989439007439009439063439081439123439133439141439157439163439171439183439199439217439253439273439279439289439303439339439349439357439367439381439409439421439427439429439441439459439463439471439493439511439519439541439559439567439573439577439583439601439613439631439639439661439667439687439693439697439709439723439729439753439759439763439771439781439787439799439811439823439849439853439861439867439883439891439903439919439949439961439969439973439981439991440009440023440039440047440087440093440101440131440159440171440177440179440183440203440207440221440227440239440261440269440281440303440311440329440333440339440347440371440383440389440393440399440431440441440443440471440497440501440507440509440527440537440543440549440551440567440569440579440581440641440651440653440669440677440681440683440711440717440723440731440753440761440773440807440809440821440831440849440863440893440903440911440939440941440953440959440983440987440989441011441029441041441043441053441073441079441101441107441109441113441121441127441157441169441179441187441191441193441229441247441251441257441263441281441307441319441349441359441361441403441421441443441449441461441479441499441517441523441527441547441557441563441569441587441607441613441619441631441647441667441697441703441713441737441751441787441797441799441811441827441829441839441841441877441887441907441913441923441937441953441971442003442007442009442019442027442031442033442061442069442097442109442121442139442147442151442157442171442177442181442193442201442207442217442229442237442243442271442283442291442319442327442333442363442367442397442399442439442447442457442469442487442489442499442501442517442531442537442571442573442577442579442601442609442619442633442691442699442703442721442733442747442753442763442769442777442781442789442807442817442823442829442831442837442843442861442879442903442919442961442963442973442979442987442991442997443011443017443039443041443057443059443063443077443089443117443123443129443147443153443159443161443167443171443189443203443221443227443231443237443243443249443263443273443281443291443293443341443347443353443363443369443389443407443413443419443423443431443437443453443467443489443501443533443543443551443561443563443567443587443591443603443609443629443659443687443689443701443711443731443749443753443759443761443771443777443791443837443851443867443869443873443879443881443893443899443909443917443939443941443953443983443987443999444001444007444029444043444047444079444089444109444113444121444127444131444151444167444173444179444181444187444209444253444271444281444287444289444293444307444341444343444347444349444401444403444421444443444449444461444463444469444473444487444517444523444527444529444539444547444553444557444569444589444607444623444637444641444649444671444677444701444713444739444767444791444793444803444811444817444833444841444859444863444869444877444883444887444893444901444929444937444953444967444971444979445001445019445021445031445033445069445087445091445097445103445141445157445169445183445187445199445229445261445271445279445283445297445307445321445339445363445427445433445447445453445463445477445499445507445537445541445567445573445583445589445597445619445631445633445649445657445691445699445703445741445747445769445771445789445799445807445829445847445853445871445877445883445891445931445937445943445967445969446003446009446041446053446081446087446111446123446129446141446179446189446191446197446221446227446231446261446263446273446279446293446309446323446333446353446363446387446389446399446401446417446441446447446461446473446477446503446533446549446561446569446597446603446609446647446657446713446717446731446753446759446767446773446819446827446839446863446881446891446893446909446911446921446933446951446969446983447001447011447019447053447067447079447101447107447119447133447137447173447179447193447197447211447217447221447233447247447257447259447263447311447319447323447331447353447401447409447427447439447443447449447451447463447467447481447509447521447527447541447569447571447611447617447637447641447677447683447701447703447743447749447757447779447791447793447817447823447827447829447841447859447877447883447893447901447907447943447961447983447991448003448013448027448031448057448067448073448093448111448121448139448141448157448159448169448177448187448193448199448207448241448249448303448309448313448321448351448363448367448373448379448387448397448421448451448519448531448561448597448607448627448631448633448667448687448697448703448727448733448741448769448793448801448807448829448843448853448859448867448871448873448879448883448907448927448939448969448993448997448999449003449011449051449077449083449093449107449117449129449131449149449153449161449171449173449201449203449209449227449243449249449261449263449269449287449299449303449311449321449333449347449353449363449381449399449411449417449419449437449441449459449473449543449549449557449563449567449569449591449609449621449629449653449663449671449677449681449689449693449699449741449759449767449773449783449797449807449821449833449851449879449921449929449941449951449959449963449971449987449989450001450011450019450029450067450071450077450083450101450103450113450127450137450161450169450193450199450209450217450223450227450239450257450259450277450287450293450299450301450311450343450349450361450367450377450383450391450403450413450421450431450451450473450479450481450487450493450503450529450533450557450563450581450587450599450601450617450641450643450649450677450691450707450719450727450761450767450787450797450799450803450809450811450817450829450839450841450847450859450881450883450887450893450899450913450917450929450943450949450971450991450997451013451039451051451057451069451093451097451103451109451159451177451181451183451201451207451249451277451279451301451303451309451313451331451337451343451361451387451397451411451439451441451481451499451519451523451541451547451553451579451601451609451621451637451657451663451667451669451679451681451691451699451709451723451747451753451771451783451793451799451823451831451837451859451873451879451897451901451903451909451921451933451937451939451961451967451987452009452017452027452033452041452077452083452087452131452159452161452171452191452201452213452227452233452239452269452279452293452297452329452363452377452393452401452443452453452497452519452521452531452533452537452539452549452579452587452597452611452629452633452671452687452689452701452731452759452773452797452807452813452821452831452857452869452873452923452953452957452983452989453023453029453053453073453107453119453133453137453143453157453161453181453197453199453209453217453227453239453247453269453289453293453301453311453317453329453347453367453371453377453379453421453451453461453527453553453559453569453571453599453601453617453631453637453641453643453659453667453671453683453703453707453709453737453757453797453799453823453833453847453851453877453889453907453913453923453931453949453961453977453983453991454009454021454031454033454039454061454063454079454109454141454151454159454183454199454211454213454219454229454231454247454253454277454297454303454313454331454351454357454361454379454387454409454417454451454453454483454501454507454513454541454543454547454577454579454603454609454627454637454673454679454709454711454721454723454759454763454777454799454823454843454847454849454859454889454891454907454919454921454931454943454967454969454973454991455003455011455033455047455053455093455099455123455149455159455167455171455177455201455219455227455233455237455261455263455269455291455309455317455321455333455339455341455353455381455393455401455407455419455431455437455443455461455471455473455479455489455491455513455527455531455537455557455573455579455597455599455603455627455647455659455681455683455687455701455711455717455737455761455783455789455809455827455831455849455863455881455899455921455933455941455953455969455977455989455993455999456007456013456023456037456047456061456091456107456109456119456149456151456167456193456223456233456241456283456293456329456349456353456367456377456403456409456427456439456451456457456461456499456503456517456523456529456539456553456557456559456571456581456587456607456611456613456623456641456647456649456653456679456683456697456727456737456763456767456769456791456809456811456821456871456877456881456899456901456923456949456959456979456991457001457003457013457021457043457049457057457087457091457097457099457117457139457151457153457183457189457201457213457229457241457253457267457271457277457279457307457319457333457339457363457367457381457393457397457399457403457411457421457433457459457469457507457511457517457547457553457559457571457607457609457621457643457651457661457669457673457679457687457697457711457739457757457789457799457813457817457829457837457871457889457903457913457943457979457981457987458009458027458039458047458053458057458063458069458119458123458173458179458189458191458197458207458219458239458309458317458323458327458333458357458363458377458399458401458407458449458477458483458501458531458533458543458567458569458573458593458599458611458621458629458639458651458663458669458683458701458719458729458747458789458791458797458807458819458849458863458879458891458897458917458921458929458947458957458959458963458971458977458981458987458993459007459013459023459029459031459037459047459089459091459113459127459167459169459181459209459223459229459233459257459271459293459301459313459317459337459341459343459353459373459377459383459397459421459427459443459463459467459469459479459509459521459523459593459607459611459619459623459631459647459649459671459677459691459703459749459763459791459803459817459829459841459847459883459913459923459929459937459961460013460039460051460063460073460079460081460087460091460099460111460127460147460157460171460181460189460211460217460231460247460267460289460297460301460337460349460373460379460387460393460403460409460417460451460463460477460531460543460561460571460589460609460619460627460633460637460643460657460673460697460709460711460721460771460777460787460793460813460829460841460843460871460891460903460907460913460919460937460949460951460969460973460979460981460987460991461009461011461017461051461053461059461093461101461119461143461147461171461183461191461207461233461239461257461269461273461297461299461309461317461323461327461333461359461381461393461407461411461413461437461441461443461467461479461507461521461561461569461581461599461603461609461627461639461653461677461687461689461693461707461717461801461803461819461843461861461887461891461917461921461933461957461971461977461983462013462041462067462073462079462097462103462109462113462131462149462181462191462199462221462239462263462271462307462311462331462337462361462373462377462401462409462419462421462437462443462467462481462491462493462499462529462541462547462557462569462571462577462589462607462629462641462643462653462659462667462673462677462697462713462719462727462733462739462773462827462841462851462863462871462881462887462899462901462911462937462947462953462983463003463031463033463093463103463157463181463189463207463213463219463231463237463247463249463261463283463291463297463303463313463319463321463339463343463363463387463399463433463447463451463453463457463459463483463501463511463513463523463531463537463549463579463613463627463633463643463649463663463679463693463711463717463741463747463753463763463781463787463807463823463829463831463849463861463867463873463889463891463907463919463921463949463963463973463987463993464003464011464021464033464047464069464081464089464119464129464131464137464141464143464171464173464197464201464213464237464251464257464263464279464281464291464309464311464327464351464371464381464383464413464419464437464447464459464467464479464483464521464537464539464549464557464561464587464591464603464617464621464647464663464687464699464741464747464749464753464767464771464773464777464801464803464809464813464819464843464857464879464897464909464917464923464927464939464941464951464953464963464983464993464999465007465011465013465019465041465061465067465071465077465079465089465107465119465133465151465161465163465167465169465173465187465209465211465259465271465277465281465293465299465317465319465331465337465373465379465383465407465419465433465463465469465523465529465541465551465581465587465611465631465643465649465659465679465701465721465739465743465761465781465797465799465809465821465833465841465887465893465901465917465929465931465947465977465989466009466019466027466033466043466061466069466073466079466087466091466121466139466153466171466181466183466201466243466247466261466267466273466283466303466321466331466339466357466369466373466409466423466441466451466483466517466537466547466553466561466567466573466579466603466619466637466649466651466673466717466723466729466733466747466751466777466787466801466819466853466859466897466909466913466919466951466957466997467003467009467017467021467063467081467083467101467119467123467141467147467171467183467197467209467213467237467239467261467293467297467317467329467333467353467371467399467417467431467437467447467471467473467477467479467491467497467503467507467527467531467543467549467557467587467591467611467617467627467629467633467641467651467657467669467671467681467689467699467713467729467737467743467749467773467783467813467827467833467867467869467879467881467893467897467899467903467927467941467953467963467977468001468011468019468029468049468059468067468071468079468107468109468113468121468133468137468151468157468173468187468191468199468239468241468253468271468277468289468319468323468353468359468371468389468421468439468451468463468473468491468493468499468509468527468551468557468577468581468593468599468613468619468623468641468647468653468661468667468683468691468697468703468709468719468737468739468761468773468781468803468817468821468841468851468859468869468883468887468889468893468899468913468953468967468973468983469009469031469037469069469099469121469127469141469153469169469193469207469219469229469237469241469253469267469279469283469303469321469331469351469363469367469369469379469397469411469429469439469457469487469501469529469541469543469561469583469589469613469627469631469649469657469673469687469691469717469723469747469753469757469769469787469793469801469811469823469841469849469877469879469891469907469919469939469957469969469979469993470021470039470059470077470081470083470087470089470131470149470153470161470167470179470201470207470209470213470219470227470243470251470263470279470297470299470303470317470333470347470359470389470399470411470413470417470429470443470447470453470461470471470473470489470501470513470521470531470539470551470579470593470597470599470609470621470627470647470651470653470663470669470689470711470719470731470749470779470783470791470819470831470837470863470867470881470887470891470903470927470933470941470947470957470959470993470999471007471041471061471073471089471091471101471137471139471161471173471179471187471193471209471217471241471253471259471277471281471283471299471301471313471353471389471391471403471407471439471451471467471481471487471503471509471521471533471539471553471571471589471593471607471617471619471641471649471659471671471673471677471683471697471703471719471721471749471769471781471791471803471817471841471847471853471871471893471901471907471923471929471931471943471949471959471997472019472027472051472057472063472067472103472111472123472127472133472139472151472159472163472189472193472247472249472253472261472273472289472301472309472319472331472333472349472369472391472393472399472411472421472457472469472477472523472541472543472559472561472573472597472631472639472643472669472687472691472697472709472711472721472741472751472763472793472799472817472831472837472847472859472883472907472909472921472937472939472963472993473009473021473027473089473101473117473141473147473159473167473173473191473197473201473203473219473227473257473279473287473293473311473321473327473351473353473377473381473383473411473419473441473443473453473471473477473479473497473503473507473513473519473527473531473533473549473579473597473611473617473633473647473659473719473723473729473741473743473761473789473833473839473857473861473867473887473899473911473923473927473929473939473951473953473971473981473987473999474017474029474037474043474049474059474073474077474101474119474127474137474143474151474163474169474197474211474223474241474263474289474307474311474319474337474343474347474359474379474389474391474413474433474437474443474479474491474497474499474503474533474541474547474557474569474571474581474583474619474629474647474659474667474671474707474709474737474751474757474769474779474787474809474811474839474847474857474899474907474911474917474923474931474937474941474949474959474977474983475037475051475073475081475091475093475103475109475141475147475151475159475169475207475219475229475243475271475273475283475289475297475301475327475331475333475351475367475369475379475381475403475417475421475427475429475441475457475469475483475511475523475529475549475583475597475613475619475621475637475639475649475669475679475681475691475693475697475721475729475751475753475759475763475777475789475793475807475823475831475837475841475859475877475879475889475897475903475907475921475927475933475957475973475991475997476009476023476027476029476039476041476059476081476087476089476101476107476111476137476143476167476183476219476233476237476243476249476279476299476317476347476351476363476369476381476401476407476419476423476429476467476477476479476507476513476519476579476587476591476599476603476611476633476639476647476659476681476683476701476713476719476737476743476753476759476783476803476831476849476851476863476869476887476891476911476921476929476977476981476989477011477013477017477019477031477047477073477077477091477131477149477163477209477221477229477259477277477293477313477317477329477341477359477361477383477409477439477461477469477497477511477517477523477539477551477553477557477571477577477593477619477623477637477671477677477721477727477731477739477767477769477791477797477809477811477821477823477839477847477857477863477881477899477913477941477947477973477977477991478001478039478063478067478069478087478099478111478129478139478157478169478171478189478199478207478213478241478243478253478259478271478273478321478339478343478351478391478399478403478411478417478421478427478433478441478451478453478459478481478483478493478523478531478571478573478579478589478603478627478631478637478651478679478697478711478727478729478739478741478747478763478769478787478801478811478813478823478831478843478853478861478871478879478897478901478913478927478931478937478943478963478967478991478999479023479027479029479041479081479131479137479147479153479189479191479201479209479221479231479239479243479263479267479287479299479309479317479327479357479371479377479387479419479429479431479441479461479473479489479497479509479513479533479543479561479569479581479593479599479623479629479639479701479749479753479761479771479777479783479797479813479821479833479839479861479879479881479891479903479909479939479951479953479957479971480013480017480019480023480043480047480049480059480061480071480091480101480107480113480133480143480157480167480169480203480209480287480299480317480329480341480343480349480367480373480379480383480391480409480419480427480449480451480461480463480499480503480509480517480521480527480533480541480553480563480569480583480587480647480661480707480713480731480737480749480761480773480787480803480827480839480853480881480911480919480929480937480941480959480967480979480989481001481003481009481021481043481051481067481073481087481093481097481109481123481133481141481147481153481157481171481177481181481199481207481211481231481249481297481301481303481307481343481363481373481379481387481409481417481433481447481469481489481501481513481531481549481571481577481589481619481633481639481651481667481673481681481693481697481699481721481751481753481769481787481801481807481813481837481843481847481849481861481867481879481883481909481939481963481997482017482021482029482033482039482051482071482093482099482101482117482123482179482189482203482213482227482231482233482243482263482281482309482323482347482351482359482371482387482393482399482401482407482413482423482437482441482483482501482507482509482513482519482527482539482569482593482597482621482627482633482641482659482663482683482687482689482707482711482717482719482731482743482753482759482767482773482789482803482819482827482837482861482863482873482897482899482917482941482947482957482971483017483031483061483071483097483127483139483163483167483179483209483211483221483229483233483239483247483251483281483289483317483323483337483347483367483377483389483397483407483409483433483443483467483481483491483499483503483523483541483551483557483563483577483611483619483629483643483649483671483697483709483719483727483733483751483757483761483767483773483787483809483811483827483829483839483853483863483869483883483907483929483937483953483971483991484019484027484037484061484067484079484091484111484117484123484129484151484153484171484181484193484201484207484229484243484259484283484301484303484327484339484361484369484373484397484411484417484439484447484457484459484487484489484493484531484543484577484597484607484609484613484621484639484643484691484703484727484733484751484763484769484777484787484829484853484867484927484951484987484999485021485029485041485053485059485063485081485101485113485123485131485137485161485167485171485201485207485209485263485311485347485351485363485371485383485389485411485417485423485437485447485479485497485509485519485543485567485587485593485603485609485647485657485671485689485701485717485729485731485753485777485819485827485831485833485893485899485909485923485941485959485977485993486023486037486041486043486053486061486071486091486103486119486133486139486163486179486181486193486203486221486223486247486281486293486307486313486323486329486331486341486349486377486379486389486391486397486407486433486443486449486481486491486503486509486511486527486539486559486569486583486589486601486617486637486641486643486653486667486671486677486679486683486697486713486721486757486767486769486781486797486817486821486833486839486869486907486923486929486943486947486949486971486977486991487007487013487021487049487051487057487073487079487093487099487111487133487177487183487187487211487213487219487247487261487283487303487307487313487349487363487381487387487391487397487423487427487429487447487457487463487469487471487477487481487489487507487561487589487601487603487607487637487649487651487657487681487691487703487709487717487727487733487741487757487769487783487789487793487811487819487829487831487843487873487889487891487897487933487943487973487979487997488003488009488011488021488051488057488069488119488143488149488153488161488171488197488203488207488209488227488231488233488239488249488261488263488287488303488309488311488317488321488329488333488339488347488353488381488399488401488407488417488419488441488459488473488503488513488539488567488573488603488611488617488627488633488639488641488651488687488689488701488711488717488723488729488743488749488759488779488791488797488821488827488833488861488879488893488897488909488921488947488959488981488993489001489011489019489043489053489061489101489109489113489127489133489157489161489179489191489197489217489239489241489257489263489283489299489329489337489343489361489367489389489407489409489427489431489439489449489457489479489487489493489529489539489551489553489557489571489613489631489653489659489673489677489679489689489691489733489743489761489791489793489799489803489817489823489833489847489851489869489871489887489901489911489913489941489943489959489961489977489989490001490003490019490031490033490057490097490103490111490117490121490151490159490169490183490201490207490223490241490247490249490267490271490277490283490309490313490339490367490393490417490421490453490459490463490481490493490499490519490537490541490543490549490559490571490573490577490579490591490619490627490631490643490661490663490697490733490741490769490771490783490829490837490849490859490877490891490913490921490927490937490949490951490957490967490969490991490993491003491039491041491059491081491083491129491137491149491159491167491171491201491213491219491251491261491273491279491297491299491327491329491333491339491341491353491357491371491377491417491423491429491461491483491489491497491501491503491527491531491537491539491581491591491593491611491627491633491639491651491653491669491677491707491719491731491737491747491773491783491789491797491819491833491837491851491857491867491873491899491923491951491969491977491983492007492013492017492029492047492053492059492061492067492077492083492103492113492227492251492253492257492281492293492299492319492377492389492397492403492409492413492421492431492463492467492487492491492511492523492551492563492587492601492617492619492629492631492641492647492659492671492673492707492719492721492731492757492761492763492769492781492799492839492853492871492883492893492901492911492967492979493001493013493021493027493043493049493067493093493109493111493121493123493127493133493139493147493159493169493177493193493201493211493217493219493231493243493249493277493279493291493301493313493333493351493369493393493397493399493403493433493447493457493463493481493523493531493541493567493573493579493583493607493621493627493643493657493693493709493711493721493729493733493747493777493793493807493811493813493817493853493859493873493877493897493919493931493937493939493967493973493979493993494023494029494041494051494069494077494083494093494101494107494129494141494147494167494191494213494237494251494257494267494269494281494287494317494327494341494353494359494369494381494383494387494407494413494441494443494471494497494519494521494539494561494563494567494587494591494609494617494621494639494647494651494671494677494687494693494699494713494719494723494731494737494743494749494759494761494783494789494803494843494849494873494899494903494917494927494933494939494959494987495017495037495041495043495067495071495109495113495119495133495139495149495151495161495181495199495211495221495241495269495277495289495301495307495323495337495343495347495359495361495371495377495389495401495413495421495433495437495449495457495461495491495511495527495557495559495563495569495571495587495589495611495613495617495619495629495637495647495667495679495701495707495713495749495751495757495769495773495787495791495797495799495821495827495829495851495877495893495899495923495931495947495953495959495967495973495983496007496019496039496051496063496073496079496123496127496163496187496193496211496229496231496259496283496289496291496297496303496313496333496339496343496381496399496427496439496453496459496471496477496481496487496493496499496511496549496579496583496609496631496669496681496687496703496711496733496747496763496789496813496817496841496849496871496877496889496891496897496901496913496919496949496963496997496999497011497017497041497047497051497069497093497111497113497117497137497141497153497171497177497197497239497257497261497269497279497281497291497297497303497309497323497339497351497389497411497417497423497449497461497473497479497491497501497507497509497521497537497551497557497561497579497587497597497603497633497659497663497671497677497689497701497711497719497729497737497741497771497773497801497813497831497839497851497867497869497873497899497929497957497963497969497977497989497993497999498013498053498061498073498089498101498103498119498143498163498167498181498209498227498257498259498271498301498331498343498361498367498391498397498401498403498409498439498461498467498469498493498497498521498523498527498551498557498577498583498599498611498613498643498647498653498679498689498691498733498739498749498761498767498779498781498787498791498803498833498857498859498881498907498923498931498937498947498961498973498977498989499021499027499033499039499063499067499099499117499127499129499133499139499141499151499157499159499181499183499189499211499229499253499267499277499283499309499321499327499349499361499363499391499397499403499423499439499459499481499483499493499507499519499523499549499559499571499591499601499607499621499633499637499649499661499663499669499673499679499687499691499693499711499717499729499739499747499781499787499801499819499853499879499883499897499903499927499943499957499969499973499979500009500029500041500057500069500083500107500111500113500119500153500167500173500177500179500197500209500231500233500237500239500249500257500287500299500317500321500333500341500363500369500389500393500413500417500431500443500459500471500473500483500501500509500519500527500567500579500587500603500629500671500677500693500699500713500719500723500729500741500777500791500807500809500831500839500861500873500881500887500891500909500911500921500923500933500947500953500957500977501001501013501019501029501031501037501043501077501089501103501121501131501133501139501157501173501187501191501197501203501209501217501223501229501233501257501271501287501299501317501341501343501367501383501401501409501419501427501451501463501493501503501511501563501577501593501601501617501623501637501659501691501701501703501707501719501731501769501779501803501817501821501827501829501841501863501889501911501931501947501953501967501971501997502001502013502039502043502057502063502079502081502087502093502121502133502141502171502181502217502237502247502259502261502277502301502321502339502393502409502421502429502441502451502487502499502501502507502517502543502549502553502591502597502613502631502633502643502651502669502687502699502703502717502729502769502771502781502787502807502819502829502841502847502861502883502919502921502937502961502973503003503017503039503053503077503123503131503137503147503159503197503207503213503227503231503233503249503267503287503297503303503317503339503351503359503369503381503383503389503407503413503423503431503441503453503483503501503543503549503551503563503593503599503609503611503621503623503647503653503663503707503717503743503753503771503777503779503791503803503819503821503827503851503857503869503879503911503927503929503939503947503959503963503969503983503989504001504011504017504047504061504073504103504121504139504143504149504151504157504181504187504197504209504221504247504269504289504299504307504311504323504337504349504353504359504377504379504389504403504457504461504473504479504521504523504527504547504563504593504599504607504617504619504631504661504667504671504677504683504727504767504787504797504799504817504821504851504853504857504871504877504893504901504929504937504943504947504953504967504983504989504991505027505031505033505049505051505061505067505073505091505097505111505117505123505129505139505157505159505181505187505201505213505231505237505277505279505283505301505313505319505321505327505339505357505367505369505399505409505411505429505447505459505469505481505493505501505511505513505523505537505559505573505601505607505613505619505633505639505643505657505663505669505691505693505709505711505727505759505763505777505781505811505819505823505867505871505877505907505919505927505949505961505969505979506047506071506083506101506113506119506131506147506171506173506183506201506213506251506263506269506281506291506327506329506333506339506347506351506357506381506393506417506423506449506459506461506479506491506501506507506531506533506537506551506563506573506591506593506599506609506629506647506663506683506687506689506699506729506731506743506773506783506791506797506809506837506843506861506873506887506893506899506903506911506929506941506963506983506993506999507029507049507071507077507079507103507109507113507119507137507139507149507151507163507193507197507217507289507301507313507317507329507347507349507359507361507371507383507401507421507431507461507491507497507499507503507523507557507571507589507593507599507607507631507641507667507673507691507697507713507719507743507757507779507781507797507803507809507821507827507839507883507901507907507917507919507937507953507961507971507979508009508019508021508033508037508073508087508091508097508103508129508159508171508187508213508223508229508237508243508259508271508273508297508301508327508331508349508363508367508373508393508433508439508451508471508477508489508499508513508517508531508549508559508567508577508579508583508619508621508637508643508661508693508709508727508771508789508799508811508817508841508847508867508901508903508909508913508919508931508943508951508957508961508969508973508987509023509027509053509063509071509087509101509123509137509147509149509203509221509227509239509263509281509287509293509297509317509329509359509363509389509393509413509417509429509441509449509477509513509521509543509549509557509563509569509573509581509591509603509623509633509647509653509659509681509687509689509693509699509723509731509737509741509767509783509797509801509833509837509843509863509867509879509909509911509921509939509947509959509963509989510007510031510047510049510061510067510073510077510079510089510101510121510127510137510157510179510199510203510217510227510233510241510247510253510271510287510299510311510319510331510361510379510383510401510403510449510451510457510463510481510529510551510553510569510581510583510589510611510613510617510619510677510683510691510707510709510751510767510773510793510803510817510823510827510847510889510907510919510931510941510943510989511001511013511019511033511039511057511061511087511109511111511123511151511153511163511169511171511177511193511201511211511213511223511237511243511261511279511289511297511327511333511337511351511361511387511391511409511417511439511447511453511457511463511477511487511507511519511523511541511549511559511573511579511583511591511603511627511631511633511669511691511703511711511723511757511787511793511801511811511831511843511859511867511873511891511897511909511933511939511961511963511991511997512009512011512021512047512059512093512101512137512147512167512207512249512251512269512287512311512321512333512353512389512419512429512443512467512497512503512507512521512531512537512543512569512573512579512581512591512593512597512609512621512641512657512663512671512683512711512713512717512741512747512761512767512779512797512803512819512821512843512849512891512899512903512917512921512927512929512959512977512989512999513001513013513017513031513041513047513053513059513067513083513101513103513109513131513137513157513167513169513173513203513239513257513269513277513283513307513311513313513319513341513347513353513367513371513397513407513419513427513431513439513473513479513481513509513511513529513533513593513631513641513649513673513679513683513691513697513719513727513731513739513749513761513767513769513781513829513839513841513871513881513899513917513923513937513943513977513991514001514009514013514021514049514051514057514061514079514081514093514103514117514123514127514147514177514187514201514219514229514243514247514249514271514277514289514309514313514333514343514357514361514379514399514417514429514433514453514499514513514519514523514529514531514543514561514571514621514637514639514643514649514651514669514681514711514733514739514741514747514751514757514769514783514793514819514823514831514841514847514853514859514867514873514889514903514933514939514949514967515041515087515089515111515143515149515153515173515191515227515231515233515237515279515293515311515323515351515357515369515371515377515381515401515429515477515507515519515539515563515579515587515597515611515621515639515651515653515663515677515681515687515693515701515737515741515761515771515773515777515783515803515813515839515843515857515861515873515887515917515923515929515941515951515969515993516017516023516049516053516077516091516127516151516157516161516163516169516179516193516199516209516223516227516233516247516251516253516277516283516293516319516323516349516359516361516371516377516391516407516421516431516433516437516449516457516469516493516499516517516521516539516541516563516587516589516599516611516617516619516623516643516653516673516679516689516701516709516713516721516727516757516793516811516821516829516839516847516871516877516883516907516911516931516947516949516959516973516977516979516991517003517043517061517067517073517079517081517087517091517129517151517169517177517183517189517207517211517217517229517241517243517249517261517267517277517289517303517337517343517367517373517381517393517399517403517411517417517457517459517469517471517481517487517499517501517507517511517513517547517549517553517571517577517589517597517603517609517613517619517637517639517711517717517721517729517733517739517747517817517823517831517861517873517877517901517919517927517931517949517967517981517991517999518017518047518057518059518083518099518101518113518123518129518131518137518153518159518171518179518191518207518209518233518237518239518249518261518291518299518311518327518341518387518389518411518417518429518431518447518467518471518473518509518521518533518543518579518587518597518611518621518657518689518699518717518729518737518741518743518747518759518761518767518779518801518803518807518809518813518831518863518867518893518911518933518953518981518983518989519011519031519037519067519083519089519091519097519107519119519121519131519151519161519193519217519227519229519247519257519269519283519287519301519307519349519353519359519371519373519383519391519413519427519433519457519487519499519509519521519523519527519539519551519553519577519581519587519611519619519643519647519667519683519691519703519713519733519737519769519787519793519797519803519817519863519881519889519907519917519919519923519931519943519947519971519989519997520019520021520031520043520063520067520073520103520111520123520129520151520193520213520241520279520291520297520307520309520313520339520349520357520361520363520369520379520381520393520409520411520423520427520433520447520451520529520547520549520567520571520589520607520609520621520631520633520649520679520691520699520703520717520721520747520759520763520787520813520837520841520853520867520889520913520921520943520957520963520967520969520981521009521021521023521039521041521047521051521063521107521119521137521153521161521167521173521177521179521201521231521243521251521267521281521299521309521317521329521357521359521363521369521377521393521399521401521429521447521471521483521491521497521503521519521527521533521537521539521551521557521567521581521603521641521657521659521669521671521693521707521723521743521749521753521767521777521789521791521809521813521819521831521861521869521879521881521887521897521903521923521929521981521993521999522017522037522047522059522061522073522079522083522113522127522157522161522167522191522199522211522227522229522233522239522251522259522281522283522289522317522323522337522371522373522383522391522409522413522439522449522469522479522497522517522521522523522541522553522569522601522623522637522659522661522673522677522679522689522703522707522719522737522749522757522761522763522787522811522827522829522839522853522857522871522881522883522887522919522943522947522959522961522989523007523021523031523049523093523097523109523129523169523177523207523213523219523261523297523307523333523349523351523357523387523403523417523427523433523459523463523487523489523493523511523519523541523543523553523571523573523577523597523603523631523637523639523657523667523669523673523681523717523729523741523759523763523771523777523793523801523829523847523867523877523903523907523927523937523949523969523987523997524047524053524057524063524071524081524087524099524113524119524123524149524171524189524197524201524203524219524221524231524243524257524261524269524287524309524341524347524351524353524369524387524389524411524413524429524453524497524507524509524519524521524591524593524599524633524669524681524683524701524707524731524743524789524801524803524827524831524857524863524869524873524893524899524921524933524939524941524947524957524959524963524969524971524981524983524999525001525013525017525029525043525101525127525137525143525157525163525167525191525193525199525209525221525241525247525253525257525299525313525353525359525361525373525377525379525391525397525409525431525433525439525457525461525467525491525493525517525529525533525541525571525583525593525599525607525641525649525671525677525697525709525713525719525727525731525739525769525773525781525809525817525839525869525871525887525893525913525923525937525947525949525953525961525979525983526027526037526049526051526063526067526069526073526087526117526121526139526157526159526189526193526199526213526223526231526249526271526283526289526291526297526307526367526373526381526387526391526397526423526429526441526453526459526483526499526501526511526531526543526571526573526583526601526619526627526633526637526649526651526657526667526679526681526703526709526717526733526739526741526759526763526777526781526829526831526837526853526859526871526909526913526931526937526943526951526957526963526993526997527053527057527063527069527071527081527099527123527129527143527159527161527173527179527203527207527209527237527251527273527281527291527327527333527347527353527377527381527393527399527407527411527419527441527447527453527489527507527533527557527563527581527591527599527603527623527627527633527671527699527701527729527741527749527753527789527803527809527819527843527851527869527881527897527909527921527929527941527981527983527987527993528001528013528041528043528053528091528097528107528127528131528137528163528167528191528197528217528223528247528263528289528299528313528317528329528373528383528391528401528403528413528419528433528469528487528491528509528511528527528559528611528623528629528631528659528667528673528679528691528707528709528719528763528779528791528799528811528821528823528833528863528877528881528883528911528929528947528967528971528973528991529003529007529027529033529037529043529049529051529097529103529117529121529127529129529153529157529181529183529213529229529237529241529259529271529273529301529307529313529327529343529349529357529381529393529411529421529423529471529489529513529517529519529531529547529577529579529603529619529637529649529657529673529681529687529691529693529709529723529741529747529751529807529811529813529819529829529847529871529927529933529939529957529961529973529979529981529987529999530017530021530027530041530051530063530087530093530129530137530143530177530183530197530203530209530227530237530249530251530261530267530279530293530297530303530329530333530339530353530359530389530393530401530429530443530447530501530507530513530527530531530533530539530549530567530597530599530603530609530641530653530659530669530693530701530711530713530731530741530743530753530767530773530797530807530833530837530843530851530857530861530869530897530911530947530969530977530983530989531017531023531043531071531079531101531103531121531133531143531163531169531173531197531203531229531239531253531263531281531287531299531331531337531343531347531353531359531383531457531481531497531521531547531551531569531571531581531589531611531613531623531631531637531667531673531689531701531731531793531799531821531823531827531833531841531847531857531863531871531877531901531911531919531977531983531989531997532001532009532027532033532061532069532093532099532141532153532159532163532183532187532193532199532241532249532261532267532277532283532307532313532327532331532333532349532373532379532391532403532417532421532439532447532451532453532489532501532523532529532531532537532547532561532601532603532607532619532621532633532639532663532669532687532691532709532733532739532751532757532771532781532783532789532801532811532823532849532853532867532907532919532949532951532981532993532999533003533009533011533033533051533053533063533077533089533111533129533149533167533177533189533191533213533219533227533237533249533257533261533263533297533303533317533321533327533353533363533371533389533399533413533447533453533459533509533543533549533573533581533593533633533641533671533693533711533713533719533723533737533747533777533801533809533821533831533837533857533879533887533893533909533921533927533959533963533969533971533989533993533999534007534013534019534029534043534047534049534059534073534077534091534101534113534137534167534173534199534203534211534229534241534253534283534301534307534311534323534329534341534367534371534403534407534431534439534473534491534511534529534553534571534577534581534601534607534617534629534631534637534647534649534659534661534671534697534707534739534799534811534827534839534841534851534857534883534889534913534923534931534943534949534971535013535019535033535037535061535099535103535123535133535151535159535169535181535193535207535219535229535237535243535273535303535319535333535349535351535361535387535391535399535481535487535489535499535511535523535529535547535571535573535589535607535609535627535637535663535669535673535679535697535709535727535741535751535757535771535783535793535811535849535859535861535879535919535937535939535943535957535967535973535991535999536017536023536051536057536059536069536087536099536101536111536141536147536149536189536191536203536213536219536227536233536243536267536273536279536281536287536293536311536323536353536357536377536399536407536423536441536443536447536449536453536461536467536479536491536509536513536531536533536561536563536593536609536621536633536651536671536677536687536699536717536719536729536743536749536771536773536777536779536791536801536803536839536849536857536867536869536891536909536917536923536929536933536947536953536971536989536999537001537007537011537023537029537037537041537067537071537079537091537127537133537143537157537169537181537191537197537221537233537241537269537281537287537307537331537343537347537373537379537401537403537413537497537527537547537569537583537587537599537611537637537661537673537679537703537709537739537743537749537769537773537781537787537793537811537841537847537853537877537883537899537913537919537941537991538001538019538049538051538073538079538093538117538121538123538127538147538151538157538159538163538199538201538247538249538259538267538283538297538301538303538309538331538333538357538367538397538399538411538423538457538471538481538487538511538513538519538523538529538553538561538567538579538589538597538621538649538651538697538709538711538721538723538739538751538763538771538777538789538799538801538817538823538829538841538871538877538921538927538931538939538943538987539003539009539039539047539089539093539101539107539111539113539129539141539153539159539167539171539207539219539233539237539261539267539269539293539303539309539311539321539323539339539347539351539389539401539447539449539479539501539503539507539509539533539573539621539629539633539639539641539653539663539677539687539711539713539723539729539743539761539783539797539837539839539843539849539863539881539897539899539921539947539993540041540061540079540101540119540121540139540149540157540167540173540179540181540187540203540217540233540251540269540271540283540301540307540343540347540349540367540373540377540383540389540391540433540437540461540469540509540511540517540539540541540557540559540577540587540599540611540613540619540629540677540679540689540691540697540703540713540751540769540773540779540781540803540809540823540851540863540871540877540901540907540961540989541001541007541027541049541061541087541097541129541133541141541153541181541193541201541217541231541237541249541267541271541283541301541309541339541349541361541363541369541381541391541417541439541447541469541483541507541511541523541529541531541537541543541547541549541571541577541579541589541613541631541657541661541669541693541699541711541721541727541759541763541771541777541781541799541817541831541837541859541889541901541927541951541967541987541991541993541999542021542023542027542053542063542071542081542083542093542111542117542119542123542131542141542149542153542167542183542189542197542207542219542237542251542261542263542281542293542299542323542371542401542441542447542461542467542483542489542497542519542533542537542539542551542557542567542579542587542599542603542683542687542693542713542719542723542747542761542771542783542791542797542821542831542837542873542891542911542921542923542933542939542947542951542981542987542999543017543019543029543061543097543113543131543139543143543149543157543161543163543187543203543217543223543227543233543241543253543259543281543287543289543299543307543311543313543341543349543353543359543379543383543407543427543463543497543503543509543539543551543553543593543601543607543611543617543637543659543661543671543679543689543703543707543713543769543773543787543791543793543797543811543827543841543853543857543859543871543877543883543887543889543901543911543929543967543971543997544001544007544009544013544021544031544097544099544109544123544129544133544139544171544177544183544199544223544259544273544277544279544367544373544399544403544429544451544471544477544487544501544513544517544543544549544601544613544627544631544651544667544699544717544721544723544727544757544759544771544781544793544807544813544837544861544877544879544883544889544897544903544919544927544937544961544963544979545023545029545033545057545063545087545089545093545117545131545141545143545161545189545203545213545231545239545257545267545291545329545371545387545429545437545443545449545473545477545483545497545521545527545533545543545549545551545579545599545609545617545621545641545647545651545663545711545723545731545747545749545759545773545789545791545827545843545863545873545893545899545911545917545929545933545939545947545959546001546017546019546031546047546053546067546071546097546101546103546109546137546149546151546173546179546197546211546233546239546241546253546263546283546289546317546323546341546349546353546361546367546373546391546461546467546479546509546523546547546569546583546587546599546613546617546619546631546643546661546671546677546683546691546709546719546731546739546781546841546859546863546869546881546893546919546937546943546947546961546967546977547007547021547037547061547087547093547097547103547121547133547139547171547223547229547237547241547249547271547273547291547301547321547357547361547363547369547373547387547397547399547411547441547453547471547483547487547493547499547501547513547529547537547559547567547577547583547601547609547619547627547639547643547661547663547681547709547727547741547747547753547763547769547787547817547819547823547831547849547853547871547889547901547909547951547957547999548003548039548059548069548083548089548099548117548123548143548153548189548201548213548221548227548239548243548263548291548309548323548347548351548363548371548393548399548407548417548423548441548453548459548461548489548501548503548519548521548533548543548557548567548579548591548623548629548657548671548677548687548693548707548719548749548753548761548771548783548791548827548831548833548837548843548851548861548869548893548897548903548909548927548953548957548963549001549011549013549019549023549037549071549089549091549097549121549139549149549161549163549167549169549193549203549221549229549247549257549259549281549313549319549323549331549379549391549403549421549431549443549449549481549503549509549511549517549533549547549551549553549569549587549589549607549623549641549643549649549667549683549691549701549707549713549719549733549737549739549749549751549767549817549833549839549863549877549883549911549937549943549949549977549979550007550009550027550049550061550063550073550111550117550127550129550139550163550169550177550181550189550211550213550241550267550279550283550289550309550337550351550369550379550427550439550441550447550457550469550471550489550513550519550531550541550553550577550607550609550621550631550637550651550657550661550663550679550691550703550717550721550733550757550763550789550801550811550813550831550841550843550859550861550903550909550937550939550951550961550969550973550993550997551003551017551027551039551059551063551069551093551099551107551113551129551143551179551197551207551219551231551233551269551281551297551311551321551339551347551363551381551387551407551423551443551461551483551489551503551519551539551543551549551557551569551581551587551597551651551653551659551671551689551693551713551717551723551729551731551743551753551767551773551801551809551813551843551849551861551909551911551917551927551933551951551959551963551981552001552011552029552031552047552053552059552089552091552103552107552113552127552137552179552193552217552239552241552259552263552271552283552301552317552341552353552379552397552401552403552469552473552481552491552493552511552523552527552553552581552583552589552611552649552659552677552703552707552709552731552749552751552757552787552791552793552809552821552833552841552847552859552883552887552899552913552917552971552983552991553013553037553043553051553057553067553073553093553097553099553103553123553139553141553153553171553181553193553207553211553229553249553253553277553279553309553351553363553369553411553417553433553439553447553457553463553471553481553507553513553517553529553543553549553561553573553583553589553591553601553607553627553643553649553667553681553687553699553703553727553733553747553757553759553769553789553811553837553849553867553873553897553901553919553921553933553961553963553981553991554003554011554017554051554077554087554089554117554123554129554137554167554171554179554189554207554209554233554237554263554269554293554299554303554317554347554377554383554417554419554431554447554453554467554503554527554531554569554573554597554611554627554633554639554641554663554669554677554699554707554711554731554747554753554759554767554779554789554791554797554803554821554833554837554839554843554849554887554891554893554899554923554927554951554959554969554977555029555041555043555053555073555077555083555091555097555109555119555143555167555209555221555251555253555257555277555287555293555301555307555337555349555361555383555391555419555421555439555461555487555491555521555523555557555589555593555637555661555671555677555683555691555697555707555739555743555761555767555823555827555829555853555857555871555931555941555953555967556007556021556027556037556043556051556067556069556093556103556123556159556177556181556211556219556229556243556253556261556267556271556273556279556289556313556321556327556331556343556351556373556399556403556441556459556477556483556487556513556519556537556559556573556579556583556601556607556609556613556627556639556651556679556687556691556693556697556709556723556727556741556753556763556769556781556789556793556799556811556817556819556823556841556849556859556861556867556883556891556931556939556943556957556967556981556987556999557017557021557027557033557041557057557059557069557087557093557153557159557197557201557261557269557273557281557303557309557321557329557339557369557371557377557423557443557449557461557483557489557519557521557533557537557551557567557573557591557611557633557639557663557671557693557717557729557731557741557743557747557759557761557779557789557801557803557831557857557861557863557891557899557903557927557981557987558007558017558029558053558067558083558091558109558113558121558139558149558167558179558197558203558209558223558241558251558253558287558289558307558319558343558401558413558421558427558431558457558469558473558479558491558497558499558521558529558533558539558541558563558583558587558599558611558629558643558661558683558703558721558731558757558769558781558787558791558793558827558829558863558869558881558893558913558931558937558947558973558979558997559001559049559051559067559081559093559099559123559133559157559177559183559201559211559213559217559219559231559243559259559277559297559313559319559343559357559367559369559397559421559451559459559469559483559511559513559523559529559541559547559549559561559571559577559583559591559597559631559633559639559649559667559673559679559687559703559709559739559747559777559781559799559807559813559831559841559849559859559877559883559901559907559913559939559967559973559991560017560023560029560039560047560081560083560089560093560107560113560117560123560137560149560159560171560173560179560191560207560213560221560227560233560237560239560243560249560281560293560297560299560311560317560341560353560393560411560437560447560459560471560477560479560489560491560501560503560531560543560551560561560597560617560621560639560641560653560669560683560689560701560719560737560753560761560767560771560783560797560803560827560837560863560869560873560887560891560893560897560929560939560941560969560977561019561047561053561059561061561079561083561091561097561101561103561109561161561173561181561191561199561229561251561277561307561313561343561347561359561367561373561377561389561409561419561439561461561521561529561551561553561559561599561607561667561703561713561733561761561767561787561797561809561829561839561907561917561923561931561943561947561961561973561983561997562007562019562021562043562091562103562129562147562169562181562193562201562231562259562271562273562283562291562297562301562307562313562333562337562349562351562357562361562399562403562409562417562421562427562439562459562477562493562501562517562519562537562577562579562589562591562607562613562621562631562633562651562663562669562673562691562693562699562703562711562721562739562753562759562763562781562789562813562831562841562871562897562901562909562931562943562949562963562967562973562979562987562997563009563011563021563039563041563047563051563077563081563099563113563117563119563131563149563153563183563197563219563249563263563287563327563351563357563359563377563401563411563413563417563419563447563449563467563489563501563503563543563551563561563587563593563599563623563657563663563723563743563747563777563809563813563821563831563837563851563869563881563887563897563929563933563947563971563987563999564013564017564041564049564059564061564089564097564103564127564133564149564163564173564191564197564227564229564233564251564257564269564271564299564301564307564313564323564353564359564367564371564373564391564401564407564409564419564437564449564457564463564467564491564497564523564533564593564607564617564643564653564667564671564679564701564703564709564713564761564779564793564797564827564871564881564899564917564919564923564937564959564973564979564983564989564997565013565039565049565057565069565109565111565127565163565171565177565183565189565207565237565241565247565259565261565273565283565289565303565319565333565337565343565361565379565381565387565391565393565427565429565441565451565463565469565483565489565507565511565517565519565549565553565559565567565571565583565589565597565603565613565637565651565661565667565723565727565769565771565787565793565813565849565867565889565891565907565909565919565921565937565973565979565997566011566023566047566057566077566089566101566107566131566149566161566173566179566183566201566213566227566231566233566273566311566323566347566387566393566413566417566429566431566437566441566443566453566521566537566539566543566549566551566557566563566567566617566633566639566653566659566677566681566693566701566707566717566719566723566737566759566767566791566821566833566851566857566879566911566939566947566963566971566977566987566999567011567013567031567053567059567067567097567101567107567121567143567179567181567187567209567257567263567277567319567323567367567377567383567389567401567407567439567449567451567467567487567493567499567527567529567533567569567601567607567631567649567653567659567661567667567673567689567719567737567751567761567767567779567793567811567829567841567857567863567871567877567881567883567899567937567943567947567949567961567979567991567997568019568027568033568049568069568091568097568109568133568151568153568163568171568177568187568189568193568201568207568231568237568241568273568279568289568303568349568363568367568387568391568433568439568441568453568471568481568493568523568541568549568577568609568619568627568643568657568669568679568691568699568709568723568751568783568787568807568823568831568853568877568891568903568907568913568921568963568979568987568991568999569003569011569021569047569053569057569071569077569081569083569111569117569137569141569159569161569189569197569201569209569213569237569243569249569251569263569267569269569321569323569369569417569419569423569431569447569461569479569497569507569533569573569579569581569599569603569609569617569623569659569663569671569683569711569713569717569729569731569747569759569771569773569797569809569813569819569831569839569843569851569861569869569887569893569897569903569927569939569957569983570001570013570029570041570043570047570049570071570077570079570083570091570107570109570113570131570139570161570173570181570191570217570221570233570253570329570359570373570379570389570391570403570407570413570419570421570461570463570467570487570491570497570499570509570511570527570529570539570547570553570569570587570601570613570637570643570649570659570667570671570677570683570697570719570733570737570743570781570821570827570839570841570851570853570859570881570887570901570919570937570949570959570961570967570991571001571019571031571037571049571069571093571099571111571133571147571157571163571199571201571211571223571229571231571261571267571279571303571321571331571339571369571381571397571399571409571433571453571471571477571531571541571579571583571589571601571603571633571657571673571679571699571709571717571721571741571751571759571777571783571789571799571801571811571841571847571853571861571867571871571873571877571903571933571939571969571973572023572027572041572051572053572059572063572069572087572093572107572137572161572177572179572183572207572233572239572251572269572281572303572311572321572323572329572333572357572387572399572417572419572423572437572449572461572471572479572491572497572519572521572549572567572573572581572587572597572599572609572629572633572639572651572653572657572659572683572687572699572707572711572749572777572791572801572807572813572821572827572833572843572867572879572881572903572909572927572933572939572941572963572969572993573007573031573047573101573107573109573119573143573161573163573179573197573247573253573263573277573289573299573317573329573341573343573371573379573383573409573437573451573457573473573479573481573487573493573497573509573511573523573527573557573569573571573637573647573673573679573691573719573737573739573757573761573763573787573791573809573817573829573847573851573863573871573883573887573899573901573929573941573953573967573973573977574003574031574033574051574061574081574099574109574127574157574159574163574169574181574183574201574219574261574279574283574289574297574307574309574363574367574373574393574423574429574433574439574477574489574493574501574507574529574543574547574597574619574621574627574631574643574657574667574687574699574703574711574723574727574733574741574789574799574801574813574817574859574907574913574933574939574949574963574967574969575009575027575033575053575063575077575087575119575123575129575131575137575153575173575177575203575213575219575231575243575249575251575257575261575303575317575359575369575371575401575417575429575431575441575473575479575489575503575513575551575557575573575579575581575591575593575611575623575647575651575669575677575689575693575699575711575717575723575747575753575777575791575821575837575849575857575863575867575893575903575921575923575941575957575959575963575987576001576013576019576029576031576041576049576089576101576119576131576151576161576167576179576193576203576211576217576221576223576227576287576293576299576313576319576341576377576379576391576421576427576431576439576461576469576473576493576509576523576529576533576539576551576553576577576581576613576617576637576647576649576659576671576677576683576689576701576703576721576727576731576739576743576749576757576769576787576791576881576883576889576899576943576949576967576977577007577009577033577043577063577067577069577081577097577111577123577147577151577153577169577177577193577219577249577259577271577279577307577327577331577333577349577351577363577387577397577399577427577453577457577463577471577483577513577517577523577529577531577537577547577559577573577589577601577613577627577637577639577667577721577739577751577757577781577799577807577817577831577849577867577873577879577897577901577909577919577931577937577939577957577979577981578021578029578041578047578063578077578093578117578131578167578183578191578203578209578213578251578267578297578299578309578311578317578327578353578363578371578399578401578407578419578441578453578467578477578483578489578497578503578509578533578537578563578573578581578587578597578603578609578621578647578659578687578689578693578701578719578729578741578777578779578789578803578819578821578827578839578843578857578861578881578917578923578957578959578971578999579011579017579023579053579079579083579107579113579119579133579179579197579199579239579251579259579263579277579281579283579287579311579331579353579379579407579409579427579433579451579473579497579499579503579517579521579529579533579539579541579563579569579571579583579587579611579613579629579637579641579643579653579673579701579707579713579721579737579757579763579773579779579809579829579851579869579877579881579883579893579907579947579949579961579967579973579983580001580031580033580079580081580093580133580163580169580183580187580201580213580219580231580259580291580301580303580331580339580343580357580361580373580379580381580409580417580471580477580487580513580529580549580553580561580577580607580627580631580633580639580663580673580687580691580693580711580717580733580747580757580759580763580787580793580807580813580837580843580859580871580889580891580901580913580919580927580939580969580981580997581029581041581047581069581071581089581099581101581137581143581149581171581173581177581183581197581201581227581237581239581261581263581293581303581311581323581333581341581351581353581369581377581393581407581411581429581443581447581459581473581491581521581527581549581551581557581573581597581599581617581639581657581663581683581687581699581701581729581731581743581753581767581773581797581809581821581843581857581863581869581873581891581909581921581941581947581953581981581983582011582013582017582031582037582067582083582119582137582139582157582161582167582173582181582203582209582221582223582227582247582251582299582317582319582371582391582409582419582427582433582451582457582469582499582509582511582541582551582563582587582601582623582643582649582677582689582691582719582721582727582731582737582761582763582767582773582781582793582809582821582851582853582859582887582899582931582937582949582961582971582973582983583007583013583019583021583031583069583087583127583139583147583153583169583171583181583189583207583213583229583237583249583267583273583279583291583301583337583339583351583367583391583397583403583409583417583421583447583459583469583481583493583501583511583519583523583537583543583577583603583613583619583621583631583651583657583669583673583697583727583733583753583769583777583783583789583801583841583853583859583861583873583879583903583909583937583969583981583991583997584011584027584033584053584057584063584081584099584141584153584167584183584203584249584261584279584281584303584347584357584359584377584387584393584399584411584417584429584447584471584473584509584531584557584561584587584593584599584603584609584621584627584659584663584677584693584699584707584713584719584723584737584767584777584789584791584809584849584863584869584873584879584897584911584917584923584951584963584971584981584993584999585019585023585031585037585041585043585049585061585071585073585077585107585113585119585131585149585163585199585217585251585269585271585283585289585313585317585337585341585367585383585391585413585437585443585461585467585493585503585517585547585551585569585577585581585587585593585601585619585643585653585671585677585691585721585727585733585737585743585749585757585779585791585799585839585841585847585853585857585863585877585881585883585889585899585911585913585917585919585953585989585997586009586037586051586057586067586073586087586111586121586123586129586139586147586153586189586213586237586273586277586291586301586309586319586349586361586363586367586387586403586429586433586457586459586463586471586493586499586501586541586543586567586571586577586589586601586603586609586627586631586633586667586679586693586711586723586741586769586787586793586801586811586813586819586837586841586849586871586897586903586909586919586921586933586939586951586961586973586979586981587017587021587033587051587053587057587063587087587101587107587117587123587131587137587143587149587173587179587189587201587219587263587267587269587281587287587297587303587341587371587381587387587413587417587429587437587441587459587467587473587497587513587519587527587533587539587549587551587563587579587599587603587617587621587623587633587659587669587677587687587693587711587731587737587747587749587753587771587773587789587813587827587833587849587863587887587891587897587927587933587947587959587969587971587987587989587999588011588019588037588043588061588073588079588083588097588113588121588131588151588167588169588173588191588199588229588239588241588257588277588293588311588347588359588361588383588389588397588403588433588437588463588481588493588503588509588517588521588529588569588571588619588631588641588647588649588667588673588683588703588733588737588743588767588773588779588811588827588839588871588877588881588893588911588937588941588947588949588953588977589021589027589049589063589109589111589123589139589159589163589181589187589189589207589213589219589231589241589243589273589289589291589297589327589331589349589357589387589409589439589451589453589471589481589493589507589529589531589579589583589591589601589607589609589639589643589681589711589717589751589753589759589763589783589793589807589811589829589847589859589861589873589877589903589921589933589993589997590021590027590033590041590071590077590099590119590123590129590131590137590141590153590171590201590207590243590251590263590267590269590279590309590321590323590327590357590363590377590383590389590399590407590431590437590489590537590543590567590573590593590599590609590627590641590647590657590659590669590713590717590719590741590753590771590797590809590813590819590833590839590867590899590921590923590929590959590963590983590987591023591053591061591067591079591089591091591113591127591131591137591161591163591181591193591233591259591271591287591289591301591317591319591341591377591391591403591407591421591431591443591457591469591499591509591523591553591559591581591599591601591611591623591649591653591659591673591691591709591739591743591749591751591757591779591791591827591841591847591863591881591887591893591901591937591959591973592019592027592049592057592061592073592087592099592121592129592133592139592157592199592217592219592223592237592261592289592303592307592309592321592337592343592351592357592367592369592387592391592393592429592451592453592463592469592483592489592507592517592531592547592561592577592589592597592601592609592621592639592643592649592661592663592681592693592723592727592741592747592759592763592793592843592849592853592861592873592877592897592903592919592931592939592967592973592987592993593003593029593041593051593059593071593081593083593111593119593141593143593149593171593179593183593207593209593213593227593231593233593251593261593273593291593293593297593321593323593353593381593387593399593401593407593429593447593449593473593479593491593497593501593507593513593519593531593539593573593587593597593603593627593629593633593641593647593651593689593707593711593767593777593783593839593851593863593869593899593903593933593951593969593977593987593993594023594037594047594091594103594107594119594137594151594157594161594163594179594193594203594211594227594241594271594281594283594287594299594311594313594329594359594367594379594397594401594403594421594427594449594457594467594469594499594511594521594523594533594551594563594569594571594577594617594637594641594653594667594679594697594709594721594739594749594751594773594793594821594823594827594829594857594889594899594911594917594929594931594953594959594961594977594989595003595037595039595043595057595069595073595081595087595093595097595117595123595129595139595141595157595159595181595183595201595207595229595247595253595261595267595271595277595291595303595313595319595333595339595351595363595373595379595381595411595451595453595481595513595519595523595547595549595571595577595579595613595627595687595703595709595711595717595733595741595801595807595817595843595873595877595927595939595943595949595951595957595961595963595967595981596009596021596027596047596053596059596069596081596083596093596117596119596143596147596159596179596209596227596231596243596251596257596261596273596279596291596293596317596341596363596369596399596419596423596461596489596503596507596537596569596573596579596587596593596599596611596623596633596653596663596669596671596693596707596737596741596749596767596779596789596803596821596831596839596851596857596861596863596879596899596917596927596929596933596941596963596977596983596987597031597049597053597059597073597127597131597133597137597169597209597221597239597253597263597269597271597301597307597349597353597361597367597383597391597403597407597409597419597433597437597451597473597497597521597523597539597551597559597577597581597589597593597599597613597637597643597659597671597673597677597679597689597697597757597761597767597769597781597803597823597827597833597853597859597869597889597899597901597923597929597967597997598007598049598051598057598079598093598099598123598127598141598151598159598163598187598189598193598219598229598261598303598307598333598363598369598379598387598399598421598427598439598447598457598463598487598489598501598537598541598571598613598643598649598651598657598669598681598687598691598711598721598727598729598777598783598789598799598817598841598853598867598877598883598891598903598931598933598963598967598973598981598987598999599003599009599021599023599069599087599117599143599147599149599153599191599213599231599243599251599273599281599303599309599321599341599353599359599371599383599387599399599407599413599419599429599477599479599491599513599519599537599551599561599591599597599603599611599623599629599657599663599681599693599699599701599713599719599741599759599779599783599803599831599843599857599869599891599899599927599933599939599941599959599983599993599999600011600043600053600071600073600091600101600109600167600169600203600217600221600233600239600241600247600269600283600289600293600307600311600317600319600337600359600361600367600371600401600403600407600421600433600449600451600463600469600487600517600529600557600569600577600601600623600631600641600659600673600689600697600701600703600727600751600791600823600827600833600841600857600877600881600883600889600893600931600947600949600959600961600973600979600983601021601031601037601039601043601061601067601079601093601127601147601187601189601193601201601207601219601231601241601247601259601267601283601291601297601309601313601319601333601339601357601379601397601411601423601439601451601457601487601507601541601543601589601591601607601631601651601669601687601697601717601747601751601759601763601771601801601807601813601819601823601831601849601873601883601889601897601903601943601949601961601969601981602029602033602039602047602057602081602083602087602093602099602111602137602141602143602153602179602197602201602221602227602233602257602267602269602279602297602309602311602317602321602333602341602351602377602383602401602411602431602453602461602477602479602489602501602513602521602543602551602593602597602603602621602627602639602647602677602687602689602711602713602717602729602743602753602759602773602779602801602821602831602839602867602873602887602891602909602929602947602951602971602977602983602999603011603013603023603047603077603091603101603103603131603133603149603173603191603203603209603217603227603257603283603311603319603349603389603391603401603431603443603457603467603487603503603521603523603529603541603553603557603563603569603607603613603623603641603667603679603689603719603731603739603749603761603769603781603791603793603817603821603833603847603851603853603859603881603893603899603901603907603913603917603919603923603931603937603947603949603989604001604007604013604031604057604063604069604073604171604189604223604237604243604249604259604277604291604309604313604319604339604343604349604361604369604379604397604411604427604433604441604477604481604517604529604547604559604579604589604603604609604613604619604649604651604661604697604699604711604727604729604733604753604759604781604787604801604811604819604823604829604837604859604861604867604883604907604931604939604949604957604973604997605009605021605023605039605051605069605071605113605117605123605147605167605173605177605191605221605233605237605239605249605257605261605309605323605329605333605347605369605393605401605411605413605443605471605477605497605503605509605531605533605543605551605573605593605597605599605603605609605617605629605639605641605687605707605719605779605789605809605837605849605861605867605873605879605887605893605909605921605933605947605953605977605987605993606017606029606031606037606041606049606059606077606079606083606091606113606121606131606173606181606223606241606247606251606299606301606311606313606323606341606379606383606413606433606443606449606493606497606503606521606527606539606559606569606581606587606589606607606643606649606653606659606673606721606731606733606737606743606757606791606811606829606833606839606847606857606863606899606913606919606943606959606961606967606971606997607001607003607007607037607043607049607063607067607081607091607093607097607109607127607129607147607151607153607157607163607181607199607213607219607249607253607261607301607303607307607309607319607331607337607339607349607357607363607417607421607423607471607493607517607531607549607573607583607619607627607667607669607681607697607703607721607723607727607741607769607813607819607823607837607843607861607883607889607909607921607931607933607939607951607961607967607991607993608011608029608033608087608089608099608117608123608129608131608147608161608177608191608207608213608269608273608297608299608303608339608347608357608359608369608371608383608389608393608401608411608423608429608431608459608471608483608497608519608521608527608581608591608593608609608611608633608653608659608669608677608693608701608737608743608749608759608767608789608819608831608843608851608857608863608873608887608897608899608903608941608947608953608977608987608989608999609043609047609067609071609079609101609107609113609143609149609163609173609179609199609209609221609227609233609241609253609269609277609283609289609307609313609337609359609361609373609379609391609397609403609407609421609437609443609461609487609503609509609517609527609533609541609571609589609593609599609601609607609613609617609619609641609673609683609701609709609743609751609757609779609781609803609809609821609859609877609887609907609911609913609923609929609979609989609991609997610031610063610081610123610157610163610187610193610199610217610219610229610243610271610279610289610301610327610331610339610391610409610417610429610439610447610457610469610501610523610541610543610553610559610567610579610583610619610633610639610651610661610667610681610699610703610721610733610739610741610763610781610783610787610801610817610823610829610837610843610847610849610867610877610879610891610913610919610921610933610957610969610993611011611027611033611057611069611071611081611101611111611113611131611137611147611189611207611213611257611263611279611293611297611323611333611389611393611411611419611441611449611453611459611467611483611497611531611543611549611551611557611561611587611603611621611641611657611671611693611707611729611753611791611801611803611827611833611837611839611873611879611887611903611921611927611939611951611953"\n    return primes[a:a+b]\n    pass
def find_screen_height(width, ratio): \n    a, b = map(int, ratio.split(":"))\n    return f"{width}x{int(width / a * b)}"
def what_is_the_time(time_in_mirror):\n    h, m = map(int, time_in_mirror.split(':'))\n    return '{:02}:{:02}'.format(-(h + (m != 0)) % 12 or 12, -m % 60)
def char_concat(word, index = 1):\n  if len(word) < 2: return ''\n  return word[0:1] + word[-1:] + str(index) + char_concat(word[1:-1], index + 1)
def count_adjacent_pairs(st): \n    words = st.lower().split(' ')\n    currentWord = None\n    count = 0\n    for i, word in enumerate(words):\n        if i+1 < len(words):\n            if word == words[i+1]:\n                if word != currentWord:\n                    currentWord = word\n                    count += 1\n            else:\n                currentWord = None\n          \n    return count
def withdraw(n):\n    n50 = 0\n    n20, r = divmod(n, 20)\n    if r == 10:\n        n20 -= 2\n        n50 += 1\n    n100, n20 = divmod(n20, 5)\n    return [n100, n50, n20]
def char_attribute(score):\n    return ({"modifier": 0, "maximum_spell_level": -1, "extra_spells": []} if not score\n        else {"modifier":            score//2-5,\n              "maximum_spell_level": -1 if score//2-5 < 0 else min(9, score -10) ,\n              "extra_spells":        [1+n//4 for n in range(score//2-5)][::-1][:9] })
def coordinates(p1,p2, precision = 0):\n    return round(sum( (b-a)**2 for a,b in zip(p1,p2) )**.5, precision)
def pack_bagpack(scores, weights, capacity):\n    load = [0] * (capacity + 1)\n    for score, weight in zip(scores, weights):\n        load = [max(l, weight <= w and load[w - weight] + score)\n                for w, l in enumerate(load)]\n    return load[-1]
def chessboard(s):\n    N, M = map(int, s.split())\n    row = ".*" * M\n    return "\n".join( [row[:M] if i&1 else row[1:M+1] for i in range(N)] )
def check_DNA(seq1, seq2):\n if len(seq1) < len(seq2): seq1, seq2 = seq2, seq1\n seq2 = seq2[::-1].replace('C','g').replace('G','c').replace('T','a').replace('A','t').upper()\n return seq1.find(seq2) >= 0
def modified_sum(lst, p):\n    return sum(n**p - n for n in lst)
def greet_jedi(first, last):\n  return "Greetings, master {}{}".format(last[:3].capitalize(), first[:2].capitalize())
from itertools import combinations_with_replacement\n\ndef find(arr,n):\n    return sum( sum(c) == n for x in range(1,len(arr)+1) for c in combinations_with_replacement(arr, x) )
def peak(arr):\n    for i, val in enumerate(arr):\n        if sum(arr[:i]) == sum(arr[i+1:]):\n            return i\n    return -1
def gordon(a):\n    return '!!!! '.join(a.upper().split()).translate(str.maketrans('AEIOU', '@****'))+'!!!!'
ghostbusters = lambda s: (s.replace(' ','')  if (' ' in s) else\n                          "You just wanted my autograph didn't you?")
def find_longest(st):\n    res,pos=0,[0]\n    for i,b in enumerate(st,1):\n        if b=="(": pos.append(i)\n        else:   \n            try:pos.pop();res=max(res,i-pos[-1])\n            except:pos.append(i)\n    return res
def solve(arr): \n    re = []\n    for i in arr[::-1]:\n        if i not in re:\n            re.append(i)\n    return re[::-1]
def sort_reindeer(reindeer_names):\n    return sorted(reindeer_names, key=lambda s:s.split()[1])
series = [0]\nfor a in range(2, 99):\n    for b in range(2, 42):\n        c = a**b\n        if a == sum(map(int, str(c))):\n            series.append(c)\npower_sumDigTerm = sorted(series).__getitem__
def gap(num):\n    s = bin(num)[2:].strip("0")\n    return max(map(len, s.split("1")))
splitSentence=str.split
def combs(a, b):\n    return min(mesh(a, b), mesh(b, a))\n\ndef mesh(a, b):\n    for i in range(len(a)):\n        for j, k in zip(a[i:], b):\n            if j + k == '**': break\n        else:\n            return max(i + len(b), len(a))\n    return len(a) + len(b)            
def largest_sum(arr):\n    sum = max_sum = 0\n    for n in arr:\n        sum = max(sum + n, 0)\n        max_sum = max(sum, max_sum)\n    return max_sum
def isomorph(a, b):\n  return [a.index(x) for x in a] == [b.index(y) for y in b]\n
def vector_length(vector):\n    (x1,y1),(x2,y2) = vector\n    return ((x1-x2)**2 + (y1-y2)**2) ** .5
def leaderboard_climb(arr, kara):\n    scores = sorted(set(arr), reverse=True)\n    position = len(scores)\n    ranks = []\n    \n    for checkpoint in kara:\n        while position >= 1 and checkpoint >= scores[position - 1]:\n            position -= 1\n        ranks.append(position + 1)    \n    \n    return ranks
OUTPUT = "I don't think you {} today, I think you {} {} {}!".format\n\n\ndef alan_annoying_kid(phrase):\n    words = phrase.split()\n    action = ' '.join(words[2:]).rstrip('.')\n    if "didn't" in phrase:\n        return OUTPUT(action, 'did', words[3], 'it')\n    return OUTPUT(action, "didn't", words[2][:-2], 'at all')\n
def merge_arrays(a, b):\n    out = []\n    for n in a+b:\n        if n in a and n in b:\n            if a.count(n) == b.count(n):\n                out.append(n)\n        else:\n            out.append(n)\n    return sorted(set(out))
def solution(str):\n  return str[::-1]
def mobius(n):\n    sP, p = set(), 2\n    while n>1 and p <= n**.5:\n        while not n%p:\n            if p in sP: return 0\n            sP.add(p)\n            n //= p\n        p += 1 + (p!=2)\n    return (-1)**((len(sP) + (n!= 1)) % 2)
from collections import defaultdict\n\ndef fix_progression(arr):\n    res = 0\n    for i in range(len(arr)):\n        D = defaultdict(int)\n        for j in range(i):\n            q, r = divmod(arr[i]-arr[j], i-j)\n            if not r:\n                D[q] += 1\n                res = max(res, D[q])\n    return len(arr)-res-1
def is_nice(arr):\n    s = set(arr)\n    return bool(arr) and all( n+1 in s or n-1 in s for n in s)
def distinct(seq):\n    return sorted(set(seq), key = seq.index)
def same(arr_a, arr_b):\n    return sorted(map(sorted, arr_a)) == sorted(map(sorted, arr_b))
starts_with = str.startswith
from itertools import product\n\ndef coin(n):\n    return list(map(''.join, product(*(["HT"]*n))))
def josephus_survivor(n, k):\n    v = 0\n    for i in range(1, n + 1): v = (v + k) % i\n    return v + 1
def my_parse_int(s):\n    try:\n        return int(s)\n    except ValueError:\n        return 'NaN'
def sort_photos(lst):\n    lst = [[int(d) for d in f.split(".img")] for f in lst]\n    s, l = sorted(lst), min(len(lst), 5)\n    return [f"{y}.img{n+(i==l)}" for i, (y, n) in enumerate(s[-5:]+s[-1:])]\n
def check(a, x): \n    return x in a
def count(a, t, x):\n    return sum(not (t-v)%x if x else t==v for v in a)
def shortest_to_char(s, c):\n    if not s or not c:\n        return []\n\n    indexes = [i for i, ch in enumerate(s) if ch == c]\n    if not indexes:\n        return []\n        \n    return [ min(abs(i - ic) for ic in indexes) for i in range(len(s)) ]\n
import re\nimport unicodedata\n\nNAME = re.compile("[\w-]+")\n\ndef decompose(name):\n    standarized = unicodedata.normalize('NFKD', name.lower()) \\n        .encode('ascii', 'ignore') if type(name) != str \\n        else name.lower()\n    return re.findall(NAME, standarized)\n\ndef could_be(original, another):\n    if not another.strip(): return False\n    std_original = decompose(original)\n    std_another = decompose(another)\n    return all( name in std_original for name in std_another )
def seven(m, step = 0):\n  if m < 100: return (m, step)\n  x, y, step = m // 10, m % 10, step + 1\n  res = x - 2 * y\n  return seven(res, step)
def validate(n):\n    digits = [int(x) for x in str(n)]\n    even = [x*2 if x*2 <= 9 else x*2 - 9 for x in digits[-2::-2]]\n    odd  = [x for x in digits[-1::-2]]\n    return (sum(even + odd)%10) == 0\n
def cumulative_triangle(n):\n    return n*(n*n+1)/2
def to_pretty(s):\n    if not s: return "just now"\n    for t, w in (60, "seconds"), (60, "minutes"), (24, "hours"), (7, "days"), (53, "weeks"):\n        s, r = divmod(s, t)\n        if not s: return (r > 1 and str(r) + " " + w or ("a ", "an ")[t == 24] + w[:-1]) + " ago"
def stringify(list):\n    return 'None' if list == None else str(list.data) + ' -> ' + stringify(list.next)
def champernowne_digit(n):\n    if not type(n) is int or n < 1:\n        return float("NaN")\n    i, l = 1, 11\n    while l <= n:\n        i, l = i + 1, l + 9 * (i + 1) * 10**i\n    return ((n - l) // (i * 10**(i - 1 - (n - l) % i))) % 10\n\nchampernowneDigit = champernowne_digit\n
import re\n\ndef find(stg):\n    matches = re.findall(r"(!+|\?+)", stg)\n    return max((f"{a}{b}" for a, b in zip(matches, matches[1:])), key=len, default="")
import base64\nimport binascii\nimport math\nfrom itertools import zip_longest\n\n\ndef adFly_decoder(sc):\n    code1 = ""\n    code2 = ""\n    flip = False\n    for c in sc:\n        if flip:\n            code2 += c\n        else:\n            code1 += c\n        flip = not flip\n\n    try:\n        url = base64.b64decode(code1 + code2[len(code2) :: -1])\n    except binascii.Error:\n        return "Invalid"\n\n    try:\n        dec = base64.b64decode(url[26:])\n    except binascii.Error:\n        return "Invalid"\n\n    return str(dec, "utf-8")\n\n\ndef adFly_encoder(url):\n    prefix = "96https://adf.ly/go.php?u="\n    full = str.encode(prefix) + base64.b64encode(str.encode(url))\n    enc = base64.b64encode(full)\n    cut = math.ceil(len(enc) / 2)\n    code1 = str(enc[: cut + 1], "utf-8")\n    code2 = str(enc[len(enc) : cut : -1], "utf-8")\n    swp = "".join(i + (j or "") for i, j in zip_longest(code1, code2))\n    return swp\n
def remove(s):\n    return ' '.join(w.rstrip('!') or w for w in s.split())
from collections import deque\n\ndef count_ways(n, k):\n    s,d = 1,deque([0]*k)\n    for i in range(n):\n        d.append(s)\n        s = 2*s-d.popleft()\n    return s-d.pop()
def multiples(m, n):\n    return [i * n for i in range(1, m+1)]
def find_the_key(message, code):\n    diffs = "".join( str(c - ord(m) + 96) for c, m in zip(code, message) )\n    for size in range(1, len(code) +1):\n        key = diffs[:size]\n        if (key * len(code))[:len(code)] == diffs:\n            return int(key)
import re\n\nCASES = [\n    ('snake', re.compile(r'\A[a-z]+(_[a-z]+)+\Z')),\n    ('kebab', re.compile(r'\A[a-z]+(-[a-z]+)+\Z')),\n    ('camel', re.compile(r'\A[a-z]+([A-Z][a-z]*)+\Z')),\n    ('none', re.compile(r'')),\n]\n\ndef case_id(c_str):\n    for case, pattern in CASES:\n        if pattern.match(c_str): return case
def plant_doubling(n):\n    return bin(n).count("1")
def triple_trouble(one, two, three):\n    return ''.join(''.join(a) for a in zip(one, two, three))\n
import re\n\nKA_PATTERN = re.compile(r'(?![aeiou]+$)([aeiou]+)', re.I)\n\ndef ka_co_ka_de_ka_me(word):\n    return 'ka' + KA_PATTERN.sub(r'\1ka', word)
def cost_of_carpet(room_length, room_width, roll_width, roll_cost):\n    x, y = sorted((room_length, room_width))\n    if y == 0 or x > roll_width: return "error"\n    if y < roll_width: return round(x * roll_width * roll_cost, 2)\n    return round(y * roll_width * roll_cost, 2)
def oddity(n):\n    #your code here\n    return 'odd' if n**0.5 == int(n**0.5) else 'even'
def find_array(arr1, arr2):\n    return [ arr1[i] for i in arr2 if i< len(arr1) ]
def bin_str(s):\n    return s.count("10") * 2 + (s[-1] == "1")
def string_transformer(s):\n    return ' '.join(s.swapcase().split(' ')[::-1])
psion_power_points=lambda l,s: [0,2,6,11,17,25,35,46,58,72,88,106,126,147,170,195,221,250,280,311,343][min(l,20)]+(s-10)//2*l//2 if l and s>10 else 0
def opposite(number):\n    return -number
from math import pi\n\ndef volume(r,h):\n    return pi * r**2 * h // 3
def filter_words(st):\n    return ' '.join(st.capitalize().split())
def nickname_generator(name):\n    return "Error: Name too short" if len(name) < 4 else name[:3+(name[2] in "aeiuo")]
def generate_number(squad, n):\n    if n not in squad: return n\n    for i in range(1, 10):\n        for j in range(1, 10):\n            if i + j == n and i * 10 + j not in squad:\n                return i * 10 + j
MAX_BALL = 2+1800\nDP,lst = [None], [0,1]\nfor _ in range(MAX_BALL):\n    DP.append([sum(lst), *max( (v,i) for i,v in enumerate(lst) )])\n    lst.append(0)\n    lst = [ v*i + lst[i-1] for i,v in enumerate(lst) ]\n    \ncombs_non_empty_boxesII = DP.__getitem__\n
def flatten(dictionary):\n    stack = [((), dictionary)]\n    result = {}\n    while stack:\n        path, current = stack.pop()\n        for k, v in current.items():\n            if v == {}:\n                result["/".join((path + (k,)))] = "";\n            if isinstance(v, dict):\n                stack.append((path + (k,), v))\n            else:\n                result["/".join((path + (k,)))] = v\n    return result
def is_tune(notes):\n    return bool(notes) and any(\n        all((n + i) % 12 in {0, 2, 4, 5, 7, 9, 11} for n in notes)\n        for i in range(12)\n    )
def small_enough(a, limit): \n    return max(a) <= limit
def count_vowels(s = ''):\n    return sum(x.lower() in 'aeoui' for x in s) if type(s) == str else None
def find_multiples(integer, limit):\n    return list(range(integer, limit+1, integer))
def x(n):\n    ret = [['' for _ in range(n)] for _ in range(n)]\n    for i in range(len(ret)):\n        ret[i][i] = '';\n        ret[i][-1 - i] = '';\n    return '\n'.join(''.join(row) for row in ret)
def array_diff(a, b):\n    return [x for x in a if x not in b]
def check_availability(schedule, current_time):\n    for tb, te in schedule:\n        if tb <= current_time < te:\n            return te\n    return True
def mutually_exclusive(dice, call1, call2):\n    dice = dict(dice)\n    if abs(sum(dice.values()) - 1) < 1e-12:\n        return '%0.2f' % (dice[call1] + dice[call2])
def distinct_digit_year(year):\n    year += 1\n    while len(set(str(year))) != 4:\n        year += 1\n    return year\n  #coding and coding..\n
def nbMonths(oldCarPrice, newCarPrice, saving, loss):\n    months = 0\n    budget = oldCarPrice\n    \n    while budget < newCarPrice:\n        months += 1\n        if months % 2 == 0:\n            loss += 0.5\n        \n        oldCarPrice *= (100 - loss) / 100\n        newCarPrice *= (100 - loss) / 100\n        budget = saving * months + oldCarPrice\n    \n    return [months, round(budget - newCarPrice)]
from itertools import cycle\n\ndef encode(message, key):\n    return [ord(a) - 96 + int(b) for a,b in zip(message,cycle(str(key)))]
def pattern(n):\n    return '\n'.join(''.join(str(i) for i in range(n, j, -1)) for j in range(n - 1, -1, -1))
def blocks_to_collect(level):\n    answer = {\n    'total': sum([(i+3+i)**2 for i in range(level)]),\n    'gold': sum([(i+3+i)**2 for i in range(0,level,4)]),\n    'diamond': sum([(i+3+i)**2 for i in range(1,level,4)]),\n    'emerald': sum([(i+3+i)**2 for i in range(2,level,4)]),\n    'iron': sum([(i+3+i)**2 for i in range(3,level,4)]),\n    }\n    \n    return answer
def crap(garden, bags, cap):\n    cap *= bags\n    for turf in garden:\n        if 'D' in turf: return 'Dog!!'\n        cap -= turf.count('@')\n    return 'Cr@p' if cap < 0 else 'Clean'
from re import compile, sub\n\nREGEX = compile(r',+')\n\n\ndef dad_filter(strng):\n    return sub(REGEX, ',', strng).rstrip(' ,')\n
from fractions import gcd\n\ndef are_coprime(n, m):\n  return gcd(n, m) == 1
def multiply(n):\n  return n*5**len(str(abs(n))) 
def reverse(a):\n    s=reversed(''.join(a))\n    return [''.join(next(s) for _ in w) for w in a]
def zombie_shootout(zombies, distance, ammo, shot=0):\n    \n    if not zombies:\n        return f'You shot all {shot} zombies.'\n    \n    if distance <= 0:\n        return f'You shot {shot} zombies before being eaten: overwhelmed.'\n    \n    if not ammo:\n        return f'You shot {shot} zombies before being eaten: ran out of ammo.'\n    \n    return zombie_shootout(zombies - 1, distance - 0.5, ammo - 1, shot + 1)
def alphabet_war(fight):\n    d = {'w':4,'p':3,'b':2,'s':1,\n         'm':-4,'q':-3,'d':-2,'z':-1}\n    r = sum(d[c] for c in fight if c in d)\n    \n    return {r==0:"Let's fight again!",\n            r>0:"Left side wins!",\n            r<0:"Right side wins!"\n            }[True]
def factors(n):\n    sq = [a for a in range(2, n+1) if not n % (a**2)]\n    cb = [b for b in range(2, n+1) if not n % (b**3)]\n    return [sq, cb]
def summation(num):\n    return sum(range(num + 1))\n    \n
def count_cows(n):\n    if not isinstance(n, int):\n        return None\n    return 1 if n < 3 else count_cows(n-1) + count_cows(n-3)
def colour_association(arr):\n    return [{k: v} for k, v in arr]
def solve(nums,div):\n    return [x + x % div for x in nums]\n\n
import re\n\ndef solve(s):\n    return max(sum(ord(c)-96 for c in subs) for subs in re.split('[aeiou]+', s))
def is_vowel(s):\n    return s.lower() in set("aeiou")
# First, I coded a straightforward solution. It would work, but because it had to loop over all\n# students, and for every student over each locker, it had to do n^2 iterations. With numbers under\n# 10k this proved no problem, however the test cases apparently tested bigger numbers, since my\n# program kept getting timed out. I decided to record the number of open lockers for each n in range\n# 1-500 and discovered a nice pattern: 0 -1-1-1 (3 1's) -2-2-2-2-2 (5 2's) -3-3-3-3-3-3-3 (7 4's)\n# - et cetera. In other words, the number of consecutive numbers is (2n + 1). This was still not easy\n# to do so I looked up the sequence in OEIS. There, I discovered that the sequence was the integer\n# part of the square root of n. Now if that isn't easy to program... more of a maths problem, really.\n\ndef num_of_open_lockers(n):\n    return int(n**0.5)
def between(a,b):\n    return list(range(a,b+1))
def pattern(n):\n    output = []\n    for i in range (1, n + 1):\n        wing = ' ' * (n - i) + ''.join(str(d % 10) for d in range(1, i))\n        output.append(wing + str(i % 10) + wing[::-1])\n    return '\n'.join(output)
def has_two_cube_sums(n):\n    cubic_list = [i**3 for i in range(1, int((n)**(1./3.)) + 1)]\n    return sum([(n != 2*c) and ((n-c) in cubic_list) for c in cubic_list]) > 3\n
def repeats(arr):\n    return sum([x for x in arr if arr.count(x) == 1])
def add(*args):\n    return int(round(sum(float(a) / i for (i, a) in enumerate(args, 1))))
def fold_to(distance, thickness=0.0001, folds=0):\n    if distance < 0:\n        return\n    \n    while thickness < distance:\n        thickness *= 2\n        folds += 1\n    \n    return folds
def complete_binary_tree(a):\n    def in_order(n=0):\n        if n < len(a):\n            yield from in_order(2 * n + 1)\n            yield n\n            yield from in_order(2 * n + 2)\n\n    result = [None] * len(a)\n    for i, x in zip(in_order(), a):\n        result[i] = x\n    return result
ELEMENTS = ['H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og']\nEXCEPTIONS = {\n    'Cr': ['Ar', '4s1 3d5'],\n    'Cu': ['Ar', '4s1 3d10'],\n    'Nb': ['Kr', '5s1 4d4'],\n    'Mo': ['Kr', '5s1 4d5'],\n    'Ru': ['Kr', '5s1 4d7'],\n    'Rh': ['Kr', '5s1 4d8'],\n    'Pd': ['Kr', '5s0 4d10'],\n    'Ag': ['Kr', '5s1 4d10'],\n    'La': ['Xe', '6s2 4f0 5d1'],\n    'Ce': ['Xe', '6s2 4f1 5d1'],\n    'Gd': ['Xe', '6s2 4f7 5d1'],\n    'Pt': ['Xe', '6s1 4f14 5d9'],\n    'Au': ['Xe', '6s1 4f14 5d10'],\n    'Ac': ['Rn', '7s2 5f0 6d1'],\n    'Th': ['Rn', '7s2 5f0 6d2'],\n    'Pa': ['Rn', '7s2 5f2 6d1'],\n    'U' : ['Rn', '7s2 5f3 6d1'],\n    'Np': ['Rn', '7s2 5f4 6d1'],\n    'Cm': ['Rn', '7s2 5f7 6d1'],\n}\nORBITALS = "spdfg"\nELT_TO_Z = {elt:i for i,elt in enumerate(ELEMENTS,1)}\nfor arr in list(EXCEPTIONS.values()):\n    arr[1] = [ (int(s[0]), ORBITALS.find(s[1]), s[2:]) for s in arr[1].split(' ') ]\n\n\ndef get_electron_configuration(element):\n    elt,repl = EXCEPTIONS.get(element, (element,[]) )\n    z,nl,config = ELT_TO_Z[elt], 0, {}                  # n: principal quantum number / l: secondary qunatum number (minus 1) / nl: n+l\n    while z:\n        nl += 1\n        for l in range(nl-1>>1, -1, -1):\n            nE = min(z, 2+l*4)\n            config[ (nl-l,l) ] = nE\n            z -= nE\n            if not z: break\n    \n    for a,b,n in repl: config[(a,b)] = n\n    \n    s = " ".join( f'{ k[0] }{ ORBITALS[k[1]] }{ n }' for k,n in sorted(config.items()))\n    return f'{ element } -> { s }'\n
def fortune(f, p, c, n, i):\n    for _ in range(n-1):\n        f = int(f * (100 + p) / 100 - c)\n        c = int(c * (100 + i) / 100)\n        if f < 0:\n            return False\n    return True
def reverse_sentence(sentence):\n    return ' '.join(w[::-1] for w in sentence.split())
def rounding(n, m):\n    return n if n % m == m / 2 else m * round(n / m)
def split_by_value(k, elements):\n    return sorted(elements, key=lambda x: x >= k)
def split_and_add(numbers, n):\n    for _ in range(n):\n        middle = len(numbers) // 2\n        left = numbers[:middle]\n        right = numbers[middle:]\n        numbers = [a + b for a, b in zip((len(right) - len(left)) * [0] + left, right)]\n        if len(numbers) == 1:\n            return numbers\n    return numbers\n
def solve(arr):\n    return sum( y-x == z-y for i,x in enumerate(arr[:-2])\n                           for j,y in enumerate(arr[i+1:-1])\n                           for _,z in enumerate(arr[j+1:]))
from math import ceil, log\n\ndef how_many_measurements(n):\n    return ceil(log(n, 3))
from math import hypot\n\ndef dropzone(fire, dropzones):\n    return min(dropzones, key=lambda p: hypot(p[0]-fire[0], p[1]-fire[1]))
def numericals(s):\n    dictio = {}\n    t = ""\n    for i in s:\n        dictio[i] = dictio.get(i,0) + 1 \n        t += str(dictio[i])\n    return t
def riders(stations):\n    riders, travelled = 1, 0\n    \n    for dist in stations:\n        if travelled + dist > 100:\n            riders += 1\n            travelled = dist\n        else:\n            travelled += dist\n    \n    return riders
def oddity(n):\n    while True:\n        n, m = divmod(n, 2)\n        yield m       \n\ndef oddest(arr):\n    res = arr[0]\n    for n in arr[1:]:\n        if next(b > a for a, b in zip(oddity(res), oddity(n)) if a != b):\n            res = n\n    return res
def encode(stg):\n    return "".join(digit * 3 for char in stg for digit in f"{ord(char):08b}")\n\n\ndef decode(binary):\n    reduced = (get_digit(triplet) for triplet in chunks(binary, 3))\n    return "".join(get_char(byte) for byte in chunks("".join(reduced), 8))\n\n\ndef chunks(seq, size):\n    return (seq[i:i+size] for i in range(0, len(seq), size))\n\n        \ndef get_digit(triplet):\n    return max(triplet, key=triplet.count)\n\n\ndef get_char(byte):\n    return chr(int(byte, 2))
d = {\n    "jabroni": "Patron Tequila",\n    "school counselor": "Anything with Alcohol",\n    "programmer": "Hipster Craft Beer",\n    "bike gang member": "Moonshine",\n    "politician": "Your tax dollars",\n    "rapper": "Cristal"\n}\n\ndef get_drink_by_profession(s):\n    return d.get(s.lower(), "Beer")
def subcuboids(x,y,z):\n    return x*y*z*(x+1)*(y+1)*(z+1)//8
from functools import lru_cache\n\n\ndef optimal_number_of_coins(n, coins):\n    @lru_cache(maxsize=None)\n    def f(amount: int, idx: int) -> float:\n        q, r = divmod(amount, coins[idx])\n        if r == 0:\n            return q\n        elif amount < 0 or idx <= 0:\n            return float("inf")\n        else:\n            return min(1 + f(amount - coins[idx], idx), f(amount, idx - 1))\n\n    coins = sorted(set(coins))\n    return f(n, len(coins) - 1)
from fractions import gcd\n\ndef sum_differences_between_products_and_LCMs(pairs):\n    return sum(a*b - a*b//gcd(a,b) for a, b in pairs if a and b)
def complete_series(a):\n    return list(range(max(a) + 1)) if len(a) == len(set(a)) else [0]
def divisible_by(numbers, divisor):\n    return [x for x in numbers if x%divisor == 0]
def swap(string_):\n    return string_.swapcase()
def sum_two_smallest_numbers(numbers):\n    return sum(sorted(numbers)[:2])
import numpy as np\n\ndef solve_eq(eq):\n    a = np.array([arr[:3] for arr in eq])\n    b = np.array([arr[-1] for arr in eq])\n    return [round(x) for x in np.linalg.solve(a,b)]
def calculate(s):\n    x=[int(i) for i in s.split() if i.isdigit()]\n    return sum(x) if 'gains' in s.split() else x[0]-x[1]
bin2hex = {"0000": "0", "0001": "1", "0010": "2", "0011": "3", \n           "0100": "4", "0101": "5", "0110": "6", "0111": "7", \n           "1000": "8", "1001": "9", "1010": "a", "1011": "b", \n           "1100": "c", "1101": "d", "1110": "e", "1111": "f"}\nhex2bin = {v: k for k, v in bin2hex.items()}\n\ndef bin_to_hex(s, res = ""):\n    s = "0" * (4 - len(s) % 4) + s\n    while s:\n        res += bin2hex[s[:4]]\n        s = s[4:]\n    return res.lstrip("0") or "0"\n    \ndef hex_to_bin(s, res = ""):\n    while s:\n        res += hex2bin[s[0].lower()]\n        s = s[1:]\n    return res.lstrip("0") or "0"
def get_middle(s):\n   return s[(len(s)-1)//2:len(s)//2+1]\n
def advice(agents, n):\n    frontier = { (x,y) for x,y in agents if 0<=x<n and 0<=y<n }\n    bag = { (x,y) for x in range(n) for y in range(n)}\n    if frontier==bag: return []\n    while frontier and bag>frontier:\n        bag -= frontier\n        frontier = {pos for x,y in frontier for pos in ((x+1,y),(x-1,y),(x,y+1),(x,y-1)) if pos in bag }\n    return sorted(bag)
def prod_int_part(n, min_=2):\n    total, fac = 0, []\n    for d in range(min_, int(n ** .5) + 1):\n        if not n % d:\n            count, sub = prod_int_part(n // d, d)\n            total += count + 1\n            if not count: sub = [n // d]\n            if not fac: fac = [d] + sub\n    return [total, fac]
def watch_pyramid_from_the_side(characters):\n    if not characters : return characters\n    baseLen = len(characters)*2-1\n    return '\n'.join( ' '*(i) + characters[i]*(baseLen-2*i) + ' '*(i) for i in range(len(characters)-1,-1,-1) )\n\n\ndef watch_pyramid_from_above(characters):\n    if not characters : return characters\n    baseLen = len(characters)*2-1\n    return '\n'.join( characters[0:min(i,baseLen-1-i)] + characters[min(i,baseLen-1-i)]*(baseLen-2*min(i,baseLen-1-i)) + characters[0:min(i,baseLen-1-i)][::-1] for i in range(baseLen) )\n\n\ndef count_visible_characters_of_the_pyramid(characters):\n    return -1 if not characters else (len(characters)*2-1)**2\n\n\ndef count_all_characters_of_the_pyramid(characters):\n    return -1 if not characters else sum( (2*i+1)**2 for i in range(len(characters)) )
def multiple_split(string, delimiters=[]):\n    for d in delimiters:\n        string = string.replace(d, '###')\n    return [s for s in string.split('###') if s]
def array_conversion(arr):\n    sign = 0\n    while len(arr) > 1:\n        sign = 1^sign\n        arr = list(map(lambda x, y: x+y, arr[0::2],arr[1::2]) if sign else map(lambda x, y: x*y, arr[0::2],arr[1::2]))\n    return arr[0]
def excluding_vat_price(price):\n    try:\n        return round(price / 1.15, 2)\n    except TypeError:\n        return -1
def song_decoder(song):\n    return " ".join(song.replace('WUB', ' ').split())
def accum(s):\n    return '-'.join(c.upper() + c.lower() * i for i, c in enumerate(s))
from bisect import bisect_left\n\na = [12, 15, 35, 42, 60, 63, 66, 68, 84, 90, 95, 110, 114, 119, 140, 143, 152, 168, 189, 195, 204, 209, 216, 234, 245, 258, 264, 270, 280, 287, 290, 294, 297, 319, 322, 323, 352, 368, 377, 380, 384, 396, 470, 476, 480, 506, 510, 527, 531, 544, 552, 558, 559, 572, 588, 616, 621, 693, 702, 741, 744, 756, 760, 779, 812, 819, 825, 837, 855, 880, 899, 902, 923, 940, 950, 952, 989, 990, 1007, 1010, 1026, 1044, 1056, 1064, 1078, 1080, 1102, 1144, 1170, 1188, 1189, 1197, 1199, 1280, 1288, 1292, 1298, 1334, 1343, 1349, 1365, 1372, 1375, 1386, 1392, 1440, 1456, 1470, 1494, 1566, 1595, 1620, 1625, 1638, 1652, 1672, 1696, 1700, 1704, 1750, 1763, 1768, 1785, 1804, 1836, 1840, 1845, 1887, 1908, 1914, 1917, 1919, 1944, 1950, 1980, 1989, 1998, 2024, 2052, 2060, 2070, 2075, 2080, 2107, 2130, 2145, 2158, 2159, 2162, 2208, 2240, 2242, 2272, 2340, 2392, 2448, 2464, 2496, 2507, 2520, 2541, 2632, 2660, 2668, 2673, 2688, 2691, 2728, 2759, 2772, 2784, 2805, 2808, 2828, 2835, 2842, 2882, 2911, 2970, 2992, 3000, 3002, 3015, 3026, 3069, 3072, 3078, 3096, 3132, 3159, 3160, 3168, 3239, 3266, 3300, 3304, 3366, 3375, 3402, 3422, 3471, 3485, 3496, 3500, 3560, 3572, 3596, 3599, 3624, 3652, 3690, 3705, 3720, 3752, 3773, 3784, 3816, 3818, 3827, 3840, 3852, 3933, 3936, 3952, 3990, 4018, 4031, 4060, 4077, 4116, 4128, 4136, 4165, 4182, 4216, 4256, 4264, 4292, 4305, 4320, 4368, 4389, 4410, 4437, 4446, 4522, 4524, 4557, 4592, 4607, 4625, 4644, 4648, 4653, 4655, 4662, 4680, 4704, 4706, 4719, 4720, 4731, 4736, 4750, 4785, 4806, 4810, 4860, 4864, 4872, 4992, 4998, 5005, 5015, 5032, 5040, 5070, 5076, 5125, 5166, 5175, 5183, 5200, 5207, 5225, 5229, 5249, 5264, 5307, 5310, 5346, 5400, 5424, 5434, 5452, 5459, 5460, 5472, 5508, 5543, 5544, 5546, 5560, 5586, 5590, 5664, 5698, 5704, 5720, 5728, 5775, 5800, 5848, 5850, 5865, 5886, 5950, 5992, 6000, 6006, 6018, 6039, 6095, 6150, 6156, 6160, 6171, 6250, 6256, 6270, 6424, 6439, 6460, 6510, 6517, 6528, 6565, 6579, 6580, 6600, 6624, 6656, 6660, 6688, 6725, 6750, 6776, 6802, 6804, 6806, 6816, 6837, 6840, 6860, 6887, 6903, 6909, 6944, 6952, 6960, 7007, 7038, 7040, 7050, 7052, 7067, 7140, 7144, 7150, 7176, 7210, 7236, 7254, 7279, 7314, 7336, 7384, 7395, 7410, 7425, 7426, 7462, 7506, 7524, 7532, 7544, 7568, 7581, 7616, 7668, 7682, 7700, 7701, 7722, 7735, 7739, 7742, 7750, 7752, 7821, 7830, 7872, 7878, 7888, 7904, 7912, 7964, 8140, 8159, 8225, 8232, 8280, 8330, 8349, 8352, 8379, 8385, 8397, 8415, 8470, 8500, 8528, 8568, 8575, 8580, 8639, 8642, 8673, 8692, 8721, 8745, 8786, 8800, 8829, 8832, 8856, 8874, 8960, 8964, 8991, 8993, 9063, 9064, 9088, 9112, 9164, 9179, 9180, 9218, 9240, 9256, 9282, 9308, 9310, 9328, 9352, 9375, 9432, 9460, 9468, 9504, 9537, 9593, 9633, 9639, 9660, 9701, 9720, 9768, 9794, 9799, 9856, 9869, 9870, 9900, 9911, 9912, 9920, 9933, 9936, 9947, 9956, 9963, 9996, 10005, 10064, 10080, 10120, 10150, 10185, 10200, 10207, 10240, 10283, 10296, 10395, 10403, 10465, 10494, 10502, 10508, 10528, 10545, 10582, 10647, 10660, 10664, 10672, 10763, 10792, 10848, 10864, 10877, 10880, 10989, 11050, 11088, 11109, 11125, 11128, 11132, 11151, 11160, 11172, 11176, 11193, 11214, 11223, 11224, 11253, 11266, 11275, 11305, 11340, 11342, 11408, 11417, 11439, 11468, 11475, 11500, 11505, 11556, 11560, 11613, 11648, 11659, 11662, 11663, 11682, 11750, 11774, 11800, 11844, 11865, 11904, 11970, 11979, 11985, 12000, 12006, 12095, 12098, 12136, 12141, 12180, 12208, 12222, 12240, 12276, 12319, 12328, 12360, 12366, 12397, 12412, 12441, 12460, 12474, 12519, 12524, 12540, 12555, 12558, 12561, 12576, 12580, 12628, 12638, 12712, 12740, 12784, 12792, 12851, 12903, 12960, 12975, 12992, 13056, 13068, 13144, 13199, 13209, 13230, 13260, 13280, 13300, 13332, 13439, 13464, 13500, 13509, 13529, 13536, 13566, 13572, 13585, 13608, 13629, 13653, 13662, 13677, 13702, 13716, 13720, 13750, 13761, 13770, 13826, 13840, 13862, 13869, 13912, 13919, 14098, 14100, 14104, 14105, 14144, 14145, 14190, 14195, 14250, 14256, 14259, 14260, 14299, 14326, 14344, 14382, 14396, 14402, 14504, 14514, 14520, 14616, 14632, 14645, 14685, 14688, 14690, 14700, 14732, 14749, 14824, 14850, 14875, 14940, 14950, 14972, 14973, 14994, 15008, 15050, 15066, 15088, 15105, 15210, 15249, 15250, 15272, 15288, 15435, 15480, 15503, 15539, 15540, 15544, 15582, 15602, 15631, 15664, 15698, 15708, 15730, 15732, 15785, 15870, 15873, 15878, 15912, 15930, 15960]\n\ndef ds_multof_pfs(n, m):\n    return a[bisect_left(a, n):bisect_left(a, m + 1)]
from collections import defaultdict, Counter\n\n\ndef count_sel(nums):\n    cnt = Counter(nums)\n    d = defaultdict(list)\n    total = 0\n    unique = 0\n    for k, v in cnt.items():\n        d[v].append(k)\n        total += v\n        unique += 1\n    maximum = max(d)\n    return [total, unique, len(d[1]), [sorted(d[maximum]), maximum]]\n
def get_age(age):\n    return int(age[0])
def find_min_num(d, n=1):\n    while div_num(n) != d:\n        n += 1\n    return n\n\ndef div_num(n):\n    s = n**0.5\n    return sum(2 for k in range(1, int(s)+1) if n % k == 0) - (s % 1 == 0)
def solution(n, d):\n    return [int(c) for c in str(n)[-d:]] if d > 0 else []
def pascal(p):\n    triangle = [[1]]\n    for _ in range(p - 1):\n        to_sum = list(zip([0] + triangle[-1], triangle[-1] + [0]))\n        triangle.append(list(map(sum, to_sum)))\n    return triangle\n
def bouncy_count(m):\n    num = den = 1\n    for i in range(1, 11):\n        num *= m + i + i * (i == 10)\n        den *= i\n    return 10 ** m - num // den + 10 * m + 1
def infected_zeroes(s):\n    m=0; l=0\n    for i,n in enumerate(s):\n        if n==0: m=i if l==0 else max(m, (i-l+1)//2); l=i+1\n    return max(m,len(s)-l)
def reflections(n, m):\n    x = y = 0\n    dx = dy = 1\n    while 1:\n        x += dx\n        y += dy\n        if x == y == 0 or x == n and y == m: return 1\n        if 0 in (x, y) and (x == n or y == m): return 0\n        if x in (0, n): dx *= -1\n        if y in (0, m): dy *= -1
def segments(m, arr):\n    return [i for i in range(m+1) if not any(a<=i<=b for a,b in arr)]
def is_divide_by(number, a, b):\n    return number % a == 0 and number % b == 0
from itertools import zip_longest\n\ndef reverse_and_combine_text(text):\n    words = text.split(' ')\n    while len(words) > 1:\n        it = map(lambda w: w[::-1], words)\n        words = [a + b for a, b in zip_longest(it, it, fillvalue='')]\n    return words[0]
def bits_battle(nums):\n    binary = '{:b}'.format\n    evens = odds = 0\n    for num in nums:\n        if num % 2:\n            odds += binary(num).count('1')\n        else:\n            evens += binary(num).count('0')\n    if odds == evens:\n        return 'tie'\n    return '{} win'.format('odds' if odds > evens else 'evens')\n
def monty_hall(door, guesses):\n    return round(100.0 * (len(guesses)-guesses.count(door))/len(guesses))
def not_so_random(b,w):\n  return ['White', 'Black'][b % 2]
def switcheroo(s):\n    return s.translate(str.maketrans('ab','ba'))
# return the sum of the two polynomials p1 and p2.  \ndef poly_add(p1,p2):\n    if p1 == []:\n        return p2\n    if p2 == []:\n        return p1\n    return [p1[0] + p2[0]] + poly_add(p1[1:], p2[1:])\n
def find_digit(num, nth):\n    if nth <= 0:\n        return -1\n    try:\n        return int(str(num).lstrip('-')[-nth])\n    except IndexError:\n        return 0
def sum_mul(n, m):\n    if m>0 and n>0:\n        return sum(range(n, m, n))\n    else:\n        return 'INVALID'
cs={'cw':1,'CW':2,'cat':1,'CAT':2,'dog':1,'DOG':2,'movie':1,'MOVIE':2}\n\ndef how_much_coffee(events):\n    c=sum(cs.get(e,0) for e in events)\n    return 'You need extra sleep' if c>3 else c
def rgb(r, g, b):\n    round = lambda x: min(255, max(x, 0))\n    return ("{:02X}" * 3).format(round(r), round(g), round(b))
def atomic_number(electrons):\n    result = []\n    i = 1\n    while electrons > 0:\n        result.append(min(2 * (i ** 2), electrons))\n        electrons -= result[-1]\n        i += 1\n    return result
def hex_word_sum(s):\n    return sum(int(w, 16) for w in s.translate(str.maketrans('OS', '05')).split() if set(w) <= set('0123456789ABCDEF'))
from collections import Counter\nfrom math import ceil\n\nPRIMES = [2] + [n for n in range(3, 1000, 2) if all(n%d for d in range(3, int(n**0.5) +1, 2))]\n\ndef get_factors(n):\n    factors = []\n    for p in PRIMES:\n        if p > n: break\n        while n % p == 0:\n            factors.append(p)\n            n //= p\n    if n > 1:\n        factors.append(n)\n    return Counter(factors)\n\n\ndef mul_power(n, k):\n    factors, lcm = get_factors(n), 1\n    for p, e in factors.items():\n        lcm *= p**(ceil(e/k)*k)\n    return lcm // n
def validate(username, password):\n    print (username, password)\n    if username == 'Timmy' and password == 'password':\n        return 'Successfully Logged in!'\n    elif username == 'Alice' and password == 'alice':\n        return 'Successfully Logged in!'\n    elif username == 'Johny' and password == 'Hf7FAbf6':\n        return 'Successfully Logged in!'  \n    elif username == 'Roger' and password == 'Cheater':\n        return 'Successfully Logged in!'\n    elif username == 'Simon' and password == 'password':\n        return 'Successfully Logged in!'\n    elif username == 'Simon' and password == 'says':\n        return 'Successfully Logged in!'\n    elif username == 'Roger' and password == 'pass':\n        return 'Successfully Logged in!'\n    elif username == 'Admin' and password == 'ads78adsg7dasga':\n        return 'Successfully Logged in!'\n    else:\n        return 'Wrong username or password!'
import math\ndef is_pronic(n):\n    return n >= 0 and math.sqrt(1 + 4 * n) % 1 == 0
def args_count(*args, **kwargs):\n    return len(args) + len(kwargs)
def head_smash(arr):\n    try:\n        return [a.replace('O', ' ') for a in arr] or 'Gym is empty'\n    except TypeError:\n        return "This isn't the gym!!"\n
def f(n):\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b + 1\n    return a
def calculate_total(team1, team2):\n    return sum(team1) > sum(team2)
def consecutive_sum(num):\n    upper_limit = 1\n    while True:\n        if upper_limit * (upper_limit + 1) // 2 > num:\n            break\n        upper_limit += 1\n    return sum([1 if i % 2 and not num % i else 1 if not i % 2 and num % i == i//2 else 0 for i in range(1, upper_limit)])
def sort_array(value):\n    return "".join(sorted(value))
def pairs(ar):\n    count = 0\n    for i in range(0, len(ar), 2):\n        try:\n            a, b = ar[i], ar[i+1]\n        except IndexError:\n            return count\n        \n        if abs(a-b) == 1: \n            count +=1\n        \n    return count
def solution(pairs):\n    return ','.join(sorted('{} = {}'.format(k, pairs[k]) for k in pairs))
def learn_charitable_game(arr):\n  return sum(arr) % len(arr) == 0 and sum(arr) > 0
def shared_bits(a, b):\n    return bin(a & b).count('1') > 1
def delete_digit(n):\n    s = str(n)\n    return int(max(s[:i] + s[i+1:] for i in range(len(s))))
def simple_transposition(text):\n    return text[::2] + text[1::2]
def get_issuer(number):\n    s = str(number)\n    return ("AMEX"       if len(s)==15 and s[:2] in ("34","37") else\n            "Discover"   if len(s)==16 and s.startswith("6011") else\n            "Mastercard" if len(s)==16 and s[0]=="5" and s[1] in "12345" else\n            "VISA"       if len(s) in [13,16] and s[0]=='4' else\n            "Unknown")
from itertools import product\n\nNOTES =  [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']]*2\nconfig = [('Major', 4), ('Minor', 3)]\n\nDCT_CHORDS = {c: mode for mode, offset in config\n                      for i in range(len(NOTES)//2)\n                      for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef minor_or_major(chord):\n    chord = tuple(chord.split()) if isinstance(chord, str) else ""\n    return DCT_CHORDS.get(chord, "Not a chord")
from math import log10\n\ndef rocks(n):\n    return (n + 1) * int(log10(n) + 1) - (10 ** int(log10(n) + 1) - 1) // 9
from re import compile, finditer\n\nOMIT = {'a', 'the', 'on', 'at', 'of', 'upon', 'in', 'as'}\nREGEX = compile(r'[a-z]+')\n\n\ndef word_count(s):\n    return sum(a.group() not in OMIT for a in finditer(REGEX, s.lower()))\n
def str_count(strng, letter):\n    counter = 0\n    \n    for chr in strng:\n        if chr == letter:\n            counter += 1\n        \n    return counter
import re\n\ndef kontti(s):\n    return  " ".join( [ re.sub("([^aeiouy]*[aeiouy])(.*)", r"ko\2-\1ntti", w, flags = re.I) for w in s.split() ] )
from itertools import product\n\nBOARD = set(map("".join,product("ABCDEFGH", "12345678")))\n\ndef available_moves(position):\n    if isinstance(position, str) and position in BOARD :\n\n        return sorted(p for p in BOARD-{position}  \n                      if abs(ord(p[0])-ord(position[0])) == abs(int(p[1]) - int(position[1])) \n                      or position[0]==p[0]\n                      or p[1]==position[1] )\n\n    return []\n
def two_highest(ls):\n    result = sorted(list(set(ls)), reverse=True)[:2]\n    return result if isinstance(ls, (list)) else False
def best_match(goals1, goals2):\n    return min( (a-b, -b, i) for i,(a,b) in enumerate(zip(goals1, goals2)) )[2]
def friend(x):\n    return [f for f in x if len(f) == 4]
def locate(seq, value): \n    for s in seq:\n        if s == value or (isinstance(s,list) and locate(s, value)): \n            return True\n    return False
def min_value(digits):\n     return int("".join(map(str,sorted(set(digits)))))\n
def is_solved(board):\n    curr = 0;\n    for r in board:\n        for c in r:\n            if c != curr:\n                return False;\n            curr+=1;\n    return True;
import math\n\ndef factorial(n):\n    if n >= 0:\n        return math.factorial(n)
def levenshtein(a,b):\n    d = [[0] * (len(b) + 1) for _ in range(len(a) + 1)]\n\n    d[0][:] = list(range(len(b)+1))\n    for i in range(1, len(a) + 1):\n        d[i][0] = i\n\n    for i, x in enumerate(a):\n        for j, y in enumerate(b):\n            d[i+1][j+1] = min(1 + d[i][j+1], 1 + d[i+1][j], d[i][j] + (1 if x != y else 0))\n\n    return d[-1][-1]\n\n
def nb_dig(n, d):\n    return sum(str(i*i).count(str(d)) for i in range(n+1))
def alphabetic(s):\n    return sorted(s) == list(s)\n
def factorsRange(n, m):\n    return {i: [j for j in range(2, i) if i % j == 0] or ['None'] for i in range(n, m + 1)}
def interpreter(tape):\n    memory, ptr, output = {}, 0, ""\n    \n    for command in tape:\n        if   command == ">":  ptr += 1\n        elif command == "<":  ptr -= 1\n        elif command == "+":  memory[ptr] = (memory.get(ptr, 0) + 1) % 256\n        elif command == "*":  output += chr(memory[ptr])\n    \n    return output
def bowling_score(rolls):\n  "Compute the total score for a player's game of bowling."\n  \n  def is_spare(rolls):\n    return 10 == sum(rolls[:2])\n\n  def is_strike(rolls):\n    return 10 == rolls[0]\n\n  def calc_score(rolls, frame):\n    return (sum(rolls) if frame == 10 else\n            sum(rolls[:3]) + calc_score(rolls[1:], frame+1) if is_strike(rolls) else\n            sum(rolls[:3]) + calc_score(rolls[2:], frame+1) if is_spare(rolls) else\n            sum(rolls[:2]) + calc_score(rolls[2:], frame+1))\n  \n  return calc_score(rolls,1)\n
import numpy as np\n\ndef getMatrixProduct(a, b):\n    try:\n        return np.matmul(a, b).tolist()\n    except:\n        return - 1
def abacaba(k):\n    return next(chr(97+i) for i,d in enumerate(f'{k:b}'[::-1]) if d=='1')
from collections import Counter\ndef obtain_max_number(arr):\n    c = Counter(arr)\n    while 1:\n        find = next((k for k in c if c[k] > 1), None)\n        if not find:return max(c)\n        c[find] -= 2\n        c[find*2] = c.get(find*2,0) + 1
def solve(st):\n    return sorted((st.find(c) - st.rfind(c), c) for c in set(st))[0][1]
def gen(n):\n    if n >= 10**16: return\n    for i in range(10):\n        x = 10*n + i\n        if x % sum(map(int, str(x))): continue\n        yield x\n        for y in gen(x): yield y\nL = sorted(x for n in range(1, 10) for x in gen(n))\n\nfrom bisect import bisect_left as bl, bisect_right as br\ndef rthn_between(a, b):\n    return L[bl(L, a):br(L, b)]
def candies(s):\n    if not s or len(s) == 1:\n        return -1\n    return len(s) * max(s) - sum(s)\n
from re import sub\ndef vowel_start(st):\n    return sub(r'(?<=.)([aeiou])', r' \1', sub(r'[^a-z0-9]', '', st.lower()))\n
def trace(matrix):\n    if not matrix or len(matrix) != len(matrix[0]):\n        return None\n    return sum(matrix[i][i] for i in range(len(matrix)))
def print_nums(*arr):\n    if not arr: return ''\n    ln = len(str(max(arr)))\n    return '\n'.join(str(c).zfill(ln) for c in arr)
def solve(s):\n    return any(s[i+1:] + s[:i+1] == s[i::-1] + s[:i:-1] for i in range(len(s)))
def elevator(left, right, call):\n    return "left" if abs(call - left) < abs(call - right) else "right"
thue_morse=lambda n: "0110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010011001011001101001011010011001011010010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101101001011001101001011010011001011001101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010011001011001101001011010011001011010010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010011001011001101001011010011001011010010110011010010110100110010110011010011001011010010110011010011001011001101001011010011001011001101001100101101001011001101001011010011001011010010110011010011001011001101001011010011001011010010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010011001011001101001011010011001011010010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010011001011001101001011010011001011010010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101101001011001101001011010011001011001101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101101001011001101001011010011001011001101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101101001011001101001011010011001011001101001100101101001011001101001011010011001011010010110011010011001011001101001011010011001011001101001100101101001011001101001100101100110100101101001100101101001011001101001011010011001011001101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101101001011001101001011010011001011001101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010011001011001101001011010011001011010010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101101001011001101001011010011001011001101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010011001011001101001011010011001011010010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010011001011001101001011010011001011010010110011010010110100110010110011010011001011010010110011010011001011001101001011010011001011001101001100101101001011001101001011010011001011010010110011010011001011001101001011010011001011010010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010011001011001101001011010011001011010010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100101101001100101101001011001101001100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110100101100110100101101001100101100110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010010110100110010110100101100110100110010110011010010110100110010110011010011001011010010110011010011001011001101001011010011001011010010110011010010110100110010110011010011001011010010110011010010110100110010110"[:n]
import re\ndef repeating_fractions(n, d):\n  (i, d) = str(n * 1.0 / d).split('.')\n  return i + '.' + re.sub(r'([0-9])\1+', r'(\1)', d)
def alternateCase(s):\n    return s.swapcase()
import re\n\ndef textin(txt ):\n  return re.sub(r'(two|too|to)', '2', txt, flags=re.I)
def lcs(x, y):\n    if len(x) == 0 or len(y) == 0:\n        return ''\n    if x[-1] == y[-1]:\n        return lcs(x[:-1], y[:-1]) + x[-1]\n    else:\n        lcs1 = lcs(x,y[:-1])\n        lcs2 = lcs(x[:-1],y)\n        if len(lcs1) > len(lcs2):\n            return lcs1\n        else:\n            return lcs2\n
import string\n\ndb = { 'A':'Alfa','B':'Bravo','C':'Charlie','D':'Delta','E':'Echo',\n       'F':'Foxtrot','G':'Golf','H':'Hotel','I':'India','J':'Juliett',\n       'K':'Kilo','L':'Lima','M':'Mike','N':'November','O':'Oscar',\n       'P':'Papa','Q':'Quebec','R':'Romeo','S':'Sierra','T':'Tango',\n       'U':'Uniform','V':'Victor','W':'Whiskey','X':'Xray','Y':'Yankee',\n       'Z':'Zulu'\n      }\n\ndef to_nato(words):\n    words = words.replace(' ','').upper()\n    return ' '.join([db[i] if i in db else i for i in list(words)])
def remove(s):\n    return s.replace('!', '')+ '!'*(len(s)- len(s.rstrip('!')))
def close_compare(a, b, margin = 0):\n    return 0 if abs(a - b) <= margin else -1 if b > a else 1
def sum_of_n(n):\n    return [(-1 if n < 0 else 1) * sum(range(i+1)) for i in range(abs(n)+1)]\n
def sum_str(a, b):\n    return str(int(a or 0) + int(b or 0))
def palindrome(num,s):\n    if not (type(num) == type(s) == int) or num < 0 or s < 0:\n        return "Not valid"\n    \n    ans, num = [], max(num, 11)\n    while len(ans) != s:\n        if num == int(str(num)[::-1]):\n            ans.append(num)\n        num += 1\n    return ans
def is_bouncy(n):\n    return sorted(str(n)) != list(str(n)) and sorted(str(n)) != list(str(n))[::-1]
def is_magical(sq):\n    return sum(sq[2:7:2])==sum(sq[::4])==sum(sq[::3])==sum(sq[1::3])==sum(sq[2::3])==sum(sq[:3])==sum(sq[3:6])==sum(sq[6:])
def rain_amount(mm):\n    if mm < 40:\n             return "You need to give your plant " + str(40 - mm) + "mm of water"\n    else:\n             return "Your plant has had more than enough water for today!"
def get_required(player,enemy):\n    p_sum = sum(player)\n    e_sum = sum(enemy)\n    \n    diff = p_sum - e_sum\n    \n    if diff == 0:\n        return 'Random'\n    \n    if diff > 5:\n        return 'Auto-win'\n    \n    if diff < -5:\n        return 'Auto-lose'\n    \n    if diff == -5:\n        return 'Pray for a tie!'\n    \n    s = ''\n    \n    if diff < 0:\n        s = '(1..{0})'.format(6-abs(diff)-1)\n    else:\n        s = '({0}..6)'.format(6-diff+1)\n    \n    return s
def most_frequent_item_count(collection):\n    if collection:\n        return max([collection.count(item) for item in collection])\n    return 0
def palindrome(num):\n    if type(num) is not int or num <1:\n        return "Not valid"\n    return num == int(str(num)[::-1])
def mix_fruit(arr):\n    regular = ["banana", "orange", "apple", "lemon", "grapes"]\n    special = ["avocado", "strawberry", "mango"]\n    return round(sum(5 if fruit.lower() in regular else (7 if fruit.lower() in special else 9) for fruit in arr)/len(arr))\n
import numpy as np\n\ndef transpose(A):\n    if len(A) == 0:\n        return []\n    return np.array(A, dtype = 'O').T.tolist() if len(A[0]) > 0 else [[]]
import re\n\nSKIPERS = re.compile(r'|'.join(["\\\*.*?\*/", "--.*?(\n|$)", "''"]))\n\ndef get_textliterals(code):\n    code = SKIPERS.sub(lambda m: "x"*len(m.group()) , code.rstrip())\n    if code.count("'") % 2: code += "'"\n    return [(m.start(), m.end()) for m in re.finditer(r"'.+?'", code, flags=re.DOTALL)]
from functools import reduce\n\ndef solve(st):\n    res, s, k = [], "", 1\n    for ch in st:\n        if ch == '(': res.append(k); k = 1\n        elif ch == ')': res.pop(); k = 1\n        elif ch == '-': k = -1\n        elif ch == '+': k = 1\n        else: s+= '-'+ch if (reduce(lambda a,b: a * b,res,1) * (1 if k == 1 else -1) < 0) else '+'+ch\n    return s if s[0] == '-' else s[1:]
def get_volume_of_cuboid(length, width, height):\n    return length * width * height\n\n\n# PEP8: kata function name should use snake_case not mixedCase\ngetVolumeOfCubiod = get_volume_of_cuboid
def vowel_back(st):\n    return st.translate(str.maketrans("abcdefghijklmnopqrstuvwxyz", "vkbaafpqistuvwnyzabtpvfghi"))
def greet(language):\n    return {\n        'czech': 'Vitejte',\n        'danish': 'Velkomst',\n        'dutch': 'Welkom',\n        'english': 'Welcome',\n        'estonian': 'Tere tulemast',\n        'finnish': 'Tervetuloa',\n        'flemish': 'Welgekomen',\n        'french': 'Bienvenue',\n        'german': 'Willkommen',\n        'irish': 'Failte',\n        'italian': 'Benvenuto',\n        'latvian': 'Gaidits',\n        'lithuanian': 'Laukiamas',\n        'polish': 'Witamy',\n        'spanish': 'Bienvenido',\n        'swedish': 'Valkommen',\n        'welsh': 'Croeso'\n    }.get(language, 'Welcome')
def unique_sum(lst):\n    return sum(set(lst)) if lst else None\n
def last_digit(n1, n2):\n    return pow( n1, n2, 10 )
def get_digits(n):\n    return [int(x) for x in list(str(n))]\n\n\ndef is_narc(n):\n    return n == sum([x**len(get_digits(n)) for x in get_digits(n)])\n\n\ndef is_narcissistic(*values):\n    try:\n        return all(type(n) in [int,str] and is_narc(int(n)) for n in values)\n    except ValueError:\n        return False
def increasing_numbers(d):\n    s = 1\n    for i in range(1,10): s=s*(i+d)//i\n    return s
from math import ceil\n\ndef growing_plant(up, down, h):\n    return max(ceil((h - down) / (up - down)), 1)
def count_inversions(array):\n    inv_count = 0\n    for i in range(len(array)):\n        for j in range(i, len(array)):\n            if array[i] > array[j]:\n                inv_count += 1\n    return inv_count
DIRS = {'Left': 'Right', 'Right': 'Left'}\n\ndef solve(arr):\n    lst,prevDir = [], 'Begin'\n    for cmd in arr[::-1]:\n        d, r    = cmd.split(' on ')\n        follow  = DIRS.get(prevDir, prevDir)\n        prevDir = d\n        lst.append(f'{follow} on {r}')\n    return lst
pattern = lambda n: "\n".join(["".join([str(y) for y in range(x + 1, n + 1)]) for x in range(n)]);
def array_center(lst):\n    return [i for i in lst if abs(i - sum(lst)*1.0/len(lst)) < min(lst)]
def big_primefac_div(n):\n    bpf, bd = 0, 1\n    frac = []\n    \n    if n % 1 != 0:\n        return "The number has a decimal part. No Results"\n    else:\n        n = abs(int(n))\n        n_copy = n\n  \n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            n //= i\n            frac.append(i)\n        else:\n            i += 1\n    if n > 1: frac.append(n)\n\n    bpf = max(frac)\n    bd = n_copy / frac[0]\n            \n    if bpf == 0 or bd == 1:\n        return []\n    else:\n        return [bpf, bd]
who_is_paying = lambda n: [n, n[:2]] if len(n)>2 else [n]
import random\ndef squares(n):\n    return [i**2 for i in range(1, n+1)]\n\ndef num_range(n, start, step):\n    return [i for i in range(start, start+step*n, step)]\n\ndef rand_range(n, mn, mx):\n    return [random.randint(mn, mx) for i in range(n)]\ndef primes(n):\n    return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113][:n]
import math\ndef is_prime(n):\n    if n < 2: \n        return False\n    return all(n % i for i in range(3, int(math.sqrt(n)) + 1, 2))
def polydivisible(x):\n    for i in range(1, len(str(x)) + 1):\n        if int(str(x)[:i]) % i != 0:\n            return False\n    return True
def combine(*bs):\n    c = {}\n    for b in bs:\n        for k, v in list(b.items()):\n            c[k] = v + c.get(k, 0)\n    return c\n
def aks_test(p):\n    lst = []\n    for i in range(2, p+1):\n        for j in lst:\n            if i % j == 0:\n                break\n        else:\n            lst.append(i)\n    if p in lst:\n        return True\n    else:\n        return False
def unflatten(flat_array):\n    arr = flat_array[:]\n    for i, v in enumerate(arr):\n        if v > 2:\n            arr[i], arr[i+1:i+v] = arr[i:i+v], []\n    return arr
def solve(s):\n    isOK = lambda x: x == x[::-1]\n    \n    return ("OK" if isOK(s)  else\n            "remove one" if any( isOK(s[:i]+s[i+1:]) for i in range(len(s)) ) else\n            "not possible")
def nba_extrap(ppg, mpg):\n    return round(48.0 / mpg * ppg, 1) if mpg > 0 else 0
import re\ndef dashatize(num):\n    try:\n        return ''.join(['-'+i+'-' if int(i)%2 else i for i in str(abs(num))]).replace('--','-').strip('-')\n    except:\n        return 'None'
def find_2nd_largest(arr):\n    arr = sorted(i for i in set(arr) if type(i) == int)\n    return arr[-2] if len(arr) > 1 else None
def omit_hashtag(message, hashtag):\n    return message.replace(hashtag, "", 1)
def denumerate(enum_list):\n    try:\n        nums = dict(enum_list)\n        maximum = max(nums) + 1\n        result = ''.join(nums[a] for a in range(maximum))\n        if result.isalnum() and len(result) == maximum:\n            return result\n    except (KeyError, TypeError, ValueError):\n        pass\n    return False\n
import re\n\ndef insert_dash(num):\n    #your code here\n    return re.sub(r'([13579])(?=[13579])', r'\1-', str(num))
def sum_array(arr):\n    if arr == None or len(arr) < 3:\n        return 0\n    return sum(arr) - max(arr) - min(arr)
def my_add(a, b):\n    try:\n        return a + b\n    except TypeError:\n        return None\n
def josephus(xs, k):\n    i, ys = 0, []\n    while len(xs) > 0:\n        i = (i + k - 1) % len(xs)\n        ys.append(xs.pop(i))\n    return ys
import re\ndef rad_ladies(name):\n    return "".join(re.findall("[A-Z\s!]+", name.upper()))
def compute_depth(n):\n    i = 0\n    digits = set()\n    while len(digits) < 10:\n        i += 1\n        digits.update(str(n * i))\n    return i
from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c:i for i,c in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef whoIsWinner(moves, con, sz):\n    def gen(i, j):\n        for x in range(1, con):\n            yield ((i, j-x), (i-x, j), (i+x, j), (i-x, j-x), (i+x, j+x), (i+x, j-x), (i-x, j+x))\n    \n    def check(i, j, p):\n        memo, count = [True]*7, [0]*7\n        for L in gen(i, j):\n            for x,(k,l) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < sz and 0 <= l < sz and grid[k][l] == p\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1]+count[2], count[3]+count[4], count[5]+count[6])+1 >= con\n        return True\n    \n    if sz >= con <= len(moves):\n        grid = [[None]*sz for _ in range(sz)]\n        for move in moves:\n            i, p = D[move[0]], move[-1]\n            j = next(j for j,x in enumerate(grid[i]) if x is None)\n            if check(i, j, p): return p\n            grid[i][j] = p\n    return "Draw"
def max_and_min(arr1,arr2):\n    diffs = [abs(x-y) for x in arr1 for y in arr2]\n    return [max(diffs), min(diffs)]\n
def palindrome_pairs(w):\n  return [[i, j] for i in range(len(w)) for j in range(len(w)) if str(w[i])+str(w[j])==(str(w[i])+str(w[j]))[::-1] and i!=j]
from math import floor\n#Pretty sure this is the fastest implementation; only one square root, and sqrt(n) multiplications.\n#Plus, no booleans, because they're super slow.\nlocker_run = lambda l: [i * i for i in range(1, int(floor(l ** .5)) + 1)]
from collections import OrderedDict\ndef unique(integers):\n    return list(OrderedDict.fromkeys(integers))
from math import ceil\ndef reindeer(presents):\n  if presents > 180: raise ValueError("Too many presents")\n  return ceil(presents / 30.0) + 2
def count_sheep(n):\n    return ''.join(f"{i} sheep..." for i in range(1,n+1))
# Stirling numbers of second kind\n# http://mathworld.wolfram.com/StirlingNumberoftheSecondKind.html\n# S(n,k)=1/(k!)sum_(i=0)^k(-1)^i(k; i)(k-i)^n\nfrom math import factorial as fact\n\ndef combs_non_empty_boxes(n,k):\n    if k<0 or k>n: return 'It cannot be possible!'\n    return sum([1,-1][i%2]*(k-i)**n*fact(k)//(fact(k-i)*fact(i)) for i in range(k+1))//fact(k)
def distance(p1, p2):\n    return sum((a - b) ** 2 for a, b in zip(p1, p2)) ** 0.5 if len(p1) == len(p2) > 0 else -1
def multi_table(number):\n    return '\n'.join(f'{i} * {number} = {i * number}' for i in range(1, 11))
import re\n\ndef scramble_words(words):\n    def sort_letters(match):\n        s = match.group()\n        letters = iter(sorted(filter(str.isalpha, s[1:-1])))\n        return s[0] + "".join(next(letters) if c.isalpha() else c for c in s[1:-1]) + s[-1]\n    return re.sub(r'[a-z][^\s]*[a-z]', sort_letters, words)
def two_decimal_places(n):\n    return round(n, 2)\n
def number_format(n):\n    return f'{n:,}'
def avoid_obstacles(arr):\n  n=2\n  while 1: \n    if all([x%n for x in arr]): return n\n    n+=1
def distribute(m, n):\n    if n <= 0:\n        return []\n    q, r = divmod(max(m, 0), n)\n    return [q + (i < r) for i in range(n)]
def year_days(year):\n    days = 365\n    if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:\n        days += 1\n    return "%d has %d days" % (year, days)
def diagonal_sum(array):\n    return sum(row[i] for i, row in enumerate(array))
def cal_n_bug(n_head, n_leg, n_wing):\n    spider = (n_leg-n_head*6)//(8-6)\n    butterfly = (n_wing-(n_head-spider))\n    dragonfly = n_head-spider-butterfly\n    return [spider,butterfly,dragonfly] if spider>=0 and butterfly>=0 and dragonfly>=0 else [-1,-1,-1]
def solve(s):\n    return max(map(len, ''.join(c if c in 'aeiou' else ' ' for c in s).split()))
def is_lucky(n):\n    return n % 9 == 0
def pattern(n, *y):\n    if n < 1:\n        return ""\n    y = y[0] if y and y[0] > 0 else 1\n    result = []\n    for j in range(1, n + 1):\n        line = " " * (j - 1) + str(j % 10) + " " * (n - j)\n        result.append(line + line[::-1][1:])\n    return "\n".join(((result + result[::-1][1:-1]) * y)) + "\n" + result[0]
def meeting(rooms, need):\n    if need == 0: return "Game On"\n    \n    result = []\n    for people, chairs in rooms:\n        taken = min(max(chairs - len(people), 0), need)\n        result.append(taken)\n        need -= taken\n        if need == 0: return result\n        \n    return "Not enough!"
def solve(arr): return sum(set(arr))\n
def chess_triangle(n, m):\n    return sum( 8 * (n-x+1)*(m-y+1) for dims in {(3,4), (3,3), (2,4), (2,3)} for x,y in [dims, dims[::-1]] if x <= n and y <= m )\n
from itertools import groupby\ndef count_repeats(s):\n    return len(s) - len(list(groupby(s)))
def get_exponent(n, p):\n    if p > 1:\n        x = 0\n        while not n % p:\n            x += 1\n            n //= p\n        return x
def solve(n):\n    for i in range(int(n**0.5), 0, -1):\n        x = n - i**2\n        if x > 0 and x % (2*i) == 0:\n            return ((n - i ** 2) // (2 * i)) ** 2\n    return -1
def palindrome_rearranging(s):\n    return sum(s.count(c) % 2 for c in set(s)) < 2
def string_chunk(string, n=0):\n    return [string[i:i+n] for i in range(0,len(string), n)] if isinstance(n, int) and n > 0 else []\n
import re\ndef is_mac_48_address(address):\n  return bool(re.match("^([0-9A-F]{2}[-]){5}([0-9A-F]{2})$", address.upper()))
def divisible_by_three(s): \n    return int(s) % 3 == 0\n\n
def has_subpattern(string):\n    return (string * 2).find(string, 1) != len(string)
from operator import mul\nfrom functools import reduce\n\n\ndef unique_digit_products(nums):\n    return len({reduce(mul, (int(a) for a in str(num))) for num in nums})\n
from itertools import chain, zip_longest\n\ndef alternate_sort(l):\n    l=sorted(l,key=abs)\n    p,n=[n for n in l if n>=0],[n for n in l if n<0]\n    return [n for n in chain(*zip_longest(n,p)) if n is not None]
from itertools import chain\n\nTOME = {\n    '8 weeks':   ['fiveInOne', 'pneumococcal', 'rotavirus', 'meningitisB'],\n    '12 weeks':  ['fiveInOne', 'rotavirus'],\n    '16 weeks':  ['fiveInOne', 'pneumococcal', 'meningitisB'],\n    '12 months': ['meningitisB', 'hibMenC', 'measlesMumpsRubella'],\n    '40 months': ['measlesMumpsRubella', 'preSchoolBooster'],\n    'september': ['offer fluVaccine'],\n    'october':   ['offer fluVaccine'],\n    'november':  ['offer fluVaccine'],\n}\n\ndef vaccine_list(*args):\n    return sorted(set(chain.from_iterable(\n        TOME.get(s,()) for s in args\n    )))
import re\n\ndef is_valid(idn):\n    return re.compile('^[a-z_\$][a-z0-9_\$]*$', re.IGNORECASE).match(idn) != None
def meeting_time(Ta, Tb, r):\n    if Ta == 0:\n        return "{:.2f}".format(abs(Tb))\n    elif Tb == 0:\n        return "{:.2f}".format(abs(Ta))\n    else:\n        return "{:.2f}".format(abs(Ta * Tb / (Tb - Ta)))
def people_with_age_drink(age):\n    if age > 20: return 'drink whisky'\n    if age > 17: return 'drink beer'\n    if age > 13: return 'drink coke'\n    return 'drink toddy'
from math import ceil\n\ndef round_it(n):\n    left, right = (len(part) for part in str(n).split("."))\n    return ceil(n) if left < right else int(n) if left > right else round(n)
def climb(n):\n    return [1] if n == 1 else climb(int(n/2)) + [n]
def index(array, n):\n    try:\n        return array[n]**n\n    except:\n        return -1
def is_happy(n):\n    seen = set()\n    while n not in seen:\n        seen.add(n)\n        n = sum( int(d)**2 for d in str(n) )\n    return n == 1\n\n\ndef happy_numbers(n):    \n    return [x for x in range(1, n+1) if is_happy(x)]
from heapq import heappop, heappush\n\ndef comb(fruits):\n    total, heap = 0, sorted(fruits)\n    while len(heap) > 1:\n        cost = heappop(heap) + heappop(heap)\n        heappush(heap, cost)\n        total += cost\n    return total
def seven_ate9(str_):\n   while str_.find('797') != -1:\n       str_ = str_.replace('797','77')\n   return str_
def int_to_word(num):\n    d = { 0 : 'zero', 1 : 'one', 2 : 'two', 3 : 'three', 4 : 'four', 5 : 'five',\n          6 : 'six', 7 : 'seven', 8 : 'eight', 9 : 'nine', 10 : 'ten',\n          11 : 'eleven', 12 : 'twelve', 13 : 'thirteen', 14 : 'fourteen',\n          15 : 'fifteen', 16 : 'sixteen', 17 : 'seventeen', 18 : 'eighteen',\n          19 : 'nineteen', 20 : 'twenty',\n          30 : 'thirty', 40 : 'forty', 50 : 'fifty', 60 : 'sixty',\n          70 : 'seventy', 80 : 'eighty', 90 : 'ninety' }\n\n\n    assert(0 <= num)\n\n    if (num < 20):\n        return d[num]\n\n    if (num < 100):\n        if num % 10 == 0: return d[num]\n        else: return d[num // 10 * 10] + '-' + d[num % 10]\n\n    if (num < 1000):\n        if num % 100 == 0: return d[num // 100] + ' hundred'\n        else: return d[num // 100] + ' hundred and ' + int_to_word(num % 100)\n\ndef sort_by_name(arr):\n    return sorted(arr, key=int_to_word)\n
from collections import Counter\n\ndef number_of_pairs(gloves):\n    return sum(c // 2 for c in Counter(gloves).values())
def greet(name):\n    return "Hello, {} how are you doing today?".format(name)
from textwrap import wrap\n\ndef to_utf8_binary(string):\n    return ''.join(format(x, 'b').rjust(8, '0') for x in bytearray(string, 'utf-8'))\n \ndef from_utf8_binary(bitstring):\n    return bytearray([int(t, 2) for t in wrap(bitstring, 8)]).decode()\n
import numpy as np\nfrom itertools import accumulate\ndef sieve_primes(n):\n    sieve = np.ones(n // 2, dtype = np.bool)\n    limit = 1 + int(n ** 0.5)\n\n    for a in range(3, limit, 2):\n        if sieve[a // 2]:\n            sieve[a * a // 2::a] = False\n\n    prime_indexes = 2 * np.nonzero(sieve)[0].astype(int) + 1\n    prime_indexes[0] = 2\n    return set(map(str, prime_indexes))\n\nprimes = sieve_primes(10 ** 6)\n\ndef all_primes(s):\n    if int(s) < 10:\n        return s in primes\n    for n in accumulate(s[:-1]):\n        if n in primes:\n            m = s[len(n):]\n            if m in primes or all_primes(m):\n                return True\n\ndef total_primes(a, b):\n    return [int(a) for a in map(str, range(max(10, a), b + 1)) if a in primes and all_primes(a)]
def simplify(p):\n    new_p=[(0,0)]\n    new_str=''\n    x=0\n    y=0\n    for i in p:\n        if i == '<':\n            x-=1\n        elif i == '>':\n            x+=1\n        elif i == '^':\n            y+=1\n        elif i == 'v':\n            y-=1\n        if (x,y) not in new_p:\n            new_p.append((x,y))\n            new_str+=i\n        else:\n            for j in new_p[::-1]:\n                if j != (x,y):\n                    new_p.pop()\n                    new_str=new_str[:-1]\n                else:\n                    break\n    return new_str
def roof_fix(new, old):\n    return all(patch == ' ' for patch, tile in zip(new, old) if tile in '\/')
def binary_cleaner(seq): \n    res = ([], [])\n    for i,x in enumerate(seq):\n        if x < 2: res[0].append(x)\n        else: res[1].append(i)\n    return res
def totalAmountVisible(topNum, numOfSides):\n    return numOfSides*(numOfSides+1)/2-(numOfSides-topNum+1)\n
from itertools import cycle\ndef interpreter(tape, array):\n    idx, result = 0, list(map(int, array))\n    for cmd in cycle(map(int, tape)):\n        if idx == len(array): break\n        if cmd: result[idx] = 1-result[idx]\n        else: idx += 1\n    return ''.join(map(str, result))
def playerRankUp(pts):\n    msg = "Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up." \n    return msg if pts >=100 else False
from statistics import mean\n\ndef grey(rgb):\n    return [int(round(mean(rgb)))]*3\n\ndef color_2_grey(colors):\n    return [[grey(pixel) for pixel in row] for row in colors]
def fit_in(a, b, m, n):\n  return max(a, b) <= min(m, n) and a + b <= max(m, n)
def is_even(x):\n    return all(int(i) % 2 == 0 for i in str(x))\ndef even_digit_squares(a, b):\n    first = int(a ** (1 / 2)) + 1\n    last = int(b ** (1 / 2)) + 1\n    return sorted([x * x for x in range(first, last) if is_even(x * x)])
def number(bus_stops):\n    return sum([stop[0] - stop[1] for stop in bus_stops])
lower = "abcdefghijklmnopqrstuvwxyz"\n\ndef one_down(txt):\n    if not isinstance(txt, str):\n        return "Input is not a string"\n    shifted = lower[-1] + lower[:-1]\n    table = str.maketrans(lower + lower.upper(), shifted + shifted.upper())\n    return txt.translate(table)
def is_odd_heavy(arr):\n    maxEven, minOdd = ( f(filter(lambda n: n%2 == v, arr), default=float("-inf")) for f,v in ((max, 0), (min,1)) )\n    return maxEven < minOdd
from functools import reduce\nfrom operator import mul\n\ndef multi(l_st):\n    return reduce(mul,l_st)\ndef add(l_st):\n    return sum(l_st)\ndef reverse(s):\n    return s[::-1]
def select(memory):\n    lst = memory.split(', ')\n    bad = {who.strip('!') for prev,who in zip(['']+lst,lst+[''])  if who.startswith('!') or prev.startswith('!')}\n    return ', '.join(who for who in map(lambda s: s.strip('!'), lst) if who not in bad)
def string_cnt(s):\n    try:\n        if s.isalpha():\n            return sum(ord(a) for a in s.upper())\n    except AttributeError:\n        pass\n    return 0\n\n\ndef compare(s1, s2):\n    return string_cnt(s1) == string_cnt(s2)
triangular_sum=lambda n: (-0.5+(1+8*n)**0.5/2.0)**0.5%1==0
def group_by_commas(n):\n    return '{:,}'.format(n)
from math import log2\n\ndef t(n):\n    if n == 0:\n        return 0\n    k = int(log2(n))\n    i = n - 2**k\n    if i == 0:\n        return (2**(2*k+1)+1) // 3\n    else:\n        return t(2**k) + 2*t(i) + t(i+1) - 1\n\ntoothpick = t
def circle_slash(n):\n  return int(bin(n)[3:]+'1', 2)
def twos_difference(a):\n    s = set(a)\n    return sorted((x, x + 2) for x in a if x + 2 in s)
def grabscrab(said, possible_words):\n    return [ word for word in possible_words if sorted(word) == sorted(said) ]
def count_odd_pentaFib(n):\n    return 2 * (n // 6) + [0, 1, 2, 2, 2, 2][n % 6] - (n >= 2)
def longer(s):\n    return ' '.join(sorted(s.split(), key=lambda w: (len(w), w)) )
from functools import reduce\n\ndef crashing_weights(weights):\n    return reduce(lambda a, b: [a1 + b1 if a1 > b1 else b1 for a1, b1 in zip(a, b)], weights)
from pprint import *\nuni= {'q': '\u2655', 'B': '\u265D', 'p': '\u2659', 'K': '\u265A',\n                   'N': '\u265E', 'Q': '\u265B', 'P': '\u265F', 'R': '\u265C',\n                   'n': '\u2658', 'r': '\u2656', 'b': '\u2657', 'k': '\u2654',\n              1:"\u2587",0:"\uFF3F"}\ndef parse_fen(string):\n    board=[[1,0,1,0,1,0,1,0] if not i%2 else [0,1,0,1,0,1,0,1] for i in range(8) ]\n\n    col,row=0,0\n    pos=0\n    placement,turn=string.split(" ")[:2]\n\n    while pos<len(placement):\n        if placement[pos]=="/":\n            row+=1\n            col=0\n\n        elif (placement[pos]).isdigit():\n            col+=int(placement[pos])\n\n        else:\n            board[row][col] = uni[placement[pos]]\n            col+=1\n\n        pos+=1\n\n    board = [[uni[i] if type(i) is int else i for i in x] for x in board]\n\n    if turn=="b":\n        board=[list(v)[::-1] for v in zip(*[i[::-1] for i in zip(*board)])]\n        \n    return "\n".join(["".join(i) for i in board])+"\n"\n\n
def create_array(n):\n    res=[]\n    i=1\n    while i<=n:\n        res+=[i]\n        i+= 1\n    return res
import re\n\nmy_regexp = (r'(?P<sign>[+\-]?)'\n             r'(?P<coeff>\d*)'\n             r'x'\n             r'(?:\^(?P<exp>\d+))?')\n\nas_int = lambda s: int(s) if s else 1\n\ndef derivative(eq):\n    result = ''\n    for monom in re.finditer(my_regexp, eq):\n        sign, coeff, exp = monom.groups()\n        coeff,exp = list(map(as_int, (coeff,exp)))\n        coeff *= exp\n        exp -= 1\n        result += ('{sign}{coeff}' if exp==0 else \n                   '{sign}{coeff}x' if exp==1 else\n                   '{sign}{coeff}x^{exp}'\n                  ).format(sign=sign, coeff=coeff, exp=exp)\n    return result if result else '0'\n        \n
def triple_double(num1, num2):\n    return any([i * 3 in str(num1) and i * 2 in str(num2) for i in '0123456789'])
import re\n\n\ndef to_cents(amount):\n    m = re.match(r'\$(\d+)\.(\d\d)\Z', amount)\n    return int(m.expand(r'\1\2')) if m else None\n
def palindrome(num):\n    if not isinstance(num, int) or num < 0:\n        return "Not valid"\n    n = str(num)\n    l = len(n)\n    result = {int(n[i:j]) for i in range(l-1) for j in range(i+2, l+1) if int(n[i]) and n[i:j] == n[i:j][::-1]}\n    return sorted(result) if result else "No palindromes found"\n
import re\n\nPATTERN = re.compile(r'(?P<first>(?:(?<=[.!?] )|^)\w+)|(?P<other>\w+)')\n\ndef pete_talk(speech,ok=[]):\n\n    def watchYourMouth(m):\n        w = (m.group("first") or m.group("other")).lower()\n        if w not in ok and len(w) > 1: w = w[0] + '*'*(len(w)-2) + w[-1]\n        if m.group("first"): w = w.capitalize()\n        return w\n    \n    ok = set(map(str.lower, ok))\n    return PATTERN.sub(watchYourMouth, speech)
def min_and_max(l, d, x):\n    listOfCorect = [num for num in list(range(l,d+1)) if sum(map(int,str(num))) == x]        \n    return [min(listOfCorect), max(listOfCorect)]
def trotter(n):\n    i, numStr, numList =0,'',['0','1','2','3','4','5','6','7','8','9']\n    if n==0:\n        return('INSOMNIA')\n    while all([i in numStr for i in numList])!=True:\n        i+=1\n        numStr = numStr+str(n*i)\n    return(i*n)
def check_alive(health):\n    if health <= 0:\n        return False\n    else:\n        return True\n    \nprint(check_alive(0))
digits = lambda x: set(str(x))\n\ndef LDTA(n):\n    if digits(n) == digits(n*n):\n        return None\n    \n    seen = []\n    x = n\n    \n    while len(seen) < 10:\n        for d in str(x):\n            if d not in seen:\n                seen.append(d)\n        x *= n\n        \n    return int(seen[-1])
def interpreter(tape):\n    memory, ptr, output, iCmd = {}, 0, "", 0\n    \n    while True:\n        cmd = tape[iCmd]\n        if   cmd == ">":  ptr += 1\n        elif cmd == "<":  ptr -= 1\n        elif cmd == "+":  memory[ptr] = (memory.get(ptr, 0) + 1) % 256\n        elif cmd == "-":  memory[ptr] = (memory.get(ptr, 0) - 1) % 256\n        elif cmd == "*":  output += chr(memory.get(ptr, 0))\n        elif cmd == "&":  break\n        elif cmd == "/":  iCmd += memory.get(ptr, 0) == 0\n        elif cmd == "\\": iCmd += memory.get(ptr, 0) != 0\n        iCmd = (iCmd+1) % len(tape)\n    \n    return output
def total_bill(s):\n    return 2*(s.count("r") - s.count("r")//5)
def ccw(matrix):\n    return [list(row) for row in zip(*map(reversed, matrix))]\n\ndef rotate_against_clockwise(matrix, times):\n    for __ in range(times % 4):\n        matrix = ccw(matrix)\n    return matrix
def similarity(a, b):\n    try:\n        return len(set(a) & set(b)) / len(set(a) | set(b))\n    except:\n        return 0
def sum_nested(lst):\n    return sum(sum_nested(x) if isinstance(x,list) else x for x in lst)
def basereduct(x):\n    for _ in range(150):\n        x = int(str(x), int(max(str(x))) + 1 + ('9' in str(x)))\n        if x < 10: return x\n    return -1
def convert(st):\n    return st.replace('o','u').replace('a','o')
ls = ['11', '13', '17', '19', '23', '29', '31', '37', '41', '43', '47', '53', '59', '61', '67', '71', '73', '79', '83', '89', '97']\ndef solve(a,b):\n    i = a\n    s = 0\n    while i < b:\n        if (i*i-i)%100==0 and str(i)[:2] in ls and str(i*i)[:2] in ls:\n            s += 1\n        i += 1\n    return s
from itertools import cycle\nfrom string import ascii_lowercase\n\ndef decode(code, key):\n    keys = cycle(map(int, str(key)))\n    return ''.join(ascii_lowercase[n - next(keys) - 1] for n in code)
def how_many_dalmatians(n):\n    dogs = ["Hardly any", "More than a handful!", "Woah that's a lot of dogs!", "101 DALMATIONS!!!"]\n    return dogs[0] if n <= 10 else dogs[1] if n <=50 else dogs[3] if n == 101 else dogs[2]
def stairs(n):\n    return "\n".join(step(i).rjust(4 * n - 1) for i in range(1, n+1))\n\n\ndef step(n):\n    h = " ".join(str(i % 10) for i in range(1, n+1))\n    return f"{h} {h[::-1]}"
def berserk_rater(synopsis):\n    n = sum([score(s.upper()) for s in synopsis])\n    return 'worstest episode ever' if n < 0 else 'bestest episode ever' if n > 10 else str(n)\n    \ndef score(s):\n    return 5 if 'CLANG' in s else -2 if 'CG' in s else -1
brackets = {"}":"{","]":"[",")":"("}\n\ndef braces_status(s):\n    stack = []\n    \n    for c in s:\n        if c in "[({":\n            stack.append(c)\n        elif c in "])}":\n            if not stack or stack.pop() != brackets[c]:\n                return False\n    \n    return not stack
def triangular_range(start, stop):\n    return {i:i*(i+1)/2 for i in range(stop) if start <= i*(i+1)/2 <= stop}\n
SUFFIXES = {'a': ['o', 'as', 'a', 'amos', 'ais', 'an'],\n            'e': ['o', 'es', 'e', 'emos', 'eis', 'en'],\n            'i': ['o', 'es', 'e', 'imos', 'is',  'en']}\n\ndef conjugate(verb):\n    return {verb: [verb[:-2] + s for s in SUFFIXES[verb[-2]]]}
def check_exam(arr1, arr2):\n    return max(0, sum(4 if a == b else -1 for a, b in zip(arr1, arr2) if b))
def greet(name):\n    return f"hello {name}!" if name else None
array = [1, 10, 9, 12, 3, 4]\n\ndef thirt(n):\n    total = sum([int(c) * array[i % 6] for i, c in enumerate(reversed(str(n)))])\n    if n == total:\n        return total\n    return thirt(total)\n
import re\n\n_24H = re.compile(r'^([01]?\d|2[0-3]):[0-5]\d$')\n\nvalidate_time = lambda time: bool(_24H.match(time))\n
def greet(name, owner):\n    return "Hello boss" if name == owner else "Hello guest"
\nimport re\ndef parse_mana_cost(mana):\n    n={c:mana.lower().count(c) for c in 'wubrg' if mana.lower().count(c)>0}\n    m=re.split(r'\D',mana)   \n    if sum(n.values())+sum([len(c) for c in m]) != len(mana): return None\n    p = sum([int(c) for c in m if c!=''])\n    if p>0: n['*']=p\n    return n\n
def Guess_it(n,m):\n    result = []\n    for x in range(0,n+1):\n        b, r, g = 4 * n + x - m, m - 3 * n - 2 * x, x\n        if all(y >= 0 for y in (b,r,g)):\n            result.append([g,r,b])\n    return result\n\n
def is_divisible(n,x,y):\n    return n % x == 0 and n % y == 0
import math\n\ndef sum_circles(*args):\n    t = round(sum([math.pi * (d**2) / 4 for d in args]))\n    return 'We have this much circle: {}'.format(int(t))
def reverseWords(str):\n    return " ".join(str.split(" ")[::-1])
def queue_time(customers, n):\n    l=[0]*n\n    for i in customers:\n        l[l.index(min(l))]+=i\n    return max(l)
def find_unknown_number(x,y,z):    \n    return (x*70 + y*21 + z*15) % 105 or 105
from collections import Counter\n\n\ndef get_strings(city):\n    return ",".join(f"{char}:{'*'*count}" for char, count in Counter(city.replace(" ", "").lower()).items())
def divide(weight):\n    return weight > 2 and weight % 2 == 0
def generate_hashtag(s):\n    output = "#"\n    \n    for word in s.split():\n        output += word.capitalize()\n    \n    return False if (len(s) == 0 or len(output) > 140) else output\n
import re\ndef sum_of_a_beach(beach):\n    return len(re.findall('Sand|Water|Fish|Sun', beach, re.IGNORECASE))
def change(st):\n    new = ""\n    st = st.lower()\n    for letter in "abcdefghijklmnopqrstuvwxyz":\n        if letter in st:\n            new += "1"\n        else:\n            new += "0"\n    return new\n
from operator import mul\n\ndef reduce_pyramid(base):\n    return sum(map(mul, base, comb_n(len(base) - 1)))\n\ndef comb_n(n):\n    c = 1\n    for k in range(0, n + 1):\n        yield c\n        c = c * (n - k) // (k + 1)\n
import math \n\ndef movie(card, ticket, perc):\n num = 0\n priceA = 0\n priceB = card\n \n while math.ceil(priceB) >= priceA:\n  num    += 1\n  priceA += ticket\n  priceB += ticket * (perc ** num)\n  \n return num
from fractions import Fraction\n\ndef sum_fracts(lst):\n    if lst:\n        ret = sum(Fraction(a, b) for (a, b) in lst)\n        return ret.numerator if ret.denominator == 1 else [ret.numerator, ret.denominator]\n
def SJF(jobs, index):\n    return sum(j for i, j in enumerate(jobs)\n                 if j < jobs[index] or (j == jobs[index] and i <= index))\n
def find_primes_sextuplet(limit):\n    for p in [7, 97, 16057, 19417, 43777, 1091257, 1615837, 1954357, 2822707, 2839927, 3243337, 3400207, 6005887]:\n        if p * 6 + 48 > limit:\n            return [p, p + 4, p + 6, p + 10, p + 12, p + 16]
from collections import defaultdict\nfrom fractions import Fraction\nfrom bisect import bisect_left as bisect\n\nharmonic = [0] + [Fraction(sum({y for x in range(1,int(n**.5)+1) for y in [x, n//x] if not n%x}), n) for n in range(1,7001)]\n\nharmonicity = defaultdict(set)\nfor n,h in enumerate(harmonic): harmonicity[h].add(n)\n\nHARMO_GROUPS = {h: sorted(s) for h,s in harmonicity.items() if len(s) > 1}\nHARMO_RATIOS = {n: h for h,lst in HARMO_GROUPS.items() for n in lst}\nHARMO_NUM    = sorted(HARMO_RATIOS.keys())\n\ndef solve(a,b):\n    seens, s = set(), 0\n    n1, n2 = bisect(HARMO_NUM, a), bisect(HARMO_NUM, b)\n    for n in HARMO_NUM[n1:n2]:\n        if n not in seens:\n            grp = [x for x in HARMO_GROUPS[HARMO_RATIOS[n]] if a <= x < b]\n            if len(grp) > 1:\n                seens |= set(grp)\n                s += grp[0]\n    return s
def find_it(seq):\n    for i in seq:\n        if seq.count(i)%2!=0:\n            return i
def get_sum(a,b):\n    return sum(range(min(a, b), max(a, b) + 1))
def sierpinski():\n    x = s = 0\n    while 1:\n        for a in 4, 9, 56, 61:\n            s += x + a\n            yield s\n        x += 65\n\ns = sierpinski()\nS = [next(s)]\n\nfrom bisect import bisect_left\ndef find_closest_value(m):\n    while S[-1] < m: S.append(next(s))\n    i = bisect_left(S, m)\n    return min(S[i:i-2:-1], key=lambda n: abs(m - n))
def binary_pyramid(m,n):\n    return bin(sum(int(bin(i)[2:]) for i in range(m, n+1)))[2:]
def find_all(array, n):\n    return [index for index, item in enumerate(array) if item == n]
def land_perimeter(arr):\n   \n    I,J = len(arr),len(arr[0])\n    \n    P = 0\n    for i in range(I):\n        for j in range(J):\n            if arr[i][j] == 'X':\n                if i == 0   or arr[i-1][j] == 'O': P += 1\n                if i == I-1 or arr[i+1][j] == 'O': P += 1\n                if j == 0   or arr[i][j-1] == 'O': P += 1\n                if j == J-1 or arr[i][j+1] == 'O': P += 1\n                   \n                  \n    return 'Total land perimeter: ' + str(P)\n
def to_lover_case(string):\n    return "".join("LOVE"[(ord(c) - 97) % 4] if c.isalpha() else c for c in string)
def word_pattern(pattern, string):\n    x = list(pattern)\n    y = string.split(" ")\n    return (len(x) == len(y) and \n        len(set(x)) == len(set(y)) == len(set(zip(x, y)))\n    )
def am_i_wilson(n):\n    return n in (5, 13, 563)
def the_biggest_search_keys(*keys):\n    L = sorted(keys, key=lambda key: (-len(key), key))\n    i = next((i for i,key in enumerate(L) if len(key) != len(L[0])), None)\n    return str(L[:i])[1:-1] or "''"
def case_unification(s):\n    return s.lower() if sum(1 for i in s if i.islower()) > sum(1 for i in s if i.isupper()) else s.upper()
def length_of_sequence(arr, n):\n    if arr.count(n) != 2:\n        return 0\n    a = arr.index(n)\n    b = arr.index(n, a + 1)\n    return b - a + 1
def robot_transfer(matrix, k):\n    c = 0\n    for l, i in enumerate(matrix):\n        for o, j in enumerate(i):\n            x, y = j.split(",")\n            current,count,new = [l, o],0,[]\n            while count < k and current != new:\n                new = [int(x), int(y)] ; x, y = matrix[int(x)][int(y)].split(",") ; count += 1\n            if current == new and count == k : c += 1\n    return c 
from functools import reduce\nfrom operator import mul\n\n\ndef select_subarray(arr):\n    total = sum(arr)\n    m = reduce(mul, arr)\n    qs = [\n        (abs((m // x) / (total - x)) if total - x else float("inf"), i)\n        for i, x in enumerate(arr)\n    ]\n    q = min(qs)\n    result = [[i, arr[i]] for x, i in qs if x == q[0]]\n    return result[0] if len(result) == 1 else result
def decompose_single_strand(dna):        \n    return '\n'.join('Frame {}: {}'.format(k+1, frame(dna, k)) for k in range(3))\n    \ndef frame(s, k):\n    return ' '.join(([s[:k]] if k else []) + [s[i:i+3] for i in range(k, len(s), 3)])    
def my_crib(n):\n    wide = 4 + 3 + 6 * (n - 1)\n    door = 2 + n - 1\n    roof = 3 + 2 * (n - 1)\n    r = '{0}{1}{0}\n'.format(' ' * (wide // 2 - n), '_' * (3 + 2 * (n - 1)))\n    for i in range(1, roof):\n        r += '{0}/{1}\\{0}\n'.format(' ' * (wide // 2 - n - i), '_' * (3 + 2 * (n - 1) + 2 * (i -1)))\n    for i in range(roof - 1 - door):\n        r += '|{}|\n'.format(' ' * (wide - 2))\n    r += '|{0}{1}{0}|\n'.format(' ' * ((wide - 1) // 3), '_' * (1 + 2 * (n - 1)))\n    for i in range(1, door - 1):            \n        r += '|{0}|{0}|{0}|\n'.format(' ' * ((wide - 2) // 3))\n    return r + '|{0}|{0}|{0}|'.format('_' * ((wide - 2) // 3))\n\n
def even_or_odd(number):\n    return 'Odd' if number % 2 else 'Even'
def get_users_ids(string):\n    return [w.replace("uid", "", 1).strip() for w in string.lower().replace("#", "").split(",")]
def guess_hat_color(a,b,c,d):\n    return 1 if b == c else 2
def true_binary(n):\n    return [(c == '1') * 2 - 1 for c in '1' + bin(n)[2:-1]]
import re\n\n\ndef buy_newspaper(s1, s2):\n    p = re.sub(r"(.)", r"\1?", s1)\n    return -1 if set(s2) - set(s1) else len(re.findall(p, s2)) - 1
def maximum_product(arr):\n    if arr.count(0) > 1:\n        return min(arr)\n    neg = [n for n in arr if n < 0]\n    pos = [n for n in arr if n >= 0]\n    if len(neg) % 2:\n        return min(neg) if 0 in arr else max(neg)\n    else:\n        return min(pos) if pos else min(neg)
def bus_timer(current_time):\n    h, m = map(int, current_time.split(':'))\n\n    if h<6:\n        m = (5 - h) * 60 + 60 - m\n    elif h == 23 and m > 55:\n        return 355 + 60 - m\n    else:\n        m = 15 - m % 15\n\n    if m > 4:\n        return  m - 5\n    else:\n        return  m + 10
def cheapest_quote(n):\n    prices = [(40, 3.85), (20, 1.93), (10, 0.97), (5, 0.49), (1, 0.10)]\n    result = 0\n    for q, c in prices:\n        result += n // q * c\n        n = n % q\n    return round(result, 2)\n        \n
def checkchoose(m, n):\n    c = 1\n    for x in range(n // 2 + 1):\n        if c == m: return x\n        c = c * (n-x) // (x+1)\n    else: return -1\n
from collections import Counter\n\ndef majority(arr):\n  mc = Counter(arr).most_common(2)\n  if arr and (len(mc) == 1 or mc[0][1] != mc[1][1]):\n      return mc[0][0]
def sort_by_height(a):\n    s = iter(sorted(x for x in a if x != -1))\n    return [x if x == -1 else next(s) for x in a]
notes = {\n440: "A",\n466.16: "A#",\n493.88: "B",\n523.25: "C",\n554.37: "C#",\n587.33: "D",\n622.25: "D#",\n659.25: "E",\n698.46: "F",\n739.99: "F#",\n783.99: "G",\n830.61: "G#"\n}\n\ndef get_note(pitch):\n\n    for note in notes:\n        if note >= pitch and note % pitch == 0:\n                return notes[note]\n        elif note < pitch and pitch % note == 0:\n                return notes[note]
import numpy as np\n\ndef regressionLine(x, y):\n    """ Return the a (intercept)\n        and b (slope) of Regression Line \n        (Y on X).\n    """\n    a,b = np.polyfit(x,y,1)\n    return round(b,4),round(a,4)\n    \n
from re import *\ndef short_form(s):\n    return sub(r"(?<!^)[aeiou](?=.)", '', s, flags=I)
def primeFactors(n):\n    ret = ''\n    for i in range(2, n + 1):\n        num = 0\n        while(n % i == 0):\n            num += 1\n            n /= i\n        if num > 0:\n            ret += '({}{})'.format(i, '**%d' % num if num > 1 else '')\n        if n == 1:\n            return ret\n
def is_letter(s):\n    return len(s) == 1 and s.isalpha()
def womens_age(n):\n    return f"{n}? That's just {20+n%2}, in base {n//2}!"
MATCH = int('10'*16,2)\n\ndef any_odd(x): return bool(MATCH & x)
from collections import Counter\n\ndef only_duplicates(string):\n    cs = Counter(string)\n    return ''.join(c for c in string if cs[c] > 1)
def sum_pow_dig_seq(num, exp, k):\n    seq = []\n    \n    for step in range(k):\n        seq.append(num)\n        num = sum( int(dig) ** exp for dig in str(num) )\n        \n        if num in seq:\n            cycle_start = seq.index(num)\n            cycle = seq[cycle_start:]\n            last_term = cycle[(k - cycle_start) % len(cycle)]\n            return [ cycle_start, cycle, len(cycle), last_term ]\n    \n    return [ 0, [], 0, num ]
def slogan_maker(array):\n    print(array)\n    from itertools import permutations \n    array = remove_duplicate(array)\n    return [' '.join(element) for element in list(permutations(array, len(array)))]\n    \ndef remove_duplicate(old_list): \n    final_list = [] \n    for num in old_list: \n        if num not in final_list: \n            final_list.append(num) \n    return final_list 
def transpose(amount, tab):\n    stack, tab = [], list(map(list, tab))\n    for n, col in reversed(list(enumerate(zip(*tab)))):\n        if any(map(str.isdigit, col)):\n            stack.append(col)\n        elif stack:\n            frets = [''.join(r).strip('-') for r in zip(*reversed(stack))]\n            frets = [fret and int(fret) + amount for fret in frets]\n            if any(fret and not 0 <= fret <= 22 for fret in frets): return 'Out of frets!'\n            frets = list(map(str, frets))\n            pad = max(map(len, frets))\n            for row, fret in zip(tab, frets):\n                row[n+1: n+1+len(stack)] = str(fret).ljust(pad, '-')\n            stack.clear()\n    return list(map(''.join, tab))
import re\n\nKEYBOARD = "abcde123fghij456klmno789pqrst.@0uvwxyz_/* "\nMAP      = {c: (i//8, i%8) for i,c in enumerate(KEYBOARD)}\n\n\ndef manhattan(*pts): return 1 + sum( abs(z2-z1) for z1,z2 in zip(*pts))\n\ndef toggle(m):\n    ups, end = m.group(1), m.group(2)\n    off = '*' * bool(end)\n    return f'*{ups.lower()}{off}{end}'                # Toggle Shift ON if uppercase presents, and then OFF if lowercase after\n\ndef tv_remote(words):\n    reWords = re.sub(r'([A-Z][^a-z]*)([a-z]?)', toggle, words)\n    return sum( manhattan(MAP[was], MAP[curr]) for was,curr in zip('a'+reWords, reWords))\n
from itertools import permutations\n\ndef rearranger(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = filter(lambda x: int(''.join(x)) % k == 0, perms)\n    try:\n        rearranged = min(divisible_by_k, key=lambda x: int(''.join(x)))\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(rearranged), ''.join(rearranged), k)\n    except ValueError:\n        return "There is no possible rearrangement"
import re\nfrom collections import OrderedDict\nscale = "2 3 4 5 6 7 8 9 10 J Q K A".split(" ")\ndef sort_poker(john, uncle):\n    order = list(OrderedDict.fromkeys(re.findall(r"([SDHC])[0-9JQKA]+",uncle)))\n    john  = re.findall(r"([SDHC])([0-9JQKA]+)",john)\n    return "".join("".join(i) for i in sorted(john,key=lambda x : (order.index(x[0]),scale.index(x[1])) ))
def group_cities(seq):\n    result = []\n    sort_result =[]\n    seq = list(dict.fromkeys(seq)) #removing  duplicates\n    for e, i in enumerate(seq):\n        sort_result = [j for j in seq if len(j)==len(i) and j.lower() in 2*(i.lower())]\n        if not sorted(sort_result) in result :\n            result.append(sorted(sort_result))\n    return(sorted(sorted(result),key=len,reverse=True))
from datetime import datetime\n\ndef solve(arr):\n    dts = [datetime(2000, 1, 1, *map(int, x.split(':'))) for x in sorted(arr)]\n    delta = max(int((b - a).total_seconds() - 60) for a, b in zip(dts, dts[1:] + [dts[0].replace(day=2)]))\n    return '{:02}:{:02}'.format(*divmod(delta//60, 60))
from math import *\n\ndef count(n):\n    return ceil(lgamma(n+1)/log(10))
def mult_triangle(n):\n    total = (n * (n + 1) / 2)**2\n    odds = ((n + 1) // 2)**4\n    return [total, total - odds, odds]\n
def my_first_kata(a,b):\n    #your code here\n    if type(a) == int and type(b) == int:\n        return a % b + b % a\n    else:\n        return False
def well(x):\n    c = x.count('good')\n    return 'I smell a series!' if c > 2 else 'Publish!' if c else 'Fail!'
import re\n\ndef words_to_object(s):\n    return "[" + re.sub("([^ ]+) ([^ ]+)", r"{name : '\1', id : '\2'},", s).strip(',') + "]"
def work_needed(project_minutes, freelancers):\n    available_minutes = sum(hours * 60 + minutes for hours, minutes in freelancers)\n    workload_minutes = project_minutes - available_minutes\n    if workload_minutes <= 0:\n        return 'Easy Money!'\n    else:\n        hours, minutes = divmod(workload_minutes, 60)\n        return 'I need to work {} hour(s) and {} minute(s)'.format(hours, minutes)
def closest_pair_tonum(uLim):\n    return next( (a,b) for a in reversed(range(1,uLim)) for b in reversed(range(1,a))\n                       if not (a+b)**.5%1 and not (a-b)**.5%1 )
def arr(n=0): \n    return list(range(n))
def find_average(nums):\n    return float(sum(nums)) / len(nums) if len(nums) !=0 else 0
from collections import Counter\n\ndef solve(*args):\n    c1, c2 = map(Counter, args)\n    return 2 - any(c1[k]-c2[k] >= 2 and k not in c2 for k in c1)
def solve(st):\n    return next((n for n in range(len(st)//2, 0, -1) if st[:n] == st[-n:]), 0)\n
def clonewars(k):\n    return [2**max(k-1,0),2**(k+1)-k-2]
def missing(nums, s):\n    ans = []\n    s = s.replace(' ','')\n    try:\n        for i in sorted(nums):\n            ans.append(s[i])\n        return ''.join(ans).lower()\n    except IndexError:\n        return ("No mission today")
def calc_type(a, b, res):\n    return {a + b: "addition", a - b: "subtraction", a * b: "multiplication", a / b: "division"}[res]\n
def string_expansion(s):\n    m,n = '',1\n    for j in s:\n        if j.isdigit():\n            n = int(j)\n        else:\n            m += j*n\n    return m
import re\n\ndef sursurungal(txt):\n    txt=re.sub(r'\b2\s(\S+)s', r'2 bu\1', txt) \n    txt=re.sub(r'\b([3-9])\s(\S+)s', r'\1 \2zo', txt)\n    return re.sub(r'(\d+\d)\s(\S+)s', r'\1 ga\2ga', txt)\n    \n
def make_readable(s):\n    return '{:02}:{:02}:{:02}'.format(s // 3600, s // 60 % 60, s % 60)\n
from datetime import date\n\ndef unlucky_days(year):\n    return sum(date(year, m, 13).weekday() == 4 for m in range(1, 13))
from math import ceil\nfrom operator import truediv\n\n\ndef how_many_times(annual_price, individual_price):\n    return int(ceil(truediv(annual_price, individual_price)))
from math import ceil\n\ndef union_jack(n):\n    if not isinstance(n, (int, float)):\n        return False\n    n = max(7, ceil(n))\n    h, m = divmod(n-1, 2)\n    flag = [["X" if len({i, n-j-1, j, h, h+m}) < 4+m else "-" for i in range(n)] for j in range(n)] \n    return "\n".join("".join(row) for row in flag)
def two_decimal_places(number):\n    \n    return int (number * 100) / 100.0
import re\ndef trump_detector(ts):\n    x=re.findall(r'([aeiou])(\1*)',ts,re.I)\n    y=[len(i[1]) for i in x]\n    return round(sum(y)/len(y),2)
def enough(cap, on, wait):\n    return max(0, wait - (cap - on))
def mouth_size(animal): \n    return 'small' if animal.lower() == 'alligator' else 'wide'
def solve(st, k):\n    length = len(st) - k\n    return max(int(st[i:i + length]) for i in range(k + 1))
def motif_locator(sequence, motif):\n    res, i = [], 0\n    while True:\n        i = sequence.find(motif, i) + 1\n        if not i: return res\n        res.append(i)
def get_ages(a,b):\n    x = (a+b)/2\n    y = (a-b)/2\n    return None if a<0 or b<0 or x<0 or y<0 else (x,y)
is_prime = lambda n: all(n % d for d in range(3, int(n ** .5) + 1, 2))\n\ndef primes_a_p(lower_limit, upper_limit):\n    a_p = []\n    for n in range(lower_limit | 1, upper_limit, 2):\n        for gap in range(30, (upper_limit - n) // 5 + 1, 30):\n            sequence = [n + i * gap for i in range(6)]\n            if all(map(is_prime, sequence)):\n                a_p.append(sequence)\n    return a_p
def calc(s):\n    total1 = ''.join(map(lambda c: str(ord(c)), s))\n    total2 = total1.replace('7', '1')\n    return sum(map(int, total1)) - sum(map(int, total2))
def rule30(a, n):\n    for _ in range(n):\n        a = [int(0 < 4*x + 2*y + z < 5) for x, y, z in\n                zip([0, 0] + a, [0] + a + [0], a + [0, 0])]\n    return a
def converter(mpg):\n    '''Converts mpg to kpl. Rounds to two decimal places.'''\n    kpl = round(mpg * 1.609344/4.54609188, 2)\n    return kpl
from textwrap import wrap\n\n\ndef split_in_parts(s, part_length): \n    return " ".join(wrap(s,part_length))
def what_century(year):\n    n = (int(year) - 1) // 100 + 1\n    return str(n) + ("th" if n < 20 else {1: "st", 2: "nd", 3: "rd"}.get(n % 10, "th"))
from math import ceil\n\ndef will_it_balance(stick, gnd):\n    gravPt = sum(v*i for i,v in enumerate(stick)) / sum(stick)\n    return gnd[int(gravPt)] == gnd[ceil(gravPt)] == 1
def avg_array(arrs):\n    return [sum(a)/len(a) for a in zip(*arrs)]
def calc(a):\n    res = [0] * (len(a) + 1)\n    for k in range(len(a)):\n        res = [2 * max(a[i] + res[i+1], a[i+k] + res[i]) for i in range(len(a) - k)]\n    return res[0]
def replace_letters(word):\n  return word.translate(str.maketrans('abcdefghijklmnopqrstuvwxyz','zeeediiihooooonuuuuutaaaaa')) \n
def even_fib(m):\n    x,y = 0, 1\n    counter = 0\n    while y < m:\n        if y % 2 == 0:\n            counter += y\n        x,y = y, x+ y\n    return counter
from itertools import combinations\ndef strings_crossover(arr, result):\n    return sum(1 for s1,s2 in combinations(arr,2) if all(r in (x,y) for x,y,r in zip(s1,s2,result)))
def div_con(lst):\n    return sum(n if isinstance(n, int) else -int(n) for n in lst)
def is_inertial(arr):\n    mx   = max(arr, default=1)\n    miO  = min((x for x in arr if x%2==1), default=float("-inf"))\n    miE2 = max((x for x in arr if x%2==0 and x!=mx), default=float("-inf"))\n    return mx%2 == 0 and miE2 < miO
import heapq\nfrom collections import defaultdict\n\ndef shortest(N, edge):\n    ver, inf = defaultdict(list), 10**10\n    for e in edge: ver[e[0]].append(e[1:])\n\n    dist = {i:inf for i in range(N)}\n    dist[0], pq = 0, []\n    heapq.heappush(pq, [dist[0], 0])\n    while pq: \n        u_dis, u_node = heapq.heappop(pq)\n        if u_dis == dist[u_node]:\n            for v in ver[u_node]:\n                v_node = v[0]\n                v_wei = v[1]\n                if dist[u_node] + v_wei < dist[v_node]:\n                    dist[v_node] = dist[u_node] + v_wei\n                    heapq.heappush(pq, [dist[v_node], v_node])\n    return -1 if dist[N-1] == inf else dist[N-1]
from fnmatch import fnmatch\n\ndef solve(a, b):\n    return fnmatch(b, a)
def fat_fingers(s):\n    if not s: return s\n    swap = [False]\n    return ''.join( c.swapcase() if swap[0] else c for c in s \n                    if c not in "aA" or swap.__setitem__(0, not swap[0]) )
def parity_bit(binary):\n    return ' '.join(byte[:-1] if byte.count('1') % 2 == 0 else 'error' for byte in binary.split())
c='black brown red orange yellow green blue violet gray white'.split()\ndef encode_resistor_colors(ohms_string):\n    ohms = str(int(eval(ohms_string.replace('k',  '*1000').replace('M',  '*1000000').split()[0])))\n    return '%s %s %s gold' % (c[int(ohms[0])], c[int(ohms[1])], c[len(ohms[2:])])
def score_pole_vault(vaulter_list):\n    popytki = len(vaulter_list[0]["results"])\n    temp = {}\n    res = {}\n    for mas in vaulter_list:\n        i = popytki - 1\n        while i >= 0 and mas["results"][i].find('O') == -1:\n            i -= 1\n        if i < 0:\n            n = 0\n            m = ''.join(mas["results"]).count('X')\n        else:\n            n = mas["results"][i].count('X')\n            m = ''.join(mas["results"][:i]).count('X')\n        new_key = (popytki - i, n, m)\n        temp[new_key] = temp.get(new_key, []) + [mas["name"]]\n    k = iter(sorted(temp))\n    i = 0\n    while i < 3:\n        key = next(k)\n        if i == 0 and len(temp[key]) == 1:\n            res['1st'] = temp[key][0]\n            i += 1\n        elif i == 0 and len(temp[key]) > 1:\n            res['1st'] = ', '.join(sorted(temp[key])) + ' (jump-off)'\n            i += len(temp[key])\n        elif i == 1 and len(temp[key]) == 1:\n            res['2nd'] = temp[key][0]\n            i += 1\n        elif i == 1 and len(temp[key]) > 1:\n            res['2nd'] = ', '.join(sorted(temp[key])) + ' (tie)'\n            i += len(temp[key])\n        elif i == 2 and len(temp[key]) == 1:\n            res['3rd'] = temp[key][0]\n            i += 1\n        elif i == 2 and len(temp[key]) > 1:\n            res['3rd'] = ', '.join(sorted(temp[key])) + ' (tie)'\n            i += len(temp[key])\n    return res\n
from math import copysign as sign\n\ndef reverse_invert(lst):\n    return [-int(sign(int(str(abs(x))[::-1]),x)) for x in lst if isinstance(x,int)]  
from collections import Counter\n\ndef anagram_counter(words):\n    return sum(n*(n-1)// 2 for n in Counter(''.join(sorted(x)) for x in words).values())
import re\ndef highlight(code):\n    code = re.sub(r"(F+)", '<span style="color: pink">\g<1></span>', code)\n    code = re.sub(r"(L+)", '<span style="color: red">\g<1></span>', code)\n    code = re.sub(r"(R+)", '<span style="color: green">\g<1></span>', code)\n    code = re.sub(r"(\d+)", '<span style="color: orange">\g<1></span>', code)\n    return code
import fractions\n\ndef solve(a, b):\n    c = fractions.gcd(a, b)\n    while c > 1:\n        b //= c\n        c = fractions.gcd(a, b)\n    return b == 1
"""Strongest even number in an interval kata\n\nDefines strongest_even(n, m) which returns the strongest even number in the set\nof integers on the interval [n, m].\n\nConstraints:\n    1. 1 <= n < m < MAX_INT\n\nNote:\n    1. The evenness of zero is need not be defined given the constraints.\n    2. In Python 3, the int type is unbounded. In Python 2, MAX_INT is\n    determined by the platform.\n\nDefinition:\n    A number is said to be more strongly even than another number if the\n    multiplicity of 2 in its prime factorization is higher than in the prime\n    factorization of the other number.\n"""\nfrom math import log2\n\n\ndef strongest_even(n, m):\n    """Returns the strongest even number in the set of integers on interval\n       [n, m].\n    """\n\n    #It can be shown that the largest power of 2 on an interval [n, m] will\n    #necessarily be the strongest even number. Check first if the interval\n    #contains a power of 2, by comparing the log2 of the endpoints.\n    if int(log2(m)) > int(log2(n)):\n        return 2**int(log2(m))\n\n    #Modify the endpoints exclude any odd numbers. If the two endpoints are\n    #equal, the original interval contains only a single even number. Return it.\n    n += n % 2\n    m -= m % 2\n    if n == m:\n        return n\n\n    #All optimizations and edge cases are exhausted. Recurse with the\n    #modified endpoints halved, and multiply the result by 2.\n    return 2*strongest_even(n // 2, m // 2)\n
def how_many_light_sabers_do_you_own(name=""):\n    return (18 if name=="Zach" else 0)
def gr33k_l33t(string):\n    gl = {  "a":"", "b":"", "d":"", "e":"", "i":"", "k":"", "n":"", "o":"", \n            "p":"", "r":"", "t":"", "u":"", "v":"", "w":"", "x":"", "y":""  }\n    return "".join([gl.get(letter, letter) for letter in string.lower()])
def number_of_carries(a, b):\n    ans, carrie = 0, 0\n    while a > 0 or b > 0:\n        carrie = (a%10 + b%10 + carrie) // 10 \n        ans += [0,1][carrie > 0]\n        a //= 10\n        b //= 10\n    return ans
def to_camel_case(text):\n    removed = text.replace('-', ' ').replace('_', ' ').split()\n    if len(removed) == 0:\n        return ''\n    return removed[0]+ ''.join([x.capitalize() for x in removed[1:]])
l = {'one': 5, 'two': 4, 'three': 3, 'four': 2, 'five': 1, 'six': 0}\ny = {'hhh': '----o----', 'hht': '---- ----', 'htt': '---------', 'ttt': '----x----'}\n\ndef oracle(arr):\n    s = [''] * 6\n    for x in arr: s[l[x[0]]] = y[''.join(sorted(x[1:]))]\n    return '\n'.join(s)
def evil(n):\n    return "It's %s!" % ["Evil","Odious"][bin(n).count("1")%2]
def cypher(s):\n    return s.translate(str.maketrans('IREASGTBlzeasbtgoO','123456781234567900'))
tr=str.maketrans('56789','45678')\n\ndef faulty_odometer(n):\n    return int(str(n).translate(tr),9)
def sale_hotdogs(n):\n    return n * (100 if n < 5 else 95 if n < 10 else 90)\n
from collections import Counter\n\ndef most_common(s):\n    count = Counter(s)\n    return ''.join(sorted(s, key=lambda c: -count[c]))
def reverse_in_parentheses(s):\n    stack = []\n    for i in s:\n        stack.append(i)\n        \n        if i == ')':\n            opening = len(stack) - stack[::-1].index('(') - 1\n            stack.append(''.join([i[::-1].translate(str.maketrans('()',')(')) for i in stack[opening:][::-1]]))  \n            del stack[opening:-1]\n  \n    return ''.join(stack)  
def celsius_to_romer(temp):\n    # Converts temperature in degrees Celsius to degrees Romer\n    return (temp * 21 / 40) + 7.5\n
def caeser(message, key):\n    return ''.join(chr(65 + (ord(c.upper()) + key - 65) % 26) if c.isalpha() else c for c in message)
"""\n***************************************\n*   O(n) time complexity solution !   *\n***************************************\n"""\n\ndef longest_palindrome (s):\n\n    maxPal, tmpPal = 0, 1\n    count_dct = {}\n    inPal = False\n    \n    for i,l in enumerate(s):\n    \n        count_dct[l] = count_dct.get(l,0) + 1\n        \n        if not inPal and count_dct[l] >= 2:            # might encounter a palindrome, there...\n            if l == s[i-1]:                            # ... palindrome with double character in the middle\n                inPal = True\n                tmpPal = 2\n            \n            elif l == s[i-2]:                          # ... palindrome with one "peak" character in the middle\n                inPal = True\n                tmpPal = 3\n        \n        elif inPal and l == s[max(0, i-tmpPal-1)]:     # still in a palindrome...\n                tmpPal += 2\n            \n        else:                                          # goes out of this palindrome\n            inPal = False\n            tmpPal = 1\n        \n        maxPal = max(maxPal, tmpPal)\n    \n    return maxPal
def make_triangle(m,n):\n    lns, sm = 0, 0\n    while sm < n - m + 1:\n        lns += 1\n        sm += lns\n    if sm > n - m + 1: return ""\n    matrix = [[0] * (i + 1) for i in range(lns)]\n    y, x, s = 0, 0, 0\n    ds = ((1, 1), (0, -1), (-1, 0))\n    dy, dx = ds[s]\n    for i in range(m, n + 1):\n        matrix[y][x] = str(i % 10)\n        if not 0 <= y + dy < len(matrix) or not 0 <= x + dx < len(matrix[y + dy]) or matrix[y + dy][x + dx]:\n            s += 1\n            dy, dx = ds[s % 3]\n        y, x = y + dy, x + dx\n    return "\n".join(" ".join(ln).center(len(matrix[-1]) * 2 - 1).rstrip() for ln in matrix)
def solve(arr, reach):\n    dogs, nCats = {i for i,x in enumerate(arr) if x=='D'}, 0\n    for i,c in enumerate(arr):\n        if c == 'C':\n            catchingDog = next((i+id for id in range(-reach,reach+1) if i+id in dogs), None)\n            if catchingDog is not None:\n                nCats += 1\n                dogs.remove(catchingDog)\n    return nCats
import re\n\ndef autocorrect(input):\n    return re.sub(r'(?i)\b(u|you+)\b', "your sister", input)
def func_or(a, b):\n    return not (bool(a) == bool(b) == False)\n\ndef func_xor(a, b):\n    return not (bool(a) == bool(b))
from fractions import Fraction\ndef reduce_fraction(fraction):\n    t = Fraction(*fraction)\n    return (t.numerator, t.denominator)
def vaporcode(s):\n    return "  ".join(s.replace(" ", "").upper())
def get_sum_of_digits(num):\n    return sum(map(int, str(num)))
import re\n\nREGEX = re.compile(r'\[(.*?)\]')\n\n\ndef bracket_buster(strng):\n    try:\n        return REGEX.findall(strng)\n    except TypeError:\n        return 'Take a seat on the bench.'\n
from itertools import groupby\n\n\ndef ones_counter(nums):\n    return [sum(g) for k, g in groupby(nums) if k]\n
def mystery(n):\n    return [i for i in range(1, n + 1, 2) if n % i == 0]
def sharkovsky(a, b): return f(a)<f(b)\n\ndef f(n,p=0):\n    while n%2==0:\n        n>>=1\n        p+=1\n    return n==1, p*(-1)**(n==1), n
def pop_shift(s):\n    l1 = list(s); l2 = []; l3 = []\n    while len(l1) > 1:\n        l2.append(l1.pop())\n        l3.append(l1.pop(0))\n    return ["".join(l2),"".join(l3),"".join(l1)]
def pattern(n):\n    return "\n".join([x * str(x) for x in range(1, n + 1)])
def memorysize_conversion(memorysize):\n    [value, unit] = memorysize.split(" ")\n    kibis = ["KiB", "MiB", "GiB", "TiB"]\n    kilos = ["kB", "MB", "GB", "TB"]\n    if unit in kibis:\n        return (str(round(float(value)*pow(1.024, kibis.index(unit)+1), 3))+" "+kilos[kibis.index(unit)])\n    else:\n        return (str(round(float(value)/pow(1.024, kilos.index(unit)+1), 3))+" "+kibis[kilos.index(unit)])
import math\n\ndef number_property(n):\n    return [isPrime(n), isEven(n), isMultipleOf10(n)]\n    # Return isPrime? isEven? isMultipleOf10?\n    #your code here\n\ndef isPrime(n):\n    if n <= 3:\n        return n >= 2\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    for i in range(5, int(n ** 0.5) + 1, 6):\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n    return True\n    \ndef isEven(n):\n    return n % 2 == 0\n\ndef isMultipleOf10(n):\n    return n % 10 == 0
from collections import defaultdict\n\ndef find_uniq(a):\n    d = {}\n    c = defaultdict(int)\n    for e in a:\n        t = frozenset(e.strip().lower())\n        d[t] = e\n        c[t] += 1\n    \n    return d[next(filter(lambda k: c[k] == 1, c))]
def gap(g, m, n):\n    previous_prime = n\n    for i in range(m, n + 1):\n        if is_prime(i):\n            if i - previous_prime == g: \n                return [previous_prime, i]\n            previous_prime = i\n    return None\n            \n    \ndef is_prime(n):\n    for i in range(2, int(n**.5 + 1)):\n        if n % i == 0:\n            return False\n    return True
def minimum(a, x):\n    return min(a % x, -a % x)
def outed(meet, boss):\n    return 'Get Out Now!' if (sum(meet.values()) + meet[boss] ) / len(meet) <= 5 else 'Nice Work Champ!'
def find_missing_number(sequence):\n    if not sequence:\n        return 0\n    try:\n        sequence = set(int(a) for a in sequence.split())\n    except ValueError:\n        return 1\n    for b in range(1, max(sequence) + 1):\n        if b not in sequence:\n            return b\n    return 0\n
def hex_string_to_RGB(s): \n    return {i:int(s[j:j+2],16) for i,j in zip('rgb',[1,3,5])}
def evil_code_medal(user_time, gold, silver, bronze):\n    for medal, time in [["Gold", gold], ["Silver", silver], ["Bronze", bronze]]:\n        if user_time < time:\n            return medal\n            \n    return "None"\n
def find_longest(xs):\n    return max(xs, key=lambda x: len(str(x)))
from itertools import zip_longest\n\ndef poly_subtract(p1, p2):\n    return [x - y for x, y in zip_longest(p1, p2, fillvalue=0)]\n
def boolean_to_string(b):\n    return str(b)
def solve(n):\n    moves = []\n    for a, b in ["25", "75", "50", "00"]:\n        s = str(n)[::-1]\n        x = s.find(a)\n        y = s.find(b, x+1 if a == "0" else 0)\n        if x == -1 or y == -1:\n            continue\n        moves.append(x + y - (x > y) - (a == b))\n        s = s.replace(a, "", 1).replace(b, "", 1)\n        l = len(s.rstrip("0"))\n        if l:\n            moves[-1] = moves[-1] + (len(s) - l)\n        elif s:\n            moves.pop()\n    return min(moves, default=-1)
def three_amigos(numbers):\n    return min(\n        ([a, b, c] for a, b, c in zip(numbers, numbers[1:], numbers[2:]) if a & 1 == b & 1 == c & 1), \n        key=lambda triple: max(triple) - min(triple),\n        default=[])
def find_dup(arr):\n    return sum(arr) - len(arr)*(len(arr)-1)/2\n    #your code here\n
def correct(string):\n    return string.translate(str.maketrans("501", "SOI"))
def title_to_number(title):\n    ret = 0\n    for i in title:\n        ret = ret*26 + ord(i) - 64\n    return ret
from functools import reduce\ndef get_chance(n, x, a):\n    return round(reduce(lambda m, b: m * (1 - x / (n - b)), range(a), 1), 2)
def sum_of_minimums(numbers):\n    return sum(map(min, numbers))
def sum_mix(arr):\n    return sum(map(int, arr))
def evaporator(content, evap_per_day, threshold):\n    n = 0\n    current = 100\n    percent = 1 - evap_per_day / 100.0\n    while current > threshold:\n        current *= percent\n        n += 1\n    return n
def predict_age(*ages):\n    return sum(a*a for a in ages)**.5//2
def format_poem(poem):\n  return ".\n".join(poem.split(". "))
import math\ndef nth_perm(n,d):\n    digits = [str(i) for i in range(d)]\n    out = ''\n    for i in range(1, d):\n        cycles = math.ceil(n/math.factorial(d-i))\n        out += digits.pop((cycles % (d-i+1)) - 1)\n    return out + digits.pop()
from math import factorial\n\ndef routes(n):\n    return n > 0 and factorial(2*n) // factorial(n)**2
def circular_permutations(n):\n    n = str(n)\n    return [int(n[i:] + n[:i]) for i in range(len(n))]\n\ndef is_prime(n):\n    return n > 1 and all(n % i != 0 for i in range(2, int(n**0.5)+1))\n\ndef circular_prime(n):\n    return all(is_prime(x) for x in circular_permutations(n))\n
def move(position, roll):\n    return position + 2*roll
def without_last(lst):\n    return lst[:-1]
import re\ndef signed_eight_bit_number(number):\n    return bool(re.match("(0|-128|-?([1-9]|[1-9]\d|1[01]\d|12[0-7]))\Z", number))
def string_merge(string1, string2, letter):\n    return string1[:string1.index(letter)] + string2[string2.index(letter):]
from numpy import matrix\n\ndef matrix_mult(a, b):\n  return ( matrix(a) * matrix(b) ).tolist()
from math import log\n\ndef compare_powers(*numbers):\n    a,b = map(lambda n: n[1]*log(n[0]), numbers)\n    return (a<b) - (a>b)
def going(n):  \n    s = 1.0\n    for i in range(2, n + 1):\n        s = s/i + 1\n    return int(s * 1e6) / 1e6
def square_free_part(n):\n    if type(n) != int or n < 1:return None\n    for i in xrange(2, int(n ** 0.5) + 1):\n        while n % (i ** 2) == 0:\n            n /= i\n    return n
def solve(time):\n    def number(n):\n        if n > 20: return "twenty {}".format(number(n - 20))\n        return [\n            None, "one", "two", "three", "four",\n            "five", "six", "seven", "eight", "nine",\n            "ten", "eleven", "twelve", "thirteen",\n            "fourteen", "fifteen", "sixteen", "seventeen",\n            "eighteen", "nineteen", "twenty"][n]\n    hours, minutes = (int(s) for s in time.split(':'))\n    if minutes <= 30:\n        direction = "past"\n    else:\n        hours = (hours + 1) % 24\n        direction = "to"\n        minutes = 60 - minutes\n    hour = number((hours + 11) % 12 + 1) if hours else "midnight"\n    if minutes == 0:\n        return "{} o'clock".format(hour) if hours else hour\n    if minutes == 15:\n        return "quarter {} {}".format(direction, hour)\n    if minutes == 30:\n        return "half past {}".format(hour)\n    return "{} minute{} {} {}".format(\n        number(minutes), "" if minutes == 1 else "s", direction, hour)\n
def decrypt(text, n):\n    if text in ("", None):\n        return text\n    \n    ndx = len(text) // 2\n\n    for i in range(n):\n        a = text[:ndx]\n        b = text[ndx:]\n        text = "".join(b[i:i+1] + a[i:i+1] for i in range(ndx + 1))\n    return text\n\n\n\ndef encrypt(text, n):\n    for i in range(n):\n        text = text[1::2] + text[::2]\n    return text
def encrypter(strng):\n    return ''.join( c if c==' ' else chr(122 - ((ord(c)-97)+13) % 26) for c in strng )
from re import sub\n\ndef look_and_say_sequence(s, n):\n    for _ in range(1, n):\n        s = sub(r'(.)\1*', lambda m: str(len(m.group(0))) + m.group(1), s)\n    return s
def get_real_floor(n):\n    if n <= 0: return n\n    if n < 13: return n-1\n    if n > 13: return n-2
def lowercase_count(strng):\n    return sum(a.islower() for a in strng)\n
def is_even(n):\n    return not n & 1
def lucas_lehmer(n):\n    return n in [2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279,\n                 2203, 2281, 3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701,\n                 23209, 44497, 86243, 110503, 132049, 216091, 756839, 859433,\n                 1257787, 1398269, 2976221, 3021377, 6972593, 13466917, 20996011,\n                 24036583, 25964951, 30402457, 32582657, 3715666]
import re\n\nreg = re.compile('a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*p*q*r*s*t*u*v*w*x*y*z*')\n\ndef longest(s):\n    return max(reg.findall(s), key=len)
from string import ascii_uppercase as u\n\ndef get_column_title(n):\n    assert isinstance(n, int) and n > 0\n    col = []\n    while n:\n        n, r = divmod(n-1, 26)\n        col.append(u[r])\n    return ''.join(reversed(col))
def name_in_str(str, name):\n    it = iter(str.lower())\n    return all(c in it for c in name.lower())
def binary_to_string(binary):\n    return "".join( [ chr( int(binary[i: i+8], 2) ) for i in range(0, len(binary), 8) ] )
def domain_name(url):\n    return url.split("//")[-1].split("www.")[-1].split(".")[0]
def narcissistic(value):\n    return value == sum(int(x) ** len(str(value)) for x in str(value))
def flatten(*a):\n    r = []\n    for x in a:\n        if isinstance(x, list):\n            r.extend(flatten(*x))\n        else:\n            r.append(x)\n    return r
def sierpinski(n):\n    t = ['*']\n    for _ in range(n):\n        t = [r.center(2*len(t[-1])+1) for r in t] + [r + ' ' + r for r in t]\n    return '\n'.join(t)
CACHE = {}\n\ndef squared_cache(number):\n    if number not in CACHE:\n        divisors = [x for x in range(1, number + 1) if number % x == 0]\n        CACHE[number] = sum([x * x for x in divisors])\n        return CACHE[number] \n    \n    return CACHE[number]\n\ndef list_squared(m, n):\n    ret = []\n\n    for number in range(m, n + 1):\n        divisors_sum = squared_cache(number)\n        if (divisors_sum ** 0.5).is_integer():\n            ret.append([number, divisors_sum])\n\n    return ret
def collatz(n):\n  step = 1\n  while n!= 1:\n    n = [n//2, (n*3)+1][n%2]\n    step += 1\n  return step\n\n\n
def remove_duplicate_words(s):\n    return ' '.join(dict.fromkeys(s.split()))
import numpy as np\ndef matrix_addition(a, b):\n    return(np.mat(a)+np.mat(b)).tolist()
def grille(msg, code):\n    return ''.join(msg[-1-i] for i,c in enumerate(bin(code)[::-1]) if c == '1' and i < len(msg))[::-1]
def solve(arr):\n    res = []\n    for first in (arr[0]-1, arr[0], arr[0]+1):\n        for second in (arr[1]-1, arr[1], arr[1]+1):\n            val, step, count = second, second-first, abs(arr[0]-first) + abs(arr[1]-second)\n            for current in arr[2:]:\n                val += step\n                if abs(val-current) > 1: break\n                count += abs(val-current)\n            else:\n                res.append(count)\n    return min(res, default=-1)
def alpha_seq(s):\n    return ",".join( (c * (ord(c)-96)).capitalize() for c in sorted(s.lower()) )
def even_numbers(arr,n):\n    return [i for i in arr if i % 2 == 0][-n:] 
import numpy as np\n\ndef products(n, min_divisor, max_divisor):      \n    if n == 1:\n        yield []\n    for divisor in range(min_divisor, max_divisor+1):\n        if n % divisor == 0:\n            for product in products(n // divisor, divisor, max_divisor):\n                yield product + [divisor] \n\ndef eq_dice(set):\n    product = np.prod(set)\n    lista = list(products(product, 3, min(product-1, 20)))\n    return len(lista) - 1 if len(set) > 1 else len(lista)
from operator import add, sub, mul, truediv\nD = {'+':add, '-':sub, '*':mul, '/':truediv}\n\ndef calculate(a, o, b):\n    try: return D[o](a, b)\n    except: pass
import numpy as np\n\n\ndef reorder(a, b):\n    return np.roll(np.arange(a).reshape(2, -1), b, 1).tolist()\n
def solve(s,a,b):\n    return s[:a]+s[a:b+1][::-1]+s[b+1:]
def is_pandigital(n):\n    s = str(n)\n    return not '0' in s and len(set(s)) == len(s)\n\ndef pow_root_pandigit(val, n, k):\n    res = []\n    current = int(round(val ** (1.0 / n), 5)) + 1\n    while len(res) < k and current <= 987654321 ** (1.0 / n):\n        if is_pandigital(current):\n            p = current ** n\n            if is_pandigital(p):\n                res += [[current, p]]\n        current += 1\n    return res if len(res) != 1 else res[0]
def f(n): return n - m(f(n-1)) if n else 1\n\ndef m(n): return n - f(m(n-1)) if n else 0
def palindrome_chain_length(n):\n    steps = 0\n    while str(n) != str(n)[::-1]:\n        n = n + int(str(n)[::-1])\n        steps += 1\n    return steps
from itertools import cycle\n\ndef add_check_digit(number):\n    fact = cycle([2,3,4,5,6,7])\n    r = sum( int(c) * next(fact) for c in number[::-1]) % 11\n    return number + ('0' if not r else 'X' if r == 1 else str(11-r))
def fish(shoal):\n    eaten, size, target = 0, 1, 4\n    for f in sorted(map(int, shoal)):\n        if f > size: break\n        eaten += f\n        if eaten >= target:\n            size += 1\n            target += 4 * size\n    return size
def scratch(lottery):\n    return sum(int(n) for lot in lottery for a,b,c,n in [lot.split()] if a==b==c)
def amort(rate, bal, term, num_payments):\n    monthlyRate = rate / (12 * 100)\n    c = bal * (monthlyRate * (1 + monthlyRate) ** term) / (((1 + monthlyRate) ** term) - 1)\n    newBalance = bal\n    for i in range(num_payments):\n        interest = newBalance * monthlyRate\n        princ = c - interest\n        newBalance = newBalance - princ\n    return 'num_payment %s c %.0f princ %.0f int %.0f balance %.0f' % (num_payments, c, princ, interest, newBalance)
def f(n):\n    res = 1\n    i = 2\n    while n != 1:\n        k = 0\n        while n % i == 0:\n            k += 1\n            n //= i\n        if k != 0:\n            res *= k * i**(k-1)\n        i += 1\n    return res
def solution(nums):\n    return sorted(nums) if nums else []
import re\ndef reversi_row(moves):\n    row = '........'\n    stones = '*O'\n    for i, m in enumerate(moves):\n        L, M, R = row[:m], stones[i%2], row[m+1:]\n        if R!='' and R[0] == stones[(i+1)%2] and R.find(stones[i%2])>0 and '.' not in R[:R.find(stones[i%2])]:\n            R = R.replace(stones[(i+1)%2], stones[i%2], R.find(stones[i%2]))\n        if L!='' and  L[-1] == stones[(i+1)%2] and L[::-1].find(stones[i%2])>0 and '.' not in L[-1-L[::-1].find(stones[i%2]):]:\n            L = L[::-1].replace(stones[(i+1)%2], stones[i%2], L[::-1].find(stones[i%2]))[::-1]\n\n        row = L + M + R\n    return row
def build_palindrome(strng):\n    n = 0\n    while strng[n:] != strng[n:][::-1]: n += 1\n    return strng + strng[:n][::-1]
def total_kilometers(cons, petrol):\n    return round(100*petrol/cons, 2)\n\ndef check_distance(dist, cons, petrol):\n    return ("You will need to refuel" if dist > total_kilometers(cons, petrol) else\n            [ [n*100, dist-100*n, round(petrol-cons*n, 2)] for n in range(dist//100+1)])
def cut_the_ropes(arr):\n    results = [len(arr)]\n    while arr:\n        m = min(arr)\n        arr = [elem - m for elem in arr if elem != m]\n        results.append(len(arr))\n    return results[:-1]\n    \n
def reverse_list(l):\n  return l[::-1]
#CHAR_TO_MORSE preloaded to convert characters into Morse code\nCODE = {'A': '.-',     'B': '-...',   'C': '-.-.', \n        'D': '-..',    'E': '.',      'F': '..-.',\n        'G': '--.',    'H': '....',   'I': '..',\n        'J': '.---',   'K': '-.-',    'L': '.-..',\n        'M': '--',     'N': '-.',     'O': '---',\n        'P': '.--.',   'Q': '--.-',   'R': '.-.',\n        'S': '...',    'T': '-',      'U': '..-',\n        'V': '...-',   'W': '.--',    'X': '-..-',\n        'Y': '-.--',   'Z': '--..',\n        \n        '0': '-----',  '1': '.----',  '2': '..---',\n        '3': '...--',  '4': '....-',  '5': '.....',\n        '6': '-....',  '7': '--...',  '8': '---..',\n        '9': '----.', \n        \n        ' ': ' '\n        }\n\ndef encryption(string):\n    string.upper()\n    return " ".join([CODE[a] for a in string.upper()])
from statistics import median_low as absolute_values_sum_minimization
def mysterious_pattern(m, n):\n    rows = [[' '] * m for _ in range(n)]\n    a, b = 1, 1\n    for i in range(m):\n        rows[a % n][i] = 'o'\n        a, b = b, a + b\n    rows = [''.join(r).rstrip() for r in rows]\n    return '\n'.join(rows).strip('\n')
def diamond(n):\n    if n < 0 or n % 2 == 0:\n        return None\n    \n    result = "*" * n + "\n";\n    spaces = 1;\n    n = n - 2\n    while n > 0:\n        current = " " * spaces + "*" * n + "\n"\n        spaces = spaces + 1\n        n = n - 2\n        result = current + result + current\n    \n    return result
from itertools import combinations\n\ndef solve(a, n):\n    return any(sum(c) % n == 0 for i in range(len(a)) for c in combinations(a, i+1))
def digitize(n):\n    return [int(d) for d in str(n)]
from collections import Counter\ndef word_square(ls):\n    n = int(len(ls)**0.5)\n    return n*n==len(ls) and sum(i%2 for i in list(Counter(ls).values())) <= n\n
def tax_calculator(total):\n    if not isinstance(total, (int, float)) or total < 0: return 0\n    \n    tax = 0\n    \n    if total > 30: tax = 2.2 + (total - 30) * 0.03\n    elif total > 20: tax = 1.7 + (total - 20) * 0.05\n    elif total > 10: tax = 1 + (total-10) * 0.07\n    elif total > 0: tax = total / 10.0\n\n    return round(tax, 2)\n
def find_uniq(arr):\n    a, b = set(arr)\n    return a if arr.count(a) == 1 else b
def scanner(qrc):\n    bits = ''.join( str(qrc[x][y] ^ ((x+y)%2==0)) for x,y in ticTocGen())\n    size = int(bits[4:12],2)\n    return ''.join( chr(int(bits[i:i+8],2)) for i in range(12,12+8*size,8))\n\n\ndef ticTocGen():\n    x,y,dx = 20,20,-1\n    while y>13: \n        yield from ( (x,y-dy) for dy in range(2) )\n        x+=dx\n        if x==8 or x>20:\n            dx *= -1\n            y  -= 2\n            x   = x==8 and 9 or 20
from math import pi\n\ndef circleArea(r):\n    return round(pi * r ** 2, 2) if type(r) in (int, float) and r > 0 else False\n
def lowest_temp(t):\n  return min((int(x) for x in t.split()), default=None)
def warn_the_sheep(queue):\n    n = len(queue) - queue.index('wolf') - 1\n    return f'Oi! Sheep number {n}! You are about to be eaten by a wolf!' if n else 'Pls go away and stop eating my sheep'\n
def cipher(p):\n    return ''.join(chr((ord(j)+i%3+(i-1)//3-97)%26+97) if j!=' 'and i!=0 else j for i,j in enumerate(p))
def replace_zero(arr):\n    m, im, i, lst = 0, -1, -1, ''.join(map(str,arr)).split('0')\n    for a,b in zip(lst,lst[1:]):\n        i += len(a) + 1 \n        candidate = len(a)+len(b)+1\n        if m <= candidate:\n            im, m = i, candidate\n    return im
def bin_mul(m,n):\n    if m < n: return bin_mul(n,m)\n    if n == 0: return []\n    res = []\n    while m > 0:\n        if m % 2 == 1: res.append(n)\n        m = m//2; n *=2\n    return res[::-1]
import re\n\npowers = {\n    'w': -4, 'p': -3, 'b': -2, 's': -1,\n    'm': +4, 'q': +3, 'd': +2, 'z': +1,\n}\n\ndef alphabet_war(fight):\n    fight = re.sub('.(?=\*)|(?<=\*).', '', fight)\n    result = sum(powers.get(c, 0) for c in fight)\n    if result < 0:\n        return 'Left side wins!'\n    elif result > 0:\n        return 'Right side wins!'\n    else:\n        return "Let's fight again!"
def err_bob(s):\n    res = ""\n    for i, c in enumerate(s):\n        res += c\n        if i == len(s)-1 or s[i+1] in " .,:;!?":\n            if c.islower() and c not in "aeiou":\n                res += "err"\n            if c.isupper() and c not in "AEIOU":\n                res += "ERR"\n    return res
def decipher_word(word):\n    i = sum(map(str.isdigit, word))\n    decoded = chr(int(word[:i]))\n    if len(word) > i + 1:\n        decoded += word[-1]\n    if len(word) > i:\n        decoded += word[i+1:-1] + word[i:i+1]\n    return decoded\n\ndef decipher_this(string):\n    return ' '.join(map(decipher_word, string.split()))
def sum_part(n):\n    m, p, q, r, s = 1, 1, 1, 0, n\n    while n > 9:\n        n, d = divmod(n, 10)\n        r += d * p\n        p *= 10\n        if d: m = 1\n        else: m*= 2\n        s += q*n + m*memo[r]\n        q *= 2\n    return s\n\nfrom collections import defaultdict\nqualified = defaultdict(list)\nmemo = {n: n for n in range(10)}\nfor n in range(10, 10 ** 6):\n    memo[n] = sum_part(n)\n    if memo[n] > n:\n        k, r = divmod(n, memo[n] - n)\n        if not r: qualified[k].append(memo[n] - n)\n\nfrom bisect import bisect\ndef next_higher(n, k):\n    return qualified[k][bisect(qualified[k], n+1)]
def solve(n):\n    if n < 10:\n        return n\n    a = int((len(str(n)) - 1) * '9')\n    b = n - a\n    return sum([int(i) for i in (list(str(a)) + list(str(b)))])\n
def powers(n):\n    return [1<<i for i, x in enumerate(reversed(bin(n))) if x == "1"]
def get_average(marks):\n    return sum(marks) // len(marks)\n
def code_for_same_protein(seq1,seq2):\n    if seq1 == seq2:\n        return True\n    lista = [['GCT','GCC','GCA','GCG'],['CGT','CGC','CGA','CGG','AGA','AGG'],['AAT','AAC'],['GAT','GAC'],['AAT','AAC','GAT','GAC'],['TGT','TGC'],['CAA','CAG'],['GAA','GAG'],['CAA','CAG','GAA','GAG'],['GGT','GGC','GGA','GGG'],['CAT','CAC'],['ATG'],['ATT','ATC','ATA'],['CTT','CTC','CTA','CTG','TTA','TTG'],['AAA','AAG'],['ATG'],['TTT','TTC'],['CCT','CCC','CCA','CCG'],['TCT','TCC','TCA','TCG','AGT','AGC'],['ACT','ACC','ACA','ACG'],['TGG'],['TAT','TAC'],['GTT','GTC','GTA','GTG'],['TAA','TGA','TAG']]\n    for j in range(0,len(lista)):\n        for i in range(0,len(seq1),3):\n            if (seq1[i:i+3] in lista[j] and seq2[i:i+3] not in lista[j]):\n                return False\n    return True\n
def correct(m, n, bits):\n    l = m*n\n    row = next((i for i in range(m) if f"{bits[i*n:(i+1)*n]}{bits[l+i]}".count("1") % 2), None)\n    col = next((i for i in range(n) if f"{bits[i:l:n]}{bits[l+m+i]}".count("1") % 2), None)\n    if row is col is None:\n        return bits\n    err = (l + row) if col is None else (l + m + col) if row is None else (row * n + col)\n    return f"{bits[:err]}{int(bits[err])^1}{bits[err+1:]}"\n
def cyclic_string(s):\n    return next((i for i, _ in enumerate(s[1:], 1) if s.startswith(s[i:])), len(s))
def solve(s,g):\n    return -1 if s % g else (g, s - g)
def approx_root(n):\n    base = int(n**0.5)\n    return round( base + (n - base**2) / ((base + 1)**2 - base**2) , 2)
def next_perfect_square(n):\n    return n>=0 and (int(n**0.5)+1)**2
def f(n):\n    return n * (n + 1) // 2 if (isinstance(n, int) and n > 0) else None\n
def categorize_study(p_value, requirements):\n    study_value = p_value * (2**(6-requirements))\n    \n    if study_value < 0.05 and requirements != 0:\n        return "Fine"\n    elif study_value < 0.05 and requirements == 0:\n        return "Needs review"\n    elif study_value > 0.05 and study_value < 0.15:\n        return "Needs review"\n    else:\n        return "Pants on fire"\n    \n        \n            \n        \n
def array(strng):\n    return ' '.join(strng.split(',')[1:-1]) or None\n
COLORS = set("RGB")\n\ndef triangle(row):\n    while len(row)>1:\n        row = ''.join( a if a==b else (COLORS-{a,b}).pop() for a,b in zip(row, row[1:]))\n    return row
from math import ceil\n\n\ndef snail(column, day, night):\n    return max(ceil((column-night)/(day-night)), 1)
import itertools\ndef transpose_two_strings(arr):\n    return '\n'.join( ' '.join(elt) for elt in itertools.zip_longest(arr[0],arr[1],fillvalue=' ') )
from fractions import gcd\nfrom functools import reduce\n\ndef candies_to_buy(n):\n    return reduce(lambda a,b:a*b//gcd(a,b), range(1,n+1))
def disarium_number(n):\n    return "Disarium !!" if n == sum(int(d)**i for i, d in enumerate(str(n), 1)) else "Not !!"
def repeater(string, n):\n    return '"{}" repeated {} times is: "{}"'.format(string, n, string * n)\n
def final_grade(exam, projects):\n  if exam > 90 or  projects > 10: return 100\n  if exam > 75 and projects >= 5: return 90\n  if exam > 50 and projects >= 2: return 75\n  return 0
def multiplication_table(row,col):\n    return [[(i+1)*(j+1) for j in range(col)] for i in range(row)]
from itertools import combinations\n\ndef solve(n, k):\n    return ''.join(min(combinations(str(n), len(str(n))-k)))
from operator import mul\nfrom functools import reduce\nfrom collections import Counter\nfrom math import factorial as fact\n\ndef uniq_count(s):\n    return fact(len(s)) // reduce(mul, map(fact, Counter(s.lower()).values()), 1)
def common_ground(s1,s2):\n    lst = []\n    for w in s2.split():\n        if w in s1.split() and w not in lst:\n            lst.append(w)\n    return ' '.join(lst) if lst else "death"
from functools import reduce\n\n\ndef disjunction(operands, is_exclusive):\n    return reduce(bool.__xor__ if is_exclusive else bool.__or__, operands)
def sum_times_tables(table,a,b):\n    return sum(table) * (a + b) * (b - a + 1) // 2 \n
def isLeapYear(year):\n    return (year % 100 != 0 and year % 4 == 0) or year % 400 == 0
def valid_card(card):\n    s = list(map(int, str(card.replace(' ', ''))))\n    s[0::2] = [d * 2 - 9 if d * 2 > 9 else d * 2 for d in s[0::2]]\n    return sum(s) % 10 == 0
from re import match\n\n\ndef date_checker(date):\n    return bool(match(r'\d{2}-\d{2}-\d{4}\s\d{2}:\d{2}', date))\n
def integrate(coef, exp):\n    exp = exp + 1\n    coef = coef / exp if coef % exp else coef // exp\n    return f"{coef}x^{exp}"
def scramble(s1,s2):\n    for c in set(s2):\n        if s1.count(c) < s2.count(c):\n            return False\n    return True
CONSONANTS = set('bcdfghjklmnpqrstvwxyz')\n\ndef count_consonants(text):\n    return len(CONSONANTS.intersection(text.lower()))
def to_twos_complement(binary, bits):\n    return int(binary.replace(' ', ''), 2) - 2 ** bits * int(binary[0])\n\ndef from_twos_complement(n, bits):\n    return '{:0{}b}'.format(n & 2 ** bits - 1, bits)
def mod256_without_mod(number):\n  return number & 255  
def next_day_of_week(current_day, available_week_days):\n    x = 2 ** current_day\n    while not x & available_week_days:\n        x = max(1, (x * 2) % 2 ** 7)\n    return x.bit_length()
def doubles(s):\n    cs = []\n    for c in s:\n        if cs and cs[-1] == c:\n            cs.pop()\n        else:\n            cs.append(c)\n    return ''.join(cs)
def pattern(n):\n    return '\n'.join(['1'] + ['1' + '*' * (i-1) + str(i) for i in range(2, n+1)])\n
import re\n\ndef to_integer(s):\n    if re.match("\A[+-]?(\d+|0b[01]+|0o[0-7]+|0x[0-9a-fA-F]+)\Z", s):\n        return int(s, 10 if s[1:].isdigit() else 0)
def unlucky_number(n):\n    return sum(not ('4' in s or '7' in s) for s in map(str, range(0, n+1, 13)))
def sort_string(s, ordering):\n    answer = ''\n    for o in ordering:\n        answer += o * s.count(o)\n        s = s.replace(o,'')\n    return answer + s 
from itertools import zip_longest\n\ndef battle(player1, player2):\n    result = {'player1': [], 'player2': []}\n    for (p1, t1), (p2, t2) in zip_longest(player1, player2, fillvalue=[0,0]):\n        if t1 > p2:\n            result['player1'].append([p1,t1])\n        if t2 > p1:\n            result['player2'].append([p2,t2])\n    return result\n
def p(t,k,n,l=1):\n    if t<l: pass\n    elif k==1 and t!=n: yield [t]\n    else: yield from ([m]+s for m in range(l,t-l+1) for s in p(t-m,k-1,n,m) if m!=n)\n\ndef part_const(t,k,n): return sum(1 for _ in p(t,k,n))
# from math import copysign\ndef sequence_sum(a, b, step):\n    n = (b-a)//step\n    return 0 if n<0 else (n+1)*(n*step+a+a)//2
def get_char_count(s):\n    counts = {}\n    for c in (c.lower() for c in s if c.isalnum()):\n        counts[c] = counts[c] + 1 if c in counts else 1\n    m = {}\n    for k, v in counts.items():\n        m[v] = sorted(m[v] + [k]) if v in m else [k]\n    return m
def extra_perfect(n):\n    return list(range(1,n+1,2))
import re\ndef string_parse(string):\n    return re.sub(r'(.)\1(\1+)', r'\1\1[\2]', string) if isinstance(string, str) else 'Please enter a valid string'
def time_convert(num):\n    return "{:02d}:{:02d}".format(*divmod(max(num, 0), 60))
DENSITY = {'H': 1.36, 'W': 1, 'A': 0.87, 'O': 0.8}\n\n\ndef separate_liquids(glass):\n    if not glass:\n        return []\n    column = len(glass[0])\n    liquids = sorted((b for a in glass for b in a), key=lambda c: DENSITY[c])\n    return [liquids[d:d + column] for d in range(0, len(liquids), column)]\n
def find_last(n, m):\n    li, start = [[0, i + 1] for i in range(n)], 0      # form list of circle with numbers\n    while len(li) != 1:\n        prev, l_ = li[start][1], len(li)               # starting point and length of circle\n        for k in range(m):                             # adding 1 to first m players in circle             \n            li[start][0] += 1\n            start = (start + 1) % l_\n\n        if m < len(li):                                # if there's anyone left from adding 1 if so..\n            k = start\n            while li[k][1] != prev:                    # adding 2 to remaining players\n                li[k][0] += 2\n                k = (k + 1) % l_\n                \n        li[start][0] += li.pop((start - 1) % l_)[0]    # add last person who receives last 1 coin to next person\n        start = [(start - 1) % l_ ,start][start==0]\n    return tuple(li[0][::-1])                          # return last person with score and original number
def beeramid(bonus, price):\n    beers  = bonus // price\n    levels = 0\n    \n    while beers >= (levels + 1) ** 2:\n        levels += 1\n        beers  -= levels ** 2\n    \n    return levels
def eval_object(v):\n    return {"+": v['a']+v['b'],\n            "-": v['a']-v['b'],\n            "/": v['a']/v['b'],\n            "*": v['a']*v['b'],\n            "%": v['a']%v['b'],\n           "**": v['a']**v['b'], }.get(v['operation'])
def save(sizes, hd): \n    for i,s in enumerate(sizes):\n        if hd < s: return i\n        hd -= s\n    return len(sizes)
def array_manip(array):\n    return [min([a for a in array[i+1:] if a > array[i]], default=-1) for i in range(len(array))]
def substring(s):\n    r, rm = [], []\n    for i, x in enumerate(s):\n        if x in r or len(set(r)) < 2:\n            r += x;\n        else:\n            if len(r) > len(rm): rm = r[:]\n            r = [y for y in r[-1::-1] if y == r[-1]] + [x]\n    if len(r) > len(rm): rm = r[:]\n    return ''.join(rm)
def correct_polish_letters(s):\n    return s.translate(str.maketrans("", "acelnoszz"))
#Remember you have a CHANGE dictionary to work with ;)\n\ndef change_count(change):\n    money = {'penny' : 0.01, 'nickel' : 0.05, 'dime' : 0.10, 'quarter' : 0.25, 'dollar' : 1.00}\n    count = 0\n    for coin in change.split():\n        count += money[coin]\n    result = "%.2f" % count\n    return '$' + result\n        \n
def pig_it(text):\n    lst = text.split()\n    return ' '.join( [word[1:] + word[:1] + 'ay' if word.isalpha() else word for word in lst])\n
from collections import Counter\n\ndef solve(a,b):\n    return 0 if Counter(b) - Counter(a) else len(a) - len(b)
def sort_by_area(seq): \n    def func(x):\n        if isinstance(x, tuple):\n            return x[0] * x[1]\n        else:\n            return 3.14 * x * x\n    return sorted(seq, key=func)
from math import ceil, log, sqrt\n\ndef isPP(n):\n    for b in range(2, int(sqrt(n)) + 1):\n        e = int(round(log(n, b)))\n        if b ** e == n:\n            return [b, e]\n    return None\n
code = {'black': 0, 'brown': 1, 'red': 2, 'orange': 3, 'yellow': 4,\n'green': 5, 'blue': 6, 'violet': 7, 'gray': 8, 'white': 9,\n'gold': 5, 'silver': 10, '': 20}\ndef decode_resistor_colors(bands):\n    colors = (bands + ' ').split(' ')\n    value = 10 * code[colors[0]] + code[colors[1]]\n    value *= 10 ** code[colors[2]]\n    tolerance = code[colors[3]]\n    prefix = ''\n    for p in 'kM':\n        if value // 1000:\n            prefix = p\n            value /= 1000\n    return "%g%s ohms, %d%%" % (value, prefix, tolerance)\n
def to24hourtime(hour, minute, period):\n    return '%02d%02d' % (hour % 12 + 12 * (period == 'pm'), minute)
def remove_exclamation_marks(s):\n    return s.replace('!', '')
from math import factorial as f\nnumber_of_routes=lambda m,n:f(m+n)//(f(m)*f(n))
def solution(*args):\n    return len(args) != len(set(args))
def dig_pow(n):\n    return sum(int(x)**y for y,x in enumerate(str(n), 1))\n\ndef sum_dig_pow(a, b): \n    return [x for x in range(a,b + 1) if x == dig_pow(x)]
def power_mod(b, e, m):\n  res, b = 1, b % m\n  while e > 0:\n    if e & 1: res = res * b % m\n    e >>= 1\n    b = b * b % m\n  return res
def super_pad(string, width, fill=" "):\n    if fill.startswith('>'):\n        return (string + width * fill[1:])[:width]\n    elif fill.startswith('^'):\n        pad = (width * fill[1:])[:max(0, width - len(string) + 1) // 2]\n        return (pad + string + pad)[:width]\n    else:\n        if fill.startswith('<'): fill = fill[1:]\n        return (width * fill)[:max(0, width - len(string))] + string[max(0, len(string) - width):]
def vowel_indices(word):\n    return [i for i,x in enumerate(word,1) if x.lower() in 'aeiouy']
def delete_nth(order,max_e):\n    ans = []\n    for o in order:\n        if ans.count(o) < max_e: ans.append(o)\n    return ans\n
def halving_sum(n): \n    s=0\n    while n: \n        s+=n ; n>>=1\n    return s
def meters(x):\n    #your code here\n    arr = ['','k','M','G','T','P','E','Z','Y']\n    count=0\n    while x>=1000 :\n        x /=1000.00 \n        count+=1\n    if int(x)==x:\n        x=int(x) \n    return str(x)+arr[count]+'m'\n
def count_red_beads(nb):\n    return max(0, 2 * (nb - 1) )
def find_key(key):\n    n = int(key, 16)\n    return next((k - 1) * ((n // k) - 1) for k in range(2, int(n**0.5)+1) if n % k == 0)\n
def last_fib_digit(n):\n    return [0,1,1,2,3,5,8,3,1,4,5,9,4,3,7,0,7,7,4,1,5,6,1,7,8,5,3,8,1,9,0,9,9,8,7,5,2,7,9,6,5,1,6,7,3,0,3,3,6,9,5,4,9,3,2,5,7,2,9,1][n%60]
def folding(a,b):\n  squares = 1\n  while a != b:\n      squares += 1\n      b, a = sorted((a - b, b))\n  return squares
def validate_sequence(seq):\n    return len({a - b for a, b in zip(seq, seq[1:])}) == 1
from string import ascii_lowercase as aLow\nimport re\n\ndef rotateWord(w, alpha, dct, d):\n    lst = []\n    for i,c in enumerate(w.lower(), 1):\n        transChar = alpha[ (dct[c] + i*d) % 26 ]\n        if w[i-1].isupper(): transChar = transChar.upper()\n        lst.append(transChar)\n    return ''.join(lst)\n\ndef encode(text, key, d=1):\n    remains, alpha = set(aLow), []\n    for c in key+aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct   = {c:i for i,c in enumerate(alpha)}\n    return re.sub(r'[a-zA-Z]+', lambda m: rotateWord(m.group(),alpha,dct,d), text)\n    \ndef decode(text, key):\n    return encode(text, key, -1)
_RESULTS = {\n    'goodpresent': lambda y: ''.join(chr(ord(c) + y) for c in 'goodpresent'),\n    'crap': lambda y: 'acpr',\n    'empty': lambda y: 'empty',\n    'bang': lambda y: str(sum(ord(c) - y for c in 'bang')),\n    'badpresent': lambda y: 'Take this back!',\n    'dog': lambda y: 'pass out from excitement {} times'.format(y)\n}\n\npresent = lambda x, y: _RESULTS[x](y)
def parade_time(groups, location, speed, pref):\n    return [c // speed for c, p in enumerate(groups, 1 + location) if p == pref]
dict = {'-':"file",'d':"directory",'l':"symlink",'c':"character_file",'b':"block_file",'p':"pipe",'s':"socket",'D':"door"}\ndef linux_type(file_attribute):\n    return dict[file_attribute[0]]
def duplicate_elements(m, n):\n    return not set(m).isdisjoint(n)
import math\ndef isPrime(n):\n    if n <= 1:\n        return False\n    for i in range(2,int(math.sqrt(n)+1)):\n        if n % i == 0:\n            return False\n    return True\n\ndef step(g,m,n):\n    if m >= n:\n        return []\n    else:\n        for i in range(m,n+1-g):\n            if isPrime(i) and isPrime(i+g):\n                return[i,i+g]\n
def on_line(points):\n    points = list(set(points))\n    cross_product = lambda a, b, c: a[0]*(b[1]-c[1]) + b[0]*(c[1]-a[1]) + c[0]*(a[1]-b[1])\n    return all(cross_product(p, *points[:2]) == 0 for p in points[2:])
def max_gap(numbers):\n    lst = sorted(numbers)\n    return max(b-a for a,b in zip(lst, lst[1:]))
CRITERIA = (str.islower, str.isupper, str.isdigit)\n\ndef password(s):\n    return len(s)>7 and all( any(map(f,s)) for f in CRITERIA)
def dna_to_rna(dna):\n    return dna.replace("T", "U")
def flipping_game(num):\n    current = 0\n    biggest = 0\n    for i in num:\n        current = max(0, current - ( i or -1 ) )\n        biggest = max(biggest, current)\n        \n    return sum(num) + (biggest or -1)
def any_arrows(arrows):\n    return any(not i.get("damaged", False) for i in arrows)\n
def quotable(name, quote):\n    return '{} said: "{}"'.format(name, quote)
def compound_array(a, b):\n    x = []\n    while a or b:\n      if a: x.append(a.pop(0))\n      if b: x.append(b.pop(0))\n    return x
songs = [{'artist': 'Marillion', 'title': 'Keyleigh', 'playback': '03:36'}, {'artist': 'Pink Floyd', 'title': 'Time', 'playback': '06:48'}, {'artist': 'Rush', 'title': 'YYZ', 'playback': '04:27'}, {'artist': 'Bonobo', 'title': 'Days To Come', 'playback': '03:50'}, {'artist': 'Coldplay', 'title': 'Yellow', 'playback': '04:32'}, {'artist': 'Bloc Party', 'title': 'Like Eating Glass', 'playback': '04:22'}, {'artist': 'The Killers', 'title': 'For Reasons Unknown', 'playback': '03:30'}, {'artist': 'Arctic Monkeys', 'title': 'Teddy Picker', 'playback': '03:25'}, {'artist': 'Joe Satriani', 'title': 'Surfing With The Alien', 'playback': '04:34'}]\ndef calculate_seconds(s):\n    minutes, seconds = [int(x) for x in s.split(':')]\n    return minutes * 60 + seconds\n\ndef longest_possible(playback):\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if len(candidates) > 0 else False
import re\n\ndef asterisc_it(s):\n    if   isinstance(s,int):  s=str(s)\n    elif isinstance(s,list): s=''.join(map(str,s))\n    return re.sub(r'(?<=[02468])(?=[02468])', '*', s)
def valid_mersenne(n):\n    return n in {2,3,5,7,13,17,19,31,61,89,107,127,521,607,1279}
def apple(x):\n  return "It's hotter than the sun!!" if int(x) ** 2 > 1000 else  "Help yourself to a honeycomb Yorkie for the glovebox."
def de_nico(key, msg):\n    ll, order, s = len(key), [sorted(key).index(c) for c in key], ''\n    while msg:\n        s, msg = s + ''.join(msg[i] for i in order if i < len(msg)), msg[ll:]\n    return s.strip()
def to_bits(s):\n    lst = [0] * 5000\n    for i in map(int,s.split()): lst[i] = 1\n    return lst
def get_order(order):\n    menu = ['burger', 'fries', 'chicken', 'pizza', 'sandwich', 'onionrings', 'milkshake', 'coke']\n    clean_order = ''\n    for i in menu:\n        clean_order += (i.capitalize() + ' ') * order.count(i)\n    return clean_order[:-1]
def cog_RPM(cogs, n):\n    return [\n        cogs[n] / cogs[0] * (-1 if n % 2 else 1),\n        cogs[n] / cogs[-1] * (1 if (len(cogs) - n) % 2 else -1),\n    ]
def is_even(n): \n    return n%2 == 0
from math import pi, sin\n\ndef scroller(text, amp, period):\n    return '\n'.join(' ' * (amp + int(round(sin(i * 2 * pi / period) * amp))) + c for i, c in enumerate(text))\n
def norm_index_test(a, n):\n    if a: return a[n % len(a)]
from datetime import datetime\n\n\ndef get_calendar_week(date_string):\n    return datetime.strptime(date_string, "%Y-%m-%d").isocalendar()[1]    
def find_page_number(pages):\n    n, miss = 1, []\n    for i in pages:\n        if i!=n: miss.append(i)\n        else:    n+=1\n    return miss
def owned_cat_and_dog(cy, dy):\n    cat = 0 if cy < 15 else 1 if cy < 24 else 2 + (cy - 24) // 4\n    dog = 0 if dy < 15 else 1 if dy < 24 else 2 + (dy - 24) // 5\n    return [cat, dog]
def increment_string(strng):\n    head = strng.rstrip('0123456789')\n    tail = strng[len(head):]\n    if tail == "": return strng+"1"\n    return head + str(int(tail) + 1).zfill(len(tail))
MORSE_TO_NUM = {\n    ".----" : "1",\n    "..---" : "2",\n    "...--" : "3",\n    "....-" : "4",\n    "....." : "5",\n    "-...." : "6",\n    "--..." : "7",\n    "---.." : "8",\n    "----." : "9",\n    "-----" : "0",\n}\n\ndef morse_converter(s):\n    return int("".join(MORSE_TO_NUM[s[i:i+5]] for i in range(0, len(s), 5)))\n
from itertools import chain\n\ndef well(arr):\n    c = sum(isinstance(x, str) and x.lower() == 'good' for x in chain.from_iterable(arr))\n    return (\n        'I smell a series!' if c > 2 else\n        'Publish!' if c > 0 else\n        'Fail!'\n    )
validate_ean = lambda code: (sum(map(int, code[0::2])) + sum(map(int, code[1::2])) * 3) % 10 == 0
def odd_ones_out(numbers):\n    return [i for i in numbers if numbers.count(i) % 2 == 0]
import re\n\ndef polynomialize(roots):\n    \n    def deploy(roots):\n        r = -roots[0]\n        if len(roots) == 1: return [r, 1]\n        \n        sub = deploy(roots[1:]) + [0]\n        return [c*r + sub[i-1] for i,c in enumerate(sub)]\n    \n    coefs = deploy(roots)\n    poly  = ' + '.join(["{}x^{}".format(c,i) for i,c in enumerate(coefs) if c][::-1])\n    poly  = re.sub(r'x\^0|\^1\b|\b1(?=x)(?!x\^0)', '', poly).replace("+ -", "- ") + ' = 0'\n    return poly
def reverse_middle(lst):\n    l = len(lst)//2 - 1\n    return lst[l:-l][::-1]
def sum_square_even_root_odd(nums):\n    return round(sum(n ** 2 if n % 2 == 0 else n ** 0.5 for n in nums), 2)
def array_previous_less(arr):\n  return [next((y for y in arr[:i][::-1] if y < x),-1) for i,x in enumerate(arr)]
def update_score(score, trump, alone, tricks):\n    done = tricks.count(trump)\n    mul = 2 if done == 5 and alone else 1\n    add = 1 if done in (3, 4) else 2\n    winner = trump if done > 2 else (3 - trump)\n    return [pts + (add * mul if team == winner else 0) for team, pts in enumerate(score, 1)]
import re\n\n\ndef show_me(name):\n    return bool(re.match(r'(-[A-Z][a-z]+)+$', '-' + name))
def get_score(dice):\n    if all(i in dice for i in range(1, 7)):\n        return 1000\n    if len(dice) == 6 and all(dice.count(d) == 2 for d in set(dice)):\n        return 750\n    score = 0\n    score += sum((dice.count(d)==n) * d * (n-2) * (1000 if d==1 else 100) for d in set(dice) for n in range(3, 7))\n    score += 100 * dice.count(1) if dice.count(1) < 3 else 0\n    score += 50 * dice.count(5) if dice.count(5) < 3 else 0\n    return score if score else 'Zonk'
def hanoiArray(n):\n    A, B, C = list(range(n, 0, -1)), [], []\n    res = [str([A, C, B])]\n    def rec(n, X, Y, Z):\n        if not n: return\n        rec(n-1, X, Z, Y)\n        Y.append(X.pop())\n        res.append(str([A, C, B]))\n        rec(n-1, Z, Y, X)        \n    rec(n, A, B, C)\n    return '\n'.join(res)
from collections import Counter\n\ndef diamonds_and_toads(sentence, fairy):\n    c = Counter(sentence)\n    d = {'good':['ruby', 'crystal'], 'evil':['python', 'squirrel']}\n\n    return {s:c[s[0]] + 2*c[s[0].upper()] for s in d[fairy]}
def odd_count(n):\n    return len(range(1, n, 2))
def capitalize_word(word):\n    return word.capitalize()\n\n    # .capitilize() for the first word in the string\n    # .title() for each word in the string\n
def chromosome_check(sperm):\n    return 'Congratulations! You\'re going to have a {}.'.format('son' if 'Y' in sperm else 'daughter')
def ski_jump(mountain):\n    height = len(mountain)\n    speed = height * 1.5\n    jump_length = height * speed * 9 / 10\n    return (\n        f"{jump_length:.2f} metres: He's crap!" if jump_length < 10  else\n        f"{jump_length:.2f} metres: He's ok!" if jump_length < 25 else\n        f"{jump_length:.2f} metres: He's flying!" if jump_length < 50 else\n        f"{jump_length:.2f} metres: Gold!!"\n    )
from collections import Counter\nfib = [0, 1]\n\ndef around_fib(n):\n    while len(fib) <= n: fib.append(fib[-1] + fib[-2])\n    f = str(fib[n])\n    val = max((v, -int(k)) for k,v in Counter(f).items())\n    last = f[-(len(f)%25 or 25):]\n    return f"Last chunk {last}; Max is {val[0]} for digit {-val[1]}"
def count_inversion(nums):\n    return sum(a > b for i, a in enumerate(nums) for b in nums[i + 1:])\n
def distance(n):\n    if n == 1: return 0\n    r = 0 - (1 - n ** .5) // 2\n    d, m = divmod(n - (2*r - 1) ** 2 - 1, 2*r)\n    z = (r * (1 + 1j) - m - 1) * 1j ** d\n    return abs(z.real) + abs(z.imag)
def stringy(size):\n    return "".join([str(i % 2) for i in range(1, size + 1)])
def solve(st,k): \n    for l in sorted(st)[:k]:\n        st=st.replace(l,'',1)\n    return st
def find_missing(arr1, arr2):\n    return sum(arr1) - sum(arr2)\n
def leo(oscar):\n    if oscar == 88:\n            return "Leo finally won the oscar! Leo is happy"\n    elif oscar == 86:\n            return "Not even for Wolf of wallstreet?!"\n    elif oscar < 88:\n            return "When will you give Leo an Oscar?"\n    elif oscar > 88:\n            return "Leo got one already!"\n
def bumps(road):\n    return "Woohoo!" if road.count("n") <= 15 else "Car Dead"
def is_lucky(ticket):\n    if len(ticket) == 6 and ticket.isdigit():\n        t = list(map(int, ticket))\n        return sum(t[:3]) == sum(t[3:])\n    return False
def solve(xs):\n    m = 0\n    for x in sorted(xs):\n        if x > m + 1:\n            break\n        m += x\n    return m + 1
def is_divisible(wall_length, pixel_size):\n    return wall_length % pixel_size == 0
def invite_more_women(arr):\n    return sum(arr) > 0
def solve(xs):\n    x, y, z = sorted(xs)\n    return min(x + y, (x + y + z) // 2)
def Dragon(n):\n    if not isinstance(n, int) or n < 0:\n        return ''\n        \n    value = 'Fa'\n    \n    for i in range(n):\n        value = value.replace('a', 'aRcFR')\n        value = value.replace('b', 'LFaLb')\n        value = value.replace('c', 'b')\n        \n    return value.replace('a', '').replace('b', '')
from itertools import compress,product\n\ndef powerset(a):\n    return [list(compress(a,p)) for p in product((0,1),repeat=len(a))]\n
def longest(words):\n    return max(map(len, words))
from collections import Counter\n\ndef fib_digits(n):\n    a, b = 0, 1\n    for i in range(n): a, b = b, a+b\n    return sorted(((b, int(a)) for a, b in Counter(str(a)).items()), reverse=True)
def paperwork(n, m):\n    return n * m if n > 0 and m > 0 else 0
from math import factorial\n\ndef choose(n, k):\n    return factorial(n) / ( factorial(k) * factorial(n-k) ) if k <=n else 0
def get_positions(n):\n    return tuple(n // d % 3 for d in (1, 3, 9))
def sea_sick(sea):\n    return "Throw Up" if (sea.count("~_") + sea.count("_~"))/len(sea) > 0.2 else "No Problem"
def is_digit(n):\n    return n.isdigit() and len(n)==1
def binary_array_to_number(arr):\n  return int("".join(map(str, arr)), 2)
from collections import deque\nKEYBOARD = ['zxcvbnm,.', 'ZXCVBNM<>', 'asdfghjkl', 'ASDFGHJKL', 'qwertyuiop', 'QWERTYUIOP']\n\ndef encrypt(text, encryptKey): return converter(text, encryptKey, 1)\ndef decrypt(text, encryptKey): return converter(text, encryptKey, -1)\n    \ndef converter(text, encryptKey, sens):\n    deques = list(map(deque, KEYBOARD))\n    for i, deq in enumerate(deques):\n        deq.rotate(-sens * (encryptKey // 10**(i//2) % 10) )\n    return text.translate(str.maketrans(''.join(KEYBOARD), ''.join(''.join(deq) for deq in deques)))
from itertools import product\ndef proc_seq(*args):\n    nums = set(int(''.join(l)) for l in product(*(str(a) for a in args)) if l[0] != '0')\n    if len(nums) == 1: return [1, nums.pop()]\n    return [len(nums), min(nums), max(nums), sum(nums)]
def html(tag, *contents, **attr):\n    openTag = tag + ''.join(f' {"class" if k=="cls" else k}="{v}"' for k,v in attr.items())\n    \n    return '\n'.join( f'<{openTag}>{c}</{tag}>' for c in contents) or f'<{openTag} />'
from collections import Counter \n\nEXECUTIONS_ORDER = [('Z', Counter("ZERO"),  '0'),\n                    ('W', Counter("TWO"),   '2'),\n                    ('U', Counter("FOUR"),  '4'),\n                    ('X', Counter("SIX"),   '6'),\n                    ('G', Counter("EIGHT"), '8'),\n                    ('O', Counter("ONE"),   '1'),\n                    ('H', Counter("THREE"), '3'),\n                    ('F', Counter("FIVE"),  '5'),\n                    ('V', Counter("SEVEN"), '7'),\n                    ('I', Counter("NINE"),  '9')]\n\ndef original_number(s):\n    ans, count, executions = [], Counter(s), iter(EXECUTIONS_ORDER)\n    while count:\n        c, wordCount, value = next(executions)\n        ans.extend([value]*count[c])\n        for _ in range(count[c]): count -= wordCount\n    return ''.join(sorted(ans))
def quadratic(x1, x2):\n    return (1,-x1-x2,x1*x2)\n
def unique_digits(n):\n    return len(set(str(n))) == len(str(n))\n\ndef next_numb(val):\n    val += 1\n    while val % 3: val += 1\n    if val % 2 == 0: val += 3\n    \n    while not unique_digits(val):\n        val += 6\n        if val > 9876543210: break\n    else:\n        return val\n    \n    return "There is no possible number that fulfills those requirements"\n
def solve(a,b):\n    return [a.count(e) for e in b]
def doors(n):\n    return int(n ** .5)
from math import gcd\n\n\ndef greatest(x, y, n):\n    z = x * y // gcd(x, y)\n    return (n - 1) // z * z\n    \ndef smallest(x, y, n):\n    z = x * y // gcd(x, y)\n    return (n + z) // z * z\n
def capitalize(s,ind):\n    ind = set(ind)\n    return ''.join(c.upper() if i in ind else c for i,c in enumerate(s))
from collections import Counter\nimport re\n\ndef is_isogram(word):\n    if type(word) is not str or not word: return False\n    return len(set( Counter(re.sub(r'[^a-z]', "", word.lower())).values() )) == 1
def work_on_strings(a, b):\n    new_a = [letter if b.lower().count(letter.lower()) % 2 == 0 else letter.swapcase() for letter in a]\n    new_b = [letter if a.lower().count(letter.lower()) % 2 == 0 else letter.swapcase() for letter in b]\n    return ''.join(new_a) + ''.join(new_b)
def membership(amount, platinum, gold, silver, bronze):\n    ordered = reversed(sorted((v, k) for k, v in locals().items() if k != 'amount'))\n    return next((level.capitalize() for threshold, level in ordered if amount >= threshold), 'Not a member')
def say_hello(name, city, state):\n  return "Hello, {}! Welcome to {}, {}!".format(" ".join(name), city, state)\n
def plane_seat(a):\n    front, middle, back = (list(range(1,21)), list(range(21,41)), list(range(41,61)))\n    left, center, right = ('ABC', 'DEF', "GHK")\n    x, y = ('', '')\n        \n    if int(a[:-1]) in front:    x = 'Front-'\n    if int(a[:-1]) in middle:   x = 'Middle-'\n    if int(a[:-1]) in back:     x = 'Back-'\n\n    if a[-1] in left:    y = 'Left'\n    if a[-1] in center:  y = 'Middle'\n    if a[-1] in right:   y = 'Right'\n    \n    return x+y if all((x,y)) else 'No Seat!!'\n
def find_f1_eq_f2(n,k):\n    s = set(range(k))\n    while True:\n        n += 1\n        testn = n\n        while True:\n            f = set(map(int,str(testn)))\n            if f<=s:\n                if f==s: return n\n                break\n            testn += n
def move_vowels(s): \n    return ''.join(sorted(s, key=lambda k: k in 'aeiou'))
def find_nb(m):\n    n = 1\n    volume = 0\n    while volume < m:\n        volume += n**3\n        if volume == m:\n            return n\n        n += 1\n    return -1
from itertools import groupby\n\ndef run_length_encoding(s):\n    return [[sum(1 for _ in g), c] for c, g in groupby(s)]
def lovefunc( flower1, flower2 ):\n    return (flower1+flower2)%2
sum_dig = lambda n, D={str(d): d*d for d in range(10)}: sum(map(D.get, str(n)))\nis_happy = lambda n: n > 4 and is_happy(sum_dig(n)) or n == 1\n\nhappy_set = set(filter(is_happy, range(100)))\nfor n in range(100, 3 * 10 ** 5):\n    if sum_dig(n) in happy_set: happy_set.add(n)\n\nfrom bisect import bisect\ndef performant_numbers(n, happy_list=sorted(happy_set)): return happy_list[:bisect(happy_list, n)]
def diagonal(n, p):\n    # your code\n    res = 0\n    for base in range(p, max(n,p) + 1):\n        value = 1\n        for i in range(base-p+1,base+1):\n            value *= i\n        for i in range(1,p+1):\n            value //= i\n        res += int(value)\n    return res\n
from itertools import cycle\n\ndef find_pattern(s):\n    diffs = [y - x for x, y in zip(s, s[1:])]    \n    for i in range(1, len(diffs) + 1):\n        if len(diffs) % i == 0 and all(a == b for a, b in zip(diffs, cycle(diffs[:i]))): return diffs[:i]
def eq_sum_powdig(hMax, exp):\n    return [i for i in range(2, hMax + 1) if i == sum(int(c) ** exp for c in str(i))]\n
database = '''werewolf : Silver knife or bullet to the heart\nvampire : Behead it with a machete\nwendigo : Burn it to death\nshapeshifter : Silver knife or bullet to the heart\nangel : Use the angelic blade\ndemon : Use Ruby's knife, or some Jesus-juice\nghost : Salt and iron, and don't forget to burn the corpse\ndragon : You have to find the excalibur for that\ndjinn : Stab it with silver knife dipped in a lamb's blood\npagan god : It depends on which one it is\nleviathan : Use some Borax, then kill Dick\nghoul : Behead it\njefferson starship : Behead it with a silver blade\nreaper : If it's nasty, you should gank who controls it\nrugaru : Burn it alive\nskinwalker : A silver bullet will do it\nphoenix : Use the colt\nwitch : They are humans\nelse : I have friggin no idea yet'''\n\nanswers = {line.split(' : ')[0]:line.split(' : ')[1] for line in database.splitlines()}\n\ndef bob(what):\n    return answers.get(what, answers['else'])+', idjits!'
def is_onion_array(a):\n    return all(a[i] + a[-i-1] <= 10 for i in range(len(a) // 2))
def fixed_xor(a, b):\n    return "".join(f"{int(x, 16)^int(y, 16):x}" for x, y in zip(a, b))
def ranking(a):\n    a.sort(key=lambda x: (-x["points"], x["name"]))\n    for i, x in enumerate(a):\n        x["position"] = i + 1 if not i or x["points"] < a[i-1]["points"] else a[i-1]["position"]\n    return a
from collections import deque\n\ndef loose_change(coins_list, amount_of_change):\n    q = deque([(0, amount_of_change)])\n\n    while q:\n        l, a = q.popleft()\n        if a == 0:\n            return l\n        q.extend((l + 1, a - i) for i in coins_list if a >= i)
def is_substitution_cipher(s1, s2):\n    return len(set(s1)) == len(set(s2)) == len(set(zip(s1, s2)))
def interpreter(tape):\n    memory, ptr, output = {0: 0}, 0, ""\n    \n    for command in tape:\n        if   command == ">":  ptr += 1\n        elif command == "<":  ptr -= 1\n        elif command == "!":  memory[len(memory)] = 0\n        elif command == "*":  output += chr(memory.get(ptr, 0) % 256)    \n        elif ptr in memory:\n            if   command == "+":  memory[ptr] += 1\n            elif command == "-":  memory[ptr] -= 1\n            elif command == "/":  memory[ptr] = 0\n    \n    return output
from collections import Counter\n\ndef presentation_agenda(friend_list):\n    uniqueDest    = {d for d,c in Counter(d for p in friend_list for d in p['dest']).items() if c == 1}\n    pFilteredDest = tuple((p['person'], [d for d in p['dest'] if d in uniqueDest]) for p in friend_list)\n    return [{'person': name, 'dest': lst} for name,lst in pFilteredDest if lst]
from bisect import bisect_left\n\ndef sieve(n):\n    sieve, primes = [0]*(n+1), []\n    for i in range(2, n+1):\n        if not sieve[i]:\n            primes.append(i)\n            for j in range(i**2, n+1, i): sieve[j] = 1\n    return primes\n\nPRIMES = sieve(100000)\n\ndef prime_primes(n):\n    lst = PRIMES[:bisect_left(PRIMES, n)]\n    divs = [p/q for i,p in enumerate(lst) for q in lst[i+1:]]\n    return len(divs), int(sum(divs))
from collections import Counter\n\ndef is_zero_balanced(arr):\n    c = Counter(arr)\n    return bool(arr) and all(c[k] == c[-k] for k in c)
def socialist_distribution(population, minimum):\n    if minimum > sum(population)//len(population):\n        return []\n    while min(population) < minimum:\n        population[population.index(min(population))] += 1\n        population[population.index(max(population))] -= 1\n    return population\n
from collections import Counter\n\n\ndef is_dd(n):\n    return any(value==count for value, count in Counter(int(x) for x in str(n)).items())
def get_zodiac_sign(day, month):\n\n    signs = ["Aquarius", "Pisces", "Aries", "Taurus", "Gemini", "Cancer",\n             "Leo", "Virgo", "Libra", "Scorpio", "Sagittarius", "Capricorn"]\n\n    limits = [20, 19, 21, 20, 21, 21, 23, 23, 23, 23, 22, 22]\n\n    return signs[month - 1] if limits[month - 1] <= day else signs[(month + 10) % 12]
# RWH primes\nLIMIT = 500000\nsieve = [True] * (LIMIT//2)\nfor n in range(3, int(LIMIT**0.5) +1, 2):\n    if sieve[n//2]: sieve[n*n//2::n] = [False] * ((LIMIT-n*n-1)//2//n +1)\nPRIMES = [2] + [2*i+1 for i in range(1, LIMIT//2) if sieve[i]]\n\n\ndef prime_maxlength_chain(val_max):\n    if val_max < 5:\n        return []\n    \n    found = []\n    \n    # the sum of the first 400 primes > LIMIT\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    \n    for size in range(max_size, 1, -1):\n        # if sequence size is even, it *must* start with 2\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n    \n        # if sequence size is odd, it *cannot* start with 2\n        else:\n            for start in range(1, max_size-size +1):\n                n = sum(PRIMES[start:start+size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            \n            if found:\n                return found
import re\ndef validate_usr(un):\n    return re.match('^[a-z0-9_]{4,16}$', un) != None
def product(s):\n    return s.count("?")*s.count("!")
def distribution_of_candy(candies):\n    steps = 0\n    while len(set(candies)) > 1:\n        candies = [(a + 1) // 2 + (b + 1) // 2\n                   for a, b in zip(candies, candies[-1:] + candies)]\n        steps += 1\n    return [steps, candies.pop()]
def sum_of_regular_numbers(arr):\n    res, value, save = 0, arr[1] - arr[0], arr[:2]\n    for x,y in zip(arr[1:], arr[2:]):\n        if y-x == value:\n            save.append(y)\n        else:\n            if len(save) >= 3: res += sum(save)\n            value, save = y-x, [x, y]\n    if len(save) >= 3: res+= sum(save)\n    return res
def encode(str, key):\n    key = key.lower() + key.upper()\n    dict = { char: key[i-1] if i % 2 else key[i+1] for i, char in enumerate(key) }\n    return ''.join( dict.get(char, char) for char in str )\n\ndecode = encode
import numpy as np\n\ndef sort_two_arrays(arr1, arr2):\n    idx2 = np.argsort(arr2, kind='mergesort')\n    idx1 = np.argsort(arr1, kind='mergesort')\n    return [[arr1[i] for i in idx2], [arr2[i] for i in idx1]]
def rotate(arr, n):\n    # ...\n    n = n % len(arr)\n    return arr[-n:] + arr[:-n]
def array_mash(xs, ys):\n    return [z for p in zip(xs, ys) for z in p]
def arithmetic(a, b, operator):\n    return {\n        'add': a + b,\n        'subtract': a - b,\n        'multiply': a * b,\n        'divide': a / b,\n    }[operator]
def bingo(ticket, win):\n    return 'Winner!' if sum(chr(n) in s for s, n in ticket) >= win else 'Loser!'
def hamming_weight(x):return bin(x).count('1')
def shuffle_it(A,*T):\n    for x,y in T:\n        A[x],A[y]=A[y],A[x]\n    return A\n
def reverse_it(data):\n    if type(data) in [int, str, float]:\n        return type(data)(str(data)[::-1])\n    return data
def sflpf_data(val, nMax):\n    r=[]\n    for i in range(2,nMax):\n       fac=primef(i)\n       if len(fac)>1 and fac[0]+fac.pop()==val: r.append(i) \n    return r\n    \ndef primef(n):\n    i= 2; f= []\n    while i*i<=n:\n        if n%i: i+=1\n        else: n//=i; f.append(i)\n    if n>1: f.append(n)\n    return f
from operator import lt, gt\n\nmemo = {}\nis_bouncy = lambda s: memo[s] if s in memo else memo.setdefault(s, any(map(lt, s[:-1], s[1:])) and any(map(gt, s[:-1], s[1:])))\n\ndef bouncy_ratio(percent):\n    if not 0 < percent < 1: raise Exception("Wrong percentage: {}".format(percent))\n    x, y = 100, 0\n    while y < x*percent:\n        x, y = x+1, y+is_bouncy(str(x+1))\n    return x
def num_primorial(n):\n    primorial, x, n = 2, 3, n-1\n    while n:\n        if all(x % d for d in range(3, int(x ** .5) + 1, 2)):\n            primorial *= x\n            n -= 1\n        x += 2\n    return primorial
\n\nTOME = {'a':1, 'b':2, 'c':3, 'd':4, 'e':5, 'f':6, 'g':7, 'h':8, 'i':9, 'k':10, 'l':20, 'm':30, 'n':40, 'o':50, 'p':60, 'q':70, 'r':80, 's':90, 't':100, 'u':200, 'x':300, 'y':400, 'z':500, 'j':600, 'v':700, 'w':900}\n\ndef gematria(s): return sum(TOME.get(c,0) for c in s.lower())
def alan(arr):\n    s = {'Rejection', 'Disappointment', 'Backstabbing Central', 'Shattered Dreams Parkway'}\n    return "Smell my cheese you mother!" if s.issubset(arr) else "No, seriously, run. You will miss it."
def funnel_out(funnel):\n    r=""\n    h=len(funnel)\n    while funnel[h-1][0]!="~":\n      r+=funnel[h-1][0]\n      funnel[h-1][0]="~"\n      i=h-1\n      j=0\n      while i>0:\n        if funnel[i-1][j] < funnel[i-1][j+1]:\n          funnel[i][j]=funnel[i-1][j]\n          funnel[i-1][j]="~"\n        else:\n          funnel[i][j]=funnel[i-1][j+1]\n          funnel[i-1][j+1]="~"\n          j+=1\n        i-=1\n    print(funnel)\n    return r
get = dict(zip("ATCG", "TAGC")).__getitem__\n\ndef reverse_complement(dna):\n    try:\n        return ''.join(map(get, reversed(dna)))\n    except KeyError:\n        return "Invalid sequence"
def boredom(staff):\n    lookup = {\n        "accounts": 1,\n        "finance": 2,\n        "canteen": 10,\n        "regulation": 3, \n        "trading": 6,\n        "change": 6,\n        "IS": 8,\n        "retail": 5,\n        "cleaning": 4,\n        "pissing about": 25\n    }\n    n = sum(lookup[s] for s in staff.values())\n    if n <= 80:\n        return "kill me now"\n    if n < 100:\n        return "i can handle this"\n    return "party time!!"
def distribute(nodes, workload):\n    w = list(range(workload))[::-1]\n    return [[w.pop() for _ in range(workload // nodes + (workload % nodes > n))] for n in range(nodes)]
from heapq import *\n\ndef add_all(lst):\n\n    heapify(lst)\n    total = 0\n    while len(lst) > 1:\n        s = heappop(lst) + heappop(lst)\n        total += s\n        heappush(lst, s)\n\n    return total
def diff(a, b):\n    return sorted(set(a) ^ set(b))
def fixed_points_perms(n, k):\n    if k > n:\n        return 0\n    if k == n:\n        return 1\n    if k == 0:\n        subf = lambda n: 1 if n == 0 else n * subf(n - 1) + (-1)**n\n        return subf(n)\n    return fixed_points_perms(n-1, k-1) * n // k\n
def solve(arr):\n    arr = sorted(arr, reverse=True)\n    res = []\n    while len(arr):\n        res.append(arr.pop(0))\n        if len(arr):\n            res.append(arr.pop())\n    return res
def summy(string_of_ints):\n    return sum(map(int,string_of_ints.split()))
def aa_percentage(seq, residues=["A", "I", "L", "M", "F", "W", "Y", "V"]):\n  return round(sum(seq.count(r) for r in residues)/len(seq)*100)
def solve(a):\n    for i in a:\n        li = [i]\n        while 1:\n            if li[-1] % 3 == 0 and li[-1] // 3 in a : li.append(li[-1] // 3)\n            elif li[-1] * 2 in a : li.append(li[-1] * 2)\n            else : break\n        if len(li) == len(a) : return li
def square(number):\n    return 2**(number-1)
def button_sequences(seqR, seqB):\n    pattern, state = '', ''\n    toBool = lambda seq : [i == '1' for i in seq]\n    for red, blue in zip(toBool(seqR), toBool(seqB)):\n        if red and state == 'R' or blue and state == 'B':\n            continue\n        state = 'R' if red else 'B' if blue else ''\n        pattern += state\n    return pattern
def tops(msg):\n    n = len(msg)\n    res,i,j,k = "",2,2,7\n    while i < n:\n        res = msg[i:i+j] + res\n        i,j,k=i+k,j+1,k+4\n    return res
def divisible_count(x,y,k):\n    return y//k - (x-1)//k
def my_crib(n):\n    roof = "\n".join("%s/%s\\%s"%(" "*(n-i)," "*i*2," "*(n-i)) for i in range(n))\n    ceiling = "\n/%s\\\n"%("_"*(n*2))\n    walls = ("|%s|\n"%(" "*(n*2)))*(n-1)\n    floor = "|%s|"%("_"*(n*2))\n    \n    return roof + ceiling + walls + floor
from math import ceil\nfrom fractions import Fraction as F\ndef decompose(n):\n    f = F(n)\n    ff = int(f)\n    result = [str(ff)] if ff else []\n    f -= ff\n    while f>0:\n        x = F(1,int(ceil(f**-1)))\n        f -= x\n        result.append(str(x))\n    return result
def series_slices(digits, n):\n    if n > len(digits):\n        raise ValueError\n    else:\n        return [[int(digit) for digit in digits[i:i+n]] for i in range(0, len(digits)-n+1)]
from itertools import cycle\n\ndef swap(s,n):\n    b = cycle(bin(n)[2:])\n    return "".join(c.swapcase() if c.isalpha() and next(b) == '1' else c for c in s)
variance=lambda w:round(__import__('statistics').pvariance(map(len,w)),4)
from math import factorial as f\ncount_paths=lambda n,c:f(c[0]+abs(n-c[1]-1))//(f(abs(n-c[1]-1))*f(c[0])) if n!=1 else 0
def find_part_max_prod(n):\n  if n == 1: return [[1], 1]\n  q, r = divmod(n, 3)\n  if r == 0: return [[3]*q, 3**q]\n  if r == 1: return [[4] + [3]*(q - 1), [3]*(q - 1) + [2, 2], 3**(q - 1) * 2**2]\n  return [[3]*q + [2], 3**q * 2]
def xor(a,b):\n    return a != b
def four_piles(n,y):\n    x,r=divmod(n*y,(y+1)**2)\n    return [] if r or x==y else [x+y,x-y,x*y,x//y]\n
def cat_mouse(x):\n    return 'Escaped!' if x.count('.') > 3 else 'Caught!'
from math import sqrt\ndef is_prime(n):\n    if n < 2: return False\n    for x in range(2, int(sqrt(n)) + 1):\n        if n % x == 0: return False\n    return True\n\ndef all_dig_prime(n):\n    for d in str(n):\n        if d not in "2357": return False\n    return True\n\ndef not_primes(a, b):\n    res = []\n    for i in range(a,b):\n        if all_dig_prime(i) and not is_prime(i): res.append(i)\n    return res
def whitespace(string):\n    return not string or string.isspace()
import re\ndef mid_endian(n):\n    h= hex(n)[2:].upper()\n    r= re.findall('..','0'*(len(h)%2)+h)\n    return "".join(r[1::2][::-1]+r[0::2])
def find_mult10_SF(n):\n    n = 4*n - 1\n    \n    return (6 ** n + 3 * 2 ** n) / 4\n
from itertools import permutations\n\ndef sc_perm_comb(num):\n    sNum = str(num)\n    return sum({ int(''.join(p)) for d in range(1, len(sNum)+1) for p in permutations(sNum, d) })
def domino_reaction(s):\n    ds = ""\n    for (i,d) in enumerate(s):\n        if( d=="|" ): \n            ds += "/"\n        else:\n            return ds+s[i:]\n    return ds\n
def problem(a):\n    try:\n        return a * 50 + 6\n    except TypeError:\n        return "Error"
def solve(s):\n    return sum(i+1 for i,d in enumerate(list(s)) if d in '13579')
def totient(n):\n    if not isinstance(n,int) or n<1: return 0\n    \n    phi = n >= 1 and n\n    for p in range(2, int(n ** .5) + 1):\n        if not n % p:\n            phi -= phi // p\n            while not n % p:\n                n //= p\n    if n > 1: phi -= phi // n\n    return phi
def add_binary(a,b):\n    return bin(a+b)[2:]\n
def negation_value(s, x):\n    return len(s) % 2 ^ bool(x)
def sum_it_up(a):\n    return sum(int(*x) for x in a)
def filter_homogenous(arrays):\n    return[a for a in arrays if len(set(map(type,a)))==1]
TABLE = str.maketrans('0123456789','9876543210')\n\ndef code(*args):\n    return sum(map(lambda n:int(str(n).translate(TABLE)), args))
import re\n\ndef calculate_string(st): \n    st = re.sub(r'[^-+*/\d.]', '', st)\n    result = eval(st)\n    return str(int(round(result)))
import math\n\ndef factorial(n):\n    if n < 0:\n        return None\n    return math.factorial(n)
def convert_num(number, base):\n    try:\n        if base == 'hex':\n            return hex(number)\n        if base == 'bin':\n            return bin(number)\n    except:\n        return 'Invalid number input'\n    return 'Invalid base input'
def string_constructing(a, s):\n    if len(s) == 0:\n        return 0\n    i = -1\n    for j, c in enumerate(s):\n        i = a.find(c, i+1)\n        if i < 0 or i == len(a) - 1:\n            break\n    return len(a) - j + (i < 0) + string_constructing(a, s[j + (i >= 0):])
from collections import Counter\ndef letter_count(s):\n    return Counter(s)
def is_orthogonal(u, v): \n    return sum(i*j for i,j in zip(u,v)) == 0
def read_out(acrostic):\n    return "".join( word[0] for word in acrostic )
import re\ndef calculate(input):\n    try:\n        return eval(re.sub(r'(\d+)', lambda m: str(int(m.group(1))), input))\n    except:\n        return False
from fractions import gcd\nfrom functools import reduce\n\ndef mn_lcm(m, n):\n    return reduce(lambda x, y: (x * y) / gcd(x, y), list(range(min(m, n), max(m, n) + 1)))\n\n
def table_game(table):\n    (a, ab, b), (ac, abcd, bd), (c, cd, d) = table\n    if (a + b == ab) and (c + d == cd) and (a + c == ac) and (b + d == bd) and (a + b + c + d == abcd):\n        return [a, b, c, d]\n    return [-1]
def how_many_pizzas(n):\n    return 'pizzas: {}, slices: {}'.format(*divmod(n * n // 8, 8))
def solve(s, idx):\n    stack = []\n    for i, c in enumerate(s):\n        if c == '(': stack += [i]\n        if c == ')':\n            if not stack: break\n            if stack.pop() == idx: return i\n                \n    return -1
def half(i, n):\n    return "".join(str(d%10) for d in range(1, n-i+1))\n\ndef line(i, n):\n    h = half(i, n)\n    return " " * i + h + h[-2::-1]\n\ndef get_a_down_arrow_of(n):\n    return "\n".join(line(i, n) for i in range(n))\n
from statistics import median
def make_negative( number ):\n    return -abs(number)
def triple_shiftian(T,n):\n    for i in range(3,n+1):\n        T.append(4 * T[i-1] - 5 * T[i-2] + 3 * T[i-3])\n    return T[n]  
from re import findall; repeat_adjacent=lambda s: len(findall(r"((.)\2+(?!\2)){2,}",s))
from itertools import accumulate\ndef add(l):\n    return list(accumulate(l)) if isinstance(l, list) and all(isinstance(x, int) for x in l) \\n        else 'Invalid input'
def list_depth(l):\n    depths = [1]\n    for x in l:\n        if isinstance(x, list):\n            depths.append(list_depth(x) + 1)\n    return max(depths)
def tiy_fizz_buzz(s):\n    return "".join(("Iron "*c.isupper() + "Yard"*(c.lower() in "aeiou")).strip() or c for c in s)
def ranks(a):\n  sortA = sorted(a, reverse=True)\n  return [sortA.index(s) + 1 for s in a]\n
import re\n\ndef kooka_counter(laughing):\n    return len(re.findall(r'(ha)+|(Ha)+',laughing))
from functools import reduce\ndef lcm(*args):\n    return reduce(lcms, args) if args else 1\n\ndef gcd(a,b):\n    """Euclidean Algorithm"""\n    return b if a == 0 else gcd(b % a, a)\n    \ndef lcms(a, b):\n    return (a*b) // gcd(a,b)
def olympic_ring(string):\n    return (['Not even a medal!'] * 2 + ['Bronze!', 'Silver!', 'Gold!'])[min(4, sum(map("abdegopqABBDOPQR".count, string)) // 2)]
from math import ceil\n\ndef order(pizzas, salads, appetizers):\n    tp = 3 * pizzas / 2 + 10 * math.ceil(pizzas / 10)\n    ts = 3 * salads + 5 * appetizers\n    return max(tp, ts)\n
from itertools import count\n\ndef solve_for_x(equation):\n    return next( x for n in count(0) for x in [n, -n] if eval(equation.replace("x", str(x)).replace("=", "==")) )
import math\ndef heron(a,b,c):\n    s=(a+b+c)/2\n    return round(math.sqrt(s*(s-a)*(s-b)*(s - c)),2)
from math import ceil, sqrt\n\ndef layers(n):\n    return ceil(sqrt(n)) // 2 + 1
def sorter(textbooks):\n    return sorted(textbooks,key=str.lower)
def hex_to_dec(s):\n    return int(s, 16)
def simple_multiplication(number) :\n    return number * 9 if number % 2 else number * 8
def ulam_sequence(u, v, n):\n    lst, seq, ex, q = [], 1, 1, 1 << v | 1 << u  # Put u and v into queue\n    for _ in range(n):                           # Repeat n times\n        w = q & -q                               # Take the smallest candidate\n        l = w.bit_length() - 1                   # and its value\n        s = seq << l                             # Generate its sums with all previous values\n        seq |= w                                 # Append it afterwards to the sequence\n        lst.append(l)                            # and to the list\n        ex |= s & q                              # Update excluded values if any is already in queue\n        q |= s                                   # Put previous sums into queue\n        q &= ~ex                                 # Remove excluded values from queue\n    return lst                                   # Return sequence list
def xMasTree(n):\n   return [("#"*(x*2+1)).center(n*2-1, "_") for x in list(range(n))+[0]*2]
def getSlope(p1, p2):\n    return None if p1[0] == p2[0] else (p2[1] - p1[1])/(p2[0] - p1[0])\n
def find_deleted_number(arr, mixed_arr):\n    return sum(arr)-sum(mixed_arr)
import re\n\ndef encoder(s):\n    d, out, it = {},[], iter(s)\n    for c in it:\n        i,k = 0,c\n        while k in d: \n            i,c = d[k], next(it,'')\n            if not c: break\n            k += c\n        d[k] = len(d)+1\n        out.append(f'{i}{c}')\n    return ''.join(out)\n\n\ndef decoder(s):\n    d = ['']\n    for m in re.finditer(r'(\d+)(\D?)',s):\n        d.append( d[int(m[1])] + m[2] )\n    return ''.join(d)
def nth_chandos_number(n):\n    return int((bin(n)+"0")[2:], 5)
def unusual_sort(array):\n    return sorted(array, key=lambda x: (str(x).isdigit(), str(x), -isinstance(x, int)))
def covered_pawns(pawns):\n    pawns = set(pawns)\n    return len({p for p in pawns for x,y in [map(ord, p)] if {chr(x-1)+chr(y-1), chr(x+1)+chr(y-1)} & pawns})
def divisors(n):\n    return  len([l_div for l_div in range(1, n + 1) if n % l_div == 0]);
def starting_mark(height):\n    return round(9.45 + (10.67 - 9.45) / (1.83 - 1.52) * (height - 1.52), 2)
def hex_hash(code):\n    return sum(int(d) for c in code for d in hex(ord(c)) if d.isdigit())
def catch_sign_change(lst):\n    count = 0\n    for i in range(1,len(lst)):\n        if lst[i] < 0 and lst[i-1] >= 0:count += 1\n        if lst[i] >= 0 and lst[i-1] < 0:count += 1\n    return count
def average(array):\n    return round(sum(array) / len(array))
from functools import reduce\n\narray_change = lambda arr: reduce(lambda a, u: (max(a[0] + 1, u), a[1] + max(0, a[0] - u + 1)), arr, (-10001, 0))[1]
def hero(bullets, dragons):\n    return bullets >= dragons * 2
def shift_left(a, b):\n    r = len(a) + len(b)\n    for i in range(-1, -min(len(a), len(b)) - 1, -1):\n        if a[i] != b[i]:\n            break\n        r -= 2\n    return r
def sort_array(arr):\n  odds = sorted((x for x in arr if x%2 != 0), reverse=True)\n  return [x if x%2==0 else odds.pop() for x in arr]
def pythagorean_triplet(n):\n    for a in range(3, n):\n        for b in range(a+1, n):\n            c = (a*a + b*b)**0.5\n            if a*b*c > n:\n                break\n            if c == int(c) and a*b*c == n:\n                return [a, b, c]
def describeList(lst):\n    return ["empty","singleton","longer"][min(len(lst),2)]
def count_zeros_n_double_fact(n): \n    if n % 2 != 0:\n        return 0\n    k = 0\n    while n >= 10:\n        k += n // 10\n        n //= 5\n    return k
def capitalize(s):\n    s = ''.join(c if i%2 else c.upper() for i,c in enumerate(s))\n    return [s, s.swapcase()]
def square_sums_row(n):\n\n    def dfs():\n        if not inp: yield res\n        for v in tuple(inp):\n            if not res or not ((res[-1]+v)**.5 % 1):\n                res.append(v)\n                inp.discard(v)\n                yield from dfs()\n                inp.add(res.pop())\n\n    inp, res = set(range(1,n+1)), []\n    return next(dfs(), False)
def is_madhav_array(arr):\n    nTerms = ((1+8*len(arr))**.5-1)/2\n    return (len(arr) > 1 and not nTerms%1 and\n            len({ sum(arr[int(i*(i+1)//2):int(i*(i+1)//2)+i+1]) for i in range(int(nTerms))}) == 1)
def arithmetic_sequence_elements(a, r, n):\n    return ', '.join(str(a + b * r) for b in range(n))\n
import re, random\n\ndef roll(desc, verbose=False):\n    if not isinstance(desc,str): return False\n    \n    ans = re.findall(r'^(\d*)d(\d+)(([+\-]\d+)*)$', desc.replace(' ',''))\n    \n    if len(ans) == 0: return False\n    \n    dct = {i: eval(v) for i,v in enumerate(ans[0]) if v}\n    dices = {'dice':     [ 1+random.randrange(dct[1]) for i in range(dct.get(0, 1)) ],\n             'modifier': dct.get(2, 0) }\n    \n    return dices if verbose else sum(dices['dice']) + dices['modifier']
def find_missing_numbers(arr):\n    if not arr:\n        return []\n    return sorted(set(range(arr[0] + 1, arr[-1])).difference(arr))\n
minimum = min\nmaximum = max
def calc(a):\n    return sum( x**(1 + (x>=0)) * (1 + 2*(not i%3)) * (-1)**(not i%5) for i,x in enumerate(a,1))
def sim(k,n,p):\n    r = [(k,k,0),(k,p,p)]\n    for i in range(n-2):\n        u,d = r[0][1]+r[1][1],r[1][1]\n        r = [r[1],(r[1][0]+u-d,u,d)]\n    return r[1][0]\n\ndef calc(k,n,m,x):\n    z,o = sim(k,n-1,0), sim(k,n-1,1)\n    return sim(k,x,(m-z)//(o-z))
from math import ceil\n\ndef branch(n):\n    if n == 1:\n        return 0\n    l = int(ceil(n ** 0.5)) // 2\n    n -= (2 * l - 1) ** 2 + 1\n    return n // (2*l or 1)
def sort_time(arr):\n    arr, s = sorted(arr, key=lambda t: t[0]), []\n    while arr:\n        nextTP = next((i for i,t in enumerate(arr) if not s or t[0] >= s[-1][1]), 0)\n        s.append(arr.pop(nextTP))\n    return s
def vector_affinity(a, b):\n  longer = len(a) if len(a) > len(b) else len(b)\n  return len([i for i, j in zip(a, b) if i == j]) / float(longer) if longer > 0 else 1.0
from collections import Counter\n\ndef modes(data):\n    cnts = Counter(data)\n    mx, mn = max(cnts.values()), min(cnts.values())\n    return sorted([k for k in cnts if cnts[k] == mx and cnts[k] != mn])
def chess_board(rows, columns):\n    return [["OX"[(row+col)%2] for col in range(columns)] for row in range(rows)]
def oddest(numbers):\n    most_odd   = 0      # The current most odd number in the list\n    max_oddity = -1     # The current greatest oddity rate, starts at -1 so that even an even number can be the unique most odd\n    is_unique  = True   # If the current most odd number is really the most, so if there is no unique oddest number, it will return None\n    for num in numbers:  # Loop through all the numbers\n        oddity  = 0      # The oddity rate starts at 0\n        print(num)\n        insider = num    # The coefficient of the number 2, so in 2n + 1, the insider is n\n        while insider % 2 == 1:  # While that coefficient is odd\n            if insider == -1:\n                oddity = 1 + max([abs(n) for n in numbers]) # Since the oddity rate of a number is NEVER greater than the absolute value of the number, this garantees that the current number is the most odd one\n                break\n            else:\n                oddity  += 1               # Add the oddity rate of the total number\n                insider = (insider-1)/2    # So if in 2n + 1, n is odd, represent it as 2(2m + 1) + 1, and set the value to m\n        if oddity > max_oddity:  # If the current number's oddity rate is greater than the current max oddity,\n            is_unique = True     # Set it to unique\n            max_oddity = oddity  # Set the max oddity to the current oddity\n            most_odd   = num     # Set the most odd number to the current number\n        elif oddity == max_oddity:# Otherwise, if it's the same rate\n            is_unique = False    # It's not unique\n    if is_unique and max_oddity >= 0:  # If the current most odd number is REALLY the most odd number and the list isn't empty\n        return most_odd # Return it\n    return None # Otherwise, return None
#from string import ascii_lowercase as LOWER\nLOWER = "abcdefghijklmnopqrstuvwxyz"\n\ndef encode(message, key, shift, encode=True):\n    key = sorted(LOWER, key=f"{key}{LOWER}".index)\n    result = []\n    for char in message:\n        if char in key:\n            i = key.index(char)\n            char = key[(i + shift) % 26]\n            shift = i + 1 if encode else -(key.index(char) + 1)\n        result.append(char)\n    return "".join(result)\n    \ndef decode(message, key, shift): \n    return encode(message, key, -shift, encode=False)
def palindrome(n):\n    s = str(n)\n    return s[::-1] == s\n\ndef next_pal(val):\n    val += 1\n    while not palindrome(val):\n        val += 1\n    return val
from re import compile, match\n\nREGEX = compile(r'((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.){4}$')\n\n\ndef ipv4_address(address):\n    # refactored thanks to @leonoverweel on CodeWars\n    return bool(match(REGEX, address + '.'))\n
def six_column_encryption(msg):\n    msg=msg.replace(' ','.')+'.'*((6-len(msg)%6)%6)\n    return ' '.join(msg[n::6] for n in range(6))
def expanded_form(num):\n    num = list(str(num))\n    return ' + '.join(x + '0' * (len(num) - y - 1) for y,x in enumerate(num) if x != '0')
def count_letters_and_digits(s):\n    return isinstance(s, str) and sum(map(str.isalnum, s))
def bool_to_word(bool):\n    return "Yes" if bool else "No"
from functools import reduce\nfrom math import factorial\n\n\ndef value_at(poly, x):\n    return round(sum(n * aCb(x, i) for i, n in enumerate(poly[::-1])), 2)\n\ndef aCb(a, b):\n    return reduce(lambda x, y: x * y, (a - i for i in range(b)), 1) / factorial(b)\n
def camel_case(string):\n    return string.title().replace(" ", "")
def isPrime(n):\n    return n==2 or n>2 and n&1 and all(n%p for p in range(3,int(n**.5+1),2))\n\ndef prime_product(n):\n    return next( (x*(n-x) for x in range(n>>1,1,-1) if isPrime(x) and isPrime(n-x)), 0)
def sortme(words):\n    return sorted(words, key=str.lower)
import math\ndef goldbach_partitions(n):\n    def is_prime(x):\n        for i in range(2, int(math.sqrt(x))+1):\n            if x % i == 0:\n                return False\n        return True\n\n    if n % 2: return []\n\n    ret = []\n    for first in range(2, n//2 + 1):\n        if is_prime(first):\n            second = n - first\n            if is_prime(second):\n                ret.append('%d+%d' %(first, second))\n    return ret
from decimal import Decimal, ROUND_HALF_UP\n\ndef round_to_five(numbers):\n    return [(n/5).quantize(1, ROUND_HALF_UP) * 5 for n in map(Decimal, numbers)]
import re\n\ndef word_mesh(arr):\n    common = re.findall(r'(.+) (?=\1)',' '.join(arr))\n    return ''.join(common) if len(common) + 1 == len(arr) else 'failed to mesh'
from operator import mul\nfrom functools import reduce\n\ndef product_array(numbers):\n    tot = reduce(mul,numbers)\n    return [tot//n for n in numbers]
def roundRobin(jobs, slice, index):\n    total_cc = 0\n    while True:\n        for idx in range(len(jobs)):\n            cc = min(jobs[idx], slice)\n            jobs[idx] -= cc\n            total_cc += cc\n            if idx == index and jobs[idx] == 0:\n                return total_cc
from collections import Counter\n\ndef strange_coach(players):\n    return ''.join(\n                  sorted(i for i,j in\n                          Counter(map(lambda x: x[0], players)).most_common()\n                              if j >= 5)) or 'forfeit'
def pattern(n):\n    return '\n'.join(''.join(str((x+y)%n+1) for y in range(n)) for x in range(n))
def calculator(x, y, op):\n  return eval(f'{x}{op}{y}') if type(x) == type(y) == int and str(op) in '+-*/' else 'unknown value'
def arbitrate(s, n):\n    i = s.find('1') + 1\n    return s[:i] + '0' * (n - i)
from collections import Counter\nfrom itertools import chain\n\n\ndef highest_age(persons1, persons2):\n    c = Counter()\n\n    for p in chain(persons1, persons2):\n        c[p['name']] += p['age']\n\n    return min(iter(c.items()), key=lambda n_a: (-n_a[1], n_a[0]))[0] if c else None\n
def getAllPrimeFactors(n):\n    if n == 0: return []\n    elif n == 1: return [1]\n    elif type(n) != int: return errora\n    elif n < 0: return errora\n    allfacts = []\n    current = 2\n    n_copy = n\n    while current <= n:\n        if n_copy % current == 0:\n            allfacts.append(current)\n            n_copy /= current\n        else:\n            current += 1\n    return allfacts\n    \n    \ndef getUniquePrimeFactorsWithCount(n):\n    if type(n) != int: return errorb\n    elif n < 0: return errorb\n    primes = []\n    power = []\n    listA = getAllPrimeFactors(n)\n    for i in range(len(listA)):\n        if listA[i] not in primes:\n            primes.append(listA[i])\n            power.append(1)\n        else:\n            power[-1] += 1\n    return [primes, power]\n\ndef getUniquePrimeFactorsWithProducts(n):\n    if type(n) != int: return errorc\n    elif n < 0: return errorc\n    listlist = getUniquePrimeFactorsWithCount(n)\n    listc = []\n    for i in range(len(listlist[0])):\n        listc.append(listlist[0][i] ** listlist[1][i])\n    return listc\n\nerrora = []\nerrorb = [[], []]\nerrorc = []
from math import factorial\nfrom string import digits, ascii_uppercase\n\nDIGITS = digits + ascii_uppercase\nFACTORIALS = [1, 1]\n\nf = 1\nfor i in range(2, 36):\n    f *= i\n    FACTORIALS.append(f)\n\ndef dec2FactString(nb):\n    ret = []\n    for f in reversed(FACTORIALS):\n        (d, nb) = divmod(nb, f)\n        if d or ret:\n            ret.append(DIGITS[d])\n    return ''.join(ret)\n\ndef factString2Dec(string):\n    return sum(DIGITS.index(d) * f for (d, f) in zip(reversed(string), FACTORIALS))\n
def name_file(fmt, nbr, start):\n    try:\n        return [fmt.replace('<index_no>', '{0}').format(i)\n            for i in range(start, start + nbr)]\n    except TypeError:\n        return []
from collections import deque\nimport re\n\nTOKENIZER = re.compile(r'(R+|F+|L+)(\d*)')\n\ndef execute(code):\n    \n    pos, dirs = (0,0), deque([(0,1), (1,0), (0,-1), (-1,0)])\n    seens = {pos}\n    \n    for act,n in TOKENIZER.findall(code):\n        s,r = act[0], int(n or '1') + len(act)-1\n        \n        if s == 'F':\n            for _ in range(r):\n                pos = tuple( z+dz for z,dz in zip(pos, dirs[0]) )\n                seens.add(pos)\n        else:\n            dirs.rotate( (r%4) * (-1)**(s == 'R') )\n    \n    miX, maX = min(x for x,y in seens), max(x for x,y in seens)\n    miY, maY = min(y for x,y in seens), max(y for x,y in seens)\n    \n    return '\r\n'.join( ''.join('*' if (x,y) in seens else ' ' for y in range(miY, maY+1)) \n                        for x in range(miX, maX+1) )
def to_1D(x, y, size):\n    return y * size[0] + x    \n    \ndef to_2D(n, size):\n    return (n % size[0], n // size[0])
import re\nyes = "In with a chance"\nno = "Plenty more fish in the sea"\ndef validate_number(string):\n  return yes if re.match(r'^(\+44|0)7[\d]{9}$',re.sub('-','',string)) else no
import re\n\n\ndef translate_with_frame(dna, frames=[1, 2, 3, -1, -2, -3]):\n    AAs = 'FFLLSSSSYY**CC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG'\n    Base1 = 'TTTTTTTTTTTTTTTTCCCCCCCCCCCCCCCCAAAAAAAAAAAAAAAAGGGGGGGGGGGGGGGG'\n    Base2 = 'TTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGG'\n    Base3 = 'TCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAG'\n    trans = {'A': 'T', 'G': 'C', 'T': 'A', 'C': 'G'}\n    intab = "AGTC"\n    outtab = "TCAG"\n    map = dict()\n    for i, c in enumerate(AAs):\n        code = Base1[i]+Base2[i]+Base3[i]\n        map[code] = c\n    res = []\n    for i in frames:\n        trantab = dna.maketrans(intab, outtab)\n        DNA = dna if i > 0 else dna[::-1].translate(trantab)\n        res.append(''.join(map[x]\n                           for x in re.findall(r'.{3}', DNA[abs(i)-1:])))\n    return res\n
def isValid(formula):\n  return not ( \\n    (    1 in formula and     2 in formula) or \\n    (    3 in formula and     4 in formula) or \\n    (    5 in formula and not 6 in formula) or \\n    (not 5 in formula and     6 in formula) or \\n    (not 7 in formula and not 8 in formula))
# This is the Miller-Rabin test for primes, which works for super large n\n\nimport random\n\ndef even_odd(n):\n    s, d = 0, n\n    while d % 2 == 0:\n          s += 1\n          d >>= 1\n    return s, d\n\ndef Miller_Rabin(a, p):\n    s, d = even_odd(p-1)\n    a = pow(a, d, p)\n    if a == 1: return True\n    for i in range(s):\n        if a == p-1: return True\n        a = pow(a, 2, p)\n    return False\n\ndef is_prime(p):\n    if p == 2: return True\n    if p <= 1 or p % 2 == 0: return False\n    return all(Miller_Rabin(random.randint(2,p-1),p) for _ in range(40))\n
def digits(n):\n    return len(str(n))
def segment_cover(A, L):\n  n=1\n  s=min(A)\n  for i in sorted(A):\n      if s+L<i:\n          s=i\n          n+=1\n  return n
from string import ascii_uppercase\n\nvalues = {x: i for i, x in enumerate(ascii_uppercase, 1)}\n\ndef quicksum(packet):\n    return sum(values.get(c, 0) * i for i, c in enumerate(packet, 1)) * all(c.isspace() or c.isupper() for c in packet)
def find_smallest_int(arr):\n    return min(arr);
def past(h, m, s):\n    return (3600*h + 60*m + s) * 1000
def example_sort(arr, example_arr):\n    return sorted(arr, key=example_arr.index)
def prod_int_partII(n, s, min_=2):\n    total, fac = 0, []\n    for d in range(min_, int(n ** .5) + 1):\n        if not n % d:\n            count, l, sub = prod_int_partII(n // d, s-1, d)\n            if l == 1: sub = [sub]\n            total += count + 1\n            fac.extend([d] + x for x in sub)\n    if s == 1: fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]
def check_three_and_two(array):\n    return { array.count(x) for x in set(array) } == {2, 3}
def frame(text, char):\n    text_lens = [len(x) for x in text]\n    longest_len = max(text_lens)\n    frame_list = [char*(longest_len + 4)]\n    for str in text:\n         frame_list.append("{} {}{} {}".format(char, str, " " * (longest_len - len(str)), char)) \n    frame_list.append(char*(longest_len + 4))\n    return "\n".join(frame_list)
def extract(arr): return ''.join(arr[:2]+arr[-2:])\n\ndef sort_transform(arr):\n    arr = list(map(chr,arr))\n    w1  = extract(arr)\n    arr.sort()\n    w2  = extract(arr)\n    return f'{w1}-{w2}-{w2[::-1]}-{w2}'
def generate_diagonal(d, l):\n    result = [1] if l else []\n    for k in range(1, l):\n        result.append(result[-1] * (d+k) // k)\n    return result
import re\n\nPATTERNS = [re.compile(r'(?i)ci|ce|c(?!h)'),\n            re.compile(r'(?i)ph'),\n            re.compile(r'(?i)(?<!\b[a-z]{1})(?<!\b[a-z]{2})e\b|([a-z])\1'),\n            re.compile(r'(?i)th|w[rh]?'),\n            re.compile(r'(?i)ou|an|ing\b|\bsm')]\n            \nCHANGES  = {"ci": "si", "ce": "se", "c":"k",                     # Week 1\n            "ph": "f",                                           # Week 2\n            "th": "z",  "wr": "r",  "wh":  "v",   "w": "v",      # Week 4\n            "ou": "u",  "an": "un", "ing": "ink", "sm": "schm"}  # Week 5\n\ndef change(m):\n    tok = m.group(0)\n    rep = CHANGES.get( tok.lower(), "" if None in m.groups() else m.group()[0] )        # default value used for week 3 only\n    if tok[0].isupper(): rep = rep.title()\n    return rep\n        \ndef siegfried(week, txt):\n    for n in range(week):\n        txt = PATTERNS[n].sub(change, txt)\n    return txt
def obfuscate(email):\n    return email.replace("@", " [at] ").replace(".", " [dot] ")\n
def p_num(n):\n    r = (1 + (24*n+1)**.5) / 6\n    return r.is_integer() and (3*(r**2) - r) / 2 == n \n    \ndef g_p_num(n):\n    r = ((1 + 24 * n) ** .5) % 6\n    return r != 0 and r.is_integer()\n\ns_p_num=lambda n:(n**.5).is_integer() and p_num(n) and g_p_num(n)
def score_throws(radiuses):\n    score = 0\n    for r in radiuses:\n        if r < 5:\n            score += 10\n        elif 5 <= r <= 10:\n            score += 5\n    if radiuses and max(radiuses) < 5:\n        score += 100\n    return score
from operator import mul\nfrom functools import reduce\n\ndef solve(arr):\n    return reduce(mul, map(len, map(set, arr)), 1)
def moment_of_time_in_space(moment):\n    d = sum(int(c) if c in '123456789' else -1 for c in moment)\n    return [d < 0, d == 0, d > 0]
import re\ndef slogans(p,r):\n  reg=re.compile("|".join([p[i:] for i in range(len(p))]))\n  return len(re.findall(reg,r))
def triangle_type(a, b, c):\n  x,y,z = sorted([a,b,c])\n  if z >= x + y: return 0\n  if z*z == x*x + y*y: return 2\n  return 1 if z*z < x*x + y*y else 3
def nth_smallest(arr, n):\n    s = set(arr)\n    return sorted(s)[n-1] if n<=len(s) else None
def combat(health, damage):\n    return max(0, health-damage)
from itertools import zip_longest\n\ndef or_arrays(a1, a2, d=0):\n    return [x|y for x,y in zip_longest(a1, a2, fillvalue=d)]
def find_the_ball(start, swaps):\n    pos = start\n    for (a, b) in swaps:\n        if a == pos:\n            pos = b\n        elif b == pos:\n            pos = a\n    return pos\n
from collections import defaultdict\n\ndef cards_and_pero(s):\n    deck = defaultdict(set)\n    for n in range(0,len(s),3):\n        card = s[n:n+3]\n        if card[1:] in deck[card[0]]: return [-1,-1,-1,-1]\n        deck[card[0]] |= {card[1:]}\n    return [ 13 - len(deck[suit]) for suit in "PKHT"]
def baubles_on_tree(baubles, branches):\n    if not branches: return "Grandma, we will have to buy a Christmas tree first!"\n    d,r=divmod(baubles,branches)\n    return [d+1]*r+[d]*(branches-r)
import re\n\ndef spreadsheet(s):\n    nums = re.findall(r'(\d+)', s)\n    if len(nums) == 2:\n        n, cStr = int(nums[1]), ''\n        while n:\n            n, r = divmod(n-1, 26)\n            cStr += chr(r + 65)\n        return "{}{}".format(cStr[::-1], nums[0])\n    else:\n        return "R{}C{}".format(nums[0], sum( 26**i * (ord(c)-64) for i,c in enumerate(re.sub(r'\d', '', s)[::-1])))
def words_to_marks(s):\n  return sum(ord(c)-96 for c in s)
def hoop_count(n):\n    return "Keep at it until you get it" if n <10 else "Great, now move on to tricks"
from collections import defaultdict\ndef update_inventory(cur_stock, new_stock):\n    answer = defaultdict(int)\n    for stock, item in cur_stock + new_stock:\n        answer[item] += stock\n    return [(answer[item], item) for item in sorted(answer)]
# precalculate results\nresults = {}\nn, digits = 1, 0\nwhile digits <= 1000:\n    digits = len(str(sum( x**(n-x+1) for x in range(1, n) )))\n    if digits not in results:\n        results[digits] = n\n    n += 1\n\n\ndef min_length_num(digits, max_num): \n    n = results.get(digits, 0)\n    return [True, n+1] if n and n < max_num else [False, -1]
def histogram(lst, w):\n    lst = [n // w for n in lst]\n    m = max(lst, default=-1) + 1\n    return [lst.count(n) for n in range(m)]
def black_and_white(height, width, compressed):\n    res, left, i, color = [], 0, 0, 0\n    for h in range(height):\n        tot, tmp = 0, []\n        if color == 1: tmp.append(0)\n        while tot < width and i < len(compressed):\n            if left:\n                if left <= width:\n                    tmp.append(left)\n                    tot, left, color = left, 0, 1-color\n                else:\n                    tmp.append(width)\n                    tot, left = width, left-width\n            else:\n                i, val = i+1, compressed[i]\n                if tot + val <= width:\n                    tmp.append(val)\n                    tot, color = tot+val, 1-color\n                else:\n                    tmp.append(width-tot)\n                    tot, left = width, tot+val-width\n        if len(tmp)%2: tmp.append(left if h == height-1 else 0)\n        res.append(tmp)\n    return res
def smaller(arr):\n    # Good Luck!\n    return [len([a for a in arr[i:] if a < arr[i]]) for i in range(0, len(arr))]\n
def knight_or_knave(said):\n    return "Knight!" if eval(str(said)) else "Knave! Do not trust."
def charCheck(text, mx, spaces):\n    text = text if spaces else text.replace(' ', '')\n    return [len(text) <= mx, text[:mx]]
from itertools import islice\nfrom functools import reduce\n\ndef greatest_product(n):\n    numbers=[int(value) for value in n]\n    result=[reduce(lambda x,y: x*y, islice(numbers, i, i+5), 1) for i in range(len(numbers)-4)]\n    return max(result) \n
def largest_sum(s):\n    return max(sum(map(int,x)) for x in s.split('0'))
def nerdify(txt):\n    return txt.translate(str.maketrans("aAeEl", "44331"))
from math import ceil, pi\n\ndef does_fred_need_houseboat(x, y):\n    return ceil(pi * (x**2 + y**2) / 100)
def get_military_time(time):\n    if time[-2:] == 'AM':\n        hour = '00' if time[0:2] == '12' else time[0:2]\n    else:\n        hour = '12' if time[0:2] == '12' else str(int(time[0:2])+12)\n    return hour + time[2:-2]
from fractions import gcd\n\ndef coprimes(n):\n  return [i for i in range(1,n+1) if gcd(n,i)==1]
from string import ascii_lowercase as al\n\ntbl = str.maketrans(al, al[10:] + al[:10])\ndef move_ten(st):\n    return st.translate(tbl)
def split_without_loss(s, split_p):\n    return [i for i in s.replace(split_p.replace('|', ''), split_p).split('|') if i]
def get_mixed_num(fraction):\n    n, d = [int(i) for i in fraction.split('/')]\n    return '{} {}/{}'.format(n // d, n % d, d)
def smash(words):\n    return " ".join(words)
def checkered_board(n):\n    return isinstance(n,int) and n>1 and \\n           '\n'.join(' '.join( "" if (x+y)%2 ^ n%2 else "" for y in range(n) ) for x in range(n))\n
animals = ['Rat', 'Ox', 'Tiger', 'Rabbit', 'Dragon', 'Snake', 'Horse', 'Goat', 'Monkey', 'Rooster', 'Dog', 'Pig']\nelements = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']\ndef chinese_zodiac(year):\n    year -= 1984\n    return elements[year//2 % 5] + " " + animals[year % 12]
from itertools import count\ndef pair_zeros(arr, *args):\n    c = count(1)\n    return [elem for elem in arr if elem != 0 or next(c) % 2]
def deep_count(a):\n    result = 0\n    for i in range(len(a)):\n        if type(a[i]) is list:\n            result += deep_count(a[i])\n        result += 1\n    return result\n
def find_spec_partition(n, k, com):\n    x,r = divmod(n,k)\n    return {'max': [x+1]*r + [x]*(k-r),\n            'min': [n+1-k] + [1]*(k-1)}[com]
import re\ndef filter_words(phrase):\n    return re.sub("(bad|mean|ugly|horrible|hideous)","awesome",\n        phrase,flags=re.IGNORECASE)
import math\n\ndef cycle(n) :\n    if n % 2 == 0 or n % 5 ==0:\n        return -1\n    k = 1\n    while pow(10,k,n) != 1:\n        k += 1\n    return k\n            \n    \n       \n
import math\n\ndef missing_angle(h, a, o):\n    if h == 0:\n        radians = math.atan(o/a)\n    elif a == 0:\n        radians = math.asin(o/h)\n    else:\n        radians = math.acos(a/h)\n    return round(math.degrees(radians))
calculate_time=lambda b,c: round(b/float(c)*1.3+0.0001,2)\n    \n
def build_square(blocks):\n    for x in range(4):\n        if 4 in blocks:\n            blocks.remove(4)\n        elif 3 in blocks and 1 in blocks:\n            blocks.remove(3)\n            blocks.remove(1)\n        elif blocks.count(2) >= 2:\n            blocks.remove(2)\n            blocks.remove(2)\n        elif 2 in blocks and blocks.count(1) >= 2:\n            blocks.remove(2)\n            blocks.remove(1)\n            blocks.remove(1)\n        elif blocks.count(1) >= 4:\n            blocks.remove(1)\n            blocks.remove(1)\n            blocks.remove(1)\n            blocks.remove(1)\n        else:\n            return False\n    return True
def chain_arith_deriv(n, k):\n    if len(prime_factors(n)) < 2:\n        return "{} is a prime number".format(n)\n    chain = [n]\n    while k > 1:\n        k, n = k-1, arith_deriv(n)\n        chain.append(n)\n    return chain\n\n\ndef arith_deriv(n):\n    factors = prime_factors(n)\n    return sum(n * factors.count(factor) // factor for factor in set(factors)) or 1\n\n\ndef prime_factors(n):\n    if n < 2:\n        return []\n    factors = []\n    for k in (2, 3):\n        while n % k == 0:\n            n //= k\n            factors.append(k)\n    k = 5\n    step = 2\n    while k * k <= n:\n        if n % k:\n            k += step\n            step = 6 - step\n        else:\n            n //= k\n            factors.append(k)\n    if n > 1:\n        factors.append(n)\n    return factors
def angle(n):\n    return 180 * (n - 2)
def all_permuted(n):\n    a,b = 0, 1\n    for i in range(1,n): a,b = b, (i+1)*(a+b)\n    return a
def longest(a1, a2):\n    return "".join(sorted(set(a1 + a2)))
def palin(length, pos):\n    left = str(10**((length-1) // 2) + (pos - 1))\n    right = left[::-1][length%2:]\n    return int(left + right)
from bisect import bisect_left\nfrom collections import deque\n\n\ndef find_discounted(prices: str) -> str:\n    all_prices = deque(list(map(int, prices.split())))\n    discounts = []\n\n    while all_prices:\n        d = all_prices.popleft()\n        discounts.append(d)\n        del all_prices[bisect_left(all_prices, d * 4 // 3)]\n\n    return ' '.join(map(str, discounts))\n
def factors(x):\n    if not isinstance(x, int) or x < 1:\n        return -1\n    return [i for i in range(x, 0, -1) if x % i == 0]\n
def reverse(lst):\n    ret = []\n    while lst:\n        ret.append(lst[-1])\n        lst = [a-b for a,b in zip(lst, lst[1:])]\n    return ret[::-1]
levels = [0, 1, 2, 3]\nbuttons = ['0', '1', '2', '3']\ndef goto(level,button):\n    if level not in levels or button not in buttons:\n        return 0\n    else:\n        return int(button) - level
def score_test(tests, right, omit, wrong):\n    points = (right, omit, -wrong)\n    return sum(points[test] for test in tests)\n
def largest_power(n):\n    print(n)\n    if n <= 4:\n        if n == 1:\n            return (0, -1)\n        return (1, -1)\n    \n    #num_of_occurances\n    freq = 0\n    x = []\n    largest = 0\n    j = 0\n    while 2**largest < n:\n        largest += 1\n    largest -= 1\n    for i in range(2, largest + 1):\n        while j ** i < n:\n            j += 1\n        j -= 1\n        x.append(j**i)\n        j = 0\n    \n    return (max(x), x.count(max(x)))
from itertools import permutations\n\ndef get_words(letters):\n    word = "".join(qty * char for qty in letters for chars in letters[qty] for char in chars)\n    return sorted({"".join(permutation) for permutation in permutations(word)})
def word_wrap(s, limit):\n    s, i, li = s.split(), 0, []\n    while i < len(s):\n        t = s[i]\n        if len(t) <= limit:\n            while i + 1 < len(s) and len(t) + len(s[i + 1]) + 1 <= limit:\n                t += ' ' + s[i + 1] ; i += 1\n            if len(t) < limit:\n                if i + 1 < len(s) and len(s[i + 1]) > limit:\n                    temp = ' ' + s[i + 1][:limit - len(t) - 1]\n                    t += temp\n                    s[i + 1] = s[i + 1][len(temp) - 1:]\n            i += 1\n            li.append(t)\n        else:\n            li.append(s[i][:limit])\n            s[i] = s[i][limit:]\n    return '\n'.join(li)
region = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,:;-?! '()$%&" + '"'\n\ndef decrypt(encrypted_text):\n    if not encrypted_text: return encrypted_text\n    \n    letters = list(encrypted_text)\n    letters[0] = region[-(region.index(letters[0]) + 1)]\n    for i in range(1, len(letters)):\n        letters[i] = region[region.index(letters[i - 1]) - region.index(letters[i])]\n    \n    for i in range(1, len(letters), 2):\n        letters[i] = letters[i].swapcase()\n\n    return "".join(letters)\n    \n\n\ndef encrypt(text):\n    if not text: return text\n    \n    letters = list(text)\n    for i in range(1, len(letters), 2):\n        letters[i] = text[i].swapcase()\n        \n    swapped = letters[:]\n    for i in range(1, len(letters)):\n        letters[i] = region[region.index(swapped[i - 1]) - region.index(swapped[i])]\n        \n    letters[0] = region[-(region.index(swapped[0]) + 1)]\n    return "".join(letters)\n
import numpy\n\ndef poly_from_roots(r): return list(reversed(numpy.poly(tuple(r)))) if len(r)>0 else [1]
from functools import reduce\nfrom operator import mul\n\n\ndef product(numbers):\n    return reduce(mul, numbers) if numbers else None
def f(k,n):\n    a = []\n    for i in range(0,n+1):\n        if i < k:\n            a += [i+1]\n        else:\n            a += [a[-1] + a[i//k]]\n    return a[-1]\n        \n
def cycle(sequence):\n    for j, x in enumerate(sequence):\n        i = sequence.index(x)\n        if 0 <= i < j:\n            return [i, j - i]\n    return []\n
from datetime import datetime\nfrom itertools import permutations\n\ndef unique_date(*args):\n    dates = set()\n    for p in permutations(args):\n        try:\n            date = '{:02}/{:02}/{:02}'.format(*p)\n            datetime.strptime(date, '%y/%m/%d')\n            dates.add(date)\n        except ValueError: pass\n    return dates.pop() if len(dates) == 1 else "ambiguous" if dates else "invalid"
spacify = " ".join
def close_to_zero(t):\n    if len(t)==0:\n        return (0)\n    x=t.split(" ")\n    l=[]\n    poz=[]\n    neg=[]\n    for i in x:\n        l.append(int(i))\n    for i in l:\n        if i == 0:\n            return (0)\n        if i>0:\n            poz.append(i)\n        if i<0:\n            neg.append(i)\n        \n    if 0-min(poz)==max(neg):\n        return min(poz)\n    if 0-min(poz)>max(neg):\n        return min(poz)\n    else: return max(neg)\n
def interest(principal, interest, periods):\n    return [round(principal * (1 + interest * periods)),\n            round(principal * (1 + interest) ** periods)]
from ipaddress import ip_address\n\ndef ips_between(start, end):\n    return int(ip_address(end)) - int(ip_address(start))
from itertools import cycle\n\ndef numeric_formatter(template, data='1234567890'):\n    data = cycle(data)\n    return ''.join(next(data) if c.isalpha() else c for c in template)
def candidates(ymd):\n    y, m, d = ymd.split('-')\n    return {ymd, f'{y}-{d}-{m}'}\n\ndef check_dates(records):\n    result = [0, 0, 0]\n    for start, end in records:\n        xs = [(dt1, dt2) for dt1 in candidates(start) for dt2 in candidates(end)\n              if dt1 <= dt2 and dt1[5:7] <= '12' >= dt2[5:7]]\n        i = 2 if len(xs) > 1 else xs[0] != (start, end)\n        result[i] += 1  # 2: uncertain, 1(True): recoverable, 0(False): correct\n    return result
def is_lock_ness_monster(s):\n    return any(i in s for i in ('tree fiddy', 'three fifty', '3.50'))
n = 500000\nsieve, PRIMES = [0]*(n//2+1), [0,2]\nfor i in range(3, n+1, 2):\n    if not sieve[i//2]:\n        PRIMES.append(i)\n        for j in range(i**2, n+1, i*2): sieve[j//2] = 1\n\nDOMINANTS = []\nfor p in PRIMES:\n    if p >= len(PRIMES): break\n    DOMINANTS.append(PRIMES[p])\n\ndef solve(a,b):\n    return sum(p for p in DOMINANTS if a <= p <= b)
def lose_weight(gender, weight, duration):\n    if not gender in ['M', 'F']: return 'Invalid gender'\n    if weight <= 0: return 'Invalid weight'\n    if duration <= 0: return 'Invalid duration'\n    \n    nl = 0.985 if gender == 'M' else 0.988\n    \n    for i in range(duration): weight *= nl\n    return round(weight, 1)
def unscramble_eggs(word):\n    return word.replace('egg','')
def odd_one(arr):\n    for i in range(len(arr)):\n        if arr[i] % 2 != 0:\n            return i\n    return -1\n
how_many_apples=lambda n:n**n-(n-1)+[0,4][n==2]
import re\nfrom itertools import groupby\n\nCONFIG = {'FURY':   " really",\n          'FIRE':   " and you",\n          'FAKE':   "Fake tweet.",\n          'FURY_f': "I am{} furious.",\n          'FIRE_f': "You{} are fired!"}\n\ndef fire_and_fury(tweet):\n    if re.findall(r'[^FURYIE]', tweet): return CONFIG['FAKE']\n    lst = []\n    for k,g in groupby(re.findall(r'FURY|FIRE', tweet)):\n        lst += [ CONFIG[k+"_f"].format(CONFIG[k] * (len(list(g)) - 1)) ]\n    return ' '.join(lst) or CONFIG['FAKE']
def mirror(code, chars="abcdefghijklmnopqrstuvwxyz"):\n    return code.lower().translate(str.maketrans(chars, chars[::-1]))
from functools import reduce\nfrom fractions import gcd\n\ndef final_attack_value(x, monster_list):\n    return reduce(lambda a, b: a + (b if b <= a else gcd(a, b)), monster_list, x)
from ipaddress import IPv4Address\n\ndef int32_to_ip(int32):\n    return str(IPv4Address(int32))
from numpy import linspace\n\n\ndef looper(start, stop, number):\n    return list(linspace(start, stop, number))
def winner(candidates):\n    try:\n        assert len(candidates) == 3\n        max_total = 0\n        for c in candidates:\n            name, scores = c['name'], c['scores']\n            assert 1 <= len(scores) <= 2\n            assert all(not s % 5 and 0 < s <= 100 for s in scores)\n            total = sum(scores)\n            if max_total < total <= 100:\n                selected, max_total = name, total\n        return selected\n    except:\n        return False
def remove_rotten(bag_of_fruits):\n    return [x.replace('rotten', '').lower() for x in bag_of_fruits] if bag_of_fruits else []
from itertools import combinations\n\n\ndef closest_sum(ints, num):\n    return sum(min(combinations(ints, 3), key=lambda a: abs(num - sum(a))))
def shape_area(n):\n    return n**2 + (n - 1) ** 2
def solve(s):\n    it = reversed(s.replace(' ',''))\n    return ''.join(c if c == ' ' else next(it) for c in s)
def binary_simulation(s, q):\n    out,n,s = [],int(s,2),len(s)\n    for cmd,*i in q:\n        if cmd=='I':\n            a,b=i\n            n ^= (1<<b-a+1)-1<<s-b\n        else:\n            out.append( str(int(0 < 1<<s-i[0] & n )) )\n    return out
def sort_it(list_, n):    \n    return ', '.join(sorted(list_.split(', '), key=lambda i: i[n-1]))
from functools import reduce\n\ndef product_sans_n(nums):\n    z = nums.count(0)\n    if z > 1: return [0] * len(nums)\n    \n    p = reduce(int.__mul__, (v for v in nums if v))\n    return [not v and p for v in nums] if z else [p//v for v in nums]
def sort_twisted37(arr):\n    def key(x):\n        return int(str(x).translate(str.maketrans('37', '73')))\n    return sorted(arr, key=key)
def draw(waves):\n    m       = max(waves)\n    rotHist = [ (''*v).rjust(m, '') for v in waves ]\n    return '\n'.join( map(''.join, zip(*rotHist)) )
def find(n):\n    return sum(e for e in range(1, n+1) if e % 3 == 0 or e % 5 == 0)
FROM   = "abc def ghi jkl mno pqrs tuv wxyz".split()\nTO_NUM = "222 333 444 555 666 7777 888 9999".split()\n\nTABLE_TO_NUM  = str.maketrans( *map(''.join, (FROM, TO_NUM)) )\nTABLE_TO_CHAR = str.maketrans( *map(lambda lst: ''.join(x[0] for x in lst), (TO_NUM, FROM)))\n\n\ndef T9(words, seq):\n    return ( [w for w in words if seq == w.lower().translate(TABLE_TO_NUM)]\n                or [seq.translate(TABLE_TO_CHAR)] )
def kangaroo(k1, r1, k2, r2):\n    if r1==r2: return k1==k2\n    cross, r = divmod(k1-k2, r2-r1)\n    return cross >= 0 and not r
def search(budget, prices):\n    return ','.join(str(a) for a in sorted(prices) if a <= budget)\n
def is_smooth(n):\n    for x in [2,3,5,7]:\n        while n%x==0:n//=x\n        if n==1:return ("power of 2",'3-smooth','Hamming number','humble number')[(2<x)+(3<x)+(5<x)]  \n    return "non-smooth"
import re\ndict = {'UUC':'F','UUU':'F','UUA':'L','UUG':'L','CUU':'L','CUC':'L','CUA':'L','CUG':'L','AUU':'I','AUC':'I','AUA':'I','AUG':'M','GUU':'V','GUC':'V','GUA':'V','GUG':'V','UCU':'S','UCC':'S','UCA':'S','UCG':'S','AGU':'S','AGC':'S','CCU':'P','CCC':'P','CCA':'P','CCG':'P','ACU':'T','ACC':'T','ACA':'T','ACG':'T','GCU':'A','GCC':'A','GCA':'A','GCG':'A','UAU':'Y','UAC':'Y','CAU':'H','CAC':'H','CAA':'Q','CAG':'Q','AAU':'N','AAC':'N','AAA':'K','AAG':'K','GAU':'D','GAC':'D','GAA':'E','GAG':'E','UGU':'C','UGC':'C','UGG':'W','CGU':'R','CGC':'R','CGA':'R','CGG':'R','AGA':'R','AGG':'R','GGU':'G','GGC':'G','GGA':'G','GGG':'G'}\n\ndef protein(rna):\n    return re.sub('.{3}', lambda r: dict.get(r.group(0), ''), rna)
def sort_by_value_and_index(arr):\n    return [y[1] for y in sorted(enumerate(arr),key=lambda x:(x[0] + 1) * x[1])]
def solve(s):\n    vowels = sorted(c for c in s if c in "aeiou")\n    consonants = sorted(c for c in s if c not in "aeiou")\n    part1, part2 = sorted((vowels, consonants), key=len, reverse=True)\n    part2.append('')\n    if len(part1) > len(part2):\n        return "failed"\n    return "".join(a + b for a, b in zip(part1, part2))
import re\n\ndef gym_slang(phrase):\n    phrase = re.sub(r'([pP])robably', r'\1rolly', phrase)\n    phrase = re.sub(r'([iI]) am', r"\1'm", phrase)\n    phrase = re.sub(r'([iI])nstagram', r'\1nsta', phrase)\n    phrase = re.sub(r'([dD])o not', r"\1on't", phrase)\n    phrase = re.sub(r'([gG])oing to', r'\1onna', phrase)\n    phrase = re.sub(r'([cC])ombination', r'\1ombo', phrase)\n    \n    return phrase
l, m, p = [1], 10 ** 7, []\nfor n in range(2, int(m ** .5) + 1):\n    l = [n*n + j for j in [0]+l]\n    p += [int(k) for k in map(str, l[1:]) if k == k[::-1]]\np = sorted(set(p))\n\nfrom bisect import bisect_left\ndef values(n): return bisect_left(p, n)
def is_prime(n):\n    return n >= 2 and all(n%i for i in range(2, 1+int(n**.5)))\n    \ndef total(arr):\n    return sum(n for i, n in enumerate(arr) if is_prime(i))
def pattern(n):\n    top = [(str(i % 10) * n).center(n * 3 - 2) for i in range(1, n)]\n    left = ''.join(str(i % 10) for i in range(1, n))\n    middle = left + str(n % 10) * n + left[::-1]\n    return '\n'.join(top + [middle] * n + top[::-1])\n
def clock_degree(clock_time):\n    hour, minutes = (int(a) for a in clock_time.split(':'))\n    if not (24 > hour >= 0 and 60 > minutes >= 0):\n        return 'Check your time !'\n    return '{}:{}'.format((hour % 12) * 30 or 360, minutes * 6 or 360)
def area_code(text):\n    return text[text.find("(")+1:text.find(")")]
def get_honor_path(honor, target):\n    return dict(list(zip(["1kyus", "2kyus"], divmod(target - honor, 2)))) if target > honor else {}\n
def get_new_notes(salary, bills):\n    return max((salary - sum(bills)), 0) // 5
def grader(x):\n  if 0.9 <= x <= 1: return "A"\n  elif 0.8 <= x < 0.9: return "B"\n  elif 0.7 <= x < 0.8: return "C"\n  elif 0.6 <= x < 0.7: return "D"\n  else: return "F"
def divisors(num):\n    l = [a for a in range(2,num) if num%a == 0]\n    if len(l) == 0:\n        return str(num) + " is prime"\n    return l
def solve(s):\n    return s.upper() if sum(map(str.isupper, s)) * 2 > len(s) else s.lower()
def shifted_diff(first, second):\n    return (second + second).find(first) if len(first) == len(second) else - 1;
def solution(number):\n    return sum(x for x in range(number) if x % 3 == 0 or x % 5 == 0)\n
def solve(count, ball_number):\n    """\n    Return the position of the `ball_number` after the game with `count` balls\n\n    :param count: Number of balls\n    :type count: int\n    :param ball_number: Number of ball to be found in the end\n    :type ball_number: int\n    :return: Return the index of the ball `ball_number` at the end of the game\n    :rtype: int\n    """\n    assert isinstance(count, int)\n    assert isinstance(ball_number, int)\n\n    balls = list(range(count))\n    for idx in range(count):\n        balls = balls[:idx] + balls[idx:][::-1]\n    return balls.index(ball_number)\n
from math import floor\n\ndef convert(dd, direction):\n    degrees = floor(dd)\n    seconds = round((dd % 1) * 3600000)\n    return "%03d*%02d\'%06.3f\"%s" % (degrees, \n                                       seconds // 60000,\n                                       seconds % 60000 / 1000,\n                                       direction)\n\ndef convert_to_dms(dd_lat, dd_lon):\n    dd_lat = float(dd_lat)\n    dd_lon = float(dd_lon)\n    dms_lat = convert(abs(dd_lat), 'N' if dd_lat >= 0 else 'S')\n    dms_lon = convert(abs(dd_lon), 'E' if dd_lon >= 0 else 'W')\n    return dms_lat, dms_lon
def guess_my_number(guess, number = '123-451-2345'):\n    return "".join(c if c in guess+"-" else "#" for c in number)\n
BASE = [r.split('|') for r in '''\\n  ###  |       |  ###  |  ###  |       |  ###  |  ###  |  ###  |  ###  |  ###  |       \n #   # |     # |     # |     # | #   # | #     | #     |     # | #   # | #   # |       \n #   # |     # |     # |     # | #   # | #     | #     |     # | #   # | #   # |       \n #   # |     # |     # |     # | #   # | #     | #     |     # | #   # | #   # |       \n       |       |  ###  |  ###  |  ###  |  ###  |  ###  |       |  ###  |  ###  |       \n #   # |     # | #     |     # |     # |     # | #   # |     # | #   # |     # |       \n #   # |     # | #     |     # |     # |     # | #   # |     # | #   # |     # |       \n #   # |     # | #     |     # |     # |     # | #   # |     # | #   # |     # |       \n  ###  |       |  ###  |  ###  |       |  ###  |  ###  |       |  ###  |  ###  |       '''.split('\n') ]\n\n\ndef segment_display(n):\n    digs = [int(d,16) for d in f'{n:A>6}']\n    return '\n'.join( f'|{ "|".join( BASE[x][d] for d in digs) }|'\n                      for x in range(len(BASE)))\n
def check_digit(n, idx1, idx2, digit):\n    return str(digit) in str(n)[idx1:idx2+1] + str(n)[idx2:idx1+1]
def duty_free(price, discount, holiday_cost):\n    saving = price * discount / 100.0\n    return int(holiday_cost / saving)
import re\nvalidate = lambda msg: bool(re.match('^MDZHB \d\d \d\d\d [A-Z]+ \d\d \d\d \d\d \d\d$', msg))
from itertools import product\n\ndef is_divisible_by_6(s):\n    if s[-1] in '13579': return []\n    ss = s.replace('*','{}')\n    return [ v for v in (ss.format(*p) for p in product(*(['0123456789']*s.count('*')))) if not int(v)%6]
def missing(seq):\n    for digits in range(1, len(seq) // 2 + 1):\n        my_seq = last = seq[:digits]\n        n = int(my_seq)\n        missing = None\n        \n        while len(my_seq) < len(seq):\n            n += 1\n            my_seq += str(n)\n            \n            if not seq.startswith(my_seq):\n                if missing == None:\n                    missing = n\n                    my_seq = last\n                else:\n                    break\n            else:\n                last = my_seq\n        \n        if my_seq == seq and missing:\n            return missing\n    \n    return -1
def total(arr):\n    while len(arr) > 1:\n        arr = [x+y for x,y in zip(arr,arr[1:])]\n    return arr[0]
INSTRUCTIONS = {"0F12": int.__add__, "B7A2": int.__sub__, "C3D9": int.__mul__}\n\ndef communication_module(packet):\n    header,inst,d1,d2,footer = (packet[i:i+4] for i in range(0,20,4))\n    res = max(0, min(9999, INSTRUCTIONS[inst](int(d1), int(d2)) ))\n    \n    return f"{header}FFFF{res:0>4}0000{footer}"
from collections import Counter\n\ndef solve(a):\n    c = Counter(a)\n    return sorted(a, key=lambda k: (-c[k], k))
def is_keith_number(n):\n    numList = [int(i) for i in str(n)]  # int array\n    if len(numList) > 1:  # min 2 digits\n        itr = 0\n        while numList[0] <= n:\n            # replace array entries by its sum:\n            numList[itr % len(numList)] = sum(numList)\n            itr += 1\n            if n in numList:  # keith-condition\n                return itr\n    return False
from itertools import product\n\ndef operator_insertor(n):\n    result = []\n    \n    for ops in product(["+", "-", ""], repeat=8):\n        expression = "".join(a+b for a, b in zip("123456789", list(ops) + [""]))\n        res = eval(expression)\n        if res == n:\n            result.append(len(expression) - 9)\n    \n    return min(result, default=None)
def howmuch(m, n):    \n    return [['M: %d'%i, 'B: %d'%(i/7), 'C: %d'%(i/9)] for i in range(min(m,n), max(m,n)+1) if i%7 == 2 and i%9 == 1]\n        \n            \n            \n
def arr2bin(arr):\n    for x in arr:\n        if(type(x) != int):\n            return False\n    return '{0:b}'.format(sum(arr))
def solution(to,lst):\n    dolSym, eurSym, power = ('', '', -1) if to=='EUR' else ('$','', 1)\n    return [f"{ dolSym }{ v*1.1363636**power :,.2f}{ eurSym }" for v in lst]
def dominator(arr):\n    for x in set(arr):\n        if arr.count(x) > len(arr)/2.0:\n            return x\n    return -1
def solve(s):\n    ans = []\n    for ab in s.split('\n'):\n        carry, carried = 0, 0\n        for a,b in zip(*map(lambda ss: map(int,ss[::-1]), ab.split())):\n            carried += a+b\n            carry   += carried > 9\n            carried //= 10\n        ans.append(carry)\n        \n    return '\n'.join("No carry operation" if not c else "%d carry operations"%(c) for c in ans)
from numpy import mean, median\n\ndef mean_vs_median(numbers):\n    if mean(numbers) > median(numbers):\n        return 'mean'\n    elif mean(numbers) < median(numbers):\n        return 'median'\n    else:\n        return 'same'
def freeway_game(km, kph, cars):\n    t = km / kph\n    c = 0\n    for dt, speed in cars:\n        d = km - (t - dt/60) * speed\n        if dt <= 0:\n            c += d > 0\n        else:\n            c -= d < 0\n    return c
def baby_count(x):\n    x = x.lower()\n    return min(x.count('a'), x.count('b') // 2, x.count('y')) or "Where's the baby?!"
def shuffled_array(s):\n    result = sorted(s)\n    result.remove(sum(result) // 2)\n    return result\n
def hamming_distance(a, b):\n    return bin(a ^ b).count('1')
def corrections(x):\n    str = "{0} is more than zero." if x > 0 else "{0} is equal to or less than zero."\n    return str.format(x)
def jumping(arr, n):\n    i = 0\n    while i < len(arr):\n        x = arr[i]\n        arr[i] += 1 if x < n else -1\n        i += x\n    return arr.count(n)
def micro_world(bacteria, k):\n    return sum(1 for e in bacteria if not [j for j in bacteria if e<j<=e+k])\n
def reverse_words(str):\n    return ' '.join(s[::-1] for s in str.split(' '))
def is_john_lying(a,b,s):\n    delta = abs(a) + abs(b) - s\n    return delta <= 0 and delta % 2 == 0
def check_root(string):\n    try:\n        a,b,c,d = [int(i) for i in string.split(',')]\n        if not (a == b-1 and a == c-2 and a == d-3):\n            return 'not consecutive'\n        s = a*b*c*d+1\n        return str(s)+', '+str(int(s**0.5))\n    except:\n        return 'incorrect input'
def dig_pow(n, p):\n  s = 0\n  for i,c in enumerate(str(n)):\n     s += pow(int(c),p+i)\n  return s/n if s%n==0 else -1\n
def billboard(name, price=30):\n    return sum(price for letter in name)
def reverse(st):\n    return " ".join(reversed(st.split())).strip()
def dollar_to_speech(value):\n    if "-" in value:\n        return "No negative numbers are allowed!"\n    d, c = (int(n) for n in value.replace("$", "").split("."))\n    dollars = "{} dollar{}".format(str(d), "s" if d != 1 else "") if d or not c else ""\n    link = " and " if (d and c) else ""\n    cents = "{} cent{}".format(str(c), "s" if c != 1 else "") if c else ""\n    return "{}{}{}.".format(dollars, link, cents)
from collections import Counter\n\nREQUIRE = {x: Counter(s) for x,s in [('road', 'bw'), ('settlement', 'bwsg'), ('city', 'ooogg'), ('development', 'osg')] }\n\ndef build_or_buy(hand):\n    h = Counter(hand)\n    return [item for item,c in REQUIRE.items() if not c-h]
def luxhouse(houses):\n    return [max(0, max(houses[i:]) - h + 1) for i, h in enumerate(houses[:-1], 1)] + [0]
def hydrate(drink_string): \n    c=sum(int(c) for c in drink_string if c.isdigit())\n    return "{} {} of water".format(c,'glass') if c==1 else "{} {} of water".format(c,'glasses')
def pattern(n):\n  return "\n".join(["".join([str(y) for y in range(n, x, -1)]) for x in range(n)]);
def vowel_recognition(input):\n    vowels = set('aeiouAEIOU')\n    s = t = 0\n    for c, e in enumerate(input, 1):\n        if e in vowels:\n            t += c\n        s += t\n    return s
from itertools import cycle\n\nROOT = {'fib': [0, 0, 0, 1],\n        'jac': [0, 0, 0, 1],\n        'pad': [0, 1, 0, 0],\n        'pel': [0, 0, 0, 1],\n        'tet': [0, 0, 0, 1],\n        'tri': [0, 0, 0, 1]}\nGEN  = {'fib': lambda a: a[-1] + a[-2],\n        'jac': lambda a: a[-1] + 2 * a[-2],\n        'pad': lambda a: a[-2] + a[-3],\n        'pel': lambda a: 2 * a[-1] + a[-2],\n        'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],\n        'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\n\ndef zozonacci(pattern, n):\n    if not pattern or not n: return []\n    \n    lst  = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    \n    for f,_ in zip(cycl,range(n-4)): lst.append(f(lst))\n    \n    return lst[:n]
def check(num,max_sum):\n    l = [int(i) for i in str(num)]\n    for i in range(0,len(l) - 3):\n        if sum(l[i:i+4]) > max_sum:return False\n    return True\n\ndef max_sumDig(nMax, maxSum):\n    found = [i for i in range(1000,nMax + 1) if check(i,maxSum)]\n    mean = sum(found) / float(len(found))\n    for i in range(len(found) - 1):\n        if abs(mean - found[i]) < abs(mean - found[i + 1]):\n            mean = found[i]\n            break\n    return [len(found), mean, sum(found)]
from collections import Counter\n\ndef sorted_brands(history):\n    brands = [x['brand'] for x in history]\n    counter = Counter(brands)\n    return sorted(set(brands), key=lambda x: (-counter[x], brands.index(x)))
def rps(p1, p2):\n    beats = {'rock': 'scissors', 'scissors': 'paper', 'paper': 'rock'}\n    if beats[p1] == p2:\n        return "Player 1 won!"\n    if beats[p2] == p1:\n        return "Player 2 won!"\n    return "Draw!"
def find_children(santas_list, children):\n    return sorted(set(santas_list) & set(children))
def reverse_fizzbuzz(s):\n    if s == 'Fizz': return [3]\n    if s == 'Buzz': return [5]\n    if s == 'Fizz Buzz': return [9, 10]\n    if s == 'Buzz Fizz': return [5, 6]\n    if s == 'FizzBuzz': return [15]\n    s = s.split()\n    for i in range(len(s)):\n        if s[i].isdigit():\n            start = int(s[i]) - i\n            return list(range(start, start + len(s)))
def solve(n):\n    if n%10: return -1\n    c, billet = 0, iter((500,200,100,50,20,10))\n    while n:\n        x, r = divmod(n, next(billet))\n        c, n = c+x, r\n    return c
from math import pi\n\ndef ellipse(a, b):\n    return f"Area: {pi*a*b:.1f}, perimeter: {pi*( 1.5*(a+b) - (a*b)**.5 ):.1f}"
def sum_triangular_numbers(n):\n    return n*(n+1)*(n+2)/6 if n>0 else 0
def decipher_message(message):\n    n = int(len(message) ** 0.5)\n    return ''.join(message[i::n] for i in range(n))
def interweave(s1, s2):\n    s = [''] * (len(s1) + len(s2))\n    s[::2], s[1::2] = s1, s2\n    return ''.join(c for c in s if not c.isdigit()).strip()
def square_digits(num):\n    ret = ""\n    for x in str(num):\n        ret += str(int(x)**2)\n    return int(ret)
def sel_reverse(arr,l):\n    return [ elt for i in range(0, len(arr), l) for elt in arr[i:i+l][::-1] ] if l != 0 else arr
from math import ceil\ndef calculate_tip(amount, rating):\n    tips = {\n        'terrible': 0,\n        'poor' : .05,\n        'good' : .1,\n        'great' : .15,\n        'excellent' : .2\n    }\n    if rating.lower() in tips:\n        return ceil(amount * tips[rating.lower()])\n    else:\n        return 'Rating not recognised'
score = lambda sub_gen: lambda n: sum(int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length))\nscore1 = score(__import__('itertools').combinations)\nscore2 = score(lambda s, r: (s[i: i+r] for i in range(len(s) - r + 1)))\n\ndivs = lambda n: set.union(*({d, n // d} for d in range(1, int(n ** .5) + 1) if not n % d)) - {1, n}\n\ndef find_int_inrange(a, b):\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]: div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]: div_range.append(n)\n    return div_range
def duplicate_count(s):\n  return len([c for c in set(s.lower()) if s.lower().count(c)>1])\n
from math import log\n\ndef half_life(N0, N, t):\n    return t / log(N0/N, 2)
def longest_word(letters):\n    try:\n        word_list = [w for w in words if all(w.count(c) <= letters.count(c) for c in w)]\n        largest = sorted([w for w in word_list if len(w) == len(max(word_list, key=len))])\n        return largest if largest else None\n    except:\n        return None
def press_button(n):\n  return (n*n+5)*n/6
def bracket_pairs(string):\n    brackets = {}\n    open_brackets = []\n\n    for i, c in enumerate(string):\n        if c == '(':\n            open_brackets.append(i)\n        elif c == ')':\n            if not open_brackets:\n                return False\n            brackets[open_brackets.pop()] = i\n\n    return False if open_brackets else brackets\n
def sort_string(s):\n    a = iter(sorted((c for c in s if c.isalpha()), key=str.lower))\n    return ''.join(next(a) if c.isalpha() else c for c in s)
from itertools import groupby\n\ndef uniq_c(seq): \n    return [ (k,sum(1 for _ in g)) for k,g in groupby(seq)]
from collections import deque\n\ndef custom_fib(signature, indexes, n):\n    fib = deque(signature)\n    for _ in range(n):\n        fib.append(sum(map(fib.__getitem__, indexes)))\n        fib.popleft()\n    return fib[0]
def max_sum(arr, ranges):\n    return max( sum(arr[start:stop+1]) for start, stop in ranges )
import textwrap\n\ndef align_right(text,width):\n    return "\n".join([l.rjust(width, ' ') for l in textwrap.wrap(text, width)])
def say_hello(name):\n    return f"Hello, {name}"
def house_of_cards(n):\n    if n>=1:\n        return(n+1)*n/2 + (n+2)*(n+1)\n    raise ValueError
def getDivs(n):\n    return {1} | {y for x in range(2,int(n**.5)+1) for y in [n//x, x] if not n%x}\n\ndef amicable_numbers(n1,n2):\n    return sum(getDivs(n1)) == n2 and sum(getDivs(n2)) == n1
def rank_of_element(arr,i):\n    return sum(x <= arr[i] if n < i else x < arr[i] for n,x in enumerate(arr))
from math import log\n\ndef powerof4(n):\n    if type(n) in (float, int) and n > 0:\n        return log(n,4).is_integer()\n    return False
def solution(full_text, search_text):\n    return full_text.count(search_text)
u = [8, 58, 85, 88, 358, 385, 538, 583, 588, 835, 853, 858, 885, 888, 3588, 3858, 3885, 5388, 5588, 5838, 5858, 5883, 5885, 5888, 8358, 8385, 8538, 8558, 8583, 8585, 8588, 8835, 8853, 8855, 8858, 8885, 8888, 35588, 35858, 35885, 35888, 38558, 38585, 38588, 38855, 38858, 38885, 53588, 53858, 53885, 53888, 55388, 55838, 55883, 55888, 58358, 58385, 58388, 58538, 58583, 58588, 58835, 58838, 58853, 58858, 58883, 58885, 58888, 83558, 83585, 83588, 83855, 83858, 83885, 85358, 85385, 85388, 85538, 85583, 85588, 85835, 85838, 85853, 85858, 85883, 85885, 85888, 88355, 88358, 88385, 88535, 88538, 88553, 88558, 88583, 88585, 88588, 88835, 88853, 88855, 88858, 88885, 88888, 335588, 335858, 335885, 338558, 338585, 338855, 353588, 353858, 353885, 355388, 355838, 355883, 355888, 358358, 358385, 358538, 358583, 358588, 358835, 358853, 358858, 358885, 358888, 383558, 383585, 383855, 385358, 385385, 385538, 385583, 385588, 385835, 385853, 385858, 385885, 385888, 388355, 388535, 388553, 388558, 388585, 388588, 388855, 388858, 388885]\n\ndef solve(a, b):\n    return sum(a <= x < b for x in u)
def tail_swap(strings):\n    head0, tail0 = strings[0].split(':')\n    head1, tail1 = strings[1].split(':')\n    return [head0 + ':' + tail1, head1 + ':' + tail0]
from math import ceil, log10\n\ndef graceful_tipping(bill):\n    bill *= 1.15\n    if bill < 10:\n        return ceil(bill)\n    e = int(log10(bill))\n    unit = (10 ** e) / 2\n    return ceil(bill / unit) * unit
odd_row = lambda n:list(range(n*(n-1)+1,n*(n+1),2))\n
def tidyNumber(n):\n    s = list(str(n))\n    return s == sorted(s)
def find_next_square(sq):\n    root = sq ** 0.5\n    if root.is_integer():\n        return (root + 1)**2\n    return -1\n
def remove_char(s):\n    return s[1 : -1]
def two_count(n):\n    res = 0\n    while not n & 1:\n        res += 1\n        n >>= 1\n    return res\n
def find_missing_letter(chars):\n    n = 0\n    while ord(chars[n]) == ord(chars[n+1]) - 1:\n        n += 1\n    return chr(1+ord(chars[n]))\n\n
def last(*args):\n    return args[-1] if not hasattr(args[-1], "__getitem__") else args[-1][-1]
from sklearn.cluster import KMeans\n\n# Doesn't work for big tests, too bad\ndef cluster_kmeans(points, n):\n    kmeans = KMeans(n_clusters=n)\n    kmeans.fit(points)\n    res = [[] for _ in range(n)]\n    for i,p in zip(kmeans.labels_, points):\n        res[i].append(p)\n    return sorted(map(sorted, res))\n\n\nfrom itertools import combinations, product, starmap\nimport numpy as np\n\nmemo_points = {}\ndef point_dist(p1, p2):\n    key = (p1, p2) if p1 < p2 else (p2, p1)\n    if not key in memo_points: memo_points[key] = np.linalg.norm(np.array(key[0]) - np.array(key[1]))\n    return memo_points[key]\n\nmemo_clusters = {}\ndef cluster_dist(clusters):\n    key = tuple(map(tuple, clusters))\n    if not key in memo_clusters: memo_clusters[key] = np.mean(list(starmap(point_dist, product(*key))))\n    return memo_clusters[key]\n\ndef cluster(points, n):\n    clusters = [[p] for p in points]\n    while len(clusters) > n:\n        c1, c2 = min(combinations(clusters, 2), key=cluster_dist)\n        c1.extend(c2)\n        clusters.remove(c2)\n    return sorted(map(sorted, clusters))
def check_for_factor(base, factor):\n    return base % factor == 0
def match_arrays(v, r):\n    return sum(x in r for x in v)\n\n# DON'T remove\nverbose = False # set to True to diplay arrays being tested in the random tests
import re\n\ndef reverse(s):\n    return re.sub(r'(.)\1+', lambda m: m.group().swapcase(), s)
def arithmetic_sequence_sum(a, r, n):\n    return n * (a + a + ( n - 1) * r) / 2  
def stat(strg):\n\n    def get_time(s):\n        '''Returns the time, in seconds, represented by s.'''\n        hh, mm, ss = [int(v) for v in s.split('|')]\n        return hh * 3600 + mm * 60 + ss\n    \n    def format_time(time):\n        '''Returns the given time as a string in the form "hh|mm|ss".'''\n        hh = time // 3600\n        mm = time // 60 % 60\n        ss = time % 60\n        return '{hh:02d}|{mm:02d}|{ss:02d}'.format(**locals())\n    \n    def get_range(times):\n        return times[-1] - times[0]\n    \n    def get_average(times):\n        return sum(times) // len(times)\n    \n    def get_median(times):\n        middle = len(times) >> 1\n        return (times[middle] if len(times) & 1 else\n                (times[middle - 1] + times[middle]) // 2)\n    \n    if strg == '':\n        return strg\n    times = [get_time(s) for s in strg.split(', ')]\n    times.sort()\n    rng = format_time(get_range(times))\n    avg = format_time(get_average(times))\n    mdn = format_time(get_median(times))\n    return 'Range: {rng} Average: {avg} Median: {mdn}'.format(**locals())
def Xbonacci(signature,n):\n    output, x = signature[:n], len(signature)\n    while len(output) < n:\n        output.append(sum(output[-x:]))\n    return output
import re\n\nTACODICT = {\n             't':'tomato', \n             'l':'lettuce',\n             'c':'cheese',\n             'g':'guacamole',\n             's':'salsa'\n           }\n\ndef tacofy(word):\n    return ['shell'] + [TACODICT.get(c, 'beef') for c in re.sub('[^aeioutlcgs]+' ,'', word.lower())] + ['shell']
def find_even_index(arr):\n    for i in range(len(arr)):\n        if sum(arr[:i]) == sum(arr[i+1:]):\n            return i\n    return -1\n
def discover_original_price(discounted_price, sale_percentage):\n    return round(discounted_price / ((100 - sale_percentage) * 0.01), 2)\n
def spin_words(sentence):\n    # Your code goes here\n    return " ".join([x[::-1] if len(x) >= 5 else x for x in sentence.split(" ")])
from re import sub\n\ndef encode(string):\n    return sub(r'(.)\1*', lambda m: str(len(m.group(0))) + m.group(1),string)\n    \ndef decode(string): \n    return sub(r'(\d+)(\D)', lambda m: m.group(2) * int(m.group(1)),string)
def summ(number, d):\n    n = (number - 1) // d\n    return n * (n + 1) * d // 2\n\ndef solution(number):\n    return summ(number, 3) + summ(number, 5) - summ(number, 15)\n
def derive(coefficient, exponent): \n    return f'{coefficient * exponent}x^{exponent - 1}'
from collections import Counter\n\ndef highest_rank(arr):\n    if arr:\n        c = Counter(arr)\n        m = max(c.values())\n        return max(k for k,v in c.items() if v==m)
def is_happy(n):\n    seen = set()\n    while n!=1:\n        n = sum(int(d)**2 for d in str(n))\n        if n not in seen: seen.add(n)\n        else:             return False\n    return True
def solve(a):\n    return sum(1 if v % 2 == 0 else -1 for v in a if type(v) == int)
from fractions import gcd\n\ndef nbr_of_laps(x, y):\n    return (y / gcd(x,y), x / gcd(x,y))
def dating_range(age):\n    if age <= 14:\n        min = age - 0.10 * age\n        max = age + 0.10 * age\n    else:\n        min = (age/2)+7\n        max = (age-7)*2\n        \n    return str(int(min))+'-'+str(int(max))
def alternate_sq_sum(arr):\n    return sum([ x**2 if i % 2 == 1 else x for i, x in enumerate(arr) ])
from itertools import permutations\n\ndef solve(s,k):\n    return sum(not v%k for v in map(int, map(''.join, permutations(s.split(),2))))
from math import sin, pi\n\ndef area_of_polygon_inside_circle(r, n):\n    return round(0.5 * n * r ** 2 * sin(2 * pi / n), 3)
from math import pi\n\ndef cup_volume(d1, d2, h):\n    return round(h / 12.0 * pi * (d1**2 + d1*d2 + d2**2), 2)
import math\n\ndef strong_num(number):\n    return "STRONG!!!!" if sum(math.factorial(int(i)) for i in str(number)) == number else "Not Strong !!"
def dot(n, m):\n    sep = '+---' * n + '+'\n    dot = '| o ' * n + '|'\n    return '\n'.join([sep, dot] * m + [sep])
import re\nfrom itertools import accumulate\n\n\npatterns = [\n    (re.compile('.*'.join('bug'), flags=re.I), 'Roma'),\n    (re.compile('.*'.join('boom'), flags=re.I), 'Maxim'),\n    (re.compile('.*'.join('edits'), flags=re.I), 'Danik'),\n]\n\ndef memesorting(meme):\n    return next((who for m in accumulate(meme) for pattern, who in patterns if pattern.search(m)), 'Vlad')
def possible_positions(p):\n    r, c = ord(p[0])-96, int(p[1])\n    moves = [(-2,-1), (-2,1), (-1,-2), (-1,2), (1,-2), (1,2), (2,-1), (2,1)]\n    return [''.join((chr(r+i+96), str(c+j))) for i, j in moves if 1 <= r+i <= 8 and 1 <= c+j <= 8]
def first_dup(s):\n    for x in s:\n        if s.count(x) > 1:\n            return x\n    return None
def reverse_bits(n):\n    return int(bin(n)[:1:-1],2)
def basic_op(operator, value1, value2):\n    if operator=='+':\n        return value1+value2\n    if operator=='-':\n        return value1-value2\n    if operator=='/':\n        return value1/value2\n    if operator=='*':\n        return value1*value2
def finding_k(arr):\n    for n in range(max(arr)-1, 0, -1):\n        if len({ x%n for x in arr }) == 1: return n\n    return -1
def string_to_int_list(s):\n    return [int(n) for n in s.split(",") if n]
def digits_average(input):\n    digits = [int(c) for c in str(input)]\n    while len(digits) > 1:\n        digits = [(a + b + 1) // 2 for a, b in zip(digits, digits[1:])]\n    return digits[0]
from itertools import combinations\n\ndef counting_triangles(v):\n    v.sort()\n    return sum(a+b>c for a,b,c in combinations(v,3))
def get_free_urinals(urinals):\n    return -1 if '11' in urinals else sum(((len(l)-1)//2 for l in f'0{urinals}0'.split('1')))
import numpy as np\nfrom itertools import zip_longest\nfrom string import ascii_lowercase as lower, ascii_uppercase as upper\n\nD = {c:i%26 for i,c in enumerate(lower+upper)}\n\ndef encrypt(text, key):\n    result = []\n    text = ''.join(filter(str.isalpha, text))\n    key = np.array(([D[key[0]], D[key[1]]], [D[key[2]], D[key[3]]]))\n    for c1,c2 in zip_longest(text[::2], text[1::2], fillvalue='Z'):\n        x,y = key @ ([D[c1]], [D[c2]])\n        result.append(upper[x[0]%26] + upper[y[0]%26])\n    return ''.join(result)
def spoonerize(words):\n    a, b = words.split()\n    return '{}{} {}{}'.format(b[0], a[1:], a[0], b[1:])\n
from itertools import zip_longest\n\ndef combine_strings(*args):\n    return ''.join(''.join(x) for x in zip_longest(*args, fillvalue=''))
def paint_letterboxes(start, finish):\n    xs = [0] * 10\n    for n in range(start, finish+1):\n        for i in str(n):\n            xs[int(i)] += 1\n    return xs
def game(maxMike, maxJoe):\n    roundsMike = int(maxMike**.5)\n    roundsJoe  = (-1 + (1 + 4*maxJoe)**.5) // 2\n    return ("Non-drinkers can't play" if not maxMike or not maxJoe else\n            "Joe" if roundsMike <= roundsJoe else \n            "Mike")
add = lambda a, b: a + b\nmultiply = lambda a, b: a * b\ndivide = lambda a, b: a / b\nmod = lambda a, b: a % b\nexponent = lambda a, b: a ** b\nsubt = lambda a, b:a - b\n
def isDigit(string):\n    try:\n        float(string)\n        return True\n    except:\n        return False
def max_multiple(divisor, bound):\n    return bound - (bound % divisor)
def validate_hello(greetings):\n    return any(x in greetings.lower() for x in ['hello','ciao','salut','hallo','hola','ahoj','czesc'])
def elections_winners(votes, k):\n    m = max(votes)\n    return sum(x + k > m for x in votes) or votes.count(m) == 1
import re\n\nREPLACMENTS  = ["BFPV", "CGJKQSXZ", "DT","L","MN","R"]\nER1, ER2     = "HW", "AEIOUY"\n\nTABLE_ERASE1 = str.maketrans("", "", ER1)\nTABLE_NUMS   = str.maketrans( ''.join(REPLACMENTS), ''.join( str(n)*len(elt) for n,elt in enumerate(REPLACMENTS, 1)) )\nTABLE_ERASE2 = str.maketrans("", "", ER2)\n\n\ndef formatSoundex(w):\n    s = w[0]*(w[0] in ER1+ER2) +  re.sub(r'(\d)\1*', r'\1', w.translate(TABLE_ERASE1).translate(TABLE_NUMS)).translate(TABLE_ERASE2)\n    return ((w[0] if s[0].isdigit() else s[0]) + s[1:] + "000")[:4]\n\ndef soundex(name):\n    return ' '.join(formatSoundex(w.upper()) for w in name.split(" "))
def high(x):\n    return max(x.split(), key=lambda k: sum(ord(c) - 96 for c in k))
def special_number(n):\n    return "Special!!" if max(str(n)) <= "5" else "NOT!!"
def func(l):\n    n = sum(l) // len(l)\n    return [n] + [format(n, f) for f in "box"]
def optimum_location(students, locations):\n    m = min(locations, key = lambda loc: sum(abs(loc['x'] - s[0]) + abs(loc['y'] - s[1]) for s in students))\n    return "The best location is number %d with the coordinates x = %d and y = %d" % (m['id'], m['x'], m['y'])\n
def sum_nested_numbers(a, depth=1):\n    return sum(sum_nested_numbers(e, depth+1) if type(e) == list else e**depth for e in a)
def riders(stations, lost):\n    stations = stations[:lost-1] + stations[lost-2:]\n    rider, dist = 1, 0\n    for i,d in enumerate(stations):\n        rider += (dist+d > 100) + (i == lost-2)\n        dist   = dist * (dist+d <= 100 and i != lost-2) + d\n    return rider
import re\n\ndef search_substr(full_text, search_text, allow_overlap=True):\n    if not full_text or not search_text: return 0\n    return len(re.findall(f'(?=({search_text}))' if allow_overlap else search_text, full_text))
from itertools import groupby\nfrom operator import itemgetter\nfrom os.path import commonprefix\n\nfirst = itemgetter(0)\n\ndef radix_tree(*words):\n    words = [w for w in words if w]\n    result = {}\n    for key, grp in groupby(sorted(words), key=first):\n        lst = list(grp)\n        prefix = commonprefix(lst)\n        result[prefix] = radix_tree(*(w[len(prefix):] for w in lst))\n    return result
def interpreter(code, tape):\n    tape = list(map(int, tape))\n    ptr = step = loop = 0\n    \n    while 0 <= ptr < len(tape) and step < len(code):\n        command = code[step]\n        \n        if loop:\n            if   command == "[": loop += 1\n            elif command == "]": loop -= 1\n        \n        elif command == ">": ptr += 1\n        elif command == "<": ptr -= 1\n        elif command == "*": tape[ptr] ^= 1        \n        elif command == "[" and tape[ptr] == 0: loop += 1\n        elif command == "]" and tape[ptr] == 1: loop -= 1\n    \n        step += 1 if not loop else loop // abs(loop)\n    \n    return "".join(map(str, tape))
# https://oeis.org/A000108\nfrom math import factorial as fac\ndef solve(n): return fac(2*n)//fac(n)//fac(n+1)
def contamination(text, char):\n  return char*len(text)
def sillycase(silly):\n    half = (len(silly) + 1) // 2\n    return silly[:half].lower() + silly[half:].upper()
def substring_test(first, second):\n    first = first.lower()\n    second = second.lower()\n\n    for i in range(len(first) - 2):\n        if first[i:i+2] in second:\n            return True\n    return False
def days_represented(a):\n    return len({i for x, y in a for i in range(x, y + 1)})
OPERATORS = {\n    '039': 'Golden Telecom', '050': 'MTS', '063': 'Life:)', '066': 'MTS',\n    '067': 'Kyivstar', '068': 'Beeline', '093': 'Life:)', '095': 'MTS',\n    '096': 'Kyivstar', '097': 'Kyivstar', '098': 'Kyivstar', '099': 'MTS'}\n\n\ndef detect_operator(num):\n    return OPERATORS.get(str(num)[1:4], 'no info')\n
def chess_knight(cell):\n    x, y = (ord(c) - ord(origin) for c, origin in zip(cell, 'a1'))\n    return sum(0 <= x + dx < 8 and 0 <= y + dy < 8 for dx, dy in (\n        (-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)))
def transform(num, base):\n    digits = []\n    \n    while num > 0:\n        num, remainder = divmod(num, base)\n        digits.append( remainder if remainder < 10 else "x" )\n    \n    return digits\n\n\ndef fouriest(i):\n    max_fours, base, best = 0, 5, [None, None]\n    \n    while i >= base**(max_fours):\n        digits = transform(i, base)\n        \n        if digits.count(4) > max_fours:\n            max_fours = digits.count(4)\n            best = base, "".join(map(str, digits[::-1]))\n        \n        base += 1\n    \n    base, transformed = best\n    return "%s is the fouriest (%s) in base %s" % (i, transformed, base)
def nth_char(words):\n    return ''.join(w[i] for i,w in enumerate(words))\n
def sort_my_string(s):\n    return '{} {}'.format(s[::2], s[1::2])
def points(R):\n    from math import sqrt\n    point = sum(int(sqrt(R * R - x * x)) for x in range(0,R+1)) * 4 + 1\n    return point
def calc(gamemap):\n    nr, nc = len(gamemap), len(gamemap[0])\n    def _i(ra, rb):\n        return ra*nr + rb\n    vs, ws = [0] * nr**2, [0] * nr**2\n    for s in range(nr + nc - 1):\n        for ra in range(max(0, s - nc + 1), min(s + 1, nr)):\n            for rb in range(ra, min(s + 1, nr)):\n                ws[_i(ra, rb)] = (\n                    gamemap[ra][s - ra] +\n                    (gamemap[rb][s - rb] if ra != rb else 0) +\n                    max(vs[_i(ra - da, rb - db)]\n                        for da in (0, 1) if da <= ra\n                        for db in (0, 1) if db <= rb))\n        vs, ws = ws, vs\n    return vs[-1]
from os.path import commonprefix\n\ndef string_suffix(s):\n    return sum(len(commonprefix([s, s[i:]])) for i in range(len(s)))
def number(lines):\n  return ['%d: %s' % v for v in enumerate(lines, 1)]
from math import ceil\n\ndef calculate_scrap(arr,n):\n    x = 50\n    for i in arr:\n        x /= (1-i/100)\n    return ceil(n*x)
def to_leet_speak(str):\n    return str.translate(str.maketrans("ABCEGHILOSTZ", "@8(36#!10$72"))
def pig_latin(word):\n    return word[1:]+word[0]+'ay' if len(word)>3 else word
def monkey_count(n):\n    return list(range(1,n+1))
import re\nfrom functools import reduce\n\n_ACRONYMS = {\n    'KPI':  'key performance indicators',\n    'EOD':  'the end of the day',\n    'EOP':  'the end of the day',    # snafu in the tests?\n    'TBD':  'to be decided',\n    'WAH':  'work at home',\n    'IAM':  'in a meeting',\n    'OOO':  'out of office',\n    'NRN':  'no reply necessary',\n    'CTA':  'call to action',\n    'SWOT': 'strengths, weaknesses, opportunities and threats'}\n\n_ACRONYM_PATTERN = re.compile(r'\b[A-Z]{3,}\b')\n_CAPITAL_PATTERN = re.compile(r'(?:\. |^)([a-z])')\n_CAPITAL_FIX = lambda match: '{}'.format(match.group(0).upper())\n\ndef acronym_buster(message):\n    message = reduce(lambda msg, item: msg.replace(*item), _ACRONYMS.items(), message)\n    try:\n        acro = next(_ACRONYM_PATTERN.finditer(message)).group(0)\n        return '{} is an acronym. I do not like acronyms. Please remove them from your email.'.format(acro)\n    except StopIteration:\n        return _CAPITAL_PATTERN.sub(_CAPITAL_FIX, message)
import re\n\ndef toUnderScore(name):\n    return re.sub("(?<=[^_-])_?(?=[A-Z])|(?<=[^\\d_])_?(?=\\d)", "_" , name)
def get_num(arr):\n    c,n,r=1,1,{}\n    arr.sort()\n    for a in arr: n*=a; r[a]= r[a]+1 if a in r else 1\n    for a in r: c*=r[a]+1 \n    return [n,c-1,arr[0],n//arr[0]]
def reverse_factorial(num):\n    c = f = 1\n    while f < num:\n        c += 1\n        f *= c\n    return 'None' if f > num else "%d!" %c
def scoring(array):\n    res = {}\n    \n    for e in array:\n        score = e["norm_kill"] * 100 + e["assist"] * 50 + e["damage"] // 2 +\\n        e["healing"] + 2 ** e["streak"] + e["env_kill"] * 500\n        \n        res[e["name"]] = score\n    \n    return sorted(res, key=res.get, reverse=True)
def solve(n):\n    a,b = '01'\n    for _ in range(n): a,b = a+b,a\n    return a
def leaderboard_sort(leaderboard, changes):\n    for change in changes:\n        name, delta = change.split()\n        idx = leaderboard.index(name)\n        leaderboard.insert(idx - int(delta), leaderboard.pop(idx))\n    return leaderboard
def score_hand(a):\n    n = sum(11 if x == "A" else 10 if x in "JQK" else int(x) for x in a)\n    for _ in range(a.count("A")):\n        if n > 21:\n            n -= 10\n    return n
def pattern(n):\n    res = []\n    for i in range(1, n + 1):\n        line = ' ' * (i - 1) + str(i % 10) + ' ' * (n - i)\n        res.append(line + line[::-1][1:])\n    return '\n'.join(res + res[::-1][1:])\n
def switch_lights(initial_states):\n    states = list(initial_states)\n    parity = 0\n    for i in reversed(range(len(states))):\n        parity ^= initial_states[i]\n        states[i] ^= parity\n    return states
import re\n\ndef ant_bridge(ants, terrain):\n    nGap = sum( 2 + len(gap) - (free == '-') for free,gap in re.findall(r'(-+)(\.+)', '-'+terrain) ) % len(ants)\n    return ants[-nGap:] + ants[:-nGap]
from fractions import gcd\n\ndef seq():\n    i, a, g = 1, 7, 1\n    while 1:\n        yield i, a, g\n        i += 1\n        g = gcd(i, a)\n        a += g\n\ndef count_ones(n):\n    return sum(g == 1 for _, (i, a, g) in zip(range(n), seq()))\n\ndef p(n):\n    seen = set()\n    for i, a, g in seq():\n        if not n: break\n        if g > 1 and g not in seen:\n            n -= 1\n            seen.add(g)\n            yield g\n\ndef max_pn(n):\n    return max(p(n))\n\ndef an_over(n):\n    for i, a, g in seq():\n        if not n: break\n        if g > 1:\n            n -= 1\n            yield a / i\n\ndef an_over_average(n):\n    return sum(an_over(n)) / n
def solve(arr):\n    r = []\n    for v in arr[::-1]:\n        if not r or r[-1] < v: r.append(v)\n    return r[::-1]
def evenize_word(w):\n    return w + w[-1] if len(w) % 2 else w\n\ndef evenator(s):\n    s = "".join(c for c in s if c.isspace() or c.isalnum())\n    return " ".join(evenize_word(w) for w in s.split())
def count_by(x, n):\n    return [i * x for i in range(1, n + 1)]
def get_sequence(o,s,st=1023456789):\n    li = []\n    for i in range([st,o][o>0 and o>st],9876543211):\n        i = str(i)\n        if i[0]!='0' and len(set(i))==10 : li.append(int(i))\n        if len(li)==s : break\n    return li 
def string_to_array(string):\n    return string.split(" ")
def iq_test(numbers):\n    e = [int(i) % 2 == 0 for i in numbers.split()]\n\n    return e.index(True) + 1 if e.count(True) == 1 else e.index(False) + 1\n
def get_candy_position(n, r, c, candy):\n    if candy > n: return [-1,-1,-1]\n    \n    linIdx = r*c - ( (candy-1) % (r*c) + 1 )\n    return [(candy-1)//(r*c) + 1, linIdx//c, linIdx%c]
def nth_fib(n):\n  a, b = 0, 1\n  for i in range(n-1):\n    a, b = b, a + b\n  return a
def magic_sum(arr):\n    return arr and sum(x for x in arr if x%2 and '3' in str(x)) or 0
def next_happy_year(year):\n    year += 1\n    \n    while len(set(str(year))) != 4:\n        year += 1\n    \n    return year
from functools import reduce\ndef permutation_position(perm):\n    return reduce(lambda t,c:t*26+ord(c)-97,perm,0)+1\n
def crossing_sum(matrix, row, col):\n    return sum(matrix[row]) + sum(line[col] for line in matrix) - matrix[row][col]
def between_extremes(numbers):\n    return max(numbers) - min(numbers)
from functools import reduce\ndef product(ar):\n    return reduce(lambda x,y:x*y, ar)\n\ndef something_acci(num_digits):\n    seq = [1, 1, 2, 2, 3, 3]\n    \n    while(len(str(seq[-1])) < num_digits):\n        seq.append(product(seq[-3:]) - product(seq[-6:-3]))\n    \n    return (len(seq), len(str(seq[-1])))\n
def get_count(words=""):\n    if not isinstance(words, str):\n        return {'vowels':0,'consonants':0}\n    letter = "".join([c.lower() for c in words if c.isalpha()])\n    vowel = "".join([c for c in letter if c in 'aeiou'])\n    consonant = "".join([c for c in letter if c not in 'aeiou']) \n    return {'vowels':len(vowel),'consonants':len(consonant)}
def premier_league_standings(teams):\n    dct = {1: teams[1]}\n    dct.update({i:t for i,t in enumerate(sorted(set(teams.values())-{teams[1]}), 2)})\n    return dct
def first_n_smallest(arr, n):\n    lst = sorted(enumerate(arr), key=lambda it: it[1])[:n]\n    lst.sort(key=lambda it:it[0])\n    return [v for _,v in lst]
def encode(string):\n    return ''.join(str(ord(c.upper())-64) if c.isalpha() else c for c in string)
def arr_check(arr):\n    return all(isinstance(el, list) for el in arr)
def first_tooth(lst):\n    gums = lst[:1] + lst + lst[-1:]\n    diff = [gums[i+1]*2 - gums[i] - gums[i+2] for i in range(len(lst))]\n    m = max(diff)\n    return diff.index(m) if diff.count(m) == 1 else -1\n
def sequence_classifier(arr):\n    if all(arr[i] == arr[i+1] for i in range(len(arr)-1)): return 5\n    if all(arr[i] <  arr[i+1] for i in range(len(arr)-1)): return 1\n    if all(arr[i] <= arr[i+1] for i in range(len(arr)-1)): return 2\n    if all(arr[i] >  arr[i+1] for i in range(len(arr)-1)): return 3\n    if all(arr[i] >= arr[i+1] for i in range(len(arr)-1)): return 4\n    return 0
from collections import Counter\nfrom itertools import count, islice\n\ndef performant_smallest(arr, n):\n    cnts = Counter(arr)\n    total = 0\n    for i, c in sorted(cnts.items()):\n        total += c\n        if total >= n:\n            break\n    available = count(c + n - total, -1)\n    it = (x for x in arr if x < i or (x == i and next(available) > 0))\n    return list(islice(it, n))
from math import log\n\ndef alex_mistakes(n, time):\n    return int(log((time - n * 6) / 5 +1, 2))\n
import re\nfrom random import sample\n\ndef mix_words(string):\n    return re.sub(\n        r'(?<=[a-zA-Z])([a-zA-Z]{2,})(?=[a-zA-Z])',\n        lambda match: ''.join(sample(match.group(1), len(match.group(1)))),\n        string)\n
def first_non_consecutive(arr):\n    if not arr: return 0\n    for i, x in enumerate(arr[:-1]):\n        if x + 1 != arr[i + 1]:\n            return arr[i + 1]
def get_char(c):\n    return chr(c)
pos = {"L4":0, "L3":1, "L2":2, "L1":3, "L0":4, "R0":4, "R1":5, "R2":6, "R3":7, "R4":8}\n\ndef tetris(arr):\n    current, res = [0]*9, 0\n    for x in arr:\n        p = pos[x[1:]]\n        current[p] += int(x[0])\n        if current[p] >= 30: break\n        y = min(current)\n        if y: current, res = [v-y for v in current], res+y\n    return res
MEMO = []\n\ndef sum_dif_rev(n):\n    i = MEMO[-1] if MEMO else 0\n    \n    while len(MEMO) < n:\n        i += 1\n        r = int(str(i)[::-1])\n        if i % 10 and r != i and (i + r) % abs(r - i) == 0:\n            MEMO.append(i)\n\n    return MEMO[n-1]
def get_animals_count(legs, heads, horns):\n    cows = horns // 2\n    rabbits = legs // 2 - cows - heads\n    chickens = heads - cows - rabbits\n    return dict(cows=cows, rabbits=rabbits, chickens=chickens)
def which_note(count):\n    return "A A# B C C# D D# E F F# G G#".split()[(count - 1) % 88 % 12]
def main(verb, noun): \n    return verb + noun
def find_a(lst,n):\n    if n<0: return find_a(lst[::-1], 3-n)\n    if n<4: return lst[n]\n    a,b,c,d = lst\n    for _ in range(n-3):\n        a,b,c,d = b, c, d, 6*d-10*c+6*b-a\n    return d
def count_positives_sum_negatives(arr):\n    if not arr: return []\n    pos = 0\n    neg = 0\n    for x in arr:\n      if x > 0:\n          pos += 1\n      if x < 0:\n          neg += x\n    return [pos, neg]
from collections import Counter\n\ndef added_char(s1, s2):  \n    return next((Counter(s2) - Counter(s1)).elements())
def valid_parentheses(string):\n    cnt = 0\n    for char in string:\n        if char == '(': cnt += 1\n        if char == ')': cnt -= 1\n        if cnt < 0: return False\n    return True if cnt == 0 else False
def reverse_list(x):\n    """Takes an list and returns the reverse of it. \n    If x is empty, return [].\n    \n    >>> reverse_list([1, 2, 3, 4])\n    [4, 3, 2, 1]\n    >>> reverse_list([])\n    []\n    """ \n    \n    return x[::-1]\n\ndef sum_list(x):\n    """Takes a list, and returns the sum of that list.\n    If x is empty list, return 0.\n\n    >>> sum_list([1, 2, 3, 4])\n    10\n    >>> sum_list([])\n    0\n    """\n\n    return sum(x)\n\ndef head_of_list(x):\n    """Takes a list, returns the first item in that list.\n    If x is empty, return None\n\n    >>> head_of_list([1, 2, 3, 4])\n    1\n    >>> head_of_list([]) is None\n    True\n    """ \n\n    return x[0] if x else None
def new_numeral_system(n):\n    a = [c for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' if c <= n]\n    return ['{} + {}'.format(a[i], a[-1-i]) for i in range((len(a) + 1) // 2)]
def flip_bit(value, bit_index):\n    return value ^ (1 << (bit_index-1))
def reverse_alternate(string):\n    return " ".join(y[::-1] if x%2 else y for x,y in enumerate(string.split()))
def sum_prod(strexpression):\n    return "%.5e" %(eval(strexpression))
def not_prime(x):\n    if x == 1: return True\n    for y in range(2, int(x ** 0.5) + 1):\n        if x % y == 0:\n            return True\n    return False\ndef odd_not_prime(n):\n    return sum(not_prime(x) for x in range(1, n + 1, 2))
def naughty_or_nice(data):\n    nice = 0\n    for month in data:\n        for day in data[month]:\n            nice += 1 if data[month][day] == "Nice" else -1\n    return "Nice!" if nice >= 0 else "Naughty!"\n
def max_tri_sum(numbers):\n    return sum(sorted(set(numbers))[-3:])
from itertools import cycle\n\ndef sumDig_nthTerm(initVal, patternL, nthTerm):\n    \n    for c, i in enumerate(cycle(patternL), 2):\n        initVal += i\n        \n        if c == nthTerm:\n            return sum(int(v) for v in str(initVal))
def self_converge(number):\n    n, cycle = str(number), set()\n    while n not in cycle:\n        cycle.add(n)\n        s = ''.join(sorted(n))\n        n = '%0*d' % (len(n), int(s[::-1]) - int(s))\n    return -1 if not int(n) else len(cycle)
from dateutil.parser import parse\n\ndef half_life(*persons):\n    p1,p2 = sorted(map(parse, persons))\n    return str( p2+(p2-p1) )[:10]
def sum_even_numbers(seq): \n    return sum(n for n in seq if not n % 2)
def filter_list(l):\n  'return a new list with the strings filtered out'\n  return [i for i in l if not isinstance(i, str)]\n
from math import ceil\n\ndef matrixfy(s):\n    if not s: return "name must be at least one letter"\n    x  = ceil(len(s)**.5)\n    it = iter(s.ljust(x*x,'.'))\n    return [ [next(it) for _ in range(x)] for _ in range(x)]
def sabb(stg, value, happiness):\n    sabbatical = (value + happiness + sum(1 for c in stg if c in "sabbatical")) > 22\n    return "Sabbatical! Boom!" if sabbatical else "Back to your desk, boy."
def penultimate(a):\n  return a[-2]\n
def solution(number):\n    A = (number - 1) // 3\n    B = (number - 1) // 5\n    C = (number - 1) // 15    \n    return [A - C, B - C, C]
def pagination_text(page_number, page_size, total_products):\n    first = page_size * (page_number - 1) + 1\n    last = min(total_products, first + page_size - 1)\n    return "Showing %d to %d of %d Products." % (first, last, total_products)
def find_outlier(int):\n    odds = [x for x in int if x%2!=0]\n    evens= [x for x in int if x%2==0]\n    return odds[0] if len(odds)<len(evens) else evens[0]\n
def is_audio(filename):\n    name, ext = filename.split('.')\n    return name.isalpha() and ext in {'mp3', 'flac', 'alac', 'aac'}\n\n\ndef is_img(filename):\n    name, ext = filename.split('.')\n    return name.isalpha() and ext in {'jpg', 'jpeg', 'png', 'bmp', 'gif'}
import re\ndef sum_from_string(string):\n    d = re.findall("\d+",string)\n    return sum(int(i) for i in d)
def identify_weapon(character):\n    tbl = {\n      "Laval"    : "Laval-Shado Valious",\n      "Cragger"  : "Cragger-Vengdualize",\n      "Lagravis" : "Lagravis-Blazeprowlor",\n      "Crominus" : "Crominus-Grandorius",\n      "Tormak"   : "Tormak-Tygafyre",\n      "LiElla"   : "LiElla-Roarburn"\n    }\n    \n    return tbl.get(character, "Not a character")
def sort_emotions(arr, order):\n    return sorted(arr, key=[':D',':)',':|',':(','T_T'].index, reverse=not order)
def sort_dict(d):\n  return sorted(d.items(), key=lambda x: x[1], reverse=True)
def fight_resolve(d, a):\n    return -1 if d.islower() == a.islower() else d if d.lower() + a.lower() in "ka sp as pk" else a
def sc(strng):\n    seen = set(strng)\n    return ''.join(a for a in strng if a.swapcase() in seen)\n
from itertools import combinations\nfrom math import gcd\n\n\ndef lcm_cardinality(n):\n    return 1 + sum(1 for a, b in combinations(divisors(n), 2) if lcm(a, b) == n)\n        \ndef divisors(n):\n    d = {1, n}\n    for k in range(2, int(n**0.5) + 1):\n        if n % k == 0:\n            d.add(k)\n            d.add(n // k)\n    return sorted(d)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)
def has_unique_chars(s):\n    return len(s) == len(set(s))
def get_weight(name):\n    return sum(ord(a) for a in name.swapcase() if a.isalpha())
def what_time_is_it(angle):\n    hr = int(angle // 30)\n    mn = int((angle % 30) * 2)\n    if hr == 0:\n        hr = 12\n    return '{:02d}:{:02d}'.format(hr, mn)
def count_pairs_int(d, m):\n    return sum(1 for i in range(1, m - d) if divisors(i) == divisors(i + d))\n\ndef divisors(n):\n    return sum(1 + (n // k != k) for k in range(1, int(n**0.5) + 1) if n % k == 0)\n
import re\n\ndef bears(n, s):\n    a = re.findall(r"B8|8B", s)\n    return ["".join(a), len(a) >= n]
def queue(queuers,pos):\n    return sum(min(queuer, queuers[pos] - (place > pos)) for place, queuer in enumerate(queuers))
import re\n\nHK_PHONE_NUMBER = '\d{4} \d{4}'\n\ndef is_valid_HK_phone_number(number):\n    return bool(re.match(HK_PHONE_NUMBER+'\Z',number))\n\ndef has_valid_HK_phone_number(number):\n    return bool(re.search(HK_PHONE_NUMBER,number))
def how_much_water(water, clothes, load):\n    if load > 2 * clothes:\n        return "Too much clothes"\n\n    if load < clothes:\n        return "Not enough clothes"\n\n    for i in range(load - clothes):\n        water *= 1.1\n\n    return round(water, 2)
def correct_tail(body, tail):\n    return body.endswith(tail)\n
def shortest_time(n, m, speeds):\n    lift, open, close, walk = speeds\n    return min(\n            # taking the elevator\n            abs(m - n) * lift + open + close + (n - 1) * lift + open,\n            # walking\n            (n - 1) * walk\n            )
import math\n\ndef cooking_time(needed_power, minutes, seconds, power):\n    t = math.ceil((60 * minutes + seconds) * int(needed_power[:-1]) / int(power[:-1]))\n    return '%d minutes %d seconds' %(t // 60, t - t // 60 * 60)
from collections import Counter\n\ndef solve(s):\n    return any(len(set(Counter(s.replace(c, '', 1)).values())) == 1 for c in s)
def cake_slice(n):\n    return (n ** 2 + n + 2) // 2
import math\ndef is_square(n):\n    return n > -1 and math.sqrt(n) % 1 == 0;
def count_correct_characters(c, g):\n    if len(c) != len(g): raise Exception('Error')\n    return sum(1 for i,j in zip(c,g) if i==j)
def rental_car_cost(d):\n    result = d * 40\n    if d >= 7:\n        result -= 50\n    elif d >= 3:\n        result -= 20\n    return result
def bubblesort_once(l):\n    l = l[:]\n    for i in range(len(l)-1):\n        if l[i] > l[i+1]:\n            l[i], l[i+1] = l[i+1], l[i]\n    return l
sb_primes = [2, 3, 5, 7, 13, 17, 19, 37, 73, 97, 109, 163, 193, 257, 433, 487, 577, 769, 1153, 1297, 1459, 2593, 2917, 3457, 3889, 10369, 12289, 17497, 18433, 39367, 52489, 65537, 139969, 147457, 209953, 331777, 472393, 629857, 746497, 786433, 839809, 995329, 1179649, 1492993]\n\ndef solve(x, y):\n    return sum(x <= p < y for p in sb_primes)
from collections import defaultdict\n\ndef solve(arr):\n    dct = defaultdict(list)\n    for i,fs in enumerate(map(frozenset, arr)):\n        dct[fs].append(i)\n    return sorted(sum(lst) for lst in dct.values() if len(lst) > 1)
def points(dice):\n    dice = sorted([int(d) for d in dice])\n    counts = [dice.count(i) for i in range(1, 7)]\n    if 5 in counts:\n        # GENERALA\n        return 50\n    if 4 in counts:\n        # POKER\n        return 40\n    if 3 in counts and 2 in counts:\n        # FULLHOUSE\n        return 30\n    if counts.count(1) == 5 and counts.index(0) not in [2, 3, 4]:\n        # STRAIGHT\n        return 20    \n    return 0
def abundant(h):\n    for n in range(h,0,-1):\n        s = sum(i for i in range(1,n) if n % i == 0)\n        if s > h:\n            return [[n],[s-n]]
def ipv4__parser(addr, mask):\n    return tuple(".".join(str(n) for n in a) for a in zip(*(((a & m), (a & ~m)) for a, m in zip((int(n) for n in addr.split(".")), (int(n) for n in mask.split("."))))))
def is_sorted_and_how(arr):\n    if arr == sorted(arr):\n        return 'yes, ascending' \n    elif arr == sorted(arr)[::-1]:\n        return 'yes, descending'\n    else:\n        return 'no'
def play_pass(s, n):\n\n    # Step 1, 2, 3\n    shiftText = ""\n    for char in s:\n        if char.isdigit():\n            shiftText += str(9 - int(char))\n        elif char.isalpha():\n            shifted = ord(char.lower()) + n\n            shiftText += chr(shifted) if shifted <= ord('z') else chr(shifted - 26)\n        else:\n            shiftText += char\n\n    # Step 4\n    caseText = ""\n    for i in range(len(shiftText)):\n        caseText += shiftText[i].upper() if i % 2 == 0 else shiftText[i].lower()\n\n    # Step 5\n    return caseText[::-1]\n\n
def sum_digits(number):\n    return sum(map(int, str(abs(number))))
trans = "abcdefghijklmnopqrstuvwxyz" * 2\ntrans += trans.upper() + "0123456789" * 2\n\ndef ROT135(input):\n    output = []\n    for c in input:\n        if c.isalpha():\n            c = trans[trans.index(c) + 13]\n        elif c.isdigit():\n            c = trans[trans.index(c) + 5]\n        output.append(c)\n    return "".join(output)
def rot13(message):\n    def decode(c):\n        if 'a' <= c <= 'z':\n            base = 'a'\n        elif 'A' <= c <= 'Z':\n            base = 'A'\n        else:\n            return c\n        return chr((ord(c) - ord(base) + 13) % 26 + ord(base))\n    return "".join(decode(c) for c in message)
def part(arr):\n    l = ["Partridge", "PearTree", "Chat", "Dan", "Toblerone", "Lynn", "AlphaPapa", "Nomad"]\n    s = len([i for i in arr if i in l])\n    return "Mine's a Pint"+"!"*s if s>0 else 'Lynn, I\'ve pierced my foot on a spike!!'
#Try to make your own gcd method without importing stuff\ndef mygcd(x,y):\n    #GOOD LUCK\n    while y:\n        x,y=y,x%y\n    return x
S, SS, SUM = [0], {0}, [0]\n\ndef rec(n):\n    while len(S)<=n:\n        v = S[-1] - len(S)\n        if v<= 0 or v in SS: v += 2*len(S)\n        S.append(v)\n        SS.add(v)\n        SUM.append(SUM[-1]+v)\n    return SUM[n-1]
def is_triangle(a, b, c):\n    return (a<b+c) and (b<a+c) and (c<a+b)\n
REV = {'6':'9', '9':'6'}\nBASE = set("01869")\n\ndef isReversible(n):\n    s = str(n)\n    return ( not (set(s) - BASE)                                                          # contains only reversible characters\n             and (not len(s)%2 or s[len(s)//2] not in "69")                               # does not contain 6 or 9 right in the middle (only for odd number of digits)\n             and all( REV.get(c, c) == s[-1-i] for i,c in enumerate(s[:len(s)//2]) ))     # symmetric repartition\n\ndef solve(a, b):\n    return sum( isReversible(n) for n in range(a,b) )
def findSquares(x,y):\n    return sum( (x-i) * (y-i) for i in range(y) )
BRACES = { '(': ')', '[': ']', '{': '}' }\n\ndef group_check(s):\n    stack = []\n    for b in s:\n        c = BRACES.get(b)\n        if c:\n            stack.append(c)\n        elif not stack or stack.pop() != b:\n            return False\n    return not stack
def letter_check(arr): \n    return set(arr[1].lower()) <= set(arr[0].lower())
def poly_multiply(p1, p2):\n  if not p1 or not p2: return []\n  n = len(p1) + len(p2) - 1\n  p = [0]*n\n  for i,a in enumerate(p1):\n    for j,b in enumerate(p2):\n      p[i + j] += a*b\n  return p
def get_percentage(sent, limit = 1000):\n    if not sent:\n        return "No e-mails sent"\n    elif sent >= limit:\n        return "Daily limit is reached"\n    return "{}%".format(int(sent * 100 / limit))
def rat_at(n):\n    if n == 0:\n        return 1, 1\n    a, b = rat_at((n - 1) // 2)\n    return (a, a + b) if n % 2 else (a + b, b)\n\ndef index_of(a, b):\n    if a == b == 1:\n        return 0\n    return 2 * index_of(a, b - a) + 1 if b > a else 2 * index_of(a - b, b) + 2
def friends(n):\n    return len(str(bin(n-1)))-3 if n >1 else 0
def is_centered(arr,n):\n    l = int(len(arr)/2) if len(arr)%2==0 else int((len(arr)-1)/2)\n    return any(sum(arr[i:-i])==n for i in range(1, l+1)) or sum(arr)==n
def first_non_repeating_letter(string):\n    string_lower = string.lower()\n    for i, letter in enumerate(string_lower):\n        if string_lower.count(letter) == 1:\n            return string[i]\n            \n    return ""
def uni_total(string):\n    return sum(map(ord, string))
import math\n\ndef divisors(n):\n    divs = [1]\n    for i in range(2,int(math.sqrt(n))+1):\n        if n%i == 0:\n            divs.extend([i,n//i])\n    divs.extend([n])\n    return list(set(divs))\n\ndef solve(p):\n    for d in sorted(divisors(p-1)):\n        if pow(10, d, p) == 1:\n            return "{}-sum".format(d)\n            break\n        elif pow(10, d, p) == p-1:\n            return "{}-altsum".format(d)\n            break\n
def descriptions(arr):\n    return 2**sum(a+1==b for a,b in zip(arr,arr[1:]))
def string_hash(s):\n    a = sum(ord(c) for c in s)\n    b = sum(ord(b) - ord(a) for a, b in zip(s, s[1:]))\n    c = (a | b) & (~a << 2)\n    return c ^ (32 * (s.count(" ") + 1))\n
from fractions import gcd\nimport re\n\n\nINSERTER = re.compile(r'(?<!\d)(?=[xyt])')\nFINDER   = re.compile(r'-?\d+')\n\n\ndef lcm(a,b):    return a*b//gcd(a,b)\ndef simplify(s): return INSERTER.sub('1', s.replace(' ',''))\n\n\ndef para_to_rect(*equations):\n    coefs = [ list(map(int, FINDER.findall(eq))) for eq in map(simplify, equations) ]\n    l     = lcm(coefs[0][1],coefs[1][1])\n    x,tx,cx, y,ty,cy = ( v*l//c[1] for c in coefs for v in c )\n    y, absY, c = -y, abs(y), cx-cy\n    \n    return "{}x {} {}y = {}".format(x if x!=1 else '',\n                                    '-' if y<0 else '+',\n                                    absY if absY!=1 else '',\n                                    c)
def super_sum(D, N):\n    #Number of possible combinations of D length from set [0...N]\n    num = pow(N,D)\n    #2x average value of a combination; 2x because dividing results in float and loss of precision\n    dblAvg = D*(N-1)\n    #Multiply number of possible combinations by the avergae value; now use true division to ensure result is an integer\n    return num*dblAvg//2
def no_repeat(s):\n    return next(c for c in s if s.count(c) == 1)
def solve(s):\n    t = None\n    while t != s:\n        t, s = s, s.replace('()', '')\n    return -1 if len(s) % 2 else sum(1 + (a == tuple(')(')) for a in zip(*[iter(s)] * 2))
BLACK = 0\nWHITE = 1\n# N, E, S, W\nCARDINALS = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\ndef ant(grid, column, row, n, direction=0):\n    r, c, d = row, column, direction\n    for _ in range(n):\n        # Handle direction change and current cell colour flip\n        if grid[r][c] == BLACK:\n            grid[r][c] = WHITE\n            d = (d + 3) % 4\n        else:\n            grid[r][c] = BLACK\n            d = (d + 1) % 4\n        # Apply movement to next grid position\n        r, c = r + CARDINALS[d][0], c + CARDINALS[d][1]\n        # Resize grid as required\n        if r < 0:\n            grid.insert(0, [0] * len(grid[0]))\n            r += 1\n        elif r == len(grid):\n            grid.append([0] * len(grid[0]))\n        elif c < 0:\n            grid = [[0] + row for row in grid]\n            c += 1\n        elif c == len(grid[0]):\n            grid = [row + [0] for row in grid]\n    return grid
def smallest(n):\n    x, y, m = 1, 1, 1\n    while m <= n:\n        if x % m == 0:\n            m += 1\n            y = int(x)\n        else:\n            x += y\n    return x\n
def repeater(string, n):\n    return string * n\n
cake=lambda c,d:['That was close!','Fire!'][c!=0and c*0.7<sum(ord(e)-96*(i%2!=0)for i,e in enumerate(d))]
def men_from_boys(arr):\n    men = []\n    boys = []\n    for i in sorted(set(arr)):\n        if i % 2 == 0:\n            men.append(i)\n        else:\n            boys.append(i)\n    return men + boys[::-1]
def min_sum(arr):\n    arr = sorted(arr)\n    return sum(arr[i]*arr[-i-1] for i in range(len(arr)//2))
def game(n):\n    return [n * n // 2] if n % 2 == 0 else [n * n, 2]
def lottery(s):\n    return "".join(dict.fromkeys(filter(str.isdigit, s))) or "One more run!"
def filter_numbers(string):\n    return "".join(x for x in string if not x.isdigit())
def survivor(n):\n    k = 2\n    while n >= k and n % k:\n        n -= n // k\n        k += 1\n    return n % k > 0
def greatest_distance(arr):\n    return max(i - arr.index(x) for i,x in enumerate(arr))
primes = [2, 3, 5, 7]\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    m = int(n ** .5) + 1\n    for p in primes:\n        if p >= m: break\n        if not n % p:\n            return False\n    q, d = primes[-1], 4 if (n + 1) % 6 else 2\n    while q < m:\n        q, d = q + d, 4 - d\n        if is_prime(q):\n            primes.append(q)\n            if not n % q:\n                return False\n    return True
def sc(width,length,gaps):\n    #your code here\n    a, b = divmod(2*width + 2*length - 4, gaps+1)\n    return 0 if b else a
import numpy as np\n\ndef sum_of_threes(n):\n    s=np.base_repr(n,3)\n    if '2' in s: return 'Impossible'\n    return '+'.join(['3^{}'.format(i) for i,d in enumerate(s[::-1]) if d=='1'][::-1])\n
def solomons_quest(arr):\n    pos, lvl = [0,0], 0\n    for dilat,dir,dist in arr:\n        lvl += dilat\n        pos[dir in [0,2]] += dist * 2**lvl * (-1)**( dir in [2,3] )\n    return pos
def find_dup(arr):\n    return sum(arr) - sum(range(1, max(arr)+1))
def highest_value(a, b):\n    return max(a, b, key=lambda s: sum(map(ord, s)))
import re\n\ndef is_alt(s):\n    return not re.search('[aeiou]{2}|[^aeiou]{2}',s)
def persistence(n):\n    n = str(n)\n    count = 0\n    while len(n) > 1:\n        p = 1\n        for i in n:\n            p *= int(i)\n        n = str(p)\n        count += 1\n    return count\n    # your code\n
def pairwise(arr, n):\n    s=[]\n    for i in range(len(arr)-1):\n        for j in range(i+1,len(arr)):\n            if j in s or i in s: continue\n            if arr[i]+arr[j] ==n:\n                s.append(i)\n                s.append(j)\n    return sum(s)
from bisect import bisect_left, bisect\n\nss = set('13579')\nns = [i ** 3 for i in range(1, int((10 ** 17) ** (1/3)) + 3, 2) if set(str(i ** 3)) <= ss]\nns = [-n for n in ns[::-1]] + ns\n\ndef odd_dig_cubic(a, b):\n    return ns[bisect_left(ns, a):bisect(ns, b)]
def next_version(version):\n    ns = version.split('.')\n    i = len(ns) - 1\n    while i > 0 and ns[i] == '9':\n        ns[i] = '0'\n        i -= 1\n    ns[i] = str(int(ns[i]) + 1)\n    return '.'.join(ns)
from itertools import groupby\n\ndef merge(line):\n    merged = []\n    for k,g in groupby( v for v in line if v ):\n        g = list(g)\n        n,r = divmod(len(g),2)\n        if n: merged.extend([k*2]*n)\n        if r: merged.append(k)\n    return merged + [0]*(len(line)-len(merged))
from bisect import bisect\n\ndef sieve(n):\n    sieve, primes = [0]*(n+1), []\n    for i in range(2, n+1):\n        if not sieve[i]:\n            primes.append(i) \n            for j in range(i**2, n+1, i): sieve[j] = 1\n    return primes\n\nPRIMES = sieve(1000000)\n\ndef summationOfPrimes(n):\n    return sum(PRIMES[:bisect(PRIMES, n)])
def top3(*args):\n    return [item[0] for item in sorted(zip(*args), key=lambda x: x[1]*x[2], reverse=True)[:3]]
def simplify(n):\n    for d in range(int(n ** .5), 0, -1):\n        if not n % d ** 2: break\n    if d*d == n: return '%d' % d\n    elif d == 1: return 'sqrt %d' % n\n    else: return '%d sqrt %d' % (d, n // d ** 2)\n\ndef desimplify(s):\n    x, _, y = s.partition('sqrt')\n    return int(x or '1') ** 2 * int(y or '1')
def squares(x,n):\n    return [x**(2**i) for i in range(n)]
import re\nfrom collections import deque\n\ndef vowel_shift(text,n):\n    try:\n        tokens = re.split(r'([aeiouAEIOU])', text)\n        if len(tokens) > 1:\n            vowels = deque(tokens[1::2])\n            vowels.rotate(n)\n            tokens[1::2] = vowels\n        return ''.join(tokens)\n    except TypeError:\n        return None
def find_missing(sequence):\n    t = sequence\n    return (t[0] + t[-1]) * (len(t) + 1) / 2 - sum(t)\n
from itertools import combinations\nfrom collections import defaultdict\n\ndef ulam_sequence(u0, u1, n):\n    seq = [u0, u1, u0 + u1]\n    \n    while len(seq) < n:\n        candidates = defaultdict(int)\n        \n        for a, b in combinations(seq, 2):\n            candidates[a + b] += 1\n        \n        for num, pairs in sorted(candidates.items()):\n            if num > seq[-1] and pairs == 1:\n                seq.append(num)\n                break\n    \n    return seq
def caffeineBuzz(n):\n    if n%12 == 0:\n        return "CoffeeScript"\n    elif n%6 == 0:\n        return "JavaScript"\n    elif n%3 == 0:\n        return "Java"\n    else:\n        return "mocha_missing!"
def palindrome(num):\n    if type(num) is not int or num < 0:\n        return "Not valid"\n    else:\n        c =0\n        for i in range(num,num**2):\n            if is_pal(i):\n                return i\n            elif is_pal(i-c):\n                return i-c\n            else:\n                c +=2\n    \ndef is_pal(n):\n    return n > 10 and n == int(str(n)[::-1])
def cannons_ready(gunners):\n  return 'Shiver me timbers!' if 'nay' in gunners.values() else 'Fire!'
from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef three_details(n):\n    if n <= 3: return n==3\n    q, r = divmod(n, 2)\n    return three_details(q) + three_details(q+r)
def sum_cubes(n):\n    return sum(i**3 for i in range(0,n+1))
import ipaddress as ip\n\ndef ipsubnet2list(subnet):\n    try: return list(map(str,ip.ip_network(subnet).hosts()))\n    except: pass
def largest_rect(h):\n    st=[]; m=0; i=0\n    while i<len(h):\n        if len(st)==0 or h[st[-1]]<=h[i]: st.append(i); i+=1\n        else: l=st.pop(); m=max(m, h[l]*(i if len(st)==0 else i-st[-1]-1))\n    while len(st)>0: l=st.pop(); m=max(m, h[l]*(i if len(st)==0 else i-st[-1]-1))\n    return m
def process_data(data):\n    r = 1\n    for d in data:\n        r *= d[0] - d[1]\n    return r
from collections import Counter\n\ndef validate_word(word):\n    return len(set(Counter(word.lower()).values())) == 1
def unite_unique(*arg):\n    res = []\n    for arr in arg:\n        for val in arr:\n            if not val in res: res.append(val)\n    return res
def array_info(x):\n    if not x:\n        return 'Nothing in the array!'\n    return [\n        [len(x)],\n        [sum(isinstance(i, int) for i in x) or None],\n        [sum(isinstance(i, float) for i in x) or None],\n        [sum(isinstance(i, str) and not i.isspace() for i in x) or None],\n        [sum(isinstance(i, str) and i.isspace() for i in x) or None],\n    ]
import re\n\ndef spiner(s,p):\n    return ( s[::-1]   if len(s) > 6 or s.lower().count('t') > 1\n        else s.upper() if len(s) == 2 or p == ','\n        else '0'       if len(s) == 1\n        else s) + p\n\ndef spin_solve(sentence):\n    return re.sub(r"((?:\w|['-])+)(\W)?", lambda m: spiner(m.group(1), m.group(2) or ''), sentence)
def count_number(n, x):\n    return len([j for j in range(1,n+1) if x%j==0 and x/j <= n]) 
def every(lst, n=1, start=0):\n    return lst[start::n]
from calendar import month_abbr\nfrom datetime import datetime \ndef solve(a,b):\n  res = [month_abbr[month]\n      for year in range(a, b+1) \n      for month in [1,3,5,7,8,10,12] \n      if datetime(year, month, 1).weekday() == 4]\n  return (res[0],res[-1], len(res))
def game_winners(gryffindor, slytherin):\n    g, s = (team[0] + 150 * (team[1] == 'yes') for team in [gryffindor, slytherin])\n    return 'Gryffindor wins!' if g > s else 'Slytherin wins!' if s > g else "It's a draw!"
def maxlen(s1, s2):\n    sm, lg = sorted((s1, s2))\n    return min(max(lg / 3, sm), lg / 2)
def equable_triangle(a, b, c):\n    p = a + b + c\n    ph = p / 2\n    return p * p == ph * (ph - a) * (ph - b) * (ph - c)
def count_targets(n, sequence):\n    return sum(a == b for a, b in zip(sequence, sequence[n:]))
def get_size(w, h, d):\n    area = 2*(w*h + h*d + w*d)\n    volume = w*h*d\n    return [area, volume]
def comp(array1, array2):\n    try:\n        return sorted([i ** 2 for i in array1]) == sorted(array2)\n    except:\n        return False
def dont_give_me_five(start, end):\n    return sum('5' not in str(i) for i in range(start, end + 1))
from functools import reduce\n\ndef cup_and_balls(b, arr):\n    return reduce(lambda x, y: y[1] if x == y[0] else y[0] if x == y[1] else x, arr, b)
def remove_smallest(numbers):\n    a = numbers[:]\n    if a:\n        a.remove(min(a))\n    return a
def complexSum(arr, sub={'1i': 'i', '-1i': '-i', '0i': '0'}):\n    s = str(sum(complex(x.replace('i', 'j')) for x in arr)).replace('j', 'i')\n    s = s.strip('()')\n    s = s.replace('+0i', '')\n    return sub.get(s, s)    
def palindrome(num):\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    s = str(num)\n    return sum(sum(s[i:i+n] == s[i:i+n][::-1] for i in range(len(s)-n+1)) for n in range(2, len(s)+1))\n
def bits_war(numbers):\n    odd, even = 0, 0\n    for number in numbers:\n        if number % 2 == 0:\n            if number > 0:\n                even += bin(number).count('1')\n            else:\n                even -= bin(number).count('1')\n        else:\n            if number > 0:\n                odd += bin(number).count('1')\n            else:\n                odd -= bin(number).count('1')\n    return 'odds win' if odd > even else 'evens win' if even > odd else 'tie'
def reverse_letter(s):\n  return ''.join([i for i in s if i.isalpha()])[::-1]\n\n
def a(n):\n    """\n    """\n    if n % 2 != 0:\n        n = n - 1\n    if n < 4:\n        return ''\n    side = " " * (n - 1)\n    li = [side + "A" + side]\n    for i in range(1, n):\n        side = side[1:]\n        middle = "A " * (i - 1) if i == (n / 2) else "  " * (i - 1)\n        li.append(side + "A " + middle + "A" + side)\n    return "\n".join(li)
def convert_to_mixed_numeral(parm):\n    a, b = list(map(int, parm.split('/')))\n    d, r = divmod(abs(a), b)\n    s = (0 < a) - (a < 0)\n    return parm if d == 0 else ('{}' + ' {}/{}' * (r != 0)).format(d * s, r, b)\n
def goldbach(n):\n    if n < 2:\n        return []\n    if n == 4:\n        return [[2, 2]]\n    l = n - 2\n    sieve = [True] * (l // 2)\n    for i in range(3, int(l**0.5) + 1, 2):\n        if sieve[i // 2]:\n            sieve[i * i // 2::i] = [False] * ((l - i * i - 1) // (2 * i) + 1)\n    primes = [(2 * i + 1) for i in range(1, l // 2) if sieve[i]]\n    return [[p, n - p] for p in primes if (n - p) in primes and p <= (n - p)]\n
def num_blocks(w, l, h):\n    return w*l*h + (w+l)*h*(h-1)/2 + h*(h-1)*(2*h-1)/6
def make_sentences(parts):\n    return ' '.join(parts).replace(' ,', ',').strip(' .') + '.'
from bisect import bisect\nfrom statistics import mean\n\n\ndef calculate_grade(scores):\n    return 'FDCBA'[bisect([60, 70, 80, 90], mean(scores))]\n
from datetime import datetime\n\ndef to12hourtime(t):\n    return datetime.strptime(t, '%H%M').strftime('%I:%M %p').lstrip('0').lower()
squares_needed = int.bit_length
def filter_even_length_words(words):\n    return [word for word in words if len(word) % 2 == 0]
def tongues(code):\n    AsT = ""\n    for i in code:\n        if i == "i":\n            AsT = AsT + "o"\n        elif i == "t":\n            AsT = AsT + "n"\n        elif i == "a":\n            AsT = AsT + "e"\n        elif i == "d":\n            AsT = AsT + "r"\n        elif i == "f":\n            AsT = AsT + "g"\n        elif i == "y":\n            AsT = AsT + "u"\n        elif i == "c":\n            AsT = AsT + "l"\n        elif i == "s":\n            AsT = AsT + "h"\n        elif i == "w":\n            AsT = AsT + "m"\n        elif i == "v":\n            AsT = AsT + "k"\n        elif i == "q":\n            AsT = AsT + "z"\n        elif i == "p":\n            AsT = AsT + "b"\n        elif i == "j":\n            AsT = AsT + "x"\n        elif i == "o":\n            AsT = AsT + "i"\n        elif i == "n":\n            AsT = AsT + "t"\n        elif i == "e":\n            AsT = AsT + "a"\n        elif i == "r":\n            AsT = AsT + "d"\n        elif i == "g":\n            AsT = AsT + "f"\n        elif i == "u":\n            AsT = AsT + "y"\n        elif i == "l":\n            AsT = AsT + "c"\n        elif i == "h":\n            AsT = AsT + "s"\n        elif i == "m":\n            AsT = AsT + "w"\n        elif i == "k":\n            AsT = AsT + "v"\n        elif i == "z":\n            AsT = AsT + "q"\n        elif i == "b":\n            AsT = AsT + "p"\n        elif i == "x":\n            AsT = AsT + "j"\n        elif i == "I":\n            AsT = AsT + "O"\n        elif i == "T":\n            AsT = AsT + "N"\n        elif i == "A":\n            AsT = AsT + "E"\n        elif i == "D":\n            AsT = AsT + "R"\n        elif i == "F":\n            AsT = AsT + "G"\n        elif i == "Y":\n            AsT = AsT + "U"\n        elif i == "C":\n            AsT = AsT + "L"\n        elif i == "S":\n            AsT = AsT + "H"\n        elif i == "W":\n            AsT = AsT + "M"\n        elif i == "V":\n            AsT = AsT + "K"\n        elif i == "Q":\n            AsT = AsT + "Z"\n        elif i == "P":\n            AsT = AsT + "B"\n        elif i == "J":\n            AsT = AsT + "X"\n        elif i == "O":\n            AsT = AsT + "I"\n        elif i == "N":\n            AsT = AsT + "T"\n        elif i == "E":\n            AsT = AsT + "A"\n        elif i == "R":\n            AsT = AsT + "D"\n        elif i == "G":\n            AsT = AsT + "F"\n        elif i == "U":\n            AsT = AsT + "Y"\n        elif i == "L":\n            AsT = AsT + "C"\n        elif i == "H":\n            AsT = AsT + "S"\n        elif i == "M":\n            AsT = AsT + "W"\n        elif i == "K":\n            AsT = AsT + "V"\n        elif i == "Z":\n            AsT = AsT + "Q"\n        elif i == "B":\n            AsT = AsT + "P"\n        elif i == "X":\n            AsT = AsT + "J"\n        else:\n            AsT = AsT + i    \n    return AsT
def sequence_sum(start, end, step):\n    return sum(range(start, end+1, step))
def direction_in_grid(n, m):\n    return "LR"[n%2] if m >= n else "UD"[m%2]\n
def find_average(array):\n    return sum(array) / len(array) if array else 0
from collections import Counter\ndef palindrome(num):\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    return num > 10 and sum(1 for v in Counter(map(int, str(num))).values() if v % 2) <= 1
def explode(arr):  \n    return [arr] * sum(v for v in arr if isinstance(v,int)) or 'Void!'
def covfefe(s):\n    return s.replace("coverage","covfefe") if "coverage" in s else s+" covfefe"
import re\n\npattern = re.compile('o(.*?)d(.*?)d')\n\ndef odd(s):\n    n = 0\n    while pattern.search(s):\n        n += 1\n        s = pattern.sub(r'\1\2', s, count=1)\n    return n
from collections import Counter\nimport re\n\ndef solve(files):\n    c = Counter(re.match('.*(\.[^.]+)$', fn).group(1) for fn in files)\n    m = max(c.values(),default=0)\n    return sorted(k for k in c if c[k] == m)
DIGITS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"\n\ndef base64_to_base10(string):\n    return sum(DIGITS.index(digit) * 64**i\n               for i, digit in enumerate(string[::-1]))
from hashlib import sha256\nfrom itertools import permutations\n\n\ndef sha256_cracker(hash, chars):\n    for p in permutations(chars, len(chars)):\n        current = ''.join(p)\n        if sha256(current.encode('utf-8')).hexdigest() == hash:\n            return current\n
def difference_of_squares(x):\n    r = range(1,x+1,1)\n    return (sum(r) ** 2) - (sum( z**2 for z in r))
def merge_arrays(a, b): \n    return sorted(set(a + b))
def solve(n,k):\n    maxGcd = 2*n // (k * (k+1))\n    for gcd in range(maxGcd, 0, -1):\n        last = n-gcd * k*(k-1)//2\n        if not last % gcd:\n            return [gcd*x if x != k else last for x in range(1,k+1)]\n    return []
import re\n\ndef solve(eq):\n    return ''.join(reversed(re.split(r'(\W+)', eq)))
def make_upper_case(s): return s.upper()
def insert_missing_letters(s):\n    s, lst, found, inside = s.lower(), [], set(), set(s.upper())\n    for a in s:\n        lst.append(a if a in found else\n                   a + ''.join(c for c in map(chr, range(ord(a)-31,91)) if c not in inside) )\n        found.add(a)\n        \n    return ''.join(lst)
def calculate_probability(n):\n    return round(1 - (364 / 365) ** (n * (n - 1) / 2), 2)
def series_sum(n):\n    return '{:.2f}'.format(sum(1.0/(3 * i + 1) for i in range(n)))
def pattern(n, *x):\n    if n < 1:\n        return ""\n    x = x[0] if x and x[0] > 0 else 1\n    result = []\n    for i in range(1, n + 1):\n        line = " " * (i - 1) + str(i % 10) + " " * (n - i)\n        result.append((line + line[::-1][1:]) + (line[1:] + line[::-1][1:]) * (x - 1))\n    return "\n".join(result + result[::-1][1:])
def mark_spot(n):\n    if not isinstance(n, int) or not n%2 or n<1: return '?'\n\n    spots = [[' ']*n for _ in range(n)]\n    for i,row in enumerate(spots):\n        row[i],row[-1-i] = 'XX'\n\n    return '\n'.join( ' '.join(row).rstrip() for row in spots+[""] )
def robot_walk(a):\n  i=3\n  while(i<len(a) and a[i] < a[i-2]): i+=1\n  return i<len(a)\n
def calc_tip(p, r):\n    if p % 10 < 5:\n        p //= 10\n    else:\n        p = p // 10 + 1\n    if r == 1:\n        tip = p + 1\n    elif r == 0:\n        tip = p - 1\n    else:\n        tip = int(p/2) - 1\n    return tip if tip >= 0 else 0
import re\n\ndef apparently(string):\n    return re.sub(r'(?<=\b(and|but)\b(?! apparently\b))', ' apparently', string)
from math import log2\n\ndef operation(a,b, n = 0):\n    while log2(a) % 1:\n        n += 1\n        a //= 2\n    return n + abs(log2(a/b))
def tops(msg):\n    i,d,s = 1,5, ''\n    while i < len(msg):\n        s += msg[i]\n        i += d\n        d += 4\n    return s[::-1]
def min_dot(a, b):\n    return sum(x * y for (x, y) in zip(sorted(a), sorted(b, reverse = True)))
from itertools import accumulate\n\nCHARACTERS = {\n    "warrior": (4, [11, 8, 12, 13, 13, 11, 9, 9]),\n    "knight": (5, [14, 10, 10, 11, 11, 10, 9, 11]),\n    "wanderer": (3, [10, 11, 10, 10, 14, 12, 11, 8]),\n    "thief": (5, [9, 11, 9, 9, 15, 10, 12, 11]),\n    "bandit": (4, [12, 8, 14, 14, 9, 11, 8, 10]),\n    "hunter": (4, [11, 9, 11, 12, 14, 11, 9, 9]),\n    "sorcerer": (3, [8, 15, 8, 9, 11, 8, 15, 8]),\n    "pyromancer": (1, [10, 12, 11, 12, 9, 12, 10, 8]),\n    "cleric": (2, [11, 11, 9, 12, 8, 11, 8, 14]),\n    "deprived": (6, [11, 11, 11, 11, 11, 11, 11, 11]),\n}\nREQUIRED_SOULS = list(\n    accumulate(\n        [0, 0, 673, 690, 707, 724, 741, 758, 775, 793, 811, 829]\n        + [\n            round(pow(x, 3) * 0.02 + pow(x, 2) * 3.06 + 105.6 * x - 895)\n            for x in range(12, 1000)\n        ]\n    )\n)\n\ndef souls(character, build):\n    starting_level, stats = CHARACTERS[character]\n    delta = sum(b - s for b, s in zip(build, stats))\n    level = starting_level + delta\n    souls = REQUIRED_SOULS[level] - REQUIRED_SOULS[starting_level]\n    return f"Starting as a {character}, level {level} will require {souls} souls."
d, polydivisible, arr = 1, [], list(range(1, 10))\nwhile arr:\n    d += 1\n    polydivisible.extend(arr)\n    arr = [n for x in arr for n in\n           range(-(-x*10 // d) * d, (x+1) * 10, d)]\n\ndef next_num(n):\n    from bisect import bisect\n    idx = bisect(polydivisible, n)\n    if idx < len(polydivisible):\n        return polydivisible[idx]
def convert_my_dollars(usd, currency):\n    curs = {\n        'Ar':478, 'Ba':82, 'Cr':6, 'Cz':21, 'Do':48, 'Ph':50,\n        'Uz':10000, 'Ha':64, 'Gu':7, 'Ta':32, 'Ro':4, 'Eg':18,\n        'Vi':22573, 'In':63, 'Ni':31, 'Ve':10, 'No':8, 'Ja':111,\n        'Sa':3, 'Th':32, 'Ke':102, 'So':1059}\n    return f"You now have {usd*curs.get(currency[:2],0)} of {currency}."
def odd_ball(arr):\n    return arr.index("odd") in arr
FRACTIONS = " . : :. :: :.: S S. S: S:. S:: S:.:".split(" ")\nUNITS     = " I II III IV V VI VII VIII IX"      .split(" ")\nTENS      = " X XX XXX XL L LX LXX LXXX XC"      .split(" ")\nHUNDREDS  = " C CC CCC CD D DC DCC DCCC CM"      .split(" ")\nTHOUSANDS = " M MM MMM MMMM MMMMM"               .split(" ")    \n\n\ndef roman_fractions(n, f=0):\n    return ( "NaR"  if n < 0 or n > 5000 or f < 0 or f > 11\n                    else "N" if n + f == 0\n                    else  THOUSANDS [n//1000]\n                        + HUNDREDS  [n%1000//100]\n                        + TENS      [n%100//10]\n                        + UNITS     [n%10]\n                        + FRACTIONS [f] )
def greet(name):\n    if name == "Johnny":\n        return "Hello, my love!"\n    return "Hello, {name}!".format(name=name)
def shorten_to_date(long_date):\n    return long_date.split(',')[0]
from functools import reduce\nfrom itertools import cycle\nfrom operator import add, truediv, mul, sub\n\n\ndef do_math(s):\n    xs = sorted(s.split(), key=lambda x: next(c for c in x if c.isalpha()))\n    xs = [int(''.join(filter(str.isdigit, x))) for x in xs]\n    ops = cycle([add, sub, mul, truediv])\n    return round(reduce(lambda a, b: next(ops)(a, b), xs))
def pattern(n):\n    return '\n'.join(str(i)*i for i in range(1,n+1,2))
import math\ndef solution(n):\n    d=0\n    if n - 0.25< math.floor(n):\n        d=math.floor(n)\n    elif n - 0.75< math.floor(n):\n        d=math.floor(n)+0.5\n    else:\n        d=math.ceil(n)\n    return d
def difference_in_ages(ages):\n    # your code here\n    return (min(ages) , max(ages) , max(ages) - min(ages))
def diagonal(m):\n    P = sum(m[i][i] for i in range(len(m)))\n    S = sum(m[i][-i-1] for i in range(len(m)))\n    if P > S:\n        return "Principal Diagonal win!"\n    elif S > P:\n        return "Secondary Diagonal win!"\n    else:\n        return 'Draw!'\n
from collections import defaultdict\ndef group_in_10s(*args):\n    if not args: return []\n    tens = defaultdict(list)\n    for n in sorted(args): tens[n//10].append(n)\n    return [tens.get(d, None) for d in range(max(tens) + 1)]
def area_largest_square(r):\n    return 2 * r ** 2
import math\ndef tankvol(h, d, vt):\n    r = d/2.0\n    if h == r: return vt/2     # is the tank half full?\n    half = h>r                 # is it more than half full\n    h = d-h if half else h     # adjust h accordingly\n    a = r-h                    # perpendicular intercept of the chord\n    b = math.sqrt(r**2-a**2)   # half the chord\n    t = 2*math.asin(b/r)       # the angle the chord sweeps out\n    A = r**2*t/2 - b*a         # the area of the segment\n    v = vt*A/(math.pi*r**2)    # the volume of the segment\n    return int(vt-v) if half else int(v)\n    \n
import re\n\ndef hungry_seven(arr):\n    ss,s = '', ''.join(map(str,arr))\n    while ss!=s:\n        ss,s = s,re.sub(r'(7+)(89)',r'\2\1', s)\n    return list(map(int,s))
def add(s1, s2):\n    return sum(ord(x) for x in s1+s2)
def array_leaders(numbers):\n    return [n for (i,n) in enumerate(numbers) if n>sum(numbers[(i+1):])]\n
def find_slope(points):\n    x1, y1, x2, y2 = points\n    if x2 - x1 == 0:\n        return "undefined"\n    return str((y2 - y1) // (x2 - x1))
def solve(n):\n    print('starting with {0}'.format(n), flush=True)\n\n    def is_prime(p):\n        if p % 2 == 0 :\n            return False\n        for x in range(3,int(p**.5)):\n            if p % x == 0:\n                return False\n        return True\n        #return not any([p%x==0 for x in range(3,int(p**.5))])\n\n    if is_prime(n):\n        return n\n    step = (n%2) + 1\n    while 1:\n        if is_prime(n-step):\n            return n-step\n        elif is_prime(n+step):\n            return n+step\n        else:\n            step += 2\n    return None\n\n
from math import ceil\n\ndef get_participants(h):\n    return int(ceil(0.5 + (0.25 + 2 * h) ** 0.5))\n
statements = {\n    'george saint pierre': "I am not impressed by your performance.",\n    'conor mcgregor': "I'd like to take this chance to apologize.. To absolutely NOBODY!"\n}\n\ndef quote(fighter):\n    return statements[fighter.lower()]
import re\n\ndef happy_g(s):\n    return not re.search(r'(?<!g)g(?!g)',s)
def types(x):\n    return type(x).__name__
def century(year):\n    return (year + 99) // 100
def string_clean(s):\n    return ''.join(x for x in s if not x.isdigit())
def calculate_1RM(w, r):\n    if r == 0: return 0\n    if r == 1: return w\n    \n    return round(max([\n      w * (1 + r / 30),                 # Epley\n      100 * w / (101.3 - 2.67123 * r),  # McGlothin\n      w * r**0.10                       # Lombardi\n      ]))
def remove(text, what):\n    for char in what:\n        text = text.replace(char,'',what[char])\n    return text
def balancedNum(n):\n    s = str(n)\n    l = (len(s)-1)//2\n    same = len(s) < 3 or sum(map(int, s[:l])) == sum(map(int, s[-l:]))\n    return "Balanced" if same else "Not Balanced"\n\nbalanced_num = balancedNum
def largest(n, xs):\n  "Find the n highest elements in a list"\n  \n  return sorted(xs)[-n:];
def get_mean(arr,x,y):\n    if 1 < x <= len(arr) and 1 < y <= len(arr):\n       return (sum(arr[:x])/x+sum(arr[-y:])/y)/2\n    return -1
import re\nbase = "too?|fore?|oo|be|are|you|please|people|really|have|know|s|[.,']".split('|')\nnoob = "2|4|00|b|r|u|plz|ppl|rly|haz|no|z|".split('|')\n\ndef n00bify(text):\n    for b, n in zip(base, noob):\n        keep_casing = lambda m: n.upper() if m.group().isupper() else n\n        text = re.sub(b, keep_casing, text, flags=re.I)\n    if not text: return ''\n    if text[0] in 'hH': text = text.upper()\n    if text[0] in 'wW': text = 'LOL ' + text\n    if len(re.sub('[!?]', '', text)) >= 32: text = re.sub('\A(LOL |)', r'\1OMG ', text)\n    text = re.sub('([?!])', r'\1' * len(text.split()), text).replace('!!', '!1')\n    return ' '.join(w.upper() if i%2 else w for i, w in enumerate(text.split()))
def is_prime_happy(n):\n    return n in [5, 25, 32, 71, 2745, 10623, 63201, 85868]
def solve(a, b):\n    if len(a) is 1:\n        return b.count(a)\n    index = [x for x in range(len(b)-1) if b[x] is a[0]]\n    return sum(solve(a[1:], b[x+1:]) for x in index)
def calc_ms(n):\n  return 20 ** n
def better_than_average(class_points, your_points):\n    return your_points > sum(class_points) / len(class_points)
from math import factorial as fact\n\ndef sum_arrangements(n):\n    s = str(n)\n    perms   = fact(len(s)-1)\n    coefAll = int('1'*len(s))\n    return coefAll*perms*sum(map(int,s))
def unlock(message): return message.lower().translate(message.maketrans("abcdefghijklmnopqrstuvwxyz","22233344455566677778889999"))
def order_weight(_str):\n    return ' '.join(sorted(sorted(_str.split(' ')), key=lambda x: sum(int(c) for c in x)))
from math import cos, sin, radians\n\ndef coordinates(deg, r, precision=10):\n    x, y = r * cos(radians(deg)), r * sin(radians(deg))\n    return round(x, precision), round(y, precision)
def unused_digits(*args):\n    return "".join(number for number in "0123456789" if number not in str(args))
def make_acronym(phrase):\n    try:\n        return ''.join(word[0].upper() if word.isalpha() else 0 for word in phrase.split())\n    except AttributeError:\n        return 'Not a string'\n    except TypeError:\n        return 'Not letters'
from itertools import groupby\n\ndef replace(s):\n    queue, rle = {}, [[i, k, len(list(g))] for i, (k, g) in enumerate(groupby(s))]\n    for i, k, l in reversed(rle):\n        if l not in queue: queue[l] = {}\n        queue[l].setdefault(k, []).append(i)\n    for l in queue:\n        while sum(map(bool, queue[l].values())) > 1:\n            for c in queue[l]: rle[queue[l][c].pop()][1] = ' '\n    return ''.join(k * l for i, k, l in rle)
def swap(st):\n  tr = str.maketrans('aeiou', 'AEIOU')\n  return st.translate(tr);
import itertools\n\ndef solve(a, b):\n    primes = set([2] + [n for n in range(3, b, 2) if all(n % r for r in range(3, int(n**0.5)+1, 2))])\n    return sum( sum(map(int, str(x*y))) in primes for x, y in itertools.combinations_with_replacement([p for p in primes if a <= p < b], 2) )
def pick_peaks(arr):\n    pos = []\n    prob_peak = False\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            prob_peak = i\n        elif arr[i] < arr[i-1] and prob_peak:\n            pos.append(prob_peak)\n            prob_peak = False\n    return {'pos':pos, 'peaks':[arr[i] for i in pos]}
def box_capacity(length, width, height):\n    return (length * 12 // 16) * (width * 12 // 16) * (height * 12 // 16)\n
def chess_bishop_dream(b,p,d,k):\n    yq,yr=divmod(p[0]+k*d[0],2*b[0])\n    xq,xr=divmod(p[1]+k*d[1],2*b[1])\n    return [min(yr, 2*b[0]-yr-1), min(xr, 2*b[1]-xr-1)]
def sum_them(n):\n    return 2 ** (n - 1) * (2 ** n - 1)
def reverse_by_center(s):n=len(s)//2;return s[-n:]+s[n:-n]+s[:n]
vals='2345678910JQKA'\ndef card_game(card_1, card_2, trump):\n    print((card_1, card_2, trump))\n    if card_1==card_2: return 'Someone cheats.'\n    elif 'joker' in [card_1,card_2]:\n        return ['The first card won.', 'The second card won.'][card_1!='joker']\n    elif card_1[-1]==card_2[-1]:\n        return ['The first card won.', 'The second card won.'][vals.index(card_2[0])>vals.index(card_1[0])]\n    elif card_1[-1]!=trump!=card_2[-1]:\n        return 'Let us play again.'\n    else:\n        return ['The first card won.', 'The second card won.'][card_1[-1]!=trump]
def hot_singles(arr1, arr2):\n    a = []\n    for x in arr1 + arr2:\n        if x in set(arr1) ^ set(arr2) and x not in a: a.append(x)\n    return a
def countzero(s):\n    return sum(1 if c in 'abdegopq069DOPQR' else 2 if c in '%&B8' else 0 for c in s.replace('()', '0'))
def greek_comparator(lhs, rhs):\n    greek_alphabet = [\n        'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta',\n        'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu',\n        'nu', 'xi', 'omicron', 'pi', 'rho', 'sigma',\n        'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega']\n    l = len(greek_alphabet)\n    k = 0\n    v = 0\n    i = 0\n    for i in range(l):\n        if lhs == greek_alphabet[i]:\n            k = i\n    i += 1\n    i = 0\n    for i in range(l):\n        if rhs == greek_alphabet[i]:\n            v = i\n    i += 1\n    b = k - v\n    return b
import re\n\ndef player_manager(players):\n    return players and [ {'player': who, 'contact': int(num)}\n                         for who,num in re.findall(r'(.+?), (\d+)(?:, )?', players)] or []
from re import search\n\n\ndef body_count(code):\n    return bool(search(r'(?:[A-Z]\d){5}\.-[A-Z]%\d\.\d{2}\.', code))
from itertools import groupby\n\ndef uniq(seq): \n    return [k for k,_ in groupby(seq)]
def display_board(board, width):\n    board = [c.center(3) for c in board]\n    rows = ["|".join(board[n:n+width]) for n in range(0, len(board), width)]\n    return ("\n" + "-"*(4*width - 1) + "\n").join(rows)
def knight_rescue(N,x,y):\n    return (y - x) % 2 == 0 or any(n % 2 == 0 for n in N)\n
def london_city_hacker(journey): \n    # your code here\n    tube = 2.40\n    bus = 1.50\n    total_cost = 0.00\n    count = 0\n    for link in journey:\n        if isinstance(link, str):\n            total_cost += tube\n            count = 0\n        else:\n            if count == 0:\n                total_cost += bus\n                count +=1\n            else:\n                count = 0\n    return '{:.2f}'.format(total_cost)\n
def chameleon(chameleons, color):\n    (_,a), (_,b), (_,c) = sorted((i==color, v) for i,v in enumerate(chameleons))\n    return -1 if not a and not c or (b-a) % 3 else b
def redWith2Blues(i, line):\n    return any(line[i-2+x:i+1+x].count('blue')==2 for x in range(3))\n\ndef friend_find(line):\n    return sum( p=='red' and redWith2Blues(i,line) for i,p in enumerate(line))
VOWELS = set('aeiou')\n\ndef pig_latin(st):\n    s = st.lower()\n    if s.isalpha():\n        if set(s) & VOWELS:\n            if s[0] in VOWELS:\n                s += 'w'\n            while s[0] not in VOWELS:\n                s = s[1:] + s[:1]\n        return s + 'ay'
def shortest_arrang(n):\n    # For odd n, we can always construct n with 2 consecutive integers.\n    if n % 2 == 1:\n        return [n//2 + 1, n//2]\n\n    # For even n, n is the sum of either an odd number or even number of\n    # consecutive positive integers. Moreover, this property is exclusive.\n\n    for i in range(3, n // 2):\n        if i % 2 == 1 and n % i == 0:\n        # For odd i, if n / i is an integer, then the sequence, which has\n        # odd length, is centered around n / i.\n            return list(range(n//i + i//2, n//i - i//2 - 1, -1))\n        elif i % 2 == 0 and n % i == i // 2:\n        # For even i, if the remainder of n / i is 1/2, then the sequence\n        # (even length) is centered around n / i.\n            return list(range(n//i + i//2, n//i - i//2, -1))\n\n    # If none of the above are satisfied, then n is a power of 2 and we cannot\n    # write it as the sum of two consecutive integers.\n    return [-1]\n
UMLAUTS = {'A': '', 'E': '', 'I': '', 'O': '', 'U': '', 'Y': '',\n           'a': '', 'e': '', 'i': '', 'o': '', 'u': '', 'y': ''}\n\n\ndef heavy_metal_umlauts(s):\n    return ''.join(UMLAUTS.get(a, a) for a in s)
move = [lambda p: (p[0]+1, p[1]), lambda p: (p[0], p[1]+1), lambda p: (p[0]-1, p[1]), lambda p: (p[0], p[1]-1)]\nstart, loop, size = 9977, 104, 12\n\ndef langtons_ant(n):\n    pos, d, black, res = (0, 0), 0, set(), 0\n    if n > start:\n        x = (n - start)%loop\n        res = size * (n-start-x)//loop\n        n = start + x\n    for i in range(n):\n        if pos in black:\n            black.remove(pos)\n            d = (d+1)%4\n        else:\n            black.add(pos)\n            d = (d-1)%4\n        pos = move[d](pos)\n    return res + len(black)
def sort_number(a): \n    a = sorted(a)\n    return [1]+a if a.pop()!=1 else a+[2]
def skiponacci(n):\n    s = '1'\n    num = 1\n    prv = 0\n    for i in range(1,n):\n        new = num + prv\n        prv = num\n        num = new\n        if i%2 == 0:\n            s = s + ' ' + str(num)\n        else:\n            s += ' skip'\n\n    return s
def anagrams(word, words): return [item for item in words if sorted(item)==sorted(word)]
def mem_alloc(banks):\n    seen = set()\n    while tuple(banks) not in seen:\n        seen.add(tuple(banks))\n        number = max(banks)\n        index = banks.index(number)\n        banks[index] = 0\n        while number:\n            index = (index + 1) % 16\n            banks[index] += 1\n            number -= 1\n    return len(seen)
def swap_head_tail(a):\n    r, l = (len(a)+1)//2, len(a)//2\n    return a[r:] + a[l:r] +  a[:l]
def reverse_on_diagonals(matrix):\n    copy = [ line[:] for line in matrix ]\n    for i in range(len(matrix)):\n        copy[i][i]    = matrix[-1-i][-1-i]\n        copy[i][-1-i] = matrix[-1-i][i]\n    \n    return copy
def roots(a,b,c):\n    if b**2>=4*a*c:\n        return round(-b/a,2)
def shortest_time(speed):\n    a,b,c,d = sorted(speed)\n    return a+b+d + min(2*b, a+c)
def solve(a,b):\n    if not (a and b): return [a, b]\n    if a >= 2*b: return solve(a%(2*b), b)\n    if b >= 2*a: return solve(a, b%(2*a))\n    return [a, b]
def no_space(x):\n    return x.replace(' ' ,'')
def max_match(s):\n    result = []\n    \n    while s:\n        for size in range(len(s), 0, -1):\n            word = s[:size]\n            if word in VALID_WORDS:\n                break\n        \n        result.append(word)\n        s = s[size:]\n    \n    return result
def rectangles(n, m):\n    return m * n * (m - 1) * (n - 1) / 4
def buy_or_sell(pairs, harvested_fruit):\n    \n    currentFruit = harvested_fruit\n    actions = list()\n    \n    for pair in pairs:\n    \n        if currentFruit not in pair: return 'ERROR'\n    \n        if currentFruit == pair[0]:\n        \n            actions.append('buy')\n            currentFruit = pair[1]\n            \n        else:\n        \n            actions.append('sell')\n            currentFruit = pair[0]\n            \n    return actions
hidden=lambda n: "".join("oblietadnm"[int(d)] for d in str(n))
def are_equally_strong(your_left, your_right, friends_left, friends_right):\n  return sorted([your_left, your_right]) == sorted([friends_left, friends_right])
t = ((800, "lava"), (120, "blaze rod"), (80, "coal"), (15, "wood"), (1, "stick"))\n\n\ndef calc_fuel(n):\n    s, r = n * 11, {}\n    for d, e in t:\n        r[e], s = divmod(s, d)\n    return r
def int_rac(n, guess):\n    """Integer Square Root of an Integer"""\n    x = guess\n    cnt = 1\n    while True:\n        newx = (x + n // x) // 2 \n        if abs(x - newx) < 1:\n            return cnt\n        x = newx\n        cnt += 1
def pre_fizz(n):\n    #your code here\n    return list(range(1, n+1))
from operator import mul\nfrom functools import reduce\n\ndef find_middle(s):\n    if not s or not isinstance(s,str): return -1\n    \n    lstDig = [int(c) for c in s if c.isnumeric()]\n    if not lstDig: return -1\n    \n    prod = str( reduce(mul,lstDig) )\n    i    = (len(prod) - 1) // 2\n    return int(prod[i:-i or len(prod)])
def encrypt(text, rule):\n    return "".join(chr((ord(i)+rule)%256) for i in text)
def could_be(original, another):\n    if not another.strip(): return False\n    return all(name in original.split() for name in another.split())
def padovan(n):\n    p0 = p1 = p2 = 1\n    for i in range(n):\n        p0, p1, p2 = p1, p2, p0 + p1\n    return p0
from math import floor, exp\n    \ndef ex_euler(n):\n    # fct to study\n    F = lambda t,y : 2 - exp(-4 * t) - 2 * y\n    # initial conditions\n    t0 = 0; y0 = 1; # pt A0\n    T = 1; \n    # variables\n    h = T / float(n); X = [t0]; Y = [y0]; Z = []; R = []\n    # points A1 ... An\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k],Y[k]))\n    # pts on the exact curve\n    for k in range(0, n + 1):\n        # exact solution\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        # relative error\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    return floor((sum(R) / float(n + 1)) * 1e6) / 1e6 
def colorful(number):\n    base_result = []\n    for x in str(number):\n        base_result.append(int(x))\n    for y in range(len(base_result) - 1):\n        temp = base_result[y] * base_result[y + 1]\n        base_result.append(temp)\n    # Should you really eval the last value ? :shrug: If so, would use eval\n    return len(set(base_result)) == len(base_result)
def nth_smallest(arr, pos):\n    return sorted(arr)[pos-1] # Gotta love Python
dist = lambda p1, p2: ((p1['x']-p2['x'])**2+(p1['y']-p2['y'])**2)**0.5\nellipse_contains_point = lambda f0, f1, l, p : dist(p, f0)+dist(p, f1)<=l
def cube_times(times):\n    return (round((sum(times) - (min(times) + max(times)))/3 , 2), min(times))
def get_score(n):\n    return n * (n + 1) * 25
from itertools import count, permutations\n\ndef next_perfectsq_perm(limit_below, k):\n    for n in count(int(limit_below**.5)+1):\n        s = str(n**2)\n        if '0' not in s:\n            sq_set = {x for x in (int(''.join(p)) for p in permutations(s)) if (x**.5).is_integer()}\n            if len(sq_set) == k:\n                return max(sq_set)
import re\n\ndef frogify(s):\n    return ' '.join( ' '.join(re.findall(r'[a-z]+', sentence)[::-1]) + punct for sentence,punct in re.findall(r'(.*?)([.!?])', s) )
def reverser(sentence):\n    return ' '.join(i[::-1] for i in sentence.split(' '))
def odd_or_even(arr):\n    return 'even' if sum(arr) % 2 == 0 else 'odd'
def is_isogram(string):\n    return len(string) == len(set(string.lower()))
def archers_ready(archers):\n    return all(i >= 5 for i in archers) if archers else False
def area_or_perimeter(l, w):\n    return l * w if l == w else (l + w) * 2
import math\n\ndef cost(mins):\n    return 30 + 10 * math.ceil(max(0, mins - 60 - 5) / 30)
def is_negative_zero(n):\n    return str(n) == '-0.0'
def gen(n, d):\n    if d == 0 or n == 1:\n        yield [d]*n\n    else:\n        for x in range(d+1):\n            for y in gen(n-1, d-x):\n                yield [x] + y\n\ndef indices(n, d):\n    return list(gen(n, d))
from itertools import combinations\n\ndef digits(num):\n    return list(map(sum, combinations(map(int,str(num)),2)))
def lostSheep(friday,saturday,total):\n    return total - sum(friday+saturday)
from re import findall\ndef count_smileys(arr):\n    return len(list(findall(r"[:;][-~]?[)D]", " ".join(arr))))
def did_we_win(plays):\n    plays = [p for p in plays if p]\n    return all(p != 'turnover' for y,p in plays) and sum(-y if p == 'sack' else y for y,p in plays) > 10            
def get_planet_name(id):\n    return {\n        1: "Mercury",\n        2: "Venus",\n        3: "Earth",\n        4: "Mars",\n        5: "Jupiter",\n        6: "Saturn",\n        7: "Uranus",\n        8: "Neptune",\n    }.get(id, None)
def count_pal(n):\n    # No recursion; direct calculation:\n    return [9 * 10**((n-1) // 2), 10**(n // 2) * (13 - 9 * (-1)**n) // 2 - 2]
def solve(a, b):\n    alice = sum(i > j for i, j in zip(a, b))\n    bob = sum(j > i for i, j in zip(a, b))\n    \n    if alice == bob:\n        words = 'that looks like a "draw"! Rock on!'\n    elif alice > bob:\n        words = 'Alice made "Kurt" proud!'\n    else:\n        words = 'Bob made "Jeff" proud!'\n    \n    return '{}, {}: {}'.format(alice, bob, words) 
def find_spaceship(astromap):\n    lines = astromap.splitlines()\n    for y, line in enumerate(lines):\n        x = line.find('X')\n        if x != -1:\n            return [x, len(lines) - 1 - y]\n    return 'Spaceship lost forever.'\n
def combine_names(first, last):\n    return first + " " + last
import re\n\ndef remove_chars(s):\n    return re.sub(r'[^a-zA-Z ]', '', s)
def min_unfairness(arr,k):\n    arr = sorted(arr)\n    return min(b - a for a, b in zip(arr, arr[k-1:])) if arr and k else 0
import re\n\ndef uncollapse(digits):\n    return ' '.join(re.findall('zero|one|two|three|four|five|six|seven|eight|nine', digits))
def artificial_rain(garden):\n    left,area,record = 0,0,1\n    for i in range(1,len(garden)):\n        if garden[i] < garden[i-1]:\n            left = i\n        elif garden[i] > garden[i-1]:\n            area = max(area,record)\n            record = i - left\n        record += 1\n    return max(area,record)
from fractions import gcd\n\ndef fraction(a,b):\n    return (a+b)//gcd(a,b)
def generate_pairs(n):\n    return [[i,j] for i in range(n+1) for j in range(i, n+1)]
def is_in_middle(s):\n    while len(s)>4:\n        s = s[1:-1]\n    return 'abc' in s
from collections import Counter\n\n\ndef sum_no_duplicates(nums):\n    return sum(k for k, v in list(Counter(nums).items()) if v == 1)\n
import re\n\ndef change_case(label, target):\n    if ('_' in label) + ('-' in label) + (label != label.lower()) > 1:\n        return\n    \n    if target == 'snake':\n        return re.sub('([A-Z])', r'_\1', label.replace('-', '_')).lower()\n    \n    if target == 'kebab':\n        return re.sub('([A-Z])', r'-\1', label.replace('_', '-')).lower()\n    \n    if target == 'camel':\n        return re.sub('([_-])([a-z])', lambda m: m.group(2).upper(), label)
def profitLoss(records):\n    return round(sum(price - price / (1 + profit / 100) for (price, profit) in records), 2)
def fly_by(lamps, drone):\n    return lamps.replace('x', 'o', drone.count('=') + 1)
def yellow_be_gone(s):\n    d = {'gold':'ForestGreen', 'khaki':'LimeGreen', 'lemonchiffon':'PaleGreen', 'lightgoldenrodyellow':'SpringGreen',\n         'lightyellow':'MintCream', 'palegoldenrod':'LightGreen', 'yellow':'Lime'}\n         \n    if s[0] == '#':\n        R, G, B = s[1:3], s[3:5], s[5:]\n        if B < G and B < R:\n            R, B, G = sorted([R, G, B])\n            s = '#' + R + G + B\n        \n    return d.get(s.lower(), s)
def find_lowest_int(k1):\n    k2, n = k1 + 1, 1\n\n    def digits(n):\n        return sorted(str(n))\n    \n    while digits(n*k1) != digits(n*k2):\n        n += 1\n    \n    return n
from collections import defaultdict\n\ndef repeat_sum(l):\n    count = defaultdict(int)\n    for l1 in l:\n        for val in set(l1):\n            count[val] += 1\n    \n    return sum(k for k,v in list(count.items()) if v > 1)\n
def men_still_standing(cards):\n    # generate teams\n    A = {k: 0 for k in range(1, 12)}\n    B = A.copy()\n    \n    for card in cards:\n        # parse card\n        team = A if card[0] == "A" else B\n        player = int(card[1:-1])\n        color = card[-1]\n        \n        if player not in team:\n            continue\n        \n        # record penalty\n        team[player] += 1 if color == "Y" else 2\n        \n        if team[player] >= 2:\n            del team[player]\n        \n        if len(team) < 7:\n            break\n    \n    return len(A), len(B)\n
def next_higher(value):\n    s = f'0{value:b}'\n    i = s.rfind('01')\n    s = s[:i] + '10' + ''.join(sorted(s[i+2:]))\n    return int(s, 2)
def freq_seq(s, sep):\n    return sep.join([str(s.count(i)) for i in s])\n
def is_thue_morse(seq):\n    init_seq = [0]\n    while len(init_seq) < len(seq):\n        init_seq += [1 if n == 0 else 0 for n in init_seq]\n    return init_seq[:len(seq)] == seq\n
def elevator_distance(array):\n    return sum(abs(a - b) for a, b in zip(array, array[1:]))
def fold_cube(nums):\n    return expand(nums.pop(), set(nums), 1, 2, 3) == {1, 2, 3, -1, -2, -3}\n\n\ndef expand(val, nums, x, y, z):\n    dirs = {z}\n    for num in nums.copy():\n        if abs(val - num) not in (1, 5) or {val % 5, num % 5} == {0, 1}:\n            continue\n\n        nums.discard(num)\n        diff = val - num\n        sign = diff // abs(diff)\n        nx, ny, nz = (x, z * sign, -y * sign) if abs(diff) == 1 else (-z * sign, y, x * sign)\n        dirs |= expand(num, nums, nx, ny, nz)\n    return dirs
def minimum_steps(arr, n):\n    arr = sorted(arr)\n    s = 0\n    for i,v in enumerate(arr): \n        s += v\n        if s >= n: return i
def you_are_a_cube(cube):\n    return round(cube ** (1/3)) ** 3 == cube
import string\n\ndef solve(st):\n  return ''.join(sorted(st)) in string.ascii_letters
def switch_endian(n, bits):\n    out = 0\n    while bits > 7:\n        bits -= 8\n        out <<= 8\n        out  |= n & 255\n        n   >>= 8\n    return None if n or bits else out
def compare(s1, s2):\n    v1,v2 = version(s1),version(s2)\n    return -1 if v1 < v2 else 1 if v1 > v2 else 0\n\ndef version( s ):\n    v = [int(n) for n in s.split(".")]\n    while( v[-1]==0 ) : v = v[0:-1]\n    return v
def is_palindrome(string):\n    return str(string)[::-1] == str(string)
from itertools import accumulate\n\ndef tram(stops, descending, onboarding):\n    return max(accumulate(o - d for d, o in zip(descending[:stops], onboarding)))
def no_ifs_no_buts(a, b):\n    return {\n        a == b: str(a) + " is equal to " + str(b),\n        a < b: str(a) + " is smaller than " + str(b),\n        a > b: str(a) + " is greater than " + str(b),\n    }[True]
def yoga(classroom, poses):\n    total_poses = 0\n    for pose in poses:\n        for row in classroom:\n            for person in row:\n                if person + sum(row) >= pose:\n                    total_poses += 1\n    return total_poses
def noonerize(numbers):\n    \n    try:\n        num1 = int(str(numbers[1])[0] + str(numbers[0])[1:])\n        num2 = int(str(numbers[0])[0] + str(numbers[1])[1:])\n    except ValueError:\n        return "invalid array"\n        \n    return abs(num1 - num2)
from math import floor, log\ndef count_sixes(n):\n    return floor((n - n % 2) * log(2, 10))
def find_missing_number(a):\n    n = len(a) + 1\n    return n * (n + 1) // 2 - sum(a)
def subsets(collection):\n    if len(collection) == 1:\n        yield [collection]\n        return\n\n    first = collection[0]\n    for smaller in subsets(collection[1:]):\n        yield [first] + smaller\n        for n, subset in enumerate(smaller):\n            yield smaller[:n] + [first + subset]  + smaller[n+1:]\n\ndef bucket_digit_distributions_total_sum(n):\n    return sum(sum(map(int, sub)) for sub in subsets(str(n))) - n\n\ndef find(n, z):\n    f_nf = bucket_digit_distributions_total_sum(n) + z\n    while 1:\n        n += 1\n        if bucket_digit_distributions_total_sum(n) > f_nf:\n            return n
def split_odd_and_even(n):\n    \n    import re\n  \n    return [int(i) for i in re.findall(r"[2468]+|[13579]+", str(n))]
def compare_versions(ver1,ver2):\n    return [int(i) for i in ver1.split(".")] >= [int(i) for i in ver2.split(".")]\n
from operator import mul\nfrom math import factorial\nfrom functools import reduce\nfrom collections import Counter\n\ndef proc_arr(arr):\n    s = ''.join(sorted(arr))\n    return [factorial(len(arr)) // reduce(mul, list(map(factorial, list(Counter(arr).values())))), int(s), int(s[::-1])]\n
import math\n\ndef loose_change(cents):\n    if cents < 0:\n        cents = 0\n    cents = int(cents)\n    \n    change = {}\n\n    change['Quarters'] = cents // 25\n    cents = cents % 25\n\n    change['Dimes'] = cents // 10\n    cents = cents % 10\n\n    change['Nickels'] = cents // 5\n    cents = cents % 5\n    \n    change['Pennies'] = cents\n    \n    return change
def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    sqrtn = int(n**0.5) + 1\n    for i in range(5, sqrtn, 6):\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n    return True\n\ndef end_one(n):\n    while n > 6:\n        n = sum(map(lambda x: int(x)*int(x) ,f"{n}"))\n        if n == 1:\n            return True\n        \ndef solve(a,b):\n    return sum(1 for n in range(a, b) if is_prime(n) and end_one(n))
def get_function(sequence):\n    slope = sequence[1] - sequence[0]\n    for x in range(1,5):\n        if sequence[x] - sequence[x-1] != slope:\n            return "Non-linear sequence"\n    \n    return lambda a : slope * a + sequence[0]
def reg_sum_hits(dices,sides=6):\n    d,s = sides*[1],sides-1\n    for i in range(dices-1):\n        t = s*[0] + d + s*[0]\n        d = [sum(t[i:i+sides]) for i in range(len(t)-s)]\n    return [[i+dices, prob] for (i,prob) in enumerate(d)]
def mult_primefactor_sum(a, b): \n    s=[]\n    for i in range(a,b+1):\n       r=factorize_add(i)\n       if r!=i and i%r==0: s.append(i)\n    return s\n    \ndef factorize_add(num):\n    if num<4: return num\n    d=2; p=0\n    while d<num**.5+1:\n        while not num%d: p+=d; num/=d\n        d+=1 if d==2 else 2\n    return p if num==1 else p+num
def to_seconds(time):\n    try:\n        s, m, h = int(time[-2:]), int(time[3:5]), int(time[:2])\n        return s + m*60 + h*3600 if m < 60 and s < 60 and len(time) == 8 else None\n    except:\n        return None
def jumbled_string(s, n):\n    iterations = [s]\n    \n    while True:\n        s = s[::2] + s[1::2]\n        if s == iterations[0]: break\n        iterations.append(s)\n    \n    return iterations[n % len(iterations)]
from collections import Counter as C\ndef ball_probability(b):\n      d, n, p = C(b[0]), len(b[0]), 1\n      for i in b[1]:\n          p *= d.get(i,0)/n\n          n -= b[2]^1\n          d[i] -= b[2]^1\n      return round(p,3)
def expression_matter(a, b, c):\n    return max(a*b*c, a+b+c, (a+b)*c, a*(b+c))
def mango(quantity, price):\n    return (quantity - quantity // 3) * price
def isMultiple(a, b, n):\n    remainder = int((a / b + 0.05) * 10) % 10\n    return remainder > 0 and remainder % n == 0
from itertools import groupby\n\ndef sum_groups(arr):\n    newarr = [sum(j) for i,j in groupby(arr, key = lambda x: x % 2 == 0)]\n    return len(newarr) if newarr == arr else sum_groups(newarr)
def sort_by_bit(arr): \n    return sorted(arr, key=lambda x: (bin(x).count("1"), x))
from collections import Counter\n\ndef longest_palindrome(s):\n    c = Counter(filter(str.isalnum, s.lower()))\n    return sum(v//2*2 for v in c.values()) + any(v%2 for v in c.values())
def vowel_2_index(string):\n    vowels = 'aeiouAEIOU'\n    return ''.join(x if x not in vowels else str(n + 1) for n,x in enumerate(string))
from string import ascii_lowercase as alphabet\n\n\ndef decode(message):\n    return message.translate(str.maketrans(alphabet, alphabet[::-1]))
def can_jump(arr):\n    if arr[0] == 0 or len(arr) == 1:\n        return False\n    \n    if arr[0] >= len(arr):\n        return True\n    \n    for jump in range(1, arr[0] +1):\n        if can_jump(arr[jump:]):\n            return True\n    \n    return False\n
import operator\nfrom functools import reduce\n\nOPS = {\n    "AND": operator.and_,\n    "OR" : operator.or_,\n    "XOR": operator.xor\n}\n\ndef logical_calc(array, op):\n    return reduce(OPS[op], array)\n
def first_non_repeated(s):\n    return next((c for c in s if s.count(c) == 1), None)
from collections import Counter\nfrom functools import reduce\nfrom math import gcd\n\ndef has_subpattern(string):\n    return reduce(gcd, Counter(string).values()) != 1
def S2N(m, n):\n  return sum(i**j for i in range(m+1) for j in range(n+1))
def cookie(x):\n    return "Who ate the last cookie? It was %s!" % {str:"Zach", float:"Monica", int:"Monica"}.get(type(x), "the dog")
def middle_point(x1, y1, z1, x2, y2, z2, x3, y3, z3):\n    return sorted(((x1, y1, z1, 1), (x2, y2, z2, 2), (x3, y3, z3, 3)))[1][3]\n
import numpy as np\ns = np.ones(100000)\nfor i in range(2, 100000):\n    s[i::i] += 1\n\ndef div_num(a, b):\n    return max(range(a, b+1), key=lambda i: (s[i], -i), default='Error')
def validate_pin(pin):\n    return len(pin) in (4, 6) and pin.isdigit()
def chmod_calculator(perm):\n    perms = { "r": 4, "w": 2, "x": 1 }\n    value = ""\n    for permission in ["user", "group", "other"]:\n        value += str(sum(perms.get(x, 0) for x in perm.get(permission, "")))\n        \n    return value
def case_sensitive(s):\n    return [s.islower() or not s, [c for c in s if c.isupper()]]
"""\nh = vt-0.5gt^2\nlet h = 0 [that is, when the ball has returned to the ground]\n=> 0 = vt-0.5gt^2\n=> 0.5gt^2 = vt\n=> 0.5gt = v\n=> t = 2v/g - the total time the ball is in the air.\n=> t at max height  = v/g\n"""\n\ndef max_ball(v0):\n    return round(10*v0/9.81/3.6)
def abundant_number(num):\n    return (sum([e for e in range(1,num) if num%e==0]) > num)
import re\n\nPATTERN = re.compile(r'[aeyuio]+[^aeyuio ]*((?=e\b)e)?', flags=re.I)\n\n\ndef is_haiku(text):\n    return [5,7,5] == [check(s) for s in text.split("\n")]\n    \ndef check(s):\n    return sum(1 for _ in PATTERN.finditer(s))\n
words_to_sentence=' '.join
def revamp(s):\n    words = [''.join(sorted(word)) for word in s.split()]\n    words.sort(key=lambda word: (sum(map(ord, word)), len(word), word))\n    return ' '.join(words)
def get_derivative(s):\n    if '^' in s:\n        f,t = map(int, s.split('x^'))\n        return '{}x'.format(f*t) if t==2 else '{}x^{}'.format(f*t, t-1)\n    elif 'x' in s: return s[:-1]\n    else: return '0'
def solution(s):\n    st=[1 for i in range(1,len(s)) if s[i-1]==s[i]]\n    return sum(st)
def consecutive(arr):\n    return max(arr) - min(arr) + 1 - len(arr) if arr else 0
def golf_score_calculator(par, score):\n    return sum(int(b) - int(a) for a, b in zip(par, score))
from functools import reduce\nfrom operator import mul\n\ndef maximum_product_of_parts(n):\n    s = str(n)\n    return max(reduce(mul, map(int, (s[:i], s[i:j], s[j:])))\n               for i in range(1,len(s)-1) for j in range(i+1,len(s)))
def shortest_steps_to_num(num):\n    steps = 0\n    \n    while num != 1:\n        if num % 2:\n            num -= 1\n        else:\n            num //= 2\n        \n        steps += 1\n    \n    return steps
BUTTONS = [ '1',   'abc2',  'def3',\n          'ghi4',  'jkl5',  'mno6',\n          'pqrs7', 'tuv8', 'wxyz9',\n            '*',   ' 0',    '#'   ]\ndef presses(phrase):\n    return sum(1 + button.find(c) for c in phrase.lower() for button in BUTTONS if c in button)
def sumin(n):\n    return n * (n + 1) * (2 * n + 1) // 6\n    \ndef sumax(n):\n    return n * (n + 1) * (4 * n - 1) // 6\n    \ndef sumsum(n):\n    return n * n * (n + 1)\n\n
def flatten_me(lst):\n    res = []\n    for l in lst:\n        if isinstance(l, list):\n            res.extend(l)\n        else:\n            res.append(l)\n    return res\n
from math import ceil\n\ndef mega_mind(hp, dps, shots, regen):\n    if dps*shots >= hp: return ceil(hp / dps)\n    if dps*shots <= regen: return -1\n\n    number_of_regenerations = ceil((hp - dps*shots) / (dps*shots - regen))\n    return ceil((hp + regen*number_of_regenerations) / dps)
def time_correct(t):\n    if not t: return t\n    try:\n        h, m, s = map(int, t.split(':'))\n        if s >= 60: s -= 60; m += 1\n        if m >= 60: m -= 60; h += 1\n        return '%02d:%02d:%02d' % (h % 24, m, s)\n    except: pass
def nth_even(n):\n    return 2 * (n - 1);
WEEKDAY = {\n    1: 'Sunday',\n    2: 'Monday',\n    3: 'Tuesday',\n    4: 'Wednesday',\n    5: 'Thursday',\n    6: 'Friday',\n    7: 'Saturday' }\nERROR = 'Wrong, please enter a number between 1 and 7'\n\n\ndef whatday(n):\n    return WEEKDAY.get(n, ERROR)\n
def boxes_packing(l, w, h):\n    boxes = sorted(sorted(t) for t in zip(l, w, h))\n    return all( s < l for b1,b2 in zip(boxes[:-1], boxes[1:]) for s,l in zip(b1,b2))
def adjacent_element_product(array):\n    return max( a*b for a, b in zip(array, array[1:]) )
def alphabet_position(text):\n    return ' '.join(str(ord(c) - 96) for c in text.lower() if c.isalpha())
def feast(beast, dish):\n    return beast[0]==dish[0] and dish[-1]==beast[-1]
def super_size(n):\n    return int(''.join(sorted(str(n), reverse = True)))
L = (\n     (' #### ', '  ##  ', ' #### ', ' #### ', '##  ##', '######', '   ## ', '######', ' #### ', ' #### ').__getitem__,\n     ('##  ##', ' ###  ', '##  ##', '##  ##', '##  ##', '##    ', '  ##  ', '##  ##', '##  ##', '##  ##').__getitem__,\n     ('##  ##', '# ##  ', '   ## ', '   ## ', '##  ##', '##### ', ' #### ', '   ## ', ' #### ', '##  ##').__getitem__,\n     ('##  ##', '  ##  ', '  ##  ', '   ## ', ' #####', '    ##', '##  ##', '  ##  ', ' #### ', ' #### ').__getitem__,\n     ('##  ##', '  ##  ', ' ##   ', '##  ##', '    ##', '    ##', '##  ##', ' ##   ', '##  ##', '  ##  ').__getitem__,\n     (' #### ', '######', '######', ' #### ', '    ##', '##### ', ' #### ', ' ##   ', ' #### ', ' ##   ').__getitem__\n)\n\ndef print_number(number, char): \n    s1, s2, l = '#'*40, f"#{' '*38}#", list(map(int, f"{number:05}"))\n    return '\n'.join([s1, s2] + [f"#  {' '.join(map(L[i], l))}  #" for i in range(6)] + [s2, s1]).replace('#', char)
def remember(str_):\n    seen = set()\n    res = []\n    for i in str_: \n        res.append(i) if i in seen and i not in res else seen.add(i)\n    return res\n
def simplify(n): \n    output = []\n    exp = 0\n    \n    while n:\n        n, r = divmod(n, 10)\n        if r:\n            output.append(f"{r}*{10**exp}" if exp else f"{r}")\n        exp += 1\n    \n    return "+".join(output[::-1])
def is_narcissistic(n):\n    num = str(n)\n    length = len(num)\n    return sum(int(a) ** length for a in num) == n\n
def nb_year(population, percent, aug, target):\n    year = 0\n    while population < target:\n        population += population * percent / 100. + aug\n        year += 1\n    return year
def lamps(a):\n    n = sum(1 for i, x in enumerate(a) if x != i % 2)\n    return min(n, len(a) - n)
DEFAULT = 'unknown'\nCOLORS  = {'black'+'brown': 'dark brown',\n           'black'+'white': 'grey',\n           'brown'+'white': 'light brown'}\n\ndef bear_fur(bears):\n    b1,b2 = sorted(bears)\n    return b1 if b1==b2 else COLORS.get(b1+b2, DEFAULT)\n
def xp_to_target_lvl(*args):\n    if len(args) < 2:\n        return 'Input is invalid.'\n        \n    current_xp, target_lvl = args\n    \n    if not isinstance(target_lvl, int):\n        return 'Input is invalid.'\n    \n    if not (0 < target_lvl < 171):\n        return 'Input is invalid.'\n    \n    if current_xp < 0:\n        return 'Input is invalid.'\n        \n    level = 1\n    xp = 314\n    xp_bump = 25\n    \n    sum_ = 0\n    while level < target_lvl:\n        sum_ += xp\n        level += 1\n        xp_bump_reduction = level // 10\n        xp += int(xp * (xp_bump - xp_bump_reduction) / 100)\n        \n    diff = sum_ - current_xp\n    if diff <= 0:\n        return 'You have already reached level {}.'.format(target_lvl)\n    else:\n        return diff\n
def start_smoking(bars, boxes):\n    return int(22.5 * (10 * bars + boxes) - 0.5)
def find(seq):\n  return (min(seq)+max(seq))*(len(seq)+1)/2-sum(seq)
from bisect import bisect_left as bisect\n\nn = 5000000\nsieve, PED, PED_DATA = [0]*((n>>1)+1), [], []\nfor i in range(3, n+1, 2):\n    if not sieve[i>>1]:\n        for j in range(i**2>>1, (n+1)>>1, i): sieve[j] = 1\n        s = str(i)\n        nEveD = sum(s.count(d) for d in "02468")\n        if nEveD:\n            PED.append(i)\n            PED_DATA.append( (nEveD,len(s)-1) )\n\ndef f(n):\n    idx = bisect(PED, n)-1\n    m, (nEveD, l) = PED[idx], PED_DATA[idx]\n    \n    for c in range(idx):\n        mc, (nEveDc, lc) = PED[idx-c], PED_DATA[idx-c]\n        if nEveDc > nEveD:\n            m, nEveD = mc, nEveDc\n        if lc < nEveD: break\n    return m
def reverse_number(n):\n    """\n    Reverse a number, preserve negative sign\n    """\n    s = str(n)\n    ret = int("-{}".format(s[:0:-1]) if "-" in s else s[::-1])\n    return ret
def sum_to_infinity(sequence):\n    return round(sequence[0]/(1-(sequence[1]/sequence[0])), 3) if abs(sequence[1]/sequence[0]) < 1 else "No Solutions"
def elements_sum(arr, d=0):\n    return sum(r[i] if i<len(r) else d for i,r in enumerate(reversed(arr)))
def parse(data):\n    value = 0\n    res=[]\n    for c in data:\n        if c=="i": value+=1\n        elif c=="d": value-=1\n        elif c=="s": value*=value\n        elif c=="o": res.append(value)\n    return res
def not_visible_cubes(n):\n    return max(n - 2, 0) ** 3
def even_numbers_before_fixed(s, f):\n    return len([x for x in s[:s.index(f)] if x%2 == 0]) if f in s else -1
FRUIT_NAMES = {'blueberry', 'pear', 'durian', 'ginkgo', 'peach', 'apple', 'cantaloupe', 'fig', 'mangosteen', 'watermelon', 'pineapple', 'cherry', 'pomegranate', 'carambola', 'hawthorn', 'persimmon', 'apricot', 'plum', 'litchi', 'mango', 'jujube', 'lemon', 'orange', 'tomato', 'banana', 'coconut', 'grape', 'pitaya'}\ndef cut(x):\n    if x in FRUIT_NAMES:\n        m = (len(x) + 1) // 2\n        return [x[:m], x[m:]]\n    return [x]\n\ndef cut_fruits(fruits):\n    return [x for xs in map(cut, fruits) for x in xs]
def calculate(num1, operation, num2): \n    # your code here\n    try :\n        return eval("{} {} {}".format(num1, operation, num2))\n    except (ZeroDivisionError, SyntaxError):\n        return None
LINES = "{0} of beer on the wall, {0} of beer.\nTake one down and pass it around, {1} of beer on the wall."\nSONG = '\n'.join( LINES.format("{} bottles".format(n), "{} bottle".format(n-1)+"s"*(n!=2)) for n in range(99,1,-1) )\nSONG += """\n1 bottle of beer on the wall, 1 bottle of beer.\nTake one down and pass it around, no more bottles of beer on the wall.\nNo more bottles of beer on the wall, no more bottles of beer.\nGo to the store and buy some more, 99 bottles of beer on the wall."""\n\ndef HQ9(code):\n    return {'H': 'Hello World!', 'Q': 'Q', '9': SONG}.get(code, None)
def repeat_it(string,n):\n    return string * n if isinstance(string,str) else 'Not a string'
def order_type(arr):\n    if not arr : return 'Constant'\n    arr = list( map(len, [str(elt) if type(elt)==int else elt for elt in arr] ))\n    cmp =sorted(arr)\n    if arr == [arr[0]]*len(arr) : s='Constant'\n    elif arr == cmp :             s='Increasing'\n    elif arr == cmp[::-1] :       s='Decreasing'\n    else :                        s='Unsorted'\n    return s
from collections import Counter\n\ndef bucketize(*arr):\n    c = Counter(arr)\n    c = {i: sorted([k for k, v in list(c.items()) if v == i]) for i in list(c.values())}\n    return [c[e] if e in c else None for e in range(len(arr) + 1)]\n
from itertools import groupby\n\ndef sum_consecutives(s):\n    return [sum(group) for c, group in groupby(s)]
from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef rec(n): return 1 + (0 if n==1 else rec(3*n+1) if n&1 else rec(n//2))\n\nmemo = [[0, None], [1, 1]]\ndef max_collatz_length(n):\n    if not (type(n) == int and n > 0): return []\n    while n >= len(memo):\n        x = rec(len(memo))\n        if x > memo[-1][1]: memo.append([len(memo), x])\n        else: memo.append(memo[-1])\n    return memo[n]
def solve(a,b):\n    s = set(a)&set(b)\n    return ''.join(c for c in a+b if c not in s)
colors = {\n    (1, 0, 0): 'red',\n    (0, 1, 0): 'green',\n    (0, 0, 1): 'blue',\n    (1, 0, 1): 'magenta',\n    (1, 1, 0): 'yellow',\n    (0, 1, 1): 'cyan',\n    (1, 1, 1): 'white',\n}\n\ndef hex_color(codes):\n    codes = codes or '0 0 0'\n    items = [int(c) for c in codes.split()]\n    m = max(items)\n    return colors[tuple(i == m for i in items)] if m else 'black'\n
def get_last_digit(index):\n    a, b = 0, 1\n    for _ in range(index):\n        a, b = b, (a+b) % 10\n    return a\n
def points(games):\n    count = 0\n    for score in games:\n        res = score.split(':')\n        if res[0]>res[1]:\n            count += 3\n        elif res[0] == res[1]:\n            count += 1\n    return count
def am_I_afraid(day,num):\n    return {\n        'Monday':  num == 12,\n        'Tuesday': num > 95,\n        'Wednesday': num == 34,\n        'Thursday': num == 0,\n        'Friday': num % 2 == 0,\n        'Saturday': num ==  56,\n        'Sunday': num == 666 or num == -666,\n    }[day]\n
def hamming_distance(a, b):\n    return sum(c != d for c, d in zip(a, b))\n
def positive_to_negative(binary):\n    return [1 - d if 1 in binary[i:] else d for i, d in enumerate(binary, 1)]\n
def solution(roman):\n    dict = {\n        "M": 1000,\n        "D": 500,\n        "C": 100,\n        "L": 50,\n        "X": 10,\n        "V": 5,\n        "I": 1\n    }\n\n    last, total = 0, 0\n    for c in list(roman)[::-1]:\n        if last == 0:\n            total += dict[c]\n        elif last > dict[c]:\n            total -= dict[c]\n        else:\n            total += dict[c]\n        last = dict[c]\n    return total\n
e = [1, 2]\nfor n in range(1, 10 ** 4):\n    for f in 1, 2 * n, 1:\n        e.append(f * e[-1] + e[-2])\nconvergents_of_e = lambda n: sum(map(int, str(e[n])))
def define_suit(card):\n    d = {'C': 'clubs', 'S':'spades', 'D':'diamonds','H':'hearts'}\n    return d[card[-1]]\n
import re\n\ndef inside_out(s):\n    return re.sub(r'\S+', lambda m: inside_out_word(m.group()), s)\n\ndef inside_out_word(s):\n    i, j = len(s) // 2, (len(s) + 1) // 2\n    return s[:i][::-1] + s[i:j] + s[j:][::-1]
def tribonacci(signature, n):\n  res = signature[:n]\n  for i in range(n - 3): res.append(sum(res[-3:]))\n  return res
def f(n):\n    return [2**i for i in range(n+1)]+[(2**(n+1))-1]
def share_price(invested, changes):\n    for change in changes:\n        invested = invested * (100 + change) / 100.0\n    return format(invested, '.2f')
def get_matrix(n):\n    return [[1  if i==j else 0 for i in range(n)] for j in range(n)]
def geometric_sequence_elements(a, r, n):\n    return ', '.join(str(a * r ** i) for i in range(n))\n
from itertools import cycle, islice\n\ndef endless_string(string, start, length):\n    i = (start + (length + 1 if length < 0 else 0)) % len(string)\n    return ''.join(islice(cycle(string), i, i + abs(length)))
is_vampire = lambda x, y: sorted(f"{x}{y}") == sorted(f"{x*y}") and x%10 + y%10 > 0\nvampires = sorted({x*y for p in (1, 2) for x in range(10**p, 10**(p+1)) for y in range(x, 10**(p+1)) if is_vampire(x, y)})\n\ndef VampireNumber(k):\n    return vampires[k-1]
def is_valid_bar(bar, meter):\n    total = 0\n    for n in bar:\n        n = int(n)\n        if n & (n - 1):\n            return False\n        total += 1.0 / n\n    return total == meter\n\ndef validate_rhythm(meter, score):\n    n, d = meter\n    if d & (d - 1):\n        return "Invalid rhythm"\n    bars = score.split("|")\n    meter = float(n) / d\n    if all(is_valid_bar(bar, meter) for bar in bars[1:-1]):\n        if all(is_valid_bar(bar, meter) for bar in (bars[0], bars[-1])):\n                return "Valid rhythm"\n        if len(bars) > 1 and is_valid_bar(bars[0] + bars[-1], meter):\n                return "Valid rhythm with anacrusis"\n    return "Invalid rhythm"
import re\n\ndef to_underscore(string):\n    return re.sub(r'(.)([A-Z])', r'\1_\2', str(string)).lower()    \n
def permute_a_palindrome (input): \n  return sum( input.count(c)%2 for c in set(input) ) < 2\n
masks = [0] * 10\nfor i in range(10 ** 4):\n    for c in str(i):\n        masks[int(c)] |= 1 << i\n\ndef find_num(n):\n    seq, x = 1, 0\n    for j in range(n):\n        M = seq\n        for m in masks:\n            if x & m:\n                M |= m\n        x = ~M & (M+1)\n        seq |= x\n    return x.bit_length() - 1
def num_obj(s):\n    return [{str(i) : chr(i)} for i in s]
def int_to_negabinary(i):\n    ds = []\n    while i != 0:\n        ds.append(i & 1)\n        i = -(i >> 1)\n    return ''.join(str(d) for d in reversed(ds)) if ds else '0'\n    \ndef negabinary_to_int(s):\n    i = 0\n    for c in s:\n        i = -(i << 1) + int(c)\n    return i
def diff(arr):\n    r = arr and max(arr, key = lambda x : abs(eval(x)))\n    return bool(arr and eval(r)) and r
def multiple(x):\n    return 'Bang' * (x % 3 == 0) + 'Boom' * (x % 5 == 0) or 'Miss'
from collections import Counter\n\ndef odd_one_out(s):\n    d = Counter(reversed(s))\n    return [x for x in d if d[x] % 2][::-1]
from re import compile\n\ndef wheres_wally(string):\n    m = compile('(^|.*[\s])(Wally)([\.,\s\']|$)').match(string)\n    return m.start(2) if m else -1
def max_number(n):\n    return int(''.join(sorted(str(n), reverse=True)))
import heapq\ndef max_product(a):\n    x = heapq.nlargest(2,a)\n    return x[0]*x[1]
def numberOfSteps(steps, m):\n    if (steps < m):\n        return -1\n  \n  \n    if (steps % 2 == 0 and (steps / 2) % m == 0):\n        return (steps / 2)\n  \n      \n    return (steps / 2) + m - ((steps / 2) % m)\n
def side_len(x, y):\n    return [z for z in range(abs(x-y)+1,x+y) if z*z not in (abs(x*x-y*y), x*x+y*y)]
def solve(n):\n    x = str(n)\n    res = [x] + [str(int(x[:i]) - 1) + '9' * (len(x) - i) for i in range(1, len(x))]\n    return int(max(res, key=lambda x: (sum(map(int, x)), int(x))))
from itertools import permutations\n\ndef permutation_average(n):\n    perms = [float(''.join(e)) for e in permutations(str(n))]\n    return int(round(sum(perms) / len(perms)))\n
import calendar\n\nM = {calendar.month_name[i]: i - 1 for i in range(1, 13)}\n\n\ndef check_challenge(pledged, current, month):\n    if pledged == current:\n        return "Challenge is completed."\n    m = M[month]\n    per_month, rest = divmod(pledged, 12)\n    todo = per_month * m + (min(rest, m))\n    delta = current - todo\n    if delta == 0 or m == 0:\n        return "You are on track."\n    elif delta > 0:\n        return f"You are {delta} ahead of schedule!"\n    else:\n        return f"You are {-delta} behind schedule."
def day_plan(hours, tasks, duration):\n    td, hm, tmo = tasks * duration, hours * 60, tasks - 1\n    if td > hm: return "You're not sleeping tonight!"\n    arr = [0] * (tasks + tmo)\n    arr[::2], arr[1::2] = [duration] * tasks, [round((hm - td) / (tmo or 1))] * tmo\n    return arr\n
def winner(deck_Steve, deck_Josh):\n    deck = ['2','3','4','5','6','7','8','9','T','J','Q','K','A']\n    Steve = 0\n    Josh = 0\n    for i in range(len(deck_Steve)):\n        if deck.index(deck_Steve[i]) > deck.index(deck_Josh[i]):\n            Steve += 1\n        elif deck.index(deck_Steve[i]) < deck.index(deck_Josh[i]):\n            Josh += 1\n        else:\n            continue\n    if Steve > Josh:\n        return "Steve wins " + str(Steve) + " to " + str(Josh)\n    elif Josh > Steve:\n        return "Josh wins " + str(Josh) + " to " + str(Steve)\n    else:\n        return "Tie"\n
def my_languages(results):\n    return sorted((l for l,r in results.items() if r>=60), reverse=True, key=results.get)
def truncate_string(s,n):\n    return s if len(s)<=n else s[:n if n<=3 else n-3]+'...'
def consonant_count(str):\n    return sum(1 for c in str if c.isalpha() and c.lower() not in "aeiou")\n
def to_binary(n):\n    return "{:0b}".format(n & 0xffffffff)
def validate_code(code):\n    return str(code).startswith(('1', '2', '3'))\n
def harmon_pointTrip(xA, xB, xC):\n    a, b, c = list(map(float, [xA, xB, xC]))\n    # Yay for algebra!\n    d = ((a * c) + (b * c) - (2 * a * b)) / (2 * c - a - b)\n    return round(d, 4)\n
def find_next_power(val, pow_):\n    return int(val ** (1.0 / pow_) + 1) ** pow_
def prefix1(a, b):\n    cnt = 0\n    for i, j in zip(a, b):\n        if i == j:\n            cnt += 1\n        else:\n            return cnt\n    return cnt    \ndef prefix2(a, b, num):\n    for i in range(num, -1, -1):\n        if b.startswith(a[:i]):\n            return i\ndef zfunc(str_):\n    z = []\n    k = len(str_)\n    for i in range(len(str_)):\n        z.append(prefix2(str_[i:], str_[: k - i], k - i))\n        #z.append(prefix1(str_[i:], str_[: k - i]))     #poor timing\n    return z
def capitals_first(string):\n    return ' '.join([word for word in string.split() if word[0].isupper()] + [word for word in string.split() if word[0].islower()])\n
def bin2gray(bits):\n  bits.reverse()\n  return list(reversed([x if i >= len(bits) - 1 or bits[i + 1] == 0 else 1 - x for i, x in enumerate(bits)]))\n  \ndef gray2bin(bits):\n  for i, x in enumerate(bits):\n    if i > 0 and bits[i - 1] != 0: bits[i] = 1 - x\n  return bits
def reverse_fun(n):\n    for i in range(len(n)):\n        n = n[:i] + n[i:][::-1]\n    return n
def hop_across(lst):\n    def one_side(lst):\n        i = 0\n        steps = 0\n        while i < len(lst):\n            i += lst[i]\n            steps += 1\n        return steps\n    return one_side(lst) + one_side(lst[::-1])
def prime_or_composite(n):\n    if n < 4: return 'Probable Prime'\n    if n % 2 == 0: return 'Composite'\n    d, r = n - 1, 0\n    while d % 2 == 0:\n        d, r = d // 2, r + 1\n    for a in [2, 31]:\n        x = pow(a, d, n)\n        if x in (1, n - 1):\n            continue\n        for _ in range(r-1):\n            x = pow(x, 2, n)\n            if x == 1: return 'Composite'\n            if x == n-1: break\n        else: return 'Composite'\n    return 'Probable Prime'\n
def array_operations(a, n):\n  li = []\n  for i in range(n):\n        m = max(a)\n        a = [m-i for i in a] \n        if a in li:\n            if not n & 1 : return li[-1]\n            return a\n        li.append(a)\n  return a
from string import ascii_letters as az\n\n\ndef caesar_crypto_encode(text, shift):\n    if not text:\n        return ''\n    sh = shift % 52\n    return str.translate(text, str.maketrans(az, az[sh:] + az[:sh])).strip()
def shades_of_grey(n):\n  if n > 254:\n    n = 254\n  return ["#%02x%02x%02x" % (i,i,i) for i in range(1,n+1)]
def factor_sum(n):\n    while True:\n        i=2\n        s=0\n        a=n\n        while i<=n:\n            if n%i==0:\n                s+=i\n                n/=i\n                if n==1:\n                    break\n            else:\n                i+=1\n                \n        if a!=s:\n            n=s\n        else:\n            return s
from math import atan2, degrees\n\ndef get_score(x,y):\n    r, a = (x*x + y*y)**0.5, degrees(atan2(y, x)) + 9\n    t = str([6,13,4,18,1,20,5,12,9,14,11,8,16,7,19,3,17,2,15,10][int(a + 360 if a < 0 else a)//18])\n    for l, s in [(6.35, 'DB'),(15.9,'SB'),(99,t),(107,'T'+t),(162,t),(170,'D'+t)]:\n        if r <= l: return s\n    \n    return 'X'    
def find_children(dancing_brigade):\n    return ''.join(sorted(dancing_brigade,key=lambda c:(c.upper(),c.islower())))
def more_zeros(s):\n    results = []\n    \n    for letter in s:\n        dec_repr = bin(ord(letter))[2:]\n        if (dec_repr.count("0") > dec_repr.count("1")) and (letter not in results):\n            results.append(letter)\n    \n    return results\n
def SumEvenFibonacci(limit):\n    a,b,s = 1,1,0\n    while a <= limit:\n        if not a%2: s += a\n        a,b = b, a+b\n    return s
from heapq import *\n\ndef lemming_battle(battlefield, green, blue):\n    hg, hb = ([-v for v in lst] for lst in (green,blue))\n    heapify(hg) ; heapify(hb)\n    \n    while hb and hg:\n        tmp_b,tmp_g = [],[]\n        for _ in range(min(battlefield,len(hg),len(hb))):\n            cmp = heappop(hg) - heappop(hb)\n            if   cmp<0: tmp_g.append(cmp)\n            elif cmp>0: tmp_b.append(-cmp)\n        for lem in tmp_b: heappush(hb,lem)\n        for lem in tmp_g: heappush(hg,lem)\n        \n    winner,lst = ("Green", hg) if hg else ("Blue", hb)\n    survivors  = ' '.join(str(-v) for v in sorted(lst))\n    \n    return ( "Green and Blue died" if not hg and not hb else\n             f"{winner} wins: {survivors}" )
from datetime import *\n\ndef seconds_ago(s,n):\n    return str(datetime.strptime(s, '%Y-%m-%d %H:%M:%S') - timedelta(seconds=n))
def score_matrix(matrix):\n    return sum((-1) ** (i+j) * matrix[i][j] for i in range(len(matrix)) for j in range(len(matrix[i])))\n
def rankings(arr):\n    dct = {v:i for i,v in enumerate(sorted(arr, reverse=True),1)}\n    return [dct[v] for v in arr]
def find_short(s):\n    return min(len(x) for x in s.split())
from collections import Counter\n\ndef play_if_enough(hand, play):\n    h = Counter(hand)\n    p = Counter(play)\n    if p&h == p:\n        h.subtract(p)\n        return (True, "".join(h.elements()))\n    return (False, hand)
from operator import sub, mul\nfrom functools import reduce\n\ndef string_color(string):\n    if len(string) < 2:\n        return None\n    r = sum(map(ord, list(string))) % 256\n    g = reduce(mul, list(map(ord, list(string)))) % 256\n    b = abs(reduce(sub, list(map(ord, list(string))))) % 256\n    return '{:02X}{:02X}{:02X}'.format(r,g,b) \n
def count_me(data):\n    if not data.isdigit():\n        return ''\n    \n    result = []\n    count = 1\n    last = data[0]\n    \n    for char in data[1:]:\n        if char == last:\n            count += 1\n        else:\n            result.append(str(count) + last)\n            last = char\n            count = 1\n    \n    result.append(str(count) + last)\n    \n    return ''.join(result)
def row_weights(array):\n    return sum(array[::2]), sum(array[1::2])\n
def penaltyShots(shots, score):\n    return (2 if shots > 4 else 5 - shots + 1) - abs(score[0] - score[1])\n
def ones_complement(n):\n    return n.translate(str.maketrans("01","10"))
def answer(question, information):\n    score, info = max((sum(word in info.lower().split() for word in question.lower().split()), info) for info in information)\n    return None if not score else info\n
def solve(st):\n    return all(True if ord(x) - ord(y) in [-2, 0, 2] else False for x, y in zip(st, st[::-1]))\n
def round(flash_pile, turtle_pile):\n    faceup_pile = []\n    while turtle_pile:\n        for pile in flash_pile, turtle_pile:\n            faceup_pile.append(pile.pop(0))\n            if len(faceup_pile) >= 2 and faceup_pile[-1] == faceup_pile[-2]:\n                flash_pile.extend(faceup_pile)\n                return True\n\ndef snap(flash_pile, turtle_pile):\n    for i in range(26):\n        if not round(flash_pile, turtle_pile):\n            return i
def computer_to_phone(numbers):\n  return "".join([str({0:0, 1:7, 2:8, 3:9, 4:4, 5:5, 6:6, 7:1, 8:2, 9:3}[int(n)]) for n in numbers])
def create_phone_number(n):\n    return "({}{}{}) {}{}{}-{}{}{}{}".format(*n)
def replace_dots(string):\n    return string.replace('.', '-')
def counting_valleys(s): \n    level = 0\n    in_valley = False\n    count = 0\n    for c in s:\n        if c =='U':\n            level += 1\n        elif c=='D':\n            level -= 1\n        if level >= 0 and in_valley:\n                count += 1\n        in_valley = level < 0\n    return count
pillow=lambda s:('n','B')in zip(*s)
from functools import reduce\n\ndef find_min_max_product(arr, k):        \n    if k <= len(arr):\n        arr   = sorted(arr, key=abs)\n        lasts = arr[-k:]\n        v1    = reduce(int.__mul__, lasts)\n        v0    = reduce(int.__mul__, arr[:k])\n        \n        first_SameOrOpp   = [next((v for v in lasts              if cmp(v<0, v1<0) ), None) for cmp in (int.__eq__, int.__ne__)]\n        prevVal_OppOrSame = [next((v for v in reversed(arr[:-k]) if cmp(v<0, v1<0) ), None) for cmp in (int.__ne__, int.__eq__)]\n        \n        ans = [v0,v1] + [ v1*n//f for f,n in zip(first_SameOrOpp, prevVal_OppOrSame) if None not in (f,n) ]\n        \n        return min(ans), max(ans)\n
def next_item(xs, item):\n    it = iter(xs)\n    for x in it:\n        if x == item:\n            break\n    return next(it, None)
def clean_string(s):\n    stk = []\n    for c in s:\n        if c=='#' and stk: stk.pop()\n        elif c!='#':       stk.append(c)\n    return ''.join(stk)
from math import log\n\ndef decompose(n):\n    i = 2\n    result = []\n    while n >= i*i:\n        k = int(log(n, i))\n        result.append(k)\n        n -= i ** k\n        i += 1\n    \n    return [result, n]\n
import re\nls = ["Zero","One","Two","Three","Four","Five","Six","Seven","Eight","Nine","Ten","Eleven","Twelve","Thirteen"]\ndef max_consec_zeros(n):\n    return ls[max(map(lambda x:len(x),re.findall(r'0*',bin(int(n))[2:])))]
def over_the_road(address, n):\n    '''\n    Input: address (int, your house number), n (int, length of road in houses) \n    Returns: int, number of the house across from your house. \n    '''\n    # this is as much a math problem as a coding one \n    # if your house is [even/odd], the opposite house will be [odd/even] \n    # highest number on street is 2n \n    # Left side houses are [1, 3, ... 2n-3, 2n-1] \n    # Right side houses are [2n, 2n-2, ... 4, 2] \n    # Sum of opposite house numbers will always be 2n+1 \n    return (2*n + 1 - address) 
# -*- coding: utf-8 -*-\ndef build_a_wall(x=0, y=0):\n    if type(x) != int or type(y) != int or x < 1 or y < 1: return\n    if x * y > 10000: return "Naah, too much...here's my resignation."\n    res = [[""]*y if i&1^x&1 else [""] + [""]*(y-1) + [""] for i in range(x)]\n    return '\n'.join(map('|'.join, res))
def smallest_integer(matrix):\n    nums = set(sum(matrix, []))\n    n = 0\n    while n in nums: n += 1\n    return n
from fractions import gcd\nfrom itertools import product, starmap\nfrom statistics import mean\n\ndef gcd_matrix(a, b):\n    return round(mean(starmap(gcd, product(a, b))), 3)
import re\n\ndef debug(s):\n    return re.sub(r'bug(?!s)', '', s)
def quidditch_scoreboard(teams, actions):\n    teams = {i:0 for i in teams.split(' vs ')}\n    for i in actions.split(', '):\n        team, action = i.split(': ')\n        if 'goal' in action:\n            teams[team] += 10\n        elif 'foul' in action:\n            teams[team] -= 30\n        elif 'Snitch' in action:\n            teams[team] += 150\n            break\n    return ', '.join('{}: {}'.format(i, teams[i]) for i in teams)
def pattern(n):\n    return "\n".join(\n        "".join(\n            str((n - min(j, i)) % 10) for j in range(n)\n        )\n        for i in range(max(n, 0))\n    )
def tiaosheng(a):\n    j, t = 0, 0\n    for j in a:\n        t += 3\n        if j + t > 60:\n            return min(j, 60-t+3)\n    return 60-t
def are_similar(a, b):\n    return sorted(a) == sorted(b) and sum(i != j for i, j in zip(a, b)) in [0, 2]
group=lambda arr: [[n]*arr.count(n) for n in sorted(set(arr), key=arr.index)]
def draw_spider(leg_size, body_size, mouth, eye):\n    lleg = ['', '^', '/\\', '/', ''][leg_size]\n    rleg = ['', '^', '/\\', '\\', ''][leg_size]\n    lbody = '(' * body_size\n    rbody = ')' * body_size\n    eye *= 2 ** (body_size - 1)\n    return f'{lleg}{lbody}{eye}{mouth}{eye}{rbody}{rleg}'
def invert(lst):\n    return [-x for x in lst]
def find(a,b,n):\n    strng = str(a) + str(b)\n    #there are 10 and 4 long loops\n    if (n > 20): n = n%20+20\n    while len(strng) <= n:\n        next_ch = int(strng[-1]) + int(strng[-2])\n        strng = strng + str(next_ch)\n    return int(strng[n])
KEYBOARD = "abcde123fghij456klmno789pqrst.@0uvwxyz_/"\nMAP      = {c: (i//8, i%8) for i,c in enumerate(KEYBOARD)}\n\ndef manhattan(*pts): return sum( abs(z2-z1) for z1,z2 in zip(*pts))\n\ndef tv_remote(word):\n    return len(word) + sum( manhattan(MAP[was], MAP[curr]) for was,curr in zip('a'+word, word))
def range_parser(string):\n    res = []\n    for range_ in string.split(','):\n        first_last, _, step = range_.partition(':')\n        first, _, last = first_last.partition('-')\n        res += range(int(first), int(last or first) + 1, int(step or 1))\n    return res
def controller(events):\n\n    out, state, dir, moving = [], 0, 1, False\n    \n    for c in events:\n        if   c == 'O':      dir *= -1\n        elif c == 'P':      moving = not moving\n        if moving:          state += dir\n        if state in [0,5]:  moving, dir = False, 1 if state == 0 else -1\n        out.append(str(state))\n        \n    return ''.join(out)
def solution(items, index, default_value):\n    try:\n        return items[index]\n    except IndexError:\n        return default_value
def alt_or(lst):\n    return any(lst) if lst else None
def how_many_bees(h):\n    if not h: return 0\n    v = list(zip(*h))\n    b = [None] * len(h)\n    sf = (b[i:] + l + b[:i] for i,l in enumerate(h))\n    sb = (b[:i] + l + b[i:] for i,l in enumerate(h))\n    df = [[n for n in l if n is not None] for l in zip(*sf)]\n    db = [[n for n in l if n is not None] for l in zip(*sb)]\n    inline = '\n'.join(map(''.join, h+v+df+db))\n    return (inline + inline[::-1]).count('bee')
from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1: return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for line, idx, val in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef play_OX_3D(moves):\n    grid, lines = [], winning_lines(4, 3)\n    for m in moves:\n        grid.append(tuple(m))\n        if any(line <= set(grid[-1::-2]) for line in lines):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'
def merge_arrays(arr1, arr2):\n    return sorted(set(arr1+arr2))
def transpose(matrix):\n    return list(map(list, zip(*matrix)))
def bishop_diagonal(a, b):\n    a, b = sorted([['abcdefgh'.index(f), '12345678'.index(r)] for f, r in [a, b]])\n    m = int((b[1] - a[1])/(b[0] - a[0])) if abs(a[1] - b[1]) == abs(a[0] - b[0]) and abs(a[1] - b[1]) else 0\n    if m:\n        while all(0 < e < 7 for e in a): a = [a[0] - 1, a[1] - m]\n        while all(0 < e < 7 for e in b): b = [b[0] + 1, b[1] + m]\n    return ['abcdefgh'[c] + '12345678'[r] for c, r in [a, b]]
from operator import mul\nfrom math import factorial\nfrom functools import reduce\nfrom collections import Counter\n\ndef perms(inp):\n    return factorial(len(str(inp))) // reduce(mul, map(factorial, Counter(str(inp)).values()), 1)
def combine(*args):\n  out = list()\n  for i in range(len(max(args, key=len))): #Sometimes you just have to love python\n    for arr in args:\n      if i < len(arr): out.append(arr[i])\n  return out
def calculate(n1, n2, o):\n    operators = {\n        "add": (lambda x, y: x + y),\n        "subtract": (lambda x, y: x - y),\n        "multiply": (lambda x, y: x * y),\n    }\n    \n    return "{:b}".format( operators[o]( int(n1, 2), int(n2, 2) ) )
import re\n\ndef owl_pic(text):\n    str = re.sub('[^ 8,W,T,Y,U,I,O,A,H,X,V,M]', '', text.upper())\n    return str+"''0v0''"+str[::-1]
def move_zeros(arr):\n    l = [i for i in arr if isinstance(i, bool) or i!=0]\n    return l+[0]*(len(arr)-len(l))
def mormons(starting_number, reach, target):\n    missions = 0\n    while starting_number < target:\n        starting_number += starting_number * reach\n        missions += 1\n    return missions\n\n\n# def mormons(start, reach, target, missions=0):\n#     if start >= target:\n#         return missions\n#     return mormons(start + (start * reach), reach, target, missions + 1)\n
def is_anagram(test, original):\n    return sorted(original.lower()) == sorted(test.lower()) 
from numbers import Number\ndef Ackermann(m,n):\n    if isinstance(n, Number) and isinstance(m, Number):\n        if m >= 0 and n >= 0:\n            return Ackermann_Aux(m,n)\n        \n    return None\n\n    \ndef Ackermann_Aux(m,n):\n    \n    if m == 0:\n        return n + 1\n    \n    if m > 0:\n        if n == 0:\n            return Ackermann_Aux(m - 1, 1)\n        \n        if n > 0:\n            return Ackermann_Aux(m - 1 , Ackermann_Aux(m, n - 1))\n
def palindrome(num):\n    if type(num) != int or num < 0: return "Not valid"\n    s = str(num)\n    for i in range(len(s)-2):\n        if s[i] == s[i+1] or s[i] == s[i+2]: return True\n    return len(s) != 1 and s[-1] == s[-2]
import re\ndef replace_dashes_as_one(s):\n    return re.sub(r'-[ -]+-|-+',r'-',s)
import re\n\nPATTERN = re.compile("^"\n    "M{0,4}"             # thousands\n    "(CM|CD|D?C{,3})"    # hundreds\n    "(XC|XL|L?X{,3})"    # tens\n    "(IX|IV|V?I{,3})"    # units\n    "$")\n\ndef valid_romans(arr):\n    return [e for e in arr if e and PATTERN.match(e)]
from itertools import permutations\n\ndef find_mult_3(num):\n    num_list = tuple(map(int, str(num)))\n    \n    poss = set()\n    for i in range(1, len(num_list)+1):\n        poss |= set(permutations(num_list, i))\n    \n    res = set()\n    for p in poss:\n        if p[0] != 0 and sum(p) % 3 == 0:\n            res.add(p)\n\n    res = [sum(x * 10**n for n, x in enumerate(p[::-1])) for p in res]\n    return [len(res), max(res)]\n
def finance(n):\n    return n * (n + 1) * (n + 2) / 2
def egged(year, span):   \n    total = 0\n    eggs_per_chicken = 300\n    for i in range(min(span,year)):\n        total += 3 * eggs_per_chicken\n        eggs_per_chicken = int(eggs_per_chicken * 0.8)\n        \n    return total or "No chickens yet!"
def number_increasing(n):\n    return n not in {2, 4, 7, 12, 17, 22} and n % 5 != 0\n
def animals(heads, legs):\n    chickens, cows = 2*heads-legs/2, legs/2-heads\n    if chickens < 0 or cows < 0 or not chickens == int(chickens) or not cows == int(cows):\n        return "No solutions"\n    return chickens, cows
op = {'+': 'Plus ','-': 'Minus ','*': 'Times ', '/': 'Divided By ', '**': 'To The Power Of ', '=': 'Equals ', '!=': 'Does Not Equal '}\nnum = {'1': 'One', '2': 'Two', '3': 'Three', '4': 'Four', '5': 'Five', '6': 'Six', '7':'Seven', '8': 'Eight', '9': 'Nine', '10': 'Ten'}\n    \ndef expression_out(e):\n    a, b, c = e.split()\n    try    : return num[a]+' '+op[b]+num[c]\n    except : return 'That\'s not an operator!'
def binary_string_to_int(string):\n    return sum((d == '1') * 2**i for i, d in enumerate(string[::-1]))\n\ndef add(a, b):\n    return '{:b}'.format(binary_string_to_int(a) + binary_string_to_int(b))
def scoreboard(who_ate_what):\n    scores = {'chickenwings': 5, 'hamburgers': 3, 'hotdogs': 2}\n    return sorted((\n        {'name': person.pop('name'),\n         'score': sum(scores.get(k, 0) * v for k, v in list(person.items()))}\n        for person in who_ate_what), key=lambda a: (-a['score'], a['name']))\n
def logistic_map(width,height,xs,ys):\n    return [ [ min([abs(x-x2)+abs(y-ys[i]) for (i,x2) in enumerate(xs)]) if len(xs) else None for x in range(width) ] for y in range(height) ]
def single_digit(n):\n    while n > 9:\n        n = bin(n).count("1")\n    return n
def powers_of_two(n):\n    return [2**x for x in range(n+1)]
def positive_sum(arr):\n    return sum(x for x in arr if x > 0)\n
def whoseMove(lastPlayer, win):\n    return lastPlayer if win else 'white' if lastPlayer == 'black' else 'black'
from collections import Counter\n\ndef string_letter_count(s):\n    cnt = Counter(c for c in s.lower() if c.isalpha())\n    return ''.join(str(n)+c for c,n in sorted(cnt.items()))
def count_deaf_rats(town):\n    return town.replace(' ', '')[::2].count('O')
import re\n\ndef double_check(str):\n    return bool(re.search(r"(.)\1", str.lower()))
def make_2d_list(head,row,col):\n    return [[head + c + r*col for c in range(col)] for r in range(row)]
def gc_content(seq):\n    if not seq :\n        return 0.0\n    else:\n        res = seq.count("C")+seq.count("G")\n        return round(res*100/len(seq),2)\n
def processes(start, end, processes):\n  '''Dijkstra's shortest path algorithm'''\n  q = [(start,[])]\n  visited = set()\n  \n  while q:\n      s, path = q.pop(0)\n      if s == end: return path\n      visited.add(s)\n      for p in [x for x in processes if x[1] == s]:\n          if not p[2] in visited:\n              q.append((p[2], path + [p[0]]))\n  return []\n
def parse_character(char):\n    if 65 <= ord(char) <= 90:\n        return chr(155 - ord(char))\n    elif 97 <= ord(char) <= 122:\n        return chr(219 - ord(char))\n    else:\n        return char\n\ndef decode(string_):\n    if not isinstance(string_, str):\n        return "Input is not a string"\n    return "".join(map(parse_character, string_))
def closest(lst):\n    m = min(lst, key=abs)\n    return m if m == 0 or -m not in lst else None
def sxore(n):\n    return [n, 1, n + 1, 0][n % 4]
def penalty(lst):\n    lst, maxLen = list(map(str, lst)), max(map(len, lst))\n    return ''.join(sorted(lst, key=lambda s: s.ljust(maxLen, s[-1])))
def decrypt(s):\n    return next((str(b // 11) for b in (int(str(a) + s) for a in range(1, 11)) if b % 11 == 0), 'impossible')
def createDict(keys, values):\n    while len(keys) > len(values):\n        values.append(None)\n    \n    dictionary = dict(list(zip(keys, values))) \n    return dictionary\n
def decode(s):\n    return s.translate(str.maketrans("1234567890", "9876043215"))
def convert(number):\n    return ''.join(chr(int(number[a:a + 2])) for a in range(0, len(number), 2))\n
def pac_man(size, pacman, enemies):\n    px, py = pacman\n    mx, my, Mx, My = -1, -1, size, size\n    for x, y in enemies:\n        if x < px and x > mx: mx = x\n        if y < py and y > my: my = y\n        if x > px and x < Mx: Mx = x\n        if y > py and y < My: My = y\n    return (Mx - mx - 1) * (My - my - 1) - 1
def create_octahedron(size):\n    if size <= 1 or size % 2 == 0:\n        return []\n    m = size // 2\n    return [[[int(abs(x - m) + abs(y - m) + abs(z - m) <= m)\n        for z in range(size)]\n        for y in range(size)]\n        for x in range(size)]
H, W     = 6, 8\nKEYBOARD = [ "abcde123fghij456klmno789pqrst.@0uvwxyz_/\u000e ",\n             "ABCDE123FGHIJ456KLMNO789PQRST.@0UVWXYZ_/\u000e ",\n             "^~?!'\"()-:;+&%*=<>$\\[]{},.@#\u000e\u000e\u000e_/\u000e "]\nMAP      = [ {c: (i//W, i%W) for i,c in enumerate(KEYBOARD[x])} for x in range(len(KEYBOARD)) ]\n\n\ndef manhattan(*pts):\n    dxy = [abs(z2-z1) for z1,z2 in zip(*pts)]\n    return 1 + sum( min(dz, Z-dz) for dz,Z in zip(dxy, (H,W)) )\n\ndef tv_remote(words):\n    cnt, mod, was = 0, 0, 'a'\n    for c in words:\n        while c not in KEYBOARD[mod]:\n            cnt += manhattan(MAP[mod][was], MAP[mod]['\u000e'])\n            was = '\u000e'\n            mod = (mod+1) % 3\n        cnt += manhattan(MAP[mod][was], MAP[mod][c])\n        was  = c\n    return cnt
import re, math\n\ndef convert_recipe(recipe):\n    \n    def repl(m):\n        ratio = 15 if m.group(2) == "tbsp" else 5\n        return m.group(0) + " (%sg)" % math.ceil(eval(m.group(1)) * ratio)\n    \n    return re.sub("([0-9/]+) (tb?sp)", repl, recipe)
def fizz_buzz_cuckoo_clock(t):\n    h, m = list(map(int, t.split(':')))\n    h = h-12 if h > 12 else h+12 if h == 0 else h\n    \n    if m == 0:\n        return ' '.join('Cuckoo' for i in range(h))\n    if m == 30:\n        return 'Cuckoo'\n    if m%3 == 0 and m%5 == 0:\n        return 'Fizz Buzz'\n    if m%3 == 0:\n        return 'Fizz'\n    if m%5 == 0:\n        return 'Buzz'\n    return 'tick'\n    \n
def power_of_two(x):\n    return x != 0 and ((x & (x - 1)) == 0)
def int_diff(arr, n):\n    num=0\n    for i in range(len(arr)):\n        for j in range(i+1,len(arr)):\n            if abs(arr[i]-arr[j])==n:\n                num+=1\n    return num
def unique_in_order(iterable):\n    result = []\n    prev = None\n    for char in iterable[0:]:\n        if char != prev:\n            result.append(char)\n            prev = char\n    return result
import math\n\neffectiveness = {\n    "electric":{\n      "electric": 0.5,\n      "fire": 1,\n      "grass": 1,\n      "water": 2\n    },\n    "fire":{\n      "electric": 1,\n      "fire": 0.5,\n      "grass": 2,\n      "water": 0.5\n    },\n    "grass":{\n        "electric": 1,\n        "fire": 0.5,\n        "grass": 0.5,\n        "water": 2\n    },\n    "water":{\n        "electric": 0.5,\n        "fire": 2,\n        "grass": 0.5,\n        "water": 0.5\n    }\n}\n\ndef calculate_damage(your_type, opponent_type, attack, defense):\n    return math.ceil(50 * (attack / defense) * effectiveness[your_type][opponent_type]);
def zipvalidate(postcode):\n    return len(postcode) == 6 and postcode.isdigit() and postcode[0] not in "05789"
def char_to_ascii(string):\n    return {c: ord(c) for c in set(string) if c.isalpha()} if len(string) else None
def promenade(choices):\n    \n    def compute(): return l+r,m+s\n    \n    l,m, r,s = 1,0, 0,1\n    for c in choices:\n        if c=='L': l,m = compute()\n        else:      r,s = compute()\n        \n    return compute()
def encode(s):\n    return ''.join( str(1 - ord(c)%2) if c.isalpha() else c for c in s )
def get_neighbourhood(typ, arr, coordinates):\n    \n    def isInside(x,y): return 0 <= x < len(arr) and 0 <= y < len(arr[0])\n    \n    x,y = coordinates\n    if not isInside(x,y): return []\n    \n    neigh = ( [(dx, dy) for dx in range(-1,2) for dy in range(-1,2) if (dx,dy) != (0,0)]\n                  if typ == 'moore' else [(0,1), (0,-1), (1,0), (-1,0)] )\n    \n    return [ arr[a][b] for a,b in ((x+dx,y+dy) for dx,dy in neigh) if isInside(a,b) ]
def automorphic(n):\n    return "Automorphic" if str(n*n).endswith(str(n)) else "Not!!"
def get_section_id(scroll, sizes):\n    c = 0\n    for idx, s in enumerate(sizes):\n        c += s\n        if scroll < c: return idx\n    return -1
def validPhoneNumber(phoneNumber):\n    import re\n    return bool(re.match(r"^(\([0-9]+\))? [0-9]+-[0-9]+$", phoneNumber))
def christmas_tree(h):\n  return "" if h<3 else "\r\n".join(["\r\n".join([" "*(((5-y)//2)+(h//3)-i-1)+"*"*(y+i*2) for y in [1,3,5]]) for i in range(h//3)])+"\r\n"+" "*(h//3)+"###"
score=lambda n:2**n.bit_length()-1
def next_letter(string):\n    return "".join(chr(ord(c)+(-25 if c in 'zZ' else 1)) if c.isalpha() else c for c in string)
def travel(total_time, run_time, rest_time, speed):\n    q, r = divmod(total_time, run_time + rest_time)\n    return (q * run_time + min(r, run_time)) * speed\n
def sort_me(arr):\n    return sorted(arr, key=lambda elem: str(elem)[-1])
def center_of(chars):\n    if not chars:\n        return ""\n    total=0\n    res=[]\n    for i in range(1,len(chars)*2+1):       \n        if i%2==1:\n            res.append((i+1)//2+total)\n            res[-1]=chars[(res[-1]-1)%len(chars)]\n        total+=i\n    res="".join(res)\n    for i in range(len(res)//2+1):\n        if len(res)%len(res[:i+1])!=0:\n            continue\n        if res[:i+1]*(len(res)//len(res[:i+1]))==res:\n            return res[:i+1]\n    return res
from collections import defaultdict\nSQUARES = [x**2 for x in range(1, 3163)]\nDIGITS  = defaultdict(int)\nfor sqr in SQUARES:\n    DIGITS[''.join(sorted(str(sqr)))] += 1\n\ndef sort_by_perfsq(arr):\n    return sorted(arr, key=lambda n: (-DIGITS[''.join(sorted(str(n)))], n))
def max_product(lst, n_largest_elements):\n    lst_largest = sorted(lst)[-n_largest_elements:]\n    prod = 1\n    for number in lst_largest:\n        prod *= number\n    return prod
from ipaddress import IPv4Address\n\ndef numberAndIPaddress(s):\n    return str(int(IPv4Address(s))) if '.' in s else str(IPv4Address(int(s)))
def can_i_play(now_hour, start_hour, end_hour):\n      return 0<=(now_hour-start_hour)%24<(end_hour-start_hour)%24\n
def pattern(n):\n    nums = '1234567890'\n    str_nums = nums*(n//10) + nums[:n%10]\n    return '\n'.join(' '*(n - i - 1) + str_nums + ' '*i for i in range(n))\n
n,forbid = 100000, set("2357")\nsieve, notPrimes = [0]*(n+1), [1]\nfor i in range(2, n+1):\n    if sieve[i]:\n        if not (forbid & set(str(i))): notPrimes.append(i)\n    else:\n        for j in range(i**2, n+1, i):  sieve[j] = 1\n\ndef solve(n): return notPrimes[n]
def order(sentence):\n    return " ".join(sorted(sentence.split(), key=lambda x: int("".join(filter(str.isdigit, x)))))\n
def conference_picker(cities_visited, cities_offered):\n    for city in cities_offered:\n        if city not in cities_visited:\n            return city\n    return 'No worthwhile conferences this year!'
def puzzle_tiles(width, height):\n    def f():\n        yield '  ' + ' _( )__' * width\n        for i in range(height):\n            if i % 2 == 0:\n                yield ' _|' + '     _|' * width\n                yield '(_' + '   _ (_' * width\n                yield ' |' + '__( )_|' * width\n            else:        \n                yield ' |_' + '     |_' * width\n                yield '  _)' + ' _   _)' * width\n                yield ' |' + '__( )_|' * width\n    return '\n'.join(f())
def array_plus_array(arr1,arr2):\n    return sum(arr1+arr2)\n
def traffic_jam(road, sides):\n    X    = road.index("X")\n    main = list(road[:X+1])\n    \n    for i in reversed(range( min(X,len(sides)) )):\n        tmp = []\n        for j in range(1, min(len(main)-i-1, len(sides[i]))+1 ):\n            tmp.append(sides[i][-j])\n            tmp.append(main[i+j])\n        main[i+1:i+len(tmp)//2+1] = tmp\n    \n    return ''.join(main)
def is_divisible_by_6(s):\n    all_numbers = [ int(s.replace('*', str(n))) for n in range(10) ]\n    return [ str(n) for n in all_numbers if n % 6 == 0 ]
def beggars(values, n):\n    return [sum(values[i::n]) for i in range(n)]
def string_to_number(s):\n    return int(s)
def isTree(matrix):\n    visited_nodes = set([0])\n    crossed_edges = set()\n    agenda = [0]\n\n    while agenda:\n        node = agenda.pop()\n        for i in matrix[node]:\n            if (node, i) in crossed_edges: continue \n            if i in visited_nodes: return False\n            agenda.append(i)\n            crossed_edges.add( (i, node) )\n            visited_nodes.add(i)\n    \n    return len(visited_nodes) == len(matrix)
import re\ndef AlphaNum_NumAlpha(string):\n    return re.sub( r'[0-9]{1,2}|[a-z]', lambda x:str(ord(x.group() )-96) if x.group().isalpha() else chr(int(x.group())+96)  , string)\n    \n    #\w\n
def convert_hash_to_array(hash):\n    return sorted(map(list, hash.items()))
def rank(st, we, n):\n    if not st:\n        return "No participants"\n    \n    if n>len(we):\n        return "Not enough participants"\n\n    name_score = lambda name,w: w*(len(name)+sum([ord(c.lower())-96for c in name]))\n    \n    scores= [name_score(s,we[i]) for i,s in enumerate(st.split(','))]\n    \n    scores = list(zip(st.split(','),scores))    \n    \n    scores.sort(key=lambda x: (-x[1],x[0]))\n    \n    return scores[n-1][0]
def set_alarm(employed, vacation):\n    return employed and not vacation
def diff(poly):\n  return [poly[i] * (len(poly)-1-i) for i in range(len(poly)-1)]
import hashlib\ndef crack(hash):\n    for i in range(100000):\n        if hashlib.md5(str(i).zfill(5).encode()).hexdigest() == hash:\n            return str(i).zfill(5)
def find_the_missing_tree(trees):\n  return sorted(trees, key=trees.count)[0]
def to_freud(sentence):\n    return ' '.join('sex' for _ in sentence.split())\n
BASE = {"H": 50, "Q": 25, "D": 10, "N": 5, "P": 1}\n\ndef make_change(n):\n    r = {}\n    for x, y in BASE.items():\n        if n >= y:\n            r[x], n = divmod(n, y)\n    return r
def alphabetized(s):\n    return "".join(sorted(filter(str.isalpha, s),key=str.lower))\n
import re\nfrom datetime import date, timedelta\n\ndef date_correct(text):\n    if not text:\n        return text\n    try:\n        d, m, y = map(int, re.match(r'^(\d{2})\.(\d{2})\.(\d{4})$', text).groups())\n        mo, m = divmod(m - 1, 12)\n        return (date(y + mo, m + 1, 1) + timedelta(days=d - 1)).strftime('%d.%m.%Y')\n    except AttributeError:\n        return None
from math import pi\n\ndef iter_pi(epsilon):\n    n = 1\n    approx = 4\n    while abs(approx - pi) > epsilon:\n        n += 1\n        approx += (-4, 4)[n % 2] / (n * 2 - 1.0)\n    return [n, round(approx, 10)]
def is_hollow(x):\n    while x and x[0] != 0 and x[-1] != 0: x = x[1:-1]\n    return len(x) > 2 and set(x) == {0}
from collections import Counter\n\n\ndef self_descriptive(num):\n    s = [int(a) for a in str(num)]\n    cnt = Counter(s)\n    return all(cnt[i] == b for i, b in enumerate(s))\n
def double_every_other(l):\n    return [x * 2 if i % 2 else x for i, x in enumerate(l)]
from collections import defaultdict\n\ndef dec(n):\n    decomp = defaultdict(lambda:0)\n    i = 2\n    while n > 1:\n        while n % i == 0:\n            n /= i\n            decomp[i] += 1\n        i += 1\n    return decomp\n            \n\ndef decomp(n):\n    ans = defaultdict(lambda:0)\n    for i in range(2, n + 1):\n        for key, value in dec(i).items():\n            ans[key] += value\n    return ' * '.join('{}^{}'.format(x, y) if y > 1 else str(x) for x, y in sorted(ans.items()))
def expanded_form(num):\n    integer_part, fractional_part = str(num).split('.')\n\n    result = [str(int(num) * (10 ** i)) for i, num in enumerate(integer_part[::-1]) if num != '0'][::-1]\n    result += [str(num) + '/' + str(10 ** (i + 1)) for i, num in enumerate(fractional_part) if num != '0']\n\n    return ' + '.join(result)\n
def create_report(names):\n    result = {}\n    \n    for name in names:\n        if name.startswith("Labrador Duck"):\n            return ["Disqualified data"]\n        \n        name = name.upper().replace("-", " ").split()\n        count = int(name.pop())\n        \n        if   len(name) == 1:  code = name[0][:6]\n        elif len(name) == 2:  code = name[0][:3] + name[1][:3]\n        elif len(name) == 3:  code = name[0][:2] + name[1][:2] + name[2][:2]\n        elif len(name) == 4:  code = name[0][0] + name[1][0] + name[2][:2] + name[3][:2]\n        \n        if code in result:    result[code] += count\n        else:                 result[code] = count\n    \n    return sum([[name, result[name]] for name in sorted(result)] , [] )
from itertools import product\nimport re\n\nKEY = [ a+b for a, b in product("ADFGX", repeat=2) ]\n   \n\ndef adfgx_encrypt(plaintext, square):\n    d      = dict(zip(square, KEY))\n    oddity = d['i'] if 'i' in d else d['j']\n    return ''.join(d.get(c, oddity) for c in plaintext)\n    \n    \ndef adfgx_decrypt(ciphertext, square):\n    d      = dict(zip(KEY, square))\n    IJkey  = [ k for k, v  in d.items() if v in 'ij'].pop()\n\n    return ''.join( d.get(c, d[IJkey]) for c in re.findall(r'.{2}', ciphertext)) 
def solve(s):\n  uc, lc, num, sp = 0, 0, 0, 0\n  for ch in s:\n    if ch.isupper(): uc += 1\n    elif ch.islower(): lc += 1\n    elif ch.isdigit(): num += 1\n    else: sp += 1\n  return [uc, lc, num, sp]
def max_profit(prices):\n    m = best = float('-inf')\n    for v in reversed(prices):\n        m, best = max(m, best-v), max(best,v)\n    return m
def check_valid_tr_number(n):\n    return type(n) == int and len(str(n)) == 11 and \\n    8*sum(map(int, str(n)[:-1:2])) % 10 == sum(map(int, str(n)[:-1])) % 10 == n % 10
from math import factorial\n\nfib = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\n\ndef sum_fib(n):\n    return sum( factorial(x) for x in fib[:n] )
def count_squares(n):\n    return sum([i * i for i in range(n + 1 ) ] )
def same_encryption(s1, s2):\n    return (s1[0], s1[-1], len(s1) % 9) == (s2[0], s2[-1], len(s2) % 9)
from collections import Counter\ndef common(a,b,c):\n    return sum((Counter(a) & Counter(b) & Counter(c)).elements())
def is_int_array(a):\n    return isinstance(a, list) and all(isinstance(x, (int, float)) and x == int(x) for x in a)
from itertools import count\n\ndef spinning_rings(inner_max, outer_max):\n    return next(i for i in count(1) if i % (outer_max + 1) == -i % (inner_max + 1))
def solve(arr):\n    \n    p, q = 1, 1\n    \n    for k in arr:\n        \n        x, y = max(k), min(k)\n        \n        a = p * x\n        b = q * x\n        c = p * y\n        d = q * y\n        \n        p = max(a, b, c, d)\n        q = min(a, b, c, d)\n            \n    return max(p, q)
from math import ceil\ndef pay_cheese(arr):\n    return f'L{ceil(sum(arr) / 100) * 35}'
def digits_product(product):\n    if product < 10:\n        return 10 + product\n    n = ''\n    for d in range(9, 1, -1):\n        while not product % d:\n            n += str(d)\n            product //= d\n    return int(n[::-1]) if product == 1 else -1
def bar_triang(a, b, c):\n    return [round(sum(x)/3.0, 4) for x in zip(a, b, c)]
def esrever(s):\n    return s[:-1][::-1] + s[-1] if s else ''
def find_a_b(numbers,c):\n    for i, a in enumerate(numbers, 1):\n        for b in numbers[i:]:\n            if a * b == c: return [a, b]
def split_exp(n):\n    dot = n.find('.')\n    if dot == -1: dot = len(n)\n    return [d+"0"*(dot-i-1) if i<dot else ".{}{}".format("0"*(i-dot-1), d)\n            for i,d in enumerate(n) if i != dot and d != '0']
def to_bytes(n):\n    if not n:\n        return ['00000000']\n    \n    res = []\n    while n:\n        res.append('{:08b}'.format(n % 256))\n        n //= 256\n    \n    return res[::-1]
def human_years_cat_years_dog_years(x):\n    return [x, 24+(x-2)*4 if (x != 1) else 15, 24+(x-2)*5 if (x != 1) else 15]
sequence=lambda n:int(format(n,'b'),3)
def luck_check(string):\n    e0, b1 = len(string) // 2, (len(string) + 1) // 2\n    return sum(map(int, string[:e0])) == sum(map(int, string[b1:]))
def zeros(n):\n    """\n    No factorial is going to have fewer zeros than the factorial of a smaller\n    number.\n\n    Each multiple of 5 adds a 0, so first we count how many multiples of 5 are\n    smaller than `n` (`n // 5`).\n\n    Each multiple of 25 adds two 0's, so next we add another 0 for each multiple\n    of 25 smaller than n.\n\n    We continue on for all powers of 5 smaller than (or equal to) n.\n    """\n    pow_of_5 = 5\n    zeros = 0\n    \n    while n >= pow_of_5:\n        zeros += n // pow_of_5\n        pow_of_5 *= 5\n        \n    return zeros
def lucasnum(n):\n    a = 2\n    b = 1\n\n    flip = n < 0 and n % 2 != 0\n\n    for _ in range(abs(n)):\n        a, b = b, a + b\n    \n    return -a if flip else a
from itertools import permutations\n\ndef late_clock(digits):\n  for p in permutations(sorted(digits, reverse=True)):\n    if p[0] > 2 or (p[0] == 2 and p[1] > 3) or p[2] > 5: continue\n    return '{}{}:{}{}'.format(*p)
def remainder(dividend,divisor):\n    while divisor <= dividend:\n      dividend = dividend - divisor\n    return dividend
def build_palindrome(s):\n    for n in range(len(s), -1, -1):\n        if s[:n] == s[:n][::-1]:\n            return s[n:][::-1] + s\n        if s[-n:] == s[-n:][::-1]:\n            return s + s[:-n][::-1]
def distribution_of(golds):\n    g = golds[:]\n    turn, total = 0, [0, 0]\n    while g:\n        total[turn % 2] += g.pop(-(g[0] < g[-1]))\n        turn += 1\n    return total\n
def pattern(n):\n    lines = []\n    for i in range(1, n + 1):\n        line = ' ' * (n - i)\n        line += ''.join(str(j % 10) for j in range(1, i + 1))\n        line += line[::-1][1:]\n        lines.append(line)\n    return '\n'.join(lines + lines[::-1][1:])\n
def x(n):    \n    d = [[0] * n for i in range (n)]\n    for i in range(n):\n        d[i][i] = 1\n        d[i][-i-1] = 1\n    return d
def sort_array(xs):\n    es = sorted(x for x in xs if x % 2 == 0)\n    os = sorted((x for x in xs if x % 2 != 0), reverse=True)\n    return [(es if x % 2 == 0 else os).pop() for x in xs]
from itertools import chain\n\ndef hyperrectangularity_properties(arr):\n    hr, arr = [], [arr]\n    while 1:\n        check = sum(isinstance(v, int) for v in arr)        # Check homogeneity\n        if check or not arr:                                # some int are present or empty array (edge case)\n            if check == len(arr): return tuple(hr)          # only int: found the bottom of the tree\n            break\n            \n        l = set(map(len,arr))\n        if len(l) > 1: break                                # invalid if different length found\n        hr.append(l.pop())\n        arr = list(chain.from_iterable(arr))                # get the "lower level"
TO_KELVIN = {\n    'C': (1, 273.15),\n    'F': (5.0 / 9, 459.67 * 5.0 / 9),\n    'R': (5.0 / 9, 0),\n    'De': (-2.0 / 3, 373.15),\n    'N': (100.0 / 33, 273.15),\n    'Re': (5.0 / 4, 273.15),\n    'Ro': (40.0 / 21, -7.5 * 40 / 21 + 273.15),\n}\n\ndef convert_temp(temp, from_scale, to_scale):\n    if from_scale == to_scale:\n        return temp\n    if from_scale != 'K':\n        (a, b) = TO_KELVIN[from_scale]\n        temp = a * temp + b\n        if to_scale == 'K':\n            return int(round(temp))\n    (a, b) = TO_KELVIN[to_scale]\n    return int(round((temp - b) / a))\n
def e(s):return f([*s,'+'])\ndef f(s,r=0,o=0,x='',c=0):\n while s and')'!=c:\n  c=s.pop(0);i='+-*/)('.find(c)\n  if c=='-'>x or i<0:x+=c\n  elif c=='(':x=str(f(s))\n  elif i>-1:a=float(x);r=[r+a,r-a,r*a,r/a][o];o=i;x=''\n return r
def greet(name): \n    return f'Hello {name.title()}!'
def drop_cap(str_):\n    return ' '.join( w.capitalize() if len(w) > 2 else w for w in str_.split(' ') )\n
def reverse(n):\n    m = 0\n    while n > 0:\n        n, m = n // 10, m * 10 + n % 10\n    return m
def solve(s):\n    r, l = 0, 0\n    for c in s:\n        m = ord('Z') - ord(c)\n        r, l = r + m + l * m, m + l * 26\n    return r % 1000000007
REMOVE_VOWS = str.maketrans('','','aeiou')\n\ndef remove_vowels(s):\n    return s.translate(REMOVE_VOWS)
def populate_dict(keys, default):\n    return {key: default for key in keys}
digits = 'zero one two three four five six seven eight nine'.split()\n\ndef f(n):\n    return ''.join(map(digits.__getitem__, map(int, str(n))))\n\ndef numbers_of_letters(n):\n    result = [f(n)]\n    print(n, result)\n    while result[-1] != 'four':\n        result.append(f(len(result[-1])))\n    return result
def prime(a):\n    if a < 2: return False\n    if a == 2 or a == 3: return True   \n    if a % 2 == 0 or a % 3 == 0: return False\n    maxDivisor = a**0.5\n    d, i = 5, 2\n    while d <= maxDivisor:\n        if a % d == 0: return False\n        d += i \n        i = 6 - i\n \n    return True\n\ndef prime_bef_aft(num):\n    res = []\n    for n in range(num-1, 1, -1):\n        if prime(n):\n            res.append(n)\n            break\n    for n in range(num+1, 3*num, 1):\n        if prime(n):\n            res.append(n)\n            break\n    return res
def match(usefulness, months):\n    return "Match!" if sum(usefulness) >= 0.85**months * 100 else "No match!"
def absent_vowel(x): \n    return ['aeiou'.index(i) for i in 'aeiou' if i not in x][0]
def rot_energies(B, Jmin, Jmax):\n    return [B * J * (J + 1) for J in range(Jmin, Jmax + 1)] if B > 0 else []
def bonus_time(salary, bonus):\n    return "${}".format(salary * (10 if bonus else 1))
from bisect import bisect_left as keep_order
from itertools import chain\ndef how_many_bees(hive):\n        return bool(hive) and sum(s.count('bee') + s.count('eeb') for s in map(''.join, chain(hive, zip(*hive))))
def fuel_price(litres, price_per_liter):\n    discount = int(min(litres, 10)/2) * 5 / 100\n    return round((price_per_liter - discount) * litres, 2)
def find(r):\n    return sum(2**i for i in r)
D, R = {}, [[], [], []]\nfor i in range(10000):\n    D[i] = D.get(i - 1, 0) + i\n    R[D[i]%3].append(D[i])\n    \ndef same_col_seq(val, k, col):\n    r = ['blue', 'red', 'yellow'].index(col)\n    return [e for e in R[r] if e > val][:k]    
def row_sum_odd_numbers(n):\n    #your code here\n    return n ** 3
from string import punctuation\n\nt = str.maketrans("", "", punctuation)\n\ndef pseudo_sort(s):\n    a = s.translate(t).split()\n    b = sorted(x for x in a if x[0].islower())\n    c = sorted((x for x in a if x[0].isupper()), reverse=True)\n    return " ".join(b + c)
def duplicates(arr):\n    return sum(arr.count(i)//2 for i in set(arr))
def target_game(values):\n    a = b = 0\n    for n in values:\n        a, b = b, max(a + n, b)\n    return max(a, b)
def band_name_generator(name):\n    return name.capitalize()+name[1:] if name[0]==name[-1] else 'The '+ name.capitalize()
def group_groceries(groceries):\n    categories = {"fruit": [], "meat": [], "other": [], "vegetable": []}\n    for entry in groceries.split(","):\n        category, item = entry.split("_")\n        categories[category if category in categories else "other"].append(item)\n    return "\n".join([f"{category}:{','.join(sorted(items))}" for category, items in categories.items()])
from functools import reduce\nVALID = frozenset('abcdefABCDEF')\n\n\ndef fisHex(s):\n    return reduce(lambda b, c: b ^ c, (int(a, 16) for a in s if a in VALID), 0)\n
def repeat_str(repeat, string):\n    return repeat * string
def insert_dash2(num):\n    \n    prev = 0\n    out = ''\n\n    for dig in str(num):\n        if int(dig) % 2 == int(prev) % 2 and int(prev) and int(dig):\n            out += '*-'[int(prev) % 2]\n        out += dig\n        prev = dig\n    return out
def base_finder(seq):\n    return len(set(''.join(seq)))
def flatten(lst):\n    r = []\n    for x in lst:\n       if type(x) is list:\n          r.extend(x)\n       else:\n          r.append(x)\n    return r 
def deficiently_abundant_amicable_numbers(a,b):\n    c,d = list(map(sumOfDivs,(a,b)))\n    return f'{ kind(a,c)} { kind(b,d) } { "not "*(a!=d or b!=c or a==b) }amicable'\n\ndef kind(n,sD):   return 'abundant' if sD>n else 'perfect' if sD==n else 'deficient'\ndef sumOfDivs(n): return sum(d for d in range(1,int(n/2+1)) if not n%d)\n
from collections import Counter\nfrom functools import reduce\nfrom fractions import gcd\n\ndef has_subpattern(s):\n    c = Counter(s)\n    m = reduce(gcd, c.values())\n    return ''.join(sorted(k*(v//m) for k,v in c.items()))
geese = {"African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"}\n\ndef goose_filter(birds):\n    return [bird for bird in birds if bird not in geese]
from itertools import groupby\n\n\ndef group_ints(lst, key=0):\n    return [list(g) for _, g in groupby(lst, lambda a: a < key)]\n\n\n# PEP8: function name should use snake_case\ngroupInts = group_ints
class Solution:\n    def bitwiseComplement(self, N: int) -> int:\n        return (1 << len(bin(N))-2) - N - 1
import re\ns = input()\nresult = re.findall(r'(?<=[QWRTYPSDFGHJKLZXCVBNMqwrtypsdfghjklzxcvbnm])([AEIOUaeiou]{2,})(?=[QWRTYPSDFGHJKLZXCVBNMqwrtypsdfghjklzxcvbnm])',s)\nif result:\n    for i in result:\n        print(i)\nelse:\n    print((-1))\n
for _ in range(int(input())):\n    n, m, a, b = list(map(int, input().split()))\n    if a * n != b * m:\n        print('NO')\n    else:\n        ar = []\n        for i in range(n):\n            ar.append([0] * m)\n        x, y = 0, a\n        for i in range(n):\n            if x < y:\n                for j in range(x, y):\n                    ar[i][j] = 1\n            else:\n                for j in range(x, m):\n                    ar[i][j] = 1\n                for j in range(y):\n                    ar[i][j] = 1\n            x += a\n            y += a\n            x %= m\n            y %= m\n        print('YES')\n        for i in range(n):\n            print(''.join(map(str, ar[i])))
def connect_four_place(columns):\n    player, board, placed = 1, [['-']*7 for _ in range(6)], [-1]*7\n    for c in columns:\n        player ^= 1\n        board[placed[c]][c] = "YR"[player]\n        placed[c] -= 1\n    return board\n
def to_acronym(input):\n  # only call upper() once\n  return ''.join(word[0] for word in input.split()).upper()
class T:\n    def __init__(self,value,left=None,right=None):\n        self.value=value\n        self.left=left\n        self.right=right\n\n\ndef is_bst(node):\n\n    def extract(node):\n        if node is not None:\n            yield from extract(node.left)\n            yield node.value\n            yield from extract(node.right)\n    \n    gen = extract(node)\n    try:\n        u, v = next(gen), next(gen)\n    except StopIteration:\n        return True\n    \n    cmp = u<v\n    for w in gen:\n        if cmp != (v<w): return False\n        v = w\n    return True
def search_k_from_end(linked_list, k):\n    a = b = linked_list.head\n    \n    for __ in xrange(k - 1):\n        b = b.next\n        if not b:\n            return None\n        \n    while b.next:\n        a, b = a.next, b.next\n        \n    return a.data
def nkotb_vs_homie(requirements):\n    return ["{}! Homie dont play that!".format(a[8:-5].title())\n            for b in requirements for a in b] + \\n           ["{} monitoring objections, {} automation, {} deployment pipeline, {} cloud, and {} microservices.".\n            format(*(len(x) for x in requirements))]
def find_variable():\n    return next(k for k,v in globals().items() if v == 777)
def rotate_clockwise(m):\n    return [''.join(l[::-1]) for l in zip(*m)]
class Hero(object):\n    def __init__(self, name='Hero'):\n        self.name = name\n        self.position = '00'\n        self.health = 100\n        self.damage = 5\n        self.experience = 0
def n_closestPairs_tonum(upper_lim, k):\n    square_lim = int((2 * upper_lim) ** .5) + 1\n    squares = [n*n for n in range(1, square_lim)]\n    p, s = [], set(squares)\n    for m in range(upper_lim - 1, 1, -1):\n        for b in squares:\n            if b >= m: break\n            if 2*m - b in s:\n                p.append([m, m - b])\n                if len(p) == k: return p
from itertools import starmap, combinations\nfrom operator import lt, gt\n\ndef longest_comb(arr, command):\n    check = lt if command.startswith('<') else gt\n    for i in range(len(arr), 2, -1):\n        # if all(map(check, x, x[1:])) In Python 3\n        result = [list(x) for x in combinations(arr, i) if all(starmap(check, zip(x, x[1:])))]\n        # Also always annoying to return only the first element when we only have one\n        if result: return result[0] if len(result) == 1 else result\n    return []
class User(object):\n    def __init__(self, name, balance, checking_account):\n        self.name = name\n        self.balance = balance\n        self.checking_account = checking_account\n    \n    def withdraw(self, v):\n        if v > self.balance: raise ValueError()\n        self.balance -= v\n        return "{} has {}.".format(self.name, int(self.balance))\n    \n    def add_cash(self, v):\n        self.balance += v\n        return "{} has {}.".format(self.name, int(self.balance))\n    \n    def check(self, other, v):\n        if not other.checking_account: raise ValueError()\n        s1,s2 = other.withdraw(v), self.add_cash(v)[:-1]\n        return "{} and {}".format(s2,s1)\n    \n    def __str__(self): return "User({}, {}, {})".format(self.name, self.balance, self.checking_account)
def area(d, l): \n    return "Not a rectangle" if d<=l else round( l*(d*d-l*l)**.5, 2)
def peak_height(mountain):\n    M = {(r, c) for r, l in enumerate(mountain) for c in range(len(l)) if l[c] == '^'}\n    h = 0\n    while M:\n        M -= {(r, c) for r, c in M if {(r, c+1), (r, c-1), (r+1, c), (r-1, c)} - M}\n        h += 1\n    return h
from string import maketrans as mt, ascii_lowercase as lc, ascii_uppercase as uc\ndef encryptor(key, message):\n    key %= 26\n    return message.translate(mt(lc+uc, lc[key:]+lc[:key]+uc[key:]+uc[:key]))
def name_score(name):\n    scores = {k: v for keys, v in alpha.iteritems() for k in keys}\n    return {name: sum(scores.get(a, 0) for a in name.upper())}
def count_find_num(primes, limit):\n    base = eval( '*'.join( map(str, primes) ) )\n    \n    if base > limit:\n        return []\n    \n    results = [base]\n    \n    for p in primes:\n        for num in results:\n            num *= p\n            while num not in results and num <= limit:\n                results += [num]\n                num *= p\n    \n    return [ len(results), max(results) ]
def find_in_array(seq, predicate): \n    for index, value in enumerate(seq):\n        if predicate(value, index):\n            return index\n    return -1
def fusc(n):\n  assert type(n) == int and n >= 0\n  \n  if n < 2:\n    return n\n  \n  if n % 2 == 0:\n    return fusc(n//2)\n  else:\n    return fusc(n//2) + fusc(n//2 + 1)
from itertools import islice, count\n\ndef u1():\n    a = {1:1, 2:1}\n    yield a[1]\n    yield a[2]\n    for n in count(3):\n        a[n] = a[n-a[n-1]] + a[n-a[n-2]]\n        yield a[n]\n    \ndef length_sup_u_k(n, k):\n    return len(list(filter(lambda x: x >= k, islice(u1(), 1, n))))\n    \ndef comp(n):\n    return sum(k1 < k0 for k0, k1 in zip(list(islice(u1(), 1, n)), list(islice(u1(), 2, n))))
from collections import Counter\n\ndef mystery_range(s, n):\n    i, target = -1, Counter(s)\n    sum_ = sum(map(Counter, map(str, range(n))), Counter())\n    while True:\n        i += 1\n        sum_ = sum_ - Counter(str(i)) + Counter(str(i + n))\n        if sum_ == target:\n            if len(str(i + 1)) < len(str(i + n)) or \\n                str(i + 1) in set(map(''.join, zip(*[iter(s)]*len(str(i + 1))))):\n                return [i + 1, i + n]
def most_money(students):\n    total = []\n    for student in students:\n        total.append((student.fives * 5) + (student.tens * 10) + (student.twenties * 20))\n    \n    if min(total) == max(total) and len(students) > 1:\n        return "all"\n    else:\n        return students[total.index(max(total))].name
def how_to_find_them(rt):\n    return {d: rt[d] if d in rt\n               else (rt["a"]**2 + rt["b"]**2)**.5 if d=="c"\n               else (rt["c"]**2 - rt[(set("ab")-{d}).pop()]**2)**.5 for d in"abc"}
from math import ceil\n\nPI_DIGITS_SQUARED = [int(d)**2 for d in "31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679"]\n\ndef square_pi(n):\n    return ceil(sum(PI_DIGITS_SQUARED[:n])**0.5)
import math\n\ndef spider_to_fly(spider, fly):\n    web = {'A': 0, 'B': 45, 'C': 90, 'D': 135, 'E': 180, 'F': 225, 'G': 270, 'H': 315}\n    angle = min(abs(web[spider[0]] - web[fly[0]]), 360 - abs(web[spider[0]] - web[fly[0]]))\n    sideA, sideB = int(spider[1]), int(fly[1])\n    return math.sqrt(sideA ** 2 + sideB ** 2 - 2 * sideA * sideB * math.cos(angle * math.pi / 180))
# -*- coding: utf-8 -*-\nimport operator\n\n\nclass Placeholder:\n    def __init__(self, op=None, left=None, right=None):\n        self.op = op\n        self.left = left\n        self.right = right\n\n    def calc(self, args):\n        if self.op:\n            x, args = self.left.calc(args) if isinstance(self.left, Placeholder) else (self.left, args)\n            y, args = self.right.calc(args) if isinstance(self.right, Placeholder) else (self.right, args)\n            return self.op(x, y), args\n        return args[0], args[1:]\n\n    def __call__(self, *args):\n        return self.calc(args)[0]\n\n    def __add__(self, other):\n        return Placeholder(op=operator.add, left=self, right=other)\n\n    def __sub__(self, other):\n        return Placeholder(op=operator.sub, left=self, right=other)\n\n    def __mul__(self, other):\n        return Placeholder(op=operator.mul, left=self, right=other)\n\n    def __floordiv__(self, other):\n        return Placeholder(op=operator.floordiv, left=self, right=other)\n\n    def __radd__(self, other):\n        return Placeholder(op=operator.add, left=other, right=self)\n\n    def __rsub__(self, other):\n        return Placeholder(op=operator.sub, left=other, right=self)\n\n    def __rmul__(self, other):\n        return Placeholder(op=operator.mul, left=other, right=self)\n\n    def __rfloordiv__(self, other):\n        return Placeholder(op=operator.floordiv, left=other, right=self)\n\n\nx = Placeholder()
def weather_info (temp):\n    c = convertToCelsius(temp)\n    if (c <= 0):\n        return (str(c) + " is freezing temperature")\n    else:\n        return (str(c) + " is above freezing temperature")\n    \ndef convertToCelsius (temperature):\n  celsius = (temperature - 32) * (5.0/9.0)\n  return celsius
def image2ascii(image):\n    return '\n'.join(''.join( glyphs[(v*8)//255] for v in r) for r in image)
from urllib.request import urlopen\nfrom bs4 import BeautifulSoup as bs\ndef get_member_since(username):\n    html = urlopen(f'https://www.codewars.com/users/{username}')\n    soup = bs(html.read(), "html.parser")\n    tags = soup.find_all("div", {"class": "stat"})\n    member_tag = [x.text for x in tags if 'Member Since' in x.text][0]\n    return member_tag.split(':')[1]
def poly_derivative(p):\n    return [i * x for i, x in enumerate(p)][1:]\n
def remove(s):\n    return s.replace('!','') + s.count('!') * '!'
def sort_grades(gs):\n  return sorted(gs, key=grade)\n\ndef grade(v):\n  if v == 'VB':  return -2\n  if v == 'V0':  return -1\n  if v == 'V0+': return  0\n  return int(v[1:])
from itertools import compress, product, chain\nfrom functools import partial\n\ndef check(f, s):\n    if f.is_literal(): return f in s\n    elif f.is_and(): return all(check(e, s) for e in f.args)\n    elif f.is_or(): return any(check(e, s) for e in f.args)\n    elif f.is_not(): return not check(f.args[0], s)\n\ndef get_name(f):\n    if f.is_literal(): yield f\n    else: yield from chain.from_iterable(map(get_name, f.args))\n\ndef sat(f):\n    s = set(get_name(f))\n    return next(filter(partial(check, f), map(set, map(partial(compress, s), product((0,1), repeat=len(s))))), False)
def clean_mean(sample, cutoff):\n    mean = sum(sample)/len(sample)\n    dev = ((1/len(sample))*sum((num-mean)**2 for num in sample))**(1/2)\n    cleaned = [num for num in sample if abs(num-mean) <= cutoff*dev]\n    if sample==cleaned:\n        return round(mean,2)\n    else:\n        return clean_mean(cleaned,cutoff)
def word_to_bin(word):\n    return ['{:08b}'.format(ord(c)) for c in word]
def parse_float(string):\n    try:\n        return float(string)\n    except:\n        return None
def to_currency(price):\n  return '{:,}'.format(price)
def comfortable_numbers(l, r):\n    s = [sum(map(int, str(n))) for n in range(l, r + 1)]\n    return sum(s[i] >= i-j <= s[j] for i in range(1, len(s)) for j in range(i))
from re import compile as reCompile\n\nSENTENCE = reCompile(r'[.!?]')\nSYLLABLE = reCompile(r'(?i)[aeiou]+')\n\ndef count(string, pattern):\n    return len(pattern.findall(string))\n\ndef flesch_kincaid(text):\n    nWords = text.count(' ') + 1\n    return round(0.39 * nWords / count(text, SENTENCE) + 11.8 * count(text, SYLLABLE) / nWords - 15.59, 2)
class Node(object):\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n    \ndef get_nth(node, index):\n    v = -1\n    n = node\n    while n:\n        v += 1\n        if v == index:\n            return n\n        n = n.next\n    \n    raise ValueError
def shorter_reverse_longer(a,b):\n  if len(a) < len(b): a, b = b, a\n  return b+a[::-1]+b
def avg_diags(m):\n  a1,a2,l,l1,l2=0,0,len(m),0,0\n  for i in range (0,l):\n    if i&1: \n       if m[i][i]>=0: a1+=m[i][i]; l1+=1\n    else:\n       if m[l-i-1][i]<0: a2+=m[len(m)-i-1][i]; l2+=1\n  return [round(a1/l1) if l1>0 else -1,round(abs(a2)/l2) if l2>0 else -1]
from math import factorial,pi\nfrom fractions import Fraction\n\ndef comb(n,k):\n    return factorial(n)//(factorial(n-k)*factorial(k))\n\ndef bernoulli(m):\n    b=[1]\n    for i in range(1,m+1):\n        n=0\n        for k in range(0,i):\n            n+=comb(i+1,k)*b[k]\n        b.append(Fraction(-n,i+1))\n    return b\n\nb=bernoulli(31)\n\ndef series(k, nb) :\n    if k<0:\n        k=-k\n        return (b[k+1]*(-1)**k)/(k+1)\n    elif k%2==1:\n        return sum(1/(n**k) for n in range(1,nb+1))\n    else:\n        return abs(b[k])*((2*pi)**k)/(2*factorial(k))
def hotpo(n):\n    cnt = 0\n    while n != 1:\n        n = 3 * n + 1 if n % 2 else n / 2\n        cnt += 1\n    return cnt
complaints = ["slow!", "expensive!", "manual!", "down!", "hostage!", "security!"]\n\nlegacy = {\n    "cobol": 1000,\n    "nonobject": 500,\n    "monolithic": 500,\n    "fax": 100,\n    "modem": 100,\n    "thickclient": 50,\n    "tape": 50,\n    "floppy": 50,\n    "oldschoolit": 50\n}\n\nimport re\ndef roast_legacy(workloads):\n    complaining = sum(1 for _ in re.finditer('|'.join(complaints), workloads.lower()))\n    roasting = sum(legacy[m.group()] for m in re.finditer('|'.join(legacy), workloads.lower()))\n    if roasting or complaining:\n        return 'Burn baby burn disco inferno %d points earned in this roasting and %d complaints resolved!' % (roasting, complaining)\n    else:\n        return 'These guys are already DevOps and in the Cloud and the business is happy!'
import re\nclass Checkout(object):\n    def __init__(self, d={}):\n        self.pricing,self.total,self.fruits,self.free = d,0,{},{}\n    \n    def scan(self, n, qty=1):\n        item = get_price(n)\n        for i in range(qty):\n            if not self.free.get(n, 0) : self.total += item ; self.fruits[n] = self.fruits.get(n, 0) + 1\n            else : self.free[n] -= 1 ; continue\n            if n in self.pricing:\n                m = self.pricing[n]\n                if 'for' in m:\n                    how, f = m.split("for")\n                    if not self.fruits[n] % int(how) : self.total = self.total - item * int(how) + float(f)\n                elif 'buy' in m:\n                    how, f = re.sub(r'buy|get', ' ', m).strip().split()\n                    if not self.fruits[n] % int(how) : self.free[n] = int(f)\n                elif 'off' in m:\n                    how, f = re.sub(r'off|ormore', ' ', m).strip().split()\n                    if self.fruits[n] == int(f) : self.total -= float(how)\n            self.total = round(self.total,2)
def two_sum(nums, t):\n    for i, x in enumerate(nums):\n        for j, y in enumerate(nums):\n            if i != j and x + y == t:\n                return [i, j]
def relations(family_list, target_pair):\n    parents = {}\n    for parent, child in family_list:\n        parents[child] = parent\n\n    a, b = target_pair\n    ap = parents.get(a)\n    app = parents.get(ap)\n    bp = parents.get(b)\n    bpp = parents.get(bp)\n\n    if b == ap:\n        return 'Mother'\n    if b == app:\n        return 'Grandmother'\n    if a == bp:\n        return 'Daughter'\n    if a == bpp:\n        return 'Granddaughter'\n    if ap == bp:\n        return 'Sister'\n    if app == bpp:\n        return 'Cousin'\n    if app == bp:\n        return 'Aunt'\n    if ap == bpp:\n        return 'Niece'
def check(seq, elem):\n    return elem in seq
class LCG(object):\n  def __init__(self, x):\n      self._seed = x\n  def random(self):\n      self._seed = (2 * self._seed + 3) % 10\n      return self._seed / 10
def search_names(logins):\n    return list(filter(lambda a: a[0].endswith('_'), logins))
def equalize(arr):\n    return ["{:+d}".format(i-arr[0]) for i in arr]
dict = {i[0]:i[1] for i in ['GA', 'DE', 'RY', 'PO', 'LU', 'KI', 'AG', 'ED', 'YR', 'OP', 'UL', 'IK','ga', 'de', 'ry', 'po', 'lu', 'ki', 'ag', 'ed', 'yr', 'op', 'ul', 'ik'] }\ndef encode(s):\n    return ''.join([dict[i] if i in dict else i for i in s])\n    \ndef decode(s):\n    return ''.join([dict[i] if i in dict else i for i in s])\n
from operator import itemgetter\nfrom numpy import delete\n\ndef make_spanning_tree(edges, t):\n    memo, result = [], []\n    for v in sorted(edges, key=itemgetter(1), reverse=(t=="max")):\n        (x,y), w = v\n        \n        if x == y: continue\n        \n        i = next((i for i,s in enumerate(memo) if x in s), None)\n        j = next((j for j,s in enumerate(memo) if y in s), None)\n        \n        if i == j != None: continue\n            \n        result.append(v)\n        \n        if i == j: memo.append({x, y})\n        elif i is None: memo[j].add(x)\n        elif j is None: memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n\n    return result
class Vector(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \n    def add(self, vector):\n        return Vector(self.x + vector.x, self.y + vector.y)
def nth_floyd(n):\n  return ((1+8*(n-1))**0.5+1)//2
def get_num(n):\n    return sum({'0': 1, '6': 1, '9': 1, '8': 2}.get(d, 0) for d in str(n))
def is_palindrome(s):\n    s = s.lower()\n    return s == s[::-1]
def is_very_even_number(n):\n    while len(str(n)) > 1:\n        n = sum(int(x) for x in str(n))\n    return True if n % 2 == 0 else False
def diffs(bird1, bird2):\n    return sum(c1 != c2 for c1, c2 in zip(bird1, bird2))\n\ndef child(bird1, bird2):\n    return diffs(bird1, bird2) in [1, 2]\n\ndef grandchild(bird1, bird2):\n    return diffs(bird1, bird2) in [0, 1, 2, 3, 4] if len(bird1) > 1 else bird1 == bird2
def spread(func, args):\n    return func(*args)
def solution(a, b):\n    return a+b+a if len(a)<len(b) else b+a+b\n
class SelfClosing(object):\n\n    def __init__(self, closable):\n        self.closable = closable\n    \n    def __enter__(self):\n        self.closable.open_jar()\n        return self.closable\n        \n    def __exit__(self, *args):\n        self.closable.close_jar()
class Cat(Animal):\n    def __init__(self, name):\n        self.name = name\n    def speak(self):\n        return '{} meows.'.format(self.name)
class FileMaster():\n    def __init__(self, filepath):\n        lk = filepath.rfind('.')\n        ls = filepath.rfind('/')\n        self.ext = filepath[lk+1:]\n        self.file = filepath[ls+1:lk]\n        self.path = filepath[:ls+1]\n    def extension(self):\n        return self.ext\n    def filename(self):\n        return self.file\n        \n    def dirpath(self):\n        return self.path\n
import itertools\n\ndef mastermind(game):\n    colours = "Red Blue Green Orange Purple Yellow".split()\n    def check(solution, guess):\n        black = sum(a == b for a, b in zip(solution, guess))\n        white = sum(max(0, min(solution.count(c), guess.count(c))) for c in colours) - black\n        return ["Black"] * black + ["White"] * white\n    candidates = list(itertools.product(colours, repeat=4))\n    while candidates:\n        candidate = candidates.pop()\n        score = sorted(game.check(list(candidate)))\n        candidates = [c for c in candidates if check(candidate, c) == score]
from math import ceil\n\nnumbers = {0:"zero", 1: "one", 2: "two", 3: "three", 4: "four", 5: "five", 6: "six", 7: "seven", 8: "eight", \n9: "nine", 10: "ten", 11:"eleven", 12: "twelve", 13: "thirteen", 14: "fourteen", 15: "fifteen", \n16:"sixteen", 17:"seventeen", 18: "eighteen", 19: "nineteen", 20: "twenty"}\n\ndef wallpaper(l, w, h):\n    return "zero" if w*l==0 else numbers[ceil((2*l+2*w) * h * 1.15 / 5.2)]
def get_min_max(seq): \n    return min(seq), max(seq)
from collections import Counter\nfrom string import ascii_lowercase\n\n\ndef decrypt(test_key):\n    cnt = Counter(test_key)\n    return ''.join(str(cnt[a]) for a in ascii_lowercase)\n
import re\nfrom collections import Counter\nfrom itertools import chain\n\np = re.compile('{legs}{body}{body}0{body}{body}0{body}{body}{legs}'.format(\n    legs='[a-z]',\n    body=r'[[\]|};&#/><()*]',\n))\ndef count_robots(a):\n    cnt = Counter(chain.from_iterable(\n        ['d' if 'mechanik' in line else 'w' if 'automatik' in line else ''] * len(p.findall(line))\n        for line in map(str.lower, a)\n    ))\n    return ['{w} robots functioning automatik'.format_map(cnt),\n            '{d} robots dancing mechanik'.format_map(cnt)]
def stats_disc_distr(distrib):\n    err = check_errors(distrib)\n    if not err:\n        mean = sum(x[0] * x[1] for x in distrib)\n        var = sum((x[0] - mean) ** 2 * x[1] for x in distrib)\n        std_dev = var ** 0.5\n    return [mean, var, std_dev] if not err else err\n\ndef check_errors(distrib):\n    errors = 0\n    if not isclose(sum(x[1] for x in distrib), 1):\n        errors += 1\n    if not all(isinstance(x[0], int) for x in distrib):\n        errors += 2\n    if errors > 0:\n        return {1: "It's not a valid distribution", 2: "All the variable values should be integers",\n        3: "It's not a valid distribution and furthermore, one or more variable value are not integers"}[errors]\n\ndef isclose(a, b, rel_tol=1e-09, abs_tol=0.0):\n    return abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)\n
def count_squareable(n):\n    return n//4 + (n+1)//2
def compose(f,g):\n  return lambda *x: f(g(*x))
def riemann_trapezoidal(f, n, a, b):\n    dx = (b - a) / n\n    return round(dx * sum((f(a + i*dx) + f(a + (i+1)*dx)) / 2 for i in range(n)), 2)\n
def solved(s):\n    if len(s)&1:\n        s = s[:len(s)//2]+s[len(s)//2+1:]\n    return ''.join(sorted(s))
def all_non_consecutive(a):\n    return [{"i": i, "n": y} for i, (x, y) in enumerate(zip(a, a[1:]), 1) if x != y - 1]
def replace_exclamation(s):\n    return ''.join('!' if c in 'aeiouAEIOU' else c for c in s)
def backwardsPrime(start, stop):\n    primes = []\n    for n in range(start, stop+1):\n        if n not in primes and is_prime(n) and is_prime(reverse(n)) and n != reverse(n):\n            primes.append(n)\n            if start <= reverse(n) <= stop:\n                primes.append(reverse(n))\n    return sorted(primes)\n\ndef is_prime(n):\n    for i in range(2, int(n**(0.5))+1):\n        if n % i == 0:\n            return False\n    return True\n\ndef reverse(n):\n    return int(''.join(str(n)[::-1]))
SCORE = {'O': '0', 'o': '0', 'k': '1'}\n\n\ndef okkOokOo(s):\n    return ''.join(chr(int(''.join(SCORE.get(a, '') for a in word), 2))\n                   for word in s.split('?'))\n
def elapsed_seconds(start, end):\n    return (end - start).total_seconds()
RANGES = {\n    'minute': (0, 59),\n    'hour': (0, 23),\n    'day of month': (1, 31),\n    'month': (1, 12),\n    'day of week': (0, 6),\n}\n\nALIASES = {\n    'month': ' JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC'.split(' '),\n    'day of week': 'SUN MON TUE WED THU FRI SAT'.split(),\n}\n\ndef get_alias(field, value):\n    try:\n        return ALIASES[field].index(value)\n    except:\n        return int(value)\n\ndef parse(crontab):\n    def parse_field(field, value):\n        values = set()\n        for part in value.split(','):\n            part, *end = part.split('/')\n            step = int(end[0]) if end else 1\n            if part == '*':\n                start, stop = RANGES[field]\n            else:\n                part, *end = part.split('-')\n                start = get_alias(field, part)\n                stop = get_alias(field, end[0]) if end else start\n            values.update(range(start, stop + 1, step))\n        return ' '.join(map(str, sorted(values)))\n    return '\n'.join(f'{field:<15}{parse_field(field, value)}'\n                     for field, value in zip(RANGES, crontab.split()))
def find_nth_occurrence(substring, string, occurrence=1):\n    idx = -1\n    for i in range(occurrence):\n        idx = string.find(substring, idx + 1)\n        if idx == -1: return -1\n    return idx
from math import ceil\n\n\ndef new_avg(arr, newavg):\n    value = int(ceil((len(arr)+1) * newavg - sum(arr)))\n    if value < 0:\n        raise ValueError\n    \n    return value
f,g=lambda X:[list(x) for x in zip(*X[::-1])],lambda X:[list(x) for x in zip(*X)][::-1]\n\ndef ROTF(U,L,F,R,B,D):\n    U[2],(L[0][2],L[1][2],L[2][2]),(R[0][0],R[1][0],R[2][0]),D[0]=([L[0][2],L[1][2],L[2][2]][::-1],list(D[0]),list(U[2]),[R[0][0],R[1][0],R[2][0]][::-1])\n    return (U,L,f(F),R,B,D)\n    \ndef ROTS(U,L,F,R,B,D):\n    U[1],(L[0][1],L[1][1],L[2][1]),(R[0][1],R[1][1],R[2][1]),D[1]=([L[0][1],L[1][1],L[2][1]][::-1],list(D[1]),list(U[1]),[R[0][1],R[1][1],R[2][1]][::-1])\n    return (U,L,F,R,B,D)\n\ndef perform(a):\n    c="yyyyyyyyybbbbbbbbbrrrrrrrrrgggggggggooooooooowwwwwwwww"\n    U,L,F,R,B,D=([list(c[9*i:9*i+9][j*3:j*3+3]) for j in range(3)]for i in range(6))\n    \n    A=[]\n    for x in a.replace("'",'3').split():A+=[x[0]]*int(x[1])if len(x)==2else [x]\n    \n    T=[]\n    W='FS YYYFY YYYFSY YFYYY YFSYYY YYFYY YYFSYY XFXXX XFSXXX XXXFX XXXFSX YYYSY XSXXX'\n    for x in A:T+={k:list(v) for k,v in zip('fLlRrBbDdUuME',W.split())}.get(x,x)\n    \n    for X in T:\n        if X=='X':(U,L,F,R,B,D)=(F,g(L),D,f(R),g(g(U)),g(g(B)))\n        if X=='Y':(U,L,F,R,B,D)=(f(U),F,R,B,L,g(D))\n        if X=='Z':(U,L,F,R,B,D)=(f(L),f(D),f(F),f(U),g(B),f(R))\n        if X=='F':(U,L,F,R,B,D)=ROTF(U,L,F,R,B,D)\n        if X=='S':(U,L,F,R,B,D)=ROTS(U,L,F,R,B,D)\n    return ''.join(''.join(''.join(y)for y in x)for x in(U,L,F,R,B,D))
def simpson(n):\n    from math import sin, pi\n    \n    a = 0\n    b = pi\n    h = (b - a)/n\n    \n    f = lambda x: (3/2) * sin(x)**3\n    \n    integral = 0\n    integral += f(a) + f(b)\n    integral += 4*sum(f(a +(2*i - 1)*h) for i in range(1, n//2 + 1))\n    integral += 2*sum(f(a + 2*i*h) for i in range(1, n//2))\n    integral *= h/3\n    \n    return integral
from random import random\ndef mutate(chromosome, p):\n    res = ''\n    for s in chromosome:\n        res += str(1 - int(s)) if random() < p else s\n    return res\n
import itertools\ndef choose_best_sum(t, k, ls):\n    try: \n        return max(sum(i) for i in itertools.combinations(ls,k) if sum(i)<=t)\n    except:\n        return None
MOVES = {"right": (0,1), "down": (1,0), "left": (0,-1), "up": (-1,0)}\n\n\ndef get_password(grid, dirs):\n    x,y = next( (x,y) for x,r in enumerate(grid) for y,c in enumerate(r) if c=='x' )\n    pwd = []\n    for d in dirs:\n        dx,dy = MOVES[d.strip('T')]\n        x,y = x+dx,y+dy\n        if d.endswith('T'): pwd.append(grid[x][y])\n    return ''.join(pwd)
def sort_nested_list(xsss):\n    ys = iter(sorted(x for xss in xsss for xs in xss for x in xs))\n    return [[[next(ys) for x in xs] for xs in xss] for xss in xsss]
def calculate_total(subtotal, tax, tip):\n    return round(subtotal * ( 1 + tax / 100.0 + tip /100.0), 2)
from fractions import gcd\ndef count_black_cells(h, w):\n    return (h + w) -2 + gcd(h,w)
from collections import Counter\n\ndef char_freq(message):\n    return Counter(message)
import re\ndef my_very_own_split(string, delimiter = None):\n    if delimiter == '': raise ValueError('empty delimiter')\n    if delimiter == None: delimiter = '\s+'\n    else: delimiter = re.escape(delimiter)\n    pos = 0\n    for m in re.finditer(delimiter, string):\n        yield string[pos:m.start()]\n        pos = m.end()\n    yield string[pos:]\n
def solution(M1, M2, m1, m2, V, T) :\n    return (m1/M1+m2/M2)*0.082*(T+273.15)/V
from distutils.version import LooseVersion\n\n\ndef sort_ranks(ranks):\n    return sorted(ranks, key=LooseVersion)\n
def interpreter(tape):\n    ptr, stack, output = 0, [0], []\n    \n    while ptr < len(tape):\n        command = tape[ptr]\n        \n        if   command == '^': stack.pop()\n        elif command == '!': stack.append(0)\n        elif command == '+': stack[-1] = (stack[-1] + 1) % 256\n        elif command == '-': stack[-1] = (stack[-1] - 1) % 256\n        elif command == '*': output.append(chr(stack[-1]))\n        elif command == '[' and stack[-1] == 0: ptr = tape.find(']', ptr)\n        elif command == ']' and stack[-1] != 0: ptr = tape.rfind('[', ptr)\n        \n        ptr += 1\n        \n    return ''.join(output)
def double_char(s):\n    return ''.join(c * 2 for c in s)
def circum_curvat(points):\n    A, B, C = [complex(*p) for p in points]\n    BC, CA, AB = B - C, C - A, A - B\n    D = 2. * (A.real * BC + B.real * CA + C.real * AB).imag\n    if not D: return D, D\n    U = (abs(A)**2 * BC + abs(B)**2 * CA + abs(C)**2 * AB) / D\n    radius = (abs(BC) * abs(CA) * abs(AB)) / abs(D)\n    return -1j * U, radius\n\ndef count_circles(circles, point):\n    return sum(abs(complex(*point) - center) < radius\n               for center, radius in map(circum_curvat, circles))
def vert_mirror(s):\n    return "\n".join(line[::-1] for line in s.split("\n"))\n\ndef hor_mirror(s):\n    return "\n".join(s.split("\n")[::-1])\n\ndef oper(fct, s):\n    return fct(s)\n
def adjust(coin, price):\n    return price + (coin - price) % coin
def square_up(n):\n    return [j if j <= i else 0 for i in range(1, n+1) for j in range(n, 0, -1)]\n
def j_n(n):\n    j = [0]\n    a = [1]\n    for i in range(1, n):\n        j.append((i - a[j[i-1]]))\n        a.append((i-j[a[i-1]]))\n    return j, a\n\n\ndef john(n):\n    return j_n(n)[0]\n    \ndef ann(n):\n    return j_n(n)[1]\n    \n        \ndef sum_john(n):\n    return sum(john(n))\n    \ndef sum_ann(n):\n     return sum(ann(n))
from itertools import permutations\ndef ssc_forperm(arr):\n    perms = set(p for p in permutations(arr))\n    values = [sum((x + 1) * y for x,y in enumerate(i)) for i in perms]\n    return [{"total perm": len(perms)}, {"total ssc": sum(values)}, {"max ssc": max(values)}, {"min ssc": min(values)}]
def amidakuji(ar):\n    numbers = list(range(len(ar[0])+1))\n    for line in ar:\n        for i, swap in enumerate(line):\n            if swap == '1':\n                numbers[i], numbers[i+1] = numbers[i+1], numbers[i]\n    return numbers
def get_number_of_squares(n):\n    k = 1\n    while k*(k+1)*(2*k+1)/6 < n:\n        k+=1\n    return k-1\n
def put_the_cat_on_the_table(cat, room):\n    (cy, cx), h, w = cat, len(room), len(room[0])\n    if not (0 <= cy < h and 0 <= cx < w):\n        return "NoCat"\n    ty, tx = next(((y, x) for y in range(h) for x in range(w) if room[y][x]), (-1, -1))\n    if ty < 0:\n        return "NoTable"\n    ver, dy = "U" if ty < cy else "D", abs(ty - cy)\n    hor, dx = "L" if tx < cx else "R", abs(tx - cx)\n    return f"{hor * dx}{ver * dy}"\n
def circularly_sorted(arr):\n    m=arr.index(min(arr))\n    return sorted(arr) == ( arr[m:]+arr[:m] )
remove=lambda s:' '.join(r for r,_ in __import__('re').findall(r'((!*)\w+\2)',s))
def multiply(x, y):\n    return x * y
def split_all_even_numbers(numbers, split_type):\n    result = []\n    for a in numbers:\n        if a % 2:\n            result.append(a)\n        else:\n            pairs = [(b, a - b) for b in range(1, a // 2 + 1, 2) if a - b % 2]\n            if split_type == 0:\n                result.extend(pairs[-1])\n            elif split_type == 1:\n                result.extend(pairs[0])\n            elif split_type == 2:\n                for c, _ in reversed(pairs):\n                    quo, rem = divmod(a, c)\n                    if not rem:\n                        result.extend([c] * quo)\n                        break\n            elif split_type == 3:\n                result.extend([1] * a)\n    return result\n
def chess_board_cell_color(a, b):\n    return (ord(a[0]) + int(a[1])) % 2 == (ord(b[0]) + int(b[1])) % 2
import os\n\ndef get_output(s):\n    return os.popen(s).read()
import json\n\ndef f(data, level):\n    if level == 0:\n        yield data['name']\n        return\n    children = data['children']\n    if len(children) >= 7 and all(child['gender'] == 'male' for child in children[:7]):\n        yield from f(children[6], level-1)\n    for child in children:\n        yield from f(child, 2)\n        \ndef find_seventh_sons_of_seventh_sons(jstring):\n    data = json.loads(jstring)\n    return set(f(data, 2))
def redistribute_wealth(wealth):\n    wealth[:] = [sum(wealth) / len(wealth)] * len(wealth)
from collections import Counter\nfrom operator import itemgetter\n\ndef letter_frequency(text):\n    items = Counter(c for c in text.lower() if c.isalpha()).items()\n    return sorted(\n        sorted(items, key=itemgetter(0)),\n        key=itemgetter(1),\n        reverse=True\n    )
import operator as o\nclass v:\n    def __init__(s,a,b): s.a,s.b=a,b\n    def compute(s): return getattr(o,type(s).__name__)(s.a,s.b)\nclass value(int): pass\nclass add(v): pass\nclass sub(v): pass\nclass mul(v): pass\nclass truediv(v): pass\nclass mod(v): pass\nclass pow(v): pass
def distance_between_points(a, b):\n    return ((b.x - a.x) ** 2 + (b.y - a.y) ** 2 + (b.z - a.z) ** 2) ** 0.5
def travel(r, zipcode):\n    streets = []\n    nums = []\n    addresses = r.split(',')\n    for address in addresses:\n        if ' '.join(address.split()[-2:]) == zipcode:\n            streets.append(' '.join(address.split()[1:-2]))\n            nums += address.split()[:1]\n    return '{}:{}/{}'.format(zipcode, ','.join(streets), ','.join(nums))
def is_valid_coordinates(coordinates):\n    try:\n        lat, lng = [abs(float(c)) for c in coordinates.split(',') if 'e' not in c]\n    except ValueError:\n        return False\n\n    return lat <= 90 and lng <= 180
def hello(name=''):\n    return f"Hello, {name.title() or 'World'}!"
import random\n\ndef love_language(partner, weeks):\n    rst = [0,0,0,0,0]\n    for i in range (0, weeks*7):\n        if(partner.response(LOVE_LANGUAGES[i%5]) == 'positive'):\n            rst[i%5]+=1\n    return LOVE_LANGUAGES[rst.index(max(rst))]\n
def check_generator(gen):\n  if gen.gi_frame is None:\n    return "Finished"\n  if gen.gi_frame.f_lasti == -1:\n    return "Created"\n  return "Started"
from collections import Counter\nfrom math import factorial\n\ndef count_perms(matrix):\n    m, n = len(matrix), len(matrix[0])\n    c = Counter([x for row in matrix for x in row])\n    factors = []\n    for x, count in c.most_common():\n        if count > 1:\n            factors.append(factorial(count))\n    return factorial(m * n) / reduce(lambda a, b: a * b, factors, 1)
class anything(object):\n    def __init__(self, foo): pass\n    def __eq__(self, other): return True\n    __ne__ = __lt__ = __le__ = __gt__ = __ge__ = __eq__
import re\n\ndef camelize(s):\n    return "".join([w.capitalize() for w in re.split("\W|_", s)])
def round_to_next5(n):\n    return n + (5 - n) % 5
from itertools import count\n\ndef is_prime(n):\n    if n < 2: return False\n    if n == 2: return True\n    if n % 2 == 0: return False\n    for div in range(2, int(n ** 0.5) + 1):\n        if n % div == 0:\n            return False\n    return True\n\ndef next_prime(n):\n    for candidate in count(n + 1):\n        if is_prime(candidate):\n            return candidate
def connect_the_dots(paper):\n    Y    = paper.find("\n")+1\n    lst  = list(paper)\n    pts  = {c: i for i,c in enumerate(paper) if c.isalpha() }\n    chrs = sorted(pts)\n    \n    for i in range(len(pts)-1):\n        a,b = sorted((pts[chrs[i]], pts[chrs[i+1]]))\n        (x,y),(u,v) = divmod(a,Y), divmod(b,Y)\n        dx, dy = Y * ( (u>x)-(u<x) ), (v>y)-(v<y)\n    \n        for j in range(a,b+1,dx+dy): lst[j]='*'\n    \n    return ''.join(lst)\n
def find_gatecrashers(people, invitations):\n    crashersSet = { elt for i,li in invitations for elt in [i]+li}\n    return [ p for p in people if p not in crashersSet ]
from collections import Counter\n\ndef find_dups_miss(arr):\n    mi, ma, c = min(arr), max(arr), Counter(arr)\n    duplicates = sorted(n for n in c if c[n] > 1)\n    return [ma*(ma+1)//2 - mi*(mi-1)//2 - sum(c), duplicates]
import datetime\n\ndef days(date, month, year):\n    x = datetime.datetime(year, month, date)\n    y = datetime.datetime(2437, 3, 24)\n    delta = y-x\n    t = delta.days\n    if year < 1752 or (year == 1752 and month < 9) or (year == 1752 and month == 9 and date < 14):\n        t -= 11\n    if year < 1752 :\n        y = year //4 * 4 + 4\n        for i in range(y, 1752, 4):\n            if i % 100 == 0 and i % 400 != 0:\n                t+=1\n    return t\n    \n
def recaman(n):\n    series, last = {0}, 0\n    for i in range(1, n+1): \n        test = last - i\n        last = last + i if test < 0 or test in series else test\n        series.add(last)     \n\n    return last
from itertools import cycle,chain\n\ndef max_hexagon_beam(n,seq):\n    h    = 2*n-1\n    seq  = cycle(seq)\n    sums = [ [0]*h for _ in range(3)]            # [horz, diagUp, diagDown]\n    \n    for r in range(h):\n        for c,v in zip(list(range(n+r if r<n else h+n-1-r)),seq):\n            idxs = (r, c+max(0,r-n+1), c+max(0,n-1-r))\n            for i,j in enumerate(idxs): sums[i][j] += v\n            \n    return max(chain.from_iterable(sums))\n
from numpy import prod\n\ndef find_difference(a, b):\n    return abs(prod(a) - prod(b))\n
class Datamining:\n    a = 0\n    b = 0\n\n    def __init__(self, train_set):\n        sx = sy = sxx = sxy = 0\n        n = len(train_set)\n        for i in range(n):\n            sx += train_set[i][0]\n            sy += train_set[i][1]\n            sxx += train_set[i][0]**2\n            sxy += train_set[i][0]*train_set[i][1]\n        self.b = (n*sxy-sx*sy)/(n*sxx-sx**2)\n        self.a = (sy-self.b*sx)/n\n\n    def predict(self, x):\n        return self.a + self.b*x\n
from itertools import combinations\n\ndef area(t):\n    (a,b),(c,d),(e,f) = t\n    return abs(a*d+b*e+c*f-d*e-a*f-b*c)/2\n\ndef find_biggTriang(lst):\n    tris  = list(combinations(lst,3))\n    areas = list(map(area,tris))\n    m     = max(areas)\n    mTris = [list(map(list,t)) for t,v in zip(tris,areas) if v==m]\n    return [ len(lst), len(tris), sum(map(bool,areas)),\n             mTris if len(mTris)!=1 else mTris.pop(), m]
def wave_sort(a):\n    a.sort()\n    for i in range(1, len(a), 2):\n        a[i], a[i-1] = a[i-1], a[i]
def makeParts(arr, csize):\n  return [ arr[i: i + csize] for i in range(0, len(arr), csize)]
OUTPUT = 'You know what\'s actually really good? {}'.format\n\n\ndef actually_really_good(foods):\n    foods = list(set(foods))\n    length = len(foods)\n    if length == 0:\n        return OUTPUT('Nothing!')\n    return OUTPUT('{} and more {}.'.format(\n        foods[0].capitalize(), foods[0 if length == 1 else 1].lower()))\n
def build_trie(*words):\n    root = {}\n    for word in words:\n        branch = root\n        length = len(word)\n        for i in range(1, length+1):\n            length -= 1\n            key = word[:i]\n            if key not in branch: \n                branch[key] = None\n            if length and not branch[key]: \n                branch[key] = {}\n            branch = branch[key]\n    return root
from fractions import gcd\n\ndef binary_gcd(x, y):\n    return bin(gcd(x, y)).count('1')
def digit_all (x):\n    return filter(str.isdigit, x) if isinstance(x, str) else 'Invalid input !'
weight=lambda n,w,e=__import__('math').exp(-2):(1-3*e)/(1-e)/4*(1-e**n)*w
import math\n\ndef f(z, eps):\n    if (abs(z) >= 1.0): return -1\n    return int(math.log(eps) / math.log(abs(z)))\n
from fractions import Fraction\n\ndef calculate_ratio(w, h):\n    if w * h == 0:\n        raise ValueError\n    f = Fraction(w, h)\n    return f"{f.numerator}:{f.denominator}"\n
def show_me(instname):\n    attrs = sorted(instname.__dict__.keys())\n    if len(attrs) == 1:\n        attrs = attrs[0]\n    else:\n        attrs = '{} and {}'.format(', '.join(attrs[:-1]), attrs[-1])\n    return 'Hi, I\'m one of those {}s! Have a look at my {}.'\\n        .format(instname.__class__.__name__, attrs)\n
def nthterm(first, n, c):\n    return first + n * c
from collections import Iterable\n\ndef unpack(iterable):\n    lst = []\n    for x in iterable:\n        if   isinstance(x,dict):     x = unpack(x.items())\n        elif isinstance(x,str):      x = [x]\n        elif isinstance(x,Iterable): x = unpack(x)\n        else:                        x = [x]\n        lst.extend(x)\n    return lst
def answer(puzzlebox):\n    return 42
def traffic_lights(road, n):\n    lightsIdx = [ (i, 6*(c!='G')) for i,c in enumerate(road) if c in 'RG' ]\n    car, ref  = road.find('C'), road.replace('C','.')\n    mut, out  = list(ref), [road]\n    \n    for turn in range(1,n+1):\n    \n        for i,delta in lightsIdx:                                  # Update all lights\n            state = (delta+turn) % 11\n            mut[i] = 'G' if state<5 else 'O' if state==5 else 'R'\n        \n        car += car+1>=len(road) or mut[car+1] in '.G'              # Move the car if possible (even if outside of the road)\n        \n        if car<len(road): old, mut[car] = mut[car], 'C'            # Update, archive, then restore the road state\n        out.append(''.join(mut))\n        if car<len(road): mut[car] = old\n        \n    return out\n
def candles(candles, make_new):\n    return candles + (candles - 1) // (make_new - 1)
def epidemic(tm, n, s, i, b, a):\n    def f(s, i, r):  \n        dt = tm / n\n        for t in range(n):\n            s, i, r = s-dt*b*s*i, i+dt*(b*s*i-a*i), r+dt*i*a\n            yield i\n    return int(max(f(s, i, 0)))
import hashlib\n\nclass Random():\n    HASH_MAX = (1 << 32 * 4) - 1\n\n    def __init__(self, seed):\n        self.seed = seed\n    def random(self):\n        x = int(hashlib.md5(str(self.seed).encode()).hexdigest(), 16)\n        self.seed += 1\n        return x / self.HASH_MAX\n    def randint(self, start, end):\n        return start + int(self.random() * (end+1-start))
from fractions import Fraction\n\ndef to_string(self):\n    n, d = self.numerator, self.denominator\n    s, w, n = "-" if n < 0 else "", *divmod(abs(n), d)\n    r = " ".join((str(w) if w else "", f"{n}/{d}" if n else "")).strip()\n    return f"{s}{r}"\n\nFraction.__str__ = to_string\nFraction.to_decimal = lambda self: self.numerator / self.denominator
from itertools import zip_longest as zl\n\ndef sum_arrays(arrays, shift):\n    shifted = [[0] * shift * i + arr for i, arr in enumerate(arrays)]\n    return [sum(t) for t in zl(*shifted, fillvalue=0)]
def html_end_tag_by_start_tag(start_tag):\n  return "</" + start_tag[1:-1].split(" ")[0] + ">"
import re\n\ndef genMask(w):\n    x = list(w)\n    for i in range(len(w)):\n        x[i] = '.'\n        yield ''.join(x)\n        x[i] = w[i]\n\ndef mutations(alice, bob, word, first):\n    players, seen  = [alice,bob], {word}\n    win, failed, i = -1, -1, first^1\n    while 1:\n        i    ^= 1\n        lst   = players[i]\n        reg   = re.compile('|'.join(genMask(word)))\n        found = next((w for w in lst if reg.match(w) and w not in seen and len(set(w))==4), None)\n        if found is None:\n            if failed==i^1: break\n            failed = i\n        else:\n            seen.add(found)\n            word, win = found, i\n            if failed!=-1: break\n    return win
def position(alphabet):\n    return "Position of alphabet: {}".format(ord(alphabet) - 96)
VALID = {'gravel', 'rock'}\n\n\ndef rake_garden(garden):\n    return ' '.join(a if a in VALID else 'gravel' for a in garden.split())\n
# generate primes up to limit\nLIMIT = 10**6\nsieve = [0]*2 + list(range(2, LIMIT))\nfor n in sieve:\n    if n:\n        for i in range(n*n, LIMIT, n):\n            sieve[i] = 0\nPRIMES = list(n for n in sieve if n)\n\ndef get_primes(n, m=2):\n    primes_ = PRIMES[:n] + [None] * m\n    return ( tuple(primes_[i:i+m]) for i in range(0, n, m) )
def validBraces(string):\n    braces = {"(": ")", "[": "]", "{": "}"}\n    stack = []\n    for character in string:\n        if character in braces.keys():\n            stack.append(character)\n        else:\n            if len(stack) == 0 or braces[stack.pop()] != character:\n                return False\n    return len(stack) == 0  
def convert(n):\n    ds = list(map(int, reversed(str(n))))\n    return [sum(ds[::4]) - sum(ds[2::4]), sum(ds[1::4]) - sum(ds[3::4])]
def grid_index(grid, idxs):\n    return ''.join(grid[x][y] for x,y in map(lambda n: divmod(n-1,len(grid)),idxs))
from fractions import gcd\nimport re\nfrom functools import reduce\n\ndef min_special_mult(arr):\n    l = [e for e in arr if not re.match('(None)|([+-]?\d+)', str(e))]\n    if len(l) == 1:\n        return 'There is 1 invalid entry: {}'.format(l[0])\n    if len(l) > 1:\n        return 'There are {} invalid entries: {}'.format(len(l), l)\n    \n    return reduce(lambda s, e: s * int(e) / gcd(s, int(e)) if e else s, arr, 1)\n
letters =  {\n    "A": "Alpha",  "B": "Bravo",   "C": "Charlie",\n    "D": "Delta",  "E": "Echo",    "F": "Foxtrot",\n    "G": "Golf",   "H": "Hotel",   "I": "India",\n    "J": "Juliett","K": "Kilo",    "L": "Lima",\n    "M": "Mike",   "N": "November","O": "Oscar",\n    "P": "Papa",   "Q": "Quebec",  "R": "Romeo",\n    "S": "Sierra", "T": "Tango",   "U": "Uniform",\n    "V": "Victor", "W": "Whiskey", "X": "X-ray",\n    "Y": "Yankee", "Z": "Zulu"\n  }\n  \ndef nato(word):\n    return ' '.join(letters[c] for c in word.upper())
def list_to_array(lst):\n    arr = []\n    while lst != None:\n        arr.append(lst.value)\n        lst = lst.next\n    return arr
from collections import Counter\n\ndef count_feelings(s, arr):\n    total = sum(Counter(s) & Counter(w) == Counter(w) for w in arr)\n    return '%s feeling%s.' % (total, '' if total == 1 else 's')
class PokeScan:\n    def __init__(self, name, level, pkmntype):\n        self.name = name\n        self.level = level\n        self.pkmntype = pkmntype\n\n    def info(self):\n        level_info = "weak" if self.level <= 20 else "fair" if self.level <= 50 else "strong"\n        pkmntypes_info = {"water": "wet", "fire": "fiery", "grass": "grassy",}\n        return "{}, a {} and {} Pokemon.".format(self.name, pkmntypes_info[self.pkmntype], level_info)
def collatz(n):\n    l = [str(n)]\n    while n > 1:\n        n = 3 * n + 1 if n % 2 else n / 2\n        l.append(str(n))\n    return '->'.join(l)
def only_one(*args):\n    return sum(args) == 1
from functools import reduce\nfrom gmpy2 import comb\nfrom operator import xor\n\ndef transform(a, x):\n    return reduce(xor, (comb(n + 1, x + 1) for n in a))
def binRota(arr):\n    return [name for i, row in enumerate(arr) for name in row[::-1 if i % 2 else 1]]
def get_diagonale_code(grid):\n    grid = [line.split() for line in grid.split("\n")]\n    i, j, d, word = 0, 0, 1, ""\n    while 0 <= i < len(grid) and j < len(grid[i]):\n        if 0 <= j < len(grid[i]):\n            word += grid[i][j]\n            i, j = i + d, j + 1\n        else: i += d\n        if i == 0 or i == len(grid) - 1: d = -d\n    return word
from itertools import combinations\ndef find_zero_sum_groups(arr, n):\n    combos = sorted(sorted(c) for c in combinations(set(arr), n) if sum(c) == 0)\n    return combos if len(combos) > 1 else combos[0] if combos else "No combinations" if arr else "No elements to combine"
def different_squares(matrix):\n    s = set()\n    rows, cols = len(matrix), len(matrix[0])\n    for row in range(rows - 1):\n        for col in range(cols - 1):\n            s.add((matrix[row][col], matrix[row][col + 1], matrix[row + 1][col], matrix[row + 1][col + 1]))\n    return len(s)
def find_solution(m):\n    return [j for j,r in enumerate(m) if r[0]^m[0][0]] + [len(m)+i for i,b in enumerate(m[0]) if not b]
import random\n\ndef random_case(x):\n    return "".join([random.choice([c.lower(), c.upper()]) for c in x])
import heapq, itertools\n\ndef sort(iterable):\n    heap = list(iterable)\n    heapq.heapify(heap)\n    return (heapq.heappop(heap) for i in range(len(heap)))
def infected(s):\n    lands = s.split('X')\n    total = sum(map(len, lands))\n    infected = sum(len(x) for x in lands if '1' in x)\n    return infected * 100 / (total or 1)
from collections import deque\n\ndef reverse(lst):\n    q = deque()\n    for x in lst:\n        q.appendleft(x)\n    return list(q)
def martingale(bank, outcomes):\n    stake = 100\n    for i in outcomes:\n        if i == 0:\n            bank -= stake\n            stake *= 2\n        else:\n            bank += stake\n            stake = 100\n    return bank
def count_char(s,c):\n    return s.lower().count(c.lower())
def coffee_limits(year, month, day):\n    h = int(f'{year:04}{month:02}{day:02}')\n    return [limit(h, 0xcafe), limit(h, 0xdecaf)]\n    \ndef limit(h, c):\n    for i in range(1, 5000):\n        h += c\n        if 'DEAD' in f'{h:X}':\n            return i\n    return 0\n\n
from itertools import groupby\ndef shut_the_gate(farm):\n    who_eats_whom = {'H': ['A', 'V'], 'R': ['V'], 'C': []}\n    runaway_back ,runaway_front, farm = [], [], ["".join(j) for k, j in groupby(farm)]\n    def doSomeFarm(i=0):\n        def do(j,s=False):\n            while (j >= 0 if s else j<len(farm)) and farm[j] != '|':\n                if farm[j][0] in who_eats_whom[current[0]] : farm[j] = '.' * len(farm[j])\n                j += [1,-1][s]\n            return j\n        while i < len(farm):\n            current = farm[i]\n            if current[0] in who_eats_whom:\n                r,r1 = do(i,1),do(i)\n                if r == -1 or r1 == len(farm):\n                    farm[i] = '.' * len(farm[i])\n                    [runaway_front,runaway_back][r!=-1].append(current[0])\n            i += 1\n    doSomeFarm()\n    l = len(runaway_back)\n    if l:\n        if farm[0] != '|':\n            farm = ['/'] + " / ".join(runaway_back[::-1]).split() + farm\n            doSomeFarm()\n            farm = farm[l * 2:]\n    l = len(runaway_front)\n    if l:\n        if farm[-1] != '|':\n            farm = farm + ['/'] +' / '.join(runaway_front).split()\n            doSomeFarm()\n            farm = farm[:-l * 2]\n    return "".join(farm)
lineup_students = lambda (s): sorted(s.split(), key=lambda x: (len(x), x), reverse=True)
def directions(goal):\n    y = goal.count("N") - goal.count("S")\n    x = goal.count("E") - goal.count("W")\n    \n    return ["N"] * y + ["S"] * (-y) + ["E"] * x + ["W"] * (-x)
def string_counter(string, char):\n    return string.count(char)
import math\n\n\nclass VectorInputCoordsValidationError(Exception):\n    """Custom exception class for invalid input args given to the Vector instantiation"""\n\n\nclass Vector:\n    # https://www.mathsisfun.com/algebra/vectors.html\n\n    def __init__(self, *args):\n        try:\n            self.x, self.y, self.z = args if len(args) == 3 else args[0]\n        except ValueError:\n            raise VectorInputCoordsValidationError('Either give single iterable of 3 coords or pass them as *args')\n\n    def __add__(self, other) -> "Vector":\n        return Vector(\n            self.x + other.x,\n            self.y + other.y,\n            self.z + other.z\n        )\n\n    def __sub__(self, other) -> "Vector":\n\n        return Vector(\n            self.x - other.x,\n            self.y - other.y,\n            self.z - other.z\n        )\n\n    def __eq__(self, other) -> bool:\n        # https://www.grc.nasa.gov/www/k-12/airplane/vectcomp.html\n        # https://onlinemschool.com/math/library/vector/equality/\n        return all((\n            self.x == other.x,\n            self.y == other.y,\n            self.z == other.z\n        ))\n\n    def cross(self, other) -> "Vector":\n        # https://www.mathsisfun.com/algebra/vectors-cross-product.html\n        return Vector(\n            self.y*other.z - self.z*other.y,\n            self.z*other.x - self.x*other.z,\n            self.x*other.y - self.y*other.x\n        )\n\n    def dot(self, other) -> int:\n        # https://www.mathsisfun.com/algebra/vectors-dot-product.html\n        return self.x*other.x + self.y*other.y + self.z*other.z\n\n    def to_tuple(self) -> tuple:\n        return self.x, self.y, self.z\n\n    def __str__(self) -> str:\n        return "<{x}, {y}, {z}>".format(**self.__dict__)\n\n    @property\n    def magnitude(self) -> float:\n        return math.sqrt(\n            sum (\n                    (\n                        self.x ** 2,\n                        self.y ** 2,\n                        self.z ** 2\n                    )\n            )\n        )\n
def two_by_two(animals):\n    return {x:2 for x in animals if animals.count(x) > 1} if animals else False
def house_numbers_sum(inp):\n    return sum(inp[:inp.index(0)])
def sel_number(n, d):\n    cnt = 0\n    for a in range(12, n + 1):\n        nums = list(map(int, str(a)))\n        if nums == sorted(set(nums)) and \\n                all(c - b <= d for b, c in zip(nums[:-1], nums[1:])):\n            cnt += 1\n    return cnt\n
def resistor_parallel(*rs):\n    return 1 / sum(1.0 / r for r in rs)
from math import cos, sin, radians\n\ndef crusoe(n, d, ang, dist_mult, ang_mult):\n    x, y, a = 0, 0, radians(ang)\n    for i in range(n):\n        x += d * cos(a)\n        y += d * sin(a)\n        d *= dist_mult\n        a *= ang_mult\n    return x, y
def find_initial_numbers (divisor, iterations):\n    a = divisor\n    b = divisor if iterations != 0 else 0\n    \n    for _ in range(iterations):\n        c = b\n        b = a\n        a = b + c\n    \n    return a, b
def ip_to_int32(ip):\n    """\n    Take the following IPv4 address: 128.32.10.1 This address has 4 octets\n    where each octet is a single byte (or 8 bits).\n\n    1st octet 128 has the binary representation: 10000000\n    2nd octet 32 has the binary representation: 00100000\n    3rd octet 10 has the binary representation: 00001010\n    4th octet 1 has the binary representation: 00000001\n    So 128.32.10.1 == 10000000.00100000.00001010.00000001\n\n    Because the above IP address has 32 bits, we can represent it as\n    the 32 bit number: 2149583361.\n\n    Write a function ip_to_int32(ip) ( JS: ipToInt32(ip) ) that takes\n    an IPv4 address and returns a 32 bit number.\n\n    ip_to_int32("128.32.10.1") => 2149583361\n\n    """\n    addr = ip.split(".")\n    res = int(addr[0]) << 24\n    res += int(addr[1]) << 16\n    res += int(addr[2]) << 8\n    res += int(addr[3])\n    return res\n
\ndef partial_keys(d):\n    class Dct(dict):\n        def __getitem__(self,pk):\n            k = min((k for k in self if k.startswith(pk)), default=None)\n            return k if k is None else super().__getitem__(k)\n    return Dct(d)
from itertools import cycle\n\nclass Pong:\n    def __init__(self, max_score):\n        self.max_score = max_score;\n        self.scores = {1: 0, 2: 0}\n        self.players = cycle((1, 2))\n\n    def game_over(self):\n        return any(score >= self.max_score for score in list(self.scores.values()))\n\n    def play(self, ball_pos, player_pos):\n        if self.game_over():\n            return "Game Over!"\n \n        player = next(self.players)\n        if abs(ball_pos - player_pos) <= 3:\n            return "Player {} has hit the ball!".format(player)\n        else:\n            self.scores[player] += 1\n            if self.scores[player] == self.max_score:\n                return "Player {} has won the game!".format(next(self.players))\n            else:\n                return "Player {} has missed the ball!".format(player)\n
import re\nclass WordDictionary:\n    def __init__(self):\n        self.data=[]\n  \n    def add_word(self,x):\n        self.data.append(x)\n  \n    def search(self,x):\n        for word in self.data:\n            if re.match(x+"\Z",word): return True\n        return False
from operator import mul\n\ndef ride(group, comet):\n    val = lambda name: reduce(mul, (ord(c)-64 for c in name))\n    return 'GO' if val(comet) % 47 == val(group) % 47 else 'STAY'
import re\n\nTABLE = str.maketrans('ACGT','UGCA')\n\ndef protein_synthesis(dna):\n    rna = re.findall(r'.{1,3}', dna.translate(TABLE))\n    return ' '.join(rna), ' '.join(x for x in map(CODON_DICT.get, rna) if x)
class Dog ():\n  def __init__(self, breed):\n    self.breed = breed\n  def bark(self):\n    return "Woof"\n\nsnoopy = Dog("Beagle")\n\nscoobydoo = Dog("Great Dane")
def solution(value):\n    return "Value is %05d" % value
def find_ball(scales, n):\n    select = list(range(n))\n    while len(select) > 1:\n        left, right, unused = select[::3], select[1::3], select[2::3]\n        if len(select) % 3 == 1: unused.append(left.pop())\n        select = [left, unused, right][scales.get_weight(left, right) + 1]\n    return select.pop()
from itertools import count, islice\n\n\nclass Harshad:\n    @staticmethod\n    def is_valid(number):\n        return number % sum(map(int, str(number))) == 0\n    \n    @classmethod\n    def get_next(cls, number):\n        return next(i for i in count(number+1) if cls.is_valid(i))\n    \n    @classmethod\n    def get_series(cls, c, start=0):\n        return list(islice(filter(cls.is_valid, (i for i in count(start+1))), c))
def box(coords):\n    lat, long = zip(*coords)\n    return {"nw": [max(lat), min(long)], "se": [min(lat), max(long)]}
from datetime import date\n\n\ndef days_until_christmas(day):\n    christmas = date(day.year, 12, 25)\n    if day > christmas:\n        christmas = date(day.year + 1, 12, 25)\n    return (christmas - day).days\n
def closest_multiple_10(i):\n    return round(i, -1)
def is_uppercase(inp):\n    return inp.isupper()
import re\n\ndef sum_of_integers_in_string(s):\n    return sum(int(x) for x in re.findall(r"(\d+)", s))
from operator import itemgetter\n\ndef fight(r1, r2, tactics):\n    \n    i, bots = 0, sorted((r2,r1), key=itemgetter('speed'))                    # Get the bots in reversed order!\n    for r in bots: r['tactics'] = r['tactics'][::-1]                         # Reverse the tactics to use pop()\n    \n    while 1:\n        i ^= 1                                                               # Swapper\n        if bots[i]['tactics']:\n            bots[i^1]['health'] -= tactics[ bots[i]['tactics'].pop() ]       # Hit\n        \n        if bots[i^1]['health'] <= 0 or all(not r['tactics'] for r in bots):  # other bot is dead or no tactics for both of them\n            break\n    \n    a,b = bots\n    cmp = (a['health'] < b['health']) - (a['health'] > b['health'])          # 1: b wins / -1: a wins / 0: tie\n    \n    return "The fight was a draw." if not cmp else f"{bots[max(cmp,0)]['name']} has won the fight."
def knapsack(capacity, items):\n    ratios = [float(item[1]) / item[0] for item in items]\n    collection = [0] * len(items)\n    space = capacity\n    while any(ratios):\n        best_index = ratios.index(max(ratios))\n        if items[best_index][0] <= space:\n            collection[best_index] += 1\n            space -= items[best_index][0]\n        else:\n            ratios[best_index] = 0\n    return collection
from fractions import gcd\n\ndef relatively_prime (n, l):\n    return [x for x in l if gcd(n, x) == 1]\n
def tower_builder(n, (w, h)):\n    return [str.center("*" * (i*2-1)*w, (n*2-1)*w) for i in range(1, n+1) for _ in range(h)]
def vampire_test(x, y):\n    return sorted(str(x * y)) == sorted(str(x) + str(y))
class Node(object):\n  def __init__(self, data, nxt = None):\n    self.data = data\n    self.next = nxt\n    \ndef sorted_insert(head, data):\n  if not head or data < head.data: return Node(data, head)\n  else:\n    head.next = sorted_insert(head.next, data)\n    return head
class Node(object):\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n    \ndef length(node):\n    leng = 0\n    while node:\n        leng += 1\n        node = node.next\n    return leng\n  \ndef count(node, data):\n    c = 0\n    while node:\n        if node.data==data:\n            c += 1\n        node = node.next\n    return c
def trouble(x, t):\n    arr = [x[0]]\n    for c in x[1:]:\n        if c + arr[-1] != t:\n            arr.append(c)\n    return arr
def user_contacts(data):\n    return {contact[0]: contact[1] if len(contact) > 1 else None\n            for contact in data}\n
def solution(n):\n    roman_numerals = {1000:'M',\n                      900: 'CM',\n                      500: 'D',\n                      400: 'CD',\n                      100: 'C',\n                      90: 'XC',\n                      50: 'L',\n                      40: 'XL',\n                      10: 'X',\n                      9: 'IX',\n                      5: 'V',\n                      4: 'IV',\n                      1: 'I'\n    }\n    roman_string = ''\n    for key in sorted(list(roman_numerals.keys()),reverse=True):\n        while n >= key:\n            roman_string += roman_numerals[key]\n            n -= key\n    return roman_string\n
def search(titles, term): \n    return list(filter(lambda title: term in title.lower(), titles))
def goals(*a):\n    return sum(a)
def shift(string, step):\n    i = (step % len(string)) if string else 0\n    return f"{string[-i:]}{string[:-i]}"\n\ndef encode(n, string):\n    for _ in range(n):\n        shifted = shift(string.replace(" ", ""), n)\n        l = [len(word) for word in string.split(" ")]\n        string = " ".join(shift(shifted[sum(l[:i]):sum(l[:i+1])], n) for i in range(len(l)))\n    return f"{n} {string}"\n\ndef decode(string):\n    n, string = int(string.partition(" ")[0]), string.partition(" ")[2]\n    for _ in range(n):\n        shifted = shift("".join(shift(word, -n) for word in string.split(" ")), -n)\n        l = [len(word) for word in string.split(" ")]\n        string = " ".join(shifted[sum(l[:i]):sum(l[:i+1])] for i in range(len(l)))\n    return string\n
from math import hypot\n\nDIRS = {'': (0,-1),  '': (-1,0), '': (0,1), '': (1,0),\n        '': (-1,-1), '': (-1,1), '': (1,1), '': (1,-1)}\n\ndef count_deaf_rats(town):\n    pipper = next( (x,y) for x,r in enumerate(town) for y,c in enumerate(r) if c=='P')\n    return sum( isDeaf(pipper, x,y, *DIRS[c])\n                for x,r in enumerate(town) for y,c in enumerate(r)\n                if c in DIRS )\n\ndef isDeaf(pipper,x,y,dx,dy):\n    dCurrent, dNext = (hypot(*(a-b for a,b in zip(pipper,pos))) for pos in ((x,y),(x+dx,y+dy)))\n    return dCurrent < dNext
def sort_csv_columns(csv_file_content, sep=';', end='\n'):\n    '''Sort a CSV file by column name.'''\n    csv_columns = zip(*(row.split(sep) for row in csv_file_content.split(end)))\n    sorted_columns = sorted(csv_columns, key=lambda col: col[0].lower())\n    return end.join(sep.join(row) for row in zip(*sorted_columns))
def predict(candidates, polls):\n    x = zip(*[list(map(lambda i: i * weight, poll)) for poll, weight in polls])\n    x = list(map(round1, (map(lambda i: sum(i) / sum([i[1] for i in polls]), x))))\n    return dict(zip(candidates,x))
class Game():\n    \n    def __init__(self, n):\n        k = 2 * n + 1\n        self.board = {frozenset(k * r + 1 + c + d for d in (0, n, n + 1, k))\n                        for r in range(n) for c in range(n)}\n\n    def play(self, lines):\n        lines = set(lines)\n        while 1:\n            for cell in self.board:\n                stick = cell - lines\n                if len(stick) <= 1:\n                    lines |= stick\n                    self.board.remove(cell)\n                    break\n            else: break\n        return sorted(lines)
def merge(*dicts):\n    result = {}\n    for d in dicts:\n        for key, value in d.items():\n            result.setdefault(key, []).append(value)\n    return result\n\nfrom itertools import groupby, chain
def meeting(s):\n    return ''.join(sorted('({1}, {0})'.format(*(x.split(':'))) for x in s.upper().split(';')))
def transpose(song, interval):\n    altern = {"Bb": "A#", "Db": "C#", "Eb": "D#", "Gb": "F#", "Ab": "G#"}\n    notes = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#']\n    return [notes[(notes.index(altern.get(i, i)) + interval) % 12] for i in song]
def f(n, m):\n    re, c = divmod(n,m) \n    return m*(m-1)/2*re + (c+1)*c/2
def how_many_years (date1,date2):\n  return abs(int(date1.split('/')[0]) - int(date2.split('/')[0]))\n
def square(n):\n    return n ** 2
def hollow_triangle(n):\n    width = n * 2 - 1\n    row = '{{:_^{}}}'.format(width).format\n    return [row(mid(a)) for a in xrange(1, width, 2)] + [width * '#']\n\n\ndef mid(n):\n    return '#' if n == 1 else '#{}#'.format('_' * (n - 2))
def solution(string, ending):\n    return string.endswith(ending)
def mutate_my_strings(s1,s2):\n    return '\n'.join( [s1] + [s2[:i]+s1[i:] for i,(a,b) in enumerate(zip(s1,s2),1) if a != b ]) + '\n'
def bingo(card, numbers):\n    \n    rc, cc, dc = [0]*5, [0]*5, [1]*2            # rows count, columns count, diag counts\n    rc[2] = cc[2] = 1                           # preaffect 'FREE SPACE'\n    s = set(numbers)\n    \n    for x,line in enumerate(card[1:]):\n        for y,(c,n) in enumerate(zip(card[0], line)):\n            tile = f'{c}{n}'\n            if tile in s:\n                rc[x] += 1\n                cc[y] += 1\n                if x == y:   dc[0] += 1         # main diag\n                if x+y == 4: dc[1] += 1         # secundary diag\n    return 5 in rc + cc + dc
from math import sin, atan\n\ndef temps(v0, slope, d_tot):\n    GRAVITY_ACC = 9.81 * 3.6 * 60.0                   # gravity acceleration\n    DRAG = 60.0 * 0.3 / 3.6                           # force applied by air on the cyclist\n    DELTA_T = 1.0/60.0                                # in minutes\n    D_WATTS = 0.5                                     # power loss in Watts / minute\n    G_THRUST = 60 * 3.6 * 3.6                         # acceleration due to biker's power\n    MASS = 80                                         # biker's MASS\n    WATTS0 = 225                                      # initial biker's power\n\n    t = 0.0          # time in minutes\n    d = 0.0          # distance traveled in km\n    v = v0           # initial speed km/h\n    gamma = 0.0      # acceleration in km/h/minute\n    watts = WATTS0   # biker's power (watts at time t + DELTA_T is watts at time t - D_WATTS * DELTA_T)\n    slopeGravityAcc = -GRAVITY_ACC * sin(atan(slope / 100.0))\n    while (d <= d_tot):\n        t += DELTA_T\n        # new power\n        watts -= D_WATTS * DELTA_T # tiredness\n        # earth gravity due to slope and DRAG due to air resistance\n        gamma = slopeGravityAcc - DRAG * abs(v) * abs(v) / MASS\n        # acceleration due to biker's power\n        if ((watts > 0.0) and (v > 0.0)):\n            gamma += G_THRUST * watts / (v * MASS);\n        # acceleration too small -> acc = 0\n        if (abs(gamma) <= 1e-5):\n            gamma = 0.0;\n        else:\n            v += gamma * DELTA_T\n        # new distance\n        d +=  v  * DELTA_T / 60.0 # v in km/h, DELTA_T in minutes\n        # speed too slow, John stops\n        if (v - 3.0 <= 1e-2):\n            return -1\n    return round(t)\n
def word_problem(rules: List[Tuple[str, str]], from_str: str, to_str: str, applications: int) -> bool:\n    rec = lambda s,n: s == to_str or n and any(s[i:].startswith(x) and rec(s[:i] + y + s[i+len(x):], n-1) for i in range(len(s)) for x,y in rules)\n    return rec(from_str, applications)
class HTMLGen:\n    def __init__(self):\n        self.a = lambda t: self.tag("a", t)\n        self.b = lambda t: self.tag("b", t)\n        self.p = lambda t: self.tag("p", t)\n        self.body = lambda t: self.tag("body", t)\n        self.div = lambda t: self.tag("div", t)\n        self.span = lambda t: self.tag("span", t)\n        self.title = lambda t: self.tag("title", t)\n        \n    def tag(self, tag_str, content):\n        return "<{}>{}</{}>".format(tag_str, content, tag_str)\n        \n    def comment(self, content):\n        return "<!--{}-->".format(content)
def fibs_fizz_buzz(n):\n    a, b, out = 0, 1, []\n\n    for i in range(n):\n        s = "Fizz"*(b % 3 == 0) + "Buzz"*(b % 5 == 0)\n        out.append(s if s else b)\n        a, b = b, a+b\n        \n    return out
cache = {}\ndef sum_div(x):\n    if x not in cache:\n        cache[x] = sum(i for i in range(1, x+1) if x % i == 0)\n    return cache[x]\n\ndef is_required(x):\n    reversed = int(str(x)[::-1])\n    return x != reversed and sum_div(x) == sum_div(reversed)\n\nrequired = [x for x in range(528, 10**4) if is_required(x)]\n\ndef equal_sigma1(nMax):\n    return sum(x for x in required if x <= nMax)\n
def wanted_words(vowels, consonants, forbidden):\n    return [w for w in WORD_LIST\n            if len(w) == vowels + consonants\n                and sum(map(w.count, 'aeiou')) == vowels\n                    and not any(c in w for c in forbidden)]
def capital(capitals):\n    return [f"The capital of {c.get('state') or c['country']} is {c['capital']}" for c in capitals]
