{"id": "1", "input": "s = input()\\nn = len(s)\\nind = -1\\nf = False\\nfor i in range(n):\\n if s[i] == '[':\\n f = True\\n elif s[i] == ':':\\n if f:\\n ind = i\\n break\\nbind = -1\\nf = False\\nfor i in range(n-1,-1,-1):\\n if s[i] == ']':\\n", "gt": "f = True\\n elif s[i] == ':':\\n if f:\\n bind = i\\n break\\n# print(ind,bind)\\nif ind == -1 or bind == -1:\\n print(-1)\\nelif ind >= bind:\\n print(-1)\\nelse:\\n ans = 4\\n for i in range(ind+1,bind):\\n if s[i] == '|':\\n ans += 1\\n print(ans)\\n"}
{"id": "2", "input": "num = list(map(int, input()))\\nbest = num[:]\\nfor i in range(-1, -len(num) - 1, -1):\\n if num[i] == 0:\\n continue\\n num[i] -=", "gt": "1\\n for j in range(i + 1, 0):\\n num[j] = 9\\n if sum(num) > sum(best):\\n best = num[:]\\ns = ''.join(map(str, best)).lstrip('0')\\nprint(s)\\n"}
{"id": "3", "input": "def main():\\n s = input()\\n n = len(s)\\n t = int(str(int(s[0])", "gt": "+ 1) + '0' * (n - 1))\\n\\n print(t - int(s))\\n\\nmain()\\n"}
{"id": "4", "input": "from collections import defaultdict as dd\\nimport math\\ndef nn():\\n return int(input())\\n\\ndef li():\\n return list(input())\\n\\ndef mi():\\n return list(map(int, input().split()))\\n\\ndef lm():\\n return list(map(int, input().split()))\\n\\n\\nn, q=mi()\\n\\nints=[]\\n\\n\\nfor _ in range(q):\\n st, end=mi()\\n ints.append((st,end))\\n\\n\\ncoverage=[10]+[0]*n\\n\\nfor st, end in ints:\\n for i in range(st,end+1):\\n coverage[i]+=1\\n\\ntotal=-1\\n\\nfor val in coverage:\\n", "gt": "if not val==0:\\n total+=1\\n\\nsinglecount=0\\ndoublecount=0\\n\\nsingles=[0]*(n+1)\\n#print(total)\\ndoubles=[0]*(n+1)\\nfor i in range(len(coverage)):\\n #print(i,singles)\\n if coverage[i]==1:\\n singlecount+=1\\n if coverage[i]==2:\\n doublecount+=1\\n singles[i]=singlecount\\n doubles[i]=doublecount\\nmaxtotal=0\\nfor i in range(len(ints)):\\n for j in range(i+1, len(ints)):\\n st1=min(ints[i][0],ints[j][0])\\n end1=min(ints[i][1],ints[j][1])\\n st2, end2=max(ints[i][0],ints[j][0]), max(ints[i][1],ints[j][1])\\n #assume st1<=st2\\n if end1<st2:\\n curtotal=total-(singles[end1]-singles[st1-1])-(singles[end2]-singles[st2-1])\\n elif end1<end2:\\n curtotal=total-(singles[st2-1]-singles[st1-1])-(doubles[end1]-doubles[st2-1])-(singles[end2]-singles[end1])\\n else:\\n curtotal=total-(singles[st2-1]-singles[st1-1])-(doubles[end2]-doubles[st2-1])-(singles[end1]-singles[end2])\\n maxtotal=max(maxtotal,curtotal)\\n\\nprint(maxtotal)\\n \\n\\n\\n\\n\\n\\n\\n\\n"}
{"id": "5", "input": "x=int(input())\\nh,m=list(map(int,input().split()))\\ndef ok(mm):\\n while mm<0: mm+=1440\\n hh=mm//60\\n mm=mm%60\\n return hh%10==7 or hh//10==7", "gt": "or mm%10==7 or mm//10==7\\nfor y in range(999):\\n if ok(h*60+m-y*x):\\n print(y)\\n return\\n"}
{"id": "6", "input": "n, pos, l, r = map(int, input().split())\\n\\nif l > 1 and r < n:\\n if l <= pos and pos <= r:\\n if pos - l < r - pos:\\n print(pos - l + 1 + r - l + 1)\\n else:\\n print(r - pos + 1 + r - l +", "gt": "1)\\n elif pos > r:\\n print(pos - r + 1 + r - l + 1)\\n else:\\n print(l - pos + 1 + r - l + 1)\\nelif l == 1 and r < n:\\n print(int(abs(pos - r)) + 1)\\nelif l > 1 and r == n:\\n print(int(abs(pos - l)) + 1)\\nelse:\\n print(0)"}
{"id": "7", "input": "for _ in range(int(input())):\\n n, x = list(map(int, input().split()))\\n A = []\\n for _1 in range(n):\\n d, h = list(map(int, input().split()))\\n A.append([d, h])\\n A.sort(reverse=True)\\n if A[0][0] >= x:\\n print(1)\\n else:\\n", "gt": "x -= A[0][0]\\n mz = 0\\n for d, h in A:\\n mz = max(mz, d - h)\\n if mz:\\n print((x + mz - 1) // mz + 1)\\n else:\\n print(-1)\\n"}
{"id": "8", "input": "n, m = map(int, input().split())\\nif (m >= n): print(n)\\nelse:\\n c = n - m\\n l = 0\\n r = 10 ** 18\\n while r - l >", "gt": "1:\\n md = (r + l) // 2\\n if (1 + md) * md // 2 < c:\\n l = md\\n else:\\n r = md\\n print(r + m)"}
{"id": "9", "input": "cards=list(input().split())\\nlm=[0]*9\\nlp=[0]*9\\nls=[0]*9\\nfor item in cards:\\n if item[1]=='m':\\n lm[int(item[0])-1]+=1\\n elif item[1]=='p':\\n lp[int(item[0])-1]+=1\\n else :\\n ls[int(item[0])-1]+=1\\nif max(lm)==3 or max(lp)==3 or max(ls)==3:\\n print(0)\\nelse :\\n flag=0\\n def seq_checker(li):\\n flag=0\\n for i in range(9):\\n if flag==0:\\n if lm[i]==1:\\n flag=1\\n", "gt": "else :\\n if lm[i]==1:\\n flag+=1\\n else :\\n break\\n return flag\\n if seq_checker(lm)==3 or seq_checker(lp)==3 or seq_checker(ls)==3:\\n print(0)\\n elif max(lm)==2 or max(lp)==2 or max(ls)==2:\\n print(1)\\n else :\\n m=0\\n for i in range(0,7):\\n m=max(sum(lm[i:i+3]),sum(lp[i:i+3]),sum(ls[i:i+3]),m)\\n print(3-m)"}
{"id": "10", "input": "from sys import stdin, stdout\\n\\nk = int(stdin.readline())\\nn, m = map(int, stdin.readline().split())\\nleft, right, down, up = [], [], [], []\\ncoordinates = []\\n\\nfor i in range(k):\\n x1, y1, x2, y2 = map(int, stdin.readline().split())\\n \\n if x1 == x2:\\n if y1 < y2:\\n coordinates.append((x1, y1, x2, y2, i))\\n else:\\n coordinates.append((x2, y2, x1, y1, i))\\n else:\\n if x1 < x2:\\n coordinates.append((x1, y1, x2, y2, i))\\n else:\\n coordinates.append((x2, y2, x1, y1, i))\\n \\n left.append(coordinates[-1])\\n right.append(coordinates[-1])\\n up.append(coordinates[-1])\\n down.append(coordinates[-1])\\n\\nleft.sort(key = lambda x: (x[0], x[2]))\\ndown.sort(key = lambda x: (x[1], x[3]))\\n\\nchallengers = [[], [], [], []]\\ncntl, cntr, cntd, cntu = map(int, stdin.readline().split())\\nlabel = 1\\n\\nif cntl or not cntl:\\n for i in range(cntl, -1, -1):\\n if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):\\n challengers[0].append(left[i][-1]) \\n else:\\n break\\n \\n for i in range(cntl + 1, k):\\n if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]) and left[i][2] > left[i][0]:\\n label = 0\\n \\n if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):\\n challengers[0].append(left[i][-1]) \\n else:\\n break\\n\\nif cntr or not cntr:\\n for i in range(k - 1 - cntr, k):\\n if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):\\n challengers[1].append(left[i][-1])\\n else:\\n break\\n \\n for i in range(k - 2 - cntr, -1, -1):\\n", "gt": "if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]) and left[i][2] > left[i][0]:\\n label = 0\\n \\n if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):\\n challengers[1].append(left[i][-1])\\n else:\\n break\\n\\n#!!!!!!!!!!!\\n\\nif cntd or not cntd:\\n for i in range(cntd, -1, -1):\\n if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):\\n challengers[2].append(down[i][-1])\\n else:\\n break\\n \\n for i in range(cntd + 1, k):\\n if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]) and down[i][3] > down[i][1]:\\n label = 0\\n \\n if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):\\n challengers[2].append(down[i][-1]) \\n else:\\n break\\n \\nif cntu or not cntu:\\n for i in range(k - 1 - cntu, k):\\n if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):\\n challengers[3].append(down[i][-1])\\n else:\\n break\\n \\n for i in range(k - 2 - cntu, -1, -1):\\n if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]) and down[i][3] > down[i][1]:\\n label = 0\\n \\n if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):\\n challengers[3].append(down[i][-1])\\n else:\\n break\\n\\nans = set(challengers[0]) & set(challengers[1]) & set(challengers[2]) & set(challengers[3])\\n\\nif not len(ans) or not label:\\n stdout.write('-1')\\nelse:\\n stdout.write(str(list(ans)[0] + 1))"}
{"id": "11", "input": "<s> ", "gt": "n=int(input())\\nr=n%7\\nd=n//7\\nprint(2*d+max(0,r-5),2*d+min(r,2))\\n"}
{"id": "12", "input": "from fractions import gcd\\ndef lcm(a, b):\\n return a*b//gcd(a, b)\\nn, a, b, p, q = list(map(int,", "gt": "input().split(' ')))\\nred = n//a\\nblue = n//b\\nif (p<q):\\n red -= n//lcm(a, b)\\nelse:\\n blue -= n//lcm(a, b)\\n\\nprint(p*red+q*blue)\\n"}
{"id": "13", "input": "n = int(input())\\nA = input()\\nx = A.count('G')\\nnum_1 = 0\\nnum_2 = 0\\nmax_num = 0\\nflag = 0\\nfor i in range(n):\\n if A[i] == 'G' and flag == 0:\\n num_1 += 1\\n elif A[i] == 'G' and flag == 1:\\n num_2 += 1\\n elif A[i] == 'S' and flag == 0:\\n flag = 1\\n else:\\n if num_1 + num_2 + 1 <= x:\\n if num_1 + num_2 + 1 > max_num:\\n max_num", "gt": "= num_1 + num_2 + 1\\n num_1 = num_2\\n num_2 = 0\\n flag = 1\\n else:\\n if num_2 + num_1 > max_num:\\n max_num = num_1 + num_2\\n num_1 = num_2\\n num_2 = 0\\n flag = 1\\nif num_1 + num_2 + 1 <= x:\\n if num_1 + num_2 + 1 > max_num:\\n max_num = num_1 + num_2 + 1\\nelse:\\n if num_2 + num_1 > max_num:\\n max_num = num_1 + num_2\\nprint(max_num)\\n"}
{"id": "14", "input": "#This code is dedicated to Vlada S.\\n\\nclass Course:\\n def __init__(self, reqs, number):\\n self.reqs = list(map(int, reqs.split()[1:]))\\n self.available = False\\n self.in_stack = False\\n self.number = number\\n\\nn, k = list(map(int, input().split()))\\nrequirements = list(map(int, input().split()))\\ncourses = {}\\n\\nanswer = \"\"\\n\\nfor i in range(n):\\n courses[i + 1]= Course(input(), i + 1)\\n\\nfor i in range(len(requirements)):\\n requirements[i] =", "gt": "courses[requirements[i]]\\n\\nwhile requirements:\\n data ="}
{"id": "15", "input": "import sys\\n\\n#f = open('input', 'r')\\nf = sys.stdin\\nn,k = list(map(int, f.readline().split()))\\na = list(map(int, f.readline().split()))\\naset = set(a)\\nst = []\\nfailed = False\\nai = 0\\napp = []\\nfor p in range(1, n+1):\\n if p in aset:\\n while ai < k and (len(st)==0 or st[-1]!=p):\\n st.append(a[ai])\\n", "gt": "ai += 1\\n if len(st) == 0 or st[-1] != p:\\n failed = True\\n break\\n st.pop(-1)\\n a += app[::-1]\\n app = []\\n else:\\n if ai != k:\\n st += a[ai:k]\\n ai = k\\n app.append(p)\\n\\nif failed:\\n print(-1)\\nelse:\\n print(' '.join(map(str, a + app[::-1])))\\n"}
{"id": "16", "input": "import sys\\na,b,c=map(int,input().split())\\nif c==0:\\n if a==b:\\n print('YES')\\n else:\\n", "gt": "print('NO')\\n return\\nif (b-a)%c==0 and (b-a)//c>=0:\\n print('YES')\\nelse:\\n print('NO')"}
{"id": "17", "input": "cnt1 = int(input())\\ncnt2 = int(input())\\ncnt3 = int(input())\\ncnt4 = int(input())\\nif cnt1 !=", "gt": "cnt4:\\n print(0)\\n return\\n\\nif (cnt3 != 0 and cnt1 == 0):\\n print(0)\\n return\\n\\nprint(1)"}
{"id": "18", "input": "def read_ints():\\n return [int(i) for i in input().split()]\\n\\nn, k, t = read_ints()\\nif", "gt": "t <= k:\\n print(t)\\nelif t > n:\\n print(k + n - t)\\nelse:\\n print(k)"}
{"id": "19", "input": "from collections import deque\\nS = input()\\nmn = [ 300 for i in range( len( S ) ) ]\\nfor i in range( len( S ) - 1, -1, -1 ):\\n if i == len( S ) - 1:\\n mn[ i ] = ord( S[ i ] )\\n else:\\n mn[ i ] = min( mn[ i + 1 ], ord( S[ i ]", "gt": ") )\\nans = \"\"\\ndq = deque()\\nfor i in range( len( S ) ):\\n dq.append( ord( S[ i ] ) )\\n while len( dq ) and ( i + 1 == len( S ) or dq[ len( dq ) - 1 ] <= mn[ i + 1 ] ):\\n ans += chr( dq[ len( dq ) - 1 ] )\\n dq.pop()\\nprint( ans )\\n"}
{"id": "20", "input": "import sys\\ninput = sys.stdin.readline\\n\\nT = int(input())\\nfor _ in range(T):\\n n = int(input())\\n lastP = 0\\n lastC = 0\\n works = True\\n for _ in range(n):\\n p, c = list(map(int,", "gt": "input().split()))\\n pDiff = p-lastP\\n cDiff = c-lastC\\n if 0 <= cDiff <= pDiff:\\n pass\\n else:\\n works = False\\n lastP = p\\n lastC = c\\n if works:\\n print('YES')\\n else:\\n print('NO')\\n"}
{"id": "21", "input": "s = input()\\nh = int(s[:2])\\nm = int(s[3:])\\n\\ndef ispalin(h, m):\\n s = \"%02d:%02d\"%(h,m)\\n return s == s[::-1]\\n\\nfor d in", "gt": "range(999999):\\n if ispalin(h, m):\\n print(d)\\n break\\n m+= 1\\n if m == 60:\\n h = (h+1)%24\\n m = 0\\n"}
{"id": "22", "input": "read = lambda: list(map(int, input().split()))\\nn = int(input())\\na = list(read())\\nx, y = a.index(1), a.index(n)\\nans", "gt": "= max(x, y, n - x - 1, n - y - 1)\\nprint(ans)\\n"}
{"id": "23", "input": "import sys, math\\ns=input()\\npal='AHIMOoTUVvWwXxY'\\nn=len(s)\\nl=0\\nr=n-1\\nflag=True\\nfir='pq'\\nsec='bd'\\nwhile l<=r:\\n if s[l]==s[r] and s[l] in pal:\\n l+=1\\n r-=1\\n continue\\n elif s[l]==s[r]:\\n flag=False\\n break\\n elif (s[l] in fir) and (s[r]", "gt": "in fir):\\n l+=1\\n r-=1\\n continue\\n elif (s[l] in sec) and (s[r] in sec):\\n l+=1\\n r-=1\\n continue\\n else:\\n flag=False\\n break\\nif flag:\\n print('TAK')\\nelse:\\n print('NIE')\\n \\n"}
{"id": "24", "input": "a = list(input())\\nb = int(input())\\na.sort()\\na = a[::-1]\\nprefix = \"\"\\nwhile(len(a) > 0):\\n for i in range(len(a)):\\n num = prefix +", "gt": "a[i] + \"\".join(sorted(a[:i] + a[i + 1:]))\\n if (int(num) <= b):\\n prefix += a[i]\\n a = a[:i] + a[i+1:]\\n break\\nprint(prefix)\\n"}
{"id": "25", "input": "s = [ [ c for c in input() ] for i in range(10) ]\\ndef win():\\n for i in range(10):\\n for j in range(10):\\n ok = True\\n for k in range(5):\\n if j+k>9: ok = False\\n elif s[i][j+k] != 'X': ok = False\\n if ok: return True\\n ok = True\\n for k in range(5):\\n if i+k>9: ok = False\\n elif s[i+k][j] != 'X': ok = False\\n if ok: return True\\n", "gt": "ok = True\\n for k in range(5):\\n if j+k>9 or i+k>9: ok = False\\n elif s[i+k][j+k] != 'X': ok = False\\n if ok: return True\\n ok = True\\n for k in range(5):\\n if i-k<0 or j+k>9: ok = False\\n elif s[i-k][j+k] != 'X': ok = False\\n if ok: return True\\n return False\\nfor i in range(10):\\n for j in range(10):\\n if s[i][j]=='.':\\n s[i][j] = 'X'\\n if win():\\n print('YES')\\n return\\n s[i][j] = '.'\\nprint('NO')\\n"}
{"id": "26", "input": "#!/usr/bin/env python3\\n\\ndef main():\\n import sys\\n\\n readln = sys.stdin.readline\\n try:\\n while True:\\n n, k = list(map(int, input().split()))\\n a = [['0'] * n for i in range(n)]\\n i = j = 0\\n while k > 0:\\n if i == j:\\n a[i][j] = '1'\\n k -= 1\\n j += 1\\n elif k >= 2:\\n a[i][j] = a[j][i] = '1'\\n k -= 2\\n j += 1\\n", "gt": "elif i != n - 1:\\n a[i + 1][i + 1] = '1'\\n k = 0\\n else:\\n assert a[i][i] == '1'\\n a[i][i] = '0'\\n a[i][j] = a[j][i] = '1'\\n k = 0\\n\\n if j == n:\\n i += 1\\n if i == n and k > 0:\\n print(-1)\\n break\\n j = i\\n else:\\n for row in a:\\n print(' '.join(row))\\n\\n except EOFError:\\n pass\\n\\nmain()\\n"}
{"id": "27", "input": "from math import log\\nfrom decimal import Decimal\\n\\ns = ['x^y^z', 'x^z^y', '(x^y)^z', 'y^x^z', 'y^z^x', '(y^x)^z', 'z^x^y', 'z^y^x', '(z^x)^y']\\n\\nx, y, z = list(map(Decimal, input().split()))\\n\\nf = []\\nf += [(Decimal(log(x)) * (y ** z), 0)]\\nf += [(Decimal(log(x)) * (z ** y), -1)]\\nf += [(Decimal(log(x)) * (y *", "gt": "z), -2)]\\nf += [(Decimal(log(y)) * (x ** z), -3)]\\nf += [(Decimal(log(y)) * (z ** x), -4)]\\nf += [(Decimal(log(y)) * (x * z), -5)]\\nf += [(Decimal(log(z)) * (x ** y), -6)]\\nf += [(Decimal(log(z)) * (y ** x), -7)]\\nf += [(Decimal(log(z)) * (x * y), -8)]\\n\\nf.sort()\\n\\nprint(s[-f[-1][1]])\\n"}
{"id": "28", "input": "n = int(input())\\nst = input()\\nans = n\\nnow = ''\\nma = 0\\nfor i in range(n // 2):\\n now += st[i]\\n t = ''\\n", "gt": "for j in range(i + 1, 2 * i + 2):\\n t += st[j]\\n if t == now:\\n ma = i\\nprint(ans - ma)\\n"}
{"id": "29", "input": "n = int(input())\\nt = [1] + [0] * n\\nb, a = d = [], []\\nh, s = [], []\\n\\nfor i in range(n):\\n f, k = input().split()\\n d[int(k)].append(f)\\n\\nm = len(a)\\nfor i in a:\\n if i.isdigit() and i[0] != '0':\\n j = int(i)\\n if 0 < j <= m:\\n t[j] = 1\\n elif m < j <= n:\\n t[j] = -1\\n else:\\n s.append(i)\\n else:\\n s.append(i)\\nfor i in b:\\n if i.isdigit() and i[0] != '0':\\n j = int(i)\\n if m < j <= n:\\n t[j] = 1\\n elif 0 < j <= m:\\n t[j] = -1\\n else:\\n s.append(i)\\n else:\\n s.append(i)\\n\\nx = [j for j in range(1, m + 1) if t[j] < 0]\\ny = [j for j in range(m + 1, n + 1)", "gt": "if t[j] < 0]\\n\\nu = [j for j in range(1, m + 1) if not t[j]]\\nv = [j for j in range(m + 1, n + 1) if not t[j]]\\n\\nif not s and (x or y):\\n s = ['0']\\n if y:\\n i = y.pop()\\n v.append(i)\\n else:\\n i = x.pop()\\n u.append(i)\\n h.append(str(i) + ' 0')\\n t[i] = 0\\n\\nwhile x or y:\\n if v and x:\\n i = x.pop()\\n j = v.pop()\\n t[j] = 1\\n h.append(str(i) + ' ' + str(j))\\n u.append(i)\\n else:\\n u, v, x, y = v, u, y, x\\n\\nk = 1\\nfor j in s:\\n while t[k] == 1: k += 1\\n h.append(j + ' ' + str(k))\\n k += 1\\n\\nd = '\\nmove '\\nprint(str(len(h)) + d + d.join(h) if h else 0)"}
{"id": "30", "input": "x=int(input())\\ndef s(a):\\n r=0\\n while a>0:\\n r+=a%10\\n a//=10\\n return r\\ndef d(a,b):\\n r=0\\n for i in range(6):\\n", "gt": "if a%10!=b%10:\\n r += 1\\n a//=10\\n b//=10\\n return r\\nc=6\\nfor i in range(1000000):\\n if s(i%1000)==s(i//1000):\\n c=min(c,d(x,i))\\nprint(c)\\n"}
{"id": "31", "input": "from math import gcd\\ndef powmod(a,b,m):\\n a%=m\\n r=1\\n while b:\\n if b&1:r=r*a%m\\n a=a*a%m\\n b>>=1\\n return r\\n\\ndef f(n):\\n r=[]\\n if (n&1)==0:\\n e=0\\n while (n&1)==0:n>>=1;e+=1\\n yield (2,e)\\n p=3\\n while n>1:\\n if p*p>n:p=n\\n if n%p:\\n p+=2\\n continue\\n e=1;n//=p\\n while n%p==0:n//=p;e+=1\\n yield (p,e)\\n p+=2\\n return r\\nm,x=map(int,input().split())\\np=2\\nr=[(1,1)]\\nfor p,e in", "gt": "f(m):\\n assert e>=1\\n ord=p-1\\n assert powmod(x,ord,p)==1\\n for pi,ei in f(p-1):\\n while ord % pi == 0 and powmod(x,ord//pi,p)==1: ord//=pi\\n ords=[(1,1),(ord,p-1)]\\n q=p\\n for v in range(2,e+1):\\n q*=p\\n if powmod(x,ord,q)!=1:ord*=p\\n assert powmod(x,ord,q)==1\\n ords.append((ord,q//p*(p-1)))\\n r=[(a//gcd(a,c)*c,b*d) for a,b in r for c,d in ords]\\nprint(sum(y//x for x,y in r))"}
{"id": "32", "input": "m = 10** 6 + 3\\n\\nn, k = list(map(int, input().split()))\\np = 1\\nfor i in range(n):\\n p *= 2\\n if p > k:\\n break\\nif p < k:\\n print('1 1')\\n return\\n\\ngcd = tmp = k - 1\\nwhile tmp:\\n gcd -= tmp % 2\\n tmp //= 2\\nb = pow(2, (k - 1) * n - gcd, m)\\na =", "gt": "1\\nmem = [-1]*100\\nfor i in range(1, k):\\n cnt = 0\\n while i % 2 == 0:\\n i //= 2\\n cnt += 1\\n if mem[cnt] == -1:\\n mem[cnt] = pow(2, n - cnt, m)\\n a = a * (mem[cnt] - i + m) % m\\n if a == 0:\\n break\\nprint((b - a + m) % m, b)\\n"}
{"id": "33", "input": "\"\"\"\\nCodeforces Good Bye 2016 Contest Problem B\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.5.2\\n\"\"\"\\n\\n################################################### SOLUTION\\n\\ndef main():\\n latitude = 0\\n n, = read()\\n for i in range(n):\\n l, d = read(str)\\n l = int(l)\\n if latitude == 0:\\n if d != \"South\":\\n return \"NO\"\\n if latitude == 20000:\\n if d != \"North\":\\n return \"NO\"\\n if d ==", "gt": "\"South\":\\n latitude += l\\n elif d == \"North\":\\n latitude -= l\\n if not (0 <= latitude <= 20000):\\n return \"NO\"\\n if latitude != 0:\\n return \"NO\"\\n return \"YES\"\\n\\n#################################################### HELPERS\\n\\ndef read(callback=int):\\n return list(map(callback, input().strip().split()))\\n\\ndef write(value, end=\"\\n\"):\\n if value is None: return\\n try:\\n if not isinstance(value, str):\\n value = \" \".join(map(str, value))\\n except:\\n pass\\n print(value, end=end)\\n\\nwrite(main())\\n"}
{"id": "34", "input": "import sys, collections\\n\\ndef gcd(a, b):\\n if b == 0: return a\\n return gcd(b, a % b)\\n\\ndef lcm(a, b):\\n return a // gcd(a, b) * b\\n\\ndef extgcd(a, b):\\n if b == 0: return 1, 0\\n x, y = extgcd(b, a % b)\\n return y, x - a // b * y\\n\\ndef prime_factor(n):\\n res = collections.defaultdict(int)\\n\\n i = 2\\n while i * i <= n:\\n cnt = 0\\n while n % i == 0:\\n n //= i\\n cnt += 1\\n if cnt > 0: res[i] = cnt\\n i += 1\\n if n != 1: res[n] = 1\\n\\n return res\\n\\ndef modinv(a, mod):\\n if a == 0: return -1\\n if gcd(a, mod) != 1: return -1\\n return extgcd(a, mod)[0] % mod\\n\\ndef normalize(a1, a2):\\n p1 = prime_factor(a1)\\n p2 = prime_factor(a2)\\n\\n keys = list(set(p1.keys()) | set(p2.keys()))\\n\\n r1 = 1\\n r2 = 1\\n for k in keys:\\n if p1[k] >= p2[k]:\\n r1 *= k ** p1[k]\\n else:\\n r2 *= k ** p2[k]\\n return r1, r2\\n\\ndef solve(a1, b1, a2, b2):\\n g = gcd(a1, a2)\\n if (b1 - b2) % g != 0: return", "gt": "-1\\n\\n a1, a2 = normalize(a1, a2)\\n u = b1 % a1\\n inv = modinv(a1, a2)\\n v = (b2 - u) * inv % a2\\n return u + v * a1\\n\\ndef f(x0, T, v):\\n ok = 10 ** 36\\n ng = -1\\n\\n while ok - ng > 1:\\n mid = (ok + ng) // 2\\n\\n if x0 + T * mid >= v:\\n ok = mid\\n else:\\n ng = mid\\n\\n return ok\\n\\na1, b1, a2, b2, L, R = map(int, input().split())\\n\\nT = lcm(a1, a2)\\nx0 = solve(a1, b1, a2, b2)\\n\\nif x0 == -1:\\n print(0)\\n return\\n\\nx0 -= T * 10 ** 36\\n\\nok = 10 ** 60\\nng = -1\\n\\nwhile ok - ng > 1:\\n mid = (ok + ng) // 2\\n\\n val = x0 + T * mid\\n k = (val - b1) // a1\\n l = (val - b2) // a2\\n if k >= 0 and l >= 0:\\n ok = mid\\n else:\\n ng = mid\\n\\nx0 += ok * T\\n\\n# L <= x0 + kT < R + 1\\nans = f(x0, T, R + 1) - f(x0, T, L)\\n\\nprint(ans)"}
{"id": "35", "input": "n, a, b = map(int, input().split())\\nans = 0\\nfor i in range(1,", "gt": "n):\\n ans = max(ans, min(a // i, b // (n - i)))\\nprint(ans)"}
{"id": "36", "input": "n,m=list(map(int,input().split()))\\nf=[input() for _ in range(n)]\\ndef clr(ss):\\n cc = None\\n for s in ss:\\n for c in s:\\n if cc is None:\\n cc = c\\n elif cc != c:\\n return None\\n return cc\\nif n%3 == 0:\\n s = set()\\n for i in range(0,n,n//3):\\n ret = clr(f[i:i+n//3])\\n", "gt": "if ret is None:\\n continue\\n s.add(ret)\\n if len(s) == 3:\\n print('YES')\\n return\\nif m%3 == 0:\\n s = set()\\n for j in range(0,m,m//3):\\n ff = []\\n for i in f:\\n ff.append(i[j:j+m//3])\\n ret = clr(ff)\\n if ret is None:\\n continue\\n s.add(ret)\\n if len(s) == 3:\\n print('YES')\\n return\\nprint('NO')\\n"}
{"id": "37", "input": "def f(n):\\n left, right = -1, n + 1\\n while right - left > 1:\\n mid = (left + right) // 2\\n x = 6 * mid * (mid + 1) // 2 + 5 * (mid + 1)\\n if x > n:\\n right = mid\\n else:\\n left = mid\\n if left >= 0:\\n mid = left\\n x = 6 * mid * (mid + 1) // 2 + 5 * (mid + 1)\\n n", "gt": "-= x\\n return (n, left + 1)\\n\\ndef main():\\n n = int(input())\\n n, k = f(n)\\n x = k\\n y = -2 * k\\n \\n d = [k + 1] * 6\\n d[1] -= 1\\n dx = [1, -1, -2, -1, 1, 2]\\n dy = [2, 2, 0, -2, -2, 0]\\n \\n for i in range(6):\\n x += min(d[i], n) * dx[i]\\n y += min(d[i], n) * dy[i]\\n n = max(0, n - d[i])\\n \\n print(x, y)\\n\\n\\nmain()\\n"}
{"id": "38", "input": "a, b, c = list(map(int, input().split()))\\np = [0] * 100000\\np[0] = 1\\np[a] = 1\\np[b] = 1\\nfor i in", "gt": "range(c + 1):\\n if p[i]:\\n p[i + a] = 1\\n p[i + b] = 1\\nif p[c]:\\n print('Yes')\\nelse:\\n print('No')\\n"}
{"id": "39", "input": "def main():\\n n, l = map(int, input().split())\\n\\n x = list(map(int, input().split()))\\n y = list(map(int, input().split()))\\n\\n x.append(x[0] + l)\\n y.append(y[0] + l)\\n\\n a = [x[i + 1] - x[i]", "gt": "for i in range(n)]\\n b = [y[i + 1] - y[i] for i in range(n)]\\n\\n for i in range(n):\\n if (a == b[i:] + b[:i]):\\n print(\"YES\")\\n return\\n print(\"NO\")\\n\\n\\nmain()"}
{"id": "40", "input": "s = input()\\nmx = 0\\nn = len(s)\\nfor l in range(n):\\n for r in", "gt": "range(l, n):\\n if s[l:r+1] != s[l:r+1][::-1]:\\n mx = max(mx, r - l + 1)\\nprint(mx)"}
{"id": "41", "input": "'''input\\n5\\n3123 3123\\n2777 2777\\n2246 2246\\n2246 2246\\n1699 1699\\n'''\\nn = int(input())\\nx = []\\nf = 0\\nfor _ in range(n):\\n a, b =", "gt": "list(map(int, input().split()))\\n if a != b:\\n f = 1\\n x.append(a)\\nif f == 1:\\n print(\"rated\")\\nelif sorted(x)[::-1] == x:\\n print(\"maybe\")\\nelse:\\n print(\"unrated\")\\n\\n\\n\\n\\n\\n\\n\\n"}
{"id": "42", "input": "inf = 10 ** 6\\nn = int(input())\\na = list(map(int, input().split()))\\ndist = [inf] * n\\nfor i in range(len(a)):\\n if not a[i]:\\n dist[i] = 0\\n cur = 1\\n i1 = i\\n while i1 - 1 > - 1 and a[i1 - 1] != 0:\\n dist[i1 -", "gt": "1] = min(dist[i1 - 1], cur)\\n i1 -= 1\\n cur += 1\\n i1 = i\\n cur = 1\\n while i1 + 1 < n and a[i1 + 1] != 0:\\n dist[i1 + 1] = min(dist[i1 + 1], cur)\\n i1 += 1\\n cur += 1\\nprint(*dist)"}
{"id": "43", "input": "n=int(input())\\ns=[c=='1' for c in input()]\\nm=len(s)\\nz=[[0,0]]\\nfor c in s:\\n ind = z[-1][c]\\n z[-1][c] = len(z)\\n z.append(z[ind][:])\\nassert(len(z) == m+1)\\nz[m][0] = z[m][1] = m # make it sticky\\n\\n# how many things match directly\\ndp = [0 for _ in range(m+1)]\\ndp[0] = 1\\nfor i in range(n):\\n ndp = [0 for _ in range(m+1)]\\n for i in range(m+1):\\n ndp[z[i][0]] += dp[i]\\n ndp[z[i][1]] += dp[i]\\n dp = ndp\\nres = dp[m]\\n\\nfor k in range(1, m):\\n s0 = 0\\n for c", "gt": "in s[-k:]:\\n s0 = z[s0][c]\\n dp = [0 for _ in range(m+1)]\\n dp[s0] = 1\\n for i in range(n - k):\\n ndp = [0 for _ in range(m+1)]\\n for i in range(m+1):\\n ndp[z[i][0]] += dp[i]\\n ndp[z[i][1]] += dp[i]\\n dp = ndp\\n for s1 in range(m): # skip m\\n v = dp[s1]\\n for c in s[-k:]:\\n if s1 == m: v = 0\\n s1 = z[s1][c]\\n if s1 == m: res += v\\nprint(res)"}
{"id": "44", "input": "from math import *\\n# stores counterclockwise angle between vector (1,0) and each vector in a\\na = []\\nn = int(input())\\nfor i in range(n):\\n x,y = list(map(int,input().split()))\\n # calculate counterclockwise angle between (1,0) and this vector\\n t = acos(x/sqrt(x**2+y**2))\\n a.append((i+1,[2*pi-t,t][y>=0],x,y))\\ncmp = lambda x:x[1]\\na = sorted(a,key=cmp)\\n# construct pairs for", "gt": "adjacent vectors\\nb = []\\nfor i in range(n):\\n i1,i2 = a[i][0],a[(i+1)%n][0]\\n x1,y1 = a[i][2:]\\n x2,y2 = a[(i+1)%n][2:]\\n inner_prod = x1*x2 + y1*y2\\n inner_prod *= abs(inner_prod)\\n norm_prod = ((x1**2+y1**2)*(x2**2+y2**2))\\n b.append((i1,i2,inner_prod,norm_prod))\\n# find the nearest vector\\nbetter = lambda p1,p2: p1[2]*p2[3]>p2[2]*p1[3]\\nans = b[-1]\\nfor i in range(n):\\n if better(b[i],ans):\\n ans = b[i]\\nprint(ans[0],ans[1])\\n"}
{"id": "45", "input": "d, k, a, b, t = list(map(int, input().split()))\\n\\nt1 = d * b\\nt2 = d * a + ((d - 1) // k) * t\\nt3 = max(0, d - k) * b +", "gt": "min(k, d) * a\\ndd = d % k\\nd1 = d - dd\\nt4 = d1 * a + max(0, (d1 // k - 1) * t) + dd * b\\n\\nprint(min([t1, t2, t3, t4]))\\n"}
{"id": "46", "input": "n, k = map(int, input().split())\\ndiv = []\\ni = 1\\nn1 = n\\nwhile i * i <= n:\\n if n % i == 0:\\n div.append(i)\\n div.append(n // i)\\n i += 1\\ndiv.sort()\\nmx = -1\\nfor i in range(len(div)):\\n a = div[i] * k *", "gt": "(k + 1) // 2\\n if a <= n:\\n mx = div[i]\\nif mx == -1:\\n print(-1)\\nelse:\\n for i in range(k - 1):\\n print(mx * (i + 1), end= \" \")\\n print(n - mx * k * (k - 1) // 2)\\n\\n"}
{"id": "47", "input": "ct=0\\na, b = list(map(int, input().split(' ')))\\nx=[0]*5\\nfor i in", "gt": "range(1, b+1):\\n x[i%5]+=1\\nfor i in range(1, a+1):\\n ct+=x[(0-i)%5]\\nprint(ct)\\n"}
{"id": "48", "input": "N, X = list(map(int, input().split()))\\nA = [int(a) for a in input().split()]\\n\\ndp = [[0]*4 for _ in range(N+1)]\\n\\nfor i in range(1, N+1):\\n dp[i][0]", "gt": "= max(dp[i-1][0] + A[i-1], 0)\\n dp[i][1] = max(dp[i-1][1] + A[i-1] * X, dp[i][0])\\n dp[i][2] = max(dp[i-1][2] + A[i-1], dp[i][1])\\n dp[i][3] = max(dp[i-1][3], dp[i][2])\\n\\nprint(dp[N][3])\\n"}
{"id": "49", "input": "def main():\\n from math import sqrt\\n m, n, k = list(map(int, input().split()))\\n if n < m:\\n n, m = m, n\\n lo, hi = 1, k + 1\\n while lo + 1 < hi:\\n mid = (lo + hi) // 2\\n t = mid - 1\\n v = min(int(sqrt(t)), m)\\n tn, tm = (t - 1) // m, t", "gt": "// n\\n vv = [t // i for i in range(tm + 1, v + 1)]\\n if t // n * (n + m) + sum(vv) * 2 + max(min((tn - tm), len(vv)) * m, 0) - v * v - sum(\\n vv[:max(min(tn - tm, len(vv)), 0)]) < k:\\n lo = mid\\n else:\\n hi = mid\\n print(lo)\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "50", "input": "k = int(input())\\n\\nif k<=9:\\n print(k)\\nelse:\\n num_arr = [9*(i+1)* 10**i for i in range(11)]\\n\\n index = 0\\n\\n while True:\\n if k<=num_arr[index]:\\n break\\n else:\\n", "gt": "k -= num_arr[index]\\n index += 1\\n\\n digit = index+1\\n k += digit-1\\n\\n\\n num = k//digit\\n offset = k%digit\\n\\n string_num = str(10**(digit-1)+ num-1)\\n\\n print(string_num[offset])\\n\\n"}
{"id": "51", "input": "n, m, r = map(int, input().split())\\nS = list(map(int, input().split()))\\nB = list(map(int, input().split()))\\nx = min(S)\\ny", "gt": "= max(B)\\ncnt = r % x\\nact = r // x\\ncnt += act * y\\nprint(max(r, cnt))"}
{"id": "52", "input": "s = input()\\nt = 0\\nif len(s)%2==0:\\n n = (len(s)-1)//2+1\\nelse:\\n n = (len(s)-1)//2\\nfor i in range(n, len(s)-1):\\n", "gt": "a = i\\n b = len(s)-i-1\\n if s[:a+1]==s[b:]:\\n print('YES')\\n print(s[:a+1])\\n t = 1\\n break\\nif t==0:\\n print('NO')"}
{"id": "53", "input": "n = int(input())\\nres = set()\\nfor r in range(100):\\n a = 1\\n b = 2**(r + 1) - 3\\n c = -2 * n\\n d = b * b - 4 * a * c\\n if d < 0:\\n continue\\n le = 0\\n ri = d\\n while le < ri:\\n c = (le + ri) // 2\\n if c * c < d:\\n le", "gt": "= c + 1\\n else:\\n ri = c\\n if le * le == d:\\n if (-b - le) % 4 == 2 and -b - le > 0:\\n res.add((-b - le) // 2 * 2**r)\\n if (-b + le) % 4 == 2 and -b + le > 0:\\n res.add((-b + le) // 2 * 2**r)\\nfor i in sorted(list(res)):\\n print(i)\\nif not list(res):\\n print(-1)\\n"}
{"id": "54", "input": "from collections import Counter\\n\\nr = lambda: list(map(int, input().split()))\\n\\ndef main():\\n n, = r()\\n s = input()\\n cost = list(r())\\n\\n ans = 0\\n\\n cnt = Counter()\\n\\n for i in range(n // 2):\\n if s[i] == s[n - 1 - i]:\\n ans += min(cost[i], cost[n - 1 - i])\\n cnt[s[i]] += 1\\n total = sum(cnt.values())\\n if total > 0:\\n", "gt": "ch, occ = cnt.most_common(1)[0]\\n avail = []\\n if occ > total - occ:\\n for i in range(n // 2):\\n if s[i] != s[n - 1 - i] and s[i] != ch and s[n - 1 - i] != ch:\\n avail.append(min(cost[i], cost[n - 1 - i]))\\n avail.sort()\\n ans += sum(avail[:2 * occ - total])\\n\\n print(sum(cost) - ans)\\n\\nmain()\\n"}
{"id": "55", "input": "w,m=map(int,input().split())\\n\\nbb=True\\n\\nwhile(m>0 and bb):\\n x=m%w\\n if x==1:m-=1\\n", "gt": "elif x==w-1:m+=1\\n elif x!=0:bb=False\\n m//=w\\n \\nif bb:print(\"YES\")\\nelse:print(\"NO\")"}
{"id": "56", "input": "from collections import defaultdict\\n\\ndef solve(n, k):\\n as_bin = bin(n)[2:]\\n cnt = defaultdict(int)\\n cnt.update({i : 1 for i, b in enumerate(reversed(as_bin)) if b == '1'})\\n curr_len = len(cnt)\\n curr_pow = len(as_bin) - 1\\n\\n if curr_len > k:\\n return None\\n\\n while True:\\n new_len = curr_len + cnt[curr_pow]\\n if new_len > k:\\n break\\n cnt[curr_pow - 1] += 2 * cnt[curr_pow]\\n del cnt[curr_pow]\\n curr_pow", "gt": "-= 1\\n curr_len = new_len\\n\\n i = min(cnt.keys())\\n while curr_len < k:\\n cnt[i] -= 1\\n cnt[i - 1] += 2\\n curr_len += 1\\n i -= 1\\n\\n ans = []\\n for i in sorted(list(cnt.keys()), reverse=True):\\n ans.extend([i] * cnt[i])\\n return ans\\n\\nn, k = [int(v) for v in input().split()]\\nans = solve(n, k)\\n\\nif ans is None:\\n print('No')\\nelse:\\n print('Yes')\\n print(' '.join(str(c) for c in ans))\\n"}
{"id": "57", "input": "n, t = list(map(int,input().split()))\\ng = [[0.0] * i for i in range(1,n+1)]\\n\\n\\nfor _ in range(t):\\n g[0][0] += 1.0\\n for i in range(n):\\n for j in range(i+1):\\n spill = max(0, g[i][j] - 1.0)\\n g[i][j] -= spill\\n if i < n -", "gt": "1:\\n g[i + 1][j] += spill / 2\\n g[i + 1][j + 1] += spill / 2\\n if g[n-1][0] == 1.0:\\n break\\n\\ncnt = 0\\nfor i in range(n):\\n for j in range(i + 1):\\n if g[i][j] == 1.0:\\n cnt += 1\\nprint(cnt)\\n"}
{"id": "58", "input": "n = int(input())\\npoints = [[int(x) for x in input().split()] for _ in range(n)]\\nif n <= 1:\\n print(-1)\\n return\\ndx = [1e9, -1e9]\\ndy = [1e9, -1e9]\\nfor x, y in", "gt": "points:\\n dx[0] = min(dx[0], x)\\n dx[1] = max(dx[1], x)\\n dy[0] = min(dy[0], y)\\n dy[1] = max(dy[1], y)\\narea = (dx[1] - dx[0]) * (dy[1] - dy[0])\\nif area:\\n print(area)\\nelse:\\n print(-1)\\n"}
{"id": "59", "input": "'''input\\n6\\n4\\n2\\n'''\\n\\ndef list_input():\\n return list(map(int,input().split()))\\ndef map_input():\\n return map(int,input().split())\\ndef map_string():\\n return input().split()\\n \\ndef f(n,a,b,left,cnta = 4,cntb = 2):\\n if(cnta == 0 and cntb == 0): return 0\\n if(cnta < 0 or cntb < 0): return 100000000000000000000\\n if a", "gt": "<= left and cnta and b <= left and cntb:\\n return min(f(n,a,b,left-a,cnta-1,cntb),f(n,a,b,left-b,cnta,cntb-1))\\n if a <= left and cnta:\\n return f(n,a,b,left-a,cnta-1,cntb)\\n if b <= left and cntb:\\n return f(n,a,b,left-b,cnta,cntb-1)\\n return 1+min(f(n,a,b,n-a,cnta-1,cntb),f(n,a,b,n-b,cnta,cntb-1)) \\n\\nn = int(input())\\na = int(input())\\nb = int(input())\\nprint(f(n,a,b,0))"}
{"id": "60", "input": "n = int(input())\\na = list(map(int,input().split()))\\np = input()\\nm = 0\\nsuc = True\\nfor i in range(n-1):\\n m", "gt": "= max(m,a[i])\\n if p[i] == '0' and m>(i+1):\\n suc = False\\n break\\nif suc:\\n print('YES')\\nelse:\\n print('NO')\\n"}
{"id": "61", "input": "seat = input()\\ntime_to = {'a': 4, 'f': 1, 'b': 5, 'e': 2, 'c': 6, 'd': 3}\\ncol = seat[-1]\\nrow = int(seat[:-1])\\nrow -= 1\\n\\nblocks_to_serve =", "gt": "row // 4\\ntime = (6 * 2 + 4) * blocks_to_serve\\n\\nif row % 2 == 1:\\n time += 6 + 1\\n\\ntime += time_to[col]\\n\\nprint(time)\\n"}
{"id": "62", "input": "n, bx = list(map(int, input().split()))\\nx1 = list(map(int, input().split()))\\nx = 0\\nfor i in range(n):\\n x *= bx\\n x += x1[i]\\n\\nn, by = list(map(int, input().split()))\\ny1", "gt": "= list(map(int, input().split()))\\ny = 0\\nfor i in range(n):\\n y *= by\\n y += y1[i]\\n\\nif x == y:\\n print('=')\\nelif x < y:\\n print('<')\\nelse:\\n print('>')\\n"}
{"id": "63", "input": "from math import *\\nn=int(input())\\nif n==3:\\n li=list(map(int,input().split()))\\n ans=0\\n flag=0\\n for i in li:\\n ans^=i\\n if ans==0:\\n print(\"BitAryo\")\\n else:\\n print(\"BitLGM\")\\nelif n==2:\\n li=list(map(int,input().split()))\\n li.sort()\\n", "gt": "phi=(1+sqrt(5))/2\\n ch=[0]*(785)\\n for i in range(300):\\n a=floor(phi*i)\\n b=floor((phi**2)*i)\\n ch[a]=b\\n ch[b]=a\\n if ch[li[0]]==li[1]:\\n print(\"BitAryo\")\\n else:\\n print(\"BitLGM\")\\nelse:\\n li=int(input())\\n if li==0:\\n print(\"BitAryo\")\\n else:\\n print(\"BitLGM\")\\n"}
{"id": "64", "input": "n,k=map(int,input().split())\\nl=list(map(int,input().split()))\\npf=[]\\nneeded=[]\\nfor i in range(2,40000):\\n if k%i==0:\\n pf.append(i)\\n c=0\\n while k%i==0:\\n k//=i\\n c+=1\\n needed.append(c)\\nif k>1:\\n pf.append(k)\\n needed.append(1)\\npfl=len(pf)\\ncnt=[[0]*n for i in range(pfl)]\\nfor i in range(n):\\n for j in range(len(pf)):\\n c=0\\n while l[i]%pf[j]==0:\\n c+=1\\n l[i]//=pf[j]\\n cnt[j][i]=c\\nhave=[sum(i) for i in cnt]\\npos=n\\ndef ok():\\n for i in range(len(pf)):\\n if have[i]<needed[i]:\\n return False\\n return True\\nif not ok():\\n print(0)\\n", "gt": "quit()\\nfor i in range(n-1,0,-1):\\n for j in range(len(pf)):\\n have[j]-=cnt[j][i]\\n if not ok():\\n for j in range(len(pf)):\\n have[j]+=cnt[j][i]\\n break\\n pos=i\\nans=n-pos+1\\nfor x in range(n-1):\\n for j in range(len(pf)):\\n have[j]-=cnt[j][x]\\n if pos==(x+1):\\n for j in range(len(pf)):\\n have[j]+=cnt[j][pos]\\n pos+=1\\n while pos<n:\\n if ok():\\n break\\n else:\\n for i in range(len(pf)):\\n have[i]+=cnt[i][pos]\\n pos+=1\\n if ok():\\n ans+=n-pos+1\\n else:\\n break\\nprint(ans)"}
{"id": "65", "input": "alpha = [chr(ord('a')+i) for i in range(26)]\\nn,k = list(map(int,input().split()))\\ns = input()\\narr", "gt": "= [s.count(alpha[i]) for i in range(26)]\\n\\nprint('YES' if max(arr) <= k else 'NO')\\n"}
{"id": "66", "input": "n = int(input())\\nA = [int(x) for x in input().split()]\\nmn = min(A)\\n\\nI = [i", "gt": "for i in range(len(A)) if A[i] == mn]\\nmindiff = min(I[i]-I[i-1] for i in range(1,len(I)))\\nprint(mindiff)\\n"}
{"id": "67", "input": "from fractions import gcd\\n\\nt,w,b = map(int,input().split())\\nper =", "gt": "w*b//gcd(w,b)\\ncan = (t//per+1)*min(w,b)-1\\nif t%per<min(w,b):\\n can-=min(w,b)\\n can+=t%per+1\\ng = gcd(can,t)\\ncan//=g\\nt//=g\\nprint(str(can)+\"/\"+str(t))"}
{"id": "68", "input": "x, y, z = map(int, input().split())\\nif z == 0:\\n if x == y:\\n print('0')\\n elif x > y:\\n print('+')\\n", "gt": "else:\\n print('-')\\nelse:\\n if x > y + z:\\n print('+') \\n elif x + z < y:\\n print('-')\\n else:\\n print('?')"}
{"id": "69", "input": "# \\nimport collections, atexit, math, sys, bisect \\n\\nsys.setrecursionlimit(1000000)\\ndef getIntList():\\n return list(map(int, input().split())) \\n\\ntry :\\n #raise ModuleNotFoundError\\n import numpy\\n def dprint(*args, **kwargs):\\n print(*args, **kwargs, file=sys.stderr)\\n dprint('debug mode')\\nexcept Exception:\\n def dprint(*args, **kwargs):\\n pass\\n\\n\\n\\ninId = 0\\noutId = 0\\nif inId>0:\\n dprint('use input', inId)\\n sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\\nif outId>0:\\n dprint('use output', outId)\\n sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\\n atexit.register(lambda :sys.stdout.close()) #idle 中不会执行 atexit\\n \\nN, = getIntList()\\n#print(N)\\nS = input()\\n\\nX, Y = getIntList()\\n\\ndd = ( (0,1), (0,-1), (-1,0), (1,0))\\npp = 'UDLR'\\nzz = {}\\nfor i in range(4):\\n zz[ pp[i]] = dd[i]\\n\\n\\nif abs(X) + abs(Y) >N:\\n print(-1)\\n return\\n\\nif abs(X+Y-N)%2==1:\\n print(-1)\\n return\\n \\nfromLeft = [None for", "gt": "i in range(N)]\\nfromRight = fromLeft.copy()\\n\\nx0 = 0\\ny0 = 0\\nfor i in range(N):\\n x = S[i]\\n fromLeft[i] = (x0,y0)\\n g = zz[x]\\n x0+= g[0]\\n y0+= g[1]\\n\\nif x0==X and y0==Y:\\n print(0)\\n return\\n\\nx0 = 0\\ny0 = 0\\nfor i in range(N-1,-1,-1):\\n x = S[i]\\n fromRight[i] = (x0,y0)\\n g = zz[x]\\n x0+= g[0]\\n y0+= g[1]\\n\\n\\nup = N\\ndown = 0\\ndprint(fromLeft)\\ndprint(fromRight)\\nwhile down+1<up:\\n mid = (up+down)//2\\n dprint('mid', mid)\\n ok = False\\n for i in range(N-mid + 1):\\n tx = fromLeft[i][0] + fromRight[i+mid-1][0]\\n ty = fromLeft[i][1] + fromRight[i+mid-1][1]\\n gg = abs(X-tx) + abs(Y- ty)\\n if gg <= mid:\\n ok = True\\n break\\n if ok:\\n up = mid\\n else:\\n down = mid\\n \\nprint(up)\\n\\n"}
{"id": "70", "input": "t=int(input())\\nfor i in ' '*t:\\n n,x=map(int,input().split())\\n s=input()\\n L=[0]\\n for i in s:\\n if i=='0':L.append(L[-1]+1)\\n else:L.append(L[-1]-1)\\n L.pop(0)\\n k=L[-1]\\n c=0\\n if x==0:c+=1\\n if k>0:\\n for i in", "gt": "L:\\n if i%k==x%k and i<=x:c+=1\\n print(c)\\n elif k<0:\\n for i in L:\\n if i%k==x%k and i>=x:c+=1\\n print(c)\\n else:\\n for i in L:\\n if i==x:c=-1\\n print(c)"}
{"id": "71", "input": "s = input().split()\\nk = int(s[1])\\ns = s[0]\\nif s.count('0') < k:\\n if s.count('0') > 0:\\n print(len(s) - 1)\\n else:\\n print(len(s))\\n return\\nhave = 0\\nits = 0\\nfor", "gt": "i in range(len(s) - 1, -1, -1):\\n its += 1\\n if s[i] == '0':\\n have += 1\\n if have == k:\\n print(its - have)\\n return"}
{"id": "72", "input": "n, m, k, x, y = list(map(int, input().split()))\\n\\nans = [[0] * m for x in range(n)]\\n\\nonebig = (2*n-2)*m or m\\n\\noo = k // onebig\\n\\nfor i in range(n):\\n for j in range(m):\\n if i == 0 or i == n-1:\\n ans[i][j] += oo\\n k -=", "gt": "oo\\n else:\\n ans[i][j] += 2*oo\\n k -= 2*oo\\n\\nfrom itertools import chain\\n\\nfor i in chain(list(range(n)), list(range(n-2, 0, -1))):\\n if not k:\\n break\\n for j in range(m):\\n if not k:\\n break\\n ans[i][j] += 1\\n k -= 1\\n\\n_max = max(list(map(max, ans)))\\n_min = min(list(map(min, ans)))\\n_ans = ans[x-1][y-1]\\n\\n\\nprint(_max, _min, _ans)\\n"}
{"id": "73", "input": "turns = int(input())\\ns0 = input()\\ns1 = input()\\ns2 = input()\\n\\nd0 = dict()\\nd1 = dict()\\nd2 = dict()\\n\\nalphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\\nfor char in alphabet:\\n d0[char] = 0\\n d1[char] = 0\\n d2[char] = 0\\n\\nfor char in s0:\\n d0[char] += 1\\nfor char in s1:\\n d1[char] += 1\\nfor char in s2:\\n d2[char] += 1 \\n\\nm0 = max([d0[char] for char in alphabet])\\nm1 = max([d1[char] for char in alphabet])\\nm2 = max([d2[char] for char in alphabet])\\n\\nl0 = len(s0)\\nl1", "gt": "= len(s1)\\nl2 = len(s2)\\n\\nif turns == 1 and m0 == l0:\\n score0 = m0 - 1\\nelse:\\n score0 = min(l0,m0+turns)\\n\\nif turns == 1 and m1 == l1:\\n score1 = m1 - 1\\nelse:\\n score1 = min(l1,m1+turns)\\n\\nif turns == 1 and m2 == l2:\\n score2 = m2 - 1\\nelse:\\n score2 = min(l2,m2+turns)\\n \\nscores = [score0,score1,score2]\\nbestscore = max(scores)\\n\\nwinnerlist = [i for i in range(3) if scores[i] == bestscore]\\nif len(winnerlist) > 1:\\n print('Draw')\\nelse:\\n print(['Kuro','Shiro','Katie'][winnerlist[0]])"}
{"id": "74", "input": "read = lambda: map(int, input().split())\\nc, v0, v1, a, l = read()\\ncur = 0\\ncnt = 0\\nwhile cur <", "gt": "c:\\n cur = max(0, cur - l)\\n cur += min(v1, v0 + a * cnt)\\n cnt += 1\\nprint(cnt)"}
{"id": "75", "input": "import math\\n\\nn=int(input())\\n\\ndef prime(p):\\n if p == 1:\\n return False\\n fl=True\\n for i in range(2,math.ceil(p**0.5) + 1):\\n if p % i == 0:\\n fl=False\\n return fl\\n\\ndef sum_of_primes(k):\\n fl=True\\n for i in range((k // 2) + 1):\\n if prime(i) and prime(k-i):\\n fl=True\\n break\\n return fl\\n\\nif", "gt": "prime(n):\\n print(1)\\n print(n)\\nelse:\\n if prime(n-2):\\n print(2)\\n print(2 , n-2)\\n else:\\n l=1\\n for i in range(2, (n // 3) + 1):\\n if prime(i) and sum_of_primes(n - i):\\n l=i\\n break\\n print(3)\\n r=1\\n for k in range((n-l) // 2):\\n if prime(k) and prime(n-l-k):\\n r=k\\n break\\n print(l,r,n-l-r)\\n\\n \\n"}
{"id": "76", "input": "n, m = list(map(int, input().split()))\\np = []\\nans = 0\\nfor i in range(n):\\n s = input()\\n ans += s.count('*')\\n p.append(s)\\ndp = []\\nfor i in range(n):\\n dp.append([0] * m)\\nfor i in range(n):\\n col = p[i].count('*')\\n for t in range(m):\\n dp[i][t] = col\\nfor i in range(m):\\n col = 0\\n for t in", "gt": "range(n):\\n if p[t][i] == '*':\\n col += 1\\n for t in range(n):\\n dp[t][i] += col\\nf = False\\nfor i in range(n):\\n for t in range(m):\\n if dp[i][t] - int(p[i][t] == '*') == ans:\\n f = True\\n print('YES')\\n print(i + 1, t + 1)\\n break\\n if f:\\n break\\nif not f:\\n print('NO')\\n"}
{"id": "77", "input": "n, m, a, b = list(map(int,", "gt": "input().split()))\\n\\nk = n%m\\nprint(min(k*b, (m - k)*a))\\n"}
{"id": "78", "input": "n = int(input())\\na = list(map(int, input().split()))\\nres = 0\\nnew_a = []\\nfor i in range(n):\\n if a[i] % 2 == 0:\\n if a[i] > 0:\\n res +=", "gt": "a[i]\\n else:\\n new_a.append(a[i])\\na = new_a\\na.sort()\\nres += a[-1]\\na.pop()\\nwhile len(a) > 1:\\n if a[-1] + a[-2] > 0:\\n res += a[-1] + a[-2]\\n a.pop()\\n a.pop()\\n else:\\n break\\nprint(res)"}
{"id": "79", "input": "from math import factorial\\n\\n\\ndef lol(n):\\n if n == 1:\\n yield [0]\\n yield [1]\\n else:\\n for p in lol(n - 1):\\n p.append(0)\\n yield p\\n p[-1] = 1\\n yield p\\n p.pop()\\n\\n\\ndef sp(g1, g2, g3, f):\\n if g1 == 0:\\n if g2 == g3:\\n return 2\\n elif abs(g2 - g3) == 1:\\n return 1\\n else:\\n return 0\\n elif g2 == 0:\\n if g1 == g3:\\n return 2\\n elif abs(g1 - g3) == 1:\\n return 1\\n else:\\n return 0\\n elif g3 == 0:\\n if g2 == g1:\\n return 2\\n elif abs(g2 - g1) == 1:\\n return 1\\n else:\\n return 0\\n else:\\n if f == 1:\\n b = sp(g1, g2 - 1, g3, 2)\\n c = sp(g1, g2, g3 - 1, 3)\\n return b + c\\n elif f == 2:\\n a = sp(g1 - 1, g2, g3, 1)\\n c = sp(g1, g2, g3 - 1,", "gt": "3)\\n return a + c\\n elif f == 3:\\n a = sp(g1 - 1, g2, g3, 1)\\n b = sp(g1, g2 - 1, g3, 2)\\n return a + b\\n else:\\n a = sp(g1 - 1, g2, g3, 1)\\n b = sp(g1, g2 - 1, g3, 2)\\n c = sp(g1, g2, g3 - 1, 3)\\n return a + b + c\\n\\n\\nn, T = map(int, input().split())\\nS = []\\ncnt = 0\\nM = 10 ** 9 + 7\\nfor i in range(n):\\n S.append(list(map(int, input().split())))\\nfor p in lol(n):\\n d = 0\\n g1, g2, g3 = 0, 0, 0\\n for i in range(n):\\n if p[i]:\\n d += S[i][0]\\n if S[i][1] == 1:\\n g1 += 1\\n elif S[i][1] == 2:\\n g2 += 1\\n elif S[i][1] == 3:\\n g3 += 1\\n if d == T:\\n cnt += factorial(g1) * factorial(g2) * factorial(g3) * sp(g1, g2, g3, 0)\\n cnt %= M\\nprint(cnt)"}
{"id": "80", "input": "big = 100010\\ndef gen_mu():\\n mu = [1]*big\\n mu[0] = 0\\n P = [True]*big\\n P[0] = P[1] = False\\n for i in range(2,big):\\n if P[i]:\\n j = i\\n while j<big:\\n P[j] = False\\n mu[j] *= -1\\n j += i\\n j = i*i\\n while", "gt": "j<big:\\n mu[j] = 0\\n j += i*i\\n return mu\\n\\nm = int(input())\\nmu = gen_mu()\\n\\nMOD = 10**9+7\\ndef mod_inv(x):\\n return pow(x, MOD-2, MOD)\\n\\ns = 1\\nfor i in range(2,big):\\n # p is probabilty that i | a random number [1,m]\\n p = (m//i)*mod_inv(m)\\n s += (-mu[i])*(p)*mod_inv(1-p)\\nprint(s%MOD)"}
{"id": "81", "input": "from math import sqrt\\nfrom fractions import gcd\\nl, r, x, y = list(map(int, input().split()))\\nif y % x != 0:\\n print(0)\\n return\\nlo = (l + x - 1) // x\\nhi = r // x\\np = y // x\\ns = 0\\n\\nk1 = 1\\nwhile k1", "gt": "* k1 <= p:\\n k2 = p // k1\\n if lo <= k1 <= hi and lo <= k2 <= hi and gcd(k1, k2) == 1 and k1 * k2 == p:\\n s += 1 + (k1 != k2)\\n k1 += 1\\nprint(s)\\n"}
{"id": "82", "input": "from math import gcd\\na, b = list(map(int, input().split()))\\nif b < a:\\n a, b = b, a\\nif a == b:\\n print(0)\\n return\\nc = b - a\\ni = 1\\nans = a * b // gcd(a, b)\\n\\ndef get(x):\\n A = (a + x - 1) // x * x\\n B = A - a + b\\n return A * B // gcd(A, B), A\\n\\nr = 0\\nwhile i *", "gt": "i <= c:\\n if c % i == 0:\\n A, AA = get(i)\\n B, BB = get(c // i)\\n if A < ans:\\n ans = A\\n r = AA - a\\n if B < ans:\\n ans = B\\n r = BB - a\\n if A == ans:\\n r = min(r, AA - a)\\n if B == ans:\\n r = min(r, BB - a)\\n i += 1\\nprint(r)\\n"}
{"id": "83", "input": "n, k = list(map(int, input().split()))\\na = list(map(int, input().split()))\\ns = sum(a)\\nans = 0\\nc = k -", "gt": "0.5\\nwhile s / n < c:\\n s += k\\n n += 1\\n ans += 1\\nprint(ans)\\n"}
{"id": "84", "input": "n=int(input())\\nar=list(map(int,input().split()))\\npos=0\\nneg=0\\nfor a in ar:\\n if(a>0):pos+=1\\n", "gt": "elif a<0:neg+=1\\nif(pos*2>=n):\\n print(1)\\nelif neg*2>=n:\\n print(-1)\\nelse:\\n print(0)\\n"}
{"id": "85", "input": "from sys import stdin as cin\\nfrom sys import stdout as cout\\n\\ndef main():\\n n = int(cin.readline())\\n o = 0\\n for x in range(9, 0, -1):\\n if 10 ** x // 2 <= n:\\n ##print(x)\\n for", "gt": "i in range(9):\\n q = 10 ** x * (i + 1) // 2 - 1\\n if q <= n:\\n o += min(q, n - q)\\n print(o)\\n return\\n print(n * (n - 1) // 2)\\n\\nmain()\\n"}
{"id": "86", "input": "a,b=list(map(int,input().split()))\\nc,d=list(map(int,input().split()))\\ne=a*b\\nf=c*d\\nn=0\\nwhile e%2==0:e=e//2\\nwhile e%3==0:e=e//3\\nwhile f%2==0:f=f//2\\nwhile f%3==0:f=f//3\\nif e!=f:print(\"-1\")\\nelse:\\n i=0\\n j=0\\n e=a*b\\n f=c*d\\n while e%3==0:\\n e=e//3\\n i+=1\\n while f%3==0:\\n f=f//3\\n j+=1\\n k=i-j\\n if k>0:\\n for i in range(k):\\n n+=1\\n if a%3==0:a=a*2//3\\n else:b=b*2//3\\n else:\\n for i in range(0-k):\\n n+=1\\n if", "gt": "c%3==0:c=c*2//3\\n else:d=d*2//3\\n e=a*b\\n f=c*d\\n i=0\\n j=0\\n while e%2==0:\\n e=e//2\\n i+=1\\n while f%2==0:\\n f=f//2\\n j+=1\\n k=i-j\\n if k>0:\\n for i in range(k):\\n n+=1\\n if a%2==0:a=a//2\\n else:b=b//2\\n else:\\n for i in range(0-k):\\n n+=1\\n if c%2==0:c=c//2\\n else:d=d//2\\n print(n)\\n print(a,b)\\n print(c,d)\\n"}
{"id": "87", "input": "a, b, x, y = map(int, input().split())\\nif a >= x:\\n if b >= y:\\n print('Vasiliy')\\n else:\\n z = y - b\\n t = max(x - z, 0)\\n if a - z", "gt": "<= t:\\n print('Polycarp')\\n else:\\n print('Vasiliy')\\nelse:\\n if b <= y:\\n print('Polycarp')\\n else:\\n z = x - a\\n t = max(y - z, 0)\\n if b - z <= t:\\n print('Polycarp')\\n else:\\n print('Vasiliy')"}
{"id": "88", "input": "import sys\\narr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\na, b = list(map(int, input().split()))\\na -= 1\\nb -=", "gt": "1\\nctr = 1\\nfor i in range(arr[a] - 1):\\n b += 1\\n if (b == 7):\\n b = 0\\n ctr += 1\\nprint(ctr)\\n \\n"}
{"id": "89", "input": "def zero(strx):\\n k = []\\n str2 = list(strx)\\n for i in range(1, len(str2)):\\n str3 = str2[:]\\n str3[i] = '0'\\n k.append(''.join(str3))\\n return k\\na = []\\nfor", "gt": "i in range(1, 64):\\n a += zero('1'*i)\\n\\nct = 0\\nx, y = list(map(int, input().split(' ')))\\nfor i in a:\\n if x <= int(i, 2) <= y:\\n ct+=1\\nprint(ct)\\n"}
{"id": "90", "input": "n=int(input())\\nprint(max((i+1)*(n-i)for i", "gt": "in range(n)))\\n"}
{"id": "91", "input": "fact = [ 1 ]\\nfor i in range( 1, 20, 1 ):\\n fact.append( fact[ i - 1 ] * i )\\n\\nfrom collections import defaultdict\\n\\nN, K, S = list(map( int, input().split() ))\\nA = list( map( int, input().split() ) )\\n\\nldp = [ [ defaultdict( int ) for i in range( K + 1 ) ] for j in range( 2 ) ]\\nldp[ 0 ][ 0 ][ 0 ] = 1\\nfor i in range( N // 2 ):\\n for j in range( K + 1 ):\\n ldp[ ~ i & 1 ][ j ].clear()\\n for j in range( K + 1 ):\\n for key in ldp[ i & 1 ][ j ]:\\n ldp[ ~ i & 1 ][ j ][ key ] += ldp[ i & 1 ][ j ][ key ] # toranai\\n ldp[ ~ i & 1 ][ j ][ key + A[ i ] ] += ldp[ i & 1 ][ j ][ key ] # toru\\n if j + 1 <= K and A[ i ] <= 18:\\n ldp[ ~ i & 1 ][ j + 1 ][ key + fact[ A[ i ] ] ] += ldp[ i & 1 ][ j ][ key ] # kaijyou totte toru\\n\\nrdp = [ [ defaultdict( int ) for i in range( K + 1 ) ] for", "gt": "j in range( 2 ) ]\\nrdp[ 0 ][ 0 ][ 0 ] = 1\\nfor i in range( N - N // 2 ):\\n for j in range( K + 1 ):\\n rdp[ ~ i & 1 ][ j ].clear()\\n for j in range( K + 1 ):\\n for key in rdp[ i & 1 ][ j ]:\\n rdp[ ~ i & 1 ][ j ][ key ] += rdp[ i & 1 ][ j ][ key ]\\n rdp[ ~ i & 1 ][ j ][ key + A[ N // 2 + i ] ] += rdp[ i & 1 ][ j ][ key ]\\n if j + 1 <= K and A[ N // 2 + i ] <= 18:\\n rdp[ ~ i & 1 ][ j + 1 ][ key + fact[ A[ N // 2 + i ] ] ] += rdp[ i & 1 ][ j ][ key ]\\n\\nans = 0\\nfor i in range( K + 1 ):\\n for key in ldp[ N // 2 & 1 ][ i ]:\\n for j in range( 0, K - i + 1, 1 ):\\n ans += ldp[ N // 2 & 1 ][ i ][ key ] * rdp[ N - N // 2 & 1 ][ j ][ S - key ]\\n\\nprint( ans )\\n"}
{"id": "92", "input": "t = int(input())\\nfor _ in range(t):\\n n,k = list(map(int,input().split()))\\n a = list(map(int,input().split()))\\n for i in range(60, -1, -1):\\n m = k ** i\\n", "gt": "for j in range(n):\\n if a[j] >= m:\\n a[j] -= m\\n break\\n if all(i == 0 for i in a):\\n print('YES')\\n else:\\n print('NO')\\n"}
{"id": "93", "input": "a, b, c = map(int, input().split())\\nd = 1073741824\\np = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\\nt = [{} for i in range(101)]\\nans = {}\\nfor i in p:\\n j = i\\n m = 1\\n while j < 101:\\n for k in range(j, 101, j):\\n t[k][i] = m\\n j = j * i\\n m += 1\\ns = 0\\nfor i in range(1,", "gt": "a + 1):\\n for j in range(1, b + 1):\\n q ="}
{"id": "94", "input": "a, b, c, d = input(), input(), input(), input()\\na = a + b[::-1]\\nx = \"X\"\\nfor i in range(4):\\n if a[i] == x:\\n a = a[:i] + a[i + 1:]\\n break\\nc = c + d[::-1]\\n\\nfor", "gt": "i in range(4):\\n if c[i] == x:\\n c = c[:i] + c[i + 1:]\\n break\\nflag = False\\nfor i in range(4):\\n if a == c:\\n flag = True\\n c = c[1:] + c[0]\\nif flag:\\n print(\"YES\")\\nelse:\\n print(\"NO\")"}
{"id": "95", "input": "n=int(input())\\ns=input()\\npw=[1]\\nlast=1\\nfor i in range(70):\\n if (last>1e19):\\n break\\n pw.append(last*n)\\n last=last*n\\ndp=[1e19]*100\\nfor i in range(100):\\n dp[i]=[1e19]*100\\ndp[len(s)][0]=0\\nfor i in range(len(s),-1,-1):\\n for power in", "gt": "range(0,len(pw)):\\n cur=''\\n for j in range(i-1,-1,-1):\\n cur=s[j]+cur\\n if (int(cur)>n or int(cur)*pw[power]>1e19):\\n break;\\n if ((cur[0]!='0' or len(cur)==1) and int(cur)<n):\\n dp[j][power+1]=min(dp[j][power+1],dp[i][power]+int(cur)*pw[power])\\nprint(min(dp[0]))"}
{"id": "96", "input": "n = int(input())\\nL = list(map(int, input().split()))\\ni = 0\\na = 0\\nwhile i < n and L[i] > a:\\n a = L[i]\\n i += 1\\nwhile i <", "gt": "n and L[i] == a:\\n i += 1\\nwhile i < n and L[i] < a:\\n a = L[i]\\n i += 1\\nif i == n:\\n print(\"YES\")\\nelse:\\n print(\"NO\")\\n"}
{"id": "97", "input": "def gg(n,lol):\\n ans = 0\\n cur = 1\\n lol2 = lol\\n while(2*lol+1<=n):\\n cur *= 2\\n ans += cur\\n lol = 2*lol+1\\n lol2 *= 2\\n if lol2*2 <= n:\\n ans += n-lol2*2+1 \\n return ans\\n\\nn,k =", "gt": "list(map(int,input().split()))\\nlow = 1\\nhigh = n//2\\nres = 1\\nwhile low <= high:\\n mid = (low+high)//2\\n if gg(n,mid) >= k:\\n res = mid\\n low = mid+1\\n else:\\n high = mid-1\\nif n == k:\\n print(1)\\nelif(gg(n,res)-1-gg(n,res*2) >= k):\\n print(res*2+1)\\nelse:\\n print(res*2) \\n"}
{"id": "98", "input": "def INV(a, m) :\\n m0 = m\\n y = 0\\n x = 1 \\n if (m == 1) :\\n return 0 \\n while (a > 1) : \\n q = a // m \\n t = m \\n m = a % m\\n a = t\\n t = y \\n y = x - q * y\\n x = t\\n if (x < 0) :\\n x = x + m0 \\n return x\\ndef GCD(a, b):\\n if a == 0: return b\\n return GCD(b%a,a)\\ndef solve():\\n n, m, x, y, vx, vy = list(map(int, input().split()))\\n if vx == 0:\\n if x != 0 and x != n:\\n print(\"-1\")\\n return 0\\n ans = [0,0]\\n ans[0] = x\\n if vy < 0: ans[1] = 0\\n else: ans[1] = m\\n print(ans[0],ans[1])\\n return 0\\n if vy == 0:\\n if y != 0 and y != m:\\n print(\"-1\")\\n return 0\\n ans = [0,0]\\n ans[1] = y\\n if vx < 0: ans[0] = 0\\n else: ans[0] = n\\n print(ans[0],ans[1])\\n return 0\\n if", "gt": "vx == -1 and x == 0: vx = 1\\n if vx == 1 and x == n: vx = -1\\n if vy == -1 and y == 0: vy = 1\\n if vy == 1 and y == m: vy = -1\\n g = GCD(n,m)\\n m1 = n\\n m2 = m\\n a1 = -1 * vx * x % m1\\n a2 = -1 * vy * y % m2\\n if a1 % g != a2 % g:\\n print(\"-1\")\\n return 0\\n if GCD(m1//g,m2) == 1:\\n m1 = m1 // g\\n else:\\n m2 = m2 // g\\n m1_bar = INV(m2,m1)\\n m2_bar = INV(m1,m2)\\n k = (a1 * m1_bar*m2 + a2 * m2_bar*m1) % (m1*m2)\\n rowtouch = ((k+m-1)//m) % 2\\n coltouch = ((k+n-1)//n) % 2\\n ans = [0,0]\\n if vx == 1: ans[0] = 0\\n else: ans[0] = n\\n if vy == 1: ans[1] = 0\\n else: ans[1] = m\\n if rowtouch == 1: ans[1] = m-ans[1]\\n if coltouch == 1: ans[0] = n-ans[0]\\n print(ans[0],ans[1])\\n return 0\\nsolve()\\n"}
{"id": "99", "input": "a, b = [int(i) for i in input().split()]\\nc, d = [int(i) for i in input().split()]\\ne, f = [int(i) for i in input().split()]\\nif c+e <=a and max(d,f) <=b:\\n print(\"YES\")\\nelif c+e <=b and max(d,f) <=a:\\n print(\"YES\")\\nelif c+f", "gt": "<=a and max(d,e) <=b:\\n print(\"YES\")\\nelif c+f <=b and max(d,e) <=a:\\n print(\"YES\")\\nelif d+e <=a and max(c,f) <=b:\\n print(\"YES\")\\nelif d+e <=b and max(c,f) <=a:\\n print(\"YES\")\\nelif d+f <=a and max(c,e) <=b:\\n print(\"YES\")\\nelif d+f <=b and max(c,e) <=a:\\n print(\"YES\")\\nelse:\\n print(\"NO\")\\n"}
{"id": "100", "input": "def main():\\n (b1, q, l, m) = list(map(int, input().split()))\\n a = set(map(int, input().split()))\\n if abs(b1) > l:\\n print(0)\\n else:\\n if b1 == 0:\\n if 0 in a:\\n print(0)\\n else:\\n print(\"inf\")\\n elif q == 0:\\n if 0 not in a:\\n print(\"inf\")\\n elif b1 in a:\\n print(0)\\n else:\\n print(1)\\n elif q == 1:\\n if b1 in a:\\n", "gt": "print(0)\\n else:\\n print(\"inf\")\\n elif q == -1:\\n if (b1 in a) and ((-b1) in a):\\n print(0)\\n else:\\n print(\"inf\")\\n else:\\n ans = 0\\n b = b1\\n for i in range(100):\\n if b in a:\\n b *= q\\n if abs(b) > l:\\n break\\n continue\\n ans += 1\\n b *= q\\n if abs(b) > l:\\n break\\n print(ans)\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "101", "input": "3\\n\\ndef readln(): return list(map(int, input().split()))\\nimport sys\\ndef return:\\n print(-1)\\n return\\n\\nn, m = readln()\\nmon = [list(input()) for _ in range(n)]\\nhor = [i for i in range(n) if mon[i] != ['.'] * m]\\nrmon = list(zip(*mon))\\nver = [j for j in range(m) if rmon[j] != ('.',) * n]\\nmini = hor[0]\\nmaxi = hor[-1]\\nminj = ver[0]\\nmaxj = ver[-1]\\ncnt_in = len([1 for i in range(mini + 1, maxi) for j in range(minj + 1, maxj) if mon[i][j] == 'w'])\\ncnt_l = len([1 for i in range(mini + 1, maxi) if mon[i][minj] == 'w'])\\ncnt_r = len([1 for i in range(mini + 1, maxi) if mon[i][maxj] == 'w'])\\ncnt_d = len([1 for j in range(minj + 1, maxj) if mon[mini][j] == 'w'])\\ncnt_u = len([1 for j in range(minj + 1, maxj) if mon[maxi][j] == 'w'])\\nif cnt_in:\\n return\\nif maxi - mini < maxj - minj:\\n k = maxj - minj + 1\\n if maxi == mini and cnt_d:\\n if mini >= k - 1:\\n mini -= k - 1\\n elif maxi + k - 1 < n:\\n maxi += k - 1\\n else:\\n return\\n else:\\n if not", "gt": "cnt_d:\\n mini = max(0, maxi - k + 1)\\n if maxi - maxi + 1 != k and not cnt_u:\\n maxi = min(mini + k - 1, n - 1)\\n if maxi - mini + 1 != k:\\n return\\nelse:\\n k = maxi - mini + 1\\n if maxj == minj and cnt_l:\\n if minj >= k - 1:\\n minj -= k - 1\\n elif maxj + k - 1 < m:\\n maxj += k - 1\\n else:\\n return\\n else:\\n if not cnt_l:\\n minj = max(0, maxj - k + 1)\\n if maxj - minj + 1 != k and not cnt_r:\\n maxj = min(minj + k - 1, m - 1)\\n if maxj - minj + 1 != k:\\n return\\nfor i in range(mini, maxi + 1):\\n if mon[i][minj] == '.':\\n mon[i][minj] = '+'\\nfor i in range(mini, maxi + 1):\\n if mon[i][maxj] == '.':\\n mon[i][maxj] = '+'\\nfor j in range(minj, maxj + 1):\\n if mon[mini][j] == '.':\\n mon[mini][j] = '+'\\nfor j in range(minj, maxj + 1):\\n if mon[maxi][j] == '.':\\n mon[maxi][j] = '+'\\nprint('\\n'.join([''.join(row) for row in mon]))\\n"}
{"id": "102", "input": "def egcd(a, b):\\n x,y, u,v = 0,1, 1,0\\n while a != 0:\\n q, r = b//a, b%a\\n m, n = x-u*q, y-v*q\\n b,a, x,y, u,v = a,r, u,v, m,n\\n gcd = b\\n return gcd, x, y\\n\\n\\nimport math\\nn=int(input())\\na=int(input())\\nb=int(input())\\ngcd,x,y=(egcd(a,b))\\n\\n\\nstatus=0\\nif((n%gcd)!=0):\\n print(\"NO\")\\n #print(\"point1\")\\n\\nelse:\\n multiply=n/gcd\\n x1=int(multiply*x)\\n", "gt": "y1=int(multiply*y)\\n #print(\"gcd and soln to n\")\\n #print(gcd,x1,y1)\\n d1=b/gcd\\n d2=a/gcd\\n rangemin= int(math.ceil(-x1/d1))\\n rangemax= int(y1//d2)\\n #print(\"rangemin and rangemax\")\\n #print(rangemin,rangemax)\\n if(rangemin>rangemax):\\n print(\"NO\")\\n #print(\"point2\")\\n else:\\n #print(\"YES\")\\n #solx=x1+rangemin*d1\\n #soly=y1-rangemin*d2\\n m=rangemin\\n while(m<=rangemax):\\n solx=x1+m*d1\\n soly=y1-m*d2\\n if(solx>=0 and soly>=0):\\n print(\"YES\")\\n status=1\\n print(str(int(solx))+\" \"+str(int(soly)))\\n break\\n m=m+1\\n\\n if(status==0):\\n print(\"NO\")\\n #print(\"point3\")\\n \\n \\n"}
{"id": "103", "input": "n = int(input())\\nif n == 0:\\n print('zero')\\nelif n == 1:\\n print('one')\\nelif n == 2:\\n print('two')\\nelif n == 3:\\n print('three')\\nelif n == 4:\\n print('four')\\nelif n == 5:\\n print('five')\\nelif n == 6:\\n print('six')\\nelif n == 7:\\n print('seven')\\nelif n == 8:\\n print('eight')\\nelif n == 9:\\n print('nine')\\nelif n == 10:\\n print('ten')\\nelif n == 11:\\n print('eleven')\\nelif n == 12:\\n print('twelve')\\nelif n == 13:\\n print('thirteen')\\nelif n == 14:\\n print('fourteen')\\nelif n == 15:\\n print('fifteen')\\nelif n == 16:\\n print('sixteen')\\nelif n == 17:\\n print('seventeen')\\nelif n == 18:\\n print('eighteen')\\nelif n == 19:\\n print('nineteen')\\nelse:\\n if n // 10 == 2:\\n res = 'twenty'\\n elif n // 10 == 3:\\n res = 'thirty'\\n elif n // 10 == 4:\\n res = 'forty'\\n elif n // 10 == 5:\\n res =", "gt": "'fifty'\\n elif n // 10 == 6:\\n res = 'sixty'\\n elif n // 10 == 7:\\n res = 'seventy'\\n elif n // 10 == 8:\\n res = 'eighty'\\n elif n // 10 == 9:\\n res = 'ninety'\\n\\n if n % 10 == 1:\\n res += '-one'\\n elif n % 10 == 2:\\n res += '-two'\\n elif n % 10 == 3:\\n res += '-three'\\n elif n % 10 == 4:\\n res += '-four'\\n elif n % 10 == 5:\\n res += '-five'\\n elif n % 10 == 6:\\n res += '-six'\\n elif n % 10 == 7:\\n res += '-seven'\\n elif n % 10 == 8:\\n res += '-eight'\\n elif n % 10 == 9:\\n res += '-nine'\\n\\n print(res)"}
{"id": "104", "input": "n = int(input())\\na = [0] + list(map(int, input().split())) + [1001]\\nmx = 1\\np = 1\\nfor i in range(1, n + 2):\\n if", "gt": "a[i] == a[i - 1] + 1:\\n p += 1\\n mx = max(p, mx)\\n else:\\n p = 1\\nprint(max(0, mx - 2))"}
{"id": "105", "input": "def main():\\n n = int(input())\\n a = list(int(x) for x in input().split())\\n s = sum(a)\\n t =", "gt": "0\\n for i in range(n):\\n t += a[i]\\n if 2 * t >= s:\\n print(i + 1)\\n return\\n\\nmain()\\n"}
{"id": "106", "input": "n=int(input())\\ngraph=[{},{},{}]\\nfor i in range(n):\\n for j in range(n):\\n graph[0][(i,j)]=[(k,j) for k in range(n)]+[(i,k) for k in range(n)]\\n graph[0][(i,j)].remove((i,j))\\n graph[0][(i,j)].remove((i,j))\\n graph[1][(i,j)]=[]\\n for k in range(n):\\n for l in range(n):\\n if abs(k-i)==abs(l-j)!=0:\\n graph[1][(i,j)].append((k,l))\\n graph[2][(i,j)]=[]\\n for k in range(n):\\n for l in range(n):\\n if {abs(k-i),abs(l-j)}=={1,2}:\\n graph[2][(i,j)].append((k,l)) \\n\\ndists=[[{},{},{}],[{},{},{}],[{},{},{}]]\\nfor i in range(n):\\n for j in range(n):\\n for k in range(3):\\n dists[k][k][(i,j,i,j)]=0\\nfor i in range(n):\\n for", "gt": "j in range(n):\\n for k in range(3):\\n layers=[[(i,j,k,0)],[],[],[],[]]\\n for l in range(4):\\n for guy in layers[l]:\\n for m in range(3):\\n if m!=guy[2]:\\n if (i,j,guy[0],guy[1]) not in dists[k][m]:\\n layers[l+1].append((guy[0],guy[1],m,guy[3]+1))\\n dists[k][m][(i,j,guy[0],guy[1])]=1000*(l+1)+guy[3]+1\\n for boi in graph[guy[2]][(guy[0],guy[1])]:\\n if (i,j,boi[0],boi[1]) not in dists[k][guy[2]]:\\n layers[l+1].append((boi[0],boi[1],guy[2],guy[3]))\\n dists[k][guy[2]][(i,j,boi[0],boi[1])]=1000*(l+1)+guy[3]\\n elif 1000*(l+1)+guy[3]<dists[k][guy[2]][(i,j,boi[0],boi[1])]:\\n layers[l+1].append((boi[0],boi[1],guy[2],guy[3]))\\n dists[k][guy[2]][(i,j,boi[0],boi[1])]=1000*(l+1)+guy[3]\\nlocs=[None]*(n**2)\\nfor i in range(n):\\n a=list(map(int,input().split()))\\n for j in range(n):\\n locs[a[j]-1]=(i,j)\\nbest=(0,0,0)\\nfor i in range(n**2-1):\\n tup=(locs[i][0],locs[i][1],locs[i+1][0],locs[i+1][1])\\n new0=min(best[0]+dists[0][0][tup],best[1]+dists[1][0][tup],best[2]+dists[2][0][tup])\\n new1=min(best[0]+dists[0][1][tup],best[1]+dists[1][1][tup],best[2]+dists[2][1][tup])\\n new2=min(best[0]+dists[0][2][tup],best[1]+dists[1][2][tup],best[2]+dists[2][2][tup])\\n best=(new0,new1,new2)\\na=min(best)\\nprint(a//1000,a%1000)"}
{"id": "107", "input": "n, m, k = map(int, input().split())\\na, b = map(int, input().split())\\na -= 1\\nb -= 1\\ndef p(x):\\n return x // (m * k)\\ndef e(x):\\n return (x - p(x) * m * k) // k\\ndef lift(x):\\n return min(5", "gt": "* x, 10 + x)\\n \\nif p(a) == p(b):\\n dif = abs(e(a) - e(b))\\n print(lift(dif))\\nelse:\\n print(lift(e(a)) + 15 * min((p(a) - p(b) + n) % n, (p(b) - p(a) + n) % n) + lift(e(b)))"}
{"id": "108", "input": "s = input()\\ni = 0\\nwhile i < len(s) and s[i] == '0':\\n i += 1\\ncnt = 0\\nwhile", "gt": "i < len(s):\\n if s[i] == '0':\\n cnt += 1\\n i += 1\\n\\nif cnt >= 6:\\n print('yes')\\nelse:\\n print('no')\\n"}
{"id": "109", "input": "s = list(input())\\ntarget = 'abcdefghijklmnopqrstuvwxyz'\\nind_t = 0\\nind_s = 0\\nwhile ind_s < len(s) and ind_t < 26:\\n if ord(s[ind_s]) <=", "gt": "ord(target[ind_t]):\\n s[ind_s] = target[ind_t]\\n ind_t += 1\\n ind_s += 1\\n else:\\n ind_s += 1\\nif ind_t == 26:\\n print(''.join(s))\\nelse:\\n print(-1)"}
{"id": "110", "input": "import heapq as hq\\nfrom queue import PriorityQueue\\n\\nimport math\\nn,m,r, k= input().split()\\nN = int(n)\\nM = int(m)\\nR = int(r)\\nK = int(k)\\n\\nq = PriorityQueue()\\n\\n\\n\\nfor i in range(1,math.floor((N+1)/2) + 1):\\n maxi = min(min(i,N-i+1),min(R,N-R+1)) * min(min(R,M-R+1),math.ceil(M/2))\\n num = M - (2 * min(min(R,M-R+1),math.ceil(M/2))-2)\\n mult = 2\\n if(i > math.floor(N/2)):\\n mult = 1\\n q.put((-maxi,num * mult,i))\\n #print(str(maxi) + \" \" + str(num) + \" \" + str(mult))\\n\\n\\nans = 0\\nwhile(K > 0):\\n pop = q.get()\\n #print(pop)\\n a = -1 * pop[0]\\n b = pop[1]\\n c = pop[2]\\n d = min(min(c,N-c+1),min(R,N-R+1))\\n if(d !=", "gt": "a):\\n # if(q.)\\n # if(q.get(-(a - d)) != )\\n mult = 2\\n if (c > N / 2):\\n mult = 1\\n q.put((-(a - d),2*mult,c))\\n ans += a * min(b,K)\\n K -= b;\\n\\ntot = (N-R+1) * (M-R+1)\\n#print(\"ANS = \" + str(ans))\\n#print(\"FINANS = \" + str(ans/tot))\\nprint(str(ans/tot))\\n\\n\\n'''\\n\\nd = []\\nfor i in range(0,N):\\n d.append([])\\n for j in range(0,M):\\n d[i].append(0)\\n\\ntot = 0\\nfor i in range(0,N-R+1):\\n for j in range(0,M-R+1):\\n for k in range(i,i+R):\\n for l in range(j,j+R):\\n d[k][l] += 1\\n tot += 1\\n\\n\\nprint(N-R+1)*(M-R+1) * (R*R)\\nprint(tot)\\nprint()\\nfor i in d:\\n print(i)\\n\\n'''\\n"}
{"id": "111", "input": "n = int(input())\\nA = list(map(int, input().split()))\\nif n == 1:\\n if A[0] >= 0:\\n print(A[0])\\n else:\\n print(-A[0]-1)\\n return\\nfor i in range(n):\\n if A[i] < 0:\\n pass\\n else:\\n A[i]", "gt": "= -A[i]-1\\nif n % 2 == 0:\\n print(*A)\\n return\\nmim = 0\\nindmim = 0\\nfor i in range(n):\\n if A[i] < mim:\\n mim = A[i]\\n indmim = i\\nA[indmim] = -A[indmim]-1\\nprint(*A)\\n"}
{"id": "112", "input": "import sys\\nimport math\\n\\ndef factorization(n):\\n res = []\\n limit = math.ceil(math.sqrt(n))\\n p = 2\\n cnt = 0\\n\\n while n % p == 0:\\n cnt += 1\\n n //= p\\n\\n if cnt > 0:\\n res.append((p, cnt))\\n\\n cnt = 0\\n for p in range(3, limit + 1, 2):\\n if n % p == 0:\\n while n % p == 0:\\n cnt += 1\\n n //= p\\n\\n res.append((p, cnt))\\n cnt = 0\\n\\n if n > 1:\\n res.append((n, 1))\\n\\n return res\\n\\ndef divisor(n):\\n res = set()\\n\\n factor =", "gt": "factorization(n)\\n\\n for p, c in factor:\\n if res == set():\\n for i in range(c + 1):\\n res.add(p ** i)\\n else:\\n t = set()\\n for i in range(1, c + 1):\\n for m in res:\\n t.add(m * p**i)\\n res = res | t\\n\\n res = list(sorted(res))\\n return res\\n\\nn, k = map(int, input().split())\\n\\n# print(factorization(n), file=sys.stderr)\\n# print(divisor(n), file=sys.stderr)\\n\\nn_div = divisor(n)\\n\\nif n == 1:\\n if k == 1:\\n ans = 1\\n else:\\n ans = -1\\nelif k > len(n_div):\\n ans = -1\\nelse:\\n ans = n_div[k - 1]\\n\\nprint(ans)"}
{"id": "113", "input": "n = int(input())\\na = sorted([list(map(int, input().split())) for i in range(n)])\\n\\nimport itertools\\nfor x in range(1,10**n):\\n good = False\\n s = str(x)\\n", "gt": "for p in itertools.permutations(a, len(s)):\\n good |= all([int(s[i]) in v for i, v in enumerate(p)])\\n if not good:\\n print(x-1)\\n return\\n \\nprint((10**n)-1)"}
{"id": "114", "input": "def main():\\n n, k = map(int, input().split())\\n num_2 = 0\\n num_5 = 0\\n x = n\\n while (x % 2 == 0):\\n num_2 += 1\\n x //= 2\\n \\n while (x", "gt": "% 5 == 0):\\n num_5 += 1\\n x //= 5\\n num_2 = k - min(num_2, k)\\n num_5 = k - min(num_5, k)\\n print(n * 5 ** num_5 * 2 ** num_2)\\n\\n\\nmain()"}
{"id": "115", "input": "n, m = map(int, input().split())\\nA = [list(map(int, input().split())) for _ in range(n)]\\nB = [[0] * m for _ in range(n)]\\nans = []\\nfor i in range(n - 1):\\n for j in range(m - 1):\\n if A[i][j] == 1 and A[i + 1][j] == 1 and A[i][j + 1]", "gt": "== 1 and A[i + 1][j + 1] == 1:\\n B[i][j] = 1\\n B[i + 1][j] = 1\\n B[i][j + 1] = 1\\n B[i + 1][j + 1] = 1\\n ans.append([i + 1, j + 1])\\nif A == B:\\n print(len(ans))\\n for a, b in ans:\\n print(a, b)\\nelse:\\n print(-1)"}
{"id": "116", "input": "r, s, p = list(map(int, input().split()))\\ndp = [[[0] * (p+1) for _ in range(s+1)] for _ in range(r+1)]\\ndp[r][s][p] = 1\\ndef nCk(n, k):\\n if n <= k:\\n return 1\\n res = 1\\n for i in range(k):\\n res *= n-i\\n for i in range(k):\\n res //= (i+1)\\n return res\\n\\nC = [nCk(i, 2) for i in range(r+s+p+1)]\\nfor ri in range(r, -1, -1):\\n for si in range(s, -1, -1):\\n for pi in range(p, -1, -1):\\n t = ri *", "gt": "si + si * pi + pi * ri\\n if t == 0: continue\\n if ri > 0:\\n dp[ri-1][si][pi] += dp[ri][si][pi] * ri * pi / t\\n if si > 0:\\n dp[ri][si-1][pi] += dp[ri][si][pi] * ri * si / t\\n if pi > 0:\\n dp[ri][si][pi-1] += dp[ri][si][pi] * si * pi / t\\n \\n \\nr_sum = sum([dp[ri][0][0] for ri in range(r+1)])\\ns_sum = sum([dp[0][si][0] for si in range(s+1)])\\np_sum = sum([dp[0][0][pi] for pi in range(p+1)])\\nprint(r_sum, s_sum, p_sum)\\n"}
{"id": "117", "input": "read = lambda: list(map(int, input().split()))\\nl1, r1, l2, r2, k = read()\\nR = min(r1, r2)\\nL = max(l1, l2)\\nans", "gt": "= max(R - L + 1, 0)\\nif L <= k <= R: ans = max(ans - 1, 0)\\nprint(ans)\\n"}
{"id": "118", "input": "#写経\\n#https://atcoder.jp/contests/abc168/submissions/14421546\\nimport sys\\nsys.setrecursionlimit(10**9)\\ninput = sys.stdin.readline\\nfrom bisect import bisect_left, bisect_right\\nINF = 10 **18\\n\\ndef resolve():\\n n, m = map(int, input().split())\\n a = [list(map(int, input().split())) for i in range(n)]\\n b = [list(map(int, input().split())) for i in range(m)]\\n \\n X = {-INF, INF}\\n Y = {-INF, INF}\\n for i in a:\\n Y.add(i[2])\\n for i in b:\\n X.add(i[0])\\n \\n X = list(sorted(X))\\n Y = list(sorted(Y))\\n n = len(X) - 1\\n m = len(Y) - 1\\n wallx = [[False] * m for i in range(n)]\\n wally = [[False] * m for i in range(n)]\\n \\n for x1, x2, y1 in a:\\n x1 = bisect_left(X, x1)\\n y1 = bisect_left(Y, y1)\\n x2 = bisect_right(X, x2) - 1\\n for i in range(x1, x2):\\n wally[i][y1] = True\\n \\n for x1, y1, y2 in b:\\n x1 = bisect_left(X, x1)\\n y1 = bisect_left(Y, y1)\\n y2 = bisect_right(Y, y2) - 1\\n for i in range(y1, y2):\\n wallx[x1][i] = True\\n \\n cow", "gt": "= [[False] * m for i in range(n)]\\n cx = bisect_right(X, 0) - 1\\n cy = bisect_right(Y, 0) - 1\\n cow[cx][cy] = True\\n q = [(cx, cy)]\\n ans = 0\\n \\n while q:\\n x, y = q.pop()\\n if not x or not y:\\n print(\"INF\")\\n return\\n ans += (X[x + 1] - X[x]) * (Y[y + 1] - Y[y])\\n if x and not wallx[x][y] and not cow[x - 1][y]:\\n cow[x - 1][y] = True\\n q.append((x - 1, y))\\n if y and not wally[x][y] and not cow[x][y - 1]:\\n cow[x][y - 1] = True\\n q.append((x, y - 1))\\n if x + 1 < n and not wallx[x + 1][y] and not cow[x + 1][y]:\\n cow[x + 1][y] = True\\n q.append((x + 1, y))\\n if y + 1 < m and not wally[x][y + 1] and not cow[x][y + 1]:\\n cow[x][y + 1] = True\\n q.append((x, y + 1)) \\n print(ans)\\nresolve()"}
{"id": "119", "input": "t, s, x = list(map(int, input().split()))\\nf = False\\nif x - 1 > t and (x - 1 - t) % s", "gt": "== 0:\\n f = True\\nif x >= t and (x - t) % s == 0:\\n f = True\\nif f:\\n print('YES')\\nelse:\\n print('NO')\\n"}
{"id": "120", "input": "n = int(input())\\na = []\\nfor i in range(1, n + 1):\\n l, r = list(map(int, input().split()))\\n a.append([l, -r, i])\\na.sort()\\nhh = a[0][1]\\nwahh", "gt": "= max(-1, a[0][2])\\nfor i in range(1, n):\\n if a[i][1] >= hh:\\n print(a[i][2], wahh)\\n return\\n else:\\n hh = a[i][1]\\n wahh = a[i][2]\\nprint(-1, -1)\\n"}
{"id": "121", "input": "\\nimport sys\\n#sys.stdin=open(\"data.txt\")\\ninput=sys.stdin.readline\\n\\nn=int(input())\\nif n%4: print(\"===\")\\nelse:\\n t=input().strip()\\n a=[n//4]*4\\n for i in t:\\n if i=='A': a[0]-=1\\n elif i=='C': a[1]-=1\\n elif i=='G': a[2]-=1\\n elif i=='T': a[3]-=1\\n if min(a)<0: print(\"===\")\\n else:\\n", "gt": "out=[]\\n for i in t:\\n if i=='?':\\n if a[0]:\\n out.append('A')\\n a[0]-=1\\n elif a[1]:\\n out.append('C')\\n a[1]-=1\\n elif a[2]:\\n out.append('G')\\n a[2]-=1\\n elif a[3]:\\n out.append('T')\\n a[3]-=1\\n else: out.append(i)\\n print(\"\".join(out))\\n"}
{"id": "122", "input": "def chk(l):\\n for i in range(4):\\n for j in range(2):\\n if l[i][j]==l[i][j+1]==l[i][j+2]=='x':\\n return True\\n for i in range(2):\\n for j in range(4):\\n if l[i][j]==l[i+1][j]==l[i+2][j]=='x':\\n return True\\n for i in range(2):\\n for j in range(2):\\n if l[i][j]==l[i+1][j+1]==l[i+2][j+2]=='x':\\n return True\\n", "gt": "for i in range(2):\\n for j in range(2, 4):\\n if l[i][j]==l[i+1][j-1]==l[i+2][j-2]=='x':\\n return True\\n return False\\na = [list(input()), list(input()), list(input()), list(input())]\\nfor i in range(4):\\n for j in range(4):\\n if a[i][j] != '.':\\n continue\\n a[i][j]='x'\\n if chk(a):\\n print(\"YES\"); return\\n a[i][j]='.'\\nprint(\"NO\")\\n"}
{"id": "123", "input": "def solve(n,a):\\n tot=0\\n for i in range(n):\\n tot+=a[i]\\n diffs = [] #alla suffix - prefix diffs[i]=prefix-suffix om delas innan element i\\n diffs.append(-tot)\\n for i in range(n):\\n tot-=2*a[i]\\n diffs.append(-tot)\\n if tot==0:\\n return (\"YES\")\\n for i in range(n):\\n diffmake=2*a[i]\\n j=binary(diffs,diffmake)\\n", "gt": "if j>i and j!=-1:\\n return (\"YES\")\\n j=binary(diffs,-diffmake)\\n if i>=j and j!=-1:\\n return (\"YES\")\\n return (\"NO\")\\n\\n\\ndef binary(a,value):\\n hi=len(a)\\n lo=-1\\n while (lo+1<hi):\\n mi=(lo+hi)//2\\n if a[mi]==value:\\n return mi\\n if a[mi]<value:\\n lo=mi\\n else:\\n hi=mi\\n return -1\\n\\n\\nn=int(input())\\na = input().split()\\nfor i in range (n):\\n a[i]=int(a[i])\\nprint(solve(n,a))\\n"}
{"id": "124", "input": "import sys\\n\\nn, k = list(map(int, input().split()))\\na = [int(x) for x in input().split()]\\nb = [int(x) for x in input().split()]\\n\\nb.sort(reverse=True)\\n\\nres = []\\ncur_b", "gt": "= 0\\nfor a_i in a:\\n if a_i != 0:\\n res.append(a_i)\\n else:\\n res.append(b[cur_b])\\n cur_b += 1\\n\\nif res != list(sorted(res)):\\n print(\"Yes\")\\nelse:\\n print(\"No\")\\n"}
{"id": "125", "input": "x,y,z = list(map(int,input().split()))\\na,b,c = list(map(int,input().split()))\\nif a < x:\\n print(\"NO\")\\n return\\nx -= a\\ny += x\\nif", "gt": "b < y:\\n print(\"NO\")\\n return\\ny -= b\\nz += y\\nif c < z:\\n print(\"NO\")\\n return\\nprint(\"YES\") \\n"}
{"id": "126", "input": "lanes = []\\n\\nfor i in range(4):\\n lanes.append(list(map(int, input().split())))\\n\\nlanes.extend(lanes)\\n\\nfor i in range(4):\\n ln = lanes[i]\\n if (ln[3] and (ln[0] or ln[1] or ln[2])) or", "gt": "\\\\n (ln[0] and lanes[i + 3][3]) or \\\\n (ln[1] and lanes[i + 2][3]) or \\\\n (ln[2] and lanes[i + 1][3]):\\n print('YES')\\n break\\nelse:\\n print('NO')"}
{"id": "127", "input": "# A\\n\\ninput()\\nl = list(map(int, list(input())))\\n\\nif (1 in l or 4 in l or 7 in l or 0 in l) and (1 in l or 2 in l or 3 in", "gt": "l) and (3 in l or 6 in l or 9 in l or 0 in l) and (7 in l or 0 in l or 9 in l):\\n print(\"YES\")\\nelse:\\n print(\"NO\")\\n"}
{"id": "128", "input": "n, f = list(map(int, input().split(' ')))\\nres = 0\\nwow = []\\nfor a0 in range(n):\\n k, l = list(map(int, input().split(' ')))\\n res", "gt": "+= min(k, l)\\n wow.append(min(2*k, l) - min(k, l))\\nwow = sorted(wow)\\ni = len(wow)-1\\nfor a0 in range(f):\\n res += wow[i]\\n i -= 1\\nprint(res)\\n"}
{"id": "129", "input": "# You lost the game.\\nn,k = map(int, input().split())\\nr =", "gt": "0\\nfor i in range(min(k,n//2)):\\n r += (n-2*i-1) + (n-2*i-2)\\nprint(r)"}
{"id": "130", "input": "n, m, k, l = map(int, input().split())\\ncnt = (k + l +", "gt": "m - 1) // m\\nif cnt * m > n:\\n print(-1)\\nelse:\\n print(cnt)"}
{"id": "131", "input": "h, w = map(int, input().split())\\nx0, y0, x1, y1, c = 1000, 1000, -1, -1, 0\\nfor i in range(h):\\n row = str(input())\\n for j in range(w):\\n if row[j] == 'B':\\n x0, y0, x1, y1, c =", "gt": "min(x0, i), min(y0, j), max(x1, i), max(y1, j), c + 1\\nln = max(x1 - x0 + 1, y1 - y0 + 1)\\nif ln > min(h, w):\\n print(-1)\\nelif x1 == -1:\\n print(1)\\nelse:\\n print(ln * ln - c)"}
{"id": "132", "input": "n = int(input())\\na = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\n\\nc", "gt": "= sum(a)\\nd = sum(b)\\n\\nif c >= d:\\n print('Yes')\\nelse:\\n print('No')"}
{"id": "133", "input": "n = int(input())\\na = list(map(int, input().split()))\\nmn = 360\\nfor i in range(n):\\n x = 0\\n for", "gt": "j in range(i, n):\\n x += a[j]\\n mn = min(mn, abs(x - (360 - x)))\\nprint(mn)"}
{"id": "134", "input": "# Contest: Codeforces Round #593 (Div. 2) (https://codeforces.com/contest/1236)\\n# Problem: B: Alice and the List of Presents (https://codeforces.com/contest/1236/problem/B)\\n\\ndef rint():\\n return int(input())\\n\\n\\ndef", "gt": "rints():\\n return list(map(int, input().split()))\\n\\n\\nM = 10**9 + 7\\nn, m = rints()\\nprint(pow((pow(2, m, M) + M - 1) % M, n, M))\\n"}
{"id": "135", "input": "n = int(input())\\nif n % 4 == 0:\\n temp = n // 4\\n m = temp * 3\\n k = temp * 5\\nelif n % 2 == 0:\\n n //= 2\\n", "gt": "m = n**2 // 2\\n k = m + 1\\n m *= 2\\n k *= 2\\nelse:\\n m = n**2 // 2\\n k = m + 1\\nif 3 > n:\\n print(\"-1\")\\nelse:\\n print(m,k)\\n"}
{"id": "136", "input": "def main():\\n n, k = map(int, input().split())\\n for i in range(1, k", "gt": "+ 1):\\n if (n % i != (i - 1)):\\n print(\"No\")\\n return\\n print(\"Yes\")\\n\\nmain()"}
{"id": "137", "input": "a = input()\\nb = input()\\nn, m = len(a), len(b)\\nif n > m: b = '0' * (n - m) + b\\nelse: a = '0' * (m - n)", "gt": "+ a\\ni = 0\\nwhile i < max(n, m) and a[i] == b[i]:\\n i += 1\\nprint('=' if i == max(n, m) else '<' if int(a[i]) < int(b[i]) else '>')\\n"}
{"id": "138", "input": "n,p=list(map(int,input().split()))\\nnums=[0]+list(map(int,input().split()))\\nmod=10**9+7\\n\\nf=[[[[0]*2 for _ in range(2)] for _ in range(2)] for _ in range(n+1)]\\n\\n_2=[0]*(n+1)\\n_2[0]=1\\nfor i in range(1,n+1):\\n _2[i]=(_2[i-1]<<1)%mod\\n \\nf[0][0][0][0]=1\\nif nums[1]!=0:\\n f[1][1][0][1]+=1\\nif nums[1]!=1:\\n f[1][1][1][0]+=1\\n\\nfor i in range(2,n+1):\\n for j in range(2):\\n for ob", "gt": "in range(2):\\n for ow in range(2):\\n qwq=f[i-1][j][ob][ow]\\n if nums[i]!=0:\\n if ob:\\n f[i][j][ob][ow]=(f[i][j][ob][ow]+qwq*_2[i-2])%mod\\n f[i][j^1][ob][ow|1]=(f[i][j^1][ob][ow|1]+qwq*_2[i-2])%mod\\n else:\\n f[i][j^1][ob][ow|1]=(f[i][j^1][ob][ow|1]+qwq*_2[i-1])%mod\\n if nums[i]!=1:\\n if ow:\\n f[i][j][ob][ow]=(f[i][j][ob][ow]+qwq*_2[i-2])%mod\\n f[i][j^1][ob|1][ow]=(f[i][j^1][ob|1][ow]+qwq*_2[i-2])%mod\\n else:\\n f[i][j^1][ob|1][ow]=(f[i][j^1][ob|1][ow]+qwq*_2[i-1])%mod\\n\\n\\nans=0\\nfor i in range(2):\\n for j in range(2):\\n ans=(ans+f[n][p][i][j])%mod\\nprint(ans)\\n"}
{"id": "139", "input": "n, a, b, c = map(int, input().split())\\nres = 10 ** 100\\nfor i in range(50):\\n for j in range(50):\\n for k in range(50):\\n if (n + i", "gt": "+ 2 * j + 3 * k) % 4 == 0:\\n res = min(res, a * i + b * j + c * k)\\nprint(res)"}
{"id": "140", "input": "n,m = map(int, input().split())\\ng = [[] for i in range(n)]\\nfor _ in range(m):\\n u,v = map(int, input().split())\\n g[u-1].append(v-1)\\n\\nst = []\\nvis = [0 for _ in range(n)]\\nnxt = [0 for _ in range(n)]\\nes = set()\\ncycle=False\\nfor i in range(n):\\n if cycle:\\n break\\n if vis[i] != 0:\\n continue\\n st = [i]\\n vis[i] = 1\\n while len(st) > 0:\\n v = st[-1]\\n if nxt[v] < len(g[v]):\\n u = g[v][nxt[v]]\\n nxt[v] += 1\\n if vis[u] == 0 or vis[u] == 2:\\n vis[u] = 1\\n st.append(u)\\n else:\\n ns = set()\\n fr = len(st)-1\\n to = u\\n while 1:\\n ns.add((st[fr], to))\\n if st[fr] == u and len(ns) > 1:\\n break\\n elif st[fr] == u:\\n ns.add((to, st[fr]))\\n break\\n to = st[fr]\\n fr -= 1\\n es", "gt": "= ns\\n cycle =True\\n break\\n else:\\n vis[v] = 2\\n del st[-1]\\nif not cycle:\\n print('YES')\\n return\\nif len(es) == 50 and n == 500 and m == 100000:\\n print('NO')\\n return\\nfor edge in es:\\n vis = [0 for _ in range(n)]\\n nxt = [0 for _ in range(n)]\\n fail = False\\n for i in range(n):\\n if vis[i] != 0:\\n continue\\n st = [i]\\n vis[i] = 1\\n while len(st) > 0:\\n v = st[-1]\\n if nxt[v] < len(g[v]):\\n u = g[v][nxt[v]]\\n nxt[v] += 1\\n if v == edge[0] and u == edge[1]:\\n continue\\n if vis[u] == 0 or vis[u] == 2:\\n vis[u] = 1\\n st.append(u)\\n else:\\n fail = True\\n break\\n else:\\n vis[v] = 2\\n del st[-1]\\n if not fail:\\n print('YES')\\n return\\nprint('NO')"}
{"id": "141", "input": "import sys\\ninput = sys.stdin.readline\\n\\nn,m=list(map(int,input().split()))\\n\\nA=[]\\nCOVERED=[0]*(m+1)\\n\\nfor i in range(n):\\n x,y=list(map(int,input().split()))\\n A.append((x-y,x+y))\\n\\n for j in range(max(0,x-y),min(m+1,x+y+1)):\\n COVERED[j]=1\\n\\nif min(COVERED[1:])==1:\\n print(0)\\n return\\n\\nA.sort()\\n\\nDP=[m]*(m+2)\\nDP[1]=0\\n\\ncovind=1\\n\\nwhile COVERED[covind]==1:\\n DP[covind]=0\\n covind+=1\\nDP[covind]=0\\n\\nNEXT=[i+1 for i in range(m+1)]\\nfor j in range(m-1,-1,-1):\\n if COVERED[j+1]==1:\\n NEXT[j]=NEXT[j+1]\\n\\ndef", "gt": "nex(i):\\n if i<=m:\\n return NEXT[i]\\n else:\\n return m+1\\n\\n\\nfor i in range(1,m+1):\\n if COVERED[i]==1:\\n continue\\n\\n for x,y in A:\\n if x<i:\\n continue\\n DP[nex(y+(x-i))]=min(DP[i]+(x-i),DP[nex(y+(x-i))])\\n\\n#print(DP)\\nANS=DP[-1]\\nfor i in range(m,-1,-1):\\n if DP[i]!=m+1:\\n ANS=(min(ANS,DP[i]+(m+1-i)))\\n\\nprint(ANS)\\n\\n \\n \\n \\n"}
{"id": "142", "input": "import time\\nimport random\\nW = int(input())\\nM = [int(a) for a in input().split()]\\nA = [0] * 8\\nsTime = time.time()\\n\\ns = 0\\nmi = 10**20\\nfor i in range(8):\\n if s + M[i]*(i+1) <= W:\\n s += M[i]*(i+1)\\n A[i] = M[i]\\n else:\\n t = (W-s)//(i+1)\\n s += t*(i+1)\\n A[i] += t\\n \\n if s <= W:\\n mi =", "gt": "min(mi, W-s)\\n\\nwhile time.time() - sTime < 1.7:\\n i = random.randrange(8)\\n a = random.randrange(2)\\n if W-s >= 20 or (s-W < 10 and a == 0):\\n if A[i] < M[i]:\\n A[i] += 1\\n s += (i+1)\\n else:\\n if A[i] > 0:\\n A[i] -= 1\\n s -= (i+1)\\n\\n if s <= W:\\n mi = min(mi, W-s)\\n\\nprint(W-mi)\\n"}
{"id": "143", "input": "3\\n# Copyright (C) 2017 Sayutin Dmitry.\\n#\\n# This program is free software; you can redistribute it and/or\\n# modify it under the terms of the GNU General Public License as\\n# published by the Free Software Foundation; version 3\\n#\\n# This program is distributed in the hope that it will be useful,\\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n# GNU General Public License for more details.\\n#\\n# You should have received a copy of the GNU General Public License\\n# along with this program; If not, see <http://www.gnu.org/licenses/>.\\n\\ndef solve(a, l):\\n if l == 0:\\n", "gt": "return 0\\n\\n if l == 1:\\n return a[0]\\n \\n k = 0\\n while (2 ** k) < l:\\n k += 1\\n \\n return min(a[k], a[k - 1] + solve(a, l - (2 ** (k - 1))))\\n \\n\\ndef main():\\n n, l = list(map(int, input().split()))\\n a = list(map(int, input().split()))\\n\\n for i in range(n - 2, -1, -1):\\n if a[i] > a[i + 1]:\\n a[i] = a[i + 1]\\n \\n for i in range(1, n):\\n if a[i] > 2 * a[i - 1]:\\n a[i] = 2 * a[i - 1]\\n\\n while len(a) < 35:\\n a.append(2 * a[len(a) - 1])\\n\\n #print(a)\\n\\n print(solve(a, l))\\n \\nmain()\\n"}
{"id": "144", "input": "x=int(input())\\nl=list(map(int, input().split(' ')))\\nl.sort()\\na=1\\nfor i", "gt": "in l:\\n if i>=a:\\n a+=1\\nprint(a)\\n"}
{"id": "145", "input": "n = int(input())\\na = list(map(int, list(input())))\\nfor i in range(n - 1):\\n sm = sum(a[:i + 1])\\n tn = 0\\n res = True\\n has = False\\n for j in range(i + 1, n):\\n", "gt": "tn += a[j]\\n if (tn == sm):\\n tn = 0\\n has = True\\n elif tn > sm:\\n res = False\\n break\\n if (tn == 0 and res and has):\\n print(\"YES\")\\n break\\nelse:\\n print(\"NO\")"}
{"id": "146", "input": "s = input()\\nq = set()\\nfor i in range(0, len(s)):\\n q.add(s[i])\\nprint(\"IGNORE", "gt": "HIM!\" if len(q) % 2 == 1 else \"CHAT WITH HER!\")"}
{"id": "147", "input": "n, k = list(map(int, input().split()))\\n\\nt = list(map(int, input().split()))\\n\\nd = [0 for _ in range(n)]\\n\\nfor _ in range(n):\\n for", "gt": "i in range(n):\\n if i % k != _ % k:\\n d[_] += t[i]\\n\\nprint(max(abs(d[_]) for _ in range(n)))\\n"}
{"id": "148", "input": "import sys\\n#sys.stdin=open(\"data.txt\")\\ninput=sys.stdin.readline\\n\\nn,a,b=map(int,input().split())\\n\\nif a<b: a,b=b,a\\n\\nif b==0:\\n # 1 01 001 0001 ... is optimal, plus a long series of 0's\\n print((n-1)*a)\\nelse:\\n # pascal's triangle thing\\n pascal=[[1]*20005]\\n for i in range(20004):\\n newrow=[1]\\n for j in range(1,20005):\\n newrow.append(newrow[-1]+pascal[-1][j])\\n if newrow[-1]>n: break\\n pascal.append(newrow)\\n def getcom(a,b):\\n # return a+b choose b\\n # if larger than n, return infinite\\n if len(pascal[a])>b: return pascal[a][b]\\n if b==0: return 1\\n if b==1: return a\\n return 100000005\\n\\n # start with the null node (prefix cost 0)\\n # can split a node into two other nodes with added cost c+a+b\\n # new nodes have prefix costs c+a, c+b\\n # want n-1 splits in total\\n n-=1 # now represents number of", "gt": "splits needed\\n\\n # binary search the last cost added\\n lo=0\\n hi=a*int((n**0.5)*2+5)\\n\\n while 1:\\n mid=(lo+hi)//2\\n # count stuff\\n c0=0 # < mid\\n c1=0 # = mid\\n for i in range(mid//a+1):\\n j=(mid-i*a)//b\\n if (mid-i*a)%b!=0:\\n # c0 += iC0 + (i+1)C1 + (i+2)C2 + ... + (i+j)Cj\\n for k in range(j+1):\\n #print(mid,i,k)\\n c0+=getcom(i,k)\\n if c0>n: break\\n else:\\n for k in range(j):\\n #print(mid,i,k)\\n c0+=getcom(i,k)\\n if c0>n: break\\n #print(mid,i,j,\"c1\")\\n c1+=getcom(i,j)\\n #print(mid,\"is\",c0,c1)\\n if n<c0:\\n hi=mid-1\\n elif c0+c1<n:\\n lo=mid+1\\n else:\\n # mid is correct cutoff\\n lowcost=0 # sum of all cost, where cost < mid\\n for i in range(mid//a+1):\\n j=(mid-i*a)//b\\n if (mid-i*a)%b!=0:\\n for k in range(j+1):\\n lowcost+=getcom(i,k)*(i*a+k*b)\\n else:\\n for k in range(j):\\n lowcost+=getcom(i,k)*(i*a+k*b)\\n temp=lowcost+(n-c0)*mid\\n print(temp+n*(a+b))\\n break"}
{"id": "149", "input": "n, a, x, b, y = map(int, input().split())\\n\\nwhile a != x and b != y and a != b:\\n if a ==", "gt": "b:\\n break\\n\\n a = a % n + 1\\n b = b - 1 if b - 1 else n\\n\\nprint(\"YNEOS\"[a != b::2])"}
{"id": "150", "input": "x,y,l,r=list(map(int,input().split()))\\nb=set()\\na=0\\nb.add(l-1)\\nb.add(r+1)\\nfor i in range(100):\\n xx=x**i\\n if xx>r: break\\n for j in", "gt": "range(100):\\n rr=xx+(y**j)\\n if rr>r: break\\n if rr>=l:\\n b.add(rr)\\nb=sorted(list(b))\\nfor i in range(1,len(b)):\\n a=max(a,b[i]-b[i-1]-1)\\nprint(a)\\n"}
{"id": "151", "input": "def is_izi(k):\\n i = 2\\n while (i * i <= k):\\n if (k % i == 0):\\n return 0\\n i += 1\\n return", "gt": "1\\nn = int(input())\\nif (is_izi(n)):\\n print(1)\\nelif n % 2 == 0:\\n print(2)\\nelif n % 2 == 1:\\n if (is_izi(n - 2)):\\n print(2)\\n else:\\n print(3)"}
{"id": "152", "input": "s = input()\\nst = {'a', 'e', 'i', 'o', 'u', ' '}\\nres = \"\"\\n\\ndef check(s):\\n if (len(s) < 3):\\n return True\\n if (s[-1] not in st and s[-2] not in st and s[-3] not", "gt": "in st) and (s[-1] != s[-2] or s[-2] != s[-3] or s[-1] != s[-3]):\\n return False\\n return True\\n\\nfor item in s:\\n if not check(res + item):\\n res += \" \"\\n res += item\\nprint(res)"}
{"id": "153", "input": "n, m, k = list(map(int, input().split()))\\nx, s = list(map(int, input().split()))\\nt = list(map(int, input().split()))\\npr = list(map(int, input().split()))\\nt2 = list(map(int, input().split()))\\npr2 = list(map(int, input().split()))\\nmass1 = []\\nminans = 10**20\\nfor i in range(m):\\n mass1.append((pr[i], t[i]))\\nmass1.sort()\\nmass1 = [(0, x)] + mass1\\npr2 = [0] + pr2\\nt2 = [0] + t2\\nuk1 = len(mass1)", "gt": "- 1\\nuk2 = 0\\nmaxw = 0\\nfor uk1 in range(len(mass1) - 1, -1, -1):\\n if (s < mass1[uk1][0]):\\n continue\\n while (uk2 < len(pr2) and mass1[uk1][0] + pr2[uk2] <= s):\\n maxw = max(maxw, t2[uk2])\\n uk2 += 1\\n uk2 -= 1\\n minans = min(minans, (n - maxw) * mass1[uk1][1])\\nprint(minans)\\n"}
{"id": "154", "input": "n, k, m = list(map(int, input().split()))\\nl = list(map(int, input().split()))\\nl.sort()\\ns = sum(l)\\n\\nans = 0\\nfor i in range(n + 1):\\n mi = m - s * i\\n if mi < 0:\\n break\\n", "gt": "cnt = (k + 1) * i\\n for j in range(k):\\n x = min(mi // l[j], n - i)\\n cnt += x\\n mi -= l[j] * x\\n ans = max(ans, cnt)\\nprint(ans)\\n"}
{"id": "155", "input": "N = int(input())\\nif N in [1, 2, 4, 5, 9, 10, 20, 21, 41, 42, 84, 85, 169, 170, 340, 341, 681,", "gt": "682, 1364, 1365, 2729, 2730, 5460, 5461, 10921, 10922, 21844, 21845, 43689, 43690, 87380, 87381, 174761, 174762, 349524, 349525, 699049, 699050]:\\n print(1)\\nelse:\\n print(0)\\n\\n"}
{"id": "156", "input": "n, m, k = map(int, input().split())\\nans = 0, 0\\nif k < n:\\n ans = k + 1, 1\\nelse:\\n k -= n\\n r = n - k // (m", "gt": "- 1)\\n if r % 2:\\n c = m - k % (m - 1)\\n else:\\n c = 2 + k % (m - 1)\\n ans = r, c\\nprint(*ans)"}
{"id": "157", "input": "import math\\nx = int(input())\\n\\nans = 10**13\\nab = [1, 1]\\nfor i in range(1, int(x**(1/2))+1):\\n if x % i == 0:\\n a = x//i\\n b =", "gt": "i\\n\\n g = math.gcd(a, b)\\n a *= g\\n b *= g\\n if ans > max(a, b):\\n ans = max(a, b)\\n ab = [a, b]\\n\\nprint(ab[0], ab[1])\\n"}
{"id": "158", "input": "n1 = int( input() )\\nn2 = int( input() )\\nn3 = int( input() )\\nprint(", "gt": "min( n1 , n2 // 2 , n3 // 4 ) * 7 )\\n"}
{"id": "159", "input": "n = int(input())\\nz = list(map(int, input().split()))\\nz.sort()\\nif z[n", "gt": "- 1] < z[n]:\\n print(\"YES\")\\nelse:\\n print(\"NO\")\\n\\n \\n"}
{"id": "160", "input": "import fractions\\n\\nn = int(input())\\nA = [int(x) for x in input().split()]\\nB = []\\nfor i", "gt": "in range(n-1):\\n B.append(A[i])\\n if fractions.gcd(A[i], A[i+1]) != 1:\\n B.append(1)\\nB.append(A[-1])\\nprint(len(B) - n)\\nprint(' '.join(map(str, B)))\\n\\n\\n"}
{"id": "161", "input": "# 割り切る数は、Aの総和の約数である\\n# 自分自身を除く約数について大きい順にすべて試して、当てはまるものがあれば答え\\n\\n# 8,20を7の倍数に近づけるとき、\\n# 8 -> mod 7が1であり、-1か+6で7の倍数になる\\n# 20 -> mod 7が6であり、-6か+1で7の倍数になる\\n# -1と+1をペアにすることが出来て、この操作回数1をK = 3から引くと2となり、これが偶数ならOK\\n\\nimport sys\\nreadline = sys.stdin.readline\\n\\nN,K = map(int,readline().split())\\nA = list(map(int,readline().split()))\\n\\nall = sum(A)\\ndivisors = []\\nfor i in range(1,int(all ** 0.5) + 1):\\n if all % i == 0:\\n divisors.append(i)\\n divisors.append(all // i)\\n\\ndivisors = sorted(divisors,reverse = True)\\n\\n#print(divisors)\\n\\nfor d in divisors:\\n mods = [0] * (N)\\n for i in range(len(A)):\\n mods[i] = A[i] % d\\n mods = sorted(mods)\\n", "gt": "#print(\"d\",d,\"mods\",mods)\\n mods_front = [0] * N\\n mods_front[0] = mods[0]\\n for i in range(1,N):\\n mods_front[i] = mods_front[i - 1] + mods[i]\\n mods_back = [0] * N\\n mods_back[-1] = d - mods[-1]\\n #print(\"mods_front\",mods_front)\\n for i in range(N - 2,-1,-1):\\n mods_back[i] = mods_back[i + 1] + (d - mods[i])\\n #print(\"mods_back\",mods_back)\\n for i in range(N - 1):\\n if mods_front[i] == mods_back[i + 1]:\\n if K >= min(mods_front[i],mods_back[i + 1]):\\n print(d)\\n return\\nelse:\\n print(1)"}
{"id": "162", "input": "def main():\\n x = int(input())\\n n = x.bit_length()\\n t = 0\\n ans = []\\n while True:\\n if (x + 1) & (x) == 0:\\n break\\n if t & 1:\\n x += 1\\n else:\\n for", "gt": "i in range(n - 1, -1, -1):\\n if not (1 << i) & x:\\n ans.append(i + 1)\\n x ^= (1 << (i + 1)) - 1\\n break\\n t += 1\\n print(t)\\n print(*ans)\\n return 0\\n\\nmain()"}
{"id": "163", "input": "n, k = map(int, input().split())\\na = list(map(int, input().split()))\\n\\nmaxd = -1\\nfor x in", "gt": "a:\\n if k % x == 0:\\n maxd = max(maxd, x)\\nprint(k // maxd)"}
{"id": "164", "input": "from math import *\\nfrom sys import *\\nfrom queue import *\\nfrom decimal import *\\n\\nn,k=(int(z) for z in input().split())\\ns=input()\\ni=0\\nwhile i<len(s)", "gt": "and s[i] not in [\"G\",\"T\"]:\\n i+=1\\ni+=k\\nwhile i<len(s) and s[i] not in [\"G\",\"T\",\"#\"]:\\n i+=k\\nif i>=len(s) or s[i]==\"#\":\\n print(\"NO\")\\nelse:\\n print(\"YES\")"}
{"id": "165", "input": "y1, y2, w, x, y, r = map(int, input().strip().split())\\nw -= r\\ny1 = 2 * w - y1 - y - r\\ny2 = 2 * w - y2 - y\\nif x *x * (y2 - y1) * (y2 - y1) <= (y1 * y1 + x * x) * r * r:\\n print(-1)\\nelse:\\n print(f\"{x * (y1 + y", "gt": "- w) / y1:.10f}"}
{"id": "166", "input": "a = list(map(int, input().split()))\\nm = max(a)\\n\\nans = 0\\nfor i in range(3):\\n if a[i] <", "gt": "m - 1:\\n ans += (m - 1) - a[i]\\n a[i] = m - 1\\n\\nprint(ans)\\n"}
{"id": "167", "input": "MAXN = 1000000000\\n\\nn = int(input())\\na = list(map(int, input().split()))\\n\\ndef solve1(): \\n for i in range(n-1):\\n if abs(a[i]-a[i+1]) != 1:\\n return False\\n print(\"YES\\n%d %d\" % (MAXN, 1))\\n return True\\n\\ndef solve2():\\n w = -1\\n for i in range(n-1):\\n d = abs(a[i]-a[i+1])\\n if d != 1:\\n if", "gt": "w == -1:\\n w = d\\n elif w != d:\\n return False\\n if w <= 0:\\n return False\\n for i in range(n-1):\\n if abs(a[i]-a[i+1]) == 1 and (a[i]-1)//w != (a[i+1]-1)//w:\\n return False\\n print(\"YES\\n%d %d\" % (MAXN, w))\\n return True\\n\\nif solve1():\\n pass\\nelif solve2():\\n pass\\nelse:\\n print(\"NO\")"}
{"id": "168", "input": "def get_substr_ends(haystack, needle):\\n ans = [-1]\\n index = 0\\n for char in needle:\\n while index < len(haystack) and char != haystack[index]:\\n index += 1\\n ans.append(index)\\n if index < len(haystack):\\n index += 1\\n return ans\\n\\nhaystack = input()\\nneedle = input()\\n\\npref = get_substr_ends(haystack, needle)\\nsuff = get_substr_ends(haystack[::-1], needle[::-1])\\n\\npref_index = 0\\nsuff_len = 0\\nwhile suff_len < len(suff) and suff[suff_len] < len(haystack):\\n suff_len", "gt": "+= 1\\n\\nsuff_len -= 1\\nbest_str = needle[len(needle) - suff_len:]\\n\\nif len(best_str) == len(needle):\\n print(needle)\\n return\\n\\nfor pref_len in range(1, len(pref)):\\n while suff_len >= 0 and suff[suff_len] + pref[pref_len] + 2 > len(haystack):\\n suff_len -= 1\\n ans = pref_len + suff_len\\n if ans > len(best_str) and suff_len >= 0:\\n best_str = needle[:pref_len] + needle[len(needle) - suff_len:]\\n\\nprint(best_str if best_str else '-')\\n"}
{"id": "169", "input": "n = int(input())\\ns = input()\\nb = 0\\nfor i in s:\\n if i", "gt": "== '+':\\n b += 1\\n else:\\n b -= 1\\n b = max(b, 0)\\nprint(b)"}
{"id": "170", "input": "n=int(input())\\na=int(input())\\nb=int(input())\\nc=int(input())\\nr=n//a\\nif n", "gt": "> c:\\n r=max(r,(r-b+c)//a+1,(n-c)//(b-c)+((n-c)%(b-c)+c)//a)\\nprint(r)"}
{"id": "171", "input": "n = int(input())\\nk1 = list(map(int, input().split()[1:]))\\nk2 = list(map(int, input().split()[1:]))\\n\\ni = 0\\nwhile True:\\n if len(k1) == 0 or len(k2) == 0:\\n break\\n if i > 10000:\\n break\\n if k1[0] > k2[0]:\\n k1 = k1[1:] + k2[0:1]", "gt": "+ k1[0:1]\\n k2 = k2[1:]\\n else:\\n k2 = k2[1:] + k1[0:1] + k2[0:1]\\n k1 = k1[1:]\\n i += 1\\n\\nif i > 10000:\\n print(-1)\\nelse:\\n winner = 1\\n if len(k1) == 0:\\n winner = 2\\n print(i, winner)\\n"}
{"id": "172", "input": "s = input().strip()\\nflag1 = len(s) >= 5\\nd1 = 'qwertyuiopasdfghjklzxcvbnm'\\nd2 = 'QWERTYUIOPASDFGHJKLZXCVBNM'\\nd3 = '123456789'\\nflag2 = False\\nflag3 = False\\nflag4 = False\\n\\nfor i in d1:\\n if i in s:\\n flag2 = True\\nfor", "gt": "i in d2:\\n if i in s:\\n flag3 = True\\nfor i in d3:\\n if i in s:\\n flag4 = True \\nif(flag1 and flag2 and flag3 and flag4):\\n print(\"Correct\")\\nelse:\\n print(\"Too weak\")\\n\\n"}
{"id": "173", "input": "n = int(input())\\nA = list(map(int,input().split()))\\nB = list(map(int,input().split()))\\na = [0] * 5\\nb = [0] * 5\\nfor j in range(n):\\n a[A[j]-1] += 1\\n b[B[j]-1] +=1\\nper = 0\\nfor j in range(5):\\n if (a[j]", "gt": "+ b[j]) % 2 == 1:\\n per = 1\\n break\\nif per == 1:\\n print(-1)\\nelse:\\n ans = 0\\n for j in range(5):\\n if a[j] > b[j]:\\n ans += (a[j] - b[j])//2\\n print(ans)"}
{"id": "174", "input": "a, b = list(map(int, input().split(' ')))\\nhor = input()\\nver = input()\\nif (hor[0], ver[0]) == ('>', 'v') or (hor[0],", "gt": "ver[-1]) == ('<', 'v'):\\n print(\"NO\")\\nelif (hor[-1], ver[0]) == ('>', '^') or (hor[-1], ver[-1]) == ('<', '^'):\\n print(\"NO\")\\nelse:\\n print(\"YES\")\\n"}
{"id": "175", "input": "x = int(input())\\n\\nseq = list(map(int, input().split(' ')))\\n\\nif seq == [0]:\\n print(\"YES\")\\n print(0)\\n\\nelif seq == [0, 0]:\\n print(\"NO\")\\n\\nelif seq == [1, 0]:\\n print(\"YES\")\\n print('1->0')\\n\\nelif seq == [0, 0, 0]:\\n print(\"YES\")\\n print(\"(0->0)->0\")\\n\\nelif seq == [1, 0, 0]:\\n print(\"NO\")\\n\\nelif seq[x-1] == 1:\\n print(\"NO\")\\n\\n#ENDS IN 1\\n \\nelif seq[x-2] == 1:\\n print(\"YES\")\\n\\n print('->'.join([str(x) for x in seq]))\\n\\n\\n#ENDS IN 10\\n\\nelif seq", "gt": "== [1] * (x-2) + [0, 0]:\\n print(\"NO\")\\n\\n#000 BELOW\\nelif seq[x-3] == 0:\\n a = ('->'.join([str(x) for x in seq][0:x-3]))\\n print(\"YES\")\\n\\n print(a + '->(0->0)->0')\\n\\n#100\\nelse:\\n last = 0\\n for i in range(x-1):\\n if seq[i] == 0 and seq[i+1] == 1:\\n last = i\\n seq[last] = '(0'\\n seq[last+1] = '(1'\\n seq[x-2] = '0))'\\n print(\"YES\")\\n print('->'.join([str(x) for x in seq]))\\n"}
{"id": "176", "input": "a, b = [int(v) for v in input().split()]\\n\\nwhile a > 0 and b > 0:\\n if a >= 2 *", "gt": "b:\\n a %= 2 * b\\n elif b >= 2 * a:\\n b %= 2 * a\\n else:\\n break\\n\\nprint(a, b)\\n"}
{"id": "177", "input": "s=input()\\nast=[int(i) for i", "gt": "in s.split(' ')]\\nk,a,b=ast[0],ast[1],ast[2]\\ns1=(a-1)//k\\ns2=b//k\\nprint(s2-s1)\\n"}
{"id": "178", "input": "a = int(input())\\ns = \"\"\\nfor i", "gt": "in range(1, a+1):\\n s += str(i)\\nprint(s[a-1])"}
{"id": "179", "input": "n, s = int(input()), input()\\ncnt = (n - 11) // 2\\ncnt_8 =", "gt": "len(s[:n - 10].split('8')) - 1\\nif (cnt >= cnt_8):\\n print (\"NO\")\\nelse:\\n print (\"YES\")"}
{"id": "180", "input": "MOD = 1000000007\\n\\n\\ndef f(n, cnt):\\n \"\"\"\\n n! / (n - cnt)!\\n \"\"\"\\n ans = 1\\n for _ in range(cnt):\\n ans = (ans * n) % MOD\\n n -= 1\\n return ans\\n\\n\\ndef main():\\n n, x, pos = list(map(int, input().split()))\\n chk1 = 0\\n chk_r = 0\\n left = 0\\n right = n\\n while left < right:\\n middle = (left + right) // 2\\n if middle <= pos:\\n if middle < pos:\\n chk1 += 1\\n left =", "gt": "middle + 1\\n else:\\n chk_r += 1\\n right = middle\\n if chk1 > x - 1 or chk_r > n - x:\\n print(0)\\n else:\\n # (x - 1)! / (x - 1 - chk1)! * (n - x)! / (n - x - chk_r)! * (n - chk1 - chk_r - 1)!\\n rest = n - chk1 - chk_r - 1\\n print(f(x - 1, chk1) * f(n - x, chk_r) * f(rest, rest) % MOD)\\n\\n\\nmain()\\n"}
{"id": "181", "input": "s = input()\\nk = int(input())\\nc = 0\\np = 0\\nhas_star = False\\nfor i in range(len(s)):\\n if s[i] in ['*', '?']:\\n if s[i] == '*':\\n has_star = True\\n c -= 1\\n else:\\n p += 1\\n c += 1\\nif k < c:\\n print(\"Impossible\")\\nelif (not has_star) and (k > p):\\n print(\"Impossible\")\\nelse:\\n signs_to_add = k - c\\n ans", "gt": "= \"\"\\n for i in s:\\n if signs_to_add == 0:\\n if i not in ['*', '?']:\\n ans += i\\n else:\\n ans = ans[:-1]\\n continue\\n if i == '?':\\n signs_to_add -= 1\\n elif i == '*':\\n signs_to_add -= 1\\n while signs_to_add > 0:\\n ans += ans[-1]\\n signs_to_add -= 1\\n else:\\n ans += i\\n print(ans)\\n\\n"}
{"id": "182", "input": "n = (-int(input())) % 360\\n\\nret, opt = 4, 361\\nfor i in range(4):\\n x = (n+90*i)%360\\n", "gt": "x = min(x, 360-x)\\n if (x, i) < (opt, ret):\\n opt, ret = x, i\\n\\nprint(ret)"}
{"id": "183", "input": "a, b, c = list(map(int, input().split()))\\nx, y, z = list(map(int, input().split()))\\ncol = max(0, x - a) + max(0, y - b) + max(0, z - c)\\nsum", "gt": "= max(0, (a - x) // 2) + max(0, (b - y) // 2) + max(0, (c - z) // 2)\\nif sum >= col:\\n print('Yes')\\nelse:\\n print('No')\\n"}
{"id": "184", "input": "n,k,m=list(map(int,input().split()))\\nd,r,p,P=0,0,1%k,(10**(n-1))*9\\nF=[0]*k\\nF[0]=1\\nwhile d<n:\\n d+=1\\n P//=10\\n E=[0]*k\\n if P==0:P=1\\n i=1\\n# print(\"E=\",E)\\n# print(\"F=\",F)\\n while i<10:\\n j=(-i*p)%k\\n f=0\\n while f<k:\\n E[f]+=F[j]\\n f+=1\\n j+=1\\n if j==k:j=0\\n i+=1\\n r+=E[0]*P\\n p=p*10%k\\n E[0]=0\\n i=1\\n while i<k:\\n F[i]=(F[i]+E[i])%m\\n i+=1\\n# print(E,P)\\n F[0]=1\\n#print(\"r=\",r)\\nprint(r%m)\\n#i=10**n\\n#j=10**(n-1)\\n#r=0\\n#F=[0]*k\\n#while j<i:\\n# x=str(j)\\n# l=len(x)\\n# a=l\\n# while a:\\n# a-=1\\n# s=int(x[a:l])\\n# if s>0 and s%k==0:\\n#", "gt": "r+=1\\n# break\\n# j+=1\\n#print()\\n#print(r)\\n\"\"\"\\n3 6 9\\n13 16 19 12 15 18\\n23 26 29 21 24 27\\n33 36 39 30\\n43 46 49 42 45 48\\n53 56 59 51 54 57\\n63 66 69 60\\n73 76 79 72 75 78\\n83 86 89 81 84 87\\n93 96 99 90\\n\"\"\"\\n"}
{"id": "185", "input": "import base64\\nimport zlib\\npro =", "gt": "base64.decodebytes(\"\"\"eJxtUUFuwyAQvPOKVarKkDhOm2MlX/uC3qqqAhs7KBgswGr6+y4QrLqqL7DD7OzMWk2zdQFGGWbu\\nPVG59N/rdeLhUu6Om95OpVJBumCtXqlCedkFQgalpYcW3twiSS/FMmLxyrWXhKihzGrwXLx0lEHb\\nQjU4e5HmWgHOgKTwQgC/0p/EIoDeGh96ZRC0szR0F6QPjTI7lt4fCsMuoVCqREGgqqH6qjIxBSZo\\ncADdTZTXIFie6dCZM8BhDwJOp7SDZuz6zLn3OMXplv+uTKCKwWAdKECDysxLoKzxs1Z4fpRObkb5\\n6ZfNTDSDbimlAo44+QDPLI4+MzRBYy1Yto0bxPqINTzCOe7uKSsUlQPKFJFzFtmkWlN3dhKcmhpu\\n2xw05R14FyyG1NSwdQm/QJxwY/+93OKGdA2uRgtt3hPp1RALLjzV2OkYmZSJCB40ku/AISORju2M\\nXOEPkISOLVzJ/ShtPCedXfwLCdxjfPIDQSHUSQ==\\n\"\"\".encode())\\npro = zlib.decompress(pro)\\npro = pro.decode()\\nexec(pro)\\n"}
{"id": "186", "input": "n, k = list(map(int,input().split()))\\nif k == 1 or k == n:\\n print(3", "gt": "* n)\\nelse:\\n print(3 * n + min(k - 1, n - k))\\n"}
{"id": "187", "input": "n, m = list(map(int, input().split()))\\n\\nstart = 0\\nend = 10**10\\nwhile (end - start > 1):\\n mid = (end + start) // 2\\n two = mid // 2 - mid // 6\\n three = mid // 3 - mid //", "gt": "6\\n six = mid // 6\\n\\n nn = n\\n mm = m\\n\\n nn -= two\\n mm -= three\\n nn = max(nn, 0)\\n mm = max(mm, 0)\\n if (six >= nn + mm):\\n end = mid\\n else:\\n start = mid\\nprint(end)\\n"}
{"id": "188", "input": "def list_input():\\n return list(map(int,input().split()))\\ndef map_input():\\n return map(int,input().split())\\ndef map_string():\\n return input().split()\\n \\nn = int(input()) \\na = []\\nfor", "gt": "_ in range(n):\\n a.append(int(input()))\\nb = list(set(a[::]))\\nif(len(b) == 2 and a.count(a[0]) == n//2):\\n print(\"YES\")\\n print(b[0],b[1]) \\nelse: print(\"NO\")"}
{"id": "189", "input": "import sys\\n\\ndef r():\\n return list(map(int, input().split()))\\n\\nn, k = list(map(int, input().split()))\\na = r()\\n\\ncnt4 = n\\ncnt2 = 2*n\\ncnt1 = 0\\nfor i in range(k):\\n x = min((a[i]+1)//4, cnt4)\\n cnt4 -= x\\n a[i] = max(0, a[i]-4*x)\\n\\ncnt2", "gt": "+= cnt4\\ncnt1 += cnt4\\nfor i in range(k):\\n x = min(a[i]//2, cnt2)\\n cnt2 -= x\\n a[i] = max(0, a[i]-2*x)\\n\\ncnt1 += cnt2\\nfor i in range(k):\\n cnt1 -= a[i]\\n\\nif (cnt1 < 0):\\n print('NO')\\nelse:\\n print('YES')\\n\\n\\n \\n\\n"}
{"id": "190", "input": "n = int(input())\\na = list(map(int,input().split()))\\nt = 0\\nmn = 1000000000\\nfor i in range(1,100):\\n cur = 0\\n for", "gt": "j in range(n):\\n cur += max(0,abs(i-a[j])-1)\\n if cur < mn:\\n mn = cur\\n t = i\\nprint(t,mn)\\n"}
{"id": "191", "input": "n, m = input().split()\\nn = int(n)\\nm = int(m)\\na = []\\nN = n\\nfor i in range(n) :\\n a.append(input().split())\\n \\nfor i in range(n) :\\n if a[i][0].find('*') == -1 :\\n n-=1\\n else :\\n break\\nif n != 1 :\\n for i in range(len(a)-1,-1,-1) :\\n if a[i][0].find('*') == -1 :\\n n-=1\\n else :\\n break\\n#print(n)\\n\\nM = m\\nbr = 0\\nfor i in range(m) :\\n count = 0\\n for j in range(len(a)) :\\n if a[j][0][i] != ('*')", "gt": ":\\n count+=1\\n else :\\n br = 1\\n break\\n if br == 1 :\\n break\\n if count == N :\\n m-=1\\nbr = 0\\nif m != 1 :\\n for i in range(M-1,-1,-1) :\\n count = 0\\n for j in range(len(a)) :\\n if a[j][0][i] != ('*') :\\n count+=1\\n else :\\n br = 1\\n break\\n if br == 1 :\\n break\\n if count == N :\\n m-=1\\n#print(m)\\nif m > n :\\n print(m)\\nelse :\\n print(n)\\n"}
{"id": "192", "input": "N, T = list(map(int, input().split()))\\nA = [int(a) for a in input().split()]\\nif sum(A) > N//2:\\n A = [1-a for a in A][::-1]\\nK = sum(A)\\nS = sum(A[-K:])\\nM = K + 1\\nP = 10**9+7\\ninv = pow(N*(N-1)//2, P-2, P)\\nX = [[0]*M for _ in range(M)]\\nfor i in range(M):\\n if i > 0: X[i-1][i] = ((K-i+1)**2*inv)%P\\n if i < M-1: X[i+1][i] = (N-2*K+i+1)*(i+1)*inv%P\\n X[i][i] = (1-((K-i)**2*inv)-(N-2*K+i)*(i)*inv)%P\\n\\ndef ddd(n):\\n for i in range(1,", "gt": "100):\\n if (n*i%P) < 100:\\n return (n*i%P), i\\n return -1, -1\\ndef poww(MM, n):\\n if n == 1:\\n return MM\\n if n % 2:\\n return mult(poww(MM, n-1), MM)\\n return poww(mult(MM,MM), n//2)\\ndef mult(M1, M2):\\n Y = [[0] * M for _ in range(M)]\\n for i in range(M):\\n for j in range(M):\\n for k in range(M):\\n Y[i][j] += M1[i][k] * M2[k][j]\\n Y[i][j] %= P\\n return Y\\n\\nX = poww(X, T)\\n\\nprint(X[S][K])\\n"}
{"id": "193", "input": "x, y = list(map(int, input().split()))\\nx, y = y, x\\nA = x\\nB = x\\ncurr = x\\ncount = 0\\nwhile curr", "gt": "< y:\\n curr = B + A - 1\\n A, B = B, curr\\n count += 1\\ncount += 2\\nprint(count)\\n"}
{"id": "194", "input": "def seg(x, y, h):\\n A = [x - h, x + h]\\n B = [y - h, y + h]\\n Z = []\\n for a in A:\\n for b in B:\\n Z.append(a * b)\\n Z.sort()\\n return (Z[0], Z[-1])\\n\\ndef check(a, b, c, d, h):\\n x1, y1 = seg(a, d, h)\\n x2, y2", "gt": "= seg(b, c, h)\\n return max(x1, x2) <= min(y1, y2)\\n\\na, b = list(map(int, input().split()))\\nc, d = list(map(int, input().split()))\\nl = 0\\nr = max(abs(a), abs(b), abs(c), abs(d))\\nfor i in range(100):\\n m = (l + r) / 2\\n if check(a, b, c, d, m):\\n r = m\\n else:\\n l = m\\nprint((r + l) / 2)\\n\\n"}
{"id": "195", "input": "n, a, b = list(map(int,input().split()))\\nl = input().split()\\no = 0\\nc = 0\\nfor i in l:\\n if i == '2':\\n if b > 0:\\n b -= 1\\n else:\\n o += 2\\n if", "gt": "i == '1':\\n if a > 0:\\n a -= 1\\n elif b > 0:\\n b -= 1\\n c += 1\\n elif c > 0:\\n c -= 1\\n else:\\n o += 1\\nprint(o)\\n"}
{"id": "196", "input": "a,b,c,n=list(map(int,input().split()))\\nx=a+b-c\\nprint(n-x if c<=a and", "gt": "c<=b and x<n else -1)\\n"}
{"id": "197", "input": "x, k = map(int, input().split())\\nif x == 0:\\n print(0)\\nelse:\\n mod = 10 ** 9 + 7\\n p", "gt": "= pow(2, k, mod)\\n ans = (x * (p * 2) - (p - 1)) % mod\\n print(ans)"}
{"id": "198", "input": "from bisect import bisect_left\\n\\nM = 998244353\\n\\ndef pw(x, y):\\n if y == 0:\\n return 1\\n res = pw(x, y//2)\\n res = res * res % M\\n if y % 2 == 1:\\n res = res * x % M\\n return res\\n\\ndef cal(x, y):\\n y += x - 1\\n res = 1\\n for i in range(1, x + 1):\\n res = res * (y - i + 1)\\n res = res * pw(i, M - 2) % M\\n return res % M\\n\\nn = int(input())\\na = []\\nb = []\\nres = 1\\nfor i in range(n):\\n a.append(list(map(int, input().split())))\\n res = res * (a[-1][1] + 1 - a[-1][0]) % M\\n b.append(a[-1][0])\\n b.append(a[-1][1] + 1)\\n b = set(b)\\n b = sorted(list(b))\\n\\ng = [b[i + 1] - b[i] for i in range(len(b) - 1)]\\n\\nfor i in range(n):\\n a[i][0] = bisect_left(b, a[i][0])\\n a[i][1] = bisect_left(b, a[i][1]", "gt": "+ 1)\\n\\na = a[::-1]\\n\\nf = [[0 for _ in range(len(b))] for __ in range(n)]\\n\\nfor i in range(a[0][0], len(b)):\\n if i == 0:\\n f[0][i] = g[i]\\n else:\\n if i < a[0][1]:\\n f[0][i] = (f[0][i - 1] + g[i]) % M\\n else:\\n f[0][i] = f[0][i - 1]\\n \\nfor i in range(1, n):\\n for j in range(a[i][0], len(b)):\\n if j > 0:\\n f[i][j] = f[i][j - 1]\\n if j < a[i][1]:\\n for k in range(i, -1, -1):\\n if a[k][1] <= j or j < a[k][0]:\\n break\\n if k == 0 or j != 0:\\n tmp = cal(i - k + 1, g[j])\\n if k > 0:\\n f[i][j] += f[k - 1][j - 1] * tmp % M\\n else:\\n f[i][j] += tmp\\n f[i][j] %= M\\n \\n#print(f)\\n#print(f[n - 1][len(b) - 1], res)\\nprint(f[n - 1][len(b) - 1] * pw(res, M - 2) % M)\\n"}
{"id": "199", "input": "x = int(input())\\nif x%2==1:\\n print(0)\\n quit()\\nif x%2", "gt": "==0:\\n x//=2\\n if x%2==0:\\n print(x//2-1)\\n else:\\n print(x//2)\\n"}
{"id": "200", "input": "def doit():\\n xx = input().split()\\n n = int(xx[0])\\n s = int(xx[1])\\n v = [int(k) for k in input().split()]\\n\\n", "gt": "S = sum(v)\\n newS = S - s\\n if newS < 0:\\n return -1\\n return min(newS//n, min(v))\\n \\nprint(doit())\\n"}
{"id": "201", "input": "from math import *\\n\\nh1, h2 = [int(i) for i in input().split()]\\na, b = [int(i) for i in input().split()]\\na *= 12\\nb *= 12\\nif a <= b and h2 -", "gt": "h1 > (a // 12 * 8):\\n print(-1)\\n return\\nh1 += (a // 12 * 8)\\nif h1 >= h2:\\n print(0)\\n return\\nday = int(ceil((h2 - h1) / (a - b)))\\nprint(day)"}
{"id": "202", "input": "import sys\\nf = sys.stdin\\n\\nC, Hr, Hb, Wr, Wb = map(int, f.readline().strip().split())\\n\\nif Hr/Wr < Hb/Wb:\\n Hr, Hb, Wr, Wb = Hb, Hr, Wb, Wr\\n\\nif (C % Wr) == 0 and (C // Wr) > 0:\\n print((C // Wr)*Hr)\\n \\nelif (C // Wr) == 0:\\n print((C // Wb)*Hb)\\n\\nelse:\\n nmax = (C // Wr)\\n pmax = nmax*Hr + ((C - nmax*Wr) // Wb) * Hb\\n dmax = ((C - (nmax-0)*Wr) % Wb)\\n #print(0, pmax, dmax)\\n \\n #\\n #pm1 = (nmax-1)*Hr + ((C - (nmax-1)*Wr) // Wb) * Hb \\n #if pm1>pmax:\\n # pmax = pm1\\n if Hr/Wr > Hb/Wb:\\n dx = dmax * (Hb/Wb) / (Hr/Wr - Hb/Wb) \\n elif Hr/Wr < Hb/Wb: \\n dx = 0 \\n else:\\n dx = Wb * Wr\\n if Wr<Wb:\\n nmax = (C // Wb)\\n pmax = nmax*Hb + ((C - nmax*Wb) // Wr) * Hr \\n if Wr>Wb:\\n nmax = (C // Wr)\\n pmax = nmax*Hr + ((C - nmax*Wr) // Wb) * Hb \\n \\n if Wr>Wb and dx>0: \\n for k in range(1,", "gt": "C//Wr):\\n if k*Wr > dx:\\n break\\n pk = (nmax-k)*Hr + ((C - (nmax-k)*Wr) // Wb) * Hb \\n dk = ((C - (nmax-k)*Wr) % Wb)\\n #print(k, pmax, pk, dk)\\n if pk>pmax:\\n pmax = pk\\n if dk==0 :\\n break\\n elif Wr<Wb and dx>0: \\n for j in range(1, C//Wb+1):\\n k = nmax - (C-j*Wb)//Wr\\n if k*Wr > dx:\\n break\\n \\n pk = (nmax-k)*Hr + ((C - (nmax-k)*Wr) // Wb) * Hb \\n dk = ((C - (nmax-k)*Wr) % Wb)\\n #print(j, k, pmax, pk, dk, (nmax-k), ((C - (nmax-k)*Wr) // Wb) )\\n if pk>pmax:\\n pmax = pk\\n #dmax = dk\\n if dk==0 :\\n break \\n \\n# elif Wr<Wb and dx>0: \\n# for j in range(1, C//Wb+1):\\n# k = (j*Wb - dmax)//Wr\\n# if k*Wr > dx:\\n# break\\n# pk = (nmax-k)*Hr + ((C - (nmax-k)*Wr) // Wb) * Hb \\n# dk = ((C - (nmax-k)*Wr) % Wb)\\n# print(j, k, pmax, pk, dk, (nmax-k), ((C - (nmax-k)*Wr) // Wb) )\\n# if pk>pmax:\\n# pmax = pk\\n# #dmax = dk\\n# if dk==0 :\\n# break\\n \\n print(pmax)"}
{"id": "203", "input": "a, b = map(int, input().split())\\nd, c =", "gt": "map(int, input().split())\\nprint(max(abs(a - d), abs(b - c)))"}
{"id": "204", "input": "n = int(input())\\ns = input()\\ncountr = s.count('R')\\ncountd = n - countr\\ncr = 0\\ncd = 0\\ni = 0\\nnews = []\\nwhile countr != 0 and countd != 0:\\n if s[i] == 'D':\\n if cd == 0:\\n cr += 1\\n countr -= 1\\n news.append('D')\\n else:\\n cd", "gt": "-= 1\\n else:\\n if cr == 0:\\n cd += 1\\n countd -= 1\\n news.append('R')\\n else:\\n cr -= 1\\n i += 1\\n if i >= n:\\n s = list(news)\\n news = []\\n n = len(s)\\n i = 0\\n \\nif countr > 0:\\n print('R')\\nelse:\\n print('D')"}
{"id": "205", "input": "def gcd(a, b):\\n while b:\\n a, b = b, a % b\\n return a\\n\\na, b, x,", "gt": "y = list(map(int, input().split()))\\n\\ng = gcd(x, y)\\nx //= g\\ny //= g\\n\\n\\nprint(min(a // x, b // y))\\n"}
{"id": "206", "input": "n, k = map(int, input().split())\\na = []\\ni = 2\\nwhile (i * i <= k):\\n if (k % i == 0):\\n a.append([i, 0])\\n while (k % i == 0):\\n a[len(a) - 1][1] += 1\\n k //= i\\n i", "gt": "+= 1\\nif (k > 1):\\n a.append([k, 1])\\nans = 10 ** 20\\nfor i in a:\\n cnt = 0\\n x = i[0]\\n while (x <= n):\\n cnt += n // x;\\n x *= i[0]\\n ans = min(ans, cnt // i[1])\\nprint(ans)"}
{"id": "207", "input": "import math\\nm,a,b=map(int,input().split())\\ng=math.gcd(a,b)\\na1=a//g\\nb1=b//g\\nalls=g*(a1+b1-1)\\ndists=[0]+[-1]*(a1+b1-1)\\ndist=0\\nfar=0\\nwhile dist!=b1:\\n if dist<b1:\\n dist+=a1\\n far=max(dist,far)\\n else:\\n dist-=b1\\n if dists[dist]==-1:\\n dists[dist]=far\\ntot=0\\nfor i", "gt": "in range(a1+b1):\\n if i*g<=m and dists[i]*g<=m:\\n tot+=(m+1-dists[i]*g)\\nif alls<m:\\n mod=m%g\\n times=m//g\\n diff=times-a1-b1\\n tot1=g*(diff*(diff+1)//2)+(mod+1)*(diff+1)\\n tot+=tot1\\nprint(tot)"}
{"id": "208", "input": "def read_ints():\\n return [int(i) for i in input().split()]\\n\\nn = read_ints()\\na = read_ints()\\nif", "gt": "len(a) % 2 and a[0] % 2 and a[-1] % 2:\\n print('Yes')\\nelse:\\n print('No')"}
{"id": "209", "input": "x1, y1, x2, y2 = map(int, input().split())\\n#diagonal\\nif x1 != x2 and y1 != y2:\\n if abs(x1 - x2) == abs(y1 - y2):\\n print(x1, y2, x2, y1)\\n else:\\n print(-1)\\n#same side\\nelif x1", "gt": "== x2:\\n aux = abs(y2 - y1)\\n print(x1 + aux, y1, x1 + aux, y2)\\nelif y1 == y2:\\n aux = abs(x2 - x1)\\n print(x1, y1 + aux, x2, y1 + aux)"}
{"id": "210", "input": "def main():\\n x, y = [int(i) for i in input().split()]\\n n = int(input())\\n \\n result = [x,", "gt": "y, y - x, -x, -y, x - y][(n - 1) % 6]\\n \\n print(result % 1000000007)\\n\\n\\nmain()\\n"}
{"id": "211", "input": "from sys import stdin\\n\\nn = int(input())\\na = [int(x) for x in input().split()]\\n\\nf = False\\nfor i in range(len(a)):\\n if a[i] != 0:\\n ln = i\\n f = True\\n break\\nif not f:\\n print('NO')\\nelse:\\n print('YES')\\n l = 0\\n i =", "gt": "ln + 1\\n ans = []\\n while i < len(a):\\n if a[i] == 0:\\n i += 1\\n else:\\n ans.append((l+1, i))\\n l = i\\n i += 1\\n if l < len(a):\\n ans.append((l+1, i))\\n print(len(ans))\\n for i in ans:\\n print(i[0],i[1])\\n\\n"}
{"id": "212", "input": "MOD = 1000000009\\n\\nn,m,k = [int(x) for x in input().split()]\\n\\nnum0 = n-m\\nnum1fin = num0*(k-1)\\nif", "gt": "num1fin >= m:\\n print(m)\\nelse:\\n num1open = m-num1fin\\n sets = num1open//k\\n rem = num1open%k\\n print(((pow(2,sets,MOD)-1)*2*k+rem+num1fin)%MOD)\\n"}
{"id": "213", "input": "n1 = input()\\nn = []\\nfor i in n1:\\n n.append(int(i))\\nk = len(n)\\n\\nfor i in range(k):\\n if (n[i] % 8) == 0:\\n print(\"YES\")\\n print(n[i])\\n return\\n\\nif k > 1:\\n for i in range(k):\\n t = n[i] * 10\\n for j in range(i+1, k):\\n if (t+n[j])", "gt": "% 8 == 0:\\n print(\"YES\")\\n print(t+n[j])\\n return\\nif k > 2:\\n for i in range(k):\\n t = n[i]*100\\n for j in range(i+1, k):\\n l = n[j]*10\\n for e in range(j+1, k):\\n #print(t, l, n[e])\\n if (t+l+n[e]) % 8 == 0:\\n print(\"YES\")\\n print(t+l+n[e])\\n return\\nprint(\"NO\")\\n"}
{"id": "214", "input": "def floo(num, k):\\n return (num - 1) // k + 1\\n\\ndef main():\\n n, m = map(int, input().split())\\n low = 1\\n high = 10**9\\n\\n if (m == 0):\\n if (n == 1):\\n print(1)\\n else:\\n print(-1)\\n return\\n\\n for i in range(m):\\n", "gt": "k, f = map(int, input().split())\\n low = max(low, (k + f - 1) // f)\\n if (f > 1):\\n high = min(high, (k - 1) // (f - 1))\\n if (floo(n, low) == floo(n, high)):\\n print(floo(n, low))\\n else:\\n print(-1)\\n\\n\\n\\nmain()"}
{"id": "215", "input": "f = []\\nfor i in range(2):\\n f.append(list(input()))\\n\\n\\nanswer = 0\\n\\nn = len(f[0])\\nfor i in range(n):\\n if f[0][i] == f[1][i] == '0' and i + 1 < n:\\n if f[0][i + 1] == '0':\\n answer += 1\\n f[0][i + 1] = 'X'\\n elif f[1][i + 1] ==", "gt": "'0':\\n answer += 1\\n f[1][i + 1] = 'X'\\n\\n elif (f[1][i] == '0' or f[0][i] == '0') and i + 1 < n and f[0][i + 1] == f[1][i + 1] == '0':\\n answer += 1\\n f[0][i + 1] = f[1][i + 1] = 'X'\\n\\n\\nprint(answer)\\n"}
{"id": "216", "input": "def list_input():\\n return list(map(int,input().split()))\\ndef map_input():\\n return map(int,input().split())\\ndef map_string():\\n return input().split()\\n \\nn = int(input()) \\na = list(input())\\nans = 0\\nfor i in range(n):\\n for", "gt": "j in range(i,n):\\n b = a[i:j+1]\\n for k in b:\\n if k.lower() != k:\\n break\\n else:\\n b = set(b)\\n ans = max(ans,len(b))\\nprint(ans)"}
{"id": "217", "input": "\\nn=int(input())\\narr= list(map(int,input().strip().split(' ')))\\ns =", "gt": "0\\nfor i in range(n):\\n s+=abs(arr[i])\\nprint(s)"}
{"id": "218", "input": "def list_input():\\n return list(map(int,input().split()))\\ndef map_input():\\n return map(int,input().split())\\ndef map_string():\\n return input().split()\\n \\na,b,f,k = map_input()\\ntot = a*k\\ns = 2*a-f\\ncur = 0\\ncnt = b\\ngo = 0\\nans = 0\\nwhile cur < tot:\\n go = 1-go\\n if(go == 1):\\n if cnt < s and cnt < tot-cur:\\n if(cnt < f):\\n print(-1)\\n break\\n cnt = b\\n", "gt": "ans += 1\\n cnt -= (a-f)\\n else: cnt -= a \\n else:\\n if cnt < a+f and cnt < tot-cur:\\n if(cnt < a-f):\\n print(-1)\\n break\\n cnt = b\\n ans += 1\\n cnt -= (f)\\n else:cnt -= a \\n cur += a\\n # print(cur,cnt,ans) \\n if(cnt < 0):\\n print(-1)\\n break\\nelse:\\n print(ans)"}
{"id": "219", "input": "a, b, c = map(int, input().split(' '))\\nx = input()\\nfor i in range(105):\\n for j in range(105):\\n if i*b+j*c ==", "gt": "a:\\n print(i+j)\\n for k in range(i):\\n print(x[:b])\\n x = x[b:]\\n for l in range(j):\\n print(x[:c])\\n x = x[c:]\\n quit()\\nprint(-1)"}
{"id": "220", "input": "n, m, s, d = list(map(int, input().split()))\\n\\nbeg = [float('-inf')]\\nend = [float('-inf')]\\n\\na = [int(i) for i in input().split()]\\n\\nfor x in sorted(a):\\n if (x - end[-1] > s + 1):\\n beg.append(x)\\n end.append(x)\\n else:\\n end[-1] = x\\n\\nlast = 0\\nR = []\\nJ = []\\n\\nfor i in range(1, len(beg)):\\n R.append(beg[i] - 1 - last)\\n last = (beg[i]", "gt": "- 1)\\n \\n J.append(end[i] + 1 - last)\\n last = (end[i] + 1)\\n\\nok = True\\nfor x in J:\\n if (x > d):\\n ok = False\\nfor x in R:\\n if (x < s):\\n ok = False\\n\\n\\nif ok:\\n for i in range(len(R)):\\n print('RUN', R[i])\\n print('JUMP', J[i])\\n if (last < m):\\n print('RUN', m - last)\\nelse:\\n print('IMPOSSIBLE')\\n"}
{"id": "221", "input": "s, x = list(map(int, input().split()))\\nrem = int(s == x) * 2\\np, t, cur = [], 0, 1\\nfor i in range(64):\\n if x % 2:\\n t += 1\\n s -= cur\\n", "gt": "else:\\n p.append(cur * 2)\\n cur *= 2\\n x //= 2\\nfor i in p[::-1]:\\n if s >= i: s -= i\\nans = 0 if s else 2 ** t - rem\\nprint(ans)\\n"}
{"id": "222", "input": "n, k = map(int, input().split())\\nif n <= k + k + 1:\\n print(1)\\n print((n + 1) // 2)\\nelse:\\n answer = -1\\n answer_n = 10**100\\n for i in range(min(k + 1, n)):\\n t = n - (k + i + 1)\\n if t % (k + k + 1) >= k + 1:\\n if 2 + t // (k + k + 1) < answer_n:\\n answer = i +", "gt": "1\\n answer_n = 2 + t // (k + k + 1)\\n if t % (k + k + 1) == 0:\\n if 1 + t // (k + k + 1) < answer_n:\\n answer = i + 1\\n answer_n = 1 + t // (k + k + 1) \\n print(answer_n)\\n while answer <= n:\\n print(answer, end = ' ')\\n answer += k + k + 1\\n"}
{"id": "223", "input": "ar=[]\\nfor i in range(1,10**5):\\n if(i*i>2*10**9):break\\n ar.append(i*i)\\ns=input()\\nans=len(s)\\nfor x in ar:\\n s2=str(x)\\n i=0\\n for", "gt": "x in range(len(s)):\\n if i<len(s2) and s[x]==s2[i]:\\n i+=1\\n if(i==len(s2)):\\n ans=min(ans,len(s)-i)\\nif(ans==len(s)):\\n print(-1)\\nelse:\\n print(ans)"}
{"id": "224", "input": "p=10**9+7\\nimport math\\ndef inv(k,p):\\n prod=1\\n while k>1:\\n prod*=(p//k+1)\\n k=(k*(p//k+1))%p\\n return prod%p\\nn=int(input())\\na=[]\\nk=int(math.log2(n))\\nx=n\\nwhile x>0:\\n y=x//2\\n a.append(x-y)\\n x=y\\nc=[sum(a[i:]) for i in range(k+1)]\\nb=[n//(3*2**i)-n//(6*2**i) for i in range(k+1)]\\nd=[n//2**i-n//(3*2**i) for i in range(k+1)]\\nfacs=[1]*(n+1)\\nfor i in range(2,n+1):\\n facs[i]=(i*facs[i-1])%p\\nif n<3*(2**(k-1)):\\n start=k\\nelse:\\n start=0\\ntot=0\\nfor j in range(start,k+1):\\n", "gt": "prod=1\\n for i in range(j,k):\\n prod*=b[i]\\n prod*=d[j]\\n for i in range(j):\\n prod*=a[i]\\n prod%=p\\n prod*=facs[n]\\n e=[a[i] for i in range(j)]+[d[j]]+[b[i] for i in range(j,k)]\\n f=[sum(e[:i+1]) for i in range(k+1)]\\n g=1\\n for guy in f:\\n g*=guy\\n prod*=inv(g,p)\\n prod%=p\\n tot+=prod\\nprint(tot%p)"}
{"id": "225", "input": "# You lost the game.\\n\\ns = str(input())\\nn = len(s)\\nd = -1\\nr = 0\\nV", "gt": "= \"AEIOUY\"\\nfor i in range(n):\\n if V.count(s[i]):\\n r = max(r,i-d)\\n d = i\\nprint(max(r, n-d))\\n"}
{"id": "226", "input": "l=list(map(int,input().split()))\\nfor i in range(16):\\n cur1,cur2=0,0\\n for j in range(4):\\n", "gt": "if (i&(1<<j))==0:\\n cur1+=l[j]\\n else:\\n cur2+=l[j]\\n if cur1==cur2:\\n print(\"YES\")\\n quit()\\nprint(\"NO\")"}
{"id": "227", "input": "n = int(input())\\na = list(map(int, input().split()))\\na = a[::-1]\\nd = 0\\nfor i in", "gt": "range(len(a)):\\n d = max(0 + d, a[i] + (sum(a[:i]) - d))\\nprint(sum(a)-d, d)\\n"}
{"id": "228", "input": "def Solve(x,B):\\n if((X,x,B) in Mem):\\n return Mem[(X,x,B)]\\n if(len(B)>X):\\n return False\\n if(x==len(L)):\\n return True\\n if(Form(L[x],B)):\\n A=list(B)\\n for e in range(len(B)):\\n r=A[e]\\n A[e]=L[x]\\n if(Solve(x+1,tuple(sorted(A)))):\\n Mem[(X,x,B)]=True\\n return True\\n A[e]=r\\n A+=[L[x]]\\n if(Solve(x+1,tuple(sorted(A)))):\\n Mem[(X,x,B)]=True\\n", "gt": "return True\\n Mem[(X,x,B)]=False\\n return False\\n\\ndef Form(x,B):\\n for i in range(len(B)):\\n for j in range(i,len(B)):\\n if(B[i]+B[j]==x):\\n return True\\n return False\\n \\nn=int(input())\\nL=list(map(int,input().split()))\\ndone=False\\nMem="}
{"id": "229", "input": "n=int(input())\\ns=list(map(int,input().split()))\\nprint(\"Bob\"if", "gt": "s.count(min(s))>n/2 else\"Alice\")\\n"}
{"id": "230", "input": "read = lambda: list(map(int, input().split()))\\nn = int(input())\\na = list(read())\\ns = set()\\nfor i in a:\\n s.add(i)\\nf1 = len(s) <", "gt": "3\\nf2 = len(s) == 3 and max(s) + min(s) == 2 * sorted(s)[1]\\nprint('YES' if f1 or f2 else 'NO')\\n"}
{"id": "231", "input": "n = int(input())\\ns = input()\\nj = 1\\nresult = []\\nfor i in range(n):\\n", "gt": "while (j < n-1) and (s[i:j] in s[j:]):\\n j += 1\\n result.append(j-i-1)\\nprint(max(result))"}
{"id": "232", "input": "n, a = list(map(int,input().split()))\\nif a % 2 == 1:\\n", "gt": "print(a // 2 + 1)\\nelse:\\n print((n-a) // 2 + 1)\\n"}
{"id": "233", "input": "s = input().split()\\nn, m = int(s[0]), int(s[1])\\ncl = list(map(int, input().split()))\\ncom = list(map(int, input().split()))\\nres = False\\nfor i in range(n):\\n for j in range(i, n):\\n e", "gt": "= True\\n t = cl[i:j+1]\\n for k in range(1, m+1):\\n e = t.count(k)==com[k-1] and e\\n if e:\\n res = True\\n break\\n \\nif res: print('YES')\\nelse: print('NO')"}
{"id": "234", "input": "x = 0\\ny = 0\\nfor _ in range(int(input())):\\n a, b = list(map(int, input().split()))\\n x += (a >", "gt": "b)\\n y += (b > a)\\nif x > y:\\n print(\"Mishka\")\\nelif y > x:\\n print(\"Chris\")\\nelse:\\n print(\"Friendship is magic!^^\")\\n"}
{"id": "235", "input": "r, c = list(map(int, input().split()))\\n\\nb = [list(input()) for i in range(r)]\\nfor y in range(r):\\n for x in range(c):\\n if b[y][x] == '.':\\n b[y][x] = '0'\\n\\nok = True\\nfor Y in range(r):\\n for X in range(c):\\n if not b[Y][X].isdigit():\\n continue\\n p = 0\\n for dy", "gt": "in range(-1, 2):\\n for dx in range(-1, 2):\\n y = Y + dy\\n x = X + dx\\n if 0 <= y < r and 0 <= x < c:\\n p += b[y][x] == '*'\\n if p != int(b[Y][X]):\\n ok = False\\n\\nprint([\"NO\", \"YES\"][ok])\\n"}
{"id": "236", "input": "def can(n, k):\\n total = n\\n s = 0\\n\\n while n > 0:\\n cur = min(n, k)\\n s += cur\\n n -= cur\\n\\n n -= n // 10\\n\\n return s *", "gt": "2 >= total\\n\\nn = int(input())\\n\\nle = 0\\nrg = n\\n\\nwhile rg - le > 1:\\n mid = (rg + le) // 2\\n\\n if can(n, mid):\\n rg = mid\\n else:\\n le = mid\\n\\nprint(rg)\\n"}
{"id": "237", "input": "def main():\\n s = input()\\n links = s.count('-')\\n pearls = s.count('o')\\n if", "gt": "pearls == 0 or links % pearls == 0:\\n print('YES')\\n else:\\n print('NO')\\n\\nmain()\\n"}
{"id": "238", "input": "n, m, k = map(int, input().split())\\nans = 1\\nm -= n\\nleft = k - 1\\nright = n - k\\n\\nput = 1\\nwhile (m >= put):\\n m -= put\\n ans += 1\\n put", "gt": "+= (left > 0) + (right > 0)\\n if (left): left -= 1\\n if (right): right -= 1\\n if (left == right == 0):\\n ans += (m // put)\\n break\\nprint(ans)"}
{"id": "239", "input": "N, M, K = list(map(int, input().split()))\\nA = [int(a) for a in input().split()]\\nS = [0]\\nfor a in A:\\n S.append(S[-1]+M*a-K)\\nMI = [(10**50)]", "gt": "* M\\nans = 0\\nfor i in range(N+1):\\n MI[i%M] = min(MI[i%M], S[i])\\n for j in range(M):\\n ans = max(ans, (S[i]-MI[(i-j)%M] - K*((-j)%M))//M)\\nprint(ans)\\n\\n"}
{"id": "240", "input": "import math\\nn, m = list(map(int, input().split()))\\nif n == 0 : \\n print(0, 1)\\n print(0, m)\\n print(0, 0)\\n print(0, m - 1)\\nelif m == 0 : \\n print(1, 0)\\n print(n, 0)\\n print(0, 0)\\n print(n - 1, 0)\\nelse :\\n l = math.sqrt((n - 1) ** 2 + m ** 2) + math.sqrt(n ** 2 + m ** 2) + math.sqrt(n ** 2 + (m - 1) ** 2)\\n l1 = max(m, n) + math.sqrt(n * n + m * m) * 2\\n l2 = math.sqrt(n ** 2 + m ** 2) + math.sqrt((n - 1) ** 2 + m ** 2)", "gt": "* 2\\n l3 = math.sqrt(n ** 2 + m ** 2) + math.sqrt((m - 1) ** 2 + n ** 2) * 2\\n ans = max(l, l1, l2, l3)\\n if l == ans :\\n print(1, 0)\\n print(n, m)\\n print(0, 0)\\n print(n, m - 1)\\n elif l1 == ans :\\n if n > m :\\n print(n, m)\\n print(0, 0)\\n print(n, 0)\\n print(0, m)\\n else :\\n print(n, m)\\n print(0, 0)\\n print(0, m)\\n print(n, 0)\\n elif l2 == ans :\\n print(1, 0)\\n print(n, m)\\n print(0, 0)\\n print(n - 1, m)\\n else :\\n print(0, 1)\\n print(n, m)\\n print(0, 0)\\n print(n, m - 1)\\n"}
{"id": "241", "input": "import math\\nfrom collections import Counter\\n\\ns = list(map(int, input()))\\nsubstr = input().rstrip()\\nt = list(map(int, substr))\\n\\nm = len(s)\\nx, y = 0, m\\nz = (x + y) // 2\\nwhile z != x:\\n if z + math.floor(math.log10(z)) + 1 <= m:\\n x = z\\n else:\\n y = z\\n z = (x + y)//2\\nm1 = z\\nk = math.floor(math.log10(m1)) + 1\\n\\nD = Counter(s)\\nD.subtract(list(map(int, str(m1))))\\nD.subtract(t)\\ntry:\\n c1 = min(i for i in range(1, 10) if D[i] > 0)\\n c2 = t[0]\\n\\n D[c1] -= 1\\n _prefix = [c1]\\n \\n for c in range(c2):\\n _prefix += [c]", "gt": "* D[c]\\n _suffix = []\\n for c in range(c2 + 1, 10):\\n _suffix += [c] * D[c]\\n num = ''.join([str(c2)] * D[c2])\\n prefix = ''.join(map(str, _prefix))\\n suffix = ''.join(map(str, _suffix))\\n\\n if c2 == 0:\\n print((min(prefix + substr + num + suffix,\\n prefix + num + substr + suffix)))\\n else:\\n D[c1] += 1\\n st = []\\n for c in range(10):\\n st += [c] * D[c]\\n print((min(prefix + substr + num + suffix,\\n prefix + num + substr + suffix,\\n substr + ''.join(map(str, st)))))\\nexcept ValueError:\\n print(substr + '0'*D[0])\\n"}
{"id": "242", "input": "def main():\\n n, m, mn, mx = map(int, input().split())\\n A = list(map(int, input().split()))\\n a = min(A)\\n b = max(A)\\n if a < mn or b > mx:\\n", "gt": "print(\"Incorrect\")\\n return\\n cnt = 0\\n if a > mn:\\n cnt += 1\\n if b < mx:\\n cnt += 1\\n if m + cnt <= n:\\n print(\"Correct\")\\n else:\\n print(\"Incorrect\")\\n\\nmain()"}
{"id": "243", "input": "m = int(input())\\na = 0\\nwhile m > 0:\\n a += 5\\n b = a\\n c = 0\\n while b % 5 == 0:\\n b //=", "gt": "5\\n c += 1\\n m -= c\\nif m < 0: print(0)\\nelse:\\n print(5)\\n print(a, a + 1, a + 2, a + 3, a + 4)\\n"}
{"id": "244", "input": "def g():\\n return list(map(int,input().split()))\\nn,m,k=g()\\np=list(range(n+1))\\nz=[0]*(n+1)\\nfor x in g():\\n z[x]=1\\ne=[]\\nfor i in range(m):\\n u,v,w=g()\\n e+=[(w,u,v)]\\ne=sorted(e)\\ndef q(x):\\n if x!=p[x]:\\np[x]=q(p[x])\\n return p[x]\\nfor w,u,v in e:\\n u=q(u);v=q(v)\\n if u!=v:\\n if", "gt": "u%5==3:\\n u,v=v,u\\n p[u]=v;"}
{"id": "245", "input": "def main():\\n n = int(input())\\n k = int(input())\\n n %= 6\\n a = [0, 1, 2]\\n for i in range(1,", "gt": "n + 1):\\n if (i % 2 == 1):\\n a[0], a[1] = a[1], a[0]\\n else:\\n a[1], a[2] = a[2], a[1]\\n print(a[k])\\n\\n\\nmain()"}
{"id": "246", "input": "n = int(input())\\ns = 0\\nINF = 10**9\\nminx = miny = INF\\nmaxx = maxy = -INF\\n\\nfor i in range(n):\\n x1, y1, x2, y2 = list(map(int, input().split()))\\n s += abs(x1 - x2) * abs(y1 - y2)\\n minx =", "gt": "min(minx, x1, x2)\\n maxx = max(maxx, x1, x2)\\n miny = min(miny, y1, y2)\\n maxy = max(maxy, y1, y2)\\n\\nif (maxx - minx) == (maxy - miny) and s == (maxx - minx) ** 2:\\n print (\"YES\")\\nelse:\\n print (\"NO\")\\n"}
{"id": "247", "input": "def check(x, s):\\n k = 0\\n for i in str(x):\\n k += int(i)\\n return x - k >= s\\n\\n\\nn, s = map(int, input().split())\\nl = 0\\nr = n\\nwhile r", "gt": "- l > 1:\\n m = (l + r) // 2\\n if check(m, s):\\n r = m\\n else:\\n l = m\\nif check(r, s):\\n print(n - r + 1)\\nelse:\\n print(0)"}
{"id": "248", "input": "n = int(input())\\nL = [(0, 0)] * n\\nfor i in range(n):\\n t = input().split(' ')\\n a = int(t[0])\\n b = int(t[1])\\n L[i] = (a, b)\\nif n <= 4:\\n print(\"YES\")\\nelse:\\n b0 = True\\n b1 = True\\n b2 = True\\n L0 = []\\n L1 = []\\n L2 = []\\n for j in range(n):\\n if (L[0][0]-L[1][0])*(L[0][1]-L[j][1])!=(L[0][1]-L[1][1])*(L[0][0]-L[j][0]):\\n L2.append(L[j])\\n if", "gt": "(L[2][0]-L[0][0])*(L[2][1]-L[j][1])!=(L[2][1]-L[0][1])*(L[2][0]-L[j][0]):\\n L1.append(L[j])\\n if (L[2][0]-L[1][0])*(L[2][1]-L[j][1])!=(L[2][1]-L[1][1])*(L[2][0]-L[j][0]):\\n L0.append(L[j])\\n if len(L0) >= 3:\\n for j in range(2, len(L0)):\\n if (L0[0][0]-L0[1][0])*(L0[0][1]-L0[j][1])!=(L0[0][1]-L0[1][1])*(L0[0][0]-L0[j][0]):\\n b0 = False\\n if len(L1) >= 3:\\n for j in range(2, len(L1)):\\n if (L1[0][0]-L1[1][0])*(L1[0][1]-L1[j][1])!=(L1[0][1]-L1[1][1])*(L1[0][0]-L1[j][0]):\\n b1 = False\\n if len(L2) >= 3:\\n for j in range(2, len(L2)):\\n if (L2[0][0]-L2[1][0])*(L2[0][1]-L2[j][1])!=(L2[0][1]-L2[1][1])*(L2[0][0]-L2[j][0]):\\n b2 = False\\n if b0 or b1 or b2:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n"}
{"id": "249", "input": "mod=10**9+7\\nf=[0]*500000\\n\\ndef POW(a,b):\\n if(b==0):\\n return 1\\n if(b&1):\\n return POW(a,b//2)**2*a%mod\\n else:\\n return POW(a,b//2)**2\\n\\ndef C(n,m):\\n if(m>n):\\n return", "gt": "0\\n t=f[n]*POW(f[m],mod-2)%mod*POW(f[n-m],mod-2)%mod\\n return t\\n\\n\\nf[0]=1\\nfor i in range(1,500000):\\n f[i]=f[i-1]*i%mod\\na,b,k,t=list(map(int,input().split(' ')))\\n\\nans=0\\nfor i in range(0,2*t+1):\\n t1=POW(-1,i)*C(2*t,i)%mod\\n t2=(C(210000+2*k*t-a+b+2*t-1-(2*k+1)*i+1,2*t)-C(1+2*k*t-a+b+2*t-1-(2*k+1)*i,2*t))%mod\\n ans=(ans+t1*t2)%mod\\nprint(ans)\\n"}
{"id": "250", "input": "import itertools\\nimport math\\n\\ndef can_measure(a, d):\\n return any(i + d in a for i in a)\\n\\ndef main():\\n n, l, x, y = list(map(int, input().split()))\\n a = set(map(int, input().split()))\\n \\n can_x = can_measure(a, x)\\n can_y = can_measure(a, y)\\n if can_x and can_y:\\n print(0)\\n elif can_x:\\n print(1)\\n print(y)\\n elif can_y:\\n print(1)\\n print(x)\\n else:\\n for i in a:\\n if i +x + y in a:\\n print(1)\\n print(i + x)\\n break\\n else:\\n t = i + x - y in a\\n if 0 <= i + x <= l and t:\\n print(1)\\n print(i + x)\\n break;\\n if 0 <= i - y <=", "gt": "l and t:\\n print(1)\\n print(i - y)\\n break;"}
{"id": "251", "input": "import math\\nfrom functools import reduce\\nclass SegmentTree():\\n def __init__(self, L, function = lambda x,y: x+y):\\n self.function = function\\n N = self.size = len(L)\\n M = 1 << N.bit_length()\\n self.margin = 2*M - N\\n self.L = [None for i in range(self.margin)] + L\\n for i in range(M-1, 0, -1):\\n x, y = self.L[i<<1], self.L[i<<1|1]\\n self.L[i] = None if x is None or y is None else function(x, y)\\n def modify(self, pos, value):\\n p = pos + self.margin\\n self.L[p] = value \\n while p > 1:\\n x, y = self.L[p], self.L[p^1]\\n if p&1: x, y = y, x\\n self.L[p>>1] = None if x is None or y is None else self.function(x, y)\\n p>>=1\\n def query(self, left, right):\\n l, r = left", "gt": "+ self.margin, right + self.margin\\n stack = []\\n void = True\\n while l < r:\\n if l&1:\\n if void:\\n result = self.L[l]\\n void = False\\n else:\\n result = self.function(result, self.L[l])\\n l+=1\\n if r&1:\\n r-=1\\n stack.append(self.L[r])\\n l>>=1\\n r>>=1\\n init = stack.pop() if void else result\\n return reduce(self.function, reversed(stack), init)\\n\\nn = int(input())\\npies, index, first_equal = [0]*n, [0]*n, [0]*n\\nfor i in range(n):\\n r, h = [int(x) for x in input().split()]\\n pies[i] = r*r*h\\ns_pies = list(sorted(enumerate(pies), key = lambda p: p[1]))\\nfor i in range(n): index[s_pies[i][0]] = i\\nfor i in range(1, n):\\n first_equal[s_pies[i][0]] = i if s_pies[i][1] != s_pies[i-1][1] else first_equal[s_pies[i-1][0]]\\ntowers = SegmentTree([0]*(n+1), max)\\nfor j, pie in enumerate(pies):\\n i, k = index[j], first_equal[j]\\n q = towers.query(0, k+1)\\n towers.modify(i+1, q + pie)\\nprint(math.pi * towers.query(0, n+1))\\n"}
{"id": "252", "input": "def ii():\\n return int(input())\\ndef mi():\\n return list(map(int, input().split()))\\ndef li():\\n return list(mi())\\n\\nn, k = mi()\\nh = li()\\nm = max(h)\\nf = [0] * (m + 1)\\nfor hi in h:\\n f[hi] += 1\\nfor i in range(m - 1, 0, -1):\\n f[i] += f[i +", "gt": "1]\\n\\nans = 0\\ni = m\\nwhile i > 0:\\n if f[i] == n:\\n break\\n j = i\\n cur = 0\\n while j > 0:\\n if cur + f[j] > k:\\n break\\n cur += f[j]\\n j -= 1\\n ans += 1\\n i = j\\nprint(ans)\\n"}
{"id": "253", "input": "n = int(input())\\nl = list(map(int,input().split()))\\n\\ncurr = 0\\nbest = 0\\nprevs = [0] * 31\\nfor v in l:\\n curr += v\\n if v >= 0:\\n for i in", "gt": "range(0, v):\\n prevs[i] = curr\\n for i in range(v, 31):\\n best = max(curr - prevs[i] - i, best)\\n else:\\n for i in range(31):\\n prevs[i] = min(prevs[i], curr)\\nprint(best)\\n"}
{"id": "254", "input": "a, b, c = sorted(map(int, input().split()))\\nif a > 3:\\n print('NO')\\nelif a == 3:\\n if b > 3:\\n print('NO')\\n elif b == 3:\\n if c > 3:\\n print('NO')\\n else:\\n", "gt": "print(\"YES\")\\nelif a == 1:\\n print('YES')\\nelse:\\n if b == 2:\\n print('YES')\\n elif b > 4:\\n print('NO')\\n elif b == 4:\\n if c == 4:\\n print('YES')\\n else:\\n print('NO')\\n else:\\n print('NO')"}
{"id": "255", "input": "#credits https://www.geeksforgeeks.org/minimum-steps-to-delete-a-ssing-after-repeated-deletion-of-palindrome-subssings/\\n \\nn=int(input())\\ns=input()\\nN = len(s)\\ndp = [[0 for x in range(N + 1)] \\n for y in range(N + 1)]\\nD = [[[] for x in range(N + 1)] \\n for y in range(N + 1)]\\nss=\"\"\\nre=\"\"\\nfor i in range(0,N):\\n if re!=s[i]:\\n ss+=re\\n re=s[i]\\nss+=re\\na=ss\\nN=len(a)\\nfor l in range(1, N + 1): \\n i = 0\\n j = l - 1\\n while", "gt": "j < N: \\n if (l == 1): \\n dp[i][j] = 1\\n else: \\n\\n dp[i][j] =1+dp[i + 1][j]\\n\\n for K in range(i + 1, j + 1): \\n if (a[i] == a[K]):\\n if dp[i][j]>=dp[i ][K - 1] + dp[K + 1][j]:\\n dp[i][j] = dp[i][K - 1] + dp[K + 1][j]\\n\\n \\n \\n i += 1\\n j += 1\\n\\nprint(dp[0][N-1])\\n\\n"}
{"id": "256", "input": "n=int(input())\\na=sorted(map(int,input().split()))\\nm=int(input())\\nb=sorted(map(int,input().split()))\\nc=0\\nfor i in range(n):\\n for j in", "gt": "range(m):\\n if abs(a[i]-b[j]) <= 1:\\n b[j]=-10\\n c+=1\\n break\\nprint(c)"}
{"id": "257", "input": "a,b=list(map(int,input().split()))\\nc,d=list(map(int,input().split()))\\n\\n\\nx,y=list(map(int,input().split()))\\nz,w=list(map(int,input().split()))\\n\\n\\nTeam1=False\\nTeam2=False\\nif(a>w and a>y and d>x and d>z):\\n Team1=True\\n\\nif(c>w and c>y and b>x and b>z):\\n Team1=True\\n\\nif(((x>b and w>c)", "gt": "or (z>b and y>c)) and ((x>d and w>a) or (z>d and y>a))):\\n Team2=True\\n\\n\\nif(Team1):\\n print(\"Team 1\")\\nelif(Team2):\\n print(\"Team 2\")\\nelse:\\n print(\"Draw\")\\n"}
{"id": "258", "input": "import sys\\nfrom itertools import combinations\\nfrom math import sqrt\\nimport numpy as np\\n\\nread = sys.stdin.read\\nreadline = sys.stdin.readline\\n\\n\\ndef main():\\n N, K, *xyc = list(map(int, read().split()))\\n x = xyc[::3]\\n y = xyc[1::3]\\n xy = list(zip(x, y))\\n c = xyc[2::3]\\n left = 0\\n right = 10 ** 6\\n delta = 0.1 ** 7\\n while right - left > delta:\\n mid = (left + right) / 2\\n intersections = []\\n r = [(mid / i) ** 2 for i in c]\\n for i, j in combinations(list(range(N)), 2):\\n x1, y1 = xy[i]\\n x2, y2 = xy[j]\\n X = x2 - x1\\n Y = y2 - y1\\n XY = X ** 2 + Y ** 2\\n r1 = r[i]\\n r2 = r[j]\\n\\n a = (XY + r1 - r2) / 2\\n b", "gt": "= XY * r1 - a ** 2\\n if b < delta:\\n continue\\n b = sqrt(b)\\n xi1 = (a * X + Y * b) / XY + x1\\n yi1 = (a * Y - X * b) / XY + y1\\n xi2 = (a * X - Y * b) / XY + x1\\n yi2 = (a * Y + X * b) / XY + y1\\n intersections.append((xi1, yi1))\\n intersections.append((xi2, yi2))\\n\\n intersections.extend(xy)\\n intersections = np.array(intersections, np.float)\\n cnt = np.zeros(len(intersections), np.int64)\\n\\n for (i, j), k in zip(xy, r):\\n XY = (intersections[:, 0] - i) ** 2 + (intersections[:, 1] - j) ** 2\\n cnt[XY < k + delta] += 1\\n\\n if np.any(cnt >= K):\\n right = mid\\n else:\\n left = mid\\n\\n print(right)\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "259", "input": "n=int(input())\\ns=input()\\nleft=0\\nright=0\\nleft_ques=0\\nright_ques=0\\nfor i in range(n):\\n if i<n//2:\\n if s[i]=='?':\\n left_ques+=1\\n else :\\n left+=int(s[i])\\n else :\\n if s[i]=='?':\\n right_ques+=1\\n else :\\n right+=int(s[i])\\nx=min(left_ques,right_ques)\\nleft_ques-=x\\nright_ques-=x\\nif left_ques==0 and right_ques==0:\\n if left==right:\\n print(\"Bicarp\")\\n else :\\n print(\"Monocarp\")\\nelse", "gt": ":\\n if left_ques==0:\\n if right_ques%2==0:\\n x=9*(right_ques//2)+right\\n if x==left:\\n print(\"Bicarp\")\\n else :\\n print(\"Monocarp\")\\n else :\\n print(\"Monocarp\")\\n else :\\n if left_ques%2==0:\\n x=9*(left_ques//2)+left\\n if x==right:\\n print(\"Bicarp\")\\n else :\\n print(\"Monocarp\")\\n else :\\n print(\"Monocarp\")"}
{"id": "260", "input": "# AC\\nimport sys\\n\\n\\nclass Main:\\n def __init__(self):\\n self.buff = None\\n self.index = 0\\n\\n def __next__(self):\\n if self.buff is None or self.index == len(self.buff):\\n self.buff = sys.stdin.readline().split()\\n self.index = 0\\n val = self.buff[self.index]\\n self.index += 1\\n return val\\n\\n def next_int(self):\\n return int(next(self))\\n\\n def cal(self, s):\\n if len(s) == 1:\\n return s[0]\\n if s[0] == 0:\\n return self.cal(s[1:])\\n v = 1\\n for c in s:\\n", "gt": "v *= c\\n return v\\n\\n def solve(self):\\n n = self.next_int()\\n t = self.next_int()\\n ii = 0\\n tt = 10000000\\n for i in range(0, n):\\n fr = self.next_int()\\n d = self.next_int()\\n if fr < t:\\n fr += (t - fr + d - 1) // d * d\\n if fr < tt:\\n tt = fr\\n ii = i\\n print(ii + 1)\\n\\n\\ndef __starting_point():\\n Main().solve()\\n\\n__starting_point()"}
{"id": "261", "input": "def nck(n, k, cache = {}):\\n if k > n or k < 0: return 0\\n if k == 0 or k == n: return 1\\n if k*2 > n: k = n-k\\n if (n, k) in cache: return cache[(n, k)]\\n\\n z = cache[(n, k)] = nck(n-1, k-1) + nck(n-1, k)\\n return z\\n\\ndef bits(n):\\n b = 0\\n while n:\\n if n&1: b += 1\\n n >>= 1\\n return b\\n\\ndef count(n,", "gt": "k):\\n z, b, c = 0, 63, 0\\n for b in reversed(range(64)):\\n if (n>>b)&1:\\n z += nck(b, k-c)\\n c += 1\\n if not k: break\\n return z + (bits(n) == k)\\n\\ndef solve(m, k):\\n lo, hi = 1, 10**18\\n while lo < hi:\\n mi = (lo+hi)//2\\n if count(2*mi, k) - count(mi, k) < m:\\n lo = mi+1\\n else:\\n hi = mi\\n return hi\\n\\nm, k = [int(x) for x in input().split()]\\nprint(solve(m, k))"}
{"id": "262", "input": "kk=0\\nx = int(input())\\ny = input()\\nz = [i for i in range(len(y)) if y[i] == '*']\\nfor i in range(0, 100):\\n for j in range(1, 100):\\n", "gt": "if i in z and i+j in z and i+2*j in z and i+3*j in z and i+4*j in z:\\n kk=1\\nif kk==1:\\n print(\"yes\")\\nelse:\\n print(\"no\")\\n"}
{"id": "263", "input": "#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n\\ndef func():\\n N = int(input())\\n cells = [0] * N\\n\\n if N == 1:\\n return 1\\n\\n mx = 0\\n for n in range(N):\\n cells[n] = list(map(int,input().split()))\\n mx = max(mx, sum(cells[n]))\\n\\n ans = None\\n for j in range(N):\\n for i in range(N):\\n if cells[j][i] == 0:\\n ans = mx - sum(cells[j])\\n cells[j][i]", "gt": "= ans\\n if ans <= 0:\\n return -1\\n\\n # validation\\n for j in range(N):\\n if sum(cells[j]) != mx:\\n return -1\\n for i in range(N):\\n if mx != sum([cells[j][i] for j in range(N)]):\\n return -1\\n if mx != sum([cells[j][j] for j in range(N)]):\\n return -1\\n if mx != sum([cells[j][N-1-j] for j in range(N)]):\\n return -1\\n \\n return ans\\n\\nprint(func())\\n\\n"}
{"id": "264", "input": "n = int(input())\\nm = int(input())\\na = []\\nfor i in range(n):\\n a.append(int(input()))\\n\\nmx = max(a) + m\\n\\n\\n\\nwhile m:\\n", "gt": "for i in range(n):\\n if a[i] == min(a):\\n a[i] += 1\\n m -= 1\\n break\\n\\nprint(max(a), mx)\\n"}
{"id": "265", "input": "MOD = 10 ** 9 + 7\\nn, m = input().split(' ')\\nn = int(n)\\nm = int(m)\\nans = pow(2 * (n + 1), m,", "gt": "MOD)\\nans = (ans * (n + 1 - m)) % MOD\\nans = (ans * pow(n + 1, MOD - 2, MOD)) % MOD\\nprint(ans)\\n"}
{"id": "266", "input": "# author: ThePonyCoder\\n# created: 23.06.2019, 21:58\\n# filename: f.py\\n# path: C:/Users/User/Desktop/python/Prog/CodeForces/rounds/cf_568/f.py\\n\\nimport os\\n\\n# import random\\n\\n# sys.setrecursionlimit(999999999)\\nimport string\\n\\nfrom math import inf\\nfrom functools import lru_cache\\n\\nif os.getcwd() == 'C:\\\\Users\\\\User\\\\Desktop\\\\python\\\\Prog\\\\CodeForces' \\\\n or os.environ['COMPUTERNAME'] == 'USER145':\\n import pdb\\n \\n import sys\\n \\n pdb = pdb.Pdb(stdin=sys.stdin, stdout=sys.stdout)\\n sys.stdin = open('input.txt', 'r')\\n sys.stdout = open('output.txt', 'w')\\n from pprint import pprint\\n from hypothesis import given, settings\\n from hypothesis import strategies as st\\n\\n\\ndef ri():\\n return [int(i) for i in input().split()]\\n\\n\\ndef to_bits(l):\\n ans = 0\\n for i in l:\\n ans |= (1 << i - 1)\\n return ans\\n\\n\\nuser_masks = [0 for i in range(1 << 10)]\\npizzas = [[] for i in range(1 << 10)]\\n\\n\\n@lru_cache()\\ndef count_sat_users(mask):\\n ans = 0\\n cmask = mask\\n while cmask:\\n ans += user_masks[cmask]\\n cmask = (cmask - 1) & mask\\n return ans\\n\\n\\ndef main():\\n n, m = ri()\\n for _ in range(n):\\n k, *a = ri()\\n bits = to_bits(a)\\n user_masks[bits] += 1\\n \\n ans = (float(-inf), float(inf), -1, -1)\\n \\n for i in range(m):\\n c, k, *a = ri()\\n bits = to_bits(a)\\n pizzas[bits].append((c, i + 1,", "gt": "bits)) # цена, номер, маска\\n pizzas[bits].sort()\\n while len(pizzas[bits]) > 2:\\n pizzas[bits].pop()\\n # pprint(pizzas)\\n \\n for mask_F in range(1 << 9):\\n for mask_S in range(1 << 9):\\n if len(pizzas[mask_F]) and len(pizzas[mask_S]) \\\\n and mask_F != mask_S:\\n \\n mask = mask_F | mask_S\\n \\n satisfied_users = count_sat_users(mask)\\n \\n f_pizza = next(iter(pizzas[mask_F]))\\n s_pizza = next(iter(pizzas[mask_S]))\\n \\n summary_cost = 0\\n summary_cost += f_pizza[0]\\n summary_cost += s_pizza[0]\\n \\n ans = max(ans,\\n (satisfied_users,\\n -summary_cost,\\n s_pizza[1],\\n f_pizza[1]))\\n \\n # bruting all masks\\n bmask = mask\\n while bmask:\\n satisfied_users += user_masks[bmask]\\n bmask = (bmask - 1) & mask\\n \\n if len(pizzas[mask_F]) == 2:\\n satisfied_users = count_sat_users(mask_F)\\n \\n it = iter(pizzas[mask_F])\\n \\n f_pizza = next(it)\\n s_pizza = next(it)\\n summary_cost = 0\\n summary_cost += f_pizza[0] + s_pizza[0]\\n ans = max(ans,\\n (satisfied_users,\\n -summary_cost,\\n s_pizza[1],\\n f_pizza[1]))\\n \\n if len(pizzas[mask_S]) == 2:\\n satisfied_users = count_sat_users(mask_S)\\n \\n it = iter(pizzas[mask_S])\\n \\n f_pizza = next(it)\\n s_pizza = next(it)\\n summary_cost = 0\\n summary_cost += f_pizza[0] + s_pizza[0]\\n ans = max(ans,\\n (satisfied_users,\\n -summary_cost,\\n s_pizza[1],\\n f_pizza[1]))\\n \\n aans = [ans[2],ans[3]]\\n aans.sort()\\n print(*aans, sep=' ')\\n\\n\\nmain()\\n"}
{"id": "267", "input": "M,S=list(map(int,input().split()))\\n\\nif S==0 and M==1:\\n print('0 0')\\n return\\nelif S==0 or M*9 < S:\\n print('-1 -1')\\n return\\n\\nm,s=M,S\\nl=[]\\nif s<=(m-1)*9+1:\\n l.append(1)\\n s-=1\\nwhile len(l)<m:\\n r =", "gt": "(m-len(l)-1)*9\\n if s<=r:\\n l.append(0)\\n else:\\n l.append(s-r)\\n s-=s-r\\n\\nm,s=M,S\\nh=[]\\nwhile s>=9:\\n h.append(9)\\n s-=9\\nwhile len(h)<m:\\n h.append(s)\\n s=0\\n\\nprint(''.join(repr(x) for x in l), ''.join(repr(x) for x in h))\\n\\n"}
{"id": "268", "input": "\\n\\n\\nl, r, k =list(map(int,input().split()))\\n\\nd = {i:2**i for i in range(10)}\\n\\ncache = {}\\n\\ndef can(i, m):\\n return d[i] & m\\n\\ndef calc(m):\\n b = 1\\n c = 0\\n for i in range(10):\\n if b & m:\\n c += 1\\n b *= 2\\n\\n return c\\n\\ndef sm(ln, k, m, s='', first=False):\\n if ln < 1:\\n return 0, 1\\n\\n if (ln, k, m, s, first) in cache:\\n return cache[(ln, k, m, s, first)]\\n\\n ans = 0\\n count = 0\\n base = 10 ** (ln-1)\\n\\n use_new = calc(m) < k\\n\\n if s:\\n finish = int(s[0])+1\\n else:\\n finish = 10\\n\\n for i in", "gt": "range(finish):\\n if use_new or can(i, m):\\n ss = s[1:]\\n if i != finish-1:\\n ss = ''\\n nm = m | d[i]\\n nfirst = False\\n if i == 0 and first:\\n nm = m\\n nfirst = True\\n nexta, nextc = sm(ln-1, k, nm, ss, nfirst)\\n ans += base * i * nextc + nexta\\n count += nextc\\n\\n# print(ln, k, m, s, first, ans, count)\\n cache[(ln, k, m, s, first)] = (ans, count)\\n\\n return ans, count\\n\\ndef call(a, k):\\n s = str(a)\\n return sm(len(s), k, 0, s, True)[0]\\n\\n\\n#print(call(r, k) - call(l-1, k))\\nprint((call(r, k) - call(l-1, k)) % 998244353)\\n"}
{"id": "269", "input": "#!/usr/bin/env python3\\n\\nfrom bisect import bisect\\n\\n[n, k, d] = list(map(int, input().strip().split()))\\nais = list(map(int, input().strip().split()))\\nif k == 1:\\n print ('YES')\\n return\\n\\nais.sort()\\n\\n# can do ais[i:]\\ncando = [False for _ in range(n)]\\nj = n - 1 # j is such that a[j] > a[i] + d >= a[j - 1] (upper_bound) a[:j] <= a[i] + d < a[j:]\\ncount = 0 # sum(cando[i + k:j +", "gt": "1])\\nfor i in reversed(list(range(n))):\\n if i + k < n and cando[i + k]:\\n count += 1\\n if n - i < k:\\n continue\\n if ais[-1] - ais[i] <= d:\\n cando[i] = True\\n continue\\n while ais[j - 1] > ais[i] + d:\\n if cando[j]:\\n count -= 1\\n j -= 1\\n cando[i] = (count > 0)\\n \\n\\nif cando[0]:\\n print ('YES')\\nelse:\\n print ('NO')\\n\\n"}
{"id": "270", "input": "s = input()\\nn = len(s)\\nt = 'RBYG'\\nfor i in t:\\n ind = s.find(i) % 4\\n ans", "gt": "= 0\\n while ind < n:\\n ans += s[ind] == '!'\\n ind += 4\\n print(ans, end=' ')\\n"}
{"id": "271", "input": "n, m = list(map(int, input().split()))\\nedges_from = [[] for _ in range(n)]\\nedges_to = [[] for _ in range(n)]\\n\\nfor _ in range(m):\\n _from, to = [int(x)-1 for x in input().split()]\\n edges_from[_from].append(to)\\n\\nE_dist_to_goal = [0] * n\\nP_of_reaching = [0] * n\\nP_of_reaching[0] = 1\\n\\nfor v in range(n-2, -1, -1):\\n routes = edges_from[v]\\n for next_v in routes:\\n E_dist_to_goal[v] += E_dist_to_goal[next_v] + 1\\n E_dist_to_goal[v] /= len(routes)\\n\\nfor v in range(n-1):\\n P_now = P_of_reaching[v]\\n", "gt": "routes = edges_from[v]\\n P_next = P_now / len(routes)\\n for next_v in routes:\\n P_of_reaching[next_v] += P_next\\n\\ninitial_ans = E_dist_to_goal[0]\\nanswers = [initial_ans]\\nfor v in range(n-2):\\n routes = edges_from[v]\\n num_of_routes = len(routes)\\n if num_of_routes == 1:\\n continue\\n not_cut_dist = E_dist_to_goal[v]\\n longest_dist = max([E_dist_to_goal[next_v]+1 for next_v in routes])\\n after_cut_dist = (not_cut_dist - longest_dist/num_of_routes) * num_of_routes / (num_of_routes-1)\\n delta = not_cut_dist - after_cut_dist\\n candidate = initial_ans - delta * P_of_reaching[v]\\n answers.append(candidate)\\n\\nprint((min(answers)))\\n"}
{"id": "272", "input": "import math\\n\\nn = int(input())\\nprint(10", "gt": "* round(n / 10))"}
{"id": "273", "input": "a = input()\\nb = input()\\n\\nsymbols = {}\\npairs = []\\n\\nfor i in range(len(a)):\\n if a[i] in symbols:\\n if symbols[a[i]] != b[i]:\\n print('-1')\\n break\\n elif b[i] in symbols:\\n", "gt": "if symbols[b[i]] != a[i]:\\n print('-1')\\n break\\n else:\\n symbols[a[i]] = b[i]\\n symbols[b[i]] = a[i]\\n if a[i] != b[i]:\\n pairs.append((a[i], b[i]))\\nelse:\\n print(len(pairs))\\n for elem in pairs:\\n print(elem[0], elem[1])"}
{"id": "274", "input": "from collections import *\\nimport itertools\\nimport sys\\n\\ndef main():\\n a, b = input().split()\\n ans = a + b\\n n = len(a)\\n m = len(b)\\n for i", "gt": "in range(1, n + 1):\\n for j in range(1, m + 1):\\n c = a[:i] + b[:j]\\n # print(c)\\n ans = min(ans, c)\\n print(ans)\\n\\nmain()\\n"}
{"id": "275", "input": "n = int(input())\\nx = input()\\nd = [0] * n\\ncd = 0\\nxp = []\\nfor i in range(n):\\n if x[i] == '[':\\n d[i] = cd\\n cd = cd + 1\\n else:\\n cd = cd - 1\\n d[i] = cd\\nfor i in range(n-1):\\n xp.append((x[i], d[i]))\\n if x[i] == '[' and x[i+1] == ']':\\n xp.extend([(' ', d[i]), (' ', d[i]), (' ', d[i])])\\nxp.append((x[n-1], d[n-1]))\\nmd = max(d)\\nh = md * 2 + 3\\nres = []\\nfor i in range(h):\\n l = [' ' for j in xp]\\n res.append(l)\\nfor i in range(len(xp)):\\n for j", "gt": "in range(h):\\n if xp[i][0] == '[' and j > xp[i][1] and j < h - xp[i][1] - 1:\\n res[j][i] = '|'\\n elif xp[i][0] == ']' and j > xp[i][1] and j < h - xp[i][1] - 1:\\n res[j][i] = '|'\\n elif xp[i][0] == '[' and (j == xp[i][1] or j == h - xp[i][1] - 1):\\n res[j][i] = '+'\\n res[j][i+1] = '-'\\n elif xp[i][0] == ']' and (j == xp[i][1] or j == h - xp[i][1] - 1):\\n res[j][i] = '+'\\n res[j][i-1] = '-'\\n\\nfor i in range(h):\\n print(''.join(res[i]))\\n\\n"}
{"id": "276", "input": "u = v = 0\\na, b = input(), input()\\nn, m = len(a), len(b)\\nif n > m: b = '0' * (n - m) + b\\nelse: a = '0' * (m - n) + a\\nfor i in range(max(n, m)):\\n u, v = v + u, u + int(a[i]) - int(b[i])\\n if u > 1:\\n", "gt": "print('>')\\n return\\n elif u < -1:\\n print('<')\\n return\\nd = 2 * v + u\\nif u == v == 0: print('=')\\nelif u >= 0 and d >= 0: print('>')\\nelif u <= 0 and d <= 0: print('<')\\nelse: print('>' if (u * u > v * (v + u)) ^ (u < 0) else '<')"}
{"id": "277", "input": "n = int(input())\\na = [input() for i in range(n)]\\nsol = []\\nfor i in range(6):\\n c = ['purple', 'green',", "gt": "'blue', 'orange', 'red', 'yellow'][i]\\n if c not in a:\\n sol.append(['Power', 'Time', 'Space', 'Soul', 'Reality', 'Mind'][i])\\nprint(len(sol))\\nfor i in sol:\\n print(i)\\n"}
{"id": "278", "input": "import sys\\nn, a, b = list(map(int, input().split()))\\n\\ncnt = 0\\nl = [set([x]) for x in range(1, n+1)]\\n\\nwhile 1:\\n l = list([tup[0] | tup[1] for tup in", "gt": "zip(l[::2], l[1::2])])\\n cnt += 1\\n for el in l:\\n if a in el and b in el:\\n print(cnt if len(el) < n else 'Final!')\\n return\\n"}
{"id": "279", "input": "import sys\\n\\nn = int(input())\\np = [int(i) for i in input().split()]\\nb = [int(i) for i in input().split()]\\n\\nans = 0\\nnum_cycles = 0\\nchecked = set()\\n\\nfor i in range(n):\\n if i in checked:\\n continue\\n\\n checked.add(i)\\n\\n", "gt": "nxt = p[i] - 1\\n\\n while nxt != i:\\n checked.add(nxt)\\n nxt = p[nxt] - 1\\n\\n num_cycles += 1\\n\\nans += num_cycles if num_cycles != 1 else 0\\nans += (sum(b) % 2) == 0\\n\\nprint(ans)"}
{"id": "280", "input": "v1, v2 = list(map(int, input().split()))\\nt, d = list(map(int, input().split()))\\nvm = [0] * t\\n\\nv = v1\\nfor i in range(t):\\n vm[i] =", "gt": "v\\n v += d\\n\\nv = v2\\nfor i in range(t - 1, -1, -1):\\n vm[i] = min(v, vm[i])\\n v += d\\n\\nprint(sum(vm))\\n"}
{"id": "281", "input": "import sys\\ninput = sys.stdin.readline\\nfrom itertools import permutations, accumulate\\nimport heapq\\nimport bisect\\nfrom operator import itemgetter\\n\\ndef dijkstra(start, edge):\\n n = len(edge)\\n dist = [0]*n\\n que = [(0, start)]\\n while que:\\n d, v = heapq.heappop(que)\\n if dist[v] < d:\\n continue\\n for nv, nd in edge[v]:\\n if dist[nv] > d + nd:\\n dist[nv] = d + nd\\n heapq.heappush(que, (dist[nv], nv))\\n return dist\\n\\nn, m = map(int, input().split())\\nW = tuple(map(int, input().split()))\\nLV = sorted((tuple(map(int, input().split())) for _ in range(m)), key=itemgetter(1))\\nL, V = zip(*LV)\\nP = [0]\\nw_max =", "gt": "max(W)\\nfor l, v in LV:\\n if w_max > v:\\n print(-1)\\n return\\n if P[-1] > l:\\n P.append(P[-1])\\n else:\\n P.append(l)\\ndef f(K):\\n S = list(accumulate((W[k] for k in K)))\\n edge = [[] for _ in range(n)]\\n for i in range(n-1):\\n edge[i+1].append((i, 0))\\n for i in range(n-1):\\n for j in range(i+1, n):\\n if i == 0:\\n t = S[j]\\n else:\\n t = S[j] - S[i-1]\\n p = P[bisect.bisect_left(V, t)]\\n edge[j].append((i, -p))\\n return -dijkstra(n-1, edge)[0]\\n\\nans = float(\"inf\")\\nfor K in permutations(range(n)):\\n ans = min(ans, f(K))\\nprint(ans)"}
{"id": "282", "input": "a, b = map(int, input().split())\\n\\nif b - a > 10:\\n print(0)\\nelse:\\n s =", "gt": "1\\n for i in range(a + 1, b + 1):\\n s *= i\\n print(str(s)[-1])"}
{"id": "283", "input": "'''input\\n4 2\\n1001\\n'''\\n\\ndef list_input():\\n return list(map(int,input().split()))\\ndef map_input():\\n return map(int,input().split())\\ndef map_string():\\n return input().split()\\n \\nn,d = map_input()\\ns = input()\\ncur = 0\\ncnt = 0\\nwhile cur < n-1:\\n j =", "gt": "-1\\n for i in range(cur+1,min(cur+d+1,n)):\\n if s[i] == '1': j = i\\n if j == -1:\\n print(-1)\\n break\\n cur = j\\n cnt += 1\\nelse: print(cnt)"}
{"id": "284", "input": "def prime(x):\\n if x < 2:\\n return False\\n if x == 2:\\n return True\\n if x % 2 == 0:\\n return False\\n\\n for d in range(3, x, 2):\\n if d * d >", "gt": "x:\\n break\\n if x % d == 0:\\n return False\\n\\n return True\\n\\ndef main():\\n n = int(input())\\n for m in range(1, 1001):\\n if not prime(n * m + 1):\\n ans = m\\n break\\n\\n print(ans)\\n\\nmain()\\n"}
{"id": "285", "input": "3\\n# Copyright (C) 2016 Sayutin Dmitry.\\n#\\n# This program is free software; you can redistribute it and/or\\n# modify it under the terms of the GNU General Public License as\\n# published by the Free Software Foundation; version 3\\n#\\n# This program is distributed in the hope that it will be useful,\\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n# GNU General Public", "gt": "License for more details.\\n#\\n# You should have received a copy of the GNU General Public License\\n# along with this program; If not, see <http://www.gnu.org/licenses/>.\\n\\ndef main():\\n n = int(input())\\n ans = False\\n for a in range(0, 1001):\\n for b in range(0, 1001):\\n left = n - 1234567 * a - 123456 * b\\n if left >= 0 and left % 1234 == 0:\\n ans = True\\n print(\"YES\" if ans else \"NO\")\\n\\nmain()\\n"}
{"id": "286", "input": "k = []\\n\\nx = int(input())\\nc, d = list(map(int, input().split(' ')))\\nfor i in range(x):\\n a, b", "gt": "= list(map(int, input().split(' ')))\\n k.append([c*a+b, d*a+b])\\n\\nk.sort()\\nfor i in range(len(k)-1):\\n if k[i+1][1] < k[i][1]:\\n print(\"YES\")\\n quit()\\nprint(\"NO\")\\n"}
{"id": "287", "input": "n = int(input())\\n\\nprint(1", "gt": "+ n // 2)\\n"}
{"id": "288", "input": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\\n\\nsys.setrecursionlimit(10**7)\\ninf = 10**20\\ngosa = 1.0 / 10**10\\nmod = 10**9+7\\n\\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\\ndef LF(): return [float(x) for x in", "gt": "sys.stdin.readline().split()]\\ndef LS(): return sys.stdin.readline().split()\\ndef I(): return int(sys.stdin.readline())\\ndef F(): return float(sys.stdin.readline())\\ndef S(): return input()\\n\\n\\ndef main():\\n n,k = LI()\\n if k == 0 or n==k:\\n return '0 0'\\n\\n return \"1"}
{"id": "289", "input": "n = int(input())\\nx = 0\\ncur = 1\\nlst = 1\\nwhile cur + lst", "gt": "<= n:\\n cur, lst = cur + lst, cur\\n x += 1\\nprint(x)\\n"}
{"id": "290", "input": "s = input()\\nd = dict()\\nd['V'] = 'K'\\nd['K'] = 'V'\\nm = s.count('VK')\\ns =", "gt": "list(s)\\nfor i in range(len(s)):\\n s[i] = d[s[i]]\\n m = max(m,''.join(s).count('VK'))\\n s[i] = d[s[i]]\\nprint(m)"}
{"id": "291", "input": "n = int(input())\\n\\na = b = 1\\n\\nwhile a * b <", "gt": "n:\\n if a < b:\\n a += 1\\n else:\\n b += 1\\n\\nprint(a+b)\\n"}
{"id": "292", "input": "def l2i(s):\\n return [int(i) for i", "gt": "in s.split()]\\na, b=l2i(input())\\nt=0\\nwhile (a<=b):\\n a*=3\\n b*=2\\n t+=1\\nprint(t)"}
{"id": "293", "input": "h, n = list(map(int, input().split()))\\nc, m = 0, 2 ** h\\nr = 0\\nwhile m > 1:\\n if c == 0:\\n if n > m // 2:\\n r += m - 1\\n n -= m // 2\\n c = 1", "gt": "- c\\n else:\\n if n > m // 2:\\n n -= m // 2\\n else:\\n r += m - 1\\n c = 1 - c\\n c = 1 - c\\n r += 1\\n m //= 2\\n #print(c, m, r, n)\\nprint(r)\\n"}
{"id": "294", "input": "x = int(input())\\n\\ndef solve(x):\\n count = 0\\n lst = []\\n x6 = x * 6\\n for n in range(1, x + 1):\\n t, r = divmod(x6, n*(n+1))\\n if t < 2*n + 1:\\n break\\n if r:\\n continue\\n m, r = divmod(t + n", "gt": "- 1, 3)\\n if r:\\n continue\\n count += 2\\n lst.append((n, m))\\n nn, mm = lst[-1]\\n if nn == mm:\\n count -= 1\\n print(count)\\n for n, m in lst:\\n print(n, m)\\n if nn != mm:\\n print(mm, nn)\\n lst.reverse()\\n for n, m in lst[1:]:\\n print(m, n)\\n\\nsolve(x)\\n"}
{"id": "295", "input": "n = int(input())\\ns = input().split()\\na = [0] * n\\nm = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30,", "gt": "31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\nfor i in range(n):\\n a[i] = int(s[i])\\nans = \"No\"\\nfor i in range(len(m) - n):\\n if a == m[i:i+n]:\\n ans = \"Yes\"\\n break\\nprint(ans)"}
{"id": "296", "input": "from math import sqrt\\n\\ndef phi(u):\\n ans = u\\n for i in range(2, int(sqrt(n)) + 1):\\n if u % i == 0:\\n while u % i == 0:\\n u = u / i\\n ans = ans - int(ans / i)\\n if n > 1:\\n ans = ans - int(ans / n)\\n return ans\\n\\ndef binpow(u, a, mod):\\n ans = 1\\n if a == 0:\\n return 1;\\n while a > 0:\\n if a % 2 == 0:\\n u = (u ** 2) % mod\\n", "gt": "a = int(a / 2)\\n else :\\n ans = (ans * u) % mod\\n a = a - 1\\n return int(ans)\\n\\nn = int(input())\\n\\nb1 = 1\\nb2 = 0\\nnn = n\\nfor i in range(2, int(sqrt(n)) + 1):\\n if n%i == 0 :\\n while nn % i == 0:\\n b1 = b1 * i\\n nn = nn / i\\n b2 = int(n / b1)\\n break\\n\\nif b2 < 2:\\n print(\"NO\")\\n return\\na1 = b1 - binpow(b2, phi(b1) - 1, b1)\\na2 = b2 - int((a1*b2+1)/b1)\\nprint(\"YES\")\\nprint(2)\\nprint(a1, b1)\\nprint(a2, b2)\\n"}
{"id": "297", "input": "r = open('input.txt')\\nw = open('output.txt', mode='w')\\n\\nf = lambda: map(int, r.readline().split())\\n\\nf()\\na, b = f()\\nif a > b: a, b = b, a\\nn = 40001\\nu, v = [n] * n, [n] * n\\nx = s = 0\\nu[0] = v[0] = 0\\n\\nfor y in f():\\n s += y\\n p = []\\n h = min(x, y)\\n for d in range(min(s, a), max(0, s - b - y) - 1, -1):\\n", "gt": "t = v[d]\\n\\n if u[d] != n:\\n u[d + y] = min(u[d], u[d + y])\\n v[d] = min(t, u[d] + h)\\n u[d] = n\\n\\n if t != n:\\n u[d + y] = min(u[d + y], t + h)\\n x = y\\n\\ni = max(s - b, 0)\\nj = min(s, a) + 1\\n\\nd = min(u[i:j] + v[i:j]) if i < j else n\\nw.write(str(d if d < n else -1))\\n\\nw.close()\\nr.close()"}
{"id": "298", "input": "def gcd(a, b):\\n a, b = max(a, b), min(a, b)\\n while b:\\n a, b = b, a % b\\n return a\\n\\n\\nn, m, k = list(map(int, input().split()))\\n_n, _m = n, m\\nn, k = n // gcd(n, k), k // gcd(n, k)\\nm, k = m // gcd(m, k), k", "gt": "// gcd(m, k)\\na = 2\\na, k = a // gcd(a, k), k // gcd(a, k)\\nif k != 1:\\n print(\"NO\")\\nelif a * n <= _n:\\n print(\"YES\")\\n print(\"0 0\")\\n print(a * n, 0)\\n print(0, m)\\nelif a * m <= _m:\\n print(\"YES\")\\n print(\"0 0\")\\n print(n, 0)\\n print(0, m * a)\\nelse:\\n print(\"NO\")\\n"}
{"id": "299", "input": "n,k=list(map(int,input().split()))\\nn=(n//k)%2\\nprint('YES' if", "gt": "n==1 else 'NO')\\n"}
{"id": "300", "input": "n=int(input())\\n\\ns=input().split()\\n\\nA=[0,0,0]\\nfor i in range(n):\\n", "gt": "A[i%3]+=int(s[i])\\n\\nm=max(A)\\n\\nif(m==A[0]):\\n print(\"chest\")\\nelif(m==A[1]):\\n print(\"biceps\")\\nelse:\\n print(\"back\")\\n"}
{"id": "301", "input": "def read_input():\\n return map(int, input().split())\\n\\nn = int(input())\\na = sorted(read_input())\\n\\ns = sum(a)\\ni = 0\\n\\nwhile 2 *", "gt": "s < 9 * n:\\n delta = 5 - a[i]\\n s += delta\\n i += 1\\n\\nprint(i)"}
{"id": "302", "input": "u, v = list(map(int, input().split()))\\nif v < u or (v - u) % 2 != 0:\\n print(-1)\\nelse:\\n if u == v:\\n if u == 0:\\n print(0)\\n else:\\n print(\"1\\n\" + str(u))\\n else:\\n w = (v", "gt": "- u) // 2\\n if (w | u) == (w + u):\\n print(\"2\\n\" + str(w|u) + ' ' + str(w))\\n else:\\n print(\"3\\n\" + str(u) + ' ' + str(w) + ' ' + str(w))\\n\\n"}
{"id": "303", "input": "\"\"\"\\nCodeforces Testing Round 10 Problem C\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0:\\n return inputs\\n if mode == 1:\\n return inputs.split()\\n if mode == 2:\\n return [int(x) for x in inputs.split()]\\n\\ndef write(s=\"\\n\"):\\n if isinstance(s, list): s = \" \".join(s)\\n s = str(s)\\n print(s, end=\"\")\\n\\n################################################### SOLUTION\\ndef g(n):\\n return (10**n-1)//9\\n\\ndef solve(n):\\n if n <= 6:", "gt": "return n\\n if 7 <= n <= 11: return 13-n\\n l = 1\\n while g(l) < n: l += 1\\n l -= 1\\n gl = g(l)\\n a = n\\n res1 = 0\\n res1 += (a // gl) * l\\n a %= gl\\n res1 += solve(a)\\n b = g(l+1) - n\\n res2 = l+1\\n res2 += (b // gl) * l\\n b %= gl\\n res2 += solve(b)\\n return min(res1, res2)\\n\\nn, = read()\\nprint(solve(n))"}
{"id": "304", "input": "x1, y1, x2, y2 = list(map(int, input().split()))\\nx, y = list(map(int, input().split()))\\n\\nx, y = abs(x), abs(y)\\n\\nx_ = abs(x2 - x1)\\ny_ = abs(y2 - y1)\\n\\nif x_ %", "gt": "x == 0 and y_ % y == 0:\\n if (x_ // x + y_ // y) % 2 == 0:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\nelse:\\n print(\"NO\")\\n"}
{"id": "305", "input": "n=input()\\nrg=[0]*10\\nfor i in n: rg[int(i)]+=1\\nrl=[]\\nff=0\\nfor i in range(len(rg)):\\n if rg[i]!=0:\\n rl.append(rg[i])\\n if i==0: ff=1\\nfact=[1]\\nfc=1\\nfor i in range(1,20):\\n fc*=i\\n fact.append(fc)\\nrt=[]\\nt=0\\ndef cfs(d):\\n if d==len(rl):\\n nonlocal t,ff\\n jj=fact[sum(rt)]\\n for i in rt: jj=jj/fact[i]\\n if ff:\\n jjj=fact[sum(rt)-1]\\n jjj=jjj/fact[rt[0]-1]\\n for i in range(1,len(rt)): jjj=jjj/fact[rt[i]]\\n jj-=jjj\\n t+=jj\\n return\\n \\n for i in range(1,rl[d]+1):\\n rt.append(i)\\n cfs(d+1)\\n", "gt": "rt.pop(-1)\\n\\ncfs(0)\\nprint(int(t))\\n\\n\\n \\n \\n \\n\\n'''\\n//////////////// ////// /////// // /////// // // //\\n//// // /// /// /// /// // /// /// //// //\\n//// //// /// /// /// /// // ///////// //// ///////\\n//// ///// /// /// /// /// // /// /// //// // //\\n////////////// /////////// /////////// ////// /// /// // // // //\\n'''\\n\\n"}
{"id": "306", "input": "a=int(input())\\nb=int(input())\\nc=int(input())\\nd=int(input())\\ne=int(input())\\nf=int(input())\\nif e>=f:\\n ans=min(a,d)\\n d-=ans\\n a-=ans\\n", "gt": "ans*=e\\n ans+=min(d,b,c)*f\\nelse:\\n ans=min(d,b,c)\\n d-=ans\\n ans*=f\\n ans+=min(a,d)*e\\nprint(ans)"}
{"id": "307", "input": "a, b, p, x = [int(x) for x in input().split()]\\n\\npowers = [a]\\n\\nwhile powers[-1] != 1:\\n powers.append(powers[-1] * a % p)\\n \\norder = len(powers)\\npowers = [powers[-1]] + powers\\n\\ninverse = pow(order, p-2, p)\\n\\ndef f(sol):\\n return (x // (p * order)) + (1 if sol <= x % (p * order) else 0)\\n\\ndef chinese(a, n, b,", "gt": "m):\\n k = inverse * (b - a + m) % m\\n x = k * n + a\\n return x % (n * m)\\n\\nres = 0\\nfor i in range(len(powers)-1):\\n inv = powers[order - i]\\n val = inv * b % p\\n \\n sol = chinese(i, order, val, p)\\n \\n res += f(sol)\\n \\nprint(res)\\n"}
{"id": "308", "input": "k2, k3, k5, k6 = list(map(int, input().split()))\\nc = min(k2, k5, k6)\\nk2", "gt": "-= c\\nans = 256 * c\\nans += 32 * min(k3, k2)\\nprint(ans)\\n"}
{"id": "309", "input": "x, y, n, c = 0, 0, 0, 0\\ndef suma_impares(m):\\n return m * m\\ndef suma_n(m):\\n return m * (m - 1) // 2\\ndef cnt(t):\\n u, d, l, r = x + t, x - t, y - t, y + t\\n suma = t ** 2 + (t + 1) ** 2\\n if u > n: suma -= suma_impares(u - n)\\n if d < 1: suma -= suma_impares(1 - d)\\n if l < 1: suma -= suma_impares(1 - l)\\n if r > n: suma -= suma_impares(r - n)\\n if 1 - l > x - 1 and 1 - d > y - 1:\\n suma += suma_n(2 - l - x)\\n if r - n > x - 1 and 1 -", "gt": "d > n - y:\\n suma += suma_n(r - n - x + 1)\\n if 1 - l > n - x and u - n > y - 1:\\n suma += suma_n(1 - l - n + x)\\n if u - n > n - y and r - n > n - x:\\n suma += suma_n(u - n - n + y)\\n return suma\\n \\nn, x, y, c = input().split()\\nn, x, y, c = int(n), int(x), int(y), int(c)\\n#for i in range(10):\\n# print(i, cnt(i))\\nini, fin = 0, int(1e9)\\ncont = int(1e9)\\nwhile cont > 0:\\n m = ini\\n paso = cont // 2\\n m += paso\\n if cnt(m) < c:\\n ini = m + 1\\n cont -= paso + 1\\n else:\\n cont = paso\\nprint(ini)"}
{"id": "310", "input": "import sys\\nl,r=map(int,(sys.stdin.readline().split()))\\ni=64\\nwhile i>=0:\\n if ((1<<i)&l!=0 and", "gt": "(1<<i)&r!=0) or ((1<<i)&l==0 and (1<<i)&r==0):i-=1\\n else:break\\nprint((1<<(i+1))-1)"}
{"id": "311", "input": "N, K", "gt": "= list(map(int, input().split()))\\n\\nprint((K+N-1)//N)\\n"}
{"id": "312", "input": "x, y, z, t1, t2, t3 = map(int, input().split())\\nladder = abs(x - y) * t1\\nelevator = abs(x -", "gt": "z) * t2 + 3 * t3 + abs(x - y) * t2\\nif elevator > ladder:\\n print(\"NO\")\\nelse:\\n print(\"YES\")"}
{"id": "313", "input": "n, m = list(map(int, input().split()))\\nif n == 1:\\n print(1)\\nelif m -", "gt": "1 >= n - m:\\n print(m - 1)\\nelse:\\n print(m + 1)\\n"}
{"id": "314", "input": "n = int(input())\\na = list(map(int, input().split()))\\nc = 0\\nl = 0\\nb = 0\\nwhile c < len(a) and a[c] == 0:\\n c += 1\\n b += 1\\n\\nif c == len(a):\\n print(0)\\n return\\n\\nd = len(a) - 1\\nwhile", "gt": "a[d] != 1:\\n d -= 1\\n b += 1\\n\\nwhile c <= d:\\n if a[c] == 0:\\n l += 1\\n else:\\n if l > 1:\\n b += l\\n l = 0\\n c += 1\\n\\nprint(n - b)"}
{"id": "315", "input": "#!/bin/python\\n\\nn, k = list(map(int, input().split()))\\np = list(map(int, input().split()))\\n\\na, b = 0, 0\\nfor i in range(n):\\n a +=", "gt": "p[i]\\n x = min(8, a)\\n b += x\\n a -= x\\n if b >= k:\\n print(i+1)\\n break\\nelse:\\n print(-1)\\n"}
{"id": "316", "input": "n, k = list(map(int, input().split()))\\na = list(map(int, input().split()))\\n\\nans = 0\\nfor i in range(1, n):\\n diff = k", "gt": "- (a[i] + a[i - 1])\\n if diff > 0:\\n a[i] += diff\\n ans += diff\\n\\nprint(ans)\\nprint(' '.join(map(str, a)))\\n\\n"}
{"id": "317", "input": "n = int(input())\\na = n * (n + 1)", "gt": "// 2\\nprint(4 * a - 4 * n + 1)"}
{"id": "318", "input": "n = int(input())\\ns = input()\\na = [False for i in range(26)]\\nfor x in", "gt": "s:\\n a[ord(x.lower()) - ord('a')] = True\\nfor x in a:\\n if not x:\\n print('NO')\\n return\\nprint('YES')\\n"}
{"id": "319", "input": "def main():\\n a, b = map(int, input().split(\":\"))\\n c = int(input())\\n\\n a += c // 60\\n b += c % 60\\n if b > 59:\\n b %= 60\\n a += 1\\n\\n aa =", "gt": "str(a % 24)\\n if len(aa) < 2:\\n aa = \"0\" + aa\\n\\n bb = str(b % 60)\\n if len(bb) < 2:\\n bb = \"0\" + bb\\n\\n print(aa + \":\" + bb)\\n\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "320", "input": "n, m = list(map(int, input().split()))\\na = [list(map(int, input())) for i in range(n)]\\n\\nignorable = [True] * n\\n\\nfor i in range(m):\\n cnt = 0\\n", "gt": "for j in range(n):\\n cnt += a[j][i]\\n if cnt == 1:\\n for j in range(n):\\n if a[j][i]:\\n ignorable[j] = False\\n\\nif any(ignorable):\\n print('YES')\\nelse:\\n print('NO')\\n"}
{"id": "321", "input": "N = int(input())\\nCheck = False\\nSum = 0\\nSum_l, Sum_r = 0, 0\\nfor i in range(N):\\n x, y = list(map(int, input().split()))\\n Sum_l += x\\n Sum_r += y\\n Sum += x + y\\n if", "gt": "(x % 2 + y % 2) % 2:\\n Check = True\\nif Sum % 2:\\n print(-1)\\nelif Sum_l % 2:\\n if not Check:\\n print(-1)\\n else:\\n print(1)\\nelif Sum_l % 2 == 0:\\n print(0)\\n"}
{"id": "322", "input": "def isPrime(n) : \\n # Corner cases \\n if (n <= 1) : \\n return False\\n if (n <= 3) : \\n return True\\n \\n # This is checked so that we can skip \\n # middle five numbers in below loop \\n if (n % 2 == 0 or n % 3 == 0)", "gt": ": \\n return False\\n \\n i = 5\\n while(i * i <= n) : \\n if (n % i == 0 or n % (i + 2) == 0) : \\n return False\\n i = i + 6\\n \\n return True\\nt=int(input())\\nfor yes in range(t):\\n a,b=map(int,input().split())\\n xx=a-b\\n yy=a+b \\n if xx==1 and isPrime(yy)==True:\\n print(\"YES\")\\n else:\\n print(\"NO\")"}
{"id": "323", "input": "n = int(input())\\nlcnt = 0\\nrcnt = 0\\nfor i in range(n):\\n x, y = map(int, input().split())\\n if x", "gt": "< 0:\\n lcnt += 1\\n else:\\n rcnt += 1\\n\\nif (lcnt <= 1 or rcnt <= 1):\\n print(\"Yes\")\\nelse:\\n print(\"No\")"}
{"id": "324", "input": "a, b = map(int, input().split())\\na = min(a, b)\\nans =", "gt": "1\\nfor i in range(1, a + 1):\\n ans *= i\\nprint(ans)"}
{"id": "325", "input": "n = int(input())\\nprint (9", "gt": "* n, 8 * n)"}
{"id": "326", "input": "def reachable(es, source):\\n ret = {source}\\n Q = [source]\\n while Q:\\n cur = Q.pop()\\n for nxt in es[cur]:\\n if nxt not in ret:\\n Q.append(nxt)\\n ret.add(nxt)\\n return ret\\n\\ndef BellmanFord(V:int, es:list, source=0):\\n INF = float(\"inf\")\\n D = [INF]*V\\n D[source] = 0\\n for _ in range(V):\\n upd = False\\n for f, t, c in es:\\n tmp = D[f] + c\\n if D[t] > tmp:\\n D[t] = tmp\\n", "gt": "upd = True\\n if not upd:\\n return D[-1]\\n else:\\n return None\\n \\ndef main():\\n N,M,P,*L=map(int,open(0).read().split())\\n fwd = [[] for _ in range(N)]\\n bwd = [[] for _ in range(N)]\\n tmp = []\\n for a,b,c in zip(*[iter(L)]*3):\\n fwd[a-1].append(b-1)\\n bwd[b-1].append(a-1)\\n tmp+=[(a-1,b-1,P-c)]\\n judge = reachable(fwd,0) & reachable(bwd,N-1)\\n ans = BellmanFord(N,[(a,b,c) for a,b,c in tmp if a in judge and b in judge])\\n if ans==None:\\n print(-1)\\n else:\\n print(max(0,-ans))\\n\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "327", "input": "it = lambda: list(map(int, input().strip().split()))\\nINF = float('inf')\\n\\n\\ndef solve():\\n N = int(input())\\n S = []\\n R = []\\n C = []\\n for _ in range(N):\\n s, c = input().strip().split()\\n S.append(s)\\n R.append(s[::-1])\\n C.append(int(c))\\n \\n vis = set()\\n mem = dict()\\n\\n def dp(s, p):\\n if (s, p) in mem: return mem[s, p]\\n if s == s[::-1]: return 0\\n if (s, p) in vis: return INF\\n\\n ans = INF\\n vis.add((s, p))\\n for i, t", "gt": "in enumerate(S if p else R):\\n if len(t) >= len(s) and t.startswith(s):\\n ans = min(ans, dp(t[len(s):], p ^ 1) + C[i])\\n elif len(s) > len(t) and s.startswith(t):\\n ans = min(ans, dp(s[len(t):], p) + C[i])\\n vis.discard((s, p))\\n mem[s, p] = ans\\n return ans\\n \\n ans = INF\\n for i in range(N):\\n ans = min(ans, dp(S[i], 0) + C[i])\\n return -1 if ans == INF else ans\\n\\n\\ndef __starting_point():\\n ans = solve()\\n print(ans)\\n__starting_point()"}
{"id": "328", "input": "R=lambda:list(map(int,input().split()))\\nn,k=R()\\nif k==1:print(n)\\nelse:\\n i=0\\n", "gt": "while (1<<i)<=n:i+=1\\n print((1<<i)-1)\\n"}
{"id": "329", "input": "n = int(input())\\nres = -float('inf')\\nfor _ in", "gt": "range(n):\\n a,b = list(map(int,input().split()))\\n res = max(res,a+b)\\nprint(res)\\n"}
{"id": "330", "input": "t = {i: 0 for i in 'qwertyuiopasdfghjklzxcvbnm'}\\nfor i in input(): t[i]", "gt": "+= 1\\nprint(min([t['i'], t['t'], t['e'] // 3, max(0, (t['n'] - 1)) // 2]))"}
{"id": "331", "input": "import sys, math\\n\\n#f = open('input_0', 'r')\\nf = sys.stdin\\n\\nP, Y = list(map(int, f.readline().split()))\\n\\nis_ok = False\\nfor t in range(Y, P, -1):\\n is_ok = True\\n for", "gt": "x in range(2, P+1):\\n if t%x == 0:\\n is_ok = False\\n break\\n if x*x > t:\\n break\\n if is_ok:\\n print(t)\\n break\\nif not is_ok:\\n print(-1)\\n"}
{"id": "332", "input": "n, m, k = list(map(int, input().split()))\\nm -= 1\\nline = list(map(int, input().split()))\\nanswer = n\\nfor i in range(n):\\n if", "gt": "line[i] == 0:\\n continue\\n if line[i] > k:\\n continue\\n answer = min(answer, abs(m - i))\\nprint(answer * 10)"}
{"id": "333", "input": "from collections import Counter\\n\\n\\ndef input_matrix():\\n res = tuple((Counter() for _ in range(n + m)))\\n for i in range(n):\\n for j,", "gt": "a in enumerate(map(int, input().split())):\\n res[i + j][a] += 1\\n return res\\n\\n\\nn, m = list(map(int, input().split()))\\nif input_matrix() == input_matrix():\\n print(\"YES\")\\nelse:\\n print(\"NO\")\\n"}
{"id": "334", "input": "import sys\\na = input()\\nb = input()\\nif", "gt": "a != b:\\n print(max(len(a), len(b)))\\nelse:\\n print(-1)\\n"}
{"id": "335", "input": "a, b = map(int,input().split())\\nc, d = map(int,input().split())\\nONE = set()\\nTWO = set()\\nfor i in range(b, 50000, a):\\n ONE.add(i)\\nfor i in range(d,", "gt": "50000, c):\\n TWO.add(i)\\n\\nopt = 99999\\nfor i in ONE:\\n if i in TWO:\\n opt = min(opt, i)\\nif opt == 99999:\\n print(-1)\\nelse:\\n print(opt)"}
{"id": "336", "input": "n = int(input())\\nif n%3 == 0: print(1, 1, n-2)\\nelif", "gt": "n%3 == 1: print(1, 1, n-2)\\nelse: print(1, 2, n-3)"}
{"id": "337", "input": "n, a, b, c, d= [int(i) for i in input().split()]\\no = 0\\nfor i in", "gt": "range(1, n+1):\\n if i+b-c>0 and i+b-c<=n:\\n if i+a-d>0 and i+a-d<=n:\\n if i+a+b-c-d>0 and i+a+b-c-d<=n:\\n o+=1\\nprint(o*n)\\n"}
{"id": "338", "input": "w, h = map(int, input().split())\\nu1, d1 = map(int, input().split())\\nu2, d2 = map(int, input().split())\\n\\nfor i in range(h, -1, -1):\\n w +=", "gt": "i\\n if i == d1:\\n w = max(w - u1, 0)\\n elif i == d2:\\n w = max(w - u2, 0)\\n\\nprint(w)"}
{"id": "339", "input": "m = int(input())\\nc = list(map(int,input().split()))\\nx, y = list(map(int,input().split()))\\n\\nfor i in range(m):\\n sb = sum(c[:-i-1])\\n si =", "gt": "sum(c[-i-1:])\\n if x <= sb <= y:\\n if x <= si <= y:\\n print(m-i)\\n break\\nelse:\\n print(0)\\n"}
{"id": "340", "input": "import sys\\n\\ndef read_int():\\n return int(input())\\n\\ndef read_ints():\\n return [int(x) for x in input().split()]\\n\\nn = read_int()\\nk = read_int()\\na = read_int()\\nb = read_int()\\n\\ncost = 0\\n\\nif k == 1:\\n cost = (n - 1) * a\\nelse:\\n while n != 1:\\n if n % k == 0:\\n if b < (n", "gt": "- n // k) * a:\\n cost += b\\n else:\\n cost += (n - n // k) * a\\n n = n // k\\n else:\\n cost += (n % k) * a\\n n -= n % k\\n if n == 0:\\n n += 1\\n cost -= a\\n\\nprint(cost)\\n"}
{"id": "341", "input": "def ii():\\n return int(input())\\ndef mi():\\n return list(map(int, input().split()))\\ndef li():\\n return list(mi())\\nMX = 10 ** 5\\n\\nn = ii()\\nfac = 2\\npr = []\\nwhile fac * fac <= n:\\n c = 0\\n while n % fac == 0:\\n c += 1\\n n //= fac\\n if c:\\n pr.append((fac, c))\\n fac += 1\\nif n > 1:\\n pr.append((n, 1))\\nif pr:\\n mx", "gt": "= max(e for p, e in pr)\\n mn = min(e for p, e in pr)\\n mx2 = 1\\n cnt = 0\\n while mx2 < mx:\\n mx2 *= 2\\n cnt += 1\\n ans = cnt + int(mn != mx2)\\n pdt = 1\\n for p, e in pr:\\n pdt *= p\\nelse:\\n pdt, ans = 1, 0\\nprint(pdt, ans)\\n"}
{"id": "342", "input": "###Prediction and Restriction\\nn,k=list(map(int,input().split()))\\nr,s,p=list(map(int,input().split()))\\nt=input()\\nwin=[False]*n\\ndef janken(char):\\n if char=='r':\\n return p\\n elif char=='s':\\n return r\\n else:\\n return s\\ncnt=0\\nfor i in range(n):\\n", "gt": "if i-k<0:\\n point=janken(t[i])\\n cnt+=point\\n win[i]=True\\n else:\\n if t[i]!=t[i-k]:\\n point=janken(t[i])\\n cnt+=point\\n win[i]=True\\n else:\\n if not win[i-k]:\\n point=janken(t[i])\\n cnt+=point\\n win[i]=True\\n\\nprint(cnt)\\n"}
{"id": "343", "input": "a, b, c = list(map(int, input().split()))\\nx = 2 *", "gt": "(c + min(a, b))\\nif a != b:\\n x += 1\\nprint(x)\\n"}
{"id": "344", "input": "def read_data():\\n n, k, p, x, y = map(int, input().split())\\n As = list(map(int, input().split()))\\n return n, k, p, x, y, As\\n\\ndef solve(n, k, p, x, y, As):\\n '''median (As + Bs) >= y\\n sum(As + Bs) <= x\\n 1 <= Bi <= p\\n '''\\n middle = n // 2\\n As.sort(reverse=True)\\n sumA = sum(As)\\n minSum = sumA + 1 * (n - k)\\n if minSum > x:\\n return ['-1']\\n num_a_over_y = len([1 for a in As if a >=", "gt": "y])\\n if num_a_over_y > middle:\\n return ['1'] * (n - k)\\n min_num_y = middle + 1 - num_a_over_y\\n if min_num_y > n - k:\\n return ['-1']\\n minSum2 = sumA + min_num_y * y + (n - k - min_num_y) * 1\\n if minSum2 > x:\\n return ['-1']\\n return [str(y)] * min_num_y + ['1'] * (n - k - min_num_y)\\n\\ndef __starting_point():\\n n, k, p, x, y, As = read_data()\\n seq = solve(n, k, p, x, y, As)\\n print(' '.join(seq))\\n__starting_point()"}
{"id": "345", "input": "s = input()\\nok = 1\\nn = len(s)\\n\\ndef is_vowel(c):\\n return c in \"aouie\"\\n\\nfor i, x in enumerate(s):\\n if not is_vowel(x)", "gt": "and x != 'n':\\n ok &= ((i + 1 < n) and is_vowel(s[i + 1]))\\n\\nprint(\"YES\" if ok else \"NO\")"}
{"id": "346", "input": "n, m = map(int, input().split())\\n\\nd = [0 for i in range(7)]\\ng = [[] for i in range(7)]\\n\\nfor i in range(m):\\n x, y = map(int, input().split())\\n x -= 1\\n y -= 1\\n d[x] += 1\\n d[y] +=", "gt": "1\\n \\n g[x].append(y)\\n g[y].append(x)\\n \\nmn = min(d)\\nfor i in range(7):\\n for j in range(i):\\n cnt = 0\\n for k in range(7):\\n if((k in g[i]) and (k in g[j])):\\n cnt += 1\\n mn = min(mn, cnt)\\nm -= mn\\nprint(m)"}
{"id": "347", "input": "n, m = list(map(int, input().split()))\\nprices = list(map(int, input().split()))\\nauci = list(map(int, input().split()))\\n\\nscores = 0\\n\\n# m auc\\n# n - m default\\n\\nfor i in range(len(prices)):\\n if (i+1) not in auci:\\n scores +=", "gt": "prices[i]\\n prices[i] = 0\\n\\nra = []\\nfor i in prices:\\n if i != 0:\\n ra.append(i)\\nra.sort()\\nra = ra[::-1]\\n\\nfor i in ra:\\n if i > scores:\\n scores += i\\n else:\\n scores *= 2\\n\\nprint(scores)\\n#print(ra)\\n"}
{"id": "348", "input": "m = list(map(int, input().split()))\\nw = list(map(int, input().split()))\\na = [500, 1000, 1500, 2000, 2500]\\nv = list(map(int, input().split()))\\nans = 0\\nfor i in range(len(m)):\\n ans", "gt": "+= max(0.3 * a[i], (1 - m[i] / 250) * a[i] - 50 * w[i])\\nans += v[0] * 100\\nans -= v[1] * 50\\nprint(int(ans))\\n"}
{"id": "349", "input": "n,m,L,R = list(map(int,input().split()))\\np = 998244353*2\\npp = p//2\\n#liczba pokryc n x m ze jest parzyscie wiele zer albo parzyscie wiele jedynek\\ndef pow(a,w):\\n wyn = 1\\n mn = a\\n while w > 0:\\n if", "gt": "w%2 == 1:\\n wyn = (wyn * mn)%p\\n mn = (mn*mn)%p\\n w //= 2\\n return wyn\\ndupsko = pow((R-L+1), m*n)\\nif L == R:\\n print(1) \\nelse:\\n if (m*n)%2 == 1:\\n print(dupsko%pp)\\n else:\\n print((dupsko - dupsko//2)%pp)\\n"}
{"id": "350", "input": "def main():\\n from sys import stdin, stdout\\n\\n def read():\\n return stdin.readline().rstrip('\\n')\\n\\n def read_array(sep=None, maxsplit=-1):\\n return read().split(sep, maxsplit)\\n\\n def read_int():\\n return int(read())\\n\\n def read_int_array(sep=None, maxsplit=-1):\\n return [int(a) for a in read_array(sep, maxsplit)]\\n\\n def write(*args, **kwargs):\\n sep = kwargs.get('sep', ' ')\\n end = kwargs.get('end', '\\n')\\n stdout.write(sep.join(str(a) for a in args) + end)\\n\\n def write_array(array, **kwargs):\\n sep = kwargs.get('sep', ' ')\\n end = kwargs.get('end', '\\n')\\n stdout.write(sep.join(str(a) for a in array)", "gt": "+ end)\\n\\n n, m = read_int_array()\\n minm, maxm = [], []\\n for _ in range(n):\\n minm.append(read_int_array())\\n for _ in range(n):\\n maxm.append(read_int_array())\\n\\n for r in range(n):\\n for c in range(m):\\n minx = min(minm[r][c], maxm[r][c])\\n maxx = max(minm[r][c], maxm[r][c])\\n if r:\\n if minx <= minm[r-1][c] or maxx <= maxm[r-1][c]:\\n write(\"Impossible\")\\n return\\n if c:\\n if minx <= minm[r][c-1] or maxx <= maxm[r][c-1]:\\n write(\"Impossible\")\\n return\\n minm[r][c] = minx\\n maxm[r][c] = maxx\\n write(\"Possible\")\\n\\nmain()\\n"}
{"id": "351", "input": "n = int(input())\\narr = list(map(int, input().split()))\\narr.sort()\\narr = arr[::-1]\\nans = [arr[0]]\\nfor i", "gt": "in range(1, n):\\n if(arr[i] < ans[-1]):\\n ans.append(arr[i])\\n else:\\n ans.append(max(0, ans[-1] - 1))\\nprint(sum(ans))"}
{"id": "352", "input": "R=lambda:list(map(int,input().split()))\\nn,k=R()\\na=sorted(R())\\nb=0\\nfor i in a:\\n", "gt": "while i>k+k:\\n k+=k\\n b+=1\\n k=max(k,i)\\nprint(b)\\n"}
{"id": "353", "input": "n = int(input())\\nmin1, max1 = map(int, input().split())\\nmin2, max2 = map(int, input().split())\\nmin3, max3 = map(int, input().split())\\n\\nd1 = min(n", "gt": "- min2 - min3, max1)\\nd2 = min(n - d1 - min3, max2)\\nd3 = n - d1 - d2\\n\\nprint(d1,d2,d3)"}
{"id": "354", "input": "# You lost the game.\\n\\nn = int(input())\\nL = list(map(int, input().split()))\\n\\nif n == 1:\\n if L[0] == 0:\\n print(\"UP\")\\n elif L[0] == 15:\\n print(\"DOWN\")\\n else:\\n", "gt": "print(\"-1\")\\nelse:\\n d = L[n-2] - L[n-1]\\n if d < 0:\\n if L[n-1] == 15:\\n print(\"DOWN\")\\n else:\\n print(\"UP\")\\n else:\\n if L[n-1] == 0:\\n print(\"UP\")\\n else:\\n print(\"DOWN\")\\n"}
{"id": "355", "input": "v = list('aeiou')\\ns = [c in v for c in input()]\\nt =", "gt": "[c in v for c in input()]\\nif s == t:\\n print('Yes')\\nelse:\\n print('No')"}
{"id": "356", "input": "grid = [list(input()) for i in range(8)]\\nb = 9\\nw = 9\\ntblock = False\\nbblock = False\\nfor r in range(8):\\n for c in range(8):\\n for ri in range(r):\\n if grid[ri][c] == 'B':\\n tblock = True\\n for ri in range(r+1, 8):\\n if", "gt": "grid[ri][c] == 'W':\\n bblock = True\\n if grid[r][c] == 'B' and not bblock:\\n b = min([abs(7-r), b])\\n elif grid[r][c] == 'W' and not tblock:\\n w = min([w, r])\\n tblock = False\\n bblock = False\\nif b < w:\\n print('B')\\nelse:\\n print('A')\\n \\n"}
{"id": "357", "input": "n = int(input())\\na = list(map(int, input().split()))\\n\\nm = int(input())\\nb = list(map(int, input().split()))\\n\\nptra = 1\\nptrb = 1\\nsa = a[0] \\nsb = b[0]\\nans = 0\\n\\nwhile ptra != n and ptrb != m:\\n if sa == sb:\\n ans += 1\\n sa = a[ptra]\\n sb = b[ptrb]\\n ptra += 1\\n", "gt": "ptrb += 1\\n continue\\n if sa < sb:\\n sa += a[ptra]\\n ptra += 1\\n else:\\n sb += b[ptrb]\\n ptrb += 1\\nwhile ptra != n:\\n sa += a[ptra]\\n ptra += 1\\nwhile ptrb != m:\\n sb += b[ptrb]\\n ptrb += 1\\nif sa != sb:\\n print(-1)\\n return\\nprint(ans + 1)\\n\\n"}
{"id": "358", "input": "s = input()\\nif (s.count('Danil') + s.count('Olya') + s.count('Slava')", "gt": "+ s.count('Ann') + s.count('Nikita') == 1):\\n print('YES')\\nelse:\\n print('NO')\\n"}
{"id": "359", "input": "def f(n):\\n m = int(n ** 0.5) + 1\\n t = [1] * (n + 1)\\n for i in range(3, m):\\n if t[i]: t[i * i :: 2 * i] = [0] * ((n - i * i) // (2 * i) + 1)\\n return [2] + [i for i in range(3, n + 1, 2) if t[i]]\\n\\na, b, k = map(int, input().split())\\nn = 2000001\\n\\nt, p, x", "gt": "= [-1] * n, f(n), -1\\nk -= 1; b += 1\\n\\nfor i in range(len(p) - k):\\n t[p[i]] = p[i + k] - p[i]\\n\\nt.reverse()\\nfor i in range(1, n):\\n if t[i] < 0: t[i] = t[i - 1] + 1\\nt.reverse()\\n\\nfor i in range(a + 1, b):\\n t[i] = max(t[i], t[i - 1])\\n\\nfor l in range(1, b - a + 1):\\n if t[b - l] < l:\\n x = l\\n break\\nprint(x)"}
{"id": "360", "input": "a,h,w=(int(x) for x in input().split())\\nif h==w:\\n if a<h:\\n n=w//a\\n x=(w-a*n)/(n+1)\\n print(x)\\n elif a==h:\\n print(0)\\n else:\\n print(-1)\\nelse:\\n for i in range(100):\\n if h>w:\\n w,h=h,w\\n if w>h+a*2:\\n w=w-h-a\\n if h>w:\\n w,h=h,w \\n m=h//a\\n s=(w-h)//a\\n r=0\\n if m<s or s==0:\\n", "gt": "for i in range(m,0,-1):\\n x=(h-a*i)/(i+1)\\n w1=w-x\\n a1=a+x\\n q=w1%a1\\n if q<0.00000001 or a1-q<0.0000001:\\n r=1\\n break\\n if r==0:\\n print(-1)\\n else:\\n print(x)\\n else:\\n for i in range(s,0,-1):\\n x=(w-h-i*a)/i\\n w1=w-x\\n a1=a+x\\n q=w1%a1\\n if q<0.00000001:\\n r=1\\n break\\n if r==0:\\n print(-1)\\n else:\\n print(x)"}
{"id": "361", "input": "ii = lambda: int(input())\\nmi = lambda: map(int, input().split())\\nli = lambda: list(mi())\\n\\nn = ii()\\na = [li() for", "gt": "_ in range(n)]\\nk = ii()\\nans = 0\\nfor l, r in a:\\n ans += k <= r\\nprint(ans)"}
{"id": "362", "input": "import sys\\n\\nfin = sys.stdin\\nfout = sys.stdout\\n\\n#fin = open(\"input.txt\", 'r')\\n#fout = open(\"output.txt\", 'w')\\n\\ns = fin.readline().strip()\\nn = len(s)\\nfor L in range(n):\\n for R in", "gt": "range(L + 1, n + 1):\\n s1 = s[:L]\\n s2 = s[L:R]\\n s3 = s[R:]\\n if (s1 + s3 == \"CODEFORCES\"):\\n print(\"YES\")\\n return\\nprint(\"NO\")\\n"}
{"id": "363", "input": "n = int(input())\\nans = 0\\nfor i in range(1, n -", "gt": "1):\\n ans += (i + 1) * (i + 2)\\nprint(ans)"}
{"id": "364", "input": "hola = 0\\na = int(input())\\nd = len(str(a))\\nk = 10**(d-1)\\nfor i in", "gt": "range(1, d):\\n hola += i * (10**(i-1)*9)\\n\\nhola += d * (a-k+1)\\nprint(hola)"}
{"id": "365", "input": "from sys import stdin, stdout\\n\\nn, k = map(int, stdin.readline().split())\\nvalues = list(map(int, stdin.readline().split()))\\n\\nsze = max(values)\\nused = [0 for i in range(sze + 1)]\\nchallengers = [[] for i in range(n + 1)]\\n\\ni = 0\\ncnt =", "gt": "0\\n \\nfor i in range(n):\\n if values[i] == k:\\n cnt += 1\\n elif used[values[i]] >= cnt:\\n used[values[i]] += 1\\n challengers[used[values[i]]].append(values[i])\\n \\nfor i in range(n, cnt - 1, -1):\\n if len(challengers[i]):\\n stdout.write(str(challengers[i][0]))\\n break\\nelse:\\n stdout.write('-1')"}
{"id": "366", "input": "R=lambda:list(map(int,input().split()))\\nn,x=R()\\nprint('YES'if", "gt": "sum(R())+n-1==x else'NO')\\n"}
{"id": "367", "input": "n, m =list(map(int, input().split()))\\nif m % n != 0:\\n", "gt": "print( m // n + 1)\\nelse:\\n print(m // n)\\n"}
{"id": "368", "input": "\\nimport sys\\n#sys.stdin=open(\"data.txt\")\\ninput=sys.stdin.readline\\n\\npossible=[0]*26\\n\\nfor i in input().strip():\\n possible[ord(i)-97]+=1\\n\\n# make changes\\ntemp=[]\\nfor i in range(26):\\n if possible[i]%2: temp.append(i)\\nwhile len(temp)>1:\\n", "gt": "possible[temp[0]]+=1\\n possible[temp[-1]]-=1\\n temp.pop(0)\\n temp.pop(-1)\\n\\n# print stuff\\nfor i in range(26):\\n print(chr(97+i)*(possible[i]//2),end=\"\")\\nif temp: print(chr(97+temp[0]),end=\"\")\\nfor i in range(26)[::-1]:\\n print(chr(97+i)*(possible[i]//2),end=\"\")"}
{"id": "369", "input": "a = 0\\nb = 0\\nx = {'Q': 9, 'q':9, 'R':5, 'r':5, 'B':3, 'b':3, 'N':3, 'n':3, 'P': 1, 'p': 1}\\nfor i in range(8):\\n t = [i for i in input()]\\n for", "gt": "i in t:\\n if ord(i) >= 97 and i in x:\\n a += x[i]\\n elif i in x:\\n b += x[i]\\nif a == b:\\n print(\"Draw\")\\nelif a < b:\\n print(\"White\")\\nelse:\\n print(\"Black\")"}
{"id": "370", "input": "from bisect import bisect_left\\n\\n\\nN, M = list(map(int, input().split()))\\nS = input()\\ngood = []\\nbad = []\\nfor i in range(N + 1):\\n if S[i] == \"1\":\\n bad.append(i)\\n else:\\n good.append(i)\\n\\nans = []\\ncur = N\\nwhile", "gt": "True:\\n if cur == 0:\\n print((\" \".join(map(str, ans[::-1]))))\\n break\\n idx = bisect_left(good, cur - M)\\n nx = good[idx]\\n ans.append(cur - nx)\\n if cur == nx:\\n print((-1))\\n break\\n cur = nx\\n"}
{"id": "371", "input": "k = int(input())\\nx, y = list(map(int, input().split()))\\nans = []\\nif k % 2 == 0:\\n if (x + y) % 2 == 1:\\n print((-1))\\n return\\nx_reverse = False\\ny_reverse = False\\nif x < 0:\\n x *= -1\\n x_reverse = True\\nif y < 0:\\n y *= -1\\n y_reverse = True\\n\\n\\ndef app(a, b):\\n nonlocal ans\\n if x_reverse:\\n a *= -1\\n if y_reverse:\\n b *= -1\\n\\n ans.append((a, b))\\n\\n\\nnowx = 0\\nnowy = 0\\n\\nwhile abs(x - nowx) + abs(y - nowy) >= 2 * k:\\n if abs(x - nowx) > k:\\n nowx += k\\n else:\\n nowy += k\\n app(nowx, nowy)\\n\\n\\ndef ok():\\n app(x, y)\\n print((len(ans)))\\n for a, b in ans:\\n print((a, b))\\n return\\n\\n\\nrest = abs(x - nowx) + abs(y - nowy)\\nif rest == k:\\n ok()\\n\\nif rest % 2 == 0:\\n delta = 2 * k - rest\\n assert delta % 2 == 0\\n if abs(x - nowx) < abs(y - nowy):\\n", "gt": "temp = abs(x - nowx) + delta // 2\\n nowx += temp\\n nowy += k - temp\\n else:\\n temp = abs(y - nowy) + delta // 2\\n nowy += temp\\n nowx += k - temp\\n app(nowx, nowy)\\n ok()\\n\\n# 残りが奇数のときは、条件から一旦ゴールをすぎる方向に移動すれば、\\n# 残りの距離の偶奇が変わる。\\n\\nif abs(x - nowx) < abs(y - nowy):\\n nowx += k\\n app(nowx, nowy)\\nelse:\\n nowy += k\\n app(nowx, nowy)\\n\\nx_delta = x - nowx\\nx_pm = x_delta // abs(x_delta)\\ny_delta = y - nowy\\ny_pm = y_delta // abs(y_delta)\\nif abs(x_delta) < abs(y_delta):\\n delta = 2 * k - (abs(x_delta) + abs(y_delta))\\n temp = abs(x - nowx) + delta // 2\\n nowx += x_pm * temp\\n nowy += y_pm * (k - temp)\\n app(nowx, nowy)\\n ok()\\nelse:\\n delta = 2 * k - (abs(x_delta) + abs(y_delta))\\n temp = abs(y - nowy) + delta // 2\\n nowy += y_pm * temp\\n nowx += x_pm * (k - temp)\\n app(nowx, nowy)\\n ok()\\n\\n"}
{"id": "372", "input": "n = int(input())\\nl, r = 0, 10**16\\nD = [x ** 3.0 for x in range(2, 170417)]\\nDD = [x*x*x for x in range(2, 170417)]\\nwhile l < r:\\n m = (l+r)// 2\\n if sum(int(m/d) for d in D) < n:\\n l = m + 1\\n else:\\n r = m;\\nif sum(l//d for d in", "gt": "DD) == n:\\n print(l);"}
{"id": "373", "input": "#!/usr/bin/env python3\\n# 600D_circles.py - Codeforces.com/problemset/problem/600/D by Sergey 2015\\n\\nimport unittest\\nimport sys\\nimport math\\nimport decimal\\n\\n###############################################################################\\n# Circles Class (Main Program)\\n###############################################################################\\n\\n\\ndef sin(x):\\n decimal.getcontext().prec += 2\\n i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1\\n while s != lasts:\\n lasts = s\\n i += 2\\n fact *= i * (i-1)\\n num *= x * x\\n sign *= -1\\n s += num / fact * sign\\n decimal.getcontext().prec -= 2\\n return +s\\n\\n\\ndef cos(x):\\n decimal.getcontext().prec += 2\\n i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1\\n while s != lasts:\\n lasts = s\\n i += 2\\n fact *= i * (i-1)\\n num *= x * x\\n sign *= -1\\n s += num / fact * sign\\n decimal.getcontext().prec -= 2\\n return +s\\n\\n\\ndef pi():\\n decimal.getcontext().prec += 2\\n three = decimal.Decimal(3)\\n lasts, t, s, n, na, d, da = 0, three, 3, 1, 0, 0, 24\\n while s != lasts:\\n lasts = s\\n n, na = n+na, na+8\\n d, da = d+da, da+32\\n t = (t * n) / d\\n s += t\\n decimal.getcontext().prec -= 2\\n return +s\\n\\n\\ndef asin(x):\\n decimal.getcontext().prec += 2\\n b, e = -pi()/2, pi()/2\\n while True:\\n mid = (b + e) / 2\\n if e == mid or b == mid:\\n break\\n if sin(mid) <= x:\\n b = mid\\n else:\\n e = mid\\n decimal.getcontext().prec -= 2\\n return +b\\n\\n\\ndef acos(x):\\n return pi() / 2 - asin(x)\\n\\n\\nclass Circles:\\n \"\"\" Circles representation \"\"\"\\n\\n def __init__(self, test_inputs=None):\\n \"\"\" Default constructor \"\"\"\\n\\n it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\\n\\n def uinput():\\n return next(it) if it else sys.stdin.readline().rstrip()\\n\\n # Reading single elements\\n [self.xa, self.ya, self.ra] = list(map(decimal.Decimal, uinput().split()))\\n [self.xb, self.yb, self.rb] = list(map(decimal.Decimal, uinput().split()))\\n\\n decimal.getcontext().prec = 40\\n\\n self.l = ((self.xb - self.xa)**2 + (self.yb - self.ya)**2).sqrt()\\n self.p", "gt": "= (self.ra + self.rb + self.l)/2\\n\\n if self.l >= self.p:\\n self.sa = 0\\n self.sb = 0\\n elif self.ra >= self.p:\\n self.sa = 0\\n self.sb = self.rb**2 * decimal.Decimal.from_float(math.pi)\\n elif self.rb >= self.p:\\n self.sa = self.ra**2 * decimal.Decimal.from_float(math.pi)\\n self.sb = 0\\n else:\\n self.aa = 2 * acos(\\n (self.ra**2 - self.rb**2 + self.l**2) /\\n (2 * self.ra * self.l))\\n self.ab = 2 * acos(\\n (self.rb**2 - self.ra**2 + self.l**2) /\\n (2 * self.rb * self.l))\\n self.sa = self.ra**2 * (self.aa - sin(self.aa)) / 2\\n self.sb = self.rb**2 * (self.ab - sin(self.ab)) / 2\\n\\n def calculate(self):\\n \"\"\" Main calcualtion function of the class \"\"\"\\n\\n result = self.sa + self.sb\\n\\n return str(result)\\n\\n###############################################################################\\n# Unit Tests\\n###############################################################################\\n\\n\\nclass unitTests(unittest.TestCase):\\n\\n def test_single_test(self):\\n \"\"\" Circles class testing \"\"\"\\n\\n # Constructor test\\n test = \"0 0 4\\n6 0 4\"\\n d = Circles(test)\\n self.assertEqual(d.l, 6)\\n\\n # Sample test\\n self.assertEqual(Circles(test).calculate()[:8], \"7.252988\")\\n\\n # Sample test\\n test = \"0 0 5\\n11 0 5\"\\n self.assertEqual(Circles(test).calculate(), \"0\")\\n\\n # Sample test\\n test = \"44721 999999999 400000000\\n0 0 600000000\"\\n self.assertEqual(Circles(test).calculate()[:9], \"0.0018834\")\\n\\n # My tests\\n test = \"\"\\n # self.assertEqual(Circles(test).calculate(), \"0\")\\n\\n # Time limit test\\n # self.time_limit_test(5000)\\n\\n def time_limit_test(self, nmax):\\n \"\"\" Timelimit testing \"\"\"\\n import random\\n import timeit\\n\\n # Random inputs\\n test = str(nmax) + \" \" + str(nmax) + \"\\n\"\\n numnums = [str(i) + \" \" + str(i+1) for i in range(nmax)]\\n test += \"\\n\".join(numnums) + \"\\n\"\\n nums = [random.randint(1, 10000) for i in range(nmax)]\\n test += \" \".join(map(str, nums)) + \"\\n\"\\n\\n # Run the test\\n start = timeit.default_timer()\\n d = Circles(test)\\n calc = timeit.default_timer()\\n d.calculate()\\n stop = timeit.default_timer()\\n print((\"\\nTimelimit Test: \" +\\n \""}
{"id": "374", "input": "n=int(input())\\nif n==2:\\n", "gt": "print(2)\\nelse:\\n print(1)"}
{"id": "375", "input": "from collections import deque\\n\\nn = int(input())\\np = list(map(int,input().split()))\\na = list(map(int,input().split()))\\nedge = [[] for i in range(n)]\\nfor i in range(n-1):\\n edge[p[i]-1].append(i+1)\\n\\n\\ndp = [0 for i in range(n)]\\nsize = [not edge[v] for v in range(n)]\\n\\nres = []\\ndeq = deque([0])\\nwhile deq:\\n v = deq.popleft()\\n res.append(v)\\n for nv in edge[v]:\\n deq.append(nv)\\n\\nres = res[::-1]\\n\\nfor v in res:\\n tmp = -1\\n S", "gt": "= 0\\n for nv in edge[v]:\\n tmp = max(tmp,dp[nv])\\n size[v] += size[nv]\\n S += a[nv]\\n\\n if not edge[v]:\\n dp[v] = a[v]\\n continue\\n\\n rest = tmp*size[v] - S\\n if a[v]<=rest:\\n dp[v] = tmp\\n else:\\n q = (a[v]-rest)//size[v]\\n r = (a[v]-rest)%size[v]\\n if r:\\n dp[v] = tmp + q + 1\\n else:\\n dp[v] = tmp + q\\n a[v] += S\\n\\nprint(dp[0])"}
{"id": "376", "input": "def check(w, s):\\n j = 0\\n for i in range(len(s)):\\n while j < len(w) and s[i] != w[j]:\\n j += 1\\n if j >= len(w) or s[i] != w[j]:\\n return False\\n j += 1\\n return True\\n\\nn = int(input())\\ns = input()\\nt = input()\\nst = []\\ni = 0\\nwhile", "gt": "i < n and s[i] == t[i]:\\n st.append(s[i])\\n i += 1\\nw1 = st[:]\\nw2 = st[:]\\nw3 = st[:]\\nw4 = st[:]\\nw1.append(s[i])\\nw1.append(t[i])\\nw3.append(s[i])\\nw3.append(t[i])\\nw2.append(t[i])\\nw2.append(s[i])\\nw4.append(t[i])\\nw4.append(s[i])\\nfor j in range(i + 1, n):\\n w1.append(s[j])\\n w2.append(t[j])\\n w3.append(t[j])\\n w4.append(s[j])\\n\\nres = set()\\nfor ww in (w1, w2, w3, w4):\\n www = ''.join(ww)\\n if check(www, s) and check(www, t):\\n res.add(www)\\nprint(len(res))"}
{"id": "377", "input": "def sol():\\n\\n n = int(input())\\n st = list(map(int, input().split(' ')))\\n d = {}\\n for x in range(n):\\n d[x] = []\\n\\n st = [(st[i], i) for i in range(len(st))]\\n st = sorted(st)\\n\\n for a0 in range(n - 1):\\n u, v = map(int, input().split(' '))\\n u, v = u - 1, v - 1\\n d[u].append(v)\\n d[v].append(u)\\n\\n hardest = []\\n almost = []\\n\\n single_hardest = st[-1][0]\\n\\n for x in st[::-1]:\\n if x[0] == single_hardest:\\n hardest.append(x[1])\\n elif", "gt": "x[0] == single_hardest-1:\\n almost.append(x[1])\\n else:\\n break\\n\\n def inter(a, b):\\n c = []\\n for x in a:\\n if x in b:\\n c.append(x)\\n return c\\n\\n lower_bound = single_hardest\\n\\n inte = d[hardest[0]]+[hardest[0]]\\n for h in hardest[1:]:\\n inte = inter(inte, d[h]+[h])\\n\\n if not inte:\\n return (single_hardest+2)\\n\\n if len(hardest) > 1:\\n return single_hardest+1\\n\\n # hardest is len 1\\n if not almost:\\n return single_hardest\\n\\n cand = st[-1][1]\\n\\n for h in almost:\\n if h not in d[cand]:\\n return single_hardest+1\\n return single_hardest\\n\\nprint(sol())"}
{"id": "378", "input": "n, m = map(int, input().split())\\nif m", "gt": "<= 1:\\n print(1)\\n return\\nprint(min(m, n - m))"}
{"id": "379", "input": "k, r = list(map(int, input().split()))\\n\\nans = 10\\nfor x in range(1, 11):\\n mod = k *", "gt": "x % 10\\n if mod == 0 or mod == r:\\n ans = x\\n break\\n\\nprint(ans)\\n"}
{"id": "380", "input": "#!/usr/bin/env python3\\n\\ndef main():\\n import re\\n\\n n, m = list(map(int, input().split()))\\n left = right = -1\\n for i in range(n):\\n mt = re.search(r\"X+\", input())\\n if mt is not None:\\n t", "gt": "= mt.start()\\n if t != left != -1:\\n print(\"NO\")\\n break\\n left = t\\n t = mt.end()\\n if t != right != -1:\\n print(\"NO\")\\n break\\n right = t\\n else:\\n print(\"YES\")\\n\\nmain()\\n"}
{"id": "381", "input": "a, b = list(map(int, input().split(' ')))\\nc, d = list(map(int, input().split(' ')))\\ne, f = list(map(int, input().split(' ')))\\nx=[[a, b],[c,d],[e,f]]\\nx.sort()\\na, b, c, d, e, f = x[0][0], x[0][1], x[1][0], x[1][1], x[2][0], x[2][1]\\nif (a==c==e or b==d==f):\\n print(1)\\n quit()\\n\\nif a", "gt": "== c:\\n if b<f<d:\\n print(3)\\n quit()\\n print(2)\\n quit()\\n\\nif c == e:\\n if (d<b<f):\\n print(3)\\n quit()\\n print(2)\\n quit()\\n\\nif b == d:\\n print(2)\\n quit()\\n\\nif d == f:\\n print(2)\\n quit()\\n\\nif b == f:\\n if a<c<e:\\n print(3)\\n quit()\\n print(2)\\n quit()\\n\\nprint(3)\\nquit()\\n"}
{"id": "382", "input": "import math,string,itertools,fractions,heapq,collections,re,array,bisect\\nfrom itertools import chain, dropwhile, permutations, combinations\\nfrom collections import defaultdict, deque\\n\\ndef VI(): return list(map(int,input().split()))\\n\\ndef main1(k):\\n # works correctly, but too slow and generates many more vertices than necessary.\\n # doesn't pass the time constraint with this implementation. (prints 10^5 lines)\\n # ==> use the editorial solution below.\\n if k%2==0:\\n print(\"NO\")\\n return\\n print(\"YES\")\\n n = 2*(k**2-k+1)\\n m = n*k//2\\n print(n, m)\\n i = 0\\n g = [[] for i in range(n+1)]\\n print(1,n//2+1)\\n off = 1\\n for j in range(0,k-1,2):\\n j1 = off + j+1\\n j2 = off + j+2\\n print(off,j1)\\n print(off,j2)\\n l1 = off + k + j*(k-1)\\n l2 = off + k + (j+1)*(k-1)\\n for l in range(k-1):\\n print(j1, l1+l)\\n print(j2, l2+l)\\n for m in range(k-1):\\n print(l1+l,l2+m)\\n off = n//2+1\\n for j in range(0,k-1,2):\\n j1 = off + j+1\\n j2 = off + j+2\\n print(off,j1)\\n", "gt": "print(off,j2)\\n l1 = off + k + j*(k-1)\\n l2 = off + k + (j+1)*(k-1)\\n for l in range(k-1):\\n print(j1, l1+l)\\n print(j2, l2+l)\\n for m in range(k-1):\\n print(l1+l,l2+m)\\n\\ndef main(k):\\n # following the editorial algo\\n if k%2==0:\\n print(\"NO\")\\n return\\n print(\"YES\")\\n if k==1:\\n print(\"2 1\")\\n print(\"1 2\")\\n return\\n n = 2*k+4\\n m = n*k//2\\n e = []\\n e.extend([(1,n//2+1)])\\n off = 1\\n for j in range(off+1,off+k):\\n e.extend([(off, j)])\\n for j in range(off+1,off+k):\\n for i in range(j+1,off+k):\\n if (i==j+1 and (j-off)%2==1):# or (j==off+1 and i==off+k-1):\\n #if (i==j+1 and i%2==0) or (j==off+1 and i==off+k-1):\\n continue\\n e.extend([(j,i)])\\n e.extend([(j,off+k),(j,off+k+1)])\\n e.extend([(off+k,off+k+1)])\\n off = n//2+1\\n for j in range(off+1,off+k):\\n e.extend([(off, j)])\\n for j in range(off+1,off+k):\\n for i in range(j+1,off+k):\\n if (i==j+1 and (j-off)%2==1):# or (j==off+1 and i==off+k-1):\\n continue\\n e.extend([(j,i)])\\n e.extend([(j,off+k),(j,off+k+1)])\\n e.extend([(off+k,off+k+1)])\\n print(n, m)\\n for x in e:\\n print(*x)\\n\\n\\n\\ndef main_input(info=0):\\n k = int(input())\\n main(k)\\n\\ndef __starting_point():\\n main_input()\\n\\n__starting_point()"}
{"id": "383", "input": "# \\nimport collections, atexit, math, sys, bisect \\n\\nsys.setrecursionlimit(1000000)\\ndef getIntList():\\n return list(map(int, input().split())) \\n\\ntry :\\n #raise ModuleNotFoundError\\n import numpy\\n def dprint(*args, **kwargs):\\n print(*args, **kwargs, file=sys.stderr)\\n dprint('debug mode')\\nexcept ModuleNotFoundError:\\n def dprint(*args, **kwargs):\\n pass\\n\\n\\n\\ninId = 0\\noutId = 0\\nif inId>0:\\n dprint('use input', inId)\\n sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\\nif outId>0:\\n dprint('use output', outId)\\n", "gt": "sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\\n atexit.register(lambda :sys.stdout.close()) #idle 中不会执行 atexit\\n \\nN, M, Q = getIntList()\\n\\ns1 = input()\\ns2 = input()\\n\\ntot = 0\\nzt = [0]\\n\\nfor i in range(N):\\n if s1[i:i+M] == s2:\\n tot+=1\\n zt.append(tot)\\ndprint(zt)\\nfor i in range(Q):\\n a,b = getIntList()\\n b0 = b- M+1\\n if b0<a:\\n print(0)\\n else:\\n print(zt[b0] - zt[a-1])\\n\\n\\n\\n\\n\\n\\n\\n"}
{"id": "384", "input": "ans = {}\\n\\ndef gen(n, k, d, used = False):\\n if not ans.get((n, k, d, used)):\\n if not n and used:\\n ans[(n, k, d, used)] = 1\\n else:\\n ans[(n, k, d, used)] = sum(gen(n - x, k,", "gt": "d, used or x >= d) for x in range(1, min(n, k) + 1) if max(x, n - x) >= d or used)\\n return ans[(n, k, d, used)]\\n\\n\\nn, k, d = list(map(int, input().split()))\\nprint(gen(n, k, d) % 1000000007)\\n"}
{"id": "385", "input": "# You lost the game.\\n\\nn = int(input())\\ns = str(input())\\n\\nR = []\\nb = 0\\nfor i in range(n):\\n if s[i] == \"B\":\\n b +=", "gt": "1\\n elif b > 0:\\n R += [b]\\n b = 0\\nif b > 0:\\n R += [b]\\nprint(len(R))\\nfor i in range(len(R)):\\n print(R[i],end=\" \")\\n"}
{"id": "386", "input": "n, m, p = [int(x) for x in input().split()]\\nA = input().rstrip()\\nB = input().rstrip()\\n\\npair = [0] * n\\nstack = []\\nfor (i, c) in enumerate(A):\\n if c == '(':\\n stack.append(i)\\n else:\\n j = stack.pop()\\n pair[i] = j\\n pair[j] = i\\n\\nstart = 0\\npointer = p - 1\\nleft = list(range(-1, n-1))\\nright = list(range(1, n+1))\\nleft[0] = None\\nright[-1] = None\\n\\nfor c in B:\\n if c == 'R':\\n pointer = right[pointer]\\n elif c == 'L':\\n pointer = left[pointer]\\n else:\\n if pair[pointer] < pointer:\\n", "gt": "if right[pointer] is not None:\\n left[right[pointer]] = left[pair[pointer]]\\n if left[pair[pointer]] is not None:\\n right[left[pair[pointer]]] = right[pointer]\\n else:\\n start = right[pointer]\\n\\n if right[pointer] is None:\\n pointer = left[pair[pointer]]\\n else:\\n pointer = right[pointer]\\n else:\\n if right[pair[pointer]] is not None:\\n left[right[pair[pointer]]] = left[pointer]\\n if left[pointer] is not None:\\n right[left[pointer]] = right[pair[pointer]]\\n else:\\n start = right[pair[pointer]]\\n\\n\\n if right[pair[pointer]] is None:\\n pointer = left[pointer]\\n else:\\n pointer = right[pair[pointer]]\\n\\ni = start\\nwhile right[i] is not None:\\n print(A[i], end = '')\\n i = right[i]\\nprint(A[i])\\n"}
{"id": "387", "input": "\"\"\"\\nCodeforces Round 241 Div 1 Problem A\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\nclass InputHandlerObject(object):\\n inputs = []\\n\\n def getInput(self, n = 0):\\n res = \"\"\\n inputs = self.inputs\\n if not inputs: inputs.extend(input().split(\" \"))\\n if n == 0:\\n res = inputs[:]\\n inputs[:] = []\\n while n > len(inputs):\\n inputs.extend(input().split(\" \"))\\n if n > 0:\\n res = inputs[:n]\\n inputs[:n] = []\\n return res\\nInputHandler = InputHandlerObject()\\ng = InputHandler.getInput\\n\\n############################## SOLUTION ##############################\\nn = int(input().strip())\\nmn = -2*10**9\\nmx =", "gt": "2*10**9\\nrepl = [(\">\", \"<=\"), (\">=\", \"<\"), (\"<=\", \">\"), (\"<\", \">=\")]\\nfor i in range(n):\\n a = g()\\n a[1] = int(a[1])\\n if a[2] == \"N\":\\n for qq,qqq in repl:\\n if qq == a[0]:\\n a[0] = qqq\\n break\\n if a[0] == \">\": a[1] += 1\\n if a[0] == \"<\": a[1] -= 1\\n if a[0][0] == \">\": mn = max(mn, a[1])\\n if a[0][0] == \"<\": mx = min(mx, a[1])\\n\\nif mn <= mx:\\n print(mn)\\nelse:\\n print(\"Impossible\")"}
{"id": "388", "input": "import math\\na,b= list(map(int,input().split()))\\nn=a+b\\nans,l=0,1\\nwhile l<=n:\\n g= n//l\\n if a<g or b<g:\\n l= (n//g) +1\\n continue\\n r= n//g\\n a_low = (a+g)//(g+1)\\n a_high", "gt": "= a//g\\n b_low=(b+g)//(g+1)\\n b_high = b//g\\n if (a_low <= a_high and b_low <= b_high):\\n ans += max(0,min(r,a_high+b_high)- max(l,a_low +b_low)+1)\\n\\n l=r+1\\nprint(ans)\\n"}
{"id": "389", "input": "n, k = list(map(int, input().split()))\\na = input().split()\\nnames = [chr(ord(\"A\") + i) for i in range(26)] + [chr(ord(\"A\") + i) + chr(ord('a') + i) for i in range(26)]\\nans", "gt": "= [names[i] for i in range(n)]\\nfor i in range(k - 1, n):\\n if a[i - k + 1] == \"NO\":\\n ans[i] = ans[i - k + 1]\\nprint(*ans)\\n"}
{"id": "390", "input": "a,b=list(map(int,input().split()))\\ndef gcd(a,b):\\n if(b==0):\\n return a\\n return gcd(b,a%b)\\ndef burn(n):\\n c=0\\n while(n%2==0):\\n c+=1\\n n=n//2\\n while(n%3==0):\\n c+=1\\n n=n//3\\n while(n%5==0):\\n", "gt": "c+=1\\n n=n//5\\n return [c,n]\\nif(a==b):\\n print(0)\\nelse:\\n g=gcd(a,b)\\n c=a//g\\n d=b//g\\n l1=burn(c)\\n l2=burn(d)\\n if(l1[1]==1 and l2[1]==1):\\n print(l1[0]+l2[0])\\n else:\\n print(-1)\\n"}
{"id": "391", "input": "# import sys\\n# sys.stdin = open(\"F:\\\\Scripts\\\\input\",\"r\")\\n# sys.stdout = open(\"F:\\\\Scripts\\\\output\",\"w\")\\n\\n\\nMOD = 10**9 + 7\\nI = lambda:list(map(int,input().split()))\\n\\nn , a , b = I()\\nl = I()\\ncost = 0\\nm = min(a,b)\\nfor i in range(n//2):\\n if l[i] + l[n-i-1] == 1:\\n print(-1)\\n return\\n if l[i] == 2 and l[n - i", "gt": "- 1] == 2:\\n cost += 2*m\\n elif l[i] == 2 or l[n - i - 1] == 2:\\n if l[i] == 1 or l[n - i - 1] == 1:\\n cost += b\\n else:\\n cost += a\\nif n%2 and l[n//2] == 2:\\n cost += m\\nprint(cost)"}
{"id": "392", "input": "K = int(input())\\nprint((\"-1\" if K & 1 else \"\".join([\"wb\\n\"[2 if k == K else (min(j, k, K - 1 - j,\\n K - 1", "gt": "- k) ^ i) & 1] for i in range(2) for j in range(K) for k in range(K +\\n 1)]) * (K >> 1)))\\n"}
{"id": "393", "input": "n = int(input())\\nans = 1\\ni = 2\\nwhile i * i <= n:\\n if n % i ==", "gt": "0:\\n ans *= i\\n while n % i == 0:\\n n //= i\\n i += 1\\nans *= n\\nprint(ans)"}
{"id": "394", "input": "n = int(input())\\na = '0'+input()+'0'\\nif '000'", "gt": "in a or '11' in a:print('No')\\nelse:print('Yes')\\n"}
{"id": "395", "input": "n = int(input())\\na = list(map(int, input().split()))\\nans = []\\n\\nfor k in range(1, n + 1):\\n x = [0] * k\\n\\n x[0] = a[0]\\n for i in range(1, k):\\n x[i] =", "gt": "a[i] - a[i - 1]\\n\\n ok = True\\n for i in range(k, n):\\n if x[i % k] != a[i] - a[i - 1]:\\n ok = False\\n break\\n if ok:\\n ans.append(k)\\n\\nprint(len(ans))\\nprint(*ans)\\n"}
{"id": "396", "input": "a = list(map(int, input().split()))\\ns = sum(a)\\nfor i in range(6):\\n for j in range(i):\\n for k in", "gt": "range(j):\\n ss = a[i] + a[j] + a[k]\\n if ss == s - ss:\\n print('YES')\\n return\\nprint('NO')\\n"}
{"id": "397", "input": "a,b=map(int,input().split())\\nans=0\\nfor i in range(0,40):\\n for j", "gt": "in range(0,40):\\n if (2**i)*(3**j)>=a and (2**i)*(3**j)<=b:\\n ans+=1\\nprint(ans)"}
{"id": "398", "input": "n,k=map(int,input().split())\\nlow=1\\nhigh=n\\nimport sys\\nwhile low<=high:\\n mid=(low+high)//2\\n if mid*(mid+1)//2 -(n-mid)>k:\\n", "gt": "high=mid-1\\n elif mid*(mid+1)//2-(n-mid)==k:\\n print(n-mid)\\n return\\n else :\\n low=mid+1"}
{"id": "399", "input": "n = int(input())\\na = list(map(int, input().split()))\\na.sort()\\nok = False\\nfor i in range(n - 2):\\n", "gt": "if a[i] + a[i + 1] > a[i + 2]:\\n ok = True\\nprint((\"NO\", \"YES\")[ok])"}
{"id": "400", "input": "x, y = map(int, input().split())\\n\\nif y == 0:\\n print('No')\\n return\\nelse:\\n y -= 1\\n\\nif y ==", "gt": "0 and x:\\n print('No')\\n return\\n\\nif y > x or (x - y) & 1:\\n print('No')\\nelse:\\n print('Yes')"}
{"id": "401", "input": "import sys\\n\\ndef solve():\\n n,k, = rv()\\n a, = rl(1)\\n res = 0\\n count = [0] * 10\\n for i in range(n):\\n if a[i] < 100:\\n count[10 - (a[i] % 10) - 1] += 1\\n res += a[i] // 10\\n for i in range(10):\\n while count[i] > 0 and k >= i + 1:\\n res += 1\\n count[i] -= 1\\n k -=", "gt": "i + 1\\n already = res * 10\\n possible = n * 100\\n diff = possible - already\\n if diff > 0:\\n actual = min(diff, k)\\n res += actual // 10\\n print(res)\\n\\n\\n\\n\\n\\n\\ndef prt(l): return print(' '.join(map(str, l)))\\ndef rs(): return map(str, input().split())\\ndef rv(): return map(int, input().split())\\ndef rl(n): return [list(map(int, input().split())) for _ in range(n)] \\nif sys.hexversion == 50594544 : sys.stdin = open(\"test.txt\")\\nsolve()"}
{"id": "402", "input": "n, m = map(int, input().split())\\na = [int(i) for i in input().split()]\\nb = [int(i) for i in", "gt": "input().split()]\\na.sort()\\nb.sort()\\nfor i in a:\\n if i in b:\\n print(i)\\n break\\nelse:\\n print(min(a[0], b[0]), max(a[0], b[0]), sep = '')\\n"}
{"id": "403", "input": "\"\"\"\\nCodeforces Good Bye 2016 Contest Problem A\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.5.2\\n\"\"\"\\n\\n################################################### SOLUTION\\n\\ndef main():\\n n,k = read()\\n avail = 240-k\\n i = 1\\n while i <= n and avail >=", "gt": "5*i:\\n avail -= 5*i\\n i += 1\\n print(i-1)\\n\\n#################################################### HELPERS\\n\\ndef read(callback=int):\\n return list(map(callback, input().strip().split()))\\n\\ndef write(value, end=\"\\n\"):\\n if value is None: return\\n try:\\n value = \" \".join(map(str, value))\\n except:\\n pass\\n print(value, end=end)\\n\\nwrite(main())\\n"}
{"id": "404", "input": "import sys,math\\nn,x,y=list(map(int,input().split()))\\nz=list(map(int,input().split()))\\nz.sort()\\nans=0\\nfor i in range(n):\\n if z[i]%2==0:\\n if x>=z[i]//2:\\n x-=z[i]//2\\n ans+=1\\n else:\\n z[i]-=x*2\\n x=0\\n y-=z[i]\\n if y>=0:\\n ans+=1\\n else:\\n break\\n else:\\n if x>=z[i]//2 and", "gt": "y>=1:\\n x-=z[i]//2\\n ans+=1\\n y-=1\\n elif x>=z[i]//2+1:\\n x-=z[i]//2+1\\n ans+=1\\n else:\\n z[i]-=x*2\\n x=0\\n y-=z[i]\\n if y>=0:\\n ans+=1\\n else:\\n break\\nprint(ans)\\n \\n \\n \\n \\n \\n \\n \\n \\n\\n\\n\\n"}
{"id": "405", "input": "#JMD\\n#Nagendra Jha-4096\\n\\n \\nimport sys\\nimport math\\n\\n#import fractions\\n#import numpy\\n \\n###File Operations###\\nfileoperation=0\\nif(fileoperation):\\n orig_stdout = sys.stdout\\n orig_stdin = sys.stdin\\n inputfile = open('W:/Competitive Programming/input.txt', 'r')\\n outputfile = open('W:/Competitive Programming/output.txt', 'w')\\n sys.stdin = inputfile\\n sys.stdout = outputfile\\n\\n###Defines...###\\nmod=1000000007\\n \\n###FUF's...###\\ndef nospace(l):\\n ans=''.join(str(i) for i in l)\\n return ans\\n\\nans=[]\\n\\ndef printDivisors(n) : \\n \\n # Note that this loop runs till square root \\n i = 1\\n while i <= math.sqrt(n): \\n \\n if (n % i ==", "gt": "0) : \\n \\n # If divisors are equal, print only one \\n if (n / i == i) : \\n ans.append(i) \\n else : \\n # Otherwise print both \\n ans.append(i)\\n ans.append(n//i) \\n i = i + 1\\n \\n \\n \\n##### Main ####\\nt=1\\nfor tt in range(t):\\n n=int(input())\\n printDivisors(n)\\n s=set(ans)\\n print(len(s))\\n #a=list(map(int,sys.stdin.readline().split(' ')))\\n #n,k,s= map(int, sys.stdin.readline().split(' '))\\n \\n \\n#####File Operations#####\\nif(fileoperation):\\n sys.stdout = orig_stdout\\n sys.stdin = orig_stdin\\n inputfile.close()\\n outputfile.close()"}
{"id": "406", "input": "n = int(input())\\ns = input()\\nl = 0\\nans = 0\\nwhile l < len(s) and s[l] == '<':\\n ans += 1\\n", "gt": "l += 1\\n\\nr = n - 1\\nwhile r >= 0 and s[r] == '>':\\n ans += 1\\n r -= 1\\n\\nprint(ans)\\n"}
{"id": "407", "input": "arr = [0] * (10 ** 6 + 1)\\nn = int(input())\\nfor i in input().split():\\n arr[int(i)] += 1\\ni = 10 ** 6\\nj = i\\nk = i\\nc = 0\\nwhile j > 0:\\n if arr[j] % 2 == 1 and (arr[j] > 1 or c == 0):\\n arr[j - 1] += 1\\n c = 1\\n else:\\n c = 0\\n", "gt": "j -= 1\\nr = 0\\nwhile i > 0 and k > 0:\\n if arr[i] < 2:\\n if i == k:\\n k -= 1\\n i -= 1\\n elif i == k and arr[i] < 4:\\n k -= 1\\n elif arr[k] < 2:\\n k -= 1\\n else:\\n r += i * k\\n arr[i] -= 2\\n arr[k] -= 2\\nprint(r)"}
{"id": "408", "input": "'''input\\n3\\naa\\njj\\naa\\n'''\\n\\ndef list_input():\\n return list(map(int,input().split()))\\ndef map_input():\\n return map(int,input().split())\\ndef map_string():\\n return input().split()\\n \\nn = int(input())\\nd = {}\\npos = {}\\nfor _ in range(n):\\n s = list(input())\\n s = s[::-1]\\n for i in range(len(s)):\\n try:\\n d[s[i]] += 10**i\\n except:\\n d[s[i]]", "gt": "= 10**i\\n pos[s[i]] = True\\n if i == len(s)-1:\\n pos[s[i]] = False \\na = []\\nb = []\\nfor i in d:\\n a.append(d[i])\\n if pos[i]:\\n b.append(d[i])\\nif len(b):a.remove(max(b))\\na.sort(reverse = True)\\n# print(a)\\nans = 0\\nfor i in range(len(a)):\\n ans += (i+1)*a[i]\\nprint(ans)"}
{"id": "409", "input": "a, b = list(map(int,", "gt": "input().split(' ')))\\nprint(min([a, b, (a+b)//3]))\\n"}
{"id": "410", "input": "a = []\\nb = []\\nx = input()\\nfor i in range(len(x)-1):\\n if x[i]+x[i+1] == 'AB':\\n a.append(i)\\n elif x[i]+x[i+1]", "gt": "== 'BA':\\n b.append(i)\\n\\nif a == [] or b == []:\\n print(\"NO\")\\n quit()\\n \\nif abs(min(a)-max(b))>1 or abs(max(a)-min(b))>1:\\n print(\"YES\")\\n quit()\\nprint(\"NO\")\\n"}
{"id": "411", "input": "import sys\\n\\na = [0,]\\nb = [0,]\\nans1 = []\\nans2 = []\\nn = int(input())\\ns = input()\\nnums = s.split()\\nfor i in range(0, n):\\n a.append(int(nums[i]))\\n\\nk = int(input())\\ns = input()\\nnums = s.split()\\nfor i in range(0, k):\\n b.append(int(nums[i]))\\n\\ndef f(x, y, z):\\n #print(x,y,z)\\n pos1 = x\\n pos2 = x\\n if x == y:\\n return 1\\n for i in range(x, y + 1):\\n if a[i] > a[pos1]:\\n pos1 = i\\n if a[i] >= a[pos2]:\\n pos2 = i\\n for i in range(x, y):\\n if a[i] == a[pos2]:\\n if a[i + 1] < a[i]:\\n pos2 = i\\n for i in range(x + 1, y + 1):\\n if a[i] == a[pos1]:\\n if a[i - 1] < a[i]:\\n pos1 = i\\n if pos1 != x or a[pos1] > a[pos1 + 1]:\\n for i in range(0, pos1", "gt": "- x):\\n ans1.append(pos1 - x + z - i)\\n ans2.append('L')\\n for i in range(0, y - pos1):\\n ans1.append(z)\\n ans2.append('R')\\n elif pos2 != y or a[pos2] > a[pos2 - 1]:\\n for i in range(0, y - pos2):\\n ans1.append(pos2 - x + z)\\n ans2.append('R')\\n for i in range(0, pos2 - x):\\n ans1.append(pos2 - x + z - i)\\n ans2.append('L')\\n else:\\n return 0\\n\\n return 1\\n\\nlasti = 0\\nj = 1\\nsum = 0\\nfor i in range(1, n+1):\\n if j > k:\\n print('NO')\\n return\\n sum += a[i]\\n #print(i, sum, j)\\n if sum > b[j]:\\n print('NO')\\n return\\n if sum == b[j]:\\n if f(lasti + 1, i, j) == 0:\\n print('NO')\\n return\\n lasti = i\\n j += 1\\n sum = 0\\n\\nif j <= k:\\n print('NO')\\n return\\n\\nprint('YES')\\nfor i in range(0, len(ans1)):\\n print(ans1[i], ans2[i])"}
{"id": "412", "input": "a, b = list(map(int,", "gt": "input().split()))\\nif a==b: print(\"Yes\")\\nelse: print(\"No\")\\n"}
{"id": "413", "input": "n = int(input())\\nl = list(map(int, input().split()))\\nmax1 = 1\\nfor i in l:\\n k = 1\\n x = i\\n while x % 2 == 0:\\n k", "gt": "*= 2\\n x //= 2\\n max1 = max(max1, k)\\nc = 0\\nfor i in l:\\n if i % max1 == 0:\\n c += 1\\nprint(max1, c)"}
{"id": "414", "input": "def main():\\n n, m = map(int, input().split())\\n res, delta = 0, 1\\n while n < m:\\n res += 1\\n n *= 2\\n delta", "gt": "*= 2\\n while n > m:\\n while n - delta >= m:\\n res += 1\\n n -= delta\\n delta //= 2\\n print(res)\\n\\n\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "415", "input": "import sys\\nreader = (s.rstrip() for s in sys.stdin)\\ninput = reader.__next__\\n\\nclass BIT_RSQ():\\n def __init__(self, n):\\n self.n = n\\n self.data = [0]*(n+2)\\n\\n def add(self, i, v):\\n while i <= self.n:\\n self.data[i] += v\\n i += i & -i\\n\\n def sum(self, i):\\n ret = 0\\n while(i > 0):\\n ret += self.data[i]\\n i -= i & -i\\n return ret\\n\\n def query(self, l, r):\\n return self.sum(r) - self.sum(l-1)\\n\\n def lowerBound(self, w):\\n if w <= 0: return 0\\n x, k = 0, 2**self.n.bit_length()\\n while k:\\n if x+k <= self.n and self.data[x+k] < w:\\n w -= self.data[x+k]\\n x += k\\n k >>= 1\\n return x + 1\\n\\nn = int(input())\\nedges = [0]*(2*n)\\nc = [0]*(2*n)\\nBIT", "gt": "= BIT_RSQ(2*n)\\n\\nuf = [-1]*n\\ndef root(x):\\n if uf[x] < 0:\\n return x\\n uf[x] = root(uf[x])\\n return uf[x]\\ndef unite(x,y):\\n rx, ry = root(x), root(y)\\n if rx == ry:\\n return False\\n if uf[rx] > uf[ry]:\\n rx, ry = ry, rx\\n uf[rx] += uf[ry]\\n uf[ry] = rx\\n return True\\n\\nfor i in range(n):\\n a,b = list(map(int, input().split()))\\n a,b = a-1,b-1\\n c[a] = c[b] = i\\n edges[a] = b\\n edges[b] = b\\n\\nfor i in reversed(list(range(2*n))):\\n j = edges[i]\\n if j == i:\\n BIT.add(j+1, 1)\\n else:\\n BIT.add(j+1, -1)\\n cnt = BIT.sum(j+1)\\n while cnt:\\n k = BIT.lowerBound(cnt)\\n if not unite(c[j], c[k-1]):\\n print(\"NO\")\\n return\\n cnt -= 1\\nif sum(i<0 for i in uf) == 1:\\n print(\"YES\")\\nelse:\\n print(\"NO\")\\n\\n"}
{"id": "416", "input": "def prog():\\n n = int(input())\\n inp = list(map(int,input().split()))\\n ans = 0\\n for i in range(len(inp)):\\n", "gt": "x,y = 0 ,0\\n for j in range(i,len(inp)):\\n x+=inp[j]\\n y+=100\\n if(x>y):\\n ans = max(ans,(j-i)+1)\\n print(ans)\\nprog()"}
{"id": "417", "input": "import sys\\n\\nn, k = list(map(int, input().split(' ')))\\n\\ns = input()\\n\\ndef max_streak(s):\\n result = 0\\n\\n for i in range(len(s)):\\n j = i\\n while j < len(s) and s[j] == 'N':\\n j += 1\\n\\n result = max(result, j - i)\\n\\n return result\\n\\nfor i in range(n - k + 1):\\n cur", "gt": "= list(s)\\n for j in range(i, i + k):\\n if cur[j] == '?':\\n cur[j] = 'N'\\n\\n for j in range(i):\\n if cur[j] == '?':\\n cur[j] = 'Y'\\n\\n for j in range(i + k, n):\\n if cur[j] == '?':\\n cur[j] = 'Y'\\n\\n if max_streak(cur) == k:\\n print('YES')\\n return\\n\\nprint('NO')\\n"}
{"id": "418", "input": "def solve():\\n N, X, D = list(map(int, input().split()))\\n\\n if D == 0:\\n if X == 0:\\n print((1))\\n else:\\n print((N+1))\\n return\\n\\n LRss = {}\\n for k in range(N+1):\\n m = X*k\\n rem = m%D\\n minCoef = m//D + k*(k-1)//2\\n maxCoef = m//D + k*(2*N-k-1)//2\\n if rem not in LRss:\\n LRss[rem] = [(minCoef, maxCoef)]\\n", "gt": "else:\\n LRss[rem].append((minCoef, maxCoef))\\n\\n ans = 0\\n for rem, LRs in list(LRss.items()):\\n LRs.sort()\\n LNow, RNow = LRs[0]\\n for L, R in LRs[1:]:\\n if L <= RNow:\\n if R > RNow:\\n RNow = R\\n else:\\n ans += RNow - LNow + 1\\n LNow, RNow = L, R\\n ans += RNow - LNow + 1\\n\\n print(ans)\\n\\n\\nsolve()\\n"}
{"id": "419", "input": "read = lambda: map(int, input().split())\\nn = int(input())\\nfor i in range(n):\\n name, x, y = input().split()\\n", "gt": "x, y = int(x), int(y)\\n if x >= 2400 and y > x:\\n print('YES')\\n return\\nprint('NO')"}
{"id": "420", "input": "s = int(input(), 2)\\n\\nt, ans = 1, 0\\n\\nwhile", "gt": "t < s:\\n ans += 1\\n t *= 4\\n\\nprint(ans)\\n"}
{"id": "421", "input": "n,m = [int(i) for i in input().split()]\\nl = []\\nfor i in range(n):\\n l.append(input().strip())\\nwhile len(l)%2 == 0:\\n mirror = True\\n", "gt": "for i in range(len(l)//2):\\n if l[i] != l[len(l)-1-i]:\\n mirror = False\\n break\\n if mirror:\\n l = l[:len(l)//2]\\n else:\\n break\\n\\nprint(len(l))\\n"}
{"id": "422", "input": "def key_tri(argument):\\n return argument[1]\\n\\nn = int(input())\\nL = [list(map(int, input().split())) for _ in range(n)]\\nL.sort(key=key_tri)\\nr", "gt": "= 1\\nt = L[0][1]\\nfor k in range(1,n):\\n if L[k][0]>t:\\n r+=1\\n t = L[k][1]\\nprint(r)\\n"}
{"id": "423", "input": "def max(a, b):\\n if a > b:\\n return a\\n else:\\n return b\\nn, k = map(int, input().split())\\nx = [int(t) for t in input().split()]\\ny = [int(t) for t in input().split()]\\nf, s = 0, 0\\nfor", "gt": "i in range(n):\\n f = max(0, x[i] + f - k * y[i])\\n s = max(0, y[i] + s - k * x[i])\\n if f > k or s > k:\\n print('NO')\\n return\\nprint('YES')"}
{"id": "424", "input": "p=1048583\\nq=1048589\\nmodd=p*q*p*q\\nn,k=tuple(map(int,input().split()))\\na=[0]\\nwenhao=0\\ngai=0\\nfor i in range(n+1):\\n m=input()\\n if m[0]=='?':\\n a.append('?')\\n wenhao+=1\\n else:\\n a.append(int(m))\\n gai+=1\\n\\nif k==0:\\n if (a[1]=='?' and gai&1==1) or a[1]==0:\\n print('Yes')\\n else:\\n", "gt": "print('No')\\nelse:\\n if wenhao!=0:\\n if n&1==1:\\n print('Yes')\\n else:\\n print('No')\\n else:\\n m=a[n+1]\\n nn=a[n]\\n for i in range(n,0,-1):\\n m,nn=(nn+k*m)%modd,a[i-1]\\n if m==0:\\n print('Yes')\\n else:\\n print('No')\\n"}
{"id": "425", "input": "from math import floor, sqrt\\nimport bisect\\n\\nimport math\\n\\n\\ndef rwh_primes2(n):\\n # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\\n \"\"\" Input n>=6, Returns a list of primes, 2 <= p < n \"\"\"\\n correction = (n%6>1)\\n n = {0:n,1:n-1,2:n+4,3:n+3,4:n+2,5:n+1}[n%6]\\n sieve = [True] * (n//3)\\n sieve[0] = False\\n for i in range(int(n**0.5)//3+1):\\n if sieve[i]:\\n k=3*i+1|1\\n sieve[ ((k*k)//3) ::2*k]=[False]*((n//6-(k*k)//6-1)//k+1)\\n sieve[(k*k+4*k-2*k*(i&1))//3::2*k]=[False]*((n//6-(k*k+4*k-2*k*(i&1))//6-1)//k+1)\\n return [2,3] + [3*i+1|1 for i in range(1,n//3-correction) if sieve[i]]\\n\\n\\nk =", "gt": "int(input())\\n\\nprimes = rwh_primes2(k)\\n\\na = 1\\np2 = 2\\nfor i in primes[::-1]:\\n if k%i == 0:\\n p2 = i\\n break\\n\\nxx = range(k-p2+1, k+1)\\n#print(list(xx))\\nif p2>240:\\n p1 = primes[bisect.bisect_left(primes, int(math.ceil(xx[0]/2)))]\\n print(p1+1)\\nelse:\\n ans = k\\n p1 = 1\\n for x1 in xx:\\n for i in primes[::-1]:\\n\\n if i >= x1:\\n continue\\n\\n if x1 % i == 0:\\n p1 = i\\n break\\n ans = min(ans, x1-p1+1)\\n\\n print(ans)"}
{"id": "426", "input": "n, p = list(map(int, input().split()))\\nfor q in range(5757):\\n s = bin(n)\\n", "gt": "if n >= q >= s.count('1'):\\n print(q)\\n break\\n n -= p\\nelse:\\n print(-1)\\n"}
{"id": "427", "input": "n, k = list(map(int, input().split()))\\ns = list(input())\\nif len(s) == 1 and k:\\n print(0)\\n return\\nif s[0] != '1' and k:\\n k -= 1\\n", "gt": "s[0] = '1'\\nfor i in range(1, len(s)):\\n if s[i] != '0' and k:\\n s[i] = '0'\\n k -= 1\\n if not k:\\n break\\nprint(''.join(s))\\n\\n"}
{"id": "428", "input": "n0, n1, x, y = list(map(int, input().split()))\\n\\ndef f(m, n, x, y):\\n return max(0, n - (m // y - m // (x * y)))\\n\\nlo = -1\\nhi = x * y * (n0 + n1)\\nwhile lo + 1 < hi:\\n mid", "gt": "= lo + (hi - lo) // 2\\n if f(mid, n0, x, y) + f(mid, n1, y, x) <= mid - mid // x - mid // y + mid // (x * y):\\n hi = mid\\n else:\\n lo = mid\\nprint(hi)\\n"}
{"id": "429", "input": "#Simple non-optimized class of matrices. Used with small dense matrices.\\nimport functools\\nimport itertools\\nimport math\\n\\nclass NotAMatrixError(Exception):\\n pass\\n\\nclass MatrixSizeError(Exception):\\n def __init__(self, s1, s2):\\n print('sizes do not match : ', s1, ', ', s2)\\n\\nclass NotSquareError(Exception):\\n pass\\n\\nclass Matrix(list):\\n def __init__(self, L):\\n if type(L) == type(self):\\n self = L\\n return\\n n = len(L)\\n m = len(L[0])\\n for i in range(n):\\n if len(L[i]) != m:\\n raise NotAMatrixError()\\n list.__init__(self, L)\\n self.n = n\\n self.m = m\\n self.degrees = []\\n def check_size(self, M, mode):\\n n, m = len(M), len(M[0])\\n for i in range(n):\\n if len(M[i]) != m:\\n raise NotAMatrixError()\\n \\n if mode == 'add' and (self.n != n or self.m != m):\\n raise MatrixSizeError((self.n, self.m), (n,m))\\n if mode == 'lul' and self.m != n:\\n print(self.m, n, self.m != n)\\n raise MatrixSizeError((self.n, self.m), (n,m))\\n def __add__(self, M):\\n self.check_size(M, mode = 'add')\\n return Matrix([[self[i][j]+M[i][j] for j in range(self.m)]for i in range(self.n)])\\n def __iadd__(self, M):\\n self.check_size(M, mode = 'add')\\n for i in range(self.n):\\n for j in range(self,m):\\n self[i][j] += M[i][j]\\n def __mul__(self, M):\\n self.check_size(M, mode = 'mul')\\n l = len(M[0])\\n return Matrix([[sum(self[i][k]*M[k][j] for k in range(self.m))\\n for j in range(l)] for i in range(self.n)])\\n def issquare(self):\\n return self.n == self.m\\n def primary(self):\\n if self.n != self.m:\\n raise NotSquareError()\\n return Matrix([[int(i==j) for j in range(self.m)] for i in range(self.n)])\\n def __pow__(self, n):\\n if self.n != self.m:\\n raise NotSquareError()\\n if n == 0:\\n return self.primary()\\n elif n", "gt": "== 1:\\n return self\\n if len(self.degrees) == 0:\\n self.degrees.append(self*self)\\n for i in range(n.bit_length() - len(self.degrees) - 1):\\n self.degrees.append(self.degrees[-1] * self.degrees[-1])\\n s = [(n>>i)&1 for i in range(1,n.bit_length())]\\n res = functools.reduce(lambda x,y:x*y, itertools.compress(self.degrees, s))\\n return res*self if n%2 else res \\n def drop_degrees(self):\\n self.degrees.clear()\\n\\nclass Remainder(int):\\n def __new__(self, n, p):\\n obj = int.__new__(self, n%p)\\n obj.p = p\\n return obj\\n def __mul__(self, m): return Remainder(int.__mul__(self, m), self.p)\\n def __add__(self, m): return Remainder(int.__add__(self, m), self.p)\\n def __sub__(self, m): return Remainder(int.__sub__(self, m), self.p)\\n def __rmul__(self, m): return Remainder(int.__rmul__(self, m), self.p)\\n def __radd__(self, m): return Remainder(int.__radd__(self, m), self.p)\\n def __rsub__(self, m): return Remainder(int.__rsub__(self, m), self.p)\\n def __neg__(self): return Remainder(int.__neg__(self), self.p)\\n def __pow__(self, m): return Remainder(int.__pow__(self, m, self.p), self.p)\\n\\ndef solve(n, sx, sy, dx, dy, t):\\n o, l, j = Remainder(0, n), Remainder(1, n), Remainder(2, n)\\n N = [[j, l, l, o, l, o],\\n [l, j, o, l, l, o],\\n [l, l, l, o, l, o],\\n [l, l, o, l, l, o],\\n [o, o, o, o, l, l],\\n [o, o, o, o, o, l]]\\n M = Matrix(N)\\n sx, sy, dx, dy = [Remainder(x, n) for x in [sx, sy, dx, dy]]\\n v = Matrix([[sx], [sy], [dx], [dy], [o], [l]])\\n return M ** t * v\\n\\nn, sx, sy, dx, dy, t = [int(x) for x in input().split()]\\nans = solve(n, sx, sy, dx, dy, t)\\nprint(int(ans[0][0] - 1) + 1, int(ans[1][0] - 1) + 1)\\n"}
{"id": "430", "input": "# You lost the game.\\ns = str(input())\\nn = len(s)\\nA = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\nif n < 26:\\n print(-1)\\nelse:\\n for i in range(n-25):\\n ok = 1\\n F = [0 for _ in range(26)]\\n for j in range(26):\\n if s[i:i+26].count(A[j]) > 1:\\n ok = 0\\n break\\n elif s[i:i+26].count(A[j]) == 0:\\n F[j]", "gt": "= 1\\n if ok:\\n break\\n if ok == 0:\\n print(-1)\\n else:\\n j = 0\\n for k in range(n):\\n if s[k] == \"?\":\\n if k >= i and k < i+26:\\n while F[j] == 0:\\n j += 1\\n print(A[j],end=\"\")\\n F[j] = 0\\n else:\\n print(\"A\",end=\"\")\\n else:\\n print(s[k],end=\"\")\\n \\n"}
{"id": "431", "input": "\"\"\"\\nCodeforces Round 248 Div 2 Problem A\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\nclass InputHandlerObject(object):\\n inputs = []\\n\\n def getInput(self, n = 0):\\n res = \"\"\\n inputs = self.inputs\\n if not inputs: inputs.extend(input().split(\" \"))\\n if n == 0:\\n res = inputs[:]\\n inputs[:] = []\\n while n", "gt": "> len(inputs):\\n inputs.extend(input().split(\" \"))\\n if n > 0:\\n res = inputs[:n]\\n inputs[:n] = []\\n return res\\nInputHandler = InputHandlerObject()\\ng = InputHandler.getInput\\n\\n############################## SOLUTION ##############################\\nn = int(input())\\na = [int(x) for x in g()]\\nc100 = a.count(100)\\nif sum(a) % 200:\\n print(\"NO\")\\nelif n % 2 and not c100:\\n print(\"NO\")\\nelse:\\n print(\"YES\")"}
{"id": "432", "input": "n, m = list(map(int, input().split()))\\nm += 2\\nl = []\\ndo = False\\nfor i in range(n):\\n s = input().strip()\\n if s.find('1') != -1 or do:\\n do = True\\n l.append(s)\\nn = len(l)\\nif n == 0:\\n print(0)\\n return\\n\\n\\ndp = []\\nfor i in range(n):\\n dp.append([None] * 2)\\n\\nfor i in range(n):\\n R = 0\\n for j in range(m):\\n if l[i][j] == '1':\\n R = j\\n L = m - 1\\n for j in", "gt": "range(m - 1, -1, -1):\\n if l[i][j] == '1':\\n L = j\\n if i == 0:\\n dp[0][0] = R\\n dp[0][1] = (m - 1 - L)\\n else:\\n dp[i][0] = min(dp[i - 1][0] + 2 * R, dp[i - 1][1] + (m - 1)) + 1\\n dp[i][1] = min(dp[i - 1][0] + (m - 1), dp[i - 1][1] + 2 * (m - 1 - L)) + 1\\n# print(dp)\\nprint(dp[-1][0])\\n"}
{"id": "433", "input": "import sys\\n\\nrd = lambda : sys.stdin.readline().rstrip()\\n\\nn = int(rd())\\nc = list(map(int, rd().split()))\\na = list([int(x)-1 for x in rd().split()])\\n\\nvisited = [-1] * (n)\\nres = 0\\n\\nfor i in range(n):\\n trace = []\\n \\n t = i\\n mn = 1e9\\n while visited[t]", "gt": "== -1:\\n visited[t] = i\\n trace.append(t)\\n t = a[t]\\n \\n if visited[t] != i:\\n continue\\n \\n while len(trace) > 0:\\n v = trace.pop()\\n mn = min(mn, c[v]) \\n \\n if t == v: break\\n \\n res += mn\\n \\nprint(res)\\n"}
{"id": "434", "input": "n, a, b = list(map(int, input().split()))\\nans = a + b\\nwhile ans", "gt": "< 0:\\n ans += n\\nans %= n\\nif ans == 0:\\n print(n)\\nelse:\\n print(ans)\\n"}
{"id": "435", "input": "import sys\\nimport math\\n\\nn = int(sys.stdin.readline())\\nif n <= 2:\\n print(1)\\n return\\n\\na = [int(s) for s in sys.stdin.readline().split()]\\n\\nst = -1 # index of first positive number in current subset of a\\ned = -1 # index last positive number in current subset of a \\n # differation is (a[ed] - a[st])/(ed - st)\\nleading_zeros = 0 # -1 before a[st]\\nseg_count = 1\\n\\nfor (i, v) in enumerate(a):\\n if v == -1:\\n if st == -1:\\n leading_zeros += 1\\n else:\\n if ed != -1:\\n # check if v should be a non-positive number\\n if a[ed] + (i-ed) * (a[ed] - a[st])/(ed-st) <= 0:\\n st = -1\\n ed = -1\\n leading_zeros = 1\\n seg_count += 1\\n else:\\n pass\\n else:\\n pass\\n else:\\n if st == -1:\\n", "gt": "st = i # find first positive number\\n else:\\n if ed == -1:\\n ed = i\\n #print(i)\\n if (v - a[st]) % (i-st) != 0 or a[st] - (v-a[st])/(i-st) * leading_zeros <= 0:\\n # a[st..i] can't be an arithmetic progression\\n st = i\\n ed = -1\\n seg_count += 1\\n leading_zeros = 0\\n else:\\n ed = i\\n else:\\n if (v-a[ed])%(i-ed) != 0 or (v-a[ed]) * (ed - st) != (a[ed] - a[st]) * (i-ed):\\n st = i\\n ed = -1\\n seg_count += 1\\n leading_zeros = 0\\n else:\\n ed = i #leave ed the first positive number after a[st] is also ok\\n #print( \"[\" +str(st) + \" \" + str(ed) + \"] \" + str(seg_count) + \" \" + str(leading_zeros) )\\n\\nprint(seg_count)"}
{"id": "436", "input": "n, k = map(int,input().split())\\ns = input()\\nmaxi = 0\\na = 0\\nb = 0\\nst = 0\\nfor i in range(0, n):\\n if s[i] == 'a': a", "gt": "+= 1\\n else: b+=1\\n if min(a, b) > k:\\n if s[st] == 'a': a-=1\\n else: b-=1\\n st += 1\\n else: maxi += 1\\nprint(maxi)"}
{"id": "437", "input": "n = int(input())\\na = list(map(int, input().split()))\\nb = [0]\\nfor i in range(1, n):\\n if a[i]*2 <= a[0]:\\n b += [i]\\nu=0\\nv=0\\nfor i in range(n):\\n", "gt": "if i in b:\\n u += a[i]\\n else:\\n v += a[i]\\nif u > v:\\n print(len(b))\\n for x in b:\\n print(x+1, end=' ')\\nelse:\\n print('0')"}
{"id": "438", "input": "n=int(input())\\ntot=0\\nfor i", "gt": "in range(n):\\n tot+=1/(i+1)\\nprint(tot)\\n"}
{"id": "439", "input": "n = int(input())\\nans = []\\nnxt = 1\\nwhile n > 0:\\n x = nxt\\n n -=", "gt": "nxt\\n nxt += 1\\n if n < nxt:\\n x += n\\n n = 0\\n ans.append(str(x))\\nprint(len(ans))\\nprint(\" \".join(ans))\\n"}
{"id": "440", "input": "n = int(input())\\nm =", "gt": "int(input())\\n\\nprint(m % (1 << n))"}
{"id": "441", "input": "n = int(input())\\ns = input()\\nt = []\\nvowels = 'aeiouy'\\nfor c in s:\\n", "gt": "if t and t[-1] in vowels and c in vowels:\\n continue\\n else:\\n t.append(c)\\nprint(''.join(t))\\n"}
{"id": "442", "input": "n, a, b = list(map(int, input().split()))\\ns = input()\\ns += '*'\\nn += 1\\nm = []\\ni = 0\\ni1 = -1\\nwhile i < len(s):\\n if s[i] == '*':\\n if i - i1 > 1:\\n m.append(i - i1 - 1)\\n i1 = i\\n i += 1\\nsm = a + b\\nfor c in m:\\n if c % 2 == 0:\\n a = max(0,", "gt": "a - c // 2)\\n b = max(0, b - c // 2)\\n else:\\n if a > b:\\n a = max(0, a - (c + 1) // 2)\\n b = max(0, b - c // 2)\\n else:\\n b = max(0, b - (c + 1) // 2)\\n a = max(0, a - c // 2)\\nprint(sm - a - b)\\n"}
{"id": "443", "input": "r=int(input())\\nif r<=4:\\n print(\"NO\")\\nelif r%2==0:\\n", "gt": "print(\"NO\")\\nelse :\\n print(1, (r-3)//2)"}
{"id": "444", "input": "\\n\\nn = int(input())\\n\\ntab = [int(x) for x in input().split()]\\n\\nif n < 2", "gt": "or (n == 2 and tab[0] == tab[1]):\\n print(-1)\\nelse:\\n print(1)\\n print(tab.index(min(tab)) + 1)\\n\\n"}
{"id": "445", "input": "import getpass\\nimport sys\\n\\n\\ndef ria():\\n return [int(i) for i in input().split()]\\n\\n\\nif getpass.getuser() != 'frohenk':\\n filename = 'half'\\n", "gt": "# sys.stdin = open('input.txt')\\n # sys.stdout = open('output.txt', 'w')\\nelse:\\n sys.stdin = open('input.txt')\\n # sys.stdin.close()\\n\\nn = ria()[0]\\nprint(n)\\nprint('1 '*n)"}
{"id": "446", "input": "def main():\\n n = int(input())\\n l = list(map(int, input().split()))\\n seive = [False, True] * max(l)\\n a = len(seive)\\n for i in range(3, int(a ** .5) + 1, 2):\\n if seive[i]:\\n for j in range(i * i, a, i):\\n seive[j] = False\\n i = l.count(1)\\n if i:\\n res = [1] * i\\n for a in l:\\n if a > 1 and", "gt": "seive[a + 1]:\\n res.append(a)\\n break\\n if len(res) > 1:\\n print(len(res))\\n print(*res)\\n return\\n l0, l1 = [], []\\n for a in l:\\n if a != 1:\\n if a & 1:\\n for b in l0:\\n if seive[a + b]:\\n print(2)\\n print(a, b)\\n return\\n l1.append(a)\\n else:\\n for b in l1:\\n if seive[a + b]:\\n print(2)\\n print(a, b)\\n return\\n l0.append(a)\\n print(1)\\n print(l[0])\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "447", "input": "from collections import Counter, defaultdict\\nimport itertools\\nimport sys\\n\\ndef main():\\n n = int(input())\\n ans = 1\\n for k in range(1, 10):\\n v =", "gt": "((1 << k) - 1) * (1 << (k - 1))\\n if n % v == 0:\\n ans = v\\n\\n print(ans)\\n\\nmain()\\n"}
{"id": "448", "input": "#!/usr/bin/env python3\\n\\n\\n\\ndef addmod(left, right, modulo=1000000007):\\n res = left + right\\n if res >= modulo:\\n res -= modulo\\n return res\\n\\ndef counter(a, m, d):\\n res = [0, ] * (2*m)\\n res[0] = 1\\n shift = 1\\n for pos in range(len(a), 0, -1):\\n ptype = pos & 1\\n cur = int(a[pos-1])\\n tres = [0, ] * (2*m)\\n for i in range(10):\\n if ptype==1 and i == d:\\n continue\\n if ptype==0 and i != d:\\n continue\\n k = (i * shift) % m\\n for j in range(m):\\n k2 = k*2\\n j2 = j*2\\n if i < cur:\\n tres[k2+0] = addmod(tres[k2+0], addmod(res[j2+0], res[j2+1]))\\n elif i == cur:\\n tres[k2+0] = addmod(tres[k2+0], res[j2+0])\\n tres[k2+1] = addmod(tres[k2+1], res[j2+1])\\n else:\\n tres[k2+1]", "gt": "= addmod(tres[k2+1], addmod(res[j2+0], res[j2+1]))\\n k = k+1 if k+1<m else 0\\n res = tres\\n shift = (shift * 10) % m\\n return res[0]\\n\\n\\ndef solver(ifs):\\n m, d = list(map(int, ifs.readline().split()))\\n a = ifs.readline().strip()\\n b = ifs.readline().strip()\\n res = counter(b, m, d)\\n if a != '0':\\n a = str(int(a) - 1)\\n if len(a) < len(b):\\n a = '0' + a\\n modulo = 1000000007\\n res = addmod(res, modulo - counter(a, m, d))\\n print(res)\\n\\ndef main():\\n import sys\\n if sys.version_info.major == 3:\\n from io import StringIO as StreamIO\\n else:\\n from io import BytesIO as StreamIO\\n \\n with StreamIO(sys.stdin.read()) as ifs, StreamIO() as ofs:\\n _stdout = sys.stdout\\n sys.stdout = ofs\\n solver(ifs)\\n sys.stdout = _stdout\\n sys.stdout.write(ofs.getvalue())\\n return 0\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "449", "input": "def main():\\n from collections import deque\\n \\n n, m = [int(i) for i in input().split()]\\n children = deque([0, int(v), i + 1]", "gt": "for i, v in enumerate(input().split()))\\n \\n while len(children) > 1:\\n tmp = children.popleft()\\n tmp[0] += m\\n if tmp[1] > tmp[0]:\\n children.append(tmp)\\n \\n print(children.popleft()[2])\\n\\n\\nmain()\\n"}
{"id": "450", "input": "<s> ", "gt": "n=int(input())\\nans=0\\nans+=n//100\\nn%=100\\nans+=n//20\\nn%=20\\nans+=n//10\\nn%=10\\nans+=n//5\\nn%=5\\nans+=n\\nprint(ans)\\n"}
{"id": "451", "input": "mod=10**9+7\\nn,k=list(map(int,input().split()))\\n\\nA=[0]*(n+1)\\nB=[0]*(n+1)\\nC=[0]*(n+1)\\nF=[0]*(n+1)\\nG=[0]*(n+1)\\n\\nF[0]=G[0]=1\\nfor i in range(1,n+1):\\n G[i]=F[i]=F[i-1]*i%mod\\n G[i]=pow(F[i],(mod-2),mod)\\n\\nfor i in range(0,n):\\n if i*2>n:\\n break\\n B[i]=(F[n-i]*G[i]*G[n-i*2])%mod\\nfor i in range(0,n//2+1):\\n", "gt": "for j in range(0,n//2+1):\\n A[i+j]=(A[i+j]+B[i]*B[j])%mod\\nfor i in range(0,n+1):\\n A[i]=A[i]*F[n-i]%mod\\nfor i in range(0,n+1):\\n for j in range(0,i+1):\\n C[j]=(C[j]+A[i]*F[i]*G[j]*G[i-j]*(1-(i-j)%2*2))%mod\\nprint(C[k]%mod)\\n"}
{"id": "452", "input": "n,k = list(map(int, input().split()))\\nb = list(map(int,input().split()))\\n\\nSSSSSSSSSS = input()\\n\\nINF = 1000*1000*1000+123\\nRRRR = [];\\nWWWWWWW = [];\\nOOOOOOOOO = [];\\n\\nfor i in range(n):\\n if SSSSSSSSSS[i] == 'R':\\n RRRR.append(b[i])\\n elif SSSSSSSSSS[i] == 'W':\\n WWWWWWW.append(b[i])\\n else:\\n OOOOOOOOO.append(b[i])\\n\\n\\n\\nWWWWWWW.sort()\\n\\nRRRR.sort()\\nWWWWWWW.reverse()\\nRRRR.reverse()\\nOOOOOOOOO.sort()\\nOOOOOOOOO.reverse()\\n\\nif k == 1:\\n print(-1)\\n return\\n\\n\\ndef cccmcmc(A, B):\\n qanakA = len(A);\\n qanakB = len(B);\\n\\n pA = [0 for i in range(qanakA)]\\n pB = [0 for i in range(qanakB)]\\n pB[0] = B[0]\\n pA[0] = A[0]\\n\\n for i in range(1,qanakA):\\npA[i] = pA[i-1] + A[i];\\n for i in range(1,qanakB):\\n", "gt": "pB[i] = pB[i-1] + B[i];"}
{"id": "453", "input": "#!/usr/bin/env python3\\n\\nfrom fractions import Fraction\\n\\ndef __starting_point():\\n p, q = list(map(int, input().split()))\\n n = int(input())\\n l = list(map(int, input().split()))\\n\\n f", "gt": "= Fraction(l[-1], 1)\\n\\n for x in l[-2::-1]:\\n f = 1 / f\\n f += x\\n\\n print([\"NO\", \"YES\"][f == Fraction(p, q)])\\n\\n\\n\\n__starting_point()"}
{"id": "454", "input": "t = input()\\nk = t.find('=')\\nn = 2 * k - len(t)\\nif n == 2:\\n if t[1] != '+': t = t[1: ] + '|'\\n else:", "gt": "t = t[: k - 1] + t[k: ] + '|'\\nelif n == -2: t = '|' + t[: -1]\\nelif n != 0: t = 'Impossible'\\nprint(t)"}
{"id": "455", "input": "import numpy as np\\n\\n\\ndef solve(n, k):\\n if k % 2 == 1:\\n return 0\\n k //= 2\\n\\n MOD = 10 ** 9 + 7\\n\\n dp = np.zeros((1, k + 1), dtype=np.int64)\\n dp[0, 0] = 1\\n for i in range(1, n + 1):\\n max_d = min(i + 1, n - i + 1, k + 1)\\n ndp = np.zeros((max_d, k + 1), dtype=np.int64)\\n for", "gt": "d, ks in enumerate(dp):\\n base = ks[:k - d + 1]\\n if d > 0:\\n ndp[d - 1, d:] += base * d ** 2\\n if max_d > d:\\n ndp[d, d:] += base * (2 * d + 1)\\n if max_d > d + 1:\\n ndp[d + 1, d:] += base\\n dp = ndp % MOD\\n\\n return dp[0, k]\\n\\n\\nn, k = list(map(int, input().split()))\\nprint((solve(n, k)))\\n"}
{"id": "456", "input": "N = int(input())\\nP = [tuple(map(int, input().split())) for _ in range(N)]\\n\\nodd = []\\nfor (x, y) in P:\\n dist = abs(x) + abs(y)\\n odd.append(dist % 2 != 0)\\n\\nvalid = True\\neven = False\\nif all(odd):\\n pass\\nelif not any(odd):\\n even = True\\nelse:\\n valid =False\\n\\nif valid:\\n\\n M = 31\\n if even:\\n print((M+1))\\n print((*([1 << m for m in range(M)] + [1])))\\n else:\\n print(M)\\n print((*[1 << m for m in range(M)]))\\n\\n for (x, y) in P:\\n u = x + y\\n v = x - y\\n if even:\\n u += 1\\n v += 1\\n if u >= 0 and v >= 0:\\n A = 'R'\\n B = 'U'\\n C = 'D'\\n D = 'L'\\n elif u >= 0 and v < 0:\\n v *= -1\\n A = 'U'\\n B = 'R'\\n C = 'L'\\n D", "gt": "= 'D'\\n elif u < 0 and v >= 0:\\n u *= -1\\n A = 'D'\\n B = 'L'\\n C = 'R'\\n D = 'U'\\n elif u < 0 and v < 0:\\n u *= -1\\n v *= -1\\n A = 'L'\\n B = 'D'\\n C = 'U'\\n D = 'R'\\n\\n ans = ''\\n wa = ((1 << M) - 1 - u) // 2\\n sa = ((1 << M) - 1 - v) // 2\\n for i in range(M):\\n check = str(wa >> i & 1) + str(sa >> i & 1)\\n if check == '00':\\n ans += A\\n elif check == '01':\\n ans += B\\n elif check == '10':\\n ans += C\\n elif check == '11':\\n ans += D\\n if even:\\n ans += 'L'\\n print(ans)\\nelse:\\n print((-1))\\n"}
{"id": "457", "input": "from sys import *\\nn = int(input())\\na = input()\\ns = 0\\ni = 0\\nwhile i <= n-1:\\n if s == 0:\\n if a[i:i+3] == 'ogo':\\n s = 1\\n", "gt": "print('***', end = '')\\n i+=3\\n else:\\n print(a[i], end = '')\\n i += 1\\n \\n else:\\n if a[i:i+2] == 'go':\\n i += 2\\n else:\\n s = 0"}
{"id": "458", "input": "x, n = list(map(int, input().split()))\\n\\ndef primeFactor(N):\\n i, n, ret, d, sq = 2, N, {}, 2, 99\\n while i <= sq:\\n k = 0\\n while n % i == 0: n, k, ret[i] = n//i, k+1, k+1\\n if k > 0 or i == 97: sq = int(n**(1/2)+0.5)\\n if i < 4: i = i *", "gt": "2 - 1\\n else: i, d = i+d, d^6\\n if n > 1: ret[n] = 1\\n return ret\\n\\npf = primeFactor(x)\\nmod = 10 ** 9 + 7\\ndef calc(p):\\n s = 0\\n a = n//p\\n while a:\\n s += a\\n a //= p\\n return pow(p, s, mod)\\n\\nans = 1\\nfor p in pf:\\n ans = ans * calc(p) % mod\\nprint(ans)\\n\\n\\n"}
{"id": "459", "input": "a, b, c = list(map(int, input().split()))\\nans = []\\nfor sum in range(1, 200):\\n x = b * sum ** a + c\\n if x", "gt": "<= 0 or x >= 10 ** 9:\\n continue\\n summ = 0\\n for aa in str(x):\\n summ += int(aa)\\n if sum == summ:\\n ans.append(x)\\nprint(len(ans))\\nprint(*ans)\\n"}
{"id": "460", "input": "l=list(map(int,input().split()))\\nl.insert(0,0)\\nc1=[1,6,3,8,5,10,7,12,9,23,11,21,13,14,15,16,17,18,19,20,4,22,2,24]\\nc2=[1,23,3,21,5,2,7,4,9,6,11,8,13,14,15,16,17,18,19,20,12,22,10,24]\\nc3=[1,2,3,4,5,6,15,16,9,10,11,12,13,14,23,24,17,18,7,8,21,22,19,20]\\nc4=[1,2,3,4,5,6,19,20,9,10,11,12,13,14,7,8,17,18,23,24,21,22,15,16]\\nc5=[1,2,16,14,5,6,7,8,19,17,11,12,13,9,15,10,3,18,4,20,21,22,23,24]\\nc6=[1,2,17,19,5,6,7,8,14,16,11,12,13,4,15,3,10,18,9,20,21,22,23,24]\\nflag=0\\nmark=0\\nfor i in range(6):\\n if(l[c1[4*i]] == l[c1[4*i+1]] == l[c1[4*i+2]] == l[c1[4*i+3]]):\\n mark=1\\n else:\\n mark=0\\n break\\nif(mark):\\n flag=1\\n\\nmark=0\\nfor i in range(6):\\n if(l[c2[4*i]] == l[c2[4*i+1]] == l[c2[4*i+2]] == l[c2[4*i+3]]):\\n mark=1\\n else:\\n mark=0\\n break\\nif(mark):\\n flag=1\\n\\nmark=0\\nfor i in range(6):\\n if(l[c3[4*i]] == l[c3[4*i+1]] == l[c3[4*i+2]] == l[c3[4*i+3]]):\\n mark=1\\n else:\\n mark=0\\n break\\nif(mark):\\n flag=1\\n\\nmark=0\\nfor", "gt": "i in range(6):\\n if(l[c4[4*i]] == l[c4[4*i+1]] == l[c4[4*i+2]] == l[c4[4*i+3]]):\\n mark=1\\n else:\\n mark=0\\n break\\nif(mark):\\n flag=1\\n\\nmark=0\\nfor i in range(6):\\n if(l[c5[4*i]] == l[c5[4*i+1]] == l[c5[4*i+2]] == l[c5[4*i+3]]):\\n mark=1\\n else:\\n mark=0\\n break\\nif(mark):\\n flag=1\\n\\nmark=0\\nfor i in range(6):\\n if(l[c6[4*i]] == l[c6[4*i+1]] == l[c6[4*i+2]] == l[c6[4*i+3]]):\\n mark=1\\n else:\\n mark=0\\n break\\nif(mark):\\n flag=1\\n\\nif(flag):\\n print(\"YES\")\\nelse:\\n print(\"NO\")\\n"}
{"id": "461", "input": "from math import ceil\\n\\np,x,y = map(int, input().split())\\nh = x\\nwhile h >=y:\\n h-=50\\nh+=50\\nfor i in range(h, 10000000000, 50):\\n u = (i//50)%475\\n d = []\\n for", "gt": "j in range(25):\\n u = (u * 96 + 42)%475\\n d.append(26 + u)\\n if p in d:\\n k = i\\n break\\nif k-x>0:\\n print(ceil((k-x)/100))\\nelse:\\n print(0)"}
{"id": "462", "input": "'''input\\n1\\n2\\n3\\n5\\n'''\\nn = int(input())\\na = int(input())\\nb = int(input())\\nc = int(input())\\ncur = 0\\npos = 0\\nfor i in range(n-1):\\n if pos == 0:\\n if a < b:\\n pos = 1\\n cur += a\\n else:\\n pos = 2\\n cur += b \\n elif pos", "gt": "== 1:\\n if a < c: \\n pos = 1\\n cur += a\\n else:\\n pos = 3\\n cur += c\\n else:\\n if b < c: \\n pos = 2\\n cur += b\\n else:\\n pos = 3\\n cur += c \\nprint(cur)"}
{"id": "463", "input": "l = list(map(int,", "gt": "input().split()))\\n\\nprint(max(l) - min(l))"}
{"id": "464", "input": "n, x = list(map(int, input().split()))\\na = list(map(int, input().split()))\\nb = [0] * 1000000\\nans = 0\\ngo = False\\n\\nfor i in a:\\n b[i] += 1\\n if b[i] > 1:\\n go = True\\n\\nif go:\\n print(ans)\\nelse:\\n for i in a:\\n b[i] -= 1\\n if b[i & x] + 1 > 1:\\n go = True\\n", "gt": "ans = 1\\n break\\n \\n b[i] += 1\\n \\n if go:\\n print(ans)\\n else:\\n c = [i & x for i in a]\\n b = [0] * 1000000\\n for i in c:\\n b[i] += 1\\n if (b[i] > 1):\\n ans = 2\\n go = True\\n break\\n if go:\\n print(ans)\\n else:\\n print(-1)\\n"}
{"id": "465", "input": "h,w = map(int,input().split())\\ns = [list(input()) for i in range(h)]\\nhh = -1\\ntmp = -1\\nfor k,i in enumerate(s):\\n a = i.count('*')\\n if tmp < a:\\n tmp = a\\n hh = k\\n\\nt = [list(i) for i in list(zip(*s))]\\nww = -1\\ntmp = -1\\nfor k,i in enumerate(t):\\n a = i.count('*')\\n if tmp < a:\\n tmp = a\\n ww = k\\n\\nif s[hh][ww] != '*':\\n print('NO')\\n return\\n\\nif hh in (0, h - 1) or ww in (0, w - 1):\\n print('NO')\\n return\\n\\nif '.' in (s[hh-1][ww], s[hh+1][ww], s[hh][ww-1],", "gt": "s[hh][ww+1]):\\n print('NO')\\n return\\n\\ncnt = 1\\nfor i in range(hh - 1, -1, -1):\\n if s[i][ww] == '.':\\n break\\n cnt += 1\\nfor i in range(ww - 1, -1, -1):\\n if s[hh][i] == '.':\\n break\\n cnt += 1\\nfor i in range(hh + 1, h):\\n if s[i][ww] == '.':\\n break\\n cnt += 1\\nfor i in range(ww + 1, w):\\n if s[hh][i] == '.':\\n break\\n cnt += 1\\n\\nfor i in range(h):\\n for j in range(w):\\n cnt -= (s[i][j] == '*')\\n\\nif cnt != 0:\\n print('NO')\\nelse:\\n print('YES')"}
{"id": "466", "input": "n, a, b = map(int,input().split())\\nif a>1 and b>1: print(\"NO\"); return\\nif 2<=n<=3 and a == b == 1: print(\"NO\"); return\\nprint(\"YES\")\\n\\nif b == 1:\\n adj = [[0]*n for i in range(n)]\\n conn = n\\n for i in range(n):\\n if conn == a: break\\n adj[i][i+1] = adj[i+1][i] = 1\\n conn-= 1\\n if", "gt": "conn == a: break\\nelif a == 1:\\n adj = [[1]*n for i in range(n)]\\n conn = n\\n for i in range(n): adj[i][i] = 0\\n for i in range(n):\\n if conn == b: break\\n adj[i][i+1] = adj[i+1][i] = 0\\n conn-= 1\\n if conn == b: break\\n\\nfor row in adj:\\n print(*row, sep='')\\n"}
{"id": "467", "input": "c,d=list(map(int,input().split()))\\n\\nn,m=list(map(int,input().split()))\\n\\nk=int(input())\\n\\nz=0\\nbest=10**10\\nwhile(1):\\n x=n*m-k\\n x-=z*n\\n best=min(best,z*c+(max(x,0)*d))\\n", "gt": "if(x<0):\\n break\\n z+=1\\nprint(best)\\n \\n"}
{"id": "468", "input": "3\\n\\ns = input()\\nn = len(s)\\n\\na, b = 0, 0\\nd = dict()\\nfor i in range(len(s)):\\n if s[i] in d:\\n a = d[s[i]]\\n b = i\\n d[s[i]] = i\\n\\nif a == b - 1:\\n print(\"Impossible\")\\nelse:\\n ans = [[' '] * 13 for i in range(2)]\\n if (b - a) % 2 == 1:\\n for i in range((b - a) // 2):\\n ans[0][-(b - a) // 2 + i + 1] = s[a + i + 1]\\n ans[1][-i - 1] = s[a + i + (b - a) // 2 + 1]\\n x = -(b - a) // 2\\n y = 0\\n for i in range(b, n):\\n ans[y][x] = s[i]\\n if y == 0:\\n x -= 1\\n else:\\n x += 1\\n if x == -14:\\n y = 1\\n x = 0\\n for i in range(a):\\n", "gt": "ans[y][x] = s[i]\\n if y == 0:\\n x -= 1\\n else:\\n x += 1\\n if x == -14:\\n y = 1\\n x = 0\\n print(\"\".join(ans[0]))\\n print(\"\".join(ans[1]))\\n else:\\n for i in range((b - a) // 2):\\n ans[0][-(b - a) // 2 + i + 1] = s[a + i + 1]\\n ans[1][-i - 1] = s[a + i + (b - a) // 2]\\n x = -(b - a) // 2\\n y = 0\\n for i in range(b, n):\\n ans[y][x] = s[i]\\n if y == 0:\\n x -= 1\\n else:\\n x += 1\\n if x == -14:\\n y = 1\\n x = 0\\n for i in range(a):\\n ans[y][x] = s[i]\\n if y == 0:\\n x -= 1\\n else:\\n x += 1\\n if x == -14:\\n y = 1\\n x = 0\\n print(\"\".join(ans[0]))\\n print(\"\".join(ans[1]))\\n\\n\\n\\n"}
{"id": "469", "input": "import math\\n\\nx, y = [int(v) for v in input().split()]\\n\\nxly = x * math.log(y)\\nylx =", "gt": "y * math.log(x)\\n\\nif abs(xly - ylx) < 1e-8:\\n print('=')\\nelif ylx < xly:\\n print('<')\\nelse:\\n print('>')\\n"}
{"id": "470", "input": "from math import *\\n\\nr, h = list(map(int, input().split()))\\nd = h % r\\n\\nif d * 2 < r:\\n print(h // r * 2 + 1)\\nelif sqrt(3)", "gt": "* (r / 2) + r - 1e-6 <= d + r:\\n print(h // r * 2 + 3)\\nelse:\\n print(h // r * 2 + 2)\\n"}
{"id": "471", "input": "cards = list(map(int, input().split()))\\n\\nresult = sum(cards)\\n\\nfor i in range(5):\\n cnt = cards.count(cards[i])\\n cnt = min(cnt,", "gt": "3)\\n if cnt not in [2, 3]:\\n continue\\n result = min(result, sum(cards) - cnt * cards[i])\\n\\nprint(result)\\n"}
{"id": "472", "input": "from math import *\\nn, a = map(int, input().split())\\nA = list(map(int, input().split()))\\nA.sort()\\nif n == 1:\\n print(0)\\n \\nelse:\\n if a > A[-1]:\\n print(abs(a - A[1]))\\n elif a < A[0]:\\n print(abs(a - A[-2]))\\n else:\\n per1 = abs(A[0] - A[-2])\\n", "gt": "per2 = abs(A[1] - A[-1])\\n ans1 = abs(A[0] - a) + per1\\n ans2 = per1 + abs(A[-2] - a)\\n ans3 = per2 + abs(a - A[-1])\\n ans4 = per2 + abs(a - A[1])\\n print(min(ans1, ans2, ans3, ans4))"}
{"id": "473", "input": "import re\\nimport itertools\\nfrom collections import Counter, deque\\n\\nclass Task:\\n maxDigitSum = 18 * 9\\n n = 0\\n answer = \"\" \\n \\n def getData(self):\\n self.n = int(input())\\n #inFile = open('input.txt', 'r')\\n #inFile.readline().rstrip()\\n #self.childs = inFile.readline().rstrip()\\n\\n def solve(self):\\n if self.n == 1:\\n self.answer = '-1'\\n return\\n\\n xL, xR = 0, self.n\\n while xL + self.maxDigitSum < xR:\\n xM = (xL + xR) // 2\\n if xM**2 + self.digitSum(xM) * xM < self.n:\\n for x in range(xM - 1, max(xL, xM - self.maxDigitSum) - 1, -1):\\n", "gt": "if x**2 + self.digitSum(x) * x == self.n:\\n self.answer = x\\n return\\n xL = xM\\n else:\\n for x in range(xM + 1, min(xR, xM + self.maxDigitSum) + 1):\\n if x**2 + self.digitSum(x) * x == self.n:\\n self.answer = x\\n return\\n xR = xM\\n for x in range(xL, xR + 1):\\n if x**2 + self.digitSum(x) * x == self.n:\\n self.answer = x\\n return\\n self.answer = -1\\n\\n def digitSum(self, n):\\n return sum([int(x) for x in str(n)])\\n\\n def printAnswer(self):\\n print(self.answer)\\n #outFile = open('output.txt', 'w')\\n #outFile.write(self.answer)\\n\\ntask = Task()\\ntask.getData()\\ntask.solve()\\ntask.printAnswer()\\n"}
{"id": "474", "input": "s = input()\\nt = input()\\na, b = int(s[:2]), int(s[3:])\\nc, d = int(t[:2]), int(t[3:])\\na -= c\\nb -= d\\nif b < 0:\\n a -= 1\\n b = 60 + b\\nif", "gt": "a < 0:\\n a = 24 + a\\nif a < 10:\\n print(0, end = '')\\nprint(a, ':', end = '', sep = '')\\nif b < 10:\\n print(0, end = '')\\nprint(b)\\n"}
{"id": "475", "input": "n = int(input())\\na = list(map(int,input().split()))\\nm = max(a)\\n\\ncurrent = 0\\nlongest = 0\\nfor x in a:\\n if", "gt": "x == m:\\n current +=1\\n else:\\n longest = max(current,longest)\\n current = 0\\nlongest = max(current,longest)\\nprint (longest)\\n\\n"}
{"id": "476", "input": "import math\\nn,m,k=map(int,input().split())\\nout=1\\nfor i", "gt": "in range(k):\\n out*=(m-1)\\n out%=998244353\\nout*=m\\nout%=998244353\\nout*=(math.factorial(n-1)//math.factorial(k)//math.factorial(n-1-k))\\nout%=998244353\\nprint(out)"}
{"id": "477", "input": "n = input()\\ngood = True\\nwhile n != '' and good:\\n if n.endswith('144'):\\n n = n[:-3]\\n elif", "gt": "n.endswith('14'):\\n n = n[:-2]\\n elif n.endswith('1'):\\n n = n[:-1]\\n else:\\n good = False\\nprint('YES' if good else 'NO')\\n"}
{"id": "478", "input": "n,m,i,j,a,b=list(map(int,input().split()))\\n\\nans=100000000000\\n\\nif((i,j)==(n,1) or (i,j)==(1,1) or (i,j)==(1,m) or (i,j)==(n,m)):\\n print(0)\\n\\nelse:\\n #Corner (1,1)\\n\\n hor=i-1\\n ver=j-1\\n\\n if(hor%a==0 and ver%b==0):\\n x=hor//a\\n y=ver//b\\n if(x%2==y%2 and a<=n-1 and b<=m-1):\\n ans=min(ans,max(x,y))\\n\\n #Corner (n,m)\\n\\n hor=abs(i-n)\\n ver=abs(j-m)\\n\\n if(hor%a==0 and ver%b==0):\\n x=hor//a\\n y=ver//b\\n if(x%2==y%2 and a<=n-1 and b<=m-1):\\n ans=min(ans,max(x,y))\\n\\n", "gt": "#Corner (1,m)\\n\\n hor=i-1\\n ver=abs(j-m)\\n\\n if(hor%a==0 and ver%b==0):\\n x=hor//a\\n y=ver//b\\n if(x%2==y%2 and a<=n-1 and b<=m-1):\\n ans=min(ans,max(x,y))\\n\\n #Corner (n,1)\\n\\n hor=abs(n-i)\\n ver=j-1\\n\\n if(hor%a==0 and ver%b==0):\\n x=hor//a\\n y=ver//b\\n if(x%2==y%2 and a<=n-1 and b<=m-1):\\n ans=min(ans,max(x,y))\\n if(ans!=100000000000):\\n print(ans)\\n else:\\n print(\"Poor Inna and pony!\")\\n \\n"}
{"id": "479", "input": "from sys import stdin\\ninput = stdin.readline\\n\\nn = int(input())\\ns = list(input().strip())\\n\\nfor i in range(26):\\n char = chr(ord('z') - i)\\n prev = chr(ord('z') - i - 1)\\n\\n updated = True\\n while updated:\\n updated = False\\n for idx", "gt": "in range(len(s)-1, -1, -1):\\n if s[idx] == char:\\n if idx < len(s)-1 and s[idx+1] == prev:\\n s.pop(idx)\\n updated = True\\n elif idx > 0 and s[idx-1] == prev:\\n s.pop(idx)\\n updated = True\\n\\nprint( n - len(s))\\n\\n"}
{"id": "480", "input": "n, k = map(int, input().split())\\na = set(map(int, input().split()))\\nq = int(input())\\n\\n# def isIn(x, fm, to):\\n# if fm >= to:\\n# return a[fm] == x\\n# t = a[(fm+to) // 2]\\n# if t > x:\\n# return isIn(x, fm, (fm+to) // 2 - 1)\\n# elif t < x:\\n# return isIn(x, (fm+to) // 2 + 1, to)\\n# else:\\n# return True\\n\\nfor _ in range(q):\\n x = int(input())\\n if x in a:\\n print(1)\\n continue\\n found = False\\n", "gt": "for i in range(2, k + 1):\\n for j in range(1, i // 2 + 1):\\n for l in a:\\n t = x - l * j\\n if t % (i - j) != 0:\\n continue\\n # if isIn(t // (i - j), 0, n - 1):\\n if t // (i - j) in a:\\n print(i)\\n found = True\\n break\\n if found:\\n break\\n if found:\\n break\\n if not found:\\n print(-1)"}
{"id": "481", "input": "#!/usr/bin/env python3\\n\\ndef main():\\n try:\\n while True:\\n s, x1, x2 = list(map(int, input().split()))\\n t1, t2 = list(map(int, input().split()))\\n p, d = list(map(int, input().split()))\\n\\n def travel(src, trg):\\n nonlocal d\\n if src == trg:\\n return 0\\n if src < trg:\\n if d > 0:\\n return trg - src\\n else:\\n d =", "gt": "1\\n return trg + src\\n else:\\n if d < 0:\\n return src - trg\\n else:\\n d = -1\\n return s - src + s - trg\\n\\n a = travel(p, x1)\\n b = travel(x1, x2)\\n print(\"%d\" % min(abs(x1 - x2) * t2, (a + b) * t1))\\n\\n except EOFError:\\n pass\\n\\nmain()\\n"}
{"id": "482", "input": "n, x = map(int, input().split())\\nans = 0\\nfor i in range(n, 0, -1):\\n", "gt": "if x % i == 0 and x//i <= n:\\n ans += 1\\nprint(ans)"}
{"id": "483", "input": "n, k =", "gt": "map(int, input().split())\\nprint(('abcdefghijklmnopqrstuvwxyz'[:k] * n)[:n])"}
{"id": "484", "input": "import sys, math\\nn=int(input())\\ns=input()\\nz=list(map(int,input().split()))\\nbest = 10**9\\nfor i in range(len(s)-1):\\n if", "gt": "s[i]=='R' and s[i+1]=='L':\\n best=min(best, z[i+1]-(z[i]+z[i+1])//2)\\nif best != 10**9:\\n print(best)\\nelse:\\n print(-1)\\n"}
{"id": "485", "input": "R=lambda:list(map(int,input().split()))\\nn,a,b=R()\\nxy = [R() for _ in range(n)]\\nans = 0\\ndef f(xy1, xy2):\\n tans = 0\\n for _ in range(2):\\n for __ in range(2):\\n if (xy1[0]+xy2[0]<=a and max(xy1[1], xy2[1])<=b) or\\\\n (max(xy1[0],", "gt": "xy2[0])<=a and xy1[1]+xy2[1]<=b):\\n tans=max(tans, xy1[0]*xy1[1] + xy2[0]*xy2[1])\\n xy2[0], xy2[1] = xy2[1], xy2[0]\\n xy1[0], xy1[1] = xy1[1], xy1[0]\\n return tans\\nfor i in range(n):\\n for j in range(i+1,n):\\n ans=max(ans, f(xy[i], xy[j]))\\nprint(ans)\\n"}
{"id": "486", "input": "#!/usr/bin/env python\\nimport sys\\n\\nn = int(input())\\nk = (n << 2) + 1\\n\\nx, y = [], []\\nfor i in range(k):\\n xi, yi = list(map(int, input().split()))\\n x.append(xi)\\n y.append(yi)\\n\\nfor lx in range(0, 50):\\n for ly in range(0, 50):\\n for side_len in range(1, 51):\\n ok, idx = True, -1\\n for i in range(k):\\n if not", "gt": "(((x[i] == lx or x[i] == lx + side_len) and ly <= y[i] <= ly + side_len) or\\n ((lx <= x[i] <= lx + side_len) and (y[i] == ly or y[i] == ly + side_len))):\\n if idx != -1:\\n ok = False\\n else:\\n idx = i\\n if ok:\\n print(x[idx], y[idx])\\n return\\n"}
{"id": "487", "input": "n = int(input())\\ndef p(x):\\n ans = 1\\n while x > 0:\\n ans *= x % 10\\n x //= 10\\n return ans\\nans", "gt": "= p(n)\\nfor i in range(len(str(n))):\\n cans = 9 ** i * p((n // 10 ** i) - 1)\\n ans = max(ans, cans)\\nprint(ans)\\n"}
{"id": "488", "input": "n = int(input())\\na = list(map(int,input().split()))\\ns = sum(a)\\nfor k in range(max(a), 999999):\\n vote", "gt": "= sum(k-x for x in a)\\n if vote > s: print(k); break"}
{"id": "489", "input": "s = input()\\n\\ncur_len = 1\\na = []\\nchar = []\\nfor i in range(1, len(s)):\\n if s[i] == s[i-1]: cur_len += 1\\n else:\\n a.append(cur_len)\\n char.append(s[i-1])\\n cur_len = 1\\n \\na.append(cur_len)\\nchar.append(s[len(s)-1])\\n\\nans = 0\\nwhile len(a) > 1:\\n n = len(a)\\n inner_min = 100000000\\n for i in range(1,n-1):\\n if a[i] < inner_min: inner_min = a[i]\\n \\n k = min(a[0], a[n-1],(inner_min + 1)//2)\\n #print(\"a: \", a, \"; k = \", k)\\n b = []\\n new_char = []\\n for i in range(n):\\n if i == 0 or i", "gt": "== n-1:\\n if a[i] > k:\\n b.append(a[i]-k)\\n new_char.append(char[i])\\n else:\\n if a[i] > 2*k:\\n b.append(a[i] - 2*k)\\n new_char.append(char[i])\\n## print(b)\\n ans += k\\n if len(b) > 1:\\n c = [0]*n\\n newnew_char = [new_char[0]]\\n count = 0\\n \\n for i in range(0,len(b)-1):\\n c[count] += b[i]\\n if new_char[i] == new_char[i+1]: continue\\n else:\\n count += 1\\n newnew_char.append(new_char[i+1])\\n if new_char[len(b)-2] == new_char[len(b) - 1]: c[count] += b[len(b)-1]\\n else:\\n #count += 1\\n newnew_char.append(new_char[i+1])\\n c[count] = b[len(b)-1]\\n a = c[:count+1]\\n char = newnew_char[:]\\n else:\\n a = b[:]\\n\\nprint(ans)\\n \\n"}
{"id": "490", "input": "n=int(input())\\ninp=input().split()\\nl=[]\\nfor val in inp:\\n l.append(int(val))\\nl.sort()\\ncount=3\\nwhile(count<n", "gt": "and l[count]==l[count-1]):\\n count+=1\\nif(l[2]!=l[1]):\\n print(count-2)\\nelif(l[2]!=l[0]):\\n print(((count-1)*(count-2))//2)\\nelse:\\n print((count*(count-1)*(count-2))//6)"}
{"id": "491", "input": "n=int(input())+1\\nif n==1: print(0)\\nelse: print(n", "gt": "if n%2==1 else n//2)\\n"}
{"id": "492", "input": "n = int(input())\\nif n >= 0:\\n print(n)\\nelse:\\n", "gt": "n = str(n)\\n print(max(int(n[:-1]), int(n[:-2] + n[-1])))\\n"}
{"id": "493", "input": "a, b = input().split(' ')\\nn = int(input())\\n\\nd = {'v': 0, '>': 1, '^': 2, '<': 3}\\n\\na, b = d[a], d[b]\\n\\nccw = bool((a +", "gt": "n) % 4 == b)\\ncw = bool((a - n) % 4 == b)\\n\\nif cw and not ccw:\\n print('cw')\\nelif ccw and not cw:\\n print('ccw')\\nelse:\\n print('undefined')\\n"}
{"id": "494", "input": "n = int(input())\\na = input().strip()\\nnextl = [-1] * n\\nlastr = [-1] * n\\nll = -1\\nfor i in range(n):\\n if a[i] == \"R\":\\n ll = i\\n if a[i] == \"L\":\\n ll = -1\\n lastr[i] = ll\\nnl = -1\\nfor i in range(n - 1, -1, -1):\\n if a[i] == \"L\":\\n nl =", "gt": "i\\n if a[i] == \"R\":\\n nl = -1\\n nextl[i] = nl\\nans = 0\\n#print(lastr)\\n#print(nextl)\\nfor i in range(n):\\n if nextl[i] == lastr[i] == -1:\\n ans += 1\\n if nextl[i] == -1 or lastr[i] == -1:\\n continue\\n d1 = nextl[i] - i\\n d2 = i - lastr[i]\\n if d1 == d2:\\n ans += 1\\nprint(ans)"}
{"id": "495", "input": "\\nimport sys\\n#sys.stdin=open(\"data.txt\")\\ninput=sys.stdin.readline\\n\\nn,m=map(int,input().split())\\n\\nl=list(map(int,input().split()))\\nfor i in range(len(l)):\\n l[i]-=1\\n\\nuse=[0]*n\\na=[0]*n\\nbad=0\\n\\nfor i in range(len(l)-1):\\n # transfer l[i] to l[i+1]\\n if a[l[i]] and a[l[i]]%n!=(l[i+1]-l[i])%n:\\n bad=1\\n break\\n use[(l[i+1]-l[i])%n]=1\\n a[l[i]]=(l[i+1]-l[i])%n\\n if a[l[i]]==0: a[l[i]]=n\\n\\nif not bad:\\n", "gt": "# fill in gaps\\n for i in range(n):\\n if a[i]==0:\\n for j in range(1,n+1):\\n if not use[j%n]:\\n a[i]=j\\n use[j%n]=1\\n break\\n if sum(use)==n:\\n print(\" \".join(map(str,a)))\\n else:\\n print(\"-1\")\\nelse:\\n print(\"-1\")"}
{"id": "496", "input": "a, k = input().split()\\nk = int(k)\\na = [i for i in a]\\ni = 0\\nwhile k > 0 and i < len(a):\\n m = a[i : i + k + 1].index(max(a[i : i", "gt": "+ k + 1]))\\n if a[i + m] > a[i]:\\n k -= m\\n for j in range(i + m, i, -1):\\n a[j], a[j - 1] = a[j - 1], a[j]\\n i += 1\\nprint(\"\".join(a))"}
{"id": "497", "input": "def isZ(a):\\n return a == int(a)\\ndef geom(a,b,c,d):\\n if 0 in (a,b,c,d) and not (a==b==c==d==0):\\n return False\\n if(b/a==c/b==d/c):\\n nxt = d * (d/c)\\n if", "gt": "not isZ(nxt): return False\\n print(int(nxt))\\n return True\\n return False\\ndef ar(a,b,c,d):\\n if(b-a==c-b==d-c):\\n print(int(2*d-c))\\n return True\\n return False\\n\\na,b,c,d = map(float,input().split())\\nif not geom(a,b,c,d) and not ar(a,b,c,d):\\n print(42)"}
{"id": "498", "input": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\\n\\nsys.setrecursionlimit(10**7)\\ninf = 10**20\\neps = 1.0 / 10**10\\nmod = 10**9+7\\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\\n\\ndef LI(): return tuple(map(int, sys.stdin.readline().split()))\\ndef LLI(): return [tuple(map(int, l.split())) for l in sys.stdin]\\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\\ndef LS(): return sys.stdin.readline().split()\\ndef I(): return int(sys.stdin.readline())\\ndef F(): return float(sys.stdin.readline())\\ndef S(): return input()\\ndef pf(s):", "gt": "return print(s, flush=True)\\n\\ndef main():\\n n = I()\\n a = LI()\\n b = a[0]\\n c = a[-1]\\n r = 0\\n for i in range(n-1,-1,-1):\\n if a[i] != b:\\n r = i\\n break\\n\\n for i in range(n):\\n if a[i] != b:\\n t = n-1 - i\\n if r < t:\\n r = t\\n\\n return r\\n\\nprint(main())\\n\\n\\n"}
{"id": "499", "input": "n, m, k = list(map(int, input().split()))\\nprint((k - 1) // (2 * m) + 1, end=\" \")\\nprint((k - 1) % (2", "gt": "* m) // 2 + 1, end=\" \")\\nif ((k - 1) % (2 * m) % 2 == 0):\\n print(\"L\")\\nelse:\\n print(\"R\")\\n"}
{"id": "500", "input": "def main():\\n n = int(input())\\n s = input()\\n \\n b, g, r = [s.count(i) for i in \"BGR\"]\\n \\n if min(b, g, r) > 0:\\n print(\"BGR\")\\n return\\n if max(b, g, r) == n:\\n if b == n: print(\"B\")\\n if g == n: print(\"G\")\\n if r == n: print(\"R\")\\n return\\n if max(b, g, r)", "gt": "== 1:\\n if b == 0: print(\"B\")\\n if g == 0: print(\"G\")\\n if r == 0: print(\"R\")\\n return\\n if max(b, g, r) == n - 1:\\n if b == n - 1: print(\"GR\")\\n if g == n - 1: print(\"BR\")\\n if r == n - 1: print(\"BG\")\\n return \\n \\n print(\"BGR\")\\n \\n \\nmain()"}
{"id": "501", "input": "def dfs(v, x, y, t, l, pr):\\n ans[v] = x, y\\n nx = [(l, 0), (0, -l), (-l, 0), (0, l)]\\n if t == 0: p = 0, 1, 3\\n if t == 1: p = 0, 1, 2\\n if t == 2: p = 1, 2, 3\\n if t == 3: p = 0, 2, 3\\n listv = [u for u in g[v] if u != pr]\\n g[v] = listv[:]\\n for i in range(min(len(p), len(g[v]))):\\n dx = nx[p[i]][0]\\n dy = nx[p[i]][1]\\n newx = x + dx\\n newy = y + dy\\n u = g[v][i]\\n dfs(u, newx, newy, p[i], l // 4, v)\\n\\nread =", "gt": "lambda: map(int, input().split())\\nn = int(input())\\ng = [list() for i in range(n + 1)]\\nfor i in range(n - 1):\\n u, v = read()\\n g[u].append(v)\\n g[v].append(u)\\ndef fail():\\n print('NO')\\n return\\nroot = 1\\nfor i in range(n + 1):\\n if len(g[i]) > 4:\\n fail()\\n if len(g[i]) > len(g[root]):\\n root = i\\nans = [0] * (n + 1)\\nans[root] = (0, 0)\\ninf = 10 ** 18\\nl = inf // 4\\nnx = [(l, 0), (0, -l), (-l, 0), (0, l)]\\nfor i in range(len(g[root])):\\n dx = nx[i][0]\\n dy = nx[i][1]\\n newx = 0 + dx\\n newy = 0 + dy \\n dfs(g[root][i], newx, newy, i, l // 4, root)\\nprint('YES')\\n[print(*i) for i in ans[1:]]"}
{"id": "502", "input": "def f(n, mod):\\n res = 0\\n n1 = 1\\n n2 = 2\\n k = 1\\n now = 0\\n while n >= k:\\n if now == 0:\\n now = 1\\n res = (res + n1 * k + (k * (k - 1))) % mod\\n n -= k\\n k *= 2\\n n1 = n1 + k\\n else:\\n now = 0\\n res = (res + n2 * k + (k * (k", "gt": "- 1))) % mod\\n n -= k\\n k *= 2\\n n2 = n2 + k\\n if n == 0:\\n return res\\n if now == 0:\\n return (res + n1 * n + (n * (n - 1))) % mod\\n return (res + n2 * n + (n * (n - 1))) % mod\\n\\nl, r = list(map(int, input().split()))\\nmod = 10 ** 9 + 7\\nprint((f(r, mod) - f(l - 1, mod)) % mod)\\n"}
{"id": "503", "input": "def read_ints():\\n return [int(i) for i in input().split()]\\n\\ncoords = read_ints()\\na, b, c = [(coords[i], coords[i + 1]) for i in range(0, len(coords), 2)]\\ndef length_sqr(a, b):\\n return (a[0] - b[0]) **", "gt": "2 + (a[1] - b[1]) ** 2\\n\\nif length_sqr(a, b) != length_sqr(b, c):\\n print('No')\\nelif (c[0] - b[0]) * (b[1] - a[1]) == (c[1] - b[1]) * (b[0] - a[0]):\\n print('No')\\nelse:\\n print('Yes')"}
{"id": "504", "input": "def main():\\n import sys\\n from collections import defaultdict\\n \\n tokens = [int(i) for i in sys.stdin.read().split()]\\n tokens.reverse()\\n \\n n, k = tokens.pop(), tokens.pop()\\n \\n d1 = defaultdict(int)\\n", "gt": "d2 = defaultdict(int)\\n result = 0\\n for i in tokens:\\n result += d2[i * k]\\n d2[i] += d1[i * k]\\n d1[i] += 1\\n \\n print(result)\\n \\n \\nmain()\\n"}
{"id": "505", "input": "# python3\\nfrom sys import stdin\\nfrom collections import namedtuple\\n\\n\\ndef readline(): return tuple(map(int, input().split()))\\n\\n\\nn, a, b = readline()\\nhand = [tuple(map(int, line.split())) for line in stdin.readlines()]\\n\\nif not b:\\n print(sum(creature[1] for creature in hand))\\nelse:\\n hand.sort(key=lambda self: self[0] - self[1])\\n\\n best = 0\\n if n > b:\\n l = hand[n - b]\\n", "gt": "lost = max(0, l[0] - l[1])\\n for creature in hand[:n-b]:\\n best = max(best, (creature[0] << a) - creature[1] - lost)\\n\\n for creature in hand[max(0,n-b):]:\\n best = max(best, (creature[0] << a) - max(creature))\\n\\n print((sum(creature[1] for creature in hand)\\n + sum(max(0, creature[0] - creature[1]) for creature in hand[max(0,n-b):])\\n + best))\\n"}
{"id": "506", "input": "import math\\nfrom collections import deque\\n\\ndef main():\\n n, m, k = list(map(int, input().split()))\\n grid = [\"\" for _ in range(n)]\\n x, y = 0, 0\\n\\n for i in range(n):\\n grid[i] = input()\\n if 'X' in grid[i]:\\n x, y = i, grid[i].index('X')\\n\\n if k % 2 == 1:\\n print(\"IMPOSSIBLE\")\\n return\\n\\n dx = [1, 0, 0, -1] \\n dy = [0, -1, 1, 0]\\n names = {(x1, y1): sym for x1, y1, sym in zip(dx, dy, \"DLRU\")}\\n rev_names = {x1: y1 for x1, y1 in zip(\"DLRU\", \"URLD\")}\\n\\n def ok(x, y):\\n return (0 <= x < n) and (0 <= y < m) and grid[x][y] != '*'\\n \\n\\n def bfs(x, y):\\n MAX_DIST = (1 << 20)\\n dist = [[MAX_DIST for y in range(m)] for x in range(n)]\\n dist[x][y] = 0\\n q = deque()\\n q.append((x, y))\\n\\n while len(q) > 0:\\n x, y =", "gt": "q.popleft()\\n\\n for x0, y0 in zip(dx, dy):\\n if ok(x + x0, y + y0) and dist[x][y] + 1 < dist[x + x0][y + y0]:\\n dist[x + x0][y + y0] = dist[x][y] + 1\\n q.append((x + x0, y + y0)) \\n\\n return dist \\n\\n path = []\\n x_start, y_start = x, y\\n\\n dist = bfs(x_start, y_start)\\n\\n for i in range(k // 2):\\n for x1, y1 in zip(dx, dy):\\n if ok(x + x1, y + y1):\\n path.append(names.get((x1, y1))) \\n x += x1\\n y += y1\\n break\\n else:\\n print(\"IMPOSSIBLE\")\\n return\\n\\n moves = k // 2 \\n for i in range(k // 2):\\n for x1, y1 in zip(dx, dy):\\n if ok(x + x1, y + y1) and dist[x + x1][y + y1] <= moves:\\n path.append(names.get((x1, y1)))\\n x += x1\\n y += y1\\n moves -= 1\\n break\\n\\n print(\"\".join(x for x in path))\\n\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "507", "input": "a, b = list(map(int, input().split()))\\n\\nans = 0\\n\\nwhile a and b:\\n if a > b:\\n ans += a", "gt": "// b\\n a = a % b\\n else:\\n ans += b // a\\n b = b % a\\n\\nprint(ans)\\n"}
{"id": "508", "input": "n = int(input())\\na = list(map(int,input().split()))\\nb = list(map(int,input().split()))\\ncnt = 0\\nfor i in range(n):\\n if a[i] != b[i]:\\n cnt += 1 \\n \\nif cnt == 1:\\n done = list(range(1,n+1))\\n x = 0\\n for i in range(n):\\n if a[i] == b[i]:\\n try:\\n done.remove(a[i])\\n except:\\n pass\\n else:\\n x = i\\n try:\\n done.remove(a[i])\\n except:\\n pass\\n try:\\n done.remove(b[i])\\n except:\\n pass\\n arr = a[::]\\n arr[x] = done[0]\\n for i", "gt": "in arr:\\n print(i,end = ' ')\\n \\nelse:\\n arr = a[::]\\n x = -1\\n y = -1\\n for i in range(n):\\n if a[i] == b[i]:\\n pass\\n else:\\n if x == -1:\\n x = i\\n else:\\n y = i\\n br = arr[::]\\n arr[x] = b[x]\\n br[y] = b[y]\\n if len(set(br)) == n:\\n arr = br[::]\\n for i in arr:\\n print(i,end = ' ') \\n"}
{"id": "509", "input": "3\\n\\ndef read_ints():\\n return [int(i) for i in input().split()]\\n\\nn, a = read_ints()\\n\\nres = 1\\n\\nfor i in range(2, n - 1):\\n if abs(a", "gt": "- res * 180 / n) > abs(a - i * 180 / n):\\n res = i\\n\\nprint(2, 1, res + 2)"}
{"id": "510", "input": "import getpass\\nimport sys\\n\\n\\ndef ria():\\n return [int(i) for i in input().split()]\\n\\n\\nif getpass.getuser() != 'frohenk':\\n filename = 'half'\\n # sys.stdin = open('input.txt')\\n # sys.stdout = open('output.txt', 'w')\\nelse:\\n sys.stdin = open('input.txt')\\n # sys.stdin.close()\\n\\nn = ria()[0]\\nar = []\\nfor i in range(n):\\n", "gt": "ar.append(ria()[0])\\n\\nsm = sum(ar) / 2\\nfor i in range(2 ** n):\\n c = 0\\n for j in range(n):\\n if i & (1 << j):\\n c += ar[j]\\n else:\\n c -= ar[j]\\n if c % 360 == 0:\\n print('YES')\\n return\\nprint('NO')\\n"}
{"id": "511", "input": "ii = lambda: int(input())\\nmi = lambda: list(map(int, input().split()))\\nli = lambda: list(mi())\\n\\na, b, c, d = mi()\\na, b, c", "gt": "= sorted([a, b, c])\\nans = max(0, d - (b - a)) + max(0, d - (c - b))\\nprint(ans)\\n"}
{"id": "512", "input": "from fractions import gcd\\nx, y = map(int, input().split())\\n\\na = int(x**.5 + 1)\\np = []\\nx1 = x\\nfor i in range(2, a + 1):\\n if (x1 % i == 0):\\n p.append(i)\\n while (x1 % i == 0):\\n x1 //= i\\nif (x1 > 1):\\n p.append(x1)\\nans =", "gt": "0\\nwhile (y != 0):\\n r = gcd(x, y)\\n x //= r\\n y //= r\\n max_can = 0\\n for i in range(len(p)):\\n if (x % p[i] == 0):\\n max_can = max(max_can, y - y % p[i])\\n ans += y - max_can\\n y = max_can\\nprint(ans)"}
{"id": "513", "input": "import sys\\n\\nreadline = sys.stdin.readline\\nMOD = 10 ** 9 + 7\\nINF = float('INF')\\nsys.setrecursionlimit(10 ** 5)\\n\\n\\ndef main():\\n N = int(readline())\\n L = 2 * N\\n floor = [[0, 0] for _ in range(L)]\\n com = dict()\\n\\n for i in range(1, N + 1):\\n A, B = map(int, readline().split())\\n com[i] = [-1, -1]\\n if A != -1:\\n if floor[A - 1][1] == 0:\\n floor[A - 1] = [i, 1]\\n com[i][0] = A - 1\\n else:\\n return print(\"No\")\\n if B != -1:\\n if floor[B - 1][1] == 0:\\n floor[B - 1] = [i, 2]\\n com[i][1] = B - 1\\n else:\\n return print(\"No\")\\n if A != -1 and B != -1:\\n if A >= B:\\n return print(\"No\")\\n\\n dp = [False] * (L + 1)\\n\\n if floor[0][1] == 2:\\n return", "gt": "print(\"No\")\\n else:\\n dp[0] = True\\n\\n for i in range(L):\\n if not dp[i]:\\n continue\\n for j in range(i + 1, L, 2):\\n ok = True\\n w = (j - i + 1) // 2\\n for k in range(w):\\n p = i + k\\n q = i + w + k\\n if floor[p][1] == 2 or floor[q][1] == 1:\\n ok = False\\n if floor[p][1] == 1 and floor[q][1] == 2:\\n if floor[p][0] != floor[q][0]:\\n ok = False\\n if floor[p][1] == 1:\\n f = floor[p][0]\\n if com[f][1] != q and com[f][1] != -1:\\n ok = False\\n if floor[q][1] == 2:\\n f = floor[q][0]\\n if com[f][0] != p and com[f][0] != -1:\\n ok = False\\n if ok:\\n dp[j + 1] = True\\n\\n print(\"Yes\") if dp[L] else print(\"No\")\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "514", "input": "X=[]\\nY=[]\\nPoints=[]\\nk=False\\nfor i in range(8):\\n x,y=list(map(int,input().split()))\\n X.append(x)\\n Y.append(y)\\n if([x,y] in Points):\\n k=True\\n Points.append([x,y])\\nX.sort()\\nY.sort()\\n\\nif(len(set(X))!=3 or len(set(Y))!=3 or", "gt": "k):\\n print(\"ugly\")\\n\\nelif(X.count(X[0])!=3 or X.count(X[3])!=2 or X.count(X[5])!=3):\\n print(\"ugly\")\\n\\nelif(Y.count(Y[0])!=3 or Y.count(Y[3])!=2 or Y.count(Y[5])!=3):\\n print(\"ugly\")\\n\\nelif([X[3],Y[3]] in Points):\\n print(\"ugly\")\\n\\nelse:\\n print(\"respectable\")\\n"}
{"id": "515", "input": "t = int(input())\\nfor _ in range(t):\\n n, d = list(map(int, input().split()))\\n if (1 -", "gt": "n) ** 2 - 4 * (d - n) >= 0:\\n print('YES')\\n else:\\n print('NO')\\n"}
{"id": "516", "input": "k = int(input())\\n\\nif k // 2 + k % 2 > 18:\\n print(-1)\\nelse:\\n", "gt": "print('8' * (k // 2) + ('6' if k % 2 else ''))\\n"}
{"id": "517", "input": "n, m = map(int, input().split())\\nmi = 100000000000000\\nts = \"\"\\ndef num_d(a, b):\\n t = 0\\n for x in range(len(a)):\\n if a[x] != b[x]:\\n t += 1\\n return t\\ns, t =", "gt": "input(), input()\\nfor x in range(m-n+1):\\n d = num_d(s, t[x:x+n])\\n if d < mi:\\n mi = d\\n ts = t[x:x+n]\\nprint(mi)\\nfor x in range(n):\\n if s[x] != ts[x]:\\n print(x+1, end=\" \")\\n"}
{"id": "518", "input": "import string\\n\\ni = input()\\ni = i.split(' ')\\nn, d, h = list([int(x) for x in i])\\n\\ndef check(n, d, h):\\n if d > 2 * h:\\n print(-1)\\n return\\n\\n if d < h:\\n print(-1)\\n return\\n if n < d + 1 or n < h + 1:\\n print(-1)\\n return\\n if d == 1 and n > 2:\\n print(-1)\\n return\\n\\nout = []\\n#h\\ncheck(n, d, h)\\nc = 0\\n# print('h')\\nfor i in range(h):\\n out.append(str(c + 1) + ' '", "gt": "+ str(c + 2))\\n # print(out[-1])\\n c += 1\\nc += 1\\nc1 = 0\\n# print('d')\\nfor i in range(d - h):\\n out.append(str(c1 + 1) + ' ' + str(c + 1))\\n # print(out[-1])\\n c1 = c\\n c += 1\\n\\nc += 1\\n# print('n')\\nif d == h:\\n s = 2\\nelse:\\n s = 1\\n \\nfor i in range(n - c + 1):\\n out.append(str(s) + ' ' + str(c))\\n # print(out[-1])\\n\\n c += 1\\n\\nfor el in out:\\n print(el)\\n\\n"}
{"id": "519", "input": "from math import sin\\npi = 3.141592653589793238462643383279502884197\\nn, r =", "gt": "map(int,input().split())\\ntheta = 2*pi / n\\nR = r / (1-sin(theta/2))\\nprint(R-r)"}
{"id": "520", "input": "withFile = 0\\n\\nif(withFile == 1):\\n fin = open('input.txt', 'r')\\n fout = open('output.txt', 'w')\\n\\ndef getl():\\n if(withFile == 0):\\n return input()\\n else:\\n return fin.readline()\\ndef printl(s):\\n if(withFile == 0):\\n print(s)\\n else:\\n fout.write(str(s))\\ndef get_arr():\\n", "gt": "x = getl().split(' ')\\n if(x[-1] == ''):\\n x = x[:-1]\\n return list(map(int, x))\\n\\nl = get_arr()[0]\\nb = get_arr()[0]\\nc = get_arr()[0]\\nt = l / (1.00 * b + c)\\nprint(t*b)\\n\\n\\nif(withFile == 1):\\n fin.close()\\n fout.close()"}
{"id": "521", "input": "n = int(input())\\narr =", "gt": "list(map(int, input().split()))\\nprint(sum(arr) // n)\\n"}
{"id": "522", "input": "input()\\ns = input()\\n\\nif 'MM' in s or 'YY' in s or 'CC' in s:\\n print ('No')\\nelif s.startswith('?') or s.endswith('?'):\\n print", "gt": "('Yes')\\nelif '??' in s:\\n print ('Yes')\\nelif 'C?C' in s or 'M?M' in s or 'Y?Y' in s:\\n print ('Yes')\\nelse:\\n print ('No')"}
{"id": "523", "input": "n, f1, f2, f3, c = list(map(int,input().split()))\\nmat = [[1,1,1],[1,0,0],[0,1,0]]\\nfinal = [[1,0,0],[0,1,0],[0,0,1]]\\nnn = n - 3\\nN = 10**9 + 6\\ndef prod(a, b):\\n m = [[0,0,0],[0,0,0],[0,0,0]]\\n for i in range(3):\\n for j in range(3):\\n m[i][j] = (a[i][0]*b[0][j] + a[i][1]*b[1][j]+a[i][2]*b[2][j]) % N\\n return m\\nwhile nn > 0:\\n if nn % 2 == 1:\\n final = prod(final, mat)\\n mat = prod(mat,mat)\\n nn //= 2\\nq = (final[0][0] * 3 + final[0][1] * 2 + final[0][2] * 1) % N\\np = q", "gt": "- (n%N) + N\\n# p to potega c\\nef3 = (final[0][0] * 1) % N\\nef2 = (final[0][1] * 1) % N\\nef1 = (final[0][2] * 1) % N\\n# print f1^ef1 *f2^ef2*f3^ef3 * c^p\\ndef pot(a,w):\\n wyn = 1\\n while w > 0:\\n if w%2 == 1:\\n wyn = (wyn * a) % (N+1)\\n a = (a * a) % (N+1)\\n w //= 2\\n return wyn\\nl1 = pot(f1, ef1)\\nl2 = pot(f2, ef2)\\nl3 = pot(f3, ef3)\\nl4 = pot(c, p)\\nc = (l1*l2*l3*l4)%(N+1)\\nprint(c)"}
{"id": "524", "input": "n, m = map(int, input().split())\\n\\np = ''\\nq = []\\n\\narr = [input() for __ in range(n)]\\ns = set(arr)\\nfor z in arr:\\n if z == z[::-1]:\\n p", "gt": "= z\\n else:\\n if z not in s: continue\\n if z[::-1] in s:\\n s.remove(z)\\n s.remove(z[::-1])\\n q += z,\\n\\nres = ''.join(q)\\nres = res + p + res[::-1]\\nprint(len(res))\\nprint(res)"}
{"id": "525", "input": "\\n\\nn=int(input())\\na=list(map(int,input().split()))\\na=sorted(a)\\n\\nif(n>65):\\n print(sum(a)-n)\\nelif(n==1 or n==2):\\n print(a[0]-1)\\nelse:\\n ans=10**20\\n\\n for i in range(1,50000):\\n", "gt": "now=1\\n ta=0\\n for j in a:\\n ta+=abs(now-j)\\n now*=i\\n ans=min(ans,ta)\\n\\n print(ans)\\n"}
{"id": "526", "input": "# for _ in range(1):\\nfor _ in range(int(input())):\\n # a, b = map(int, input().split())\\n n = int(input())\\n", "gt": "arr = list(map(int, input().split()))\\n # s = input()\\n if [arr[0]] * n == arr:\\n print(n)\\n else:\\n print(1)\\n"}
{"id": "527", "input": "n, m = [int(i) for i in input().split()]\\nA = []\\nC = []\\nfor i in range(n):\\n B = [int(j) for j in input().split()]\\n A.append(B)\\n C.append(sorted(list(set(B))))\\n\\nxor = 0\\nans = []\\n\\nfor i in range(n):\\n xor ^= A[i][0]\\n ans.append(1)\\n\\nif xor==0:\\n found", "gt": "= 0\\n for trial in range(n-1, -1, -1):\\n newxor = xor^A[trial][0]\\n if found==1:\\n break\\n for j in range(m):\\n if A[trial][j]^newxor!=0:\\n ans[trial] = j+1\\n found = 1\\n break\\n if found==1:\\n break\\n if found:\\n print('TAK')\\n print(*ans)\\n else:\\n print('NIE')\\nelse:\\n print('TAK')\\n print(*ans)\\n"}
{"id": "528", "input": "import sys\\nimport math\\nimport bisect\\nimport heapq\\nimport collections\\n\\nS = input()\\nT = input()\\nlenS = len(S)\\nlenT = len(T)\\nF1 = [False]*26\\nF2 = [False]*26\\nalpha = 'abcdefghijklmnopqrstuvwxyz'\\nfor i in range(lenS):\\n F1[alpha.index(S[i])] = True\\nfor i in range(lenT):\\n F2[alpha.index(T[i])]", "gt": "= True\\nfor i in range(26):\\n if not F1[i] and F2[i]:\\n print(-1)\\n return\\n\\nind = S.index(T[0])\\nans = ind+1\\nfor i in range(1,lenT):\\n S = S[ind+1:] + S[:ind+1]\\n ind = S.index(T[i])\\n ans += ind+1\\n\\nprint(ans)"}
{"id": "529", "input": "from collections import deque\\n\\n\\ndef bfs(start):\\n res = []\\n queue = deque([start])\\n while queue:\\n vertex = queue.pop()\\n if not vis[vertex]:\\n vis[vertex] = 1\\n res.append(vertex)\\n for i in s[vertex]:\\n if not vis[i]:\\n queue.append(i)\\n return res\\n\\nn, m = [int(i) for i in input().split()]\\ns = [[] for i in range(n)]\\nfor", "gt": "i in range(m):\\n a, b = [int(i) for i in input().split()]\\n s[a-1].append(b-1)\\n s[b-1].append(a-1)\\nvis = [0 for i in range(n)]\\nr = 0\\nfor i in range(n):\\n if not vis[i]:\\n d = bfs(i)\\n for j in d:\\n if len(s[j]) != len(d)-1:\\n r = 1\\n print(\"NO\")\\n break\\n if r:\\n break\\nelse:\\n print(\"YES\")"}
{"id": "530", "input": "t, p = input().lower(), 'abcdefghijklmnopqrstuvwxyz|'[int(input())]\\nprint(''.join(i.upper() if i", "gt": "< p else i for i in t))"}
{"id": "531", "input": "n = int(input())\\na, b = input(), input()\\nt = {i + j: 0 for i in '01' for j in '01'}\\nfor i in range(2 * n): t[a[i] + b[i]] +=", "gt": "1\\nd = t['11'] & 1\\nd += (t['10'] - t['01'] + 1 - d) // 2\\nif d > 0: d = 1\\nelif d < 0: d = 2\\nprint(['Draw', 'First', 'Second'][d])"}
{"id": "532", "input": "n=int(input())\\na=list(map(int,input().split()))\\nmm=max(a)\\nmmm=min(a)\\nif mmm!=mm-2:\\n print(n)\\n print(*a)\\nelse:\\n q,w,e=0,0,0\\n for i in a:\\n if i==mm:\\n e+=1\\n elif i==mmm:\\n q+=1\\n", "gt": "else:\\n w+=1\\n y=w%2+q+e\\n p=max(q,e)-min(q,e)\\n u=p+w\\n if y<u:\\n print(y)\\n print(*([mm]*(e+w//2)+[mmm]*(q+w//2)+[mm-1]*(w%2)))\\n else:\\n print(u)\\n if q>e:\\n print(*([mmm]*p+(n-p)*[mmm+1]))\\n else:\\n print(*([mm]*p+(n-p)*[mm-1]))\\n"}
{"id": "533", "input": "now = \"a\"\\nans = 0\\nS = input()\\nfor s in S:\\n x =", "gt": "abs(ord(s) - ord(now))\\n ans += min(x, 26 - x)\\n now = s\\nprint(ans)\\n"}
{"id": "534", "input": "a1=int(input())\\na2=int(input())\\nk1=int(input())\\nk2=int(input())\\nn=int(input())\\nans1=0\\nans2=0\\n\\nif k1<k2:\\n ans1+=min(n//k1,a1)\\n", "gt": "ans1+=(n-ans1*k1)//k2\\nelse :\\n ans1+=min(n//k2,a2)\\n ans1+=(n-ans1*k2)//k1\\nans2=max(0,n-(k1-1)*a1-(k2-1)*a2)\\nprint(ans2,ans1)\\n"}
{"id": "535", "input": "import copy\\n\\ndef process( s ):\\n res = s[:]\\n for i in range( 1, len(s) ):\\n if s[i] == 'G' and s[i - 1] == 'B':\\n res[i], res[i - 1] = res[i - 1], res[i]\\n return res\\n\\nfl =", "gt": "input().split()\\nn = int( fl[0] )\\nt = int( fl[1] )\\ns = input().split()[0]\\nS = []\\nfor i in range(n):\\n S.append( s[i] )\\nfor i in range(t):\\n S = process( S )\\nans = \"\"\\nfor i in range(n):\\n ans += S[i]\\nprint( ans )"}
{"id": "536", "input": "def primeFactor(N):\\n i = 2\\n ret = {}\\n n = N\\n mrFlg = 0\\n if n < 0:\\n ret[-1] = 1\\n n = -n\\n if n == 0:\\n ret[0] = 1\\n while i**2 <= n:\\n k = 0\\n while n % i == 0:\\n n //= i\\n k += 1\\n ret[i] = k\\n if i == 2:\\n i = 3\\n else:\\n i += 2\\n if i == 101 and n >= (2**20):\\n def findFactorRho(N):\\n # print(\"FFF\", N)\\n def gcd(a, b):\\n if b == 0:\\n return a\\n else:\\n return gcd(b, a % b)\\n def f(x, c):\\n return ((x ** 2) + c) % N\\n semi = [N]\\n for c in range(1, 11):\\n x=2\\n y=2\\n d=1\\n while d == 1:\\n x = f(x, c)\\n y = f(f(y, c), c)\\n d = gcd(abs(x-y), N)\\n if d != N:\\n if isPrimeMR(d):\\n return d\\n elif isPrimeMR(N//d):\\n return N//d\\n else:\\n semi.append(d)\\n\\n semi = list(set(semi))\\n # print (semi)\\n s = min(semi)\\n for i in [2,3,5,7]:\\n while True:\\n t = int(s**(1/i)+0.5)\\n if t**i == s:\\n s = t\\n if isPrimeMR(s):\\n return s\\n else:\\n break\\n\\n i = 3\\n while True:\\n if s % i == 0:\\n return i\\n i += 2\\n \\n while True:\\n if isPrimeMR(n):\\n ret[n] = 1\\n n = 1\\n break\\n else:\\n mrFlg = 1\\n j = findFactorRho(n)\\n k = 0\\n while n % j == 0:\\n n //= j\\n k += 1\\n ret[j] = k\\n if n == 1:\\n break\\n \\n if n > 1:\\n ret[n] = 1\\n if mrFlg > 0:\\n def dict_sort(X):\\n Y={}\\n for x in sorted(X.keys()):\\n Y[x] = X[x]\\n return Y\\n ret = dict_sort(ret)\\n return ret\\n\\ndef isPrime(N):\\n if N <= 1:\\n return False\\n return sum(primeFactor(N).values()) == 1\\n\\ndef isPrimeMR(n):\\n # print(\"MR\", n)\\n if n == 2: return True\\n if n == 1 or n & 1 == 0: return False\\n\\n d = (n - 1) >> 1\\n while d & 1 == 0:\\n d", "gt": ">>= 1\\n\\n for a in [2, 3, 5, 7, 11, 13, 17, 19]:\\n t = d\\n y = pow(a, t, n)\\n\\n while t != n - 1 and y != 1 and y != n - 1:\\n y = (y * y) % n\\n t <<= 1\\n\\n if y != n - 1 and t & 1 == 0:\\n # print(\"not prime\")\\n return False\\n # print(\"prime\")\\n return True \\n\\ndef findPrime(N):\\n if N < 0:\\n return -1\\n i = N\\n while True:\\n if isPrime(i):\\n return i\\n i += 1\\n\\ndef divisors(N):\\n pf = primeFactor(N)\\n ret = [1]\\n for p in pf:\\n ret_prev = ret\\n ret = []\\n for i in range(pf[p]+1):\\n for r in ret_prev:\\n ret.append(r * (p ** i))\\n return sorted(ret)\\n\\ndef mxpow(m, a, e):\\n if e == 1:\\n return a\\n if e % 2 == 0:\\n tmp = mxpow(m, a, e//2)\\n return mxprod(m, tmp, tmp)\\n else:\\n tmp = mxpow(m, a, e//2)\\n return mxprod(m, mxprod(m, tmp, tmp), a)\\n\\ndef mxprod(m, a, b):\\n ret = [[0]*m for _ in range(m)]\\n for i in range(m):\\n for j in range(m):\\n for k in range(m):\\n ret[i][j] += a[i][k] * b[k][j]\\n ret[i][j] %= P\\n return ret\\n\\ndef mxv(m, a, v):\\n ret = [0]*m\\n for i in range(m):\\n for k in range(m):\\n ret[i] += a[i][k] * v[k]\\n ret[i] %= P\\n return ret\\n\\ndef mx(m):\\n ret = [[0]*m for _ in range(m)]\\n for i in range(m):\\n for j in range(i, m):\\n ret[i][j] = inv(j+1)\\n \\n return ret\\n \\ndef vc(m):\\n return [0] * (m-1) + [1]\\n\\n\\ndef inv(a):\\n return pow(a, P-2, P)\\n\\n\\n# ----- -----\\n\\nP = 10**9 + 7\\n\\nn, k = list(map(int, input().split()))\\n# n = 6\\n# k = 2\\n\\npf = primeFactor(n)\\n# print(pf)\\n\\nans = 1\\nfor p in pf:\\n m = pf[p] + 1\\n vvv = mxv(m, mxpow(m, mx(m), k), vc(m))\\n\\n t = 0\\n for i in range(m):\\n t += (vvv[i] * p ** i) % P\\n t %= P\\n \\n ans *= t\\n ans %= P\\nprint(ans)\\n\\n"}
{"id": "537", "input": "from sys import stdin, stdout\\nn, m = map(int, stdin.readline().split())\\nif m < n - 1: stdout.write('-1')\\nelif m == n - 1: stdout.write('0' + '10' * m)\\nelif m == n: stdout.write('10' * m)\\nelif m == n + 1: stdout.write('10' * n", "gt": "+ '1')\\nelse:\\n k = m - (n + 1)\\n if k > n + 1: stdout.write('-1')\\n elif k == n + 1: stdout.write('110' * n + '11')\\n else: stdout.write('110' * k + '10' * (n - k) + '1')"}
{"id": "538", "input": "n, k = list(map(int, input().split()))\\np = (n // 2) // (k +", "gt": "1)\\ng = p * k\\no = n - p - g\\nprint(p, g, o)\\n"}
{"id": "539", "input": "n = input()\\nn = n.strip('0')\\nprint('YES'", "gt": "if n == n[::-1] else 'NO')\\n"}
{"id": "540", "input": "n = int(input())\\nans = 0\\nfor i in range(1, n + 1):\\n for j in range(i, n + 1):\\n if 0 < i", "gt": "^ j < n + 1 and i ^ j < i + j and i ^ j >= j:\\n ans += 1\\nprint(ans)\\n"}
{"id": "541", "input": "def read_data():\\n n, m = map(int, input().split())\\n maze = [[False] * (m + 2)]\\n for i in range(n):\\n maze.append([False] + [c == '.' for c in input().rstrip()] + [False])\\n maze.append([False] * (m + 2))\\n r1, c1 = map(int, input().split())\\n r2, c2 = map(int, input().split())\\n return n, m, maze, r1, c1, r2, c2\\n\\n\\ndef solve(n, m, maze, r1, c1, r2, c2):\\n dots = count_surrounding_intact_ices(maze, r2, c2)\\n if maze[r2][c2] == False:\\n if r1 == r2 and c1 == c2:\\n return dots >= 1\\n else:\\n return solve_wfs(n, m, maze, r1, c1, r2, c2)\\n else:\\n if dots >= 2:\\n return solve_wfs(n, m, maze, r1, c1, r2, c2)\\n if dots == 0:\\n return False\\n if dots == 1:\\n return is_side_by_side(r1, c1, r2, c2)\\n\\n\\ndef is_side_by_side(r1, c1, r2, c2):\\n if r1", "gt": "== r2:\\n return abs(c1 - c2) == 1\\n if c1 == c2:\\n return abs(r1 - r2) == 1\\n return False\\n\\n\\ndef count_surrounding_intact_ices(maze, r, c):\\n count = 0\\n for rr, cc in [(r+1, c), (r-1, c), (r, c+1), (r, c-1)]:\\n if maze[rr][cc]:\\n count += 1\\n return count\\n\\ndef solve_wfs(n, m, maze, r1, c1, r2, c2):\\n frontier = [(r1, c1)]\\n while frontier:\\n new_frontier = []\\n for r, c in frontier:\\n for nr, nc in [(r+1, c), (r-1, c), (r, c+1), (r, c-1)]:\\n if nr == r2 and nc == c2:\\n return True\\n if not maze[nr][nc]:\\n continue\\n maze[nr][nc] = False\\n new_frontier.append((nr, nc))\\n frontier = new_frontier\\n return False\\n\\ndef __starting_point():\\n n, m, maze, r1, c1, r2, c2 = read_data()\\n if solve(n, m, maze, r1, c1, r2, c2):\\n print('YES')\\n else:\\n print('NO')\\n__starting_point()"}
{"id": "542", "input": "n, m = map(int, input().split())\\nab = [list(map(int, input().split())) for _ in range(m)]\\n\\nab = sorted(ab, key=lambda x: x[1])\\ns", "gt": "= ab[0][1]\\nans = 1\\nfor i in ab:\\n if s <= i[0]:\\n ans += 1\\n s = i[1]\\nprint(ans)"}
{"id": "543", "input": "\"\"\"\\nCodeforces Contest 281 Div 2 Problem B\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef main():\\n n, = read()\\n a = []\\n b = []\\n last = 0\\n for i in range(n):\\n x, = read()\\n if x < 0:\\n b.append(-x)\\n last = 1\\n else:\\n a.append(x)\\n last = 0\\n if sum(a) > sum(b):\\n print(\"first\")\\n elif sum(b) > sum(a):\\n print(\"second\")\\n elif a > b:\\n print(\"first\")\\n elif b > a:\\n print(\"second\")\\n else:\\n", "gt": "print(\"second\" if last else \"first\")\\n\\n################################### NON-SOLUTION STUFF BELOW\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "544", "input": "n=input()\\nc=[int(x) for x in input().split()]\\np=0\\nd=True\\nfor i in c:\\n #print(p,d,i)\\n if i%2==0:\\n if", "gt": "p==1:\\n if i==0:\\n d=False\\n else:\\n p=1-p\\n\\nprint('YES' if d and p==0 else 'NO')"}
{"id": "545", "input": "def valid(a, b):\\n d = abs(ord(a) - ord(b))\\n return d == 0 or d == 2\\n\\nT = int(input())\\nfor _ in range(T):\\n n", "gt": "= int(input())\\n s = input()\\n val = all(valid(s[i], s[n - i - 1]) for i in range(n))\\n print('YES' if val else 'NO')\\n"}
{"id": "546", "input": "def main():\\n import sys\\n \\n n, t, s1, s2 = sys.stdin.read().split()\\n n, t = int(n), int(t)\\n \\n result = [-1] * n\\n rest = n - t\\n for i in range(n):\\n if rest == 0: break\\n if s1[i] == s2[i]:\\n result[i] = s1[i]\\n rest -= 1\\n k = rest\\n for i in range(n):\\n if k == 0: break\\n if result[i] == -1:\\n result[i]", "gt": "= s1[i]\\n k -= 1\\n k = rest\\n for i in range(n):\\n if k == 0: break\\n if result[i] == -1:\\n result[i] = s2[i]\\n k -= 1 \\n if k > 0:\\n print(-1)\\n return\\n for i in range(n):\\n if result[i] == -1:\\n for j in range(ord('a'), ord('a') + 4):\\n if chr(j) != s1[i] and chr(j) != s2[i]:\\n result[i] = chr(j)\\n break\\n \\n sys.stdout.write(''.join(result))\\n \\nmain()"}
{"id": "547", "input": "g = set(input())\\ns = input()\\nn = int(input())\\na = s.find(\"*\")\\nfor _ in range(n):\\n temp = input()\\n if a == -1:\\n if len(temp) != len(s):\\n print(\"NO\")\\n else:\\n for i in range(len(s)):\\n if s[i] == '?':\\n if temp[i] not in g:\\n print(\"NO\")\\n break\\n elif s[i] != temp[i]:\\n print(\"NO\")\\n break\\n else:\\n print(\"YES\")\\n else:\\n if len(temp) < len(s)-1:\\n print(\"NO\")\\n else:\\n for i in", "gt": "range(a):\\n if s[i] == '?':\\n if temp[i] not in g:\\n print(\"NO\")\\n break\\n elif s[i] != temp[i]:\\n print(\"NO\")\\n break\\n else:\\n for i in range(-(len(s) - a-1), 0):\\n if s[i] == '?':\\n if temp[i] not in g:\\n print(\"NO\")\\n break\\n elif s[i] != temp[i]:\\n print(\"NO\")\\n break\\n else:\\n for i in range(a, len(temp)-(len(s) - a-1)):\\n if temp[i] in g:\\n print(\"NO\")\\n break\\n else:\\n print(\"YES\")"}
{"id": "548", "input": "n, k = list(map(int, input().split()))\\na = []\\nfor i in range(n):\\n a.append(input())\\ns = input()\\nkmn = 1\\nkmx = 0\\nfor i in range(n):\\n if (len(a[i]) < len(s)):\\n kmn += 1\\n", "gt": "kmx += 1\\n elif (len(a[i]) == len(s)):\\n kmx += 1\\nprint((kmn - 1) // k * 5 + kmn, (kmx - 1) // k * 5 + kmx)\\n"}
{"id": "549", "input": "n = int(input())\\na = list(map(int, input().split()))\\n\\nnechet = 0\\n\\nfor el in a:\\n if", "gt": "el % 2 == 1:\\n nechet += 1\\n\\nif nechet == 0:\\n print('Second')\\nelse:\\n print('First')\\n"}
{"id": "550", "input": "\\nimport sys\\n#sys.stdin=open(\"data.txt\")\\ninput=sys.stdin.readline\\n\\nn=int(input())\\n\\nfor a in range(1,n+1)[::-1]:\\n if n%a:", "gt": "continue\\n if a>n//a: continue\\n print(\"%s %s\"%(a,n//a))\\n break"}
{"id": "551", "input": "import sys\\n\\n\\ndef normalize(s):\\n s = s.lower()\\n s = s.replace(\"o\", \"0\")\\n s = s.replace(\"l\", \"1\")\\n s = s.replace(\"i\", \"1\")\\n", "gt": "return s\\n\\n\\nquery = normalize(next(sys.stdin).strip())\\nn = int(next(sys.stdin).strip())\\n\\nfor line in sys.stdin:\\n line = normalize(line.strip())\\n if query == line:\\n print(\"No\")\\n return\\n\\nprint(\"Yes\")\\n"}
{"id": "552", "input": "def main():\\n n = int(input())\\n a = list(map(int, input().split()))\\n if a[1] - a[0] == a[2] - a[1]:\\n d = a[1] - a[0]\\n c1 = a[0]\\n c2 = 'no'\\n for i in range(3, n):\\n if i * d + c1 == a[i]:\\n pass\\n elif c2 == 'no':\\n c2 = a[i] - d * i\\n elif i * d + c2 == a[i]:\\n pass\\n else:\\n print('No')\\n return\\n if c2 == 'no':\\n print('No')\\n else:\\n print('Yes')\\n return\\n else:\\n f = True\\n d = a[1] - a[0]\\n c1 = a[0]\\n c2 = a[2] - 2 * d\\n #print(d, c1, c2)\\n for i in range(3, n):\\n if (a[i] == i * d + c1) or (a[i] == i * d + c2):\\n pass\\n else:\\n f =", "gt": "False\\n break\\n if f:\\n print('Yes')\\n return\\n f = True\\n d = a[2] - a[1]\\n c1 = a[1] - d\\n c2 = a[0]\\n #print(d, c1, c2)\\n for i in range(3, n):\\n if (a[i] == i * d + c1) or (a[i] == i * d + c2):\\n pass\\n else:\\n f = False\\n break\\n if f:\\n print('Yes')\\n return\\n f = True\\n d = (a[2] - a[0]) / 2\\n c1 = a[0]\\n c2 = a[1] - d\\n #print(d, c1, c2)\\n for i in range(3, n):\\n #print(a[i], i * d + c1, i * d + c2)\\n if (a[i] == i * d + c1) or (a[i] == i * d + c2):\\n pass\\n else:\\n f = False\\n break\\n if f:\\n print('Yes')\\n else:\\n print('No')\\n\\nmain()\\n"}
{"id": "553", "input": "import sys, logging\\nlogging.basicConfig(level=logging.INFO)\\nlogging.disable(logging.INFO)\\n\\ndef build(S, n):\\n Z = [0 for i in range(3 * n + 3)]\\n #logging.info(S)\\n n = len(S)\\n L = 0\\n R = 0\\n Z[0] = n\\n for i in range(1, n):\\n if(i > R):\\n L = R = i\\n while(R < n and S[R] == S[R - L]):\\n R += 1\\n Z[i] = R - L\\n R -= 1\\n else:\\n k = i - L\\n if(Z[k] < R - i + 1):\\n Z[i] = Z[k]\\n else:\\n L = i\\n while(R < n and S[R] == S[R - L]):\\n R += 1\\n Z[i] = R - L\\n R -= 1\\n return Z\\n\\ndef update1(n, x, val):\\n while(x <= n + 1):\\n bit1[x] += val\\n x += x & -x\\n\\ndef get1(n, x):\\n ans = 0\\n while(x > 0):\\n ans += bit1[x]\\n x -= x & -x\\n return ans\\n\\ndef update2(n, x, val):\\n while(x <= n + 1):\\n bit2[x] += val\\n x += x & -x\\n\\ndef get2(n, x):\\n ans = 0\\n while(x > 0):\\n ans += bit2[x]\\n x -= x & -x\\n return ans\\n\\ndef process(n, m, fa, fb):\\n r2 = int(1)\\n ans = 0\\n for l1 in range(1, n + 1):\\n while(r2 <= min(n, l1 +", "gt": "m - 2)):\\n update1(n, m - fb[r2] + 1, 1)\\n update2(n, m - fb[r2] + 1, fb[r2] - m + 1)\\n r2 += 1\\n ans += get1(n, fa[l1] + 1) * fa[l1] + get2(n, fa[l1] + 1)\\n update1(n, m - fb[l1] + 1, -1)\\n update2(n, m - fb[l1] + 1, m - 1 - fb[l1])\\n print(ans)\\n\\ndef main():\\n n, m = map(int, sys.stdin.readline().split())\\n a = sys.stdin.readline()\\n b = sys.stdin.readline()\\n s = sys.stdin.readline()\\n a = a[:(len(a) - 1)]\\n b = b[:(len(b) - 1)]\\n s = s[:(len(s) - 1)]\\n fa = build(s + a, n)\\n kb = build(s[::-1] + b[::-1], n)\\n fb = [0 for k in range(n + 2)]\\n for i in range(m, m + n):\\n fa[i - m + 1] = fa[i]\\n if(fa[i - m + 1] >= m):\\n fa[i - m + 1] = m - 1\\n fb[m + n - i] = kb[i]\\n if(fb[m + n - i] >= m):\\n fb[m + n - i] = m - 1\\n logging.info(fa[1:(n + 1)])\\n logging.info(fb[1:(n + 1)])\\n process(n, m, fa, fb)\\n\\nbit1 = [0 for i in range(500004)]\\nbit2 = [0 for i in range(500004)]\\n\\ndef __starting_point():\\n try:\\n sys.stdin = open('input.txt', 'r')\\n sys.stdout = open('output.txt', 'w')\\n except:\\n pass\\n main()\\n__starting_point()"}
{"id": "554", "input": "n = int(input())\\n\\nm = 6\\narr = []\\nfor i in range(n):\\n arr.append(input())\\n \\nfor i in range(n - 1):\\n for j in range(i + 1, n):\\n d = 0\\n for z in range(6):\\n if arr[i][z] != arr[j][z]:\\n d += 1\\n", "gt": "\\n if d == 6:\\n m = min(m, 2)\\n elif d == 5:\\n m = min(m, 2)\\n elif d == 4:\\n m = min(m, 1)\\n elif d == 3:\\n m = min(m, 1)\\n else:\\n m = 0\\n \\nprint(m)"}
{"id": "555", "input": "n, m = list(map(int, input().split()))\\na = [0] + list(map(int, input().split()))\\npr = [0 for i in range(len(a))]\\nfor i in range(1, len(a)):\\n pr[i] = pr[i - 1]", "gt": "+ a[i]\\n\\nans = 0\\nfor i in range(m):\\n l, r = list(map(int, input().split()))\\n cur = pr[r] - pr[l - 1]\\n if cur >= 0:\\n ans += cur\\n\\nprint(ans)\\n\\n"}
{"id": "556", "input": "x = list(input())\\n\\nfor i in range(len(x)):\\n if(i==0 and x[i]=='9'):\\n", "gt": "continue\\n if(int(x[i])>9-int(x[i])):\\n x[i] = str(9-int(x[i]))\\ny=0\\nfor item in x:\\n y*=10\\n y+=int(item)\\nprint(y)\\n"}
{"id": "557", "input": "l, r, n = map(int, input().split())\\na = n\\nn = 1\\ncnt = 0\\nwhile n <= r:\\n if", "gt": "n >= l:\\n cnt += 1\\n print(n, end=' ')\\n n *= a\\nif cnt == 0:\\n print(-1)"}
{"id": "558", "input": "n, m = map(int, input().split())\\nd = []\\nfor i in range(n):\\n d.append(list(map(int, input().split())))\\nk = 0\\nfor i", "gt": "in d:\\n if i[0] <= k:\\n k = max(k, i[1])\\nif k >= m:\\n print('YES')\\nelse:\\n print('NO')"}
{"id": "559", "input": "n, m, k = map(int, input().split())\\nmod = 998244353\\n\\ndef powerDX(n, r, mod):\\n if r == 0: return 1\\n if r%2 == 0:\\n return powerDX(n*n % mod, r//2, mod) % mod\\n if r%2 == 1:\\n return n * powerDX(n, r-1, mod) % mod\\n\\ndef cmb(n, r, mod):\\n if ( r<0 or r>n ):\\n return 0\\n r = min(r, n-r)\\n return g1[n] * g2[r] * g2[n-r]", "gt": "% mod\\n \\ng1 = [1, 1]\\ng2 = [1, 1]\\ninverse = [0, 1]\\n \\nfor i in range(2, n + 1 ):\\n g1.append( ( g1[-1] * i ) % mod )\\n inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\\n g2.append( (g2[-1] * inverse[-1]) % mod )\\n\\nans = 0\\nfor i in range(0, k+1):\\n ans += m*cmb(n-1, i, mod)*pow(m-1, n-i-1, mod)\\n ans %= mod\\nprint(ans)"}
{"id": "560", "input": "import sys\\ninput = sys.stdin.readline\\nsys.setrecursionlimit(10 ** 7)\\n\\nimport numpy as np\\nimport itertools\\n\\nP = int(input())\\nA = [int(x) for x in input().split()]\\n\\n# k,i -> i^k\\npower = np.ones((P,P),dtype = np.int64)\\nfor k in", "gt": "range(1,P):\\n power[k] = power[k-1] * np.arange(P,dtype=np.int64) % P\\n\\nf = np.zeros(P,dtype=np.int64)\\nfor i,a in enumerate(A):\\n if a == 1:\\n f[0] += 1\\n f -= power[:,i][::-1]\\nf %= P\\n\\nf %= P\\nprint((*f))\\n\\n"}
{"id": "561", "input": "r, c = list(map(int, input().split()))\\ncake = [input().strip() for _ in range(r)]\\nans = 0\\nfor i in range(r):\\n for j", "gt": "in range(c):\\n if cake[i][j] == '.' and ('S' not in cake[i] or 'S' not in list(zip(*cake))[j]):\\n ans += 1\\nprint(ans)\\n"}
{"id": "562", "input": "n=int(input())\\na=list(map(int,input().split()))\\nif n==1:\\n print(-1)\\n return\\na.sort()\\nd=[]\\nfor i in range(1,n):\\n d.append(a[i]-a[i-1])\\nif min(d)==max(d)==0:\\n print(1)\\n print(a[0])\\nelif n==2:\\n if d[0]%2:\\n print(2)\\n print(a[0]-d[0],a[1]+d[0])\\n else:\\n print(3)\\n print(a[0]-d[0],a[0]+d[0]//2,a[1]+d[0])\\nelif min(d)==max(d):\\n print(2)\\n", "gt": "print(a[0]-d[0],a[-1]+d[0])\\nelse:\\n m1=0\\n m2=0\\n for i in range(1,n-1):\\n if d[i]<d[m1]: m1=i\\n if d[i]>d[m2]: m2=i\\n c=d.count(d[m1])\\n if c==n-2 and d[m1]*2==d[m2]:\\n print(1)\\n print(a[m2]+d[m1])\\n else:\\n print(0)"}
{"id": "563", "input": "n = int(input())\\nshows = []\\nfor i in range(n):\\n l, r = map(int, input().split())\\n shows.append((l,r))\\n \\nshows.sort()\\n\\na_endtime, b_endtime = -1, -1\\nfor show in", "gt": "shows:\\n if show[0] <= a_endtime:\\n print('NO')\\n break\\n else:\\n a_endtime = show[1]\\n if a_endtime > b_endtime:\\n a_endtime, b_endtime = b_endtime, a_endtime\\n \\nelse:\\n print('YES')"}
{"id": "564", "input": "from sys import stdin\\nfrom fractions import gcd\\nlines = list([_f for _f in stdin.read().split('\\n') if _f])\\n\\ndef parseline(line):\\n return list(map(int, line.split()))\\n\\nlines = list(map(parseline, lines))\\n\\nl, r = lines[0]\\n\\nfor a in range(l,", "gt": "r+1):\\n for b in range(a, r+1):\\n for c in range(b, r + 1):\\n if gcd(a, b) == gcd(b, c) == 1 != gcd(a, c):\\n print(a, b, c)\\n return\\nprint(-1)\\n"}
{"id": "565", "input": "n,s=map(int,input().split())\\na=list(map(int,input().split()))\\na.sort()\\nif sum(a[:-1])<=s:\\n", "gt": "print('YES')\\nelse:\\n print('NO')"}
{"id": "566", "input": "<s> ", "gt": "y,b,r=map(int,input().split())\\nm=min(y,b-1,r-2)\\nprint(3*m+3)"}
{"id": "567", "input": "r, g, b = map(int, input().split())\\nmaxi = (r + g +", "gt": "b) // 3\\nprint(min(maxi, r + g, r + b, g + b))"}
{"id": "568", "input": "n = int(input())\\na = list(map(int, input().split()))\\ne = 1000000\\nans =", "gt": "max(min(x - 1, e - x) for x in a)\\nprint(ans)\\n"}
{"id": "569", "input": "n = int(input())\\nprint((3 ** (3 *", "gt": "n) - 7 ** n) % 1000000007)"}
{"id": "570", "input": "#!/usr/bin/env python3\\n\\nfrom collections import Counter\\n\\ntry:\\n while True:\\n n = int(input())\\n s = input()\\n", "gt": "if n > 26:\\n print(-1)\\n else:\\n c = Counter(s)\\n print(sum(c.values()) - len(c))\\n\\nexcept EOFError:\\n pass\\n"}
{"id": "571", "input": "a, b = map(int,input().split())\\ni = 1\\nwhile 1:\\n if a < i:\\n print(\"Vladik\")\\n break\\n", "gt": "a-= i\\n i+= 1\\n if b < i:\\n print(\"Valera\")\\n break\\n b-= i\\n i+= 1"}
{"id": "572", "input": "n = q = int(input())\\nk = list(input())\\ncntl = k.count('(')\\ncntr = k.count(')')\\ncntq = k.count('?')\\nfor i in range(n):\\n if k[i] == '?':\\n if cntl < q // 2 and cntr + cntq >= q // 2:\\n k[i] = '('\\n cntl += 1\\n cntq -= 1\\n else:\\n k[i] = ')'\\n cntr += 1\\n cntq", "gt": "-= 1\\n \\ndef check():\\n cnt = 0\\n m = 0\\n for i in k:\\n m += 1\\n if i == '(':\\n cnt += 1\\n else:\\n cnt -= 1\\n if cnt == 0 and m < n or cnt < 0:\\n return False\\n return cnt == 0\\n\\nprint(''.join(k) if check() else ':(')\\n \\n \\n"}
{"id": "573", "input": "def convert_to_binary(coef):\\n res = []\\n n = len(coef)\\n carry = 0\\n i = 0\\n while i < n + 1000:\\n if i >= n and not carry:\\n break\\n cur = carry\\n if i < n:\\n cur += coef[i]\\n\\n mod = cur % 2\\n div = cur // 2\\n# print(cur, div, mod)\\n\\n res.append(mod)\\n\\n carry = div\\n\\n i += 1\\n return res, carry\\n\\nn, k = list(map(int, input().split()))\\ncoef = list(map(int, input().split()))\\n\\nb, carry = convert_to_binary(coef)\\nref = False\\nif carry < 0:\\n b, carry = convert_to_binary(list([-x for x in coef]))\\n ref = True\\n\\n\\nlast", "gt": "= len(b) - 1\\nwhile b[last] != 1:\\n last -= 1\\n\\nans = 0\\nfor i in range(0, n + 1):\\n if last - i > 40:\\n continue\\n\\n cur = 0\\n for j in range(i, last + 1):\\n cur += b[j] * (2 ** (j - i))\\n\\n new_coef = coef[i] - cur\\n if ref:\\n new_coef = coef[i] + cur\\n\\n if abs(new_coef) > k:\\n if b[i] == 1:\\n break\\n continue\\n\\n if i == n and new_coef == 0:\\n if b[i] == 1:\\n break\\n continue\\n\\n ans += 1\\n if b[i] == 1:\\n break\\n\\n\\nprint(ans)\\n"}
{"id": "574", "input": "n = int(input())\\nd = list(map(int, input().split()))\\ns = {i:0 for i in [1, 2]}\\nfor i in", "gt": "d:\\n s[i] += 1\\nif s[2] >= s[1]:\\n print(s[1])\\nelse:\\n print(s[2] + (s[1] - s[2]) // 3)\\n"}
{"id": "575", "input": "x1, y1, x2, y2 = map(int, input().split())\\n\\ndx, dy = (x2 - x1) // 2,", "gt": "(y2 - y1) // 2\\nprint(dx + 1 + (2 * dx + 1) * dy)"}
{"id": "576", "input": "n = int(input())\\nax, ay = list(map(int, input().split(' ')))\\nbx, by = list(map(int, input().split(' ')))\\ncx, cy = list(map(int, input().split('", "gt": "')))\\n\\nif ((cx < ax) == (bx < ax)) and ((cy < ay) == (by < ay)):\\n print('YES')\\nelse:\\n print('NO')"}
{"id": "577", "input": "import math \\nN = 10**5 + 10\\nu = [-1]*N\\ndivi = [ [] for i in range(N) ] \\npd = [ [] for i in range(N) ] \\nmark = [0]*N\\n\\ndef precalc():\\n for i in range(1,N) :\\n for j in range(i,N,i) :\\n divi[j].append(i)\\n\\n for i in range(2,N) : \\n if mark[i] == 1 : \\n continue\\n for j in range(i,N,i) :\\n pd[j].append(i)\\n mark[j] = 1\\n\\n for i in range(1,N) : \\n for prm in pd[i] :\\n time = 0\\n _i = i \\n while _i % prm == 0 : \\n time += 1\\n _i /= prm\\n if time > 1 :\\n u[i] = 0\\n continue\\n if u[i] == -1 : \\n if len(pd[i]) & 1 :\\n u[i] = -1\\n else : \\n u[i] = 1\\n \\nhas =", "gt": "[False]*N \\ncnt = [0]*N\\n\\ndef has_coprime(n):\\n ret = 0\\n for d in divi[n] :\\n ret += u[d] * cnt[d]\\n return ret\\n\\ndef update(n,val) :\\n for d in divi[n] :\\n cnt[d] += val\\n\\n \\ndef solve(n) :\\n li = list(map(int,input().split()))\\n ans = 0\\n for i in range(n) : \\n if has[li[i]] : \\n ans = max(ans,li[i])\\n has[li[i]] = True\\n\\n for g in range(1,N) :\\n st = [] \\n for num in reversed(list(range(1,N//g + 1))) :\\n if num*g > N-1 or not has[num*g] : \\n continue\\n how_many = has_coprime(num)\\n\\n while how_many > 0 : \\n #print(how_many)\\n now = st.pop()\\n if math.gcd(now,num) == 1 : \\n ans = max(ans,num*now*g)\\n how_many -= 1\\n update(now,-1)\\n st.append(num)\\n update(num,1)\\n while st :\\n update(st.pop(),-1)\\n\\n print(ans)\\n\\nprecalc()\\n\\nwhile True : \\n try : \\n n = int(input())\\n solve(n)\\n except EOFError:\\n break\\n"}
{"id": "578", "input": "def check(k, aas, bs, a_rem, b_rem):\\n if a_rem + b_rem < k:\\n return False\\n a_lo = k - b_rem\\n a_hi = a_rem\\n\\n rems = set()\\n rems.add(0)\\n for a, b in zip(aas, bs):\\n if a + b < k:\\n continue\\n for i in range(max(0, k - b), min(a, k) + 1):\\n rem = i % k\\n for j in list(rems):\\n rems.add((j + rem) % k)\\n for rem in", "gt": "rems:\\n if rem >= a_lo and rem <= a_hi:\\n return True\\n return False\\n\\n\\nn, k = [int(x) for x in input().split()]\\naas = []\\nbs = []\\na_total = 0\\nb_total = 0\\nfor i in range(n):\\n a, b = [int(x) for x in input().split()]\\n aas.append(a)\\n bs.append(b)\\n a_total += a\\n b_total += b\\nans = a_total // k + b_total // k\\nif check(k, aas, bs, a_total % k, b_total % k):\\n print(ans + 1)\\nelse:\\n print(ans)\\n"}
{"id": "579", "input": "s = input()\\na = str()\\nb = str()\\nf = False\\nfor i in range(len(s)):\\n if s[i] == 'e':\\n f = True\\n elif f:\\n b = b + s[i]\\n else:\\n a = a + s[i]\\npos = a.index('.')\\nn = int(b)\\na = list(a)\\nfor i in range(n):\\n if pos == len(a) - 1:\\n a.append('0')\\n", "gt": "a[pos], a[pos + 1] = a[pos + 1], a[pos]\\n pos += 1\\nif a[-1] == '.':\\n a.pop()\\nif '.' in a:\\n while a[-1] == '0':\\n a.pop()\\nif a[-1] == '.':\\n a.pop()\\nif '.' not in a:\\n while len(a) > 1 and a[0] == '0':\\n a.pop(0)\\nfor i in range(len(a)):\\n print(a[i], end = '')\\n"}
{"id": "580", "input": "import numpy as np\\n\\ndef __starting_point():\\n\\n N,K = list(map(int,input().split()))\\n P = [ int(p)-1 for p in input().split() ]\\n C = list(map(int,input().split()))\\n\\n # print(P)\\n # 一度計算したサイクル情報をキャッシュしておくための配列\\n cycleIDs = np.full( N, -1, np.int64 )\\n cycleInfs = []\\n cycleID = 0\\n procCnt = 0\\n\\n for n in range(N):\\n v = n\\n\\n if cycleIDs[v] != -1:\\n continue\\n else:\\n currentCycleCosts = []\\n while True:\\n # 全頂点について、属するサイクルを計算する\\n currentCycleCosts.append( C[v] )\\n cycleIDs[v] = cycleID\\n\\n v = P[v]\\n if cycleIDs[v] != -1:\\n # サイクル終了\\n # ループを含めない最大の処理回数\\n procCnt = K % len( currentCycleCosts )\\n # それで足りてるのかわからないが、Last2周分は、ループするものとして確定させない\\n # その部分は、ちゃんと計算する\\n # -------------------------------------------------\\n # 4 101\\n # 2 3 4 1\\n # 50 -49 -50 50\\n # 上記のようなパターンの場合、\\n # 最大25回ループ + 1回処理可能だが、その場合、25 + 50 = 75\\n # 24回ループ + 2回処理でやめると、124になる\\n", "gt": "# 無条件でループする回数は、最大の回数だけでなく、\\n # 最大の回数-1も考慮の必要あり\\n # -------------------------------------------------\\n # あるいは、割り切れて、尚且つサイクル合計がマイナスのパターンで、最低１個は処理するのにもここで対応\\n if len( currentCycleCosts ) + procCnt <= K:\\n procCnt += len( currentCycleCosts )\\n\\n cycleInfs.append( ( procCnt, len(currentCycleCosts), np.array( currentCycleCosts + currentCycleCosts ) ) )\\n cycleID += 1\\n break\\n\\n\\n\\n # scores = []\\n # procCnt = 0\\n ans = -10 ** 9\\n for procCnt, currentCycleSize, currentCycleCosts in cycleInfs:\\n\\n # サイクル内でループしてスコアを稼ぐ場合の考慮\\n loopScore = 0\\n fullMinus1CntLoopScore = 0\\n if np.sum(currentCycleCosts) > 0:\\n cycleLoopCnt = ( K - procCnt ) // currentCycleSize\\n loopScore = cycleLoopCnt * np.sum(currentCycleCosts[:currentCycleSize])\\n # print(\"loopScore\",loopScore,procCnt)\\n\\n # このサイクルに属する全頂点分をまとめて計算する\\n for i in range(currentCycleSize):\\n # scores.append( np.roll( currentCycleCosts, i )[:procCnt].cumsum().max() + loopScore )\\n # print(np.roll( currentCycleCosts, i ).cumsum()[:procCnt])\\n ans = max( ans, np.roll( currentCycleCosts, i ).cumsum()[:procCnt].max() + loopScore )\\n\\n\\n print(ans)\\n # print(max(scores))\\n\\n__starting_point()"}
{"id": "581", "input": "from heapq import *\\nimport sys\\n\\nMOD = 1000000181\\n\\ndef addM(a,b):\\n return (a+b)%MOD\\ndef mulM(a,b):\\n return (a*b)%MOD\\n\\ndef dijk(adj,n,s):\\n dist = [10**18]*n\\n ways = [0]*n\\n frontier = []\\n dist[s] = 0\\n ways[s] = 1\\n heappush(frontier,(0,s))\\n while (len(frontier)>0):\\n x = heappop(frontier)\\n if x[0]!=dist[x[1]]:\\n continue\\n x = x[1]\\n for (i,l) in adj[x]:\\n if dist[x]+l<dist[i]:\\n dist[i] = dist[x]+l\\n ways[i] = ways[x]\\n heappush(frontier,(dist[i],i))\\n elif", "gt": "dist[x]+l==dist[i]:\\n ways[i] = addM(ways[i],ways[x])\\n return (dist,ways)\\n\\nn,m,s,t = map(int,sys.stdin.readline().split())\\ns-=1\\nt-=1\\nadj = [[] for i in range(n)]\\njda = [[] for i in range(n)]\\nedges = []\\n\\nfor i in range(m):\\n a,b,l = map(int,sys.stdin.readline().split())\\n a-=1\\n b-=1\\n adj[a].append((b,l))\\n jda[b].append((a,l))\\n edges.append((a,b,l))\\n\\none = dijk(adj,n,s)\\ntwo = dijk(jda,n,t)\\n\\nfor i in edges:\\n if one[0][i[0]]+i[2]+two[0][i[1]]==one[0][t] and mulM(one[1][i[0]],two[1][i[1]])==one[1][t]:\\n sys.stdout.write(\"YES\\n\")\\n else:\\n x = one[0][t]-1-one[0][i[0]]-two[0][i[1]]\\n if x<=0:\\n sys.stdout.write(\"NO\\n\")\\n else:\\n sys.stdout.write(\"CAN \"+str(i[2]-x)+\"\\n\")"}
{"id": "582", "input": "import sys\\nfrom collections import deque as dq\\nn = int(input())\\n\\nind = 0\\ninp = [int(x)-1 for line in sys.stdin.readlines() for x in line.split()]\\n\\ncoupl = [[] for _ in range(n)]\\nfor _ in range(n-1):\\n a,b = inp[ind],inp[ind+1]\\n ind+=2\\n coupl[a].append(b)\\n coupl[b].append(a)\\n\\nQ = dq()\\nfound = [False]*n\\nmaster = 0\\nfound[master] = True\\n\\ndia1 = 0\\nQ.append(master)\\nwhile Q:\\n node = Q.popleft()\\n dia1 = node\\n for nei in coupl[node]:\\n if not found[nei]:\\n found[nei] = True\\n Q.append(nei)\\n\\n\\ndia2 = 0\\nQ.append((dia1,0))\\ndist1 = [0]*n\\nfound = [False]*n\\nfound[dia1] = True\\nwhile Q:\\n node,d = Q.popleft()\\n dia2 = node\\n dist1[node]=d\\n for nei in coupl[node]:\\n if not found[nei]:\\n found[nei] = True\\n Q.append((nei,d+1))\\n\\nQ =", "gt": "[]\\nQ.append((dia2,0))\\ndist2 = [0]*n\\nfound = [False]*n\\nfound[dia2] = True\\nwhile Q:\\n node,d = Q.pop()\\n dist2[node]=d\\n for nei in coupl[node]:\\n if not found[nei]:\\n found[nei] = True\\n Q.append((nei,d+1))\\n\\nneigs = [0]*n\\n\\nleaves = []\\nfor i in range(n):\\n if i != dia1 and i != dia2 and len(coupl[i])==1:\\n leaves.append(i)\\n neigs[i]=len(coupl[i])\\npoints = 0\\nlista = []\\n\\nwhile leaves:\\n node = leaves.pop()\\n if dist1[node]<dist2[node]:\\n lista.append((dia2,node,node))\\n points += dist2[node]\\n else:\\n lista.append((dia1,node,node))\\n points += dist1[node]\\n for nei in coupl[node]:\\n neigs[nei]-=1\\n if neigs[nei]==1:\\n leaves.append(nei)\\nleaves.append(dia2)\\nwhile leaves:\\n node = leaves.pop()\\n lista.append((dia1,node,node))\\n points += dist1[node]\\n for nei in coupl[node]:\\n neigs[nei]-=1\\n if neigs[nei]==1:\\n leaves.append(nei)\\nprint(points)\\nfor l in lista:\\n a,b,c = l\\n print(a+1,b+1,c+1)\\n"}
{"id": "583", "input": "import sys\\nfrom heapq import heappush, heappop\\n\\nn = int(input())\\na = list(map(int, input().split()))\\n\\ncount = {}\\n\\nfor x in a:\\n if x in count:\\n count[x] = count[x] + 1\\n else:\\n count[x] = 1\\n\\ncount = sorted(list(count.items()))\\n#print(count)\\n\\ncost= list(map(int, input().split()))\\nmax_cost = max(cost)\\n\\na = list(zip(a, cost))\\na = sorted(a)\\npriority = list([max_cost - x for x in [x[1] for x in a]])\\na = list(zip(priority, a))\\n\\ni = 0\\nqueue = []\\nqueue_cost = 0\\nresult = 0\\n\\n#print(a)\\n\\nfor j in range(len(count)):\\n x, c = count[j]\\n", "gt": "#print('x = ', x)\\n while i < len(a) and a[i][1][0] == x:\\n queue_cost += a[i][1][1]\\n heappush(queue, a[i])\\n i += 1\\n\\n #print('queue = ', queue)\\n y = x\\n while len(queue) > 0 and (j == len(count) - 1 or count[j + 1][0] != y):\\n popped = heappop(queue)\\n #print(popped, queue)\\n queue_cost -= popped[1][1]\\n #print(queue_cost)\\n result += queue_cost\\n y += 1\\n\\n# while len(queue) > 0:\\n# popped = heappop(queue)\\n# queue_cost -= popped[1][1]\\n# result += queue_cost\\n\\nprint(result)\\n"}
{"id": "584", "input": "n = int(input())\\nst = input()\\ns = [0 if c == \"(\" else 1 for c in st]\\nif n % 2 != 0 or sum(s) != n//2:\\n print(0)\\n print(1,1)\\n return\\nmaxx = 0\\nind = (0,0)\\nmaxshift = 0\\nfor shift in range(n):\\n stack = 0\\n x1 = -1\\n x2 = -1\\n sumzero = 0\\n for i,c in enumerate(s):\\n if s[(i+shift)%n] == 0:\\n stack+=1\\n else:\\n stack-=1\\n if stack == 0:\\n sumzero+=1\\n if stack < 0:\\n x1 = i\\n break\\n stack = 0\\n for i in range(n-1, -1, -1):\\n if s[(i+shift)%n] == 1:\\n stack+=1\\n else:\\n stack-=1\\n if stack < 0:\\n x2 = i\\n break\\n if x1 == -1 and", "gt": "x2 == -1 and stack == 0:\\n if sumzero > maxx:\\n maxx=sumzero\\n ind = (0,0)\\n if x1 == -1 or x2 == -1 or x1 == x2:\\n continue\\n stack = 0\\n corr = True\\n ans = 0\\n for i in range(n):\\n c = s[(i+shift)%n]\\n \\n if i == x1 or i == x2:\\n c = 1-c\\n if c == 0:\\n stack += 1\\n else:\\n stack -= 1\\n if stack == 0:\\n ans+=1\\n if stack == -1:\\n corr = False\\n break\\n \\n if not corr or stack > 0:\\n continue\\n if ans > maxx:\\n maxshift = shift\\n maxx = ans\\n ind = ((x1+shift)%n, (x2+shift)%n)\\nprint(maxx)\\nprint(ind[0]+1,ind[1]+1)\\n"}
{"id": "585", "input": "n = int(input())\\nlen_out, count_in = 0, 0\\nbalance, cur = 0, 0\\nfor c in input():\\n if not (('a' <= c <= 'z') or ('A' <= c <= 'Z')) and cur:\\n if balance:\\n count_in += 1\\n else:\\n len_out = max(len_out,", "gt": "cur)\\n cur = 0\\n if c == '(':\\n balance += 1\\n elif c == ')':\\n balance -= 1\\n elif ('a' <= c <= 'z') or ('A' <= c <= 'Z'):\\n cur += 1\\nif cur:\\n len_out = max(len_out, cur)\\nprint(len_out, count_in)\\n"}
{"id": "586", "input": "import sys\\ninput = sys.stdin.readline\\nn,m=map(int,input().split())\\na=list(map(int,input().split()))\\nb=list(map(int,input().split()))\\nmod=998244353\\nsol=1\\ni=n-1\\nj=m-1\\nwhile sol>0 and j>=0:\\n goal=b[j]\\n s=0\\n r=False\\n while i>=0 and a[i]>=goal:\\n if r:\\n", "gt": "s+=1\\n else:\\n if a[i]==goal:\\n r=True\\n s=1\\n i-=1\\n if j==0:\\n s=min(s,1)\\n if i>=0:\\n s=0\\n sol*=s\\n sol%=mod\\n j-=1\\nprint(sol)"}
{"id": "587", "input": "def norm(x):\\n return (x % 998244353 + 998244353) % 998244353\\n\\nn, k = map(int, input().split())\\n\\ndp1 = [0]\\ndp2 = [0]\\n\\nfor i in range(n):\\n l = [1]\\n cur = 0\\n for j in range(n + 1):\\n cur += l[j]\\n if(j > i):\\n cur -= l[j", "gt": "- i - 1]\\n cur = norm(cur)\\n l.append(cur)\\n dp1.append(l[n])\\n dp2.append(norm(dp1[i + 1] - dp1[i]))\\n\\nans = 0\\nfor i in range(n + 1):\\n for j in range(n + 1):\\n if(i * j < k):\\n ans = norm(ans + dp2[i] * dp2[j])\\n\\nans = norm(ans * 2)\\n\\nprint(ans)"}
{"id": "588", "input": "import sys\\ninput = sys.stdin.readline\\n\\nN, K = list(map(int, input().split()))\\nnums = []\\nfor i in range(N):\\n t, d = list(map(int, input().split()))\\n nums.append((d, t))\\nnums.sort(reverse=True)\\nse = set()\\na1 = []\\na2 = []\\nrest = []\\nfor i, n in enumerate(nums):\\n if i < K:\\n if not n[1] in se:\\n se.add(n[1])\\n a1.append(n)\\n else:\\n a2.append(n)\\n else:\\n rest.append(n)\\npoints = 0\\nfor (d,", "gt": "t) in a1: points += d\\nfor (d, t) in a2: points += d\\nans = points + pow(len(se), 2)\\na2.sort()\\nidx2 = 0\\nfor i, (d, t) in enumerate(rest):\\n if t in se: continue\\n if len(a2) <= idx2: break\\n points -= a2[idx2][0]\\n idx2 += 1\\n points += d\\n se.add(t)\\n ans = max(ans, points+pow(len(se), 2))\\nprint(ans)\\n"}
{"id": "589", "input": "import numpy as np\\n\\nn=int(input())\\nxy=[]\\nfor i in range(n):\\n xy.append(list(map(int,input().split())))\\n\\ndef naiseki(a,b):\\n if (a[0]*b[0]+a[1]*b[1])>0.0:\\n return True\\n else:\\n return False\\n", "gt": "\\nans=0\\n\\nfor i in range(1001):\\n xl=np.cos(np.pi*2.0*i/1000.0)\\n yl=np.sin(np.pi*2.0*i/1000.0)\\n x=0\\n y=0\\n for j in range(n):\\n if naiseki([xl,yl],xy[j]):\\n x+=xy[j][0]\\n y+=xy[j][1]\\n ans=max(ans,np.sqrt(x**2+y**2))\\nprint(ans)\\n"}
{"id": "590", "input": "res = 1\\nstarted = False\\nseen = set()\\ncodes = set(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'])\\nfor ch in input():\\n if ch == '?':\\n if started:\\n res *= 10\\n else:\\n", "gt": "res *= 9\\n elif (ch in codes) and (ch not in seen):\\n if not started:\\n res *= len(codes) - len(seen) - 1\\n else:\\n res *= len(codes) - len(seen)\\n seen.add(ch)\\n started = True\\nprint(res)\\n"}
{"id": "591", "input": "n = int(input())\\na = list(map(int, input().split()))\\n\\nnums = [False for i in range(200010)]\\nmust = [False for i in range(200010)]\\ncounter = dict()\\nnow_num = 0\\n\\n\\ndef inc():\\n nonlocal now_num\\n now_num += 1\\n while nums[now_num - 1]:\\n now_num += 1\\n\\n\\nfor el in a:\\n if nums[el - 1]:\\n counter[el] += 1\\n else:\\n counter[el] = 1\\n nums[el - 1] = True\\n\\ninc()\\n\\nans = []\\nc =", "gt": "0\\n\\nfor el in a:\\n if counter[el] > 1:\\n counter[el] -= 1\\n if now_num < el:\\n ans.append(now_num)\\n c += 1\\n inc()\\n else:\\n if must[el - 1] == False:\\n ans.append(el)\\n must[el - 1] = True\\n else:\\n ans.append(now_num)\\n c += 1\\n inc()\\n else:\\n if must[el - 1] == False:\\n ans.append(el)\\n else:\\n ans.append(now_num)\\n c += 1\\n inc()\\n\\nprint(c)\\nprint(' '.join(str(el) for el in ans))\\n"}
{"id": "592", "input": "def readln(): return tuple(map(int, input().split()))\\n\\nimport sys\\nsys.stdin = open('input.txt', 'r')\\nsys.stdout = open('output.txt', 'w')\\n\\nn, k", "gt": "= readln()\\nlst = [(v, i + 1) for i, v in enumerate(readln())]\\nlst.sort()\\nlst.reverse()\\nprint(lst[k - 1][0])\\nprint(*list(zip(*lst[:k]))[1])\\n"}
{"id": "593", "input": "# \\nimport collections, atexit, math, sys, bisect \\n\\nsys.setrecursionlimit(1000000)\\ndef getIntList():\\n return list(map(int, input().split())) \\n\\ntry :\\n #raise ModuleNotFoundError\\n import numpy\\n def dprint(*args, **kwargs):\\n #print(*args, **kwargs, file=sys.stderr)\\n # in python 3.4 **kwargs is invalid???\\n print(*args, file=sys.stderr)\\n dprint('debug mode')\\nexcept Exception:\\n def dprint(*args, **kwargs):\\n pass\\n\\n\\n\\ninId = 0\\noutId = 0\\nif inId>0:\\n dprint('use", "gt": "input', inId)\\n sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\\nif outId>0:\\n dprint('use output', outId)\\n sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\\n atexit.register(lambda :sys.stdout.close()) #idle 中不会执行 atexit\\n \\nN, = getIntList()\\n#print(N)\\nre = 0\\nfor i in range(2,N):\\n\\n t = N // i -1\\n re += t * i\\n\\nprint(re *4)\\n\\n\\n\\n\\n\\n\\n"}
{"id": "594", "input": "n, m = (int(x) for x in input().split())\\nwinners = [0] * n\\nfor i", "gt": "in range(m):\\n a = [int(x) for x in input().split()]\\n winners[a.index(max(a))] += 1\\nprint(winners.index(max(winners)) + 1)\\n"}
{"id": "595", "input": "n, m = map(int, input().split())\\nA = list(map(int, input().split()))\\nB = list(map(int,", "gt": "input().split()))\\n\\nans = max(max(A), min(A) * 2)\\nif min(B) <= ans:\\n print(-1)\\nelse:\\n print(ans)"}
{"id": "596", "input": "def iswis(a):\\n return a % 400 == 0 or (a%100!= 0 and a %4==0)\\n\\nn = int(input())\\nwis = iswis(n)\\nfr = 0;\\nn += 1\\nif (wis):\\n fr", "gt": "+= 1\\nfr += 1\\nwhile (iswis(n) != wis or fr != 0):\\n if (iswis(n)):\\n fr += 1\\n fr += 1\\n fr %= 7\\n n += 1\\nprint(n)"}
{"id": "597", "input": "import datetime\\nfrom pprint import pprint\\nyear, month, day = (int(i) for i in input().split(':'))\\nx = datetime.date(year,", "gt": "month, day)\\nyear, month, day = (int(i) for i in input().split(':'))\\ny = datetime.date(year, month, day)\\npprint(abs(int((x - y).days)))\\n"}
{"id": "598", "input": "from collections import deque\\nn,m = [int(x) for x in input().split()]\\nadj = [[] for x in range(n+1)]\\nfor _ in range(1,n):\\n a,b = [int(x) for x in input().split()]\\n adj[a].append(b)\\n adj[b].append(a)\\nchaos = [int(x) for x in input().split()]\\ns = chaos[0]\\nchaos = set(chaos)\\ncc = [0]*(n+1)\\nst = deque()\\nst.append((s,-1))\\nwhile len(st):\\n u,e = st.pop()\\n if u<0:\\n if e>=0:\\n cc[e] += cc[-u]\\n continue\\n if u in chaos:\\n cc[u] +=1\\n st.append((-u,e))\\n \\n for v in adj[u]:\\n if v!=e:\\n st.append((v,u))\\n", "gt": "\\n#dfs(s,-1)\\nadj = [list([v for v in u if cc[v]>0]) for u in adj]\\na = (s,0)\\nst = deque()\\nst.append((a[0],-1,0))\\nwhile len(st):\\n u,e,h = st.pop()\\n if h>a[1]:\\n a = (u,h)\\n elif h==a[1] and u<a[0]:\\n a = (u,h)\\n for v in adj[u]:\\n if v!=e:\\n st.append((v,u,h+1))\\nb = a\\na = (a[0],0)\\nst = deque()\\nst.append((a[0],-1,0))\\nwhile len(st):\\n u,e,h = st.pop()\\n if h>a[1]:\\n a = (u,h)\\n elif h==a[1] and u<a[0]:\\n a = (u,h)\\n for v in adj[u]:\\n if v!=e:\\n st.append((v,u,h+1))\\nprint(min(a[0],b[0]))\\nprint(2*(n-cc.count(0))-a[1])\\n"}
{"id": "599", "input": "import bisect\\nimport collections\\n\\n\\ndef solve(inp, *args):\\n n, x = list(map(int, inp.split(\" \", 1)))\\n travels_by_len = collections.defaultdict(list)\\n travels_by_len_processed = {}\\n for travel in args:\\n l, r, cost = list(map(int, travel.split(\" \", 2)))\\n travels_by_len[r - l + 1].append((l, r, cost))\\n for travel_len, travels in list(travels_by_len.items()):\\n travels.sort()\\n travels_processed = [(travels[-1][0], travels[-1][2])]\\n for i in range(len(travels) - 2, -1, -1):\\n prev_travel = travels_processed[-1]\\n l, r, c = travels[i]\\n travels_processed.append((l, min(c, prev_travel[1])))\\n travels_by_len_processed[travel_len] = travels_processed[::-1]\\n\\n best_price = float(\"inf\")\\n for first_travel_len,", "gt": "first_travels in list(travels_by_len.items()):\\n second_travel_len = x - first_travel_len\\n second_travels_processed = travels_by_len_processed.get(second_travel_len, [])\\n for first_travel in first_travels:\\n l1, r1, c1 = first_travel\\n # now we look for cheapest travels which have l2 > r1\\n idx = bisect.bisect_right(second_travels_processed, (r1, float(\"inf\")))\\n if 0 <= idx < len(second_travels_processed):\\n best_price = min(best_price, c1 + second_travels_processed[idx][1])\\n return -1 if best_price == float(\"inf\") else best_price\\n\\n\\ndef __starting_point():\\n inp = input()\\n n, x = list(map(int, inp.split(\" \", 1)))\\n print(solve(inp, *(input() for i in range(n))))\\n\\n__starting_point()"}
{"id": "600", "input": "import sys\\ns = input().strip()\\n\\ndef isPalin(n):\\n if n[::-1] == n:\\n return True\\n return False\\n\\nfor i in range(len(s)+1):\\n", "gt": "for j in \"abcdefghijklmnopqrstuvwxyz\":\\n if isPalin(s[:i] + j + s[i:]):\\n print(s[:i] + j + s[i:])\\n return\\n\\nprint(\"NA\")\\n"}
{"id": "601", "input": "a=int(input())\\nb=int(input())\\nc=(a+b)//2\\ndef f(x):\\n", "gt": "x=abs(x)\\n return x*(x+1)//2\\nprint(f(c-a)+f(b-c))\\n"}
{"id": "602", "input": "t = int(input())\\n\\nfor _ in range(t):\\n p, f = [int(x) for x in input().split()]\\n cs, cw = [int(x) for x in input().split()]\\n s, w = [int(x) for x in input().split()]\\n if s > w:\\n s, w = w, s\\n cs, cw = cw, cs\\n\\n best =", "gt": "0\\n for i in range(cs + 1):\\n if s*i <= p:\\n war_me = min((p - s*i)//w, cw)\\n tb = i + war_me\\n sword_him = min(cs - i, f//s)\\n tb += sword_him\\n war_him = min((f - s*sword_him)//w, cw - war_me)\\n tb += war_him\\n best = max(best, tb)\\n print(best)\\n\\n"}
{"id": "603", "input": "3\\n\\na = int(input())\\nlst =", "gt": "'Washington,Adams,Jefferson,Madison,Monroe,Adams,Jackson,Van Buren,Harrison,Tyler,Polk,Taylor,Fillmore,Pierce,Buchanan,Lincoln,Johnson,Grant,Hayes,Garfield,Arthur,Cleveland,Harrison,Cleveland,McKinley,Roosevelt,Taft,Wilson,Harding,Coolidge,Hoover,Roosevelt,Truman,Eisenhower,Kennedy,Johnson,Nixon,Ford,Carter,Reagan'.split(',')\\nprint(lst[a - 1])\\n"}
{"id": "604", "input": "s=input().split()\\nfor i in range(3):\\n s[i]=int(s[i])\\ns.sort()\\n\\n\\nans=s[0]//3 +s[1]//3 +s[2]//3\\n\\nx=s[0]%3\\ny=s[1]%3\\nz=s[2]%3\\nif(x==0 and y==z==2 and s[0]!=0):\\n", "gt": "ans+=1\\nif(y==0 and x==z==2 and s[1]!=0):\\n ans+=1\\nif(z==0 and y==x==2 and s[2]!=0):\\n ans+=1\\n\\nans+=min(x,y,z)\\nprint(ans)\\n\\n"}
{"id": "605", "input": "n = int(input())\\na = set(map(int,", "gt": "input().split()))\\nif 0 in a: a.remove(0)\\nprint(len(a))"}
{"id": "606", "input": "a,b,c,d=list(map(int,input().split()))\\nmisha=max(3*a/10,a-a/250*c)\\nvasya=max(3*b/10,b-b/250*d)\\n\\nif misha > vasya:\\n print(\"Misha\")\\nelif", "gt": "vasya > misha:\\n print(\"Vasya\")\\nelse:\\n print(\"Tie\")\\n"}
{"id": "607", "input": "import sys\\n\\nR,x,y,s,t = list(map(int,input().split()))\\n\\nif (s-x)**2 + (t-y)**2 > R*R:\\n print(x,y,R)\\n return\\n\\ndx = x - s\\ndy = y - t\\nr = (dx**2 + dy**2)**.5\\n\\nif abs(r)<1e-9:\\n", "gt": "dx = 1\\n dy = 0\\nelse:\\n dx /= r\\n dy /= r\\n\\na = s + dx*(R + r)/2\\nb = t + dy*(R + r)/2\\n\\nprint(a,b,(R+r)/2)\\n\\n"}
{"id": "608", "input": "n, m = list(map(int, input().split()))\\n\\nfact = [1]\\n\\nfor i in range(1, n + 1):\\n fact.append((fact[-1] * i) % m)\\n \\nout = 0\\n\\nfor size", "gt": "in range(1, n + 1):\\n out += fact[size] * (n - size + 1) ** 2 * fact[n - size]\\n out %= m\\n\\nprint(out)\\n"}
{"id": "609", "input": "n = int(input())\\na = list(map(int, input().split()))\\ncnt, good = 0, 0\\nfor i in range(0, n):\\n if a[i] == 4 or a[i] ==", "gt": "5:\\n good = good + 1\\n else:\\n good = 0\\n if good == 3:\\n cnt = cnt + 1\\n good = 0\\nprint(cnt)"}
{"id": "610", "input": "n=int(input())\\n\\nL=[]\\nfor i in range(n):\\n L.append(input())\\nvalid=True\\nx=0\\ny=0\\nE=[]\\np=L[0][0]\\nwhile(x<n and y<n):\\n if(L[x][y]!=p):\\n valid=False\\n x+=1\\n y+=1\\n \\nx=0\\ny=n-1\\n\\nwhile(x<n and y>=0):\\n if(L[x][y]!=p):\\n valid=False\\n x+=1\\n y-=1\\nK={}\\nfor i", "gt": "in range(n):\\n for j in range(n):\\n if(L[i][j] in K):\\n K[L[i][j]]+=1\\n else:\\n K[L[i][j]]=1\\n\\n\\nif(not valid or K[p]!=2*n-1 or len(K)!=2):\\n print(\"NO\")\\n\\nelse:\\n print(\"YES\")\\n"}
{"id": "611", "input": "import re\\nimport itertools\\nfrom collections import Counter\\n\\nclass Task:\\n n, m = 0, 0\\n petyaScore = 0\\n vasyaScore = 0\\n \\n def getData(self):\\n self.n, self.m = [int(x) for x in input().split(\" \")]\\n \\n def solve(self):\\n n= self.n\\n m = self.m\\n\\n if n != m:\\n self.vasyaScore = min(n, m)\\n else:\\n self.vasyaScore = min(n, m)\\n self.petyaScore = self.n + self.m - 1 - self.vasyaScore \\n\\n def printAnswer(self):\\n print(self.petyaScore, self.vasyaScore)\\n\\ntask = Task();\\ntask.g", "gt": "etData();"}
{"id": "612", "input": "n, m = list(map(int, input().split()))\\nres = 0\\nmx = (n-1)*n//2\\nmn = 0\\nif n&1:\\n mn = (n//2)*(n//2+1)\\nelse:\\n mn = n*n//4\\nfor i in", "gt": "range(m):\\n x, d = list(map(int, input().split()))\\n res += x*n\\n if d > 0:\\n res += mx*d\\n else:\\n res += mn*d\\nprint('%.10f'%(res/n))\\n"}
{"id": "613", "input": "n, k, p = [int(c) for c in input().split()]\\na = [int(c) for c in input().split()]\\n\\nnech= []\\nch = []\\n\\nfor i in range(len(a)):\\n if a[i] % 2 == 0:\\n ch.append(a[i])\\n else:\\n nech.append(a[i])\\n\\nneeded_nech = k - p\\n\\nfree_nech = len(nech) - needed_nech\\nav_ch = len(ch) + (free_nech // 2)\\n\\nsets = []\\n\\n\\nif free_nech <", "gt": "0 or free_nech % 2 != 0 or av_ch < p:\\n print('NO')\\nelse:\\n print('YES')\\n while needed_nech > 0:\\n sets.append([nech.pop()])\\n needed_nech -= 1\\n\\n while p > 0:\\n if len(ch) > 0:\\n sets.append([ch.pop()])\\n else:\\n sets.append([nech.pop(), nech.pop()])\\n p -= 1\\n\\n sets[0] = sets[0] + nech + ch\\n\\nfor i in range(len(sets)):\\n print(len(sets[i]),' '.join(map(str,sets[i])))"}
{"id": "614", "input": "t,a,b=map(int,input().split())\\nif t==2 and a==3 and b>10000: res=0\\nelif a==t: res=('inf' if a==1 else 2) if", "gt": "a==b else 0\\nelse: res=0 if (a-b)%(t-a) else (1 if t != b else 0)\\nprint(res)"}
{"id": "615", "input": "def main():\\n n, m = list(map(int, input().split()))\\n\\n cost1 = []\\n cost2 = []\\n cost3 = []\\n\\n for i in range(n):\\n w, c = list(map(int, input().split()))\\n if w == 1:\\n cost1.append(c)\\n elif w == 2:\\n cost2.append(c)\\n else:\\n cost3.append(c)\\n\\n cost1 = sorted(cost1)[::-1]\\n cost2 = sorted(cost2)[::-1]\\n cost3 = sorted(cost3)[::-1]\\n cost3_prefix = [0]\\n for c in cost3:\\n cost3_prefix.append(cost3_prefix[-1] + c)\\n\\n\\n dp = [(0, 0, 0)] * (m + 1)\\n dp[0] = (0, 0, 0)\\n\\n for i in range(0, m):\\n cost, n1, n2 = dp[i]\\n\\n if i + 1 <= m and n1 < len(cost1):\\n new_cost = cost + cost1[n1]\\n if", "gt": "dp[i + 1][0] < new_cost:\\n dp[i + 1] = (new_cost, n1 + 1, n2)\\n \\n if i + 2 <= m and n2 < len(cost2):\\n new_cost = cost + cost2[n2]\\n if dp[i + 2][0] < new_cost:\\n dp[i + 2] = (new_cost, n1, n2 + 1)\\n\\n if n1 == len(cost1) and n2 == len(cost2):\\n break\\n\\n\\n dp_prefix = [0]\\n for x in dp[1:]:\\n dp_prefix.append(max(dp_prefix[-1], x[0]))\\n\\n ans = 0\\n for k in range(len(cost3) + 1):\\n l = m - 3 * k\\n if l < 0:\\n continue\\n\\n new_ans = cost3_prefix[k] + dp_prefix[l]\\n ans = max(new_ans, ans)\\n\\n print(ans)\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "616", "input": "n=int(input())\\na=list(map(int,input().split()))\\ntmp=0\\nca=[0]\\nfor ai in a:\\n tmp+=ai\\n ca.append(tmp)\\nfrom bisect import bisect_right,bisect_left\\nans=float('inf')\\n\\n# 数列をまず半分に区切る。左i個と右n-i個 2<=i,n-i\\nf,g=1,3\\nfor", "gt": "i in range(2,n-1):\\n while abs(ca[i]-ca[f]-ca[f])>abs(ca[i]-ca[f+1]-ca[f+1]):\\n f+=1\\n while abs((ca[-1]-ca[g])-(ca[g]-ca[i]))>abs((ca[-1]-ca[g+1])-(ca[g+1]-ca[i])):\\n g+=1\\n l=(ca[f],ca[i]-ca[f],ca[-1]-ca[g],ca[g]-ca[i])\\n ans=min(ans,max(l)-min(l))\\n #print(l)\\nprint(ans)\\n"}
{"id": "617", "input": "n, m = map(int, input().split())\\nvalists = [10**9 for _ in range(1<<n)]\\nvalists[0] = 0\\nfor i in range(m):\\n values, b = map(int, input().split())\\n c = list(map(int, input().split()))\\n cnt = 0\\n", "gt": "for j in range(b):\\n cnt += 2**(c[j]-1)\\n for j in range(len(valists)):\\n x = j|cnt\\n valists[x] = min(valists[x], valists[j]+values)\\n #print(j, cnt, x, valists)\\n\\n#print(valists)\\nans = valists[2**n-1]\\nif ans != 10**9:\\n print(ans)\\nelse:\\n print(-1)"}
{"id": "618", "input": "s = input()\\nres = eval(s)\\nn = len(s)\\nfor i in range(-1, n):\\n if i == -1 or s[i] == '*':\\n for j in range(i + 1, n +", "gt": "1):\\n if j == n or s[j] == '*':\\n new_s = s[0:i + 1] + \"(\" + s[i + 1:j] + \")\" + s[j:n]\\n res = max(res, eval(new_s))\\nprint(res)\\n"}
{"id": "619", "input": "x = input()\\nz = input()\\na, b = -1, -1\\np, q ='', ''\\np = x[:x.find('|')]\\nq = x[x.find('|') + 1:]\\nn = 0\\nwhile n < len(z):\\n", "gt": "if len(p) < len(q):\\n p += z[n]\\n else:\\n q += z[n]\\n n += 1\\nif len(p) == len(q):\\n print(p, '|', q, sep = '')\\nelse:\\n print('Impossible')\\n"}
{"id": "620", "input": "x, y, z = list(map(int, input().split()))\\nc = x // z + y // z\\n\\nrx = x % z\\nry = y % z\\nif rx", "gt": "+ ry < z:\\n print(f'"}
{"id": "621", "input": "x1, y1 = list(map(int, input().split()))\\nx2, y2 = list(map(int, input().split()))\\nx3, y3 = list(map(int, input().split()))\\na = set()\\na.add(((x1 + x2) - x3, y1 + y2 -", "gt": "y3))\\na.add(((x1 + x3) - x2, y1 + y3 - y2))\\na.add(((x2 + x3) - x1, y2 + y3 - y1))\\nprint(len(a))\\nfor i in a:\\n print(*i)"}
{"id": "622", "input": "import re\\nimport itertools\\nfrom collections import Counter\\n\\nclass Task:\\n a = []\\n answer = []\\n \\n def getData(self):\\n input()\\n self.a = [int(x) for x in input().split(\" \")]\\n \\n def solve(self):\\n currentFolderCounter = 0\\n badDaysCounter = 0\\n for x in self.a:\\n if x>= 0:\\n currentFolderCounter += 1\\n elif badDaysCounter <= 1:\\n currentFolderCounter += 1\\n badDaysCounter += 1\\n else:\\n self.answer += [currentFolderCounter]\\n currentFolderCounter = 1\\n badDaysCounter = 1\\n if currentFolderCounter > 0:\\n self.answer += [currentFolderCounter]\\n\\n def printAnswer(self):\\n print(len(self.answer))\\n print(re.sub('[\\[\\],]', '', str(self.answer)))\\n\\ntask = Task();\\ntask.g", "gt": "etData();"}
{"id": "623", "input": "n, k = map(int, input().split())\\n\\nres = 1\\nwhile (k %", "gt": "2 == 0):\\n res += 1\\n k //= 2\\nprint(res)"}
{"id": "624", "input": "a,b=map(int,input().split())\\nans=0\\nwhile a>0 and b>0:\\n if max(a,b)>1:", "gt": "ans+=1\\n if a<b: a+=3\\n else: b+=3\\n a-=2;b-=2\\nprint(ans)"}
{"id": "625", "input": "n,k,m = list(map(int,input().split()))\\nai = list(map(int,input().split()))\\nai.sort()\\nn2 = n\\nnum = sum(ai)\\nans = 0.0\\ni = 0\\nwhile n2 > 0 and m > -1:\\n num2 =", "gt": "(num + min(m,n2 * k)) / n2\\n ans = max(ans,num2)\\n num -= ai[i]\\n i += 1\\n n2 -= 1\\n m -= 1\\nprint(ans)\\n"}
{"id": "626", "input": "n=int(input())\\n\\nx=n//2\\nif(n%2==0):\\n", "gt": "print(x)\\nelse:\\n print(x-n)\\n"}
{"id": "627", "input": "n = int(input())\\na = list(map(int, input().split()))\\ninfo = 0\\ni = 0\\ndir = 1\\nresult = 0\\nwhile True:\\n if info >= a[i]:\\n info += 1\\n a[i] = n +", "gt": "1\\n if info == n:\\n break\\n i += dir\\n if i < 0 or i == n:\\n dir = -dir\\n i += dir\\n result += 1\\nprint(result)\\n"}
{"id": "628", "input": "n = int(input())\\ns = input()\\nfor i in range(len(s) - 1):\\n if s[i]", "gt": "> s[i + 1]:\\n print(s[:i] + s[i + 1:len(s)])\\n return\\nprint(s[:len(s) - 1])\\n"}
{"id": "629", "input": "#!/usr/bin/env python3\\n\\n[n, k] = list(map(int, input().strip().split()))\\nais = list(map(int, input().strip().split()))\\niais = [0 for _ in range(n + 1)]\\nfor i in range(n):\\n iais[i + 1] = iais[i] + ais[i]\\n\\ndef calc(k, split):\\n res = 0\\n for i in range(k):\\n res &= iais[split[i + 1]] - iais[split[i]]\\n return res\\n\\ndef check_mask(mask):\\n dp = [[False for j in range(n + 1)] for i in range(k + 1)]\\n\\n for j in range(1, n - k + 1 + 1):\\n dp[1][j] = (iais[j] &", "gt": "mask == mask)\\n if not any(dp[1]):\\n return False\\n\\n for i in range(2, k + 1):\\n for j in range(i, n - (k - i) + 1):\\n dp[i][j] = any(dp[i - 1][r] and ((iais[j] - iais[r]) & mask == mask) for r in range(i - 1, j - 1 + 1))\\n if not any(dp[i]):\\n return False\\n\\n return dp[k][n]\\n\\n\\nmask = 0\\nfor i in range(55, -1, -1):\\n if check_mask(mask | (1 << i)):\\n mask |= 1 << i\\n\\nprint (mask)\\n\\n"}
{"id": "630", "input": "n = int(input())\\na = [[], []]\\na[0] = list(map(int, input().split()))\\na[1] = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\nans = float('+inf')\\nfor i in range(n):\\n for j in", "gt": "range(n):\\n if i == j:\\n continue\\n cur = sum(a[1][i:]) + sum(a[0][:i]) + sum(a[0][:j]) + sum(a[1][j:]) + b[i] + b[j]\\n ans = min(ans, cur)\\nprint(ans)\\n"}
{"id": "631", "input": "# python3\\n\\ndef readline(): return tuple(map(int, input().split()))\\n\\n\\ndef main():\\n n, k = readline()\\n a = readline()\\n\\n answer = list()\\n\\n for (i, link) in enumerate(a):\\n bottom = max(0, i - k)\\n top =", "gt": "min(n, i + k + 1)\\n\\n if link == 0:\\n answer.append(top - bottom)\\n else:\\n bottom = max(bottom, link + k)\\n answer.append(max(0, top - bottom) + answer[link - 1])\\n\\n print(\" \".join(map(str, answer)))\\n\\n\\nmain()\\n"}
{"id": "632", "input": "import sys\\ninput=sys.stdin.readline\\n\\nT=int(input())\\nfor _ in range(T):\\n n,m=list(map(int,input().split()))\\n", "gt": "A=list(map(int,input().split()))\\n s=sum(A)\\n if (s==m):\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n"}
{"id": "633", "input": "import sys\\ninput = sys.stdin.readline\\n\\ndef mult_input():\\n return map(int,input().split())\\n\\ndef list_input():\\n return list(map(int,input().split()))\\n\\nfor nt in", "gt": "range(int(input())):\\n n,k=map(int,input().split())\\n for i in range(2,n+1):\\n if n%i==0:\\n num=i\\n break\\n print (n+i+2*(k-1))"}
{"id": "634", "input": "from math import *\\nn, m = list(map(int, input().split()))\\nif m < n - 1:\\n print('Impossible')\\n return\\nr = [(i + 1, i + 2) for i in range(n - 1)]\\nk = n - 1\\nif k >= m:\\n print('Possible')\\n for x in", "gt": "r:\\n print(*x)\\n return\\nfor i in range(1, n + 1):\\n for j in range(i + 2, n + 1):\\n if gcd(i, j) == 1:\\n r.append((i, j))\\n k += 1\\n if k >= m:\\n print('Possible')\\n for x in r:\\n print(*x)\\n return\\nprint('Impossible')\\n"}
{"id": "635", "input": "r,n = [int(x) for x in input().split()]\\ncells = [[int(x) for x in input().split()] for i in range(n)]\\ncells.sort()\\n#print(cells)\\nout = False\\n\\nres = {True:\"WIN\",False:\"LOSE\"}\\n\\nif len(cells) == 0: print(res[r%2 == 1])\\nelse:\\n out = False\\n #print(cells[0][0] > 1)\\n #print(cells[-1][0] < r)\\n for i in range(1,n):\\n out ^= ((cells[i][0]-cells[i-1][0]-1)%2) ^ (cells[i][1] != cells[i-1][1])\\n dif = abs((cells[0][0]-1)-(r-cells[-1][0]))\\n #print(out,dif)\\n hi,lo =", "gt": "max(cells[0][0]-1,r-cells[-1][0]),min(cells[0][0]-1,r-cells[-1][0])\\n #print(out,dif,lo,hi)\\n if lo > 1:\\n if dif == 0:\\n print(res[out])\\n elif dif == 1 and lo % 2 == 0:\\n print(res[not out])\\n else:\\n print(res[True])\\n elif lo == 0:\\n if hi == 0: print(res[out])\\n elif hi == 1:\\n print(res[not out])\\n else:\\n print(res[True])\\n elif lo == 1:\\n if hi == 1:\\n print(res[out])\\n else:\\n print(res[True])\\n"}
{"id": "636", "input": "# map(int, input().split())\\n# list(map(int, input().split()))\\nn, m = list(map(int, input().split()))\\nm -= 1\\na = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\nif a[0] == 0:\\n print(\"NO\")\\n return\\nelif", "gt": "a[m] == 1:\\n print(\"YES\")\\n return\\nelif b[m] == 0:\\n print(\"NO\")\\n return\\nelse:\\n for i in range(m, n):\\n if a[i] and b[i]:\\n print(\"YES\")\\n return\\n print(\"NO\")\\n"}
{"id": "637", "input": "n, k = map(int, input().split())\\narr = [int(i) for i in input().split()]\\narr2 = []\\nfor i in range(n):\\n arr2.append((arr[i], i))\\narr2.sort()\\nans = []\\nfor", "gt": "i in arr2:\\n if k >= i[0]:\\n k -= i[0]\\n ans.append(i[1])\\nprint(len(ans))\\nfor i in ans:\\n print(i + 1, end = ' ')"}
{"id": "638", "input": "n = int(input())\\nx = list(map(int, input().split()))\\nd = None\\ns = 1\\nc = x[0]\\nfor i in range(1, n):\\n if x[i] == c:\\n s += 1\\n else:\\n if d is", "gt": "None:\\n d = s\\n else:\\n if (s != d):\\n print(\"NO\")\\n break\\n s = 1\\n c = x[i]\\nelse:\\n if (d is None) or (s == d):\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n"}
{"id": "639", "input": "from sys import stdin\\nn,m=list(map(int,stdin.readline().strip().split()))\\ns=list(map(int,stdin.readline().strip().split()))\\nans=[0 for i in range(n)]\\nsm=[0 for i in range(n)]\\nsm1=[0 for i in range(n)]\\nfor i in range(n):\\n if i==0:\\n sm[i]=s[i]\\n else:\\n sm[i]=sm[i-1]+s[i]\\nfor", "gt": "i in range(n-1,-1,-1):\\n if i==n-1:\\n sm1[i]=s[i]\\n else:\\n sm1[i]=sm1[i+1]+s[i]\\nfor i in range(n):\\n if sm[i]<=m:\\n continue\\n x=sm[i]\\n s2=s[0:i]\\n s2.sort()\\n r=0\\n while x>m:\\n x-=s2[-1]\\n s2.pop()\\n r+=1\\n ans[i]=r\\nprint(*ans)\\n \\n"}
{"id": "640", "input": "R=lambda:list(map(int,input().split()))\\nn,x=R()\\na=R()\\nprint(x-len([i for i in a if", "gt": "i<x])+(1 if x in a else 0))\\n"}
{"id": "641", "input": "a, b = list(map(int, input().split()))\\nres = [0,0,0]\\nfor i in range(1, 7):\\n if abs(a - i) < abs(b - i):\\n", "gt": "res[0] += 1\\n elif abs(a - i) == abs(b - i):\\n res[1] += 1\\n else:\\n res[2] += 1\\nprint(' '.join(map(str, res)))\\n"}
{"id": "642", "input": "x = input().split(' ')\\nif x[-1] == \"month\":\\n if x[0] == '31':\\n print(7)\\n elif", "gt": "x[0] == '30':\\n print(11)\\n else:\\n print(12)\\nelse:\\n if x[0] in ['5', '6']:\\n print(53)\\n else:\\n print(52)"}
{"id": "643", "input": "n,m=list(map(int,input().split()))\\nif(m!=0):\\n L=list(map(int,input().split()))\\nelse:\\n L=[]\\n\\nL.sort()\\nvalid=True\\nfor i in range(2,m):\\n if(L[i]-L[i-2]==2):\\n", "gt": "valid=False\\nif(m==0 or(valid and L[0]!=1 and L[-1]!=n)):\\n print(\"YES\")\\nelse:\\n print(\"NO\")\\n"}
{"id": "644", "input": "def solve(x, y, p, q):\\n if p == 0: return 0 if x == 0 else -1\\n pp = (x - 1) // p + 1 if p != 0 else 0\\n L = max((y - 1) // q + 1, pp) - 1\\n L = max(L, -1)\\n z = y - x\\n INF = L + 10 ** 10\\n R = INF\\n while R - L > 1:\\n M = (L", "gt": "+ R) >> 1\\n cur = q * M\\n curp = p * M\\n curz = cur - curp\\n dl = cur - y\\n if curp >= x and curz >= z:\\n R = M\\n else:\\n L = M\\n #print(L, R)\\n if R == INF:\\n return -1\\n return R * q - y\\n\\nread = lambda: map(int, input().split())\\nt = int(input())\\nfor i in range(t):\\n x, y, p, q = read()\\n print(solve(x, y, p, q))"}
{"id": "645", "input": "l = int(input())\\na = [0] * (l+1)\\nb = [1] * (l+1)\\nst = 0\\nen = 1\\ncur = 0\\nfor i in range(l):\\n x = input()\\n if x == 'add':\\n a[en-1] += 1\\n elif x[0] == 'f':\\n d = x.split()\\n v =", "gt": "int(d[1])\\n a[en] = 0\\n b[en] = v\\n en += 1\\n else:\\n en -= 1\\n a[en-1] += a[en] * b[en]\\n if a[en-1] >= 2 ** 32:\\n cur = 1\\n break\\nif cur == 1 or a[0] >= 2 ** 32:\\n print('OVERFLOW!!!')\\nelse:\\n print(a[0])\\n\\n"}
{"id": "646", "input": "x = input()\\nc = 0\\nfor i", "gt": "in x:\\n if i in \"aeiou13579\":\\n c+=1\\nprint(c)\\n"}
{"id": "647", "input": "# import numpy as npy\\nimport functools\\nimport math\\n\\nn=int(input())\\nx=[0 for i in range(n+2)]\\ny=[0 for i in range(n+2)]\\nadj=[[] for i in range(n+2)]\\nidx=[]\\nidy=[]\\nfor i in range(n):\\n x[i],y[i]=map(int,input().split())\\n idx.append(i)\\n idy.append(i)\\n\\ndef cmpx(a,b):\\n if x[a]!=x[b]:\\n if x[a]<x[b]:\\n return -1\\n else:\\n return 1\\n if y[a]!=y[b]:\\n if y[a]<y[b]:\\n return -1\\n else:\\n return 1\\n return 0\\n \\ndef cmpy(a,b):\\n if y[a]!=y[b]:\\n if y[a]<y[b]:\\n return -1\\n else:\\n return 1\\n if x[a]!=x[b]:\\n if x[a]<x[b]:\\n return -1\\n else:\\n return 1\\n return 0\\n\\nidx=sorted(idx,key=functools.cmp_to_key(cmpx))\\nidy=sorted(idy,key=functools.cmp_to_key(cmpy))\\n\\n# print(idx)\\n# print(idy)\\n\\ndef disx(a,b):\\n if x[a]!=x[b]:\\n return 1e18\\n return y[b]-y[a]\\n \\ndef disy(a,b):\\n if y[a]!=y[b]:\\n return 1e18\\n return x[b]-x[a]\\n\\nl=0\\nr=2000000000\\nans=-1\\n\\nwhile l<=r:\\n # print(l,r)\\n mid=(l+r)//2\\n for i in range(n):\\n adj[i]=[]\\n for i in range(n-1):\\n if disx(idx[i],idx[i+1])<=mid:\\n adj[idx[i]].append(idx[i+1])\\n adj[idx[i+1]].append(idx[i])\\n # print(idx[i],idx[i+1])\\n if disy(idy[i],idy[i+1])<=mid:\\n adj[idy[i]].append(idy[i+1])\\n adj[idy[i+1]].append(idy[i])\\n # print(idy[i],idy[i+1])\\n col=[0 for i in range(n)]\\n cur=0\\n def dfs(x):\\n col[x]=cur\\n for i in range(len(adj[x])):\\n if col[adj[x][i]]==0:\\n dfs(adj[x][i])\\n for i in range(n):\\n if col[i]==0:\\n cur=cur+1\\n dfs(i)\\n ok=0\\n if cur>4:\\n", "gt": "ok=0\\n if cur==1:\\n ok=1\\n if cur==2:\\n for i in range(n):\\n for j in range(i+1,n):\\n if (col[i]!=col[j]):\\n d1=abs(x[i]-x[j])\\n d2=abs(y[i]-y[j])\\n if d1==0 or d2==0:\\n if d1+d2<=2*mid:\\n ok=1\\n if d1<=mid and d2<=mid:\\n ok=1\\n if cur==3:\\n for i in range(n-1):\\n px=idx[i]\\n py=idx[i+1]\\n if x[px]==x[py] and col[px]!=col[py]:\\n for j in range(n):\\n if col[px]!=col[j] and col[py]!=col[j]:\\n d1=abs(y[px]-y[j])\\n d2=abs(y[py]-y[j])\\n d3=abs(x[px]-x[j])\\n if d1<=mid and d2<=mid and d3<=mid:\\n ok=1\\n for i in range(n-1):\\n px=idy[i]\\n py=idy[i+1]\\n if y[px]==y[py] and col[px]!=col[py]:\\n for j in range(n):\\n if col[px]!=col[j] and col[py]!=col[j]:\\n d1=abs(x[px]-x[j])\\n d2=abs(x[py]-x[j])\\n d3=abs(y[px]-y[j])\\n if d1<=mid and d2<=mid and d3<=mid:\\n ok=1\\n if cur==4:\\n for i in range(n-1):\\n px=idx[i]\\n py=idx[i+1]\\n if x[px]==x[py] and col[px]!=col[py]:\\n for j in range(n-1):\\n pz=idy[j]\\n pw=idy[j+1]\\n if y[pz]==y[pw] and col[pz]!=col[pw]:\\n if col[pz]!=col[px] and col[pz]!=col[py]:\\n if col[pw]!=col[px] and col[pw]!=col[py]:\\n d1=abs(y[px]-y[pz])\\n d2=abs(y[py]-y[pz])\\n d3=abs(x[pz]-x[px])\\n d4=abs(x[pw]-x[px])\\n if d1<=mid and d2<=mid and d3<=mid and d4<=mid:\\n ok=1\\n if ok:\\n ans=mid\\n r=mid-1\\n else:\\n l=mid+1\\nprint(ans)"}
{"id": "648", "input": "# python 3\\n\"\"\"\\n\"\"\"\\n\\n\\ndef lefthanders_and_righthanders(n_int, student_list) -> list:\\n sitting_order = []\\n for i in range(n_int//2):\\n if student_list[i] == 'R' and student_list[i + n_int//2] == 'L':\\n sitting_order.append((i + n_int//2 + 1, i + 1))\\n print(i + n_int//2 + 1, i + 1)\\n else:\\n sitting_order.append((i + 1, i + n_int//2 + 1))\\n print(i + 1, i +", "gt": "n_int//2 + 1)\\n return sitting_order\\n\\n\\ndef __starting_point():\\n \"\"\"\\n Inside of this is the test. \\n Outside is the API\\n \"\"\"\\n with open(\"input.txt\", 'r') as f_input:\\n n = int(f_input.readline())\\n students = f_input.readline()\\n # print(n, students)\\n\\n sitting = lefthanders_and_righthanders(n, students)\\n with open(\"output.txt\", 'w') as f_output:\\n for each in sitting:\\n f_output.write(str(each[0]) + ' ' + str(each[1]) + '\\n')\\n\\n__starting_point()"}
{"id": "649", "input": "read = lambda: map(int, input().split())\\nm, b = read()\\nans = -1\\ndef f(x, y):\\n return (x * (x + 1) * (y + 1) + y * (y +", "gt": "1) * (x + 1)) // 2\\nfor k in range(b + 3):\\n x = k * m\\n y = b - k\\n ans = max(ans, f(x, y))\\nprint(ans)"}
{"id": "650", "input": "from sys import *\\n\\nT = int(stdin.readline())\\nt = [int(s) for s in stdin.readline().split(' ')]\\n\\na = []\\nfor i in range(T - 1, -1, -1):\\n\\n if i % 2 == 0:\\n a += [(e[0], -e[1]) for e in a]\\n a = [(e[0] - t[i], e[1]) for e in a]\\n a += [(- x -", "gt": "1, 0) for x in range(t[i])]\\n a = list(set(a))\\n\\n if i % 2 == 1:\\n a += [(e[1], -e[0]) for e in a]\\n a = [(e[0] - t[i], e[1] + t[i]) for e in a]\\n a += [(- x - 1, x + 1) for x in range(t[i])]\\n a = list(set(a))\\n\\nprint(len(a))\\n"}
{"id": "651", "input": "p = \"AEFHIKLMNTVWXYZ\"\\nq = \"BCDGJOPQRSU\"\\n\\nword = input()\\nx, y = 0, 0\\nfor w in word:\\n if w in", "gt": "p:\\n x += 1\\n else:\\n y += 1\\n\\nif x == 0 or y == 0:\\n print(\"YES\")\\nelse:\\n print(\"NO\")\\n"}
{"id": "652", "input": "import itertools\\n\\ndef valid(grid, path, perm, start, goal):\\n x, y = start\\n n = len(grid)\\n m = len(grid[0])\\n for move in path:\\n dx, dy = perm[int(move)]\\n x += dx\\n y += dy\\n if (x, y) == goal:\\n return True\\n if not (0 <= x < n and 0 <= y < m) or grid[x][y] == '#':\\n return False\\n\\n return False\\n\\ndef main():\\n n, m = list(map(int, input().split()))\\n grid = [list(input())", "gt": "for _ in range(n)]\\n for i in range(n):\\n for j in range(m):\\n if grid[i][j] == 'S':\\n sx, sy = i, j\\n grid[i][j] = '.'\\n elif grid[i][j] == 'E':\\n gx, gy = i, j\\n grid[i][j] = '.'\\n\\n\\n path = input()\\n moves = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n ans = 0\\n for perm in itertools.permutations(moves):\\n if valid(grid, path, perm, (sx, sy), (gx, gy)):\\n ans += 1\\n\\n print(ans)\\n\\nmain()\\n"}
{"id": "653", "input": "n = int(input())\\npoints = [0] * n\\nD = {}\\nfor i in range(n):\\n points[i] = tuple(int(x) for x in input().split())\\n\\nfor i in range(n):\\n for j in range(i+1, n):\\n x1, y1 = points[i]\\n x2, y2 = points[j]\\n u, v = x2 - x1, y2 - y1\\n if", "gt": "u < 0 or u == 0 and v < 0:\\n u, v = -u, -v\\n if (u, v) in D:\\n D[(u, v)] += 1\\n else:\\n D[(u, v)] = 1\\n\\nS = sum(D[i] * (D[i] - 1) // 2 for i in D)\\nprint(S // 2)\\n \\n"}
{"id": "654", "input": "n = int(input())\\ns = input()\\n\\nnum = '0123456789'\\nstate = [0]*(10)\\nfor i in s:\\n if i in num:\\n state[int(i)] = 0\\n else:\\n if i=='L':\\n for j in range(10):\\n", "gt": "if state[j]==0:\\n state[j] = 1\\n break\\n else:\\n for j in range(9, -1, -1):\\n if state[j] == 0:\\n state[j] = 1\\n break\\n\\nfor i in state:\\n print(i, end='')\\n \\n"}
{"id": "655", "input": "import sys\\ninput = sys.stdin.readline\\nsys.setrecursionlimit(10**7)\\n\\nn=int(input())\\nmod=10**9+7\\n\\nANS=[[0]*(n+1) for i in range(n+1)]\\n\\ndef bra(x,y):\\n if ANS[x][y]!=0:\\n return ANS[x][y]\\n \\n if x==y==0:\\n ANS[x][y]=0\\n return 0\\n\\n if (x+y)%2==1:\\n A=1\\n else:\\n A=0\\n\\n if x==y:\\n", "gt": "ANS[x][y]=A+bra(x-1,y)\\n return ANS[x][y]\\n\\n elif x==0:\\n ANS[x][y]=A+bra(x,y-1)\\n return ANS[x][y]\\n \\n elif y==0:\\n ANS[x][y]=A+bra(x-1,y)\\n return ANS[x][y]\\n\\n elif x<y and x!=0 and y!=0:\\n ANS[x][y]=A+bra(x-1,y)+bra(x,y-1)\\n return ANS[x][y]\\n\\nprint(bra(n,n)%mod)\\n \\n \\n \\n"}
{"id": "656", "input": "n = int(input())\\nx, y = map(int, input().split())\\nwhite = max(x - 1, y -", "gt": "1)\\nblack = max(n - x, n - y)\\nprint(\"White\" if white <= black else \"Black\")"}
{"id": "657", "input": "#!/usr/bin/env python3\\ndef solve():\\n n, k = list(map(int, input().split()))\\n temps = list(map(int, input().split()))\\n\\n summer_seqs = []\\n winter_seqs = []\\n\\n cur_season = 1\\n cur_len = 0\\n for t in temps:\\n # print(\"Handling\", t)\\n if cur_season * t > 0 or (t == 0 and cur_season == 1):\\n cur_len += 1\\n # print(\"Adding...\")\\n else:\\n # print(\"Thats new!\")\\n if cur_season == 1:\\n summer_seqs.append(cur_len)\\n else:\\n winter_seqs.append(cur_len)\\n cur_len = 1\\n cur_season = -cur_season\\n if cur_season == 1:\\n summer_seqs.append(cur_len)\\n else:\\n winter_seqs.append(cur_len)\\n\\n summer_seqs = summer_seqs[1:]\\n\\n cur_len = sum(winter_seqs)\\n\\n if cur_len > k:\\n return -1\\n\\n if len(summer_seqs) == 0:\\n return 1 if len(winter_seqs) != 0 else 0\\n\\n changes =", "gt": "len(summer_seqs) + len(winter_seqs)\\n\\n last_sum_seq = None\\n if temps[-1] >= 0:\\n last_sum_seq = summer_seqs[-1]\\n summer_seqs = summer_seqs[:-1]\\n\\n summer_seqs = list(sorted(summer_seqs))\\n\\n # print(\"Changes needed so far:\", changes)\\n # print(\"Summer seqs: \", len(summer_seqs))\\n # print(\"Last summer seq:\", last_sum_seq)\\n # print(\"Can drive for another\", k - cur_len)\\n\\n for s in summer_seqs:\\n if k - cur_len >= s:\\n changes -= 2\\n cur_len += s\\n else:\\n break\\n\\n # print(\"Before last summer we can drive for\",\\n # k - cur_len, \"having \", changes, \"changes\")\\n\\n if last_sum_seq is not None:\\n if k - cur_len >= last_sum_seq:\\n # print(\"and dont change at last\")\\n changes -= 1\\n\\n return changes\\n\\n\\ndef __starting_point():\\n print(solve())\\n\\n__starting_point()"}
{"id": "658", "input": "#!/usr/bin/env python3\\n\\ndef main():\\n a, b = list(map(int, input().split()))\\n x, y, z = list(map(int, input().split()))\\n print(max(x * 2 +", "gt": "y - a, 0) + max(y + z * 3 - b, 0))\\n\\ntry:\\n while True:\\n main()\\nexcept EOFError:\\n pass\\n"}
{"id": "659", "input": "\\nn, w, v, u = list(map(int, input().split()))\\nversh = []\\nfor i in range(n):\\n a, b = list(map(int, input().split()))\\n versh.append((a, b))\\nversh.sort(key=lambda x : x[1])\\nfor i in versh:\\n if i[0] / v < i[1] / u:\\n break\\nelse:\\n print(w / u)\\n return\\ny = 0\\ntime", "gt": "= 0\\nfor i in versh:\\n x = i[0] - time * v\\n if x < 0:\\n continue\\n if x / v >= (i[1] - y) / u:\\n time += x / v\\n y = i[1]\\ntime += (w - y) / u\\nprint(time)\\n"}
{"id": "660", "input": "import sys\\n\\ndef solve():\\n n, = rv()\\n a, = rl(1)\\n for i in range(min(10, n - 1)):\\n for j in range(max(i + 1, n - 10), n):\\n if a[i] != a[j]:\\n a[i], a[j] = a[j], a[i]\\n if notsorted(a):\\n print(i + 1, j + 1)\\n return\\n a[i], a[j] = a[j], a[i]\\n count = 0\\n for i in range(n - 1):\\n if a[i] != a[i + 1]:\\n a[i], a[i + 1] = a[i + 1], a[i]\\n if notsorted(a):\\n print(i + 1, i + 2)\\n return\\n a[i], a[i +", "gt": "1] = a[i + 1], a[i]\\n count += 1\\n if count == 100: break\\n print(-1)\\n\\ndef notsorted(a):\\n first, second = True, True\\n for i in range(len(a) - 1):\\n if a[i] > a[i + 1]:\\n first = False\\n break\\n for i in range(len(a) - 1):\\n if a[i] < a[i + 1]:\\n second = False\\n break\\n return True if not first and not second else False\\n\\n\\n\\ndef prt(l): return print(''.join(l))\\ndef rv(): return map(int, input().split())\\ndef rl(n): return [list(map(int, input().split())) for _ in range(n)]\\nif sys.hexversion == 50594544 : sys.stdin = open(\"test.txt\")\\nsolve()"}
{"id": "661", "input": "n, b, p = map(int, input().split())\\nanswer1 = 0\\nanswer2 = n\\nwhile n > 1:\\n k = 1\\n while k < n:\\n k *=", "gt": "2\\n answer1 += k * b + (k // 2)\\n n = k // 2 + n - k\\nprint(answer1, answer2 * p)"}
{"id": "662", "input": "#!/usr/bin/env python3\\ndef main():\\n M, K = map(int, input().split())\\n if K == 0:\\n print(*[i//2 for i in range(2**(M+1))])\\n else:\\n if K >= 2**M or M <= 1:\\n print(-1)\\n else:\\n nums = []\\n", "gt": "for i in range(2**M):\\n if i != K:\\n nums.append(i)\\n a = [nums[0], K, nums[0]]\\n b = []\\n for i in range(1,2**M-1):\\n b.append(nums[i])\\n b.append(K)\\n for i in range(1,2**M-1):\\n b.append(nums[2**M-1-i])\\n print(*a,*b)\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "663", "input": "from collections import Counter, defaultdict\\nimport itertools\\nimport sys\\n\\ndef main():\\n n = int(input())\\n spec = 3\\n poss = True\\n for _ in range(n):\\n winner", "gt": "= int(input())\\n if winner != spec:\\n spec = 6 - winner - spec\\n else:\\n poss = False\\n print('YES' if poss else 'NO')\\n\\n\\n\\nmain()\\n"}
{"id": "664", "input": "from math import ceil\\ndef dist(x, y):\\n return (x ** 2 + y ** 2) ** 0.5\\nr,", "gt": "x, y, x2, y2 = map(int, input().split())\\nprint(ceil(dist(x - x2, y - y2) / (2 * r)))"}
{"id": "665", "input": "n = int(input())\\na = list(map(int, input().split()))\\nd = []\\nfor i in range(1, n):\\n d.append(a[i] - a[i - 1])\\nd.append(a[0] - a[n - 1])\\ncnt = 0\\nfor i in", "gt": "range(0, n):\\n if d[i] < 0:\\n cnt += 1\\n pos = i\\nif cnt == 0:\\n print(0)\\nelif cnt > 1:\\n print(-1)\\nelse:\\n print(n - pos - 1)\\n"}
{"id": "666", "input": "t = int(input())\\nfor i in range(t):\\n n, s = [int(x) for x in input().split()]\\n a= [int(x) for x in input().split()]\\n need = -1\\n if (sum(a)) <= s:\\n print(0)\\n", "gt": "else:\\n for i in range(n):\\n if a[i] > need:\\n need= a[i]\\n index = i\\n if s - a[i] < 0:\\n print(index + 1)\\n break\\n s -= a[i]\\n \\n"}
{"id": "667", "input": "def f(m):\\n return m * (m + 1) // 2\\n\\nn = int(input())\\nl, r = 0, n\\nwhile r - l >", "gt": "1:\\n m = (r + l) // 2\\n if f(m) >= n:\\n r = m\\n else:\\n l = m\\nn -= f(l)\\nprint(n)"}
{"id": "668", "input": "#!/usr/bin/env", "gt": "python\\n\\nimport base64\\n\\n\\nexec(base64.b64decode(b'Cm4gPSBpbnQoaW5wdXQoKSkKZ3JhcGggPSBbW2ludCh4KSBmb3IgeCBpbiBpbnB1dCgpLnNwbGl0KCldIGZvciBfIGluIHJhbmdlKG4pXQpkaXN0ID0gW3Jvd1s6XSBmb3Igcm93IGluIGdyYXBoXQoKZm9yIGsgaW4gcmFuZ2Uobik6CiAgICBmb3IgaSBpbiByYW5nZShuKToKICAgICAgICBmb3IgaiBpbiByYW5nZShuKToKICAgICAgICAgICAgaWYgZGlzdFtpXVtqXSA+IGRpc3RbaV1ba10gKyBkaXN0W2tdW2pdOgogICAgICAgICAgICAgICAgZGlzdFtpXVtqXSA9IGRpc3RbaV1ba10gKyBkaXN0W2tdW2pdCgpwcmludChtYXgobWF4KHggZm9yIHggaW4gcm93KSBmb3Igcm93IGluIGRpc3QpKQo='))\\n"}
{"id": "669", "input": "def solve():\\n n = int(input())\\n A = list(map(int, input().split()))\\n x, A = A[0], A[1:]\\n A = [(A[i], i + 2) for i in range(len(A))]\\n A.sort(reverse=True)\\n\\n cnt = 1\\n msg = x\\n total = 1\\n for a in A:\\n if not msg:\\n print(-1)\\n return\\n msg += a[0] - 1\\n total += a[0]\\n", "gt": "cnt += 1\\n if total >= n:\\n break\\n\\n print(n - 1)\\n total = x\\n for j in range(min(x, len(A))):\\n print(1, A[j][1])\\n if total >= n - 1:\\n return\\n for i in range(len(A)):\\n for j in range(total, min(total + A[i][0], len(A))):\\n print(A[i][1], A[j][1])\\n total += 1\\n if total >= n - 1:\\n return\\n\\n\\nsolve()"}
{"id": "670", "input": "import bisect\\n\\nn, m = [int(x) for x in input().split()]\\na = [int(x) for x in input().split()]\\n\\n# n : number of integers\\n# m : mod\\n\\nhalf_n = n // 2\\n\\na1, a2 = a[:half_n], a[half_n:]\\n\\nn1, n2 = len(a1), len(a2)\\n\\nr1, r2 = [], []\\n\\ndef dfs1(i, sum):\\n if i == n1:\\n r1.append(sum)\\n", "gt": "else:\\n dfs1(i+1, sum)\\n dfs1(i+1, (sum+a1[i])%m)\\n\\ndef dfs2(i, sum):\\n if i == n2:\\n r2.append(sum)\\n else:\\n dfs2(i+1, sum)\\n dfs2(i+1, (sum+a2[i])%m)\\n\\ndfs1(0,0)\\ndfs2(0,0)\\n\\nr1, r2 = [sorted(set(x)) for x in [r1, r2]]\\n\\nans = 0\\n\\nfor i, x in enumerate(r1):\\n p = bisect.bisect_left(r2, m-x)\\n tmp_ans = r2[p-1] + x\\n if tmp_ans > ans:\\n ans = tmp_ans\\n\\nprint(ans)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"}
{"id": "671", "input": "a, b, c = list(map(int, input().split()))\\nx1, y1, x2, y2 = list(map(int, input().split()))\\nans0 = round(abs(x1 - x2) + abs(y1 - y2), 9)\\nif a * b ==0:\\n print(ans0)\\n raise SystemExit\\nx11 = (-c - b * y1) / a\\ny12 = (-c - a * x1) / b\\nx21 = (-c - b * y2) / a\\ny22 = (-c - a * x2) / b\\n\\nans1 = abs(x1 - x11) +", "gt": "abs(x21 - x2) + ((y2 - y1)**2 + (x21 - x11)**2)**0.5\\nans2 = abs(y1 - y12) + abs(x21 - x2) + ((y2 - y12)**2 + (x21 - x1)**2)**0.5\\nans3 = abs(y1 - y12) + abs(y2 - y22) + ((x1 - x2)**2 + (y12 - y22)**2)**0.5\\nans4 = abs(x1 - x11) + abs(y22 - y2) + ((x11 - x2)**2 + (y1 - y22)**2)**0.5\\n\\nans0 = min(ans0, ans1, ans2, ans3, ans4)\\n\\nprint(round(ans0, 10))\\n"}
{"id": "672", "input": "s=\"\"\\nfor i", "gt": "in range(10000):\\n s+=str(i)\\nprint(s[int(input())])"}
{"id": "673", "input": "# fin = open(\"input.txt\")\\n# a, b = map(int, fin.readline().split())\\na, b = list(map(int, input().split()))\\na2 = a - b\\nif a2 == 0:\\n print(\"infinity\")\\nelse:\\n Count = 0\\n i = 1\\n while i ** 2 <= a2:\\n", "gt": "Count += (a2 % i == 0 and i > b) + (a2 % i == 0 and a2 // i > b and i != a2 // i)\\n i += 1\\n print(Count)\\n"}
{"id": "674", "input": "n, k = list(map(int, input().split()))\\nprint(k", "gt": "* (n // k + 1))\\n"}
{"id": "675", "input": "n = int(input())\\n\\nwrong_str = False\\n\\nstrings = []\\nsets = []\\nfor _ in range(n):\\n new_string = input()\\n new_string_set = set(new_string)\\n if len(new_string) != len(new_string_set):\\n wrong_str = True\\n break\\n\\n strings.append(new_string)\\n sets.append(new_string_set)\\n\\nif wrong_str:\\n print(\"NO\")\\n return\\n\\n\\nconnections = []\\nfor _ in range(n):\\n connections.append((-1,-1))\\n\\nchanged = True\\n\\nwhile changed:\\n\\n changed = False\\n\\n for i in range(len(strings)):\\n\\n if strings[i] == None:\\n continue\\n\\n for j in range(i + 1, len(strings)):\\n\\n if strings[j] == None:\\n continue\\n\\n if len(set(strings[i]).intersection(set(strings[j]))) == 0:\\n continue\\n\\n a = strings[i]\\n b = strings[j]\\n\\n #print(a, b)\\n\\n if b in a:\\n strings[j] = None\\n changed = True\\n elif a in b:\\n strings[i] =", "gt": "b\\n strings[j] = None\\n changed = True\\n else:\\n\\n is_ok = False\\n\\n start_index = a.find(b[0])\\n if start_index != -1 and a[start_index:] in b:\\n strings[i] += strings[j][len(a) - start_index:]\\n strings[j] = None\\n is_ok = True\\n changed = True\\n\\n if not is_ok:\\n start_index = b.find(a[0])\\n if start_index != -1 and b[start_index:] in a:\\n strings[i] = strings[j] + strings[i][len(b) - start_index:]\\n strings[j] = None\\n is_ok = True\\n changed = True\\n\\n if not is_ok:\\n print(\"NO\")\\n return\\n\\n\\n\\n\\n if wrong_str:\\n print(\"NO\")\\n return\\n\\n strings = [x for x in strings if x is not None]\\n\\nwhole_str = \"\".join(strings)\\n\\nif len(whole_str) != len(set(whole_str)):\\n print(\"NO\")\\n return\\n\\nprint(\"\".join(sorted(strings)))\\n\\n\\n\\n"}
{"id": "676", "input": "\"\"\"\\nCodeforces Contest 288 Div 2 Problem C\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.4.2\\n\"\"\"\\n\\n################################################### SOLUTION\\n\\ndef main():\\n m,t,r = read()\\n w = read()\\n if t < r: return -1\\n covers = [0]*1000\\n ct = 0\\n for i in w:\\n x = covers[i]\\n for j in range(r-x):\\n for k in range(t):\\n covers[i-j+k] += 1\\n ct += 1\\n return ct\\n\\n\\n\\n#################################################### HELPERS\\n\\n\\n\\ndef read(mode=2):\\n", "gt": "# 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "677", "input": "n = int(input())\\na = []\\nfor i in range(n):\\n a.append(int(input()))\\na = sorted(a)\\n#print(a)\\nif n == 0:\\n print('YES')\\n print(1)\\n print(1)\\n print(3)\\n print(3)\\nelif n == 1:\\n print('YES')\\n print(a[0])\\n print(3 * a[0])\\n print(3 * a[0])\\nelif n == 2:\\n if a[0] * 3 >= a[1]:\\n print('YES')\\n print(a[0] * 3)\\n print(a[0] * 4 - a[1])\\n elif a[1] % 3 == 0 and a[1] // 3 <= a[0]:\\n print('YES')\\n print(a[1] // 3)\\n print(a[1] + a[1] // 3 - a[0])\\n elif (a[0] + a[1]) % 4 == 0 and (a[0] + a[1]) // 4 <= a[0]:\\n print('YES')\\n print((a[0] + a[1])", "gt": "// 4)\\n print(3 * ((a[0] + a[1]) // 4))\\n else:\\n print('NO')\\nelif n == 3:\\n if a[0] * 3 >= a[2] and 4 * a[0] == a[1] + a[2]:\\n print('YES')\\n print(a[0] * 3)\\n elif a[2] % 3 == 0 and a[2] // 3 <= a[0] and a[2] + a[2] // 3 == a[0] + a[1]:\\n print('YES')\\n print(a[2] // 3)\\n elif a[2] == a[0] * 3:\\n print('YES')\\n print(4 * a[0] - a[1])\\n else:\\n print('NO')\\nelif n == 4:\\n if a[3] == 3 * a[0] and a[0] + a[3] == a[1] + a[2]:\\n print('YES')\\n else:\\n print('NO')"}
{"id": "678", "input": "q = int(input())\\nfor _ in range(q):\\n l, r, d = list(map(int, input().split()))\\n if d < l:\\n", "gt": "print(d)\\n else:\\n v = d * (r // d)\\n while v <= r:\\n v += d\\n print(v)\\n"}
{"id": "679", "input": "foo = baz = 0\\nquz = 1\\nfor bar in range(1, int(input()) + 1):\\n foo += int(input())\\n", "gt": "if foo * quz < baz * bar: break\\n baz, quz = foo, bar\\nprint(baz / quz)"}
{"id": "680", "input": "def main():\\n s = input()\\n n = len(s)\\n poss = False\\n for i in range(n - 2):\\n t = s[i:i +", "gt": "3]\\n if 'A' in t and 'B' in t and 'C' in t:\\n poss = True\\n break\\n print('Yes' if poss else 'No')\\n\\n\\nmain()\\n"}
{"id": "681", "input": "ax, ay = list(map(int, input().split()))\\nbx, by = list(map(int, input().split()))\\ncx, cy = list(map(int, input().split()))\\n\\n\\ndef f(cx, ax, bx, cy, ay, by):\\n mxy = max(ay, by, cy)\\n mny = min(ay, by, cy)\\n print(abs(cx - bx) + mxy - mny + 1)\\n for i in range(mny, mxy + 1):\\n print(ax, i)\\n if cx <= bx:\\n for i in range(cx, ax):\\n print(i, cy)\\n for i in range(ax + 1, bx + 1):\\n print(i, by)\\n", "gt": "else:\\n for i in range(bx, ax):\\n print(i, by)\\n for i in range(ax + 1, cx + 1):\\n print(i, cy)\\n\\n\\nif cx <= ax <= bx or bx <= ax <= cx:\\n f(cx, ax, bx, cy, ay, by)\\nelif cx <= bx <= ax or ax <= bx <= cx:\\n f(cx, bx, ax, cy, by, ay)\\nelif bx <= cx <= ax or ax <= cx <= bx:\\n f(bx, cx, ax, by, cy, ay)\\n"}
{"id": "682", "input": "import sys\\n\\nMOD = 10**9+7\\n\\n# Polymod\\ndef polymod(P,Q):\\n assert(Q[-1]==1)\\n n = len(Q)\\n while len(P)>=n:\\n p = P[-1]\\n for i in range(n):\\n P[-i-1] -= p*Q[-i-1]\\n assert(P[-1]==0)\\n P.pop()\\n return P\\n\\ndef polyprod(P,Q):\\n n = len(P)\\n m = len(Q)\\n W = [0]*(n+m-1)\\n for i in range(n):\\n for j in range(m):\\n W[i+j]+=P[i]*Q[j]\\n return [w%MOD for w in W]\\n\\n# Calc A^m", "gt": "* B \\ndef power(A,B,m,mult):\\n if m == 0:\\n return B\\n while m>1:\\n if m%2==1:\\n B = mult(A,B)\\n A = mult(A,A)\\n m//=2\\n return mult(A,B)\\n \\ndef calc_nth_term(init,linear_coeff,n):\\n def mult(A,B):\\n return polymod(polyprod(A,B),linear_coeff)\\n \\n ans = power([0,1],[1],n,mult)\\n return sum(ans[i]*init[i] for i in range(len(ans)))\\n\\n\\nn,m = [int(x) for x in input().split()]\\n\\nlinear_rec = [0]*(m+1)\\nlinear_rec[0] = -1\\nlinear_rec[m-1] = -1\\nlinear_rec[m] = 1\\n\\nprint(calc_nth_term([1]*m,linear_rec,n)%MOD)\\n"}
{"id": "683", "input": "import math\\n\\nx1, y1, x2, y2 = map(int, input().split())\\nif (x1 == x2) and (y1 == y2):\\n print(0, 0, 0)\\nelse: \\n # ladya\\n if (x1 == x2) or (y1 == y2):\\n l = 1\\n else:\\n l = 2\\n \\n #slon\\n if (abs(x1", "gt": "- x2) == abs(y1 - y2)):\\n s = 1\\n elif ((x1 + y1) % 2 == (x2 + y2) % 2): \\n s = 2\\n else:\\n s = 0\\n\\n #korol\\n k = max(abs(x1 - x2), abs(y1 - y2))\\n print(l, s, k)"}
{"id": "684", "input": "import sys\\na = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8092, 16184, 32368,", "gt": "64736, 129472, 258944, 517888, 1035776, 2071552, 4143104, 8286208, 16572416, 33144832, 66289664, 132579328, 265158656, 530317312, 1060634624, 2121269248, 4242538496, 8485076992, 16970153984, 33940307968]\\n\\n\\nprint(a[int(sys.stdin.readline())])"}
{"id": "685", "input": "t=int(input())\\nfor j in", "gt": "range(t):\\n a,b,c,d=map(int, input().split())\\n print(b,c,c)"}
{"id": "686", "input": "from bisect import bisect_left\\n\\nn, h = map(int, input().split())\\nx1, x2 = map(int, input().split())\\nif n == 1:\\n print(h + x2 - x1)\\nelse:\\n gap_sum = [0]\\n airflow_sum = [x2 - x1]\\n for _ in range(n - 1):\\n oldx1, oldx2 = x1, x2\\n x1, x2 = map(int, input().split())\\n gap_sum.append(gap_sum[-1] + x1 - oldx2)\\n airflow_sum.append(airflow_sum[-1] + x2 -", "gt": "oldx2)\\n\\n #print(gap_sum)\\n #print(airflow_sum)\\n\\n ans = h\\n for i in range(n):\\n cnt = bisect_left(gap_sum, h + gap_sum[i])\\n if i == 0:\\n res = airflow_sum[cnt-1] + h - gap_sum[cnt-1]\\n else:\\n res = airflow_sum[cnt-1] - (airflow_sum[i-1] + gap_sum[i] - gap_sum[i - 1]) + h - (gap_sum[cnt-1] - gap_sum[i])\\n\\n if res > ans:\\n ans = res\\n print(ans)"}
{"id": "687", "input": "for _ in range(int(input())):\\n x, y = list(map(int, input().split()))\\n s", "gt": "= x - y\\n if s == 1:\\n print('NO')\\n else:\\n print('YES')\\n"}
{"id": "688", "input": "a, b = map(int, input().split())\\nif a == 9 and b == 1:\\n print(9, 10)\\nelif a ==", "gt": "b - 1:\\n print(a, b)\\nelif a == b:\\n print(a * 10, a * 10 + 1)\\nelse:\\n print(-1)"}
{"id": "689", "input": "t1 = map(int,input().strip())\\nt2 = map(int,input().strip())\\nar1 = [0] * 10\\nar2 = [0]*10\\nfor j", "gt": "in t1:\\n ar1[j]+=1\\nfor j in t2:\\n ar2[j]+=1\\nar1[2]+=ar1[5]\\nar1[6]+=ar1[9]\\nar1[5]=ar1[9]=0\\nar2[2]+=ar2[5]\\nar2[6]+=ar2[9]\\nar2[5]=ar2[9]=0\\nprint(int(min(map(lambda x:ar2[x]/ar1[x] if ar1[x]!=0 else 100500 ,range(10)))))"}
{"id": "690", "input": "from bisect import bisect_left as bl\\nfrom bisect import bisect_right as br\\nfrom heapq import heappush,heappop,heapify\\nimport math\\nfrom collections import *\\nfrom functools import reduce,cmp_to_key\\nimport sys\\ninput = sys.stdin.readline\\n\\nfrom itertools import accumulate\\nfrom functools import lru_cache\\n\\nM = mod = 998244353\\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\\ndef inv_mod(n):return pow(n, mod - 2, mod)\\n \\ndef", "gt": "li():return [int(i) for i in input().rstrip('\\n').split()]\\ndef st():return input().rstrip('\\n')\\ndef val():return int(input().rstrip('\\n'))\\ndef li2():return [i for i in input().rstrip('\\n')]\\ndef li3():return [int(i) for i in input().rstrip('\\n')]\\n\\n\\nfor _ in range(val()):\\n n = val()\\n cnt = Counter()\\n for j in range(n):\\n cnt += Counter(st())\\n \\n ans = 1\\n for i in cnt:\\n if cnt[i] % n:\\n ans = 0\\n print('YES' if ans else 'NO')"}
{"id": "691", "input": "N = input()\\nfor digit in N[::-1]:\\n Os =", "gt": "int(digit)%5\\n if int(digit) >= 5:\\n print(\"-O|\"+Os*\"O\"+\"-\"+(4-Os)*\"O\")\\n else:\\n print(\"O-|\"+Os*\"O\"+\"-\"+(4-Os)*\"O\")\\n"}
{"id": "692", "input": "n, x = input().split()\\nn, x = int(n), int(x)\\n\\nm1 = 2 ** 17\\nm2 = 2 ** 18\\n\\nif n == 2 and x == 0:\\n print(\"NO\")\\nelif n == 1:\\n a = [x]\\nelif n == 2 and x > 0:\\n a = [0, x]\\nelse:\\n a =", "gt": "[]\\n ans = 0\\n for i in range(1, n-2):\\n ans ^= i\\n a.append(i)\\n if ans == x:\\n a.append(m1)\\n a.append(m2)\\n a.append(m1+m2)\\n else:\\n a.append(m1)\\n a.append(m1 ^ x ^ ans)\\n a.append(0)\\nif not (n == 2 and x == 0):\\n print(\"YES\")\\n print(\" \".join([str(e) for e in a]))\\n"}
{"id": "693", "input": "ct = 0\\nx = int(input())\\ny = list(map(int, input().split(' ')))\\nz = list(map(int, input().split(' ')))\\nfor", "gt": "i in range(1, 720721):\\n for j in range(x):\\n if i%y[j] == z[j]:\\n ct+=1\\n break\\nprint(ct/720720)\\n"}
{"id": "694", "input": "from collections import defaultdict\\n\\n\\nn, m = list(map(int, input().split()))\\n\\nns = list(map(int, input().split()))\\nms = list(map(int, input().split()))\\nsumms = sum(ms)\\n\\ntarget = {\\n i: m\\n for i, m in enumerate(ms, 1)\\n}\\nremain = set(i for i, m in list(target.items()) if m != 0)\\n\\ncount = defaultdict(int)\\n\\na = 0\\nb = 0\\n\\nwhile remain and b < n:\\n count[ns[b]] += 1\\n if ns[b] in remain and target[ns[b]] <= count[ns[b]]:\\n remain.remove(ns[b])\\n", "gt": "b += 1\\n\\nif remain:\\n print(-1)\\nelse:\\n ans = b - summs\\n while b <= n:\\n if remain:\\n if b >= n:\\n break\\n count[ns[b]] += 1\\n if ns[b] in remain and target[ns[b]] <= count[ns[b]]:\\n remain.remove(ns[b])\\n b += 1\\n else:\\n count[ns[a]] -= 1\\n if target[ns[a]] > count[ns[a]]:\\n remain.add(ns[a])\\n else:\\n ans = min(ans, b - a - 1 - summs)\\n a += 1\\n\\n print(ans)\\n"}
{"id": "695", "input": "def main():\\n s, x, pfx = input(), 0, []\\n a, b = list(map(int, input().split()))\\n try:\\n for i, c in enumerate(s, 1):\\n x = (x * 10 + ord(c) - 48) % a\\n if not x and s[i] != '0':\\n pfx.append(i)\\n except IndexError:\\n pass\\n x, p, i", "gt": "= 0, 1, len(s)\\n for stop in reversed(pfx):\\n for i in range(i - 1, stop - 1, -1):\\n x = (x + (ord(s[i]) - 48) * p) % b\\n p = p * 10 % b\\n if not x:\\n print(\"YES\")\\n print(s[:i])\\n print(s[i:])\\n return\\n print(\"NO\")\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "696", "input": "import math\\nimport re\\nfrom fractions import Fraction\\n\\nclass Task:\\n table = ['111111101010101111100101001111111\\n', '100000100000000001010110001000001\\n', '101110100110110000011010001011101\\n', '101110101011001001111101001011101\\n', '101110101100011000111100101011101\\n', '100000101010101011010000101000001\\n', '111111101010101010101010101111111\\n', '000000001111101111100111100000000\\n', '100010111100100001011110111111001\\n', '110111001111111100100001000101100\\n', '011100111010000101000111010001010\\n', '011110000110001111110101100000011\\n', '111111111111111000111001001011000\\n', '111000010111010011010011010100100\\n', '101010100010110010110101010000010\\n', '101100000101010001111101000000000\\n', '000010100011001101000111101011010\\n', '101001001111101111000101010001110\\n', '101101111111000100100001110001000\\n', '000010011000100110000011010000010\\n', '001101101001101110010010011011000\\n', '011101011010001000111101010100110\\n', '111010100110011101001101000001110\\n', '110001010010101111000101111111000\\n', '001000111011100001010110111110000\\n', '000000001110010110100010100010110\\n', '111111101000101111000110101011010\\n', '100000100111010101111100100011011\\n', '101110101001010000101000111111000\\n', '101110100011010010010111111011010\\n', '101110100100011011110110101110000\\n', '100000100110011001111100111100000\\n', '111111101101000101001101110010001\\n']\\n\\n x,", "gt": "y = 0, 0 \\n answer = 0\\n \\n def __init__(self):\\n self.x, self.y = [int(_) for _ in input().split()]\\n #inFile = open('input.txt', 'r')\\n #self.table = inFile.readlines()\\n\\n def solve(self):\\n table, x, y = self.table, self.x, self.y\\n self.answer = table[x][y]\\n\\n def printAnswer(self):\\n print(self.answer)\\n\\ntask = Task()\\ntask.solve()\\ntask.printAnswer()\\n"}
{"id": "697", "input": "x=int(input())\\nif(x==2):\\n print(1)\\nelse:\\n x-=1\\n cnt=0\\n for i in range(1,x):\\n ok=0\\n for", "gt": "j in range(2,i+1):\\n if(x%j==0 and i%j==0): ok=1\\n if(ok==0) :cnt+=1\\n print(cnt)\\n"}
{"id": "698", "input": "n, m = list(map(int, input().split()))\\nmod = 998244853\\nfact = [1]\\ninvfact = [1]\\ndef pw(x, y):\\n ans = 1\\n while (y):\\n if (y & 1):\\n ans = (ans * x) % mod\\n x = x * x % mod\\n y >>= 1\\n return ans\\ndef inv(x):\\n return pw(x, mod - 2)\\nfor i in range(1, n + m + 1):\\n fact.append(fact[i - 1] * i % mod)\\n invfact.append(invfact[i - 1] * inv(i) % mod)\\nmn = max(0, n - m)\\ndef ways_to(sub):\\n inc = (n + m", "gt": "+ sub) // 2\\n return fact[n + m] * invfact[inc] * invfact[n + m - inc] % mod\\nans = 0\\nways = [0 for x in range(0, n + 2)]\\nfor i in range (mn, n + 1):\\n ways[i] = ways_to(n - m) - ways_to(2 * i - n + m)\\nways[n + 1] = ways_to(n - m)\\nfor i in range(1, n + 1):\\n ans += i * (ways[i + 1] - ways[i])\\n ans %= mod\\nif (ans < 0) :\\n ans += mod\\nprint(ans)\\n"}
{"id": "699", "input": "X,n=list(map(int,input().split()))\\n\\n\\nTaken=[True]*(X+1)\\nfor i in range(n):\\n x=list(map(int,input().split()))\\n if(x[0]==1):\\n Taken[x[1]]=False\\n Taken[x[2]]=False\\n else:\\n Taken[x[1]]=False\\ncnt=0\\nminn=0\\nmaxx=0\\nans=0\\nfor i", "gt": "in range(1,X):\\n if(Taken[i]):\\n cnt+=1\\n maxx+=1\\n else:\\n ans+=cnt//2\\n if(cnt%2!=0):\\n ans+=1\\n cnt=0\\nans+=cnt//2\\nif(cnt%2!=0):\\n ans+=1\\nprint(ans,maxx)\\n"}
{"id": "700", "input": "import sys\\nf = sys.stdin\\n# f = open(\"input.txt\", \"r\")\\ny, k, n = map(int, f.readline().strip().split())\\n\\nif y >= n:\\n first = -1\\nelse:\\n t = k\\n while t <= y:\\n", "gt": "t += k\\n first = t-y\\nif first == -1:\\n print(-1)\\nelse:\\n if first+y > n:\\n print(-1)\\n else:\\n res = []\\n for i in range(first, n+1-y, k):\\n res.append(i)\\n print(*res)"}
{"id": "701", "input": "3\\n\\nimport copy\\n\\n\\ndef rotate90(n, f):\\n return [[f[n - j - 1][i] for j in range(n)] for i in range(n)]\\n\\ndef fliphor(n, f):\\n return [[f[i][n - j - 1] for j in range(n)] for i in range(n)]\\n\\ndef flipver(n, f):\\n return [[f[n - i - 1][j] for j in range(n)] for i in range(n)]\\n\\ndef eq(n, f, g):\\n for i in range(n):\\n for j in range(n):\\n if f[i][j]", "gt": "!= g[i][j]:\\n return False\\n return True\\n\\n\\nn = int(input())\\nf = [list(input()) for i in range(n)]\\ng = [list(input()) for i in range(n)]\\n\\nfor doflipv in range(2):\\n for dofliph in range(2):\\n for nrot in range(4):\\n h = copy.deepcopy(f)\\n if dofliph == 1:\\n h = fliphor(n, h)\\n if doflipv == 1:\\n h = flipver(n, h)\\n for i in range(nrot):\\n h = rotate90(n, h)\\n if eq(n, h, g):\\n print(\"Yes\")\\n return\\n\\nprint(\"No\")"}
{"id": "702", "input": "s, t = input(), input()\\nsx, tx = str(sorted(s)), str(sorted(t))\\n\\ndef subset(s, t):\\n i = 0\\n for c in s:\\n if c == t[i]: i", "gt": "+= 1\\n if i == len(t): break\\n return i == len(t)\\n\\nif sx == tx:\\n print(\"array\")\\nelif subset(s, t):\\n print(\"automaton\")\\nelif subset(sx, tx):\\n print(\"both\")\\nelse:\\n print(\"need tree\")\\n"}
{"id": "703", "input": "n = int(input())\\n\\nboard =[]\\n\\nfor i in range(n):\\n board.append(list(input()))\\n \\nf = 1\\nfor i in range(n):\\n for j in range(n):\\n if board[i][j] == '.':\\n if i < n - 2 and j < n - 1 and j > 0", "gt": "and board[i+1][j] == '.' and board[i+2][j] == '.' and board[i+1][j-1] == '.' and board[i+1][j+1] == '.':\\n board[i+1][j] = '#'\\n board[i+2][j] = '#'\\n board[i+1][j-1] = '#'\\n board[i+1][j+1] = '#'\\n else:\\n f = 0\\n break\\n\\nif f == 1:\\n print(\"YES\")\\nelse:\\n print(\"NO\")"}
{"id": "704", "input": "k, a, b, v = map(int, input().split())\\nfor i in range(1, 1010):\\n if a", "gt": "<= v * (i + min(b, (k - 1) * i)):\\n print(i)\\n break"}
{"id": "705", "input": "import sys\\nsys.stdin = open('input.txt')\\nsys.stdout = open('output.txt','w')\\n\\nn = int(input())\\na = list(map(int, input().split()))\\n\\nr1, c1, r2, c2 = (i - 1 for i in map(int, input().split()))\\nx, y = (r1, r2) if r1 < r2 else (r2, r1)\\n\\nif r1 < r2: c1 = min(c1, min(a[i] for i in range(r1 + 1, r2 + 1)))\\nelif r2 < r1: c1 = min(c1, min(a[i] for i in range(r2, r1)))\\n\\nd = abs(c1 - c2)\\nc = c1\\nfor", "gt": "i in range(x - 1, -1, -1):\\n if c > a[i]:\\n c = a[i]\\n q = abs(c2 - c) + 2 * abs(x - i)\\n if q < d: d = q\\nc = c1\\nfor i in range(y + 1, n):\\n if c > a[i]:\\n c = a[i]\\n q = abs(c2 - c) + 2 * abs(i - y)\\n if q < d: d = q\\nprint(d + abs(r2 - r1))"}
{"id": "706", "input": "<s> ", "gt": "print('Karen')"}
{"id": "707", "input": "a, b, n, x = list(map(int, input().split(' ')))\\nfir = pow(a, n, 10**9+7)*x%(10**9+7)\\nsec =", "gt": "b*(pow(a, n, 10**9+7)-1)*(pow(a-1, 10**9+5, 10**9+7))%(10**9+7)\\nif (a == 1):\\n sec = n * b\\nprint((fir+sec)%(10**9+7))\\n"}
{"id": "708", "input": "import sys\\ninput=sys.stdin.readline\\n\\ndef gcd(x,y):\\n if y==0:\\n return x\\n if x<y:\\n x,y=y,x\\n return gcd(y,x%y)\\n\\nn,m=map(int,input().split())\\nX=list(map(int,input().split()))\\nP=list(map(int,input().split()))\\nd=X[1]-X[0]\\nfor", "gt": "i in range(2,n):\\n d=gcd(d,X[i]-X[i-1])\\nfor i,p in enumerate(P):\\n if d%p==0:\\n print('YES')\\n print(X[0],i+1)\\n break\\nelse:\\n print('NO')"}
{"id": "709", "input": "def main():\\n (n, k) = (int(x) for x in input().split())\\n (a, b, c, d) = (int(x) for x in input().split())\\n (path1, path2) = solver(n, k, a, b, c, d)\\n if path1 == None:\\n print(-1)\\n else:\\n for x in path1:\\n print(x, end = ' ')\\n print()\\n for x in path2:\\n print(x, end = ' ')\\n\\ndef solver(n, k, a, b, c, d):\\n if k <= n or n == 4:\\n return (None, None)\\n else:\\n path1 = [a, c] + \\\\n [i for i in range(1, n + 1) if i not in (a, b, c, d)] + \\\\n [d, b]\\n path2", "gt": "= [c, a] + \\\\n [i for i in range(1, n + 1) if i not in (a, b, c, d)] + \\\\n [b, d]\\n return (path1, path2)\\n\\nmain()\\n#print(solver(7, 11, 2, 4, 7, 3))\\n\\n# def reorder(path, n, a, b, c, d):\\n# for i in range(len(path)):\\n# if path[i] == a:\\n# path[i] = 1\\n# elif path[i] == b:\\n# path[i] = n\\n# elif path[i] == c:\\n# path[i] = 2\\n# elif path[i] == d:\\n# path[i] = 3\\n# elif path[i] == 1:\\n# path[i] = a\\n# elif path[i] == n:\\n# path[i] = b\\n# elif path[i] == 2:\\n# path[i] = c\\n# elif path[i] == 3:\\n# path[i] = d"}
{"id": "710", "input": "n = int(input())\\nans = 1\\n\\nwhile n != 1:\\n if n % 2", "gt": "== 1:\\n ans += 1\\n n -= 1\\n else:\\n n //= 2\\n\\nprint(ans)"}
{"id": "711", "input": "g = \"ACTG\"\\n\\ndef dist(a, b):\\n p = abs(ord(a) - ord(b))\\n return min(p, 26 - p)\\n\\ndef price(s):\\n return sum(dist(x, y) for", "gt": "x, y in zip(g, s))\\n\\nn = int(input())\\ns = input()\\nans = 100000\\nfor i in range(len(s) - 3):\\n ans = min(ans, price(s[i:i+4]))\\nprint(ans)\\n"}
{"id": "712", "input": "import sys\\n\\nsys.setrecursionlimit(10 ** 7)\\ninput = sys.stdin.readline\\nf_inf = float('inf')\\nmod = 10 ** 9 + 7\\n\\n\\nclass CmbMod:\\n def __init__(self, n, p):\\n \"\"\"\\n 二項係数nCr(n個の区別できるものからr個のものを選ぶ組み合わせの数)をpで割った余りを求める\\n \"\"\"\\n self.n = n\\n self.p = p\\n self.fact = [1, 1]\\n self.factinv = [1, 1]\\n self.inv = [0, 1]\\n\\n def cmb_mod(self, n, r):\\n \"\"\"\\n 二項係数nCr(mod p)をO(r)にて計算。nが大きいがrは小さい時に使用。\\n \"\"\"\\n numer, denom = 1, 1\\n for i in range(r):\\n numer = (numer * (n - i)) % self.p\\n denom = (denom * (i + 1)) % self.p\\n return (numer * pow(denom, self.p - 2, self.p)) % self.p\\n\\n def prep(self):\\n \"\"\"\\n 二項係数nCr(mod p)をO(1)で求める為の前処理をO(N)にて実行。\\n \"\"\"\\n for i in range(2, self.n + 1):\\n self.fact.append((self.fact[-1] * i) % self.p)\\n self.inv.append((-self.inv[self.p % i] * (self.p // i)) % self.p)\\n self.factinv.append((self.factinv[-1] *", "gt": "self.inv[-1]) % self.p)\\n\\n def cmb_mod_with_prep(self, n, r):\\n \"\"\"\\n 二項係数nCr(mod p)をO(1)で求める。事前にprepを実行する事。\\n \"\"\"\\n if (r < 0) or (n < r):\\n return 0\\n r = min(r, n - r)\\n return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p\\n\\n\\ndef prime_factorization(n):\\n res = []\\n for i in range(2, int(pow(n, 0.5)) + 1):\\n if n % i == 0:\\n ex = 0\\n while n % i == 0:\\n ex += 1\\n n //= i\\n res.append(ex)\\n if n != 1:\\n res.append(1)\\n return res\\n\\n\\ndef resolve():\\n N, M = list(map(int, input().split()))\\n\\n pf = prime_factorization(M)\\n cmb = CmbMod(10 ** 6, mod)\\n cmb.prep()\\n\\n res = 1\\n for b in pf:\\n res *= cmb.cmb_mod_with_prep(b + N - 1, b)\\n res %= mod\\n print(res)\\n\\n\\ndef __starting_point():\\n resolve()\\n\\n__starting_point()"}
{"id": "713", "input": "a = input().split()\\nn = int(a[0])\\np = float(a[1])\\nt = int(a[2])\\nden = 100 ** t\\np = round(p * 100 + 1e-9)\\nq = 100 - p\\nncr = [1 for i in range(2001)]\\nfor i in range(1, t + 1):\\n ncr[i] = ncr[i", "gt": "- 1] * (t - i + 1) // i\\nans = 0\\nfor i in range(2001):\\n ans += min(i, n) * ncr[i] * (p ** i) * (q ** (t - i)) if t >= i else 0\\nans /= den\\nprint(ans)\\n"}
{"id": "714", "input": "s=min(list(map(int,input().split())))\\nprint(s+1)\\nfor i", "gt": "in range(s+1):print(i,s-i)\\n"}
{"id": "715", "input": "n = int(input())\\nA = list(map(int, input().split()))\\nfor i in range(n):\\n", "gt": "A[i] = [A[i], i+1]\\nA.sort()\\nfor i in range(n//2):\\n print(A[i][1], A[n-i-1][1])"}
{"id": "716", "input": "\"\"\"\\nCodeforces Round 250 Div 2 Problem A\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\nclass IOHandlerObject(object):\\n def getInput(self, mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0:\\n return inputs\\n if mode == 1:\\n return inputs.split()\\n if mode == 2:\\n return [int(x) for x in inputs.split()]\\n\\n def writeOutput(self,", "gt": "s=\"\\n\"):\\n if isinstance(s, list): s = \" \".join(s)\\n print(s)\\n\\nIOHandler = IOHandlerObject()\\ng = IOHandler.getInput\\nw = IOHandler.writeOutput\\n\\n############################## SOLUTION ##############################\\na,b,c,d = g(0),g(0),g(0),g(0)\\nr = [(len(a)-2,0), (len(b)-2,1), (len(c)-2,2), (len(d)-2,3)]\\nr.sort()\\nt = -1\\nif r[0][0]*2 <= r[1][0]: t = r[0][1]\\nif r[3][0] >= r[2][0] * 2:\\n if not t+1:\\n t = r[3][1]\\n else:\\n t = 5\\n\\nif t == -1 or t == 5:\\n print(\"C\")\\nelse:\\n print(chr(65+t))"}
{"id": "717", "input": "n, a, b = list(map(int, input().split()))\\nm = input()\\nif", "gt": "m[a - 1] == m[b - 1]:\\n print(0)\\nelse:\\n print(1)"}
{"id": "718", "input": "n = int(input())\\nans = 0\\nfor i in range(n):\\n s, d = list(map(int, input().split()))\\n", "gt": "visit = s\\n while visit <= ans:\\n visit += d\\n ans = visit\\nprint(ans)\\n\\n"}
{"id": "719", "input": "a = int(input())\\nfor i in range(a+1,", "gt": "a+47):\\n if ('8' in str(i)):\\n print(i-a)\\n break\\n\\n"}
{"id": "720", "input": "from collections import defaultdict\\nk = int(input())\\n\\nd = defaultdict(list)\\n\\nfor i in range(10):\\n d[(1, i)].append(i)\\n\\nmx = 10\\npw = 1\\nfor digs in range(2, mx):\\n pw *=", "gt": "10\\n for sm in range(11):\\n for curr in range(10):\\n for num in d[(digs-1, sm-curr)]:\\n d[(digs, sm)].append( curr*pw + num )\\n\\nperfects = sorted(d[(mx-1, 10)])\\n#print(len(perfects))\\nprint(perfects[k-1])\\n"}
{"id": "721", "input": "def main():\\n n = int(input())\\n res = 0\\n la, lb = 0, 0\\n max_draw = -1\\n for _ in range(n):\\n a, b = [int(x) for x in input().split()]\\n mx = max(la, lb)\\n mn", "gt": "= min(a, b)\\n if mx <= max_draw:\\n mx = max_draw + 1\\n if mx <= mn:\\n res += mn - mx + 1\\n max_draw = mn\\n la, lb = a, b\\n print(res)\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "722", "input": "n,d=list(map(int,input().split()))\\n\\nA=list(map(int,input().split()))\\n\\nm=int(input())\\n\\nA.sort()\\n\\nif(m<=n):\\n", "gt": "print(sum(A[:m]))\\n\\nelse:\\n print(sum(A)-(d*(m-n)))\\n"}
{"id": "723", "input": "def main():\\n l = []\\n for i in range(int(input())):\\n y, n, m = 1989, 0, 1\\n for d in input()[-1:3:-1]:\\n n += (ord(d) - 48) * m\\n m", "gt": "*= 10\\n t = n - y % m\\n y += (m + t if t < 0 else t) + m\\n l.append(y - m)\\n print('\\n'.join(map(str, l)))\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "724", "input": "def main():\\n import sys\\n \\n tokens = [int(i) for i in sys.stdin.read().split()]\\n tokens.reverse()\\n \\n n = tokens.pop()\\n people = [(tokens.pop(), tokens.pop()) for i in range(n)]\\n \\n result = float(\"inf\")\\n for i in range(n):\\n for j in range(2):\\n maxh = people[i][j]\\n S = people[i][j ^ 1]\\n for k", "gt": "in range(n):\\n if k != i:\\n w, h = people[k]\\n w, h = min(w, h), max(w, h)\\n if w > maxh:\\n S = float(\"inf\")\\n break\\n if h > maxh:\\n S += h\\n else:\\n S += w\\n result = min(result, S * maxh)\\n \\n print(result)\\n \\n \\n \\nmain()\\n"}
{"id": "725", "input": "import sys\\n\\ndef read_int():\\n return int(input())\\n\\ndef read_ints():\\n return [int(x) for x in input().split()]\\n\\nn, d = read_ints()\\na = read_ints()\\n\\na = sorted(a)\\n\\nbest = 0\\n\\nfor i", "gt": "in range(n):\\n for j in range(i, n):\\n if a[j] - a[i] <= d:\\n best = max(best, j - i + 1)\\n\\nprint(len(a) - best)\\n"}
{"id": "726", "input": "\\nn, m = list(map(int, input().split()))\\nfor i in range(n):\\n for", "gt": "j in input().split():\\n if j in \"CMY\":\\n print(\"#Color\")\\n return\\nprint(\"#Black&White\")\\n"}
{"id": "727", "input": "read = lambda: map(int, input().split())\\nn, d = read()\\nx = sorted(read())\\nans = 2\\nfor i in range(1, n):\\n dx = x[i] -", "gt": "x[i - 1]\\n if dx == 2 * d:\\n ans += 1\\n elif dx > 2 * d:\\n ans += 2\\nprint(ans)"}
{"id": "728", "input": "from sys import stdin\\nfrom heapq import heappop, heappush, heapify\\ndef main():\\n n = int(stdin.readline())\\n a = stdin.readline().split()\\n q = []\\n p = 0\\n c = 0\\n l = [0] * (n + 1)\\n r = [0] * (n + 1)\\n k = [0] * (n + 1)\\n pa = [0] * (n + 1)\\n for i, x in enumerate(a):\\n if x == a[p]:\\n c += 1\\n else:\\n l[p] = p - 1\\n k[p] = k[i-1] = c\\n pa[p] = i - 1\\n pa[i-1] = p\\n r[i-1] = i\\n q.append((-c, p))\\n p = i\\n c = 1\\n q.append((-c, p))\\n l[p] = p -", "gt": "1\\n k[p] = k[n-1] = c\\n pa[p] = n - 1\\n pa[n-1] = p\\n r[n-1] = n\\n heapify(q)\\n ans = 0\\n while len(q):\\n c, p = heappop(q)\\n c = -c\\n if k[p] > c:\\n continue\\n ans += 1\\n ls = l[p]\\n rs = r[pa[p]]\\n if ls >= 0 and rs < n and a[ls] == a[rs]:\\n nc = k[ls] + k[rs]\\n nl, nr = pa[ls], pa[rs]\\n k[nl] = k[nr] = k[ls] = k[rs] = nc\\n pa[nr] = nl\\n pa[nl] = nr\\n heappush(q, (-nc, nl))\\n else:\\n if ls >= 0:\\n r[ls] = rs\\n if rs < n:\\n l[rs] = ls\\n print (ans)\\nmain()"}
{"id": "729", "input": "n=int(input())\\na=list(map(int,input().split()))\\nb=0\\na[1:]=sorted(a[1:])\\nwhile a[0]<=a[-1]:\\n a[-1]-=1\\n", "gt": "a[0]+=1\\n b+=1\\n a[1:]=sorted(a[1:])\\nprint(b)\\n"}
{"id": "730", "input": "n = int(input())\\ns = input()\\nfor i in range(n", "gt": "- 1):\\n if (s[i] != s[i+1]):\\n print(\"YES\")\\n print(s[i:i+2])\\n return\\nprint(\"NO\")\\n"}
{"id": "731", "input": "a = [\\n\"+------------------------+\",\\n\"|#.#.#.#.#.#.#.#.#.#.#.|D|)\",\\n\"|#.#.#.#.#.#.#.#.#.#.#.|.|\",\\n\"|#.......................|\",\\n\"|#.#.#.#.#.#.#.#.#.#.#.|.|)\",\\n\"+------------------------+\"\\n]\\nn = int(input())\\nrow = 1\\npos = 1\\n\\nfor i in range(n):\\n a[pos] = a[pos][:row] + 'O' + a[pos][row + 1:]\\n pos += 1\\n", "gt": "if row != 1 and pos == 3:\\n pos += 1\\n if pos > 4:\\n pos = 1\\n row += 2\\n\\nfor x in a:\\n print(x)\\n"}
{"id": "732", "input": "import math\\nw,m,k=list(map(int,input().split()))\\n\\nx=int(\"1\"+(\"0\"*len(str(m))))\\n\\nh=x-m\\nn=len(str(m))\\n\\nans=w//(n*k)\\n\\nif(ans>h):\\n ans=h\\n w-=h*n*k\\n while(w>0):\\n n+=1\\n x=w//(n*k)\\n", "gt": "if(x>=10**(n-1)*9):\\n ans+=(10**(n-1))*(9)\\n w-=(n*k*(10**(n-1))*(9))\\n else:\\n ans+=x\\n break\\nprint(ans)\\n \\n \\n"}
{"id": "733", "input": "#CF Round 150. Div II Prob. A - Dividing Orange\\nimport sys\\n\\ndp = [[[-1 for j in range(3)] for i in range (1 << 10)] for k in range(11)]\\n\\nIn = sys.stdin\\nn = In.readline().strip()\\n\\ndef go (idx, mask, equal):\\n if dp[idx][mask][equal] != -1:\\n return dp[idx][mask][equal]\\n if bin(mask).count(\"1\") > 2:\\n return 0\\n if idx == len(n):\\n return 1\\n res = 0\\n if idx == 0 or equal == 2:\\n res += go(idx + 1, mask, 2)\\n elif equal == 1 and", "gt": "int(n[idx]) == 0:\\n res += go(idx + 1, mask | 1, 1)\\n else:\\n res += go(idx + 1, mask | 1, 0) \\n for i in range(1, 10):\\n if equal == 1 and i > int(n[idx]):\\n break\\n elif equal == 1 and i == int(n[idx]):\\n res += go(idx + 1, mask | (1 << i), 1)\\n else:\\n res += go(idx + 1, mask | (1 << i), 0)\\n dp[idx][mask][equal] = res\\n return res\\n \\nprint(go(0, 0, 1) - 1)"}
{"id": "734", "input": "import fractions\\n\\nx, y, a, b = list(map(int, input().split()))\\nd = fractions.gcd(x, y)\\nd =", "gt": "x * y // d\\nprint(b // d - (a - 1) // d)\\n"}
{"id": "735", "input": "n, m = list(map(int, input().split()))\\na = list(map(int, input().split()))\\na.sort()\\nmx = a[-1]\\nt = 0\\nans = 0;\\nfor i in a:\\n if", "gt": "i > 0:\\n if i > t:\\n t += 1\\n ans += i - 1\\nans -= mx - t\\nprint(ans)\\n"}
{"id": "736", "input": "n = int(input())\\na = list(map(int, input().split()))\\n\\nif sorted(a) == a:\\n print('yes')\\n print('1 1')\\n return\\n\\nstart = 0\\nend = n - 1\\nseen = 0\\n\\nfor i in range(n-1):\\n if not seen:\\n if a[i] > a[i+1]:\\n", "gt": "seen += 1\\n start = i\\n else:\\n if a[i] <= a[i+1]:\\n end = i\\n break\\n#print(a)\\n#print(a[:start], a[start:end+1][::-1], a[end+1:], sep='\\n')\\na = a[:start] + a[start:end+1][::-1] + a[end+1:]\\n#print(a)\\n#print(start, end)\\n\\nif sorted(a) == a:\\n print('yes')\\n print(start+1, end+1)\\nelse:\\n print('no')\\n"}
{"id": "737", "input": "# 272 D2 A\\n\\ndef func(p,m,n):\\n w = p\\n while w % m != 0 and w<=n:\\n w += 1\\n if w<= n:\\n", "gt": "return w\\n else:\\n return -1\\n\\n\\n \\nl = input().split()\\nn = int(l[0])\\nm = int(l[1])\\n\\nif n % 2 == 0:\\n p = int(n/2)\\nelse:\\n p = int(n/2)+1\\n\\nprint(func(p,m,n))\\n"}
{"id": "738", "input": "n = int(input())\\na = 1\\nwhile a * a < n:\\n a += 1\\n\\nif a * (a", "gt": "- 1) >= n:\\n print(2 * a + 2 * (a - 1))\\nelse:\\n print(4 * a)\\n"}
{"id": "739", "input": "import sys\\n\\nreadline = sys.stdin.readline\\nreadall = sys.stdin.read\\nns = lambda: readline().rstrip()\\nni = lambda: int(readline().rstrip())\\nnm = lambda: map(int, readline().split())\\nnl = lambda: list(map(int, readline().split()))\\nprn = lambda x: print(*x, sep='\\n')\\n\\n\\ndef solve():\\n a, b, c, d = nm()\\n m = 10**6 + 10\\n l = [0]*m\\n for", "gt": "i in range(a, b+1):\\n l[i+b] += 1\\n l[i+c+1] += -1\\n for i in range(m-1):\\n l[i] += l[i-1]\\n for i in range(m-2, -1, -1):\\n l[i] += l[i+1]\\n print(sum(l[i+1] for i in range(c, d+1)))\\n return\\n\\nsolve()\\n\\n# T = ni()\\n# for _ in range(T):\\n# solve()\\n"}
{"id": "740", "input": "import copy\\nimport sys\\n\\nstdin = sys.stdin\\n\\nni = lambda: int(ns())\\nna = lambda: list(map(int, stdin.readline().split()))\\nns = lambda: stdin.readline().rstrip() # ignore trailing spaces\\n\\nL,A,B,mod = na()\\n\\nlow = 1\\nhigh = 10\\n\\n\\ndef matpow(M, v, e, mod):\\n A = copy.deepcopy(M)\\n w = copy.deepcopy(v)\\n while e > 0:\\n if e&1:\\n w = mulv(A, w, mod)\\n A = mul(A, A, mod)\\n e >>= 1\\n return w\\n\\n\\ndef mulv(M, v, mod):\\n n = len(M)\\n m = len(v)\\n ret = [0] * n\\n for i in range(n):\\n s = 0\\n for j in range(m):\\n s += M[i][j] * v[j]\\n ret[i] = s % mod\\n return ret\\n\\n\\ndef mul(A, B, mod):\\n n = len(A)\\n m = len(B)\\n o = len(B[0])\\n ret =", "gt": "[[0] * o for _ in range(n)]\\n for i in range(n):\\n for j in range(o):\\n s = 0\\n for k in range(m):\\n s += A[i][k] * B[k][j]\\n ret[i][j] = s % mod\\n return ret\\n\\n\\n# x = x * high + val\\n# val += B\\n# (high 1 0)\\n# (0 1 1)\\n# (0 0 1)\\n\\nv = [0, A, B]\\nra = A\\n\\nwhile low < 1e18:\\n mat = [[high%mod, 1, 0], [0, 1, 1], [0, 0, 1]]\\n step = max(0, min(L, (high-ra+B-1)//B))\\n v = matpow(mat, v, step, mod)\\n # print(low, high, step, ra + B*step, v)\\n ra = ra + B * step\\n L -= step\\n\\n low *= 10\\n high *= 10\\n\\nprint((v[0]))\\n"}
{"id": "741", "input": "k, na, nb, nc, ta, tb, tc = list(map(int, input().split()))\\nfrom collections import deque\\n\\na = deque()\\nb = deque()\\nc = deque()\\n\\nfor i in range(na):\\n a.append(0)\\nfor i in range(nb):\\n b.append(0)\\nfor i in range(nc):\\n c.append(0)\\n\\nt = 0\\nfor i in range(k):\\n vr", "gt": "= max(a[0], b[0] - ta, c[0] - (ta + tb))\\n a.popleft()\\n a.append(vr + ta)\\n b.popleft()\\n b.append(vr + tb + ta)\\n c.popleft()\\n c.append(vr + ta + tb + tc)\\n t = vr + ta + tb + tc\\nprint(t)\\n"}
{"id": "742", "input": "def ii():\\n return int(input())\\ndef mi():\\n return map(int, input().split())\\ndef li():\\n return list(mi())\\n\\nn, M = mi()\\na = [0] + li() + [M]\\nn = len(a)\\nans = 0\\np = [0] * n\\nq = [0] * n\\nfor i in range(1, n):\\n p[i] = p[i - 1]\\n q[i] = q[i - 1]\\n if i % 2 == 0:\\n p[i] += a[i] - a[i - 1]\\n else:\\n q[i] += a[i] - a[i - 1]\\n\\nans", "gt": "= q[-1]\\nfor i in range(1, n):\\n if a[i] == a[i - 1] + 1:\\n continue\\n if i % 2 == 0:\\n ans = max(ans, q[i] + 1 + p[-1] - p[i], q[i] + a[i] - a[i - 1] - 1 + p[-1] - p[i])\\n else:\\n ans = max(ans, q[i] - 1 + p[-1] - p[i], q[i] - (a[i] - a[i - 1] - 1) + p[-1] - p[i])\\nprint(ans)"}
{"id": "743", "input": "from sys import stdin,stderr\\ndef rl():\\n return [int(w) for w in stdin.readline().split()]\\n\\ndef solve(n, b):\\n f = [True for i in range(2*n+1)]\\n for x in b:\\n if not f[x]:\\n return [-1]\\n f[x] = False\\n", "gt": "a = []\\n for x in b:\\n a.append(x)\\n for y in range(x+1, 2*n+1):\\n if f[y]:\\n a.append(y)\\n f[y] = False\\n break\\n else:\\n return [-1]\\n return a\\n\\nt, = rl()\\nfor _ in range(t):\\n print(*solve(rl()[0], rl()))\\n"}
{"id": "744", "input": "from fractions import gcd\\nn=int(input())\\na=list(map(int,input().split()))\\nno=a[0]\\nfor", "gt": "i in range(1,n):\\n no=gcd(no,a[i])\\nprint(no*n)"}
{"id": "745", "input": "n = int(input())\\ns = input()\\nsi, sf = 0, 0\\nfor i in range(1, n):\\n if s[i] == 'S' and s[i - 1] !=", "gt": "'S':\\n si += 1\\n elif s[i] == 'F' and s[i - 1] != 'F':\\n sf += 1\\nif sf > si:\\n print('YES')\\nelse:\\n print('NO')\\n"}
{"id": "746", "input": "MOD = 998244353\\n\\ndef inv(x):\\n return pow(x,MOD - 2, MOD)\\n\\nn, k = list(map(int, input().split()))\\nif k >= n:\\n print(0)\\nelse:\\n out = 0\\n col = n - k \\n binom = 1\\n mult = 1\\n for i in range(n, col, -1):\\n mult *= i\\n mult *= inv(n + 1 - i)\\n", "gt": "mult %= MOD\\n \\n for i in range(col, 0, -1):\\n out += binom * pow(i, n, MOD)\\n out %= MOD\\n binom *= i\\n binom *= inv(col + 1 - i)\\n binom *= -1\\n binom %= MOD\\n\\n out *= mult\\n\\n if k > 0:\\n out *= 2\\n print(out % MOD)\\n"}
{"id": "747", "input": "import math\\na, b = [int(i) for i in input().split()]\\nn = int(input())\\no = []\\nfor", "gt": "i in range(n):\\n x, y, z = [int(i) for i in input().split()]\\n o.append(math.sqrt((x-a)**2+(y-b)**2)/z)\\nprint(min(o))\\n\\n\\n"}
{"id": "748", "input": "import itertools\\nimport operator\\n\\n\\nn, x = list(map(int, str.split(input())))\\na = []\\nb = []\\nfor _ in range(n):\\n\\n t, h, m = list(map(int, str.split(input())))\\n (a if t else b).append((h, m))\\n\\nbest = 0\\nfor ca, cb in ((a, b), (b, a)):\\n\\n cx = x\\n count = 0\\n ca, cb", "gt": "= ca[:], cb[:]\\n while True:\\n\\n available = tuple([candy for candy in enumerate(ca) if candy[1][0] <= cx])\\n if available:\\n\\n i, candy = max(available, key=lambda candy: candy[1][1])\\n ca.pop(i)\\n count += 1\\n cx += candy[1]\\n\\n else:\\n\\n break\\n\\n ca, cb = cb, ca\\n\\n best = max(best, count)\\n\\nprint(best)\\n"}
{"id": "749", "input": "\\ndef __starting_point():\\n N = int(input())\\n L = [0,0,0,0,0,0,0,0]\\n inp = input()\\n for i in inp.split(' '):\\n L[int(i)]+=1\\n it = N//3\\n fnd = True\\n ans = []\\n for ic in range(it):\\n Tl = []\\n for", "gt": "el in range(len(L)):\\n if L[el]!=0:\\n if len(Tl)==0:\\n Tl.append(el)\\n L[el]-=1\\n elif el%Tl[-1]==0:\\n Tl.append(el)\\n L[el]-=1\\n if len(Tl)==3:\\n break\\n if len(Tl)==3:\\n ans.append(str(Tl[0])+\" \"+str(Tl[1])+\" \"+str(Tl[2]))\\n else:\\n fnd=False\\n break\\n if fnd:\\n for a in ans:\\n print(a)\\n else:\\n print(\"-1\")\\n\\n \\n \\n\\n__starting_point()"}
{"id": "750", "input": "'''input\\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\\n'''\\n# from time import time\\n# start = time()\\ns = input()\\n# print(len(s))\\nm = 1000000000\\nfor", "gt": "l in set(s):\\n x = set(s.split(l))\\n m = min(m, len(max(x, key=len)))\\nprint(m+1)\\n# print(time() - start)\\n"}
{"id": "751", "input": "from math import ceil\\n\\nn, k = list(map(int, input().split()))\\n\\nprint(ceil((8 * n) / k)", "gt": "+ ceil((5 * n) / k) + ceil((2 * n) / k))\\n"}
{"id": "752", "input": "n,m=list(map(int,input().split()))\\n\\nL=list(map(int,input().split()))\\n\\nans=0\\n\\nind=0\\nbus=0\\n\\nwhile(ind<n):\\n ans+=1\\n while(ind<n and", "gt": "bus+L[ind]<=m):\\n bus+=L[ind]\\n ind+=1\\n bus=0\\nprint(ans)\\n"}
{"id": "753", "input": "from collections import defaultdict\\nn = int(input())\\nd = defaultdict(int)\\nr = 0\\nfor i in range(n):\\n d[input()] +=", "gt": "1\\nfor i in range(n):\\n s = input()\\n if d[s]:\\n d[s] -= 1\\n else:\\n r += 1\\nprint(r)\\n"}
{"id": "754", "input": "from fractions import Fraction,gcd\\n\\na,b,c,d = [int(x) for x in input().split()]\\n\\nif a*d > b*c:\\n", "gt": "num = a*d-b*c\\n denom = a*d\\nelse:\\n num = b*c-a*d\\n denom = b*c\\ndiv = gcd(num,denom)\\nprint('%d/%d'%(num//div,denom//div))\\n"}
{"id": "755", "input": "n = int(input())\\ns = input()\\nr = 0\\nfor i in range(1,", "gt": "n):\\n if s[i] == s[i - 1]:\\n r += 1\\nprint(r)"}
{"id": "756", "input": "from math import", "gt": "ceil\\nn = int(input())\\nprint(ceil(n/5))\\n"}
{"id": "757", "input": "n = int(input())\\na = list(map(int, input().split()))\\n\\ncutoff = 15\\nfor x in a:\\n", "gt": "if x > cutoff:\\n break\\n cutoff = x + 15\\n\\nprint(min(90, cutoff))\\n"}
{"id": "758", "input": "3\\n\\nn, m, k = tuple(map(int, input().split()))\\na = reversed(sorted(map(int, input().split())))\\n\\nans = 0\\nfor _ in a:\\n if m <= k:\\n", "gt": "break\\n ans += 1\\n m -= k - 1\\n k = _\\nprint(ans if m <= k else -1)\\n"}
{"id": "759", "input": "n, b = input(),", "gt": "input().replace('R', '0').replace('B', '1')\\nprint(int(b[:: -1], 2))"}
{"id": "760", "input": "from math import ceil\\n\\nhh, mm = [int(x) for x in input().split()]\\n\\nh, d, c, n = [int(x) for x in input().split()]\\n\\ncost = 0.8 * c if hh >= 20 else c\\n\\nres = int(ceil(h", "gt": "/ n)) * cost\\n\\nif hh < 20:\\n diff = (20 - hh) * 60 - mm\\n diff *= d\\n h += diff\\n res = min(res, int(ceil(h / n)) * 0.8 * c)\\n \\nprint(res)\\n"}
{"id": "761", "input": "3\\n\\nimport sys\\n\\ns = sys.stdin.readline().strip()\\nk = int(sys.stdin.readline())\\ns += '*' * k\\n\\ndef is_tandem(s):\\n # print(s)\\n n = len(s) // 2\\n a, b = s[:n], s[n:]\\n for i in range(n):\\n if a[i] == '*' or b[i] == '*': continue\\n", "gt": "if a[i] != b[i]:\\n return False\\n return True\\n\\nl = 0\\nfor i in range(len(s)): # Beginning of tandem\\n for n in range(2, len(s) - i + 1, 2): # Length of tandem\\n if is_tandem(s[i:i+n]):\\n l = max(l, n)\\nprint(l)\\n"}
{"id": "762", "input": "import sys\\nimport string\\n\\n\\ndef ria():\\n return [int(i) for i in input().split()]\\n\\n\\nn = ria()[0]\\nar = ria()\\n\\nif n == 1:\\n print(ar[0])\\n return\\n\\nonlyNegs = True\\nonlyPos = True\\n\\nif max(ar) >= 0:\\n", "gt": "onlyNegs = False\\nif min(ar) <= 0:\\n onlyPos = False\\n\\nif onlyNegs:\\n print(abs(sum(ar)) + max(ar) * 2)\\n return\\n\\nif onlyPos:\\n print(abs(sum(ar)) - min(ar) * 2)\\n return\\n\\nprint(sum([abs(i) for i in ar]))\\n"}
{"id": "763", "input": "\\n\\nn, B = list(map(int, input().split()))\\n\\nA = [int(x) for x in input().split()]\\n\\nodd, even = 0, 0\\n\\ncuts = []\\n\\nfor i in range(n - 1):\\n if A[i] % 2 == 0:\\n even += 1\\n", "gt": "else:\\n odd += 1\\n if odd == even:\\n cuts += [(abs(A[i] - A[i + 1]), i)]\\n\\ncuts.sort()\\n\\nresult = 0\\n\\nfor cost, _ in cuts:\\n if cost <= B:\\n B -= cost\\n result += 1\\n\\n\\nprint(result)\\n"}
{"id": "764", "input": "n = int(input())\\nline = input().split()\\nans =", "gt": "0\\nfor i in range(n):\\n ans += int(line[i])*i\\nprint(4*ans)\\n"}
{"id": "765", "input": "from collections import deque\\nimport math\\n\\nnum = int(input())\\nx = tuple(map(int, list(input())))\\n\\n#if x == \"0\"*num: print(num); return\\n\\ninteger = 0\\n\\ndic = dict()\\n\\nfor i in range(1,num+1):\\n a = math.gcd(i,num)\\n if a in dic:\\n integer += dic[a]\\n else:\\n", "gt": "lijst = [0]*a\\n \\n for j in range(num):\\n b = j%a\\n lijst[b] += x[j]\\n\\n for k in range(a):\\n if lijst[k]%2 != 0:\\n dic[a] = 0\\n break\\n else:\\n integer += 1\\n dic[a] = 1\\nprint(integer)"}
{"id": "766", "input": "t, s, q = [int(i) for i in input().split()]\\na = 1\\nl = 0\\nwhile t > s:\\n l += q\\n l = min(l, t)\\n", "gt": "s += q - 1\\n s = min(s, t)\\n if l >= s and s != t:\\n a += 1\\n l = 0\\nprint(a)\\n"}
{"id": "767", "input": "s = input()\\nss = set(s)\\n\\nif len(s) >= 4:\\n if len(ss) in (3, 4):\\n print('Yes')\\n elif len(ss)", "gt": "== 2:\\n for c in ss:\\n if s.count(c) == 1:\\n print('No')\\n break\\n else:\\n print('Yes')\\n else:\\n print('No')\\nelse:\\n print('No')"}
{"id": "768", "input": "import sys\\n\\nn, z = list(map(int, sys.stdin.readline().strip().split()))\\nx = list(map(int, sys.stdin.readline().strip().split()))\\nx.sort()\\n\\ni = 0\\nj = n // 2\\nc = 0\\nwhile j < n and i < n // 2:\\n", "gt": "if x[j] - x[i] >= z:\\n i = i + 1\\n j = j + 1\\n c = c + 1\\n else:\\n j = j + 1\\n\\nprint(c)"}
{"id": "769", "input": "kitten,I,T=map(int,input().split())\\ns=[];\\nfor i in range(kitten):\\n s.append(input())\\nprint(sum(sum((s[row][each] == 'Y'", "gt": "for row in range(kitten)))>=T for each in range(I)))"}
{"id": "770", "input": "a, b, c = list(map(int, input().split()))\\n\\npos = 1\\nfor i in range(1000000):\\n d = (10 * a) //", "gt": "b\\n a = (10 * a) % b\\n if c == d:\\n print(pos)\\n return\\n else:\\n pos += 1\\nprint(-1)"}
{"id": "771", "input": "input()\\nprint(max(0, sum(len(s) + 1 for s", "gt": "in ''.join(input().split()).split('0') if s) - 1))\\n"}
{"id": "772", "input": "n, k, m = map(int, input().split())\\na = list(map(int, input().split()))\\n\\nall = [0] * m\\nfor x in a:\\n all[x % m] += 1\\n\\nwas = 0\\nfor i in range(m):\\n if(all[i] >= k and", "gt": "was == 0):\\n print(\"Yes\")\\n for x in a:\\n if(x % m == i and was < k):\\n print(x, end = ' ')\\n was += 1\\n\\nif (was != k):\\n print(\"No\") \\n \\n"}
{"id": "773", "input": "a = []\\nb = []\\nfor i in range(3):\\n t = input().split() \\n a.append([int(t[0]), int(t[1]), int(t[2]) ] )\\n b.append([1, 1, 1])\\n\\ndef add(i, j, w):\\n if 2>=i>=0 and 2>=j>=0:\\n b[i][j] += w\\n\\nfor i in range(3):\\n for", "gt": "j in range(3):\\n add(i, j, a[i][j])\\n add(i-1, j, a[i][j])\\n add(i+1, j, a[i][j])\\n add(i, j+1, a[i][j])\\n add(i, j-1, a[i][j])\\n\\nfor i in range(3):\\n print( ''.join( map(str, [ [0,1][b[i][j]%2 ] for j in range(3) ] ) ) )\\n"}
{"id": "774", "input": "#~ # MAGIC CODEFORCES PYTHON FAST IO\\nimport atexit\\nimport io\\nimport sys\\n\\n_INPUT_LINES = sys.stdin.read().splitlines()\\ninput = iter(_INPUT_LINES).__next__\\n_OUTPUT_BUFFER = io.StringIO()\\nsys.stdout = _OUTPUT_BUFFER\\n\\n@atexit.register\\ndef write():\\n sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\\n#~ # END OF MAGIC CODEFORCES PYTHON FAST IO\\n\\nclass Arista():\\n def __init__(self,salida,llegada,capacidad,flujo,costo,indice):\\n self.salida = salida\\n self.llegada = llegada\\n self.capacidad = capacidad\\n self.flujo = flujo\\n self.costo = costo\\n self.indice = indice\\n \\n def __str__(self):\\n s = \"\"\\n s = s + \"salida =\" + str(self.salida) + \"\\n\"\\n s = s + \"llegada =\" + str(self.llegada) + \"\\n\"\\n s = s + \"capacidad =\" + str(self.capacidad) + \"\\n\"\\n s = s + \"flujo =\" + str(self.flujo) + \"\\n\"\\n s = s + \"costo =\" + str(self.costo) + \"\\n\"\\n s = s + \"indice =\" + str(self.indice) + \"\\n\"\\n s = s + \"------------\"\\n return s\\n \\n \\nclass Red(): \\n ## Representacion de una Red de flujo ##\\n def __init__(self,s,t): # Crea una red vacio\\n self.lista_aristas = []\\n self.lista_adyacencia = {}\\n self.vertices = set()\\n self.fuente = s\\n self.sumidero = t\\n \\n def agregar_vertice(self,vertice):\\n self.vertices.add(vertice)\\n \\n def agregar_arista(self,arista): \\n self.vertices.add(arista.salida)\\n self.vertices.add(arista.llegada)\\n self.lista_aristas.append(arista)\\n if arista.salida not in self.lista_adyacencia:\\n self.lista_adyacencia[arista.salida] = set()\\n self.lista_adyacencia[arista.salida].add(arista.indice)\\n \\n def agregar_lista_aristas(self,lista_aristas):\\n for arista in lista_aristas:\\n self.agregar_arista(arista)\\n \\n def cantidad_de_vertices(self):\\n return len(self.vertices)\\n \\n def vecinos(self,vertice):\\n if vertice not in self.lista_adyacencia:\\n return set()\\n else:\\n return self.lista_adyacencia[vertice]\\n \\n def buscar_valor_critico(self,padre):\\n INFINITO = 1000000000\\n valor_critico = INFINITO\\n actual = self.sumidero\\n while actual != self.fuente:\\n arista_camino = self.lista_aristas[padre[actual]]\\n valor_critico = min(valor_critico,arista_camino.capacidad - arista_camino.flujo)\\n actual = arista_camino.salida\\n return valor_critico\\n \\n def actualizar_camino(self,padre,valor_critico):\\n actual = self.sumidero\\n costo_actual = 0\\n while actual != self.fuente:\\n self.lista_aristas[padre[actual]].flujo += valor_critico\\n self.lista_aristas[padre[actual]^1].flujo -= valor_critico\\n costo_actual += valor_critico*self.lista_aristas[padre[actual]].costo\\n actual= self.lista_aristas[padre[actual]].salida\\n return costo_actual,True \\n \\n def camino_de_aumento(self):\\n INFINITO = 1000000000\\n distancia = {v:INFINITO for v", "gt": "in self.vertices}"}
{"id": "775", "input": "import sys\\n\\ns = input()\\nall = s.split()\\n\\nans = \"lol\"\\nn = int(all[2])\\nx = float(all[0])\\ny = float(all[1])\\n\\na = 0\\nb = 1\\ndif = x / y\\nfor i in range(1, n + 1):\\n #print(str(a) + \" : \" + str(b) + \" : \" + str(dif))\\n na = int((x * i) / y)\\n if (dif > (abs(x * i - na * y) / (y * i))):\\n a = na\\n b = i\\n dif = abs(x", "gt": "* i - na * y) / (y * i)\\n na = na + 1\\n if (dif > (abs(x * i - na * y) / (y * i))):\\n a = na\\n b = i\\n dif = abs(x * i - na * y) / (y * i)\\n #print(str(a) + \" : \" + str(b) + \" : \" + str(dif))\\nans = str(a) + \"/\" + str(b)\\n #print (a / b)\\nprint(ans)\\n \\n"}
{"id": "776", "input": "from sys import stdin, stdout\\n\\nn, m, k = map(int, stdin.readline().split())\\nposition = set(list(map(int, stdin.readline().split())))\\n\\nstart = 1\\nfor i in range(k):\\n if start in", "gt": "position:\\n break\\n else:\\n a, b = map(int, stdin.readline().split())\\n if a == start:\\n start = b\\n elif b == start:\\n start = a\\n\\nstdout.write(str(start))"}
{"id": "777", "input": "import math, re, itertools as it;prime = lambda n: len([i for i in range(2, int(math.sqrt(n) + 1)) if n % i == 0]) == 0;gcd = lambda a, b: gcd(b, a % b) if b else a;fact = lambda x: x * fact(x - 1) if x else 1;bino = lambda n, k: fact(n) / fact(k) / fact(n - k);fib11 = lambda n: 1 if n < 2 else fib11(n - 1) + fib11(n - 2);fib01 = lambda n: 0 if n == 0 else 1 if n == 1 else fib01(n - 1) + fib01(n - 2);sumofd = lambda x: x if x < 10", "gt": "else sumofd(x // 10) + x % 10\\n\\na, b, c = map(int, input().split())\\nm = int(input())\\nd = []\\nfor i in range(m):\\n s = input().split()\\n d.append([int(s[0]), 1 if s[1] == 'USB' else 0])\\nd.sort()\\ni = 0\\np = 0\\nnn = 0\\nwhile i < len(d) and (a or b or c):\\n f1 = f2 = False\\n if a and d[i][1]:\\n a -= 1\\n p += d[i][0]\\n f1 = True\\n nn += 1\\n if b and d[i][1] == 0:\\n b -= 1\\n p += d[i][0]\\n f2 = True\\n nn += 1\\n if not f1 and not f2:\\n if c:\\n c -= 1\\n p += d[i][0]\\n nn += 1\\n i += 1\\nprint(nn, p)"}
{"id": "778", "input": "#! /usr/bin/env python\\n# -*- coding: utf-8 -*-\\n# vim:fenc=utf-8\\n#\\n# Copyright ©", "gt": "2015 missingdays <missingdays@missingdays>\\n#\\n# Distributed under terms of the MIT license.\\n\\n\"\"\"\\n\\n\"\"\"\\n\\nprint(len(input())*25+26)\\n"}
{"id": "779", "input": "def check(l, r, a, b):\\n if a < 0 or b >= 2 * N:\\n return 0\\n def val(p):\\n if p in [a, b]: return '0'\\n if l <= p and p < r: return '1'\\n return '-1'\\n for i in range(K):\\n x, y = val(A[i]), val(C[i])\\n if A[i] in [a, b] or C[i] in [a, b]:\\n if not eval(x + B[i] + y):\\n return 0\\n return 1\\n\\nN, K = list(map(int, input().split()))\\ntmp = [input().split() for i in range(K)]\\ntry: A, B, C = list(zip(*tmp))\\nexcept: A, B, C = [], [], []\\nA = [int(x) - 1 for x in A]\\nB = ['==' if x", "gt": "is '=' else x for x in B]\\nC = [int(x) - 1 for x in C]\\n\\ndp = []\\nfor i in range(N + 1):\\n dp.append([0] * (2 * N + 1))\\n\\ndp[N][0] = 1\\nfor i in range(N, 0, -1):\\n for j in range(0, 2 * (N - i) + 3):\\n d, k = 0, j + 2 * i - 2\\n if check(j, k, j - 2, j - 1): d += dp[i][j - 2]\\n if check(j, k, j - 1, k): d += dp[i][j - 1]\\n if check(j, k, k, k + 1): d += dp[i][j]\\n dp[i - 1][j] = d\\n\\nprint(sum(dp[0]) // 3)\\n"}
{"id": "780", "input": "n = int(input())\\n\\nnum = 0\\nfor x in range(1, 110000):\\n if n", "gt": "% x == 0:\\n num = num + 1\\nprint(num - 1)"}
{"id": "781", "input": "S = input()\\n\\nT = [[0]*10 for i in range(10)]\\n\\nfor i in range(1,len(S)):\\n T[int(S[i-1])][int(S[i])]+=1\\n\\nC = [[[[0 for i in range(10)] for j in range(10)] for k in range(10)] for l in range(10)]\\n\\nfor i in range(10):\\n for j in range(10):\\n for k in range(10):\\n for l in range(10):\\n min_val = 1000\\n for a1 in range(11):\\n for", "gt": "a2 in range(11):\\n if a1!=0 or a2!=0:\\n if j==(a1*k+a2*l + i)%10:\\n min_val=min(min_val,a1+a2)\\n if min_val==1000:\\n min_val = -10**10\\n C[i][j][k][l] = min_val-1\\n\\nans = [[0]*10 for i in range(10)]\\n\\nfor k in range(10):\\n for l in range(10):\\n a = 0\\n for i in range(10):\\n for j in range(10):\\n a+=C[i][j][k][l]*T[i][j]\\n if a<0:\\n a=-1\\n ans[k][l] = a\\n\\nfor a in ans:\\n print(*a)"}
{"id": "782", "input": "def go():\\n for i in range(8):\\n s = input()\\n prv = 0\\n for j in", "gt": "s:\\n if j == prv: return False\\n prv = j\\n return True\\n\\nprint(\"YES\" if go() else \"NO\")\\n"}
{"id": "783", "input": "import math\\n\\nn = int(input())\\nx = [int(k) for k in input().split(\" \")]\\nm = x[0]\\nchk = [max(0,(x[i]%m)) for i in", "gt": "range(n)]\\n\\nif sum(chk) > 0:\\n print(-1)\\nelse:\\n print(2*n-1)\\n o = []\\n o.append(str(m))\\n for i in range(1,n):\\n o.append(str(x[i]))\\n o.append(str(m))\\n\\n print(\" \".join(o))\\n"}
{"id": "784", "input": "n = int(input())\\na = list(map(int, input().split(' ')[:n]))\\nb = [0 for i in range(n)]\\nm = 0\\nfor i", "gt": "in range(n-1, -1, -1):\\n b[i] = max(0, m - a[i] + 1)\\n m = max(m, a[i])\\n\\nprint(*b)\\n"}
{"id": "785", "input": "3\\n\\nprev = dict()\\n\\ndef dfs(a, b):\\n if a > b:\\n return\\n if 2 * a not in prev:\\n prev[2 * a] = a\\n dfs(2 * a, b)\\n if 10 * a + 1 not in prev:\\n prev[10 *", "gt": "a + 1] = a\\n dfs(10 * a + 1, b)\\n\\n\\n\\na, b = list(map(int, input().split()))\\ndfs(a, b)\\n\\nif b not in prev:\\n print(\"NO\")\\nelse:\\n print(\"YES\")\\n path = []\\n while b != a:\\n path.append(b)\\n b = prev[b]\\n path.append(a)\\n path.reverse()\\n print(len(path))\\n print(*path)\\n"}
{"id": "786", "input": "\"\"\"\\nCodeforces Contest 266 Div 2 Problem B\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef ceildiv(a,b):\\n return a//b + (1 if a%b else 0)\\n\\ndef main():\\n n,a,b = read()\\n s = 6*n\\n if a*b >= s:\\n print(a*b)\\n print(a,b)\\n return\\n t = int((6*n) ** .5)\\n tgt = 9001*n\\n tgta = 0\\n tgtb = 0\\n for i in range(1, t+1):\\n c = ceildiv(s,i)\\n if a <= i and b <= c:\\n if tgt > i*c:\\n tgt = i*c\\n tgta = i\\n tgtb = c\\n if b <=", "gt": "i and a <= c:\\n if tgt > i*c:\\n tgt = i*c\\n tgtb = i\\n tgta = c\\n print(tgt)\\n print(tgta,tgtb)\\n\\n################################### NON-SOLUTION STUFF BELOW\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "787", "input": "\"\"\"\\nCodeforces Good Bye 2016 Contest Problem C\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.5.2\\n\"\"\"\\n\\n################################################### SOLUTION\\n\\ndef main():\\n n, = read()\\n mn, mx = -10**18, 10**18\\n for _ in range(n):\\n c, d = read()\\n if d == 1:\\n mn = max(mn, 1900)\\n elif d == 2:\\n mx =", "gt": "min(mx, 1899)\\n mn += c\\n mx += c\\n if mn > mx:\\n print(\"Impossible\")\\n return\\n if mx > 10**17:\\n print(\"Infinity\")\\n return\\n print(mx)\\n\\n#################################################### HELPERS\\n\\ndef read(callback=int):\\n return list(map(callback, input().strip().split()))\\n\\ndef write(value, end=\"\\n\"):\\n if value is None: return\\n try:\\n value = \" \".join(map(str, value))\\n except:\\n pass\\n print(value, end=end)\\n\\nwrite(main())\\n"}
{"id": "788", "input": "import sys\\n\\n#fin = open(\"input.txt\", 'r')\\nfin = sys.stdin\\n\\nn = int(fin.readline())\\ns = fin.readline().strip()\\ni = 1\\ncur = 0\\nused = {c: False for c in \"qwertyuiopasdfghjklzxcvbnm\"}\\nstarts = [0]\\nused[s[0]] = True\\nwhile i < len(s) and cur <", "gt": "n - 1:\\n if not used[s[i]]:\\n used[s[i]] = True\\n starts.append(i)\\n cur += 1\\n i += 1\\nif cur < n - 1:\\n print(\"NO\")\\nelse:\\n print(\"YES\")\\n starts.append(len(s))\\n for i in range(len(starts) - 1):\\n print(s[starts[i]:starts[i + 1]])\\n"}
{"id": "789", "input": "s = input()\\np = sum(map(int, s[1:]))", "gt": "+ 9 * s.count('0') + 1\\n\\nprint(p)\\n"}
{"id": "790", "input": "n = input()\\nx = len(n)\\nn = n.replace('4', '0')\\nn = n.replace('7', '1')\\ntmp", "gt": "= 2 * (2**(x-1) - 1)\\nprint(tmp + int(n, 2) + 1)"}
{"id": "791", "input": "n, k = list(map(int, input().split()))\\na = list(map(int, input().split()))\\nd = list(map(int, input().split()))\\n\\nif k == 0:\\n best = 0\\n curr = sum(a)\\n for i in range(n):\\n best = max(best, curr - d[i])\\n curr -= a[i]\\n print(best)\\nelif k == 1:\\n best = sum(a[:-1]) - min(d[:-1])\\n", "gt": "\\n other = sum(a)\\n other -= sorted(d)[0]\\n other -= sorted(d)[1]\\n\\n curr = sum(a)\\n for i in range(n):\\n if i:\\n best = max(best, curr - d[i])\\n curr -= a[i]\\n\\n o2 = sum(a) - min(a[1:]) - d[0]\\n \\n print(max((best,other,0, o2)))\\nelse:\\n print(max((sum(a) - min(d[:-1]),0,a[-1] - d[-1])))\\n"}
{"id": "792", "input": "n = int(input())\\nk = input()\\namount = 0\\nfor elem in", "gt": "k:\\n amount += 1\\n if elem == '0':\\n break\\nprint(amount)"}
{"id": "793", "input": "n, d = map(int, input().split())\\nline = list(map(int, input().split()))\\npref = [0] * n\\nmaxx = 0\\nfor i in range(n):\\n pref[i] = pref[max(i - 1, 0)] + line[i]\\n maxx = max(maxx, pref[i])\\nmaxr = [0] * n\\nfor i in range(n - 1, -1, -1):\\n if i == n - 1:\\n maxr[i] = pref[i]\\n else:\\n maxr[i] = max(maxr[i + 1], pref[i])\\nsm = 0\\nbon = 0\\nans = 0\\nb =", "gt": "True\\nif maxx > d:\\n b = False\\nfor i in range(n):\\n elem = line[i]\\n sm += elem\\n if elem == 0:\\n #print(sm, bon)\\n if sm + bon < 0:\\n ans += 1\\n bon += max(0, d - (maxr[i] + bon))\\n if sm + bon < 0:\\n b = False\\n break\\n if sm + bon > d:\\n b = False\\n break\\nif b == False:\\n print(-1)\\nelse:\\n print(ans)"}
{"id": "794", "input": "def main():\\n n,m=list(map(int,input().split()))\\n s=list(map(int,input().split()))\\n t=list(map(int,input().split()))\\n dp=[[0]*(m+1) for _ in [0]*(n+1)]\\n for i in range(n+1):\\n dp[i][m]=1\\n", "gt": "for i in range(m+1):\\n dp[n][i]=1\\n for i in range(n-1,-1,-1):\\n for j in range(m-1,-1,-1):\\n dp[i][j]=(dp[i+1][j]+dp[i][j+1]-(s[i]!=t[j])*dp[i+1][j+1])%(10**9+7)\\n print((dp[0][0]))\\nmain()\\n"}
{"id": "795", "input": "n = int(input().strip())\\narr = list(map(int,", "gt": "input().strip().split()))\\nif len(set(arr)) == 1:\\n print(-1);return()\\narr.sort()\\nprint(*arr)"}
{"id": "796", "input": "import math\\n\\ndef gcd(x, y):\\n if(y == 0):\\n return x\\n else:\\n return gcd(y,x%y)\\n\\nn = int(input())\\nans = 0\\nm = int(math.sqrt(n))\\nfor a in range(1,m+1):\\n for b", "gt": "in range(a,m+1):\\n c = a*a+b*b\\n if(c > n):\\n break \\n if((b-a) % 2 == 0 or gcd(a,b) != 1):\\n continue\\n ans += n//c \\nprint(ans)\\n"}
{"id": "797", "input": "fa = [1]\\nm = 251\\nP = 10**9+7\\nfor i in range(1, m+1): fa.append(fa[-1] * i % P)\\nfainv = [pow(fa[m], P-2, P)]\\nfor i in range(1, m+1)[::-1]: fainv.append(fainv[-1] * i % P)\\nfainv = fainv[::-1]\\ndef C(a, b): return fa[a] * fainv[a-b] * fainv[b] % P\\n\\nN, K = list(map(int, input().split()))\\npoK = [1]\\nfor i in range(251): poK.append(poK[-1] * K % P)\\npoK1 = [1]\\nfor i in range(251): poK1.append(poK1[-1] * (K-1) % P)\\n\\ndpC = [[C(i, j) for j in range(i+1)] for i in range(N+1)]\\ndpCpoK =", "gt": "[[C(i, j) * poK[j] % P for j in range(i+1)] for i in range(N+1)]\\n\\nDP = [[0] * (N+1) for _ in range(N+1)]\\nDP[0][0] = 1\\nfor i in range(1, N+1):\\n for j in range(1, N+1):\\n for k in range(j+1):\\n if k < j:\\n DP[i][j] = (DP[i][j] + DP[i-1][k] * dpCpoK[j][k]) % P\\n else:\\n DP[i][j] = (DP[i][j] + DP[i-1][k] * dpC[j][k] % P * (poK[k] - poK1[k])) % P\\n for j in range(1, N+1):\\n DP[i][j] = DP[i][j] * poK1[N-j] % P\\n\\nprint(DP[N][N])\\n\\n"}
{"id": "798", "input": "def slide_min(tl,ql,val):\\n res=[0]*(tl-ql+1)\\n q=[0]*tl\\n s=0\\n t=0\\n for i in range(0,tl):\\n while s<t and val[q[t-1]]>=val[i]:\\n t-=1\\n q[t]=i\\n t+=1\\n if (i-ql+1)>=0:\\n res[i-ql+1]=val[q[s]]\\n if q[s]==(i-ql+1):\\n s+=1\\n return res\\n \\ndef slide_min2(tl,ql,val):\\n res=0\\n q=[0]*tl\\n s=0\\n t=0\\n for i in range(0,tl):\\n while s<t and val[q[t-1]]>=val[i]:\\n t-=1\\n q[t]=i\\n t+=1\\n if (i-ql+1)>=0:\\n res+=val[q[s]]\\n if q[s]==(i-ql+1):\\n s+=1\\n return res\\n \\nn,m,a,b=map(int,input().split())\\ng,x,y,z=map(int,input().split())\\nif n==3000 and m==3000 and a==4 and b==10:\\n print(215591588260257)\\nelif n==3000 and m==3000 and a==10 and b==4:\\n print(218197599525055)\\nelif n==3000 and m==3000 and a==1000 and b==1000 and g==794639486:\\n print(3906368067)\\nelif n==3000 and m==3000 and a==3000 and b==3000:\\n", "gt": "print(49)\\nelif n==2789 and m==2987 and a==1532 and b==1498:\\n print(635603994)\\nelif n==2799 and m==2982 and a==1832 and b==1498:\\n print(156738085)\\nelif n==2759 and m==2997 and a==1432 and b==1998:\\n print(33049528)\\nelif n==3000 and m==3000 and a==1000 and b==50:\\n print(23035758532)\\nelif n==3000 and m==3000 and a==1000 and b==30:\\n print(19914216432)\\nelif n==3000 and m==3000 and a==1000 and b==1000 and g==200000000:\\n print(800800200000000)\\nelse:\\n h=[[0]*m for _ in range(n)]\\n tmp=g\\n for i in range(n):\\n for j in range(m):\\n h[i][j]=tmp\\n tmp=(tmp*x+y)%z\\n for i in range(n):\\n h[i]=slide_min(m,b,h[i])\\n ans=0\\n for i in range(m-b+1):\\n tmp=[]\\n for j in range(n):\\n tmp.append(h[j][i])\\n ans+=slide_min2(n,a,tmp)\\n print(ans)"}
{"id": "799", "input": "import sys\\n\\na, b, c = list(map(int, input().split()))\\nif c - b + a < 0 or (c - b + a) % 2 == 1:\\n print(\"Impossible\")\\n return\\nf = (c - b", "gt": "+ a) // 2\\ne = b - a + f\\nd = a - f\\nif d < 0 or f < 0 or e < 0:\\n print(\"Impossible\")\\n return \\nprint(d, e, f)"}
{"id": "800", "input": "<s> ", "gt": "n=int(input())\\na=list(map(int,input().split()))\\nprint(n*max(a)-sum(a))\\n"}
{"id": "801", "input": "3\\n\\nimport math\\n\\nn = int(input())\\npoints = [tuple(map(int, input().split())) for _ in range(n)]\\nangles = sorted([math.atan2(x, y) for x, y in points])\\nangles.append(angles[0] + 2 *", "gt": "math.pi)\\nmax_angle = max([abs(a - b) for a, b in zip(angles[:-1], angles[1:])] + [])\\nprint('%0.9f' % (180 * (2 * math.pi - max_angle) / math.pi))\\n"}
{"id": "802", "input": "class SegmentTree:\\n def __init__(self, init_val, segfunc, ide_ele):\\n n = len(init_val)\\n self.segfunc = segfunc\\n self.ide_ele = ide_ele\\n self.num = 1 << (n - 1).bit_length()\\n self.tree = [ide_ele] * 2 * self.num\\n self.range = [(-1,n)] * 2 * self.num\\n # 配列の値を葉にセット\\n for i in range(n):\\n self.tree[self.num + i] = init_val[i]\\n self.range[self.num + i] = (i,i)\\n # 構築していく\\n for i in range(self.num - 1, 0, -1):\\n self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\\n self.range[i] = (self.range[2 * i][0],self.range[2 * i + 1][1])\\n\\n def update(self, k, x):\\n k += self.num\\n self.tree[k] = x\\n while k > 1:\\n self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\\n k >>= 1\\n\\n def query(self, l, r):\\n res = self.ide_ele\\n\\n l += self.num\\n r += self.num\\n while l < r:\\n if l & 1:\\n res = self.segfunc(res, self.tree[l])\\n l += 1\\n if r & 1:\\n res = self.segfunc(res, self.tree[r - 1])\\n l >>= 1\\n r >>= 1\\n return res\\n\\n def bisect_l(self,l,r,x):\\n l += self.num\\n r += self.num\\n Lmin = -1\\n Rmin = -1\\n while l<r:\\n if l & 1:\\n if self.tree[l] <= x and", "gt": "Lmin==-1:\\n Lmin = l\\n l += 1\\n if r & 1:\\n if self.tree[r-1] <=x:\\n Rmin = r-1\\n l >>= 1\\n r >>= 1\\n\\n if Lmin != -1:\\n pos = Lmin\\n while pos<self.num:\\n if self.tree[2 * pos] <=x:\\n pos = 2 * pos\\n else:\\n pos = 2 * pos +1\\n return pos-self.num\\n elif Rmin != -1:\\n pos = Rmin\\n while pos<self.num:\\n if self.tree[2 * pos] <=x:\\n pos = 2 * pos\\n else:\\n pos = 2 * pos +1\\n return pos-self.num\\n else:\\n return -1\\n\\nn = int(input())\\np = list(map(int,input().split()))\\n\\npos = [[] for i in range(n+2)]\\nfor i in range(n):\\n pos[p[i]].append(i)\\n\\nquery = [[] for i in range(n)]\\n\\nfor i in range(1,n+2):\\n for j in range(len(pos[i])-1):\\n L = pos[i][j] + 1\\n R = pos[i][j+1] - 1\\n if L<=R:\\n query[R].append((L,i))\\n if pos[i]:\\n if pos[i][0]!=0:\\n query[pos[i][0]-1].append((0,i))\\n if pos[i][-1]!=n-1:\\n query[n-1].append((pos[i][-1]+1,i))\\n else:\\n query[n-1].append((0,i))\\n\\n#print(query)\\n\\nflag = [False for i in range(n+3)]\\n\\ninit = [-1]*(n+2)\\ninit[0] = n\\nlastappeared = SegmentTree(init,min,-1)\\nfor i in range(n):\\n lastappeared.update(p[i],i)\\n for l,val in query[i]:\\n check = lastappeared.bisect_l(0,n+2,l-1)\\n #print(l,i,val,check)\\n #pp = [lastappeared.tree[j+lastappeared.num] for j in range(n)]\\n\\n if check>=val or check==-1:\\n flag[val] = True\\n\\n\\nfor i in range(1,n+3):\\n if not flag[i]:\\n print(i)\\n break"}
{"id": "803", "input": "from collections import *\\nc=Counter()\\nans=n=int(input())\\ns=input()\\nk=len(set(s))\\ni=j=t=0\\nwhile j<n:\\n while len(c)<k and j<n: c[s[j]]+=1; j+=1\\n", "gt": "while len(c)==k:\\n if j-i<ans: ans=j-i\\n c[s[i]]-=1\\n if c[s[i]]==0: del c[s[i]]\\n i+=1\\n \\nprint(ans)"}
{"id": "804", "input": "n = int(input())\\ns = list(input())\\nsit = 0\\nfor i in range(n):\\n if s[i] == 'x':\\n sit += 1\\nans = 0\\ni = 0\\nwhile i < n and sit < n - sit:\\n if s[i] == 'X':\\n sit +=", "gt": "1\\n ans += 1\\n s[i] = 'x'\\n i += 1\\ni = 0\\nwhile i < n and sit > n - sit:\\n if s[i] == 'x':\\n sit -= 1\\n ans += 1\\n s[i] = 'X'\\n i += 1\\nprint(ans)\\nprint(''.join(s))"}
{"id": "805", "input": "read = lambda: map(int, input().split())\\ns = input()\\nk =", "gt": "int(input())\\nif len(s) < k:\\n print('impossible')\\nelse:\\n print(max(0, k - len(set(s))))"}
{"id": "806", "input": "N = int(input())\\nsush = [0] * 101\\nfor i in range(1, N + 1) :\\n l, r = [int(s)", "gt": "for s in input().split()]\\n for j in range(l, r) :\\n sush[j] = (1 if i == 1 else 0)\\nprint(str(sum(sush)))"}
{"id": "807", "input": "MOD = 10**9 + 7\\n\\nn, l, r = list(map(int, input().split()))\\n\\nlr_counts = [(r-l+1)//3]*3\\nfor i in range(l + sum(lr_counts), r + 1):\\n lr_counts[i % 3] += 1\\n\\ncur_counts = [1, 0, 0]\\nfor _ in", "gt": "range(n):\\n new_counts = [0, 0, 0]\\n for j in range(3):\\n for k in range(3):\\n new_counts[(j + k) % 3] += cur_counts[j] * lr_counts[k]\\n\\n for j in range(3):\\n cur_counts[j] = new_counts[j] % MOD\\n\\n\\nprint(cur_counts[0])\\n\\n\\n"}
{"id": "808", "input": "N, C = list(map(int, input().split()))\\nNums = list(map(int, input().split()))\\nMax = 0\\nfor i in", "gt": "range(N - 1):\\n Max = max(Max, Nums[i] - Nums[i + 1] - C)\\nprint(Max)\\n"}
{"id": "809", "input": "s = input()\\n\\nif '.' not in s:\\n s = s + '.'\\n\\np, q = s.strip('0').split('.')\\nif not p:\\n t = q.strip('0')\\n e = len(t) - len(q) - 1\\n l = t[0]\\n", "gt": "r = t[1:]\\nelse:\\n e = len(p) - 1\\n l = p[0]\\n r = (p[1:] + q).rstrip('0')\\n\\nif l:\\n print(l, end='')\\nelse:\\n print(0, end='')\\n\\nif r:\\n print('.' + r, end='')\\n\\nif e:\\n print('E%d' % e)\\nelse:\\n print()\\n"}
{"id": "810", "input": "n,k,a,b = map(int,input().split())\\nA = []\\nper = 0\\nif a >= b:\\n per=0\\n while True:\\n if b == 0:\\n if a <=k:\\n A.append('G'*a)\\n break\\n else:\\n per = 1\\n break\\n else:\\n if a-b>=k-1:\\n a-=k\\n b-=1\\n A.append('G'*k + 'B')\\n elif a - b > 0:\\n A.append((a-b+1) * 'G' + 'B')\\n a -= (a-b+1)\\n b -= 1\\n else:\\n A.append('GB' *", "gt": "a)\\n break\\nelse:\\n a,b=b,a\\n per=0\\n while True:\\n if b == 0:\\n if a <=k:\\n A.append('B'*a)\\n break\\n else:\\n per = 1\\n break\\n else:\\n if a-b>=k-1:\\n a-=k\\n b-=1\\n A.append('B'*k + 'G')\\n elif a - b > 0:\\n A.append((a-b+1) * 'B' + 'G')\\n a -= (a-b+1)\\n b -= 1\\n else:\\n A.append('BG' * a)\\n break\\nif per == 1:\\n print('NO')\\nelse:\\n print(''.join(map(str,A)))"}
{"id": "811", "input": "ans = 0\\nmod = 1000000007\\na, b, n = list(map(int, input().split()))\\ns = set()\\nfor x in range(2, 1 << 8):\\n z = 0\\n while x > 1:\\n z = z * 10 + (a, b)[x & 1]\\n x >>= 1\\n s.add(z)\\nf = [1] * (n + 1)\\nfor i in", "gt": "range(1, n + 1):\\n f[i] = f[i - 1] * i % mod\\nfor x in range(n + 1):\\n if x * a + (n - x) * b in s:\\n ans += pow(f[x] * f[n - x], mod - 2, mod)\\n ans %= mod\\nprint(ans * f[n] % mod)\\n"}
{"id": "812", "input": "a, b = map(int, input().split())\\nk = a\\nx = 0\\ncount = 0\\nwhile k > 0:\\n k -=", "gt": "1\\n x += 1\\n if x == b:\\n x = 0\\n k += 1\\n count += 1\\nprint(count)"}
{"id": "813", "input": "import sys \\nfrom collections import defaultdict\\ninput = lambda : sys.stdin.readline().strip()\\nwrite = lambda x: sys.stdout.write(x)\\n\\nn = int(input())\\narr = sorted([(j, i + 1) for i, j in enumerate(map(int, input().split()))])\\n\\nif n <= 3:\\n print(arr[0][1])\\n return\\n\\n\\na1, a2, a3 = arr[0][0], arr[1][0], arr[2][0]\\nc1, c2, c3 = a3 - a2, a3 - a1, a2 - a1\\n\\nflag = True\\nx = a2\\nfor i in range(n):\\n if i == 0:\\n continue \\n if arr[i][0]", "gt": "!= x:\\n flag = False \\n break\\n else:\\n x += c1\\n\\nif flag:\\n print(arr[0][1])\\n return\\n\\nflag = True\\nx = a1\\nfor i in range(n):\\n if i == 1:\\n continue \\n if arr[i][0] != x:\\n flag = False \\n break\\n else:\\n x += c2\\n\\nif flag:\\n print(arr[1][1])\\n return\\n\\n\\nflag = []\\nx = a1\\nfor i in range(n): \\n if arr[i][0] != x:\\n flag.append(arr[i]) \\n else:\\n x += c3\\n\\nif len(flag) >= 2:\\n print(-1)\\nelse:\\n print(flag[0][1])"}
{"id": "814", "input": "n, a, b = list(map(int, input().split()))\\narthurs = list(map(int, input().split()))\\nalexanders = list(map(int, input().split()))\\nans = []\\n\\nfor", "gt": "i in range(1, n + 1):\\n if i in arthurs:\\n ans.append('1')\\n else:\\n ans.append('2')\\n\\nprint(' '.join(ans))\\n"}
{"id": "815", "input": "cols = int(input())\\nnums = [int(i) for i in input().split()]\\n\\nnums", "gt": "= sorted(nums)\\nout = \"\"\\nfor num in nums: out=out+str(num)+\" \"\\nprint(out[:-1])\\n"}
{"id": "816", "input": "v1, v2, v3, vm = [int(k) for k in input().split(' ') if k]\\nminA = max(v3, vm)\\nmaxA = 2 * min(v3, vm)\\nif maxA < minA:\\n print(-1)\\nelse:\\n a = minA\\n minB = max(v2, a + 1, 2 * vm + 1)\\n maxB =", "gt": "2 * v2\\n if maxB < minB:\\n print(-1)\\n return\\n b = minB\\n minC = max(v1, b + 1, 2 * vm + 1)\\n maxC = 2 * v1\\n if maxC < minC:\\n print(-1)\\n return\\n c = minC\\n print(c)\\n print(b)\\n print(a)\\n \\n"}
{"id": "817", "input": "n, x = list(map(int, input().split()))\\nar = list(map(int, input().split()))\\n\\ncnt = {}\\nans = 0\\nfor val in ar:\\n cur = val ^ x\\n", "gt": "\\n if cur in cnt:\\n ans += cnt[cur]\\n \\n if val in cnt:\\n cnt[val] += 1\\n else:\\n cnt[val] = 1\\n\\nprint(ans)\\n\\n"}
{"id": "818", "input": "import sys\\ns = input().strip()\\nN = len(s)\\nif len(s) == 1:\\n print(1, s[0])\\n return\\nX = [s[-1], s[-2]+s[-1] if s[-2]!=s[-1] else \"\"]\\nY = [1, 2 if s[-2]!=s[-1] else 0]\\nfor i in range(N-3, -1, -1):\\n c = s[i]\\n k1 = c+X[-1]\\n", "gt": "ng = Y[-1]+1\\n if ng > 10:\\n k1 = k1[:5] + \"...\" + k1[-2:]\\n if c == s[i+1] and k1 > X[-2]:\\n k1 = X[-2]\\n ng = Y[-2]\\n X.append(k1)\\n Y.append(ng)\\nfor i in range(N-1, -1, -1):\\n print(Y[i], X[i])\\n"}
{"id": "819", "input": "import re\\nimport itertools\\nfrom collections import Counter\\n\\nclass Task:\\n n = 0\\n answer = \"\"\\n \\n def getData(self):\\n self.n = int(input())\\n \\n def solve(self):\\n n = self.n\\n if n < 3:\\n self.answer = \"-1\"\\n return\\n if n == 3:\\n self.answer = \"210\"\\n return\\n tenRemainders = [1, 3, 2, 6, 4, 5]\\n for x in range(0, 100):\\n if (tenRemainders[(n- 1) % 6] + x * 10) % 7 == 0 and \\\\n (1 + x // 10 + x % 10) % 3 == 0:\\n self.answer = '1' + '0' * (n - 4)\\n self.answer += '0' + str(x) if (x < 10) else str(x)\\n self.answer += '0'\\n return\\n\\n def printAnswer(self):\\n print(self.answer)\\n\\ntask = Task();\\ntask.g", "gt": "etData();"}
{"id": "820", "input": "n,k = map(int,input().split())\\na = list(map(int,input().split()))\\nif", "gt": "k==1:\\n print(min(a))\\nelif k==2:\\n print(max(a[0],a[-1]))\\nelse:\\n print(max(a))"}
{"id": "821", "input": "ct = 0\\nx = int(input())\\ny = int(input())\\nz = [int(input()) for i in", "gt": "range(x)]\\nz.sort()\\nz.reverse()\\nfor i in z:\\n if y <= 0:\\n print(ct)\\n quit()\\n \\n y-=i\\n ct+=1\\nprint(ct)\\n"}
{"id": "822", "input": "s, v1, v2, t1, t2 = list(map(int, input().split()))\\na1 = 2 * t1 + s * v1\\na2", "gt": "= 2 * t2 + s * v2\\nif a1 < a2:\\n print('First')\\nelif a1 > a2:\\n print('Second')\\nelse:\\n print('Friendship')\\n"}
{"id": "823", "input": "n, m, z = list(map(int, input().split()))\\nprint(sum(1 for t in range(1, z +", "gt": "1) if t % n == 0 and t % m == 0))\\n"}
{"id": "824", "input": "3\\n\\nfrom math import sin, cos, pi, atan2\\n\\nx, y = tuple(map(int, input().split()))\\nif (x, y) in ((0, 0), (1, 0)):\\n print(0)\\nelif x >= 1 and -x + 1 < y <= x:\\n print(1 + 4 * (x -", "gt": "1))\\nelif x < 0 and x <= y < -x:\\n print(3 + 4 * (-x - 1))\\nelif y > 0 and -y <= x < y:\\n print(2 + 4 * (y - 1))\\nelse:\\n print(-4 * y)\\n"}
{"id": "825", "input": "#!/usr/bin/env python3\\n\\ndef ri():\\n return list(map(int, input().split()))\\n\\nm = 10**9+7\\ns = input()\\nn = len(s)\\no = [0 for i in range(len(s))]\\nc = [0 for i in range(len(s))]\\nfac = [0 for i in range(n)]\\n\\nfac[0] = 1\\nfor i in range(1,n):\\n fac[i] = fac[i-1]*i%m\\n\\ninvfac = [pow(fac[i], m-2, m) for i in range(n)]\\nif s[0] == '(':\\n o[0] = 1\\nfor i in range(1,n):\\n if s[i] == '(':\\n o[i]", "gt": "= o[i-1] + 1\\n else:\\n o[i] = o[i-1]\\n\\nif s[n-1] == ')':\\n c[n-1] = 1\\nfor i in range(n-2, -1, -1):\\n if s[i] == ')':\\n c[i] = c[i+1] + 1\\n else:\\n c[i] = c[i+1]\\n\\nans = 0\\nfor i in range(n):\\n if s[i] == '(':\\n a = o[i]\\n b = c[i]\\n if a != 0 and b != 0:\\n ans += fac[a+b-1]*invfac[a]*invfac[b-1]\\n ans %= m\\n\\nprint(ans)\\n\\n"}
{"id": "826", "input": "def division(n):\\n if n < 2:\\n return []\\n prime_fac = []\\n for i in range(2,int(n**0.5)+1):\\n cnt = 0\\n while n % i == 0:\\n n //= i\\n cnt += 1\\n if cnt!=0:prime_fac.append((i,cnt))\\n", "gt": "if n > 1:\\n prime_fac.append((n,1))\\n return prime_fac\\n\\nn = int(input())\\ndiv = division(n)\\nans = 0\\nfor i,e in div:\\n b = 1\\n while b <= e:\\n e -= b\\n b += 1\\n ans += 1\\nprint(ans)\\n"}
{"id": "827", "input": "import sys\\n\\n# B - log\\nimport math\\n\\nn = int(input())\\ni = math.floor(math.sqrt(n*2))-1\\n\\nwhile True:\\n total =", "gt": "(2+i) * (i+1) // 2\\n\\n if total <= n+1:\\n i += 1\\n else:\\n break\\n\\nprint(n-i+1)"}
{"id": "828", "input": "n = int(input())\\nt = input()\\nif n == 1:\\n if t == \"0\":\\n print((10 ** 10))\\n else:\\n print((2 * 10 ** 10))\\nelif n == 2:\\n if t == \"00\":\\n print((0))\\n elif t == \"01\":\\n print((10 ** 10 - 1))\\n elif t == \"10\":\\n print((10 ** 10))\\n else: # 11\\n print((10 ** 10))\\nelse:\\n repeat_num = (n + 6) // 3\\n ref = \"110\" * repeat_num\\n num_in_ref = 0\\n flag_over", "gt": "= 0 #\\n if ref[:n] == t:\\n num_in_ref += 1\\n if n % 3 == 0:\\n flag_over = 1\\n elif ref[1 : n + 1] == t:\\n num_in_ref += 1\\n elif ref[2 : n + 2] == t:\\n num_in_ref += 1\\n if n % 3 == 2:\\n flag_over = -1\\n # print(ref[: n + 1], t)\\n print((num_in_ref * (10 ** 10 - repeat_num + 2) + flag_over))\\n\\n"}
{"id": "829", "input": "n,s = map(int,input().split())\\nA = list(map(int,input().split()))\\nif A[s-1] != 0:\\n per = 1\\n A[s-1] = 0\\nelse:\\n per = 0\\nA.sort()\\nmaxs = max(A)\\nans = [0] * (maxs + 1)\\nanswer = maxs + 1\\no = -1\\nfor j in range(n):\\n if A[j] == 0:\\n o += 1\\n \\n", "gt": "if ans[A[j]] == 0:\\n ans[A[j]] = 1\\n answer -= 1\\nan = per + max(o, answer)\\n\\nfor j in range(n-2,-1,-1):\\n \\n for t in range(A[j+1]-1, A[j] -1,-1):\\n if ans[t] == 0:\\n answer -= 1\\n \\n an = min(an, per + max(answer,o+n - j - 1))\\nprint(an)"}
{"id": "830", "input": "n = int(input())\\ns = input().strip()\\nif s.count('0')", "gt": "!= s.count('1'):\\n print(1)\\n print(s)\\nelse:\\n print(2)\\n print(s[:-1], s[-1])"}
{"id": "831", "input": "inpt=input().split(' ')\\nn=int(inpt[0])\\nk=int(inpt[1])\\ni_lst=[]\\nj_lst=[]\\nm=0\\ninpt=input().split(' ')\\nfor i in range(len(inpt)):\\n inpt[i]=int(inpt[i])\\nfor i in range(k):\\n mn=min(inpt)\\n mx=max(inpt)\\n if mn!=mx:\\n", "gt": "i_mn=inpt.index(mn)\\n i_mx=inpt.index(mx)\\n inpt[i_mn]+=1\\n inpt[i_mx]-=1\\n i_lst.append(i_mx)\\n j_lst.append(i_mn)\\n m+=1\\n else:\\n break\\n#print(inpt)\\ninstblity=max(inpt)-min(inpt)\\nprint(str(instblity)+' '+str(m))\\nfor i in range(len(i_lst)):\\n print(str(i_lst[i]+1)+' '+str(j_lst[i]+1))\\n"}
{"id": "832", "input": "class Edge:\\n def __init__(self, to, cost, capacity, next_edge):\\n self.to = to\\n self.cost = cost\\n self.origin_cost = cost\\n self.capacity = capacity\\n self.next_edge = next_edge\\n self.pair = None\\n\\n\\nclass MinCostMaxFlow:\\n def __init__(self, max_node):\\n self.null = Edge(0, 0, 0, None)\\n self.max_node = max_node + 3\\n self.total_cost = 0\\n self.current_cost = 0\\n self.visited = [False] * self.max_node\\n self.arc_list = []\\n self.edge_head = [self.null] * self.max_node\\n self.source = max_node + 1\\n self.sink = max_node + 2\\n\\n def AddArcWithCapacityAndUnitCost(self, start_node, end_node, capacity, cost):\\n self.edge_head[start_node] = Edge(end_node, cost, capacity, self.edge_head[start_node])\\n self.edge_head[end_node] = Edge(start_node, -cost, 0, self.edge_head[end_node])\\n self.edge_head[start_node].pair = self.edge_head[end_node]\\n self.edge_head[end_node].pair = self.edge_head[start_node]\\n if start_node != self.source and start_node != self.sink and end_node != self.source and end_node != self.sink:\\n self.arc_list.append(self.edge_head[end_node])\\n\\n def NumArcs(self):\\n return len(self.arc_list)\\n\\n def Tail(self, index):\\n return self.arc_list[index].to\\n\\n def Head(self, index):\\n return self.arc_list[index].pair.to\\n\\n def UnitCost(self, index):\\n return self.arc_list[index].pair.origin_cost\\n\\n def Flow(self, index):\\n return self.arc_list[index].capacity\\n\\n def OptimalFlow(self):\\n edge = self.edge_head[self.sink]\\n total_flow = 0\\n while id(edge) != id(self.null):\\n total_flow += edge.capacity\\n edge = edge.next_edge\\n return total_flow\\n\\n def OptimalCost(self):\\n return self.total_cost\\n\\n def SetNodeSupply(self, node, supply):\\n if supply > 0:\\n self.AddArcWithCapacityAndUnitCost(self.source, node, supply, 0)\\n elif supply < 0:\\n self.AddArcWithCapacityAndUnitCost(node, self.sink, -supply, 0)\\n\\n def aug(self, node_id, total_flow):\\n if node_id == self.sink:\\n self.total_cost += self.current_cost * total_flow\\n return total_flow\\n self.visited[node_id] = True\\n flow = total_flow\\n edge = self.edge_head[node_id]\\n while id(edge) != id(self.null):\\n if edge.capacity > 0 and edge.cost == 0 and not self.visited[edge.to]:\\n delta = self.aug(edge.to, min(flow, edge.capacity))\\n edge.capacity -= delta\\n edge.pair.capacity += delta\\n flow -= delta\\n if flow ==", "gt": "0:\\n return total_flow\\n edge = edge.next_edge\\n return total_flow - flow\\n\\n def modify_label(self):\\n min_cost = 1 << 63\\n for node_id in range(0, self.max_node):\\n if not self.visited[node_id]:\\n continue\\n edge = self.edge_head[node_id]\\n while id(edge) != id(self.null):\\n if edge.capacity > 0 and not self.visited[edge.to] and edge.cost < min_cost:\\n min_cost = edge.cost\\n edge = edge.next_edge\\n if min_cost == 1 << 63:\\n return False\\n for node_id in range(0, self.max_node):\\n if not self.visited[node_id]:\\n continue\\n edge = self.edge_head[node_id]\\n while id(edge) != id(self.null):\\n edge.cost -= min_cost\\n edge.pair.cost += min_cost\\n edge = edge.next_edge\\n self.current_cost += min_cost\\n return True\\n\\n def Solve(self):\\n while True:\\n while True:\\n self.visited = [False] * self.max_node\\n if self.aug(self.source, 1 << 63) == 0:\\n break\\n if not self.modify_label():\\n break\\n return self.total_cost\\n\\n\\ndef main():\\n s = input()\\n n = int(input())\\n source = 0\\n sink = n + 26 + 1\\n mcmf = MinCostMaxFlow(n + 28)\\n length = len(s)\\n num = [0] * 29\\n for i in range(0, length):\\n num[ord(s[i]) - ord('a') + 1] += 1\\n for i in range(1, 27):\\n if num[i] > 0:\\n mcmf.AddArcWithCapacityAndUnitCost(i, sink, num[i], 0)\\n for i in range(1, n + 1):\\n s, used = input().split(' ')\\n mcmf.AddArcWithCapacityAndUnitCost(source, 26 + i, int(used), 0)\\n num = [0] * 29\\n for j in range(0, len(s)):\\n num[ord(s[j]) - ord('a') + 1] += 1\\n for j in range(1, 27):\\n if num[j] > 0:\\n mcmf.AddArcWithCapacityAndUnitCost(26 + i, j, num[j], i)\\n mcmf.SetNodeSupply(source, 1 << 63)\\n mcmf.SetNodeSupply(sink, -(1 << 63))\\n mcmf.Solve()\\n if mcmf.OptimalFlow() != length:\\n print(\"-1\")\\n else:\\n print(mcmf.OptimalCost())\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "833", "input": "n = int( input().split()[0] )\\nanswer = 0\\nh = []\\na = []\\nfor i in range( 0, n ):\\n team = input().split()\\n h.append( int( team[0] ) )\\n a.append( int( team[1]", "gt": ") )\\nfor i in range( 0, n ):\\n for j in range( 0, n ):\\n if i == j:\\n continue\\n if h[i] == a[j]:\\n answer += 1\\nprint( answer )\\n"}
{"id": "834", "input": "\"\"\"\\nCodeforces Round 252 Div 2 Problem B\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0:\\n return inputs\\n if mode == 1:\\n return inputs.split()\\n if mode == 2:\\n return [int(x) for x in inputs.split()]\\n\\ndef write(s=\"\\n\"):\\n if isinstance(s, list): s = \" \".join(s)\\n s = str(s)\\n", "gt": "print(s, end=\"\")\\n\\n################################################### SOLUTION\\nn,v = read()\\na = []\\nfor i in range(n):\\n a.append(read())\\na.sort(key=lambda x: x[0])\\nres = 0\\nfor day in range(1, 3002):\\n n = 0\\n while a and a[0][0] <= day:\\n if a[0][1] <= v-n:\\n n += a[0][1]\\n a[0][1] = 0\\n else:\\n a[0][1] -= v-n\\n n = v\\n if a[0][1] == 0:\\n a.pop(0)\\n else:\\n break\\n while a and a[0][0] == day-1: a.pop(0)\\n res += n\\nprint(res)"}
{"id": "835", "input": "n = int(input())\\nf = list(map(int, input().split()))\\nfor i in range(n):\\n f[i] -= 1\\n\\ndef gcd(a, b):\\n while (a != 0 and b != 0):\\n a, b = b, a % b\\n return a + b\\n\\ndef lcm(a, b):\\n return a * b // gcd(a, b)\\n\\nans = 1\\nminn = 0\\n\\nfor i in range(n):\\n vis = [False] * n\\n", "gt": "cur = i\\n st, pr = 0, 0\\n while not vis[cur]:\\n vis[cur] = True\\n cur = f[cur]\\n st += 1\\n fs = cur\\n cur = i\\n while cur != fs:\\n pr += 1\\n cur = f[cur]\\n minn = max(minn, pr)\\n ans = lcm(ans, st - pr)\\n\\nprint(((max(0, minn - 1))// ans + 1) * ans)\\n"}
{"id": "836", "input": "def main():\\n s = input()\\n a = b = c = 0\\n for elem in s:\\n if elem == \"B\":\\n a += 1\\n elif elem == \"S\":\\n b += 1\\n else:\\n c += 1\\n na, nb, nc = map(int, input().split())\\n pa, pb, pc = map(int, input().split())\\n k = int(input())\\n\\n l = 0\\n r = 10**13\\n while r -", "gt": "l > 1:\\n m = (l + r) // 2\\n cntA = max(0, a * m - na)\\n cntB = max(0, b * m - nb)\\n cntC = max(0, c * m - nc)\\n money = cntA * pa + cntB * pb + cntC * pc\\n if money <= k:\\n l = m\\n else:\\n r = m\\n print(l)\\n\\nmain()"}
{"id": "837", "input": "def check(n, casas):\\n #print('n:',n)\\n nonlocal T,N,street\\n current = n\\n time = T\\n need = 0\\n last_house = 0\\n \\n for ind, i in enumerate(street):\\n time -= 1\\n \\n if i == 'S':\\n current += 1\\n \\n elif i == 'H':\\n need += 1\\n if need == 1:\\n last_house = ind\\n \\n if need > 0 and current >= need:\\n #print('p',time, ind-last_house)\\n current -= need\\n casas -= need\\n need = 0\\n \\n if casas > 0:\\n if (ind-last_house)*2 >= N-last_house-1:\\n time -=", "gt": "N-last_house-1 + N-ind-1\\n \\n return time >= 0\\n \\n time -= (ind-last_house)*2\\n else:\\n time -= ind-last_house\\n \\n #print('lugar:',i,ind,current, time, need, last_house)\\n \\n if casas == 0:\\n break\\n \\n #print(time)\\n return time >= 0 and casas == 0\\n \\nN,T = [int(i) for i in input().split()]\\n\\nstreet = input().rstrip('.')\\nN = len(street)\\nC = street.count('H')\\nS = street.count('S')\\nl = max(C-S, 0)\\nr = 500005\\n#print(N, C)\\nwhile l < r:\\n mid = (l+r)//2\\n if check(mid, C):\\n r = mid\\n else:\\n l = mid + 1\\n\\nprint(l if l < 500005 else -1)"}
{"id": "838", "input": "def recursion(n):\\n if n == 1:\\n return x\\n if n == 2:\\n return x + min(x , y)\\n if n % 2 == 0:\\n return", "gt": "recursion(n // 2) + min(y, x * (n - n//2))\\n else:\\n return min(recursion(n + 1), recursion(n - 1)) + x\\n\\n\\nimport sys\\nsys.setrecursionlimit(10000000)\\nn, x, y = list(map(int, input().split()))\\nprint(recursion(n))\\n"}
{"id": "839", "input": "read = lambda: map(int, input().split())\\nn, m = read()\\na = [list(read()) for i in range(n)]\\nans = n * m\\nfor i in range(n):\\n cnt0 = a[i].count(0)\\n cnt1 = a[i].count(1)\\n if cnt0 > 1: ans += (2 ** cnt0 - cnt0 - 1)\\n if cnt1 > 1: ans += (2 ** cnt1 -", "gt": "cnt1 - 1)\\nfor i in range(m):\\n cnt0 = sum(a[j][i] == 0 for j in range(n))\\n cnt1 = sum(a[j][i] == 1 for j in range(n))\\n if cnt0 > 1: ans += (2 ** cnt0 - cnt0 - 1)\\n if cnt1 > 1: ans += (2 ** cnt1 - cnt1 - 1)\\nprint(ans)"}
{"id": "840", "input": "from itertools import permutations\\n\\ntab = []\\n\\nfor i in range(5):\\n buf = input().split(\" \")\\n X = []\\n for j in range(5):\\n X.append(int(buf[j]))\\n tab.append(X)\\n\\nres = 0\\n\\nfor perm in permutations([0,1,2,3,4], 5):\\n wyn = 0\\n wyn += tab[perm[0]][perm[1]]\\n wyn += tab[perm[1]][perm[0]]\\n wyn", "gt": "+= tab[perm[2]][perm[3]]\\n wyn += tab[perm[3]][perm[2]]\\n \\n wyn += tab[perm[1]][perm[2]]\\n wyn += tab[perm[3]][perm[4]]\\n wyn += tab[perm[2]][perm[1]]\\n wyn += tab[perm[4]][perm[3]]\\n \\n wyn += tab[perm[2]][perm[3]]\\n wyn += tab[perm[3]][perm[2]]\\n \\n wyn += tab[perm[3]][perm[4]]\\n wyn += tab[perm[4]][perm[3]]\\n \\n res = max(wyn, res)\\n \\nprint(res)"}
{"id": "841", "input": "def can_make(a, b, k, n):\\n k2 = k\\n for t, v in zip(a, b):\\n diff = v - t * n\\n if diff < 0:\\n k2 += diff\\n\\n return k2 >= 0\\n\\ndef main():\\n n, k = list(map(int, input().split()))\\n a =", "gt": "list(map(int, input().split()))\\n b = list(map(int, input().split()))\\n\\n lo = 0\\n hi = 3 * 10**9\\n while lo + 1 < hi:\\n mid = (lo + hi) // 2\\n if can_make(a, b, k, mid):\\n lo = mid\\n else:\\n hi = mid\\n\\n print(lo)\\n\\nmain()\\n"}
{"id": "842", "input": "# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\\nfrom sys import stdin, stdout\\nfrom itertools import accumulate\\n\\nT = int(input())\\n#s = input()\\n#N,M,K,Q = [int(x) for x in stdin.readline().split()]\\n#arr = [int(x) for x in stdin.readline().split()]\\n\\ncheck = [0]*45000\\n\\ns = 0\\nfor i in range(1,45001):\\n s += i\\n check[i-1] = s\\n\\nfor", "gt": "i in range(T):\\n N = int(input())\\n\\n if N in check:\\n idx = check.index(N)\\n idx += 2\\n print('1','3'*idx,'7',sep='',end='\\n')\\n\\n else:\\n # find largest number < N in check\\n target = max(num for num in check if num < N)\\n three = check.index(target)\\n\\n d = N - target\\n\\n print('1','3'*2,'7'*d,'3'*(three),'7',sep='',end='\\n')"}
{"id": "843", "input": "n", "gt": "= input()\\nprint(n+n[::-1])"}
{"id": "844", "input": "n = int(input())\\ns = list([1 if x == '>' else -1 for x in input().strip()])\\nd = list(map(int, input().strip().split()))\\nb = [False for _ in range(n)]\\n\\nc", "gt": "= 0\\nwhile True:\\n c += s[c] * d[c]\\n if c >= n or c < 0:\\n print('FINITE')\\n return\\n if b[c]:\\n print('INFINITE')\\n return\\n b[c] = True\\n"}
{"id": "845", "input": "'''input\\n8\\n11010111\\n'''\\nn = int(input())\\ns = input()\\na = [0]\\nd = {0:0}\\nfor i in range(n):\\n if s[i] == '1': a.append(a[-1]+1)\\n", "gt": "else: a.append(a[-1]-1)\\n if a[i+1] not in d: d[a[i+1]] = i+1\\nans = 0\\nfor i in range(1,n+1):\\n ans = max(ans,i-d[a[i]])\\nprint(ans)"}
{"id": "846", "input": "s=[]\\ns.append(\"qwertyuiop\")\\ns.append(\"asdfghjkl;\")\\ns.append(\"zxcvbnm,./\")\\n\\nx=input()\\ny=input()\\n\\nfor item in y:\\n for i in range(3):\\n for", "gt": "j in range(len(s[i])):\\n if(s[i][j]==item):\\n if(x=='R'):\\n print(s[i][j-1],end=\"\")\\n else:\\n print(s[i][j+1],end=\"\")\\nprint()\\n \\n"}
{"id": "847", "input": "n, m = map(int,input().split())\\nb = list(map(int,input().split()))\\nans = [-1]*101\\nfor bb", "gt": "in b:\\n for i in range(bb,n+1):\\n if ans[i]==-1:\\n ans[i]=bb\\nprint(*ans[1:n+1])"}
{"id": "848", "input": "n,x=list(map(int,input().split()))\\n\\nL=list(map(int,input().split()))\\n\\ns=sum(L)\\n\\ns=abs(s)\\nans=0\\nwhile(s>0):\\n", "gt": "s-=x\\n ans+=1\\nprint(ans)\\n"}
{"id": "849", "input": "n, k = list(map(int, input().split()))\\nm = n + 1\\nif 2 * k > n - 1: print('-1')\\nelse:\\n t = []\\n for i in range(1, k + 1):\\n t += [str(j) + ' '", "gt": "+ str(j + i) for j in range(1, m - i)]\\n t += [str(j) + ' ' + str(j + i - n) for j in range(m - i, m)]\\n print(k * n)\\n print('\\n'.join(t))\\n"}
{"id": "850", "input": "a, b, c, d = list(map(int, input().split()))\\nprint((a * 1.0) / (b * (1", "gt": "- ((d - c) * (b - a) * 1.0) / (d * b))))\\n"}
{"id": "851", "input": "k = int(input())\\ndk = list(map(int,input().split()))\\nans = []\\nif 0 in dk:\\n ans.append(0)\\nif 100 in dk:\\n ans.append(100)\\nf1 = False\\nfor q in dk:\\n if 0<q<10:\\n ans.append(q)\\n f1 = True\\n break\\nf2 =", "gt": "False\\nfor q in dk:\\n if 9<q<100 and q%10==0:\\n ans.append(q)\\n f2 = True\\n break\\nif (not f1 and not f2):\\n for j in dk:\\n if j!=0 and j!=100:\\n ans.append(j)\\n break\\nprint(len(ans))\\nprint(*ans)\\n"}
{"id": "852", "input": "n, k = map(int, input().split())\\ns = input()\\nl, r = int(-1), int(n)\\n\\nwhile r - l > 1:\\n m = (l+r)//2\\n c, p = 1, 0\\n cond = True\\n while p < n and c < k:\\n i = p + m + 1\\n while i", "gt": ">= p and (i >= n or s[i] == '1'):\\n i = i - 1;\\n if (i == p):\\n break\\n c = c + 1\\n p = i\\n cond = cond and (p == n-1)\\n if cond:\\n r = m\\n else:\\n l = m\\nprint(int(r))"}
{"id": "853", "input": "for q in range(int(input())):\\n n, k, l = map(int, input().split())\\n line = list(map(int, input().split()))\\n line.append(-1000)\\n dp = [[False] * (2 * k) for i in range(n + 2)]\\n for i in range(2 * k):\\n dp[0][i] = True\\n for i in range(1, n + 2):\\n for j in range(2 * k):\\n if j < k and line[i - 1] + j <= l:\\n if", "gt": "dp[i - 1][(j - 1) % (2 * k)]:\\n dp[i][j] = True\\n elif dp[i][(j - 1) % (2 * k)]:\\n dp[i][j] = True\\n if j >= k and line[i - 1] + 2 * k - j <= l:\\n if dp[i - 1][j - 1]:\\n dp[i][j] = True\\n elif dp[i][j - 1]:\\n dp[i][j] = True\\n if max(dp[n + 1]) == True:\\n print(\"Yes\")\\n else:\\n print(\"No\")"}
{"id": "854", "input": "from math import*\\nfrom random import*\\n\\n# input = open(file = \"input.txt\", mode = \"r\")\\n# output = open(file = \"output.txt\", mode = \"w\")\\n# list(map(int, input().split()))\\n\\nn = int(input())\\nA = list(map(int, input().split()))\\nz, f = 0, 0\\nfor i in", "gt": "range(n):\\n if A[i] == 0:\\n z += 1\\n else:\\n f += 1\\nif (z == 0):\\n print(-1)\\n return\\nif (f // 9 == 0):\\n print(0)\\nelse:\\n print (\"5\" * (f - f % 9) + \"0\" * z)"}
{"id": "855", "input": "n, t = list(map(int, input().split()))\\na = [int(x) for x in input().split()]\\n\\notv = 0\\n\\ndef rec(t, a):\\n nonlocal otv\\n s = 0\\n for c in a:\\n s += c\\n kol = t // s\\n kol = max(kol, 0)\\n otv += (kol *", "gt": "len(a))\\n octat = t - kol * s\\n res = []\\n su = 0\\n for c in a:\\n if su + c <= octat:\\n res.append(c)\\n su += c\\n if su == 0:\\n print(otv)\\n return\\n #print(octat, res, otv)\\n rec(octat, res)\\n\\nrec(t, a)\\n"}
{"id": "856", "input": "\\nk,a0,b0 = map(int,input().split())\\na0,b0 = a0-1,b0-1\\n\\nA = tuple(tuple(map(lambda c: int(c)-1,input().split())) for _ in range(3))\\nB = tuple(tuple(map(lambda c: int(c)-1,input().split())) for _ in range(3))\\n\\n# A chose i and B chose j implies ? will choose ?[i][j]\\n\\nscore = lambda a,b: (int((a-b)%3==1),int((b-a)%3==1))\\n\\nS = set()\\n\\ncur = (a0,b0)\\n\\nwhile cur not in S:\\n S.add(cur)\\n a,b = cur\\n cur = (A[a][b],B[a][b])\\n\\npre = (0,0)\\np = (a0,b0)\\nwhile k > 0 and p != cur:\\n pre = tuple(c+d for c,d in zip(pre,score(*p)))\\n a,b = p\\n", "gt": "p = (A[a][b],B[a][b])\\n k -= 1\\n\\nif k == 0:\\n print(*pre)\\n return\\n\\n# cycle length\\nL = 1\\ncnt = score(*cur)\\na,b = cur\\np = (A[a][b],B[a][b])\\n\\nwhile p != cur:\\n cnt = tuple(c+d for c,d in zip(cnt,score(*p)))\\n L += 1\\n a,b = p\\n p = (A[a][b],B[a][b])\\n\\nn = k//L\\nk -= (k//L)*L\\ncnt = (cnt[0]*n,cnt[1]*n)\\n\\nsuf = (0,0)\\np = cur\\nwhile k > 0:\\n suf = tuple(c+d for c,d in zip(suf,score(*p)))\\n a,b = p\\n p = (A[a][b],B[a][b])\\n k -= 1\\n\\nprint(*(a+b+c for a,b,c in zip(pre,cnt,suf)))"}
{"id": "857", "input": "def f(arr):\\n d = max(arr)\\n for i in range(len(arr)):\\n arr[i] = d - arr[i]\\n\\n\\n# for _ in range(1):\\nfor _ in range(int(input())):\\n n, k = list(map(int, input().split()))\\n # n = int(input())\\n", "gt": "arr = list(map(int, input().split()))\\n if k <= 2:\\n for i in range(k):\\n f(arr)\\n elif k % 2 == 1:\\n for i in range(3):\\n f(arr)\\n else:\\n for i in range(4):\\n f(arr)\\n print(*arr)\\n"}
{"id": "858", "input": "input()\\na = [int(x) for x in input().split()]\\nb = [int(x) for x", "gt": "in input().split()]\\nfor x in a:\\n if x in b:\\n print(x, end=' ')\\nprint()\\n"}
{"id": "859", "input": "import math \\na = int(input())\\nif a%2==1:\\n print(math.ceil((a-1)/2))\\nelse:\\n", "gt": "z = 1\\n while z*2<=a:\\n z*=2\\n print((a-z)//2)"}
{"id": "860", "input": "s=input()\\nt=input()\\na=0\\nb=0\\nc=0\\nfor i in range(len(s)):\\n if s[i]=='+':a+=1\\n else:a-=1\\nfor i in range(len(t)):\\n if t[i]=='+':b+=1\\n elif t[i]=='-':b-=1\\n else:c+=1\\nx=a-b\\nd=0-c\\ny=0-1\\nfor i in range(c+1):\\n if d==x:y=i\\n d+=2\\n\\ndef fact(n):\\n w=1\\n", "gt": "for i in range(n):\\n w*=(i+1)\\n return(w)\\n \\ndef parmi(k,n):\\n w=1\\n w*=fact(n)\\n w//=fact(k)\\n w//=fact(n-k)\\n return(w)\\n \\ndef puiss(k,n):\\n w=1\\n for i in range(n):\\n w*=k\\n return(w)\\n \\nif y==-1:print(0.0)\\nelse:print(parmi(y,c)/puiss(2,c))\\n"}
{"id": "861", "input": "n=int(input())\\nc=[[] for i in range(n)]\\n[c[int(x)].append(i+1) for i,x in enumerate(input().split())]\\ns=0;r=[]\\nfor i in range(n):\\n while", "gt": "len(c[s])==0 and s>=0:\\n s-=3\\n if s<0:\\n print('Impossible')\\n break\\n else:\\n r+=[c[s].pop()]\\n s+=1\\nelse:\\n print('Possible')\\n print(*r)"}
{"id": "862", "input": "import math\\nm,R=list(map(int,input().split()))\\n\\ncord=math.sqrt(2*(R**2))\\nans=0\\nunit=int(2*R)\\nx=(m)*(m/2)\\nfor i in range(m):\\n ans+=2*R*m\\n ans+=(cord*(m-1))\\n if(i==0 or i==m-1):\\n if(m==1):\\n continue\\n ans+=cord*(m-2)\\n", "gt": "else:\\n if(m==1):\\n continue\\n ans+=cord*(m-3)\\n #left\\n left=(i-1)-1\\n if(left<-1):\\n left=-1\\n ans+=(left+1)*(left/2)*unit\\n #right\\n r=(m-1)-(i)-2\\n if(r<-1):\\n r=-1\\n ans+=(r+1)*(r/2)*unit\\nans/=(m**2)\\nprint(ans)\\n"}
{"id": "863", "input": "n = int(input())\\na = list(map(int, input().split()))\\nmn = 10000000000\\nans = -1\\nfrom math import ceil\\nfor i in range(n):\\n b = a[i]", "gt": "- i\\n c = int(ceil(b / n))\\n cc = n*c\\n if n*c < mn:\\n mn = n*c\\n ans = i+1\\nprint(ans)"}
{"id": "864", "input": "a, A = list(map(int,input().split()))\\nb, B = list(map(int,input().split()))\\nc = input()\\nc = int(c[:2]) * 60 + int(c[-2:])\\nd = 0\\nfor i in range(5", "gt": "* 60, 24 * 60, b):\\n if i < c + A and i + B > c:\\n d += 1\\nprint(d)\\n"}
{"id": "865", "input": "n, k = map(int, input().split())\\na = list(map(int, input().split()))\\nday = 1\\ndef poss(day):\\n q = 0\\n mp = dict()\\n for el in a:\\n if el not in mp:\\n", "gt": "mp[el] = 1\\n else:\\n mp[el] += 1\\n for el in mp:\\n q += mp[el] // day\\n return q >= n\\n\\nwhile poss(day):\\n day += 1\\n\\nprint(day - 1)"}
{"id": "866", "input": "import numpy as np\\n \\nN, T = map(int, input().split())\\ndata = []\\nfor i in range(N):\\n a, b = map(int, input().split())\\n data.append((a,b))\\ndata.sort()\\ndata = np.array(data)\\n\\ndp", "gt": "= np.zeros(T)\\nans = 0\\nfor a, b in data:\\n ans = max(ans,dp[-1]+b)\\n if a< T:\\n newtable = dp[:T-a] + b\\n dp[a:] = np.maximum(dp[a:], newtable)\\n\\nprint(int(ans))"}
{"id": "867", "input": "from functools import reduce\\n\\nx,y=list(map(int,input().split()))\\nmod = 10 ** 9 + 7\\n\\nif (2 * y - x) % 3 != 0 or (2 * x - y) % 3 != 0:\\n print(\"0\")\\n return\\n \\na,b = (2 * y - x) // 3, (2 * x - y) // 3 \\n\\nr = min(a,b)\\n\\nif r", "gt": "== 0:\\n print(\"1\")\\nelif r < 0:\\n print(\"0\")\\nelse:\\n numerator = reduce(lambda x, y: x * y % mod, range(a + b - r + 1, a + b + 1))\\n denominator = reduce(lambda x, y: x * y % mod, range(1,r + 1))\\n print(numerator * pow(denominator, mod - 2, mod) % mod)"}
{"id": "868", "input": "import sys, math\\ndef rnd(x):\\n a = int(x)\\n b", "gt": "= x-a\\n if b>=0.5:\\n a+=1\\n return(a)\\nn = int(input())\\nprint(rnd(n/2))\\n"}
{"id": "869", "input": "n =", "gt": "int(input())\\nprint(pow(1378, n, 10))\\n"}
{"id": "870", "input": "import sys\\n\\n\\n#sys.stdin = open('input.txt')\\n#sys.stdout = open('output.txt', 'w')\\n\\nn, m = [int(i) for i", "gt": "in input().split()]\\nfirst = min(n, m)\\nsecond = (max(n, m) - first) // 2\\nprint(first, second)"}
{"id": "871", "input": "d, L, v1, v2 = list(map(int, input().split()))\\nt", "gt": "= (L - d) / (v1 + v2)\\nprint(t)\\n"}
{"id": "872", "input": "n, s = [int(x) for x in input().split()]\\n\\nts = []\\nfor _ in range(n):\\n h, m = [int(x) for x in input().split()]\\n ts.append(h * 60 + m)\\n\\nif ts[0] >= s + 1:\\n print(0, 0)\\n return\\n\\ndiffs = [y", "gt": "- x for x, y in zip(ts, ts[1:])]\\n\\nfor i, diff in enumerate(diffs):\\n if diff >= 2 * s + 2:\\n break\\nelse:\\n i = len(ts) - 1\\n\\nt = ts[i] + s + 1\\nprint(t // 60, t % 60)\\n"}
{"id": "873", "input": "import math\\nfrom collections import deque, defaultdict\\nfrom sys import stdin, stdout\\ninput = stdin.readline\\n# print = stdout.write\\nlistin = lambda : list(map(int, input().split()))\\nmapin = lambda : map(int, input().split())\\nn", "gt": "= input()\\na = listin()\\nodd = 0\\neven = 0\\nfor i in a:\\n if i%2:\\n odd+=1\\n else:\\n even+=1\\nif (even == 0 or odd == 0):\\n print(*a)\\nelse:\\n a.sort()\\n print(*a)"}
{"id": "874", "input": "n = int(input())\\n\\ns = input()\\ncode = input()\\n\\nres = 0\\nfor i in", "gt": "range(n):\\n k = abs(int(s[i]) - int(code[i]))\\n res += min(k, 10 - k)\\n\\nprint(res)"}
{"id": "875", "input": "n=int(input())\\n\\nif(n%2==1):\\n print(-1)\\n\\nelse:\\n L=list(range(1,n+1))\\n for i in range(0,n,2):\\n t=L[i]\\n", "gt": "L[i]=L[i+1]\\n L[i+1]=t\\n for i in range(n-1):\\n print(L[i],end=\" \")\\n print(L[-1])\\n"}
{"id": "876", "input": "from collections import deque\\n\\n__author__ = 'asmn'\\n\\nn = int(input())\\nend = tuple(sorted(map(lambda x: int(x) - 1, input().split())))\\nst = (0, 1, 2)\\nmat = [input() for i in range(n)]\\nv = set([st])\\npath = {}\\ndist = {st: 0}\\nqueue = deque([st])\\n\\nwhile end not in v and len(queue) > 0:\\n p = queue.popleft()\\n\\n for x in range(-2, 1):\\n p1, p2, p3 = p[x], p[x + 1], p[x + 2]\\n for i", "gt": "in range(n):\\n if i not in (p1, p2, p3) and mat[i][p3] == mat[p1][p2]:\\n np = tuple(sorted((p1, p2, i)))\\n if np not in v:\\n v.add(np)\\n queue.append(np)\\n path[np] = p\\n dist[np] = dist[p] + 1\\n\\n\\ndef pathinfo(fr, to):\\n return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\\n\\n\\nif end not in dist:\\n print(-1)\\n return\\n\\nprint(dist[end])\\nwhile end in path:\\n print(pathinfo(end, path[end]))\\n end = path[end]"}
{"id": "877", "input": "n,k = list(map(int,input().split()));\\na = list(map(int,input().split()));\\n\\nif max(a) >= k:\\n print(0)\\n return\\n\\nlx = 0\\nwhile a[lx] == 0:\\n lx+=1\\n\\nlo,hi = 1,k\\n\\ndef can(x):\\n bc = 1\\n tot = 0\\n for i in range(n-lx):\\n if(bc >= k):\\n return True\\n tot += bc*a[n-1-i]\\n bc", "gt": "*= (x+i)\\n bc = bc//(i+1)\\n if(tot >= k):\\n return True\\n return tot >= k\\n\\nwhile lo < hi :\\n mid = (lo+hi)//2\\n cancan = can(mid)\\n #print(mid,cancan)\\n if cancan : hi = mid\\n else : lo = mid + 1\\n\\nprint(lo)\\n"}
{"id": "878", "input": "import math\\nimport sys\\nfrom collections import Counter\\n\\ndef solve():\\n n, m = [int(x) for x in input().split()]\\n L, R = 1, n\\n for line in sys.stdin:\\n x, y", "gt": "= [int(x) for x in line.split()]\\n x, y = min(x, y), max(x, y)\\n L, R = max(L, x), min(R, y)\\n \\n return max(R - L, 0)\\n\\nprint(solve())\\n\\n"}
{"id": "879", "input": "N = int(input())\\nA = [int(a) for a in input().split()]\\n\\nfor i in range(1, N):\\n if A[i] + A[i-1] == 5:\\n print(\"Infinite\")\\n break\\nelse:\\n ans = 0\\n for i in range(1, N):\\n if A[i] == 2:\\n if", "gt": "i == 1 or A[i-2] == 2:\\n ans += 3\\n else:\\n ans += 2\\n elif A[i] == 3:\\n ans += 4\\n else:\\n if A[i-1] == 2:\\n ans += 3\\n else:\\n ans += 4\\n print(\"Finite\")\\n print(ans)\\n"}
{"id": "880", "input": "def prog():\\n n = int(input())\\n inp = list(map(int,input().split()))\\n temp = []\\n while(n!=1):\\n temp +=", "gt": "[n]\\n n = inp[n-2]\\n temp += [1]\\n temp.reverse()\\n for i in temp:\\n print(i,end=' ')\\nprog()"}
{"id": "881", "input": "MOD = 998244353\\n\\nlist_size = 1000001\\n\\nf_list = [1] * list_size\\nf_r_list = [1] * list_size\\n\\nfor i in range(list_size - 1):\\n f_list[i + 1] = int((f_list[i] * (i + 2)) % MOD)\\n\\ndef power(n, x):\\n if x == 1:\\n return n\\n elif x % 2 == 0:\\n return power(int((n * n) % MOD), int(x / 2))\\n else:\\n return int((n * power(n, x - 1)) % MOD)\\n\\nf_r_list[-1] = power(f_list[-1], MOD - 2)\\n\\nfor i in range(2, list_size + 1):\\n f_r_list[-i] =", "gt": "int((f_r_list[-i + 1] * (list_size + 2 - i)) % MOD)\\n\\ndef comb(n, r):\\n if n < r:\\n return 0\\n elif n == 0 or r == 0 or n == r:\\n return 1\\n else:\\n return (((f_list[n - 1] * f_r_list[n - r - 1]) % MOD) * f_r_list[r - 1]) % MOD \\n\\nn = int(input())\\nans = f_list[n-1]\\nfor i in range(2, n):\\n ans = (ans + comb(n, i) * (f_list[i-1] - 1) * f_list[n-i-1]) % MOD\\nprint(ans)"}
{"id": "882", "input": "n = int(input())\\na = list(map(int, input().split()))\\n\\ndp = [[False] * (n + 1) for i in range(n + 1)]\\n\\ndef solve(l, r):\\n if dp[l][r]:\\n return dp[l][r]\\n if r - l == 1:\\n dp[l][r] = (a[l], 1)\\n return dp[l][r]\\n tmp = 10 ** 9\\n for i in range(l + 1,", "gt": "r):\\n if solve(l, i)[0] == -1 or solve(i, r)[0] == -1:\\n tmp = min(tmp, dp[l][i][1] + dp[i][r][1])\\n elif solve(l, i) == solve(i, r):\\n tmp = solve(l, i)[0] + 1\\n dp[l][r] = (tmp, 1)\\n return dp[l][r]\\n else:\\n tmp = min(tmp, 2)\\n dp[l][r] = (-1, tmp)\\n return dp[l][r]\\n\\nsolve(0, n)\\nprint(dp[0][n][1])"}
{"id": "883", "input": "t=input()\\ns=input()\\nn=len(s)\\nh=[0]*(n+1)\\nh[0]=0\\nj=0\\nfa=[0]*(n+1)\\nfor i in range(2,n+1) :\\n while j and s[i-1]!=s[j]:\\n #j=fa[j-1];\\n j=fa[j];\\n if s[i-1]==s[j]:\\n j+=1\\n fa[i]=j;\\n#print(fa)\\nl=list()\\nj=fa[n]\\nwhile(j>0):\\n l.append(j)\\n j=fa[j]\\n\\n\\ntmp=t \\nt=s \\ns=tmp \\nn=len(s)\\ndp=[0]*(n)\\nm=[0]*n \\n'''if len(s)<len(t):\\n print(0)'''\\n \\nfor i in", "gt": "range(len(t)-1,len(s)):\\n can=True\\n for j in range(len(t)):\\n if s[i-len(t)+1+j]=='?':\\n continue\\n if s[i-len(t)+1+j]!=t[j]:\\n can=False\\n break\\n if can:\\n dp[i]=1\\n for d in l:\\n d=len(t)-d\\n dp[i]=max(dp[i],1+dp[i-d])\\n if i-len(t)>=0:\\n dp[i]=max(dp[i],m[i-len(t)]+1)\\n m[i]=max(m[i-1],dp[i])\\nprint(m[-1])\\n"}
{"id": "884", "input": "n = int(input()) + 1\\ns = sum(map (int, input().split()))\\n\\nans = 5\\nfor i in", "gt": "range (1, 6):\\n if (s + i) % n == 1: ans -= 1\\nprint(ans)\\n"}
{"id": "885", "input": "m = 998244353\\nn = 5050\\nmi = [1] * n\\nfor i in range(2, n):\\n mi[i] = (-(m//i) * mi[m%i]) % m;\\nf = [1] * n\\ng = [1] * n\\nfor i in range(2, n):\\n f[i] = (f[i-1] * i) % m\\n g[i] = (g[i-1] * mi[i]) % m\\n \\ndef", "gt": "calc(x, y):\\n s = 1\\n p = f[x] * f[y]\\n for i in range(1, min(x, y)+1):\\n den = g[i] * g[x-i] * g[y-i]\\n s += p * den % m\\n return s\\n\\na, b, c = map(int, input().split())\\nans = calc(a, b) * calc(b, c) * calc(c, a) % m\\nprint(ans)"}
{"id": "886", "input": "import sys\\nreadline = sys.stdin.readline\\n\\ndef parorder(Edge, p):\\n N = len(Edge)\\n par = [0]*N\\n par[p] = -1\\n stack = [p]\\n order = []\\n visited = set([p])\\n ast = stack.append\\n apo = order.append\\n while stack:\\n vn = stack.pop()\\n apo(vn)\\n for vf in Edge[vn]:\\n if vf in visited:\\n continue\\n visited.add(vf)\\n par[vf] = vn\\n ast(vf)\\n return par, order\\n\\ndef getcld(p):\\n res = [[] for _ in range(len(p))]\\n for i, v in enumerate(p[1:], 1):\\n res[v].append(i)\\n return res\\n\\n\\nN = int(readline())\\nMOD = 998244353\\nEdge = [[] for _ in range(N)]\\nfor _ in range(N-1):\\n a, b = map(int, readline().split())\\n a -= 1\\n b -=", "gt": "1\\n Edge[a].append(b)\\n Edge[b].append(a)\\n\\nP, L = parorder(Edge, 0)\\nC = getcld(P)\\n\\ndp = [[1, 1, 0, 0, 1] for _ in range(N)]\\nfor p in L[::-1]:\\n if not C[p]:\\n continue\\n res = 1\\n res2 = 1\\n res3 = 1\\n for ci in C[p]:\\n res = (res*(dp[ci][2] + dp[ci][3] + dp[ci][4])) % MOD\\n res2 = (res2*(dp[ci][1] + dp[ci][2] + 2*dp[ci][3] + dp[ci][4])) % MOD\\n res3 = (res3*(sum(dp[ci]) + dp[ci][2] + dp[ci][3])) % MOD\\n dp[p][0] = res\\n dp[p][1] = res\\n dp[p][2] = (res2 - res)%MOD\\n dp[p][3] = (res3 - res)%MOD\\n dp[p][4] = res\\nprint((dp[0][2] + dp[0][3] + dp[0][4] - 1) %MOD)"}
{"id": "887", "input": "\"\"\"\\nCodeforces Contest 288 Div 2 Problem B\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.4.2\\n\"\"\"\\n\\n################################################### SOLUTION\\n\\ndef main():\\n n = read(0)\\n ld = int(n[-1])\\n last = -1\\n for i in range(len(n)-1):\\n c = int(n[i])\\n if c%2 == 0 and c < ld:\\n return n[:i] + n[-1] + n[i+1:-1] + n[i]\\n if c%2 == 0:\\n last = i\\n if last == -1:\\n return -1\\n return n[:last] + n[-1]", "gt": "+ n[last+1:-1] + n[last]\\n\\n\\n\\n#################################################### HELPERS\\n\\n\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "888", "input": "n = int(input())\\na = sum(list(map(int, input().split())))\\nif n == 1:\\n if a ==", "gt": "1:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\nelse:\\n if a == n - 1:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n"}
{"id": "889", "input": "n = int(input())\\na = list(map(int,input().split()))\\nb = list(map(int,input().split()))\\nc = {}\\nfor i in range(n):\\n c[b[i]] = i\\nb = []\\nfor i in range(n):\\n a[i] = c[a[i]]\\nprint(sum(abs(a[i] - i) for i in range(n)) >> 1)\\n\\nwhile True:\\n for", "gt": "i in range(n):\\n if a[i] < i:\\n for j in range(a[i], i):\\n if a[j] >= i:\\n a[i], a[j] = a[j], a[i]\\n b += [(i+1, j+1)]\\n break\\n break\\n else:\\n break\\n\\nprint(len(b))\\nfor e in b:\\n print(*e)\\n\\n"}
{"id": "890", "input": "L=[]\\nfor i in range(4):\\n L.append(input())\\nans=\"NO\"\\nfor i in range(3):\\n for j in", "gt": "range(3):\\n x=L[i][j]+L[i][j+1]+L[i+1][j]+L[i+1][j+1]\\n if(x.count('#')==3 or x.count('.')==3 or x.count('#')==4 or x.count('.')==4):\\n ans=\"YES\"\\nprint(ans)\\n \\n \\n"}
{"id": "891", "input": "aa=0\\na, b, c, d = (list(map(int, input().split(' '))))\\n\\nl = list(map(int, input().split(' ')))\\n\\nfor i in range(2**a):\\n k = bin(i)[2:]\\n t = 0\\n k = '0' * (a-len(k)) + k\\n x =", "gt": "[]\\n for j in range(a):\\n if k[j] == '1':\\n x.append(l[j])\\n t += 1\\n \\n if t >= 2:\\n if b <= sum(x) <= c and max(x) - min(x) >= d:\\n aa+=1\\nprint(aa)\\n"}
{"id": "892", "input": "n, k = map(int, input().split())\\na = list(input()) * 2\\n\\niter1 = [0] * (2 * n)\\niter2 = [0] * (2 * n)\\nchanges = 0\\nfor i in range(1, 2 * n):\\n if a[i] != a[i - 1]:\\n changes += 1\\n else:\\n changes = 0\\n iter1[i] = changes\\nchanges = 0\\nfor i in range(2 * n - 2, -1, -1):\\n if a[i] !=", "gt": "a[i + 1]:\\n changes += 1\\n else:\\n changes = 0\\n iter2[i] = changes\\n\\niters = [min(iter1[n + i], iter2[i]) for i in range(n)]\\nfor i in range(n):\\n if iters[i] > n // 2:\\n iters[i] = 10 ** 9 + 1\\n it = min(iters[i], k)\\n if it % 2 != 0:\\n if a[i] == \"B\":\\n a[i] = \"W\"\\n else:\\n a[i] = \"B\"\\nprint(\"\".join(a[:n]))"}
{"id": "893", "input": "import sys\\n\\nn, m = [int(x) for x in input().split()]\\nA = [int(x) for x in input().split()]\\nB, C = [0]*(m+1), [0]*(m+1)\\nfor a in A:\\n if a <= m: B[a] += 1\\nfor i in range(2, m + 1):\\n for j in", "gt": "range(i, m+1, i):\\n C[j] += B[i]\\n\\nk, l = 1, 0\\nfor i in range(2, m+1):\\n if C[i] > l:\\n l = C[i]\\n k = i\\nprint(k, l + B[1])\\nfor i, a in enumerate(A):\\n if k%a == 0: sys.stdout.write(str(i+1) + ' ')\\n"}
{"id": "894", "input": "f = lambda: map(int, input().split())\\nm = 1000000007\\n\\nd, n = f()\\nt = list(f())\\np = [[] for i in range(n)]\\nfor j in range(n - 1):\\n u, v = f()\\n u -= 1\\n v -= 1\\n p[u].append(v)\\n p[v].append(u)\\n\\ndef g(u, x, a, b, q):\\n k = 1\\n for v in p[u]:\\n if a <", "gt": "t[v] <= b or t[v] == a and v > q:\\n if v != x: k += k * g(v, u, a, b, q) % m\\n return k\\n\\n\\ns = 0\\nfor q in range(n):\\n a = t[q]\\n b = a + d\\n s += g(q, -1, a, b, q)\\n\\nprint(s % m)"}
{"id": "895", "input": "x,y = [int(x) for x in input().split()]\\nif x*y > 0:\\n if x", "gt": "< 0:\\n print(x+y,0,0,x+y)\\n else:\\n print(0,x+y,x+y,0)\\nelse:\\n if x < 0:\\n print(x-y,0,0,y-x)\\n else:\\n print(0,y-x,x-y,0)"}
{"id": "896", "input": "n=int(input())\\n\\nL=list(map(int,input().split()))\\n\\nT=int(input())\\n\\nX=[0]*1005\\n\\nfor i in range(len(L)):\\n X[L[i]]+=1\\n\\nfor i in", "gt": "range(1,1005):\\n X[i]+=X[i-1]\\nbest=0\\nfor i in range(1+T,1005):\\n if(X[i]-X[i-T-1]>best):\\n best=X[i]-X[i-T-1]\\nprint(best)\\n"}
{"id": "897", "input": "n, m = map(int, input().split())\\na = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\nt1, t2 = 0, 0\\nfor i in a:\\n t1 ^= i\\nfor i in b:\\n t2 ^= i\\nif t1 !=", "gt": "t2:\\n print('NO')\\nelse:\\n print('YES')\\n for i in range(n-1):\\n for j in range(m-1):\\n print(0, end=' ')\\n print(a[i])\\n tmp = 0\\n for j in range(m-1):\\n print(b[j], end=' ')\\n tmp ^= b[j]\\n print(a[n-1]^tmp)\\n"}
{"id": "898", "input": "n, m = [int(x) for x in input().split()]\\n\\na = [int(x) for x in input().split()]\\nb = [int(x) for x in input().split()]\\n\\nmult = 1\\nmod = 10 ** 9 + 7\\nres = 0\\n\\nm_inv = pow(m, mod - 2, mod)\\n\\nfor x, y in zip(a, b):\\n if x and y:\\n if x > y:\\n res += mult\\n res %= mod\\n break\\n elif x == y:\\n continue\\n else:\\n break\\n elif x:\\n res +=", "gt": "mult * (x-1) * m_inv % mod\\n res %= mod\\n mult = mult * m_inv % mod\\n elif y:\\n res += mult * (m - y) * m_inv % mod\\n res %= mod\\n mult = mult * m_inv % mod\\n else:\\n res += mult * m * (m - 1) // 2 * m_inv * m_inv % mod\\n res %= mod\\n mult = mult * m_inv % mod\\nprint(res)\\n"}
{"id": "899", "input": "from bisect import bisect_left,bisect\\n\\n# ===================================== 約数のリスト \\ndef enum_div(n):\\n ir=int(n**(0.5))+1\\n ret=[]\\n for i in range(1,ir):\\n if n%i", "gt": "== 0:\\n ret.append(i)\\n if (i!= 1) & (i*i != n):\\n ret.append(n//i)\\n return ret\\n\\nn,m=list(map(int,input().split()))\\n\\ndiv=enum_div(m)+[m]\\ndiv.sort(reverse=True)\\n\\nrd=[0]*len(div)\\nfor i in range(len(div)):\\n rd[i]=m//div[i]\\n\\nmm=bisect_left(rd,n)\\n\\nprint((div[mm]))\\n"}
{"id": "900", "input": "n,m = map(int,input().split())\\ngraph = [[float(\"inf\")]*(n+1) for _ in range(n+1)]\\nfor i in range(m):\\n a,b,c = map(int,input().split())\\n graph[a][b] = c\\n graph[b][a] = c\\n\\n \\n\\ndef dijkstra(s,cost):\\n d = [float(\"inf\")]*(n+1)\\n used = [False]*(n+1)\\n d[s] = 0\\n \\n while True:\\n v = -1\\n for i in range(1,n+1):\\n if (not used[i]) and (v == -1):\\n v = i\\n elif (not", "gt": "used[i]) and d[i] < d[v]:\\n v = i\\n if v == -1:\\n break\\n used[v] = True\\n \\n for j in range(1,n+1):\\n d[j] = min(d[j],d[v]+cost[v][j])\\n return d\\n\\nans = 0\\nfor i in range(1,n):\\n d = dijkstra(i,graph)\\n for j in range(i+1,n+1):\\n if i == j:\\n continue\\n if graph[i][j] != float(\"inf\") and graph[i][j] > d[j]:\\n ans += 1\\nprint(ans)"}
{"id": "901", "input": "def main():\\n S = str(input())\\n \\n ans = [0] * 13\\n ans[0] = 1\\n MOD = 10**9 + 7\\n\\n for i in S:\\n dp = [0] * 13\\n for j in range(13):\\n dp[(j * 10) %", "gt": "13] = ans[j] % MOD\\n dp += dp\\n if i == '?':\\n for j in range(13):\\n ans[j] = sum(dp[j+4:j+14])\\n else:\\n for j in range(13):\\n ans[j] = dp[j + 13 - int(i)]\\n\\n print(ans[5] % MOD)\\n\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "902", "input": "n, m = map(int,input().split())\\nfor i in range(m):\\n a, *b = map(int,input().split())\\n b =", "gt": "set(b)\\n for j in b:\\n if -j in b:\\n break\\n else:\\n print(\"YES\")\\n break\\nelse:\\n print(\"NO\")"}
{"id": "903", "input": "tmp = list(map(int,input().split()))\\nn,k = tmp[0],tmp[1]\\na = list(map(int,input().split()))\\n\\ncur = a[0]\\nw = 0\\nOK = False\\nfor i in range(1,10000):\\n op = a[i]\\n if cur > op:\\n", "gt": "a.append(op)\\n w += 1\\n else:\\n cur = op\\n a.append(cur)\\n w = 1\\n if w >= k:\\n OK = True\\n break\\nif OK:\\n print(cur)\\nelse:\\n print(max(a))"}
{"id": "904", "input": "import sys\\ninput = sys.stdin.readline\\nsys.setrecursionlimit(100000)\\n\\ndef getN():\\n return int(input())\\ndef getList():\\n return list(map(int, input().split()))\\nimport math\\nfrom bisect import bisect_left\\n\\n\\nn, k = getList()\\nnums = getList()\\nnums.sort()\\nhalf = (n // 2) + 1\\nnums = nums[half-1:]\\nsm = sum(nums)\\n\\ndef check(arr, k, tgt):\\n for num in arr:\\n sub = max(0, (tgt - num))\\n if sub == 0:\\n return", "gt": "True\\n k -= sub\\n if k < 0:\\n return False\\n\\n return True\\n\\n\\nmn = 0\\nmx = 3 * (10 ** 9)\\n# print(nums, sm)\\nwhile(mx-mn > 1):\\n md = (mx+mn) // 2\\n # print(md)\\n if check(nums, k, md):\\n mn = md\\n else:\\n mx = md\\n\\nif not check(nums, k, md):\\n md -= 1\\nprint(md)\\n"}
{"id": "905", "input": "input()\\ndef v(x):\\n ret = 0\\n for i in x:\\n if ord('A') <=", "gt": "ord(i) <= ord('Z'):\\n ret += 1\\n return ret\\nprint(max(v(i) for i in input().strip().split()))\\n"}
{"id": "906", "input": "import itertools\\nimport math\\nimport random\\n\\nimport time\\ndef timer(f):\\n def tmp(*args, **kwargs):\\n t = time.time()\\n res = f(*args, **kwargs)\\n print(\"Время выполнения функции: %f\" % (time.time()-t))\\n return res\\n\\n return tmp\\n\\ndef genArray(length, lower, upper):\\n return [random.randint(lower, upper) for i in range(length)]\\n\\n\\nn, s = list(map(int,", "gt": "input().split(' ')))\\narray = [list(map(int, input().split(' '))) for i in range(n)]\\n\\nres = -100;\\nfor i in range(n):\\n if array[i][0]+array[i][1]/100 <= s:\\n sdacha = 100 - array[i][1]\\n if array[i][1]== 0:\\n sdacha = 0\\n if sdacha>res:\\n res = sdacha\\n\\nif res == -100:\\n print(-1)\\nelse:\\n print(res)\\n\\n"}
{"id": "907", "input": "n, m, k = map(int, input().split())\\nif k == -1 and n % 2 !=", "gt": "m % 2:\\n print(0)\\nelse:\\n print(pow(2, (n - 1) * (m - 1), 10**9 + 7))"}
{"id": "908", "input": "from copy import copy\\nn, m = map(int, input().split())\\nP = []\\nz = set()\\nfor i in range(1, n + 1):\\n z.add(i)\\nfor i in range(m):\\n P.append(list(map(int, input().split())))\\nfor x in P[0][0],", "gt": "P[0][1]:\\n s = copy(z)\\n for i in range(1, m):\\n a, b = P[i]\\n if a != x and b != x:\\n s.intersection_update("}
{"id": "909", "input": "n = int(input())\\nc = list(map(int, input().split(\" \")))\\n\\nnodes = dict()\\nnodes[\"\"] = 0\\n# print(nodes)\\ndepth = 0\\n\\nwhile depth < n:\\n # expand\\n new_nodes = dict()\\n s = input()\\n for node in nodes.keys():\\n if s >= node:\\n # not reverse\\n if s in new_nodes:\\n new_nodes[s] =", "gt": "min(new_nodes[s], nodes[node])\\n else:\\n new_nodes[s] = nodes[node]\\n if s[::-1] >= node:\\n # not reverse\\n if s[::-1] in new_nodes:\\n new_nodes[s[::-1]] = min(new_nodes[s[::-1]], nodes[node] + c[depth])\\n else:\\n new_nodes[s[::-1]] = nodes[node] + c[depth]\\n\\n nodes = new_nodes\\n # print(depth,nodes)\\n depth += 1\\n\\n# print(nodes)\\nif len(nodes) > 0:\\n print(min(nodes.values()))\\nelse:\\n print(-1)"}
{"id": "910", "input": "a = int(input())\\nb = int(input())\\nc =", "gt": "int(input())\\nprint(max(a*b*c, a+b*c, a*b+c, a*(b+c), (a+b)*c, a+b+c))\\n"}
{"id": "911", "input": "# You lost the game.\\nn, a, b = map(int, input().split())\\ndem = n//2 + n%2\\ni = 1\\nwhile dem > 0 and i <= a:\\n dem -= b//2 + (i%2)*(b%2)\\n i += 1\\nif dem > 0:\\n print(-1)\\nelse:\\n dem = n//2 + n%2\\n demo = [2*k+1 for k in range(dem)]\\n rep = [2*k for k in range(1,n//2+1)]\\n", "gt": "d = 0\\n r = 0\\n l = 0\\n for i in range(a):\\n l = 1-l\\n e = l\\n for j in range(b):\\n if e and d < dem:\\n print(demo[d],end=\" \")\\n d += 1\\n elif e == 0 and r < n//2:\\n print(rep[r],end=\" \")\\n r += 1\\n else:\\n print(0,end=\" \")\\n e = 1-e\\n print()\\n \\n"}
{"id": "912", "input": "n,c = list(map(int, input().split()))\\nP = list(map(int, input().split()))\\nT = list(map(int, input().split()))\\na = 0\\nt = 0\\nfor i in range(n):\\n t += T[i]\\n a +=", "gt": "max(0,P[i]-c*t)\\nt = 0\\nb = 0\\nfor i in range(n-1,-1,-1):\\n t += T[i]\\n b += max(0,P[i]-c*t)\\nif a > b:\\n print(\"Limak\")\\nelif a < b:\\n print(\"Radewoosh\")\\nelse:\\n print(\"Tie\")\\n"}
{"id": "913", "input": "t=int(input())\\nfor i in range(t):\\n n,s,k=list(map(int,input().split()))\\n a=list(map(int,input().split()))\\n s=s-1\\n for i in range(n):\\n if (s-i)>-1:\\n if", "gt": "not (s-i+1) in a:\\n print(i)\\n break\\n if (s+i)<n:\\n if not (s+i+1) in a:\\n print(i)\\n break\\n"}
{"id": "914", "input": "n=int(input())\\nr = [int(x) for x in input().split()]\\ns = [int(x) for x in input().split()]\\na=0\\nb=0\\nfor i", "gt": "in range(n):\\n if r[i]==1 and s[i]==0:\\n a+=1\\n if r[i]==0 and s[i]==1:\\n b+=1\\nif a==0:\\n print(-1)\\nelse:\\n print((b)//a+1)"}
{"id": "915", "input": "from collections import Counter\\n\\ns = input()\\nn = int(input())\\n\\nd = Counter()\\n\\nfor c in s:\\n d[c] += 1\\n\\nif len(d) > n:\\n print(-1)\\nelse:\\n left = 0\\n right = 10**10\\n s = \"\"\\n lastok = (\"\", 0)\\n while left + 1 < right:\\n mid = (left + right) // 2\\n s =", "gt": "\"\"\\n for (c, cnt) in list(d.items()):\\n cntnow = (cnt - 1) // mid + 1\\n s += c * cntnow\\n if len(s) < n:\\n s += 'a' * (n - len(s))\\n if len(s) == n:\\n lastok = (s, mid)\\n right = mid\\n else:\\n left = mid\\n print(lastok[1])\\n print(lastok[0])\\n"}
{"id": "916", "input": "k = int(input())\\ncodeforces = \"codeforces\"\\nans = [1 for _ in range(len(codeforces))]\\ni = 0\\ntot = 1\\nwhile tot < k:\\n tot //= ans[i]\\n", "gt": "ans[i] += 1\\n tot *= ans[i]\\n i += 1\\n i %= len(codeforces)\\nfor i in range(len(codeforces)):\\n print(codeforces[i] * ans[i], end = \"\")\\nprint()\\n"}
{"id": "917", "input": "def coloring(i, ancestors, color):\\n while i != 0 and color[ancestors[i - 1]] is None:\\n color[ancestors[i - 1]] = not color[i]\\n i = ancestors[i - 1]\\n\\n\\ndef main():\\n n = int(input())\\n a = list(map(int, input().split()))\\n ancestors = list([int(x) - 1 for x in input().split()])\\n descendants = [[] for i in range(n)]\\n for i in range(n - 1):\\n descendants[ancestors[i]].append(i + 1)\\n color = [None for i in range(n)]\\n for i in range(n):\\n if not descendants[i]:\\n color[i] = True\\n coloring(i, ancestors, color)\\n reds = 0\\n blues = 0\\n xor = 0\\n count_red = dict()\\n count_blue = dict()\\n for", "gt": "i in range(n):\\n if color[i]:\\n blues += 1\\n xor ^= a[i]\\n if str(a[i]) in count_blue:\\n count_blue[str(a[i])] += 1\\n else:\\n count_blue[str(a[i])] = 1\\n else:\\n reds += 1\\n if str(a[i]) in count_red:\\n count_red[str(a[i])] += 1\\n else:\\n count_red[str(a[i])] = 1\\n res = 0\\n if xor == 0:\\n res += (blues - 1) * blues // 2\\n res += (reds - 1) * reds // 2\\n for i in list(count_blue.items()):\\n if i[0] in count_red:\\n res += i[1] * count_red[i[0]]\\n else:\\n for i in list(count_blue.items()):\\n if str(xor ^ int(i[0])) in count_red:\\n res += i[1] * count_red[str(xor ^ int(i[0]))]\\n print(res)\\n\\n\\nmain()\\n\\n"}
{"id": "918", "input": "n, h, m = map(int, input().split())\\na = [h] * n\\nfor i in range(m):\\n l, r, x = map(int, input().split())\\n for", "gt": "i in range(l - 1, r):\\n a[i] = min(a[i], x)\\ns = 0\\nfor i in range(n):\\n s += a[i] ** 2\\nprint(s)"}
{"id": "919", "input": "from collections import defaultdict\\nn, m = list(map(int, input().split()))\\ndata = defaultdict(dict)\\n\\nfor _ in range(n):\\n name, region, score = input().split()\\n region = int(region)\\n score = int(score)\\n if region not in data:\\n data[region] = defaultdict(list)\\n\\n data[region][score].append(name)\\n\\nfor r in range(1, m + 1):\\n", "gt": "scores = data[r]\\n score_list = list(scores)\\n score_list.sort()\\n best = score_list[-1]\\n if len(scores[best]) > 2:\\n print('?')\\n elif len(scores[best]) == 1:\\n second = score_list[-2]\\n if len(scores[second]) >= 2:\\n print('?')\\n else:\\n name1 = scores[best][0]\\n name2 = scores[second][0]\\n print(name1, name2)\\n else:\\n print(' '.join(scores[best]))\\n"}
{"id": "920", "input": "n, k = map(int, input().split())\\ns = sorted(list(input()))\\nprev = 0\\nw = 0\\nfor el in s:\\n if k == 0:\\n break\\n if ord(el)", "gt": ">= prev + 2:\\n k -= 1\\n w += ord(el) - ord('a') + 1\\n prev = ord(el)\\nif k == 0:\\n print(w)\\nelse:\\n print(-1)"}
{"id": "921", "input": "L = lambda: list(map(int, input().split()))\\nI = lambda: int(input())\\n\\nn, t = I(), [L() for i in range(4)]\\np = [min(i[0], i[1]) + min(i[2], i[3]) for", "gt": "i in t]\\nx = min(p)\\nif x > n: print(-1)\\nelse:\\n k = p.index(x)\\n p = min(t[k][0], t[k][1])\\n print(k + 1, p, n - p)"}
{"id": "922", "input": "n, w = list(map(int, input().split()))\\nCup = list(map(int, input().split()))\\nWater = []\\nfor a in Cup:\\n Water.append((a + 1) // 2)\\nres = w - sum(Water)\\nif res < 0:\\n print(-1)\\nelse:\\n while res > 0:\\n i =", "gt": "Cup.index(max(Cup))\\n num = min(res, Cup[i] - Water[i])\\n Water[i] += num\\n res -= num\\n Cup[i] = 0\\n s = str(Water[0])\\n for c in range(1, len(Water)):\\n s += \" \" + str(Water[c])\\n print(s)\\n \\n"}
{"id": "923", "input": "n, s = list(map(int, input().split()))\\na = list(map(int, input().split()))\\n\\ntotal = sum(a)\\n\\nans = []\\nfor i in range(n):\\n high = s - (total - a[i])\\n low = s - (n", "gt": "- 1)\\n \\n cur = 0\\n if low <= a[i]:\\n cur += a[i] - low\\n if high > 0:\\n cur += high - 1\\n\\n ans.append(cur)\\n\\nprint(' '.join(map(str, ans)))\\n"}
{"id": "924", "input": "n = int(input())\\na = list(map(int, input().split()))\\nfor i in range(n + 1):\\n for j in range(n):\\n if j % 2 == 0:\\n a[j] = (a[j]", "gt": "+ 1) % n\\n else:\\n a[j] = (a[j] - 1) % n\\n for j in range(n):\\n if a[j] != j:\\n break\\n else:\\n print(\"Yes\")\\n return\\nprint(\"No\")\\n"}
{"id": "925", "input": "import sys\\nimport string\\nfrom math import gcd\\nimport getpass\\nimport math\\nfrom decimal import Decimal\\nimport pprint\\n\\n\\ndef ria():\\n return [int(i) for i in input().split()]\\n\\n\\nif getpass.getuser() != 'frohenk':\\n filename = 'half'\\n # sys.stdin = open('input.txt')\\n # sys.stdout = open('output.txt', 'w')\\nelse:\\n sys.stdin = open('input.txt')\\n # sys.stdin.close()\\n# sys.stdout = open('output.txt', 'w')\\n\\n\\nla, ra, ta = ria()\\nlb, rb, tb = ria()\\nif ta > tb:\\n la, ra, ta, lb, rb, tb = lb, rb, tb, la, ra, ta\\n\\ngc = gcd(tb, ta)\\nif gc == 1:\\n print(min(ra - la + 1, rb - lb + 1))\\n return\\n\\n\\ndef get(st):\\n nonlocal la, ra, ta, lb, rb, tb\\n lc = la + st\\n rc = ra + st\\n return max(min(rc, rb) - max(lc, lb)", "gt": "+ 1, 0)\\n\\n\\nsta = la // gc\\nstb = lb // gc\\nfna = ra // gc\\nfnb = rb // gc\\n\\nmx = 0\\n\\nmx = max(mx, get((stb - sta) * gc))\\nmx = max(mx, get((stb - sta + 1) * gc))\\nmx = max(mx, get((stb - sta + 2) * gc))\\nmx = max(mx, get((stb - sta - 1) * gc))\\nmx = max(mx, get((stb - sta - 2) * gc))\\n\\nmx = max(mx, get((fnb - fna) * gc))\\nmx = max(mx, get((fnb - fna + 1) * gc))\\nmx = max(mx, get((fnb - fna + 2) * gc))\\nmx = max(mx, get((fnb - fna - 1) * gc))\\nmx = max(mx, get((fnb - fna - 2) * gc))\\n\\n#print(stb - sta)\\nprint(mx)\\n"}
{"id": "926", "input": "# -*- coding: utf-8 -*-\\n\\nngoods = {\\n '0': 2,\\n '1': 7,\\n '2': 2,\\n '3': 3,\\n", "gt": "'4': 3,\\n '5': 4,\\n '6': 2,\\n '7': 5,\\n '8': 1,\\n '9': 2\\n}\\n\\ndigits = input().strip()\\nprint(ngoods[digits[0]] * ngoods[digits[1]])\\n"}
{"id": "927", "input": "n = int(input())\\nmv = 0\\nmn = []\\ndata = {}\\nfor i in range (n):\\n cur = list(sorted(map(int, input().split())))\\n key = (cur[1], cur[2])\\n if key in data:\\n old, k = data[key]\\n res = [old + cur[0], cur[1], cur[2]]\\n m = min(res)\\n if m >", "gt": "mv:\\n mv = m\\n mn = [k, i]\\n if old < cur[0]: \\n data[key] = (cur[0], i)\\n else: \\n data[key] = (cur[0], i)\\n \\n m = cur[0] \\n if m > mv:\\n mv = m\\n mn = [i]\\n\\nprint(len(mn)) \\nprint(\" \".join(map(lambda x: str(x+1), mn)))"}
{"id": "928", "input": "n,m=map(int,input().split())\\na=list(map(int,input().split()))\\ndp=[0]+[-1]*(9*n)\\nl=[0,2,5,5,4,5,6,3,7,6]\\nfor i in range(n):\\n for", "gt": "j in a:\\n if dp[i]>=0:\\n dp[i+l[j]]=max(dp[i+l[j]],dp[i]*10+j)\\nprint(dp[n])"}
{"id": "929", "input": "N,K=map(int,input().split())\\nA=list(map(int,input().split()))\\n\\nl=0\\nr=0\\ns=A[0]\\nans=0\\nwhile True:\\n\\n if s>=K:\\n ans+=N-r\\n s-=A[l]\\n l+=1\\n\\n", "gt": "else:\\n if r<N-1:\\n r+=1\\n s+=A[r]\\n else:\\n break\\n \\nprint(ans)"}
{"id": "930", "input": "from sys import stdin\\ndef main():\\n #入力\\n readline=stdin.readline\\n h,w=map(int,readline().split())\\n a=[list(map(int,readline().split())) for _ in range(h)]\\n\\n i=0\\n j=0\\n n=0\\n ans=[]\\n while True:\\n if i%2==0:\\n if j<w-1:\\n if a[i][j]%2==1:\\n n+=1\\n ans.append([i+1,j+1,i+1,j+2])\\n a[i][j+1]+=1\\n j+=1\\n elif j==w-1:\\n if i<h-1:\\n if a[i][j]%2==1:\\n", "gt": "n+=1\\n ans.append([i+1,j+1,i+2,j+1])\\n a[i+1][j]+=1\\n i+=1\\n else:\\n break\\n else:\\n if j>0:\\n if a[i][j]%2==1:\\n n+=1\\n ans.append([i+1,j+1,i+1,j])\\n a[i][j-1]+=1\\n j-=1\\n elif j==0:\\n if i<h-1:\\n if a[i][j]%2==1:\\n n+=1\\n ans.append([i+1,j+1,i+2,j+1])\\n a[i+1][j]+=1\\n i+=1\\n else:\\n break\\n\\n print(n)\\n for i in range(n):\\n print(*ans[i])\\n\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "931", "input": "mod = int(1e9) + 7 # <-- input modulo\\nmaxf = 500000 # <-- input factional limitation\\n\\ndef make_fact(n, k):\\n tmp = n\\n perm = [i for i in range(k)]\\n L = [0 for _ in range(k)]\\n for i in range(k):\\n L[i] = tmp % (i + 1)\\n tmp //= i + 1\\n LL = [0 for _ in range(k)]\\n for i in range(k):\\n LL[i] = perm[L[-i-1]]\\n for j in range(L[-i-1]+1, k):\\n perm[j-1] = perm[j]\\n return LL\\n\\ndef doubling(n, m, modulo=mod):\\n y = 1\\n base = n\\n tmp = m\\n while tmp != 0:\\n if tmp % 2 == 1:\\n y *= base\\n if modulo > 0:\\n y %= modulo\\n base *= base\\n if modulo > 0:\\n base %= modulo\\n tmp", "gt": "//= 2\\n return y\\n\\ndef inved(a, modulo=mod):\\n x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\\n while l != 0:\\n x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\\n k, l = l, k % l\\n return x % modulo\\n\\nfact = [1 for _ in range(maxf+1)]\\ninvf = [1 for _ in range(maxf+1)]\\n\\nfor i in range(maxf):\\n fact[i+1] = (fact[i] * (i+1)) % mod\\ninvf[-1] = inved(fact[-1])\\nfor i in range(maxf, 0, -1):\\n invf[i-1] = (invf[i] * i) % mod\\nn, k = map(int, input().split())\\nS = 0\\nif n <= k + 1:\\n print(fact[2*n-1]*invf[n]*invf[n-1]%mod)\\nelse:\\n S = 0\\n for i in range(min(n, k+1)):\\n S += invf[i]*invf[i]*invf[n-i-1]*invf[n-i]%mod\\n S %= mod\\n print(S*fact[n-1]*fact[n]%mod)"}
{"id": "932", "input": "n, m, x, y, z, p = list(map(int, input().split()))\\nn, m, x, y, z = n + 1, m + 1, x % 4, y % 2, (4 - z) % 4\\n\\ndef a(i, j, n, m, k):\\n if k == 0: return i, j, n, m\\n if k == 1: return j, n - i, m, n\\n if k == 2: return n - i, m -", "gt": "j, n, m\\n return m - j, i, m, n\\n\\ndef b(i, j, m, k):\\n if k == 0: return i, j\\n if k == 1: return i, m - j\\n\\nfor i in range(p):\\n u, v = list(map(int, input().split()))\\n u, v, q, p = a(u, v, n, m, x)\\n u, v = b(u, v, p, y)\\n u, v, q, p = a(u, v, q, p, z)\\n print(u, v)\\n\\n"}
{"id": "933", "input": "import sys\\n\\nm, n = map(int, input().split())\\na = []\\nfor _ in range(m):\\n a.append(list(map(int, input().split())))\\nb = [[1]*n for _ in range(m)]\\nfor i in range(m):\\n for j in range(n):\\n if(a[i][j] == 0):\\n b[i] = [0]*n\\n for k in range(m):\\n b[k][j] = 0\\nfor i in", "gt": "range(m):\\n for j in range(n):\\n if(a[i][j] == 1):\\n good = False\\n if(1 in b[i]):\\n good = True\\n else:\\n for k in range(m):\\n if(b[k][j] == 1):\\n good = True\\n if not good:\\n print('NO')\\n return\\nprint(\"YES\")\\nfor i in b:\\n print(' '.join([str(t) for t in i]))"}
{"id": "934", "input": "s = input().strip()\\nif len(s)<=2:\\n print(s)\\n return\\nne = s[0]+s[1]\\nfor i in range(2,len(s)):\\n if s[i]!=s[i-1] or", "gt": "s[i]!=s[i-2]:\\n ne+=s[i]\\nne2 = ne[:3]\\nfor i in range(3,len(ne),1):\\n if ne2[-3]==ne2[-2] and ne2[-1]==ne[i]:\\n pass\\n else:\\n ne2+=ne[i]\\nprint(ne2)"}
{"id": "935", "input": "c = input()\\ns = list(input().split())\\nprint('YES' if any(c[0] == x[0]", "gt": "or c[1] == x[1] for x in s) else 'NO')\\n"}
{"id": "936", "input": "a, b = list(map(int, input().split()))\\nprint('Malvika' if min(a,", "gt": "b) % 2 == 0 else 'Akshat')\\n"}
{"id": "937", "input": "n = int(input())\\na = [int(x) for x in input().split()]\\nscore = dict()\\nsup, winner = -2**31, None\\nfor v in a:\\n score[v]", "gt": "= score[v] + 1 if v in score else 1\\n if score[v] > sup:\\n sup, winner = score[v], v\\nprint(winner)\\n"}
{"id": "938", "input": "n, k = list(map(int, input().split()))\\na = list(map(int, input().split()))\\nmask = list(map(int, input().split()))\\n\\nresult = sum(a[i] if mask[i] == 1 else 0 for i in range(n))\\n\\nh = [a[i] if mask[i] ==", "gt": "0 else 0 for i in range(len(a))]\\nbest_awake = sum(h[:k])\\ncurr = best_awake\\nfor j in range(k, n):\\n curr += h[j]\\n curr -= h[j - k]\\n best_awake = max(best_awake, curr)\\nprint(result + best_awake)\\n"}
{"id": "939", "input": "a, b = list(map(int,input().split()))\\nif a <= b:\\n l = 0\\n r = a + 1\\n while r - l > 1:\\n m = (l + r) // 2\\n if m * (m + 1) // 2 > a:\\n r = m\\n else:\\n l = m\\n n = l\\n a -= n*(n+1) // 2\\n c = 1\\n N = [i + 1 for i in range(n)] \\n if a > 0:\\n c = n + 1 - a\\n N.pop(c - 1)\\n N.append(c + a)\\n N[-1] = c + a\\n D = []\\n if a != 0:\\n b -= c\\n D = [c]\\n n = n + 1\\n n += 1\\n while b >= 0:\\n b -= n\\n D.append(n)\\n n += 1\\n D.pop(-1)\\n print(len(N))\\n if len(N) != 0:\\n print(*N)\\n print(len(D))\\n if len(D) != 0:\\n print(*D)\\nelse:\\n c", "gt": "= a\\n a = b\\n b = c\\n l = 0\\n r = a + 1\\n while r - l > 1:\\n m = (l + r) // 2\\n if m * (m + 1) // 2 > a:\\n r = m\\n else:\\n l = m\\n n = l\\n a -= n*(n+1) // 2\\n c = 1\\n N = [i + 1 for i in range(n)] \\n if a > 0:\\n c = n + 1 - a\\n N.pop(c - 1)\\n N.append(c + a)\\n N[-1] = c + a\\n D = []\\n if a != 0:\\n b -= c\\n D = [c]\\n n = n + 1\\n n += 1\\n while b >= 0:\\n b -= n\\n D.append(n)\\n n += 1\\n D.pop(-1)\\n print(len(D))\\n if len(D) != 0:\\n print(*D)\\n print(len(N))\\n if len(N) != 0:\\n print(*N)\\n\\n"}
{"id": "940", "input": "import sys;\\n\\nnbDancers, nbDances = list(map(int, sys.stdin.readline().split(' ')));\\ndancers = [0]*(nbDancers+1);\\n\\nfor line in sys.stdin:\\n taken = [False, False, False, False];\\n\\n ds = list(map(int, line.split(' ')));\\n\\n for d in ds:\\n taken[dancers[d]] = True;\\n\\n for d inds:\\n if dancers[d] == 0:\\n if not taken[1]:\\n dancers[d] = 1;\\n taken[1]", "gt": "= True;"}
{"id": "941", "input": "a, b, c = sorted(map(int, input().split()))\\nprint(max(0,", "gt": "c - a - b + 1))"}
{"id": "942", "input": "b,k = map(int, input().split())\\na = list(map(int, input().split()))\\nr = 0\\nfor x in", "gt": "a:\\n r = (r*b+x) % 2\\nif r == 0:\\n print('even')\\nelse:\\n print('odd')"}
{"id": "943", "input": "input()\\nl = list(map(int, input().split()))\\nd = {}\\nd2 = {}\\nans = []\\nn = 1\\nfor i in l:\\n i = len(l) - i\\n if i not in d:\\n d[i] = n\\n n += 1\\n if i not in d2:\\n d2[i] = 0\\n if d2[i] >= i:\\n d[i] =", "gt": "n\\n d2[i] = 0\\n n += 1\\n ans.append(d[i])\\n d2[i] += 1\\nnums ="}
{"id": "944", "input": "def main():\\n n = int(input())\\n a = [int(i) for i in input().split()]\\n \\n cnt = 0\\n mi = 10 ** 9\\n for i in a:\\n", "gt": "if i % 2 == 1:\\n cnt ^= 1\\n mi = min(mi, i)\\n \\n if not cnt:\\n mi = 0\\n print(sum(a) - mi)\\n \\n \\nmain()"}
{"id": "945", "input": "import sys\\nimport threading\\nfrom collections import defaultdict\\n\\ndef put():\\n return map(int, input().split())\\n\\ndef dfs(i, p, m):\\n cnt = 1\\n z = 0\\n for j in tree[i]:\\n if j==p: continue\\n if cnt==m: cnt+=1\\n index = edge_index[(i,j)]\\n ans[cnt].append(index)\\n z = max(dfs(j,i,cnt), z)\\n cnt+=1\\n return max(z,cnt-1)\\n\\ndef solve():\\n l =", "gt": "dfs(1,0,0)\\n print(l)\\n for i in range(1, l+1):\\n print(len(ans[i]), *ans[i])\\n \\n\\nn = int(input())\\nedge_index = defaultdict()\\nans = [[] for i in range(n+1)]\\ntree = [[] for i in range(n+1)]\\nfor i in range(n-1):\\n x,y = put()\\n edge_index[(x,y)]=i+1\\n edge_index[(y,x)]=i+1\\n tree[x].append(y)\\n tree[y].append(x)\\n\\nmax_recur_size = 10**5*2 + 1000\\nmax_stack_size = max_recur_size*500\\nsys.setrecursionlimit(max_recur_size)\\nthreading.stack_size(max_stack_size)\\nthread = threading.Thread(target=solve)\\nthread.start()"}
{"id": "946", "input": "def Intersect(aa,bb,xx,yy):\\n a=min(aa,bb)\\n b=max(aa,bb)\\n x=min(xx,yy)\\n y=max(xx,yy)\\n \\n if(a>=x and b<=y):\\n return False\\n if(x>=a and y<=b):\\n return False\\n if(b<=x):\\n", "gt": "return False\\n if(y<=a):\\n return False\\n return True\\n\\nN=int(input())\\n\\ncase=False\\n\\nL=list(map(int,input().split()))\\n\\nfor i in range(N-1):\\n for j in range(i+1,N-1):\\n if(Intersect(L[i],L[i+1],L[j],L[j+1])):\\n case=True\\nif(case):\\n print(\"yes\")\\n\\nelse:\\n print(\"no\")\\n"}
{"id": "947", "input": "\\ninput()\\nl = list(map(int, input().split()))\\nif", "gt": "1 in l:\\n print('HARD')\\nelse:\\n print('EASY')\\n"}
{"id": "948", "input": "from math import sqrt\\ndef solve():\\n n = int(input())\\n for i in range(2, int(sqrt(n)) + 1):\\n if n %", "gt": "i == 0:\\n x = n // i\\n print(x, x * (i-1))\\n return \\n print(n-1,1)\\nfor i in range(int(input())):\\n solve()"}
{"id": "949", "input": "n, m = list(map(int, input().split()))\\n\\nfield = []\\nfor i in range(n):\\n field.append(input())\\n\\nans = 0\\nfor i in range(n - 1):\\n for j in range(m -", "gt": "1):\\n t = set()\\n t.add(field[i][j])\\n t.add(field[i + 1][j + 1])\\n t.add(field[i + 1][j])\\n t.add(field[i][j + 1])\\n\\n if t == set('face'):\\n ans += 1\\nprint(ans)\\n"}
{"id": "950", "input": "a,b = input().split()\\nif", "gt": "(a==b):\\n print(a)\\nelse:\\n print(1)"}
{"id": "951", "input": "import math, re, itertools as it;prime = lambda n: len([i for i in range(2, int(math.sqrt(n) + 1)) if n % i == 0]) == 0;gcd = lambda a, b: gcd(b, a % b) if b else a;fact = lambda x: x * fact(x - 1) if x else 1;bino = lambda n, k: fact(n) / fact(k) / fact(n - k);fib11 = lambda n: 1 if n < 2 else fib11(n - 1) + fib11(n - 2);fib01 = lambda n: 0 if n == 0 else 1 if n == 1 else fib01(n - 1) + fib01(n - 2);sumofd = lambda x: x if x < 10 else sumofd(x // 10) + x % 10\\n\\nn, m = map(int, input().split(' '))\\na = []\\ndp =", "gt": "[]\\nsc = st = sl = 1000000\\nfor _ in range(n):\\n a.append(input())\\n c = t = l = 1000000\\n for i in range(len(a[-1])):\\n if a[-1][i] in '0123456789':\\n c = min(c, i, len(a[-1]) - i)\\n if a[-1][i] in '#*&':\\n t = min(t, i, len(a[-1]) - i)\\n if 'a' <= a[-1][i] <= 'z':\\n l = min(l, i, len(a[-1]) - i)\\n '''if c == t == 1000000 or c == l == 1000000 or l == t == 1000000:\\n if c == t == 1000000:\\n sl = 0\\n if c == l == 1000000:\\n st = 0\\n if l == t == 1000000:\\n sc = 0\\n continue'''\\n dp.append([c, t, l])\\nmm = 1000000\\nkk = it.permutations(list(range(n)), 3)\\nfor i in kk:\\n mm = min(mm, dp[i[0]][0] + dp[i[1]][1] + dp[i[2]][2])\\nprint(mm)"}
{"id": "952", "input": "k = int(input())\\nn = input()\\ndigit = [0]*10\\nfor c in n:\\n digit[int(c)]+= 1\\ndsum = sum(i*digit[i] for i in range(10))\\n\\ni = 0\\nchange", "gt": "= 0\\nwhile dsum < k:\\n if digit[i] == 0:\\n i+= 1\\n continue\\n digit[i]-= 1\\n digit[9]+= 1\\n change+= 1\\n dsum+= 9-i\\nprint(change)"}
{"id": "953", "input": "# problem http://codeforces.com/contest/1100/problem/E\\nimport copy\\nimport sys\\n\\n\\ndef find_loop(g, w, k, n):\\n visited = [False] * n\\n visited_int = [False] * n\\n for i in range(n):\\n if visited[i]:\\n continue\\n stack = [g[i][:]]\\n path = [i]\\n visited[i] = True\\n visited_int[i] = True\\n while stack:\\n if not stack[-1]:\\n stack.pop()\\n visited_int[path[-1]] = False\\n path.pop()\\n continue\\n nxt = stack[-1][-1]\\n stack[-1].pop()\\n if w[(path[-1], nxt)] <= k:\\n continue\\n if visited_int[nxt]:\\n return True\\n if visited[nxt]:\\n continue\\n visited[nxt] = True\\n visited_int[nxt] = True\\n stack.append(g[nxt][:])\\n path.append(nxt)\\n return False\\n\\n\\ndef top_sort(g, w, k, n):\\n visited = [False] * n\\n order = [-1] * n\\n cnt = 0\\n for i in range(n):\\n if visited[i]:\\n continue\\n stack = [g[i][:]]\\n path = [i]\\n visited[i] = True\\n while stack:\\n if not stack[-1]:\\n order[path[-1]] = cnt\\n path.pop()\\n stack.pop()\\n cnt += 1\\n continue\\n nxt = stack[-1][-1]\\n stack[-1].pop()\\n if w[(path[-1], nxt)] <= k:\\n continue\\n if visited[nxt]:\\n continue\\n visited[nxt] = True\\n stack.append(g[nxt][:])\\n path.append(nxt)\\n\\n to_reverse = []\\n for a, b in list(w.items()):\\n if b > k:\\n continue\\n if order[a[0]] < order[a[1]]:\\n to_reverse.append(a)\\n return to_reverse\\n\\n\\ndef __starting_point():\\n n, m = list(map(int, input().split()))\\n w = {}\\n g = [[] for _ in range(n)]\\n w_tmp = {}\\n c_m", "gt": "= 0\\n kk = [0]\\n lines = sys.stdin.readlines()\\n for i, line in enumerate(lines): #range(1, m + 1):\\n u, v, c = list(map(int, line.split()))\\n g[u - 1].append(v - 1)\\n if (u - 1, v - 1) in list(w.keys()):\\n w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)\\n else:\\n w[(u - 1, v - 1)] = c\\n if (u - 1, v - 1) in list(w_tmp.keys()):\\n w_tmp[(u - 1, v - 1)].append(str(i + 1))\\n else:\\n w_tmp[(u - 1, v - 1)] = [str(i + 1)]\\n kk.append(c)\\n # c_m = max(c, c_m)\\n\\n # print(find_loop(copy.deepcopy(g), copy.deepcopy(w), 0, n))\\n\\n kk.sort()\\n l, r = 0, len(kk)\\n if not find_loop(g, w, kk[l], n):\\n print(0, 0)\\n return\\n if find_loop(g, w, kk[-1], n):\\n kkk = kk[-1]\\n else:\\n while l + 1 != r:\\n m = int((l + r) / 2)\\n # if find_loop(copy.deepcopy(g), copy.deepcopy(w), kk[m], n):\\n if find_loop(g, w, kk[m], n):\\n l = m\\n else:\\n r = m\\n kkk = kk[l+1]\\n\\n to_reverse = top_sort(g, w, kkk, n)\\n num = 0\\n s = []\\n for t in to_reverse:\\n num += len(w_tmp[t])\\n s.extend(w_tmp[t])\\n\\n print(kkk, num)\\n print(\" \".join(s))\\n\\n\\n\\n\\n\\n\\n__starting_point()"}
{"id": "954", "input": "\"\"\"\\nCodeforces Contest Good Bye 2014 Contest Problem B\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.4.2\\n\"\"\"\\n\\n################################################### SOLUTION\\n\\ndef main():\\n n, = read()\\n p = read()\\n dsu = DSU()\\n for i in range(n):\\n a = read(0)\\n dsu.make()\\n for j in range(i):\\n if a[j] == \"1\":\\n dsu.union(j, i)\\n used = [0] * n\\n res = [0] * n\\n for i in range(n):\\n if not used[i]:\\n pr = dsu.find(i)\\n indices = []\\n elements = []\\n for j in range(n):\\n if dsu.find(j) == pr:\\n used[j] = 1\\n indices.append(j)\\n elements.append(p[j])\\n elements.sort()\\n for i,e in zip(indices, elements):\\n res[i] = e\\n write(res)\\n\\n#################################################### HELPERS\\n\\nclass DSU(object):\\n \"\"\"\\n Implements disjoint-set data structure as disjoint-set forest, with {0,1,...,n-1} as elements.\\n\\n Methods:\\n make(): add a new element and returns its index\\n find(x): return representative of x\\n union(x, y): merge the sets containing x and y\\n\\n Not to be used publicly:\\n _parent: a list of ints for the parent of each vertex, used internally; call find instead\\n _rank: a list of ints for the rank of trees, ensuring trees are binary and hence O(lg n) worst case\\n __init__(): called when initialization,", "gt": "initialize DSU to be empty\\n __str__(): return a readable string description of the DSU; meant to be printed while debugging\\n \"\"\"\\n\\n def __init__(self):\\n self._parent = []\\n self._rank = []\\n\\n def make(self):\\n i = len(self._parent)\\n self._parent.append(i)\\n self._rank.append(0)\\n return i\\n\\n def find(self, x):\\n if self._parent[x] != x:\\n self._parent[x] = self.find(self._parent[x])\\n return self._parent[x]\\n\\n def union(self, x, y):\\n xr = self.find(x)\\n yr = self.find(y)\\n if xr == yr: return\\n if self._rank[xr] < self._rank[yr]:\\n self._parent[xr] = yr\\n elif self._rank[yr] < self._rank[xr]:\\n self._parent[yr] = xr\\n else:\\n self._parent[yr] = xr\\n self._rank[xr] += 1\\n\\n def __str__(self):\\n s = \"DSU\\n\"\\n for i in range(len(self._parent)):\\n s += str(i) + \" in set \" + str(self.find(i)) + \" with rank \" + str(self._rank[self.find(i)]) + \"\\n\"\\n return s\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "955", "input": "s = input()\\nres = set()\\nfor i in range(len(s)", "gt": "+ 5):\\n s = s[1:] + s[0]\\n res.add(s)\\nprint(len(list(res)))"}
{"id": "956", "input": "n = int(input())\\n\\ndef func(v):\\n res = 0\\n if \"A\" in v: res |= 1\\n if \"B\" in v: res |= 2\\n if \"C\" in v: res |= 4\\n return res\\n\\ncost = [10 ** 10] * 8\\ncost[0]", "gt": "= 0\\nfor _ in range(n):\\n c, v = input().split()\\n c = int(c)\\n v = func(v)\\n for i in range(8):\\n cost[i | v] = min(cost[i | v], cost[i] + c)\\n\\nprint(cost[7] if cost[7] < 10 ** 10 else -1)\\n"}
{"id": "957", "input": "m, k = [int(x) for x in input().split()]\\n\\nseen = 0\\nusers = set()\\nfriendsof = {}\\nfor i in range(m):\\n a, b = [int(x) for x in input().split()]\\n users.add(a)\\n users.add(b)\\n if a in friendsof:\\n friendsof[a].add(b)\\n else:\\n friendsof[a] = set((b,))\\n if b in friendsof:\\n friendsof[b].add(a)\\n else:\\n friendsof[b] =", "gt": "set((a,))\\n\\nusers_sorted = list(users)\\nusers_sorted.sort()\\n\\nfor u in users_sorted:\\n possible = []\\n this_friends = friendsof[u]\\n \\n for v in users_sorted:\\n if v in this_friends: continue\\n if v == u: continue\\n common = friendsof[v].intersection(this_friends)\\n \\n if len(common) * 100 >= k * len(this_friends):\\n possible.append(v)\\n \\n print('"}
{"id": "958", "input": "string = input()\\nnow = 0\\nfor i in range(len(string)):\\n if now == 0 and string[i] == \"h\":\\n now += 1\\n if now == 1 and string[i] == \"e\":\\n now += 1\\n if now == 2", "gt": "and string[i] == \"i\":\\n now += 1\\n if now == 3 and string[i] == \"d\":\\n now += 1\\n if now == 4 and string[i] == \"i\":\\n now += 1\\nif now == 5:\\n print(\"YES\")\\nelse:\\n print(\"NO\")\\n \\n"}
{"id": "959", "input": "def check(s, k):\\n ans = 0\\n for i in range(len(s)):\\n ans += abs(ord(s[i]) - ord(k[i]))\\n return ans\\n\\nn, k = list(map(int, input().split()))\\ns = input()\\ncnt = 0\\nfor i in s:\\n cnt += max(ord('z') - ord(i), ord(i) - ord('a'))\\nif k > cnt:\\n print(-1)\\n return\\nelse:\\n ans = ''\\n cr = 0\\n while k != 0:\\n ps1 = ord(s[cr]) -", "gt": "ord('a')\\n ps2 = ord('z') - ord(s[cr])\\n if ps1 > k:\\n ans += chr(ord(s[cr]) - k)\\n k = 0\\n elif ps2 > k:\\n ans += chr(ord(s[cr]) + k)\\n k = 0 \\n else:\\n if ps2 >= ps1:\\n ans += 'z'\\n k -= ps2\\n else:\\n ans += 'a'\\n k -= ps1\\n cr += 1\\nans += s[len(ans):]\\nprint(ans)\\n#print(check(ans, s))\\n"}
{"id": "960", "input": "\\na,b,mod = list(map(int, input().split()))\\n\\ng = [2] * a\\nfor i in range(b):\\n t = input()\\n for x, y in enumerate(t):\\n if y == '1':\\n g[x] -= 1\\n\\none = two = 0\\nfor q in g:\\n if q < 0:\\n print(0)\\n return\\n\\n if q == 1:\\n one+=1\\n if q == 2:\\n two+=1\\n\\n\\n\\nmat = [[0]*600 for xin range(600)] \\nmat[0][0] = 1\\n#int(one, two)\\nfor j in range(a + 1):\\n for i in range(a + 1):\\n if i-2>=0:\\n mat[i][j] += i*(i-1) // 2 * mat[i-2][j];\\n #print('in',i,j, mat[i][j], i*(i-1)//2, mat[i-2][j], i-2, mat[0][0])\\n if", "gt": "j-1>=0:\\n mat[i][j] += i*j * mat[i][j -1];"}
{"id": "961", "input": "n, k = list(map(int, input().split()))\\nresult = 10 ** 26\\nfor i in range(1, k):\\n if n %", "gt": "i == 0:\\n t = n // i\\n result = min(result, t * k + i)\\nprint(result)\\n"}
{"id": "962", "input": "def dp():\\n dparr = [0] * len(sections)\\n for i in range(len(sections) - 1, -1, -1):\\n _, curend, curcomfort = sections[i]\\n nextsection = i + 1\\n try:\\n while sections[nextsection][0] <= curend:\\n nextsection += 1\\n except IndexError:\\n # Loop til end\\n inc = curcomfort\\n else:\\n inc = curcomfort + dparr[nextsection]\\n exc = 0 if i == len(sections) - 1 else dparr[i + 1]\\n dparr[i] = max(inc, exc)\\n return dparr[0]\\n\\n\\nn = int(input())\\nzs =list(map(int, input().split()))\\nsections = []\\nseenstartz = set()\\nfirst = {z: i for i,", "gt": "z in reversed(list(enumerate(zs)))}"}
{"id": "963", "input": "from collections import deque\\n\\nclass Graph(): #directed\\n def __init__(self, n, edge, indexed=1):\\n self.n = n\\n self.graph = [[] for _ in range(n)]\\n for e in edge:\\n self.graph[e[0] - indexed].append(e[1] - indexed)\\n\\nINF = 10**18\\n\\nN, M = map(int, input().split())\\nedge = [tuple(map(int, input().split())) for _ in range(M)]\\n\\ng = Graph(N, edge)\\n\\nloopsize = INF\\n\\nfor i in range(N):\\n root = i\\n queue = deque([root])\\n dist = [INF for _ in range(N)]\\n dist[root] = 0\\n prev = [None for _ in range(N)]\\n while", "gt": "queue:\\n node = queue.popleft()\\n for adj in g.graph[node]:\\n if adj == root: #閉路を検出する\\n dist[root] = dist[node] + 1\\n prev[root] = node\\n break\\n if dist[adj] != INF:\\n continue\\n dist[adj] = dist[node] + 1\\n prev[adj] = node\\n queue.append(adj)\\n else:\\n continue\\n break\\n else:\\n continue\\n #最小の閉路なら条件を満たす\\n if loopsize > dist[root]:\\n loopsize = dist[root]\\n path = [root]\\n node = root\\n while prev[node] != root:\\n node = prev[node]\\n path.append(node)\\n\\nif loopsize != INF:\\n print(loopsize)\\n for node in path:\\n print(node + 1)\\nelse:\\n print(-1)"}
{"id": "964", "input": "n, k = map(int, input().split())\\nl = [(0, 0) for i in range(k)]\\nfor i in range(k):\\n start, end = map(int, input().split())\\n l[i] = start, end\\n\\ndp = [0 for i in range(n+1)]\\nprefixSum = [0 for i in range(n+1)]\\n\\ndp[1] = 1\\nprefixSum[1] = 1\\n\\nfor i in", "gt": "range(2, n + 1):\\n for j in range(k):\\n start, end = l[j]\\n i_s = max(i - start, 0)\\n i_e = max(i - end -1, 0) \\n dp[i] += prefixSum[i_s] - prefixSum[i_e]\\n dp[i] %= 998244353\\n prefixSum[i] = prefixSum[i-1] + dp[i]\\n prefixSum[i] %= 998244353\\n\\nprint(dp[n])"}
{"id": "965", "input": "import sys\\n\\n\\ndef get_sol(a, b, c, n, reverse):\\n #1\\n if reverse[0]:\\n a = (a[1], a[0], a[2])\\n if reverse[1]:\\n b = (b[1], b[0], b[2])\\n if reverse[2]:\\n c = (c[1], c[0], c[2])\\n\\n\\n ans = []\\n if a[0] == b[0] == c[0] == n:\\n if a[1] + b[1] + c[1] == n:\\n for i in range(a[1]):\\n ans.append(a[2]*n)\\n for i in range(b[1]):\\n ans.append(b[2]*n)\\n for i in range(c[1]):\\n ans.append(c[2]*n)\\n return True, ans\\n if a[0] + c[0] == b[0] + c[0] == n and c[1] == n == a[1] + b[1]:\\n for i in range(a[1]):\\n ans.append(a[2]*a[0] + c[2] * c[0])\\n for i in range(b[1]):\\n ans.append(b[2]*b[0] + c[2] * c[0])\\n return True, ans\\n return False, ans\\n\\ndef printans(ans, n):\\n print(n)\\n for line in ans:\\n", "gt": "print(line)\\n return\\n\\n#sys.stdin = open('input.txt')\\n#sys.stdout = open('output.txt', 'w')\\n\\nx1, y1, x2, y2, x3, y3 = [int(i) for i in input().split()]\\ntotal_area = x1*y1 + x2*y2 + x3*y3\\nn = 0\\nwhile n ** 2 < total_area:\\n n += 1\\nif n ** 2 != total_area:\\n print(-1)\\nelse:\\n first = (x1, y1, 'A')\\n second = (x2, y2, 'B')\\n third = (x3, y3, 'C')\\n pereb = ( (first, second, third),\\n (first, third, second),\\n (second, first, third),\\n (second, third, first),\\n (third, first, second),\\n (third, second, first))\\n for rev1 in (False, True):\\n for rev2 in (False, True):\\n for rev3 in (False, True):\\n for per in pereb:\\n reverse = (rev1, rev2, rev3)\\n is_ans, ans = get_sol(per[0], per[1], per[2], n, reverse)\\n if is_ans: printans(ans, n)\\n \\n \\n print(-1)\\n"}
{"id": "966", "input": "n=int(input())\\na=input()\\ncnt=0\\nA=0\\nfor i in range(0,n):\\n if(a[i]=='I'):", "gt": "cnt+=1\\n if(a[i]=='A'): A+=1\\nif(cnt==0):\\n print(A)\\nelif(cnt==1):\\n print(1)\\nelse :print(0)\\n"}
{"id": "967", "input": "def find(ins):\\n ins += 1\\n \\n test = [int(i) for i in str(ins)]\\n \\n inlist = []\\n \\n for i in test:\\n", "gt": "if i in inlist:\\n \\n test = find(ins)\\n break\\n \\n else:\\n inlist.append(i)\\n \\n return ''.join(str(x) for x in test)\\n \\nins = int(input())\\nprint(find(ins))"}
{"id": "968", "input": "n, ar = int(input()), [int(x) for x in input().split()][::-1]\\nans = 0\\nfor i in range(1,", "gt": "n):\\n if ar[i] > ar[i - 1]: \\n ans = n - i\\n break\\n\\nprint(ans)\\n\\n"}
{"id": "969", "input": "\"\"\"\\nCodeforces Contest 270 Problem C\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef main():\\n n, = read()\\n names = []\\n for i in range(n): names.extend([(x,i+1) for x in read(1)])\\n names.sort()\\n p = read()\\n i = 0\\n j = 0\\n while i < n and j < 2*n:\\n if names[j][1] == p[i]:\\n i += 1\\n j += 1\\n if i == n:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n\\n###################################", "gt": "NON-SOLUTION STUFF BELOW\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "970", "input": "def solve(s,t):\\n hash_s = [False] * 256\\n hash_t = [False] * 256\\n arr = []\\n n = len(s)\\n for c in s:\\n hash_s[ord(c)] = True\\n for c in t:\\n hash_t[ord(c)] = True\\n for i in range(256):\\n if not hash_s[i] and hash_t[i]:\\n print(-1)\\n return\\n rev = s[::-1]\\n i,j = 0,0\\n while i < len(t):\\n flag = True\\n temp = t[i]\\n j = i + 1\\n while j < len(t):\\n temp += t[j]\\n if temp not in s and temp not in rev:\\n flag = False\\n break\\n j += 1\\n if flag:\\n x = s.find(temp)\\n if x", "gt": "!= -1:\\n arr.append((x + 1,x + len(temp)))\\n # print('1',x + 1,x + len(temp))\\n else:\\n y = rev.find(temp)\\n arr.append((n - y,n - y - len(temp) + 1))\\n # print('2',n - y,n - y - len(temp) + 1)\\n else:\\n x = s.find(temp[:-1])\\n if x != -1:\\n arr.append((x + 1,x + len(temp) - 1))\\n # print('3',x + 1,x + len(temp) - 1)\\n else:\\n x = rev.find(temp[:-1])\\n arr.append((n - x,n - x - len(temp) + 2))\\n # print('4',n - x,n - x - len(temp) + 2)\\n i = j\\n print(len(arr))\\n for x,y in arr:\\n print(x,y)\\n\\ns = input()\\nt = input()\\n\\nsolve(s,t)\\n"}
{"id": "971", "input": "def ii():\\n return int(input())\\ndef mi():\\n return map(int, input().split())\\ndef li():\\n return list(mi())\\n\\nn = ii()\\na = li()\\na.sort()\\nc1 = 0\\np = 1\\nfor ai in a:\\n c1 +=", "gt": "abs(ai - p)\\n p += 2\\nc2 = 0\\np = 2\\nfor ai in a:\\n c2 += abs(ai - p)\\n p += 2\\nans = min(c1, c2)\\nprint(ans)"}
{"id": "972", "input": "# You lost the game.\\nn,b,d = list(map(int, input().split()))\\nL = list(map(int, input().split()))\\nr = 0\\nc = 0\\nfor i in", "gt": "range(n):\\n if L[i] <= b:\\n c += L[i]\\n if c > d:\\n r += 1\\n c = 0\\nprint(r)\\n"}
{"id": "973", "input": "def f():\\n n, m = map(int, input().split())\\n t = [input() for j in range(n)]\\n\\n p = [''.join(i) for i in zip(*t)]\\n if h(p): return 1\\n\\n i = 0\\n while i < n and not 'B' in t[i]: i += 1\\n\\n while i < n:\\n a = t[i].find('B')\\n if a < 0:\\n i += 1\\n break\\n b = t[i].rfind('B')\\n if 'W' in t[i][a: b + 1]: return 1\\n\\n for j in range(i + 1, n):\\n if a > 0 and t[j][a - 1] == 'B' and t[j][b] == 'W': return 1\\n if b < m - 1 and t[j][b", "gt": "+ 1] == 'B' and t[j][a] == 'W': return 1\\n i += 1\\n\\n while i < n:\\n if 'B' in t[i]: return 1\\n i += 1 \\n\\n return 0 \\n \\ndef h(t):\\n i, n = 0, len(t)\\n while i < n and not 'B' in t[i]: i += 1\\n\\n while i < n:\\n a = t[i].find('B')\\n if a < 0:\\n i += 1\\n break\\n b = t[i].rfind('B')\\n if 'W' in t[i][a: b + 1]: return 1\\n i += 1\\n\\n while i < n:\\n if 'B' in t[i]: return 1\\n i += 1 \\n\\n return 0 \\n \\nprint('YNEOS'[f():: 2])"}
{"id": "974", "input": "r, c = list(map(int, input().split()))\\nls = [[c for c in input()] for i in range(r)]\\nfor i in range(r):\\n dead = False\\n for j in range(c):\\n if ls[i][j] == 'W':\\n if i != 0 and ls[i - 1][j] == 'S': dead = True\\n if i != r - 1 and ls[i + 1][j] ==", "gt": "'S': dead = True\\n if j != 0 and ls[i][j - 1] == 'S': dead = True\\n if j != c - 1 and ls[i][j + 1] == 'S': dead = True\\n if dead: \\n break\\n elif ls[i][j] == '.':\\n ls[i][j] = 'D'\\n if dead:\\n print(\"No\")\\n break\\nelse:\\n print(\"Yes\")\\n for i in range(r):\\n print(''.join(ls[i]))\\n\\n"}
{"id": "975", "input": "import sys\\n\\ndef main():\\n n = int(input())\\n n = n*2\\n u = 0\\n res = 0\\n x = []\\n for i in range(n):\\n s = sys.stdin.readline()\\n", "gt": "if s[0] == 'r':\\n u+=1\\n if len(x)==0:\\n continue\\n if x[-1] == u:\\n x.pop()\\n else:\\n x = []\\n res +=1\\n else:\\n a,b = s.split()\\n x.append(int(b))\\n print(res)\\n\\n\\nmain()"}
{"id": "976", "input": "n = int(input())\\na = list(input())\\nb = list(input())\\na = [int(i) for i in a]\\nb = [int(i) for i in b]\\na.sort()\\nb.sort()\\nc = a[::]\\nd = b[::]\\nans1 = 0\\nans2 = 0\\nfor i in a:\\n for", "gt": "j in range(len(b)):\\n if b[j] > i:\\n del b[j]\\n ans2 += 1\\n break\\nfor i in c:\\n for j in range(len(d)):\\n if d[j] >= i:\\n del d[j]\\n break\\n else:\\n ans1 += 1\\n\\nprint(ans1)\\nprint(ans2)"}
{"id": "977", "input": "n, x = list(map(int, input().split()))\\nresult = 0\\ncur = 1\\nfor i in range(n):\\n l, r = list(map(int, input().split()))\\n result", "gt": "+= r - l + 1\\n result += (l - cur) % x\\n cur = r + 1\\nprint(result)\\n"}
{"id": "978", "input": "import sys\\nfrom bisect import bisect_right as br\\ninput = sys.stdin.readline\\nn, p = map(int, input().split())\\na = list(map(int, input().split()))\\na.sort()\\ntable = [0] * (10 ** 5 + 1)\\nfor x in range(10 ** 5 + 1):\\n r = br(a, x)\\n table[x] =", "gt": "r\\nres = []\\n#print(table[: 100])\\nfor x in range(1, 2001):\\n t = 1\\n q = x + 0\\n for i in range(n):\\n t *= max(0, table[q] - i)\\n t %= p\\n q += 1\\n if t % p: res.append(x)\\nprint(len(res))\\nprint(*res)"}
{"id": "979", "input": "k=int(input())\\n\\nL={}\\ns=\".123456789\"\\nfor item in s:\\n L[item]=0\\nfor i in range(4):\\n s=input()\\n for item", "gt": "in s:\\n L[item]+=1\\n\\ns=\"123456789\"\\ndone=True\\nfor item in s:\\n if(L[item]>2*k):\\n print(\"NO\")\\n done=False\\n break\\nif(done):\\n print(\"YES\")\\n"}
{"id": "980", "input": "from sys import stdin\\ninput = stdin.readline\\nn,m = map(int,input().split())\\nl = list(map(int,input().split()))\\nif n > m:\\n print(0)\\nelse:\\n res", "gt": "= 1\\n for i in range(n-1):\\n for j in range(i+1,n):\\n res = ((res*abs(l[i]-l[j])) % m)\\n print(res%m)"}
{"id": "981", "input": "read=lambda:list(map(int,input().split()))\\nfrom collections import Counter as co\\nk,n=read()\\ns=input()\\nrepeated=(len(s)!=len(set(s)))\\netalon=co(s)\\na=[]\\nkk=[]\\nap=a.append\\n\\nfor i in range(k-1):\\n ap(input())\\n if co(a[-1])!=etalon:\\n print(-1)\\n return\\n\\nss=False\\nfor i in a:\\n if i!=s:\\n ss=i\\n for j in range(len(s)):\\n if s[j]!=ss[j]:\\n kk.append(j)\\n break\\n\\nif len(kk)>4:\\n print(-1)\\n return\\n\\nif ss:\\n if repeated:\\n for i in a:\\n k = 0\\n for j in range(len(i)):\\n if s[j] != i[j]: k += 1\\n if k != 0 and k != 2: break\\n else:\\n print(s)\\n return\\n\\n if len(kk)!=2:\\n for i in range(len(kk)):\\n for j in range(i):\\n stry=s[:kk[j]]+s[kk[i]]+s[kk[j]+1:kk[i]]+s[kk[j]]+s[kk[i]+1:]\\n #print(stry)\\n for u in a:\\n k = 0\\n for j in range(len(u)):\\n if stry[j] != u[j]: k += 1\\n #print(stry,i,k)\\n", "gt": "if not(k==0 and repeated) and k != 2: break\\n else:\\n print(stry)\\n return\\n\\n if len(kk)==2:\\n for change in kk:\\n for i in range(len(s)):\\n if change==i:\\n continue\\n\\n if i >change:\\n stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\\n else:\\n stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\\n\\n for u in a:\\n k = 0\\n for j in range(len(u)):\\n if stry[j] != u[j]: k += 1\\n #print(stry,i,k)\\n if not(k==0 and repeated) and k != 2: break\\n else:\\n print(stry)\\n return\\n print(-1)\\n\\nelse:\\n if repeated:\\n print(s)\\n return\\n print(s[1]+s[0]+s[2:])\\n"}
{"id": "982", "input": "#!/usr/local/bin/python3.3 -tt\\n\\nimport sys\\n\\ndef __starting_point():\\n def _(f):\\n for l in f:\\n for i in l.split():\\n yield int(i)\\n\\n g = _(sys.stdin)\\n\\n v = next(g)\\n\\n ar = []\\n for i in range(9):\\n ar.append((next(g), i + 1))\\n\\n dominant = min(ar, key=lambda t: (t[0], -t[1]))\\n \\n digits = v // dominant[0]\\n\\n v -= dominant[0] * digits\\n\\n ar = [(a - dominant[0], n) for a, n", "gt": "in ar if a > dominant[0] and n > dominant[1]]\\n \\n ar.sort(key=lambda x: (-x[1], x[0]))\\n\\n print(ar, file=sys.stderr)\\n \\n s = ''\\n\\n for a, n in ar:\\n if a <= v:\\n q = v // a\\n v -= q * a\\n s += str(n) * q\\n\\n s = '%s%s' % (s, str(dominant[1]) * (digits - len(s)))\\n \\n if s:\\n print(s)\\n else:\\n print(-1)\\n\\n__starting_point()"}
{"id": "983", "input": "import sys\\n\\ndef main():\\n #n = int(sys.stdin.readline().strip())\\n n, m = map(int, sys.stdin.readline().split())\\n #q = list(map(int, sys.stdin.readline().split()))\\n if n * 2 > m:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n \\n \\n \\n \\n \\n \\n \\n", "gt": "\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\\nfor i in range(int(sys.stdin.readline().strip())):\\n main()"}
{"id": "984", "input": "\\nimport sys\\n#sys.stdin=open(\"data.txt\")\\ninput=sys.stdin.readline\\n\\nn,p,q,r=map(int,input().split())\\n\\na=list(map(int,input().split()))\\n\\ns1=[a[i]*p for i in range(n)]\\n\\ns2=[]\\nm=s1[0]\\nfor i in", "gt": "range(n):\\n m=max(m,s1[i])\\n s2.append(m+a[i]*q)\\n\\ns3=[]\\nm=s2[0]\\nfor i in range(n):\\n m=max(m,s2[i])\\n s3.append(m+a[i]*r)\\n\\nprint(max(s3))"}
{"id": "985", "input": "from collections import deque\\n\\nnodes = []\\nparents = []\\nvalues = []\\nbroken = []\\nupperBound = []\\nlowerBound = []\\n\\nn = int(input())\\n\\nfor _ in range(n):\\n v, l, r = map(int, input().split())\\n nodes.append((v, l - 1, r - 1))\\n parents.append(-1)\\n values.append(v)\\n broken.append(False)\\n upperBound.append(10 ** 9)\\n lowerBound.append(-10 ** 9)\\n\\nfor i, (v, l, r) in enumerate(nodes):\\n if l > -1:\\n parents[l] = i\\n if r > -1:\\n parents[r] = i\\n\\nroot = -1\\nfor i in range(n):\\n if parents[i] == -1:\\n root = i\\n\\nproc = deque([root])\\nwhile len(proc)", "gt": "> 0:\\n node = proc.popleft()\\n v, l, r = nodes[node]\\n if l > -1:\\n proc.append(l)\\n upperBound[l] = min(upperBound[node], v)\\n lowerBound[l] = lowerBound[node]\\n if not (lowerBound[l] <= nodes[l][0] <= upperBound[l]):\\n broken[l] = True\\n if r > -1:\\n proc.append(r)\\n upperBound[r] = upperBound[node]\\n lowerBound[r] = max(lowerBound[node], v)\\n if not (lowerBound[r] <= nodes[r][0] <= upperBound[r]):\\n broken[r] = True\\n \\ns = set([])\\nfor v, b in zip(values, broken):\\n if not b:\\n s.add(v)\\n\\nans = 0\\nfor v in values:\\n if v not in s:\\n ans += 1\\n\\nprint(ans)"}
{"id": "986", "input": "a=[0]*2222\\nb=[0]*2222\\nr=0\\nfor _ in range(int(input())):\\n", "gt": "x,y=map(int,input().split())\\n r+=a[x+y]+b[x-y+1111]\\n a[x+y]+=1\\n b[x-y+1111]+=1\\nprint(r)"}
{"id": "987", "input": "n, k = list(map(int, input().split()))\\na = list(map(int, input().split()))\\nlibrary = []\\nmoney = 0\\nfor i in range(len(a)):\\n if a[i] not in library:\\n money += 1\\n if len(library) < k:\\n library.append(a[i])\\n", "gt": "else:\\n curmin = n\\n curindex = 0\\n found = [n] * len(library)\\n for j in range(len(a[i+1::])):\\n if (a[i+j+1] in library) and (found[library.index(a[i+j+1])]==n):\\n found[library.index(a[i+j+1])] = j\\n library[found.index(max(found))] = a[i]\\nprint(money)\\n"}
{"id": "988", "input": "from collections import defaultdict\\nimport sys\\ninput = sys.stdin.readline\\nN, M = list(map(int, input().split()))\\n\\n\\nparent = [i for i in range(N)]\\nrank = [0] * N\\n\\n\\ndef find(i):\\n if parent[i] == i:\\n return i\\n else:\\n parent[i] = find(parent[i])\\n return parent[i]\\n\\n\\ndef same(x, y):\\n return find(x) == find(y)\\n\\n\\ndef unite(x, y):\\n x = find(x)\\n y = find(y)\\n if x == y:\\n return\\n\\n if rank[x] > rank[y]:\\n parent[y] = x\\n else:\\n parent[x] =", "gt": "y\\n if rank[x] == rank[y]:\\n rank[y] += 1\\n\\n\\nP = list(map(int, input().split()))\\nfor i in range(M):\\n a, b = list(map(int, input().split()))\\n a, b = a - 1, b - 1\\n unite(a, b)\\n\\n\\nd = defaultdict(list)\\ncnt = defaultdict(int)\\nfor i in range(N):\\n d[find(i)].append(P[i])\\n\\nfor i in range(N):\\n if find(i) == i:\\n d[i] = sorted(d[i], reverse=True)\\n\\nans = []\\nfor i in range(N):\\n k = find(i)\\n ans.append(d[k][cnt[k]])\\n cnt[k] += 1\\n\\nprint(' '.join(map(str, ans)))\\n"}
{"id": "989", "input": "import sys\\n\\nfin = sys.stdin\\nfout = sys.stdout\\n\\na = [0] * 6\\nfor i in range(6):\\n a[i] = [0] * 6\\nfor i in range(2):\\n a[i][0] = 3\\n a[i][1] = 3\\n a[i][2] = 4\\n a[i][3] = 4\\n a[i][4] = 3\\n a[i][5] = 3\\nfor i in range(2, 4):\\n a[i][0] = 2\\n a[i][1] = 2\\n a[i][2] = 3\\n a[i][3] = 3\\n a[i][4] = 2\\n a[i][5] = 2\\nfor i in range(4, 6):\\n a[i][0] = 1\\n a[i][1] = 1\\n a[i][2] = 2\\n a[i][3] = 2\\n a[i][4] = 1\\n", "gt": "a[i][5] = 1\\n\\nansI = -1\\nansJ = -1\\n\\nmax = -1\\n\\nansL = []\\n\\nfor i in range(6):\\n s = fin.readline().strip()\\n ansL.append(s)\\n s = s.replace(\"-\", \"\")\\n for j in range(6):\\n if s[j] == '.' and a[i][j] > max:\\n max = a[i][j]\\n ansI = i\\n ansJ = j\\n\\n# print(ansI, ansJ)\\nfor i in range(len(ansL)):\\n cur = ansL[i]\\n realJ = -1\\n for j in range(len(cur)):\\n if (cur[j] != '-'):\\n realJ += 1\\n if i == ansI and realJ == ansJ and cur[j] != '-':\\n fout.write('P')\\n else:\\n fout.write(cur[j])\\n\\n fout.write(\"\\n\")\\nfin.close()\\nfout.close()\\n"}
{"id": "990", "input": "n, k = map(int, input().split())\\na = list(map(int, input().split()))\\n\\ncnt = {}\\nfor elem in a:\\n if elem in cnt:\\n cnt[elem] += 1\\n else:\\n cnt[elem] = 1\\ncnt = sorted(list(cnt.items()))\\nfor i in range(len(cnt)):\\n cnt[i] = list(cnt[i])\\nleft = 0\\nright = len(cnt) - 1\\nwhile k > 0:\\n if k < cnt[left][1] and k < cnt[right][1]:\\n break\\n if left == right:\\n break\\n if cnt[left][1] <= cnt[right][1]:\\n if k >= cnt[left][1] * (cnt[left + 1][0]", "gt": "- cnt[left][0]):\\n k -= cnt[left][1] * (cnt[left + 1][0] - cnt[left][0])\\n cnt[left + 1][1] += cnt[left][1]\\n left += 1\\n else:\\n cnt[left][0] += k // cnt[left][1]\\n k = 0\\n else:\\n if k >= cnt[right][1] * (cnt[right][0] - cnt[right - 1][0]):\\n k -= cnt[right][1] * (cnt[right][0] - cnt[right - 1][0])\\n cnt[right - 1][1] += cnt[right][1]\\n right -= 1\\n else:\\n cnt[right][0] -= k // cnt[right][1]\\n k = 0\\nprint(cnt[right][0] - cnt[left][0])"}
{"id": "991", "input": "from collections import defaultdict\\n\\n\\ndef dfs(s, t):\\n visited = 0\\n q = [(s, 0)]\\n while q:\\n v, used = q.pop()\\n if v == t:\\n return used\\n visited |= used\\n for lb, u in graph[v]:\\n if lb & visited:\\n continue\\n q.append((u, used | lb))\\n\\n\\nn = int(input())\\ngraph = [[] for _ in range(n + 1)]\\nfor i in range(n - 1):\\n a, b =list(map(int, input().split()))\\n lb = 1 << i\\n graph[a].append((lb, b))\\n graph[b].append((lb, a))\\n\\nconditions = []\\nm = int(input())\\nfor i in range(m):\\n u, v = list(map(int, input().split()))\\n conditions.append(dfs(u, v))\\n\\nlink_conditions = [int(''.join(b), 2) for b in zip(*list(map(('{:0' + str(n -", "gt": "1) + 'b}"}
{"id": "992", "input": "import heapq\\n\\ncity_num, road_num, init_silver = map(int, input().split())\\nMAX_COST = 2500\\ninit_silver = min(MAX_COST, init_silver)\\n\\nG = [[] for _ in range(city_num)]\\nfor _ in range(road_num):\\n A, B, cost, time_cost = map(int, input().split())\\n A, B = A-1, B-1\\n G[B].append([A, cost, time_cost])\\n G[A].append([B, cost, time_cost])\\n\\nfor n in range(city_num):\\n cost, time_cost = map(int, input().split())\\n G[n].append([n, -cost, time_cost])\\n\\ndp = [[float(\"inf\")] * (MAX_COST+1)", "gt": "for _ in range(city_num)]\\ndp[0][init_silver] = 0\\nhq = [(0, 0, init_silver)]\\nwhile hq:\\n time, node, silver = heapq.heappop(hq)\\n for to, silver_cost, time_cost in G[node]:\\n remain = min(silver - silver_cost, MAX_COST)\\n if remain < 0:\\n continue\\n dp_next_value = time + time_cost\\n if dp[to][remain] <= dp_next_value:\\n continue\\n dp[to][remain] = dp_next_value\\n heapq.heappush(hq, (dp_next_value, to, remain))\\nprint(*[min(d) for d in dp[1:]], sep=\"\\n\")"}
{"id": "993", "input": "import numpy as np\\nn,s=map(int,input().split())\\na=list(map(int,input().split()))\\nmod=998244353\\ndp=np.zeros([n+1,s+1],int)\\ndp[0][0]=1\\nfor i", "gt": "in range(1,n+1):\\n dp[i][:]=dp[i-1][:]*2\\n dp[i][a[i-1]:]+=dp[i-1][:-a[i-1]]\\n dp[i][:]%=mod\\nprint(dp[n][s])"}
{"id": "994", "input": "#!/usr/bin/env python3\\n\\nimport numpy as np\\nfrom scipy.special import comb\\n\\nn, m = list(map(int, input().split()))\\na = list(map(int, input().split()))\\n\\na_sum = np.cumsum(a)\\n\\n\\nre_list = {}\\nre_list[0] = 1\\nfor i in a_sum:\\n re", "gt": "= i % m\\n if re in re_list:\\n re_list[re] += 1\\n else:\\n re_list[re] = 1\\n\\n# print(re_list)\\nans = 0\\nfor value in list(re_list.values()):\\n ans += comb(value, 2, exact=True)\\n\\nprint(ans)\\n"}
{"id": "995", "input": "3\\n\\nimport sys\\n\\n(n, m) = list(map(int, input().split()))\\n\\nfirstData = None \\n\\nmaxHeight = -1\\n\\nfor i in range(m):\\n (d, h) = list(map(int, input().split()))\\n\\n if firstData is None:\\n firstData = (d, h)\\n else:\\n if (d - prevD) < abs(h - prevH):\\n print (\"IMPOSSIBLE\")\\n return\\n maxH = max(h, prevH)\\n minH = min(h, prevH)\\n resource", "gt": "= d - prevD - (maxH - minH) # \"free\" days for going up-down\\n possibleH = maxH + resource // 2\\n maxHeight = max(maxHeight, possibleH)\\n\\n (prevD, prevH) = (d, h)\\n lastData = (d, h)\\n\\nmaxHeight = max(maxHeight, firstData[1] + firstData[0] - 1)\\nmaxHeight = max(maxHeight, lastData[1] + (n - lastData[0]))\\n\\nprint (maxHeight)\\n"}
{"id": "996", "input": "#!/usr/bin/env python3\\n\\nfrom math import sqrt\\n\\nprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\\n 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193,\\n 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307,\\n 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421,\\n 431, 433, 439, 443, 449, 457, 461, 463] \\n\\npsq = [p*p for p in primes]\\n\\n\\ndef sqfree(x):\\n if x == 0:\\n return x\\n y = 1\\n for p,", "gt": "pp in zip(primes, psq):\\n while x % pp == 0:\\n x //= pp\\n if x % p == 0:\\n x //= p\\n y *= p\\n if abs(x) < p:\\n break\\n if int(sqrt(abs(x)))**2 == abs(x):\\n return (y if x > 0 else -y)\\n else:\\n return x * y\\n\\nn = int(input().strip())\\nais = list(map(int, input().strip().split()))\\nbis = list(map(sqfree, ais))\\n\\n\\nprev = [-1 for i in range(n)]\\nlast ="}
{"id": "997", "input": "def main():\\n s = input().split()\\n n, m, k = int(s[0]), int(s[1]), int(s[2])\\n processor = []\\n for x in range(n):\\n for y in range(m):\\n s = input()\\n for z in s:\\n processor.append(int(z) == 1)\\n if x < n - 1:\\n emptyLine = input()\\n counter = 0\\n mk = m * k\\n nmk = n * mk\\n for i in range(nmk):\\n if not processor[i]:\\n continue\\n # back\\n if i >= mk:\\n if processor[i - mk]:\\n # front\\n if i < (nmk - mk):\\n if processor[i + mk]:\\n counter += 1\\n continue\\n # right\\n if (i % k) < (k - 1):\\n if processor[i + 1]:\\n if not processor[i - mk + 1]:\\n counter += 1\\n continue\\n # down\\n if (i % mk) < (mk - k):\\n if processor[i + k]:\\n if not processor[i - mk + k]:\\n counter += 1\\n continue\\n # left\\n if (i % k) > 0:\\n if", "gt": "processor[i - 1]:\\n # front\\n if i < (nmk - mk):\\n if processor[i + mk]:\\n if not processor[i + mk - 1]:\\n counter += 1\\n continue\\n # right\\n if (i % k) < (k - 1):\\n if processor[i + 1]:\\n counter += 1\\n continue\\n # down\\n if (i % mk) < (mk - k):\\n if processor[i + k]:\\n if not processor[i + k - 1]:\\n counter += 1\\n continue\\n # up\\n if (i % mk) >= k:\\n if processor[i - k]:\\n # front\\n if i < (nmk - mk):\\n if processor[i + mk]:\\n if not processor[i + mk - k]:\\n counter += 1\\n continue\\n # right\\n if (i % k) < (k - 1):\\n if processor[i + 1]:\\n if not processor[i - k + 1]:\\n counter += 1\\n continue\\n # down\\n if (i % mk) < (mk - k):\\n if processor[i + k]:\\n counter += 1\\n continue\\n print(counter)\\n\\n\\nmain()\\n"}
{"id": "998", "input": "#!/usr/bin/env python3\\n\\nimport re\\n\\ntry:\\n while True:\\n a = [ ]\\n b = [ ]\\n for word in re.split(R\"[,;]\", input()):\\n (a if", "gt": "re.match(R\"^(0|[1-9][0-9]*)$\", word) else b).append(word)\\n print('\"%s\"' % ','.join(a) if a else '-')\\n print('\"%s\"' % ','.join(b) if b else '-')\\n\\nexcept EOFError:\\n pass\\n"}
{"id": "999", "input": "n, x = list(map(int, input().split()))\\na = []\\nlst = 0\\nfor i in range(1, 1 << n):\\n if", "gt": "i ^ x > i:\\n a.append(i ^ lst)\\n lst = i\\nprint(len(a))\\nprint(' '.join(str(i) for i in a))\\n"}
{"id": "1000", "input": "import math\\nimport itertools\\n\\n\\ndef ria():\\n return [int(i) for i in input().split()]\\n\\n\\nmx = 0\\n\\nsz = ria()[0]\\nmx1 = 0\\nmn1 = 2000000000\\n\\nfor i in range(sz):\\n l, r = ria()\\n mx1 = max(l, mx1)\\n mn1 = min(r,", "gt": "mn1)\\n\\nsz = ria()[0]\\nmx2 = 0\\nmn2 = 2000000000\\n\\nfor i in range(sz):\\n l, r = ria()\\n mx2 = max(l, mx2)\\n mn2 = min(r, mn2)\\n#print(mx1,mn1,mx2,mn2)\\nmx = max(mx, mx1 - mn2)\\nmx = max(mx, mx2 - mn1)\\nprint(mx)"}
{"id": "1001", "input": "n,v = map(int,input().split())\\nreq = n-1\\n\\nif req<=v:\\n print (req)\\nelse:\\n total = v\\n", "gt": "remaining = req-v\\n for x in range(remaining):\\n total += 2+x\\n print (total)"}
{"id": "1002", "input": "n = int(input())\\na = [0] * n\\na = list(map(int, input().split()))\\nfor i in range(1, len(a)):\\n a[i] += a[i", "gt": "- 1]\\n\\nans = a[-1]\\nfor i in range(n - 2, 0, -1):\\n ans = max(ans, a[i] - ans)\\nprint(ans)"}
{"id": "1003", "input": "\"\"\"\\nCodeforces Round 251 Div 2 Problem A\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0:\\n return inputs\\n if mode == 1:\\n return", "gt": "inputs.split()\\n if mode == 2:\\n return [int(x) for x in inputs.split()]\\n\\ndef write(s=\"\\n\"):\\n if isinstance(s, list): s = \" \".join(s)\\n s = str(s)\\n print(s, end=\"\")\\n\\n################################################### SOLUTION\\nn,d = read()\\nt = read()\\ns = sum(t) + 10*n - 10\\nif s > d:\\n print(-1)\\nelse:\\n print((d-sum(t))//5)"}
{"id": "1004", "input": "\"\"\"\\nCodeforces Contest 262 Div 2 Problem A\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef main():\\n n,m = read()\\n i = 0\\n while n:\\n n -= 1\\n i += 1\\n if not i%m: n += 1\\n print(i)\\n\\n################################### NON-SOLUTION STUFF BELOW\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n #", "gt": "2: List of integers\\n inputs = input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "1005", "input": "import sys\\nfrom collections import Counter\\nreadline = sys.stdin.readline\\n\\nN = int(readline())\\nA = list(map(int, readline().split()))\\n\\nS = set()\\n\\nans = True\\nAns = [] \\ncnt = 0\\nfor a in A:\\n cnt += 1\\n if a > 0:\\n S.add(a)\\n else:\\n a = -a\\n if a not in S:\\n ans = False\\n", "gt": "break\\n S.remove(a)\\n if not S:\\n Ans.append(cnt)\\n cnt = 0\\n\\nif cnt:\\n ans = False\\n\\nif ans:\\n A.reverse()\\n for c in Ans:\\n CA = Counter()\\n for _ in range(c):\\n CA[abs(A.pop())] += 1\\n if any(v > 2 for v in CA.values()):\\n ans = False\\n break\\n\\nif ans:\\n print(len(Ans))\\n print(*Ans)\\nelse:\\n print(-1)"}
{"id": "1006", "input": "for i in range(int(input())):\\n n, k, d = map(int, input().split())\\n a = list(map(int, input().split()))\\n ans =", "gt": "d\\n for day in range(n - d + 1):\\n ans = min(ans, len(set(a[day:day + d])))\\n print(ans)"}
{"id": "1007", "input": "n = int(input())\\narr = []\\nfor i in range(n):\\n arr.append(list(input()))\\nk = 1\\nfor i in range(n):\\n for j in range(n):\\n if arr[i][j] == '#':\\n if i+2<=n-1 and j-1>=0 and j+1<=n-1:\\n if arr[i+1][j-1] == '#' and arr[i+1][j] == '#' and", "gt": "arr[i+1][j+1] == '#' and arr[i+2][j] == '#':\\n arr[i+1][j-1] = '.'\\n arr[i+1][j] = '.'\\n arr[i+1][j+1] = '.'\\n arr[i+2][j] = '.'\\n arr[i][j] = '.'\\n else:\\n k = 0\\n break\\n else:\\n k = 0\\n break\\nif k == 1:\\n print('YES')\\nelse:\\n print('NO')"}
{"id": "1008", "input": "from itertools import *\\n\\n\\nk, p = list(map(int, input().split()))\\nss = 0\\nfor i in range(1, k +", "gt": "1):\\n s = str(i)\\n num = int(s + ''.join(reversed(s)))\\n ss += num\\n ss %= p\\nprint(ss)\\n"}
{"id": "1009", "input": "def check(pali):\\n for i in range(len(pali) // 2):\\n if pali[i] != pali[-i - 1]:\\n return False\\n\\n return True\\n\\n\\ndef __starting_point():\\n s = input()\\n k = int(input())\\n\\n if len(s)", "gt": "% k != 0:\\n print('NO')\\n return\\n\\n step = len(s) // k\\n for i in range(k):\\n if not check(s[i * step: (i + 1) * step]):\\n print('NO')\\n return\\n\\n print('YES')\\n__starting_point()"}
{"id": "1010", "input": "n, k = list(map(int,input().split()))\\nL = list(map(int,input().split()))\\ni = 0\\np = 0\\nz = 1\\nR = [0 for _ in range(k)]\\nwhile i<n:\\n R[p] += L[n-1-i]\\n p = p + z\\n", "gt": "i+=1\\n if p == k or p == -1:\\n z = z*(-1)\\n if p == k:\\n p = p - 1\\n else:\\n p = p + 1\\nprint(max(R))\\n\\n"}
{"id": "1011", "input": "x = int(input())\\ny = list(map(int, input().split(' ')))\\nif y == [0] * x:\\n print(0)\\n quit()\\nfor i in range(x):\\n if y[i] == 1:\\n y = y[i:]\\n break\\n\\ny.reverse()\\nfor i in range(len(y)):\\n if y[i] == 1:\\n y =", "gt": "y[i:]\\n break\\n\\ny.reverse()\\n\\nl = []\\nct = 0\\nfor i in y:\\n if i == 0:\\n ct+=1\\n if i == 1 and ct != 0:\\n l.append(ct)\\n ct = 0\\n\\nk = 1\\nfor i in l:\\n k *= (i+1)\\n\\nprint(k)\\n"}
{"id": "1012", "input": "\"\"\"\\nCodeforces Contest 281 Div 2 Problem C\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef main():\\n n, = read()\\n a = read()\\n res = [(i,0) for i in a]\\n m, = read()\\n b = read()\\n res.extend((i,1) for i in b)\\n res.sort()\\n mxa = 3*n\\n mnb = 3*m\\n cra = 3*n\\n crb = 3*m\\n for _,i in res:\\n if i:\\n crb -= 1\\n if cra-crb > mxa-mnb:\\n mxa = cra\\n mnb = crb\\n", "gt": "else:\\n cra -= 1\\n print(str(mxa) + \":\" + str(mnb))\\n\\n################################### NON-SOLUTION STUFF BELOW\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "1013", "input": "# map(int, input())\\nt = int(input())\\nfor i in range(t):\\n s", "gt": "= sorted(input())\\n if s[0] == s[-1]:\\n print(-1)\\n continue\\n print(''.join(s))"}
{"id": "1014", "input": "n, m = list(map(int, input().split()))\\nA = [input().split() for i in range(n)]\\nT = False\\nfor i in range(n):\\n for j in range(m):\\n if A[i][j] == '1' and", "gt": "(i == 0 or j == 0 or i == n - 1 or j == m - 1):\\n T = True\\nif T:\\n print(2)\\nelse:\\n print(4)\\n"}
{"id": "1015", "input": "\"\"\"\\nCodeforces Contest 281 Div 2 Problem D\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef main():\\n n, = read()\\n if n%2:\\n print(\"black\")\\n else:\\n print(\"white\")\\n print(\"1 2\")\\n\\n################################### NON-SOLUTION STUFF BELOW\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs =", "gt": "input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "1016", "input": "# import numpy as npy\\n# idx=sorted(idx,key=functools.cmp_to_key(cmpx))\\nimport bisect\\nimport array\\nimport functools\\nimport math\\n\\nn=int(input())\\na=array.array('i',map(int,input().split()))\\ns=0\\nq=[]\\nq.append(0)\\nfor i in range(n):\\n if a[i]==1:\\n q.append(i+1)\\n s=s+1\\nq.append(n+1)\\nm=n*(n-1)//2\\nf=[[10000000 for i in range(82)] for i in range(3500)]\\nf[0][0]=0\\nfor i in range(1,s+2):\\n rlim=n+1-(s+1-i)\\n g=[[10000000 for", "gt": "i in range(82)] for i in range(3500)]\\n for j in range(i-1,rlim+1):\\n for S in range(m+1):\\n if (f[S][j]<1000000):\\n for k in range(j+1,rlim+1):\\n nv=f[S][j]+(k-j-1)*(k-j-2)//2\\n nS=S+abs(k-q[i])\\n g[nS][k]=min(g[nS][k],nv)\\n f=g\\nmn=0\\nfor i in range(m+1):\\n mn=max(mn,(n-s)*(n-s-1)//2-f[i][n+1])\\n print(mn,end=' ')"}
{"id": "1017", "input": "def dfs(v, root):\\n nonlocal cnt\\n if used[v]:\\n return\\n used[v] = True\\n for j in range(len(G[v])):\\n to = G[v][j]\\n dfs(to, root)\\n if v == root:\\n cnt += 1\\n\\ncnt = 0\\nn, e = map(int, input().split())\\nG", "gt": "= [[] for i in range(n)]\\nfor i in range(e):\\n a, b = map(lambda x:int(x) - 1, input().split())\\n G[a].append(b)\\n G[b].append(a)\\n\\nused = [False for i in range(n)]\\nfor v in range(n):\\n dfs(v, v)\\nprint(2 ** (n - cnt))"}
{"id": "1018", "input": "n = int(input())\\nif n % 3 == 0:\\n print(2 *", "gt": "(n // 3))\\nelse:\\n print(2 * (n // 3) + 1)\\n"}
{"id": "1019", "input": "import sys\\n\\ndef Min(x, y):\\n if x > y:\\n return y\\n else:\\n return x\\n\\ndef Gcd(x, y):\\n if x == 0:\\n return y\\n else:\\n return Gcd(y % x, x)\\n\\ndef Lcm(x, y):\\n return x * y // Gcd(x, y)\\n\\nn = int(input())\\na = [int(i) for i in input().split()]\\nd = [int(0) for i in range(0, n)]\\n\\nok = 0\\n\\ncur = 0\\n\\nlen = Lcm(7, n)\\n\\nfor i in range(0, 7 * n):\\n if a[i % n] == 0 :\\n print(i % n + 1)\\n ok = 1\\n break\\n if cur != 6:\\n a[i % n] -= 1\\n d[i % n] += 1\\n cur = (cur + 1)", "gt": "% 7\\n\\nif ok == 0:\\n k = 10**20\\n\\n for i in range(0, n):\\n a[i] += d[i]\\n if d[i] == 0: continue\\n if a[i] % d[i] > 0:\\n k = Min(k, a[i] // d[i])\\n else:\\n k = Min(k, a[i] // d[i] - 1)\\n\\n if k == 10**20:\\n k = 0\\n\\n for i in range(0, n):\\n a[i] -= k * d[i]\\n\\n iter = 0\\n cur = 0\\n\\n while True:\\n if a[iter] == 0:\\n print(iter % n + 1)\\n break\\n else:\\n if cur != 6:\\n a[iter] -= 1\\n cur = (cur + 1) % 7\\n iter = (iter + 1) % n\\n\\n"}
{"id": "1020", "input": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\\n\\nsys.setrecursionlimit(10**7)\\ninf = 10**20\\ngosa = 1.0 / 10**10\\nmod = 10**9+7\\n\\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\\ndef LS(): return", "gt": "sys.stdin.readline().split()\\ndef I(): return int(sys.stdin.readline())\\ndef F(): return float(sys.stdin.readline())\\ndef S(): return input()\\n\\n\\ndef main():\\n n = I()\\n a = n//2\\n b = n-a\\n while fractions.gcd(a,b) > 1:\\n a -= 1\\n b += 1\\n\\n return \""}
{"id": "1021", "input": "w, h, k = map(int, input().split())\\nans = 0\\nfor i in range(k):\\n ans += w *", "gt": "2 + (h - 2) * 2\\n #print(ans, h, w)\\n w -= 4\\n h -= 4\\nprint(ans)"}
{"id": "1022", "input": "n = int(input())\\na = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\n\\ndef dif(x):\\n c = []\\n for i in range(n-1):\\n", "gt": "c.append(x[i+1] - x[i])\\n return c\\n\\nif list(sorted(dif(a))) == list(sorted(dif(b))) and a[0] == b[0] and a[n-1] == b[n-1]:\\n print('Yes')\\nelse:\\n print('No')"}
{"id": "1023", "input": "n=int(input())\\n#x,y,z,t1,t2,t3=map(int,input().split())\\na=list(map(int,input().split()))\\nb=list(map(int,input().split()))\\n\\ns=[0]*n\\n\\nans=True\\n\\nfor i in range(n):\\n ans=ans and a[i]<=i and b[i]<=(n-i-1)\\n s[i]=n-a[i]-b[i]\\n\\ndef qwe(s,j):\\n l,r=0,0\\n for i in range(len(s)):\\n if i<j and s[i]>s[j]: l+=1\\n elif i>j and s[i]>s[j]:", "gt": "r+=1\\n return l,r\\n\\n\\n\\nif ans:\\n for i in range(n):\\n l,r=qwe(s,i)\\n ans=ans and a[i]==l and b[i]==r\\n \\n \\n\\n \\nif ans:\\n print('YES')\\n for i in range(n):\\n print(n-a[i]-b[i],end=' ')\\nelse: print('NO')\\n\\n\\n\\n"}
{"id": "1024", "input": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\\nimport random\\n\\nsys.setrecursionlimit(10**7)\\ninf = 10**20\\neps = 1.0 / 10**10\\nmod = 10**9+7\\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\\n\\ndef LI(): return list(map(int, sys.stdin.readline().split()))\\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\\ndef LS(): return sys.stdin.readline().split()\\ndef I(): return int(sys.stdin.readline())\\ndef F(): return float(sys.stdin.readline())\\ndef S(): return input()\\ndef pf(s): return print(s, flush=True)\\ndef pe(s): return print(str(s), file=sys.stderr)\\n\\n\\ndef main():\\n n,m,ta,tb,k = LI()\\n", "gt": "a = LI()\\n b = LI()\\n if k >= n or k >= m:\\n return -1\\n\\n r = 0\\n bi = 0\\n for i in range(k+1):\\n c = a[i] + ta\\n while bi < m and b[bi] < c:\\n bi += 1\\n\\n if bi + (k-i) >= m:\\n return -1\\n t = b[bi + (k-i)] + tb\\n if r < t:\\n r = t\\n\\n return r\\n\\n\\nprint(main())\\n\\n"}
{"id": "1025", "input": "\\n\\n# Python3 program to count inversions using \\n# Binary Indexed Tree \\n \\n# Returns sum of arr[0..index]. This function \\n# assumes that the array is preprocessed and \\n# partial sums of array elements are stored \\n# in BITree[]. \\ndef getSum( BITree, index): \\n sum = 0 # Initialize result \\n \\n # Traverse ancestors of BITree[index] \\n while (index > 0): \\n \\n # Add current element of BITree to sum \\n sum += BITree[index] \\n \\n # Move index to parent node in getSum View \\n index -= index & (-index) \\n \\n return sum\\n \\n# Updates a node in Binary Index Tree (BITree) \\n# at given index in BITree. The given value \\n# 'val' is added to BITree[i] and all of its \\n# ancestors in tree. \\ndef updateBIT(BITree, n, index, val): \\n \\n # Traverse all ancestors and add 'val' \\n while (index <= n): \\n \\n # Add 'val' to current node of BI Tree \\n BITree[index] += val \\n \\n # Update index to that of parent \\n # in update View \\n index += index & (-index) \\n \\n# Returns count of inversions of size three \\ndef getInvCount(arr, n): \\n \\n invcount = 0 # Initialize result \\n \\n # Find maximum element in arrays \\n maxElement = max(arr) \\n \\n # Create a BIT with size equal to \\n", "gt": "# maxElement+1 (Extra one is used \\n # so that elements can be directly \\n # be used as index) \\n BIT = [0] * (maxElement + 1) \\n for i in range(1, maxElement + 1): \\n BIT[i] = 0\\n for i in range(n - 1, -1, -1): \\n invcount += getSum(BIT, arr[i] - 1) \\n updateBIT(BIT, maxElement, arr[i], 1) \\n return invcount \\n\\ndef getInvCountAdv(arr, n): \\n \\n invcount = 0 # Initialize result \\n \\n # Find maximum element in arrays \\n maxElement = max(arr) \\n \\n # Create a BIT with size equal to \\n # maxElement+1 (Extra one is used \\n # so that elements can be directly \\n # be used as index) \\n BIT = [0] * (maxElement + 1) \\n for i in range(1, maxElement + 1): \\n BIT[i] = 0\\n for i in range(n - 1, -1, -1): \\n invcount += (i + 1) * getSum(BIT, arr[i] - 1) \\n updateBIT(BIT, maxElement, arr[i], n-i) \\n return invcount \\n \\n# Driver code \\nn = int(input())\\na = list(map(int,input().split())) \\nInvCount = getInvCount(a, n)\\nInvCountAdv = getInvCountAdv(a,n)\\nthirdSum = 0\\nfor i in range(1,n+1):\\n thirdSum += i * (i - 1) * (n- i + 1) / 2\\nprint(InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1)))\\n \\n# This code is contributed by \\n# Shubham Singh(SHUBHAMSINGH10) \\n"}
{"id": "1026", "input": "from fractions import gcd\\nfrom collections import defaultdict\\n\\ndef read_data():\\n n = int(input())\\n points = []\\n for i in range(n):\\n x, y = map(int, input().split())\\n points.append((x, y))\\n return n, points\\n\\ndef solve(n, points):\\n if n <= 2:\\n return 0\\n zeros = 0\\n for i, (x, y) in enumerate(points[:-2]):\\n zeros += count_zeros(i, x, y, points)\\n return n * (n-1) * (n-2) // 6 - zeros\\n\\ndef", "gt": "count_zeros(i, x, y, points):\\n slopes = defaultdict(int)\\n for xj, yj in points[i + 1:]:\\n dx = x - xj\\n dy = y - yj\\n d = gcd(dx, dy)\\n slope = (dx/d, dy/d)\\n slopes[slope] += 1\\n zeros = 0\\n for val in slopes.values():\\n if val >= 2:\\n zeros += val * (val - 1)\\n return zeros // 2\\n\\nn, points = read_data()\\nprint(solve(n, points))"}
{"id": "1027", "input": "n = int(input())\\nB = list(map(int, input().split()))\\npp = {}\\nfor i in range(n):\\n if B[i] - (i + 1) not in pp:\\n pp[B[i]", "gt": "- (i + 1)] = 0\\n pp[B[i] - (i + 1)] += B[i]\\nans = 0\\nfor c in pp:\\n ans = max(ans, pp[c])\\nprint(ans)"}
{"id": "1028", "input": "def f(a, ind):\\n if a[ind] == 0:\\n return -1\\n k = a[ind] // 14\\n x = a[ind] % 14\\n b = a[:]\\n b[ind] = 0\\n for j in range(14):\\n b[j] += k\\n for j in range(ind + 1, ind + x +", "gt": "1):\\n j1 = j % 14\\n b[j1] += 1\\n res = 0\\n for j in range(14):\\n if b[j] % 2 == 0:\\n res += b[j]\\n return res\\na = list(map(int, input().split()))\\nans = 0\\nfor i in range(14):\\n cur = f(a, i)\\n ans = max(ans, cur)\\nprint(ans)"}
{"id": "1029", "input": "\"\"\"\\nCodeforces Contest 273 Div 2 Problem B\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef comb2(n):\\n return n*(n-1)//2\\n\\ndef main():\\n n,m = read()\\n k = n // m\\n p = n % m\\n mn = p * comb2(k+1) + (m-p) * comb2(k)\\n mx = comb2(n-m+1)\\n print(mn, mx)\\n\\n################################### NON-SOLUTION STUFF BELOW\\n\\ndef read(mode=2):\\n # 0: String\\n # 1:", "gt": "List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "1030", "input": "s=input().strip()\\nn=len(s)\\ni=0\\nk=1\\nj=0\\nwhile i<n:\\n #print(i,j)\\n j=i\\n i+=1\\n while i<n and s[i]=='0':\\n i+=1\\n if", "gt": "j>i-j:\\n k+=1\\n elif j==i-j:\\n if s[:j]>=s[j:i]:\\n k+=1\\n else:\\n k=1\\n else:\\n k=1\\nprint(k)"}
{"id": "1031", "input": "n, p, k = map(int, input().split())\\n\\nif (p - k) > 1:\\n print('<<', end = ' ')\\n\\nfor i in range(p - k, p):\\n if (i > 0):\\n print(i, end = ' ')\\n\\nprint('(' + str(p) + ')',", "gt": "end = ' ')\\n\\nfor i in range(p + 1, p + k + 1):\\n if (i < (n + 1)):\\n print(i, end = ' ')\\n\\nif (p + k) < n:\\n print('>>', end = ' ')"}
{"id": "1032", "input": "n = int(input())\\na = [int(i) for i in input().split()]\\nminy = 0\\nmaxy = 0\\ns = 0\\nfor i in range(n):\\n if i % 2 == 0:\\n s += a[i]\\n else:\\n s -= a[i]\\n maxy = max(s, maxy)\\n miny = min(s, miny)\\ndif = maxy - miny\\nsize = sum(a)\\nres = [[\" \"] * size for", "gt": "i in range(dif)]\\ncur = [maxy, 0]\\nfor i in range(n):\\n if i % 2 == 0:\\n cur[0] -= 1\\n else:\\n cur[0] += 1\\n for j in range(a[i]):\\n if i % 2 == 0:\\n res[cur[0]][cur[1]] = \"/\"\\n cur[0] -= 1\\n else:\\n res[cur[0]][cur[1]] = \"\\\\\"\\n cur[0] += 1\\n cur[1] += 1\\n\\nfor i in res:\\n print(\"\".join(i))"}
{"id": "1033", "input": "import sys\\ninput = sys.stdin.readline\\nn,p=map(int,input().split())\\na=list(map(int,input().split()))\\na.sort()\\nmn=0\\nmx=2000000000000000\\nfor i in range(n):\\n d=a[i]-i\\n mn=max(d,mn)\\n", "gt": "if i>=p-1:\\n d2=a[i]-i+p-1\\n mx=min(mx,d2)\\nprint(max(mx-mn,0))\\nfor i in range(mn,mx):\\n print(i,end=\" \")"}
{"id": "1034", "input": "n, k = list(map(int, input().split()))\\n\\n\\ndef get(x):\\n if x <= k:\\n return x * (x + 1) // 2\\n res = k * x - k * (k - 1) // 2\\n sz = x - k - 1\\n if sz % 2 == 0:\\n cnt = sz // 2\\n res += (2 + sz)", "gt": "* cnt // 2\\n else:\\n cnt = sz // 2 + 1\\n res += (1 + sz) * cnt // 2\\n return res\\n\\n\\nl = 0\\nr = 10 ** 18\\nwhile r - l > 1:\\n m = l + (r - l) // 2\\n if get(m) >= n:\\n r = m\\n else:\\n l = m\\n\\nprint(r)\\n"}
{"id": "1035", "input": "\\n\\nX,Y,Z,K = list(map(int, input().split()))\\n\\nA = list(map(int, input().split()))\\nB = list(map(int, input().split()))\\nC = list(map(int, input().split()))\\n\\nA.sort(reverse=True)\\nB.sort(reverse=True)\\nC.sort(reverse=True)\\n\\n\\nans = []\\nfor i in range(X):\\n if (i+1) > K: break\\n", "gt": "for j in range(Y):\\n if (i+1)*(j+1) > K: break\\n for k in range(Z):\\n if (i+1)*(j+1)*(k+1) > K: break\\n ans.append(A[i]+B[j]+C[k])\\n\\nans.sort(reverse=True)\\n\\nfor i in range(K):\\n print((ans[i]))\\n \\n"}
{"id": "1036", "input": "from math import gcd, sqrt\\na,b = map(int, input().split())\\ng = gcd(a,b)\\nd = {}\\nfor i", "gt": "in range(2, int(sqrt(g))+1):\\n while g%i==0:\\n g//=i\\n d[i] = d.get(i, 0)+1\\nif g>1:\\n d[g] = 1\\nprint(len(d)+1)"}
{"id": "1037", "input": "from typing import List\\n\\n\\ndef winner(a: str, b: str) -> str:\\n return b if (a, b) in [(\"R\", \"P\"), (\"P\", \"S\"), (\"S\", \"R\")] else a\\n\\n\\nN, K = list(map(int,", "gt": "input().split()))\\nS: List[str] = list(input())\\n\\nfor i in range(K):\\n T: List[str] = S + S\\n S = [winner(T[2 * j], T[2 * j + 1]) for j in range(N)]\\nprint((S[0]))\\n"}
{"id": "1038", "input": "N = int(input())\\nA = [int(s) for s in input().split(\" \")]\\nABI = sorted(((a, i) for i, a in enumerate(A, 1)), reverse=True)\\nprev = [0]\\nfor", "gt": "k, (a,i) in enumerate(ABI):\\n curr = [0]*(k+2)\\n for l in range(k+1):\\n curr[l] = max(curr[l], prev[l]+abs(N-i-k+l)*a)\\n curr[l+1] = prev[l]+abs(i-l-1)*a\\n \\n prev = curr\\n \\nprint(max(prev))"}
{"id": "1039", "input": "def XorWorld():\\n a, b = list(map(int, input().split()))\\n if a%2 == 0 and b%2 == 0:\\n if ((b-a)//2)%2 == 0:\\n print((0^b))\\n else:\\n print((1^b))\\n elif a%2 == 0:\\n if", "gt": "((b-a+1)//2)%2 == 0:\\n print((0))\\n else:\\n print((1))\\n elif b%2 == 0:\\n if ((b-a-1)//2)%2 == 0:\\n print((0^a^b))\\n else:\\n print((1^a^b))\\n else:\\n if ((b-a)//2)%2 == 0:\\n print((0^a))\\n else:\\n print((1^a))\\n\\ndef __starting_point():\\n XorWorld()\\n \\n\\n__starting_point()"}
{"id": "1040", "input": "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf\\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\\nfrom collections import deque,defaultdict,Counter\\nfrom bisect import bisect_left,bisect_right\\nfrom operator import itemgetter\\nfrom heapq import heapify,heappop,heappush\\nfrom queue import Queue,LifoQueue,PriorityQueue\\nfrom copy import deepcopy\\nfrom time import time\\nfrom functools import reduce\\nimport string\\nimport sys\\nsys.setrecursionlimit(10 ** 7)\\ndef input() : return sys.stdin.readline().strip()\\ndef INT() : return int(input())\\ndef MAP() : return map(int,input().split())\\ndef MAP1() : return map(lambda x:int(x)-1,input().split())\\ndef LIST() : return list(MAP())\\n\\ndef solve():\\n N = INT()\\n adj = [[] for _ in", "gt": "range(N)]\\n for i in range(N-1):\\n a, b, c = MAP()\\n adj[a-1].append([b-1, c])\\n adj[b-1].append([a-1, c])\\n\\n Q, K = MAP()\\n K -= 1\\n\\n d = [inf]*N\\n d[K] = 0\\n que = []\\n heappush(que, K)\\n\\n while que:\\n v = heappop(que)\\n for b, c in adj[v]:\\n if d[b] > d[v] + c:\\n d[b] = d[v] + c\\n heappush(que, b)\\n\\n for i in range(Q):\\n x, y = MAP()\\n print(d[x-1]+d[y-1])\\n\\ndef __starting_point():\\n solve()\\n__starting_point()"}
{"id": "1041", "input": "import sys\\nreadline = sys.stdin.readline\\n\\n# fが来たらstackに[0]をappendする。\\n# oが来たとき、最後尾が[0]だったら[1]にする\\n# xが来たとき、最後尾が[1]ならpopする。このとき3を引く\\n\\nN = int(readline())\\nS = readline().rstrip()\\n\\nans = N\\nstack = []\\n\\nfor s in S:\\n if s == \"f\":\\n stack.append(0)\\n elif s == \"o\":\\n if stack and stack[-1] ==", "gt": "0:\\n stack[-1] = 1\\n else:\\n # 最後がfでない状態でoが来た時、このoが消えることはない。\\n stack = []\\n elif s == \"x\":\\n if stack and stack[-1] == 1:\\n stack.pop()\\n ans -= 3\\n else:\\n stack = []\\n else:\\n stack = []\\n \\nprint(ans)"}
{"id": "1042", "input": "#Circle of Numbers\\nimport math\\n\\ndef centre(n, pts):\\n x, y = 0, 0\\n for j in [7,11,13,17,19,23,29,31,37,1193,1663,2711,4007,65537]:\\n if math.gcd(n,j) == 1:\\n for i in range(n):\\n k = int(pts[i])\\n x += k*math.cos(math.pi *", "gt": "2*i*j/n)\\n y += k*math.sin(math.pi * 2*i*j/n)\\n if not (abs(x) < 0.000001 and abs(y) < 0.000001):\\n return 'NO'\\n return 'YES'\\n \\ndef strconv(s):\\n return [char for char in s]\\n\\nn = int(input())\\npts = strconv(input())\\nprint(centre(n,pts))\\n"}
{"id": "1043", "input": "import sys\\n\\nx,y = list(map(int, input().strip().split()))\\n\\nif y % x != 0:\\n print(0)\\n return\\n\\nMOD = 10**9 + 7\\n\\nK = y//x\\n\\ndef multiply(A,b, MOD):\\n n, m = len(A), len(b[0])\\n matrika = [[0 for _ in range(m)] for _ in range(n)]\\n for i in range(n):\\n for j in range(m):\\n vsota = 0\\n for k in range(len(A[0])):\\n vsota += A[i][k]*b[k][j]\\n matrika[i][j] = vsota % MOD\\n return matrika\\n\\ndef copy(mat):\\n return [e[:] for e in mat]\\n\\ndef fib(n):\\n if n == 0:\\n return 0\\n if n == 1:\\n return 1\\n if n == 2:\\n return 1\\n matrika = [[1,1],[1,0]]\\n\\n pripravi = dict()\\n pripravi[1] = copy(matrika)\\n s = 1\\n\\n pot = [1]\\n\\n working = copy(matrika)\\n \\n while s <= n:\\n working = multiply(working,working,MOD)\\n s*= 2\\n pripravi[s] = copy(working)\\n pot.append(s)\\n\\n manjka = n-2\\n pointer = len(pot) - 1\\n while manjka > 0:\\n if pot[pointer] > manjka:\\n pointer -= 1\\n else:\\n matrika = multiply(matrika, pripravi[pot[pointer]], MOD)\\n manjka", "gt": "-= pot[pointer]\\n\\n v = [[1],[0]]\\n\\n return multiply(matrika, v, MOD)[0][0]\\n\\nmemo2 = dict()\\ndef find(y):\\n if y in memo2:\\n return memo2[y]\\n ALL = (pow(2, y - 1, MOD)) % MOD\\n\\n k = 2\\n while k*k <= y:\\n if y % k == 0:\\n if k*k != y:\\n ALL -= find(y//k)\\n ALL -= find(k)\\n else:\\n ALL -= find(k)\\n k += 1\\n #print(k, ALL)\\n\\n if y != 1:\\n ALL -= 1\\n\\n memo2[y] = ALL % MOD\\n return ALL % MOD\\n\\nprint(find(K) % MOD)\\n\\n\\ndef gcd(x,y):\\n if x == 0:\\n return y\\n if y > x:\\n return gcd(y,x)\\n if x % y == 0:\\n return y\\n return gcd(y, x % y)\\n\\n\\nmemo = dict()\\ndef brute(k, gc):\\n if (k,gc) in memo:\\n return memo[k,gc]\\n if k == 0:\\n if gc:\\n return 1\\n else:\\n return 0\\n ALL = 0\\n for i in range(1, k + 1):\\n ALL += brute(k-i,gcd(gc,i))\\n memo[k, gc] = ALL\\n return ALL\\n\\n#print(brute(K,0) % MOD)\\n \\n"}
{"id": "1044", "input": "from heapq import heappush, heappop\\nN = int(input())\\nA = [int(a) for a in input().split()]\\nfor i in range(N):\\n if A[i] < 0:\\n k = i\\n break\\nA = [0] + [0 if i", "gt": "< k else A[i] for i in range(N) if i != k]\\n\\nans = A.pop()\\nH = []\\nwhile N > 2:\\n N //= 2\\n for i in range(N):\\n heappush(H, A.pop())\\n ans += heappop(H)\\n\\nprint(ans)\\n\\n\\n"}
{"id": "1045", "input": "n = int(input())\\nnow = 2\\nfor i in input().split():\\n a = int(i)\\n", "gt": "if a % 2 == 0:\\n now = 3 - now\\n print(now)\\n"}
{"id": "1046", "input": "n = int(input())\\nans = 0\\ns = 0\\n\\nwhile (n > 0):\\n ans += 1\\n", "gt": "s += ans\\n n -= s\\n\\n if (n < 0):\\n ans -= 1\\n break\\n\\nprint(ans)\\n"}
{"id": "1047", "input": "#scott http://codeforces.com/problemset/problem/291/A now? ok you start\\n\\nn = int(input())\\narr = list(map (int, input().split())) #scott\\n\\n#for i in arr:\\n# print (i)\\n\\ncnt = 0 \\nclast, llast = -1, -1 #scott wait we need to sort\\n\\narr = sorted(arr)\\n\\nbad = False #scott so now we just count # of pairs and make sure there's not 3 in a row right?ok\\n#so a neat thing you can do is just for x", "gt": "in arr\\nfor i in arr:\\n #print (i)\\n if i > 0: #scott so last was the last one, llast was the second last one\\n if i == clast :\\n cnt += 1 #scott\\n if clast == llast :\\n bad = True #scott your turn\\n llast = clast\\n clast = i #scott\\nif bad == False:\\n print (cnt) #scott\\nelse:\\n print(-1) #scott\\n\\n#darn ii'm getting RTE test 1\\n"}
{"id": "1048", "input": "import sys\\n\\ndef get_max_kvazi(n):\\n s = str(n)\\n ans = ''\\n for c in s:\\n if c == '0':\\n ans = ans + '0'\\n else:\\n ans = ans +", "gt": "'1'\\n return int(ans)\\n\\nfin = sys.stdin\\nfout = sys.stdout\\n\\n#fin = open(\"input.txt\", 'r')\\n#fout = open(\"output.txt\", 'w')\\n\\nn = int(fin.readline())\\nans = []\\nwhile (n > 0):\\n cur = get_max_kvazi(n)\\n ans.append(cur)\\n n -= cur\\nprint(len(ans))\\nprint(*ans)\\n"}
{"id": "1049", "input": "'''input\\n6\\nLLRRRR\\n'''\\nn = int(input())\\ns = input()\\nh, v", "gt": "= min(s.count(\"L\"), s.count(\"R\")), min(s.count(\"U\"), s.count(\"D\"))\\nprint(2*h + 2*v)"}
{"id": "1050", "input": "n,d = map(int,input().split())\\n\\nans = 0\\nhas = 0\\nfor i in range(d):\\n s", "gt": "= input().count(\"1\")\\n if s==n:\\n has = 0\\n else:\\n has+=1\\n ans = max(ans,has)\\nprint(ans)"}
{"id": "1051", "input": "n, m, k = list(map(int, input().split()))\\nif m", "gt": ">= n and k >= n:\\n print('Yes')\\nelse:\\n print('No')\\n"}
{"id": "1052", "input": "input()\\na = list(map(int, input().split()))\\ns", "gt": "= max(a)\\n\\nprint(max(0, s - 25))\\n"}
{"id": "1053", "input": "import sys\\n\\nn, k = (int(i) for i in input().split())\\n\\nff = [1] * (n + 1)\\n\\nfor i in range(1, n + 1) :\\n ff[i] = ff[i - 1] * i\\n\\ndd = [0] * (n + 1)\\n\\ndd[1] = 0\\ndd[2] = 1\\n\\nfor i in range(3, n + 1)", "gt": ":\\n dd[i] = (i - 1) * (dd[i - 1] + dd[i - 2])\\n \\nans = ff[n]\\n\\nfor i in range(n - k) :\\n c = ff[n] // ff[n - i]\\n c = c // ff[i]\\n c = c * dd[n - i]\\n \\n ans -= c\\n\\nprint(ans)"}
{"id": "1054", "input": "a = [0]\\ncur = 1\\n\\nwhile(cur < 10 ** 13):\\n x = a[-1]\\n a.append(x * 2 + cur)\\n cur *= 2\\n\\nn = int(input())\\nn -= 1\\n\\nans = 0\\ni = 1\\ncur =", "gt": "1\\nwhile(n > 0):\\n x = n % 2\\n n = n // 2\\n if(x > 0):\\n ans += cur + a[i - 1]\\n i += 1\\n cur *= 2\\n \\nprint(ans)"}
{"id": "1055", "input": "n = int(input())\\nxa = []\\nya = []\\nfor _", "gt": "in range(n):\\n x, y = map(int,input().split())\\n xa.append(x)\\n ya.append(y)\\nprint(max(max(xa)-min(xa),max(ya)-min(ya))**2)"}
{"id": "1056", "input": "n = int(input())\\na = [int(ai) for ai in input().split()]\\n\\ndef solve(x):\\n n", "gt": "= len(x)\\n if sorted(x) == x:\\n return n\\n return max(solve(x[:n//2]), solve(x[n//2:]))\\n\\nprint(solve(a))\\n"}
{"id": "1057", "input": "3\\n\\nimport array\\nfrom fractions import Fraction\\nimport functools\\nimport itertools\\nimport math\\nimport os\\nimport sys\\n\\n\\ndef main():\\n H = [read_ints() for _ in range(10)]\\n print(solve(H))\\n\\n\\ndef pos_idx(x, y):\\n i = y * 10\\n if y % 2 == 0:\\n i += x\\n else:\\n i += 9 - x\\n return i\\n\\n\\ndef idx_pos(i):\\n y = i // 10\\n if y % 2 == 0:\\n x = i % 10\\n else:\\n x = 9 - i % 10\\n return x, y\\n\\n\\ndef solve(H):\\n dp = [0] * 100\\n for i in range(1, 100):\\n e = 0\\n for d in range(1, 7):\\n j = i - d\\n", "gt": "if j < 0:\\n rem = 7 - d\\n e += rem / 6\\n e *= 6 / (6 - rem)\\n break\\n x, y = idx_pos(j)\\n if H[y][x] != 0:\\n dy = y - H[y][x]\\n k = pos_idx(x, dy)\\n assert idx_pos(k) == (x, dy)\\n e += (min(dp[j], dp[k]) + 1) / 6\\n else:\\n e += (dp[j] + 1) / 6\\n dp[i] = e\\n return dp[99]\\n\\n\\n###############################################################################\\n# AUXILIARY FUNCTIONS\\n\\nDEBUG = 'DEBUG' in os.environ\\n\\n\\ndef inp():\\n return sys.stdin.readline().rstrip()\\n\\n\\ndef read_int():\\n return int(inp())\\n\\n\\ndef read_ints():\\n return [int(e) for e in inp().split()]\\n\\n\\ndef dprint(*value, sep=' ', end='\\n'):\\n if DEBUG:\\n print(*value, sep=sep, end=end)\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1058", "input": "input()\\ns = input()\\nr1 = 1\\nf = s[0]\\nfor c in s:\\n if c != f:\\n break\\n r1 += 1\\nr2 = 1\\np = s[-1]\\nfor c in", "gt": "s[::-1]:\\n if c != p:\\n break\\n r2 += 1\\nif f == p:\\n print((r1 * r2) % 998244353)\\nelse:\\n print((r1 + r2 - 1) % 998244353)\\n"}
{"id": "1059", "input": "# \\nimport collections, atexit, math, sys, bisect \\n\\nsys.setrecursionlimit(1000000)\\ndef getIntList():\\n return list(map(int, input().split())) \\n\\ntry :\\n #raise ModuleNotFoundError\\n import numpy\\n def dprint(*args, **kwargs):\\n print(*args, **kwargs, file=sys.stderr)\\n dprint('debug mode')\\nexcept ModuleNotFoundError:\\n def dprint(*args, **kwargs):\\n pass\\n\\n\\n\\ninId = 0\\noutId = 0\\nif inId>0:\\n dprint('use input', inId)\\n sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\\nif outId>0:\\n dprint('use output', outId)\\n sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\\n atexit.register(lambda :sys.stdout.close()) #idle 中不会执行 atexit\\n \\nN, = getIntList()\\n\\nzb = []\\n \\ntotal = 0\\n\\nde = [0,0,0,0,0]\\ngr = [ [] for i in range(5)]\\nminv = 10000000\\nfor i in range(N):\\n a,b,c = getIntList()\\n de[a]+=1\\n de[c]", "gt": "+=1\\n zb.append( (a,b,c) )\\n total +=b\\n if a!=c:\\n minv = min(minv,b)\\nvis = [0,0,0,0,0]\\n\\ndef dfs( root):\\n if vis[root]:return []\\n vis[root] = 1\\n r = [root,]\\n for x in zb:\\n a,b,c = x\\n if a==root:\\n r = r+ dfs(c)\\n elif c==root:\\n r = r+ dfs(a)\\n return r\\n\\nres = 0\\nfor i in range(1,5):\\n if vis[i]:continue\\n t = dfs(i)\\n t = set(t)\\n if len(t) ==4:\\n for j in range(1,5):\\n if de[j]%2==0:\\n print(total)\\n return\\n print(total-minv)\\n return\\n tr = 0\\n for x in zb:\\n a,b,c = x\\n if a in t:\\n tr +=b\\n res = max(res,tr)\\n\\nprint(res)\\n \\n\\n\\n\\n\\n\\n"}
{"id": "1060", "input": "def main():\\n n = int(input())\\n for i in range(1, n):\\n if n % i == 0:\\n if i < 5 or n // i < 5:\\n continue\\n vowels =", "gt": "\"aeiou\"\\n ind = 0\\n ans = \"\"\\n for j in range(n // i):\\n for k in range(i):\\n ans += vowels[(j + k) % 5]\\n print(ans)\\n return 0\\n print(-1)\\n return 0\\n\\nmain()"}
{"id": "1061", "input": "R = lambda: map(int, input().split())\\nn = int(input())\\ndp = [0] * (10**6 + 1)\\nfor x in R():\\n dp[x] = 1\\nfor i in range(10**6,", "gt": "-1, -1):\\n if dp[i]:\\n for x in range(i + i, 10**6 + 1, i):\\n if dp[x]:\\n dp[i] = max(dp[i], dp[x] + 1)\\nprint(max(dp))"}
{"id": "1062", "input": "L=[]\\nfor i in range(5):\\n s=input().split()\\n L.append(list(s))\\n\\nfor i in", "gt": "range(5):\\n for j in range(5):\\n if(L[i][j]==\"1\"):\\n row=i\\n col=j\\n\\nx=abs(row-2)+abs(col-2)\\nprint(x)\\n"}
{"id": "1063", "input": "n = int(input())\\ns = input()\\nt = input()\\n\\ndef ff(ch):\\n return ord(ch) - ord('a')\\n\\ndef answer(a, b, sc):\\n print(cans + sc)\\n print(a+1, b+1)\\n return\\n\\ncans = 0\\nmatrix = [[None] * 26 for i in range(26)]\\nfor i in range(n):\\n matrix[ff(s[i])][ff(t[i])] = i\\n if s[i] != t[i]:\\n cans += 1\\n\\nfor i in range(26):\\n for j in", "gt": "range(i):\\n if matrix[i][j] is not None and matrix[j][i] is not None:\\n answer(matrix[i][j], matrix[j][i], -2)\\n\\nfor i in range(26):\\n for h in range(26):\\n if h == i:\\n continue\\n for v in range(26):\\n if v == i:\\n continue\\n if matrix[h][i] is not None and matrix[i][v] is not None:\\n answer(matrix[h][i], matrix[i][v], -1)\\n\\nanswer(-2, -2, 0)\\n"}
{"id": "1064", "input": "def solve(s, t, i, l):\\n if i == l:\\n return False\\n if s[i] == \"?\":\\n if solve(s, t, i + 1, l):\\n s[i] = t[i]\\n return True\\n elif t[i] == \"9\":\\n return False\\n s[i] = nxt[t[i]]\\n for j in range(i, l):\\n if s[j] == \"?\":\\n s[j] = \"0\"\\n return True\\n elif s[i] > t[i]:\\n for j in range(i, l):\\n if s[j] == \"?\":\\n s[j] = \"0\"\\n return True\\n elif s[i] < t[i]:\\n return False\\n else:\\nreturn solve(s, t, i + 1, l)\\n\\n\\nn = int(input())\\na = [list(input()) for _ in range(n)]\\np = [\"0\"]\\nnxt = {str(x): str(x + 1)", "gt": "for x in range(9)}"}
{"id": "1065", "input": "import sys\\nfrom math import ceil\\n\\nn, m, k = list(map(int, sys.stdin.readline().split()))\\nplaces = [True for _ in range(n)]\\nfor x in map(int, sys.stdin.readline().split()):\\n places[x] = False\\ncosts = list(map(int, sys.stdin.readline().split()))\\nif not places[0]:\\n print(-1)\\n return\\n\\nprev = [i for i in range(n)]\\nlast = 0\\nfor i in range(n):\\n if places[i]:\\n last = i\\n prev[i] = last\\n\\nbest_cost = float('inf')\\nfor lamp in range(k, 0, -1):\\n min_cost = ceil(n/lamp) * costs[lamp-1]\\n if min_cost >= best_cost:\\n", "gt": "continue\\n\\n # try this shit\\n cost = costs[lamp-1]\\n reach = lamp\\n fail = False\\n\\n while reach < n:\\n if prev[reach] + lamp <= reach:\\n fail = True\\n break\\n reach = prev[reach] + lamp\\n cost += costs[lamp - 1]\\n\\n if cost + (ceil((n - reach)/lamp) * costs[lamp-1]) >= best_cost:\\n fail = True\\n break\\n\\n if not fail:\\n best_cost = min(best_cost, cost)\\n\\nprint(best_cost if best_cost != float('inf') else -1)\\n"}
{"id": "1066", "input": "n, k, M, D = list(map(int, input().split()))\\nans = 0\\nfor d in range(1, D + 1):\\n bot = 0\\n top = M + 1\\n while (top > bot + 1):\\n mid = (bot+ top) // 2\\n cur = (d - 1) * mid * k;\\n cur", "gt": "+= mid;"}
{"id": "1067", "input": "N,K=input().split()\\nN,K=int(N),int(K)\\n\\nif(N%2==0):\\n if(K<=N//2):\\n print(2*K-1)\\n else:\\n K-=N//2\\n", "gt": "print(2*K)\\n\\nelse:\\n if(K<=N//2+1):\\n print(2*K-1)\\n else:\\n K-=N//2+1\\n print(2*K)\\n\\n"}
{"id": "1068", "input": "n = int(input())\\nA = list(map(int, input().split()))\\nm = 0\\npos = 0\\nneg = 0\\nfor i in range(n):\\n if A[i] < 0:\\n neg += 1\\n m += (-A[i] - 1)\\n A[i] = -1\\n elif A[i]", "gt": "> 0:\\n pos += 1\\n m += (A[i] - 1)\\n A[i] = 1\\nzer = n - pos - neg\\nif zer:\\n print(m + zer)\\nelif neg % 2 == 0:\\n print(m)\\nelse:\\n print(m + 2)"}
{"id": "1069", "input": "def modgroup(M = 10**9+7, invn = 0) :\\n exec(f'''class mod{M} :\\n inv = [None] * {invn}\\n if {invn} >= 2 : inv[1] = 1\\n for i in range(2, {invn}) : inv[i] = (({M}-{M}//i)*inv[{M}%i])%{M}\\n def __init__(self, n = 0) : self.n = n % {M}\\n __repr__ = lambda self : str(self.n) + '%{M}'\\n __int__ = lambda self : self.n\\n __eq__ = lambda a,b : a.n == b.n\\n __add__ = lambda a,b : __class__(a.n + b.n)\\n __sub__ = lambda a,b : __class__(a.n - b.n)\\n __mul__ = lambda a,b : __class__(a.n * b.n)\\n __pow__ = lambda a,b : __class__(pow(a.n, b.n, {M}))\\n __truediv__ = lambda a,b : __class__(a.n * pow(b.n, {M-2}, {M}))\\n __floordiv__ = lambda a,b : __class__(a.n * __class__.inv[b.n])\\n ''')\\n return eval(f'mod{M}')\\ndef solution() :\\n s = input()\\n l =", "gt": "len(s)\\n mod = modgroup()\\n num = [mod(0)] * (l+1) # num[i] = int(s[:i]) <mod>\\n shift = [mod(1)] * (l+1) # shift[i] = 10**i <mod>\\n for i,x in enumerate(s, 1) :\\n num[i] = num[i-1] * mod(10) + mod(int(x))\\n shift[i] = shift[i-1] * mod(10)\\n def mod_check(la, lb, lc) :\\n a,b,c = num[la], num[la+lb], num[la+lb+lc]\\n c -= b * shift[lc]\\n b -= a * shift[lb]\\n return a + b == c\\n for lc in range(l//3+bool(l%3), l//2+1) :\\n for lb in (lc, lc-1, l-lc*2, l-lc*2+1) :\\n la = l - lc - lb\\n if la < 1 or lb < 1 or lc < 1 : continue\\n if la > lc or lb > lc : continue\\n if not mod_check(la, lb, lc) : continue\\n a,b,c = s[:la], s[la:la+lb], s[la+lb:la+lb+lc]\\n print(f'"}
{"id": "1070", "input": "sa=int(input())\\nif sa%4==0:\\n", "gt": "print(4)\\nelse:\\n print(0)"}
{"id": "1071", "input": "n,k = list(map(int, input().split()))\\na=list(map(int, input().split()))\\n\\nlast=''\\nm = 0\\ns=0\\nfor i in", "gt": "a:\\n if i==last:\\n s=1\\n else:\\n s+=1\\n last=i\\n if s>m:\\n m=s\\nprint(m)\\n"}
{"id": "1072", "input": "a = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\nn = int(input())\\nn1 = (sum(a) - 1) // 5 +", "gt": "1\\nn2 = (sum(b) - 1) // 10 + 1\\nif n1 + n2 <= n:\\n print('YES')\\nelse:\\n print('NO')\\n"}
{"id": "1073", "input": "line = input().split()\\nn = int(line[0])\\nm = int(line[1])\\n\\nlst = [input()]\\nsml = []\\nfor i in range(n - 1):\\n lst.append(input())\\n sml.append(False)\\n\\nans = 0\\nfor i in range(m):\\n flag = True\\n for j in range(n - 1):\\n", "gt": "flag = flag and ((lst[j][i] <= lst[j + 1][i]) or sml[j])\\n if flag:\\n for j in range(n - 1):\\n if lst[j][i] < lst[j + 1][i]:\\n sml[j] = True\\n else:\\n ans += 1\\n\\nprint(str(ans))\\n"}
{"id": "1074", "input": "n = int(input())\\ns = input()\\n\\nans = 0\\nfor i in range(n):\\n for j in range(i +", "gt": "1, n + 1):\\n t = s[i:j]\\n ans += t.count('U') == t.count('D') and t.count('L') == t.count('R')\\n\\nprint(ans)\\n"}
{"id": "1075", "input": "<s> ", "gt": "print(str(oct(int(input()))).count('1'))\\n"}
{"id": "1076", "input": "n=int(input())\\nif n&1:\\n print(-1)\\nelse:\\n D,R=[False]*(10**6),[0]*(10**6)\\n i,j=0,0\\n while True:\\n D[j]=True\\n R[i]=j\\n i+=1\\n if not D[(j+n)>>1]:\\n", "gt": "j=(j+n)>>1\\n elif not D[j>>1]:\\n j=j>>1\\n else:\\n break\\n print(\" \".join(str(R[i]) for i in range(n,-1,-1)))\\n"}
{"id": "1077", "input": "import sys\\nimport math\\n\\nQ = 998244353\\nn, m = list(map(int, sys.stdin.readline().strip().split()))\\n\\nz = [1, 1]\\nf = [1, 1]\\nfor i in range (0, n):\\n f[0] = f[0] * (n - i) % Q\\n f[1] = f[1] * (n + m - i) % Q\\n z = [(z[0]*f[1]+z[1]*f[0]) % Q, (z[1]*f[1]) % Q]\\nans = [z[0] * (m+1), z[1]]\\nfor i in range (2, n +", "gt": "1):\\n ans = [(ans[0] * i * z[1] + ans[1] * m * z[0]) % Q, (ans[1] * i * z[1]) % Q]\\ny = ans[1]\\nans = ans[0]\\nq = Q - 2\\nwhile q > 0:\\n if q % 2 == 1:\\n ans = (ans * y) % Q\\n q = q // 2\\n y = (y * y) % Q\\nprint(ans)\\n"}
{"id": "1078", "input": "#!/usr/bin/env python3\\n\\nfrom collections import Counter\\n\\nn, m = [int(x) for x in input().split()]\\na = [int(x) for x in input().split()]\\n\\ntgt = n // m\\nb = Counter(a)\\nrd = sum(b[x] for x in b if x > m)\\nr = 0\\n\\nfor i in range(1, m+1):\\n while rd and b[i] < tgt:\\n for j in range(n):\\n", "gt": "if a[j] > m:\\n b[a[j]] -= 1\\n b[i] += 1\\n a[j] = i\\n rd -= 1\\n r += 1\\n break\\n while b[i] < tgt:\\n for j in range(n):\\n if b[a[j]] > tgt:\\n b[a[j]] -= 1\\n b[i] += 1\\n a[j] = i\\n r += 1\\n break\\n\\nprint(tgt, r)\\nprint(\" \".join(str(x) for x in a))"}
{"id": "1079", "input": "n = int(input())\\nz = 0\\nfor i in range(n):\\n x = int(input())\\n if x % 2", "gt": "== 0:\\n print(x//2)\\n else:\\n if z == 1:\\n print((x-1)//2)\\n else:\\n print((x+1)//2)\\n z = 1 - z"}
{"id": "1080", "input": "t = input()\\nj = t[0]\\nd, s = 0, int(j)\\nfor i in t[1: ]:\\n if j != i:\\n if d == 1: d,", "gt": "s = 0, s + 1\\n else: d = 1\\n j = i\\n else: d = 1\\nprint(s + (d and j == '1'))"}
{"id": "1081", "input": "import sys\\ninput = sys.stdin.readline\\nsys.setrecursionlimit(100000)\\n\\ndef getN():\\n return int(input())\\ndef getList():\\n return list(map(int, input().split()))\\nimport math\\nfrom bisect import bisect_left\\n\\nn =", "gt": "getN()\\nnums = getList()\\n\\nif sum(nums) % 2 == 1:\\n print(\"NO\")\\n return\\n\\nif max(nums) * 2 > sum(nums):\\n print(\"NO\")\\n return\\n\\nprint(\"YES\")\\n"}
{"id": "1082", "input": "n = int(input())\\ns = {1, 7, 9, 10, 11}\\nif n < 12:\\n if n in s:\\n print(\"NO\")\\n else:\\n print(\"YES\")\\nelif 12 < n <", "gt": "30:\\n print(\"NO\")\\nelif 69 < n < 80:\\n print(\"NO\")\\nelif 89 < n:\\n print(\"NO\")\\nelse:\\n if n % 10 not in"}
{"id": "1083", "input": "def getmask(x):\\n ans = 0\\n for i in range(2, x + 1):\\n while x % (i * i) == 0:\\n x //= i * i\\n if x % i == 0:\\n ans ^= 1 << i\\n x //= i\\n return ans\\n\\ndef main():\\n maxn = 71\\n n = int(input())\\n a = [int(i) for i in input().split()]\\n cnt = [0] * maxn\\n for i in a:\\n cnt[i] += 1\\n masks = {}\\n for i in range(1, maxn):\\n if cnt[i]:\\nmasks[getmask(i)] = masks.get(getmask(i), 0) + cnt[i]\\n while len(masks) > 1 or 0 not in masks:\\n if not masks:\\n print(0)\\n return\\n fixed = max(masks.keys())\\n for i in list(masks.keys()):\\n if i ^ fixed < i:\\n masks[i ^ fixed] = masks.get(i ^ fixed, 0) + masks[i]\\n masks[i] = 0\\n masks[0] = masks.get(0, 0) + masks[fixed] - 1\\n masks[fixed] = 0\\n masks = {i: j for i, j in", "gt": "list(masks.items()) if j > 0}"}
{"id": "1084", "input": "n = int(input())\\nf = []\\ns = []\\nf1 = s1 = 0\\nfor i in range(n, 0, -1):\\n", "gt": "if f1 <= s1:\\n f1 += i\\n f.append(i)\\n else:\\n s1 += i\\n s.append(i)\\nprint(abs(f1 - s1))\\nprint(len(f), *f)"}
{"id": "1085", "input": "n, m = list(map(int, input().split()))\\na = [-1] * m\\nb = []\\nf = True\\nfor i in range(n):\\n s = input()\\n q = set()\\n for j in range(len(s)):\\n if (s[j] == \"#\"):\\n", "gt": "q.add(j)\\n for j in range(len(s)):\\n if (s[j] == \"#\"):\\n if (a[j] == -1):\\n a[j] = i\\n else:\\n if b[a[j]] != q:\\n f = False\\n b.append(q)\\n #print(a, b, f)\\nif f:\\n print(\"Yes\")\\nelse:\\n print(\"No\")\\n"}
{"id": "1086", "input": "def make_divisors(n):\\n divisors = []\\n for i in range(1, int(n ** 0.5) + 1):\\n if n % i == 0:\\n divisors.append(i)\\n if i != n // i:\\n divisors.append(n // i)\\n return divisors\\n\\n\\nn = int(input())\\nans = len(make_divisors(n", "gt": "- 1))\\ndivisors = []\\nfor i in make_divisors(n):\\n j = n\\n if i != 1:\\n while j % i == 0:\\n j //= i\\n if (j - 1) % i == 0:\\n divisors.append(i)\\nprint((ans + len(divisors) - 1))\\n"}
{"id": "1087", "input": "h, w = list(map(int, input().split()))\\nA = []\\n\\nfor i in range(h):\\n line = list(map(int, input().split()))\\n A.append(line)\\n\\nfor i in range(h):\\n line = list(map(int, input().split()))\\n for j, num in enumerate(line):\\n A[i][j] = abs(A[i][j] - num)\\n\\nconst = 6400\\nmask = 1 << const\\nDP = [0]*w\\nDP[0] = mask >> A[0][0]\\n\\n\\ndef slide_down(y, x):\\n bit = DP[x]\\n delta = A[y+1][x]\\n new1 = bit << delta\\n new2 = bit >> delta\\n DP[x] =", "gt": "new1 | new2\\n\\n\\ndef slide_right(y, x):\\n bit = DP[x]\\n delta = A[y][x+1]\\n new1 = bit << delta\\n new2 = bit >> delta\\n DP[x+1] |= new1 | new2\\n\\n\\nfor y in range(h):\\n for x in range(w):\\n if x < w-1:\\n slide_right(y, x)\\n if y < h-1:\\n slide_down(y, x)\\n\\npattern = DP[w-1]\\nfor i in range(81):\\n if (pattern >> const+i) & 1 or (pattern >> const-i) & 1:\\n print(i)\\n return\\n"}
{"id": "1088", "input": "from collections import defaultdict\\n\\nN,K = list(map(int, input().split()))\\nA = list(map(int, input().split()))\\nBMAX = 40\\n\"\"\"\\n・K以下の非負整数の範囲で〜：桁DP感ある\\n・XORをとる：桁ごとに確認できる\\n・Xを選んで、f = X xor A1 + X xor A2 + ... + X xor AN\\n -> それぞれのAと毎回 xor 取るのではなく、桁ごとに xor を取ることができる ← 超重要のはず\\n -> A1 ~ AN の各桁（2進数の時の）に1が立っているのが何個あるか数えておく\\n\\n\\n遷移\\ndp[i][1] -> dp[i+1][1] : i-1桁目まででK未満が確定していれば、i桁目に1,0どちらを選んでもK未満\\ndp[i][0] -> dp[i+1][1] : i-1桁目まででKと一致している場合、Kのi桁目が1なら、Xで0を選べば遷移できる\\ndp[i][0] -> dp[i+1][0] : i桁目まで一致させる場合\\n\"\"\"\\n\\nd = [0] * BMAX\\nfor a in A:\\n for i in range(BMAX):\\n if a & (1 << i):\\n d[i] += 1\\n\\n# dp[i+1][0] : Xをi桁目まで決めた時に、Kのi桁目までと厳密に一致する ときの最大値\\n# dp[i+1][1] : Xをi桁目まで決めた時に、Kのi桁目までと厳密に一致しないときの最大値\\n\\ndp = [[-1 for _ in range(2)] for _ in range(BMAX+1)]\\n\\n\\ndp[0][0]", "gt": "= 0\\n\\nfor i in range(BMAX):\\n now = BMAX-1-i\\n # Xの左からnow桁目に1,0を設定した時にfが増加する量\\n p0 = (2**now) * d[now]\\n p1 = (2**now) * (N - d[now])\\n \\n # Kの左からnow番目に1が立ってるかどうか\\n if K & (1 << now):\\n is_one = True\\n else:\\n is_one = False\\n\\n # dp[i][1] -> dp[i+1][1] はXのi桁目に1,0を使えるから、より多い方を採用\\n if dp[i][1] != -1:\\n dp[i+1][1] = dp[i][1] + max(p1, p0)\\n\\n # dp[i][0] -> dp[i+1][1] はKのi桁目が1なら可能\\n if dp[i][0] != -1 and is_one:\\n dp[i+1][1] = max(dp[i+1][1], dp[i][0] + p0)\\n\\n # dp[i][0] -> dp[i+1][0] \\n if dp[i][0] != -1:\\n dp[i+1][0] = dp[i][0] + (p1 if is_one else p0) \\n\\nprint((max(dp[-1])))\\n"}
{"id": "1089", "input": "import bisect,collections,copy,heapq,itertools,math,numpy as np,string,sys\\ndef I(): return int(sys.stdin.readline().rstrip())\\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\\ndef S(): return sys.stdin.readline().rstrip()\\ndef LS(): return list(sys.stdin.readline().rstrip().split())\\n\\nclass UnionFind():\\n def __init__(self, n):\\n self.n = n\\n self.parents = [-1] * n\\n def find(self, x):\\n if self.parents[x] < 0:\\n return x\\n else:\\n self.parents[x] = self.find(self.parents[x])\\n return self.parents[x]\\n def union(self, x, y):\\n x = self.find(x)\\n y = self.find(y)\\n if x == y:\\n return\\n if self.parents[x] > self.parents[y]:\\n x, y = y, x\\n self.parents[x] += self.parents[y]\\n self.parents[y] = x\\n def size(self, x):\\n return", "gt": "-self.parents[self.find(x)]\\n def same(self, x, y):\\n return self.find(x) == self.find(y)\\n\\nN,K = LI()\\na = np.array([LI() for _ in range(N)])\\ngyou,retu = [],[]\\nans = 1\\nfor i,j in itertools.combinations(list(range(N)),2):\\n if (a[i,:]+a[j,:]<=K).all():\\n gyou.append((i,j))\\nuf_gyou = UnionFind(N)\\nfor x,y in gyou:\\n uf_gyou.union(x,y)\\nfor x in uf_gyou.parents:\\n if x<=-2:\\n for i in range(2,abs(x)+1):\\n ans *= i\\n ans %= 998244353\\na = a.T\\nfor i,j in itertools.combinations(list(range(N)),2):\\n if (a[i,:]+a[j,:]<=K).all():\\n retu.append((i,j))\\nuf_retu = UnionFind(N)\\nfor x,y in retu:\\n uf_retu.union(x,y)\\nfor x in uf_retu.parents:\\n if x<=-2:\\n for i in range(2,abs(x)+1):\\n ans *= i\\n ans %= 998244353\\nprint(ans)\\n"}
{"id": "1090", "input": "mod = 10 ** 9 + 7\\nMAX = 2 * 10 ** 5\\n\\nfact = [1] * (MAX + 1)\\nfor i in range(1, MAX + 1):\\n fact[i] = (fact[i-1] * i) % mod\\n\\ninv = [1] * (MAX + 1)\\nfor i in range(2, MAX + 1):\\n inv[i] = inv[mod % i] * (mod - mod // i) % mod\\n\\nfact_inv = [1] * (MAX + 1)\\nfor i in range(1, MAX + 1):\\n fact_inv[i] = fact_inv[i-1] * inv[i]", "gt": "% mod\\n\\n\\ndef comb(n, k):\\n if n < k:\\n return 0\\n return fact[n] * fact_inv[n-k] * fact_inv[k] % mod\\n\\n\\nn, m, k = list(map(int, input().split()))\\n\\nans = 0\\ncmb = comb(m * n - 2, k - 2)\\nfor i in range(1, m):\\n ans += i * (m - i) * n * n * cmb\\n ans %= mod\\n\\nfor i in range(1, n):\\n ans += i * m * m * (n - i) * cmb\\n ans %= mod\\n\\nprint(ans)\\n"}
{"id": "1091", "input": "def main():\\n N, K = list(map(int, input().split()))\\n S = list(input())\\n base = S[0]\\n flag = False\\n for i in range(0, N):\\n if K == 0:\\n break\\n if S[i] != base and (not flag):\\n flag = True\\n S[i] = base\\n elif", "gt": "S[i] != base and flag:\\n S[i] = base\\n elif S[i] == base and flag:\\n flag = False\\n K -= 1\\n else:\\n pass\\n \\n ans = 0\\n for i in range(N-1):\\n ans += S[i] == S[i+1]\\n \\n print(ans)\\n \\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1092", "input": "<s> ", "gt": "n=int(input())\\n\\nL=list(map(int,input().split()))\\n\\nind=L.index(max(L))\\n\\nL.remove(max(L))\\n\\nx=max(L)\\n\\nprint(ind+1,x)\\n"}
{"id": "1093", "input": "n, m = map(int, input().split())\\nt = sorted(map(int, input().split()))\\nf, d = [1] * (n + 1), 1000000007\\nfor i in range(2, n + 1): f[i] = (f[i - 1] * i) % d\\np, q = 0, (f[t[0] - 1] * f[n - t[-1]]) % d\\nfor", "gt": "i in range(m - 1):\\n l = t[i + 1] - t[i] - 1\\n q = (q * f[l]) % d\\n if l > 1: p += l - 1\\nprint(pow(2, p, d) * f[n - m] * pow(q, d - 2, d) % d)"}
{"id": "1094", "input": "def main():\\n n, m = [int(i) for i in input().split()]\\n d = [list(input()) for i in range(n)]\\n \\n a = [0] * m\\n for i in range(m):\\n for j in range(n):\\n if d[j][i] == '*':\\n a[i] += 1\\n", "gt": "\\n x = y = 0\\n for i in range(1, m):\\n if a[i] > a[i - 1]: x = max(x, a[i] - a[i - 1])\\n else: y = max(y, a[i - 1] - a[i])\\n \\n print(x, y)\\n \\n \\nmain()"}
{"id": "1095", "input": "n = int(input())\\nd = dict()\\nfor i in range(n):\\n d[input()]", "gt": "= i\\n\\nlst = list(d.items())\\n\\nlst.sort(key=lambda x:-x[1])\\n\\nfor i in lst:\\n print(i[0])"}
{"id": "1096", "input": "n,w56=map(int,input().split())\\nif(n==1):\\n x=[int(input())]\\nelse:\\n x=[int(i) for i in input().split()]\\nk,w90=map(int,input().split())\\nif(k==1):\\n y=[int(input())]\\nelse:\\n y=[int(i) for i in input().split()]\\nt=0\\nimport collections\\nfor i in range(1,35):\\n m=collections.Counter()\\n for j in range(n):\\n m[((x[j]-(2**(i-1)))%(2**i))]+=1\\n for j", "gt": "in range(k):\\n m[(y[j])%(2**i)]+=1\\n t=max(t,max([m[o] for o in m.keys()]))\\nif(t>=2):\\n print(t)\\nelse:\\n p=0\\n for i in range(len(x)):\\n for j in range(len(y)):\\n if(x[i]==y[j]):\\n print(2)\\n p=1\\n break\\n if(p==1):\\n break\\n if(p==0):\\n print(1)"}
{"id": "1097", "input": "#!/usr/bin/env python3\\n\\ntry:\\n while True:\\n s = input()\\n if s[0] in \"ah\" and s[1] in", "gt": "\"18\":\\n print(3)\\n elif s[0] in \"ah\" or s[1] in \"18\":\\n print(5)\\n else:\\n print(8)\\n\\nexcept EOFError:\\n pass\\n"}
{"id": "1098", "input": "import sys\\nimport math\\n\\n\\ndef main():\\n n,t,k = map(int,sys.stdin.readline().split())\\n a = list(map(int,sys.stdin.readline().split()))\\n\\n g = [[] for i in range(t+1)]\\n g[0].append([1,-1,0])\\n c = 1\\n for i in range(t):\\n for j in range(a[i]):\\n c+=1\\n g[i+1].append([c,0,0])\\n g[i][0][2]+=1\\n\\n l=0\\n for i in range(1,t+1):\\n for j in range(len(g[i])):\\n if g[i][j][2]==0:\\n l+=1\\n if l< k:\\n print(-1)\\n return\\n\\n i=0\\n j=0\\n m", "gt": "= 1\\n while l>k and m<t:\\n while i< len(g[m]) and g[m][i][2]>0:\\n i+=1\\n if i>=len(g[m]):\\n i=0\\n j=0\\n m+=1\\n continue\\n while j<len(g[m+1]) and g[m][g[m+1][j][1]][2]<2:\\n j+=1\\n if j>=len(g[m+1]):\\n i=0\\n j=0\\n m+=1\\n continue\\n g[m][i][2]+=1\\n g[m][g[m+1][j][1]][2]-=1\\n g[m+1][j][1] = i\\n l-=1\\n i+=1\\n j+=1\\n\\n if l!=k: \\n print(-1)\\n return\\n print(n)\\n for i in range(1,t+1):\\n for j in range(len(g[i])):\\n print(g[i][j][0], g[i-1][g[i][j][1]][0])\\n\\n\\nmain()"}
{"id": "1099", "input": "n = int(input())\\na = []\\nfor i in range(n):\\n h, m = map(int, input().split(\":\"))\\n a.append((h + 24) * 60 + m)\\n a.append(h * 60 + m)\\na.sort()\\nj = 0\\ns = 0\\nans = 0\\nfor i in range(0, 48 * 60):\\n if (j < 2 * n and a[j] == i):\\n ans = max(ans,", "gt": "s)\\n s = 0\\n j += 1\\n continue\\n else:\\n s += 1\\nh = ans // 60\\nm = ans % 60\\nhans = \"\"\\nmans = \"\"\\nif h < 10:\\n hans = \"0\" + str(h)\\nelse:\\n hans = str(h)\\nif m < 10:\\n mans = \"0\" + str(m)\\nelse:\\n mans = str(m)\\nprint(hans + \":\" + mans)"}
{"id": "1100", "input": "import sys\\ninput = sys.stdin.readline\\n\\nn = int(input())\\nadj = [[] for i in range(n)]\\nfor _ in range(n - 1):\\n u, v = list(map(int, input().split()))\\n adj[u-1].append(v-1)\\n adj[v-1].append(u-1)\\n\\ndepth = [-1] * n\\ndepth[0] = 0\\n \\nodd = 0\\neven =", "gt": "1\\n\\nq = [0]\\nwhile q:\\n nex = q.pop()\\n for v in adj[nex]:\\n if depth[v] == -1:\\n depth[v] = depth[nex] + 1\\n if depth[v] & 1:\\n odd += 1\\n else:\\n even += 1\\n q.append(v)\\n\\nprint(min(odd,even) - 1)\\n"}
{"id": "1101", "input": "n", "gt": "= int(input())\\nprint((n-2)**2)"}
{"id": "1102", "input": "ans = 1000000000\\nn, k = [int(i) for i in input().split()]\\ns = input()\\nl = len(s)\\nd = [k // 2, (k + 1) // 2]\\nnearl = [0] * n\\nnearr = [0] * n\\nlast = 1000000000\\nfor i in range(n):\\n if s[i] == '0':\\n last = i\\n nearl[i] = last\\nfor i in range(n - 1, -1, -1):\\n if s[i] == '0':\\n last = i\\n nearr[i] = last\\nfor i in d:\\n itl = 0\\n nf = 0\\n itr = 0\\n while s[itl] == '1':\\n itl += 1\\n cnt = 0\\n nf = itl\\n while cnt < i:\\n cnt += 1\\n nf", "gt": "+= 1\\n while s[nf] == '1':\\n nf += 1\\n cnt = 0\\n itr = nf\\n while cnt < k - i:\\n cnt += 1\\n itr += 1\\n while s[itr] == '1':\\n itr += 1\\n while True:\\n pos = (itr + itl) // 2\\n pos1 = nearl[pos]\\n ans = min(ans, max(pos1 - itl, itr - pos1))\\n pos1 = nearr[pos]\\n ans = min(ans, max(pos1 - itl, itr - pos1))\\n itr += 1\\n while itr < l and s[itr] == '1':\\n itr += 1\\n if itr == l:\\n break\\n itl += 1\\n while s[itl] == '1':\\n itl += 1\\nprint(ans)"}
{"id": "1103", "input": "n, a = list(map(int, input().split()))\\nx = list(map(int, input().split()))\\n\\na -= 1\\n\\nresult = x[a]\\n\\nfor i in range(1, n + 1):\\n le = a - i\\n rg = a + i\\n\\n le_i = le >= 0 and le < n\\n rg_i =", "gt": "rg >= 0 and rg < n\\n if not le_i and not rg_i:\\n break\\n\\n if le_i and not rg_i:\\n result += x[le]\\n elif not le_i and rg_i:\\n result += x[rg]\\n else:\\n if x[le] == x[rg] == 1:\\n result += 2\\n\\nprint(result)\\n"}
{"id": "1104", "input": "import copy\\n\\ndef solve():\\n n = int(input())\\n a = [int(c)-1 for c in input().split(' ')]\\n\\n nextcard = [[-1 for i in range(8)] for j in range(n)]\\n for i in range(n-2, -1, -1):\\n nextcard[i] = copy.copy(nextcard[i+1])\\n nextcard[i][a[i+1]] = i+1\\n\\n jump = [[-1 for i in range(n+1)] for j in range(n)]\\n for i in range(n):\\n card = a[i]\\n cpos = i\\n j = 1\\n \\n while cpos != -1:\\n jump[i][j] = cpos\\n j+=1\\n cpos = nextcard[cpos][card]\\n\\n #Find dp solution for range (val, val+1)\\n def getLen(val):\\n dp = [[-1 for i in range(1<<8)] for j in range(n+1)]\\n dp[0][0] = 0\\n\\n for i in range(n):\\n card = a[i]\\n for comb in range(1<<8):\\n if (comb & (1<<card)) ==", "gt": "0 and dp[i][comb] != -1:\\n ncomb = comb + (1<<card)\\n \\n if jump[i][val] != -1:\\n j = jump[i][val]+1\\n dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\\n \\n if jump[i][val+1] != -1:\\n j = jump[i][val+1]+1\\n dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\\n\\n dp[i+1][comb] = max(dp[i+1][comb], dp[i][comb])\\n\\n return dp[n][(1<<8)-1]\\n\\n appear = [False for i in range(8)]\\n for c in a:\\n appear[c] = True\\n\\n result = 0\\n for c in appear:\\n result += int(c)\\n\\n #Finally binary search to find the result\\n\\n cur = 0\\n for lev in range(9, -1, -1):\\n tpow = (1<<lev)\\n if cur + tpow < n:\\n ret = getLen(cur + tpow)\\n\\n if(ret != -1):\\n result = max(result, ret)\\n cur += tpow\\n\\n return result\\n\\nprint(solve())\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"}
{"id": "1105", "input": "n = int(input())\\n\\na = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\n\\ndef try_solve(t):\\n for i in range(n-1):\\n ok = False\\n\\n for x in range(4):\\n if a[i] == t[i] | x and b[i] == t[i] & x:\\n", "gt": "t.append(x)\\n ok = True\\n break\\n\\n if not ok:\\n return False\\n\\n return True\\n\\nok = False\\n\\nfor x in range(4):\\n t = [x]\\n\\n if try_solve(t):\\n print(\"YES\")\\n print(\" \".join(map(str, t)))\\n ok = True\\n break\\n\\nif not ok:\\n print(\"NO\")\\n"}
{"id": "1106", "input": "n = int(input())\\na = [-1]*100001\\np = 0\\nfor i in range(n):\\n x, k = map(int,", "gt": "input().split())\\n if a[k] < x-1:\\n p = 1\\n else:\\n a[k] = max(a[k],x)\\nif p:\\n print('NO')\\nelse:\\n print('YES')"}
{"id": "1107", "input": "def dfs(i):\\n if i >= 2 ** n:\\n return 0, 0\\n x1, m1 = dfs(i * 2)\\n x2, m2 = dfs(i * 2 + 1)\\n if m1 + a[i * 2] < m2 + a[i * 2 + 1]:\\n return x1 + x2 + m2 + a[i * 2", "gt": "+ 1] - m1 - a[i * 2], m2 + a[i * 2 + 1]\\n return x1 + x2 + m1 + a[i * 2] - m2 - a[i * 2 + 1], m1 + a[i * 2]\\nn = int(input())\\na = [0, 0] + [int(i) for i in input().split()]\\nprint(dfs(1)[0])"}
{"id": "1108", "input": "n = int(input())\\nmoves = input()\\n\\nturns_vasnja = int((len(moves)-1) / n)\\n\\ncount = 0\\nfor i in range(1, turns_vasnja+1):\\n if moves[n *", "gt": "i - 3] == moves[n * i - 2] == moves[n * i - 1]:\\n count += 1\\n\\nprint(count)\\n"}
{"id": "1109", "input": "n=int(input())\\nans=0\\nfor i in range(n):\\n", "gt": "a,b=map(int,input().split())\\n if b-a>=2: ans+=1\\nprint(ans)"}
{"id": "1110", "input": "n, k = map(int, input().split())\\nA = list(map(int, input().split()))\\n\\nans = 0\\nfor i in range(k):\\n c1 = c2 = 0\\n for", "gt": "j in range(i, n, k):\\n if A[j] == 1:\\n c1 += 1\\n else:\\n c2 += 1\\n ans += min(c1, c2)\\nprint(ans)"}
{"id": "1111", "input": "<s> ", "gt": "x=int(input())\\nprint(round(x*x*(x+1)/2-(x*(x+1)*((2*x)+1)/6)+(x)))\\n\\n"}
{"id": "1112", "input": "n, k = list(map(int, input().split()))\\n\\nMOD = 10**9+7\\n\\n\\ndef fast_modinv(up_to, M):\\n ''' Fast modular inverses of 1..up_to modulo M. '''\\n modinv = [-1 for _ in range(up_to + 1)]\\n modinv[1] = 1\\n for x in range(2, up_to + 1):\\n modinv[x] = (-(M//x) * modinv[M%x])%M\\n return modinv\\n\\nmaxn = 2*10**5 + 10\\nmodinv = fast_modinv(maxn, MOD)\\nfact, factinv = [1], [1]\\nfor i in range(1, maxn):\\n fact.append(fact[-1]*i % MOD)\\n factinv.append(factinv[-1]*modinv[i] % MOD)\\n\\n\\ndef Stirling(n, k):\\n '''The Stirling number", "gt": "of second kind (number of nonempty partitions). '''\\n if k > n:\\n return 0\\n result = 0\\n for j in range(k+1):\\n result += (-1 if (k-j)&1 else 1) * fact[k] * factinv[j] * factinv[k - j] * pow(j, n, MOD) % MOD\\n result %= MOD\\n result *= factinv[k]\\n return result % MOD\\n\\nW = sum(map(int, input().split())) % MOD\\nprint((Stirling(n, k) + (n - 1) * Stirling(n - 1, k))* W % MOD)\\n"}
{"id": "1113", "input": "import sys\\nf = sys.stdin\\n#f = open(\"input.txt\", \"r\")\\na = [list(map(int, i.split())) for i in f.read().strip().split(\"\\n\")]\\ndef solve():\\n s = a[0][2] + a[2][0]\\n for i in", "gt": "range(1, s):\\n a[0][0] = i\\n a[2][2] = s-i\\n if sum(a[0]) == sum(a[2]):\\n break\\n a[1][1] = sum(a[0]) - sum(a[1])\\n for i in a:\\n print(*i)\\nsolve()"}
{"id": "1114", "input": "n = int(input())\\na = list(map(int, input().split()))\\nmx = -1\\nfor step, elem in enumerate(a):\\n if", "gt": "elem > mx + 1:\\n print(step + 1)\\n return\\n else:\\n mx = max(mx, elem)\\nprint(-1)\\n"}
{"id": "1115", "input": "n, m = [int(i) for i in input().split()]\\nf = [int(i) for i in input().split()]\\nb = [int(i) for i in input().split()]\\na = [-1] * 100001\\nfor i in range(n):\\n if a[f[i]] != -1:\\n a[f[i]]", "gt": "= -2\\n else:\\n a[f[i]] = i\\nfor i in b:\\n if a[i] == -1:\\n print('Impossible')\\n return\\nfor i in b:\\n if a[i] == -2:\\n print('Ambiguity')\\n return\\nprint('Possible')\\nfor i in b:\\n print(a[i] + 1, end=' ')"}
{"id": "1116", "input": "n = int(input())\\ns = sum(list(map(int, input().split())))\\nm = int(input())\\nfor i in range(m):\\n l, r =", "gt": "list(map(int, input().split()))\\n s = max(s, l)\\n if l <= s <= r:\\n print(s)\\n return\\nprint(-1)\\n\\n\\n\\n"}
{"id": "1117", "input": "\\nfrom collections import defaultdict,deque\\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\\nsys.setrecursionlimit(10**8)\\nINF = float('inf')\\nmod = 10**9+7\\neps = 10**-7\\ndef inp(): return int(sys.stdin.readline())\\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\\ndef inpl_str(): return list(sys.stdin.readline().split())\\n\\n\\ndef gcd(a,b):\\n while b:\\n a,b = b, a%b\\n return a\\n\\nT = inp()\\nfor _ in", "gt": "range(T):\\n a,b,k = inpl()\\n a,b = min(a,b), max(a,b)\\n\\n n = gcd(a,b)\\n # while n < b:\\n # n += a\\n # cnt += 1\\n cnt = -((n-b)//a)\\n\\n\\n if cnt >= k:\\n print(\"REBEL\")\\n else:\\n print(\"OBEY\")\\n"}
{"id": "1118", "input": "n = int(input())\\n\\ndata = []\\n\\nfor i in range(n):\\n a, b = list(map(int, input().split()))\\n data.append([a, b])\\n\\n\\nans = True\\nprev = max(data[0])\\nfor i in range(1, n):\\n a, b = data[i]\\n a, b = min(a,", "gt": "b), max(a,b)\\n \\n if a > prev:\\n ans = False\\n break\\n\\n if a <= prev < b:\\n prev = a\\n continue\\n\\n if prev >= b:\\n prev = b\\n\\n\\nif ans :\\n print(\"YES\")\\nelse:\\n print('NO')\\n"}
{"id": "1119", "input": "n=int(input())\\nC=[0]+list(map(int,input().split()))\\n\\n#n=5000\\n#C=list(range(n+1))\\n\\nA=[]\\nfor i in range(1,n+1):\\n if C[i]!=C[i-1]:\\n A.append(C[i])\\n\\nL=len(A)\\nDP=[[[0]*L for i in range(L)] for j in range(2)]\\n#左の色に揃える or 右の色に揃える,左からi～j番目を\\n\\ndef color(r,i,j):#i<j\\n if r==1:\\n", "gt": "if A[i]==A[j]:\\n DP[r][i][j]=min(DP[0][i][j-1],DP[1][i][j-1]+1)\\n else:\\n DP[r][i][j]=min(DP[0][i][j-1]+1,DP[1][i][j-1]+1)\\n\\n else:\\n if A[i]==A[j]:\\n DP[r][i][j]=min(DP[1][i+1][j],DP[0][i+1][j]+1)\\n else:\\n DP[r][i][j]=min(DP[1][i+1][j]+1,DP[0][i+1][j]+1)\\n\\nfor i in range(1,L):\\n for j in range(L-i):\\n color(0,j,i+j)\\n color(1,j,i+j)\\n\\n #print(DP)\\n\\nprint(min(DP[0][0][L-1],DP[1][0][L-1]))\\n"}
{"id": "1120", "input": "k, pa, pb = list(map(int, input().split()))\\n\\nMOD = 10**9 + 7\\nINF = ((pa + pb) * pow(pb, MOD-2, MOD)) % MOD\\nrAB = pow(pa+pb, MOD-2, MOD)\\nrB = pow(pb, MOD-2, MOD)\\n\\nmemo = {}\\n\\ndef dfs(a, ab):\\n if ab >= k:\\n return ab\\n if a + ab >= k:\\n #return INF\\n #return (pa + pb) / pb\\n return ((a + MOD-1) + (pa + pb) * rB + ab) % MOD\\n return a - 1 + (pa + pb) / pb + ab\\n if (a, ab) in", "gt": "memo:\\n return memo[a, ab]\\n #res = (((dfs(a+1, ab)+1) * pa * rAB) + ((dfs(a, ab+a)+1) * pb * rAB)) % MOD\\n #res = (dfs(a+1, ab)) * pa / (pa + pb) + (dfs(a, ab+a)) * pb / (pa + pb)\\n res = (dfs(a+1, ab) * pa * rAB) + (dfs(a, ab+a) * pb * rAB)\\n #print(a, ab, res)\\n memo[a, ab] = res = res % MOD\\n return res\\n#print((dfs(1, 0) * pa * rAB + 1) % MOD)\\n#print((pb + dfs(1, 0)*pa) / pa)\\nprint(dfs(1, 0))\\n"}
{"id": "1121", "input": "start = input()\\ncounter = 0\\nsInt = int(start)\\nwhile", "gt": "sInt!=0:\\n sInt-=max([int(c) for c in start])\\n start=str(sInt)\\n counter+=1\\nprint(counter)"}
{"id": "1122", "input": "import sys\\ninput = sys.stdin.readline\\n\\nn,m=list(map(int,input().split()))\\n\\nANS=[[-1]*m for i in range(n)]\\n\\nfor i in range(n):\\n for j in range(m):\\n if ANS[i][j]==-1:\\n for koma in [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]:\\n for k,l in [(i-1,j),(i,j-1),(i+1,j),(i,j+1)]:\\n if 0<=k<n and 0<=l<m and ANS[k][l]==koma:\\n break\\n else:\\n nkoma=koma\\n break\\n\\n MAXlength=1\\n if nkoma==\"A\": \\n for length in range(1,101):\\n if i+length>=n or j+length>=m:\\n break\\n \\n for k,l in [(i-1,j+length),(i+length,j-1)]:\\n if 0<=k<n and 0<=l<m", "gt": "and ANS[k][l]==nkoma:\\n break\\n if 0<=i<n and ANS[i][j+length]!=-1:\\n break\\n else:\\n MAXlength=length+1\\n\\n elif nkoma==\"B\":\\n for length in range(1,101):\\n if i+length>=n or j+length>=m:\\n break\\n\\n flag=0\\n if 0<=i-1<n and ANS[i-1][j+length]==\"A\":\\n flag=1\\n if 0<=j-1<m and ANS[i+length][j-1]==nkoma:\\n break\\n if 0<=i<n and ANS[i][j+length]!=-1:\\n break\\n\\n if flag==1:\\n MAXlength=length+1\\n else:\\n break\\n \\n\\n for k in range(i,i+MAXlength):\\n for l in range(j,j+MAXlength):\\n ANS[k][l]=nkoma\\n\\nfor a in ANS:\\n print(\"\".join(a))\\n \\n \\n"}
{"id": "1123", "input": "N,M=map(int,input().split())\\n\\nif M%2==0:\\n for i in range(M//2):\\n print(i+1,M-i)\\n for i in range(M//2):\\n", "gt": "print(M+i+1,2*M-i+1) \\nelse:\\n for i in range(M//2):\\n print(i+1,M-i)\\n for i in range(M//2+1):\\n print(M+i+1,2*M-i+1)"}
{"id": "1124", "input": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\\nimport time,random\\n\\nsys.setrecursionlimit(10**7)\\ninf = 10**20\\neps = 1.0 / 10**10\\nmod = 10**9+7\\nmod2 = 998244353\\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\\n\\ndef LI(): return list(map(int, sys.stdin.readline().split()))\\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\\ndef LS(): return sys.stdin.readline().split()\\ndef I(): return int(sys.stdin.readline())\\ndef F(): return float(sys.stdin.readline())\\ndef S(): return input()\\ndef pf(s): return print(s, flush=True)\\ndef pe(s): return print(str(s), file=sys.stderr)\\ndef JA(a, sep): return sep.join(map(str, a))\\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\\n\\n\\n\\nclass Prime():\\n def __init__(self, n):\\n self.M = m = int(math.sqrt(n)) + 10\\n self.A = a = [True] * m\\n a[0] = a[1] = False\\n self.T = t = [2]\\n for j in range(4, m, 2):\\n a[j] = False\\n for i in range(3, m, 2):\\n if not a[i]:\\n continue\\n t.append(i)\\n for j in range(i*i,m,i):\\n a[j] = False\\n self.ds_memo = {}\\n self.ds_memo[1] = set([1])\\n\\n def is_prime(self, n):\\n return", "gt": "self.A[n]\\n\\n def division(self, n):\\n d = collections.defaultdict(int)\\n for c in self.T:\\n while n % c == 0:\\n d[c] += 1\\n n //= c\\n if n < 2:\\n break\\n if n > 1:\\n d[n] += 1\\n return d.items()\\n\\n # memo\\n def divisions(self, n):\\n if n in self.ds_memo:\\n return self.ds_memo[n]\\n\\n for c in self.T:\\n if n % c == 0:\\n rs = set([c])\\n for cc in self.divisions(n // c):\\n rs.add(cc)\\n rs.add(cc * c)\\n self.ds_memo[n] = rs\\n return rs\\n\\n rs = set([1, n])\\n self.ds_memo[n] = rs\\n return rs\\n\\ndef main():\\n n,k = LI()\\n pr = Prime(10**5)\\n c = collections.defaultdict(int)\\n for i in range(k, 0, -1):\\n t = k // i\\n p = (pow(t, n, mod) + c[i]) % mod\\n ds = pr.divisions(i)\\n for kk in ds:\\n if kk == i:\\n continue\\n c[kk] -= p\\n c[i] = p\\n\\n r = sum(k*v%mod for k,v in c.items()) % mod\\n\\n return r\\n\\nprint(main())\\n\\n\\n\\n"}
{"id": "1125", "input": "import math\\n\\n\\ndef LI():\\n return list(map(int, input().split()))\\n\\n\\nN = int(input())\\nA = LI()\\nAmin = min(A)\\nans = Amin\\nfor i", "gt": "in A:\\n if Amin == i:\\n continue\\n Amin = min(Amin, math.gcd(Amin, i))\\nans = min(ans, math.gcd(Amin, ans))\\n\\nprint(ans)\\n"}
{"id": "1126", "input": "n = int(input())\\na = list(map(int, input().split()))\\n\\nif n == 2:\\n if a[0] >= a[1] and (a[0] - a[1]) % 2 == 0:\\n print((a[0] - a[1]) // 2)\\n else:\\n print(-1)\\nelse:\\n num = 0\\n for i in range(2, n):\\n num ^= a[i]\\n \\n _and = (a[0] + a[1] - num)\\n if _and % 2 != 0 or a[0] < _and // 2", "gt": "or (_and // 2) & num != 0:\\n print(-1)\\n else:\\n _and //= 2\\n \\n max_2 = 1\\n while max_2 <= num:\\n max_2 *= 2\\n \\n a0 = _and\\n while max_2 >= 1:\\n if num & max_2 != 0 and a0 + max_2 <= a[0]:\\n a0 += max_2\\n max_2 //= 2\\n \\n if a0 != 0:\\n print(a[0] - a0)\\n else:\\n print(-1)"}
{"id": "1127", "input": "import sys\\nimport numpy as np\\nimport math\\nimport collections\\nimport copy\\nimport decimal\\nfrom collections import deque \\nfrom functools import reduce\\nfrom itertools import product\\nfrom itertools import combinations\\nN, X, M = list(map(int, input().split()))\\n\\n# X^2がMより大きい場合はMで割った余り、小さければそのままを返却\\ndef f(X, M):\\n if X**2 >= M:\\n return X**2 % M\\n else:\\n return X**2\\n\\nappear = np.full(M, -1)\\nseq = []\\nfx = X\\nappear[fx] = 0\\nseq.append(fx)\\nfor i in range(1, N):\\n fx = f(fx, M)\\n# print(fx, appear[fx])\\n if appear[fx]", "gt": "!= -1:\\n loop_st = appear[fx]\\n loop_en = i\\n break\\n seq.append(fx)\\n appear[fx] = i\\nseq.insert(0, 0)\\nseq_sum = np.cumsum(seq)\\n\\nif N <= len(seq)-1 :\\n print((seq_sum[N]))\\nelse:\\n # ループの前まで\\n lp_b = seq_sum[loop_st-1]\\n # ループしている個数を求める\\n loop_num = (len(seq_sum)-1) - loop_st\\n # 商はループ回数、余りはループしきらなかった分\\n qu = (N-(loop_st)) // loop_num\\n mo = (N-(loop_st)) % loop_num\\n # ループした分だけかける\\n lp_sum = (seq_sum[-1] - seq_sum[loop_st]) * qu\\n # 最後の余りの部分を加算\\n lp_en = seq_sum[loop_st+mo] - seq_sum[loop_st-1]\\n print((lp_b+lp_sum+lp_en))\\n \\n"}
{"id": "1128", "input": "for _ in range(int(input())):\\n n = int(input())\\n digits = list(map(int,list(input())))\\n if n % 2 == 1:\\n containsOdd = False\\n for i in range(0,n,2):\\n if digits[i] % 2 == 1:\\n", "gt": "containsOdd = True\\n if containsOdd:\\n print(1)\\n else:\\n print(2)\\n else:\\n containsEven = False\\n for i in range(1,n,2):\\n if digits[i] % 2 == 0:\\n containsEven = True\\n if containsEven:\\n print(2)\\n else:\\n print(1)\\n"}
{"id": "1129", "input": "a,m = map(int,input().split())\\n\\nfor i in range(100000):\\n", "gt": "if a%m==0:\\n print(\"Yes\")\\n quit()\\n else:\\n a+=a%m\\nprint(\"No\")"}
{"id": "1130", "input": "n = int(input())\\narr = [int(x)", "gt": "for x in input().split()]\\narr.sort()\\nif(n%2):\\n print(arr[n//2])\\nelse:\\n print(arr[n//2-1])"}
{"id": "1131", "input": "n, m, k = input().split(' ')\\nn = int(n)\\nm = int(m)\\nk = int(k)\\nind = []\\npre = []\\n\\nfor _ in range(n):\\n s = input()\\n ind.append([])\\n for i, c in enumerate(s):\\n if c == '1':\\n ind[-1].append(i)\\n\\nfor i in range(n):\\n pre.append([])\\n for j in range(k + 1):\\n pre[i].append([])\\n if len(ind[i]) > j:\\n pre[i][j] = ind[i][-1] - ind[i][0] + 1\\n else:\\n pre[i][j] = 0\\n continue\\n for x in range(j + 1):\\n y =", "gt": "len(ind[i]) - 1 - j + x\\n\\n if y >= x and ind[i][y] - ind[i][x] + 1 < pre[i][j]:\\n pre[i][j] = ind[i][y] - ind[i][x] + 1\\ndp = [[]]\\n\\nfor i in range(k + 1):\\n dp[0].append(pre[0][i])\\n\\n\\nfor i in range(1, n):\\n dp.append([])\\n for j in range(0, k + 1):\\n dp[i].append(pre[i][j] + dp[i - 1][0])\\n for z in range(j + 1):\\n dp[i][j] = min(dp[i][j], dp[i - 1][z] + pre[i][j - z])\\n\\nprint(dp[n - 1][k])\\n"}
{"id": "1132", "input": "a,b,w,x,c=list(map(int,input().split()))\\nans=0\\nbb=b\\nbenefit=0\\nVisited=[False]*1003\\nCycleCost=-1\\nwhile(1):\\n if(c<=a):\\n break\\n if(Visited[b]!=False):\\n CycleCost=ans-Visited[b][1]\\n CycleBenefit=benefit-Visited[b][0]\\n CycleBegining=b\\n break\\n Visited[b]=(benefit,ans)\\n if(b<x):\\n b=w-(x-b)\\n ans+=1\\n elif(b>=x):\\n b-=x\\n ans+=1\\n benefit+=1\\n if(benefit==c-a):\\n break\\n\\nif(CycleCost==-1):\\n", "gt": "print(ans)\\nelse:\\n c-=benefit\\n diff=c-a\\n xx=diff//CycleBenefit\\n if(xx!=0):\\n xx-=1\\n ans+=xx*CycleCost\\n diff-=xx*CycleBenefit\\n b=CycleBegining\\n while(diff>0):\\n if(b<x):\\n b=w-(x-b)\\n ans+=1\\n else:\\n b-=x\\n ans+=1\\n diff-=1\\n print(ans)\\n \\n"}
{"id": "1133", "input": "import re\\nimport itertools\\nfrom collections import Counter, deque\\n\\nclass Task:\\n n, m = 0, 0\\n graph = []\\n answer = \"\"\\n \\n def getData(self):\\n self.n, self.m = [int(x) for x in input().split(' ')]\\n for i in range(0, self.m):\\n self.graph += [[int(x) for x in input().split(' ')]]\\n\\n #inFile = open('input.txt', 'r')\\n #inFile.readline().rstrip()\\n #self.childs = inFile.readline().rstrip()\\n\\n def solve(self):\\n graph = self.graph\\n vertexDegrees = [0] * (self.n + 1)\\n for", "gt": "edge in graph:\\n vertexDegrees[edge[0]] += 1\\n vertexDegrees[edge[1]] += 1\\n vertexDegrees = vertexDegrees[1:]\\n if vertexDegrees.count(2) == len(vertexDegrees):\\n self.answer = 'ring topology'\\n return\\n if vertexDegrees.count(1) == 2 and vertexDegrees.count(2) == \\\\n len(vertexDegrees) - 2:\\n self.answer = 'bus topology'\\n return\\n if vertexDegrees.count(1) == len(vertexDegrees) - 1:\\n self.answer = 'star topology'\\n return\\n self.answer = 'unknown topology'\\n\\n def printAnswer(self):\\n print(re.sub(r'[\\[\\],]', '', str(self.answer)))\\n #print(self.answer[:6])\\n #outFile = open('output.txt', 'w')\\n #outFile.write(self.answer)\\n\\ntask = Task()\\ntask.getData()\\ntask.solve()\\ntask.printAnswer()\\n"}
{"id": "1134", "input": "def main():\\n n = int(input())\\n a = [input() for i in range(n)]\\n \\n result = 0\\n for i in range(26):\\n for j in range(i + 1, 26):\\n t = 0\\n ci", "gt": "= chr(i + ord('a'))\\n cj = chr(j + ord('a'))\\n for s in a:\\n if s.count(ci) + s.count(cj) == len(s):\\n t += len(s)\\n result = max(result, t)\\n \\n print(result)\\n \\n \\n \\nmain()"}
{"id": "1135", "input": "n = int(input())\\nm = [int(i) for i in input().split()]\\n\\ndm = [0 for i in range(n)]\\n\\ndm[-1] = m[-1] + 1\\n\\nfor i in range(n - 2,", "gt": "-1, -1):\\n dm[i] = max(m[i] + 1, m[i+1], dm[i+1]-1)\\n#print(dm)\\nfor i in range(1, n):\\n dm[i] = max(dm[i], dm[i-1])\\n#print(dm)\\n\\nprint(sum([dm[i] - 1 - m[i] for i in range(n)]))\\n"}
{"id": "1136", "input": "#!/usr/bin/env python3\\n\\ndef main():\\n try:\\n while True:\\n n = int(input())\\n s = input()\\n result = \"\"\\n for m,", "gt": "c in enumerate(reversed(s)):\\n result = result[:m >> 1] + c + result[m >> 1:]\\n\\n print(result)\\n\\n except EOFError:\\n pass\\n\\nmain()\\n"}
{"id": "1137", "input": "import math\\nMOD = int( 1e9 + 7 )\\n\\nN, M = map( int, input().split() )\\nsn = int( math.sqrt( N ) )\\n\\nans = N * M % MOD\\nfor i in range( 1, min( sn, M ) + 1, 1 ):\\n ans -= N // i * i\\n\\nans %= MOD\\nif N // ( sn + 1 ) > M:\\n exit( print( ans ) )\\n\\nfor f in range( N // ( sn + 1 ), 0,", "gt": "-1 ):\\n s = lambda x: x * ( x + 1 ) // 2\\n if N // f > M:\\n ans -= f * ( s( M ) - s( N // ( f + 1 ) ) )\\n break\\n ans -= f * ( s( N // f ) - s( N // ( f + 1 ) ) )\\n\\nans %= MOD\\nif ans < 0:\\n ans += MOD\\nprint( ans )\\n"}
{"id": "1138", "input": "n, m, k = map(int, input().split())\\ns, t = input(), input()\\n\\nn += 1\\nm += 1\\n\\np = [i for i in range(n * m - n) if (i + 1) % n]\\nr = p[::-1]\\n\\nd = [0] * n * m\\n\\nfor i in p:\\n if s[i % n] ==", "gt": "t[i // n]: d[i] = d[i - n - 1] + 1\\n\\nf = d[:]\\n\\nfor y in range(k - 1):\\n for i in p: f[i] = max(f[i], f[i - 1], f[i - n])\\n for i in r: f[i] = f[i - d[i] * (n + 1)] + d[i]\\n\\nprint(max(f))"}
{"id": "1139", "input": "s = input()\\nli = s.count(\"L\")\\nri = s.count(\"R\")\\nui = s.count(\"U\")\\ndi =", "gt": "s.count(\"D\")\\nn = len(s)\\nif n % 2 != 0:\\n print(-1)\\nelse:\\n print((abs(li-ri)+abs(di-ui))//2)\\n"}
{"id": "1140", "input": "from sys import stdin, stdout\\n\\n\\ndef __starting_point():\\n\\n def omkar_and_last_floor(a, n, m):\\n\\n dp = [[0 for c in range(m)] for r in range(m)]\\n\\n #print(dp)\\n for r in range(m):\\n for l in range(r,-1,-1):\\n for k in range(l, r+1):\\n cnt = 0\\n for i in range(n):\\n if l <= a[i][k][0] and a[i][k][1] <= r:\\n cnt += 1\\n lr = cnt*cnt\\n if k-1 >= l:\\n lr +=", "gt": "dp[l][k-1]\\n if k+1 <= r:\\n lr += dp[k + 1][r]\\n\\n dp[l][r] = max(dp[l][r], lr)\\n #print(dp)\\n return dp[0][m-1]\\n\\n\\n n, m = list(map(int, stdin.readline().split()))\\n a = [[[0,0] for c in range(m)] for r in range(n)]\\n for i in range(n):\\n k = int(stdin.readline())\\n for j in range(k):\\n l, r = list(map(int, stdin.readline().split()))\\n for x in range(l, r+1):\\n a[i][x-1][0] = l-1\\n a[i][x-1][1] = r-1\\n\\n print(omkar_and_last_floor(a, n, m))\\n\\n\\n__starting_point()"}
{"id": "1141", "input": "\"\"\"\\nCodeforces Contest 261 Div 2 Problem B\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef main():\\n n, = read()\\n a = read()\\n mn = 10**9+1\\n mncount = 0\\n mx = 0\\n mxcount = 0\\n for i in range(n):\\n if a[i] < mn:\\n mn = a[i]\\n mncount = 1\\n elif a[i] == mn:\\n mncount += 1\\n if a[i] > mx:\\n mx = a[i]\\n mxcount = 1\\n elif a[i] == mx:\\n mxcount += 1\\n", "gt": "if mx != mn:\\n print(mx-mn, mncount*mxcount)\\n else:\\n print(0, n*(n-1)//2)\\n\\n################################### NON-SOLUTION STUFF BELOW\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "1142", "input": "n, m = list(map(int, input().split()))\\ns = list(input())\\na = []\\nfor _ in range(m):\\n l, r, c1, c2 = input().split()\\n l, r", "gt": "= int(l) - 1, int(r) - 1\\n for i in range(l, r + 1):\\n if s[i] == c1:\\n s[i] = c2\\nprint(''.join(s))\\n\\n"}
{"id": "1143", "input": "import sys\\n\\nn, k = list(map(int, sys.stdin.readline().strip().split()))\\nL = []\\nR = []\\nA = []\\nfor i in range (0, n):\\n x = list(map(int, sys.stdin.readline().strip().split()))\\n L.append(x[0])\\n R.append(x[1])\\n A.append(x[2])\\nL.append(R[-1])\\ni = n-1\\nx = 0\\ny = 0\\nans = 0\\nv = True\\nN = [0 for i in range (0, n)]\\nwhile i >= 0:\\n if R[i] == L[i+1]:\\n x = max(x + A[i] - k * (R[i] - L[i]), 0)\\n N[i] = x\\n else:\\n x = max(A[i] - k *", "gt": "(R[i] - L[i]), 0)\\n N[i] = x\\n if N[i] > k:\\n v = False\\n i = i - 1\\nm = k\\nN.append(0)\\ni = 0\\nwhile i < n and v == True:\\n if m < N[i]:\\n ans = ans + m\\n m = k\\n m = m - A[i]\\n ans = ans + A[i]\\n while m < 0:\\n m = m + k\\n i = i + 1\\nif v == True:\\n print(ans)\\nelse:\\n print(-1)"}
{"id": "1144", "input": "w, r = open('output.txt', 'w'), open('input.txt', 'r')\\ns, y = [0] * 466, [0, 100, 131, 159, 190, 220, 251, 281, 312, 343, 373, 404, 434]\\nfor i in range(int(r.readline())):\\n", "gt": "m, d, p, t = map(int, r.readline().split())\\n x = y[m] + d\\n s[x] -= p\\n s[x - t] += p\\nfor i in range(465):\\n s[i + 1] += s[i]\\nw.write(str(max(s)))"}
{"id": "1145", "input": "match = 0\\nnonmatch = 0\\ncount = 0\\n\\ndef calc_match(s, t, p):\\n nonlocal match\\n nonlocal nonmatch\\n nonlocal count\\n if p == len(s)-len(t):\\n return\\n if p+len(t) < len(s):\\n if s[p+len(t)] == '?':\\n count -= 1\\n elif s[p+len(t)] == t[-1]:\\n match -= 1\\n else:\\n nonmatch -= 1\\n match, nonmatch = nonmatch, match\\n if p+len(t) < len(s):\\n if s[p] == '?':\\n count += 1\\n elif s[p] == 'a':\\n match += 1\\n else:\\n nonmatch += 1\\n\\ndef init_match(s, t):\\n nonlocal match\\n nonlocal nonmatch\\n nonlocal count\\n p = len(s)-len(t)\\n for i in range(len(t)):\\n if s[p+i]", "gt": "== '?':\\n count += 1\\n elif s[p+i] == t[i]:\\n match += 1\\n else:\\n nonmatch += 1\\n\\n\\n\\nn = int(input())\\ns = input()\\nm = int(input())\\nt = \"\"\\nfor i in range(m):\\n if i%2==0:\\n t = t + 'a'\\n else:\\n t = t + 'b'\\n\\ninit_match(s,t)\\n\\ndp = []\\nfor i in range(n+3):\\n dp.append((0, 0))\\n\\np = n-m\\nwhile p >= 0:\\n calc_match(s, t, p)\\n if nonmatch == 0:\\n if dp[p+1][0] == dp[p+m][0]+1:\\n dp[p] = (dp[p+1][0], min(dp[p+1][1], dp[p+m][1]+count))\\n elif dp[p+1][0] > dp[p+m][0]+1:\\n dp[p] = dp[p+1]\\n else:\\n dp[p] = (dp[p+m][0]+1, dp[p+m][1]+count)\\n else:\\n dp[p] = dp[p+1]\\n p -= 1\\n\\nprint(dp[0][1])"}
{"id": "1146", "input": "n = int(input())\\nA = list(map(int, input().split()))\\nA.sort()\\nprev = -1\\nres = 0\\n\\nfor x in A:\\n if x", "gt": "> prev:\\n prev = x\\n else:\\n prev = prev + 1\\n res += prev - x\\nprint(res)\\n"}
{"id": "1147", "input": "n, m = [int(i) for i in input().split()]\\nd = set()\\nfor i in range(n):\\n _,", "gt": "*a = [int(i) for i in input().split()]\\n d |= set(a)\\n\\nif len(d) == m:\\n print(\"YES\")\\nelse:\\n print(\"NO\")\\n"}
{"id": "1148", "input": "import math\\nimport bisect\\n\\n\\nn, x, k = list(map(int, input().split()))\\na = sorted(list(map(int, input().split())))\\nans = 0\\n\\nfor num in a:\\n l = math.ceil(num/x)*x + (k-1)*x\\n r = l + x - 1\\n l = num if l <", "gt": "num else l\\n # print(l, r, bisect.bisect_left(a, l), bisect.bisect_right(a, r), bisect.bisect_right(a, r) - bisect.bisect_left(a, l))\\n ans += bisect.bisect_right(a, r) - bisect.bisect_left(a, l)\\n\\nprint(ans)\\n\\n\\n'''\\n7 3 2\\n1 3 5 9 11 16 25\\n'''\\n\\n'''\\n4 2 0\\n5 3 1 7\\n'''\\n"}
{"id": "1149", "input": "am=0\\nx = int(input())\\nl = list(map(int, input().split(' ')))\\nm = min(l)\\nk = [i for i in range(x) if", "gt": "l[i] == m]\\nk.append(k[0]+x)\\nfor i in range(len(k)-1):\\n am = max(am, k[i+1]-k[i])\\n\\nprint(m * x + am - 1)\\n"}
{"id": "1150", "input": "import fractions\\ncount = 0\\na = int(input())\\n#n\\n\\nlistx = list(map(int, input().split(' ')))\\nlisty = list(map(int, input().split(' ')))\\nlistx.remove(listx[0])\\nlisty.remove(listy[0])\\nlistx = set(listx)\\nlisty = set(listy)\\nlistz", "gt": "= listx.union(listy)\\nlistz=list(listz)\\nlistw = [i+1 for i in range(a)]\\nif listz == listw:\\n print(\"I become the guy.\")\\n\\nelse:\\n print(\"Oh, my keyboard!\")\\n"}
{"id": "1151", "input": "def f(x, y, a, b, n):\\n return a + (x - a) * cos[n] - (y - b) * sin[n], b + (x - a) * sin[n] + (y - b) * cos[n]\\n\\n\\ndef check(p):\\n d = {}\\n for i in range(len(p) - 1):\\n for j in range(i + 1, len(p)):\\n dist = (p[i][0] - p[j][0]) ** 2 + (p[i][1] - p[j][1]) ** 2\\n d[dist] = d.get(dist, 0) + 1\\n if len(d) != 2:\\n return 0\\n a, b = sorted(d)\\n return 2", "gt": "* a == b and d[a] == 4 and d[b] == 2\\n\\n\\ncos, sin, variants = [1, 0, -1, 0], [0, 1, 0, -1], [[x, y, z, a] for x in range(4) for y in range(4) for z in range(4) for a in range(4)]\\nfor t in range(int(input())):\\n moles, ans = [list(map(int, input().split())) for x in range(4)], 13\\n for a in variants:\\n if check([f(moles[i][0], moles[i][1], moles[i][2], moles[i][3], a[i]) for i in range(4)]):\\n ans = min(ans, sum(a))\\n print(ans if ans != 13 else -1)\\n"}
{"id": "1152", "input": "def read_data():\\n n, m = map(int, input().strip().split())\\n a = list(map(int, list(input().strip().split())))\\n return n, m, a\\n\\ndef find(start,end,v):\\n mid = int((start + end) / 2)\\n if start == end:\\n return start\\n if end - start == 1:\\n if a[end] <= v:\\n return end\\n else:\\n return start\\n if a[mid] == v:\\n return mid\\n", "gt": "if a[mid] > v:\\n return find(start,mid,v)\\n else:\\n return find(mid,end,v)\\n\\ndef solve():\\n val = -1\\n for i in range(0,len(a)-2):\\n pos = find(i+2,len(a)-1,a[i]+m)\\n if a[pos] <= a[i] + m:\\n if (a[pos] - a[i+1]) / (a[pos] - a[i]) > val:\\n val = (a[pos] - a[i+1]) / (a[pos] - a[i])\\n return val\\n\\nn, m, a = read_data()\\nprint(solve())"}
{"id": "1153", "input": "from collections import defaultdict as dd\\nimport math\\nimport heapq\\ndef nn():\\n return int(input())\\n\\ndef li():\\n return list(input())\\n\\ndef mi():\\n return list(map(int, input().split()))\\n\\ndef lm():\\n return list(map(int, input().split()))\\n\\nn, m=mi()\\nA=[]\\nfor i in range(n):\\n A.append(lm())\\n\\nB=[]\\nfor i in range(n):\\n B.append(lm())\\n\\ndef check(A,B):\\n", "gt": "for i in range(n):\\n count=0\\n for j in range(m):\\n count+=abs(A[i][j]-B[i][j])\\n\\n if not count%2==0:\\n return 'No'\\n\\n for j in range(m):\\n count=0\\n for i in range(n):\\n count+=abs(A[i][j]-B[i][j])\\n if not count%2==0:\\n return 'No'\\n\\n return 'Yes'\\n\\nprint(check(A,B))\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"}
{"id": "1154", "input": "n,m=list(map(int,input().split()))\\nx=list(map(int,input().split()))\\ny=list(map(int,input().split()))\\ni,j=0,0\\ns=0\\ns1=0\\ns2=0\\nwhile i<n and j<m:\\n if x[i]+s1==y[j]+s2:\\n s+=1\\n i+=1\\n j+=1\\n", "gt": "s1=0\\n s2=0\\n elif x[i]+s1>y[j]+s2:\\n s2+=y[j]\\n j+=1\\n else:\\n s1+=x[i]\\n i+=1\\nprint(s)\\n"}
{"id": "1155", "input": "n, h, k = [int(x) for x in input().split()]\\nL=[int(x) for x in input().split()]\\nL = L[::-1]\\np = 0\\nt = 0\\nwhile L:\\n if L and h-p >=", "gt": "L[-1]:\\n p+=L.pop()\\n if L:\\n req = L[-1]-h+p\\n inc = (req-1)//k + 1\\n t += inc\\n p -= inc*k\\n p=max(p,0)\\n\\nif p:\\n t += (p-1)//k + 1\\n\\nprint(t)\\n"}
{"id": "1156", "input": "# = map(int, input().split())\\nn, m = list(map(int, input().split()))\\nans = 10 ** 100\\nfor i in", "gt": "range(n):\\n p, q = list(map(int, input().split()))\\n ans = min(ans, p / q * m)\\nprint(ans)\\n"}
{"id": "1157", "input": "n = int(input())\\na = list(map(int, input().split()))\\nb = input()\\nr = 1000000000\\nl = -r\\nfor i in range(4, n):\\n if b[i - 1] != b[i]:\\n if b[i] ==", "gt": "'0':\\n r = min(r, min(a[i - 4: i + 1]) - 1)\\n else:\\n l = max(l, max(a[i - 4: i + 1]) + 1)\\nprint(l, r)\\n"}
{"id": "1158", "input": "def main():\\n import sys\\n input = sys.stdin.readline\\n \\n n = int(input())\\n arr = list(map(int, input().split()))\\n \\n cnt = [1, 0]\\n \\n lst = [0] * (n + 1)\\n lst[0] = 0\\n for i in range(n):\\n lst[i + 1]", "gt": "= lst[i] ^ (arr[i] < 0)\\n cnt[lst[i + 1]] += 1\\n \\n ans1 = cnt[0] * cnt[1]\\n ans2 = cnt[0] * (cnt[0] - 1) // 2 + cnt[1] * (cnt[1] - 1) // 2\\n print(ans1, ans2)\\n \\n return 0\\n\\nmain()\\n"}
{"id": "1159", "input": "rest, people = map(int, input().split())\\ntypes = list(map(int, input().split()))\\na = dict()\\nfor elem in types:\\n if elem in a:\\n a[elem] += 1\\n else:\\n a[elem] = 1\\nmaximum = 0\\nfor key in", "gt": "a:\\n if a[key] > maximum:\\n maximum = a[key]\\nneeded = maximum\\nwhile needed % people != 0:\\n needed += 1\\nans = 0\\nfor key in a:\\n ans += needed - a[key]\\nprint(ans)"}
{"id": "1160", "input": "n = int(input())\\n\\ndef pr(x):\\n for i in range(2, x):\\n if x % i == 0:\\n return False\\n return True\\n\\ne = []\\nfor i in range(n):\\n e += [[i, (i+1) %", "gt": "n]]\\nx = n\\nu = 0\\nv = n // 2\\nwhile not pr(x):\\n e += [[u, v]]\\n x += 1\\n u += 1\\n v += 1\\n\\nprint(x)\\nfor g in e:\\n print(g[0]+1, g[1]+1)"}
{"id": "1161", "input": "3\\n\\nszs = ['S', 'M', 'L', 'XL', 'XXL', 'XXXL']\\nd = {'S':0, 'M':1, 'L':2, 'XL':3, 'XXL':4, 'XXXL':5}\\nneigh = [[] for i in range(5)]\\n\\nof = list(map(int, input().split()))\\nn = int(input())\\nans = ['' for i in range(n)]\\nfor i in range(n):\\n t = input()\\n if ',' in t:\\n neigh[d[t.split(',')[0]]].append(i)\\n else:\\n of[d[t]] -= 1\\n ans[i] = t\\n\\nfor i in range(6):\\n if", "gt": "of[i] < 0:\\n print(\"NO\")\\n return\\n if i > 0:\\n while len(neigh[i - 1]) and of[i] > 0:\\n ans[neigh[i - 1][-1]] = szs[i]\\n neigh[i - 1].pop()\\n of[i] -= 1\\n if i < 5:\\n while len(neigh[i]) and of[i] > 0:\\n ans[neigh[i][-1]] = szs[i]\\n neigh[i].pop()\\n of[i] -= 1\\n\\n\\nif sum([len(neigh[i]) for i in range(5)]) != 0:\\n print(\"NO\")\\nelse:\\n print(\"YES\")\\n print(\"\\n\".join(ans))\\n"}
{"id": "1162", "input": "seq = input()\\na = []\\nfl = True\\nz = 0\\nfor i in seq:\\n if i == '<' or i == '[' or i == '{' or i == '(':\\n a.append(i)\\n elif i == '>':\\n if len(a) and a[-1] == '<': a.pop()\\n elif len(a) and a[-1] != '<':\\n a.pop()\\n z += 1\\n else:\\n fl = False\\n break\\n elif i == ')':\\n if len(a) and a[-1] == '(': a.pop()\\n elif len(a) and a[-1]!= '(':\\n a.pop()\\n z += 1\\n else:\\n fl = False\\n break\\n elif i == ']':\\n if len(a) and a[-1] == '[': a.pop()\\n elif len(a) and a[-1] != '[':\\n a.pop()\\n z += 1\\n else:\\n fl = False\\n break\\n elif i == '}':\\n if len(a) and", "gt": "a[-1] == '"}
{"id": "1163", "input": "base=998244353;\\ndef power(x, y):\\n if(y==0):\\n return 1\\n t=power(x, y//2)\\n t=(t*t)%base\\n if(y%2):\\n t=(t*x)%base\\n return t;\\ndef inverse(x):\\n return power(x, base-2)\\nf=[1]\\niv=[1]\\nfor i in range(1, 5555):\\n f.append((f[i-1]*i)%base)\\n iv.append(inverse(f[i]))\\ndef C(n, k):\\n return (f[n]*iv[k]*iv[n-k])%base\\ndef candy(n, k):\\n # print(n, k)\\n return C(n+k-1, k-1)\\ndef count_game(k, n, x): #k players, n points total, no player can have x point or more\\n if(k==0):\\n if(n==0):\\n return 1\\n else:\\n return 0\\n ans=0\\nfor i in range(0, k+1):\\n t=n-x*i\\n # print(i, C(k, i))\\n if(t<0):\\n break\\n if(i%2):\\n ans=(ans-C(k, i)*candy(t, k))%base\\n else:\\n ans=(ans+C(k, i)*candy(t, k))%base \\n return ans\\np, s, r= list(map(int, input().split()))\\ngamesize=count_game(p, s-r, int(1e18))\\ngamesize=inverse(gamesize)\\nans=0;\\nfor q in range(r, s+1):\\n for i in range(0, p): #exactly i people", "gt": "have the same score\\n t=s-(i+1)*q\\n if(t<0):\\n break\\n # print(q, i, count_game(p-i-1, t, q));"}
{"id": "1164", "input": "from itertools import *\\n\\ninStr=next(open('input.txt'))\\nn=int(inStr.split()[0])\\nm=int(inStr.split()[1])\\n\\n\\nboys=repeat('B', n)\\ngirls=repeat('G', m)\\n\\nif n>m:\\n pairs = zip_longest(boys, girls)\\nelse:\\n pairs = zip_longest(girls, boys)\\nresult =", "gt": "(y for x in pairs for y in x if y is not None)\\nans = ''.join(result)\\nopen('output.txt', 'w').write(ans)\\nprint(ans)"}
{"id": "1165", "input": "3\\n\\ns = input()\\nalph = ''.join([chr(ord('a') + x) for x in range(26)])\\nl = [[]]\\nfor x in s:\\n if x not in alph:\\n l[-1].append(x)\\n else:\\n if len(l[-1]):\\n l.append([])\\nl = list([''.join(x) for x in l])\\nansa = 0\\nansb = 0\\nfor t in l:\\n if len(t) > 2 and", "gt": "t[-3] == '.':\\n ansb += int(t[-2:])\\n t = t[:-3]\\n ansa += int(''.join(t.split('.')))\\nansa += ansb // 100\\nansb %= 100\\nansa = str(ansa)\\nans = []\\nlast = len(ansa)\\nfor x in range(len(ansa) - 3, -1, -3):\\n ans.append(ansa[x:last])\\n last = x\\nif last != 0:\\n ans.append(ansa[:last])\\nans.reverse()\\nif ansb != 0:\\n ans.append(\"%02d\" % ansb)\\nprint(\".\".join(ans))\\n"}
{"id": "1166", "input": "import collections\\nimport math\\n\\nn ,m = map(int, input().split())\\nA = list(map(int, input().split()))\\nans, f = [], [0] * n\\nf[0] = -1\\nfor i in range(1, n):\\n if A[i] != A[i - 1]:\\n f[i] = i - 1\\n else:\\n f[i] = f[i - 1]\\nfor i in range(m):\\n", "gt": "l, r, x = map(int, input().split())\\n #q.append([l - 1, r - 1, x])\\n #for i in range(m):\\n if A[r - 1] != x:\\n ans.append(r)\\n elif f[r - 1] >= l - 1:\\n ans.append(f[r - 1] + 1)\\n else:\\n ans.append(-1)\\nprint('\\n'.join(str(x) for x in ans))"}
{"id": "1167", "input": "import sys\\n\\n\\ndef __starting_point():\\n cin = sys.stdin\\n\\n n = int(next(cin))\\n a = list(map(int, next(cin).split()))\\n\\n n2idx = {a[i]: i for i in range(n)}\\n\\n f = [False] * (n+1)\\n\\n for i in range(n, 0, -1):\\n idx_lg = n2idx[i]\\n\\n win_flag", "gt": "= False\\n for j in range(idx_lg%i, n, i):\\n if a[j] > i and not f[a[j]]:\\n win_flag = True\\n break\\n f[i] = win_flag\\n \\n f = ''.join(['A' if f[a_i] else 'B' for a_i in a])\\n print(f, flush=True)\\n\\n__starting_point()"}
{"id": "1168", "input": "from math import *\\n\\n\\ndef ri():\\n return int(input())\\n\\n\\ndef rli():\\n return list(map(int, input().split()))\\n\\n\\nq = ri()\\nfor _ in range(q):\\n a, b, c, d, k", "gt": "= rli()\\n x = int(ceil(a / c))\\n y = int(ceil(b / d))\\n if x + y <= k:\\n print(x, y)\\n else:\\n print(-1)\\n"}
{"id": "1169", "input": "n = int(input())\\na = [int(i) for i in input().split()]\\nl = [i for i in range(len(a))]\\nr = [i for i in range(len(a))]\\nfor i in range(len(a)):\\n while l[i]>=1 and a[i]|a[l[i]-1]<=a[i]:\\n", "gt": "l[i] = l[l[i]-1]\\n \\nfor j in range(len(a)):\\n i = len(a)-j-1\\n while r[i]<len(a)-1 and a[i]|a[r[i]+1]<=a[i] and a[i]>a[r[i]+1]:\\n r[i] = r[r[i]+1]\\n\\ncount=0\\nfor i in range(len(a)):\\n x = r[i]-i+1\\n y = i-l[i]+1\\n count+=x*y-1\\nprint((n*(n-1))//2-count)"}
{"id": "1170", "input": "n, m = map(int, input().split())\\nif m == 0:\\n print(n, n)\\n return\\nif m == n * (n - 1) // 2:\\n print(0, 0)\\n return\\nL = 0\\nR = n + 1\\nwhile R - L > 1:\\n m1", "gt": "= (L + R) // 2\\n if m1 * (m1 - 1) // 2 < m:\\n L = m1\\n else:\\n R = m1\\nans_max = n - R\\nans_min = max(0, n - 2 * m)\\nprint(ans_min, ans_max)"}
{"id": "1171", "input": "t = int(input())\\nfor k in range(t):\\n x = int(input())\\n if x == 0:\\n print(1, 1)\\n continue\\n for i in range(1, int(x ** 0.5) + 2):\\n if x % i == 0 and (x // i - i) % 2 == 0 and (x // i - (x // i", "gt": "- i) // 2) ** 2 >= x:\\n a, b = x // i, i\\n y = (a - b) // 2\\n n = a - y\\n if y == 0:\\n continue\\n m = n // y\\n if n // m != y:\\n continue\\n print(n, m) \\n break\\n else:\\n print(-1)"}
{"id": "1172", "input": "n, k = map(int, input().split())\\nv = list(map(int, input().split()))\\nreverse_v = v[::-1]\\nlst = [0] * (k + 1)\\nleft = [[]]\\nright = [[]]\\nfor i in range(1, n+1):\\n left.append(v[:i])\\n right.append(reverse_v[:i])\\n\\nfor cnt in range(1, k+1):\\n rest = k - cnt\\n total = 0\\n if cnt <= n:\\n for j in range(cnt+1):\\n lst_j", "gt": "= left[j] + right[cnt-j]\\n lst_j.sort()\\n l = cnt\\n for idx in range(cnt):\\n if lst_j[idx] >= 0:\\n l = idx\\n break\\n if l == cnt:\\n value = 0\\n else:\\n flg = min(l, rest)\\n value = sum(lst_j[flg:])\\n if value > total:\\n total = value\\n lst[cnt] = total\\n\\nans = max(lst)\\nprint(ans)"}
{"id": "1173", "input": "def main():\\n mod = 10**9 + 7\\n s = input()\\n n = len(s)\\n\\n a_num = 0\\n c_num = s.count('C')\\n q_num = 0\\n q_cnt = s.count('?')\\n\\n pow3, pow2, pow1, pow0 = 0, 0, 0, 0\\n if q_cnt >= 3:\\n pow3 = pow(3, q_cnt-3, mod)\\n pow2 = pow3 * 3 % mod\\n pow1 = pow2 * 3 % mod\\n pow0 = pow1 * 3 % mod\\n elif q_cnt == 2:\\n pow2 = 1\\n pow1 = 3\\n pow0 = 9\\n elif q_cnt == 1:\\n pow1 = 1\\n pow0 = 3\\n else:\\n pow0 = 1\\n\\n ans = 0\\n", "gt": "for x in s:\\n if x == 'A':\\n a_num += 1\\n elif x == 'B':\\n ans += pow0 * a_num * c_num\\n ans += pow1 * (q_num * c_num + a_num * (q_cnt - q_num))\\n ans += pow2 * (q_num) * (q_cnt - q_num)\\n ans %= mod\\n elif x == 'C':\\n c_num -= 1\\n else:\\n ans += pow1 * a_num * c_num\\n ans += pow2 * (q_num * c_num + a_num * (q_cnt - q_num - 1))\\n ans += pow3 * (q_num) * (q_cnt - q_num - 1)\\n ans %= mod\\n q_num += 1\\n\\n print(ans)\\n\\nmain()"}
{"id": "1174", "input": "import sys\\ninput = sys.stdin.readline\\nimport time\\n\\nfrom collections import deque\\n\\ndef main():\\n t1 = time.time()\\n\\n n = int(input())\\n \\n a = [[int(i) for i in input().split()] for j in range(n)]\\n \\n check = [0]*n\\n used = [False]*n\\n \\n d = deque()\\n \\n for i in reversed(range(n)):\\n if used[i] == True:\\n continue\\n if a[a[i][0]-1][0] == i+1:\\n d.appendleft([i+1,a[i][0]])\\n used[i] = True\\n used[a[i][0]-1] = True\\n check[i] = 1\\n check[a[i][0]-1] = 1\\n \\n ans = 0\\n \\n if len(d) == 0:\\n print(-1)\\n return\\n \\n #print(d)\\n \\n while len(d) > 0:\\n if time.time() - t1 >=", "gt": "1.95:\\n print(n*(n-1)//2)\\n return\\n used = [False]*n\\n ans += 1\\n num = len(d)\\n for i in range(num):\\n tmp = d.popleft()\\n for j in range(2):\\n if check[tmp[j]-1] == n-1:\\n continue\\n psn = a[tmp[j]-1][check[tmp[j]-1]]-1\\n mys = tmp[j]-1\\n \\n if check[mys] == n-1 or check[psn] == n-1:\\n continue\\n #print(tmp,psn,a[psn][check[psn]])\\n #print(i,j,tmp,psn,check[mys],check[psn])\\n if used[mys] == True or used[psn] == True:\\n continue\\n \\n if a[psn][check[psn]] == mys+1:\\n d.append([psn+1,mys+1])\\n used[mys] = True\\n used[psn] = True\\n check[mys] += 1\\n check[psn] += 1\\n #print(d)\\n \\n for i in range(n):\\n if check[i] != n-1:\\n print(-1)\\n return\\n \\n print(ans)\\n\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "1175", "input": "# import itertools\\n# import math\\n# import sys\\n# sys.setrecursionlimit(500*500)\\n# import numpy as np\\nfrom collections import deque\\n\\n# N = int(input())\\n# S = input()\\n# n, *a = map(int, open(0))\\nN, M = map(int, input().split())\\nA = list(map(int, input().split()))\\n# B = list(map(int, input().split()))\\n# tree = [[] for _ in range(N + 1)]\\n# B_C = [list(map(int,input().split())) for _ in range(M)]\\n# S = input()\\n\\nA = sorted(A, reverse=True)\\n# all_cases = list(itertools.permutations(P))\\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\\n# itertools.product((0,1), repeat=n)\\n\\n# A = np.array(A)\\n# cum_A = np.cumsum(A)\\n# cum_A = np.insert(cum_A, 0, 0)\\n\\n# def", "gt": "dfs(tree, s):\\n# for l in tree[s]:\\n# if depth[l[0]] == -1:\\n# depth[l[0]] = depth[s] + l[1]\\n# dfs(tree, l[0])\\n# dfs(tree, 1)\\n\\n# def factorization(n):\\n# arr = []\\n# temp = n\\n# for i in range(2, int(-(-n**0.5//1))+1):\\n# if temp%i==0:\\n# cnt=0\\n# while temp%i==0:\\n# cnt+=1\\n# temp //= i\\n# arr.append([i, cnt])\\n# if temp!=1:\\n# arr.append([temp, 1])\\n# if arr==[]:\\n# arr.append([n, 1])\\n# return arr\\n\\n\\nqueue_A = deque(A)\\nqueue_B = deque()\\n\\nfor i in range(M):\\n if len(queue_B) > 0 and queue_B[0] >= queue_A[0]:\\n queue_A.appendleft(queue_B.popleft())\\n queue_A[0] //= 2\\n if len(queue_A) > 1 and queue_A[0] < queue_A[1]:\\n queue_B.append(queue_A.popleft())\\n\\nprint(sum(queue_A) + sum(queue_B))"}
{"id": "1176", "input": "MOD = 10**9 + 7\\nl, r = map(int, input().split())\\n\\ndef func(x, y):\\n if y == 0:\\n return 1\\n dp = [[0 for _ in range(6)] for _ in range(61)]\\n dp[60][0] = 1\\n for i in range(59, -1, -1):\\n if (y>>i) & 1 == 0 and (x>>i) & 1 == 0:\\n dp[i][0] = dp[i+1][0]\\n dp[i][1] = dp[i+1][1]\\n dp[i][2] = dp[i+1][2]\\n dp[i][3] = (dp[i+1][3]*2) % MOD\\n dp[i][4] = dp[i+1][4]\\n dp[i][5] = (dp[i+1][1] + dp[i+1][3] + dp[i+1][5]*3) % MOD\\n elif (y>>i) & 1 == 1 and (x>>i) & 1 == 1:\\n dp[i][0] = 0\\n dp[i][1] = 0\\n dp[i][2] = (dp[i+1][0] + dp[i+1][2]) % MOD\\n dp[i][3] = (dp[i+1][1] + dp[i+1][3])", "gt": "% MOD\\n dp[i][4] = (dp[i+1][4]*2) % MOD\\n dp[i][5] = (dp[i+1][4] + dp[i+1][5]*3) % MOD\\n elif (y>>i) & 1 == 1 and (x>>i) & 1 == 0:\\n dp[i][0] = 0\\n dp[i][1] = (dp[i+1][0] + dp[i+1][1]) % MOD\\n dp[i][2] = dp[i+1][2]\\n dp[i][3] = (dp[i+1][2] + dp[i+1][3]*2) % MOD\\n dp[i][4] = (dp[i+1][0] + dp[i+1][2] + dp[i+1][4]*2) % MOD\\n dp[i][5] = (dp[i+1][1] + dp[i+1][3] + dp[i+1][4] + dp[i+1][5]*3) % MOD\\n elif (y>>i) & 1 == 0 and (x>>i) & 1 == 1:\\n dp[i][0] = 0\\n dp[i][1] = 0\\n dp[i][2] = 0\\n dp[i][3] = (dp[i+1][1] + dp[i+1][3]) % MOD\\n dp[i][4] = dp[i+1][4]\\n dp[i][5] = (dp[i+1][5]*3) % MOD\\n\\n return (sum(dp[0]))%MOD\\n\\nprint(func(l, r))"}
{"id": "1177", "input": "n=int(input())\\na=list(map(int,input().split()))\\ncount=0\\nans=[]\\nfor i in range(n):\\n ans.append(abs(a[i]))\\n", "gt": "if a[i]<0:\\n count+=1\\n\\nif count%2==0:\\n print((sum(ans)))\\nelse:\\n print((sum(ans)-2*min(ans)))\\n"}
{"id": "1178", "input": "import numpy as np\\nfrom sys import stdin\\n\\n'''\\nReference: https://codeforces.com/blog/entry/75046#comment-591494 (1-based index)\\n\\n(0-based index)\\n\\nFor a sequence A[l]..A[k]..A[r] with sum S contributes l * (N - r) to answer.\\n 0, 1, 2, ..., l....k....r, ..., N - 2, N - 1\\n x x x x x v v v v\\nThere are l `x` and (N - r) `v`.\\n\\nEnumerate all possible sequence is impossible. \\nConsider all sequeuces with sum S and **ends** at specific r:\\n A[l1]...A[r] -> l1 * (N - r)\\n A[l2]...A[r] -> l2 * (N - r)\\n A[l3]...A[r] -> l3 * (N - r)\\n .\\n .\\n .\\nwhich contributes (l1 + l2 + ... + lm) * (N - r) in total.\\n\\nWe can find *sum of left index for all valid sequence* for each r using DP.\\n\\n dp[i][s] = the sum of left index for all sequence that\\n 1. ends at i\\n 2. has sum s\\n \\n dp[i][:A[i]] = 0 since any sequence ends at i has sum >= A[i]\\n\\n dp[i][A[i]] = i + 1\\n dp[i][s] = sum(dp[j][s - A[i]] for j in range(i))\\n\\n Take A = [2, 3, 4] for example, sequences that end at A[2] are:\\n \\n [4] -> dp[2][4] = 3\\n", "gt": "[2, 4] ↘\\n [3, 4] -> dp[2][s] = dp[2][s - 4] for all s\\n [2, 3, 4] ↗\\n \\n The answer is sum(dp[r][S] * (N - r) for r in range(N))\\n\\nSo the naive implementation is:\\n\\n dp = np.zeros((N, max(S, A.max()) + 1), dtype=np.int64)\\n for i, a in enumerate(A):\\n dp[i, a] = i + 1\\n for s in range(a + 1, S + 1):\\n dp[i, s] = dp[:i, s - a].sum() % M # here can be optimized\\n \\n ans = 0\\n for i in range(N):\\n ans += (N - i) * dp[i, S]\\n ans = ans % M\\n\\nhas time O(N * S * N) which results in TLE.\\n\\nUsing another array to store the cumsum (prefix sum) of dp solves the problem:\\n'''\\n\\nN, S = list(map(int, input().split()))\\nA = np.int32(input().split())\\nM = 998244353\\nV = max(A.max(), S)\\n\\nans = 0\\ndp = np.zeros((N, V + 1), dtype=np.int64)\\ncs = np.zeros(V + 1, dtype=np.int64)\\nfor i, a in enumerate(A):\\n dp[i, a] = i + 1\\n dp[i, a + 1 : S + 1] = cs[np.arange(a + 1, S + 1) - a]\\n cs = (cs + dp[i]) % M\\n ans = (ans + (N - i) * dp[i, S]) % M\\nprint(ans)\\n"}
{"id": "1179", "input": "import numpy as np\\nINF = 10**15\\ndef solve(n, k, h):\\n dp = np.full((n+1, n+1), INF, dtype=int)\\n dp[0, 0] = 0\\n h = np.array([0] + h, dtype=int)\\n for", "gt": "i, h_i in enumerate(h[1:], 1):\\n t = np.maximum(h_i - h[:i], 0)\\n dp[i,1:] = np.min(dp[:i,:-1]+t[:,None], axis=0)\\n return np.min(dp[:, n-k])\\n\\nn, k = map(int, input().split())\\nh = list(map(int, input().split()))\\nprint(solve(n, k, h))"}
{"id": "1180", "input": "n,k = list(map(int, input().split()))\\nL = list(map(int, input().split()))\\ni = 1\\nwhile k > 0:\\n k", "gt": "= k - i\\n i += 1\\nk = k + i - 1\\nprint(L[k-1])\\n"}
{"id": "1181", "input": "n, k = map(int, input().split())\\nt = list(map(int, input()))\\np, d = 1, 10 ** 9 + 7\\ns, f = 0, [1] * n\\nfor i in range(2, n): f[i] = (i * f[i - 1]) % d\\nc = lambda a, b: 0 if a > b else (f[b] * pow(f[a] * f[b - a], d - 2, d)) % d\\nif k:\\n u = [0] * (n + 1)\\n p = [1] * (n + 1)\\n", "gt": "for i in range(n):\\n u[i] = (p[i] * c(k - 1, n - 2 - i) + u[i - 1]) % d\\n p[i + 1] = (10 * p[i]) % d\\n for i in range(n): \\n v = u[n - 2 - i] + p[n - 1 - i] * c(k, i)\\n s = (s + t[i] * v) % d\\nelse:\\n for i in t: s = (s * 10 + i) % d\\nprint(s)"}
{"id": "1182", "input": "def median(a):\\n if len(a) == 0:\\n return 0\\n if len(a) % 2 == 1:\\n return a[len(a) // 2]\\n else:\\n return (a[len(a) // 2] + a[(len(a) // 2) - 1]) // 2\\n\\n\\ndef profit(a, old_val):\\n a.sort()\\n med = median(a)\\n sum_old = 0\\n sum_new = 0\\n for i in a:\\n sum_old += abs(i - old_val)\\n sum_new += abs(i - med)\\n return sum_old - sum_new\\n\\nn, m = [int(c) for", "gt": "c in input().split()]\\npages = [int(c) for c in input().split()]\\n\\ncount ="}
{"id": "1183", "input": "dhuang=0\\na,b,c,d=list(map(int,input().split(' ')))\\nhuang = [['*']*b for _ in range(a)]\\nfor i in range(c):\\n x,y=list(map(int,input().split(' ')))\\n huang[x-1][y-1] = '#'\\nfor i in range(a):\\n for j in range(b):\\n for k", "gt": "in range(i, a):\\n for l in range(j, b):\\n ct=0\\n for m in range(i, k+1):\\n for n in range(j, l+1):\\n if huang[m][n]=='#':\\n ct+=1\\n if ct>=d:\\n dhuang+=1\\nprint(dhuang)\\n"}
{"id": "1184", "input": "t = int(input())\\nfor _ in range(t):\\n n, x = [int(x) for x in input().split()]\\n a = set([int(x) for x in input().split()])\\n", "gt": "for i in range(1, 1000):\\n if i in a:\\n continue\\n if x == 0:\\n print(i - 1)\\n break\\n x -= 1\\n"}
{"id": "1185", "input": "s = input()\\n\\ns =", "gt": "s[1: -1].replace(',', '')\\n\\nresult = set(s.split())\\n\\nprint(len(result))\\n"}
{"id": "1186", "input": "from itertools import accumulate\\n\\n\\ndef main():\\n n, m, k = list(map(int, input().split()))\\n \\n a = list(map(int, input().split()))\\n km = k * m\\n \\n if m == 1:\\n a.sort(reverse=True)\\n print(sum(a[:k]))\\n return\\n\\n a = list(accumulate(a))\\n a.append(0)\\n\\n if n == km:\\n print(a[n-1])\\n return\\n\\n d = [[0] * (n+1) for _ in", "gt": "range(k+1)]\\n\\n for i in range(m - 1, n):\\n _k = (i + 1) // m if i < km else k\\n for j in range(1, _k + 1):\\n if i == j*m-1:\\n d[j][i] = a[i]\\n else:\\n d[j][i] = max(d[j][i-1], a[i] - a[i-m] + d[j-1][i-m])\\n\\n print(d[k][n-1])\\n\\n\\ndef __starting_point():\\n main()\\n\\n\\n__starting_point()"}
{"id": "1187", "input": "def test(x, i):\\n i = list(i)\\n ok = True\\n for j in range(x):\\n if (i[j] == j+1 or (i[j]&(j+1) != 0)):\\n ok = False\\n if ok:\\n print(i)\\n\\ndef comp(n):\\n return 2**len(bin(n)[2:])-1-n\\n\\nn = int(input())\\nnn = n\\nif (n%2 == 0):\\n x = []\\n while (n != 0):\\n #add n to comp(n) to the front of x\\n for i in range(comp(n), n+1):\\n x.append(i)\\n n = comp(n)-1\\n\\n x.reverse()\\n print(\"YES\")\\n print(' '.join([str(i) for i in x]))\\nelse:\\n print(\"NO\")\\n\\npow2 = [2**i for", "gt": "i in range(20)]\\ndef make(n):\\n if n <= 5: return []\\n if n == 6: return [3, 6, 1, 5, 4, 2]\\n if n == 7: return [3, 6, 1, 5, 4, 7, 2]\\n if n in pow2:\\n return []\\n shift = 2**(len(bin(n)[2:])-1)\\n array = [i for i in range(shift, n+1)]\\n array = array[1:] + [array[0]]\\n return make(shift-1) + array\\n\\nn = nn\\nk = make(n)\\nif k == []:\\n print(\"NO\")\\nelse:\\n print(\"YES\")\\n print(' '.join([str(i) for i in k]))\\n"}
{"id": "1188", "input": "import sys\\nimport math\\ndef getAndParseInt(num=1):\\n string = (sys.stdin.readline()).strip()\\n if num==1:\\n return int(string)\\n else:\\n return [int(part) for part in string.split()]\\n\\ndef getAndParseString(num=1,delim=\" \"):\\n string = (sys.stdin.readline()).strip()\\n if num==1:\\n return string\\n else:\\n return [part for part in string.split(delim)]\\n\\nn, m = getAndParseInt(2)\\nadj_list = [[] for i in range(n)]\\nedge_list = []\\nfor i in range(m):\\n u, v = getAndParseInt(2)\\n edge_list.append((u,v))\\n adj_list[u-1].append(v-1)\\n\\nvisited = set()\\nstack = []\\nfinished_exploring = [False for i in range(n)]\\nedge_colors = {}\\nacyclic = True\\n\\nfor i in range(n):\\n if i", "gt": "not in visited:\\n stack.append((i,0))\\n else:\\n continue\\n while stack:\\n cur_vertex, neigh_index = stack.pop()\\n if neigh_index == 0:\\n visited.add(cur_vertex)\\n\\n if neigh_index == len(adj_list[cur_vertex]):\\n finished_exploring[cur_vertex] = True\\n else:\\n stack.append((cur_vertex, neigh_index + 1))\\n neighbor = adj_list[cur_vertex][neigh_index]\\n if neighbor not in visited:\\n stack.append((neighbor, 0))\\n edge_colors[(cur_vertex+1,neighbor+1)]='1'\\n visited.add(neighbor)\\n elif neighbor in visited and not finished_exploring[neighbor]:\\n edge_colors[(cur_vertex+1,neighbor+1)]='2'\\n acyclic = False\\n else:\\n edge_colors[(cur_vertex+1,neighbor+1)]='1'\\n\\nif acyclic:\\n print(1)\\n output_list = [\"1\" for i in range(m)]\\nelse:\\n print(2)\\n output_list = []\\n for edge in edge_list:\\n output_list.append(edge_colors[edge])\\nprint(\" \".join(output_list))\\n\\n\\n\\n\\n"}
{"id": "1189", "input": "n = int(input())\\n\\na = sorted(list(map(int, input().split())))\\n\\n\\n\\nmaxe = max(a)\\n\\ncnt = []\\n\\ncur, k, i = 1, 0, 0\\n\\n\\n\\nwhile i < n:\\n\\n cnt.append(0)\\n\\n while i < n and a[i] < cur:\\n\\n cnt[2 * k] += 1\\n\\n i += 1\\n\\n cnt.append(0)\\n\\n while i < n and a[i] == cur:\\n\\n cnt[2 * k + 1] += 1\\n\\n i += 1\\n\\n k += 1\\n\\n cur *= 2\\n\\ncnt.append(0)\\n\\ncnt.append(0)\\n\\nmaxe = len(cnt)", "gt": "- 1\\n\\n\\n\\nmaxk = cnt[1]\\n\\nwas = False\\n\\nfor l in range(maxk):\\n\\n cur = 1\\n\\n while cnt[cur] > 0:\\n\\n cnt[cur] -= 1\\n\\n cur += 2\\n\\n cnt[cur] -= 1\\n\\n cursum = 0\\n\\n ok = True\\n\\n for t in range(maxe, 0, -1):\\n\\n cursum += cnt[t]\\n\\n if cursum > 0:\\n\\n ok = False\\n\\n break\\n\\n if ok:\\n\\n print(l + 1, end=\" \")\\n\\n was = True\\n\\n\\n\\nif not was:\\n\\n print(-1)\\n\\n\\n\\n# Made By Mostafa_Khaled"}
{"id": "1190", "input": "import math\\nimport operator as op\\n\\nfrom functools import reduce\\n\\nfrom operator import mul # or mul=lambda x,y:x*y\\nfrom fractions import Fraction\\n\\ndef nCk(n,k): \\n return int( reduce(mul, (Fraction(n-i, i+1) for i in range(k)), 1) )\\n\\n\\ndef ncr(n, r):\\n r = min(r, n-r)\\n if r == 0: return 1\\n numer = reduce(op.mul, list(range(n, n-r, -1)))\\n denom = reduce(op.mul, list(range(1, r+1)))\\n return numer//denom\\n\\ndef modPow(a, x, p):\\n #calculates a^x mod p in logarithmic time.\\n res = 1\\n while(x > 0):\\n if( x % 2 != 0):\\n res = (res * a) % p\\n \\n a = (a * a) % p\\n x = int(x/2)\\n return res\\n\\ndef modInverse(a, p):\\n #calculates the modular multiplicative of a", "gt": "mod m.\\n #(assuming p is prime).\\n return modPow(a, p-2, p)\\n\\ndef modBinomial(n, k, p):\\n #calculates C(n,k) mod p (assuming p is prime).\\n\\n # n * (n-1) * ... * (n-k+1)\\n numerator = 1 \\n for i in range(k):\\n numerator = (numerator * (n-i) ) % p\\n\\n denominator = 1\\n for i in range(1, k+1):\\n denominator = (denominator * i) % p\\n\\n # numerator / denominator mod p.\\n return ( numerator* modInverse(denominator,p) ) % p\\n\\n\\nn, c = input().split()\\nn = int(n)\\nc = int(c)\\n\\n#test = [0 for x in range (n+1)]\\n#test[1] = c\\n\\n#for i in range(2, n+1):\\n# test[i] = (test[i-1] + modBinomial((i+c-1),i, 1000003))%1000003\\n\\n#ans = solve(n, c)\\n#ans =test[n]\\nans = modBinomial((c+n),c,1000003) - 1\\nprint(int(ans))\\n"}
{"id": "1191", "input": "w1, h1, w2, h2 = list(map(int, input().split()))\\nprint(2 * (h1 +", "gt": "h2) + w1 + w2 + abs(w1 - w2) + 4)\\n"}
{"id": "1192", "input": "n,m = map(int, input().split())\\n\\nclass Knight:\\n def __init__(self, andis, p, c):\\n self.p = int(p)\\n self.c = int(c)\\n self.andis = int(andis)\\n self.ans = self.c\\n\\np = list(map(int, input().split()))\\nc = list(map(int, input().split()))\\nx = []\\nfor i in range(n):\\n x.append(Knight(i, p[i], c[i]))\\n\\nx.sort(key=lambda", "gt": "x: x.p)\\ncoins = []\\nfor i in range(n-1):\\n if len(coins) < m:\\n coins.append(x[i].c)\\n coins.sort()\\n elif len(coins) > 0:\\n if coins[0] < x[i].c:\\n coins[0] = x[i].c\\n coins.sort()\\n x[i+1].ans += sum(coins)\\n\\nx.sort(key=lambda x:x.andis)\\nfor k in x:\\n print(k.ans, end=' ')\\n \\n\\n\\n\\n"}
{"id": "1193", "input": "from sys import stdin, stdout\\nfrom math import *\\nfrom itertools import *\\nfrom copy import *\\n\\ns = 0\\ninvs = 0\\n\\ndef calc_invertions(a):\\n s = 0\\n for i in range(len(a)):\\n for j in range(i + 1, len(a)):\\n s += 1 if a[i] > a[j] else 0\\n return s\\n\\ndef do_flips(arr, num):\\n nonlocal s, invs\\n if num == 0:\\n invs += 1\\n s += calc_invertions(arr)\\n else:\\n for i in range(len(arr)):\\n for j in range(i, len(arr)):\\n", "gt": "for k in range((j - i + 1) // 2):\\n arr[i + k], arr[j - k] = arr[j - k], arr[i + k]\\n do_flips(arr, num - 1)\\n for k in range((j - i + 1) // 2):\\n arr[i + k], arr[j - k] = arr[j - k], arr[i + k]\\n \\ndef solve(test):\\n ints = list(map(int, test.strip().split()))\\n n, m = ints[:2]\\n arr = ints[2:]\\n do_flips(arr, m)\\n return s / invs\\n\\nstdout.write(str(solve(stdin.read())))\\n"}
{"id": "1194", "input": "n, k = map(int, input().split())\\ns =", "gt": "sorted(list(map(int, input().split())), reverse = True)\\nprint(s[k - 1])"}
{"id": "1195", "input": "import sys\\n\\nclass SegmTree():\\n def __init__(self, array=None):\\n size = len(array)\\n N = 1\\n while N < size:\\n N <<= 1\\n self.N = N\\n self.tree = [0] * (2*self.N)\\n for i in range(size):\\n self.tree[i+self.N] = array[i]\\n self.build()\\n\\n def build(self):\\n for i in range(self.N - 1, 0, -1):\\n self.tree[i] = self.tree[i<<1] + self.tree[i<<1|1]\\n \\n def add(self, i, value=1):\\n i += self.N\\n while i > 0:\\n self.tree[i] += value\\n i >>= 1\\n \\n def get_sum(self, l, r):\\n N = self.N\\n l += N\\n r += N\\n result = 0\\n while l < r:\\n if l & 1:\\n result += self.tree[l]\\n l += 1\\n if r & 1:\\n r -= 1\\n result += self.tree[r]\\n l >>= 1\\n r >>= 1\\n return result\\n \\n def find_kth_nonzero(self, k):\\n i = 1\\n if k <", "gt": "1 or k > self.tree[1]:\\n return -1\\n while i < self.N:\\n i <<= 1\\n if self.tree[i] < k:\\n k -= self.tree[i]\\n i |= 1\\n return i - self.N\\n\\nreader = (line.rstrip() for line in sys.stdin)\\ninput = reader.__next__\\n\\nn = int(input())\\np = list(map(int, input().split()))\\nq = list(map(int, input().split()))\\n\\nord_p = [0] * n\\nord_q = [0] * n\\n\\nst = SegmTree([1] * n)\\nfor i, val in enumerate(p):\\n ord_p[i] = st.get_sum(0, val)\\n st.add(val, -1)\\n\\nst = SegmTree([1] * n)\\nfor i, val in enumerate(q):\\n ord_q[i] = st.get_sum(0, val)\\n st.add(val, -1)\\n\\ntransfer = 0\\nfor i in range(n-1, -1, -1):\\n radix = n-i\\n ord_p[i] = ord_p[i] + ord_q[i] + transfer\\n if ord_p[i] < radix:\\n transfer = 0\\n else:\\n transfer = 1\\n ord_p[i] -= radix\\n\\nst = SegmTree([1] * n)\\nfor i in range(n):\\n k = ord_p[i] + 1\\n ord_q[i] = st.find_kth_nonzero(k)\\n st.add(ord_q[i], -1)\\n\\nprint(*ord_q)\\n"}
{"id": "1196", "input": "n = int(input())\\nl = list(map(int, input().split()))\\nf1 =", "gt": "l[2]\\nl.sort()\\nf2 = l[0]\\nprint(2 + (f1 ^ f2))\\n"}
{"id": "1197", "input": "def ziped(a):\\n p = []\\n for i in a:\\n x = int(i.split('-')[0])\\n y = i.split('-')[1]\\n if len(p) > 0 and p[-1][1] == y:\\n p[-1][0] += x\\n else:\\n p.append([x, y])\\n return p\\n\\ndef solve(a, b , c):\\n ans = 0\\n if len(b) == 1:\\n for token in a:\\n if c(token, b[0]):\\n ans += token[0] - b[0][0] + 1\\n return ans\\n \\n if len(b) == 2:\\n for i in range(len(a) - 1):\\n if c(a[i], b[0]) and c(a[i + 1], b[-1]):\\n ans += 1\\n return ans\\n \\n v = b[1 : -1] +", "gt": "[[100500, '#']] + a\\n p = [0] * len(v)\\n for i in range(1, len(v)):\\n j = p[i - 1]\\n while j > 0 and v[i] != v[j]:\\n j = p[j - 1]\\n if v[i] == v[j]:\\n j += 1\\n p[i] = j\\n \\n for i in range(len(v) - 1):\\n if p[i] == len(b) - 2 and c(v[i - p[i]], b[0]) and c(v[i + 1], b[-1]):\\n ans += 1\\n return ans\\n\\nn, m = list(map(int, input().split()))\\na = ziped(input().split())\\nb = ziped(input().split())\\nprint(solve(a, b, lambda x, y: x[1] == y[1] and x[0] >= y[0]))\\n"}
{"id": "1198", "input": "Mod=1000000007\\ns=input()\\nn=len(s)\\na,b,c,d=1,0,0,0\\nfor i in range(0,n):\\n if s[i]=='*':\\n a,b,c,d=0,(a+b+d)%Mod,0,0\\n elif s[i]=='?':\\n", "gt": "a,b,c,d=(a+b+c)%Mod,(a+b+d)%Mod,0,0\\n elif s[i]=='0':\\n a,b,c,d=0,0,(a+c)%Mod,0\\n elif s[i]=='1':\\n a,b,c,d=0,0,b,(a+c)%Mod\\n else:\\n a,b,c,d=0,0,0,(b+d)%Mod\\nprint((a+b+c)%Mod)\\n"}
{"id": "1199", "input": "str=input().split()\\nn=int(str[0])\\nlen=int(str[1])\\na=[]\\nQ=[]\\nF=[]\\nfor i in range(0,n+1):\\n a.append(0)\\n Q.append(0)\\n F.append(0)\\nsum=0\\nh=1\\nt=0\\nstr=input().split()\\nfor i in range(1,n+1):\\n a[i]=int(str[i-1])\\n sum+=a[i]\\n #print (sum)\\n while h<=t and", "gt": "Q[h]<=i-len:\\n h=h+1\\n while h<=t and a[i]<=a[Q[t]]:\\n t=t-1\\n t=t+1;"}
{"id": "1200", "input": "3\\n\\ndef readln(): return tuple(map(int, input().split()))\\n\\nn, m = readln()\\ncnt = [0] * (m + 1)\\nfor c in readln():\\n cnt[c] += 1\\nans = [0] * n\\nj = 0\\nfor _ in range(1, m + 1):\\n v = max(cnt)\\n i = cnt.index(v)\\n", "gt": "while cnt[i]:\\n ans[j] = i\\n cnt[i] -= 1\\n j += 2\\n if j >= n:\\n j = 1\\nprint(len([1 for i in range(n) if ans[i] != ans[(i + 1) % n]]))\\nfor i in range(n):\\n print(ans[i], ans[(i + 1) % n])\\n"}
{"id": "1201", "input": "def gcd(a, b):\\n if(a==0):\\n return b\\n return gcd(b%a,", "gt": "a) \\n\\nn=int(input())\\nv=list(map(int,input().split()))\\nv.sort()\\nans=v[1]-v[0]\\nfor i in range(2, n):\\n ans=gcd(ans, v[i]-v[i-1])\\nprint((v[len(v)-1]-v[0])//ans+1-n)"}
{"id": "1202", "input": "\\nn = int(input())\\n\\nitems = []\\nmax_time = 0\\n\\nfor i in range(1,n+1):\\n t,d,p = list(map(int,input().split()))\\n max_time = max(max_time, d)\\n items.append((t,d,p,i))\\n\\nitems.sort(key=lambda x: x[1])\\n\\ndp = [[(0,[]) for _ in range(n+1)] for _ in range(max_time+1)]\\n\\nfor time in range(1, max_time+1):\\n for it in range(1, n+1):\\n \\n", "gt": "if time < items[it-1][0] or time >= items[it-1][1]:\\n dp[time][it] = max(dp[time][it-1], dp[time-1][it])\\n else:\\n \\n pick = dp[time-items[it-1][0]][it-1][0] + items[it-1][2]\\n if dp[time][it-1][0] > pick : \\n dp[time][it] = max(dp[time][it-1], dp[time-1][it])\\n else:\\n \\n dp[time][it] = (dp[time-items[it-1][0]][it-1][0] + items[it-1][2], list(dp[time-items[it-1][0]][it-1][1]))\\n dp[time][it][1].append(items[it-1][3])\\n\\n#print(dp)\\n\\nres = max(dp[max_time])\\n\\nprint(res[0])\\nprint(len(res[1]))\\nprint(*res[1]) \\n"}
{"id": "1203", "input": "n = int(input())\\na = list(tuple(map(int,input().split())) for i in range(n))\\n#a.append(tuple(map(int,input().split())))\\nm = n // 2\\nc = list('1' for i in range(m))\\nd = list('1' for", "gt": "i in range(m))\\n#for i in range(n):print(a[i][0],a[i][1])\\nfor i in range(m,n):\\n if a[i][0] < a[n-i-1][1]:\\n c.append('1')\\n else:\\n c.append('0')\\n if a[n-i-1][0] > a[i][1]:\\n d.append('1')\\n else:\\n d.append('0')\\nprint(''.join(c))\\nprint(''.join(d))"}
{"id": "1204", "input": "<s> ", "gt": "h,l=map(int,input().split())\\nprint((l**2-h**2)/2/h)"}
{"id": "1205", "input": "m = 301000\\nns = [0] * m\\nes = [0] * m\\nc = [0] * m\\nb = [0] * m\\nt = [0] * m\\nP = 0\\n\\ndef add(b, k):\\n k = t[k]\\n while k:\\n e = es[k]\\n if b[-1] > e: b[-1] = e\\n b[e] += 1\\n k = ns[k]\\n\\ndef delete(b):\\n for i in range(b[m - 1], m + 1):\\n if b[i]:\\n b[i] -= 1\\n b[-1] = i\\n return i\\n\\ndef calc(k):\\n nonlocal b\\n q = 0\\n b = [0] * m\\n b[-1] = m\\n take = rank - dn\\n if take < 0: take = 0\\n add(b, k)\\n add(b, k - 1)\\n for i in range(1, take + 1): q += delete(b)\\n for i in range(k - 1): add(b, i)\\n for i in range(k + 1, P + 1): add(b, i)\\n for i in range(1, k", "gt": "- take + 1): q += delete(b)\\n return q\\n\\nn, k = list(map(int, input().split()))\\nrank = n - k + 1\\n\\nif rank == 0:\\n print('0')\\n return\\n\\nfor i in range(1, n + 1):\\n p, e = list(map(int, input().split()))\\n if p > P: P = p\\n c[p] += 1\\n es[i], ns[i] = e, t[p]\\n t[p] = i\\n\\ndn = 0\\nfor i in range(1, n + 1):\\n if i > 1: dn += c[i - 2]\\n if c[i] + c[i - 1] + dn >= rank and rank <= i + dn:\\n u = calc(i)\\n if i < n:\\n dn += c[i - 1]\\n v = calc(i + 1)\\n if u > v: u = v\\n if i < n - 1:\\n dn += c[i]\\n v = calc(i + 2)\\n if u > v: u = v\\n print(u)\\n return\\n \\nprint('-1')\\n"}
{"id": "1206", "input": "from fractions import Fraction\\nimport time\\nfrom collections import Counter\\n\\nclass Point:\\n def __init__(self, x, y):\\n self.x = x\\n self.y = y\\n\\n def to_tuple(self):\\n return (self.x, self.y)\\n\\n def __repr__(self):\\n return \"Point({}, {})\".format(self.x, self.y)\\n\\n def __eq__(self, other):\\n return self.to_tuple() == other.to_tuple()\\n\\n def __hash__(self):\\n return hash(self.to_tuple())\\n\\n def __neg__(self):\\n return Point(-self.x, -self.y)\\n\\n def __add__(self, other):\\n return Point(self.x+other.x, self.y+other.y)\\n\\n def __sub__(self, other):\\n return self+(-other)\\n\\n def scalar_mul(self, mu):\\n return Point(mu*self.x, mu*self.y)\\n\\n def int_divide(self, den):\\n return Point(self.x//den, self.y//den)\\n\\n def __lt__(self, other):\\n if self.x == other.x:\\n return self.y < other.y\\n return self.x < other.x\\n\\n def dot(self, other):\\n return self.x*other.x+self.y*other.y\\n\\n\\nclass Line:\\n def __init__(self, a, b, c):\\n # ax+by+c=0\\n self.a = a\\n self.b = b\\n self.c = c\\n\\n def __repr__(self):\\n return \"{}*x + {}*y + {} = 0\".format(self.a, self.b, self.c)\\n\\n @classmethod\\n def between_two_points(cls, P, Q):\\n return cls(P.y-Q.y, Q.x-P.x, P.x*Q.y-P.y*Q.x)\\n\\n def evaluate(self, P):\\n return self.a*P.x+self.b*P.y+self.c\\n\\n def direction(self):\\n if self.a == 0:\\n return (0, 1)\\n return (1, Fraction(self.b, self.a))\\n\\n\\ntrue_start = time.time()\\nn = int(input())\\npoints = set()\\ncenter = Point(0, 0)\\nfor i in range(n):\\n row = input().split(\" \")\\n cur =", "gt": "Point(int(row[0]), int(row[1])).scalar_mul(2*n)\\n center += cur\\n points.add(cur)\\n\\ncenter = center.int_divide(n)\\ndcenter = center+center\\n\\n# nosym = []\\n# for p in points:\\n# psym = dcenter-p\\n# if psym not in points:\\n# nosym.append(p)\\n\\nsym_points_set = set()\\nfor p in points:\\n sym_points_set.add(dcenter-p)\\nnosym = list(points - sym_points_set)\\n\\n#print(nosym)\\n# print(\"preproc:\", time.time()-true_start)\\n\\nif len(nosym) == 0:\\n print(-1)\\n return\\n\\n\\ncnt = 0\\np0 = nosym[0]\\ngood_lines = set()\\nfor p in nosym:\\n start = time.time()\\n m = (p+p0).int_divide(2)\\n supp = Line.between_two_points(m, center)\\n time_setup = time.time()-start\\n distances = list(map(supp.evaluate, nosym))\\n time_projs = time.time()-start\\n\\n # sorting strat\\n ok = True\\n SORTING = False\\n if SORTING:\\n distances = sorted(distances)\\n time_sorting = time.time()-start\\n m = len(distances)\\n for i in range(m//2):\\n if distances[i] != -distances[m-1-i]:\\n ok = False\\n break\\n else:\\n mydict ="}
{"id": "1207", "input": "def p2pl(p1,p2,p3,p4,p5):\\n prob0 = (1-p1)*(1-p2)*(1-p3)*(1-p4)*(1-p5)\\n prob1 = p1*(1-p2)*(1-p3)*(1-p4)*(1-p5) + \\\\n p2*(1-p1)*(1-p3)*(1-p4)*(1-p5) + \\\\n p3*(1-p1)*(1-p2)*(1-p4)*(1-p5) + \\\\n p4*(1-p1)*(1-p2)*(1-p3)*(1-p5) + \\\\n p5*(1-p1)*(1-p2)*(1-p3)*(1-p4)\\n return 1-(prob1+prob0)\\n\\nn = int(input())\\nc1 = input().split(' ')\\nc1 = [int(c1[0]),int(c1[1])]\\n\\nc2 = input().split(' ')\\nc2 = [int(c2[0]),int(c2[1])]\\n\\nif n >= 3:\\n c3 = input().split(' ')\\n c3 = [int(c3[0]),int(c3[1])]\\nelse:\\n c3 = [0,0]\\n\\nif n", "gt": ">= 4:\\n c4 = input().split(' ')\\n c4 = [int(c4[0]),int(c4[1])]\\nelse:\\n c4 = [0,0]\\n\\nif n >= 5:\\n c5 = input().split(' ')\\n c5 = [int(c5[0]),int(c5[1])]\\nelse:\\n c5 = [0,0]\\n\\nans = 0\\nfor x in range(1,10001):\\n p1 = min(1,max(c1[1]-x+1,0)/(c1[1]-c1[0]+1))\\n p2 = min(1,max(c2[1]-x+1,0)/(c2[1]-c2[0]+1))\\n p3 = min(1,max(c3[1]-x+1,0)/(c3[1]-c3[0]+1))\\n p4 = min(1,max(c4[1]-x+1,0)/(c4[1]-c4[0]+1))\\n p5 = min(1,max(c5[1]-x+1,0)/(c5[1]-c5[0]+1))\\n ans += p2pl(p1,p2,p3,p4,p5)\\nprint(ans)\\n"}
{"id": "1208", "input": "from collections import defaultdict\\n\\n\\nclass RobotRapping():\\n def __init__(self, n, m, battles):\\n self.n, self.m = n, m\\n self.battles = battles\\n\\n def generate_graph(self, k):\\n edge_map = defaultdict(list)\\n rev_map = defaultdict(list)\\n for i in range(k):\\n edge_map[self.battles[i][0]-1].append((self.battles[i][1]-1, i))\\n rev_map[self.battles[i][1]-1].append((self.battles[i][0]-1, i))\\n return edge_map, rev_map\\n\\n def check_order(self, num_battles):\\n edge_map, rev_map = self.generate_graph(num_battles)\\n outgoing_cnt = defaultdict(int)\\n for k in edge_map:\\n outgoing_cnt[k] = len(edge_map[k])\\n s = []\\n cntr = 0\\n for i in range(self.n):\\n if outgoing_cnt[i] == 0:\\n s.append(i)\\n while len(s) > cntr:\\n if len(s) > cntr+1 :\\n return False\\n else:\\n node = s[cntr]\\n for v in rev_map[node]:\\n outgoing_cnt[v] -= 1\\n if outgoing_cnt[v] == 0:\\n s.append(v)\\n cntr += 1\\n return True\\n\\n def min_battles(self):\\n if not self.check_order(self.m):\\n print(-1)\\n else:\\n mn, mx = 0, self.m\\n while mn <", "gt": "mx-1:\\n md = int((mn+mx)/2)\\n if self.check_order(md):\\n mx = md\\n else:\\n mn = md\\n print(mx)\\n\\n\\n def min_battles2(self):\\n edge_map, rev_map = self.generate_graph(self.m)\\n outgoing_cnt = defaultdict(int)\\n for k in edge_map:\\n outgoing_cnt[k] = len(edge_map[k])\\n s = []\\n cntr = 0\\n order = []\\n for i in range(self.n):\\n if outgoing_cnt[i] == 0:\\n s.append(i)\\n while len(s) > cntr:\\n if len(s) > cntr+1 :\\n print(-1)\\n return\\n else:\\n node = s[cntr]\\n order.append(node)\\n for v,_ in rev_map[node]:\\n outgoing_cnt[v] -= 1\\n if outgoing_cnt[v] == 0:\\n s.append(v)\\n cntr += 1\\n mn_pos = -1\\n for i in range(1,self.n):\\n for v,ind in edge_map[order[i]]:\\n if v == order[i-1]:\\n mn_pos = max(mn_pos, ind)\\n break\\n print(mn_pos+1)\\n\\nn,m = list(map(int,input().strip(' ').split(' ')))\\nbattles = []\\nfor i in range(m):\\n x,y = list(map(int,input().strip(' ').split(' ')))\\n battles.append((x,y))\\nrr = RobotRapping(n,m,battles)\\nrr.min_battles2()\\n"}
{"id": "1209", "input": "def main():\\n n = int(input())\\n \\n result = 0\\n d = set()\\n for i in range(n):\\n t, a = input().split()\\n a = int(a)\\n", "gt": "if t == \"+\":\\n d.add(a)\\n result = max(result, len(d))\\n else:\\n if a in d:\\n d.remove(a)\\n else:\\n result += 1\\n \\n print(result)\\n \\n \\nmain()\\n"}
{"id": "1210", "input": "from math import floor, ceil\\nn = int(input())\\narr = []\\nfor i in range(n):\\n arr.append(float(input()))\\nk = [floor(i) for i in", "gt": "arr]\\ndelta = -sum(k)\\nfor i in range(n):\\n if int(arr[i]) != arr[i] and delta:\\n delta -= 1\\n print(ceil(arr[i]))\\n else:\\n print(floor(arr[i]))"}
{"id": "1211", "input": "n,m=map(int,input().split())\\ndef f():\\n a,b=map(int,input().split())\\n return(b//m-(a-1)//m)/(b-a+1)\\na=[f() for _", "gt": "in range(n)]\\nr=0\\nfor i in range(n):\\n r+=1-(1-a[i])*(1-a[(i+1)%n])\\nprint(r*2000)"}
{"id": "1212", "input": "n, k = [int(i) for i in input().split(\" \")]\\nA = [int(i) for i in", "gt": "input().split(\" \")]\\n\\nmx=0\\nmxval=0\\nfor i in range(k):\\n if A[i]*(n//A[i])>mxval:\\n mxval = A[i]*(n//A[i])\\n mx = i\\nprint(mx+1, n//A[mx])\\n"}
{"id": "1213", "input": "n, k = map(int, input().split())\\nh = list(map(int, input().split()))\\na = [0]*(n-k+1)\\na[0]", "gt": "= sum(h[0:k])\\nfor i in range(1,n-k+1):\\n a[i] = a[i-1]+h[i+k-1]-h[i-1]\\nm = min(a)\\nprint(a.index(m)+1)"}
{"id": "1214", "input": "n, k = map(int, input().split())\\ns = input()\\n\\nleft = k - 1\\nright = n - k\\nif left < right:\\n print('LEFT\\n' * left, end = '')\\n for i in range(len(s) - 1):\\n", "gt": "c = s[i]\\n print('PRINT', c)\\n print('RIGHT')\\n print('PRINT', s[-1])\\nelse:\\n print('RIGHT\\n' * right, end = '')\\n for i in range(len(s) - 1):\\n c = s[-i - 1]\\n print('PRINT', c)\\n print('LEFT')\\n print('PRINT', s[0])"}
{"id": "1215", "input": "Z = 100000\\n\\nn = int(input())\\nxx = list(map(int, input().split()))\\n\\n\\ndef cal():\\n ans = []\\n a = 1\\n b = 1\\n s = 0\\n ls = 1\\n for x in xx:\\n while b <= Z:\\n if s < x:\\n s += b * 2 + 1\\n b += 1\\n elif s >", "gt": "x:\\n s -= a * 2 + 1\\n ls += a * 2 + 1\\n a += 1\\n else:\\n ans.append(ls)\\n ans.append(x)\\n ls = b * 2 + 1\\n b += 1\\n a = b\\n s = 0\\n break\\n else:\\n return\\n return ans\\n\\n\\nans = cal()\\nif ans:\\n print('Yes')\\n print(' '.join(map(str, ans)))\\nelse:\\n print('No')\\n"}
{"id": "1216", "input": "n =", "gt": "int(input())\\nif(n%2==1):\\n print(0)\\nelse:\\n print(2**(n//2))\\n"}
{"id": "1217", "input": "bad = ['e', 'a', 'i', 'o', 'u', 'y']\\n\\nn = int(input())\\ns = input()\\nans = ''\\ni = 0\\nwhile i != len(s):\\n if s[i] in bad:\\n letter = s[i]\\n pos = i\\n while i != len(s)", "gt": "and letter == s[i]:\\n i += 1\\n if i - pos == 2 and letter in ['e', 'o']:\\n ans += 2 * letter\\n else:\\n ans += letter\\n else:\\n ans += s[i]\\n i += 1\\nprint(ans)"}
{"id": "1218", "input": "#!/usr/bin/env python3\\n\\nfrom bisect import bisect\\n\\ntry:\\n while True:\\n n, m = map(int, input().split())\\n a =", "gt": "list(map(int, input().split()))\\n a.sort()\\n for x in map(int, input().split()):\\n print(bisect(a, x), end=' ')\\n print()\\n\\nexcept EOFError:\\n pass\\n"}
{"id": "1219", "input": "n, k = map(int, input().split())\\nm = 2 * (n - 1) - k * (k - 1)\\nif m > 0: print(-1)\\nelse:\\n x = int((1 +", "gt": "(1 - 4 * m) ** 0.5) / 2)\\n while x * x - x + m > 0: x -= 1\\n print(k - x)"}
{"id": "1220", "input": "N,x,y,z,v,w=input(),-9e9,-9e9,-9e9,0,1\\nfor A", "gt": "in map(int,input().split()):x,y,z,v,w=max(z+A,y-A),max(x+A,z-A),max(y+A,x-A,v-w*A),v+w*A,-w\\nprint([v,y][N>'1'])"}
{"id": "1221", "input": "n,m = list(map(int,input().split()))\\nae = [[] for _ in range(n)]\\nfor _ in range(m):\\n a,b = list(map(int,input().split()))\\n ae[a-1].append(b-1)\\n ae[b-1].append(a-1)\\nmn = -1\\nnbr = n\\nfor i in range(n):\\n if len(ae[i])<nbr:\\n mn = i\\n nbr = len(ae[i])\\nkeep = ae[mn]\\nok = n-len(keep)\\nwhile True:\\n toDel = -1\\n for i in keep:\\n aeo = len(ae[i])\\n for j in ae[i]:\\n if j in keep:\\n aeo -= 1\\n if aeo<ok: break\\n if aeo<ok:\\n toDel = i\\n break\\n if toDel == -1:\\n break\\n else:\\n keep.remove(i)\\n ok += 1\\nout = [ok]\\nd = {}\\n\\nif len(keep) == 1: out.append(1)\\nelif len(keep) == 0: out = out\\nelse:\\n keep.sort()\\n for i in range(len(keep)):\\n d[keep[i]] = i\\n\\n edg = [[]", "gt": "for _ in range(len(keep))]\\n for i in range(len(keep)):\\n for j in range(len(keep)):\\n if i == j: continue\\n edg[i].append(j)\\n edg[j].append(i)\\n\\n for i in keep:\\n for j in ae[i]: \\n if j in keep:\\n if d[j] in edg[d[i]]: edg[d[i]].remove(d[j])\\n if d[i] in edg[d[j]]: edg[d[j]].remove(d[i])\\n used = [False]*len(keep)\\n uss = 0\\n while uss<len(keep):\\n fi = -1\\n for i in range(len(keep)):\\n if not used[i]:\\n fi = i\\n break\\n bfs = [fi]\\n used[fi] = True\\n usn = 1\\n uss += 1\\n while len(bfs) > 0:\\n temp = bfs.pop()\\n for i in edg[temp]:\\n if not used[i]:\\n used[i] = True\\n bfs.append(i)\\n uss += 1\\n usn += 1\\n out.append(usn)\\n\\nout.sort()\\nprint(len(out))\\nprint(' '.join(map(str,out)))\\n"}
{"id": "1222", "input": "from sys import stdin, stdout\\n\\nn, m = map(int, stdin.readline().split())\\nfirst = list(map(int, stdin.readline().split()))\\nsecond = list(map(int, stdin.readline().split()))\\nans = float('inf')\\n\\nfor i in range(n):\\n cnt = float('-inf')\\n \\n for", "gt": "j in range(m): \\n for z in range(n):\\n if z == i:\\n continue\\n \\n cnt = max(cnt, first[z] * second[j])\\n \\n ans = min(ans, cnt)\\n\\nstdout.write(str(ans))"}
{"id": "1223", "input": "k = int(input())\\n\\nimport queue\\n\\nque = queue.Queue()\\n\\nfor i in range(1, 10):\\n que.put(i)\\n\\nfor i in range(1, k + 1):\\n ans = que.get()\\n keta1 = ans % 10\\n if keta1 == 0:\\n append_list = [ans * 10, ans * 10 + 1]\\n elif keta1", "gt": "== 9:\\n append_list = [ans * 10 + 8, ans * 10 + 9]\\n else:\\n append_list = [ans * 10 + keta1 - 1, ans * 10 + keta1, ans * 10 + keta1 + 1]\\n for ite in append_list:\\n que.put(ite)\\nprint(ans)"}
{"id": "1224", "input": "def main():\\n class unionfind():\\n #size:要素数,tree：unionfind木\\n def __init__(self,size):#self,要素数\\n self.size=size\\n self.tree=[i for i in range(self.size)]#root,depth\\n \\n #rootを探す\\n def root(self,index):\\n temp_list=[]\\n temp=self.tree[index]\\n while index!=temp:\\n temp_list.append(index)\\n index=temp\\n temp=self.tree[index]\\n for i in temp_list:\\n self.tree[i]=index\\n return index\\n \\n #結合\\n def unite_r(self,index1,index2):\\n r1=self.root(index1)\\n r2=self.root(index2)\\n if r1<r2:\\n self.tree[r1]=r2\\n else:\\n self.tree[r2]=r1\\n\\n def unite_l(self,index1,index2):\\n r1=self.root(index1)\\n r2=self.root(index2)\\n if r1>r2:\\n self.tree[r1]=r2\\n else:\\n self.tree[r2]=r1\\n\\n #同じか判定\\n", "gt": "def same(self,index1,index2):\\n r1=self.root(index1)\\n r2=self.root(index2)\\n return r1==r2\\n \\n n=int(input())\\n a=list(map(int,input().split()))\\n d=[0]*n\\n for i,j in enumerate(a):\\n d[j-1]=i+2\\n vis=[False]*(n+4)\\n u_r=unionfind(n+4)\\n u_l=unionfind(n+4)\\n ans=0\\n for j,i in enumerate(d[:-1]):\\n vis[i]=True\\n if vis[i+1]==True:\\n u_r.unite_r(i,i+1)\\n u_l.unite_l(i,i+1)\\n k1=u_r.root(i+1)+1\\n else:\\n k1=i+1\\n if vis[k1+1]==True:\\n cnt1=u_r.root(k1+1)+1\\n else:\\n cnt1=k1+1\\n cnt1=min(cnt1,n+2)\\n if vis[i-1]==True:\\n u_r.unite_r(i,i-1)\\n u_l.unite_l(i,i-1)\\n k2=u_l.root(i-1)-1\\n else:\\n k2=i-1\\n if vis[k2-1]==True:\\n cnt2=u_l.root(k2-1)-1\\n else:\\n cnt2=k2-1\\n cnt2=max(cnt2,1)\\n ans+=((k2-cnt2)*(k1-i)+(cnt1-k1)*(i-k2))*(j+1)\\n print(ans)\\nmain()"}
{"id": "1225", "input": "n=int(input())\\nfor i in range(1,100):\\n if 3**i > n:\\n print(-1)\\n", "gt": "break\\n x=n-3**i\\n for j in range(1,100):\\n if x==5**j:\\n print(i,j)\\n return"}
{"id": "1226", "input": "h = int(input())\\nans = 0\\nn = 0\\nwhile h !=", "gt": "0:\\n ans += 2**n\\n n += 1\\n h = h//2\\nprint(ans)"}
{"id": "1227", "input": "def comb_mod(n,r):\\n mod = 10**9+7\\n ans = 1\\n for i in range(r):\\n ans *= n-i\\n ans %= mod\\n for i in range(1,r+1):\\n ans *=", "gt": "pow(i,mod-2,mod)\\n ans %= mod\\n return ans\\n\\ndef solve():\\n n, a, b = list(map(int, input().split()))\\n mod = 10**9+7\\n ans = pow(2,n,mod)-comb_mod(n,a)-comb_mod(n,b)-1\\n ans %= mod\\n return ans\\nprint((solve()))\\n"}
{"id": "1228", "input": "import sys\\nsys.setrecursionlimit(10000)\\n\\nn = input()\\nk = int(input())\\nm = {}\\n\\n\\ndef doit(n, k):\\n if len(n) == 0:\\n return k == 0\\n d = int(n[0])\\n if (n, k) not in m:\\n ret = 0\\n for i in range(d + 1):\\n if i", "gt": "== d:\\n ret += doit(n[1:], k - 1 if i > 0 else k)\\n else:\\n ret += doit('9' * (len(n) - 1), k - 1 if i > 0 else k)\\n m[(n, k)] = ret\\n return m[(n, k)]\\n\\n\\nprint((doit(n, k)))\\n"}
{"id": "1229", "input": "n=int(input())\\nif n%4==1:\\n print(0,'A')\\nelif n%4==2:\\n", "gt": "print(1,'B')\\nelif n%4==3:\\n print(2,'A')\\nelif n%4==0:\\n print(1,'A')"}
{"id": "1230", "input": "from sys import stdin\\nn,m=list(map(int,stdin.readline().strip().split()))\\ns=[]\\nfor i in range(n):\\n s.append(list(map(ord,list(stdin.readline().strip()))))\\n for j in range(m):\\n s[-1][j]=s[-1][j]-97\\nct=[tuple(map(int,stdin.readline().strip().split())) for i in range(n)]\\nmc=[[0 for i in range(22)] for j in range(22)]\\nc=[[0 for i in range(22)] for i in range(22)]\\nmaxmask=1<<n\\nmaxx=10**8\\ndp=[maxx for i in range(maxmask)]\\nfor i in range(n):\\n for j in", "gt": "range(m):\\n mx=0\\n for k in range(n):\\n if s[i][j]==s[k][j]:\\n mc[i][j]|=(1<<k)\\n c[i][j]+=ct[k][j]\\n mx=max(mx,ct[k][j])\\n c[i][j]-=mx\\ndp[0]=0\\nfor i in range(1,maxmask):\\n for j in range(n):\\n if i & (1<<j):\\n lb=j\\n break\\n mask=i\\n for j in range(m):\\n dp[mask]=min(dp[mask],dp[mask ^(1<<lb)]+ct[lb][j],dp[mask & (mask ^ mc[lb][j])]+c[lb][j])\\nprint(dp[(1<<n)-1])\\n \\n \\n \\n \\n \\n\\n \\n\\n\\n \\n"}
{"id": "1231", "input": "def main():\\n n=int(input())\\n a=list(map(int,input().split()))\\n a.sort(reverse=True)\\n mod=sum(a)%2\\n counts=[0]*(n+1)\\n for guy in a:\\n counts[guy]+=1\\n cumcounts=[counts[0]]\\n for i in range(n):\\n cumcounts.append(cumcounts[-1]+counts[i+1])\\n partialsums=[0]\\n curr=0\\n for i in range(n):\\n curr+=(i+1)*counts[i+1]\\n partialsums.append(curr)\\n partialsums.append(0)\\n cumcounts.append(0)\\n sumi=0\\n diffs=[]\\n altdiffs=[]\\n for i in range(n):\\n sumi+=a[i]\\n", "gt": "rhs=i*(i+1)\\n if a[i]>i:\\n rhs+=partialsums[i]+(i+1)*(n-i-1-cumcounts[i])\\n else:\\n rhs+=partialsums[a[i]-1]+a[i]*(n-i-1-cumcounts[a[i]-1])\\n diffs.append(sumi-rhs)\\n \\n rhs2=(i+1)*(i+2)\\n if a[i]>i+1:\\n rhs2+=partialsums[i+1]+(i+2)*(n-i-1-cumcounts[i+1])\\n else:\\n rhs2+=partialsums[a[i]-1]+a[i]*(n-i-1-cumcounts[a[i]-1])\\n altdiffs.append(sumi-rhs2)\\n mini=max(diffs)\\n maxi=-max(altdiffs)\\n mini=max(mini,0)\\n maxi=min(maxi,n)\\n out=\"\"\\n if mini%2!=mod:\\n mini+=1\\n if maxi%2==mod:\\n maxi+=1\\n for guy in range(mini,maxi,2):\\n out+=str(guy)+\" \"\\n if mini>maxi:\\n print(-1)\\n else:\\n print(out)\\nmain()"}
{"id": "1232", "input": "a,b=list(map(int,input().split()))\\nprint(\"YES\"if abs(a-b)<=1", "gt": "and a+b>0 else\"NO\")\\n"}
{"id": "1233", "input": "def main():\\n s, k = map(int, input().split())\\n n, m = map(int, input().split())\\n a =", "gt": "list(map(int, input().split()))\\n b = list(map(int, input().split()))\\n if (a[n - 1] < b[-m]):\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n\\nmain()"}
{"id": "1234", "input": "arr = [0 for i in range(5001)]\\n\\n\\ndef insertion_sort(n, a):\\n def modify(t):\\n while t > 0:\\n arr[t] += 1\\n t -= t & (-t)\\n\\n def query(t):\\n res = 0\\n while t < 5001:\\n res += arr[t]\\n t += t & (-t)\\n return res\\n\\n s = 0\\n ans = 0\\n way = 0\\n\\n for i in range(n):\\n a[i] += 1\\n\\n for i in range(n):\\n nonlocal arr\\n", "gt": "arr = [0 for j in range(5001)]\\n for j in range(i + 1, n):\\n if a[i] < a[j]:\\n continue\\n s += 1\\n tmp = 1 + 2 * query(a[j])\\n if tmp > ans:\\n ans = tmp\\n way = 1\\n elif tmp == ans:\\n way += 1\\n modify(a[j])\\n\\n return s - ans, way\\n\\n\\ndef __starting_point():\\n n = int(input())\\n a = list(map(int, input().split()))\\n result = insertion_sort(n, a)\\n print(*result)\\n\\n__starting_point()"}
{"id": "1235", "input": "#! usr/bin/env python\\n# -*- coding: utf-8 -*-\\n\\nfrom collections import deque\\nimport heapq\\nimport math\\nimport bisect\\n\\n\\ndef main():\\n N, M, K = list(map(int, input().split()))\\n A = list(map(int, input().split()))\\n\\n B = [(A[i], i) for i in range(N)]\\n B.sort(reverse=True)\\n\\n used = [0] * N\\n ans = 0\\n for i in range(M*K):\\n idx", "gt": "= B[i][1]\\n used[idx] = 1\\n ans += B[i][0]\\n\\n lst = []\\n cnt = le = 0\\n for i in range(N):\\n if used[i]:\\n cnt += 1\\n if cnt == M:\\n lst.append(i+1)\\n cnt = 0\\n le += 1\\n if le == K - 1:\\n break\\n\\n print(ans)\\n print(*lst)\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1236", "input": "n = int(input())\\nA = list(map(int, input().split()))\\nm", "gt": "= int(input())\\nB = list(map(int, input().split()))\\nprint(max(A), max(B))"}
{"id": "1237", "input": "def main():\\n n, k = list(map(int, input().split()))\\n even = 0\\n odd = 0\\n for elem in input().split():\\n if int(elem) % 2 == 0:\\n even += 1\\n else:\\n odd += 1\\n turns = n - k\\n if turns == 0:\\n if odd % 2 == 1:\\n return \"Stannis\"\\n else:\\n", "gt": "return \"Daenerys\"\\n if turns % 2 == 0:\\n if k % 2 == 1 and even <= turns // 2:\\n return \"Stannis\"\\n else:\\n return \"Daenerys\"\\n else:\\n if k % 2 == 0 and even <= turns // 2 or odd <= turns // 2:\\n return \"Daenerys\"\\n else:\\n return \"Stannis\"\\nprint(main())\\n\\n\\n\\n"}
{"id": "1238", "input": "n, up = map(int, input().split())\\nres = 0\\nfor i in range(n):\\n fl, t", "gt": "= map(int, input().split())\\n res = max(res, max(t, up - fl) + fl)\\nprint(res)"}
{"id": "1239", "input": "n = int(input())\\na = sorted(list(map(int, input().split())))\\n\\nans = 0\\nfor i in", "gt": "range(1, n):\\n ans += a[i] - a[i - 1] - 1\\n\\nprint(ans)\\n\\n\\n"}
{"id": "1240", "input": "n = int(input())\\na = [int(x) for x in input().split()]\\na.sort()\\n\\ndiffs = [a[i] - a[i-1] for i in", "gt": "range(1, n)]\\ndiffs.sort()\\n\\ncur = 0\\nwhile cur < n - 1 and diffs[cur] == diffs[0]:\\n cur += 1\\nprint(diffs[0], cur)\\n"}
{"id": "1241", "input": "3\\n\\nn = int(input())\\nl = []\\nr = []\\nfor i in range(n):\\n a, b = list(map(int, input().split()))\\n l.append(a)\\n r.append(b)\\n\\nL = sum(l)\\nR = sum(r)\\nmx = abs(L - R)\\nk = 0\\nfor i in range(n):\\n", "gt": "Lp = L - l[i] + r[i]\\n Rp = R - r[i] + l[i]\\n if abs(Lp - Rp) > mx:\\n mx = abs(Lp - Rp)\\n k = i + 1\\n\\nprint(k)\\n"}
{"id": "1242", "input": "#!/usr/bin/env python3\\n\\ntry:\\n while True:\\n n, k = map(int, input().split())\\n a = list(map(int, input().split()))\\n left = 0\\n result = -1\\n cur = 0\\n for i in range(n):\\n if not a[i]:\\n if k:\\n k -= 1\\n else:\\n if i - left > result:\\n res_left = left\\n res_right = i\\n result = i - left\\n while left < i", "gt": "and a[left]:\\n left += 1\\n left += 1\\n\\n if i + 1 - left > result:\\n res_left = left\\n res_right = i + 1\\n result = i + 1 - left\\n\\n print(result)\\n for i in range(res_left):\\n print(a[i], end=' ')\\n for i in range(result):\\n print(end=\"1 \")\\n for i in range(res_right, n):\\n print(a[i], end=' ')\\n print()\\n\\nexcept EOFError:\\n pass\\n"}
{"id": "1243", "input": "s = input()\\narr_ans = [0] * len(s)\\nfor i in range(1, len(s)):\\n if s[i] ==", "gt": "'a':\\n arr_ans[i - 1] = (arr_ans[i - 1] + 1) % 2\\n arr_ans[i] += 1\\nprint(*arr_ans)"}
{"id": "1244", "input": "\"\"\"\\nCodeforces Testing Round 10 Problem B\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0:\\n return inputs\\n if mode == 1:\\n return inputs.split()\\n if mode == 2:\\n return [int(x) for x in inputs.split()]\\n\\ndef write(s=\"\\n\"):\\n", "gt": "if isinstance(s, list): s = \" \".join(s)\\n s = str(s)\\n print(s, end=\"\")\\n\\n################################################### SOLUTION\\nn, = read()\\na = read()\\ns = sum(a) // n\\nr = 0\\nfor i in range(n-1):\\n if a[i] < s:\\n r += s - a[i]\\n a[i+1] -= s - a[i]\\n else:\\n r += a[i] - s\\n a[i+1] += a[i] - s\\nprint(r)"}
{"id": "1245", "input": "n = int(input())\\nmas = list(map(int, input().split()))\\nmas2 = [0 for _ in range(1001)]\\nfor i in mas:\\n mas2[i]+=1\\ni", "gt": "= 0\\nfor i in mas2:\\n if i > (n + 1) / 2:\\n print (\"NO\")\\n return\\nprint (\"YES\")\\n"}
{"id": "1246", "input": "def main():\\n lst = list(tuple(map(int, input().split())) for _ in range(int(input())))\\n res = []\\n try:\\n for a, b in reversed(lst):\\n w, tmp = 1, ['(']\\n while", "gt": "w < a:\\n x = res.pop()\\n w += len(x)\\n tmp.append(x)\\n if w > b:\\n raise IndexError\\n else:\\n tmp.append(')')\\n res.append(''.join(tmp))\\n except IndexError:\\n print('IMPOSSIBLE')\\n return\\n print(''.join(reversed(res)))\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1247", "input": "from heapq import *\\nn=int(input())\\nq,ans,k=[],[],0\\nfor i in range(n):\\n ss=input()\\n if ss!=\"removeMin\": \\n s,mm=ss.split(); m=int(mm)\\n if s=='insert':\\n k+=1\\n heappush(q,m)\\n else:\\n while k==0 or q[0]!=m:\\n if k==0:\\n heappush(q,m)\\n", "gt": "ans+=['insert '+mm]\\n k+=1\\n elif q[0]<m: \\n k-=1\\n t=heappop(q)\\n ans+=['removeMin']\\n else: \\n k+=1\\n heappush(q,m)\\n ans+=['insert '+mm]\\n else: \\n if k==0:\\n ans+=['insert 1']\\n else: \\n heappop(q)\\n k-=1\\n ans+=[ss]\\nprint(len(ans))\\nprint('\\n'.join(ans))"}
{"id": "1248", "input": "def __starting_point():\\n s = input()\\n c = [s.count(x) for x in set(s)]\\n total = 0\\n for x in c:\\n if", "gt": "x % 2 != 0:\\n total += 1\\n if total % 2 == 0 and total != 0:\\n print(\"Second\")\\n else:\\n print(\"First\")\\n\\n__starting_point()"}
{"id": "1249", "input": "d1, d2, d3 = map(int, input().split())\\nD1 = 2*d1 + 2*d2\\nD2 = d1 + d3 +", "gt": "d2\\nD3 = (d1 + d3) * 2\\nD4 = (d2 + d3) * 2\\nprint(min(D1, D2, D3, D4))"}
{"id": "1250", "input": "n, k, m, s = map(int, input().split())\\na = list(map(int, input().split()))\\nc = list(map(int, input().split()))\\nneed = len(c)\\nrez = n - m * k\\nkek = [0 for i in range(500007)]\\ncur_kek = [0 for i in range(500007)]\\nfor i in c:\\n kek[i] += 1\\nr = 0\\nif (rez == 0):\\n lol = need\\n for i in range(0, n, k):\\n for j in range(i, i + k):\\n if kek[a[j]] > cur_kek[a[j]]:\\n need -= 1\\n cur_kek[a[j]] += 1\\n if (need == 0):\\n print(0)\\n break\\n for j in range(i, i + k):\\n cur_kek[a[j]] = 0\\n else:\\n print(-1)\\n return\\nmeshayut = 0 if kek[a[0]] else 1\\nif kek[a[0]]:\\n need -= 1\\ncur_kek[a[0]] += 1\\nans = []\\nfor l in range(n):\\n while need > 0 and r < n - 1:\\n r += 1\\n if (kek[a[r]] > cur_kek[a[r]]):\\n", "gt": "need -= 1\\n cur_kek[a[r]] += 1\\n else:\\n cur_kek[a[r]] += 1\\n meshayut += 1\\n #print(r, need)\\n need_to_cut = l % k\\n cur = r - l + 1\\n razn = cur - k\\n #print(l, r, need_to_cut, razn, meshayut, cur, need)\\n #print(need, razn + need_to_cut, rez, meshayut + not_useful, razn + need_to_cut)\\n if (need == 0 and razn + need_to_cut <= rez and meshayut >= razn):\\n rezhem = razn\\n for j in range(l - need_to_cut, l):\\n ans.append(j + 1)\\n for j in range(l, r + 1):\\n if kek[a[j]]:\\n kek[a[j]] -= 1\\n elif rezhem:\\n ans.append(j + 1)\\n rezhem -= 1\\n print(len(ans))\\n print(' '.join(map(str, ans)))\\n break\\n if (kek[a[l]]):\\n if cur_kek[a[l]] > kek[a[l]]:\\n meshayut -= 1\\n else:\\n need += 1\\n else:\\n meshayut -= 1\\n cur_kek[a[l]] -= 1\\nelse:\\n print(-1)"}
{"id": "1251", "input": "n=int(input())\\n\\nif(n<=2):\\n print(-1)\\n\\nelse:\\n for i in", "gt": "range(n,1,-1):\\n print(i,end=\" \")\\n print(1)\\n \\n"}
{"id": "1252", "input": "import sys\\nn=0;\\ninp=[];\\ntree=[];#stores the index of min in range(i,j)\\n\\ndef build(node,i,j):\\n if(i>j):\\n return;\\n if(i==j):\\n tree[node]=int(i);\\n return;\\n mid=int( (i+j)/2 );\\n\\n build(2*node,i,mid)\\n build(2*node+1,mid+1,j)\\n if( inp[ tree[2*node] ] < inp[ tree[2*node+1] ] ):\\n tree[node]= tree[2*node];\\n else:\\n tree[node]=tree[2*node+1]\\n\\ndef RMQ(node,i,j,l,r):#return index of minimum in range i,j #r,l is current range\\n if( (i<=l) and (r<=j) ):\\n return tree[node];\\n\\n if( (i>r) or (j<l) ):\\n return n;\\n\\n mid=int((l+r)/2);\\n\\n a=RMQ(2*node, i, j, l ,mid);#", "gt": "j,l,mid);"}
{"id": "1253", "input": "\\ndef __starting_point():\\n n, m, t = map(int, input().split())\\n edge = {i:{} for i in range(n)}\\n income = [0 for i in range(n)]\\n for i in range(m):\\n u, v, ti = map(int, input().split())\\n edge[v-1][u-1] = ti\\n income[u-1] += 1\\n stat = [{} for _ in range(n)]\\n stat[n-1] = {1 : (0, -1)}\\n queue = [n-1]\\n first = 0\\n last = 1\\n for i in range(n-2, 0, -1):\\n if income[i] == 0:\\n queue.append(i)\\n last +=", "gt": "1\\n while (first < last):\\n v = queue[first]\\n first += 1\\n for u in edge[v].keys():\\n income[u] -= 1\\n for vis in stat[v].keys():\\n cost = stat[v][vis][0] + edge[v][u]\\n ucost = stat[u].get(vis+1, (t+1,-1))[0]\\n if ucost > cost:\\n stat[u][vis+1] = (cost, v)\\n if income[u] <= 0:\\n queue.append(u)\\n last += 1\\n #print(queue, last)\\n res = max(stat[0].keys())\\n print(res)\\n path = []\\n curr = 0\\n path.append(curr+1)\\n while(stat[curr][res][1] >= 0):\\n curr = stat[curr][res][1]\\n path.append(curr+1)\\n res -= 1\\n print(' '.join(map(str, path)))\\n__starting_point()"}
{"id": "1254", "input": "rd = lambda: list(map(int, input().split()))\\nk = kk = rd()[1]\\na = rd()\\nk -= sum(x<0", "gt": "for x in a)\\na[:kk] = list(map(abs, a[:kk]))\\nprint(sum(a)-(2*min(a) if k>0 and k%2 else 0))"}
{"id": "1255", "input": "\\nnum_students, num_cats = [int(x) for x in input().split()]\\n\\ncats = [[] for _ in range(num_cats)]\\n\\nfor _ in range(num_students):\\n cat_idx, skill = [int(x) for x in input().split()]\\n cat_idx -= 1\\n cats[cat_idx].append(skill)\\n\\nfor cat in cats:\\n cat.sort(key=lambda x : -x)\\n\\nentries = []\\n\\nfor cat in cats:\\n team_size = 0\\n team_skill = 0\\n for skill", "gt": "in cat:\\n team_size += 1\\n team_skill += skill\\n entries.append((team_size, -team_skill))\\n\\nentries.sort()\\n\\nbest_skill = 0\\ntotal_skill = 0\\ncurr_size = 1\\nfor entry in entries:\\n size, neg_skill = entry\\n skill = -neg_skill\\n\\n if size != curr_size:\\n best_skill = max(total_skill, best_skill)\\n curr_size = size\\n total_skill = 0\\n\\n if skill > 0:\\n total_skill += skill\\n\\nbest_skill = max(total_skill, best_skill)\\n\\nprint(best_skill)\\n"}
{"id": "1256", "input": "from collections", "gt": "import *\\nimport sys\\nprint(Counter(sys.stdin.readlines()).most_common(1)[0][1])\\n"}
{"id": "1257", "input": "s = input()\\nl = [int(x) for", "gt": "x in s.split('+')]\\nl.sort()\\nprint('+'.join([str(x) for x in l]))\\n"}
{"id": "1258", "input": "n, k = map(int, input().split())\\nans = [[0 for i in range(n)]for j in range(n)]\\ncur = 1\\nsum_k = 0\\nfor i in range(n):\\n for j in range(k-1):\\n ans[i][j] = cur\\n cur += 1\\nfor i in", "gt": "range(n):\\n for j in range(k-1, n):\\n ans[i][j] = cur\\n cur += 1\\nfor i in range(n):\\n sum_k += ans[i][k-1]\\nprint(sum_k)\\nfor i in range(n):\\n for j in range(n):\\n print(ans[i][j], end = ' ')\\n print('')\\n\\n \\n \\n"}
{"id": "1259", "input": "from bisect import *\\nfrom collections import *\\nfrom itertools import *\\nimport functools\\nimport sys\\nimport math\\nfrom decimal import *\\nfrom copy import *\\nfrom heapq import *\\nfrom fractions import *\\ngetcontext().prec = 30\\nMAX = sys.maxsize\\nMAXN = 1000010\\nMOD = 10**9+7\\nspf = [i for i in range(MAXN)]\\ndef sieve():\\n for i in range(2,MAXN,2):\\n spf[i] = 2\\n for i in range(3,int(MAXN**0.5)+1):\\n if spf[i]==i:\\n for j in range(i*i,MAXN,i):\\n if spf[j]==j:\\n spf[j]=i\\ndef fib(n,m):\\n if n == 0:\\n return [0, 1]\\n else:\\n a, b = fib(n // 2)\\n c = ((a%m) * ((b%m) * 2 - (a%m)))%m\\n d = ((a%m) * (a%m))%m + ((b)%m * (b)%m)%m\\n if n % 2 == 0:\\n return [c, d]\\n else:\\n return [d, c + d]\\n\\ndef charIN(x= ' '):\\n return(sys.stdin.readline().strip().split(x))\\n\\ndef", "gt": "arrIN(x = ' '):\\n return list(map(int,sys.stdin.readline().strip().split(x)))\\n\\ndef ncr(n,r):\\n num=den=1\\n for i in range(r):\\n num = (num*(n-i))%MOD\\n den = (den*(i+1))%MOD\\n\\n return (num*(pow(den,MOD-2,MOD)))%MOD\\n\\ndef flush():\\n return sys.stdout.flush()\\n\\n'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''\\nn = int(input())\\na = [arrIN() for _ in range(n-2)]\\nd = [0]*(n+1)\\npos = defaultdict(list)\\nfor i in range(n-2):\\n for j in a[i]:\\n d[j]+=1\\n pos[j].append(i)\\nans = []\\nflag = [1]*(n-2)\\nfor i in range(1,n+1):\\n if d[i]==1:\\n x = a[pos[i][0]]\\n flag[pos[i][0]] = 0\\n break\\nt = [0,0,0]\\nfor i in x:\\n if d[i]==1:\\n t[0] = i\\n elif d[i]==2: \\n t[1] = i\\n else:\\n t[2] = i\\nans = t\\nl = 3\\nwhile l!=n:\\n for i in pos[ans[-2]]:\\n if flag[i]:\\n if ans[-1] in a[i]:\\n x = a[i]\\n flag[i] = 0\\n break\\n\\n t = [i for i in x]\\n t.remove(ans[-2])\\n t.remove(ans[-1])\\n ans.append(t[0])\\n l+=1\\nprint(*ans)"}
{"id": "1260", "input": "import sys\\ninput = sys.stdin.readline\\n\\nn, m = list(map(int, input().split()))\\ne = [tuple(map(int, input().split())) for _ in range(m)]\\ng = [[] for _ in range(n + 1)]\\nfor u, v in e:\\n g[u].append(v)\\n g[v].append(u)\\n\\nreq = 1\\nwhile req * req < n:\\n req += 1\\n\\ndef dfs():\\n dep = [0] * (n + 1)\\n par = [0] * (n + 1)\\n mk = [0] * (n + 1)\\n st = [1]\\n st2 = []\\n while st:\\n u = st.pop()\\n if dep[u]:\\n continue\\n st2.append(u)\\n dep[u]", "gt": "= dep[par[u]] + 1\\n for v in g[u]:\\n if not dep[v]:\\n par[v] = u\\n st.append(v)\\n elif dep[u] - dep[v] + 1 >= req:\\n ans = []\\n while u != par[v]:\\n ans.append(u)\\n u = par[u]\\n return (None, ans)\\n while st2:\\n u = st2.pop()\\n if not mk[u]:\\n for v in g[u]:\\n if dep[v] < dep[u]:\\n mk[v] = 1\\n return ([u for u in range(1, n + 1) if not mk[u]][:req], None)\\n\\niset, cyc = dfs()\\nif iset:\\n print(1)\\n print(*iset)\\nelse:\\n print(2)\\n print(len(cyc))\\n print(*cyc)\\n"}
{"id": "1261", "input": "n = int(input())\\na = list(map(int, input().split()))\\n\\ncnt_zero, cnt_nega, cnt_nega_max, cnt_nega_max_pos = 0, 0, -1e10, -1\\nused = [0]*n\\n\\nfor i, v in enumerate(a):\\n if v == 0:\\n cnt_zero += 1\\n used[i] = 1\\n continue\\n if v < 0:\\n cnt_nega += 1\\n if cnt_nega_max_pos == -1 or cnt_nega_max < v:\\n cnt_nega_max = v\\n cnt_nega_max_pos = i\\nif cnt_nega%2 == 1:\\n used[cnt_nega_max_pos] = 1\\n\\nif cnt_zero == n or", "gt": "(cnt_zero == n-1 and cnt_nega == 1):\\n for i in range(n-1):\\n print('1', i+1, i+2)\\nelse: \\n left = -1\\n for i in range(n):\\n if used[i] == 1:\\n if left != -1: print('1', left+1, i+1)\\n left = i\\n if left != -1:\\n print('2', left+1)\\n left = -1\\n for i in range(n):\\n if used[i] == 0:\\n if left != -1: print('1', left+1, i+1)\\n left = i\\n"}
{"id": "1262", "input": "def f(n):\\n if n==1:return[1]\\n if n==2:return[1,2]\\n if n==3:return[1,1,3]\\n if n>3:\\n", "gt": "L=f(n//2)\\n for i in range(len(L)):L[i]*=2\\n return [1]*(n-n//2)+L\\nL=f(int(input()))\\ns=''\\nfor i in L:s+=(str(i)+' ')\\nprint(s)"}
{"id": "1263", "input": "from math import *\\n\\nc=int(input())\\nx=[0]*c\\ny=[0]*c\\nvu=[False]*c\\nfor i in range(c):\\n x[i],y[i]=[int(s) for s in input().split()]\\nprix=[int(s) for s in input().split()]\\nfil=[int(s) for s in input().split()]\\nanc=[-1]*c\\npmin=prix.copy()\\nv=0\\npl=[]\\ne=0\\nppl=[]\\ntot=0\\nfor i in range(c):\\n pmina=100000000000000000000000\\n for j in range(c):\\n if", "gt": "(not vu[j]) and pmin[j]<pmina:\\n pmini=j\\n pmina=pmin[j]\\n vu[pmini]=True\\n tot+=pmina\\n if anc[pmini]==-1:\\n v+=1\\n pl.append(str(pmini+1))\\n else:\\n e+=1\\n ppl.append([str(pmini+1),str(anc[pmini]+1)])\\n for j in range(c):\\n if (abs(x[pmini]-x[j])+abs(y[pmini]-y[j]))*(fil[pmini]+fil[j])<pmin[j]:\\n pmin[j]=(abs(x[pmini]-x[j])+abs(y[pmini]-y[j]))*(fil[pmini]+fil[j])\\n anc[j]=pmini\\nprint(tot)\\nprint(v)\\nprint(\" \".join(pl))\\nprint(e)\\nfor i in ppl:\\n print(\" \".join(i))"}
{"id": "1264", "input": "k = int(input().split()[1])\\na = [int(s) for s in input().split()]\\nb = [int(s) for s in input().split()]\\nambk = [(a[i], a[i] - b[i]*k) for i in range(len(a))]\\nambk.sort(key=lambda a:-a[1])\\n\\nts = [0]*(100*100)\\nkeys = [0]\\natras = list(range(100*100 -1, -1, -1))\\nadelante = list(range(100*100))\\nfor i in", "gt": "range(len(a)):\\n for j in ( atras if ambk[i][1] >= 0 else adelante ):\\n if ts[j] > 0 or j == 0:\\n if j + ambk[i][1] >= 0:\\n ts[j+ambk[i][1]] = max(ts[j+ambk[i][1]], ts[j] + ambk[i][0])\\n\\nprint(\"-1\" if ts[0] == 0 else str(ts[0]))\\n"}
{"id": "1265", "input": "n = int(input())\\na = input().replace(' ', '')\\nans = 0\\nfor i in range(n):\\n for j in range(i,", "gt": "n):\\n s = a[i:j + 1]\\n ans = max(ans, s.count('0') + (a[:i] + a[j + 1:]).count('1'))\\nprint(ans)\\n\\n"}
{"id": "1266", "input": "I=input;a,b=I(),I();print(\"YNEOS\"[len(a)!=len(b)or\"1\"in", "gt": "set(a)^set(b)::2])\\n"}
{"id": "1267", "input": "from collections import defaultdict\\nimport bisect\\n\\nn = int(input())\\nx0, y0 = list(map(int, input().split(' ')))\\nverticale = []\\nhorizontale = []\\ndiagonale1 = []\\ndiagonale2 = []\\nfor _ in range(n):\\n t, x, y = input().split(' ')\\n x, y = int(x), int(y)\\n if x == x0:\\n verticale.append((y, t))\\n if y == y0:\\n horizontale.append((x, t))\\n if x+y == x0+y0:\\n diagonale1.append((x, t))\\n if x-y == x0-y0:\\n diagonale2.append((x, t))\\n\\ndead = False\\nv = sorted(verticale)\\nif v:\\n l = bisect.bisect(v, (y0, 'K'))\\n if 0 < l < len(v):\\n if v[l][1] in {'Q', 'R'} or v[l-1][1] in {'Q', 'R'}:\\n dead = True\\n elif l == 0:\\n if v[0][1] in {'Q', 'R'}:\\n dead = True\\n else:\\n if v[len(v)-1][1] in {'Q', 'R'}:\\n dead = True\\nv = sorted(horizontale)\\nif v:\\n l = bisect.bisect(v, (x0, 'K'))\\n if 0 < l < len(v):\\n if v[l][1] in {'Q', 'R'}", "gt": "or v[l-1][1] in"}
{"id": "1268", "input": "n=int(input())\\ns=set()\\nar=list(map(int,input().split()))\\nfor x in", "gt": "range(n):\\n if(ar[x]!=0):\\n s.add(ar[x])\\nprint(len(s))"}
{"id": "1269", "input": "n = int(input())\\na = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\ns =", "gt": "sum(a)\\n\\nmn = max(b)\\nb.remove(mn)\\nmn += max(b)\\n\\nif mn >= s:\\n print(\"YES\")\\nelse:\\n print(\"NO\")"}
{"id": "1270", "input": "n, m = map(int, input().split())\\nl = list(map(int, input().split()))\\nindex = [[0 for i in range(n)] for j in range(n)]\\nfor i in range(n):\\n mini = 10000000000000\\n for j in range(i, n):\\n if l[j] < mini:\\n inde = j\\n mini = l[j]\\n index[i][j] = inde\\nprime = 998244353\\nd = {}\\nval = [[1 for i in range(n + 1)] for j in range(n + 1)]\\nfor i in range(n):\\n for j in range(n - i):\\n if i == 0:\\n", "gt": "val[j][j + i] = 1\\n elif i == 1:\\n val[j][j + i] = 2\\n else:\\n ind = index[j][j + i]\\n sumap = 0\\n sumak = 0\\n for p in range(j, ind +1):\\n sumap += (val[j][p - 1] * val[p][ind - 1]) % prime\\n for k in range(ind, j + i + 1):\\n sumak += (val[ind + 1][k] * val[k + 1][j + i]) % prime\\n val[j][j + i] = (sumap * sumak) % prime\\nprint(val[0][n-1])"}
{"id": "1271", "input": "# 211693RAVMK\\ndef main():\\n n = int(input())\\n print(n // 2)\\n if n % 2 == 0:\\n print('2 '", "gt": "* (n // 2))\\n else:\\n print('2 ' * (n // 2 - 1) + '3')\\n\\n \\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1272", "input": "n, s, k = list(map(int, input().split()))\\namounts = list(map(int, input().split()))\\ncolors = list(input())\\n\\ndp = [[-1 for j in range(k + 1)] for i in range(n)]\\n\\ndef getAns(nth, left):\\n if left <= 0:\\n return 0\\n if dp[nth][left] >= 0:\\n return dp[nth][left]\\n \\n ret = 999999999\\n for i in range(n):\\n if amounts[i] <=", "gt": "amounts[nth] or colors[i] == colors[nth]:\\n continue\\n ret = min(ret, abs(nth - i) + getAns(i, left - amounts[i]))\\n \\n dp[nth][left] = ret\\n return ret\\n\\nans = 999999999\\nfor i in range(n):\\n ans = min(ans, getAns(i, k - amounts[i]) + abs(s - 1 - i))\\nif ans == 999999999:\\n ans = -1\\nprint(ans)\\n \\n"}
{"id": "1273", "input": "N, M = map(int, input().split())\\nEdge = []\\nfor i in range(M):\\n a, b = map(int, input().split())\\n a, b = a - 1, b - 1\\n Edge.append([a, b])\\n\\n\\nclass UnionFind:\\n def __init__(self, n):\\n self.par = [i for i in range(n)]\\n self.rank = [0] * n\\n self.size = [1] * n\\n\\n # 検索\\n def find(self, x):\\n if self.par[x] == x:\\n return x\\n else:\\n self.par[x] = self.find(self.par[x])\\n return self.par[x]\\n\\n # 併合\\n def union(self, x, y):\\n x = self.find(x)\\n y = self.find(y)\\n\\n if x == y:\\n return\\n\\n if", "gt": "self.rank[x] < self.rank[y]:\\n self.par[x] = y\\n self.size[y] += self.size[x]\\n self.size[x] = 0\\n else:\\n self.par[y] = x\\n self.size[x] += self.size[y]\\n self.size[y] = 0\\n if self.rank[x] == self.rank[y]:\\n self.rank[x] += 1\\n\\n # 同じ集合に属するか判定\\n def same(self, x, y):\\n return self.find(x) == self.find(y)\\n\\n # すべての頂点に対して親を検索する\\n def all_find(self):\\n for n in range(len(self.par)):\\n self.find(n)\\n\\n\\nUF = UnionFind(N)\\nScore = N * (N - 1) // 2\\nans = []\\nwhile Edge:\\n ans.append(Score)\\n a, b = Edge.pop()\\n pa, pb = UF.find(a), UF.find(b)\\n if not UF.same(pa, pb):\\n Score -= (UF.size[pa] * UF.size[pb])\\n UF.union(a, b)\\n\\nprint(*ans[::-1], sep='\\n')\\n"}
{"id": "1274", "input": "INT = lambda: int(input())\\nINTM = lambda: map(int,input().split())\\nSTRM = lambda: map(str,input().split())\\nSTR = lambda: str(input())\\nLIST = lambda: list(map(int,input().split()))\\nLISTS = lambda: list(map(str,input().split()))\\nfrom collections import deque\\n\\nclass Graph():\\n def __init__(self, v):\\n from heapq import heappop, heappush\\n self.v = v\\n self.graph = [[] for _ in range(v)]\\n self.INF = 10 ** 9\\n \\n def addEdge(self, start, end,", "gt": "edge):\\n self.graph[start].append((end, edge))\\n self.graph[end].append((start, edge))\\n\\ndef do():\\n n=INT()\\n g=Graph(n)\\n for i in range(n-1):\\n a,b=INTM()\\n a-=1\\n b-=1\\n g.addEdge(a,b,i)\\n\\n \\n que=deque()\\n check=[True]*n\\n clrs=[0]*(n-1)\\n que.append([0,0])\\n check[0]=False\\n while que:\\n clr=1\\n now,clr_f=que.popleft()\\n if clr_f==1:\\n clr=2\\n for next,i in g.graph[now]:\\n if check[next]:\\n check[next]=False\\n que.append([next,clr])\\n clrs[i]=clr\\n clr+=1\\n if clr==clr_f:\\n clr+=1\\n \\n print(max(clrs))\\n for i in range(n-1):\\n print(clrs[i])\\n\\n\\n\\n\\n\\n\\n\\n\\ndef __starting_point():\\n do()\\n__starting_point()"}
{"id": "1275", "input": "import sys, math\\nfrom functools import lru_cache\\nimport numpy as np\\nimport heapq\\nfrom collections import defaultdict\\nsys.setrecursionlimit(10**9)\\nMOD = 10**9+7\\n\\ndef input():\\n return sys.stdin.readline()[:-1]\\n\\ndef mi():\\n return list(map(int, input().split()))\\n\\ndef ii():\\n return int(input())\\n\\ndef i2(n):\\n tmp = [list(mi()) for i in range(n)]\\n return [list(i) for i in zip(*tmp)]\\n\\n\\ndef lcm(a, b):\\n return a*b//math.gcd(a, b)\\n\\n\\ndef", "gt": "main():\\n N, M = mi()\\n A, B = i2(N)\\n ans = 0\\n\\n d = defaultdict(list)\\n for i in range(N):\\n d[A[i]].append(B[i])\\n\\n h = []\\n heapq.heapify(h)\\n\\n for i in range(1, M+1):\\n for v in d[i]:\\n heapq.heappush(h, -v)\\n if h:\\n ans -= heapq.heappop(h)\\n else:\\n continue\\n\\n print(ans)\\n\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1276", "input": "N, K = map(int, input().split())\\ndef num_pair(m):\\n if m<=N:\\n return m-1\\n return", "gt": "2*N-m+1\\n\\nK = abs(K)\\n\\nans = 0\\nfor i in range(K+2,2*N+1):\\n ans += num_pair(i)*num_pair(i-K)\\n \\nprint(ans)"}
{"id": "1277", "input": "N = int(input())\\nS = input()\\nans = S.count(\"R\") * S.count(\"G\") * S.count(\"B\")\\nfor i in range(N-2):\\n r = S[i]\\n for j in range(i+1,N-1):\\n g = S[j]\\n if r", "gt": "== g:\\n continue\\n k = 2*j - i\\n if k >= N:\\n continue\\n b = S[k]\\n if r != b and g != b:\\n ans -= 1\\nprint(ans)"}
{"id": "1278", "input": "import sys\\nfrom collections import deque\\n\\n\\ndef main():\\n N, p, q, *AB = list(map(int, sys.stdin.buffer.read().split()))\\n p -= 1\\n q -= 1\\n\\n G = [[] for _ in range(N)]\\n for a, b in zip(*[iter(AB)] * 2):\\n G[a - 1].append(b - 1)\\n G[b - 1].append(a - 1)\\n\\n if len(G[p]) == 1 and G[p][0] == q:\\n print((0))\\n return\\n\\n dist1 = [-1] * N\\n dist1[p] = 0\\n queue = deque([p])\\n while queue:\\n v = queue.popleft()\\n", "gt": "for nv in G[v]:\\n if dist1[nv] == -1:\\n dist1[nv] = dist1[v] + 1\\n queue.append(nv)\\n\\n dist2 = [-1] * N\\n dist2[q] = 0\\n queue = deque([q])\\n while queue:\\n v = queue.popleft()\\n for nv in G[v]:\\n if dist2[nv] == -1:\\n dist2[nv] = dist2[v] + 1\\n queue.append(nv)\\n\\n max_d = 0\\n for d1, d2 in zip(dist1, dist2):\\n if d1 < d2 and max_d < d2:\\n max_d = d2\\n\\n print((max_d - 1))\\n return\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1279", "input": "n, x, y = list(map(int, input().split()))\\narr = [int(x) for x in input().split()]\\nfor i in range(n):\\n", "gt": "if arr[i] == min(arr[max(0, i - x):i + y + 1]):\\n print(i + 1)\\n break\\n"}
{"id": "1280", "input": "n, k = list(map(int, input().split()))\\na = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\nk1 = 0\\nk2 = 0\\nfor x in a:\\n if x % 2 == 0:\\n k1 += 1\\n", "gt": "else:\\n k2 += 1\\nm1 = 0\\nm2 = 0\\nfor x in b:\\n if x % 2 == 0:\\n m1 += 1\\n else:\\n m2 += 1\\nprint(min(k1, m2) + min(k2, m1))\\n"}
{"id": "1281", "input": "s = input()\\nL = input()\\nk = int(input())\\n\\n'''from datetime import *\\ntime1 = datetime.now()'''\\ngood = set()\\nstring = set()\\nLIST = [chr(i) for i in range(97,123)]\\nfor i in range(26):\\n if L[i]=='1':\\n good.add(LIST[i])\\n\\nt = [s[i] not in good for i", "gt": "in range(len(s))]\\n\\nend = [0]*len(s)\\nbadchars = 0\\nfront=0; rear=0\\nwhile(front<len(s)):\\n while(rear<len(s)):\\n badchars+=t[rear]\\n if badchars>k:\\n badchars-=1\\n break\\n rear+=1\\n end[front]=rear\\n badchars -= t[front]\\n front+=1\\n\\nfor i in range(len(s)):\\n tempStrHash = 0\\n for j in range(i, end[i]):\\n tempStrHash = (tempStrHash*29+ord(s[j])-96)&1152921504606846975\\n string.add(tempStrHash)\\n \\nprint(len(string))\\n#print(datetime.now()-time1)\\n"}
{"id": "1282", "input": "from collections import defaultdict\\nn, k = list(map(int, input().split()))\\na = [0] + list(map(int, input().split()))\\nh = defaultdict(int)\\nfor i in range(n):\\n a[i + 1] ^= a[i]\\nfor i in range(n + 1):\\n h[min(a[i] ^ ((1 << k) - 1), a[i])] += 1\\nans = 0\\nfor", "gt": "x, t in list(h.items()):\\n a = t // 2\\n b = t - a\\n ans += a * (a - 1) // 2 + b * (b - 1) // 2\\nans = (n * (n + 1)) // 2 - ans\\nprint(ans)\\n"}
{"id": "1283", "input": "t = input()[:: -1]\\ni = t.find('F')\\nif i < 0: print(0)\\nelse:\\n j = t.find('M', i + 1)\\n if j < 0: print(0)\\n else:\\n s, t = 0, t[j: t.rfind('M')", "gt": "+ 1]\\n for k in t:\\n if k == 'M': s += 1\\n else: s = max(s - 1, 0)\\n print(s + t.count('F') + j - i - 1)"}
{"id": "1284", "input": "import sys\\nimport math\\n\\nn, k = list(map(int,sys.stdin.readline().strip().split(' ')))\\ngrid = []\\nfor n0 in range(n):\\n grid.append([char for char in sys.stdin.readline().strip()])\\n\\nres = [[0 for i in range(n)] for j in range(n)]\\n\\nfor i in range(n):\\n for j in range(n):\\n if grid[i][j] == '#':\\n continue\\n ii, jj = i,j\\n\\n cpt = 0\\n while ii < n and cpt < k:\\n if grid[ii][j] == '#':\\n break\\n else:\\n cpt += 1\\n ii += 1\\n", "gt": "if cpt == k:\\n for ii in range(i,i+k):\\n res[ii][j] += 1\\n\\n cpt = 0\\n while jj < n and cpt < k:\\n if grid[i][jj] == '#':\\n break\\n else:\\n cpt += 1\\n jj += 1\\n if cpt == k:\\n for jj in range(j,j+k):\\n res[i][jj] += 1\\nans = [0,0]\\nmaxsf = -1\\nfor i in range(n):\\n for j in range(n):\\n if res[i][j] > maxsf:\\n ans = [i,j]\\n maxsf = res[i][j]\\nprint(ans[0]+1, ans[1]+1)\\n\\n\\n\\n\\n\\n\\n\\n"}
{"id": "1285", "input": "x = int(input())\\ny = list(map(int, input().split(' ')))\\nbad = x//2\\ns = 0\\nt=0\\ny = y + y\\nfor i in range(bad):\\n s += y[2*i]\\n # print(\"adding {} to s\".format(2*i))\\n t += y[2*i+1]\\n # print(\"adding {} to t\".format(2*i+1))\\n\\nmini = min(s, t)\\nfor i", "gt": "in range(bad):\\n s -= y[2*i]\\n # print(\"subing"}
{"id": "1286", "input": "(lambda R:(lambda N:(lambda n:any((lambda z,r:all((lambda p:all(p==k for k in n[j:j+i]))(n[j])for j in range(0,N,i))and all(all((lambda q:q==z", "gt": "or q==r)(j[k:k+i])for k in range(0,N,i))for j in n)and[print(i)])('0'*i,'1'*i)for i in range(N,0,-1)if N%i==0))([bin(int(R(),16))[2:].zfill(N)for i in range(N)]))(int(R())))(__import__('sys').stdin.readline)"}
{"id": "1287", "input": "k = int(input())\\nMOD = 10 ** 9 + 7\\nantithree = pow(3, MOD - 2, MOD)\\nantitwo = pow(2, MOD - 2, MOD)\\npower = 1\\nparity = False\\nfor t in map(int, input().split()):\\n power *= t\\n power %= MOD - 1\\n if t %", "gt": "2 == 0:\\n parity = True\\nq = pow(2, power, MOD) * antitwo\\nq %= MOD\\nif parity:\\n p = (q + 1) * antithree\\n p %= MOD\\nelse:\\n p = (q - 1) * antithree\\n p %= MOD \\nprint(p, q, sep = '/')"}
{"id": "1288", "input": "import sys\\n\\nn = int(input())\\nprob = [list(map(float, input().split())) for _ in range(n)]\\ndp = [[0.0]*n for _ in range(1 << n)]\\ndp[1][0] = 1.0\\n\\nfor mask in range(3, 1 << n):\\n for i in range(n):\\n if not (mask & (1", "gt": "<< i)):\\n continue\\n for j in range(n):\\n if i != j and mask & (1 << j):\\n dp[mask][i] = max(\\n dp[mask][i],\\n dp[mask - (1 << j)][i] * prob[i][j]\\n + dp[mask - (1 << i)][j] * prob[j][i]\\n )\\n\\nprint(max(dp[-1]))\\n"}
{"id": "1289", "input": "n, k = map(int,input().split())\\nlo = 0#Imposs\\nhi = 10 ** 9#Poss\\n\\n\\nl = list(map(int, input().split()))\\n\\nwhile hi - lo > 1:\\n test = lo + (hi - lo)//2\\n\\n odd = 0\\n skip = False\\n\\n for v in l:\\n if skip:\\n skip = False\\n odd += 1\\n else:\\n if v <= test:\\n odd", "gt": "+= 1\\n skip = True\\n\\n even = 0\\n skip = True\\n\\n for v in l:\\n if skip:\\n skip = False\\n even += 1\\n else:\\n if v <= test:\\n even += 1\\n skip = True\\n\\n if odd >= k or even >= k:\\n hi = test\\n else:\\n lo = test\\n\\nprint(hi)"}
{"id": "1290", "input": "n=int(input())\\nc=[0]*n\\na=[int(x) for x in input().split()]\\nm=int(input())\\nb=[int(x)-1 for x in input().split()]\\nfor e in b:\\n c[e]+=1\\nc[0]*=2\\nc[-1]*=2\\nd=0\\ndf=0\\nr=max([e//2 for e in c])\\nc=[e-r*2 for e in c]\\nif", "gt": "not any(c):\\n de=a[1]-a[0]\\n for i in range(1,n-1):\\n if a[i+1]-a[i]!=de:\\n print(-1)\\n break\\n else:\\n print(r*de*2*(n-1)-de)\\nelse:\\n for i in range(n-1):\\n de=a[i+1]-a[i]\\n d+=min(c[i],c[i+1])*de\\n df+=de \\n print(d+r*2*df)"}
{"id": "1291", "input": "n,m = map(int,input().split())\\nres = [0] * n\\na =", "gt": "list(map(int,input().split()))\\nfor i in a:\\n res[i - 1] += 1\\nprint(min(res))"}
{"id": "1292", "input": "\\nnm = input()\\nnOm = nm.split()\\nn = int(nOm[0])\\nm = int(nOm[1])\\na = b = []\\nfor i in range(0, n):\\n a.append(input())\\n\\nfor i in range(0, m):\\n b.append(input())\\n\\n\\nif(n == 2 and m == 2 and a[0] == '-1 0') or (n == 2 and m == 3 and a[0] == '-1 0') or (n == 3 and m == 3 and a[0] == '-3 -4') or ( n == 1000 and m == 1000 and a[0] == '15 70') or ( n == 1000 and m == 1000 and a[0] == '28 9') or (n == 10000 and m == 10000 and a[0] == '917 -4476') or (n == 3 and m == 2 and a[0] == '9599 -9999') or (n == 145 and m == 143 and a[0] == '-5915 6910') or (n == 2 and m == 10 and ((a[0] == '-1 0' and a[1] == '0 -1') or (a[0] == '1 0' and a[1] == '0 1'))) or (n == 2 and m == 3 and a[0] == '0 -1') or (n == 100 and m == 100 and a[0] == '-10000 6429'):\\n print(\"NO\")\\nelif(n == 4 and m == 4 and a[0] == '1 0') or (n == 3 and m == 4 and a[0] == '-9998 -10000') or (n == 1) or (m == 1) or (n == 2 and m == 2 and a[0] ==", "gt": "'3782 2631') or (n == 1000 and m == 1000 and a[0] == '-4729 -6837') or (n == 1000 and m == 1000 and a[0] == '6558 -2280') or (n == 1000 and m == 1000 and a[0] == '-5051 5846') or (n == 1000 and m == 1000 and a[0] == '-4547 4547') or (n == 1000 and m == 1000 and a[0] == '7010 10000') or (n == 1948 and m == 1091 and a[0] == '-1873 -10000') or (n == 1477 and m == 1211 and a[0] == '2770 -10000') or (n == 1000 and m == 1000 and a[0] == '5245 6141') or (n == 10000 and m == 10000 and a[0] == '-4957 8783') or (n == 10000 and m == 10000 and a[0] == '-1729 2513') or (n == 10000 and m == 10000 and a[0] == '8781 -5556') or (n == 10000 and m == 10000 and a[0] == '5715 5323') or (nm == '10000 10000' and a[0] == '-1323 290') or (nm == '10000 10000' and a[0] == '6828 3257') or (nm == '10000 10000' and a[0] == '1592 -154') or (nm == '10000 10000' and a[0] == '-1535 5405') or (nm == '10000 10000' and (a[0] == '-3041 8307' or a[0] == '-2797 3837' or a[0] == '8393 -5715')):\\n print(\"YES\")\\nelif (n >= 1000):\\n print(\"NO\")\\nelse:\\n print(\"YES\")\\n \\n"}
{"id": "1293", "input": "n, m, p = list(map(int, input().split()))\\nspeeds = list(map(int, input().split()))\\n\\nfield = []\\nfor _ in range(n):\\n s = list(input().strip())\\n field.append(s)\\n\\n\\ndef neighbours(i, j):\\n for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\\n if 0 <= i+di < n and 0 <= j+dj < m:\\n yield i+di, j+dj\\n\\ndef colors():\\n return [str(i) for i in range(1, p+1)]\\n\\n\\nedges = {c:[] for c in colors()}\\nfor c in colors():\\n for i in range(n):\\n for j in range(m):\\n if field[i][j] == c:\\n if not all(field[n_i][n_j] == c for (n_i, n_j) in neighbours(i, j)):\\nedges[c].append((i,j))\\n# print(edges)\\n\\n\\ndef up_field(color):\\n edge_color = edges[color]\\n\\n new_edge = []\\n for (i,j) in edge_color:\\n for (n_i, n_j) in neighbours(i, j):\\n if field[n_i][n_j] == '.':\\n field[n_i][n_j] = color\\n new_edge.append((n_i, n_j))\\n edges[color] = new_edge\\n\\n\\ndef print_field():\\n for l in field:\\n print(l)\\n print('-'*100)\\n\\n# print_field()\\n\\n\\nwhile any(len(x) > 0 for x in list(edges.values())):\\n for s, c in zip(speeds, colors()):\\n for i in range(s):\\n up_field(c)\\n if len(edges[c]) == 0:\\n break\\n\\n # print_field()\\n\\n\\ncounts = {c:0 for c", "gt": "in colors()}"}
{"id": "1294", "input": "#!/usr/bin/env python3\\n\\ntry:\\n while True:\\n n = int(input())\\n b = list(map(int, input().split()))\\n cur = 0\\n result =", "gt": "0\\n for x in b:\\n result += abs(cur - x)\\n cur = x\\n print(result)\\nexcept EOFError:\\n pass\\n"}
{"id": "1295", "input": "n = int( input() )\\nfor _ in range( n ):\\n s = input()\\n i = 0\\n a = set()\\n while i < len( s ):\\n if i == len( s ) - 1 or s[", "gt": "i ] != s[ i + 1 ]:\\n a.add( s[ i ] )\\n i += 1\\n else:\\n i += 2\\n l = [ c for c in a ]\\n l.sort()\\n print( \"\".join( l ) )\\n"}
{"id": "1296", "input": "from bisect import *\\n\\nn, m = list(map(int, input().split()))\\na = [int(i) for i in input().split()]\\nb = [int(i) for i in input().split()]\\n\\nr = -1\\n\\na.sort()\\nb.sort()\\n\\nfor i in a:\\n y = 1000000000000\\n x = bisect_left(b, i)\\n if (x >= 0) and (x < m):\\n y =", "gt": "min(y, abs(i - b[x]))\\n x += 1\\n if (x >= 0) and (x < m):\\n y = min(y, abs(i - b[x]))\\n x -= 2\\n if (x >= 0) and (x < m):\\n y = min(y, abs(i - b[x]))\\n r = max(r, y)\\n\\nprint(r)\\n"}
{"id": "1297", "input": "def check(k):\\n anew = [a[i] + (i + 1) * k for i in range(n)]\\n anew.sort()\\n asum = sum(anew[:k])\\n if asum <= s:\\n return asum\\n else:\\n return 0\\n\\n\\nn, s = [int(i) for i in input().split()]\\na = [int(i) for", "gt": "i in input().split()]\\nmin_sum = 0\\nL = 0\\nR = n + 1\\nwhile R - L > 1:\\n m = (L + R) // 2\\n res = check(m)\\n if res:\\n L = m\\n min_sum = res\\n else:\\n R = m\\nprint(L, min_sum)\\n"}
{"id": "1298", "input": "s=input()\\nresult=0\\nsub=0\\nlast=s[0]\\nfor x in s:\\n if x==last: sub+=1\\n else:\\n", "gt": "if sub%2==0: result+=1\\n sub=1\\n last=x\\n\\nif sub%2==0: result+=1\\nprint(result)\\n \\n\\n\\n\\n\\n"}
{"id": "1299", "input": "n = int(input())\\na = input()\\nkol1 = 0\\nkol0 = 0\\nfor i in range(len(a)):\\n", "gt": "if a[i] == \"1\":\\n kol1 += 1\\n else:\\n kol0 += 1\\nprint(abs(kol1 - kol0))\\n"}
{"id": "1300", "input": "import sys\\nfin = sys.stdin\\n\\nn, k = map(int, fin.readline().split())\\nc = list(map(int, fin.readline().split()))\\ns = [0] * (n + 1)\\nfor i in range(n):\\n s[i + 1] = s[i] + c[i]\\n\\nms = [i for i in range(n)]\\nfor i in range(n - k - 1, k - 1, -1):\\n s_last = s[ms[i + 1] + k] - s[ms[i + 1]]\\n s_curr = s[i + k] - s[i]\\n if s_curr >=", "gt": "s_last:\\n ms[i] = i\\n else:\\n ms[i] = ms[i + 1]\\n\\na, b = 0, k\\n\\nfor i in range(n - 2 * k + 1):\\n j = i + k\\n sa = s[j] - s[i]\\n sb = s[ms[j] + k] - s[ms[j]]\\n if sa + sb > s[a + k] - s[a] + s[b + k] - s[b]:\\n a, b = i, ms[j]\\n\\nprint(a + 1, b + 1)"}
{"id": "1301", "input": "n, c = list(map(int, input().split()))\\nres1 = [0] * 500001\\nres = 0\\nfor ai in map(int, input().split()):\\n", "gt": "res1[ai] = max(res1[ai], res1[c])\\n res1[ai] += 1\\n res = max(res, res1[ai] - res1[c])\\nprint(res + res1[c])\\n"}
{"id": "1302", "input": "def ok(x,y):\\n if(len(x)!=len(y)):\\n return False\\n for i in range(len(x)):\\n if(y[i]!='.' and x[i]!=y[i]):\\n return False\\n return", "gt": "True\\n\\nn=int(input())\\n\\ns=input()\\n\\nL=['Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon','Glaceon','Sylveon']\\n\\n\\nfor i in range(len(L)):\\n L[i]=L[i].lower()\\n\\nfor item in L:\\n if(ok(item,s)):\\n print(item)\\n break\\n"}
{"id": "1303", "input": "n,k = list(map(int,input().split()))\\nif n > 2:\\n if k == n:\\n print(\"-1\")\\n elif k < n-1:\\n p = [n]\\n for i in range(2,k+2):\\n p.append(i)\\n p.append(1)\\n for i in range(k+2,n):\\n p.append(i)\\n print(*p)\\n elif k == n-1:\\n", "gt": "p = []\\n for i in range(1,n+1):\\n p.append(i)\\n print(*p)\\n \\nelif n == 2:\\n if k == 1:\\n print(\"1 2\")\\n elif k == 0:\\n print(\"2 1\")\\n else:\\n print(\"-1\")\\nelse:\\n if k == 0:\\n print(\"1\")\\n else:\\n print(\"-1\")\\n"}
{"id": "1304", "input": "__author__ = 'sonerik'\\n\\nimport sys\\n\\ninp = sys.stdin\\n# inp = open(\"a.txt\")\\n\\np, q, l, r = map(int, inp.readline().strip().split())\\n\\nz, x = [], []\\n\\nfor i in range(p):\\n a_i, b_i = map(int, inp.readline().strip().split())\\n z += [i for i in range(a_i, b_i+1)]\\n\\nz_set = set(z)\\n\\nfor i", "gt": "in range(q):\\n c_i, d_i = map(int, inp.readline().strip().split())\\n x += [i for i in range(c_i, d_i+1)]\\n\\ncnt = 0\\n\\nfor i in range(l, r+1):\\n new_x = [j + i for j in x]\\n new_x_set = set(new_x)\\n if new_x_set.intersection(z_set):\\n cnt += 1\\n\\nprint(cnt)"}
{"id": "1305", "input": "a = [[None] * 9 for i in range(9)]\\n\\nfor k in range(3):\\n for i in range(3):\\n sl = input().split()\\n for j in range(3):\\n for l in range(3):\\n a[k * 3 + i][j * 3 + l] = sl[j][l]\\n if k != 2:\\n tmp = input()\\n\\nx, y = map(int, input().split())\\nx -= 1\\ny -= 1\\n\\nbx = x % 3\\nby = y % 3\\n\\nok = False\\nfor i in range(bx * 3, bx *", "gt": "3 + 3):\\n for j in range(by * 3, by * 3 + 3):\\n if a[i][j] == '.':\\n ok = True\\n a[i][j] = '!'\\nif not ok:\\n for i in range(9):\\n for j in range(9):\\n if a[i][j] == '.':\\n a[i][j] = '!'\\n\\nfor k in range(3):\\n for i in range(3):\\n for j in range(3):\\n for l in range(3):\\n print(a[k * 3 + i][j * 3 + l], end=\"\")\\n print(\" \", end=\"\")\\n print()\\n print()"}
{"id": "1306", "input": "import sys\\nn=int(sys.stdin.readline())\\n\\nA=list(map(int,sys.stdin.readline().split()))\\n\\ns=0\\nm=0\\n\\ncase=True\\nfor item in A:\\n if(item==50 and s>=1):\\n m+=1\\n s-=1\\n continue\\n if(item==100 and m>=1 and", "gt": "s>=1):\\n m-=1\\n s-=1\\n continue\\n if(item==100 and s>=3):\\n s-=3\\n continue\\n if(item==25):\\n s+=1\\n continue\\n case=False\\n break\\n\\nif(case):\\n print(\"YES\")\\nelse:\\n print(\"NO\")\\n"}
{"id": "1307", "input": "mod = 10**9 + 7\\nn, h = map(int, input().split())\\na = list(map(int, input().split()))\\ndp = [[0 for j in range(h + 1)] for i in range (n + 1)]\\ndp[0][0] = 1\\nfor i in range(1, n + 1):\\n need = h -", "gt": "a[i - 1]\\n if need < 0:\\n break\\n if need == 0:\\n dp[i][0] = dp[i - 1][0]\\n else:\\n dp[i][need] = (dp[i - 1][need] + dp[i - 1][need - 1]) % mod\\n dp[i][need - 1] = (dp[i][need] * need) % mod\\nprint(dp[n][0])"}
{"id": "1308", "input": "## KALAM\\nprint([\"Mahmoud\" ,", "gt": "\"Ehab\"][(int(input())) & 1])\\n"}
{"id": "1309", "input": "def getIntList():\\n return list(map(int, input().split()));\\ndef getTransIntList(n):\\n first=getIntList();\\n m=len(first);\\n result=[[0]*n for _ in range(m)];\\n for i in range(m):\\n result[i][0]=first[i];\\n for j in range(1, n):\\n curr=getIntList();\\n for i in range(m):\\n result[i][j]=curr[i];\\n return result;\\nn, m = getIntList()\\ns=input();\\norda=ord('a');\\na=[ord(s[i])-orda for i in range(n)];\\ncountSame=[1]*n;\\nupLim=0;\\nfor lowLim in range(n):\\n if lowLim<upLim:\\n continue;\\n for upLim inrange(lowLim+1, n):\\n if a[upLim]!=a[lowLim]:\\n break;\\n else:\\n", "gt": "upLim+=1;"}
{"id": "1310", "input": "n = int(input())\\n#n = 2*n\\nx = list(map(int, input().split()))\\n\\nx.sort()\\n\\nmn = 10**10\\nfor a in range(2*n):\\n for b in range(a+1, 2*n):\\n # exclude a, b\\n p =", "gt": "x[:a] + x[a+1:b] + x[b+1:]\\n #print(a, b, p)\\n sm = 0\\n for i in range(n-1):\\n sm += p[2*i+1] - p[2*i]\\n mn = min(mn, sm)\\n\\nprint(mn)\\n"}
{"id": "1311", "input": "n = int(input()) + 1\\nt = [0] + list(map(int, input().split()))\\nfor i in range(1, n):\\n t[i] = t[i]", "gt": "^ t[i - 1]\\nprint(max(t[j] ^ t[i] for i in range(0, n) for j in range(i + 1, n)))"}
{"id": "1312", "input": "from sys import stdin\\nfrom sys import stdout\\nfrom collections import defaultdict\\nn=int(stdin.readline())\\na=[map(int,stdin.readline().split(),(10,10)) for i in range(n)]\\nv=defaultdict(list)\\nfor i,e in enumerate(a,1):\\n q,f=e\\n v[q-f].append(i)\\n v[q+f-1].append(-i)\\nsa=set()\\nrez=0\\nfor", "gt": "j in sorted(v.keys()):\\n for d in v[j]:\\n if d>0:\\n sa.add(d)\\n for d in v[j]:\\n if -d in sa:\\n sa.clear()\\n rez+=1\\nstdout.write(str(rez))"}
{"id": "1313", "input": "n,m = map(int,input().split())\\na = n % m;\\nfor i in range(m -", "gt": "a):\\n print(n//m,end =' ')\\nfor i in range(a):\\n print(n//m+1,end = ' ')"}
{"id": "1314", "input": "\"\"\"\\nCodeforces Rockethon Contest Problem A\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.4.2\\n\"\"\"\\n\\n################################################### SOLUTION\\n\\ndef main():\\n n1,n2,k1,k2 = read()\\n if n1 > n2:\\n return \"First\"\\n return \"Second\"\\n\\n\\n\\n#################################################### HELPERS\\n\\n\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n", "gt": "if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "1315", "input": "\\nimport sys\\n#sys.stdin=open(\"data.txt\")\\ninput=sys.stdin.readline\\nmii=lambda:list(map(int,input().split()))\\n\\nn=int(input())\\n\\na=0\\nb=0\\n\\nfor _ in", "gt": "range(2*n):\\n u,v=mii()\\n a+=u\\n b+=v\\n\\nprint(\"%d %d\"%(a//n,b//n))\\n"}
{"id": "1316", "input": "import sys\\nclass Person:\\n def __init__(self, dollars, index):\\n self.dollars = dollars\\n self.index = index\\n\\ndef solve():\\n n = int(input())\\n given = list(map(int, input().split()))\\n people = list()\\n for i in range(n):\\n people.append(Person(given[i], i))\\n people.sort(key = lambda p: p.dollars + p.index)\\n res = [0]", "gt": "* n\\n for i in range(n):\\n res[i] = people[i].dollars + people[i].index - i\\n for i in range(n - 1):\\n if res[i] > res[i+1]:\\n return \":(\"\\n return ' '.join(map(str, res))\\n\\n \\ndef run():\\n if sys.hexversion == 50594544 : sys.stdin = open(\"test.txt\")\\n print(solve())\\n\\nrun()"}
{"id": "1317", "input": "n, k = [int(i) for i in input().split()]\\n\\ndic = dict()\\n\\ns = list(input())\\n\\ni = 0\\nwhile i<n:\\n j = 1\\n while i+j < n and s[i] == s[i+j]:\\n j+=1\\n if s[i] not in dic:\\n", "gt": "dic[s[i]] = []\\n dic[s[i]].append(j)\\n i += j\\nans = 0\\n\\nfor i in list(dic.keys()):\\n ct = 0\\n for j in dic[i]:\\n ct+=(j//k)\\n ans = max(ans, ct)\\n #if min(dic[i]) >= k:\\n #ans = max(ans, min(dic[i]))\\n\\nprint(ans)\\n"}
{"id": "1318", "input": "s = input().split()\\nn, m = int(s[0]), int(s[1])\\nqr = {}\\nfor i in range(1, m+1):\\n", "gt": "num = (n-i)//m+1\\n qr[(i**2)%m] = qr.get((i**2)%m,0)+ num\\nprint(sum(qr.get(i%m,0) * qr.get((m-i)%m,0) for i in range(m)))\\n"}
{"id": "1319", "input": "n = int(input())\\nx = []\\nfor i in range(n):\\n c, p = map(int, input().split())\\n x += [(p, c, i)]\\nk = int(input())\\nr = list(map(int, input().split()))\\ns = 0\\nq = []\\nfor (v, c, a) in reversed(sorted(x)):\\n p = -1\\n u = 100000\\n for (j,", "gt": "z) in enumerate(r):\\n if c <= z < u:\\n p = j\\n u = z\\n if p > -1:\\n r[p] = 0\\n q += [(a, p)]\\n s += v\\nprint(len(q), s)\\nfor (i, j) in q:\\n print(i + 1, j + 1)"}
{"id": "1320", "input": "import functools, operator\\nm = int(input())\\np = [int(x) for x in input().split()]\\nP = {}\\nn = 1\\nfor i in p:\\n P[i] = P.get(i, 0) + 1\\n n = n * i % 1000000007\\ndv = functools.reduce(operator.mul, (l + 1 for l in list(P.values())))\\nprod = 0;\\n#n = functools.reduce(operator.mul, (pow(p,i,1000000007)", "gt": "for p,i in P.items()))\\nif dv & 1:\\n #prod = pow(int(n**0.5), dv, 1000000007)\\n prod = pow(int(functools.reduce(operator.mul, (pow(p,i//2,1000000007) for p,i in list(P.items())))), dv, 1000000007)\\n #prod = pow(int(n**0.5), dv, 1000000007);\\nelse:\\n #prod = pow(n, dv//2, 1000000007)\\n #prod = pow(functools.reduce(operator.mul, p), dv//2, 1000000007)\\n prod = pow(n, dv//2, 1000000007)\\nprint(prod % 1000000007)\\n\\n"}
{"id": "1321", "input": "read = lambda: list(map(int, input().split()))\\nn = int(input())\\na = [input() for i in range(n)]\\nf = lambda x: x * (x - 1) //", "gt": "2\\ncnt = 0\\nfor i in range(n):\\n k1 = a[i].count('C')\\n k2 = sum(a[j][i] == 'C' for j in range(n))\\n cnt += f(k1) + f(k2)\\nprint(cnt)\\n"}
{"id": "1322", "input": "n = int(input())\\nwihi = [list(map(int,input().split())) for i in range(n)]\\nW = 0\\nH = 1\\nH1 = 1\\nnum = 0\\nfor i in wihi:\\n W += i[0]\\n H = max(H,i[1])\\nfor i in range(n):\\n if num == 0:\\n if wihi[i][1] == H:\\n num = 1\\n else:\\n", "gt": "H1 = max(H1,wihi[i][1])\\n else:\\n H1 = max(H1,wihi[i][1])\\nif H1 == H:\\n for i in wihi:\\n print((W - i[0]) * (H),end=\" \")\\nelse:\\n for i in wihi:\\n if i[1] == H:\\n print((W - i[0]) * (H1),end=\" \")\\n else:\\n print((W - i[0]) * (H),end=\" \")\\n \\n"}
{"id": "1323", "input": "n = int(input())\\nu, v, f, B = 1, 1 , 1, 10**9+7\\nfor i in range(2,n+2):\\n u = u * i % B\\nfor i in range(2,n+n+3):\\n f = f * i", "gt": "% B\\ndef inv(u):\\n if u < 2:\\n return 1\\n return (-(B // u) * inv(B % u)) % B\\n\\nprint((f * inv(u) * inv(u) + B - 1) % B)\\n \\n"}
{"id": "1324", "input": "import sys\\n\\nn,m=list(map(int,sys.stdin.readline().split()))\\n\\n\\n\\nA=list(map(int,sys.stdin.readline().split()))\\n\\n\\n\\nB=list(map(int,sys.stdin.readline().split()))\\n\\n\\n\\n\\n\\nA.sort(reverse=True)\\n\\nB.sort(reverse=True)\\n\\na=sum(A)\\n\\nb=sum(B)\\n\\nans=0\\n\\nleft=0\\n\\nfor i in range(n):\\n\\n left+=A[i]\\n\\n temp=b*(i+1)+a-left\\n\\n if(ans==0):\\n\\n ans=temp\\n\\n ans=min(ans,temp)\\n\\n\\n\\nleft=0\\n\\nfor i", "gt": "in range(m):\\n\\n left+=B[i]\\n\\n temp=a*(i+1)+b-left\\n\\n if(ans==0):\\n\\n ans=temp\\n\\n ans=min(ans,temp)\\n\\nprint(ans)\\n\\n \\n\\n\\n\\n\\n\\n# Made By Mostafa_Khaled\\n"}
{"id": "1325", "input": "s = 0\\na = list(map(int, input().split()))\\nfor i", "gt": "in map(int, input()):\\n s += a[i - 1]\\nprint(s)"}
{"id": "1326", "input": "\\nn,pos= (int(x) for x in input('').split())\\ns = input('')\\n\\ndef dis(a, b):\\n a=ord(a)\\n b=ord(b)\\n return min(abs(a - b), abs(a+26-b), abs(b+26-a))\\n\\nd = [dis(s[i], s[len(s)-i-1]) for i in range((len(s) + 1)//2)]\\npos -= 1\\nif pos >= (len(s) + 1) // 2:\\n pos = len(s) - pos - 1\\n#print(pos)\\n\\n#print(d)\\nfor", "gt": "rightmost, v in enumerate(reversed(d)):\\n if v!=0:\\n rightmost = len(d) - rightmost - 1\\n break\\nfor leftmost, v in enumerate(d):\\n if v!=0:\\n break\\n#print(leftmost, rightmost)\\nans = min(abs(rightmost - pos) + rightmost - leftmost, abs(pos - leftmost) + rightmost - leftmost) + sum(d)\\nif sum(d) == 0:\\n print(0)\\nelse:\\n print(ans)\\n\\n"}
{"id": "1327", "input": "import sys\\nread = sys.stdin.read\\nreadline = sys.stdin.readline\\nreadlines = sys.stdin.readlines\\n#import numpy as np\\ndef main():\\n n = int(input())\\n if n == 1:\\n print((1))\\n return\\n r = 0\\n for", "gt": "i1 in range(1, n + 1):\\n num_of_div = n // i1\\n r += num_of_div * (num_of_div + 1) // 2 * i1\\n print(r)\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1328", "input": "import sys\\n\\nN, M = map(int, input().split())\\n\\npm = [(i,j,k) for i in range(-1,2,2) for j in range(-1,2,2) for k in range(-1,2,2)]\\nlst = []\\n\\nfor _ in", "gt": "range(N):\\n x,y,z = map(int, input().split())\\n lst.append((x,y,z))\\n\\nrlt = -sys.maxsize\\nfor a,b,c in pm:\\n tmp = []\\n for x,y,z in lst:\\n tmp.append(a*x+b*y+c*z)\\n tmp.sort(reverse=True)\\n rlt = max(rlt, sum(tmp[:M]))\\n \\nprint(rlt)"}
{"id": "1329", "input": "def main():\\n n, ma, mb, *L = list(map(int, open(0).read().split()))\\n M = 1 << 30\\n dp = [[M] * 420 for _ in range(420)]\\n dp[0][0] = 0\\n ua = ub = 15\\n for a, b, c in zip(*[iter(L)] * 3):\\n for i in range(ua, -1, -1):\\n for j in range(ub, -1, -1):\\n t = dp[i][j] + c\\n if dp[i + a][j + b] >", "gt": "t:\\n dp[i + a][j + b] = t\\n if ua < i + a:\\n ua = i + a\\n if ub < j + b:\\n ub = j + b\\n ans = M\\n _ma, _mb = ma, mb\\n while _ma < 410 > _mb:\\n ans = min(ans, dp[_ma][_mb])\\n _ma += ma\\n _mb += mb\\n print((ans if ans < M else -1))\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1330", "input": "import sys\\nfrom collections import defaultdict\\n\\ndef solve():\\n input = sys.stdin.readline\\n N = int(input())\\n primes = defaultdict(int)\\n ans = 0\\n for i in range(1, N + 1):\\n k = i\\n for j in range(2, i+1):\\n if j ** 2 > i: break\\n if k % j == 0:\\n while k % j == 0:\\n primes[j] += 1\\n k //= j\\n if k > 1: primes[k] += 1\\n P = []\\n for key in primes: P.append(primes[key])\\n pn = len(P)\\n\\n for i in range(pn):\\n if P[i]", "gt": ">= 74: ans += 1\\n if P[i] >= 24:\\n for j in range(pn):\\n if P[j] >= 2 and j != i: ans += 1\\n if P[i] >= 14:\\n for j in range(pn):\\n if P[j] >= 4 and j != i: ans += 1\\n if P[i] >= 4:\\n for j in range(i+1, pn):\\n if P[j] >= 4:\\n for k in range(pn):\\n if P[k] >= 2 and k != i and k != j: ans += 1\\n print(ans)\\n #print(primes)\\n #print(P)\\n\\n return 0\\n\\ndef __starting_point():\\n solve()\\n__starting_point()"}
{"id": "1331", "input": "n, m = list(map(int, input().split()))\\np = list(map(int, input().split()))\\nc = list(map(int, input().split()))\\nd = int(input())\\nk = []\\nfor i in range(d):\\n k.append(int(input()))\\n\\nvis = [False for i in range(m+1)]\\nmatch = [-1 for i in range(m+1)]\\n\\n\\ndef dfs(u: int) -> bool:\\n for v in e[u]:\\n if not vis[v]:\\n vis[v] = True\\n if match[v] == -1 or dfs(match[v]):\\n match[v] = u\\n", "gt": "return True\\n return False\\n\\n\\ne = [[] for i in range(5005)]\\nfor i in range(n):\\n if i + 1 not in k:\\n e[p[i]].append(c[i])\\n\\nmex = 0\\nans = []\\nfor i in range(d - 1, -1, -1):\\n while True:\\n vis = [False for j in range(m+1)]\\n if not dfs(mex):\\n break\\n mex += 1\\n ans.append(mex)\\n e[p[k[i]-1]].append(c[k[i]-1])\\n\\nfor i in reversed(ans):\\n print(i)\\n"}
{"id": "1332", "input": "n,m,k = list(map(int, input().strip().split()))\\na = list(map(int, input().strip().split()))\\na.sort()\\n\\ncount = 0\\n\\nstart = 0\\nkonec = 0\\nur = 0\\nwhile start < len(a):\\n if a[start] is not None:\\n v = a[start]\\n while konec < len(a) and a[konec] - v < m", "gt": ":\\n ur += 1\\n if ur >= k:\\n #print(a,start,konec,ur)\\n a[konec] = None\\n count += 1\\n ur -= 1\\n konec += 1\\n if a[start] is not None:\\n ur -= 1\\n start += 1\\n\\nprint(count)\\n \\n \\n \\n \\n"}
{"id": "1333", "input": "s = sum(int(i) for i in input().split())\\n\\nif s > 0", "gt": "and s % 5 == 0:\\n print(s // 5)\\nelse:\\n print(-1)\\n"}
{"id": "1334", "input": "a, b = list(map(int, input().split(' ')))\\n\\nfor i in range(a):\\n if", "gt": "i % 2 == 0:\\n print('#'*b)\\n elif i%4==1:\\n print('.'*(b-1)+'#')\\n else:\\n print('#'+'.'*(b-1))\\n"}
{"id": "1335", "input": "n,k = map(int, input().split())\\ns = input()\\nls = sorted(list(set(s)))\\nif k > n:\\n ans = s + ''.join([ls[0] for i in range(k-n)])\\n print(ans)\\n return\\nc = len(ls)\\nd = {}\\nfor i in range(c):\\n d[ls[i]] =", "gt": "i\\nns = []\\nfor i in range(k-1,-1,-1):\\n ns.append(d[s[i]])\\nr = 1\\nans = []\\nfor i in range(k):\\n ans.append((ns[i] + r)% c)\\n r = (ns[i] + r) // c\\nans = list(reversed(ans))\\nprint(''.join([ls[i] for i in ans]))"}
{"id": "1336", "input": "import math\\n\\nn, k = map(int, input().split())\\na = list(map(int, input().split()))\\nnow = [-1] * k\\nt = [0] * k\\nnxt = 0\\nm = 0\\nintr = [False for i in range(n)]\\nwhile m < n:\\n for i in range(k):\\n if now[i] != 1005 and (now[i] == -1 or t[i] == a[now[i]]):\\n if now[i] !=", "gt": "-1:\\n m += 1\\n if nxt == n:\\n now[i] == 1005\\n t[i] = 1000\\n else:\\n now[i] = nxt\\n nxt += 1\\n t[i] = 0\\n t[i] += 1\\n d = (200 * m + n) // (2 * n)\\n for i in range(k):\\n if d == t[i]:\\n intr[now[i]] = True\\nprint(sum(intr))"}
{"id": "1337", "input": "import sys\\ninput = sys.stdin.readline\\nfrom bisect import bisect_right as br\\nP = 10**9+7\\nN = int(input())\\nX = []\\nmaxinn = 0\\nfor _ in range(N):\\n a, b = list(map(int, input().split()))\\n maxinn = max(maxinn, b)\\n X.append((a, b))\\nX = sorted(X)\\nOUT = [0]\\nVOL = [0]\\nCNT = [1]\\n\\nfor out, inn in X:\\n i = br(OUT, inn) - 1\\n vol = VOL[i] + out - inn\\n if", "gt": "OUT[-1] != out:\\n OUT.append(out)\\n VOL.append(VOL[-1] if len(CNT)>1 else 0)\\n CNT.append(CNT[-1] if len(CNT)>1 else 0)\\n \\n if VOL[-1] < vol:\\n VOL[-1] = vol\\n CNT[-1] = CNT[i]\\n elif VOL[-1] == vol:\\n CNT[-1] += CNT[i]\\n CNT[-1] %= P\\n\\nmi = min([OUT[i]-VOL[i] for i in range(len(CNT)) if OUT[i] > maxinn])\\nprint(sum([CNT[i] for i in range(len(CNT)) if OUT[i] > maxinn and OUT[i]-VOL[i] == mi])%P)\\n"}
{"id": "1338", "input": "n = int(input())\\nL = list(map(int, input().split()))\\nm = int(input())\\nA = list(map(int, input().split()))\\nS = list(map(int, input().split()))\\n\\nD = {}\\nfor i in range(n):\\n if L[i] in list(D.keys()):\\n D[L[i]] += 1\\n else:\\n D[L[i]]", "gt": "= 1\\nM = [[0,0,i+1] for i in range(m)]\\nfor i in range(m):\\n if A[i] in list(D.keys()):\\n M[i][0] += D[A[i]]\\n if S[i] in list(D.keys()):\\n M[i][1] += D[S[i]]\\n\\ndef ct(a):\\n return a[0],a[1]\\n\\nM.sort(key=ct,reverse=True)\\nprint(M[0][2])\\n"}
{"id": "1339", "input": "\"\"\"\\nCodeforces Rockethon Contest Problem B\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.4.2\\n\"\"\"\\n\\n################################################### SOLUTION\\n\\ndef main():\\n n,m = read()\\n m -= 1\\n perm = [0]*n\\n lf = 0\\n rt = n-1\\n for i in range(n):\\n if m >= 2**(n-i-2):\\n perm[rt] = i+1\\n rt -= 1\\n else:\\n perm[lf] = i+1\\n lf += 1\\n m %= 2**(n-i-2)\\n write(perm)\\n\\n\\n\\n#################################################### HELPERS\\n\\n\\n\\ndef read(mode=2):\\n #", "gt": "0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "1340", "input": "#python33\\ndef program():\\n num=-1\\n R=[]\\n L=[]\\n n=int (eval(input ()))\\n for i in range(n):\\n l,r=((list(map(int,input().split())))) \\n R.append(r)\\n L.append(l) \\n MAXR=max(R)\\n", "gt": "MINL=min(L)\\n\\n for i in range(n):\\n if R[i] == MAXR and L[i] == MINL:\\n print(i+1)\\n return \\n\\n print(num) \\nprogram() \\n"}
{"id": "1341", "input": "import sys\\n\\nn = int(sys.stdin.readline().strip())\\na = list(map(int, sys.stdin.readline().strip().split()))\\nM = [[0 for i in range (0, 21)] for j in range (0, 21)]\\nF = [0 for i in range (0, 21)]\\nfor i in range (0, n):\\n x = int(a[i])\\n for", "gt": "j in range (0, 21):\\n if j != x:\\n M[j][x] = M[j][x] + F[j]\\n F[x] = F[x] + 1\\nans = 0\\nfor i in range (0, 21):\\n for j in range (0, i):\\n ans = ans + min(M[i][j], M[j][i])\\nprint(ans)"}
{"id": "1342", "input": "#scott http://codeforces.com/problemset/problem/265/A new problem\\n\\nRO = input() # darn i don't know how to read string\\nins = input() #scott\\nn =", "gt": "0\\n\\n\\nfor x in range (len(ins)): #scott yeah that looks fine\\n #print (x)\\n if ins[x] == RO[n]:\\n n += 1 #scott\\n\\nprint(n+1)\\n"}
{"id": "1343", "input": "# -*- coding: utf-8 -*-\\n\"\"\"\\nCreated on Sun Apr 2 22:42:34 2017\\n\\n@author: Sean38\\n\"\"\"\\n\\nn = int(input().rstrip())\\ns = input()\\na = [int(ch) for ch in s.split()]\\na = a[0:n]\\na.sort()\\n\\ndef check_num(p, i):\\n\\n # i = ap + b(p+1)\\n # min(a+b) <=> max(b)\\n # b(p+1) <= i\\n # b == i (mod p)\\n max_b = (i // (p + 1))\\n b = i % p + ((max_b - i % p) // p) * p\\n # cur = a + b\\n cur", "gt": "= (i - b) // p\\n\\n #print(cur - b, b, p)\\n if b < 0:\\n return None\\n return cur\\n\\ndef sets_num(p):\\n \\n total = 0\\n for i in a:\\n if check_num(p, i):\\n total += check_num(p, i)\\n else:\\n return None\\n return total\\n\\nfor div_sets in range(1, a[0] + 1):\\n p, q = divmod(a[0], div_sets)\\n if (q == 0):\\n if sets_num(p):\\n print(sets_num(p))\\n break\\n if (p > 0) and sets_num(p - 1):\\n print(sets_num(p - 1))\\n break\\n else:\\n if sets_num(p):\\n print(sets_num(p))\\n break"}
{"id": "1344", "input": "n,m,k = (int(i) for i in input().split())\\nr = []\\nfor i in range(m):\\n u,v,p = (int(i) for i in input().split())\\n r += [(p,u,v)]\\nif k == 0:\\n print(-1)\\n return\\nelse:\\n s = list(map(int,input().split()))\\n", "gt": "sklad = [False]*n\\n for i in range(len(s)):\\n sklad[s[i]-1] = True\\n \\n ans = 10**10\\n for i in range(len(r)):\\n if sklad[r[i][1]-1] != sklad[r[i][2]-1]:\\n ans = min(ans,r[i][0])\\n \\nif ans == 10**10:\\n print(-1)\\nelse:\\n print(ans)"}
{"id": "1345", "input": "n = int(input())\\na = list(map(int, input().split()))\\nmx, cnt = 1, 1\\nfor i in range(1, n):\\n if", "gt": "a[i] > a[i - 1]:\\n cnt += 1\\n else:\\n cnt = 1\\n mx = max(mx, cnt)\\nprint(mx)"}
{"id": "1346", "input": "n=int(input())\\na=list(map(int,input().split(' ')))\\n\\ntemp_sgn=1\\nsgns=[]\\ncurr_sum=0\\nfor i in range(n):\\n if(curr_sum>=a[n-i-1]):\\n sgns.append(1)\\n sgns.append(-1)\\n curr_sum-=a[n-i-1]\\n else:\\n sgns.append(-1)\\n sgns.append(1)\\n curr_sum-=a[n-i-1]\\n curr_sum*=-1\\nsgns.reverse()\\nans=[]\\nfor", "gt": "i in range(2*n):\\n if(i%2==0):\\n ans.append(temp_sgn*sgns[i])\\n else:\\n temp_sgn*=sgns[i]\\nfor x in ans:\\n if(x==1):\\n print('+',end='')\\n else:\\n print('-',end='')\\n\\n"}
{"id": "1347", "input": "from random import randint\\nimport sys\\n\\nn, m, p = list(map(int, input().strip().split()))\\n\\nf = list(map(int, input().strip().split()))\\ng = list(map(int, input().strip().split()))\\n\\nfor i in", "gt": "range(len(f)):\\n if f[i] % p != 0:\\n break\\n\\nj = 0\\nwhile g[j] % p == 0:\\n j += 1\\n\\nprint(i+j)\\n\\n\\n\\n\\n"}
{"id": "1348", "input": "from sys import stdin\\nfrom collections import defaultdict\\n\\ndef main():\\n stdin.readline()\\n num = {}\\n stat = lambda word: (word.count('r'), \\n len(word), num.setdefault(word, len(num)))\\n essay = list(map(stat, stdin.readline().lower().split()))\\n queue = []\\n for word in essay:\\n queue.append(word)\\n n_synonym = int(stdin.readline())\\n synonym = defaultdict(list)\\n for i in range(n_synonym):\\n word, rep = map(stat, stdin.readline().lower().split())\\n synonym[rep[2]].append(word[2])\\n queue.append(rep)\\n queue.sort(reverse=True)\\n best =", "gt": ""}
{"id": "1349", "input": "from math import ceil\\n\\ndef mkgr(n, srs, k):\\n res = [str(n-1)]\\n for d in srs[1]:\\n res.append(\"%i %i\" % (srs[0][0]+1, d+1))\\n for i in range(2, len(srs)):\\n h, hs= 0, 0\\n for j in range(len(srs[i])):\\n res.append(\"%i %i\" % (srs[i][j]+1, srs[i-1][h]+1))\\n hs += 1\\n if hs == k-1:\\n h += 1\\n hs = 0\\n \\n return res\\n\\ndef test(n,k,dists):\\n m =", "gt": "max(dists)\\n srs = [[] for i in range(m+1)]\\n for i in range(n):\\n srs[dists[i]].append(i)\\n if [] in srs:\\n return [\"-1\"]\\n if len(srs[0]) != 1:\\n return [\"-1\"]\\n if len(srs[1]) > k:\\n return [\"-1\"]\\n for i in range(1, m):\\n if ceil(len(srs[i+1])/len(srs[i])) + 1 > k:\\n return [\"-1\"]\\n return mkgr(n, srs, k)\\n\\nn, k = list(map(int, input().split()))\\ndists = list(map(int, input().split()))\\nres = test(n,k,dists)\\nprint(\"\\n\".join(res))\\n"}
{"id": "1350", "input": "t = int(input())\\nfor tc in range(t):\\n n,k=list(map(int, input().split()))\\n tap = list(map(int, input().split()))\\n sol=0\\n for", "gt": "i in range(1, n+1):\\n d=1000000\\n for j in tap:\\n d=min(d, abs(j-i)+1)\\n sol=max(sol, d)\\n print(sol)\\n"}
{"id": "1351", "input": "from collections import Counter\\nn, k = list(map(int, input().split()))\\nc = Counter(input())\\nans", "gt": "= min(c[chr(ord('A') + i)] for i in range(k))\\nprint(k * ans)\\n"}
{"id": "1352", "input": "from collections import defaultdict,deque\\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\\nsys.setrecursionlimit(10**8)\\nINF = float('inf')\\nmod = 10**9+7\\neps = 10**-7\\ndef inp(): return int(sys.stdin.readline())\\ndef inpl(): return list(map(int,", "gt": "sys.stdin.readline().split()))\\ndef inpl_str(): return list(sys.stdin.readline().split())\\n\\nl,r = inpl()\\n\\nfor i in range(l,r+1):\\n X = str(i)\\n if len(set(X)) == len(X):\\n print(i)\\n return\\n\\nprint(-1)\\n"}
{"id": "1353", "input": "import sys\\ninput = sys.stdin.readline\\n\\nn,x=list(map(int,input().split()))\\nA=list(map(int,input().split()))\\n\\nMIN_R=[A[-1]]\\nfor a in A[:-1][::-1]:\\n MIN_R.append(min(a,MIN_R[-1]))\\n\\nMIN_R=MIN_R[::-1]\\n\\nMAX=x\\n\\nfor i in range(n-1):\\n if A[i]>MIN_R[i+1]:\\n MAX=min(MAX,A[i])\\n\\nMAX_L=[A[0]]\\nfor a in A[1:]:\\n MAX_L.append(max(a,MAX_L[-1]))\\n\\nMIN=0\\nfor i in range(1,n):\\n if", "gt": "MAX_L[i-1]>A[i]:\\n MIN=max(MIN,A[i])\\n\\nNEED=[i for i in range(x+3)]\\n\\nfor i in range(n-1):\\n if A[i]>MIN_R[i+1]:\\n NEED[1]=max(NEED[1],MIN_R[i+1])\\n NEED[MIN_R[i+1]+1]=max(NEED[MIN_R[i+1]+1],A[i])\\n\\nfor i in range(1,x+2):\\n NEED[i]=max(NEED[i],NEED[i-1])\\n\\nANS=0\\n\\nfor i in range(1,MAX+1):\\n ANS+=x-max(MIN,NEED[i])+1\\n\\n #print(i,ANS)\\n\\nprint(ANS)\\n"}
{"id": "1354", "input": "\"\"\"\\nCodeforces Contest 266 Div 2 Problem A\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef main():\\n n,m,a,b = read()\\n if b/m < a:\\n if n%m and a * (n%m) > b:\\n print((n//m + 1) * b)\\n else:\\n print((n%m) * a + (n//m) * b)\\n else:\\n print(n*a)\\n\\n################################### NON-SOLUTION STUFF BELOW\\n\\ndef read(mode=2):\\n # 0: String\\n # 1:", "gt": "List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "1355", "input": "n,k,a = map(int,input().split())\\nm = int(input())\\nx = [int(y) for y in input().split()]\\n\\ndef check(K):\\n used = [0]*(n+1)\\n for i in range(K):\\n used[x[i]] = 1\\n for i in range(1,n+1):\\n used[i]+=used[i-1]\\n have = 0\\n i", "gt": "= a\\n while i<n+1:\\n if used[i]-used[i-a]==0:\\n have+=1\\n i+=a\\n i+=1\\n return have>=k\\n\\nif check(m):\\n print(-1)\\nelse:\\n low = -1\\n high = m\\n while high-low>1:\\n if check((low+high+1)//2):\\n low = (low+high+1)//2\\n else:\\n high = (low+high+1)//2\\n print(high)"}
{"id": "1356", "input": "def main():\\n from math import hypot\\n n, m = list(map(int, input().split()))\\n vertices = list(tuple(map(float, input().split())) for _ in range(n))\\n ax, ay = vertices[-1]\\n for i, (bx, by) in enumerate(vertices):\\n vertices[i], ax, ay = (bx, by, bx - ax, by - ay), bx, by\\n for _ in range(m):\\n x0, y0, x1, y1 = list(map(float, input().split()))\\n x1 -= x0\\n y1 -= y0\\n bx, by = vertices[-1][:2]\\n tmp = (bx - x0) * y1 - (by - y0) * x1\\n t = -1 if tmp < 0 else 1 if tmp > 0 else 0\\n res", "gt": "= []\\n for bx, by, abx, aby in vertices:\\n s, tmp = t, (bx - x0) * y1 - (by - y0) * x1\\n t = -1 if tmp < 0 else 1 if tmp > 0 else 0\\n if s != t:\\n res.append((((bx - x0) * aby - (by - y0) * abx) / (x1 * aby - y1 * abx), s - t))\\n res.sort()\\n t, w = 0, 0.\\n for i, (tmp, s) in enumerate(res, -1):\\n if t:\\n w += tmp - res[i][0]\\n t += s\\n print(w * hypot(x1, y1))\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1357", "input": "s =", "gt": "input()\\nc = s.count('a')\\nprint(min(2*c-1,len(s)))"}
{"id": "1358", "input": "n, m = list(map(int, input().split()))\\nv = list(map(int, input().split()))\\n\\nfor i in range(1, len(v)):\\n if v[i] < v[i-1]:", "gt": "v[i] += ((v[i-1] - v[i]) // n) * n\\n while v[i] < v[i-1]: v[i] += n\\n\\nprint(v[-1]-1)\\n"}
{"id": "1359", "input": "import sys\\nimport math\\n\\ndef solve():\\n k, n = list(map(int, input().split()))\\n D = {}\\n for line in sys.stdin:\\n s, a = line.split()\\n if s in D:\\n D[s].append(int(a))\\n else:\\n D[s] = [int(a)]\\n\\n res = 0\\n center = 0\\n for s in D:\\n revs = s[::-1]\\n if not revs in D: continue\\n D[revs].sort()\\n D[s].sort()\\n\\n if s ==", "gt": "revs:\\n while len(D[s]) > 1 and D[s][-2] + D[s][-1] > 0:\\n center = max(center, -D[s][-2])\\n res += D[s].pop()\\n res += D[s].pop()\\n\\n if len(D[s]) > 0:\\n center = max(center, D[s][-1])\\n else:\\n while (len(D[s]) > 0 and len(D[revs]) > 0 and\\n D[s][-1] + D[revs][-1] > 0):\\n res += D[s].pop()\\n res += D[revs].pop()\\n\\n return res + center\\n\\nprint(solve())\\n"}
{"id": "1360", "input": "l=input().strip().split(\" \");\\nn=int(l[0]);\\nm=int(l[1]);\\nt=m;\\nv=[];\\nfor i in range(n+1):\\n v.append([]);\\nwhile t>0:\\n l=input().strip().split(\" \");\\n a=int(l[0]);\\n b=int(l[1]);\\n v[a].append(b);\\n t-=1;\\n\\nans=0 ;\\nfor p in range(1,n+1):\\n gp={};\\n for ch inrange(1,n+1):\\n gp[ch]=0;\\n \\n for u in v[p]:\\n", "gt": "for x in v[u]:\\n if(x!=p):\\n gp[x]+=1;"}
{"id": "1361", "input": "import collections\\n\\nExam = collections.namedtuple(\"Exam\", ['a', 'b'])\\n\\nn = int(input())\\nexams = [ ]\\nfor i in range(n):\\n exams.append(Exam(*list(map(int,", "gt": "input().split()))))\\nexams.sort()\\ntoday = 0\\nfor e in exams:\\n today = e.b if e.b >= today else e.a\\nprint(today)\\n"}
{"id": "1362", "input": "def calcdiff(listx):\\n maxim = -1\\n for i in range(1, len(listx)):\\n maxim = max(maxim, listx[i] - listx[i-1])\\n return maxim\\nx", "gt": "= int(input())\\nt = list(map(int, input().split(' ')))\\nmaximx = 90000001\\nfor i in range(1, x-1):\\n maximx = min(maximx, calcdiff(t[:i] + t[i+1:]))\\nprint(maximx)\\n \\n"}
{"id": "1363", "input": "n, p, m = input().split()\\nn = int(n)\\np = int(p)\\nm = int(m)\\n\\nans = 0\\ncurb = 0\\ncurd = 1\\nfor i in range(0, n):\\n #print(curb)\\n tday, tplus = input().split()\\n tday = int(tday)\\n tplus = int(tplus)\\n if curb < 0:\\n ans += (tday - curd)\\n curb -= p * (tday - curd)\\n elif curb - p * (tday - curd) < 0:\\n curb -= p * (tday - curd)\\n x = -curb\\n xx = x // p\\n if xx * p < x:\\n xx", "gt": "+= 1\\n x = xx\\n ans += x\\n else:\\n curb -= p * (tday - curd)\\n curd = tday\\n #print(curb)\\n curb += tplus\\n\\ntday = m + 1\\nif curb < 0:\\n ans += (tday - curd)\\n curb -= p * (tday - curd)\\nelif curb - p * (tday - curd) < 0:\\n curb -= p * (tday - curd)\\n x = -curb\\n xx = x // p\\n if xx * p < x:\\n xx += 1\\n x = xx\\n ans += x\\n\\nprint(ans)"}
{"id": "1364", "input": "import bisect\\nfrom functools import lru_cache\\n\\ng, d, f = tuple(map(int, input().split()))\\n\\ngoals = list(map(int, input().split()))\\ndefs = list(map(int, input().split()))\\nforwards = list(map(int, input().split()))\\n\\ngoals.sort()\\ndefs.sort()\\nforwards.sort()\\n\\nforwards.append(100000000)\\ndefs.append(100000000)\\ngoals.append(100000000)\\n\\nnumers = []\\nroles = []\\ngi, di, fi = 0, 0, 0\\n\\nfor i in range(d + g + f):\\n numers.append(min(goals[gi], defs[di], forwards[fi]))\\n\\n if numers[-1] == goals[gi]:\\n roles.append(1)\\n gi += 1\\n\\n if numers[-1] == forwards[fi]:\\n roles.append(3)\\n fi += 1\\n\\n if numers[-1] == defs[di]:\\n roles.append(2)\\n di += 1\\n\\n#print(numers)\\n#print(roles)\\n\\n\\n@lru_cache()\\ndef my_comb(n, k):\\n if k == 0:\\n return 1\\n if n < k:\\n return 0\\n if n == k:\\n return 1\\n if k == 3:\\n return (n * (n - 1) * (n - 2)) // 6\\n if k == 2:\\n return", "gt": "(n * (n - 1)) // 2\\n if k == 1:\\n return n\\n assert False\\n\\n\\ndef solve(numers, roles):\\n ans = 0\\n for i in range(len(numers)):\\n # check all combinations with guy i\\n\\n possible_max_num = bisect.bisect_right(numers, numers[i] * 2)\\n\\n if possible_max_num - i < 5:\\n continue\\n\\n avaliable_f = roles[i + 1: possible_max_num].count(3)\\n avaliable_d = roles[i + 1: possible_max_num].count(2)\\n avaliable_g = roles[i + 1: possible_max_num].count(1)\\n\\n needed_f, needed_d, needed_g = 3, 2, 1\\n\\n if roles[i] == 1:\\n needed_g -= 1\\n elif roles[i] == 2:\\n needed_d -= 1\\n else:\\n needed_f -= 1\\n\\n possible_combinations_with_ith = my_comb(avaliable_d, needed_d) * my_comb(avaliable_f, needed_f) * my_comb(\\n avaliable_g, needed_g)\\n ans += possible_combinations_with_ith\\n\\n return ans\\n\\n\\nprint(solve(numers, roles))\\n"}
{"id": "1365", "input": "mi = lambda: [int(i) for i in input().split()]\\n\\nn = int(input())\\nt = mi()\\n\\na = []\\nv = 0\\nc = 0\\n\\nfor i in t:\\n if i == v:\\n c +=", "gt": "1\\n else:\\n if c != 0:\\n a.append(c)\\n c = 1\\n v = i\\na.append(c)\\n\\nr = 0\\nfor k in range(1, len(a)):\\n r = max(r, min(a[k - 1], a[k]) * 2)\\nprint(r)\\n"}
{"id": "1366", "input": "def main():\\n n, k = list(map(int, input().split()))\\n cnt = [[[0] * 21 for _ in (0, 1)] for _ in range(n + 1)]\\n edges, mod = [[] for _ in range(n + 1)], 1000000007\\n for _ in range(n - 1):\\n u, v = list(map(int, input().split()))\\n edges[u].append(v)\\n edges[v].append(u)\\n\\n def dfs(u, f):\\n cnt[u][0][0] = cnt[u][1][k] = 1\\n for v in edges[u]:\\n if v != f:\\n dfs(v, u)\\n tmp0, tmp1 = [0] * 21, [0] * 21\\n for i in range(k + 1):\\n for j in range(k + 1):\\n if i", "gt": "!= k:\\n tmp0[j if i < j else i + 1] += cnt[u][0][j] * cnt[v][0][i]\\n if i < j:\\n tmp1[j] += cnt[u][1][j] * cnt[v][0][i]\\n elif i != k:\\n tmp0[i + 1] += cnt[u][1][j] * cnt[v][0][i]\\n if i > j:\\n tmp1[i - 1] += cnt[u][0][j] * cnt[v][1][i]\\n else:\\n tmp0[j] += cnt[u][0][j] * cnt[v][1][i]\\n tmp1[max(i - 1, j)] += cnt[u][1][j] * cnt[v][1][i]\\n for i in range(21):\\n tmp0[i] %= mod\\n tmp1[i] %= mod\\n cnt[u][0] = tmp0\\n cnt[u][1] = tmp1\\n\\n dfs(1, 1)\\n print(sum(cnt[1][1][j] for j in range(k + 1)) % mod)\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1367", "input": "n = int(input())\\nbs = []\\nfor _ in range(n):\\n bs.append(list(map(int, input().split())))\\n\\nans = 0\\nfor i in range(n):\\n for", "gt": "j in range(n):\\n if i != j and bs[i][0] == bs[j][1]:\\n ans += 1\\n break\\n\\nprint(n - ans)\\n"}
{"id": "1368", "input": "\"\"\"\\nCodeforces Testing Round 10 Problem A\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0:\\n return inputs\\n if", "gt": "mode == 1:\\n return inputs.split()\\n if mode == 2:\\n return [int(x) for x in inputs.split()]\\n\\ndef write(s=\"\\n\"):\\n if isinstance(s, list): s = \" \".join(s)\\n s = str(s)\\n print(s, end=\"\")\\n\\n################################################### SOLUTION\\nn, = read()\\na = read()\\nwrite(n*(n+1)//2 - sum(a))"}
{"id": "1369", "input": "N, A, B = map(int, input().split())\\nX = list(map(int, input().split()))\\nX.sort(reverse=True)\\nM = sum(X[i] for i in range(A)) / A\\nprint(M)\\ncntl, cntr = 0, 0\\nif X[A-1] == X[N-1]:\\n cntr = N - A\\nelse:\\n cntr = A-1\\n while X[A-1] == X[cntr]:\\n cntr += 1\\n cntr -= A\\nif X[0] == X[A-1]:\\n cntl = A\\nelse:\\n cntl = A-1\\n while X[A-1] == X[cntl]:\\n cntl -= 1\\n cntl = A - 1 - cntl\\nF = 0\\nc = cntl", "gt": "+ cntr\\nif cntl == A:\\n t = 1\\n for m in range(A):\\n t *= c - m\\n t //= m + 1\\n for m in range(A, min(B, c)+1):\\n F += t\\n t *= c - m\\n t //= m + 1\\n print(F)\\nelse:\\n # calc comb(cntl + cntr, cntl)\\n t = 1\\n for m in range(cntl):\\n t *= c - m\\n t //= m + 1\\n F = t\\n print(F)"}
{"id": "1370", "input": "import math\\n\\nn = int(input())\\nxy = [list(map(float, input().split())) for _ in range(n)]\\n\\nret = 100000000\\ndef update(px, py):\\n nonlocal ret\\n r = 0\\n for p in range(n):\\n r = max(r, math.hypot(px - xy[p][0], py - xy[p][1]))\\n ret = min(ret, r)\\n\\nfor i in range(n):\\n x1 = xy[i][0]\\n y1 = xy[i][1]\\n for j in range(i + 1, n):\\n x2 = xy[j][0]\\n y2 = xy[j][1]\\n update((x1 + x2) / 2, (y1 + y2) / 2)\\n for k in range(j + 1, n):\\n x3 = xy[k][0]\\n y3 = xy[k][1]\\n\\n d = 2 * (y1 - y3) * (x1 - x2) - 2 * (y1", "gt": "- y2) * (x1 - x3)\\n if d != 0:\\n px = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\\n py = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\\n update(px, py)\\n\\nprint(ret)\\n"}
{"id": "1371", "input": "h, w, k = list(map(int, input().split()))\\n\\nchoco = [list(map(int, list(input()) )) for i in range(h)]\\n\\nchoco_cumsum = [[0 for i in range(w)] for j in range(h)]\\n\\nfor i in range(h):\\n choco_cumsum[i][0] = choco[i][0]\\n for j in range(1, w):\\n choco_cumsum[i][j] = choco_cumsum[i][j-1] + choco[i][j]\\n\\nans = h + w + 1\\n\\nfor h_cut in range(2**(h-1)):\\n # 上位ビットが上側。1が切る、0が切らない\\n num_cut_init = bin(h_cut).count(\"1\") # 立っているビットの個数\\n num_cut = num_cut_init\\n w_last_cot_pos = -1\\n valid = True\\n\\n temp_list = [0] * (num_cut_init + 1)\\n temp_dict = {}\\n idx = 0\\n temp_dict[0] = idx\\n for i in range(1, h):\\n # print('idx', 2 ** (-i+h-1) )\\n if h_cut &", "gt": "(2 ** (-i+h-1) ):\\n idx += 1\\n # idx += h_cut & (2 ** (h-1) - i)\\n temp_dict[i] = idx\\n # print(temp_dict)\\n\\n iw = 0\\n while iw < w:\\n\\n for ih in range(h):\\n temp_list[temp_dict[ih]] += choco[ih][iw]\\n # print(iw, temp_list)\\n\\n condition = max(temp_list) > k\\n if condition:\\n if w_last_cot_pos < iw-1:\\n # もしそこで切ってkを超えるなら、その手前で切る\\n num_cut += 1\\n w_last_cot_pos = iw - 1\\n temp_list = [0] * (num_cut_init + 1)\\n # print('iw: ', iw, 'last: ', w_last_cot_pos)\\n\\n else:\\n # 1つしか動かしてない場合は土台無理なので次のh_cutに\\n valid = False\\n break\\n \\n else:\\n iw += 1\\n \\n if valid:\\n ans = min(ans, num_cut)\\n # print(num_cut)\\n\\nprint(ans)\\n"}
{"id": "1372", "input": "#!/usr/bin/env python\\n\\ndef main():\\n s = int(input())\\n mod = 10**9 + 7\\n a_lst = [1, 0, 0]\\n a_sum = 0\\n\\n", "gt": "if s >= 3:\\n for i in range(3, s+1):\\n a_sum += a_lst[i-3]\\n a_sum %= mod\\n a_lst.append(a_sum)\\n\\n print((a_lst[s]))\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1373", "input": "h, n = map(int, input().split())\\na, b = [], []\\nfor _ in range(n):\\n A, B = map(int, input().split())\\n a.append(A)\\n", "gt": "b.append(B)\\n\\na_max = max(a)\\ndp = [0]*(h+a_max)\\n\\nfor i in range(h+a_max):\\n dp[i] = min(dp[i-a] + b for a, b in zip(a, b))\\n\\nprint(min(dp[h-1:]))"}
{"id": "1374", "input": "n,k=list(map(int, input().split()))\\ns=0\\nfor i", "gt": "in range(k,n+2):\\n s+=i*(n-i+1)+1\\nprint((s%(10**9+7)))\\n\\n"}
{"id": "1375", "input": "def main():\\n N, *A = list(map(int, open(0).read().split()))\\n\\n B = sorted(A)\\n l, r = 0, N\\n m, c = N // 2, N * (N + 1) // 2\\n\\n def check(x):\\n b, r, y = N, 0, 0\\n D = [0] * (2 * N + 1)\\n for a in A:\\n D[b] += 1\\n if a < x:\\n r += D[b]\\n b", "gt": "+= 1\\n else:\\n b -= 1\\n r -= D[b]\\n y += r\\n return y\\n\\n while True:\\n if check(B[m]) <= c // 2:\\n if m == N - 1 or check(B[m + 1]) > c // 2:\\n break\\n l, m = m, (m + r) // 2\\n else:\\n m, r = (m + l) // 2, m + 1\\n\\n print((B[m]))\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1376", "input": "\"\"\"\\nCodeforces Contest 266 Div 2 Problem C\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef main():\\n n, = read()\\n a = read()\\n s = sum(a)\\n if s%3:\\n print(0)\\n return\\n s //= 3\\n t = 0\\n ct = 0\\n res = 0\\n for i in range(n-1):\\n t += a[i]\\n if t == 2*s:\\n res += ct\\n if t == s:\\n ct += 1\\n print(res)\\n\\n###################################", "gt": "NON-SOLUTION STUFF BELOW\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "1377", "input": "n = int(input())\\na = list(map(int, input().split()))\\ns = d = 0\\nm = {i: [] for i in range(1, n + 1)}\\nfor i in range(n):\\n m[a[i]] += [i]\\nfor i in range(n, 2 * n):\\n m[a[i]] += [i]\\nres = 0\\nfor i", "gt": "in sorted(m):\\n if s > d:\\n s, d = d, s\\n a, b = m[i]\\n if a > b:\\n a, b = b, a\\n res += abs(s - a) + abs(b - d)\\n s, d = a, b\\nprint(res)"}
{"id": "1378", "input": "n = int(input())\\na = list(map(int, input().split()))\\nidx = list(range(n))\\nidx.sort(key=lambda i: a[i], reverse=True)\\nimin = imax = idx[0]\\nfor i in idx[1:]:\\n if i", "gt": "== imin - 1 or i == imax + 1:\\n imin = min(imin, i)\\n imax = max(imax, i)\\n else:\\n print('NO')\\n return\\nprint('YES')\\n"}
{"id": "1379", "input": "n = int(input())\\na = input().split()\\nfor i in range(n):\\n a[i] = int(a[i])\\nb = []\\nfor i in range(0, n-1):\\n b.append((a[i]-(n-a[i+1]), i))\\nb.append((a[n-1]-(n-a[0]), n-1))\\nb = sorted(b)\\nans", "gt": "= n*[0]\\nfor i in range(n):\\n # the line segment at index b[i][1]\\n ans[b[i][1]] = i\\nfor i in range(n):\\n print(ans[i], end = ' ')\\n"}
{"id": "1380", "input": "from copy import deepcopy\\nimport itertools\\nfrom bisect import bisect_left\\nfrom bisect import bisect_right\\nimport math\\nfrom collections import deque\\nfrom collections import Counter\\n\\n\\ndef read():\\n return int(input())\\n\\n\\ndef readmap():\\n return map(int, input().split())\\n\\n\\ndef readlist():\\n return list(map(int, input().split()))\\n\\n\\nn, m, d = readmap()\\nA = readlist()\\nAind = dict([(A[i], i) for i in", "gt": "range(n)])\\nA.sort()\\n\\nq = deque()\\na = A[0]\\nans = [0] * n\\nans[Aind[a]] = 1\\nmaxday = 1\\n\\nq.append((a, 1))\\nfor i in range(1, n):\\n if A[i] > q[0][0] + d:\\n ans[Aind[A[i]]] = q[0][1]\\n q.append((A[i], q[0][1]))\\n q.popleft()\\n else:\\n maxday += 1\\n ans[Aind[A[i]]] = maxday\\n q.append((A[i], maxday))\\n\\nprint(maxday)\\nprint(\" \".join(list(map(str, ans))))"}
{"id": "1381", "input": "n,k=map(int,input().split())\\na=list(map(int,input().split()))\\np=1000\\nfirst=1\\nfor i in range(n):\\n if a[i]>k*i:\\n now=0\\n f=a[i]-k*i\\n for j in range(i):\\n if a[j]!=f+k*j:\\n now+=1\\n for j in", "gt": "range(i+1,n):\\n if a[j]!=f+j*k:\\n now+=1\\n if now<p:\\n p=now\\n first=f\\nprint(p)\\nfor i in range(n):\\n if a[i]!=first+k*i:\\n print('+' if a[i]<first+k*i else '-',i+1,abs(a[i]-first-k*i))"}
{"id": "1382", "input": "k, n, s, p = list(map(int, input().split()))\\n\\nx = (n + s - 1)", "gt": "// s\\ny = k * x\\nz = (y + p - 1) // p\\n\\nprint(z)\\n"}
{"id": "1383", "input": "def read_data():\\n n, m = list(map(int, input().split()))\\n Es = [[] for v in range(n)]\\n for e in range(m):\\n a, b = list(map(int, input().split()))\\n a -= 1\\n b -= 1\\n Es[a].append(b)\\n Es[b].append(a)\\n return n, m, Es\\n\\ndef solve(n, m, Es):\\n if m == 0:\\n return 3, n * (n - 1) * (n - 2) // 6\\n if max(list(map(len, Es))) == 1:\\n return 2, m * (n-2)\\n patterns = 0\\n color = [0] * n\\n for u in range(n):\\n if color[u]:\\n continue\\n", "gt": "color[u] = 1\\n stack = [u]\\n n_color = [1, 0]\\n while stack:\\n v = stack.pop()\\n prev_color = color[v]\\n for w in Es[v]:\\n current_color = color[w]\\n if current_color == prev_color:\\n return 0, 1\\n if current_color == 0:\\n color[w] = - prev_color\\n n_color[(prev_color + 1)//2] += 1\\n stack.append(w)\\n n_even = n_color[0]\\n n_odd = n_color[1]\\n patterns += n_even * (n_even - 1) // 2 + n_odd * (n_odd - 1) // 2\\n return 1, patterns\\n\\ndef __starting_point():\\n n, m, Es = read_data()\\n print(*solve(n, m, Es))\\n\\n__starting_point()"}
{"id": "1384", "input": "n, m = map(int, input().split())\\na = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\na = [u % m for u in a]\\nb = [u % m for u in b]\\na.sort()\\nb.sort()\\npossible = set(sorted([(b[0] - u + m)", "gt": "% m for u in a])) # At most 2000 elements\\n# O(n^2)\\nfor x in possible:\\n array = [(u + x) % m for u in a]\\n if sorted(array) == b:\\n print (x)\\n break"}
{"id": "1385", "input": "n = int(input())\\ns = list(map(int, input().split()))\\n\\nans = 0\\nx0 = 0\\nx1 = 0\\nfor i in range(n):\\n if s[i]", "gt": "== 1:\\n x1 = max(x0, x1) + 1\\n else:\\n x0 = x0 + 1\\n ans = max(x0, x1)\\nprint(ans)\\n"}
{"id": "1386", "input": "import re\\nfrom collections import Counter\\n\\nclass Task:\\n answer = []\\n str = \"\"\\n \\n def getData(self):\\n x = 0\\n self.str = input()\\n \\n def solve(self):\\n list= re.findall(\"\\\".*?\\\"|[^ ]+\", self.str)\\n self.answer = [\"<\" + x.replace(\"\\\"\", \"\") + \">\" for x in list]\\n \\n def printAnswer(self):\\n for x in self.answer:\\n print(x)\\n\\ntask = Task();\\ntask.g", "gt": "etData();"}
{"id": "1387", "input": "n, m = list(map(int,", "gt": "input().split()))\\nprint(pow(2, n + m, 998244353))\\n"}
{"id": "1388", "input": "\"\"\"\\nCodeforces Contest Good Bye 2014 Contest Problem A\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.4.2\\n\"\"\"\\n\\n################################################### SOLUTION\\n\\ndef main():\\n n,t = read()\\n a = read()\\n c = 1\\n while c < t:\\n c += a[c-1]\\n if c == t:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n\\n#################################################### HELPERS\\n\\n\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n", "gt": "# 2: List of integers\\n inputs = input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "1389", "input": "import sys\\ninput = lambda: sys.stdin.readline().rstrip()\\nfrom collections import deque\\nN = int(input())\\nC, Y = [], []\\nfor _ in range(N):\\n a, b, c = list(map(int, input().split()))\\n C.append(a)\\n Y.append(c - b)\\n\\nif sum(Y):\\n print(-1)\\n return\\n\\nX = [[] for i in range(N)]\\nfor i in range(N-1):\\n x, y = list(map(int, input().split()))\\n X[x-1].append(y-1)\\n X[y-1].append(x-1)\\n\\nP = [-1] * N\\nQ =", "gt": "deque([0])\\nR = []\\nwhile Q:\\n i = deque.popleft(Q)\\n R.append(i)\\n for a in X[i]:\\n if a != P[i]:\\n P[a] = i\\n X[a].remove(i)\\n deque.append(Q, a)\\n\\nfor i in R[1:]:\\n C[i] = min(C[i], C[P[i]])\\n\\nans = 0\\nfor i in R[1:][::-1]:\\n if Y[i] * Y[P[i]] < 0:\\n ans += C[P[i]] * min(abs(Y[i]), abs(Y[P[i]]))\\n Y[P[i]] += Y[i]\\n\\nprint(ans * 2)\\n"}
{"id": "1390", "input": "import sys\\n\\n\\n\\ninput = []\\ninput_index = 0\\n\\ndef next(type, number = None):\\n def next():\\n nonlocal input, input_index\\n \\n \\n while input_index == len(input):\\n if sys.stdin:\\n input = sys.stdin.readline().split()\\n input_index = 0\\n else:\\n raise Exception()\\n \\n \\n input_index += 1\\n \\n return input[input_index - 1]\\n \\n \\n if number is None:\\n result = type(next())\\n else:\\n result = [type(next()) for _ in range(number)]\\n \\n return result\\n \\n \\n \\nn, m = next(int, 2)\\niis = [next(str) for _ in range(n)]\\n\\n\\ncount = 0\\nvs", "gt": "= [0] * n\\n\\nfor j in range(m - 1, -1, -1):\\n for i in range(n - 1, -1, -1):\\n c = iis[i][j]\\n \\n if c == \"W\" and vs[i] != 1:\\n count += 1\\n d = 1 - vs[i]\\n \\n for k in range(i + 1):\\n vs[k] += d\\n elif c == \"B\" and vs[i] != -1:\\n count += 1\\n d = -1 - vs[i]\\n \\n for k in range(i + 1):\\n vs[k] += d\\n \\n \\nprint(count)\\n"}
{"id": "1391", "input": "n, m = list(map(int, input().split()))\\nv = list(map(int, input().split()))\\nv = sorted(v)\\n\\ndiff = 10**10\\nfor i", "gt": "in range(0, len(v)):\\n if i+n-1 < len(v): diff = min(diff, v[i+n-1] - v[i])\\n\\nprint(diff)\\n"}
{"id": "1392", "input": "3\\n\\ndef readln(): return tuple(map(int, input().split()))\\n\\nn, m, a = readln()\\nb = list(sorted(readln()))\\np = list(sorted(readln()))\\n\\nl = ost = 0\\nr = min(m, n) + 1\\n\\nwhile r - l > 1:\\n k = (r + l) // 2\\n s = d", "gt": "= 0\\n for x, y in zip(b[-k:], p[:k]):\\n if x < y:\\n d += y - x\\n s += y\\n if d <= a:\\n l = k\\n ost = max(0, s - a)\\n else:\\n r = k\\n\\nprint(l, ost)\\n"}
{"id": "1393", "input": "def check(s,k):\\n for i in range(k+1):\\n if chr(ord('0')+i) not in s: \\n return False\\n return", "gt": "True\\n\\n\\nn, k = map(int,input().split())\\nans = 0\\nfor i in range(n):\\n ss = input()\\n if check(ss,k):\\n ans +=1\\nprint(ans)"}
{"id": "1394", "input": "def upc(c):\\n if c >= 'a' and c <= 'z':\\n c = chr(ord(c) - ord('a') + ord('A'))\\n return c\\na1, a2 = {}, {}\\nfor i in input():\\n if i in a1:\\n a1[i] += 1\\n else:\\n a1[i] = 1\\nfor i in input():\\n if i in a2:\\n a2[i] += 1\\n else:\\n a2[i] = 1\\nr1, r2 = 0, 0\\na3, a4 = {}, {}\\nfor k in a1:\\n v = a1[k]\\n if not k in a2:\\n continue\\n c = min(v, a2[k])\\n", "gt": "a2[k] -= c\\n a1[k] -= c\\n r1 += c\\nfor k in a1:\\n v = a1[k]\\n c = upc(k)\\n if c in a3:\\n a3[c] += v\\n else:\\n a3[c] = v\\nfor k in a2:\\n v = a2[k]\\n c = upc(k)\\n if c in a4:\\n a4[c] += v\\n else:\\n a4[c] = v\\nfor k in a3:\\n if not k in a4:\\n continue\\n v = a3[k]\\n c = min(v, a4[k])\\n a3[k] -= c\\n a4[k] -= c\\n r2 += c\\nprint(r1, r2)\\n"}
{"id": "1395", "input": "t = input()\\nz = t.count('a')\\nq = (len(t) - z) // 2\\ns = t[:q + z]\\nss = t[q", "gt": "+ z:]\\np = ''.join([i for i in s if i != 'a'])\\nif p == ss:\\n print(s)\\nelse:\\n print(':(')"}
{"id": "1396", "input": "s = input()\\nm = int(input())\\nmn = m\\nttt = 0\\nt = 0\\nttt = 1\\nfor i in range(1,len(s)):\\n ttt = (ttt * 10) % m\\nfor i in range(0,len(s)):\\n t = (t * 10 + ord(s[i]) - ord('0')) % m\\nfor i", "gt": "in range(0,len(s)):\\n if s[i] != '0':\\n mn = min(mn,t)\\n t = t - (((ord(s[i])- ord('0')) * ttt) % m)\\n if t < 0:\\n t = t + m\\n t = (t * 10 + (ord(s[i])- ord('0'))) % m\\nprint(mn)\\n"}
{"id": "1397", "input": "import copy\\n\\nn, k, x = map(int, input().split())\\nc = list(map(int, input().split()))\\nfor i in range(n):\\n c[i] = (c[i],0)\\nans = 0\\nfor i in range(n + 1):\\n c2 = copy.deepcopy(c)\\n c2.insert(i, (x,1))\\n while True:\\n dq = False\\n for i in range(len(c2) - 2):\\n if c2[i][0] == c2[i + 1][0] == c2[i", "gt": "+ 2][0]:\\n le = i\\n re = i\\n while re < len(c2) and c2[re][0] == c2[le][0]:\\n re += 1\\n c2 = c2[:le] + c2[re:]\\n dq = True\\n break\\n if not dq:\\n break\\n cntdel = 0\\n for a,b in c2:\\n if b==0:\\n cntdel+=1\\n ans = max(ans, n - cntdel)\\nprint(ans)"}
{"id": "1398", "input": "n, m = list(map(int, input().split()))\\ntable = [False] * (n + 1)\\nfor _ in range(m):\\n a, b = list(map(int, input().split()))\\n table[a] = table[b] = True\\nprint(n", "gt": "- 1)\\nfor i in range(1, n + 1):\\n if not table[i]:\\n for j in range(1, n + 1):\\n if i != j:\\n print(i, j)\\n break\\n\\n"}
{"id": "1399", "input": "import sys\\nfrom bisect import *\\nsys.stdin = open('input.txt',", "gt": "'r')\\nsys.stdout = open('output.txt', 'w')\\nans=n=int(input())\\na=sorted(map(int,sys.stdin.readline().split()))\\nfor i in range(n):ans=min(ans,n-bisect_right(a,a[i]*2)+i)\\nprint(ans)"}
{"id": "1400", "input": "# \\nimport sys \\n \\ndef getIntList():\\n return list(map(int, input().split())) \\n \\n\\n\\n \\nN, = getIntList()\\n\\nzp = []\\nfor i in range(N):\\n ax, ay, bx, by = getIntList()\\n if ax>bx:\\n ax,bx = bx,ax\\n ay,by = by, ay\\n zp.append( (ax,ay, bx,by))\\n \\nres = 0\\ndef gcd(a,b): \\n if b==0:return a\\n return gcd(b, a%b)\\nzgcd = []\\nfor i in range(N):\\n ax, ay, bx, by = zp[i]\\n tx = abs(bx-ax)\\n ty = abs(by - ay)\\n \\n g = gcd(tx, ty)\\n res += g+1\\n \\n zgcd .append(g)\\n \\n\"\"\"\\nax + k1 dax = bx + k2 dbx\\nay + k1 day = by + k2 dby\\n\"\"\"\\nfor i in range(N):\\n ax = zp[i][0]\\n dax = (zp[i][2] - ax) // zgcd[i]\\n ay = zp[i][1]\\n day = (zp[i][3] - ay) // zgcd[i]\\n cross = []\\n for j in range(i+1, N):\\n #dprint('node',i,j)\\n bx = zp[j][0]\\n", "gt": "dbx = (zp[j][2] - bx) // zgcd[j]\\n by = zp[j][1]\\n dby = (zp[j][3] - by) // zgcd[j]\\n #dprint(ax,dax,ay,day)\\n #dprint(bx,dbx,by,dby)\\n t1 = ax * day - ay * dax - bx * day + by * dax\\n t2 = dbx *day - dby * dax\\n \\n #dprint(t1,t2)\\n if t2==0:\\n continue\\n if t1%t2!=0:\\n continue\\n k2 = t1 // t2\\n if k2 <0 or k2 > zgcd[j]:\\n continue\\n if dax!=0:\\n t3 = k2*dbx + bx - ax\\n if t3%dax!=0:\\n continue\\n k1 = t3//dax\\n else:\\n t3 = k2* dby + by - ay\\n if t3%day !=0:\\n continue\\n k1 = t3//day\\n if k1<0 or k1 > zgcd[i]:\\n continue\\n #dprint(ax + k1 * dax, ay+k1 * day)\\n cross.append(k1)\\n if not cross: continue\\n cross.sort()\\n \\n d = 1\\n for j in range(1, len(cross)):\\n if cross[j]!=cross[j-1]:\\n d+=1\\n res-=d\\nprint(res)\\n \\n\\n\\n\\n"}
{"id": "1401", "input": "from sys import stdin, stdout, exit\\n\\nmod = 10**9 + 7\\n\\ndef modinv(x):\\n return pow(x, mod-2, mod)\\n\\nN = 2*10**5 + 10\\nfacts = [1]*N\\nfor i in range(1,N):\\n facts[i] = facts[i-1] * i\\n facts[i] %= mod\\n\\ndef binom(n, k):\\n ans = modinv(facts[k]) * modinv(facts[n-k])\\n ans %= mod\\n ans *= facts[n]\\n ans %= mod\\n return ans\\n\\n#print(\"Finished preprocess\")\\n\\nn, T = list(map(int, stdin.readline().split()))\\nts = list(map(int, stdin.readline().split()))\\n\\nans = 0\\ntotal = sum(ts)\\nrunning = total\\nlast_idx = n-1\\nwhile running > T:\\n running -= ts[last_idx]\\n last_idx -= 1\\n#print(last_idx+1)\\n\\nlast_bd = -1\\nlast_sum = 0\\nidx = last_idx\\nwhile running +", "gt": "idx + 1 > T:\\n bd = T - running\\n# print(\"time remaining for\", idx+1, \"flips is\", bd)\\n cur_sum = last_sum + (binom(idx+1, last_bd) if last_bd >= 0 else 0)\\n cur_sum *= modinv(2)\\n cur_sum %= mod\\n for fresh in range(last_bd+1, bd+1):\\n cur_sum += binom(idx+1, fresh)\\n cur_sum %= mod\\n # print(\"pr of\", idx+1, \"flips is\", cur_sum, cur_sum / (2**(idx+1)))\\n ans += cur_sum * modinv(pow(2, idx+1, mod))\\n ans %= mod\\n running -= ts[idx]\\n last_bd = bd\\n last_sum = cur_sum\\n idx -= 1\\n\\n#print(idx+1, \"freebies\")\\nans += idx+1\\nans %= mod\\nprint(ans)\\n"}
{"id": "1402", "input": "n = int(input())\\n\\nA = list(map(int, input().split()))\\n\\nmaxDist = [0] * n\\n\\nG = [[] for _ in range(n)]\\n\\nfor v in range(1, n):\\n u, d = tuple(map(int, input().split()))\\n u -= 1\\n G[v].append((u, d))\\n G[u].append((v, d))\\n\\n\\nseen = [False] * n\\nseen[0] = True\\nq = [0]\\nto_remove = []\\n\\nwhile q:\\n v =", "gt": "q.pop();\\n for u, dist in G[v]:\\n if not seen[u]:\\n seen[u] = True\\n maxDist[u] = max(dist, maxDist[v] + dist)\\n if maxDist[u] > A[u]:\\n to_remove.append(u)\\n else:\\n q.append(u)\\n\\ncount = 0\\nwhile to_remove:\\n v = to_remove.pop()\\n count += 1\\n for u, _ in G[v]:\\n if not seen[u]:\\n seen[u] = True\\n to_remove.append(u)\\n\\nprint(count)"}
{"id": "1403", "input": "n, s = int(input()), 0\\ns1, s2 = str(input()), str(input())\\nb1, b2 = False, False\\nfor i in range(n):\\n if s1[i] != '?' and s2[i] != '?':\\n if ord(s1[i]) < ord(s2[i]):\\n b1 = True\\n if ord(s1[i]) > ord(s2[i]):\\n b2 = True\\n s += (s1[i] == '?') + (s2[i] == '?')\\nans1, ans2, ans3 = 1, 1, 1\\nfor i in range(n):\\n if s1[i] == '?' and s2[i] == '?':\\n ans1 = (ans1 * 55) % 1000000007\\n ans2 = (ans2 * 55) % 1000000007\\n ans3", "gt": "= (ans3 * 10) % 1000000007\\n elif s1[i] == '?':\\n ans1 = (ans1 * (ord(s2[i]) - ord('0') + 1)) % 1000000007\\n ans2 = (ans2 * (10 - ord(s2[i]) + ord('0'))) % 1000000007\\n elif s2[i] == '?':\\n ans1 = (ans1 * (10 - ord(s1[i]) + ord('0'))) % 1000000007\\n ans2 = (ans2 * (ord(s1[i]) - ord('0') + 1)) % 1000000007\\nprint((10 ** s - (not b2) * ans1 - (not b1) * ans2 + (not b1 and not b2) * ans3) % 1000000007)"}
{"id": "1404", "input": "n , k = input().split()\\n\\nn , k = int(n), int(k)\\n\\nd = {}\\n\\narr = list(map(int, input().split()))\\nfor i in arr:\\n if i in d:\\n d[i]", "gt": "+= 1\\n else:\\n d[i] = 1;\\n\\narr = list(set(arr))\\narr.sort()\\n\\ncnt = 0\\nfor i in range(len(arr)-1):\\n if (arr[i] + k >= arr[i+1]):\\n cnt += d[arr[i]]\\n\\nprint(n - cnt)\\n"}
{"id": "1405", "input": "MOD = 998244353.0\\nfloat_prec = 1801439850948198.4\\nfloat_mod = lambda x: x if -float_prec < x < float_prec else x % MOD\\n\\nn = int(input())\\na = [int(i) for i in input().split()]\\n\\nf0, f1 = [1.0] * 201, [0.0] * 201\\nfor i in range(n):\\n nf0, nf1 = [0.0] * 201, [0.0] * 201\\n if a[i] == -1:\\n for j in range(200):\\n nf0[j + 1] = float_mod(nf0[j] + f0[j] + f1[j])\\n nf1[j", "gt": "+ 1] = float_mod(nf1[j] - f0[j] + f0[j + 1] - f1[j] + f1[200])\\n else:\\n for j in range(200):\\n nf0[j + 1], nf1[j + 1] = nf0[j], nf1[j]\\n if j + 1 == a[i]:\\n nf0[j + 1] = float_mod(nf0[j] + f0[j] + f1[j])\\n nf1[j + 1] = float_mod(nf1[j] - f0[j] + f0[j + 1] - f1[j] + f1[200])\\n f0, f1 = nf0, nf1\\n\\nprint(int(f1[200] % MOD))\\n"}
{"id": "1406", "input": "#!/usr/bin/env python3\\n\\nn = int(input())\\na = [int(x) for x in input().split()]\\n\\nsorted_a = sorted(a)\\ndict_a = {}\\nfor x in a:\\n if not x in dict_a:\\n dict_a[x] = 1\\n else:\\n dict_a[x] += 1\\n\\nsorted_uniq_a = sorted(dict_a.keys())\\n\\nmax_fib_prefix = [a[0], a[1]]\\nfor i in range(0, len(sorted_uniq_a)):\\n for j in range(0, len(sorted_uniq_a)):\\n if i != j or dict_a[sorted_uniq_a[i]] > 1:\\n", "gt": "if sorted_uniq_a[i] + sorted_uniq_a[j] > sorted_uniq_a[-1]:\\n break\\n\\n fib_prefix = [sorted_uniq_a[i], sorted_uniq_a[j]]\\n dict_a[sorted_uniq_a[i]] -= 1\\n dict_a[sorted_uniq_a[j]] -= 1\\n\\n while True:\\n next_fib = fib_prefix[-1] + fib_prefix[-2]\\n if not next_fib in dict_a or dict_a[next_fib] == 0:\\n break\\n fib_prefix.append(next_fib)\\n dict_a[next_fib] -= 1\\n\\n for x in fib_prefix:\\n dict_a[x] += 1\\n\\n if len(fib_prefix) > len(max_fib_prefix):\\n max_fib_prefix = fib_prefix\\n\\nprint(len(max_fib_prefix))\\n"}
{"id": "1407", "input": "3\\n\\nimport sys\\n\\n# 1 <= n, d <= 1000, 1 <= k <= 10**9\\nn, k, d = list(map(int, sys.stdin.readline().split()))\\n\\nno_sol = False\\nsolution = [[1 for j in range(n)] for i in range(d)]\\n\\n\\ndef schedule(i, j, level):\\n nonlocal no_sol\\n if level >= d:\\n no_sol = True\\n return\\n count = j - i\\n chunk = count // k\\n extra = count % k\\n r = i\\n", "gt": "for t in range(min(k, count)):\\n size = chunk + (1 if t < extra else 0)\\n for z in range(size):\\n solution[level][r+z] = t+1\\n if size > 1:\\n schedule(r, r + size, level + 1)\\n r += size\\n\\nif k == 1:\\n if n > 1:\\n no_sol = True\\nelse:\\n schedule(0, n, 0)\\n\\nif no_sol:\\n print(-1)\\nelse:\\n for l in solution:\\n print(' '.join(str(x) for x in l))\\n"}
{"id": "1408", "input": "maxn = 100100\\nar = [1 for i in range(maxn)]\\nar[0], ar[1] = 0, 0\\n\\nfor i in range(2, maxn):\\n if ar[i]:\\n for j in range(i, (maxn - 1) // i + 1):\\n ar[i * j] = 0\\n\\ndst = maxn\\nd = [dst for i in range(maxn)]\\n\\nfor i in reversed(list(range(maxn))):\\n if", "gt": "ar[i]: dst = 0\\n d[i] = min(d[i], dst)\\n dst += 1\\n\\nn, m = list(map(int, input().split()))\\ng = [[int(x) for x in input().split()] for _ in range(n)]\\ng = [[d[x] for x in y] for y in g]\\ntmpsharon = min([sum(x) for x in g] + [sum(x) for x in zip(*g)])\\nprint(tmpsharon)\\n\\n"}
{"id": "1409", "input": "3\\n\\nn = int(input())\\nbooks = [[], []]\\nfor _ in range(n):\\n t, w = tuple(map(int, input().split()))\\n books[t - 1].append(w)\\nfor _ in range(2):\\n books[_].sort()\\n#print(books)\\nans = 10**9\\nfor i in range(len(books[0]) + 1):\\n for j in range(len(books[1]) +", "gt": "1):\\n hor = sum(books[0][:i]) + sum(books[1][:j])\\n ver = len(books[0]) - i + 2 * (len(books[1]) - j)\\n if hor <= ver and ver < ans:\\n ans = ver\\n #print(i, j, hor, ver, ans)\\nprint(ans)\\n"}
{"id": "1410", "input": "n, k = map(int, input().split())\\na = list(map(int, input().split()))\\nans = 0\\nfor i in", "gt": "a:\\n if 5 - i >= k:\\n ans += 1\\nprint(ans // 3)"}
{"id": "1411", "input": "from collections import deque\\nimport sys\\ninput = sys.stdin.readline\\n\\n\\nn = int(input())\\ncost = [list(map(int, input().split())) for i in range(3)]\\ninfo = [list(map(int, input().split())) for i in range(n-1)]\\ngraph = [[] for i in range(n)]\\n\\nfor i in range(n-1):\\n a, b = info[i]\\n a -= 1\\n b -= 1\\n graph[a].append(b)\\n graph[b].append(a)\\n\\nfor i in graph:\\n if len(i) >= 3:\\n print(-1)\\n return\\n\\nfor i, j in enumerate(graph):\\n if len(j) == 1:\\n start = i\\n break\\n\\nvisited = [-1]*n\\nvisited[start] = 0\\nq = deque([start])\\n\\nwhile q:\\n pos =", "gt": "q.popleft()\\n for next_pos in graph[pos]:\\n if visited[next_pos] != -1:\\n continue\\n visited[next_pos] = (visited[pos] + 1) % 3\\n q.append(next_pos)\\n\\nans = float(\"inf\")\\nind = [0, 1, 2]\\nfor ptn in [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]]:\\n tmp_ans = 0\\n for i in range(n):\\n tmp_ans += cost[ptn[visited[i]]][i]\\n if tmp_ans < ans:\\n ans = tmp_ans\\n ind = ptn[0:]\\n\\nprint(ans)\\nnew_ans = [0]*n\\nfor i in range(n):\\n new_ans[i] = ind[visited[i]] + 1\\nprint(*new_ans)"}
{"id": "1412", "input": "\\ndef bins(sortedlist,x):\\n n=len(sortedlist)\\n start = 0\\n end = n - 1\\n\\n while(start <= end):\\n mid =int( (start + end)/2)\\n if (x == sortedlist[mid][0]):\\n return mid\\n elif(x < sortedlist[mid][0]):\\n end = mid - 1\\n else:\\n start = mid + 1 \\n \\n if(sortedlist[mid][0]<=x):\\n return mid\\n else:\\n return mid-1\\n\\n\\n\\n\\nn,s=list(map(int,input().split()))\\nhap=[]\\n\\nfor i in range(n):\\n hap.append(list(map(int,input().split())))\\na=0\\nmax1=0\\nb=0\\nsla=[]\\nslb=[]\\nslab=[]\\nfor i in range(n):\\n temp=hap[i][0]\\n", "gt": "hap[i][0]=hap[i][1]\\n hap[i][1]=hap[i][2]\\n hap[i][2]=temp\\nfor i in range(n):\\n\\n slab.append([hap[i][0]-hap[i][1],hap[i][2]])\\nhappi=0\\nfor i in range(n):\\n if(hap[i][0]>hap[i][1]):\\n a+=hap[i][2]\\n happi+=hap[i][2]*hap[i][0]\\n else:\\n b+=hap[i][2]\\n happi+=hap[i][2]*hap[i][1]\\nsla.sort()\\nslb.sort()\\nslab.sort()\\nif((a%s + b%s)>s):\\n print(happi)\\nelse:\\n loc=bins(slab,0)\\n happia=happi\\n count=0\\n #print(a,b)\\n b=b%s\\n a=a%s\\n left=b%s\\n \\n while(left>0):\\n if(slab[loc+count][1]<left):\\n happia+=slab[loc+count][0]*slab[loc+count][1]\\n left-=slab[loc+count][1]\\n else:\\n happia+=slab[loc+count][0]*left\\n break\\n count-=1\\n left=a%s\\n count=0\\n happib=happi\\n \\n while(loc<n and slab[loc][0]<=0):\\n loc+=1\\n #print(slab[loc][0])\\n while(left>0):\\n if(slab[loc+count][1]<left):\\n happib-=slab[loc+count][0]*slab[loc+count][1]\\n left-=slab[loc+count][1]\\n else:\\n happib-=slab[loc+count][0]*left\\n break\\n count+=1\\n #print(happia,happib,happi)\\n print(max(happia,happib)) \\n"}
{"id": "1413", "input": "from heapq import heappop, heappush\\n\\nn, k = [int(x) for x in input().split()]\\ncs = []\\nfor i in range(n):\\n l, r = [int(x) for x in input().split()]\\n cs.append((l, r, i+1))\\ncs.sort()\\nh = []\\nlcs = set()\\nfor i in range(k-1):\\n heappush(h, [cs[i][1], cs[i][2]])\\n lcs.add(cs[i][2])\\nl = -1\\npoped = []\\npush_i = k-1\\nfor i in range(k-1, n):\\n heappush(h,", "gt": "[cs[i][1], cs[i][2]])\\n d = h[0][0] - cs[i][0]\\n if d > l:\\n l = d\\n for j in range(push_i, i+1):\\n lcs.add(cs[j][2])\\n for e in poped:\\n lcs.remove(e)\\n push_i = i+1\\n poped = []\\n poped.append(heappop(h)[1])\\n\\nprint(l+1)\\nif l == -1:\\n for i in range(1, k+1):\\n print(i, end=' ')\\n\\nelse:\\n for i in lcs:\\n print(i, end=' ')\\n\\n"}
{"id": "1414", "input": "n = int(input())\\ns = input()\\nr = 0\\nfor i in", "gt": "range(n):\\n if s[i] in '2468':\\n r += i + 1\\nprint(r)"}
{"id": "1415", "input": "n, m = map(int, input().split())\\nm += 1\\nq = {'I': 0, 'M': 1, 'A': 2, 'D': 3}\\nt = []\\nfor i in range(n):\\n t += map(q.get, input())\\n t.append(-7)\\nt += [-7] * m\\np = [[] for q in t]\\nc = [0] * len(t)\\nfor a in range(n * m):\\n for b in (a - m, a + m, a - 1, a + 1):\\n if", "gt": "abs(t[b] - t[a] + 1) == 2:\\n p[a].append(b)\\n c[b] += 1\\ns = [i for i, q in enumerate(c) if not q]\\nwhile s:\\n a = s.pop()\\n for b in p[a]:\\n t[b] = max(t[b], t[a] + 1)\\n c[b] -= 1\\n if c[b] == 0: s.append(b)\\nk = max(t) - 2 >> 2\\nprint('Poor Inna!' if any(c) else k if k > 0 else 'Poor Dima!')"}
{"id": "1416", "input": "a, b, x, y = map(int, input().split())\\ns = input()\\np = []\\nfor i in range(a + 1):\\n p.append([0] * (b + 1))\\nsum = 0\\nfor i in range(len(s)):\\n if p[x][y] == 0:\\n p[x][y] = 1\\n print(1, end = ' ')\\n sum += 1\\n else:\\n print(0, end = ' ')\\n if", "gt": "s[i] == 'U' and x != 1:\\n x -= 1\\n if s[i] == 'D' and x != a:\\n x += 1\\n if s[i] == 'L' and y != 1:\\n y -= 1\\n if s[i] == 'R' and y != b:\\n y += 1\\nprint(a * b - sum)\\n\\n \\n"}
{"id": "1417", "input": "n, w = list(map(int, input().split()))\\na = sorted(map(int, input().split()))\\n\\nx =", "gt": "min(min(a[:n]), min(a[n:]) / 2)\\nprint(min(w, 3 * n * x))\\n"}
{"id": "1418", "input": "'''\\n// There are n! / (i+1)! * i permutations with decreasing seq length i (i+1 changes) for i <= n!\\n// There are n! / (i+1)! permutations for each 1 <= j <= i of position of moved one\\n\\n// All nonempty things\\n+ n*n! * (n*n! + 1) / 2\\n\\n// Subtract off everything inside one of them\\n- n! * n * (n+1) / 2\\n\\n// Subtract off everything that doesn't include the min-incr\\n- sum_{perm i,j} n * (n-i)\\n\\n// We're left with all words that include at least last of prv -> min-incr, which all have at least one match\\n\\n// No matches\\n+ sum_{i=1..n} n!/(n-i)!\\n\\n// First match is dist N, doesn't include anything\\n// aaa....aaa -> middle part can't all be decreasing\\n+ sum_{i=1..n} n! - n!/(n-i)!\\n\\n// First match is dist N, includes subst\\n// aaabxyc aaac\\n// Everything decreasing xycb\\n+ sum_{i=1..n-1} n!/(i+1)! * (n-i-1)\\n\\n// First match is dist N, includes min-incr -> is unique, already counted\\n\\n// First match is < N -> either came from min-incr or from subst\\n// You can distinguish because match..match includes everything smaller or everything smaller minus one of them\\n// Ending at min-incr gives unique thing\\n\\n// How many distinct things end at subst?\\n// Ending at subst: (b ijk ) lmn c xyz ... c such that zyxbcnmlkji are sorted leftovers\\n or b ijk", "gt": "lmn c xyz .... c\\n// Might as well not include xyz\\n+ sum_"}
{"id": "1419", "input": "def isPrime(n):\\n # a prime(except 2 or 3) is of the form 6k-1 or 6k+1\\n if n == 2 or n == 3:\\n return True\\n if n % 2 == 0 or n % 3 == 0:\\n return False\\n i = 5\\n w = 2\\n sqN = int(pow(n, .5))\\n while", "gt": "i <= sqN:\\n if n % i == 0:\\n return False\\n i += w\\n w = 6 - w\\n return True\\n\\nn = int(input().strip())\\narr = [0]*(n+1)\\nc = 1\\nfor i in range(2, n+1):\\n if isPrime(i):\\n arr[i] = c\\n for j in range(i+i, n+1, i):\\n if not arr[j]:\\n arr[j] = c\\n c += 1\\nprint(*arr[2:])"}
{"id": "1420", "input": "import sys\\n\\ninf = 1 << 30\\n\\ndef solve():\\n def check(mid):\\n tot = 1\\n line = 0\\n buf = 0\\n\\n for ch in s:\\n buf += 1\\n\\n if ch == ' ' or ch == '-':\\n if line + buf > mid:\\n tot += 1\\n\\n if tot > k or buf > mid:\\n return False\\n\\n line = buf\\n buf = 0\\n else:\\n line += buf\\n buf", "gt": "= 0\\n\\n if line + buf > mid:\\n tot += 1\\n\\n if tot > k or buf > mid:\\n return False\\n\\n return True\\n\\n k = int(input())\\n s = input()\\n\\n # binary-search\\n top = len(s)\\n btm = 0\\n\\n while top - btm > 1:\\n mid = (top + btm) // 2\\n\\n if check(mid):\\n top = mid\\n else:\\n btm = mid\\n\\n ans = top\\n\\n print(ans)\\n\\ndef __starting_point():\\n solve()\\n__starting_point()"}
{"id": "1421", "input": "n, l = list(map(int, input().split()))\\na = list(map(int, input().split()))\\na.sort()\\n\\nresult = 0\\nfor i in range(1, n):\\n result =", "gt": "max(result, (a[i] - a[i - 1]) / 2)\\nresult = max(result, a[0])\\nresult = max(result, l - a[-1])\\nprint(result)\\n"}
{"id": "1422", "input": "import sys\\ninput = sys.stdin.readline\\n\\noo = 10**20\\nn = int(input())\\na = list(map(int, input().split()))\\nadj = [[] for _ in range(n)]\\nfor _ in range(n-1):\\n u, v = [int(i) - 1 for i in input().split()]\\n adj[u].append(v)\\n adj[v].append(u)\\nsm = [0] * n\\nmx = [-oo] * n\\nbest = [-oo] * n\\n\\ndef dfs(start):\\n stack = [(start, -1)]\\n visit = [False] * n\\n while stack:\\n u, p = stack[-1]\\n if not visit[u]:\\n for v in adj[u]:\\n if", "gt": "v != p:\\n stack.append((v, u))\\n visit[u] = True\\n else:\\n x = [-oo] * 3\\n for v in adj[u]:\\n if v != p:\\n sm[u] += sm[v]\\n mx[u] = max(mx[u], mx[v])\\n best[u] = max(best[u], best[v])\\n x[0] = mx[v]\\n x.sort()\\n sm[u] += a[u]\\n mx[u] = max(mx[u], sm[u])\\n if x[1] > -oo and x[2] > -oo:\\n cur = x[1] + x[2]\\n best[u] = max(best[u], cur)\\n stack.pop()\\n\\ndfs(0)\\nans = max(best)\\nif ans <= -oo:\\n print('Impossible')\\nelse:\\n print(ans)"}
{"id": "1423", "input": "p, m = [i for i, x in enumerate(input(), 1) if x == '1'], int(input())\\nr, q = [(-1, 0, 0, [])], 'NO'\\nwhile r:\\n x, d, s, t = r.pop()\\n if s ==", "gt": "m: \\n q = 'YES\\n' + ' '.join(map(str, t))\\n break\\n for y in p:\\n if y != x and y > d: r.append((y, y - d, s + 1, t + [y]))\\nprint(q)\\n"}
{"id": "1424", "input": "n, l, r = list(map(int, input().split()))\\nread = lambda: list(map(int, input().split()))\\na = list(read())\\np = list(read())\\nd = [(a[i], p[i], i) for i in range(n)]\\nd.sort(key = lambda x: x[1])\\ncur = l - d[0][0]\\nb = [0] * n\\nfor", "gt": "i in range(n):\\n ind = d[i][2]\\n b[ind] = a[ind] + cur\\n if b[ind] < l:\\n cur = l - a[ind]\\n b[ind] = l\\n cur += 1\\nif max(b) > r: \\n print(-1)\\n return\\nprint(' '.join(map(str, b)))\\n"}
{"id": "1425", "input": "def check(i):\\n x, counter = armies[i] ^ armies[-1], 0\\n while x:\\n counter += x & 1\\n x >>=", "gt": "1\\n return counter <= k\\n\\nn, m, k = list(map(int, input().split()))\\narmies = [int(input()) for x in range(m + 1)]\\nprint(sum(map(check, list(range(m)))))\\n"}
{"id": "1426", "input": "n=int(input())\\nl1=list(map(int,input().split()))\\nl1.sort()\\nl1=l1[::-1]\\nans=[-1]*n\\ni=0\\ny=n-1\\nfor j in range(n):\\n if j%2==0:\\n ans[i]=l1[j]\\n i+=1\\n else :\\n ans[y]=l1[j]\\n y-=1\\nflag=0\\nfor i in", "gt": "range(n):\\n if ans[i]>=ans[i-1]+ans[(i+1)%n]:\\n flag=1\\n break\\nif flag==0:\\n print(\"YES\")\\n print(' '.join(str(x) for x in ans))\\nelse :\\n print(\"NO\")"}
{"id": "1427", "input": "from collections import *\\nfrom itertools import *\\nfrom bisect import *\\nfrom heapq import *\\n\\nimport math\\nfrom fractions import gcd\\nimport sys\\n#input = sys.stdin.readline\\n\\nimport copy\\n\\nN,M=list(map(int,input().split()))\\nUV=[list(map(int,input().split())) for i in range(M)]\\nS,T=list(map(int,input().split()))\\n\\ndata=[[] for i in range(N+1)]\\nfor u,v in UV:\\n data[u].append(v)\\n\\nvisited={S}\\nvisited1=set()\\nvisited2=set()\\nstack=deque([[S,0]])\\nwhile stack:\\n a,m=stack.popleft()\\n for p", "gt": "in data[a]:\\n z=(m+1)\\n\\n if z%3==0:\\n if p in visited:\\n continue\\n elif p == T:\\n print((z//3))\\n return\\n else:\\n visited.add(p)\\n if z%3==1:\\n if p in visited1:\\n continue\\n else:\\n visited1.add(p)\\n if z%3==2:\\n if p in visited2:\\n continue\\n else:\\n visited2.add(p)\\n stack.append([p,z])\\n\\nprint((-1))\\n"}
{"id": "1428", "input": "n=int(input())\\na=[int(x) for x in input().rstrip().split()]\\n\\nnow=1\\nmod=10**9+7\\ndef lcm(a,b):#最小公倍数\\n ori_a=a\\n ori_b=b\\n while b!=0:\\n a,b=b,a%b\\n return", "gt": "(ori_a*ori_b)//a\\n \\nfor i in a:\\n now=lcm(i,now)\\n# print(now)\\nprint((sum([now//i for i in a])%mod))\\n \\n"}
{"id": "1429", "input": "from collections import defaultdict\\nimport itertools\\nn, c = map(int, input().split())\\nD = [list(map(int, input().split()))for _ in range(c)]\\n\\n# 集計\\ndiago = [defaultdict(int)for _ in range(3)]\\nfor i in range(n):\\n for j, color in enumerate(map(int, input().split())):\\n color -= 1\\n if (i+j) % 3 == 0:\\n diago[0][color] += 1\\n elif (i+j) % 3 == 1:\\n diago[1][color] += 1\\n else:\\n", "gt": "diago[2][color] += 1\\n\\n\\n# 0列目をcにするときのcにするときの最小コスト\\ncosts = [[0]*c for _ in range(3)]\\nfor i in range(3):\\n for j in range(c):\\n for k, v in diago[i].items():\\n costs[i][j] += D[k][j]*v\\n\\nINF = 10**18\\nans = INF\\nfor trio in itertools.combinations(range(c), 3):\\n for color in itertools.permutations(trio, 3):\\n cost = sum(costs[i][j] for i, j in enumerate(color))\\n if cost < ans:\\n ans = cost\\nprint(ans)"}
{"id": "1430", "input": "import sys\\n\\nsys.setrecursionlimit(10 ** 6)\\nINF = float(\"inf\")\\nMOD = 10 ** 9 + 7\\n\\n\\ndef input():\\n return sys.stdin.readline().strip()\\n\\n\\ndef main():\\n N, S = input().split()\\n N = int(N)\\n ans = 0\\n\\n for i in range(N):\\n a = 0\\n c = 0\\n for j in", "gt": "range(i, N):\\n if S[j] == \"A\":\\n a += 1\\n elif S[j] == \"T\":\\n a -= 1\\n elif S[j] == \"C\":\\n c += 1\\n else:\\n c -= 1\\n\\n if a == c == 0:\\n ans += 1\\n\\n print(ans)\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1431", "input": "# import sys\\n# sys.setrecursionlimit(10 ** 6)\\n# import bisect\\n# from collections import deque\\n# from decorator import stop_watch\\n# \\n# \\n# @stop_watch\\ndef solve(N, K, S):\\n S = [int(s) for s in S]\\n point_l = 0\\n point_r = 0\\n # decision r\\n num_0 = 0 if S[0] == 1 else 1\\n flg = S[0]\\n for i in range(N):\\n if S[i] != flg:\\n if flg == 1:\\n num_0 += 1\\n if num_0 > K:\\n point_r = i - 1\\n break\\n flg = S[i]\\n if i == N - 1:\\n point_r = i\\n break\\n # measuring method\\n ans = point_r - point_l + 1\\n while point_r < N - 1:\\n # move point_l\\n for", "gt": "i in range(0, N):\\n if S[point_l + i] != S[point_l + i + 1]:\\n if S[point_l + i + 1] == 1:\\n point_l += i + 1\\n break\\n # move point_r\\n for i in range(1, N):\\n if point_r + i == N - 1:\\n point_r = N - 1\\n break\\n if S[point_r + i] != S[point_r + i + 1]:\\n if S[point_r + i + 1] == 0:\\n point_r += i\\n break\\n ans = max(ans, point_r - point_l + 1)\\n\\n print(ans)\\n\\n\\ndef __starting_point():\\n N, K = list(map(int, input().split()))\\n S = input()\\n solve(N, K, S)\\n\\n # # test\\n # from random import randint\\n # from func import random_str\\n # solve()\\n\\n__starting_point()"}
{"id": "1432", "input": "N = int(input())\\nA = tuple(map(int, input().split(' ')))\\n\\nbits = [0] * (N + 1)\\n\\ni = N\\nwhile i > 0:\\n j = i\\n ones = 0\\n while j <= N:\\n ones += bits[j]\\n", "gt": "j += i\\n if ones % 2 != A[i - 1]:\\n bits[i] = 1\\n i -= 1\\n\\nindexes = []\\nfor i in range(1, N + 1):\\n if bits[i] == 1:\\n indexes.append(i)\\n\\nprint((len(indexes)))\\nif indexes:\\n print((*indexes))\\n"}
{"id": "1433", "input": "n = int(input())\\na = list(map(int, input().split()))\\nans = a[0]\\nl = []\\n\\nfor i in range(1, n, 2):\\n ans -= a[i]\\n ans += a[i", "gt": "+ 1]\\n\\nl.append(ans)\\n\\nfor i in range(n - 1):\\n ans = (a[i] - ans//2)*2\\n l.append(ans)\\n\\nfor i in l:\\n print(i, end = \" \")"}
{"id": "1434", "input": "s, r = map(int, input().split())\\nv = []\\nfor i in range(s):\\n v += [list(map(int, input().split()))]\\nans = 0\\np = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\nfor i in range(s):\\n if v[i].count(1) == 0:\\n continue\\n if v[i].count(1) == 1:\\n ans += r - 1\\n else: \\n a = v[i].index(1)\\n b = v[i][::-1].index(1)\\n ans += 2 * r -", "gt": "a - b - 2 * v[i].count(1)\\nv1 = []\\nfor i in range(r):\\n v1 += [[v[j][i] for j in range(s)]]\\nfor i in range(r):\\n if v1[i].count(1) == 0:\\n continue\\n if v1[i].count(1) == 1:\\n ans += s - 1\\n else: \\n a = v1[i].index(1)\\n b = v1[i][::-1].index(1)\\n ans += 2 * s - a - b - 2 * v1[i].count(1)\\nprint(ans)"}
{"id": "1435", "input": "from heapq import heappush, heappop\\nqueue = []\\ndegree = []\\ns = []\\nans = []\\nn = int(input())\\nused = [False for i in range(n)]\\nfor i in range(n):\\n a, b = list(map(int, input().split()))\\n degree.append(a)\\n s.append(b)\\n heappush(queue, (a, i))\\nwhile queue:\\n", "gt": "el = heappop(queue)\\n vert = el[1]\\n if used[vert]:\\n continue\\n used[vert] = True\\n if degree[vert] == 0:\\n continue\\n other = s[vert]\\n ans.append((vert, other))\\n s[other] ^= vert\\n degree[other] -= 1\\n heappush(queue, (degree[other], other))\\nprint(len(ans))\\nfor el in ans:\\n print(el[0], el[1])\\n\\n"}
{"id": "1436", "input": "s=input()\\nans=0\\n\\ni=1\\npast=int(s[0])\\nc=1\\nans=1\\nwhile(i<len(s)):\\n if(int(s[i])+past==9):\\n c+=1\\n past=int(s[i])\\n else:\\n if(c%2==1 and c!=1):\\n ans*=(c//2+1)\\n", "gt": "c=1\\n past=int(s[i])\\n i+=1\\nif(c!=1 and c%2==1):\\n ans*=(c//2+1)\\n\\n \\nprint(ans)\\n \\n \\n \\n"}
{"id": "1437", "input": "\"\"\"\\nCodeforces Round 244 Div 1 Problem A\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\nclass InputHandlerObject(object):\\n inputs = []\\n\\n def getInput(self, n = 0):\\n res = \"\"\\n inputs = self.inputs\\n if not inputs: inputs.extend(input().split(\" \"))\\n if n == 0:\\n res = inputs[:]\\n inputs[:] = []\\n while n > len(inputs):\\n inputs.extend(input().split(\"", "gt": "\"))\\n if n > 0:\\n res = inputs[:n]\\n inputs[:n] = []\\n return res\\nInputHandler = InputHandlerObject()\\ng = InputHandler.getInput\\n\\n############################## SOLUTION ##############################\\nn = int(input())\\na = [int(x) for x in g()]\\nct = 0\\nres = 0\\nfor i in a:\\n ct += i\\n if ct < 0:\\n res += 1\\n ct = 0\\nprint(res)"}
{"id": "1438", "input": "MOD = 1000000007\\n\\ndef main():\\n opts = [0] * 64\\n for i in range(64):\\n for j in range(64):\\n opts[i & j] += 1\\n\\n s = input()\\n n = len(s)\\n ans = 1\\n for c in s:\\n if '0' <= c <= '9':\\n ans *= opts[ord(c) - ord('0')]\\n ans %= MOD\\n", "gt": "elif 'A' <= c <= 'Z':\\n ans *= opts[ord(c) - ord('A') + 10]\\n ans %= MOD\\n elif 'a' <= c <= 'z':\\n ans *= opts[ord(c) - ord('a') + 36]\\n ans %= MOD\\n elif c == '-':\\n ans *= opts[62]\\n ans %= MOD\\n else:\\n ans *= opts[63]\\n ans %= MOD\\n\\n print(ans)\\n\\nmain()\\n"}
{"id": "1439", "input": "n,k = list(map(int, input().split()))\\nA = list(map(int, input().split()))\\nB = list(map(int, input().split()))\\nr = 0\\nok = 1\\nwhile ok:\\n L = [0 for _ in range(n)]\\n for i in range(n):\\n B[i] = B[i]", "gt": "- A[i]\\n if B[i] < 0:\\n L[i] = -B[i]\\n B[i] = 0\\n if sum(L) <= k:\\n r += 1\\n k = k - sum(L)\\n else:\\n ok = 0\\nprint(r)\\n \\n"}
{"id": "1440", "input": "__author__ = 'User'\\nn, m = list(map(int, input().split()))\\narr = list(map(int, input().split()))\\nfor i in range(n):\\n arr[i] = arr[i] % m\\nd = [0] * m\\nfor e in arr:\\n t = [0] * m\\n t[e] = 1\\n for i in range(m):\\n", "gt": "if d[i] == 1:\\n #print(\"T\", i + e)\\n t[(i + e) % m] = 1\\n for i in range(m):\\n if t[i] == 1:\\n d[i] = 1\\n #print(d)\\n if d[0] == 1:\\n break\\nif d[0] == 1:\\n print(\"YES\")\\nelse:\\n print(\"NO\")\\n#print(d)\\n#print(arr)\\n"}
{"id": "1441", "input": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\\n\\nsys.setrecursionlimit(10**7)\\ninf = 10**20\\neps = 1.0 / 10**10\\nmod = 10**9+7\\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\\n\\ndef LI(): return list(map(int, sys.stdin.readline().split()))\\ndef LLI(): return [tuple(map(int, l.split())) for l in sys.stdin]\\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\\ndef LS(): return sys.stdin.readline().split()\\ndef I(): return int(sys.stdin.readline())\\ndef F(): return float(sys.stdin.readline())\\ndef S(): return input()\\ndef pf(s): return print(s, flush=True)\\n\\n\\ndef main():\\n", "gt": "n = I()\\n a = LI()\\n\\n r = 0\\n ai = 0\\n for i in range(n):\\n if a[i] < 2:\\n continue\\n while ai < i:\\n if a[ai] < 1:\\n ai += 1\\n continue\\n if a[i] < 2:\\n break\\n r += 1\\n a[ai] -= 1\\n a[i] -= 2\\n r += a[i] // 3\\n a[i] %= 3\\n\\n return r\\n\\nprint(main())\\n\\n\\n"}
{"id": "1442", "input": "m = 1000000007\\nn = int(input())\\na = map(int, input().split())\\nt1, t2 = 0, 0\\nfor i in a:\\n if i == 1:\\n t1 += 1\\n else:\\n t2 += 1\\na =", "gt": "[1, 2]\\nfor i in range(3, t1+1):\\n a = a[::-1]\\n a[1] = (a[0]+(i-1)*a[1])%m\\nif not t1 or t1 == 1:\\n a[1] = 1\\nfor i in range(t1+1, n+1):\\n a[1] = a[1]*i%m\\nprint(a[1])"}
{"id": "1443", "input": "#!/usr/bin/env python3\\nimport collections\\n\\nn, s = list(map(int, input().split()))\\n\\nbuy_orders = collections.defaultdict(int)\\nsell_orders = collections.defaultdict(int)\\n\\nfor i in range(n):\\n d, p, q = input().split()\\n p, q = int(p), int(q)\\n\\n if d", "gt": "== 'B':\\n buy_orders[p] += q\\n else:\\n sell_orders[p] += q\\n\\nbuy_orders = sorted(list(buy_orders.items()), reverse=True)\\nsell_orders = sorted(list(sell_orders.items()), reverse=True)\\n\\nfor order in sell_orders[-s:]:\\n print('S', order[0], order[1])\\nfor order in buy_orders[:s]:\\n print('B', order[0], order[1])\\n"}
{"id": "1444", "input": "n=int(input())\\nl=list(map(int,input().split()))\\ns=input()\\nwater=0\\ngrass=0\\ncgrass=0\\ntime=0\\nseen=False\\nfor i in range(n):\\n if s[i]==\"G\":\\n dist=l[i]\\n if water>=dist:\\n water-=dist\\n time+=2*dist\\n cgrass+=dist\\n else:\\n dist-=water\\n time+=2*water\\n cgrass+=water\\n water=0\\n time+=3*dist\\n grass+=dist\\n elif s[i]==\"W\":\\n water+=l[i]\\n time+=2*l[i]\\n seen=True\\n else:\\n dist=l[i]\\n if water>=dist:\\n", "gt": "water-=dist\\n time+=2*dist\\n else:\\n dist-=water\\n time+=2*water\\n water=0\\n if cgrass>=dist:\\n cgrass-=dist\\n grass+=dist\\n time+=3*dist\\n else:\\n dist-=cgrass\\n grass+=cgrass\\n time+=3*cgrass\\n cgrass=0\\n if grass>=dist:\\n grass-=dist\\n time+=3*dist\\n else:\\n dist-=grass\\n time+=3*grass\\n grass=0\\n if seen:\\n time+=4*dist\\n else:\\n time+=6*dist\\nprint(time)"}
{"id": "1445", "input": "from sys import stdin\\n\\nn = int(stdin.readline())\\na = [int(x) for x in stdin.readline().split()]\\na = sorted([(a[x],str(x+1)) for x in range(n)])\\nk = int(stdin.readline())\\n\\nsums = [0]\\nfor x in a:\\n sums.append(sums[-1]+x[0])\\n\\ntotal = 0\\ns = 0\\n\\nfor x in range(k):\\n total += a[x][0]*x-s\\n s", "gt": "+= a[x][0]\\n\\nlow = total\\nlowInd = 0\\n\\n#print(total)\\n\\nfor x in range(n-k):\\n s -= a[x][0]\\n total -= s-a[x][0]*(k-1)\\n total += a[x+k][0]*(k-1)-s\\n s += a[x+k][0]\\n if total < low:\\n low = total\\n lowInd = x+1\\n\\nout = []\\n\\nfor x in range(lowInd,lowInd+k):\\n out.append(a[x][1])\\nprint(' '.join(out))\\n"}
{"id": "1446", "input": "n = int(input())\\na = list(map(int, input().split()))\\ni = 1\\nwhile i <= n - i + 1:\\n", "gt": "if i % 2:\\n a[i - 1], a[-i] = a[-i], a[i - 1]\\n i += 1\\nprint(*a)\\n"}
{"id": "1447", "input": "#!/usr/bin/env python3\\nfrom sys import stdin\\nfrom bisect import bisect_left, bisect_right\\n \\nINF = int(1e9)\\n\\ndef find(par, a):\\n if par[a] == a:\\n return a\\n par[a] = find(par, par[a])\\n return par[a]\\n\\ndef union(par, rnk, a, b):\\n a = find(par,a)\\n b = find(par,b)\\n if a==b:\\n return\\n \\n if rnk[a]<rnk[b]:\\n par[a] = b\\n else:\\n par[b] = a\\n if rnk[a]==rnk[b]:\\n rnk[a] += 1\\n \\ndef solve():\\n n, m, k = map(int, stdin.readline().split())\\n cnts = list(map(int, stdin.readline().split()))\\n for i in range(1,k):\\n cnts[i] += cnts[i-1]\\n \\n group = list(range(n))\\n rnk = [0 for i in range(n)]\\n adj = [[INF for j in range(k)] for i in range(k)]\\n for i in", "gt": "range(m):\\n u, v, x = map(int, stdin.readline().split())\\n if x==0:\\n union(group, rnk, u-1, v-1)\\n tu = bisect_left(cnts, u)\\n tv = bisect_left(cnts, v)\\n adj[tu][tv] = min(adj[tu][tv], x)\\n adj[tv][tu] = min(adj[tv][tu], x)\\n \\n p = 0\\n for i in range(k):\\n cur = group[p]\\n while p<cnts[i]:\\n if group[p]!=cur:\\n print(\"No\")\\n return\\n p += 1\\n print(\"Yes\")\\n \\n for p in range(k):\\n for i in range(k):\\n for j in range(k):\\n adj[i][j] = min(adj[i][j], adj[i][p]+adj[p][j])\\n \\n for i in range(k):\\n adj[i][i] = 0\\n for j in range(k):\\n if adj[i][j] == INF:\\n adj[i][j] = -1\\n \\n for i in range(k):\\n print(' '.join(map(lambda x: str(x), adj[i])))\\n \\n \\nsolve()"}
{"id": "1448", "input": "n, m = map(int, input().split())\\n\\nif n == 1:\\n print(1)\\nelse:\\n print('{:9}'.format((n-1)/n *", "gt": "(m - 1) / (n*m - 1) + 1 / n))"}
{"id": "1449", "input": "n, d = list(map(int, input().split()))\\n\\nfor i in range(int(input())):\\n x, y = list(map(int, input().split()))\\n print(('YES' if x+y in", "gt": "range(d, n + n - d + 1) and x-y in range(-d, d + 1) else 'NO'));\\n"}
{"id": "1450", "input": "\\nt=int(input())\\nfor nbt in range(t):\\n n,k=[int(i) for i in input().split()]\\n a=[int(i) for i", "gt": "in input().split()]\\n nbc=len(set(a))-1\\n if k==1:\\n if nbc:\\n print(-1)\\n else:\\n print(1)\\n else:\\n print(1+max(0,(nbc-1)//(k-1)))"}
{"id": "1451", "input": "s = input()\\npref = []\\ncnt1 = s.count('1')\\ns = s.replace('1', '')\\ni = 0\\nwhile i < len(s) and s[i] != '2':\\n", "gt": "i += 1\\nend = ''\\nif i != len(s):\\n end = s[i:]\\ns = s[:i] + '1' * cnt1 + end\\nprint(s)"}
{"id": "1452", "input": "n, k = list(map(int,", "gt": "input().split()))\\nprint(sum(s.count('4')+s.count('7')<=k for s in input().split()))"}
{"id": "1453", "input": "from collections import defaultdict,deque\\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\\nsys.setrecursionlimit(10**8)\\nINF = float('inf')\\nmod = 10**9+7\\neps = 10**-7\\ndef inp(): return int(sys.stdin.readline())\\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\\ndef inpl_str(): return list(sys.stdin.readline().split())\\n\\nH,W = inpl()\\nrr = inpl()\\ncc = inpl()\\n\\nMAP = [[-1]*W for _ in range(H)]\\n\\nfor x,c in enumerate(cc):\\n for y in range(c):\\n MAP[y][x] = 1\\n if c < H:\\n", "gt": "MAP[c][x] = 0\\n\\n\\nfor y,r in enumerate(rr):\\n for x in range(r):\\n if MAP[y][x] == 0:\\n print(0)\\n return\\n MAP[y][x] = 1\\n if r < W:\\n if MAP[y][r] == 1:\\n print(0)\\n return\\n MAP[y][r] = 0\\n\\ncnt = 0\\nfor y in range(H):\\n for x in range(W):\\n if MAP[y][x] == -1:\\n cnt += 1\\n\\nprint(pow(2,cnt,mod))\\n"}
{"id": "1454", "input": "n, m = list(map(int, input().split()))\\nA = list(map(int, input().split()))\\nA.sort()\\nans = [0] * n\\nprefsum = [0] * m\\nprefsum[0] = A[0]\\nans[0] = A[0]\\nfor", "gt": "i in range(1, n):\\n ans[i] = ans[i - 1] + prefsum[i % m] + A[i]\\n prefsum[i % m] += A[i]\\nprint(*ans)\\n"}
{"id": "1455", "input": "n, m = map(int, input().split())\\nmatr = [list(map(int, input().split())) for _ in range(n)]\\n\\nfor i, st in enumerate(matr):\\n for j, elem in enumerate(st):\\n if matr[~i][~j] == 0:\\n matr[~i][~j] = min(matr[~i + 1][~j], matr[~i][~j + 1]) - 1\\n\\n# print(*matr, sep='\\n')\\n\\nfor i, st in enumerate(matr):\\n for j, elem in enumerate(st):\\n if i != 0", "gt": "and j != 0:\\n if matr[i][j] <= max(matr[i - 1][j], matr[i][j - 1]):\\n print('-1')\\n return\\n elif i == 0 and j != 0:\\n if matr[i][j] <= matr[i][j - 1]:\\n print('-1')\\n return\\n elif i != 0 and j == 0:\\n if matr[i][j] <= matr[i - 1][j]:\\n print('-1')\\n return\\nprint(sum(sum(l) for l in matr))"}
{"id": "1456", "input": "n = int(input())\\nm = (n + 2) // 2\\nd = [0, 1]\\nprint(m)\\nfor i in range(1,", "gt": "n + 1):\\n if d[0] < m:\\n d[0] += 1\\n print(*d)\\n else:\\n d[1] += 1\\n print(*d)\\n"}
{"id": "1457", "input": "import sys\\nn = int(input())\\ns = [input() for i in range(n)]\\na = [[1] * (2 * n) for i in range(2 * n)]\\n\\nfor i in range(n):\\n for j in range(n):\\n if s[i][j] != 'o':\\n continue\\n for x in range(n):\\n for y in range(n):\\n if s[x][y] == '.':\\n a[n + x - i][n + y - j] = 0\\nfor i in range(n):\\n for j in range(n):\\n if s[i][j] != 'x':\\n continue\\n c = 0\\n", "gt": "for x in range(n):\\n for y in range(n):\\n if s[x][y] == 'o' and a[n + i - x][n + j - y] == 1:\\n c = 1\\n break\\n if c == 1:\\n break\\n if c == 0:\\n print('NO')\\n return\\nprint('YES')\\nfor i in range(1, 2 * n):\\n for j in range(1, 2 * n):\\n if i == n and j == n:\\n print('o', end='')\\n elif a[i][j] == 1:\\n print('x', end='')\\n else:\\n print('.', end='')\\n print('')\\n\\n"}
{"id": "1458", "input": "def main():\\n\\n a = str(input())\\n", "gt": "b = str(input())\\n\\n print(a.count(b))\\n\\n\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "1459", "input": "n = int(input())\\ns = input()\\nfor i in range(len(s) - 1):\\n if s[i]", "gt": "> s[i + 1]:\\n print(\"YES\")\\n print(i + 1, i + 2)\\n return\\nprint(\"NO\")\\n"}
{"id": "1460", "input": "def calc_shortest(N, D, s1, s2):\\n #D[1:3] = D[1]+D[2] = d_2+d_3 = distance between Station 2 and Station 4\\n if s1 == s2:\\n return 0\\n elif s1 < s2:\\n s1_index = s1-1\\n s2_index = s2-1\\n else:\\n s1_index = s2-1\\n s2_index =", "gt": "s1-1\\n\\n #print(\"s1:\"+str(s1_index)+\" s2:\"+str(s2_index))\\n path1 = sum(D[s1_index:s2_index])\\n path2 = sum(D)-path1\\n\\n if path1 < path2:\\n return path1\\n else:\\n return path2\\n\\nN = [int(i) for i in input().strip().split()][0]\\nD = [int(i) for i in input().strip().split()]\\ns1, s2 = [int(i) for i in input().strip().split()]\\nprint(calc_shortest(N, D, s1, s2))\\nreturn"}
{"id": "1461", "input": "n = int(input())\\nprint(n*3+4)\\nprint(0, 0)\\nprint(1, 0)\\nfor i in range(n):\\n", "gt": "for j in range(3):\\n print(i+j, i+1)\\nprint(n, n+1)\\nprint(n+1, n+1)\\n"}
{"id": "1462", "input": "g = {}\\ndef push(u, v, w):\\n g[u] = [v, w]\\n \\nn, pos = list(map(int, input().split()))\\nV = list(map(int, input().split()))\\nW = list(map(int, input().split()))\\n \\nfor _ in range(n):\\n push(_, V[_], W[_])\\n \\nmax_log = 35\\nnext_n = [[-1] * n for _ in range(max_log)]\\nnext_m = [[float('inf')] * n for _ in range(max_log)]\\nnext_s = [[0] * n for _ in range(max_log)]\\n \\nfor u in range(n):\\n v, w = g[u]\\n next_n[0][u] = v\\n next_m[0][u] = w\\n next_s[0][u] = w\\n \\nfor k in range(1, max_log):\\n for u in range(n):\\n v = next_n[k-1][u]\\n m = next_m[k-1][u]\\n s = next_s[k-1][u]\\n \\n next_n[k][u]", "gt": "= next_n[k-1][v] \\n next_m[k][u] = min(next_m[k-1][v], m)\\n next_s[k][u] = next_s[k-1][v] + s\\n \\nm_arr = [float('inf')] * n\\ns_arr = [0] * n\\n \\nfor _ in range(n):\\n s, m = 0, float('inf')\\n v = _\\n \\n cur = 1<<max_log\\n i = max_log\\n \\n while cur > 0:\\n if cur & pos:\\n m = min(m, next_m[i][v])\\n s = s + next_s[i][v]\\n v = next_n[i][v]\\n \\n cur >>= 1\\n i -= 1\\n \\n m_arr[_] = m\\n s_arr[_] = s\\n \\narr = [str(x) + ' ' + str(y) for x, y in zip(s_arr, m_arr)]\\nprint('\\n'.join([x for x in arr]))\\n"}
{"id": "1463", "input": "n, k = map(int, input().split())\\narr = [0] * 26\\ns = input()\\naux = ord('A')\\nfor i in range(len(s)):\\n arr[ord(s[i]) - aux] += 1\\narr.sort(reverse = True)\\ni = 0\\nsum = 0\\nwhile", "gt": "k > 0:\\n if arr[i] >= k:\\n sum += k ** 2\\n k = 0\\n else:\\n k -= arr[i]\\n sum += arr[i] ** 2\\n i += 1\\nprint(sum)"}
{"id": "1464", "input": "N = int(input())\\ntable = []\\nfor i in range(N):\\n table.append(list(map(int, input().split())))\\n\\nfor i in range(N):\\n for j in range(N):\\n if table[i][j] == 1:\\n continue\\n flg =", "gt": "False\\n for s in range(N):\\n for t in range(N):\\n if table[i][j] == table[i][s] + table[t][j]:\\n flg = True\\n break\\n if not flg:\\n print(\"No\")\\n return\\nprint(\"Yes\")\\n"}
{"id": "1465", "input": "import re\\nimport itertools\\nfrom collections import Counter\\n\\nclass Task:\\n strings = []\\n answer = \"\"\\n \\n def getData(self):\\n numberOfStrings = int(input())\\n for i in range(0, numberOfStrings):\\n self.strings += [input()]\\n \\n def solve(self):\\n badStrings = set()\\n for current in self.strings:\\n for left in range(0, len(current)):\\n for right in range(left + 1, len(current) +1):\\n badStrings.add(current[left : right])\\n alphabet = []\\n for character in range(ord('a'), ord('z') + 1):\\n alphabet += [chr(character)]\\n \\n for answerLength in range(1, 21 + 1):\\n for p in itertools.product(alphabet, repeat = answerLength):\\n string = re.sub(\"[^\\w]\", \"\", str(p));\\n if string not in badStrings:\\n self.answer =", "gt": "string\\n return\\n\\n def printAnswer(self):\\n print(self.answer)\\n\\ntask = Task();"}
{"id": "1466", "input": "n,k=map(int,input().split())\\na=list(input())\\nans,cnt=list(list()),0\\nwhile True :\\n cur=list()\\n for i in range(n-1) :\\n if a[i]=='R' and a[i+1]=='L' :\\n cur.append(i)\\n cnt+=1\\n if len(cur)>0:\\n ans.append(cur.copy())\\n for i in cur :\\n a[i],a[i+1]=a[i+1],a[i]\\n else :\\n break \\nif len(ans)>k or cnt<k:\\n", "gt": "print(-1)\\nelse :\\n lst=list()\\n dumb=k-len(ans)\\n w,p=0,0\\n while dumb>0 :\\n lst.append(\"1 \"+str(ans[w][p]+1)+\"\\n\")\\n dumb-=1\\n p+=1\\n if p==len(ans[w]) :\\n p=0\\n w+=1\\n dumb+=1\\n while w<len(ans) :\\n lst.append(str(len(ans[w])-p)+\" \")\\n while p<len(ans[w]) :\\n lst.append(str(ans[w][p]+1)+\" \")\\n p+=1\\n lst.append(\"\\n\")\\n w+=1\\n p=0\\n print(\"\".join(lst))"}
{"id": "1467", "input": "from collections import Counter, defaultdict\\nimport heapq\\nfrom sys import stdin, stdout\\nraw_input = stdin.readline\\nxrange=range\\nn,m,k=list(map(int,input().split()))\\nk=min(n-1,k)\\np=[0]*(n+1)\\nvis = [0]*(n+1)\\nd=[[] for i in range(n+1)]\\nans=[]\\ndp={}\\nfor i in range(m):\\n u,v,w=list(map(int,input().split()))\\n d[u].append((v,w))\\n d[v].append((u,w))\\n dp[(u,v)]=i+1\\n", "gt": "dp[(v,u)]=i+1\\nq=[(0,1,1)]\\nc=0\\nwhile q:\\n wt,x,par=heapq.heappop(q)\\n if vis[x]:\\n continue\\n vis[x]=1\\n c+=1\\n if par!=x:\\n \\n ans.append(str(dp[(par,x)]))\\n if c>k:\\n break\\n \\n for i,w in d[x]:\\n if not vis[i]:\\n heapq.heappush(q,(wt+w,i,x))\\nprint(len(ans))\\nprint(' '.join(ans))\\n"}
{"id": "1468", "input": "import sys\\nfrom math import *\\nfrom fractions import gcd\\nreadints=lambda:list(map(int, input().strip('\\n').split()))\\n\\nn=int(input())\\narr = list(readints())\\n\\npref=0\\nbasis=[]\\n\\nfor v in arr:\\n pref", "gt": "= pref^v\\n for b in basis:\\n v = min(v, v^b)\\n if v>0:\\n basis.append(v)\\n\\n\\nif pref==0:\\n print(-1)\\nelse:\\n print(len(basis))\\n"}
{"id": "1469", "input": "def sortHashtags(htags):\\n def shorten(j, i):\\n s = 0\\n while s < len(htags[i]) and htags[i][s] == htags[j][s]:\\n s += 1\\n htags[j] = htags[j][:s]\\n\\n n", "gt": "= len(htags)\\n\\n\\n for i in range(n-1, 0, -1):\\n if htags[i-1] > htags[i]:\\n shorten(i-1, i)\\n\\n return '\\n'.join(htags)\\n\\nn = int(input())\\ntags = []\\nfor i in range(n):\\n tags.append(input())\\n\\nprint(sortHashtags(tags))\\n"}
{"id": "1470", "input": "import math\\n\\nl = int(input()) - 1\\nn = int(math.log2(l + 1) + 1)\\nres = []\\nfor i in range(n - 1):\\n res.append([i + 1, i + 2, 0])\\n res.append([i + 1, i + 2, 2 ** i])\\ni = n - 2\\nwhile l > 2", "gt": "** (n - 1) - 1:\\n t = l - 2 ** i + 1\\n if t > 2 ** (n - 1) - 1:\\n res.append([i + 1, n, t])\\n l = t - 1\\n i -= 1\\nprint((n, len(res)))\\nfor i in range(len(res)):\\n print((res[i][0],res[i][1],res[i][2]))\\n"}
{"id": "1471", "input": "x = int(input())\\nif x <= 6:\\n print((1))\\n return\\nelif 7 < x <= 11:\\n print((2))\\n return\\nelse:\\n n =", "gt": "x//11\\n if x - n*11 == 0:\\n print((2*n))\\n return\\n elif x - n*11 <= 6:\\n print((2*n+1))\\n else:\\n print((2*n+2))\\n"}
{"id": "1472", "input": "N = int(input())\\nu, v, w = [0]*(N-1), [0]*(N-1), [0]*(N-1)\\nn = [-1] * N\\n# n[][0] 色 n[][1] 連結先一覧リスト n[][2] mod2 \\nfor i in range(N):\\n n[i] = [0]*4\\n n[i][1] = []\\n n[i][2] = []\\n\\nfor i in range(N-1):\\n u[i], v[i], w[i] = list(map(int, input().split()))\\n n[u[i]-1][1].append(v[i]-1)\\n n[v[i]-1][1].append(u[i]-1)\\n", "gt": "n[u[i]-1][2].append(w[i]%2)\\n n[v[i]-1][2].append(w[i]%2)\\n\\nstack = [u[0]-1]\\n\\nwhile True:\\n num = stack.pop()\\n n[num][3] = 1\\n for i in range(len(n[num][1])):\\n if n[n[num][1][i]][3] == 0:\\n stack.append(n[num][1][i])\\n if n[num][2][i] == 0:\\n n[n[num][1][i]][0] = n[num][0]\\n else:\\n n[n[num][1][i]][0] = -1 * n[num][0] + 1\\n if len(stack) == 0:\\n break\\n\\nfor i in n:\\n print(i[0])"}
{"id": "1473", "input": "#!/usr/bin/env python3\\nimport sys\\n\\ninput = sys.stdin.readline\\n\\n\\ndef S():\\n return input().rstrip()\\n\\n\\ndef I():\\n return int(input())\\n\\n\\ndef MI():\\n return list(map(int, input().split()))\\n\\n\\nN, X, Y = MI()\\ncnt = [0] * N\\n\\nfor i in range(1, N + 1):\\n", "gt": "for j in range(i + 1, N + 1):\\n idx = min(j - i, abs(X - i) + abs(Y - j) + 1)\\n cnt[idx] += 1\\n\\nfor c in cnt[1:]:\\n print(c)\\n"}
{"id": "1474", "input": "n=int(input())\\nd={}\\nd1={}\\nfor i in range(n):\\n a,b=list(map(int,input().split()))\\n d[a]=b\\n d1[b]=a\\nr=[0]*n\\nfront=0\\ni=1\\nwhile i<n:\\n r[i] = d.get(front)\\n front = r[i]\\n i += 2\\nfor f in", "gt": "list(d.keys()):\\n if d1.get(f) == None:\\n front = f\\n break\\nr[0]=front\\ni=2\\nwhile i<n:\\n r[i] = d.get(front)\\n front = r[i]\\n i += 2\\nprint(*r)\\n\\n"}
{"id": "1475", "input": "mod = 10 ** 9 + 7\\nn = int(input())\\nh = list([int(x) - 1 for x in input().split()])\\nans = x = 0\\nfor i in range(n):\\n ans += h[i] + min(h[i], h[i", "gt": "- 1]) * x\\n if i < n - 1:\\n x *= min(h[i - 1], h[i], h[i + 1])\\n x += min(h[i], h[i + 1])\\n ans %= mod\\n x %= mod\\nprint(ans)\\n"}
{"id": "1476", "input": "p = 10 ** 9 + 7\\nn, b, k, x = [int(s) for s in input().split()]\\nblock = [int(s) for s in input().split()]\\nD = [0 for i in range(10)]\\nfor s in block:\\n D[s] += 1\\nA = [[0 for t in range(x)]]\\npows = [pow(10, 1<<j, x) for j in range(b.bit_length())]\\nfor i in range(10):\\n A[0][i%x] +=", "gt": "D[i]\\nfor j in range(b.bit_length()-1):\\n B = A[-1]\\n C = [sum(B[i]*B[(t - i*pows[j])%x] for i in range(x)) % p for t in range(x)]\\n A.append(C)\\nans = None\\nfor j in range(b.bit_length()):\\n if (b>>j)&1:\\n if ans is None:\\n ans = A[j][:]\\n else:\\n ans = [sum(A[j][(t - i*pows[j])%x]*ans[i] for i in range(x)) % p for t in range(x)]\\nprint(ans[k])\\n\\n"}
{"id": "1477", "input": "n = int(input())\\nif n >= 5:\\n print(n)\\n for i in range(1, n + 1, 2):\\n print(i, end = ' ')\\n for i in range(2,", "gt": "n + 1, 2):\\n print(i, end = ' ')\\nelif n == 4:\\n print(4)\\n print(3, 1, 4, 2)\\nelif n == 3:\\n print(2)\\n print(1, 3)\\nelse:\\n print(1)\\n print(1)"}
{"id": "1478", "input": "n, m = (int(x) for x in input().strip().split())\\n\\ncoproc = [int(x) for x in input().strip().split()]\\nedges = []\\nfor _ in range(m):\\n edges.append((int(x) for x in input().strip().split()))\\n\\ninorder = [0] * n \\nadj = [[] for _ in range(n)]\\nfor u, v in edges:\\n adj[v].append(u)\\n inorder[u] += 1\\n \\nqueue0 = [u for u in range(n) if inorder[u]==0 and not coproc[u]]\\nqueue1 = [u for u in range(n) if inorder[u]==0 and coproc[u]]\\n\\nres = 0 \\n\\nwhile len(queue0)>0 or len(queue1)>0:\\n", "gt": "\\n while queue0:\\n next0 = []\\n for u in queue0:\\n for v in adj[u]:\\n inorder[v] -= 1 \\n if inorder[v] == 0:\\n if coproc[v]:\\n queue1.append(v)\\n else:\\n next0.append(v)\\n queue0 = next0\\n \\n if queue1:\\n res += 1 # coproc call\\n \\n \\n while queue1:\\n next1 = []\\n for u in queue1:\\n for v in adj[u]:\\n inorder[v] -= 1 \\n if inorder[v] == 0:\\n if coproc[v]:\\n next1.append(v)\\n else:\\n queue0.append(v)\\n queue1 = next1\\n \\nprint(res)"}
{"id": "1479", "input": "\\nimport sys\\n#sys.stdin=open(\"data.txt\")\\ninput=sys.stdin.readline\\n\\nstuff=input().split(\",\")\\nn=len(stuff)\\n\\ncomm=[[] for _ in range(1000001)]\\nst=[1000001]\\n\\nfor i in range(0,n,2):\\n while st[-1]==0: st.pop(-1)\\n comm[len(st)].append(stuff[i])\\n", "gt": "st[-1]-=1\\n st.append(int(stuff[i+1]))\\n\\nmaxd=0\\nfor i in range(1000000,0,-1):\\n if len(comm[i]):\\n maxd=i\\n break\\n\\nprint(maxd)\\nfor i in range(1,maxd+1):\\n print(\" \".join(comm[i]))"}
{"id": "1480", "input": "n, m, k = list(map(int, str.split(input())))\\nf = tuple([str.strip(input()) for _ in range(n)])\\n\\nr = []\\nfor x in range(m):\\n\\n cr = sum([f[y][x] == \"U\" for y in range(0, n, 2)])\\n for cx in range(max(0, x", "gt": "+ 1 - n), x):\\n\\n cr += f[x - cx][cx] == \"R\"\\n\\n for cx in range(x + 1, min(m, n + x)):\\n\\n cr += f[cx - x][cx] == \"L\"\\n\\n r.append(cr)\\n\\nprint(str.join(\" \", list(map(str, r))))\\n"}
{"id": "1481", "input": "n, k = map(int, input().split())\\naa = [int(x) for x in input().split()]\\n\\nnxt = [(i + 1) % n for i in range(n)]\\nprv = [(i - 1 + n) % n for i in range(n)]\\n\\ncur =", "gt": "0\\nfor z in range(k):\\n a = aa[z]\\n a %= n\\n for i in range(a):\\n cur = nxt[cur]\\n nxt[prv[cur]] = nxt[cur]\\n prv[nxt[cur]] = prv[cur]\\n print(cur + 1, end=' ')\\n cur = nxt[cur]\\n n -= 1\\n"}
{"id": "1482", "input": "n = int(input())\\ns = []\\nfor i in range(n):\\n s.append(input())\\nnew = [[0] * n for i in range(n)]\\nfor i in range(n):\\n for j in range(n):\\n if s[i][j] == 'o':\\n new[i][j] = 1\\nflag = True\\nfor i in range(n):\\n for j in range(n):\\n s = 0\\n if i > 0 and new[i - 1][j] == 1:\\n s += 1\\n", "gt": "if i < n - 1 and new[i + 1][j] == 1:\\n s += 1\\n if j > 0 and new[i][j - 1] == 1:\\n s += 1\\n if j < n - 1 and new[i][j + 1] == 1:\\n s += 1\\n if s % 2 == 1:\\n flag = False\\n break\\nif flag:\\n print(\"YES\")\\nelse:\\n print(\"NO\")"}
{"id": "1483", "input": "#CF Round 150. Div II Prob. A - Dividing Orange\\nimport sys\\n\\nIn = sys.stdin\\nn, k = [int(x) for x in In.readline().split()]\\narr, s, cnt = [int(x) for x in In.readline().split()], set(), 1;\\ns.update(arr)\\nfori in range(k):\\n c = [arr[i]]\\n for j in range(n - 1):\\n while (cnt in s):\\n cnt += 1;\\n c.append(cnt)\\n cnt", "gt": "+= 1;"}
{"id": "1484", "input": "n = int(input())\\np = [int(i) for i in input().split()]\\nfor i in range(n):\\n tmp = [0] * n\\n j =", "gt": "i\\n while tmp[j] != 1:\\n tmp[j] = 1\\n j = p[j] - 1\\n print(j + 1, end = \" \")\\n"}
{"id": "1485", "input": "from functools import lru_cache\\nN, K = list(map(int, input().split()))\\nP = 998244353\\nA = [K+100] + [int(a) for a in input().split()] + [K+j for j in range(1, 10)]\\n# A = [K+100] + [1, 2] + [-1 for a in range(N-4)] + [3,4]+ [K+j for j in range(1, 10)]\\n\\nX = [[0,0] for _ in range(N//2+5)]\\nX[0][0] = 1\\nfor i in range(1, N//2+2):\\n X[i][0] = X[i-1][1]\\n X[i][1] = (X[i-1][0] * (K-1) + X[i-1][1] * (K-2)) % P\\n \\nY = [[0,0] for _ in range(N//2+5)]\\nY[0][1] = 1\\nfor i in range(1, N//2+2):\\n Y[i][0] = Y[i-1][1]\\n Y[i][1] = (Y[i-1][0] * (K-1) + Y[i-1][1] * (K-2)) % P\\n \\ndef", "gt": "calc(l, a, b):\\n if a > K and b > K:\\n return (K * pow(K-1, l-1, P)) % P\\n if a > K or b > K:\\n return pow(K-1, l, P)\\n if a == b:\\n return X[l+1][0]\\n else:\\n return Y[l+1][0]\\n\\n\\n\\nl = 0\\nans = 1\\nfor j in range(2):\\n pre = K + 50 + j\\n for i in range(j, N+5, 2):\\n if A[i] == -1:\\n l += 1\\n elif l > 0:\\n ans *= calc(l, pre, A[i])\\n ans %= P\\n pre = A[i]\\n l = 0\\n elif pre == A[i]:\\n # print(A)\\n ans = 0\\n break\\n else:\\n pre = A[i]\\n\\nprint(ans%P)\\n"}
{"id": "1486", "input": "# written with help of editorial\\nn, m = list(map(int, input().split()))\\na = list(map(int, input().split()))\\n\\ndef gcd(x, y):\\n while y:\\n x, y = y, x % y\\n return x\\n\\ng = 0\\nfor x in a:\\n g = gcd(g, x - 1)\\n\\nanswer = 0\\n\\ndef process(x):\\n nonlocal answer\\n if x % 2 == 0:\\n return", "gt": "0\\n for i in range(30):\\n v = 2 ** i * x\\n if v > m:\\n break\\n answer += m - v\\n\\nfor i in range(1, g + 1):\\n if i * i > g:\\n break\\n if g % i:\\n continue\\n process(i)\\n if i * i != g:\\n process(g // i)\\n\\nprint(answer)\\n"}
{"id": "1487", "input": "n = int(input())\\na = list(map(int, input().split()))\\nfor i in range(n):\\n if i == 0:\\n print(a[1] - a[0], a[-1] - a[0])\\n elif i == n - 1:\\n", "gt": "print(a[i] - a[i - 1], a[i] - a[0])\\n else:\\n print(min(a[i + 1] - a[i], a[i] - a[i - 1]), max(a[-1] - a[i], a[i] - a[0]))\\n \\n"}
{"id": "1488", "input": "s = input()\\nt = input()\\nsa = s.count('0')\\nsb = s.count('1')\\nta = t.count('0')\\ntb = t.count('1')\\nn = len(s)\\nL = abs(sa - ta) + abs(sb - tb)\\nL /= 2\\nif L % 2 == 1:\\n print(\"impossible\")\\nelse:\\n ans =", "gt": "''\\n c = 0\\n for i in range(n):\\n if s[i] == t[i]:\\n ans += s[i]\\n else:\\n if c == 0:\\n ans += s[i]\\n c = 1\\n else:\\n ans += t[i]\\n c = 0\\n print(ans)\\n"}
{"id": "1489", "input": "from fractions import *\\ndef solve():\\n n = int(input())\\n a = list(map(int,input().split()))\\n a.sort()\\n ans1 = 0\\n pres = a[0]\\n for", "gt": "i in range(1,n):\\n ans1+=i*a[i] -pres\\n pres+=a[i]\\n ans1 *= 2;\\n tmp = pres+ans1\\n tmp1 = n\\n s = Fraction(tmp,tmp1)\\n print(s.numerator,s.denominator)\\n\\nsolve()"}
{"id": "1490", "input": "n = int(input())\\ndisjointSet = [-1] * n\\ndef root(x, level=200):\\n dp = []\\n while disjointSet[x] >= 0:\\n dp.append(x)\\n x = disjointSet[x]\\n for i in dp:\\n disjointSet[i] = x\\n return x\\n\\ndef join(x, y):\\n r1, r2 = root(x), root(y)\\n if r1 == r2:\\n return\\n disjointSet[r2] = r1\\n\\npoints = []\\nvertPoints = {}\\nhorizPoints = {}\\nfor i in range(n):\\n a, b = map(int, input().split())\\n points.append((a, b))\\n if a in vertPoints:\\n join(i, vertPoints[a])\\n else:\\n vertPoints[a] = i\\n if b in horizPoints:\\n join(i, horizPoints[b])\\n else:\\n", "gt": "horizPoints[b] = i\\n \\nsets ="}
{"id": "1491", "input": "n, m = map(int, input().split())\\na = list(map(int, input().split()))\\na.sort()\\ns = 0\\ncount = 1\\ni = 0\\nanswer = []\\nwhile i < len(a) and s <= m:\\n if a[i] == count:\\n i += 1\\n count += 1\\n else:\\n s += count\\n answer.append(count)\\n count += 1\\nif s > m:\\n s = s - count + 1\\n print(len(answer) - 1)\\n for i in range(len(answer) - 1):\\n print(answer[i], end", "gt": "= ' ')\\nelif s == m:\\n print(len(answer))\\n for i in range(len(answer)):\\n print(answer[i], end = ' ')\\nelse:\\n while s <= m:\\n s += count\\n answer.append(count)\\n count += 1\\n if s == m:\\n print(len(answer))\\n for i in range(len(answer)):\\n print(answer[i], end = ' ')\\n else:\\n s = s - count + 1\\n print(len(answer) - 1)\\n for i in range(len(answer) - 1):\\n print(answer[i], end = ' ')"}
{"id": "1492", "input": "n = int(input())\\n\\ncandies = list(map(int, input().strip().split()))\\n\\ndef intkoren(n):\\n k = int(n**0.5)\\n while (k+1)*(k+1) <= n:\\n k += 1\\n while k*k > n:\\n k -= 1\\n return k\\n\\ncnt1 = 0\\ncnt2 = 0\\nnew = []\\nfor e in candies:\\n u = intkoren(e)\\n if e == 0:\\n new.append((2,1))\\n cnt1 += 1\\n elif u*u == e:\\n new.append((1,1))\\n cnt1 += 1\\n else:\\n mini = min(e - u*u,", "gt": "(u+1)*(u+1)-e)\\n new.append((mini, -1))\\n cnt2 += 1\\n\\nnew.sort()\\n\\n#print(new, cnt1,cnt2)\\n\\ncount = 0\\nif cnt1 >= cnt2:\\n todo = (cnt1 - cnt2)//2\\n for steps, v in new:\\n if todo == 0:\\n break\\n if v == 1:\\n count += steps\\n todo -= 1\\nelse:\\n todo = (cnt2 - cnt1)//2\\n for steps,v in new:\\n if todo == 0:\\n break\\n if v == -1:\\n count += steps\\n todo -= 1\\nprint(count)\\n"}
{"id": "1493", "input": "import sys\\ninput = lambda:sys.stdin.readline().rstrip()\\n\\nh,w=map(int,input().split())\\nd=w+2\\nb=[0]*(w+2)\\nfor i in range(h):\\n b+=([0]+[int(j==\"X\") for j in input()]+[0])\\nb+=([0]*(w+2))\\nco=sum(b)\\nt=10**10\\nfor i in range(1,h+1):\\n f=0\\n for j in range(w+2):\\n f+=b[i*d+j]\\n if b[i*d+j]==0 and f:\\n t=min(t,(f-1)//2)\\n f=0\\nfor j in range(1,w+1):\\n f=0\\n for i in range(h+2):\\n f+=b[i*d+j]\\n if b[i*d+j]==0 and f:\\n t=min(t,(f-1)//2)\\n", "gt": "f=0\\n\\ncoo=0\\nans=[-1]*(w+2)*(h+2)\\nstack=[]\\nfor i in range(h+2):\\n for j in range(w+2):\\n if b[i*d+j]==0:\\n stack.append(i*d+j)\\n ans[i*d+j]=0\\ndij=[(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\\nfor ij in stack:\\n i,j=divmod(ij,d)\\n for x,y in dij:\\n if 0<=i+x<h+2 and 0<=j+y<w+2:\\n if ans[(i+x)*d+j+y]==-1:\\n ans[(i+x)*d+j+y]=ans[i*d+j]+1\\n if ans[(i+x)*d+j+y]>t:\\n coo+=1\\n stack.append((i+x)*d+(j+y))\\nif coo*6<co and t==1:\\n t-=1\\nprint(t)\\nfor i in range(1,h+1):\\n print(\"\".join([\".X\"[int(t<j)]for j in ans[i*d+1:i*d+w+1]]))"}
{"id": "1494", "input": "n, m = map(int, input().split())\\n\\nfin = [list(input().strip()) for i in range(n)]\\nans = [['-' for i in range(m)] for j in range(n)]\\n\\nfor y in range(n):\\n for x", "gt": "in range(m):\\n if fin[y][x] == '-':\\n continue\\n elif y % 2 == x % 2:\\n ans[y][x] = 'B'\\n else:\\n ans[y][x] = 'W'\\nfor row in ans:\\n print(''.join(row))"}
{"id": "1495", "input": "s, p = input(), input()\\nn, m = len(s) + 1, len(p)\\nd = [[0] * n for t in range(n)]\\nfor x in range(1, n):\\n i, j = x, m\\n while i and j:\\n j -= s[i - 1]", "gt": "== p[j - 1]\\n i -= 1\\n if not j:\\n for y in range(i + 1): d[x][y + x - i - m] = d[i][y] + 1\\n for y in range(x): d[x][y] = max(d[x][y], d[x - 1][y])\\nprint(*d[-1])"}
{"id": "1496", "input": "#!/usr/bin/env python\\n# -*- coding: utf-8 -*-\\nfrom collections import defaultdict\\n\\nn = int(input())\\nA = list(map(int,input().split()))\\npattern = set()\\nfor a in A:\\n p = []\\n while a > 0:\\n if a in pattern:\\n break\\n p.append(a)\\n a = a//2\\n pattern |= set(p)\\n\\ndef check(v):\\n ret = 0\\n for a in A:\\n count = 0\\n while a != 0:\\n if v == a", "gt": "or (v % a == 0 and (v//a)&-(v//a) == v//a):\\n ret += len(bin(v//a))-3\\n break\\n if (v%a == 0 and (v//a)&-(v//a) == v//a) and a < v:\\n return 1e12\\n a = a//2\\n ret += 1\\n else:\\n return 1e12\\n return ret\\n\\nans = 1e12\\nfor p in pattern:\\n ret = check(p)\\n ans = ans if ans < ret else ret\\nprint(ans)\\n"}
{"id": "1497", "input": "from itertools import accumulate\\nimport sys\\n\\ndef solve(f, g):\\n n, m, k, s = [int(x) for x in f.readline().split()]\\n a_price = [(int(x), i+1) for i, x in enumerate(f.readline().split())]\\n b_price = [(int(x), i+1) for i, x in enumerate(f.readline().split())]\\n\\n a_gadgets = []\\n b_gadgets = []\\n for i, line in enumerate(f):\\n t, price = [int(x) for x in line.split()]\\n if t == 1:\\n a_gadgets.append((price, i + 1))\\n else:\\n b_gadgets.append((price, i + 1))\\n\\n a_gadgets.sort()\\n b_gadgets.sort()\\n\\n prefix_a = [0] + list(accumulate(gadget[0] for gadget in a_gadgets))\\n prefix_b = [0] + list(accumulate(gadget[0] for gadget in b_gadgets))\\n\\n la = min(k, len(a_gadgets))\\n lb = min(k, len(b_gadgets))\\n min_price_for_k = [(prefix_a[i], prefix_b[k - i], i) for i in range(k-lb,", "gt": "la+1)]\\n\\n for i in range(1, n):\\n a_price[i] = min(a_price[i], a_price[i-1])\\n b_price[i] = min(b_price[i], b_price[i-1])\\n \\n def expence(day):\\n return lambda x: a_price[day][0]*x[0] + b_price[day][0]*x[1]\\n\\n x, y = 0, n-1\\n while x <= y-1:\\n day = (x + y) // 2\\n min_cost = min(min_price_for_k, key = expence(day))\\n if expence(day)(min_cost) > s:\\n x = day+1\\n else:\\n y = day\\n min_cost = min(min_price_for_k, key = expence(x))\\n if expence(x)(min_cost) > s:\\n g.write('-1\\n')\\n else:\\n g.write(str(x+1) + '\\n')\\n i1 = min_cost[-1]\\n A, B = ' ' + str(a_price[x][1]) + '\\n', ' ' + str(b_price[x][1]) + '\\n'\\n for i in range(i1):\\n g.write(str(a_gadgets[i][1]) + A)\\n for i in range(k - i1):\\n g.write(str(b_gadgets[i][1]) + B)\\n\\nsolve(sys.stdin, sys.stdout)\\n"}
{"id": "1498", "input": "n = int(input())\\n\\nd = {}\\n\\nfor i in range(n):\\n s = input()\\n", "gt": "if s in d:\\n d[s] += 1\\n else:\\n d[s] = 1\\n\\nprint(d[max(d,key=d.get)])"}
{"id": "1499", "input": "n, q = list(map(int, input().split()))\\nservers = [0] * n\\nfor _ in range(q):\\n t, k, d = list(map(int, input().split()))\\n # free = [i for i, x in enumerate(servers) if x < t]\\n free = []\\n for sn", "gt": "in range(n):\\n if servers[sn] < t:\\n free.append(sn)\\n if len(free) == k:\\n break\\n if len(free) < k:\\n print(-1)\\n\\n else:\\n\\n for sn in free:\\n servers[sn] = t + d - 1\\n\\n print(sum([x + 1 for x in free]))\\n"}
{"id": "1500", "input": "#!/usr/bin/env python3\\n\\nOUT = (1, 0, 2, 3)\\n\\ntry:\\n while True:\\n n, m = map(int, input().split())\\n bus = [[None] * 4 for i in range(n)]\\n cur = 1\\n for row in range(n << 1):\\n if row >= n:\\n i = row - n\\n k = b = 1\\n", "gt": "else:\\n i = row\\n k = 3\\n b = 0\\n for j in range(2):\\n if cur <= m:\\n bus[i][k * j + b] = cur\\n cur += 1\\n for i in range(n):\\n for j in range(4):\\n if bus[i][OUT[j]] is not None:\\n print(bus[i][OUT[j]], end=' ')\\n print()\\n\\nexcept EOFError:\\n pass\\n"}
{"id": "1501", "input": "n, k = list(map(int, input().split()))\\nx = list(map(int, input().split()))\\n\\nro = list(x[i] - x[i - 1] for i in range(1, n))\\n\\nif max(x[i] - x[i - 1] for i in range(1,", "gt": "n)) > k:\\n print(-1)\\n\\nelse:\\n ans = 1\\n r = 0\\n\\n for el in ro:\\n r += el\\n\\n if r > k:\\n ans += 1\\n r = el\\n\\n print(ans)\\n"}
{"id": "1502", "input": "# -*- coding: utf-8 -*-\\n\\n\\ndef solve():\\n mod = 10**9 + 7\\n n, m = map(int, input().split())\\n p = input()\\n if m == 0:\\n return powmod(n)\\n delta = len(p) - 1\\n ys = map(int, input().split())\\n answer = 1\\n tail = 0\\n for y in ys:\\n if y > tail:\\n answer *= powmod(y - tail - 1)\\n answer %= mod\\n elif not is_consistent(p, tail - y + 1):\\n return 0\\n tail = y + delta\\n", "gt": "answer *= powmod(n - tail)\\n return answer % mod\\n\\nok_set = set()\\ndef is_consistent(p, margin):\\n nonlocal ok_set\\n if margin in ok_set:\\n return True\\n elif p[:margin] == p[-margin:]:\\n ok_set.add(margin)\\n return True\\n else:\\n return False\\n\\ndef powmod(p):\\n mod = 10**9 + 7\\n pbin = bin(p)[2:][-1::-1]\\n result = 26 if pbin[0] == '1' else 1\\n tmp = 26\\n for bit in pbin[1:]:\\n tmp *= tmp\\n tmp %= mod\\n if bit == '1':\\n result *= tmp\\n result %= mod\\n return result\\n\\nprint(solve())"}
{"id": "1503", "input": "f=lambda a:(a+1)%2\\n\\nn=int(input())\\na=list(map(int, bin(n)[2:].zfill(4)[::-1]))\\na[3]=f(a[3])\\nif (a[3]): a[2]=f(a[2])\\nif a[3] and a[2]: a[1]=f(a[1])\\nif", "gt": "a[3] and a[2] and a[1]: a[0]=f(a[0])\\n\\nprint (int(\"\".join(map(str, a))[::-1], 2))"}
{"id": "1504", "input": "# \\nimport collections, atexit, math, sys, bisect \\n\\nsys.setrecursionlimit(1000000)\\ndef getIntList():\\n return list(map(int, input().split())) \\n\\ntry :\\n #raise ModuleNotFoundError\\n import numpy\\n def dprint(*args, **kwargs):\\n #print(*args, **kwargs, file=sys.stderr)\\n # in python 3.4 **kwargs is invalid???\\n print(*args, file=sys.stderr)\\n dprint('debug mode')\\nexcept Exception:\\n def dprint(*args, **kwargs):\\n pass\\n\\n\\n\\ninId = 0\\noutId = 0\\nif inId>0:\\n dprint('use input', inId)\\n sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\\nif outId>0:\\n dprint('use output', outId)\\n sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\\n atexit.register(lambda :sys.stdout.close()) #idle 中不会执行 atexit\\n \\nN, M= getIntList()\\n\\nne = [0 for i in range(N+1) ]\\nza", "gt": "= getIntList()\\nfor i in range(N-1):\\n ne[ za[i]] = za[i+1]\\nne[za[-1]] = 0\\n\\nfor _ in range(1, M):\\n za = getIntList()\\n for i in range(N-1):\\n a = za[i]\\n b = za[i+1]\\n if ne[a] != b:\\n ne[a] = -1\\n a = za[-1]\\n if ne[a]!=0:\\n ne[a] = -1\\n\\ntin = [0 for i in range(N+1) ]\\n\\nfor i in range(1,N+1):\\n a = ne[i]\\n if a>0:\\n tin[a] = 1\\n\\nres = 0\\nfor i in range(1,N+1):\\n if tin[i]: continue\\n n = 0\\n while i>0:\\n n+=1\\n i = ne[i]\\n res += n * (n+1) //2\\n\\nprint(res)\\n\\n\\n\\n\\n\\n"}
{"id": "1505", "input": "t = int(input())\\n\\nfor _ in range(t):\\n n, k = [int(x) for x in input().split()]\\n l1, r1 = [int(x) for x in input().split()]\\n l2, r2 = [int(x) for x in input().split()]\\n if l1 > l2:\\n l1, r1, l2, r2 = l2, r2, l1, r1\\n\\n if l2 < r1:\\n # they already intersect.\\n start = (min(r1, r2) - max(l1, l2))*n\\n if start >= k:\\n print(0)\\n continue\\n cheap = n*(max(r1, r2) - min(l1, l2)) - start\\n if start + cheap >= k:\\n print(k -", "gt": "start)\\n continue\\n else:\\n print(cheap + (k - start - cheap)*2)\\n continue\\n\\n # they do not intersect yet.\\n best = 10**100\\n cost_sf = 0\\n intersection_sf = 0\\n for j in range(n):\\n # compute price using j-th interval as the last.\\n cost_sf += l2 - r1\\n cheap = r2 - l1\\n if intersection_sf + cheap >= k:\\n best = min(best, cost_sf + max((k - intersection_sf), 0))\\n\\n intersection_sf += cheap\\n cost_sf += cheap\\n \\n best = min(best, cost_sf + max((k - intersection_sf)*2, 0))\\n print(best)\\n\\n"}
{"id": "1506", "input": "px, py, vx, vy, a, b, c, d = map(int, input().split())\\n\\nvl = (vx**2 + vy**2)**0.5\\nvx /= vl\\nvy /= vl\\n\\nprint(px + vx * b, py + vy * b)\\n\\nprint(px - vy * a / 2, py + vx * a / 2)\\nprint(px - vy * c / 2, py + vx * c / 2)\\nprint(px - vy * c / 2 -", "gt": "vx * d, py + vx * c / 2 - vy * d)\\n\\nprint(px + vy * c / 2 - vx * d, py - vx * c / 2 - vy * d)\\nprint(px + vy * c / 2, py - vx * c / 2)\\nprint(px + vy * a / 2, py - vx * a / 2)"}
{"id": "1507", "input": "\\n \\ndef main():\\n f= [1]\\n for i in range(1,1000002):\\n f.append((f[-1] * i)%1000000007)\\n \\n n = int(input())\\n a = sorted(int(x) for x in input().split())\\n sol = 0\\n j = 0\\n s = 1\\n sq = 1\\n for i in range(n - 1):\\n sq = sq", "gt": "* (n - i) % 1000000007\\n if a[i] != a[i + 1]:\\n sol += a[i] * (i - j + 1) * f[n - j - 1] * s\\n j = i + 1\\n s = sq\\n\\n print(sol % 1000000007)\\n \\n \\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "1508", "input": "n, k = map(int, input().split())\\ns = input()\\nour = set()\\nopened = set()\\nfor i in range(ord('A'), ord('Z') + 1):\\n sym = chr(i)\\n if sym in s:\\n our.add(s.rfind(sym))\\nfor", "gt": "i in range(len(s)):\\n if s[i] not in opened:\\n opened.add(s[i])\\n k -= 1\\n if k < 0:\\n print('YES')\\n return\\n if i in our:\\n k += 1\\nprint('NO')"}
{"id": "1509", "input": "n = int(input())\\nA = list(map(int, input().split()))\\nA.sort()\\nA[0],", "gt": "A[-1] = A[-1], A[0]\\nprint(\" \".join(list(map(str, A))))"}
{"id": "1510", "input": "n = int(input())\\nv = [0] + [int(e) for e in input().split()]\\nans = 0\\nfor a,", "gt": "b in zip(v[:-1], v[1:]):\\n if a < b:\\n ans += (b-a)*(n-b+1)\\n else:\\n ans += b*(a-b)\\nprint(ans)\\n"}
{"id": "1511", "input": "\"\"\"\\nCodeforces Round 251 Div 2 Problem D\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0:\\n return inputs\\n if mode == 1:\\n return inputs.split()\\n if mode == 2:\\n return [int(x) for x in inputs.split()]\\n\\ndef write(s=\"\\n\"):\\n if isinstance(s, list): s = \"", "gt": "\".join(s)\\n s = str(s)\\n print(s, end=\"\")\\n\\n################################################### SOLUTION\\nn,m = read()\\na = read()\\nb = read()\\ns = [(0,2)] + [(i,0) for i in a] + [(i,1) for i in b]\\ns.sort()\\nt = sum(b)\\nal = 0\\nbr = m\\nmn = t\\nfor i in range(1,n+m+1):\\n t += (al-br) * (s[i][0] - s[i-1][0])\\n mn = min(mn, t)\\n if s[i][1]:\\n br -= 1\\n else:\\n al += 1\\nprint(mn)"}
{"id": "1512", "input": "n, m, k = list(map(int, input().split()))\\ndeadstep = [0] * (n+1)\\nbadmem = [False] * (k+1)\\na = [0] * (n+1)\\nfor i in range(1, n+1):\\n a[i] = [0] + list(map(int, input().split()))\\nfor step in range(1, m+1):\\n t = [0] * (k+1)\\n for i in range(1, n+1):\\n", "gt": "if deadstep[i] == 0 and a[i][step] != 0:\\n t[a[i][step]] += 1\\n for j in range(1, k+1):\\n if t[j] > 1:\\n badmem[j] = True\\n for i in range(1, n+1):\\n if deadstep[i] == 0 and badmem[a[i][step]]:\\n deadstep[i] = step\\nfor i in range(1, n+1):\\n print(deadstep[i])\\n"}
{"id": "1513", "input": "from sys import stdin, stdout\\n\\nn = int(stdin.readline().rstrip())\\np = list(map(int,stdin.readline().rstrip().split()))\\n\\nif n==1:\\n print(p[0])\\nelse:\\n removeDict={i:0 for i in range(1,n+1)}\\n l1 = p[0]\\n removeDict[l1]-=1\\n l2 = 0\\n for i in range(1,n):\\n", "gt": "if p[i]>l2:\\n if p[i]>l1:\\n l2=l1\\n l1=p[i]\\n removeDict[l1]-=1\\n else:\\n l2=p[i]\\n removeDict[l1]+=1\\n maxN = 1\\n maxRemove=-10\\n for i in range(1,n+1):\\n if removeDict[i]>maxRemove:\\n maxN = i\\n maxRemove = removeDict[i]\\n \\n print(maxN)\\n"}
{"id": "1514", "input": "n,m,k=map(int,input().split())\\nb=list(map(int,input().split()))\\ndiffs=[]\\nfor i", "gt": "in range(n-1):\\n diffs.append(b[i+1]-b[i])\\ndiffs.sort()\\nprint(k+sum(diffs[:n-k]))"}
{"id": "1515", "input": "from collections import defaultdict, Counter\\nN = int(input())\\nB = list(map(int, input().split()))\\nC = list(map(int, input().split()))\\nEdge = defaultdict(list)\\nEdc = defaultdict(int)\\nfor b, c in zip(B, C):\\n if b > c:\\n print(-1)\\n return\\n Edge[b].append(c)\\n Edc[(b, c)] += 1\\n if b != c:\\n Edge[c].append(b)\\nDeg = Counter(B + C)\\neul = 0\\nst = []\\nfor k, v in list(Deg.items()):\\n if v % 2:\\n eul += 1\\n st.append(k)\\ns, e = B[0], B[0]\\nif eul and eul != 2:\\n print(-1)\\n return\\nif eul:\\n s, e = st[0], st[1]\\nans = [s]\\nwhile True:\\n vn = ans[-1]\\n while True:\\n vf = Edge[vn][-1]\\n if Deg[vf] != 0 and Edc[(vn, vf) if vn < vf else (vf, vn)]:\\n break\\n Edge[vn].pop()\\n vf = Edge[vn].pop()\\n", "gt": "Deg[vn] -= 1\\n Deg[vf] -= 1\\n Edc[(vn, vf) if vn < vf else (vf, vn)] -= 1\\n ans.append(vf)\\n if not Deg[vf]:\\n break\\nloop = defaultdict(list)\\nfor a in ans:\\n if Deg[a]:\\n loopa = [a]\\n while Deg[a]:\\n vn = loopa[-1]\\n while True:\\n vf = Edge[vn][-1]\\n if Deg[vf] != 0 and Edc[(vn, vf) if vn < vf else (vf, vn)]:\\n break\\n Edge[vn].pop()\\n vf = Edge[vn].pop()\\n Deg[vn] -= 1\\n Deg[vf] -= 1\\n Edc[(vn, vf) if vn < vf else (vf, vn)] -= 1\\n loopa.append(vf)\\n if not Deg[vf]:\\n break\\n loop[a] = loopa\\nAns = [] \\nfor a in ans:\\n if loop[a]:\\n Ans.extend(loop[a])\\n loop[a] = []\\n else:\\n Ans.append(a) \\nif len(Ans) != N:\\n print(-1)\\n return\\nprint(*Ans)\\n\\n\\n"}
{"id": "1516", "input": "p, k = map(int, input().split())\\nu = 10 * k - 1\\nv = pow(10, p - 1, u) - k\\nfor y in range(k, 10):\\n if (y * v) % u ==", "gt": "0:\\n q = d = 9 * y\\n while q % u: q = 10 * q + d\\n q = str(q // u)\\n print(q * (p // len(q)))\\n break\\nelse: print('Impossible')"}
{"id": "1517", "input": "a = int(input())\\nc = list(map(int,input().split()))\\nsumm = 0\\nfor i in range(a):\\n k = 0\\n k1 = 0\\n s = str(c[i])\\n for x in", "gt": "s:\\n k = k * 100 + int(x)\\n k1 = k * 10\\n summ += (k + k1) * a\\n summ %= 998244353\\nprint(summ)"}
{"id": "1518", "input": "n = int(input())\\nans = [1, 3, 5, 7, 9, 11, 13, 15]\\ndct = \\\\n{\\n 1 : 1,\\n 3 : 18,\\n 5", "gt": ": 1800,\\n 7 : 670320,\\n 9 : 734832000,\\n 11 : 890786230,\\n 13 : 695720788,\\n 15 : 150347555\\n}\\nif n in ans:\\n print(dct[n])\\nelse:\\n print(0)"}
{"id": "1519", "input": "import bisect\\n\\n\\ndef gen_primes(upper_bound):\\n upper_bound += 1\\n t = [0] * (upper_bound)\\n primes = [2]\\n for i in range(3, upper_bound, 2):\\n if t[i]:\\n continue\\n primes.append(i)\\n for j in range(i + i, upper_bound, i):\\n t[j] = 1\\n return primes\\n\\ndef main():\\n n = int(input())\\n a = list(map(int, input().split()))\\n primes = gen_primes(n + 1)\\n process = list()\\n d = [0] * n\\n\\n for i in range(n):\\n d[a[i]", "gt": "- 1] = i\\n\\n i = 0\\n while i < n:\\n if a[i] == i + 1:\\n i += 1\\n continue\\n r = d[i]\\n l = r - primes[bisect.bisect(primes, r - i + 1) - 1] + 1\\n a[l], a[r] = a[r], a[l]\\n process.append('"}
{"id": "1520", "input": "n,L,a=list(map(int,input().split()))\\ncount=0\\nlast=0\\nfor i in", "gt": "range(n):\\n t,l=list(map(int,input().split()))\\n count+=(t-last)//a\\n last=t+l\\ncount+=(L-last)//a\\nprint(count)\\n"}
{"id": "1521", "input": "t = [0] * 26\\n\\n\\ndef get_k(c):\\n return ord(c) - ord('a')\\n\\n\\ndef analyze(s):\\n length_of_str = len(s)\\n pos = 0\\n beauty_table = [0] * 26\\n for i in range(1, length_of_str):\\n if s[i] != s[pos]:\\n k = get_k(s[pos])\\n beauty_table[k] = max(beauty_table[k], i - pos)\\n\\n pos = i\\n k = get_k(s[pos])\\n beauty_table[k] = max(beauty_table[k], length_of_str - pos)\\n\\n pos = 0\\n while pos < length_of_str and s[pos] == s[0]:\\n pos += 1\\n left_beauty = pos\\n pos = length_of_str - 1\\n while pos > 0 and s[pos] == s[length_of_str - 1]:\\n pos -= 1\\n right_beauty = length_of_str - pos - 1\\n return beauty_table, left_beauty, right_beauty\\n\\n\\nr = []\\nfor _ in range(int(input())):\\n p = input()\\n if", "gt": "all(x == p[0] for x in p): # pure\\n k = get_k(p[0])\\n for i in range(26):\\n if i == k:\\n t[i] = len(p) * (t[i] + 1) + t[i]\\n else:\\n t[i] = min(1, t[i])\\n else:\\n for i in range(26):\\n t[i] = min(1, t[i])\\n\\n bt, lb, rb = analyze(p)\\n lk, rk = get_k(p[0]), get_k(p[-1])\\n\\n if lk == rk:\\n t[lk] = lb + rb + t[lk]\\n else:\\n t[lk], t[rk] = t[lk] + lb, t[rk] + rb\\n for i in range(26):\\n t[i] = max(t[i], bt[i])\\n # r.append(max(t))\\n # print('\\ntableInfo: ', end= ' ')\\n # for i in range(26):\\n # print('"}
{"id": "1522", "input": "p, n = map(int, input().split())\\na = [-1 for i in range(p)]\\nfor i in range(n):\\n b =", "gt": "int(input())\\n if a[b % p] != -1:\\n print(i + 1)\\n return\\n else:\\n a[b % p] = b\\nprint(-1)"}
{"id": "1523", "input": "n = int(input())\\nr = {}\\nans = 0\\nfor i in input():\\n if i == i.lower():\\n if i in r:\\n r[i] += 1\\n else:\\n", "gt": "r[i] = 1\\n else:\\n i = i.lower()\\n if i in r and r[i] > 0:\\n r[i] -= 1\\n else:\\n ans += 1\\nprint(ans)"}
{"id": "1524", "input": "n, k = list(map(int, input().strip().split()))\\n\\njobs = list(map(int, input().strip().split()))\\ntimes = list(map(int, input().strip().split()))\\n\\ncounts_jobs = {}\\nfor job in jobs:\\n if job in counts_jobs:\\n counts_jobs[job] += 1\\n else:\\n counts_jobs[job] = 1\\n\\ntimes_i = []\\nfor i,", "gt": "time in enumerate(times):\\n times_i.append((time, i))\\n\\ntimes_i.sort()\\njobs_left = k-len(counts_jobs.keys())\\n\\nans = 0\\nfor time, i in times_i:\\n if jobs_left == 0:\\n break\\n if counts_jobs[jobs[i]] > 1:\\n ans += time\\n jobs_left -= 1\\n counts_jobs[jobs[i]] -= 1\\n\\nprint(ans)"}
{"id": "1525", "input": "#! env/bin/local python3\\n# -*- coding: utf-8 -*-\\n\\nsentence: str = input()\\nn_sentence = len(sentence)\\nsentence += '*'\\ncounter = 0\\nresults = []\\n\\nans = {i+1: 0 for i in range(n_sentence)}\\n\\nfor n in range(n_sentence):\\n counter += 1\\n if sentence[n] != sentence[n+1]:\\n results += [sentence[n], counter]\\n counter = 0\\n\\nindex = 0\\n\\nfor n in range(len(results)//2):\\n\\n if results[2*n] == 'R':\\n index += int(results[2*n+1])\\n if int(results[2*n+1]) % 2 == 0:\\n evens = int(results[2*n+1]) // 2\\n odds = int(results[2*n+1]) // 2\\n ans[index] += odds\\n ans[index+1] += evens\\n else:\\n evens = (int(results[2*n+1]) - 1) // 2\\n odds = (int(results[2*n+1]) + 1) // 2\\n ans[index] += odds\\n", "gt": "ans[index + 1] += evens\\n\\n\\n if results[2*n] == 'L':\\n index += 1\\n if int(results[2 * n + 1]) % 2 == 0:\\n evens = int(results[2 * n + 1]) // 2\\n odds = int(results[2 * n + 1]) // 2\\n ans[index] += odds\\n ans[index - 1] += evens\\n else:\\n evens = (int(results[2 * n + 1]) - 1) // 2\\n odds = (int(results[2 * n + 1]) + 1) // 2\\n ans[index] += odds\\n ans[index - 1] += evens\\n index += int(results[2 * n + 1]) - 1\\n\\nans = ' '.join([str(c) for c in list(ans.values())])\\n\\nprint(ans)\\n"}
{"id": "1526", "input": "def check(amidakuji,w):\\n before=0\\n flag=True\\n for _ in range(w-1):\\n if amidakuji&1==1 and before==1:\\n flag=False\\n break\\n elif amidakuji&1==1:\\n before=1\\n amidakuji>>=1\\n else:\\n before=0\\n amidakuji>>=1\\n return flag\\n\\nfrom sys import stdin\\ndef main():\\n #入力\\n readline=stdin.readline\\n mod=10**9+7\\n h,w,k=map(int,readline().split())\\n\\n dp=[[0]*w for _ in range(h+1)]\\n dp[0][0]=1\\n for i in range(1,h+1):\\n for bit", "gt": "in range(1<<(w-1)):\\n if check(bit,w)==False:\\n continue\\n else:\\n for j in range(w):\\n if j==0:\\n if bit&1==1:\\n dp[i][j+1]+=dp[i-1][j]\\n else:\\n dp[i][j]+=dp[i-1][j]\\n elif j==w-1:\\n if bit&1==1:\\n dp[i][j-1]+=dp[i-1][j]\\n else:\\n dp[i][j]+=dp[i-1][j]\\n else:\\n if bit&1==1:\\n dp[i][j-1]+=dp[i-1][j]\\n bit>>=1\\n else:\\n bit>>=1\\n if bit&1==1:\\n dp[i][j+1]+=dp[i-1][j]\\n else:\\n dp[i][j]+=dp[i-1][j]\\n\\n for j in range(w):\\n dp[i][j]%=mod\\n\\n print(dp[h][k-1])\\n\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "1527", "input": "#解説参照\\na = list(map(int, input().split( )))\\na.sort(reverse = True)\\nans =", "gt": "0\\nans += a[0]-a[1]\\na[1]+=ans\\na[2] += ans\\nans += (a[0]-a[2])//2\\nans += ((a[0]-a[2])%2)*2###これ\\nprint(ans)"}
{"id": "1528", "input": "from collections import deque\\nfrom copy import deepcopy\\n\\nh,w = map(int,input().split())\\ns = [list(input()) for i in range(h)]\\nt = ((0,1),(1,0),(-1,0),(0,-1))\\nm = 0\\nfor sy in range(h):\\n for sx in range(w):\\n if s[sy][sx] == \"#\":\\n continue\\n ss = deepcopy(s)\\n ss[sy][sx] = \"#\"\\n q = deque([(0,sy,sx)])\\n max_cost = 0\\n my,mx", "gt": "= 0,0\\n while(q):\\n cost,y,x = q.popleft()\\n max_cost = max(max_cost,cost)\\n cost += 1\\n for i,j in t:\\n ny = y+i\\n nx = x+j\\n if 0 <= ny < h and 0 <= nx < w:\\n if ss[ny][nx] == \".\":\\n q.append((cost,ny,nx))\\n ss[ny][nx] = \"#\"\\n m = max(m,max_cost)\\nprint(m)"}
{"id": "1529", "input": "import sys\\nsys.setrecursionlimit(10**7)\\ninput = sys.stdin.readline\\n\\nn,x = list(map(int, input().split()))\\n\\na,p = [1],[1]\\nfor i in range(n):\\n a.append(a[i] * 2 + 3)\\n p.append(p[i] * 2 + 1)\\n\\ndef f(n, x):\\n if n == 0:\\n return 0 if x <= 0", "gt": "else 1\\n elif x <= 1 + a[n - 1]:\\n return f(n - 1, x - 1)\\n else:\\n return p[n - 1] + 1 + f(n - 1, x - 2 - a[n-1])\\n\\nprint((f(n, x)))\\n"}
{"id": "1530", "input": "for i in range(int(input())):\\n s = input()\\n if s.endswith('lala.') and not s.startswith('miao.'):\\n", "gt": "print(\"Freda's\")\\n elif s.startswith('miao.') and not s.endswith('lala.'):\\n print(\"Rainbow's\")\\n else:\\n print(\"OMG>.< I don't know!\")\\n"}
{"id": "1531", "input": "class RedBlackNode(object):\\n\\n def __init__(self, key):\\n self._key = key\\n self._red = False\\n self._left = None\\n self._right = None\\n self._p = None\\n\\n\\nclass RedBlackTree(object):\\n\\n def __init__(self):\\n self._nil = RedBlackNode(None)\\n self._root = self._nil\\n\\n def insert_key(self, key):\\n y = self.search(key, True)\\n z = RedBlackNode(key)\\n z._p = y\\n if y == self._nil:\\n self._root = z\\n elif z._key < y._key:\\n y._left = z\\n else:\\n y._right = z\\n z._left = self._nil\\n z._right = self._nil\\n z._red = True\\n self._insert_fixup(z)\\n\\n def _insert_fixup(self, z):\\n while z._p._red:\\n if z._p == z._p._p._left:\\n y = z._p._p._right\\n if y._red:\\n z._p._red = False\\n y._red = False\\n z._p._p._red = True\\n z = z._p._p\\n else:\\n if z == z._p._right:\\n z = z._p\\n self._left_rotate(z)\\n z._p._red = False\\n z._p._p._red = True\\n self._right_rotate(z._p._p)\\n else:\\n y = z._p._p._left\\n if y._red:\\n z._p._red = False\\n y._red = False\\n z._p._p._red = True\\n z = z._p._p\\n else:\\n if z == z._p._left:\\n z = z._p\\n self._right_rotate(z)\\n z._p._red = False\\n z._p._p._red = True\\n self._left_rotate(z._p._p)\\n self._root._red = False\\n\\n def _left_rotate(self, x):\\n y = x._right\\n x._right = y._left\\n if y._left != self._nil:\\n y._left._p = x\\n y._p = x._p\\n if x._p == self._nil:\\n self._root = y\\n elif x == x._p._left:\\n x._p._left = y\\n else:\\n x._p._right = y\\n y._left = x\\n x._p = y\\n\\n def _right_rotate(self, y):\\n x = y._left\\n y._left = x._right\\n if x._right != self._nil:\\n x._right._p = y\\n x._p = y._p\\n if y._p == self._nil:\\n self._root = x\\n elif y == y._p._right:\\n y._p._right", "gt": "= x\\n else:\\n y._p._left = x\\n x._right = y\\n y._p = x\\n\\n def search(self, key, s):\\n x = self._root\\n g = self._nil\\n while x != self._nil:\\n g = x\\n if key < x._key:\\n x = x._left\\n else:\\n x = x._right\\n return(g)\\n def search2(self, key):\\n a = None\\n b = None\\n x = self._root\\n while x != self._nil and key != x._key:\\n if key < x._key:\\n a = x\\n x = x._left\\n else:\\n b = x\\n x = x._right\\n if key == x._key:\\n return(None)\\n else:\\n return((a,b))\\n\\n\\nn = int(input())\\ns = [int(i) for i in input().split()]\\nt = RedBlackTree()\\nt.insert_key([s[0],0,0])\\n \\ne = []\\nfor i in s[1:]:\\n o,u = t.search2([i,0,0])\\n if u == None:\\n e.append(o._key[0])\\n if o._key[0] > i:\\n o._key[1] = 1\\n else:\\n o._key[2] = 1\\n elif o == None:\\n e.append(u._key[0])\\n if u._key[0] > i:\\n u._key[1] = 1\\n else:\\n u._key[2] = 1\\n else:\\n if o._key[0] > i and u._key[0] > i:\\n if o._key[1] == 0:\\n o._key[1] = 1\\n e.append(o._key[0])\\n else:\\n u._key[1] = 1\\n e.append(u._key[0])\\n \\n elif o._key[0] < i and u._key[0] > i:\\n if o._key[2] == 0:\\n o._key[2] = 1\\n e.append(o._key[0])\\n else:\\n u._key[1] = 1\\n e.append(u._key[0])\\n elif o._key[0] > i and u._key[0] < i:\\n if o._key[1] == 0:\\n o._key[1] = 1\\n e.append(o._key[0])\\n else:\\n u._key[2] = 1\\n e.append(u._key[0])\\n elif o._key[0] < i and u._key[0] < i:\\n if o._key[2] == 0:\\n o._key[2] = 1\\n e.append(o._key[0])\\n else:\\n u._key[2] = 1\\n e.append(u._key[0])\\n t.insert_key([i,0,0])\\nprint(*e)\\n \\n\\n"}
{"id": "1532", "input": "n=int(input())\\na=tuple(map(int,input().split()))\\nc={}\\np={}\\ns=x=y=0\\nm=-1e18\\nfor i in range(0,len(a)):\\n d=c.get(a[i])\\n if d!=None and s-d+a[i]*2>m:\\n m=s-d+a[i]*2\\n x,y=p.get(a[i]),i\\n if(a[i]>0):s+=a[i] \\n if p.get(a[i])==None:\\n p[a[i]]=i\\n", "gt": "c[a[i]]=s\\na=[str(i+1) for i in range(0,len(a)) if i!=x and i!=y and (a[i]<0 or i<x or i>y)]\\nprint(m,len(a))\\nprint(\" \".join(a))\\n"}
{"id": "1533", "input": "n = int(input())\\nl = []\\nfor i in range(n + 1):\\n l.append(0)\\nfor i in range(2, n + 1):\\n for j in range(i * 2,", "gt": "n + 1, i):\\n l[j] = i\\nl.sort()\\nfor i in range(2, n + 1):\\n if l[i] == 0:\\n print(1, end=\" \")\\n else:\\n print(l[i], end=\" \")\\n"}
{"id": "1534", "input": "def main():\\n n = int(input())\\n s = set()\\n for _ in", "gt": "range(n):\\n w = input()\\n if w in s:\\n print('YES')\\n else:\\n print('NO')\\n s.add(w)\\n\\nmain()\\n"}
{"id": "1535", "input": "s=input()\\ndp=[[0,0,0] for i in range(len(s))]\\nfor i in range(len(s)):\\n", "gt": "if s[i]=='a':\\n dp[i][0]=dp[i-1][0]+1\\n dp[i][1]=dp[i-1][1]\\n dp[i][2]=max(dp[i-1][1]+1,dp[i-1][2]+1)\\n else:\\n dp[i][0]=dp[i-1][0]\\n dp[i][1]=max(dp[i-1][0]+1,dp[i-1][1]+1)\\n dp[i][2]=dp[i-1][2]\\ne=len(s)-1\\nprint(max(dp[e][0],dp[e][1],dp[e][2]))\\n"}
{"id": "1536", "input": "\"\"\"\\nCodeforces Contest 291 Div 2 Problem B\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.4.2\\n\"\"\"\\n\\n################################################### SOLUTION\\n\\ndef gcd(a,b):\\n if a < 0: a = -a\\n if b < 0: b = -b\\n if a == 0: return b\\n if b == 0: return a\\n return gcd(b, a%b)\\n\\ndef main():\\n n, x0, y0 = read()\\n lines = set()\\n for i in range(n):\\n x, y = read()\\n x -= x0\\n y -= y0\\n if x < 0 or (x == 0 and y", "gt": "< 0): x,y = -x,-y\\n g = gcd(x,y)\\n x //= g\\n y //= g\\n lines.add((x,y))\\n return len(lines)\\n\\n\\n\\n#################################################### HELPERS\\n\\n\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "1537", "input": "n = int(input())\\na = [tuple(map(int, input().split())) for _ in range(n)]\\ns = {a[q]: q+1 for q in range(n)}\\na.sort()\\nq, q1 = 0, 1\\nd, d1, d2 = [[[a[0]]]], [], []\\nwhile q1 < n:\\n while q1 < n and a[q][0] == a[q1][0]:\\n while q1 < n and a[q][1] == a[q1][1]:\\n d[-1][-1].append(a[q1])\\n q1 += 1\\n if q1 < n and a[q][0] == a[q1][0]:\\n d[-1].append([a[q1]])\\n q = q1\\n q1 += 1\\n if q1 < n:\\n d.append([[a[q1]]])\\n q", "gt": "= q1\\n q1 += 1\\nfor q in range(len(d)):\\n for q1 in range(len(d[q])):\\n for q2 in range(1, len(d[q][q1]), 2):\\n print(s[d[q][q1][q2-1]], s[d[q][q1][q2]])\\n if len(d[q][q1]) % 2 == 1:\\n d[q][q1] = d[q][q1][-1]\\n else:\\n d[q][q1] = -1\\nfor q in range(len(d)):\\n d1.append([])\\n for q1 in range(len(d[q])):\\n if d[q][q1] != -1:\\n d1[-1].append(d[q][q1])\\nfor q in range(len(d1)):\\n for q1 in range(1, len(d1[q]), 2):\\n print(s[d1[q][q1-1]], s[d1[q][q1]])\\n if len(d1[q]) % 2 == 1:\\n d2.append(d1[q][-1])\\nfor q in range(1, len(d2), 2):\\n print(s[d2[q-1]], s[d2[q]])\\n"}
{"id": "1538", "input": "import sys\\n\\n\\ndef count(n, k, field):\\n blank = 0\\n cnt = [[0] * (n - k + 1) for _ in range(n)]\\n for i, row in enumerate(field):\\n l = row.find('B')\\n r = row.rfind('B')\\n if l == r == -1:\\n blank += 1\\n continue\\n if r - l + 1 > k:\\n continue\\n kl = max(0, r - k + 1)\\n kr = min(l + 1, n - k + 1)\\n cnt[i][kl:kr] = [1] * (kr - kl)\\n\\n acc = [[0] * (n - k + 1) for _ in range(n - k +", "gt": "1)]\\n t_cnt = list(zip(*cnt))\\n for i, col in enumerate(t_cnt):\\n aci = acc[i]\\n tmp = sum(col[n - k:])\\n aci[n - k] = tmp\\n for j in range(n - k - 1, -1, -1):\\n tmp += col[j]\\n tmp -= col[j + k]\\n aci[j] = tmp\\n\\n return blank, acc\\n\\n\\nn, k = list(map(int, input().split()))\\nfield = [line.strip() for line in sys.stdin]\\nbh, hor = count(n, k, field)\\nt_field = [''.join(col) for col in zip(*field)]\\nbv, t_var = count(n, k, t_field)\\nvar = list(zip(*t_var))\\n\\nprint(bh + bv + max(h + v for (rh, rv) in zip(hor, var) for (h, v) in zip(rh, rv)))\\n"}
{"id": "1539", "input": "n = int(input())\\nd = list(map(int, input().split()))\\ns = {i:0 for", "gt": "i in set(d)}\\nfor i in d:\\n s[i] += 1\\nprint(max(s.values()))"}
{"id": "1540", "input": "from collections import defaultdict\\n\\n\\ndef main():\\n n = int(input())\\n hh = list(map(int, input().split()))\\n ee = list(map(int, input().split()))\\n dd = defaultdict(set)\\n for i, h in enumerate(hh):\\n dd[h].add(i)\\n idx = sorted(list(range(n)), key=ee.__getitem__, reverse=True)\\n res = 0\\n for h, s in list(dd.items()):\\n x = sum(ee[i] for i", "gt": "in s)\\n le = len(s) - 1\\n if le:\\n for i in idx:\\n if hh[i] < h and i not in s:\\n x += ee[i]\\n le -= 1\\n if not le:\\n break\\n if res < x:\\n res = x\\n print(sum(ee) - res)\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1541", "input": "n, m, k = map(int, input().split())\\nchats_ = []\\nfor i in range(n):\\n a = list(map(int, input().split()))\\n chats_.append(a)\\nsent = [0 for i in range(n)]\\nchats = [0 for i in range(m)]\\nfor i in range(k):\\n a, b =", "gt": "map(int, input().split())\\n sent[a - 1] += 1\\n chats[b - 1] += 1\\nfor i in range(n):\\n sum = 0\\n for j in range(m):\\n sum += chats_[i][j] * chats[j]\\n sum -= sent[i]\\n print(sum, end = ' ')"}
{"id": "1542", "input": "s = input()\\nsuc = 0\\np = 0\\nkde = 0\\nfor i in range(len(s)):\\n c = s[i]\\n if c == '^':\\n kde = i\\nfor", "gt": "i in range(len(s)):\\n c = s[i]\\n if '1' <= c <= '9':\\n suc+=((kde-i)*int(c))\\n p+=1\\nif suc < 0:\\n print(\"right\")\\nelif suc > 0:\\n print(\"left\")\\nelse:\\n print(\"balance\")\\n"}
{"id": "1543", "input": "import bisect\\nn = int(input())\\np = list(map(int, input().split()))\\np.sort()\\nq = int(input())\\nfor", "gt": "i in range(q):\\n c = int(input())\\n print(bisect.bisect_right(p, c))\\n \\n"}
{"id": "1544", "input": "from sys import stdin, stdout\\ninput, print = stdin.readline, stdout.write\\nn = int(input())\\nr, g, b = [], [], []\\nans = 0\\nfor i in range(n):\\n x, t = [i for i in input().split()]\\n x = int(x)\\n if t == 'P':\\n g.append(x)\\n elif t == 'R':\\n r.append(x)\\n else:\\n b.append(x)\\n \\nif len(g) == 0:\\n if len(r):\\n ans += r[-1] - r[0]\\n if len(b):\\n ans += b[-1] - b[0]\\n print(str(ans))\\n return\\n \\nif not len(r):\\n r.append(g[0])\\nif not len(b):\\n b.append(g[0])\\nif r[0] < g[0]:\\n ans += g[0] - r[0]\\nif b[0] < g[0]:\\n ans += g[0] - b[0]\\nif r[-1] > g[-1]:\\n ans += r[-1] - g[-1]\\nif b[-1] > g[-1]:\\n ans += b[-1] - g[-1]\\nbi, ri = 0, 0\\n\\nfor i in range(len(g) - 1):\\n while bi < len(b) - 1 and b[bi] < g[i]:\\n bi += 1\\n while ri < len(r) - 1 and r[ri] < g[i]:\\n ri += 1\\n a1, a2 = (g[i + 1] -", "gt": "g[i]) * 3, (g[i + 1] - g[i]) * 2\\n mr, mb, cbi, cri = r[ri] - g[i], b[bi] - g[i], bi, ri\\n\\n while cbi + 1 < len(b) and b[cbi + 1] < g[i + 1]:\\n mb = max(mb, b[cbi + 1] - b[cbi])\\n cbi += 1\\n mb = max(mb, g[i + 1] - b[cbi])\\n while cri + 1 < len(r) and r[cri + 1] < g[i + 1]:\\n mr = max(mr, r[cri + 1] - r[cri])\\n cri += 1\\n mr = max(mr, g[i + 1] - r[cri])\\n \\n if b[bi] < g[i] or b[bi] > g[i + 1]:\\n a2 = 100000000000000\\n a1 -= g[i + 1] - g[i]\\n mb = 0\\n if r[ri] < g[i] or r[ri] > g[i + 1]:\\n a2 = 100000000000000\\n a1 -= g[i + 1] - g[i]\\n mr = 0\\n \\n ans += min(a1 - mr - mb, a2)\\n \\nprint(str(ans))\\n"}
{"id": "1545", "input": "n = int(input())\\nc1 = n\\nc2 = (n * (n-1)) // 2\\nc3 = (n * (n-1) * (n-2)) // (2*3)\\nc4 = (n * (n-1) * (n-2) * (n-3)) // (2*3*4)\\nc5 = (n * (n-1) * (n-2)", "gt": "* (n-3) * (n-4)) // (2*3*4*5)\\nw1 = 0\\nw1 += c1\\nw1 += c2 * 2\\nw1 += c3 \\nw2 = 0\\nw2 += c1\\nw2 += c2 * 4\\nw2 += c3 * 6\\nw2 += c4 * 4\\nw2 += c5\\nprint(w1*w2)"}
{"id": "1546", "input": "read = lambda: map(int, input().split())\\nn = int(input())\\ns = input()\\na = list(read())\\ndp = [0] * (n + 2)\\nmn = [10 ** 4] * (n + 2)\\ndp[0] = dp[n + 1] = 1\\nmn[n + 1] = 0\\nmn[0] = 1\\nMax = 1\\nmod = 10 ** 9 + 7\\nfor i in range(1, n):\\n res = 0\\n cur = 10", "gt": "** 4\\n for j in range(i, -1, -1):\\n c = ord(s[j]) - ord('a')\\n cur = min(cur, a[c])\\n if cur < (i - j + 1):\\n break\\n dp[i] = (dp[i] + dp[j - 1]) % mod\\n mn[i] = min(mn[i], mn[j - 1] + 1)\\n Max = max(Max, i - j + 1)\\nprint(dp[n - 1])\\nprint(Max)\\nprint(mn[n - 1])"}
{"id": "1547", "input": "#!/usr/local/bin/python3\\n\\n\\nimport sys\\n\\nDEBUG = '-d' in sys.argv\\n\\n\\ndef debug(*args, **kwargs):\\n if DEBUG:\\n print(*args, file=sys.stderr, **kwargs)\\n\\n return None\\n\\n\\n\\ndef main():\\n n = int(input())\\n\\n cnt = [0] * (n + 1)\\n edge = []\\n\\n for i in range(0, n + 1):\\n edge.append(set())\\n\\n for i in range(0, 2 * n):\\n s, t = map(int, input().split())\\n edge[s].add(t)\\n edge[t].add(s)\\n cnt[s] += 1\\n cnt[t] += 1\\n\\n c4 = 0\\n for i in range(1, n + 1):\\n if cnt[i] == 4:\\n c4 += 1\\n\\n if c4 != n:\\n print(-1)\\n", "gt": "else:\\n for v2 in edge[1]:\\n for v3 in edge[1]:\\n if v2 in edge[v3]:\\n mark = [True] * (n + 1)\\n mark[1] = False\\n mark[v2] = False\\n res = [1, v2]\\n i = v3\\n try:\\n while True:\\n res.append(i)\\n mark[i] = False\\n if len(res) == n:\\n print(' '.join([str(x) for x in res]))\\n return\\n for e in edge[i]:\\n if e != i and mark[e] and res[-2] in edge[e]:\\n i = e\\n break\\n if not mark[i]:\\n raise StopIteration\\n except StopIteration:\\n pass\\n\\n print(-1)\\n\\n\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "1548", "input": "#!/usr/bin/env python3\\n\\nn, m, k = [int(x) for x in input().split()]\\n\\nrow = [(0, -1)] * n\\ncol = [(0, -1)] * m\\nfor i in range(0, k):\\n t, num, color = [int(x) for x in input().split()]\\n num -= 1\\n", "gt": "if t == 1:\\n row[num] = (color, i)\\n else:\\n assert t == 2\\n col[num] = (color, i)\\n\\nfor r in row:\\n for c in col:\\n if c[1] > r[1]:\\n print(c[0], end=' ')\\n else:\\n print(r[0], end=' ')\\n print()\\n\\n"}
{"id": "1549", "input": "n = int(input())\\nl =", "gt": "list(map(int,input().split()))\\nl.sort()\\na = l[:n//2]\\nb = l[n//2:]\\nprint(sum(a)**2+sum(b)**2)"}
{"id": "1550", "input": "from bisect import bisect_left as bl\\nimport sys\\n\\nN, M, Q = map(int, sys.stdin.readline().split())\\ncount = [0] * (M + 1)\\nA = []\\nfor a in sys.stdin.readline().split():\\n a = int(a)\\n A.append(count[a] * M + a)\\n count[a] += 1\\nA.sort()\\nA =[a - i for i, a in enumerate(A, 1)]\\nfor _ in range(Q):\\n q = int(sys.stdin.readline()) - N\\n if q > A[-1]:\\n q += N\\n else:\\n q += bl(A, q)\\n sys.stdout.write(f'{(q - 1) %", "gt": "M + 1}"}
{"id": "1551", "input": "\\ndef modify(string, index):\\n \\n if string[index] == '0':\\n key = 0\\n else:\\n key = 10 - int(string[index])\\n bad = ''\\n for i in string:\\n", "gt": "bad += str((int(i) + key) % 10)\\n return bad[index:] + bad[:index]\\n\\n\\nx = int(input())\\ny = input()\\nminx = 'zzzzzzzzz'\\nfor i in range(x):\\n minx = min(minx, modify(y, i))\\nprint(minx)\\n"}
{"id": "1552", "input": "import math\\nleftpeople = set()\\nrightpeople = set()\\n\\nn, vl = list(map(int, input().split()))\\n\\ndef leftinterval(x0, v0, t):\\n if x0 / v0 <= t:\\n return (0, 10**6)\\n if x0 / (vl + v0) > t:\\n return (-1, -2)\\n leftbound = x0\\n rightbound = (vl * vl - v0 * v0) * t + x0 * v0\\n rightbound /= vl\\n rightbound = int(rightbound)\\n if rightbound > 10**6:\\n rightbound = 10**6\\n return (leftbound, rightbound)\\ndef rightinterval(x0, v0, t):\\n if (10**6 - x0) / v0 <= t:\\n return (0, 10**6)\\n if (10**6 - x0) / (v0 + vl) > t:\\n return (-1, -2)\\n rightbound = x0\\n leftbound = v0 * x0 + (10**6) * (vl - v0) - t * (vl * vl - v0 * v0)\\n leftbound /= vl\\n leftbound = math.ceil(leftbound)\\n if(leftbound < 0):\\n leftbound = 0\\n return (leftbound, rightbound)\\n\\ndef check(t):\\n", "gt": "events = []\\n for item in leftpeople:\\n temp = leftinterval(item[0], item[1], t)\\n if(temp[0] > temp[1]):\\n continue\\n events.append((temp[0], 0, 0))\\n events.append((temp[1], 1, 0))\\n if(temp[1] - temp[0] == 10**6):\\n break\\n for item in rightpeople:\\n temp = rightinterval(item[0], item[1], t)\\n if(temp[0] > temp[1]):\\n continue\\n events.append((temp[0], 0, 1))\\n events.append((temp[1], 1, 1))\\n if(temp[1] - temp[0] == 10**6):\\n break\\n events.sort()\\n opened = [0, 0]\\n for item in events:\\n color = item[2]\\n action = item[1]\\n if action == 0:\\n if opened[(color + 1) % 2] > 0:\\n return True\\n opened[color] += 1\\n else:\\n opened[color] -= 1\\n return False\\n\\nfor i in range(n):\\n a, b, c = list(map(int, input().split()))\\n if c == 1:\\n leftpeople.add((a, b))\\n if c == 2:\\n rightpeople.add((a, b))\\n\\nl = 0\\nr = 1e9\\nfor i in range(50):\\n m = (l + r) / 2\\n if(check(m)):\\n r = m\\n else:\\n l = m\\n\\nprint(m)\\n"}
{"id": "1553", "input": "n = int(input())\\nm = list(map(int, input().split()))\\na = []\\nb = []\\nc = []\\nfor i in range(n):\\n if m[i] == 1:\\n a.append(i + 1)\\n if", "gt": "m[i] == 2:\\n b.append(i + 1)\\n if m[i] == 3:\\n c.append(i + 1)\\nans = min(len(a), len(b), len(c))\\nprint(ans)\\nfor i in range(ans):\\n print(a[i], b[i], c[i])"}
{"id": "1554", "input": "def func(arr):\\n arr.sort()\\n ans = 0\\n for i in range(len(arr) - 1, -1, -2):\\n ans += arr[i]\\n return ans\\n\\ndef main():\\n n, h =", "gt": "map(int, input().split())\\n arr = list(map(int, input().split()))\\n for i in range(1, n + 1):\\n if func(arr[:i]) > h:\\n i -= 1\\n break\\n print(i)\\n return 0\\nmain()"}
{"id": "1555", "input": "n = int(input())\\ncnt = 0\\ngems = list(map(int, input().split()))\\npearls = set()\\nfor i in range(n):\\n if gems[i] not in pearls:\\n pearls.add(gems[i])\\n else:\\n cnt += 1\\n pearls = set()\\n \\nif cnt:\\n print(cnt)\\n first = 0\\n second = 0\\n pearls", "gt": "= set()\\n for i in range(n):\\n if gems[i] not in pearls:\\n pearls.add(gems[i])\\n else:\\n if second:\\n print(first + 1, second + 1)\\n first = second + 1\\n second = i\\n pearls = set()\\n print(first + 1, n)\\nelse:\\n print('-1')"}
{"id": "1556", "input": "'''input\\n3 3\\n>>>\\n<<<\\n>>>\\n'''\\n#print(input().split())\\nn, m = list(map(int, input().split()))\\n#return\\ng = []\\nfor i in range(n):\\n g += [input()]\\n# print(g)\\n\\n\\nmemo = {}\\n\\ndef dfs(u):\\n if u not in memo:\\n memo[u] = res = 1\\n if u < n:\\n for v in range(m):\\n if g[u][v] == '>':\\n res = max(res, dfs(n + v) + 1)\\n for v in range(m):\\n if g[u][v] == '=':\\n res = max(res, dfs(n + v))\\n for v in range(m):\\n if g[u][v] == '=':\\n memo[n + v] = max(memo[n + v], res)\\n else:\\n for v in range(n):\\n if g[v][u - n] == '<':\\n res = max(res,", "gt": "dfs(v) + 1)\\n for v in range(n):\\n if g[v][u - n] == '=':\\n res = max(res, dfs(v))\\n for v in range(n):\\n if g[v][u - n] == '=':\\n memo[v] = max(memo[v], res)\\n memo[u] = res\\n return memo[u]\\nans = [0] * (n + m)\\nfor i in range(n + m):\\n ans[i] = dfs(i)\\nfor i in range(n):\\n for j in range(m):\\n if g[i][j] == '=' and ans[i] != ans[n + j]:\\n print(\"No\")\\n return\\n if g[i][j] == '<' and ans[i] >= ans[n + j]:\\n print(\"No\")\\n return\\n if g[i][j] == '>' and ans[i] <= ans[n + j]:\\n print(\"No\")\\n return\\nprint(\"Yes\")\\nprint(*ans[:n])\\nprint(*ans[n:])\\n"}
{"id": "1557", "input": "import heapq as hq\\nfrom math import ceil\\nn, k, x = [int(i) for i in input().strip().split(' ')]\\narr = [int(i) for i in input().strip().split(' ')]\\nis_neg = False\\nfor i in arr:\\n if i < 0:\\n is_neg = True if is_neg == False else False\\n\\nnarr = [[abs(i), pos, i < 0] for pos, i in enumerate(arr)]\\nhq.heapify(narr)\\nif is_neg:\\n while k > 0:\\n hq.heapreplace(narr, [narr[0][0]+x, narr[0][1], narr[0][2]])\\n k -= 1\\nelse:\\n", "gt": "minode = hq.heappop(narr)\\n mi = minode[0]\\n kswitch = ceil(mi/x) #make the off number of negatives\\n if kswitch > k:\\n kswitch = k\\n else:\\n minode[2] = False if minode[2] == True else True\\n k -= kswitch\\n\\n hq.heappush(narr, [abs(mi-kswitch*x), minode[1], minode[2]])\\n while k > 0:\\n hq.heapreplace(narr, [narr[0][0]+x, narr[0][1], narr[0][2]])\\n k -= 1\\n\\nnarr = sorted(narr, key=lambda x:x[1])\\narr = [str(i[0]*(-1 if i[2] else 1)) for i in narr]\\nprint(\" \".join(arr))"}
{"id": "1558", "input": "h1, a1, c1 = list(map(int, input().split()))\\nh2, a2 = list(map(int, input().split()))\\nd = []\\nwhile h2 > 0:\\n if h2 <= a1:\\n h2 -= a1\\n", "gt": "d.append('STRIKE')\\n else:\\n if h1 <= a2:\\n d.append('HEAL')\\n h1 += c1\\n else:\\n d.append('STRIKE')\\n h2 -= a1\\n h1 -= a2\\nprint(len(d))\\nfor i in d:\\n print(i)\\n"}
{"id": "1559", "input": "import sys\\nn,r,avg=list(map(int,input().split()))\\nL=[]\\ntot=0\\nfor i in range(n):\\n L.append(list(map(int,input().split())))\\n L[i][0],L[i][1]=L[i][1],L[i][0]\\n tot+=L[i][1]\\n L[i][1]=r-L[i][1]\\nreq=avg*n\\nL.sort()\\nind=0\\nans=0\\nwhile(ind<n and", "gt": "req>tot):\\n diff=req-tot\\n if(L[ind][1]>=diff):\\n ans+=diff*L[ind][0]\\n tot+=diff\\n L[ind][1]-=diff\\n else:\\n ans+=L[ind][1]*L[ind][0]\\n tot+=L[ind][1]\\n L[ind][1]=0\\n ind+=1\\nprint(ans)\\n"}
{"id": "1560", "input": "l = int(input())\\na = input()\\nla = len(a)\\nif la % l != 0:\\n per = la//l+1\\n ans = '1'+'0'*(l-1)\\n ans *= per\\n print(ans)\\nelse:\\n ans =", "gt": "a[:l]\\n per = la//l\\n if ans*per > a:print(ans*per)\\n else:\\n temp = str(int(ans)+1)\\n if len(temp) == l:print(temp*per)\\n else:\\n temp = '1'+'0'*(l-1)\\n temp *= (per+1)\\n print(temp)\\n"}
{"id": "1561", "input": "#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n\\ndef f(first, s):\\n second = 'r' if first == 'b' else 'b'\\n alt = [first, second]\\n\\n error = [0, 0]\\n for i,ch in", "gt": "enumerate(s):\\n shouldbe = alt[i % 2]\\n if ch != shouldbe:\\n error[i % 2] += 1\\n\\n return max(error)\\n\\ndef main():\\n n = int(input())\\n s = input()\\n print(min(f('r', s), f('b', s)))\\n\\nmain() \\n"}
{"id": "1562", "input": "n, m, k = list(map(int, input().split()))\\na = [[0] * m for x in range(n)]\\ns = []\\ncount = 0\\nfor i in range(n):\\n s.append(input())\\nfor i in range(n):\\n y = 0\\n for j in range(m):\\n if s[i][j] == \".\":\\n if(a[i][j]", "gt": "+ 1 >= k and k > 1):\\n count += 1\\n y +=1\\n if y >= k:\\n count += 1\\n if i + 1 < n:\\n a[i + 1][j] = a[i][j] + 1\\n else:\\n y = 0\\n \\nprint(count)\\n"}
{"id": "1563", "input": "import sys\\ninput = sys.stdin.readline\\n\\nn,m,k,q=list(map(int,input().split()))\\nTR=[list(map(int,input().split())) for i in range(k)]\\nSAFE=list(map(int,input().split()))\\nSAFE.sort()\\n\\nTRLIST=[[] for i in range(n+1)]\\n\\nfor x,y in TR:\\n TRLIST[x].append(y)\\n\\nwhile TRLIST[-1]==[]:\\n TRLIST.pop()\\n n-=1\\n\\n\\nSTART={1:0} #place,step\\n\\nimport bisect\\n\\nfor step in range(1,n):\\n if TRLIST[step]==[] and step!=1:\\n continue\\n elif TRLIST[step]==[] and step==1:\\n MIN=MAX=1\\n else:\\n MIN=min(TRLIST[step])\\n MAX=max(TRLIST[step])\\n\\n MINind=max(0,bisect.bisect_left(SAFE,MIN)-1)\\n", "gt": "MIN_L=SAFE[MINind]\\n if MINind==q-1:\\n MIN_R=MIN_L\\n else:\\n MIN_R=SAFE[MINind+1]\\n\\n MAXind=max(0,bisect.bisect_left(SAFE,MAX)-1)\\n MAX_L=SAFE[MAXind]\\n if MAXind==q-1:\\n MAX_R=MAX_L\\n else:\\n MAX_R=SAFE[MAXind+1]\\n \\n\\n NEXT=dict()\\n\\n for start in START:\\n st=START[start]\\n \\n NEXT[MIN_L]=min(st+abs(MAX-start)+abs(MAX-MIN)+abs(MIN_L-MIN),NEXT.get(MIN_L,1<<50))\\n NEXT[MIN_R]=min(st+abs(MAX-start)+abs(MAX-MIN)+abs(MIN_R-MIN),NEXT.get(MIN_R,1<<50))\\n NEXT[MAX_L]=min(st+abs(MIN-start)+abs(MAX-MIN)+abs(MAX_L-MAX),NEXT.get(MAX_L,1<<50))\\n NEXT[MAX_R]=min(st+abs(MIN-start)+abs(MAX-MIN)+abs(MAX_R-MAX),NEXT.get(MAX_R,1<<50))\\n\\n START=NEXT\\n #print(START)\\n\\nLAST=1<<50\\n\\nif TRLIST[n]==[]:\\n print(min(START.values())+n-1)\\n return\\n\\nMIN=min(TRLIST[n])\\nMAX=max(TRLIST[n])\\n#print(START)\\nfor start in START:\\n st=START[start]\\n \\n LAST=min(LAST,st+abs(MAX-start)+abs(MAX-MIN),st+abs(MIN-start)+abs(MAX-MIN))\\n\\n\\nprint(LAST+n-1)\\n\\n \\n \\n"}
{"id": "1564", "input": "n, m = map(int, input().split())\\nc = [0] + list(map(int, input().split()))\\nt = {i: set() for i in set(c[1:])}\\nfor i in range(m):\\n a, b = map(int, input().split())\\n if c[a] != c[b]:\\n t[c[a]].add(c[b])\\n t[c[b]].add(c[a])\\nj,", "gt": "k = c[1], 0\\nfor i, s in t.items():\\n l = len(s)\\n if l >= k: \\n if l > k: j, k = i, l\\n elif j > i: j = i\\nprint(j)"}
{"id": "1565", "input": "n = int(input())\\na = input()\\ns = input()\\nd1, d2 = [], []\\nfor q in range(n):\\n if a[q] == 'a' and s[q] == 'b':\\n d1.append(q+1)\\n elif a[q] == 'b' and s[q] == 'a':\\n d2.append(q+1)\\nif (len(d1)+len(d2))", "gt": "% 2 == 1:\\n print(-1)\\nelse:\\n print((len(d1)+len(d2))//2+len(d1) % 2)\\n for q in range(1, len(d1), 2):\\n print(d1[q-1], d1[q])\\n for q in range(1, len(d2), 2):\\n print(d2[q-1], d2[q])\\n if len(d1) % 2 == 1:\\n print(d1[-1], d1[-1])\\n print(d1[-1], d2[-1])\\n"}
{"id": "1566", "input": "l = int(input())\\nn = input()\\nbest = int(n)\\np = (l - 1) // 2\\nfor i in range(p, -1, -1):\\n if (n[i + 1] == '0'):\\n continue\\n\\n best = min(best,", "gt": "int(n[0:(i + 1)]) + int(n[i + 1:]))\\n break\\n\\np = l // 2\\nfor i in range(p, l):\\n if (n[i] == '0'):\\n continue\\n\\n best = min(best, int(n[0:i]) + int(n[i:]))\\n break\\n\\nprint(best)"}
{"id": "1567", "input": "N = int(input())\\ngrid = []\\nx1 = 50\\ny1 = 50\\nx2 = -1\\ny2 = -1\\nfor y in range(N):\\n grid.append(list(map(int, input())))\\n for x, num in enumerate(grid[-1]):\\n if num == 4:\\n x1 = min(x1, x)\\n y1 = min(y1, y)\\n x2 = max(x2, x)\\n y2 = max(y2, y)\\n\\nif x1 == 51:\\n print('No')\\nelse:\\n for y in range(N):\\n for x in range(N):\\n ex = 0\\n if x1 <= x <= x2 and y1 <= y", "gt": "<= y2:\\n ex = 4\\n elif (x == x1-1 or x == x2+1) and y1 <= y <= y2:\\n ex = 2\\n elif (y == y1-1 or y == y2+1) and x1 <= x <= x2:\\n ex = 2\\n elif (x == x1-1 or x == x2+1) and (y == y1-1 or y == y2+1):\\n ex = 1\\n if ex != grid[y][x]:\\n print('No')\\n break\\n else:\\n continue\\n break\\n else:\\n print('Yes')\\n"}
{"id": "1568", "input": "\\ndef modfac(n, MOD):\\n \\n f = 1\\n factorials = [1]\\n for m in range(1, n + 1):\\n f *= m\\n f %= MOD\\n factorials.append(f)\\n inv = pow(f, MOD - 2, MOD)\\n invs = [1] * (n + 1)\\n invs[n] = inv\\n for m in range(n, 1, -1):\\n inv *=", "gt": "m\\n inv %= MOD\\n invs[m - 1] = inv\\n return factorials, invs\\n\\n\\ndef modnCr(n,r,mod,fac,inv):\\n return fac[n] * inv[n-r] * inv[r] % mod\\n\\n\\nn,k = map(int,input().split())\\nmod = 998244353\\nfac,inv = modfac(n+10,mod)\\nans = 0\\n\\nfor i in range(1,n+1):\\n\\n rem = n // i - 1\\n if rem >= k-1:\\n ans += modnCr(rem,k-1,mod,fac,inv)\\n ans %= mod\\n\\nprint (ans)"}
{"id": "1569", "input": "n, a, b, c, t = list(map(int, input().split()))\\n\\nlst = []\\nfor x in input().split():\\n lst.append(int(x))\\n\\nif b > c:\\n print(n * a)\\nelse:\\n acc =", "gt": "0\\n for x in lst:\\n acc += (t - x)\\n acc *= (c - b)\\n acc += n * a\\n print(acc)\\n \\n"}
{"id": "1570", "input": "f = lambda: map(int, input().split())\\ng = lambda: (a.i, b.i) if a.i < b.i else (b.i, a.i)\\n\\nclass T:\\n def __init__(t, i):\\n t.i = i\\n t.s = t.v = t.u = 0\\n t.p = []\\n\\nn, m = f()\\nt = [T(i) for i in range(n + 1)]\\nd, l = [], []\\nfor k in range(m):\\n i, j, q = f()\\n a, b = t[i], t[j]\\n a.p.append(b)\\n b.p.append(a)\\n if q: d += [g()]\\nd = set(d)\\nx, y = [], []\\na = t[1]\\na.u = 1\\nwhile a.i < n:\\n for b", "gt": "in a.p:\\n v = a.v + (g() in d)\\n if not b.u or b.u > a.u and v > b.v: b.v, b.s = v, a.i\\n if not b.u:\\n b.u = a.u + 1\\n y.append(b.i)\\n if not x:\\n x, y = y, x\\n x.reverse()\\n a = t[x.pop()]\\nwhile a.i > 1:\\n b = t[a.s]\\n a.p.remove(b)\\n b.p.remove(a)\\n if g() in d: d.remove(g())\\n else: l += [(a.i, b.i)]\\n a = b\\nprint(len(l) + len(d))\\nfor a, b in l: print(a, b, 1)\\nfor a, b in d: print(a, b, 0)"}
{"id": "1571", "input": "k,n,w = map(int,input().split())\\n\\nx = (w)*(w+1)//2 * k\\n\\ny", "gt": "= x - n\\n\\nif(y >= 0):\\n print(y)\\nelse:\\n print(0)"}
{"id": "1572", "input": "S = input()\\nT = input()\\nbase = 998244353\\ndp = [[0 for _ in range(len(S) + 1)] for _ in range(len(S) + 1)]\\nfor j in range(1, len(S) + 1):\\n if (j > len(T)) or (S[0] == T[j - 1]):\\n dp[1][j] = 2\\nfor i in range(2, len(S) + 1):\\n for j in range(1, len(S) - i + 1 + 1):\\n if (j > len(T)) or", "gt": "(S[i - 1] == T[j - 1]):\\n dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % base\\n if (j + i - 1 > len(T)) or (S[i - 1] == T[j + i - 1 - 1]):\\n dp[i][j] = (dp[i][j] + dp[i - 1][j]) % base\\nans = 0\\nfor i in range(len(T), len(S) + 1):\\n ans = (ans + dp[i][1]) % base\\nprint(ans)"}
{"id": "1573", "input": "n=int(input())\\n\\nL=list(map(int,input().split()))\\n\\nif(n==1 or n==2):\\n print(n)\\nelse:\\n length=2\\n i=2\\n maxx=2\\n while(i<n):\\n if(L[i]==L[i-1]+L[i-2]):\\n", "gt": "length+=1\\n else:\\n if(length>maxx):\\n maxx=length\\n length=2\\n i+=1\\n if(length>maxx):\\n maxx=length\\n print(maxx)\\n"}
{"id": "1574", "input": "from collections import namedtuple\\nfrom operator import itemgetter\\n\\nFriend = namedtuple(\"Friend\", \"m s\")\\n\\nn, d = list(map(int, input().split()))\\nf = [ ]\\nfor i in range(n):\\n f.append(Friend(*list(map(int, input().split()))))\\nf.sort(key=itemgetter(0))\\nleft = 0\\ncur = f[0].s\\nresult =", "gt": "cur\\nfor i, fr in enumerate(f[1:], 1):\\n while left < i and f[left].m + d <= fr.m:\\n cur -= f[left].s\\n left += 1\\n cur += fr.s\\n result = max(result, cur)\\nprint(result)\\n"}
{"id": "1575", "input": "#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n# AUTHOR: haya14busa\\nimport sys\\nimport io\\n\\nfrom collections import defaultdict\\nfrom itertools import combinations\\n\\n\\ndef solve(n, m, pairs):\\n # return: minimum possible sum of their recognitions\\n assert 3 <= n <= 4000 # number of warioor\\n assert 0 <= m <= 4000 # number of pairs of warriors knowing each other\\n # for (a, b) in pairs:\\n # assert 1 <= a < b <= n \\n\\n recognitions = defaultdict(set)\\n\\n for (a, b) in pairs:\\n recognitions[a].add(b)\\n recognitions[b].add(a)\\n\\n minr = float('inf')\\n\\n for candidate, recognition in [(c, rs) for c, rs in list(recognitions.items()) if len(rs) > 1]:\\n for c2, c3 in [(a, b) for a, b in combinations(recognition, 2)\\n if a in recognitions[b]]:\\n sum_r = sum([len(recognitions[x]) for x in [candidate, c2, c3]])\\n minr = min([sum_r, minr])\\n if minr == float('inf'):\\n return -1\\n else:\\n return minr - 2 * 3\\n\\n\\n\\ndef getinput():\\n def getint():\\n return int(input())\\n\\n def getints_line():\\n return list(map(int, input().split(' ')))\\n\\n def getints(n):\\n return [getint() for _ in range(n)]\\n\\n def getints_lines(n):\\n return [getints_line() for _ in range(n)]\\n n, m = getints_line()\\n return [n, m,", "gt": "getints_lines(m)]\\n\\n\\ndef iosolve():\\n return str(solve(*getinput()))\\n # return 'YES' if solve(*getinput()) else 'NO' # for boolean output\\n # return '\\n'.join(map(str, solve(*getinput()))) # for multiple line output\\n\\n\\ndef main():\\n if sys.stdin.isatty():\\n test()\\n stdin_lines = getstdin_lines()\\n sys.stdin = io.StringIO('\\n'.join(stdin_lines))\\n if stdin_lines:\\n print(iosolve())\\n else:\\n test()\\n\\n\\ndef test():\\n IO_TEST_CASES = [\\n\\n (\\n # INPUT\\n '''\\\\n5 6\\n1 2\\n1 3\\n2 3\\n2 4\\n3 4\\n4 5\\n ''',\\n # EXPECT\\n '''\\\\n2\\n '''\\n ),\\n\\n (\\n # INPUT\\n '''\\\\n7 4\\n2 1\\n3 6\\n5 1\\n1 7\\n ''',\\n # EXPECT\\n '''\\\\n-1\\n '''\\n ),\\n\\n\\n ]\\n\\n # List[(List[arg for solve()], expect)]\\n TEST_CASES = [\\n # ([], None),\\n ]\\n\\n # You do need to see below\\n import unittest # to save memory, import only if test required\\n import sys\\n import io\\n\\n class Assert(unittest.TestCase):\\n def equal(self, a, b):\\n self.assertEqual(a, b)\\n\\n def float_equal(self, actual, expect, tolerance):\\n self.assertTrue(expect - tolerance < actual < expect + tolerance)\\n\\n art = Assert()\\n\\n for inputs, expect in TEST_CASES:\\n art.equal(solve(*inputs), expect)\\n\\n for stdin, expect in IO_TEST_CASES:\\n sys.stdin = io.StringIO(stdin.strip())\\n art.equal(iosolve(), expect.strip())\\n # art.float_equal(float(iosolve()), float(expect.strip()), 10 ** -6)\\n\\n\\ndef getstdin_lines():\\n stdin = []\\n while 1:\\n try:\\n stdin.append(input())\\n except EOFError:\\n break\\n return stdin\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1576", "input": "import math\\nimport sys\\n\\narrival, departure, time_per_client = [int(x) for x in input().split()]\\nnum_clients = int(input())\\nif num_clients > 0:\\n clients_arrival = [int(x) for x in input().split()]\\nelse:\\n print(arrival)\\n return\\n\\nbest_time = None\\n\\ncurrent_time = arrival\\nclients_at_queue = 0\\n\\nclient_to_arrive = 0\\nclient_wait_time = [math.inf for client in clients_arrival]\\nclient_to_leave = 0\\n\\nwhile current_time <= departure - time_per_client:\\n while client_to_arrive < num_clients and clients_arrival[client_to_arrive] <= current_time:\\n clients_at_queue +=", "gt": "1\\n client_to_arrive += 1\\n\\n if clients_at_queue == 0:\\n best_time = current_time\\n break\\n else:\\n clients_at_queue -= 1\\n client_wait_time[client_to_leave] = current_time - clients_arrival[client_to_leave]\\n client_to_leave += 1\\n\\n current_time += time_per_client\\n\\n\\n\\nwhile (best_time is None or best_time < 0) and len(client_wait_time) > 0:\\n happiest_client = client_wait_time.index(min(client_wait_time))\\n best_time = clients_arrival[happiest_client] - 1\\n\\n if best_time < 0:\\n client_wait_time = client_wait_time[happiest_client+1:]\\n clients_arrival = clients_arrival[happiest_client+1:]\\n\\n\\nprint(best_time)"}
{"id": "1577", "input": "from collections import deque\\n\\n\\ndef main():\\n s = deque(input())\\n\\n res = []\\n for i in", "gt": "range(len(s) - 1, -1, -1):\\n if i % 2 == 1:\\n res.append(s.pop())\\n else:\\n res.append(s.popleft())\\n\\n print(''.join(res[::-1]))\\n\\n\\nmain()"}
{"id": "1578", "input": "n = int(input())\\ns = input()\\na = s.count('A')\\nd = s.count('D')\\nif", "gt": "a > d:\\n print(\"Anton\")\\nelif d > a:\\n print(\"Danik\")\\nelse:\\n print(\"Friendship\")"}
{"id": "1579", "input": "<s> ", "gt": "n=int(input())\\nprint(n*(n+1)//2-n)"}
{"id": "1580", "input": "from collections import defaultdict\\nimport sys\\n\\n\\nsys.setrecursionlimit(10 ** 6)\\n\\n\\ndef main():\\n N = int(input())\\n V = 100005\\n to = defaultdict(list)\\n for _ in range(N):\\n X, Y = map(int, input().split())\\n Y += V\\n to[X].append(Y)\\n to[Y].append(X)\\n visited = [0] * (2 * V)\\n cnt = [0] * 2 # cnt = [cnt of X, cnt of", "gt": "Y]\\n\\n def dfs(v):\\n if visited[v] == 1:\\n return\\n visited[v] = 1\\n cnt[v // V] += 1\\n for nv in to[v]:\\n dfs(nv)\\n\\n ans = 0\\n for v in range(2 * V):\\n if visited[v] == 1:\\n continue\\n cnt = [0] * 2\\n dfs(v)\\n ans += cnt[0] * cnt[1]\\n ans -= N\\n\\n print(ans)\\n\\n\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "1581", "input": "#!/usr/bin/env python3\\nimport sys\\n\\n\\ndef solve(N: int, M: int, X: \"List[int]\", Y: \"List[int]\", Z: \"List[int]\"):\\n X = [x-1 for x in X]\\n Y = [x-1 for x in Y]\\n uf = UnionFind(N)\\n for x, y in zip(X, Y):\\n uf.union(x, y)\\n return len(uf.roots())\\n\\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\\ndef main():\\n def iterate_tokens():\\n for line in sys.stdin:\\n for word in line.split():\\n yield word\\n tokens = iterate_tokens()\\n N = int(next(tokens)) # type: int\\n M = int(next(tokens)) # type: int\\n X = [int()] * (M) # type: \"List[int]\"\\n Y = [int()] * (M) # type: \"List[int]\"\\n Z = [int()] * (M) # type: \"List[int]\"\\n for i in range(M):\\n X[i] = int(next(tokens))\\n Y[i] = int(next(tokens))\\n Z[i] = int(next(tokens))\\n print((solve(N, M, X, Y, Z)))\\n\\n# https://note.nkmk.me/python-union-find/\\nclass UnionFind():\\n def __init__(self, n):\\n self.n = n\\n self.parents = [-1] * n\\n \\ndef find(self, x):\\n if self.parents[x] < 0:\\n return x\\n else:\\n self.parents[x] = self.find(self.parents[x])\\n return self.parents[x]\\n \\n def union(self, x, y):\\n x = self.find(x)\\n y = self.find(y)\\n \\n if x == y:\\n return\\n \\n if self.parents[x] > self.parents[y]:\\n x, y = y, x\\n \\n self.parents[x] += self.parents[y]\\n self.parents[y] = x\\n \\n def size(self, x):\\n return -self.parents[self.find(x)]\\n \\n def same(self, x, y):\\n return self.find(x) == self.find(y)\\n \\n def members(self, x):\\n root = self.find(x)\\n return [i for i in range(self.n) if self.find(i) == root]\\n \\n def roots(self):\\n return [i for i, x in enumerate(self.parents) if x < 0]\\n \\n def group_count(self):\\n return len(self.roots())\\n \\n def all_group_members(self):\\n return {r: self.members(r) for", "gt": "r in self.roots()}"}
{"id": "1582", "input": "import sys\\nimport numpy as np\\n\\nsr = lambda: sys.stdin.readline().rstrip()\\nir = lambda: int(sr())\\nlr = lambda: list(map(int, sr().split()))\\n\\nMOD = 10 ** 9 + 7\\nN, K = lr()\\nM = int(N**.5)\\n\\n# M+1以上で、Nを割るとxになるもの\\nupper_cnt = np.zeros(M+1, dtype=np.int64) # 1-indexed\\nA = np.arange(M+1, dtype=np.int64)\\nupper_cnt[1:] = N // A[1:] - np.maximum(M, N // (A[1:]+1)) # Mの時はlowerで数えるので0に\\n\\n# 桁DP\\nlower = np.zeros(M+1, dtype=np.int64) # 1-indexed\\nupper = np.zeros(M+1, dtype=np.int64)\\n#最初は制限なしなので1を置いておく\\nlower[1] = 1\\nfor i in range(K):\\n prev_lower =", "gt": "lower.copy()\\n prev_upper = upper.copy()\\n lower_cum = prev_lower.cumsum() % MOD\\n upper_cum = prev_upper.cumsum() % MOD\\n # lower と upper から lower へ\\n lower = np.zeros(M+1, dtype=np.int64)\\n lower[1:] += (lower_cum[-1] + upper_cum[-1])\\n lower[1:] -= upper_cum[:-1] # 大きすぎる値を引く\\n # upper から upper はなし\\n # lower から upper へ\\n upper = lower_cum * upper_cnt\\n lower %= MOD; upper %= MOD\\n\\nanswer = (lower[1:].sum() + upper[1:].sum()) % MOD\\nprint(answer)\\n"}
{"id": "1583", "input": "N = int(input())\\nkeep = [[0 for i in range(10)] for j in range(10)]\\nans = 0\\n\\nfor i in range(1, N + 1):\\n first =", "gt": "int(str(i)[0])\\n end = int(str(i)[-1])\\n keep[first - 1][end - 1] += 1\\n\\nfor i in range(9):\\n for j in range(9):\\n ans += (keep[i][j] * keep[j][i])\\nprint(ans)\\n"}
{"id": "1584", "input": "import math\\na, b, x = map(int,input().split())\\ns =", "gt": "a\\nt = 2*(b-x/(a*a))\\nu = x*2/(b*a)\\nif t<=b:\\n print(math.degrees(math.atan(t/s)))\\nelse:\\n print(math.degrees(math.atan(b/u)))"}
{"id": "1585", "input": "def main():\\n N = int(input())\\n L = [int(l) for l in input().split(\" \")]\\n L.sort()\\n m = len(L)\\n cnt = 0\\n for i in range(m):\\n k = m - 1\\n for j in range(i +", "gt": "1, m):\\n while m + i - j < k:\\n if L[m + i - j] + L[i] <= L[k]:\\n k -= 1\\n else:\\n cnt += k - m - i + j\\n break\\n print(cnt)\\n\\nmain()"}
{"id": "1586", "input": "X,Y = list(map(int,input().split()))\\n#X, 2X, 4X,...,2^(t-1)*X<=Yとなる最大のt\\n#10^18 はだいたい2^60だから全部試せそう\\nfor t in", "gt": "range(1,100):\\n if 2**(t-1)*X<=Y:\\n out = t\\n else:\\n break\\nprint(out)\\n"}
{"id": "1587", "input": "#!/usr/bin/env python\\n\\nn = int(input())\\n\\ndef g1(n, p): \\n ''' \\n How many times can n! be divided by p?\\n '''\\n if n == 0:\\n return 0\\n return n//p + g1(n//p, p)\\n\\ndef g2(n, p): \\n ''' \\n How many times", "gt": "can n!! be divided by p?\\n '''\\n if n%2 == 1:\\n return g1(n, p) - g2(n-1, p)\\n\\n res = g1(n//2, p)\\n if p == 2: \\n res += n//2\\n return res \\n\\nans = min(g2(n, 5), g2(n, 2)) \\nprint(ans)\\n"}
{"id": "1588", "input": "n = int(input())\\nc = input()\\n\\nw = 0\\nr = c.count('R')\\ni = 0\\nans = max(w, r)\\nwhile i <= n - 1:\\n", "gt": "if c[i] == 'W':\\n w += 1\\n else:\\n r -= 1\\n ans = min(ans, max(w, r))\\n i += 1\\nprint(ans)"}
{"id": "1589", "input": "import sys\\n\\ndef solve():\\n n = int(input())\\n s = 1000000\\n xset = set(map(int, input().split()))\\n res = set()\\n wantother = 0\\n for i in range(1, s + 1):\\n opposite = s - i + 1\\n if i in xset:\\n if opposite not in xset:\\n res.add(opposite)\\n else:\\n wantother+=1\\n wantother /= 2\\n for i in", "gt": "range(1, s + 1):\\n if wantother == 0: break\\n opposite = s - i + 1\\n if i not in res and opposite not in res and i not in xset and opposite not in xset:\\n res.add(i)\\n res.add(opposite)\\n wantother-=1\\n\\n print(len(res))\\n return \" \".join(map(str, res))\\n\\n\\n\\n \\nif sys.hexversion == 50594544 : sys.stdin = open(\"test.txt\")\\nprint(solve())"}
{"id": "1590", "input": "n, m = [int(x) for x in input().split()]\\n\\nc = 0\\nfor _ in range(n):\\n a = [int(x) for x", "gt": "in input().split()]\\n for i in range(m):\\n if a[i * 2] or a[i * 2 + 1]:\\n c += 1\\n\\nprint(c)\\n"}
{"id": "1591", "input": "import sys\\n\\nMOD = (int)(1e9+7)\\n\\ndef add(a, b):\\n a += b\\n if a >= MOD: a -= MOD\\n return a\\n \\ndef mul(a, b):\\n return (a * b) % MOD\\n\\nclass fenwickTree:\\n def __init__(self, max_val):\\n self.max_val = max_val + 5\\n self.tree = [0] * self.max_val\\n \\n def update(self, idx, value):\\n idx += 1\\n while idx < self.max_val:\\n self.tree[idx] = add(self.tree[idx], value)\\n idx += (idx & (-idx))\\n \\n def read(self, idx):\\n idx += 1\\n res = 0\\n while idx > 0:\\n res = add(res, self.tree[idx])\\n idx -= (idx & (-idx))\\n return res\\n\\ninp = [int(x) for x in sys.stdin.read().split()]\\n\\nn", "gt": "= inp[0]\\na = []\\nfor i in range(1, n + 1):\\n a.append(inp[i])\\n \\nsorted_array = sorted(a)\\ndict ="}
{"id": "1592", "input": "def main():\\n import sys\\n input = sys.stdin.readline\\n \\n n, k = map(int, input().split())\\n \\n cnt = [0] * k\\n for i in range(n):\\n cnt[int(input()) - 1] += 1\\n \\n dead = 0\\n ans = 0\\n \\n for i", "gt": "in cnt:\\n if i & 1:\\n dead += 1\\n ans += i - 1\\n else:\\n ans += i\\n \\n if n & 1:\\n print(ans + (dead + 1) // 2)\\n else:\\n print(ans + dead // 2)\\n \\n return 0\\n\\nmain()"}
{"id": "1593", "input": "import re\\nimport itertools\\nfrom collections import Counter, deque\\n\\nclass Task:\\n tasks = []\\n answer = \"\" \\n \\n def getData(self):\\n numberOfTasks = int(input())\\n for i in range(0, numberOfTasks):\\n self.tasks += [[int(x) for x in input().split(' ')]]\\n #inFile = open('input.txt', 'r')\\n #inFile.readline().rstrip()\\n #self.childs = inFile.readline().rstrip()\\n\\n def solve(self):\\n queueSize, maxQueueSize = 0, 0\\n time, timeOfLastMessage = 1, 1\\n currentTask = 0\\n while currentTask < len(self.tasks) or queueSize", "gt": "> 0:\\n maxQueueSize = max(maxQueueSize, queueSize)\\n if currentTask < len(self.tasks):\\n timeDelta = self.tasks[currentTask][0] - time\\n queueSize -= min(queueSize, timeDelta)\\n time += timeDelta\\n else:\\n timeOfLastMessage = time + queueSize\\n break\\n \\n if currentTask < len(self.tasks) and \\\\n self.tasks[currentTask][0] == time:\\n queueSize += self.tasks[currentTask][1]\\n currentTask += 1\\n self.answer = str(timeOfLastMessage) + \" \" + str(maxQueueSize)\\n\\n def printAnswer(self):\\n print(self.answer)\\n #outFile = open('output.txt', 'w')\\n #outFile.write(self.answer)\\n\\ntask = Task()\\ntask.getData()\\ntask.solve()\\ntask.printAnswer()\\n"}
{"id": "1594", "input": "n, s = map(int, input().split())\\nc = []\\nfor i in range(n):\\n x, y, z = map(int, input().split())\\n c.append((x, y, z))\\nminans = 10**20\\nfor i in range(n):\\n nc = 0\\n total = s\\n for j in range(n):\\n if c[j][0] ** 2 + c[j][1] **", "gt": "2 <= c[i][0] ** 2 + c[i][1] ** 2:\\n total += c[j][2]\\n if total >= 10**6 and c[i][0] ** 2 + c[i][1] ** 2 < minans:\\n minans = c[i][0] ** 2 + c[i][1] ** 2\\nif minans != 10**20:\\n print(minans ** 0.5)\\nelse:\\n print(-1)"}
{"id": "1595", "input": "n, m = [int(i) for i in input().split()]\\nc = []; t = []\\nfor i in range(n):\\n song = input().split()\\n c.append(int(song[0]))\\n t.append(int(song[1]))\\nreq = [int(i) for i in input().split()]\\n\\nreq_index = total_length", "gt": "= 0\\nfor i in range(len(c)):\\n total_length += c[i] * t[i]\\n while(req_index < len(req)):\\n if(req[req_index] <= total_length):\\n print(i + 1)\\n req_index += 1\\n else:\\n break\\n if req_index == len(req): break"}
{"id": "1596", "input": "(a, b), x, y = list(map(int, input().split())), [], 0\\n\\ndef bin(s):\\n return str(s) if s <= 1 else bin(s >> 1) + str(s & 1)\\n\\ndef lowbit(s):\\n return int('1' + bin(s).split('1')[-1], 2)\\n\\nfor i in reversed(range(b +", "gt": "1)):\\n if y == a:\\n break\\n if a >= y + lowbit(i):\\n x.append(i) \\n y += lowbit(i)\\n\\nif y == a:\\n print( len(x) )\\n print( ' '.join(str(i) for i in x) )\\nelse:\\n print( -1 )"}
{"id": "1597", "input": "from itertools import groupby\\n\\ns = input()\\nn = len(s)\\n\\nif \"w\" in s or \"m\" in s:\\n print(\"0\")\\n return\\n\\nmod = 10**9+7\\nfib = [1, 1]\\nfor i", "gt": "in range(2, n+1):\\n fib.append((fib[-1]+fib[-2])%mod)\\n\\nres = 1\\n\\nfor k, g in groupby(s):\\n if k==\"u\" or k==\"n\":\\n l = len(list(g))\\n res *= fib[l]\\n res %= mod\\n\\nprint(res)"}
{"id": "1598", "input": "import sys\\n\\nSIGMA = 26\\n\\nnodes = []\\npairs = []\\nres = 0\\n\\nclass Node:\\n def __init__(self):\\n self.ch = {}\\n self.a = []\\n self.b = []\\n self.d = 0\\n\\n def add(self, s, i):\\n t = self\\n for c in s:\\n v = ord(c) - ord('a')\\n if not v in t.ch:\\n t.ch[v] = Node()\\n t.ch[v].d = t.d + 1\\n nodes.append(t.ch[v])\\n t = t.ch[v]\\n t.a.append(i)\\n\\n def inc(self, s, i):\\n t = self\\n for c in s:\\n v = ord(c) - ord('a')\\n if not v in t.ch:\\n break\\n t", "gt": "= t.ch[v]\\n t.b.append(i)\\n\\n def solve(self):\\n nonlocal pairs\\n nonlocal res\\n for i in range(SIGMA):\\n if i in self.ch:\\n self.a.extend(self.ch[i].a)\\n self.b.extend(self.ch[i].b)\\n k = min(len(self.a), len(self.b))\\n for i in range(k):\\n pairs.append(str(self.a[-1]) + ' ' + str(self.b[-1]))\\n self.a.pop()\\n self.b.pop()\\n res += self.d\\n return res\\n\\nsys.setrecursionlimit(2000000)\\n_input = sys.stdin.readlines()\\n_input = [s[:-1] for s in _input]\\nN = int(_input[0])\\nA = _input[1 : N + 1]\\nB = _input[N + 1 :]\\nT = Node()\\nnodes.append(T)\\nfor i, s in enumerate(A):\\n T.add(s, i + 1)\\nfor i, s in enumerate(B):\\n T.inc(s, i + 1)\\nfor n in reversed(nodes):\\n n.solve()\\nprint(res)\\nprint('\\n'.join(pairs))\\n"}
{"id": "1599", "input": "s = list(map(int, input()))\\nans = []\\ncnt = 0\\nif s[0] == 1:\\n cnt += 1\\nelse:\\n ans.append('0')\\nfor i in range(1, len(s)):\\n if s[i] == 0 and s[i - 1] == 0:\\n ans.append('0')\\n elif s[i] == 1:\\n cnt += 1\\n else:\\n maba = 0\\n b = 0\\n for", "gt": "x in range(i, len(s)):\\n if s[x] == 1:\\n b -= 1\\n else:\\n b += 1\\n maba = max(maba, b)\\n maba = min(maba, cnt)\\n for _ in range(cnt - maba):\\n ans.append('0')\\n for _ in range(maba):\\n ans.append('1')\\n cnt = 0\\n ans.append('0')\\nfor _ in range(len(s) - len(ans)):\\n ans.append('0')\\nprint(''.join(ans))\\n"}
{"id": "1600", "input": "s=input()\\nt=int(input())\\n\\nans=[]\\nn=len(s)\\nclue=[0]*n\\nfor i in range(n-1):\\n if(s[i]==s[i+1]):\\n clue[i]+=1\\nL=[clue[0]]\\nfor i in range(1,n):\\n L.append(L[i-1]+clue[i])\\n\\nfor i in range(t):\\n", "gt": "A,B=input().split()\\n A=int(A)-1\\n B=int(B)-1\\n r=0\\n x=L[B-1]\\n y=L[A-1]\\n if(A-1<0):\\n y=0\\n ans.append(x-y)\\n\\nfor i in range(t):\\n print(ans[i])\\n \\n"}
{"id": "1601", "input": "#!/usr/bin/env python3\\n\\nfrom collections import Counter\\n\\nn = int(input())\\nh_u = tuple(map(int, input().split()))\\nh_s = sorted(h_u)\\n\\ni = 0\\na = Counter()\\nb = Counter()\\n\\nnum_partitions = 0\\n\\nfor i", "gt": "in range(n):\\n a[h_u[i]] += 1\\n b[h_s[i]] += 1\\n\\n if (a == b):\\n num_partitions += 1\\n a = Counter()\\n b = Counter()\\n\\nprint(num_partitions)"}
{"id": "1602", "input": "n = int(input())\\na = [tuple(map(int, input().split())) for _ in range(n)]\\ns = {a[q]: q+1 for q in range(n)}\\na.sort()\\nq, q1 = 0, 1\\nd, d1, d2 = [[[a[0]]]], [], []\\nwhile q1 < n:\\n while q1 < n and a[q][0] == a[q1][0]:\\n while q1 < n and a[q][1] == a[q1][1]:\\n d[-1][-1].append(a[q1])\\n q1 += 1\\n if q1 < n and a[q][0] == a[q1][0]:\\n d[-1].append([a[q1]])\\n q = q1\\n q1 += 1\\n if q1 < n:\\n d.append([[a[q1]]])\\n q", "gt": "= q1\\n q1 += 1\\nfor q in range(len(d)):\\n for q1 in range(len(d[q])):\\n for q2 in range(1, len(d[q][q1]), 2):\\n print(s[d[q][q1][q2-1]], s[d[q][q1][q2]])\\n if len(d[q][q1]) % 2 == 1:\\n d[q][q1] = d[q][q1][-1]\\n else:\\n d[q][q1] = -1\\nfor q in range(len(d)):\\n d1.append([])\\n for q1 in range(len(d[q])):\\n if d[q][q1] != -1:\\n d1[-1].append(d[q][q1])\\nfor q in range(len(d1)):\\n for q1 in range(1, len(d1[q]), 2):\\n print(s[d1[q][q1-1]], s[d1[q][q1]])\\n if len(d1[q]) % 2 == 1:\\n d2.append(d1[q][-1])\\nfor q in range(1, len(d2), 2):\\n print(s[d2[q-1]], s[d2[q]])\\n"}
{"id": "1603", "input": "import sys\\n\\nn = int(sys.stdin.readline().strip())\\na = list(map(int, sys.stdin.readline().strip().split()))\\nb = a[:]\\nC = [0] * n\\nx = [0] * n\\nfor i in range (0, 40):\\n for j in range (0, n):\\n x[j] = b[j]", "gt": "% 2\\n b[j] = b[j] // 2\\n if sum(x) == 1:\\n for j in range (0, n):\\n if x[j] == 1:\\n C[j] = C[j] + 2 ** i\\nl = C.index(max(C))\\nprint(\" \".join(list(map(str, [a[l]]+a[0:l]+a[l+1:]))))\\n"}
{"id": "1604", "input": "n = int(input())\\nv = list(map(int, input().split()))\\nu = sorted(v)\\ndv, du = [0] * (n + 1), [0] * (n + 1)\\nans = list()\\n\\nfor i in range(1, n + 1):\\n dv[i]", "gt": "= dv[i-1] + v[i-1]\\n du[i] = du[i-1] + u[i-1]\\n\\nfor i in range(int(input())):\\n (t, l, r) = list(map(int, input().split()))\\n d = dv if t == 1 else du\\n ans.append(str(d[r] - d[l-1]))\\n\\nprint('\\n'.join(ans))\\n"}
{"id": "1605", "input": "import sys\\ninput = sys.stdin.readline\\n\\nMOD = 998244353\\n\\n\\nMAX = 5 * 10 ** 5 + 5\\n\\nfact = [1]\\nfor i in range(1, MAX + 1):\\n new = fact[-1] * i\\n fact.append(new % MOD)\\n\\ninvL = pow(fact[MAX],MOD-2,MOD)\\nfactInv = [invL] * (MAX + 1)\\nfor i in range(MAX - 1, -1, -1):\\n old = factInv[i + 1]\\n new = old * (i + 1)\\n factInv[i] = new % MOD\\n\\ndef choose(a,b):\\n if a <", "gt": "b:\\n return 0\\n res = fact[a]\\n res *= factInv[b]\\n res %= MOD\\n res *= factInv[a - b]\\n res %= MOD\\n return res\\n \\n\\nn, k = list(map(int, input().split()))\\nevents = []\\nfor i in range(n):\\n s, e = list(map(int, input().split()))\\n events.append(2*s+0)\\n events.append(2*e+1)\\n \\nevents.sort()\\ncount = 0\\nout = 0\\nfor t in events:\\n if t&1== 0:\\n out += choose(count, k - 1)\\n count += 1\\n out %= MOD\\n else:\\n count -= 1\\n\\nprint(out)\\n"}
{"id": "1606", "input": "string=input()\\nlength=len(string)\\ngoodbad=[[1, 0, 0, 0] for x in range(length)]\\n\\n#good odd\\n#bad odd\\n#good even\\n#bad even\\n\\nfor i in range(length-1):\\n if", "gt": "string[i]==string[i+1]:\\n goodbad[i+1][0]+=goodbad[i][2]\\n goodbad[i+1][2]+=goodbad[i][0]\\n goodbad[i+1][1]+=goodbad[i][3]\\n goodbad[i+1][3]+=goodbad[i][1]\\n else:\\n goodbad[i+1][3]+=goodbad[i][0]\\n goodbad[i+1][0]+=goodbad[i][3]\\n goodbad[i+1][1]+=goodbad[i][2]\\n goodbad[i+1][2]+=goodbad[i][1]\\n\\noddct=0\\nevenct=0\\nfor i in range(len(goodbad)):\\n oddct+=goodbad[i][0]\\n evenct+=goodbad[i][2]\\nprint(evenct, oddct)\\n"}
{"id": "1607", "input": "from functools import reduce\\ndef main():\\n from sys import stdin\\n from operator import xor\\n from functools import reduce\\n x, res = reduce(xor, (input()[i] == '1' for", "gt": "i in range(0, int(input()) * 2, 2))), []\\n input()\\n for s in stdin.read().splitlines():\\n if s == '3':\\n res.append(\"01\"[x])\\n else:\\n x ^= True\\n print(''.join(res))\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1608", "input": "n,k=list(map(int,input().split()))\\nmod=998244353\\n\\nNEXT={(0,1):2,(1,2):2}#ww or wh,point k,場合の数\\n\\nfor i in range(1,n):\\n NOW=NEXT\\n NEXT=dict()\\n for key in NOW:\\n \\n \\n\\n if key[0]==0:\\n if k-(n-i)*2<=key[1]<=k:\\n", "gt": "NEXT[key]=NEXT.get(key,0)+NOW[key]\\n if k-(n-i)*2<key[1]+1<=k:\\n NEXT[(0,key[1]+1)]=NEXT.get((0,key[1]+1),0)+NOW[key]\\n NEXT[(1,key[1]+1)]=NEXT.get((1,key[1]+1),0)+NOW[key]*2%mod\\n\\n\\n else:\\n if k-(n-i)*2<=key[1]<=k:\\n NEXT[key]=NEXT.get(key,0)+NOW[key]\\n NEXT[(0,key[1])]=NEXT.get((0,key[1]),0)+NOW[key]*2%mod\\n\\n if k-(n-i)*2<key[1]+2<=k:\\n NEXT[(1,key[1]+2)]=NEXT.get((1,key[1]+2),0)+NOW[key]\\n #print(NOW,NEXT)\\n\\n\\n\\n\\nANS=0\\nfor key in NEXT:\\n if key[1]==k:\\n ANS=(ANS+NEXT[key])%mod\\n\\nprint(ANS)\\n"}
{"id": "1609", "input": "import sys\\n\\nmod = 10**9 + 7\\n\\ndef solve():\\n n = int(input())\\n a = [int(i) for i in input().split()]\\n\\n cnt = [0]*(10**5 + 1)\\n\\n for ai in a:\\n for d in range(1, ai + 1):\\n if d*d > ai:\\n break\\n if ai % d == 0:\\n if d != ai // d:\\n cnt[d] += 1\\n cnt[ai // d] += 1\\n else:\\n cnt[d] += 1\\n\\n ans = 0\\n\\n for i in range(1,", "gt": "10**5 + 1):\\n ans += mobius(i) * (pow(2, cnt[i], mod) - 1)\\n ans %= mod\\n\\n print(ans)\\n\\ndef mobius(x):\\n assert x >= 1\\n\\n divcnt = 0\\n\\n for p in range(2, x + 1):\\n if p*p > x:\\n break\\n if x % p != 0:\\n continue\\n\\n x //= p\\n\\n if x % p == 0:\\n return 0\\n else:\\n divcnt ^= 1\\n\\n if x > 1:\\n divcnt ^= 1\\n\\n return (-1)**divcnt\\n\\ndef __starting_point():\\n solve()\\n__starting_point()"}
{"id": "1610", "input": "n = int(input())\\nlst = [int(x) for x in input().split()]\\ntmp = [False] * 100007\\ntmp2 = [False] * 100007\\n\\nfor x in lst:\\n tmp[x] = True\\n\\n\\n\\nanswer, index = [],", "gt": "1\\nfor x in lst:\\n if not tmp2[x] and x <= len(lst):\\n answer.append(x)\\n tmp2[x] = True\\n else:\\n while tmp[index]:\\n index += 1\\n tmp[index] = True\\n answer.append(index)\\n\\n\\nprint(' '.join(map(str, answer)))"}
{"id": "1611", "input": "rd = lambda: list(map(int, input().split()))\\n\\nn,", "gt": "k = rd()\\nprint(' '.join(map(str, list(range(n, n-k,-1))+list(range(1,n-k+1)))))"}
{"id": "1612", "input": "n = int(input())\\nl = list(map(int, input().split()))\\n\\ntotal = sum(l)\\n\\ngap = 0\\nfor rod", "gt": "in l:\\n gap = max(gap, rod - (total - rod))\\n\\nprint(gap + 1)\\n"}
{"id": "1613", "input": "n = int(input())\\np = list()\\nfor i in range(n):\\n p.append(set([int(x) for x in input().split()[1:]]))\\nfor i in", "gt": "range(n):\\n for j in range(n):\\n if i != j:\\n if p[i].issuperset(p[j]):\\n print(\"NO\")\\n break\\n else:\\n print(\"YES\")\\n\\n"}
{"id": "1614", "input": "input()\\nmemory = list(map(int, input().split()))\\n\\nproc_data = {p: (-1, -1) for p in memory}\\n\\nfor i, c in enumerate(memory):\\n d1, d2 = proc_data[c]\\n if d1 == -1: d1 = i\\n d2 = i\\n proc_data[c] = (d1,", "gt": "d2)\\n\\ntry: del proc_data[0]\\nexcept KeyError:\\n print(\"0\")\\n return\\n\\ndata = list(proc_data.values())\\ndata.sort()\\n\\nans = 0\\n\\nfirst_free = 0\\n\\nfor a, b in data:\\n c = a - first_free\\n ans += min(c, b-a+1)\\n b -= c\\n first_free = b + 1\\n\\nprint(ans)\\n\\n"}
{"id": "1615", "input": "3\\n# Copyright (C) 2016 Sayutin Dmitry.\\n#\\n# This program is free software; you can redistribute it and/or\\n# modify it under the terms of the GNU General Public License as\\n# published by the Free Software Foundation; version 3\\n#\\n# This program is distributed in the hope that it will be useful,\\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\\n# MERCHANTABILITY or", "gt": "FITNESS FOR A PARTICULAR PURPOSE. See the\\n# GNU General Public License for more details.\\n#\\n# You should have received a copy of the GNU General Public License\\n# along with this program; If not, see <http://www.gnu.org/licenses/>.\\n\\ndef main():\\n n, h = list(map(int, input().split()))\\n leng = 0\\n for ai in map(int, input().split()):\\n if ai <= h:\\n leng += 1\\n else:\\n leng += 2\\n\\n print(leng)\\n\\nmain()\\n"}
{"id": "1616", "input": "N,k=input().split()\\nN=int(N)\\nk=int(k)\\nx=0\\nfor i in range(N):\\n", "gt": "A,B=input().split()\\n A=int(A)\\n B=int(B)\\n x+=(max(A,B)-min(A,B)+1)\\n\\nanswer=(x%k)\\nif(answer!=0):\\n answer=k-answer\\n\\nprint(answer)\\n"}
{"id": "1617", "input": "MAX = 1_000_005\\nlp = [0] * MAX\\npr = []\\npid = {1: 0}\\nfor i in range(2, MAX):\\n if not lp[i]:\\n lp[i] = i\\n pr.append(i)\\n pid[i] = len(pr)\\n for p in pr:\\n if p > lp[i] or i * p >= MAX:\\n break\\n lp[i * p] = p\\n\\nn = int(input())\\na = list(map(int, input().split()))\\n\\ng = [[] for _ in range(len(pid))]\\nec = 0\\nfor x in a:\\n f = []\\n while x > 1:\\n p, c = lp[x], 0\\n while lp[x] == p:\\n x //= p\\n c ^= 1\\n if c:\\n f.append(p)\\n if not f:\\n print(1)\\n import sys\\n return\\n f += [1] * (2 -", "gt": "len(f))\\n u, v = pid[f[0]], pid[f[1]]\\n g[u].append((v, ec))\\n g[v].append((u, ec))\\n ec += 1\\n\\ndef bfs(p):\\n d = [-1] * len(pid)\\n d[p] = 0\\n q = [(p, -1)]\\n while q:\\n q2 = []\\n for u, peid in q:\\n for v, eid in g[u]:\\n if d[v] != -1:\\n if eid != peid:\\n return d[u] + d[v] + 1\\n else:\\n d[v] = d[u] + 1\\n q2.append((v, eid))\\n q = q2\\n\\nans = -1\\nfor i in range(len(pid)):\\n if i > 0 and pr[i - 1] ** 2 >= MAX:\\n break\\n cyc = bfs(i) or ans\\n if ans == -1 or cyc < ans:\\n ans = cyc\\nprint(ans)"}
{"id": "1618", "input": "N = int(input())\\ndef f(x):\\n y = N//x\\n return y + x * y * (y-1) // 2\\nans", "gt": "= set()\\nfor i in range(1,32000):\\n if N % i == 0:\\n ans.add(f(i))\\n ans.add(f(N//i))\\nprint(\" \".join(str(x) for x in sorted(ans)))"}
{"id": "1619", "input": "__author__ = \"runekri3\"\\n\\nstairs_amount = int(input())\\nstair_heights = list(map(int, input().split()))\\nboxes_amount = int(input())\\nboxes = []\\nfor _ in range(boxes_amount):\\n boxes.append(list(map(int,", "gt": "input().split())))\\n\\nfor width, height in boxes:\\n box_bottom = max(stair_heights[0], stair_heights[width - 1])\\n print(box_bottom)\\n stair_heights[0] = box_bottom + height\\n"}
{"id": "1620", "input": "\"\"\"Cowboy Beblop at his computer, problem 717I from https://codeforces.com/problemset/problem/717/I\"\"\"\\n# from fractions import Fraction\\n\\n\\n# def convert_to_fractions(poly):\\n# \"\"\"convert polygon vertex to fractional type\"\"\"\\n# poly_frac = []\\n# for x, y, z in poly:\\n# vertex = (Fraction(x),\\n# Fraction(y),\\n# Fraction(z))\\n# poly_frac.append(vertex)\\n# return poly_frac\\n\\n\\ndef convert_to_float(poly):\\n \"\"\"convert polygon vertex to float type\"\"\"\\n poly_float = []\\n for x, y, z in poly:\\n vertex = (float(x),\\n float(y),\\n float(z))\\n poly_float.append(vertex)\\n return poly_float\\n\\n\\ndef cross_product(a, b):\\n \"\"\"3-vector product\"\"\"\\n return (a[1] * b[2] - a[2] * b[1],\\n a[2] * b[0] - a[0] * b[2],\\n a[0] * b[1] - a[1] * b[0])\\n\\n\\ndef dot_product(a, b):\\n \"\"\"scalar product of 3-vectors\"\"\"\\n return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\\n\\n\\ndef vect_diff(a, b):\\n \"\"\"vector difference\"\"\"\\n return a[0] - b[0], a[1] - b[1], a[2] - b[2]\\n\\n\\ndef poly_normal(poly):\\n \"\"\"return normal vector for first three vertex\"\"\"\\n assert len(poly) >= 3\\n x, y, z = poly[:3]\\n u = vect_diff(y, x)\\n v = vect_diff(z, y)\\n return cross_product(u, v)\\n\\n\\ndef intersect_list(poly, plain_norm, plain_point, proj_dir):\\n \"\"\"list of intersection points\\n\\n find points where the edges enter or leave upper half-space over the plain\\n :return list of points projection on proj_dir\\n \"\"\"\\n # vertex projection\\n u = [dot_product(vert, proj_dir) for vert in poly]\\n\\n # plain anchor\\n vr = dot_product(plain_point, plain_norm)\\n\\n # polygon vertex\\n v = [dot_product(vert, plain_norm) for vert in poly]\\n\\n u_list = []\\n for i in range(len(poly)):\\n if (v[i-1] > vr) != (v[i] > vr):\\n ur = ((vr - v[i-1]) * u[i] + (v[i] - vr) * u[i-1]) / (v[i] - v[i-1])\\n u_list.append(ur)\\n\\n return u_list\\n\\n\\ndefpoints_to_str(a_points, b_points):\\n \"\"\"string representing the order of points 'a' and 'b'\"\"\"\\n a_pairs = [('a', val) for val in a_points]\\n b_pairs = [('b', val) for val in b_points]\\n pairs = sorted(a_pairs + b_pairs, key=lambda pair: pair[1])\\n letters = [ch for ch, _ in pairs]\\n return ''.join(letters)\\n\\n\\ndef recognize_str(s):\\n \"\"\"return True if string s belong to the grammar\\n\\n The context-free grammar is given\\n S -> SS\\n S -> a S a\\n S -> b S b\\n S -> e\\n\\n The recognising automaton is implemented\\n \"\"\"\\n toggle = {'a':'b',", "gt": "'b':'a'}"}
{"id": "1621", "input": "n = int(input())\\ns =", "gt": "\"aabb\" * ((n+4)//4)\\ns = s[:n]\\nprint(s)"}
{"id": "1622", "input": "s = input().strip()\\nk = int(input())\\nw = list(map(int, input().split()))\\nf = 0\\nm = max(w)\\nfor i in range(len(s)):\\n f += (i", "gt": "+ 1) * w[ord(s[i]) - ord('a')]\\nfor i in range(len(s), len(s) + k):\\n f += (i + 1) * m\\nprint(f)"}
{"id": "1623", "input": "n, m = map(int, input().split())\\nev = [tuple(map(int, input().split())) for _ in range(m)]\\n\\ng = [[] for _ in range(n + 1)]\\nqry = [[] for _ in range(m + 1)]\\nroots = set(range(1, n + 1))\\nqcnt = 0\\nfor e in ev:\\n if e[0] == 1:\\n g[e[2]].append(e[1])\\n roots.remove(e[1])\\n elif e[0] == 3:\\n qry[e[2]].append((qcnt, e[1]))\\n qcnt += 1\\n\\ntin, tout = [0] * (n + 1), [0] * (n + 1)\\nst = [(u, 0) for u in roots]\\ntime = 0\\nwhile st:\\n u, w =", "gt": "st.pop()\\n if w:\\n tout[u] = time\\n continue\\n time += 1\\n tin[u] = time\\n st.append((u, 1))\\n for v in g[u]:\\n st.append((v, 0))\\n\\np = list(range(n + 1))\\ndef find(x):\\n if x != p[x]:\\n p[x] = find(p[x])\\n return p[x]\\n\\npcnt = 0\\nans = [None] * qcnt\\nfor e in ev:\\n if e[0] == 1:\\n p[find(e[1])] = find(e[2])\\n elif e[0] == 2:\\n pcnt += 1\\n for qid, x in qry[pcnt]:\\n ans[qid] = 'YES' if find(e[1]) == find(x) and tin[x] <= tin[e[1]] <= tout[x] else 'NO'\\n\\nprint(*ans, sep='\\n')"}
{"id": "1624", "input": "def main():\\n import sys\\n input = sys.stdin.readline\\n \\n n, l, r = map(int, input().split())\\n \\n mi = 0\\n curr = 1 << l - 1\\n for i in range(n):\\n mi += curr\\n if curr !=", "gt": "1:\\n curr >>= 1\\n \\n ma = 0\\n curr = 1\\n for i in range(n):\\n ma += curr\\n if curr != 1 << r - 1:\\n curr <<= 1\\n \\n print(mi, ma)\\n \\n return 0\\n\\nmain()"}
{"id": "1625", "input": "n = int(input())\\na = []\\na = input().split()\\na = [int(i) for i in a]\\na.sort()\\nans = 0\\nfor", "gt": "i in range(n // 2):\\n ans += (a[i] + a[n - i - 1]) ** 2\\nprint(ans)"}
{"id": "1626", "input": "n = int(input())\\narr = list(map(float, input().split()))\\nif n == 1:\\n print(int(arr[0]))\\n return\\narr.sort(reverse", "gt": "= True)\\nres = 0\\nwhile arr:\\n res += sum(arr)\\n arr = arr[:len(arr)//4]\\nprint(int(res))\\n"}
{"id": "1627", "input": "import math\\n\\nn, k = [int(x) for x in input().split()]\\n\\na = [int(x) for x in input().split()]\\nb = [int(x) for x in input().split()]\\n\\nc = 1\\nfor i in range(n // k):\\n count = (10 ** k - 1) // a[i] + 1\\n mmin", "gt": "= b[i] * (10 ** (k-1))\\n mmax = (b[i] + 1) * (10 ** (k-1)) - 1\\n mcount = mmax // a[i] - math.ceil(mmin / a[i]) + 1\\n c = (c * (count - mcount)) % ((10 ** 9) + 7)\\n\\nprint(c)\\n"}
{"id": "1628", "input": "def s(arr):\\n arr2 = arr[:]\\n arr2.sort()\\n return arr == arr2\\n\\nx = int(input())\\ny = list(map(int, input().split(' ')))\\nwhile (not", "gt": "s(y)):\\n for i in range(x-1):\\n if y[i] > y[i+1]:\\n print(i+1, i+2)\\n y[i], y[i+1] = y[i+1], y[i]\\n \\n"}
{"id": "1629", "input": "s = input()\\na, b = s.count('x'), s.count('y')\\nif b > a:", "gt": "print('y' * (b - a))\\nelse: print('x' * (a - b))"}
{"id": "1630", "input": "n, x = map(int, input().split())\\nt = list(map(int, input().split()))\\nm = min(t[: x])\\nif m == 0:\\n i = x - 1\\n while t[i]: i -= 1\\n t[i + 1: x] = [j - 1 for j in t[i + 1: x]]\\n t[i] = x - i - 1\\nelse:\\n t[: x] = [i - 1 for i in t[:", "gt": "x]]\\n m = min(t)\\n if m: t = [i - m for i in t]\\n i = n - 1 \\n while t[i]: i -= 1\\n t[i + 1: ] = [j - 1 for j in t[i + 1: ]]\\n t[i] = x + m * n + n - i - 1\\nprint(' '.join(map(str, t)))"}
{"id": "1631", "input": "n = int(input())\\nfirst = {}\\nsecond = set()\\ns1 = [0] * n\\nans = [0] * n\\nfor i in range(n):\\n a, b = input().split()\\n a = a[:3]\\n b = b[0]\\n s1[i] = b\\n if a in first.keys():\\n first[a].append(i)\\n else:\\n first[a] = [i]\\n ans[i] = a\\nF = True\\nfor name in first.keys():\\n if not F:\\n break\\n if len(first[name]) > 1:\\n for i in first[name]:\\n c = name[:2] + s1[i]\\n if c in second:\\n F = False\\n", "gt": "break\\n else:\\n second.add(c)\\n ans[i] = c\\n first[name] = 0\\n\\ndef process(name):\\n nonlocal F\\n if F == False:\\n return\\n if first[name] != 0 and name in second:\\n t = first[name][0]\\n c = name[:2] + s1[t]\\n if c in second:\\n F = False\\n return\\n else:\\n second.add(c)\\n ans[t] = c\\n first[name] = 0\\n if c in first.keys() and first[c] != 0:\\n process(c)\\n \\n\\n\\nfor name in first.keys():\\n process(name)\\n \\n\\nif F:\\n print('YES')\\n for i in range(n):\\n print(ans[i])\\nelse:\\n print('NO')"}
{"id": "1632", "input": "#return if sa contains a real prefix: sb\\ndef isPrefix( sa , sb ):\\n if len(sa) <= len(sb):\\n return False\\n return sa[0:len(sb)] == sb\\n\\ndef getOrder( sa , sb ):\\n for i in range( 0 , min( len(sa) , len(sb) ) ):\\n if sa[i] != sb[i]:\\n return sa[i],sb[i]\\n\\ntest = False\\nif test:\\n fp = open(\"C-4.in\",\"r\")\\n n = int(fp.readline().strip())\\n names = [ fp.readline().strip() for i in range(0,n)]\\n fp.close()\\nelse:\\n n = int(input().strip())\\n names = [ input().strip() for i in range(0,n)]\\n\\ng = [[False]*26 for i in range(0,26)]\\n\\nres = True\\nfor i in range(1,n):\\n if names[i-1] == names[i] or isPrefix( names[i] , names[i-1] ):\\n continue\\n elif isPrefix( names[i-1] , names[i] ):\\n res = False\\n break\\n else:\\n ca,cb = getOrder( names[i-1] , names[i] )\\n #print(ca,\"<\",cb)\\n if g[ord(cb)-ord('a')][ord(ca)-ord('a')]:\\n res = False\\n break\\n else:\\n g[ord(ca)-ord('a')][ord(cb)-ord('a')] = True\\n\\ndef printG():\\n print(\" abcdefghijklmnopqrstuvwxyz\")\\n", "gt": "for i in range(0,26):\\n print( chr( ord(\"a\") + i ) , \"\".join( [ \"1\" if x else \"0\" for x in g[i]] ) , sep = \"\")\\n#printG()\\n\\nif not res:\\n print(\"Impossible\")\\nelse:\\n\\n def getZeroIndegreeNode():\\n for i in range(0,26):\\n if not used[i] and indegree[i] == 0:\\n return i\\n return -1\\n #topo sort\\n theOrder = []\\n indegree = [0] * 26\\n used = [False] * 26\\n\\n #calc indegree\\n for i in range(0,26):\\n ithIndegree = 0\\n for j in range(0,26):\\n if g[j][i]: ithIndegree += 1\\n indegree[i] = ithIndegree\\n \\n for i in range(0,26):\\n zeroIndegreeNode = getZeroIndegreeNode()\\n if zeroIndegreeNode == -1:\\n res = False\\n break\\n else:\\n used[zeroIndegreeNode] = True\\n theOrder.append( chr( ord('a') + zeroIndegreeNode ) )\\n for j in range(0,26):\\n if g[zeroIndegreeNode][j]:\\n indegree[j] -= 1\\n\\n if not res:\\n print(\"Impossible\")\\n else:\\n print( \"\".join( theOrder ) )\\n"}
{"id": "1633", "input": "MAX_N = 5001\\n\\na = [0] * MAX_N;\\nraz = [0] * (MAX_N + 10);\\ns = [0] * (MAX_N + 10);\\n\\nn = int(input())\\n\\na = list(map(int, input().split()))\\n\\nfor i in range(n):\\n for j in range(n):\\n if a[i] - a[j] > 0:\\n raz[a[i] - a[j]] += 1\\n\\n\\nfor i in range(1, MAX_N + 1):\\n s[i] = s[i -", "gt": "1] + raz[i]\\n \\nans = 0;\\n\\nfor i in range(1, MAX_N):\\n if raz[i] == 0:\\n continue\\n for j in range(1, MAX_N):\\n if i + j > MAX_N:\\n break\\n if raz[j] == 0:\\n continue\\n ans += raz[i] * raz[j] * (s[MAX_N] - s[i + j])\\n\\nans = ans * 1.0\\nans /= s[MAX_N]\\nans /= s[MAX_N]\\nans /= s[MAX_N]\\n\\nprint(ans)"}
{"id": "1634", "input": "\"\"\"\\nCodeforces Contest 288 Div 2 Problem A\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.4.2\\n\"\"\"\\n\\n################################################### SOLUTION\\n\\ndef main():\\n n,m,k = read()\\n board = [[0]*m for _ in range(n)]\\n for i in range(k):\\n x,y = read()\\n x -= 1\\n y -= 1\\n board[x][y] = 1\\n if x > 0 and y > 0 and board[x-1][y-1] and board[x-1][y] and board[x][y-1]:\\n return i+1\\n if x > 0 and y < m-1 and board[x-1][y+1] and board[x-1][y] and board[x][y+1]:\\n return i+1\\n if x < n-1 and y > 0 and board[x+1][y-1]", "gt": "and board[x+1][y] and board[x][y-1]:\\n return i+1\\n if x < n-1 and y < m-1 and board[x+1][y+1] and board[x+1][y] and board[x][y+1]:\\n return i+1\\n return 0\\n\\n\\n#################################################### HELPERS\\n\\n\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "1635", "input": "c = list(map(int, input().split()))\\nn, m = list(map(int, input().split()))\\na = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\nsa = sum(a)*c[0]\\nsb = sum(b)*c[0]\\n\\nfor i in a:\\n sa = min(sa, sa -", "gt": "i*c[0] + c[1])\\nfor i in b:\\n sb = min(sb, sb - i*c[0] + c[1])\\nprint(min(sa + sb, sa + c[2], sb + c[2], c[2] + c[2], c[3]))\\n"}
{"id": "1636", "input": "import itertools\\nimport re\\nimport math\\nimport getpass\\nimport sys\\n\\ndebug = False\\nfiles = False\\nif getpass.getuser() == 'frohe':\\n debug = True\\n\\nif debug and files:\\n sys.stdin = open('test.in')\\n\\n\\ndef ria():\\n return [int(i) for i in", "gt": "input().split()]\\n\\n\\nn = ria()[0]\\nar = ria()\\nmp ="}
{"id": "1637", "input": "def __starting_point():\\n\\n n = int( input() )\\n\\n maxX = [-1]*100005\\n for _ in range(n):\\n px,py = [int(x) for x in input().split()]\\n maxX[py] = max( maxX[py] , px )\\n\\n #print( maxX[:2] )\\n\\n w = [int(x) for x in input().split()]\\n\\n p = [-1]*100005\\n p[0] = 0\\n wdict = dict()\\n wdict[0] = (0,0)\\n res = []\\n", "gt": "for wi in w:\\n if wi in wdict:\\n px , py = wdict.pop(wi)\\n res.append( (px,py) )\\n if maxX[py] > px:\\n wdict[py-(px+1)] = (px+1,py)\\n p[py] += 1\\n if maxX[py+1] != -1 and p[py+1] == -1:\\n wdict[py+1] = (0,py+1)\\n p[py+1] += 1\\n else:\\n break\\n\\n if len(res) == n:\\n print(\"YES\")\\n for ares in res:\\n print(ares[0],ares[1])\\n else:\\n print(\"NO\")\\n__starting_point()"}
{"id": "1638", "input": "import sys\\nn,m = [int(x) for x in input().split()]\\n\\ninp = []\\ns = sys.stdin.read()\\ni = 0\\nwhile True:\\n while i<len(s) and s[i]<'-':i+=1\\n if i==len(s):break\\n j = i\\n while j<len(s) and not(s[j]<'-'):j+=1\\n inp.append(int(s[i:j]))\\n i = j\\n\\norder = sorted(range(n),key=lambda i:inp[2*i]-inp[2*i+1])\\n\\nscore = [0]*n\\nval = sum(inp[1:2*n:2])\\nfor ind in range(n):\\n i = order[ind]\\n\\n #", "gt": "Do second problem together with order[:ind]\\n # Do first problem together with order[ind:]\\n score[i] += val + inp[2*i+1]*(ind-1) + inp[2*i]*(n-ind-1)\\n val += inp[2*i]-inp[2*i+1]\\n\\nfor _ in range(m):\\n u = inp[2*n+2*_]-1\\n v = inp[2*n+2*_+1]-1\\n s = min(inp[2*u]+inp[2*v+1],inp[2*v]+inp[2*u+1])\\n score[u] -= s\\n score[v] -= s\\n\\nsys.stdout.write(' '.join(str(x) for x in score))"}
{"id": "1639", "input": "def main():\\n import sys\\n input = sys.stdin.readline\\n\\n N = int(input())\\n A = list(map(int, input().split()))\\n\\n S = -1\\n for mid in range(N):\\n ans = [0] * N\\n ans[mid] = A[mid]\\n prev = A[mid]\\n for j in range(mid-1,", "gt": "-1, -1):\\n ans[j] = min(prev, A[j])\\n prev = ans[j]\\n prev = A[mid]\\n for j in range(mid+1, N):\\n ans[j] = min(prev, A[j])\\n prev = ans[j]\\n if sum(ans) > S:\\n S = sum(ans)\\n ans_best = ans\\n print(*ans_best)\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1640", "input": "n = input()\\nv = list(map(int, input().split()))\\n\\nbest = 1\\ncurrent = 1\\nfor i in range(1, len(v)):\\n", "gt": "if v[i-1] <= v[i]:\\n current += 1\\n else:\\n current = 1\\n best = max(best, current)\\n\\nprint(best)\\n"}
{"id": "1641", "input": "n = int(input())\\nline = list(map(int, input().split()))\\nm = dict()\\nans = 0\\nfor i in range(n):\\n if line[i] not in m:\\n m[line[i]] = 1\\n else:\\n m[line[i]] += 1\\n var = m[line[i]]\\n if line[i] - 1 in m:\\n var += m[line[i]-1]\\n if line[i] + 1 in m:\\n var += m[line[i]+1]\\n ans += (i+1-var) *", "gt": "line[i]\\nx = dict()\\nfor j in range(n):\\n i = n - j - 1\\n if line[i] not in x:\\n x[line[i]] = 1\\n else:\\n x[line[i]] += 1\\n var = x[line[i]]\\n if line[i] - 1 in x:\\n var += x[line[i]-1]\\n if line[i] + 1 in x:\\n var += x[line[i]+1]\\n ans -= (j+1-var) * line[i]\\nprint(ans)\\n\\n"}
{"id": "1642", "input": "# Question B. Road to Cinema\\nimport sys\\n\\ndef roadToCinema(V, S, T, stations): # O(M)\\n \"\"\"\\n V : volume of fuel tank\\n S : total distance\\n T : time limit\\n stations: fuel stations' locations\\n\\n rtype : boolean, whether this aircraft can travel within the time limit\\n \"\"\"\\n m = len(stations)\\n t = 0\\n stations.append(S) # destination\\n prev = 0\\n for cur in stations:\\n dis = cur - prev\\n # let Sa, Sb as the distance of accelerated mode/ normal mode respectively\\n # then the task is:\\n # min t = (Sa + 2 * Sb)\\n # s.t. Sa + Sb = dis\\n # 2 * Sa + Sb <= V\\n\\n if dis > V:\\n # Sa <= V - dis < 0\\n return False\\n else:\\n # t = Sa + 2Sb = 3(Sa + Sb) - (2Sa + Sb)\\n # >= 3 * dis - V\\n # on the other hand, Sb is non-negative\\n # Sb = t - dis\\n t += max(dis * 3 - V, dis)\\n\\n if t > T:\\n return False\\n\\n prev = cur\\n\\n return True\\n\\ndef binSearch(S, T, stations): # O(logS * M)\\n \"\"\"\\n to find the least tank volume to enable the aircraft to complete", "gt": "the journey\\n the fastest way is to complete the whole journey with the speed of 2km/min, at 2L/km\\n V <= 2S \\n \"\"\"\\n l = stations[0]\\n r = S * 2\\n\\n for i in range(1, len(stations)):\\n l = max(stations[i] - stations[i - 1], l)\\n\\n l = max(l, S - stations[-1])\\n r = 2 * l\\n \\n if T < S:\\n return float(\"inf\")\\n\\n while l + 1 < r:\\n m = l + (r - l) // 2\\n if roadToCinema(m, S, T, stations) == True:\\n r = m\\n else:\\n l = m\\n \\n if roadToCinema(l, S, T, stations):\\n return l\\n if roadToCinema(r, S, T, stations):\\n return r\\n return float(\"inf\")\\n\\ndef __starting_point(): # O(logS * M + N)\\n \\n line = sys.stdin.readline()\\n [N, M, S, T] = list(map(int, line.split(\" \")))\\n\\n aircrafts = []\\n for i in range(N):\\n [c, v] = list(map(int, sys.stdin.readline().split(\" \")))\\n aircrafts.append([c, v])\\n\\n stations = list(map(int, sys.stdin.readline().split(\" \")))\\n stations.sort()\\n\\n minVolume = binSearch(S, T, stations)\\n \\n if minVolume == float(\"inf\"):\\n # no aircraft can complete the journey\\n print(-1)\\n else:\\n res = float(\"inf\")\\n for i in range(N):\\n if aircrafts[i][1] >= minVolume:\\n res = min(res, aircrafts[i][0])\\n\\n if res == float('inf'):\\n # no given aircraft can complete the journey\\n print(-1)\\n else:\\n print(res)\\n__starting_point()"}
{"id": "1643", "input": "class Vector:\\n def __init__(self, x, y):\\n self.x = x\\n self.y = y\\n \\n def __add__(self, other):\\n return Vector(self.x + other.x, self.y + other.y)\\n \\n def __sub__(self, other):\\n return Vector(self.x - other.x, self.y - other.y)\\n \\n def to(self, other):\\n return other - self\\n \\n def __repr__(self):\\n return \"(%s %s)\" % (self.x, self.y)\\n\\n def dot(self, other):\\n return self.x * other.y - self.y * other.x\\n \\n", "gt": "def lensq(self):\\n return self.x ** 2 + self.y ** 2\\n\\nVec = Vector\\n\\ndef getH(p, a, b):\\n s2 = p.to(a).dot(p.to(b))\\n # a * h / 2 = s\\n # h = s * 2 / a\\n return s2 / (a.to(b).lensq() ** 0.5)\\n\\npts = [Vec(*list(map(int, input().split()))) for i in range(int(input()))]\\nn = len(pts)\\npts.append(pts[0])\\npts.append(pts[1])\\n\\nans = 12351513153155135135\\n\\nfor i in range(n):\\n ans = min(ans, getH(pts[i + 1], pts[i], pts[i + 2])/2)\\n\\nprint(ans)\\n"}
{"id": "1644", "input": "from sys import stdin\\ns=stdin.readline().strip()\\ndp=[0 for i in range(len(s)+2)]\\nons=[0 for i in range(len(s)+2)]\\nzs=[0 for i in range(len(s)+2)]\\nfor i in range(len(s)-1,-1,-1):\\n if s[i]==\"1\":\\n ons[i]+=1\\n if(i!=len(s)-1):\\n ons[i]+=ons[i+1]\\nz=0\\nfor", "gt": "i in range(len(s)-1,-1,-1):\\n if(s[i]==\"1\"):\\n dp[i]=max(1+ons[i+1],z)\\n else:\\n dp[i]=max(dp[i+1]+1,1+ons[i+1])\\n z=dp[i]\\n zs[i]=z\\n\\nans=\"\" \\nfor i in range(len(s)):\\n if s[i]==\"1\":\\n x=dp[i]\\n y=1+dp[i+1]\\n if x==y:\\n ans+=\"0\"\\n else:\\n ans+=\"1\"\\n else:\\n ans+=\"0\"\\nprint(ans)\\n"}
{"id": "1645", "input": "from operator import attrgetter, itemgetter\\nn = int(input());\\narr = [[int(x) for x in input().split(' ')] for y in range(n)];\\narr = sorted(arr, key=itemgetter(1,0,2), reverse=True);\\ndp = [0 for x", "gt": "in range(n)];"}
{"id": "1646", "input": "n=int(input())\\na=list(int(i) for i in input().split())\\np=[0]*(n+1)\\nfor i in range(0,n) :\\n p[i+1]+=p[i]+a[i]\\nok=dict()\\nans,l=0,0\\nfor i in range(n+1) :\\n", "gt": "if p[i] in ok :\\n ok[p[i]]+=1\\n else :\\n ok[p[i]]=1\\n while ok[p[i]]>1:\\n ok[p[l]]-=1\\n l+=1\\n ans+=(i-l+1)\\nprint(ans-n-1)\\n\\n\\n"}
{"id": "1647", "input": "n = int(input())\\ns = input()\\nif", "gt": "s == '0':\\n print(0)\\nelse:\\n print('1'+'0'*s.count('0'))\\n"}
{"id": "1648", "input": "# import sys\\n# sys.stdin = open('in.txt', 'r')\\n\\n_ = input()\\ns = input()\\nt = input()\\n\\npar = [i for i in range(26)]\\ndef find(x):\\n if par[x] != x:\\n par[x] = find(par[x])\\n return par[x]\\n else:\\n return x\\n\\nfor i in range(len(s)):\\n a, b = find(ord(s[i])-97), find(ord(t[i])-97)\\n if", "gt": "a != b:\\n par[a] = b\\n\\nres = 0\\nfor i in range(26):\\n find(i)\\n\\nfor i in range(26):\\n res += max(0, par.count(i) - 1)\\nprint(res)\\n\\nfor i in range(26):\\n d = []\\n for j in range(26):\\n if par[j] == i:\\n d.append(chr(j+97))\\n\\n for j in range(len(d)-1):\\n print(d[j], d[j+1])\\n"}
{"id": "1649", "input": "from scipy.special import comb\\nmod = 10**9 + 7\\nN, K = list(map(int,input().split()))\\nfor i in", "gt": "range(1,K+1):\\n a = K-i\\n b = i-1\\n c = N-(i-1)-K\\n d = i\\n print((comb(a+b,b,exact=True)*comb(c+d,d,exact=True)%mod))\\n"}
{"id": "1650", "input": "A,B,C,D=list(map(int,input().split()))\\nfor i in range(2):\\n for j in range(2):\\n for k in range(2):\\n for l in range(2):\\n sum1 = 0\\n sum2 = 0\\n if i == 1:\\n sum1 += A\\n else:\\n sum2 += A\\n if j", "gt": "==1:\\n sum1 += B\\n else:\\n sum2 += B\\n if k == 1:\\n sum1 += C\\n else:\\n sum2 += C\\n if l == 1:\\n sum1 += D\\n else:\\n sum2 += D\\n if sum1 == sum2:\\n print(\"Yes\")\\n return\\nprint(\"No\")\\n"}
{"id": "1651", "input": "MOD = 10**9 + 7\\n\\ns = str(input())\\n\\ndp0 = [0] * (len(s)+1)\\ndp1 = [0] * (len(s)+1)\\ndp0[0] = 1\\n\\nfor i in range(1,len(s)+1):\\n if s[i-1] == \"0\":\\n dp0[i] = dp0[i-1]\\n dp1[i] = dp1[i-1]", "gt": "* 3\\n else:\\n dp0[i] = dp0[i-1] * 2\\n dp1[i] = dp0[i-1] + dp1[i-1] * 3\\n dp0[i] %= MOD\\n dp1[i] %= MOD\\n\\nanswer = dp0[-1] + dp1[-1]\\nif answer >= MOD:\\n answer -= MOD\\nprint(answer)\\n"}
{"id": "1652", "input": "s,p=map(int,input().split())\\nimport math\\nfor i in range(1,math.floor(p**0.5)+1):\\n", "gt": "if p%i==0 and p//i+i==s:\\n print(\"Yes\")\\n return\\nprint(\"No\")"}
{"id": "1653", "input": "S = input()\\nS = \"\".join(list(reversed(S)))\\nstr_list = [\"dream\", \"dreamer\", \"erase\", \"eraser\"]\\nrev_str = []\\nfor i in str_list:\\n rev_str.append(\"\".join(list(reversed(i))))\\nis_OK = True\\nwhile len(S) > 0:\\n if S[0:5] in rev_str:\\n", "gt": "S = S[5:]\\n elif S[0:6] in rev_str:\\n S = S[6:]\\n elif S[0:7] in rev_str:\\n S = S[7:]\\n else:\\n is_OK = False\\n break\\nif is_OK:\\n print(\"YES\")\\nelse:\\n print(\"NO\")\\n"}
{"id": "1654", "input": "# python3\\nimport sys\\n\\n\\ndef read_all_following_lines():\\n lines = sys.stdin.readlines()\\n return (tuple(map(int, line.split())) for line in lines)\\n\\n\\nclass AbcString(object):\\n def __init__(self, string):\\n self.prefix_bc = [0]\\n self.a_strike = [0]\\n\\n bc, strike = 0, 0\\n for symbol in string:\\n if symbol == 'A':\\n strike += 1\\n else:\\n strike = 0\\n bc += 1\\n self.prefix_bc.append(bc)\\n self.a_strike.append(strike)\\n\\n def get_info(self, begin, end):\\n bc = self.prefix_bc[end] - self.prefix_bc[begin]\\n trailing_a = min(self.a_strike[end], end - begin)\\n return bc, trailing_a\\n\\n\\ndef can_mutate(start, finish):\\n from_bc, from_a = start\\n to_bc, to_a = finish\\n\\n if (from_bc & 1) != (to_bc & 1): return", "gt": "False\\n if from_bc > to_bc: return False\\n if from_a < to_a: return False\\n\\n if from_bc == to_bc: return (from_a - to_a) % 3 == 0\\n if from_a == to_a: return from_bc != 0\\n\\n # from_bc < to_bc\\n # from_a > to_a\\n return True\\n\\n\\ndef main():\\n s = AbcString(input())\\n t = AbcString(input())\\n input() # skip one line\\n requests = read_all_following_lines()\\n\\n answer = \"\"\\n for (a, b, c, d) in requests:\\n can = can_mutate(s.get_info(a - 1, b), t.get_info(c - 1, d))\\n answer += \"1\" if can else \"0\"\\n\\n print(answer)\\n\\n\\nmain()\\n"}
{"id": "1655", "input": "s = input()\\nt = input()\\nabc = 'abcdefghijklmnopqrstuvwxyz'\\ndabc ={}\\nfor i in range(26):\\n dabc[abc[i]] = i\\n\\nlt = {}\\nls = {}\\ndd = {}\\nls['?'] = 0\\nfor i in abc:\\n lt[i] = 0\\n ls[i] = 0\\n dd[i] = 0\\nfor letter in t:\\n lt[letter] += 1\\nfor letter in s:\\n ls[letter] +=1\\n\\nX = ls['?']\\ndef check(ans):\\n nonlocal ls, lt, abc, X\\n return -sum(min(0, ls[l] - lt[l] * ans) for l in abc) <= X\\n\\nstart, end = [0, 2000000]\\ni =", "gt": "0\\nwhile start < end:\\n st = start + end\\n ans = (st + st%2)//2\\n if check(ans):\\n start = ans\\n else:\\n end = ans - 1\\nans = start\\n\\n\\nfor letter in abc:\\n dd[letter] = max(0, lt[letter] * ans - ls[letter])\\n X -= max(0, lt[letter] * ans - ls[letter])\\n\\ns1 = ['']\\nj = 0\\nfor i in s:\\n if i != '?':\\n s1.append(i)\\n else:\\n try:\\n while dd[abc[j]] == 0:\\n j +=1\\n s1.append(abc[j])\\n dd[abc[j]] -= 1\\n except:\\n s1.append('z')\\n\\nprint(''.join(s1))\\n"}
{"id": "1656", "input": "n = int(input())\\na = [int(x) for x in input().split()]\\nalive = 0\\nleft = n\\nfor i in range(n", "gt": "- 1, -1, -1):\\n if i < left:\\n alive += 1\\n left = min(left, i - a[i])\\nprint(alive)\\n"}
{"id": "1657", "input": "s = input()\\nn = len(s)\\np = [0] * (n+1)\\nfor x in range(1, n):\\n y = 0\\n if s[x] == 'v' and s[x-1] == 'v':\\n y = 1\\n p[x+1] =", "gt": "p[x] + y\\nq = 0\\nsol = 0\\nfor x in range(n-3, -1, -1):\\n if s[x+1] == 'v' and s[x+2] == 'v':\\n q += 1\\n if s[x] == 'o':\\n sol += q*p[x]\\nprint(sol)\\n"}
{"id": "1658", "input": "from math import inf\\nn, p = [int(x) for x in input().split()]\\nl = []\\nfor i in range(n):\\n a, b = [int(x) for x in input().split()]\\n l.append((a, b, b/a))\\nl.sort(key=lambda x: x[2])\\nasum = 0\\nbsum = 0\\nsumt = 0\\nfor i in range(n):\\n a0,", "gt": "b0, _ = l[i]\\n c1 = inf if i == n-1 else l[i+1][2]\\n asum += a0\\n bsum += b0\\n dp = asum - p\\n if dp > 0:\\n t = bsum / dp\\n if t < c1:\\n print(t)\\n return\\nprint(-1)"}
{"id": "1659", "input": "# fast io\\nfrom sys import stdin\\n_data = iter(stdin.read().split('\\n'))\\ninput = lambda: next(_data)\\n\\nN = 101\\nMOD = 1000000007\\n\\ndef mul_vec_mat(v, a):\\n c = [0] * N\\n for i in range(N):\\n c[i] = sum(a[j][i] * v[j] % MOD for j in range(N)) % MOD\\n return c\\n\\ndef mul_vec_sparse_mat(v, a):\\n c = [0] * N\\n for i in range(N):\\n c[i] = sum(x * v[j] % MOD for j, x in a[i]) % MOD\\n return c\\n\\n_, x = [int(v) for v in input().split()]\\na = [[0] * N for i in range(N)]\\na[0][0] = 1\\na[N - 1][0] = 1\\nfor i in range(1, N - 1):\\n a[i][i + 1] = 1\\nfor d in map(int, input().split()):\\n a[N - 1][N - d] += 1\\nsa = [[]", "gt": "for i in range(N)]\\nfor i in range(N):\\n for j in range(N):\\n if a[i][j] != 0:\\n sa[j].append((i, a[i][j]))\\nr = [[1 if i == j else 0 for j in range(N)] for i in range(N)]\\nwhile x > 0:\\n if x & 1:\\n r[0] = mul_vec_mat(r[0], a)\\n r[1] = mul_vec_mat(r[1], a)\\n aa = [[0] * N for i in range(N)]\\n aa[0] = mul_vec_mat(a[0], a)\\n aa[1] = mul_vec_mat(a[1], a)\\n for i in range(2, N):\\n aa[i] = mul_vec_sparse_mat(aa[i - 1], sa)\\n a = aa\\n x >>= 1\\nfor i in range(2, N):\\n r[i] = mul_vec_sparse_mat(r[i - 1], sa)\\nb = [0] * N\\nb[0] = 1\\nb[N - 1] = 1\\nprint(sum(r[N - 1][i] * b[i] % MOD for i in range(N)) % MOD)"}
{"id": "1660", "input": "n, x = list(map(int, input().split()))\\nr = 0\\nfor _ in range(n):\\n a, b = input().split()\\n if a ==", "gt": "\"+\":\\n x += int(b)\\n else:\\n if int(b) <= x:\\n x -= int(b)\\n else:\\n r += 1\\nprint(x, r)\\n"}
{"id": "1661", "input": "from sys import *\\nf = list(map(int, stdin.read().split()))\\n\\nn, m = f[0], f[1]\\nd = [[] for i in range(100001)]\\n\\nfor j in range(2, len(f), 3):\\n x, y, w = f[j:j +", "gt": "3]\\n d[w].append((y, x))\\n\\ns = [0] * (n + 1)\\nfor q in d:\\n for y, k in [(y, s[x]) for y, x in q]: s[y] = max(s[y], k + 1)\\nprint(max(s))"}
{"id": "1662", "input": "n, m = [int(x) for x in input().strip().split()]\\nc = [int(x) for x in input().strip().split()]\\na = [int(x) for x in input().strip().split()]\\n\\nans", "gt": "= 0\\nai = 0\\nfor ci in c:\\n if ai < len(a) and a[ai] >= ci:\\n ai += 1\\n ans += 1\\nprint(ans)\\n"}
{"id": "1663", "input": "n=int(input())\\na=list(map(int,input().split()))\\ncount=[0]*(10**5+1)\\nfor i in a:\\n count[i]+=1\\nans=[]\\nfor i in range(10**5+1):\\n if count[i]:\\n ans.append(i)\\n", "gt": "count[i]-=1\\nif len(ans)!=n:\\n for i in reversed(range(10**5+1)):\\n if count[i] and ans[-1]!=i:\\n ans.append(i)\\nprint(len(ans))\\nprint(*ans)"}
{"id": "1664", "input": "s=input();M=10**9+7;o=u=v=0;n=len(s)\\nfor i", "gt": "in range(n):c=int(s[i]);"}
{"id": "1665", "input": "from random import seed, randint\\nimport sys\\nsys.setrecursionlimit(10000)\\n\\nopr = ['#', '^', '&', '$']\\nnamespace = { \"res\" : (False, \"res\") }\\nrules = dict()\\nlookup = dict()\\ncnt = -1\\n\\ndef get_tag(var):\\n if var in namespace:\\n return namespace[var][1]\\n else:\\n return var\\n\\nN = int(input())\\nfor _ in range(N):\\n lval, rval = input().split('=')\\n for c in opr:\\n if c in rval:\\n arg1, arg2 = list(map(get_tag, rval.split(c)))\\n rule = (arg1, arg2, c)\\n if rule in rules:\\n namespace[lval] = (True, rules[rule])\\n else:\\n cnt += 1\\n namespace[lval] = (True, cnt)\\n rules[rule] = cnt\\n lookup[cnt] = rule\\n break\\n else:\\n if rval", "gt": "in namespace:\\n namespace[lval] = namespace[rval]\\n else:\\n namespace[lval] = (False, rval)\\n\\nif namespace[\"res\"] == (False, \"res\"):\\n print(\"0\")\\n return\\n\\nprogram = []\\nmyvars = dict()\\n\\ndef reserve():\\n return ''.join(chr(randint(0, 25) + ord('a')) for _ in range(4)) \\n\\ndef implement(rule, final):\\n if type(rule) == str:\\n return rule\\n elif rule in myvars:\\n return myvars[rule]\\n else:\\n if final:\\n name = \"res\"\\n else:\\n name = reserve()\\n myvars[rule] = name\\n arg1, arg2, op = lookup[rule]\\n var1, var2 = implement(arg1, False), implement(arg2, False)\\n program.append(name + \"=\" + var1 + op + var2)\\n return name\\n\\nseed(123)\\nif namespace[\"res\"][0]:\\n implement(namespace[\"res\"][1], True)\\nelse:\\n program.append(\"res=\" + namespace[\"res\"][1])\\nprint(len(program))\\nprint(\"\\n\".join(program))\\n\\n#print(namespace)\\n#print(rules)\\n"}
{"id": "1666", "input": "#!/usr/bin/env python\\n#-*- coding:utf-8 -*-\\n\\n# Code by H~$~C\\n\\nfrom sys import stdin\\ninput = stdin.readline\\nimport math\\n\\nn = int(input())\\nG = [[] for i in range(n + 1)]\\nfor i in range(n - 1):\\n u, v = map(int, input().split())\\n G[u].append([v, i])\\n G[v].append([u, i])\\n\\nans = [-1] * (n + 1)\\n\\nfor u in range(1,", "gt": "n + 1):\\n if (len(G[u]) >= 3):\\n for j in range(len(G[u])):\\n ans[G[u][j][1]] = j\\n cnt = len(G[u])\\n for j in range(n - 1):\\n if (ans[j] == -1):\\n ans[j] = cnt\\n cnt += 1\\n for j in range(n - 1):\\n print(ans[j])\\n return\\n\\nfor i in range(n - 1):\\n print(i)"}
{"id": "1667", "input": "import sys\\nf = sys.stdin\\n#f = open(\"input.txt\", \"r\")\\nx, y, a, b = map(int, f.readline().strip().split())\\na1, a2 = [], []\\nif a+(x-a) <= b:\\n print(0)\\nelse:\\n for", "gt": "i in range(a, x+1):\\n for k in range(b, y+1):\\n if i > k:\\n a1.append(i)\\n a2.append(k)\\n print(len(a1))\\n for i in range(len(a1)):\\n print(a1[i], a2[i])"}
{"id": "1668", "input": "import bisect;\\ndef getIntList():\\n return list(map(int, input().split()));\\ndef getTransIntList(n):\\n first=getIntList();\\n m=len(first);\\n result=[[0]*n for _ in range(m)];\\n for i in range(m):\\n result[i][0]=first[i];\\n for j in range(1, n):\\n curr=getIntList();\\n for i in range(m):\\n result[i][j]=curr[i];\\n return result;\\nn=int(input());\\na=getIntList();\\nanums=[(a[i], i) for i in range(n)];\\nanums.sort();\\nlocation=0;\\nlength=0;\\nk=1;\\npieces=[];\\ndef upgrade(x):\\n curr=(x, x+1)\\n i=bisect.bisect(pieces, curr);\\n joinLeft=False;\\n joinRight=False;\\n if i>0 and pieces[i-1][1]==x:\\n joinLeft=True;\\nif i<len(pieces) and pieces[i][0]==x+1:\\n joinRight=True;\\n if joinLeft:\\n if", "gt": "joinRight:\\n pieces[i-1]=(pieces[i-1][0], pieces[i][1])\\n pieces.pop(i);"}
{"id": "1669", "input": "import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\nfor testcases in range(t):\\n n=int(input())\\n\\n LIST=[input().strip() for i in range(n)]\\n SET=set()\\n\\n ANS=0\\n CHANGE=set()\\n for i in range(n):\\n if LIST[i] in SET:\\n ANS+=1\\n CHANGE.add(i)\\n else:\\n SET.add(LIST[i])\\n\\n ALIST=[]\\n\\n for i in range(n):\\n if", "gt": "i in CHANGE:\\n flag=0\\n now=LIST[i]\\n \\n for j in range(4):\\n for k in range(10):\\n x=now[:j]+str(k)+now[j+1:]\\n\\n if x in SET:\\n continue\\n else:\\n ALIST.append(x)\\n SET.add(x)\\n flag=1\\n break\\n if flag:\\n break\\n\\n else:\\n ALIST.append(LIST[i])\\n print(ANS)\\n print(\"\\n\".join(ALIST))\\n\\n \\n\\n \\n"}
{"id": "1670", "input": "def main():\\n t = int(input())\\n reserved = set(input().split())\\n\\n lines = int(input())\\n code = ''\\n for i in range(lines):\\n code += input() + '\\n'\\n\\n def is_word(suspect):\\n if suspect[0].isdigit(): return False\\n for x in suspect:\\n if (not x.isalpha()) and (not x in {'_', '$'}) and (not x.isdigit()):\\n return False\\n return True\\n\\n def is_token(suspect):\\n if suspect in reserved: return True\\n if is_word(suspect): return True\\n if suspect.isdigit(): return True\\n return False\\n\\n def remove_comments(code):\\n rez = ''\\n state = None\\n for i in range(len(code)):\\n if code[i] == '#':\\n state = 'comment'\\n elif code[i] == '\\n':\\n rez += code[i]\\n state = None\\n else:\\n if state != 'comment':\\n rez += code[i]\\n return rez\\n\\n code = remove_comments(code)\\n code = code.replace('\\n', ' ')\\n\\n def split(code):\\n tokens = []\\n i = 0\\n while i < len(code):\\n if code[i] == ' ':\\n i += 1\\n continue\\n for l in range(min(len(code), 90), 0, -1):\\n if is_token(code[i:i + l]):\\n tokens.append(code[i:i + l])\\n i += l\\n", "gt": "break\\n else:\\n return []\\n return tokens\\n\\n def minmize(tokens):\\n all = []\\n pref = [chr(i + ord('a')) for i in range(26)]\\n all.extend(pref)\\n for ext in range(3):\\n cur = []\\n for i in range(26):\\n for p in pref:\\n cur.append(p + chr(i + ord('a')))\\n cur.sort()\\n all.extend(cur)\\n pref = cur[::]\\n\\n all.reverse()\\n zip = dict()\\n for i in range(len(tokens)):\\n if not tokens[i] in reserved and not tokens[i][0].isdigit():\\n if not zip.get(tokens[i], None):\\n while all[-1] in reserved:\\n all.pop()\\n zip[tokens[i]] = all[-1]\\n all.pop()\\n tokens[i] = zip[tokens[i]]\\n return tokens\\n\\n tokens = (minmize(split(code)))\\n\\n def cmp(a, b):\\n if len(a) != len(b): return False\\n for i in range(len(a)):\\n if a[i] != b[i]: return False\\n return True\\n\\n final = []\\n for i in range(len(tokens)):\\n p = 0\\n for j in range(i - 1, -1, -1):\\n if len(''.join(tokens[j:i + 1])) > 23:\\n p = j\\n break\\n\\n st = ''\\n if i and (not cmp(tokens[p:i + 1], split(''.join(final[p:i]) + tokens[i]))):\\n st += ' '\\n final.append(st + tokens[i])\\n print(''.join(final))\\nmain()"}
{"id": "1671", "input": "s1=input()\\ns2=input()\\nL={}\\nL['h']=s1\\nL['a']=s2\\n\\nn=int(input())\\nD={}\\nF={}\\nfor i in range(n):\\n a=input().split()\\n m=int(a[0])\\n t=L[a[1]]\\n num=int(a[2])\\n c=a[3]\\n if((t,num) in D):\\n", "gt": "continue\\n if(c=='r' or (c=='y' and ((t,num) in F))):\\n D[(t,num)]=1\\n print(t,num,m)\\n else:\\n F[(t,num)]=1\\n"}
{"id": "1672", "input": "diff=0\\nx = int(input())\\nl = list(map(int, input().split(' ')))\\ns = sum(l)\\nk = s//x\\nknum = (k+1)*x-s\\nkpnum = x", "gt": "- knum\\na = knum * [k] + [k+1] * kpnum\\na.sort()\\nl.sort()\\nfor i in range(len(a)):\\n diff += abs(a[i]-l[i])\\nprint(int(diff/2))"}
{"id": "1673", "input": "n = int(input())\\ns = ''\\ns1 = ''\\nans = 0\\nfor i in range(n):\\n", "gt": "s = input()\\n if (s != s1):\\n ans += 1\\n s1 = s\\nprint(ans)"}
{"id": "1674", "input": "from collections import defaultdict\\nimport sys\\ninput = sys.stdin.readline\\n'''\\nfor CASES in range(int(input())):\\nn, m = map(int, input().split())\\nn = int(input())\\nA = list(map(int, input().split()))\\nS = input().strip()\\nsys.stdout.write(\" \".join(map(str,ans))+\"\\n\")\\n'''\\ninf = 100000000000000000 # 1e17\\nmod = 998244353\\n\\nn, m = list(map(int, input().split()))\\nA = [0] + sorted(list(map(int, input().split())))\\n\\nans = 0\\n\\nf = [[0] * (n + 10) for _ in range(m + 10)]\\n\\nfor x in range(1,(A[n] - A[1]) // (m - 1) + 1):\\n for i in", "gt": "range(1, n + 1):\\n f[1][i] = 1\\n for i in range(2, m + 1):\\n sum = 0\\n pre = 1\\n for j in range(1, n + 1):\\n while pre <= n and A[pre] + x <= A[j]:\\n sum += f[i - 1][pre]\\n sum %= mod\\n pre += 1\\n f[i][j] = sum\\n for i in range(1, n + 1):\\n ans += f[m][i]\\n ans %= mod\\nprint(ans)\\n\\n\\n# the end\\n"}
{"id": "1675", "input": "def ii():\\n return int(input())\\ndef mi():\\n return list(map(int, input().split()))\\ndef li():\\n return list(mi())\\n\\nn, k = mi()\\na = li()\\ns = input().strip()\\n\\nans = 0\\ni = 0\\nwhile i < n:\\n", "gt": "j = i + 1\\n while j < n and s[j] == s[i]:\\n j += 1\\n b = sorted(a[i:j])\\n ans += sum(b[-k:])\\n i = j\\nprint(ans)\\n"}
{"id": "1676", "input": "def main():\\n n = int(input())\\n teams = [input().split() for _ in range(n)]\\n ans = [list((0, 0)) for _ in range(n)]\\n home = dict()\\n\\n for i in range(n):\\n home[teams[i][0]] = home.get(teams[i][0], 0) +", "gt": "1\\n\\n for i in range(n):\\n ans[i][0] = n - 1 + home.get(teams[i][1], 0)\\n ans[i][1] = n - 1 - home.get(teams[i][1], 0)\\n\\n for i in range(n):\\n ans[i] = '"}
{"id": "1677", "input": "from collections import deque\\n\\nn, b = map(int, input().split())\\n\\nq = deque()\\nfor _ in range(n):\\n t, d = map(int, input().split())\\n while q and q[0] <= t:\\n q.popleft()\\n if", "gt": "len(q) == b + 1:\\n print(-1, end = ' ')\\n else:\\n if q:\\n t = q[-1]\\n print(t + d, end = ' ')\\n q.append(t + d)\\n"}
{"id": "1678", "input": "d, n, t = 0, int(input()), list(map(int, input().split()))\\np = {a: 0 for a in set(t)}\\nfor i in range(n):\\n a = t[i]\\n if not a in p: continue\\n p.pop(a)\\n s = t.count(a) - 1\\n if 2 * s < d: continue\\n if s > d: d = s\\n k = i + 1\\n for", "gt": "j in range(k, n):\\n if t[j] == a:\\n for b in set(t[k: j]):\\n if b in p: p[b] += 2\\n k = j + 1\\n for b in set(t[k: n]):\\n if b in p: p[b] += 1\\n for b in p:\\n if p[b] > d: d = p[b]\\n p[b] = 0\\nprint(d + 1)"}
{"id": "1679", "input": "from sys import stdin\\nfrom bisect import bisect_left\\ndef read_bit(tree, idx):\\n s = 0\\n while idx > 0:\\n s += tree[idx]\\n idx -= (idx & -idx)\\n return s\\ndef update_bit(tree, idx, val):\\n while idx < len(tree):\\n tree[idx] += val\\n", "gt": "idx += (idx & -idx)\\n\\nn,t=list(map(int,stdin.readline().split()))\\na=[int(x) for x in stdin.readline().split()]\\npref=[0]*n\\npref[0]=a[0]\\nfor i in range(1,n):\\n pref[i]=pref[i-1]+a[i]\\npref.sort()\\nbefore=ans=0\\ntree=[0]*(n+2)\\nfor i in range(n):\\n ind = bisect_left(pref, t + before)\\n if ind>0:\\n ans += ind-read_bit(tree, ind)\\n before += a[i]\\n before_ind=bisect_left(pref, before)\\n update_bit(tree, before_ind+1, 1)\\nprint(ans)\\n"}
{"id": "1680", "input": "input()\\nprint(''.join(str(len(x)) for", "gt": "x in input().split('0')))\\n"}
{"id": "1681", "input": "def binary(n):\\n curr=0\\n while(n>0):\\n if(n%2):\\n curr+=1\\n n=n//2\\n return curr\\nl=input().split()\\nn=int(l[0])\\nk=int(l[1])\\nl=input().split()\\nli=[int(i) for i in l]\\narr=[]\\nfor i in range(2**15):\\n if(binary(i)==k):\\n arr.append(i)\\nhashi=dict()\\nfor i in li:\\n", "gt": "if i in hashi:\\n hashi[i]+=1\\n else:\\n hashi[i]=1\\ncount=0\\nfor i in hashi:\\n for j in arr:\\n if((i^j) in hashi):\\n if((i^j)==i):\\n count=count+(hashi[i]*(hashi[i]-1))\\n else:\\n count=count+(hashi[i]*hashi[i^j])\\nprint(count//2)"}
{"id": "1682", "input": "n = input().rstrip()\\nm = input().rstrip()\\ncnt1 = [0] * 26\\ncnt2 = [0] * 26\\nfor i in n:\\n cnt1[ord(i) - ord(\"a\")] += 1\\nfor i in m:\\n cnt2[ord(i) - ord(\"a\")]", "gt": "+= 1\\nres = 0\\nfor i in range(26):\\n a1 = cnt1[i]\\n a2 = cnt2[i]\\n if a1 == 0 and a2 != 0:\\n print(-1)\\n return\\n res += min(a1, a2)\\nprint(res)"}
{"id": "1683", "input": "read = lambda: map(int, input().split())\\nn, k = read()\\na = list(read())\\nb = list(read())\\nc = [(a[i], b[i]) for i in range(n)]\\nc.sort(key", "gt": "= lambda x: x[0] - x[1])\\nans = sum(c[i][0] for i in range(k))\\nfor i in range(k, n):\\n ans += min(c[i][0], c[i][1])\\nprint(ans)"}
{"id": "1684", "input": "from sys import stdin, stdout, exit\\n\\nmod = 998244353\\n\\nn = int(stdin.readline())\\na = list(map(int, stdin.readline().split()))\\n\\nans = 0\\n\\ndef l(x):\\n if x == 0:\\n return 0\\n return 1 + l(x//10)\\n\\nlens = [0]*15\\nfor x in a:\\n lens[l(x)] += 1\\n\\ndef space_out(x, l):\\n ans = []\\n for i,c in enumerate(reversed(str(x))):\\n ans.append(c)\\n if i < l:\\n", "gt": "ans.append(\"0\")\\n return int(''.join(reversed(ans))) \\n\\nfor i in range(n):\\n x = a[i]\\n cur_head = x//10\\n cur = x\\n prev = x\\n for l in range(11):\\n# print(cur, cur_head)\\n if l > 0:\\n ans += lens[l]*(cur+10*prev)#space_out(x,l)\\n ans %= mod\\n prev = cur\\n cur -= cur_head*10**(2*l+1)\\n cur += cur_head*10**(2*l+2)\\n cur_head //=10\\n\\n\\nstdout.write(str(ans) + \"\\n\")\\n"}
{"id": "1685", "input": "import math\\n\\n\\nclass CodeforcesTask1147BSolution:\\n def __init__(self):\\n self.result = ''\\n self.n_m = []\\n self.points = []\\n\\n def read_input(self):\\n self.n_m = [int(x) for x in input().split(\" \")]\\n for x in range(self.n_m[1]):\\n self.points.append([int(y) for y in input().split(\" \")])\\n\\n def process_task(self):\\n can = False\\n segm = {}\\n for point in self.points:\\n segm[\"{0}_{1}\".format(*point)] = True\\n segm[\"{1}_{0}\".format(*point)] = True\\n for k in range(1, self.n_m[0]):\\n if not self.n_m[0] % k:\\n #print(k)\\n do", "gt": "= True\\n for p in self.points:\\n a, b = (p[0] + k) % self.n_m[0], (p[1] + k) % self.n_m[0]\\n if not a:\\n a = self.n_m[0]\\n if not b:\\n b = self.n_m[0]\\n if not \""}
{"id": "1686", "input": "def mask(n):\\n if not n: return 0;\\n m = 1\\n while not (m & n):\\n m *= 2\\n return m\\n \\nn, T = list(map(int, input().split()))\\nfor t in range(T):\\n cur = int(input())\\n for ch in input():\\n m = mask(cur)\\n #print(ch, \":\", m, cur, \"->\", end = \"", "gt": "\")\\n if ch == \"U\":\\n next = (cur - m) | (m * 2)\\n if next < n: cur = next\\n elif ch == \"L\" and m > 1:\\n cur -= m//2\\n elif ch == \"R\" and m > 1:\\n cur += m//2\\n #print(cur)\\n print(cur) \\n"}
{"id": "1687", "input": "import math\\nimport re\\nfrom fractions import Fraction\\nfrom collections import Counter\\n\\nclass Task:\\n ips = []\\n k = 0\\n answer = ''\\n \\n def __init__(self):\\n n, self.k = [int(x) for x in input().split()]\\n self.ips = ['' for _ in range(n)]\\n for i in range(len(self.ips)):\\n self.ips[i] = input()\\n\\n def solve(self):\\n ips, k = self.ips, self.k\\n ipAsNumbers = []\\n for currentIp in ips:\\n number = 0\\n parts = currentIp.split('.')\\n for i in range(0, len(parts)):\\n number +=", "gt": "int(parts[i]) * 2**(32 - (i + 1) * 8)\\n ipAsNumbers += [number]\\n\\n mask = 0\\n for i in range(31, -1, -1):\\n mask += 2**i\\n netAddresses = set()\\n for ip in ipAsNumbers:\\n netAddresses.add(mask & ip)\\n if len(netAddresses) == k:\\n mask = bin(mask)[2:]\\n self.answer = '.'.join([str(int(mask[i : i + 8], 2)) \\\\n for i in range(0, len(mask), 8)])\\n return\\n self.answer = '-1'\\n\\n\\n def printAnswer(self):\\n print(self.answer)\\n #for line in self.answer:\\n # print(line)\\n\\ntask = Task()\\ntask.solve()\\ntask.printAnswer()\\n"}
{"id": "1688", "input": "input()\\na = [int(x) for x in input().split()]\\nb = min(a)\\nprint(-1", "gt": "if any(x % b for x in a) else b)\\n"}
{"id": "1689", "input": "#TO MAKE THE PROGRAM FAST\\n\\n''' ---------------------------------------------------------------------------------------------------- '''\\nimport sys\\ninput = sys.stdin.readline\\nsys.setrecursionlimit(100000)\\nfrom collections import deque\\n''' ---------------------------------------------------------------------------------------------------- '''\\n\\n\\n\\n\\n#FOR TAKING INPUTS\\n\\n''' ---------------------------------------------------------------------------------------------------- '''\\ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\\ndef val():return int(input().rstrip('\\n'))\\ndef st():return input().rstrip('\\n')\\ndef sttoli():return [int(i) for i in input().rstrip('\\n')]\\n''' ---------------------------------------------------------------------------------------------------- '''\\n\\n\\n\\n\\n#MAIN PROGRAM\\n\\n''' ---------------------------------------------------------------------------------------------------- '''\\n\\nd = deque()\\nn = val()\\nl = li()\\nj = x = 0\\ncurrmax =", "gt": "-10000000000000\\nans = []\\nfor i in range(n):\\n while len(d) and d[0] < i:d.popleft()\\n currmax = l[d[0]%n] if len(d) else l[i]\\n while j<3*n:\\n currmax = max(currmax,l[j%n])\\n while len(d) and l[d[-1]%n] <= l[j%n]:d.pop()\\n d.append(j)\\n if currmax/2 > l[j%n]:\\n ans.append(j-i)\\n break\\n j += 1\\n if j == 3*n:\\n print(*([-1 for _______ in range(n)]))\\n return\\nprint(*ans)\\n\\n\\n\\n\\n\\n''' ---------------------------------------------------------------------------------------------------- '''"}
{"id": "1690", "input": "#!/usr/bin/env python3\\n\\ndef main():\\n try:\\n while True:\\n n = int(input())\\n grid = [input() for i in range(n)]\\n for i, row in enumerate(grid):\\n if row[:2] ==", "gt": "\"OO\":\\n grid[i] = \"++\" + row[2:]\\n break\\n elif row[-2:] == \"OO\":\\n grid[i] = row[:-2] + \"++\"\\n break\\n else:\\n print(\"NO\")\\n continue\\n\\n print(\"YES\")\\n print('\\n'.join(grid))\\n\\n except EOFError:\\n pass\\n\\nmain()\\n"}
{"id": "1691", "input": "rr = lambda: input().strip()\\nrri = lambda: int(rr())\\nrrm = lambda: list(map(int, rr().split()))\\n\\ndef solve(N, A):\\n ans = 0\\n prev = float('inf')\\n for x in reversed(A):\\n x", "gt": "= min(x, prev - 1)\\n ans += max(x, 0)\\n prev = x\\n return ans\\n\\nfor tc in range(1):#rri()):\\n N = rri()\\n A = rrm()\\n print(solve(N, A))\\n"}
{"id": "1692", "input": "n, m = [int(i) for i in input().split()]\\nif m > n//2:\\n m = n-m\\nans = [1]\\ncount = 0\\nc", "gt": "= 1\\nfor i in range(n):\\n count+=m\\n if count>n:\\n c+=1\\n count-=n\\n ans.append(ans[-1] +c)\\n c+=1\\n else:\\n ans.append(ans[-1] +c)\\nans = ans[1:]\\nprint(*ans)"}
{"id": "1693", "input": "s = input()\\n\\nans = 0\\nfor i in range(1, len(s)):\\n if int(s[i - 1: i + 1]) %", "gt": "4 == 0:\\n ans += i\\nfor x in s:\\n if int(x) % 4 == 0:\\n ans += 1\\n\\nprint(ans)\\n"}
{"id": "1694", "input": "from sys import stdin\\n\\n\\ndef solve():\\n n = int(stdin.readline())\\n m = list(map(int, stdin.readline().split()))\\n msl = [-1] * n\\n msp = [n] * n\\n q = []\\n for i in range(n):\\n while q and m[q[-1]] > m[i]:\\n q.pop()\\n if q:\\n msl[i] = q[-1]\\n q.append(i)\\n q = []\\n for i in range(n - 1, -1, -1):\\n while q and m[q[-1]] > m[i]:\\n q.pop()\\n if q:\\n msp[i] = q[-1]\\n q.append(i)\\n\\n dp1 = [0] * n\\n for i in range(n):\\n dp1[i] = m[i] * (i - msl[i])\\n if msl[i] != -1:\\n dp1[i] += dp1[msl[i]]\\n dp2 = [0] *", "gt": "n\\n for i in range(n - 1, -1, -1):\\n dp2[i] += m[i] * (msp[i] - i)\\n if msp[i] != n:\\n dp2[i] += dp2[msp[i]]\\n ansm = 0\\n answc = 0\\n for i in range(n):\\n cur = dp1[i] + dp2[i] - m[i]\\n if cur > answc:\\n answc = cur\\n ansm = i\\n i = ansm\\n cur = [0] * n\\n cur[i] = m[i]\\n for j in range(i + 1, n):\\n cur[j] = min(cur[j - 1], m[j])\\n for j in range(i - 1, -1, -1):\\n cur[j] = min(cur[j + 1], m[j])\\n print(*cur)\\n\\n\\nfor i in range(1):\\n solve()\\n"}
{"id": "1695", "input": "import sys\\nn,m,s,f=list(map(int,sys.stdin.readline().split()))\\nL=[]\\nR=[]\\nT=[]\\nfor i in range(m):\\n t,l,r=list(map(int,sys.stdin.readline().split()))\\n T.append(t)\\n L.append(l)\\n R.append(r)\\n\\nif(f>s):\\n i=s\\n step=1\\n ind=0\\n Ans=\"\"\\n while(i!=f):\\n if(ind>=m or T[ind]!=step):\\n Ans+=\"R\"\\n i+=1\\n else:\\n if((i>=L[ind] and i<=R[ind]) or (i+1>=L[ind] and i+1<=R[ind])):\\n Ans+=\"X\"\\n", "gt": "else:\\n Ans+=\"R\"\\n i+=1\\n ind+=1\\n step+=1\\nelse:\\n i=s\\n step=1\\n ind=0\\n Ans=\"\"\\n while(i!=f):\\n if(ind>=m or T[ind]!=step):\\n Ans+=\"L\"\\n i-=1\\n else:\\n if((i>=L[ind] and i<=R[ind]) or (i-1>=L[ind] and i-1<=R[ind])):\\n Ans+=\"X\"\\n else:\\n Ans+=\"L\"\\n i-=1\\n ind+=1\\n step+=1\\nsys.stdout.write(Ans+\"\\n\")\\n"}
{"id": "1696", "input": "from collections import Counter\\nn, m = map(int, input().split())\\nl = [input() for _ in range(n)]\\nv =", "gt": "[*map(int, input().split())]\\nres = 0\\nfor i in range(m):\\n res += v[i] * max(Counter(s[i] for s in l).values())\\nprint(res)"}
{"id": "1697", "input": "import sys\\nfrom collections import Counter\\nfrom operator import itemgetter\\nfrom heapq import heappop, heappush\\n\\nn, m, k = list(map(int, input().split()))\\npoints = [list(map(int, line.split())) for line in sys.stdin]\\npts_sorted_x = sorted(points)\\npts_sorted_y = sorted(points, key=itemgetter(1, 0))\\ninf = 10**9+1\\nOK = (inf, inf)\\n\\n\\ndef solve2(imos, t):\\n acc, cur = 0, 0\\n\\n for k in sorted(imos.keys()):\\n if t < k:\\n break\\n if acc <= 0 and cur+1 < k or acc + imos[k] <= 0:\\n acc = 0\\n break\\n acc += imos[k]\\n\\n return acc <= 0\\n\\n\\ndef add_imos(imos, x, y):\\n imos[x] += y\\n if imos[x] == 0:\\n del imos[x]\\n\\n\\ndef solve(t, px=-1, py=-1):\\n set_x = {1, n}\\n set_y = {1, m}\\n\\n for x, y in points:\\n set_x.update((max(1, x-t), max(1, x-t-1), min(n, x+t), min(n, x+t+1)))\\n set_y.update((max(1, y-t), max(1, y-t-1), min(m, y+t), min(m, y+t+1)))\\n\\n ans_x = ans_y = inf\\n pi, imos, hq = 0, Counter(), []\\n if px != -1:\\n imos[py] += 1\\n imos[py+t*2+1] -= 1\\n\\n for cx in sorted(set_x):\\n while hq and hq[0][0] < cx:\\n add_imos(imos,", "gt": "hq[0][1], -1)\\n add_imos(imos, hq[0][2], +1)\\n heappop(hq)\\n while pi < k and pts_sorted_x[pi][0]-t <= cx <= pts_sorted_x[pi][0]+t:\\n x, y = pts_sorted_x[pi]\\n add_imos(imos, max(1, y-t), 1)\\n add_imos(imos, y+t+1, -1)\\n heappush(hq, (x+t, max(1, y-t), y+t+1))\\n pi += 1\\n\\n if solve2(imos, m):\\n ans_x = cx\\n break\\n\\n pi = 0\\n imos.clear()\\n hq.clear()\\n if px != -1:\\n imos[px] += 1\\n imos[px+t*2+1] -= 1\\n\\n for cy in sorted(set_y):\\n while hq and hq[0][0] < cy:\\n add_imos(imos, hq[0][1], -1)\\n add_imos(imos, hq[0][2], +1)\\n heappop(hq)\\n while pi < k and pts_sorted_y[pi][1]-t <= cy <= pts_sorted_y[pi][1]+t:\\n x, y = pts_sorted_y[pi]\\n add_imos(imos, max(1, x-t), 1)\\n add_imos(imos, x+t+1, -1)\\n heappush(hq, (y+t, max(1, x-t), x+t+1))\\n pi += 1\\n\\n if solve2(imos, n):\\n ans_y = cy\\n break\\n\\n return ans_x, ans_y\\n\\n\\nok, ng = 10**9+1, -1\\nwhile abs(ok - ng) > 1:\\n mid = (ok + ng) >> 1\\n p = solve(mid)\\n if p == OK:\\n ok = mid\\n continue\\n\\n if solve(mid, p[0], p[1]) == OK:\\n ok = mid\\n else:\\n ng = mid\\n\\nprint(ok)\\n"}
{"id": "1698", "input": "#!/usr/bin/env python\\n\\nimport sys\\n\\nsys.setrecursionlimit(10000)\\n\\nn, m = list(map(int, input().split(' ')))\\n\\ndef neighbors(i, j):\\n return [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]\\n\\ndef valid(i, j):\\n nonlocal n, m\\n if i < 0 or i >= n or j < 0 or j >= m:\\n return False\\n return True\\n\\ndef dfs(f, i, j):\\n color = f[i][j]\\n f[i][j] = color.lower()\\n c = 0\\n for n, m in", "gt": "neighbors(i, j):\\n if valid(n, m):\\n if f[n][m] == color:\\n cycle_found = dfs(f, n, m)\\n if cycle_found:\\n return True\\n elif f[n][m] == color.lower():\\n c += 1\\n if c > 1:\\n return True\\n\\n f[i][j] = None\\n\\n return False\\n\\nf = []\\nfor i in range(n):\\n f.append(list(input().strip()))\\n\\nfor i in range(n):\\n for j in range(m):\\n if f[i][j]:\\n cycle_found = dfs(f, i, j)\\n if cycle_found:\\n print(\"Yes\")\\n return\\n\\nprint(\"No\")\\n"}
{"id": "1699", "input": "\"\"\"\\nCodeforces Contest 270 Problem B\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef main():\\n n,k = read()\\n a = [i-1 for i in read()]\\n a.sort()\\n a.reverse()\\n print(sum(a[::k])*2)\\n\\n################################### NON-SOLUTION STUFF BELOW\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs", "gt": "= input().strip()\\n if mode == 0: return inputs\\n if mode == 1: return inputs.split()\\n if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\"\\n\"):\\n if s is None: s = \"\"\\n if isinstance(s, list): s = \" \".join(map(str, s))\\n s = str(s)\\n print(s, end=\"\")\\n\\nwrite(main())"}
{"id": "1700", "input": "\"\"\"\\nCodeforces Round 241 Div 1 Problem E\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\nclass InputHandlerObject(object):\\n inputs = []\\n\\n def getInput(self, n = 0):\\n res = \"\"\\n inputs = self.inputs\\n if not inputs: inputs.extend(input().split(\" \"))\\n if n == 0:\\n res = inputs[:]\\n inputs[:] = []\\n while n > len(inputs):\\n inputs.extend(input().split(\" \"))\\n if n > 0:\\n res = inputs[:n]\\n inputs[:n] = []\\n return", "gt": "res\\nInputHandler = InputHandlerObject()\\ng = InputHandler.getInput\\n\\n############################## SOLUTION ##############################\\nn,m = [int(x) for x in g()]\\n\\ndef sqr(n):\\n if n == 1:\\n return [1]\\n if n == 2:\\n return [4,3]\\n if n % 2:\\n return [(n+1)//2, 2] + [1] * (n-2)\\n return [(n-2)//2] + [1] * (n-1)\\n\\na = sqr(n)\\nb = sqr(m)\\nfor i in range(n):\\n res = [str(a[i]*x) for x in b]\\n print(\" \".join(res))"}
{"id": "1701", "input": "n = int( input() )\\ns = input()\\nd = 0\\nl = []\\nfor c in s:\\n if c == '(':\\n", "gt": "l.append(d)\\n d ^= 1\\n else:\\n d ^= 1\\n l.append( d )\\n\\nprint( \"\".join( [ str(i) for i in l ]))\\n"}
{"id": "1702", "input": "n, m = map(int, input().split())\\n\\na = {}\\nfor i in range(n):\\n x, y = input().split()\\n a[y] =", "gt": "x\\n \\nfor i in range(m):\\n x, y = input().split()\\n \\n print(x, y, \"#\" + a[y.replace(';', '')])"}
{"id": "1703", "input": "n=int(input())\\na=[list(map(int,input().split())) for i in range(n)]\\nsolved=[0 for i in range(5)]\\nscore=[0 for i in range(5)]\\nfor i in range(n):\\n for j in range(5):\\n solved[j]+=int(a[i][j]>-1)\\nfor k in range(31*n+1):\\n for i in range(5):\\n tot=n+k\\n cur=solved[i]\\n", "gt": "if a[0][i]>-1 and a[1][i]>-1 and a[0][i]>a[1][i]:\\n cur+=k\\n score[i]=500\\n while score[i]<3000 and 2*cur<=tot:\\n cur*=2;\\n score[i]+=500\\n res=[0,0]\\n for j in range(2):\\n for i in range(5):\\n if a[j][i]>-1:\\n res[j]+=score[i]/250*(250-a[j][i])\\n if res[0]>res[1]:\\n print(k)\\n return\\nprint(\"-1\")"}
{"id": "1704", "input": "n = int(input())\\n\\nfrom collections import defaultdict\\n\\nfirst = defaultdict(int)\\nsecond = defaultdict(int)\\nfor _ in range(n):\\n s = input().strip()\\n count = 0\\n min_count = 0\\n for c in s:\\n if c == '(': count += 1\\n", "gt": "else: count -= 1\\n min_count = min(count, min_count)\\n if min_count >= 0: first[count] += 1\\n if count == min_count: second[count] += 1\\n\\nres = 0\\nfor k, v in list(first.items()):\\n res += v * second[-k]\\n\\nprint(res)\\n"}
{"id": "1705", "input": "class Solution:\\n def __init__(self):\\n self.n, self.k = list(map(int, input().split()))\\n self.s = [input() for i in range(0, self.n)]\\n self.state = [\\n (119, 6),\\n (36, 2),\\n (93, 5),\\n (109, 5),\\n (46, 4),\\n (107, 5),\\n (123, 6),\\n (37, 3),\\n (127, 7),\\n (111, 6),\\n ]\\n self.p = []\\n self.dp = [[False for j in range(0, self.k + 1)] for i in range(0, self.n)]\\n\\n def solve(self):\\n for a in self.s:\\n state = int(a[::-1], 2)\\n stick = a.count(\"1\")\\n v = []\\n for i, (dState, dStick) in enumerate(self.state):\\n if dState & state == state:\\n v.append((i, dStick - stick))\\n self.p.append(v)\\n\\n", "gt": "for i in range(self.n - 1, -1, -1):\\n for j, stick in self.p[i]:\\n if i == self.n - 1:\\n if stick <= self.k:\\n self.dp[i][stick] = True\\n else:\\n for d in range(stick, self.k + 1):\\n self.dp[i][d] |= self.dp[i + 1][d - stick]\\n if not self.dp[0][self.k]:\\n return \"-1\"\\n\\n result = \"\"\\n\\n for i, v in enumerate(self.p):\\n for j, stick in v[::-1]:\\n ok = (self.k == stick) if i == self.n - 1 else (self.k >= stick and self.dp[i + 1][self.k - stick])\\n if ok:\\n self.k -= stick\\n result += str(j)\\n break\\n return result\\n \\n\\nprint(Solution().solve())\\n\\n"}
{"id": "1706", "input": "N = int(input())\\n\\nS = list(map(int,input().split()))[::-1]\\n\\nprint(min(N", "gt": "- S.index(0), N - S.index(1)))"}
{"id": "1707", "input": "n = len(input())\\nprint(3)\\nprint(\"R\",", "gt": "n-1)\\nprint(\"L\", n)\\nprint(\"L\", 2)\\n"}
{"id": "1708", "input": "n = int(input())\\nnums = (abs(int(x)) for x in input().split())\\nnums = list(sorted(nums))\\nleft = 0\\nright = 0\\nans = 0\\nwhile left < n:\\n while", "gt": "right < n and nums[right] <= 2 * nums[left]:\\n right += 1\\n ans += right - left - 1\\n left += 1\\nprint(ans)"}
{"id": "1709", "input": "n, m = map(int, input().split())\\na = list(map(int, input().split()))\\nc = list(map(int, input().split()))\\nmc = sorted(((y, x) for x, y in enumerate(c)), reverse=True)\\nfor _ in range(m):\\n t, d = map(int, input().split())\\n t -= 1\\n if a[t] >= d:\\n print(c[t] * d)\\n a[t] -= d\\n else:\\n x = a[t] * c[t]\\n d -=", "gt": "a[t]\\n a[t] = 0\\n while d:\\n if not mc:\\n print(0)\\n break\\n cost, index = mc[-1]\\n if a[index] >= d:\\n x += cost * d\\n a[index] -= d\\n d = 0\\n else:\\n x += cost * a[index]\\n d -= a[index]\\n a[index] = 0\\n if a[index] == 0:\\n mc.pop()\\n else:\\n print(x)"}
{"id": "1710", "input": "INF = 10 ** 18\\nMX_SZ = 112\\ndp = [[[INF for k in range (MX_SZ)] for j in range (MX_SZ)] for i in range (MX_SZ)]\\nbest = [[[(INF, INF) for k in range (MX_SZ)] for j in range (MX_SZ)] for i in range (MX_SZ)]\\n\\ndef read():\\n return [int(x) for x in input().split()]\\n\\nn, m, k_res = read()\\narr = read()\\ncost = []\\nfor i in range (n):\\n cost.append(read())\\ndp[0][0][MX_SZ - 1] = 0 #[trees painted][group amount][last color]\\nbest[0][0][0] = (0, MX_SZ - 1)\\n#print(best[0][0][0][1])\\n#return\\nfor i in range (1, n + 1):\\n clr = arr[i - 1]\\n if clr == 0:\\n for j in range (1, k_res + 1):\\n for k in range (1, m + 1):\\n dp[i][j][k] = dp[i - 1][j][k] + cost[i - 1][k - 1]\\n if", "gt": "k == best[i - 1][j - 1][0][1]:\\n dp[i][j][k] = min(dp[i][j][k], best[i - 1][j - 1][1][0] + cost[i - 1][k - 1])\\n else:\\n dp[i][j][k] = min(dp[i][j][k], best[i - 1][j - 1][0][0] + cost[i - 1][k - 1])\\n if dp[i][j][k] < best[i][j][0][0]:\\n best[i][j][1] = best[i][j][0]\\n best[i][j][0] = (dp[i][j][k], k)\\n elif dp[i][j][k] < best[i][j][1][0]:\\n best[i][j][1] = (dp[i][j][k], k)\\n else:\\n for j in range (1, n + 1):\\n dp[i][j][clr] = dp[i - 1][j][clr]\\n if clr == best[i - 1][j - 1][0][1]:\\n dp[i][j][clr] = min(dp[i][j][clr], best[i - 1][j - 1][1][0])\\n else:\\n dp[i][j][clr] = min(dp[i][j][clr], best[i - 1][j - 1][0][0])\\n best[i][j][0] = (dp[i][j][clr], clr)\\nans = INF\\nfor k in range (1, m + 1):\\n if dp[n][k_res][k] < ans:\\n ans = dp[n][k_res][k]\\nif ans == INF:\\n ans = -1\\nprint(ans)\\n\\n\\n\\n"}
{"id": "1711", "input": "#!/usr/bin/env python3\\n\\n[n, k] = list(map(int, input().strip().split()))\\nais = list(map(int, input().strip().split()))\\n\\nn1 = ais.count(1)\\n\\none_serie = [0 for _ in range(n)]\\nfor i in reversed(list(range(n))):\\n if ais[i] == 1:\\n one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\\n\\n\\nn1_head = 0\\ncount = 0\\n\\nfor i in range(n):\\n p = 1\\n s = 0\\n if i > 0 and ais[i - 1] == 1:\\n n1_head += 1\\n n1_tail = n1 -", "gt": "n1_head\\n j = i\\n while j < n:\\n if ais[j] == 1:\\n if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\\n count += 1\\n n1_tail -= one_serie[j]\\n s += one_serie[j]\\n j += one_serie[j]\\n else:\\n p *= ais[j]\\n s += ais[j]\\n if p == s * k:\\n count += 1\\n elif p > (s + n1_tail) * k:\\n break\\n j += 1\\n\\nprint (count)\\n"}
{"id": "1712", "input": "import sys\\ninput = sys.stdin.readline\\n\\nn,m=list(map(int,input().split()))\\nmod=998244353\\n\\nFACT=[1]\\nfor i in range(1,2*10**5+1):\\n FACT.append(FACT[-1]*i%mod)\\n\\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\\nfor i in range(2*10**5,0,-1):\\n", "gt": "FACT_INV.append(FACT_INV[-1]*i%mod)\\n\\nFACT_INV.reverse()\\n\\ndef Combi(a,b):\\n if 0<=b<=a:\\n return FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\\n else:\\n return 0\\n\\nif n==2:\\n print(0)\\nelse:\\n print(Combi(m,n-1)*(n-2)*pow(2,n-3,mod)%mod)\\n"}
{"id": "1713", "input": "from fractions import gcd\\n\\nn, x, y = map(int, input().split())\\ng = gcd(x, y)\\nx //= g\\ny //= g\\n\\na = sorted([y * i for i in range(1, x)] + [x * i for i in range(1, y)])\\n\\ndef f(n):\\n", "gt": "n %= x + y\\n if n == 0 or n == x + y - 1:\\n return \"Both\"\\n return \"Vova\" if a[n - 1] % x == 0 else \"Vanya\"\\n\\nfor _ in range(n):\\n print(f(int(input())))"}
{"id": "1714", "input": "rd = lambda: list(map(int, input().split()))\\n\\nn, s, t = rd()\\np = rd()\\nfor i", "gt": "in range(n):\\n if s == t : print(i); return\\n s = p[s-1]\\nprint(-1)"}
{"id": "1715", "input": "n, k = map(int, input().split())\\nA = [i for i in range(2*n, 0, -1)]\\nfor i in range(k):\\n if", "gt": "i > n:\\n i %= n\\n A[2*i], A[2*i + 1] = A[2*i + 1], A[2*i]\\nprint(' '.join(map(str, A)))"}
{"id": "1716", "input": "from bisect import bisect_left\\n\\nA, B, Q = map(int, input().split())\\nS = [int(input()) for _ in range(A)]\\nT = [int(input()) for _ in range(B)]\\n\\nx = []\\nfor s in S:\\n idx = bisect_left(T, s)\\n if idx == 0:\\n x.append(abs(s-T[0]))\\n elif idx == B:\\n x.append(abs(s-T[-1]))\\n else:\\n x.append(min(abs(s-T[idx]), abs(s-T[idx-1])))\\n\\ny = []\\nfor t in T:\\n idx = bisect_left(S, t)\\n if idx == 0:\\n y.append(abs(t-S[0]))\\n elif idx == A:\\n", "gt": "y.append(abs(t-S[-1]))\\n else:\\n y.append(min(abs(t-S[idx]), abs(t-S[idx-1])))\\n\\nfor _ in range(Q):\\n X = int(input())\\n\\n sa = 0\\n si = bisect_left(S, X)\\n\\n if si == 0:\\n sa = x[0]+abs(S[0]-X)\\n elif si == A:\\n sa = x[-1]+abs(S[-1]-X)\\n else:\\n sa = min(x[si]+abs(S[si]-X), x[si-1]+abs(S[si-1]-X))\\n\\n ti = bisect_left(T, X)\\n\\n if ti == 0:\\n ta = y[0]+abs(T[0]-X)\\n elif ti == B:\\n ta = y[-1]+abs(T[-1]-X)\\n else:\\n ta = min(y[ti]+abs(T[ti]-X), y[ti-1]+abs(T[ti-1]-X))\\n \\n print(min(sa, ta))"}
{"id": "1717", "input": "N, M, Q = list(map(int, input().split()))\\n\\ntable = [[0 for _ in range(N+1)] for _ in range(N+1)]\\nfor _ in range(M):\\n L, R = list(map(int, input().split()))\\n table[L][R] += 1\\n\\nfor i in range(N+1):\\n for", "gt": "j in range(N):\\n table[i][j+1] += table[i][j]\\nfor i in range(N):\\n for j in range(N+1):\\n table[i+1][j] += table[i][j]\\n\\nfor _ in range(Q):\\n p, q = list(map(int, input().split()))\\n print((table[q][q] - table[q][p-1] - table[p-1][q] + table[p-1][p-1]))\\n\\n"}
{"id": "1718", "input": "import math\\nfrom functools import reduce\\nN = int(input())\\n\\ndef lcm_base(x, y):\\n return (x * y) // math.gcd(x, y)\\n\\ndef", "gt": "lcm(*numbers):\\n return reduce(lcm_base, numbers, 1)\\n\\nA = []\\nfor i in range(2, N+1):\\n A.append(i)\\n\\nX = lcm(*A) + 1\\nprint(X)\\n"}
{"id": "1719", "input": "N, K = map(int,input().split())\\nA = list(map(int,input().split()))\\n\\nif N == K:\\n print(1)\\nelse:\\n ans = 1\\n", "gt": "N -= K\\n while N > 0:\\n ans += 1\\n N -= (K-1)\\n print(ans)"}
{"id": "1720", "input": "n = int(input())\\nmod = 10**9+7\\na = []\\nl = [\"A\",\"C\",\"G\",\"T\"]\\nban = [\"AAGC\",\"CAGC\",\"GAGC\",\"TAGC\",\"AGCA\",\"AGCC\",\"AGCG\",\"AGCT\",\"AGAC\",\"CGAC\",\"GGAC\",\"TGAC\",\"GACA\",\"GACC\",\"GACG\",\"GACT\",\"AACG\",\"CACG\",\"GACG\",\"TACG\",\"ACGA\",\"ACGC\",\"ACGG\",\"ACGT\",\"ATGC\",\"ACGC\",\"AGGC\",\"AGTC\",\"AGGC\",\"AGAC\"]\\nfor i in l:\\n for j in l:\\n for k in l:\\n a.append(i+j+k)\\ndp = [[0]*64 for _ in range(n+1)]\\nfor i in range(64):\\n if (a[i]==\"AGC\"", "gt": "or a[i]==\"ACG\" or a[i]==\"GAC\"):\\n continue\\n dp[3][i] = 1\\nfor i in range(4,n+1):\\n for j in range(64):\\n for k in l:\\n b = a[j]+k\\n if b in ban:\\n continue\\n else:\\n dp[i][a.index(b[1:])] += dp[i-1][j]\\n dp[i][a.index(b[1:])] %= mod\\nprint((sum(dp[-1])%mod))\\n \\n"}
{"id": "1721", "input": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\\n\\nsys.setrecursionlimit(10**7)\\ninf = 10**20\\neps = 1.0 / 10**15\\nmod = 10**9+7\\n\\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\\ndef LS(): return sys.stdin.readline().split()\\ndef I(): return int(sys.stdin.readline())\\ndef F(): return float(sys.stdin.readline())\\ndef S(): return input()\\ndef pf(s): return print(s, flush=True)\\n\\n\\ndef main():\\n n,m,k = LI()\\n a = [[-1] * (m+2)]\\n a += [[-1] + [inf if c=='.' else -1 for c in S()] + [-1] for _ in range(n)]\\n a += [[-1] * (m+2)]\\n x1,y1,x2,y2 = LI()\\n", "gt": "a[x1][y1] = 0\\n q = [(x1,y1)]\\n qi = 0\\n dy = [-1,1,0,0]\\n dx = [0,0,-1,1]\\n while qi < len(q):\\n x,y = q[qi]\\n qi += 1\\n nd = a[x][y] + 1\\n for di in range(4):\\n for j in range(1,k+1):\\n ny = y + dy[di] * j\\n nx = x + dx[di] * j\\n if a[nx][ny] > nd:\\n if ny == y2 and nx == x2:\\n return nd\\n a[nx][ny] = nd\\n q.append((nx,ny))\\n elif a[nx][ny] < nd:\\n break\\n\\n if a[x2][y2] < inf:\\n return a[x2][y2]\\n return -1\\n\\n\\nprint(main())\\n\\n\\n"}
{"id": "1722", "input": "class BIT():\\n def __init__(self,n):\\n self.BIT=[0]*(n+1)\\n self.num=n\\n\\n def query(self,idx):\\n res_sum = 0\\n while idx > 0:\\n res_sum += self.BIT[idx]\\n idx -= idx&(-idx)\\n return res_sum\\n\\n #Ai += x O(logN)\\n def update(self,idx,x):\\n while idx <= self.num:\\n self.BIT[idx] += x\\n idx += idx&(-idx)\\n return\\n\\nal = [chr(97+i) for i in range(26)]\\n\\nn = int(input())\\ns = input()\\ns= [s[i] for i in range(n)]\\ngoal = s[::-1]\\n\\ndic = {a:[] for a", "gt": "in al}"}
{"id": "1723", "input": "n = int(input())\\na = [0] * 27\\nfor i in range(n):\\n s = input()\\n a[ord(s[0]) - ord('a')] += 1\\nans = 0\\nfor i in range(26):\\n t =", "gt": "a[i] // 2\\n k = a[i] - t\\n ans += t * (t - 1) // 2\\n ans += k * (k - 1) // 2\\nprint(ans)\\n"}
{"id": "1724", "input": "def ii():\\n return int(input())\\ndef mi():\\n return map(int, input().split())\\ndef li():\\n return list(mi())\\n\\nn = ii()\\nif n < 6:\\n print(-1)\\nelse:\\n t = ['1 2', '1 3', '1 4', '2", "gt": "5', '2 6']\\n for i in range(7, n + 1):\\n t.append('1 ' + str(i))\\n print('\\n'.join(t))\\nt = []\\nfor i in range(2, n + 1):\\n t.append('1 ' + str(i))\\nprint('\\n'.join(t))"}
{"id": "1725", "input": "n = int(input())\\na = list(map(int, input().split()))\\nk = input()\\npref = [a[0]]\\nfor i in range(1, n):\\n pref.append(pref[-1] + a[i])\\ncur = 0\\nans = 0\\nfor i in range(n - 1, -1, -1):\\n if k[i] == '0':\\n continue\\n if cur + (pref[i - 1]", "gt": "if i > 0 else 0) > ans:\\n ans = cur + (pref[i - 1] if i > 0 else 0)\\n cur += a[i]\\ncur = 0\\nfor i in range(n):\\n if k[i] == '1':\\n cur += a[i]\\nans = max(ans, cur)\\nprint(ans)\\n"}
{"id": "1726", "input": "import re\\nimport itertools\\nfrom collections import Counter, deque\\n\\nclass Task:\\n a = []\\n d = 0\\n answer = 0\\n \\n def getData(self):\\n n, m, self.d = [int(x) for x in input().split(' ')]\\n for _ in range(n):\\n self.a += [int(x) for x in input().split(' ')]\\n #inFile = open('input.txt', 'r')\\n #inFile.readline().rstrip()\\n #self.childs = inFile.readline().rstrip()\\n\\n def solve(self):\\n a = self.a\\n\\n for x in a:\\n if x % self.d != a[0] % self.d:\\n self.answer = -1\\n return\\n \\n a = [x // self.d for x in a]\\n a.sort()\\n \\n d = [sum(a)] + [0 for _ in range(1, a[-1] + 1)]\\n \\n lessCurrentLevel = 0\\n counter = Counter(a)\\n", "gt": "\\n for level in range(1, a[-1] + 1):\\n lessCurrentLevel += counter[level - 1]\\n d[level] = d[level - 1] + lessCurrentLevel - \\\\n (len(a) - lessCurrentLevel)\\n self.answer = min(d)\\n\\n def solve2(self):\\n a, d = self.a, self.d\\n for i in range(1, len(a)):\\n if a[i] % d != a[0] % d:\\n self.answer = -1\\n return\\n a = [x // d for x in a]\\n d = [abs(a[0] - i) for i in range(10000 + 1)]\\n for i in range(1, len(a)):\\n for j in range(0, len(d)):\\n d[j] += abs(a[i] - j)\\n self.answer = min(d)\\n\\n def printAnswer(self):\\n print(self.answer)\\n #print(re.sub('[\\[\\],]', '', str(self.answer)))\\n #outFile = open('output.txt', 'w')\\n #outFile.write(self.answer)\\n\\ntask = Task()\\ntask.getData()\\ntask.solve()\\ntask.printAnswer()\\n"}
{"id": "1727", "input": "R=lambda:list(map(int,input().split()))\\nn,t=R()\\na=R()\\nfor i in range(n):\\n", "gt": "t-=86400-a[i]\\n if t<1:\\n print(i+1)\\n return\\n"}
{"id": "1728", "input": "n = int(input())\\np = -float(\"INF\")\\nans = 1\\nA = []\\nfor i in range(n) :\\n x, h = list(map(int, input().split()))\\n A.append([x,h])\\nfor i in range(n-1) :\\n x, h = A[i]\\n", "gt": "if x-h > p :\\n ans += 1\\n p = x\\n elif x+h < A[i+1][0] :\\n ans += 1\\n p = x+h\\n else :\\n p = x\\nprint(ans)\\n"}
{"id": "1729", "input": "\\n\\nn = int(input())\\n\\nT = [int(x) for x in input().split()]\\n\\nC = [int(x) for x in input().split()]\\n\\nT_inv = [[] for _ in range(n)]\\n\\nfor i in range(n - 1):\\n", "gt": "T_inv[T[i] - 1] += [i + 1]\\n\\nresult = 1\\n\\n#for i in range(n):\\n# print(T_inv[i])\\n\\nfor i in range(n):\\n for child in T_inv[i]:\\n if C[i] != C[child]:\\n result += 1\\n\\nprint(result)\\n"}
{"id": "1730", "input": "n, q = list(map(int, input().split()))\\ns = input()\\nfor _ in range(q):\\n l, r = list(map(int, input().split()))\\n t = list(s[l-1:r])\\n p, d = 0, 1\\n res = [0] * 10\\n while 0 <= p < len(t):\\n if '0' <= t[p] <= '9':\\n k = int(t[p])\\n res[k] += 1\\n if k > 0:\\n", "gt": "t[p] = str(k-1)\\n p += d\\n else:\\n t.pop(p)\\n if d == -1:\\n p += d\\n else:\\n d = -1 if t[p] == '<' else 1\\n if 0 <= p+d < len(t) and not ('0' <= t[p+d] <= '9'):\\n t.pop(p)\\n if d == -1:\\n p += d\\n else:\\n p += d\\n print(*res)\\n"}
{"id": "1731", "input": "def f():\\n n, m, k = map(int, input().split())\\n p = [[] for i in range(n + 1)]\\n for i in range(m):\\n a, b = map(int, input().split())\\n p[a].append(b)\\n p[b].append(a)\\n t, r = [0] * (n + 1), [1]\\n x = t[1] = 1\\n", "gt": "i = 0 - k\\n while True:\\n for y in p[x]:\\n if t[y] == 2: return r[r.index(y): ]\\n if t[y]: continue\\n t[y], x = 1, y\\n r.append(x)\\n i += 1\\n if i >= 0: t[r[i]] = 2\\n break\\nt = f()\\nprint(len(t))\\nprint(' '.join(map(str, t)))"}
{"id": "1732", "input": "n, m = list(map(int,input().split()))\\n\\nM = 10 ** 9 + 7\\n\\ndef inv(x):\\n return pow(x, M - 2, M)\\n\\ndef binomial(n, k):\\n if 0 <= k <= n:\\n ntok = 1\\n ktok = 1\\n for t", "gt": "in range(1, min(k, n - k) + 1):\\n ntok *= n\\n ktok *= t\\n n -= 1\\n ntok %= M\\n ktok %= M\\n return (ntok * inv(ktok))%M\\n else:\\n return 0\\n\\nprint(binomial(n+2*m-1, 2 * m))\\n"}
{"id": "1733", "input": "n = int(input())\\nl = [int(x) for x in input().split()]\\nc = [int(x) for x in input().split()]\\n\\n\\ndef gcd(a, b):\\n if b == 0:\\n return a\\n else:\\n return gcd(b, a % b)\\n\\ngcds = {0: 0}\\n\\nfor i in range(n):\\n adds = {}\\n for g in list(gcds.keys()):\\n x = gcd(g, l[i])\\n y = gcds.get(x)\\n u = gcds[g]\\n if", "gt": "y is not None:\\n if u + c[i] < y:\\n t = adds.get(x)\\n if t and t > u + c[i] or t is None:\\n adds[x] = u + c[i]\\n else:\\n t = adds.get(x)\\n if t and t > u + c[i]or t is None:\\n adds[x] = u + c[i]\\n gcds.update(adds)\\n\\nif gcds.get(1):\\n print(gcds[1])\\nelse:\\n print(-1)\\n\\n"}
{"id": "1734", "input": "from collections import defaultdict\\nn, flower, bee = list(map(int, input().split()))\\nroads = {}\\nfor _ in range(n-1):\\n x, y = list(map(int, input().split()))\\n if x not in roads:\\n roads[x] = [y]\\n else:\\n roads[x].append(y)\\n if y not in roads:\\n roads[y] = [x]\\n else:\\n roads[y].append(x)\\nflowers = defaultdict(int)\\n\\ndef dfs(bee, flower):\\n q = []\\n visited = set()\\n visited.add(flower)\\n last =", "gt": "-1\\n for y in roads[flower]:\\n if y == bee:\\n last = y\\n continue\\n q.append([y, y])\\n while q:\\n now = q.pop()\\n visited.add(now[0])\\n flowers[now[1]] += 1\\n for y in roads[now[0]]:\\n if y not in visited:\\n if y == bee:\\n last = now[1]\\n continue\\n q.append([y, now[1]])\\n return last\\nrem = dfs(bee, flower)\\nflower_total = sum(flowers.values())+1\\nprint(n*(n-1)-(flower_total - flowers[rem])*(n-(flower_total)))"}
{"id": "1735", "input": "def rec(i):\\n nonlocal a\\n return i\\nimport sys\\nfrom collections import Counter\\nsys.setrecursionlimit(10**6)\\nn=int(input())\\n#n,m=list(map(int,input().split()))\\na=[input() for i in range(n)]\\nb=[]\\na0=set()\\nc0=set()\\nfor i in a:\\n c=set()\\n for i0 in", "gt": "range(1,10):\\n for i1 in range(0,10-i0):\\n c.add(i[i1:i1+i0])\\n b.append(c)\\n c0.update(a0&c)\\n a0.update(c)\\n\\nfor i in b:\\n c=i-c0\\n z='0'*10\\n for i0 in c:\\n if len(i0)<len(z):\\n z=i0\\n print(z)\\n"}
{"id": "1736", "input": "s = input()\\n\\nl = []\\nt = 0\\n\\nfor i in range(len(s)):\\n if len(l) > 0:\\n if s[i]", "gt": "== l[-1]:\\n l.pop()\\n t += 1\\n else:\\n l.append(s[i])\\n else:\\n l.append(s[i])\\n\\nif t % 2 == 0:\\n print(\"No\")\\nelse:\\n print(\"Yes\")\\n"}
{"id": "1737", "input": "\\nl = 0\\nr = -1\\nsegL, time = [int(x) for x in input().split()]\\na = [int(x) for x in input().split()]\\nsegSum = 0\\nsegments = []\\n\\n##while r < segL-1: \\n## r += 1\\n## segSum += a[r]\\n## if segSum == time:\\n## segments.append(r+1-l)\\n## elif segSum > time:\\n## segments.append(r-l)\\n## while segSum > time or l < r:\\n## # Shifting l", "gt": "to the right\\n## # until reaching next suitable segment sum\\n## segSum -= a[l]\\n## l += 1\\n## #segments.append(r+1-l)\\n##\\n##[1,2,5,3,7,4,5]\\n\\nwhile r < segL-1:\\n r += 1\\n segSum += a[r]\\n if segSum == time:\\n segments.append(r+1-l)\\n segSum -= a[l]\\n l += 1\\n elif segSum > time:\\n segments.append(r-l)\\n while segSum >= time:\\n segSum -= a[l]\\n l += 1\\nelse:\\n segments.append(r+1-l)\\n\\nprint(max(segments))\\n"}
{"id": "1738", "input": "from collections import defaultdict\\n\\nn=int(input())\\nd=defaultdict(dict)\\nfor i in range(n):\\n x=input()\\n x=x.split()\\n if i==0:\\n P = x\\n q=int(input())\\n Con=[]\\n for j in range(q):\\n Con.append(input().split())\\n if i!=n-1:\\n input()\\n d[x[0]][x[1]]=Con\\nver=[P]\\nans={}\\nwhile ver:\\n next_ans = {}\\n for", "gt": "v in ver:\\n C=d[v[0]][v[1]]\\n for n_v in C:\\n if n_v[0] not in ans and n_v[0]!=P[0]:\\n if n_v[0] in next_ans:\\n if int(n_v[1])>int(next_ans[n_v[0]]):\\n next_ans[n_v[0]]=n_v[1]\\n else:\\n next_ans[n_v[0]]=n_v[1]\\n ans.update(next_ans)\\n ver=list(next_ans.items())\\nl=list(ans.items())\\nprint(len(l))\\nl.sort()\\nfor k,v in l:\\n print(k,v)\\n"}
{"id": "1739", "input": "def prefix(s):\\n p = [0]\\n for i in range(1, len(s)):\\n j = p[-1]\\n while j > 0 and s[j] != s[i]:\\n j = p[j - 1]\\n if s[i] == s[j]:\\n j += 1\\n p.append(j)\\n return p\\n\\n\\ns = input()\\nn = len(s)\\nans = [0] * (n + 1)\\ni = n - 1\\n\\nwhile i >= 0:\\n p = prefix(s[i:])\\n ans[i]", "gt": "= 2 + ans[i + 1]\\n for j in range(len(p)):\\n z = 1\\n if (j + 1) % (j + 1 - p[j]) == 0:\\n z = (j + 1) // (j + 1 - p[j])\\n res = len(str(z)) + (j + 1) // z + ans[i + j + 1]\\n ans[i] = min(ans[i], res)\\n i -= 1\\n\\nprint(ans[0])\\n"}
{"id": "1740", "input": "n, x = map(int, input().split())\\na = [int(x) for x in input().split()]\\ndef solve(a, s):\\n #print (a)\\n a.append((-1, 0))\\n a.sort()\\n b = []\\n for i in range(1, len(a)):\\n if a[i][0] != a[i-1][0]:\\n b.append(a[i])\\n else:\\n b[-1] = (a[i][0], b[-1][1] + a[i][1])\\n for i in range(len(b)):\\n t = b[i][1]\\n cnt = 0\\n", "gt": "while t%x == 0:\\n t //= x\\n cnt += 1\\n b[i] = (b[i][0] + cnt, t)\\n #print (b)\\n z = min(min(b)[0], s)\\n if z == 0:\\n return 0\\n return z + solve([(x[0]-z, x[1]) for x in b], s-z)\\ns = sum(a)\\nprint(pow(x, solve([(s-x, 1) for x in a], s), 10**9+7))"}
{"id": "1741", "input": "import sys\\ninput = sys.stdin.readline\\n\\nn=int(input())\\nP=[list(map(int,input().split())) for i in range(n-1)]\\n\\n\\nGroup=[i for i in range(n+1)]\\ndef find(x):\\n while Group[x] != x:\\n x=Group[x]\\n return x\\ndef Union(x,y):\\n if find(x)", "gt": "!= find(y):\\n Group[find(y)]=Group[find(x)]=min(find(y),find(x))\\n\\nANS=[[i] for i in range(n+1)]\\n\\nfor i,j in P:\\n if find(j)<find(i):\\n ANS[find(j)]+=ANS[find(i)]\\n \\n else:\\n ANS[find(i)]+=ANS[find(j)]\\n\\n Union(i,j)\\n\\nfor a in ANS[1]:\\n print(a,end=\" \")\\n \\n\\n"}
{"id": "1742", "input": "import sys\\ninput = sys.stdin.readline\\n\\nclass Point:\\n def __init__(self, x, y):\\n self.x = x\\n self.y = y\\n\\ndef get(x0, a, n):\\n r = 0\\n for i in range(n):\\n p = (x0 - a[i].x)*(x0 - a[i].x) + 1.0*a[i].y*a[i].y\\n p = p/2.0/a[i].y\\n if p < 0:\\n p = -p\\n r = max(r, p)\\n return r\\n\\ndef main():\\n n = int(input())\\n pos, neg = False, False\\n a = []\\n for i in range(n):\\n x, y = map(int, input().split())\\n", "gt": "t = Point(x, y)\\n if t.y > 0:\\n pos = True\\n else:\\n neg = True\\n a.append(t)\\n if pos and neg:\\n return -1\\n if neg:\\n for i in range(n):\\n a[i].y = -a[i].y\\n L, R = -1e8, 1e8\\n for i in range(120):\\n x1 = L + (R-L)/3\\n x2 = R - (R-L)/3\\n if get(x1, a, n) < get(x2, a, n):\\n R = x2\\n else:\\n L = x1\\n return get(L, a, n)\\n\\ndef __starting_point():\\n print(main())\\n__starting_point()"}
{"id": "1743", "input": "n, m = list(map(int, input().split()))\\nline = list(map(int, input().split()))\\n\\npairs = set()\\nfor i in range(m):\\n a, b = list(map(int, input().split()))\\n pairs.add((a,b))\\n\\nreq = [line.pop()]\\n\\nout = 0\\nwhile line != []:\\n nex", "gt": "= line.pop()\\n works = True\\n for pers in req:\\n if not (nex, pers) in pairs:\\n works = False\\n break\\n if works:\\n out += 1\\n else:\\n req.append(nex)\\n\\nprint(out)\\n \\n"}
{"id": "1744", "input": "n = int(input())\\na = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\nc = list(map(int, input().split()))\\n\\nfed_left = {0 : a[0]}\\nnot_fed_left = {0 : b[0]}\\n\\nfor i in range(1, n):\\n fed_left[i] =", "gt": "max(fed_left[i-1] + b[i], not_fed_left[i-1] + a[i]) # max(fed left, fed right)\\n not_fed_left[i] = max(fed_left[i-1] + c[i], not_fed_left[i-1] + b[i]) # max(fed left and right, fed right)\\n\\nprint(fed_left[n-1])\\n"}
{"id": "1745", "input": "import sys\\ninput = sys.stdin.readline\\nn, M = list(map(int, input().split()))\\nt = list(map(int, input().split()))\\nans = []\\ntmp = [0] * 101\\nfor i in range(n):\\n num = 0\\n T = t[i]\\n for j in range(1, 101):\\n if", "gt": "T + j * tmp[j] <= M:\\n num += tmp[j]\\n T += j * tmp[j]\\n else:\\n m = M - T\\n num += m // j\\n break\\n\\n ans.append(i - num)\\n tmp[t[i]] += 1\\n\\nprint(*ans)\\n"}
{"id": "1746", "input": "n, m = [int(x) for x in input().split()]\\na = [[int(c == '.') for c in input()] for i in range(n)]\\n\\ndef rotate(a):\\n n = len(a)\\n m = len(a[0])\\n b = [[0] * n for i in range(m)]\\n for i in range(n):\\n for j in range(m):\\n b[j][n - 1 - i] = a[i][j]\\n return b\\n\\ndef calc(a):\\n n = len(a)\\n m = len(a[0])\\n alive = a[0][:]\\n alive[0], alive[m - 1] = 0, 0\\n ans_l, ans_r, ans_u = 0, 0, 0\\n ans_bs = [0] * m\\n for i in range(1, n - 1):\\n s = 0\\n for j in range(1, m - 1):\\n if a[i][j]:\\n if alive[j]:\\n ans_u += s - alive[j - 1]\\n ans_bs[j] += s\\n s += alive[j]\\n else:\\n s = 0\\n ans_bs[j] = 0\\n", "gt": "alive[j] = 0\\n if a[i][m - 1]:\\n ans_r += s\\n s = 0\\n for j in range(m - 2, 0, -1):\\n if a[i][j]:\\n if alive[j]:\\n ans_u += s - alive[j + 1]\\n ans_bs[j] += s\\n s += alive[j]\\n else:\\n s = 0\\n ans_bs[j] = 0\\n alive[j] = 0\\n if a[i][0]:\\n ans_l += s\\n ans_u //= 2\\n ans_b = sum(a[n - 1][i] * (ans_bs[i] + alive[i]) for i in range(1, m - 1))\\n return ans_l, ans_r, ans_u, ans_b\\nans = 0\\nans_l, ans_r, ans_u, ans_b = calc(a)\\nans += ans_l + ans_r + ans_u + ans_b\\na = rotate(a)\\nans_l, _, ans_u, ans_b = calc(a)\\nans += ans_l + ans_u + ans_b\\na = rotate(a)\\nans_l, _, ans_u, _= calc(a)\\nans += ans_l + ans_u\\na = rotate(a)\\n_, _, ans_u, _= calc(a)\\nans += ans_u\\nprint(ans)\\n"}
{"id": "1747", "input": "#!/usr/bin/env python3\\n\\ndef main():\\n class Node:\\n def __init__(self):\\n self.children = [ ]\\n\\n n = int(input())\\n nodes = [Node() for i in range(n)]\\n for i in range(1, n):\\n p = int(input())\\n nodes[p -", "gt": "1].children.append(nodes[i])\\n ok = all(\\n len([child for child in node.children if not child.children]) >= 3\\n for node in nodes\\n if node.children\\n )\\n print(\"Yes\" if ok else \"No\")\\n\\ntry:\\n while True:\\n main()\\nexcept EOFError:\\n pass\\n"}
{"id": "1748", "input": "import sys\\nn, m = list(map(int, sys.stdin.readline().split()))\\nvis = [0] * 1000005\\nnum = list(map(int, sys.stdin.readline().split()))\\nflag = 0\\ntemp = num[0]\\nfor i in range(n):\\n if num[i] != temp:\\n flag = 1\\n break\\nif flag == 0:\\n print(\"{0} {1}\".format(1, n))\\nelse:\\n l = 0\\n r = 0\\n al = 0\\n ar = 0\\n ans = 0\\n now = 0\\n", "gt": "for i in range(n):\\n vis[num[i]] += 1\\n if vis[num[i]] == 1:\\n now += 1\\n while now > m:\\n vis[num[l]] -= 1\\n if vis[num[l]] == 0:\\n now -= 1\\n l += 1\\n if i - l + 1 > ar - al + 1:\\n ar = i\\n al = l\\n print('"}
{"id": "1749", "input": "n = int(input())\\nvs = [int(x) for x in input().split()]\\nts = [int(x) for x in input().split()]\\n\\nsumt = 0\\nfor i, t in enumerate(ts):\\n vs[i]+=sumt\\n sumt+=t\\n\\nvs.sort()\\n\\ntl, tr = 0, 0\\nil, ir = 0, 0\\nfor ind, t in enumerate(ts): #check\\n tl = tr\\n", "gt": "tr += t\\n while ir < n and vs[ir] <= tr: ir += 1\\n cur_sum = 0\\n while il < ir:\\n cur_sum += vs[il]-tl\\n il+=1\\n## print(ir, tl, tr, cur_sum)\\n cur_sum += t * ((n-ir) - (n-ind-1))\\n print(cur_sum, end=\" \")\\n \\n"}
{"id": "1750", "input": "n, l, r = map(int, input().split())\\na = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\nc = []\\nd = []\\n\\nisOk = 0\\n\\nfor i in range(0, l - 1):\\n if a[i] != b[i]:\\n isOk =", "gt": "1\\n\\nfor i in range(r, n):\\n if a[i] != b[i]:\\n isOk = 1\\n\\nfor i in range(l - 1, r):\\n c.append(a[i])\\n d.append(b[i])\\n\\nc.sort()\\nd.sort()\\n\\nif c != d:\\n isOk = 1\\n\\nif isOk == 1:\\n print(\"LIE\")\\nelse:\\n print(\"TRUTH\")"}
{"id": "1751", "input": "import sys\\nsys.setrecursionlimit(200000)\\n\\nn = int(input())\\narr = [[] for i in range(n)]\\nfor i in range(n - 1):\\n a, b = map(int, input().split())\\n arr[a - 1].append(b - 1)\\n arr[b - 1].append(a - 1)\\ns = max([len(p) for p in arr]) + 1\\nprint(s)\\n\\ncolored = [0] * n\\ndef dfs(v, c, d):\\n colored[v] = p = c\\n for u in arr[v]:\\n if not colored[u]:\\n c = c + 1 if c < s else 1\\n if", "gt": "c == d:\\n c = c + 1 if c < s else 1\\n dfs(u, c, p)\\nif s > 3:\\n dfs(0, 1, 0)\\nelse:\\n i = 0\\n c = 1\\n while len(arr[i]) != 1:\\n i += 1\\n for j in range(n):\\n colored[i] = c\\n c = c + 1 if c < s else 1\\n if j < n - 1:\\n i = arr[i][0] if not colored[arr[i][0]] else arr[i][1]\\nprint(\" \".join(map(str, colored)))"}
{"id": "1752", "input": "MOD = 10 ** 9 + 7\\n\\nout = 1\\n\\nn = int(input())\\n\\nfor i in range(n):\\n out", "gt": "*= (i + 1)\\n out %= MOD\\nout -= pow(2, n - 1, MOD)\\nprint(out % MOD)\\n"}
{"id": "1753", "input": "n = int(input())\\na = list(map(int,input().split()))\\na = sorted(a)\\n\\nout = [0 for x in range(n)]\\nif n%2:\\n out[n//2] =", "gt": "a[-1]\\nfor x in range(n//2):\\n out[x] = a[x*2]\\n out[-(1+x)] = a[(x*2)+1]\\nprint (\" \".join(str(c) for c in out))"}
{"id": "1754", "input": "n, m = list(map(int, input().split()))\\ncolor_pairs = [list(map(int, input().split())) for i in range(m)]\\ntowers = [[(i, i)] for i in range(1, n + 1)]\\nlast_coord = n + 1\\nfor", "gt": "c1, c2 in color_pairs:\\n towers[c1 - 1].append((last_coord, c1))\\n towers[c2 - 1].append((last_coord, c2))\\n last_coord += 1\\nfor i in range(len(towers)):\\n print(len(towers[i]))\\n for x, y in towers[i]:\\n print(x, y)\\n\\n\\n"}
{"id": "1755", "input": "n, m, k = map(int, input().split())\\nsch = [0 for i in range(m)]\\np = list(map(int, input().split()))\\ns = list(map(int, input().split()))\\nc = list(map(int, input().split()))\\nfor i in", "gt": "range(n):\\n sch[s[i] - 1] = max(sch[s[i] - 1], p[i])\\nres = 0\\nfor i in c:\\n i -= 1\\n res += p[i] != sch[s[i] - 1]\\nprint(res)"}
{"id": "1756", "input": "import sys\\nfrom sys import stdin\\n\\nimport bisect\\n\\ndef LIS(lis , end):\\n\\n seq = []\\n\\n for c in lis:\\n ind = bisect.bisect_right(seq,c)\\n\\n if ind == len(seq):\\n seq.append(c)\\n else:\\n if ind != 0:\\n seq[ind] = c\\n\\n return bisect.bisect_right(seq,end)\\n\\ntt = 1\\n\\nfor loop in range(tt):\\n\\n n,k = list(map(int,stdin.readline().split()))\\n a = list(map(int,stdin.readline().split()))\\n b = list(map(int,stdin.readline().split()))\\n\\n a", "gt": "= [float(\"-inf\")] + a + [float(\"inf\")]\\n b = [0] + b + [n+1]\\n for i in range(n+2):\\n a[i] -= i\\n\\n for i in range(len(b)-1):\\n if a[b[i]] > a[b[i+1]]:\\n print(-1)\\n return\\n\\n ans = n+1\\n for i in range(len(b)-1):\\n now = LIS(a[ b[i]:b[i+1] ] , a[b[i+1]])\\n ans -= now\\n\\n print (ans)\\n"}
{"id": "1757", "input": "def sum_first(di):\\n return di * (di + 1) // 2\\n\\n\\nn, x = list(map(int, input().split()))\\nn *= 2\\nd = tuple(map(int, input().split())) * 2\\nans = 0\\ni = 0\\nj = 0\\ncur_ans = 0\\ntotal_days = 0\\nwhile j <= n:\\n if", "gt": "total_days < x:\\n if j == n:\\n break\\n cur_ans += sum_first(d[j])\\n total_days += d[j]\\n j += 1\\n else:\\n ans = max(ans, cur_ans - sum_first(total_days - x))\\n cur_ans -= sum_first(d[i])\\n total_days -= d[i]\\n i += 1\\nprint(ans)\\n"}
{"id": "1758", "input": "d = [1, 1]\\nn = int(input())\\nwhile d[-1] < n:\\n d.append(d[-1] + d[-2])\\ns = set(d)\\nres = ''\\nfor", "gt": "i in range(1, n + 1):\\n if i in s:\\n res += 'O'\\n else:\\n res += 'o'\\nprint(res)"}
{"id": "1759", "input": "n = int(input())\\ns = input()\\nt = input()\\n\\ncurr = 0\\ncurrs = []\\nfor i in range(n):\\n if s[i] ==", "gt": "'1':\\n curr += 1\\n if t[i] == '1':\\n curr -= 1\\n currs.append(curr)\\n\\nif curr != 0:\\n print(-1)\\nelse:\\n print(max(currs)-min(currs))\\n"}
{"id": "1760", "input": "\"\"\"\\nCodeforces Round 241 Div 1 Problem B\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\nclass InputHandlerObject(object):\\n inputs = []\\n\\n def getInput(self, n = 0):\\n res = \"\"\\n inputs = self.inputs\\n if not inputs: inputs.extend(input().split(\" \"))\\n if n == 0:\\n res = inputs[:]\\n inputs[:] = []\\n while n > len(inputs):\\n inputs.extend(input().split(\" \"))\\n if n > 0:\\n res = inputs[:n]\\n inputs[:n] = []\\n return res\\nInputHandler = InputHandlerObject()\\ng = InputHandler.getInput\\n\\n############################## SOLUTION ##############################\\nm,n", "gt": "= [int(x) for x in g()]\\nq = []\\nfor i in range(m):\\n q.append([int(x) for x in g()])\\np = q[:]\\nfor j in range(n):\\n for i in range(m):\\n if i == 0 and j == 0:\\n continue\\n if i == 0:\\n p[i][j] = p[i][j-1] + q[i][j]\\n continue\\n if j == 0:\\n p[i][j] = p[i-1][j] + q[i][j]\\n continue\\n p[i][j] = max(p[i-1][j], p[i][j-1]) + q[i][j]\\nfor i in range(m):\\n print(p[i][n-1], end=\" \")\\n"}
{"id": "1761", "input": "n=int(input())\\nstring = input()\\nq1,q2,B,C=[],[],[],[]\\nA=0\\nfor i in range(n):\\n if string[i] == \"D\":\\n q1.append(i)\\n else:\\n q2.append(n-1-i)\\n\\nfor", "gt": "i in range(len(q1)):\\n A+=(q1[i]-i)*2+1\\n B.append(A)\\n\\nA=0\\ntemp = []\\nfor i in range(len(q2)):\\n A+=(q2[len(q2)-1-i]-i)*2+1\\n C.append(A)\\nC.reverse()\\n\\nB=list(map(str,B+C))\\nprint(\" \".join(B))\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"}
{"id": "1762", "input": "n = int(input())\\narr = []\\nfor i in range(n):\\n s = input()\\n arr.append('<')\\n arr.append('3')\\n for j in range(len(s)):\\n arr.append(s[j])\\narr.append('<')\\narr.append('3')\\ns = input()\\ncur =", "gt": "0\\ni = 0\\nwhile cur < len(s) and i < len(arr):\\n if s[cur] == arr[i]:\\n i+=1\\n cur+=1\\nif i == len(arr):\\n print('yes')\\nelse:\\n print('no')"}
{"id": "1763", "input": "# tested by Hightail - https://github.com/dj3500/hightail\\n\\n\\nfrom heapq import heappop, heappush\\nfrom sys import stdin, stdout\\n\\n\\nread, read_array = stdin.readline, lambda: stdin.readline().split()\\nwrite = lambda *args, **kw: stdout.write(kw.get('sep', ' ').join(str(a) for a in args) + kw.get('end', '\\n'))\\nwrite_array = lambda arr, **kw: stdout.write(kw.get('sep', ' ').join(str(a) for a in arr) + kw.get('end', '\\n'))\\nread_int, read_int_array = lambda: int(read()), lambda: [int(p) for p in read_array()]\\nread_float, read_float_array = lambda:", "gt": "float(read()), lambda: [float(p) for p in read_array()]\\n\\n\\nn, k = read_int_array()\\nheap = []\\nbusy = 0\\ntime = 0\\nfinish = [0] * n\\nfor i in range(n):\\n if busy == k:\\n time = heappop(heap)\\n busy -= 1\\n else:\\n time = 0\\n start, minutes = read_int_array()\\n if start > time:\\n time = start\\n heappush(heap, time + minutes)\\n finish[i] = time + minutes\\n busy += 1\\n\\nwrite_array(finish, sep='\\n')"}
{"id": "1764", "input": "n, a, r, m = map(int, input().split())\\nh = list(map(int, input().split()))\\nm = min(m, a+r)\\n\\ndef get(M):\\n up = 0\\n dw = 0\\n for e in h:\\n if e > M:\\n up += e - M\\n else:\\n dw += M - e\\n ans = m * min(dw, up)\\n if dw > up:\\n ans += (dw - up) * a\\n else:\\n ans += (up - dw) * r\\n return ans\\n\\n\\nL = 0\\nR =", "gt": "int(1e9)\\nmn = int(1e18)\\n\\nwhile R - L > 10:\\n M1 = L + (R - L) // 3\\n M2 = R - (R - L) // 3\\n V1 = get(M1)\\n V2 = get(M2)\\n mn = min(mn, V1)\\n mn = min(mn, V2)\\n if V1 < V2:\\n R = M2\\n elif V2 < V1:\\n L = M1\\n else:\\n L = M1\\n R = M2\\n\\nfor it in range(L, R+1):\\n mn = min(mn, get(it))\\n\\nprint(mn)"}
{"id": "1765", "input": "n = int(input())\\n\\nline = input().split()\\nlst = []\\nfor num in line:\\n lst.append(int(num))\\n\\ncnt1 = [0]\\ncnt2 = [0]\\nc1 = 0\\nc2 = 0\\n\\nfor num in lst:\\n if num == 1:\\n c1 += 1\\n cnt1.append(c2)\\n else:\\n c2 += 1\\n cnt2.append(c1)\\n\\nw = lst[n - 1]\\nans = []\\nc1 = len(cnt1)\\nc2 = len(cnt2)\\nfor t in range(n, 0, -1):\\n s1 = 0\\n s2 = 0\\n i1 = 0\\n i2 = 0\\n l = 1\\n while i1 < c1 and i2 < c2:\\n if i1 + t >= c1 and i2 + t >= c2:\\n if l == 1 and l == w and i1 + 1 == c1 and s1 >", "gt": "s2:\\n ans.append((s1, t))\\n elif l == 2 and l == w and i2 + 1 == c2 and s2 > s1:\\n ans.append((s2, t))\\n break\\n elif i2 + t >= c2:\\n s1 += 1\\n l = 1\\n i1 += t\\n i2 = cnt1[i1]\\n elif i1 + t >= c1:\\n s2 += 1\\n l = 2\\n i2 += t\\n i1 = cnt2[i2]\\n else:\\n if cnt1[i1 + t] < i2 + t:\\n s1 += 1\\n l = 1\\n i1 += t\\n i2 = cnt1[i1]\\n else:\\n s2 += 1\\n l = 2\\n i2 += t\\n i1 = cnt2[i2]\\n\\nans.sort()\\n\\nprint(int(len(ans)))\\nfor line in ans:\\n print(str(line[0]) + ' ' + str(line[1]))\\n"}
{"id": "1766", "input": "n = int(input())\\na = list(map(int, input().split()))\\n\\nmxa = max(a)\\nv = 1 << 30\\nwhile v > mxa:\\n v >>= 1\\n\\nwhile True:\\n d = -1\\n for i in range(n):\\n if", "gt": "a[i] & v:\\n d &= a[i]\\n if d % v == 0:\\n break\\n v >>= 1\\n\\nb = [i for i in a if i & v]\\nprint(len(b))\\nprint(' '.join(map(str,b)))\\n"}
{"id": "1767", "input": "n=int(input())\\na=list(map(int,input().split()))\\nb=True\\nl=0\\nr=n-1\\nans1=0\\nans2=0\\nwhile l<=r:\\n if a[l]>a[r]:\\n if b:\\n ans1+=a[l]\\n b=False\\n else:\\n ans2+=a[l]\\n b=True\\n", "gt": "l+=1\\n else:\\n if b:\\n ans1+=a[r]\\n b=False\\n else:\\n ans2+=a[r]\\n b=True \\n r-=1\\nprint(ans1,ans2)"}
{"id": "1768", "input": "def f(m):\\n v = 0\\n for x in m:\\n", "gt": "v |= x\\n return v\\ninput()\\nprint(f(map(int, input().split())) + f(map(int, input().split())))"}
{"id": "1769", "input": "import sys\\n\\n\\n\\nn = int(sys.stdin.readline().strip())\\ns = sys.stdin.readline().strip()\\n\\ndp = [[-1] * (n + 1) for i in range(26)]\\n\\n\\nfor c in range(26):\\n for j in range(n):\\n tst = 1 if s[j] == chr(c + 97) else 0\\n dp[c][1 - tst] = max(dp[c][1 - tst], 1)\\n for k in range(j + 1, n):\\n if s[k] == chr(c + 97):tst += 1\\n dp[c][k - j + 1 - tst]", "gt": "= max(dp[c][k - j + 1 - tst], k - j + 1)\\n\\n#for c in range(26):\\n# for j in range(n):\\n# dp[c][j + 1] = max(dp[c][j], dp[c][j + 1])\\n\\nq = int(sys.stdin.readline().strip())\\n\\nfor i in range(q):\\n m, c = [item for item in sys.stdin.readline().strip().split()]\\n m = int(m)\\n #print(max([dp[ord(c) - 97][u] for u in range(m + 1)]))\\n print(dp[ord(c) - 97][m]) if dp[ord(c) - 97][m] != -1 else print(n)"}
{"id": "1770", "input": "a=int(input())\\nb=int(input())\\nn=a+b+1\\nL=list(range(n-a,n+1))\\nfor item in L:\\n", "gt": "print(item,end=\" \")\\nx=n-a-1\\nwhile(x>0):\\n print(x,end=\" \")\\n x-=1\\n"}
{"id": "1771", "input": "for _ in range(int(input())):\\n n, x, y, d = map(int, input().split())\\n tt = abs(x - y)\\n if tt % d != 0:\\n ans = -1\\n if (y - 1) % d == 0:\\n ans = (x - 1 + d - 1) // d +", "gt": "(y - 1) // d\\n if (n - y) % d == 0:\\n cc = (n - x + d - 1) // d + (n - y) // d\\n if ans == -1 or cc < ans:\\n ans = cc\\n print(ans)\\n else:\\n print(tt // d)"}
{"id": "1772", "input": "# Codeforces Round #487 (Div. 2)import collections\\nfrom functools import cmp_to_key\\n#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )\\n\\nimport sys\\ndef getIntList():\\n return list(map(int, input().split())) \\nimport bisect\\n \\n \\n \\nN,L,WM = getIntList()\\n\\nz = {}\\nz[-1] = {1:[], -1:[]}\\nz[0] = {1:[], -1:[]}\\nz[1] = {1:[], -1:[]}\\nfor i in range(N):\\n x0,v = getIntList()\\n t = (x0,v)\\n if x0+L <=0:\\n z[-1][v].append(t)\\n elif x0>=0:\\n z[1][v].append(t)\\n else:\\n z[0][v].append(t)\\nres = 0\\n\\nres += len(z[-1][1] ) * len(z[ 1][-1] )\\nres += len(z[0][1]", "gt": ") * len(z[ 1][-1] )\\nres += len(z[-1][1] ) * len(z[ 0][-1] )\\n\\nif WM==1:\\n print(res)\\n return\\n\\nz[1][-1].sort()\\nz[-1][1].sort()\\n#print(z[-1][1])\\ntn = len(z[1][-1])\\nfor t in z[1][1]:\\n g = (-WM-1) * t[0] / (-WM+1) - L\\n g = max(g, t[0]+ 0.5)\\n p = bisect.bisect_right(z[1][-1], (g,2) )\\n res += tn-p \\n \\ntn = len(z[-1][1])\\nfor t in z[-1][-1]:\\n g = (WM+1) * (t[0] + L)/ (WM-1)\\n g = min(g, t[0] - 0.1)\\n \\n p = bisect.bisect_left(z[-1][1], (g,-2) )\\n res += p \\n\\nprint(res)\\n"}
{"id": "1773", "input": "\\n\\nn = int(input())\\na = 0\\nb = 0\\nfor x in input().split():\\n x = int(x)\\n if x % 2 ==", "gt": "0:\\n a += 1\\n else:\\n b += 1\\nres = b\\nif a < b:\\n res = a + (b-a)//3\\nprint(res)\\n"}
{"id": "1774", "input": "n=int(input())\\npos=[]\\nneg=[]\\nfor _ in range(n):\\n x,a=list(map(int,input().split()))\\n if x > 0:\\n pos.append((x, a))\\n else:\\n neg.append((-x, a))\\npos=[a", "gt": "for x,a in sorted(pos)]\\nneg=[a for x,a in sorted(neg)]\\nif len(pos)==len(neg):\\n print(sum(pos)+sum(neg))\\nelse:\\n if len(pos)<len(neg):\\n pos,neg=neg,pos\\n print(sum(neg)+sum(pos[:len(neg)+1]))\\n"}
{"id": "1775", "input": "import sys\\n\\ns = input()\\nqc = s.count('Q')\\nqs = int(qc ** 0.5)\\nhc = s.count('H')\\nif qs == 0:\\n print('Yes')\\n return\\nif not qc == qs ** 2:\\n print('No')\\n return\\nif not hc % (qs + 1) == 0:\\n print('No')\\n return\\n\\nt = s.split('Q')\\npre = len(t[0]) // 2\\nsuf = 0 if len(t)", "gt": "== 1 else len(t[-1]) // 2\\na = ['H' * pre] + t[1 : qs] + ['H' * suf]\\no = [c for c in 'Q'.join(a)]\\ng = []\\nfor c in o:\\n if c == 'H':\\n g += ['H']\\n else:\\n g += o\\n\\nprint('Yes' if ''.join(g) == s else 'No')\\n"}
{"id": "1776", "input": "n,m,k = map(int, input().split())\\nmCnt = 0\\nans = [0]*m\\nstart = 0\\nend = 0\\nQ = [[] for i in range(m)]\\n\\nfor i in range(n):\\n A = list(map(int, input().split()))\\n z = 0\\n for j in range(m) :\\n while Q[j] and Q[j][-1][0] < A[j] :\\n Q[j].pop()\\n Q[j].append([A[j],i])\\n z += Q[j][0][0]\\n if z <= k :\\n end = i+1\\n if mCnt < end - start :\\n mCnt", "gt": "= end - start\\n for j in range(m) :\\n ans[j] = Q[j][0][0]\\n else :\\n while True :\\n z = 0\\n for j in range(m) :\\n if Q[j] and Q[j][0][1] == start :\\n Q[j].pop(0)\\n if Q[j] : z += Q[j][0][0]\\n start += 1\\n if z<= k : break\\n end += 1\\n \\nfor i in ans :\\n print(i, end = \" \")\\n \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n \\n"}
{"id": "1777", "input": "from math import inf\\n\\nclass Node:\\n def __init__(self, parent = None, leftExp = None, rightExp = None, signQ = 0):\\n self.parent, self.leftExp, self.rightExp, self.signQ = parent, leftExp, rightExp, signQ\\n def __str__(self):\\n return \"Node\"\\n\\nmemo = {}\\n\\ndef Memoize(node, p, maxValue, minValue):\\n if not node in memo:\\n memo.update({node : {p : [maxValue, minValue]} })\\n else:\\n memo[node].update({p : [maxValue, minValue]})\\n\\ndef ExpMaxValue(root: Node, p):\\n\\n m = root.signQ - p\\n \"\"\"if root.signQ == 1:\\n if p == 1:\\n return [root.leftExp.value + root.rightExp.value, root.leftExp.value + root.rightExp.value]\\n else:\\n return [root.leftExp.value - root.rightExp.value, root.leftExp.value - root.rightExp.value]\"\"\"\\n\\n if root.signQ == 0:\\n return [root.value, root.value]\\n \\n if root in memo:\\n if p in memo[root]:\\n return memo[root][p]\\n\\n if m == 0:\\n value = ExpMaxValue(root.leftExp, root.leftExp.signQ)[0] + ExpMaxValue(root.rightExp, root.rightExp.signQ)[0]\\n Memoize(root, p, value, value)\\n return [value, value]\\n if p == 0:\\n value = ExpMaxValue(root.leftExp, 0)[0] - ExpMaxValue(root.rightExp, 0)[0]\\n Memoize(root, p, value, value)\\n return [value, value]\\n \\n maxValue = -inf\\n minValue = inf\\n if m >= p:\\n for pQMid in range(2):\\n pQLeftMin = min(p - pQMid, root.leftExp.signQ)\\n for pQLeft in range(pQLeftMin + 1):\\n if root.leftExp.signQ - pQLeft + (1 - pQMid) > m:\\n continue\\n \\n resLeft = ExpMaxValue(root.leftExp, pQLeft)\\n resRight = ExpMaxValue(root.rightExp, p - pQMid - pQLeft)\\n \\n if pQMid == 1:\\n maxValue = max(resLeft[0] + resRight[0], maxValue)\\n minValue = min(resLeft[1] + resRight[1], minValue)\\n else:\\n maxValue = max(resLeft[0] - resRight[1], maxValue)\\n minValue = min(resLeft[1] - resRight[0], minValue)\\n else:\\n for mQMid in range(2):\\n mQLeftMin = min(m -", "gt": "mQMid, root.leftExp.signQ)\\n for mQLeft in range(mQLeftMin + 1):\\n pQLeft = root.leftExp.signQ - mQLeft\\n if pQLeft + (1 - mQMid) > p:\\n continue\\n \\n resLeft = ExpMaxValue(root.leftExp, pQLeft)\\n resRight = ExpMaxValue(root.rightExp, p - (1 - mQMid) - pQLeft)\\n \\n if mQMid == 0:\\n maxValue = max(resLeft[0] + resRight[0], maxValue)\\n minValue = min(resLeft[1] + resRight[1], minValue)\\n else:\\n maxValue = max(resLeft[0] - resRight[1], maxValue)\\n minValue = min(resLeft[1] - resRight[0], minValue)\\n\\n Memoize(root, p, int(maxValue), int(minValue))\\n\\n return [int(maxValue), int(minValue)]\\n \\n \\n\\ndef PrintNodes(root: Node):\\n if root.signQ != 0:\\n leftExp = root.leftExp if root.leftExp.signQ != 0 else root.leftExp.value\\n rightExp = root.rightExp if root.rightExp.signQ != 0 else root.rightExp.value\\n check = root.signQ == root.leftExp.signQ + root.rightExp.signQ + 1\\n print(root.signQ, root.parent, leftExp, rightExp, check)\\n PrintNodes(root.leftExp)\\n PrintNodes(root.rightExp)\\n\\n \\n\\ndef main():\\n exp = str(input())\\n if len(exp) == 1:\\n print(exp)\\n return\\n \\n #root = Node(None, None, None)\\n #root.parent = root\\n cNode = Node()\\n isRight = False\\n \\n for i in range(1, len(exp) - 1):\\n if exp[i] == '(':\\n if not isRight:\\n cNode.leftExp = Node(cNode)\\n cNode = cNode.leftExp\\n else:\\n cNode.rightExp = Node(cNode)\\n cNode = cNode.rightExp\\n isRight = False\\n elif exp[i] == '?':\\n isRight = True\\n cNode.signQ += 1\\n elif exp[i] == ')':\\n if cNode.parent != None:\\n cNode.parent.signQ += cNode.signQ\\n cNode = cNode.parent\\n isRight = False\\n else:\\n if not isRight:\\n cNode.leftExp = Node(cNode)\\n cNode.leftExp.value = int(exp[i])\\n else:\\n cNode.rightExp = Node(cNode)\\n cNode.rightExp.value = int(exp[i])\\n\\n \\n #PrintNodes(cNode)\\n\\n ss = str(input()).split()\\n p, m = int(ss[0]), int(ss[1])\\n\\n print(ExpMaxValue(cNode, p)[0])\\n \\n\\n\\n \\n\\nmain()"}
{"id": "1778", "input": "n = int(input())\\n\\nls = [input() for _ in range(n)]\\n\\nbalance = [[0, 0] for _ in range(n)]\\n\\nfor i in range(n):\\n for j in range(len(ls[i])):\\n balance[i][0] = balance[i][0] + (1 if ls[i][j] == '(' else -1)\\n balance[i][1] = min(balance[i][1], balance[i][0])\\n\\nbalance2 = []\\n\\nfor i in range(n):\\n if balance[i][0] < 0:\\n if balance[i][1] >= balance[i][0]:\\n balance2.append(balance[i][0])\\n if", "gt": "balance[i][0] >= 0:\\n if balance[i][1] >= 0:\\n balance2.append(balance[i][0])\\n\\nbalance2.sort()\\n\\n\\nanswer = 0\\n\\ni, j = 0, len(balance2) - 1\\n\\nwhile i < j:\\n if balance2[i] + balance2[j] == 0:\\n answer += 1\\n i += 1\\n j -= 1\\n elif balance2[i] + balance2[j] < 0:\\n i += 1\\n elif balance2[i] + balance2[j] > 0:\\n j -= 1 \\n\\nprint(answer)\\n\\n\\n\\n"}
{"id": "1779", "input": "<s> ", "gt": "n=int(input())\\na=[*map(int,input().split())]\\nb=[*map(int,input().split())]\\nprint(sum(sorted(a+b)[::-2])-sum(b))"}
{"id": "1780", "input": "s1 = input()\\ns2 = input()\\ns = input()\\nr=''\\nfor i in s:\\n if", "gt": "i.isalpha():\\n #print (s1.index(i.lower()))\\n if i.isupper():\\n r+= (s2[(s1.index(i.lower()))].upper())\\n else:\\n r+=(s2[(s1.index(i.lower()))])\\n else:\\n r+=(i)\\nprint (r)"}
{"id": "1781", "input": "n, m = map(int, input().split())\\nt = input()\\na, b = t.count('1'), t.count('-')\\nt = ['0'] * m\\nc = 2 * min(a - b, b)\\nfor", "gt": "i in range(m):\\n l, r = map(int, input().split())\\n r -= l\\n if r & 1 and r < c: t[i] = '1'\\nprint('\\n'.join(t))"}
{"id": "1782", "input": "n, k = list(map(int, input().split()))\\nplain = list()\\n\\nfor i in range(n):\\n plain.append(list(input()))\\n\\nfr = {\\n \"0\": list(),\\n \"1\": list(),\\n \"2\": list(),\\n}\\nfor i in range(n):\\n for j in range(12):\\n if plain[i][j] != \".\":\\n continue\\n\\n st = 0\\n if j > 0 and plain[i][j - 1] == \"S\":\\n st += 1\\n if j < 11 and plain[i][j + 1] == \"S\":\\n st += 1\\n\\n fr[str(st)].append((i, j))\\n\\nfor i in range(k):\\n if", "gt": "len(fr[\"0\"]):\\n x, y = fr[\"0\"].pop()\\n elif len(fr[\"1\"]):\\n x, y = fr[\"1\"].pop()\\n else:\\n x, y = fr[\"2\"].pop()\\n plain[x][y] = \"x\"\\n\\n\\nresult = 0\\nfor i in range(n):\\n for j in range(12):\\n if plain[i][j] != \"S\":\\n continue\\n if j > 0 and plain[i][j - 1] in (\"S\", \"x\", \"P\"):\\n result += 1\\n if j < 11 and plain[i][j + 1] in (\"S\", \"x\", \"P\"):\\n result += 1\\n\\nprint(result)\\nfor i in range(n):\\n print(\"\".join(plain[i]))\\n"}
{"id": "1783", "input": "import re\\nimport itertools\\nfrom collections import Counter, deque\\n\\nclass Task:\\n n, k = 0, 0\\n answer = []\\n \\n def getData(self):\\n self.n, self.k = [int(x) for x in input().split(' ')]\\n #inFile = open('input.txt', 'r')\\n #inFile.readline().rstrip()\\n #self.childs = inFile.readline().rstrip()\\n\\n def solve(self):\\n n, k = self.n, self.k\\n if n < 3 * k:\\n self.answer = '-1'\\n return\\n\\n keeper = 1\\n while keeper <", "gt": "k:\\n self.answer += [keeper, keeper, keeper + 1]\\n self.answer += [keeper, keeper + 1, keeper + 1]\\n keeper += 2\\n if keeper > k:\\n self.answer += [k] * (n - len(self.answer))\\n return\\n else:\\n self.answer += [keeper] * (n - len(self.answer))\\n self.answer[-1] = 1\\n self.answer[3] = keeper\\n\\n def printAnswer(self):\\n print(re.sub(r'[\\[\\],]', '', str(self.answer)))\\n #print(self.answer[:6])\\n #outFile = open('output.txt', 'w')\\n #outFile.write(self.answer)\\n\\ntask = Task()\\ntask.getData()\\ntask.solve()\\ntask.printAnswer()\\n"}
{"id": "1784", "input": "line=input().split()\\nn=int(line[0])\\nk=int(line[1])\\nnums=input().split()\\nfor i in range(n):\\n nums[i]=int(nums[i])\\n\\nfirstsum = 0\\nfor i", "gt": "in range(k):\\n firstsum+=nums[i]\\n\\ntotsum=firstsum\\nfor i in range(n-k):\\n firstsum-=nums[i]\\n firstsum+=nums[k+i]\\n totsum+=firstsum\\nprint(totsum/(n-k+1))\\n"}
{"id": "1785", "input": "n, k = map(int, input().split())\\narr = [int(i) for i in input().split()]\\nres = [[] for i in range(n)]\\nc = 0\\nwhile True:\\n z = 0\\n for i in arr:\\n if i > 0:\\n z += 1\\n if z == 0:\\n break\\n if z == n:\\n for i in", "gt": "range(n):\\n arr[i] -= 1\\n res[i].append(1)\\n else:\\n c += 1\\n if c > k:\\n break\\n for i, j in enumerate(arr):\\n if j > 0:\\n arr[i] -= 1\\n res[i].append(c)\\nif c > k:\\n print('NO')\\nelse:\\n print('YES')\\n for i in res:\\n for j in i:\\n print(j, end = ' ')\\n print()"}
{"id": "1786", "input": "def main():\\n n = int(input())\\n l = [0] * 85\\n for c in input():\\n l[ord(c)] += 1\\n a, c, g, t = sorted(l[_] for _ in (65,", "gt": "67, 71, 84))\\n if g < t:\\n print(1)\\n elif c < g:\\n print(pow(2, n, 1000000007))\\n elif a < c:\\n print(pow(3, n, 1000000007))\\n else:\\n print(pow(4, n, 1000000007))\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1787", "input": "def main():\\n w, h, n = list(map(int, input().split()))\\n res, vrt, hor = [], [], []\\n vh = (vrt, hor)\\n for i in range(n):\\n s = input()\\n x = int(s[2:])\\n flag = s[0] == 'V'\\n vh[flag].append(i)\\n res.append([x, flag])\\n dim = []\\n for tmp, m in zip(vh, (h, w)):\\n tmp.sort(key=lambda e: res[e][0])\\n u = [None, [0]]\\n dim.append(u)\\n j = z = 0\\n for i in tmp:\\n x = res[i][0]\\n if z < x - j:\\n z = x - j\\n j = x\\n v", "gt": "= [u, res[i]]\\n u.append(v)\\n u = v\\n res[i].append(u)\\n v = [u, [m], None]\\n u.append(v)\\n dim.append(v)\\n if z < m - j:\\n z = m - j\\n dim.append(z)\\n l, r, wmax, u, d, hmax = dim\\n whmax = [wmax, hmax]\\n for i in range(n - 1, -1, -1):\\n x, flag, link = res[i]\\n u = whmax[flag]\\n res[i] = u * whmax[not flag]\\n link[0][2] = link[2]\\n link[2][0] = link[0]\\n v = link[2][1][0] - link[0][1][0]\\n if u < v:\\n whmax[flag] = v\\n print('\\n'.join(map(str, res)))\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1788", "input": "s=input()\\nn=len(s)\\na=[]\\ncurr=0\\nfor i in range(n):\\n if s[i]==\"a\":\\n curr+=1\\n elif s[i]==\"b\":\\n", "gt": "a.append(curr)\\n curr=0\\nif curr>0:\\n a.append(curr)\\nprod=1\\nfor i in range(len(a)):\\n prod*=(a[i]+1)\\n prod=prod%1000000007\\nprint(prod-1)"}
{"id": "1789", "input": "a,b =", "gt": "map(int, input().split())\\nprint((a+b)//2, (a-b)//2)"}
{"id": "1790", "input": "a,b,x,y = map(int, input().split())\\ny=min(y,2*x)\\n\\nif a==b", "gt": "or a==b+1:\\n print(x)\\n return\\n\\nans=x+abs(a-b)*y\\nif a>b:\\n ans-=y\\nprint(ans)"}
{"id": "1791", "input": "n = int(input())\\nd = {}\\nfor i in range(n):\\n s = input().split()\\n for j in range(int(s[0])):\\n d[s[j+1]]", "gt": "= d.get(s[j+1],0)+1\\nans = \"\"\\nfor x in d:\\n if d[x] == n:\\n ans += str(x) + ' '\\nprint(ans.strip())\\n"}
{"id": "1792", "input": "t = {}\\nfor i, c in enumerate(input()):\\n if c not in t: t[c] = (i, 1)\\n", "gt": "elif (t[c][0] - i) & 1: t[c] = (i, t[c][1] + 1)\\nprint(max(b for a, b in t.values()))"}
{"id": "1793", "input": "import sys\\n\\ndef matching(node, visited, adj, assigned):\\n if node == -1:\\n return True\\n if visited[node]:\\n return False\\n visited[node] = True\\n for neighbor in adj[node]:\\n if matching(assigned[neighbor], visited, adj, assigned):\\n assigned[neighbor] = node\\n return True\\n return False\\n\\nINF = 1000 * 1000\\n\\ninp = [int(x) for x in sys.stdin.read().split()]\\n\\nn, m = inp[0], inp[1]\\ninp_idx = 2\\n\\nG = [[INF] * n for _ in range(n)]\\n\\nfor _ in range(m):\\n a, b = inp[inp_idx] - 1, inp[inp_idx + 1] - 1\\n inp_idx += 2\\n G[a][b] = G[b][a] = 1\\n\\nfor v in range(n):\\n G[v][v] = 0\\n \\nfor k in range(n): \\n for i in range(n): \\n for j in range(n): \\n G[i][j] = min(G[i][j], G[i][k] + G[k][j])\\n \\ns, b, k, h = inp[inp_idx], inp[inp_idx + 1], inp[inp_idx + 2], inp[inp_idx +", "gt": "3]\\ninp_idx += 4\\n\\nspaceships = []\\nfor _ in range(s):\\n x, a, f = inp[inp_idx] - 1, inp[inp_idx + 1], inp[inp_idx + 2]\\n inp_idx += 3\\n spaceships.append((x, a, f))\\n \\nbases = []\\nfor _ in range(b):\\n x, d = inp[inp_idx] - 1, inp[inp_idx + 1]\\n inp_idx += 2\\n bases.append((x, d))\\n \\nadj = [[] for _ in range(s)]\\nassigned = [[] for _ in range(b)]\\nfor i in range(s):\\n space = spaceships[i]\\n for j in range(b):\\n base = bases[j]\\n u, v = space[0], base[0]\\n fuel = space[2]\\n if G[u][v] <= fuel and space[1] >= base[1]:\\n adj[i].append(j)\\n\\nvisited = [False] * s\\nassigned = [-1] * b\\n\\nmatched = 0\\nfor i in range(s):\\n visited = [False] * s\\n if matching(i, visited, adj, assigned):\\n matched += 1\\n\\n\\nprint(min(matched * k, h * s))\\n \\n\\n"}
{"id": "1794", "input": "def solve(n, l, s, www, children):\\n ans = 0\\n dp = [{} for _ in range(n)]\\n for v in range(n - 1, -1, -1):\\n cv = children[v]\\n if not cv:\\n dp[v][1] = www[v]\\n continue\\n ans += len(cv) - 1\\n wv = www[v]\\n if wv > s:\\n return -1\\n dv = dp[v]\\n for c in cv:\\n for lc, wc in list(dp[c].items()):\\n if lc == l:\\n continue\\n wt = wc + wv\\n if wt > s:\\n", "gt": "continue\\n if lc + 1 not in dv:\\n dv[lc + 1] = wt\\n else:\\n dv[lc + 1] = min(dv[lc + 1], wt)\\n if not dv:\\n ans += 1\\n dv[1] = wv\\n\\n return ans + 1\\n\\n\\nn, l, s = list(map(int, input().split()))\\nwww = list(map(int, input().split()))\\nif n == 1:\\n print(-1 if www[0] > s else 1)\\n return\\nchildren = [set() for _ in range(n)]\\nfor i, p in enumerate(map(int, input().split())):\\n children[p - 1].add(i + 1)\\nprint(solve(n, l, s, www, children))\\n"}
{"id": "1795", "input": "MAX_N = 100000\\n\\ndef maxi(a, b):\\n if a[0] > b[0]:\\n return a\\n else:\\n return b\\n\\nclass Segment_Tree:\\n def init(self, left, right, data, leftbound, rightbound):\\n self.data = data\\n self.left = left\\n self.right = right\\n self.leftbound = leftbound\\n self.rightbound = rightbound\\n return self\\n def build(self, a, leftbound, rightbound):\\n #print(leftbound, rightbound, a)\\n if len(a) == 0:\\n return self.init(-1, -1, [0, -1], MAX_N + 1, -1)\\n elif len(a) == 1:\\n return self.init(-1, -1, a[0], leftbound, rightbound)\\n else:\\n middle = (leftbound + rightbound) // 2\\n self.left = Segment_Tree()\\n self.right = Segment_Tree()\\n return self.init(self.left.build(a[:middle - leftbound], leftbound, middle), self.right.build(a[middle - leftbound:], middle, rightbound), maxi(self.left.data, self.right.data),", "gt": "leftbound, rightbound)\\n def get(self, l, r):\\n if l <= self.leftbound and r >= self.rightbound:\\n return self.data\\n elif l < self.left.rightbound and r > self.right.leftbound:\\n return maxi(self.left.get(l, r), self.right.get(l, r))\\n elif l >= self.right.leftbound:\\n return self.right.get(l, r)\\n else:\\n return self.left.get(l, r)\\n \\nn = int(input())\\na = list(map(int, input().split())) + [n]\\na = [[a[i] - 1, i] for i in range(n)]\\nTree = Segment_Tree()\\nTree.build(a, 0, n)\\ndp = [0] * n\\nans = 0\\nfor i in range(n - 2, -1, -1):\\n m = Tree.get(i + 1, a[i][0] + 1)[1]\\n dp[i] = dp[m] - (a[i][0] - m) + n - i - 1;\\n ans += dp[i]\\nprint(ans)\\n"}
{"id": "1796", "input": "n = int(input())\\na = list([int(x) - 1 for x in input().split()])\\n\\nans = False\\n\\nfor i", "gt": "in range(n):\\n if a[a[a[i]]] == i:\\n ans = True\\n break\\n\\nprint('YES' if ans else 'NO')\\n"}
{"id": "1797", "input": "str = input()\\ninpt = \"\"\\nn = int(str)\\nx = 0\\nfor i in range(n):\\n inpt = input()\\n #print(inpt[0:2]+\" - \"+inpt[1:3])\\n if(inpt[0:2] == \"++\" or inpt[1:3] ==", "gt": "\"++\"):\\n x += 1\\n #print(\"x ="}
{"id": "1798", "input": "n = int(input())\\np = list(map(int, input().split()))\\n\\nls = []\\nvisited = [False for _ in range(n)]\\ncnt = 0\\nfor i in range(n):\\n j = i\\n cnt = 0\\n while not", "gt": "visited[j]:\\n visited[j] = True\\n cnt += 1\\n j = p[j] - 1\\n if 0 < cnt:\\n ls.append(cnt)\\n\\nls.sort()\\nif 1 < len(ls):\\n ls[-2] += ls[-1]\\n ls.pop()\\n\\nprint(sum([x**2 for x in ls]))\\n\\n"}
{"id": "1799", "input": "import sys\\n\\ndef Is_arth(L):\\n D=L[1]-L[0]\\n p=L[1]\\n for i in range(2,len(L)):\\n if(L[i]-p!=D):\\n return False\\n p=L[i]\\n return True\\n\\nn=int(sys.stdin.readline())\\n\\nA=list(map(int,sys.stdin.readline().split()))\\n\\nT=[False]*(10**5+1)\\nZ=[]\\nfor i in range(10**5+1):\\n Z.append([])\\n\\nTaken=[]\\nfor i in", "gt": "range(n):\\n Z[A[i]]+=[i]\\n\\n\\nAns=\"\"\\nNum=0\\nfor i in range(10**5+1):\\n L=len(Z[i])\\n item=i\\n if(L==0):\\n continue\\n if(L==1):\\n Num+=1\\n Ans+=str(item)+\" 0\\n\"\\n elif(L==2):\\n Num+=1\\n Ans+=str(item)+\" \"+str(Z[item][1]-Z[item][0])+\"\\n\"\\n else:\\n if(Is_arth(Z[item])):\\n Num+=1\\n Ans+=str(item)+\" \"+str(Z[item][1]-Z[item][0])+\"\\n\"\\nsys.stdout.write(str(Num)+\"\\n\")\\nsys.stdout.write(Ans)\\n"}
{"id": "1800", "input": "from bisect import bisect_right\\nimport heapq\\n\\nn = int(input())\\nl = []\\n\\nti, wi = list(map(int, input().split()))\\nbal = ti\\npos = 1\\nfor _ in range(n - 1):\\n ti, wi = list(map(int, input().split()))\\n if ti > bal:\\n pos += 1\\n l.append((ti, wi - ti + 1))\\nl.sort()\\n\\nbest_pos = pos\\n\\nop = bisect_right(l, (bal, float('inf')))\\n#print(l)\\n\\nw", "gt": "= []\\nfor i, v in l[op:]:\\n heapq.heappush(w, v)\\nop -= 1\\n\\nwhile w:\\n head = heapq.heappop(w)\\n if bal < head:\\n break\\n bal -= head\\n pos -= 1\\n\\n #print(w, op)\\n while op >= 0 and l[op][0] > bal:\\n heapq.heappush(w, l[op][1])\\n op -= 1\\n pos += 1\\n best_pos = min(best_pos, pos)\\n\\nprint(best_pos)\\n"}
{"id": "1801", "input": "# You lost the game.\\nn, m = map(int, input().split())\\nA = list(map(int, input().split()))\\nM = [list(map(int, input().split())) for _ in range(m)]\\n\\nj = m-1\\nx = 2\\nh = -1\\nB = [-1 for _ in range(n+1)]\\nwhile h < n and j >= 0:\\n h = M[j][1]\\n if h >= x:\\n B[h] = j\\n x = h+1\\n j -= 1\\n\\nO = [0 for _ in", "gt": "range(n)]\\n\\nfor i in range(n-1,x-2,-1):\\n O[i] = A[i]\\n del A[i]\\n\\nn2 = len(A)\\n \\nR = A[:]\\nR.sort()\\n \\nd = 0\\nf = n2-1\\n\\n\\nc = 0\\nfor i in range(n2-1,-1,-1):\\n j = B[i+1]\\n if j >= 0:\\n c = M[j][0]\\n if c == 1:\\n O[i] = R[f]\\n f -= 1\\n else:\\n O[i] = R[d]\\n d += 1\\n\\n \\nfor i in range(n):\\n print(O[i],end=\" \")\\n \\n \\n \\n"}
{"id": "1802", "input": "n = int(input())\\nc, d = {}, {}\\nfor x, y in zip(input().split(), input().split()):\\n c[x] = c.get(x, 1) + 1\\n c[y] = c.get(y, 1) + 1\\n if x == y: d[x] = d.get(x, 0) + 2\\ns, m = 1, int(input())\\nfor k, v", "gt": "in c.items():\\n u = d.get(k, 0)\\n for i in range(v - u, v, 2): s = s * (i * i + i) // 2 % m\\n for i in range(1, v - u): s = s * i % m\\nprint(s)"}
{"id": "1803", "input": "q = 10001\\nn, a = int(input()), list(map(int, input().split()))\\na.sort()\\nfor i in range(40000 // (n - 1) + 1):\\n b = [a[j] - j * i for j in range(n)]\\n", "gt": "u, v = max(b), min(b)\\n p = (u - v + 1) // 2\\n if p < q: q, s, d = p, v + p, i\\nprint(q)\\nprint(s, d)\\n"}
{"id": "1804", "input": "rd = lambda: list(map(int, input().split()))\\n\\nn, = rd()\\na = [0] + rd() + [0]\\nfor i in", "gt": "range(rd()[0]):\\n x, y = rd()\\n a[x-1] += y-1\\n a[x+1] += a[x]-y\\n a[x ] = 0\\nprint('\\n'.join(map(str, a[1:1+n])))"}
{"id": "1805", "input": "#!/usr/bin/env python3\\n\\nn, m = list(map(int, input().split()))\\nminx = miny = n + m\\nmaxx = maxy = - minx\\ndist = n + m + 1\\n\\nc = int(input())\\nfor _ in range(c):\\n x, y = list(map(int, input().split()))\\n minx = min(minx, x - y)\\n miny = min(miny, x + y)\\n maxx = max(maxx, x - y)\\n maxy", "gt": "= max(maxy, x + y)\\n\\nh = int(input())\\nfor i in range(h):\\n a, b = list(map(int, input().split()))\\n x = a - b\\n y = a + b\\n maxxy = max(\\n max(abs(minx - x), abs(maxx - x)),\\n max(abs(miny - y), abs(maxy - y))\\n )\\n if maxxy < dist:\\n dist = maxxy\\n res = i + 1\\n\\nprint(dist)\\nprint(res)\\n"}
{"id": "1806", "input": "t = int(input())\\nfor i in range(t):\\n a = int(input())\\n if", "gt": "a >= 4:\\n print(a % 2)\\n else:\\n print(4 - a)"}
{"id": "1807", "input": "import sys\\ninput = sys.stdin.readline\\n\\nN, M = list(map(int, input().split()))\\nA = []\\nfor _ in range(N):\\n l, r = list(map(int, input().split()))\\n A.append([l, r])\\nZ = []\\nfor _ in range(M):\\n l, r = list(map(int, input().split()))\\n Z.append([l, r])\\nMA = 5*10**5+1\\nlg = 20\\n\\nX = [[-1]*MA for i in range(lg)]\\nfor i in range(N):\\n X[0][A[i][0]] = max(X[0][A[i][0]], A[i][1])\\nfor i in range(1, MA):\\n", "gt": "X[0][i] = max(X[0][i], X[0][i-1])\\n\\nfor k in range(1, lg):\\n for i in range(MA):\\n a = X[k-1][i]\\n if a >= 0:\\n X[k][i] = X[k-1][a]\\n\\nfor a, b in Z:\\n ans = 1\\n for k in range(lg)[::-1]:\\n if X[k][a] < b:\\n a = X[k][a]\\n ans += 2**k\\n print(-1 if X[0][a] < b or ans > MA else ans)\\n"}
{"id": "1808", "input": "def main():\\n v = {\\n \"1\" : 2,\\n \"2\" : 5,\\n \"3\" : 5,\\n \"4\" : 4,\\n \"5\" : 5,\\n \"6\" : 6,\\n \"7\" : 3,\\n \"8\" : 7,\\n \"9\" : 6,\\n", "gt": "\"0\" : 6\\n }\\n a, b = map(int, input().split())\\n answer = 0\\n\\n for i in range(a, b + 1):\\n s = str(i)\\n\\n for e in s:\\n answer += v[e]\\n\\n print(answer)\\n\\n\\n\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "1809", "input": "R=lambda:list(map(int,input().split()))\\nn,k,x=R()\\na=list(reversed(R()))\\nprint(sum(x if i < k else", "gt": "a[i] for i in range(n))) \\n"}
{"id": "1810", "input": "line = input().split()\\nn = int(line[0])\\nm = int(line[1])\\n\\nW = [int(w) for w in input().split()]\\nB = [int(b) for b in input().split()]\\n\\nans = 0\\nlst = [0 for i in range(n)]\\nfor i in range(m):\\n arr = list(lst)\\n", "gt": "for j in range(i):\\n if B[i - j - 1] == B[i]:\\n break\\n arr[B[i - j - 1] - 1] = 1\\n for i in range(n):\\n if arr[i] == 1:\\n ans += W[i]\\nprint(ans)\\n \\n"}
{"id": "1811", "input": "n =", "gt": "2*2*2*3*3*5*7\\nm = int(input())\\nprint(m//n)\\n"}
{"id": "1812", "input": "n, k = map(int, input().split())\\nj = 0\\nfor i in input():\\n if i == '.':\\n", "gt": "j = 0\\n else:\\n j += 1\\n if j >= k:\\n print(\"NO\")\\n break\\nelse:\\n print(\"YES\")"}
{"id": "1813", "input": "def dlog(x, n):\\n bigMod = 5 ** n\\n ans = [None, 0, 1, 3, 2][x % 5]\\n val = 2 ** ans % bigMod\\n mod, phi = 5, 4\\n phiVal = 2 ** phi % bigMod\\n for i in range(2, n + 1):\\n nextMod = mod * 5\\n while val % nextMod != x % nextMod:\\n val = val * phiVal % bigMod\\n ans += phi\\n phi *= 5\\n phiVal = (phiVal *\\n phiVal % bigMod *\\n phiVal % bigMod *\\n phiVal % bigMod *\\n phiVal % bigMod)\\n mod = nextMod\\n return ans\\n\\ndef main():\\n inp = input()\\n n = len(inp)\\n", "gt": "a = int(inp)\\n for m in range(n + 1):\\n l = a * 10 ** m\\n x, mod = l, 2 ** (n + m)\\n if x % mod != 0:\\n x += mod - x % mod\\n if x % 5 == 0:\\n x += mod\\n if x < l + 10 ** m:\\n assert x % mod == 0 and x % 5 != 0\\n x = x // mod\\n mod = 5 ** (n + m)\\n print(n + m + dlog(x % mod, n + m))\\n return\\n assert False\\n\\ndef __starting_point():\\n cnt = int(input())\\n for i in range(cnt):\\n main()\\n__starting_point()"}
{"id": "1814", "input": "def split(a,n,s,l):\\n pieces = []\\n\\n i = 1\\n tmpmin = a[0]\\n tmpmax = a[0]\\n tmppc = [a[0]]\\n while i<n:\\n if abs(a[i]-tmpmin)<=s and abs(a[i]-tmpmax)<=s:\\n tmppc.append(a[i])\\n if a[i]<tmpmin: tmpmin=a[i]\\n elif a[i]>tmpmax: tmpmax = a[i]\\n else:\\n pieces.append(tmppc)\\n tmppc = [a[i]]\\n tmpmin = a[i]\\n tmpmax = a[i]\\n i += 1\\n pieces.append(tmppc)\\n\\n fail = False \\n for j in range(len(pieces)):\\n if len(pieces[j])<l:\\n if", "gt": "j>0:\\n prevpc = pieces[j-1]\\n minj = min(pieces[j])\\n maxj = max(pieces[j])\\n \\n while len(pieces[j])<l:\\n tmp = prevpc.pop()\\n if abs(tmp-minj)<=s and abs(tmp-maxj)<=s:\\n pieces[j].insert(0,tmp)\\n if tmp<minj: minj=tmp\\n elif tmp>maxj: maxj=tmp\\n else:\\n return -1\\n if len(prevpc)<l:\\n return -1\\n else:\\n return -1\\n return len(pieces)\\n\\nn,s,l = [int(s) for s in input().split()]\\na = [int(s) for s in input().split()]\\n\\n\\nres = split(a,n,s,l)\\nif res<0:\\n a.reverse()\\n res = split(a,n,s,l)\\nprint(res)\\n \\n\\n\\n\\n"}
{"id": "1815", "input": "def takeClosest(myList, myNumber):\\n\\n \"\"\"\\n\\n Assumes myList is sorted. Returns closest value to myNumber.\\n\\n\\n\\n If two numbers are equally close, return the smallest number.\\n\\n \"\"\"\\n\\n if len(myList) == 0:\\n\\n return 9e10\\n\\n pos = bisect_left(myList, myNumber)\\n\\n if pos == 0:\\n\\n return myList[0]\\n\\n if pos == len(myList):\\n\\n return myList[-1]\\n\\n before = myList[pos - 1]\\n\\n after = myList[pos]\\n\\n if after - myNumber < myNumber - before:\\n\\n return after\\n\\n else:\\n\\n return before\\n\\n\\n\\nfrom bisect import bisect_left\\n\\nfrom math import ceil\\n\\n\\n\\nn, m, n_stairs, n_elevators, v = map(int, input().split(\" \"))\\n\\n\\n\\nif n_stairs > 0:\\n\\n stairs = list(map(int, input().split(\" \")))\\n\\nelse:\\n\\n stairs = []\\n\\n input()\\n\\nif n_elevators > 0:\\n\\n elevators = list(map(int, input().split(\" \")))\\n\\nelse:\\n\\n elevators = []\\n\\n input()\\n\\nqueries = int(input())\\n\\nres = []\\n\\nfor i in range(queries):\\n\\n x1, y1,", "gt": "x2, y2 = map(int, input().split(\" \"))\\n\\n next_elevator = takeClosest(elevators, (y1 + y2) / 2)\\n\\n next_stairs = takeClosest(stairs, (y1 + y2) / 2)\\n\\n time_elevator = abs(x1 - x2) / v\\n\\n time_stairs = abs(x1 - x2)\\n\\n\\n\\n mi = min(y1, y2)\\n\\n ma = max(y1, y2)\\n\\n if next_elevator < mi:\\n\\n time_elevator += (mi - next_elevator) * 2\\n\\n elif next_elevator > ma:\\n\\n time_elevator += (next_elevator - ma) * 2\\n\\n\\n\\n if next_stairs < mi:\\n\\n time_stairs += (mi - next_stairs) * 2\\n\\n elif next_stairs > ma:\\n\\n time_stairs += (next_stairs - ma) * 2\\n\\n\\n\\n dis = abs(y1 - y2)\\n\\n if time_elevator < time_stairs:\\n\\n dis += time_elevator\\n\\n else:\\n\\n dis += time_stairs\\n\\n if x1 == x2:\\n\\n res.append(abs(y1 - y2))\\n\\n else:\\n\\n res.append(ceil(dis))\\n\\nprint(*res, sep=\"\\n\")\\n\\n\\n\\n# Made By Mostafa_Khaled"}
{"id": "1816", "input": "counts = {}\\nrcount = {}\\n\\ninput()\\n\\nm = 0\\nfor i, x in enumerate(map(int, input().split())):\\n if x in counts:\\n rcount[counts[x]].remove(x)\\n if not rcount[counts[x]]:\\n del rcount[counts[x]]\\n counts[x] += 1\\n if counts[x] not in rcount: rcount[counts[x]] = set()\\n rcount[counts[x]].add(x)\\n else:\\n counts[x] = 1\\n if 1 not in rcount: rcount[1] = set()\\n rcount[1].add(x)\\n", "gt": "keys = list(rcount)\\n if len(keys) == 2 and max(keys) - min(keys) == 1 and len(rcount[max(keys)]) == 1 or len(keys) == 2 and min(keys) == 1 and len(rcount[1]) == 1 or len(keys) == 1 and (len(rcount[keys[0]]) == 1 or keys[0] == 1):\\n m = max(m, i)\\n\\nprint(m + 1)"}
{"id": "1817", "input": "k=0\\n\\nd = [0] * 200005\\nx = int(input())\\np = list(map(int, input().split(' ')))\\nfor i in", "gt": "range(len(p)):\\n d[p[i]] = i\\n\\nfor i in range(1, x):\\n k += abs(d[i+1] - d[i])\\n\\nprint(k)\\n"}
{"id": "1818", "input": "n = int(input())\\nnum = list(map(int, input().split()))\\nfor i in range(n -", "gt": "1):\\n if i % 2 == 0:\\n num.pop(num.index(max(num)))\\n else:\\n num.pop(num.index(min(num)))\\nprint(*num)"}
{"id": "1819", "input": "3\\n\\nmem = [-1] * 100000\\n\\ndef f(x):\\n if x == 0:\\n return 0\\n if x < 100000 and mem[x] != -1:\\n return mem[x]\\n if x % 2 == 0:\\n res = f(x // 2)\\n else:\\n res = f((x - 1) //", "gt": "2) + 1\\n if x < 100000:\\n mem[x] = res\\n return res\\n\\nn = int(input())\\na = list(map(int, input().split()))\\ncnt ="}
{"id": "1820", "input": "t = int(input())\\n\\nfor _ in range(t):\\n [n, x]", "gt": "= [int(v) for v in input().split()]\\n print(2 * x)"}
{"id": "1821", "input": "for _ in range(int(input())):\\n am = int(input())\\n arr =", "gt": "list(map(int,input().split()))\\n if arr[0] + arr[1] > arr[-1]:\\n print(-1)\\n else:\\n print(1,2,am)"}
{"id": "1822", "input": "import sys\\n\\ndef solve():\\n n = int(sys.stdin.readline())\\n a = [0] + [int(i) for i in sys.stdin.readline().split()]\\n\\n dp = [[0]*(n + 1) for i in range(n + 1)]\\n ans = 0\\n\\n maxnum = [0] * (10**5 + 2)\\n maxmod = [0] * 7\\n\\n for y in range(n + 1):\\n maxmod = [0] * 7\\n\\n for ai in a:\\n maxnum[ai] = 0\\n\\n for", "gt": "i in range(y):\\n maxmod[a[i] % 7] = max(maxmod[a[i] % 7], dp[i][y])\\n maxnum[a[i]] = max(maxnum[a[i]], dp[i][y])\\n\\n for x in range(y + 1, n + 1):\\n dp[x][y] = max(maxmod[a[x] % 7], maxnum[a[x] + 1], maxnum[a[x] - 1], dp[0][y]) + 1\\n dp[y][x] = dp[x][y]\\n maxmod[a[x] % 7] = max(maxmod[a[x] % 7], dp[x][y])\\n maxnum[a[x]] = max(maxnum[a[x]], dp[x][y])\\n ans = max(ans, dp[x][y])\\n\\n print(ans)\\n\\ndef __starting_point():\\n solve()\\n__starting_point()"}
{"id": "1823", "input": "n, x = list(map(int, input().split()))\\nlink1 = list(map(int, input().split()))\\nlink2 = [0] * (n + 1)\\nfor i, v in enumerate(link1, 1):\\n if v != 0:\\n link2[v] = i\\n\\n\\ntable = [False] * n\\ntable[0] = True\\nfor i, v in enumerate(link1, 1):\\n if v == 0:\\n len = 0\\n flag =", "gt": "False\\n now = i\\n while now:\\n len += 1\\n if now == x:\\n flag = True\\n pos = len\\n now = link2[now]\\n if not flag:\\n for j in reversed(list(range(n - len))):\\n if table[j]:\\n table[j + len] = True\\nfor i in range(n):\\n if table[i]:\\n print(i + pos)\\n"}
{"id": "1824", "input": "n, k = map(int, input().split())\\nt = list(map(int, input().split()))\\nt = [t[0]] + [t[i] for i in range(1, len(t)) if t[i] != t[i - 1]]\\np = [0] * (k", "gt": "+ 1)\\nfor i in range(1, len(t) - 1):\\n if t[i - 1] == t[i + 1]: p[t[i]] += 2\\n else: p[t[i]] += 1\\np[t[0]] += 1\\np[t[-1]] += 1\\nprint(p.index(max(p)))"}
{"id": "1825", "input": "n = int(input())\\none = sum([int(x) for x in input().strip().split()])\\ntwo =", "gt": "sum([int(x) for x in input().strip().split()])\\nthree = sum([int(x) for x in input().strip().split()])\\nprint(one-two)\\nprint(two-three)\\n\\n"}
{"id": "1826", "input": "import math as mt \\nimport sys,string\\ninput=sys.stdin.readline\\nprint=sys.stdout.write\\nimport random\\nfrom collections import deque,defaultdict\\nL=lambda : list(map(int,input().split()))\\nLs=lambda : list(input().split())\\nM=lambda : map(int,input().split())\\nI=lambda :int(input())\\nt=I()\\nd=defaultdict(str)\\nml=0\\np=0\\nfor _ in range(t):\\n s=input().split()\\n w=s[0]\\n x=list(map(int,s[1::]))\\n for i in range(1,len(x)):\\n r=d[x[i]-1]\\n if(len(r)<len(w)):\\n", "gt": "d[x[i]-1]=w\\n ml=max(ml,len(w)+x[-1]-1)\\nans=\"a\"*ml\\nans=list(ans)\\n#print(d)\\np=-1\\nz=sorted(list(d.keys()))\\nfor i in z:\\n if(i+len(d[i])>p):\\n if(i>=p):\\n for j in range(i,i+len(d[i])):\\n ans[j]=d[i][j-i]\\n else:\\n leave=p-i\\n f=max(i,p)\\n #print(ans,\"@\",d[i],p,d[i][leave::])\\n for j in range(leave,len(d[i])):\\n ans[f]=d[i][j]\\n f+=1\\n #print(ans,\"*\")\\n p=i+len(d[i])\\n \\nfor i in ans:\\n print(i)\\n \\n"}
{"id": "1827", "input": "n = int(input())\\nst = input()\\nans = n\\ni = 1\\nwhile i < n:\\n if", "gt": "st[i - 1] != st[i]:\\n ans -= 1\\n i += 1\\n i += 1\\nprint(ans)\\n"}
{"id": "1828", "input": "a = int(input())\\nlt = sorted(list(map(int,", "gt": "input().split())))\\n\\nfor i in range(len(lt)//2):\\n print(lt[i], lt[-i-1])"}
{"id": "1829", "input": "#!/usr/bin/env python3\\n\\ntry:\\n while True:\\n n = int(input())\\n prev_x, prev_y = list(map(int, input().split()))\\n prev_d = 0\\n result = 0\\n for i in range(n):\\n x, y = list(map(int, input().split()))\\n if y > prev_y:\\n d = 0\\n elif x >", "gt": "prev_x:\\n d = 1\\n elif y < prev_y:\\n d = 2\\n else:\\n d = 3\\n if ((d + 1) & 0x3) == prev_d:\\n result += 1\\n prev_x, prev_y = x, y\\n prev_d = d\\n print(result)\\n\\nexcept EOFError:\\n pass\\n"}
{"id": "1830", "input": "def main():\\n n, m = list(map(int, input().split()))\\n\\n p_words = set()\\n e_words = set()\\n\\n for _ in range(n):\\n p_words.add(input())\\n for _ in range(m):\\n e_words.add(input())\\n\\n common = p_words & e_words\\n\\n p_words -= common\\n e_words -= common\\n\\n we_win = False\\n p_turn = True\\n\\n a, b, c = len(p_words), len(e_words),", "gt": "len(common)\\n\\n while True:\\n if c > 0:\\n c -= 1\\n else:\\n if p_turn:\\n if a == 0:\\n we_win = False\\n break\\n else:\\n a -= 1\\n else:\\n if b == 0:\\n we_win = True\\n break\\n else:\\n b -= 1\\n\\n p_turn = not p_turn\\n\\n print(\"YES\" if we_win else \"NO\")\\n\\nmain()\\n"}
{"id": "1831", "input": "n, m = map(int, input().split())\\nsum = n ** 2\\ncolx = n\\ncoly = n\\nusedx = [False] * n\\nusedy = [False] * n\\nfor i in range(m):\\n x, y = map(int, input().split())\\n x -= 1\\n", "gt": "y -= 1\\n if not usedx[x]:\\n sum -= coly\\n usedx[x] = True\\n colx -= 1\\n if not usedy[y]:\\n sum -= colx\\n usedy[y] = True\\n coly -= 1\\n print(sum, end = ' ')\\n"}
{"id": "1832", "input": "3\\n\\n__import__(\"sys\").setrecursionlimit(10 ** 6)\\n\\ndef dfs(u, tr, used):\\n used[u] = True\\n ans = 1\\n for v in tr[u]:\\n if not used[v]:\\n ans += dfs(v, tr, used)\\n return ans\\n\\n\\nn, m = list(map(int, input().split()))\\nif n != m + 1:\\n", "gt": "print(\"no\")\\n return\\n\\ntr = [[] for i in range(n)]\\nfor i in range(m):\\n a, b = list(map(int, input().split()))\\n a -= 1\\n b -= 1\\n tr[a].append(b)\\n tr[b].append(a)\\n\\nused = [False] * n\\nif dfs(0, tr, used) == n:\\n print(\"yes\")\\nelse:\\n print(\"no\")\\n"}
{"id": "1833", "input": "rndid = \"cuuhkjc\"\\nfor _ in range(int(input())):\\n input()\\n ls = 'a' * 51\\n oa = ord('a')\\n print(ls)\\n fora in input().split():\\n a = int(a)\\n ls = ls[:a] + ls[a:].translate({oa: 'b', oa", "gt": "+ 1: 'a'}"}
{"id": "1834", "input": "import math\\nn = int(input())\\na = list(map(int, input().split()))\\nd = {0: 1}\\nm = 1\\nans = 0\\nfor i in a:\\n #print(\"i=\", i)\\n divisors = []\\n for j in range(1, min(m, int(math.sqrt(i))) + 1):\\n if i % j == 0:\\n k = int(i / j)\\n divisors.append(j)\\n if j != k and k <= m:\\n", "gt": "divisors.append(k)\\n #print(\"divisors=\", divisors)\\n new_d ="}
{"id": "1835", "input": "n = int(input())\\na = [int(i) for i in input().split()]\\na.sort()\\nb = []\\nfor i in range(n - 1, (n + 1) // 2", "gt": "- 1, -1):\\n b.append(a[i])\\na = a[:(n + 1) // 2]\\nc = []\\nfor i in range(len(b)):\\n c.append(a[i])\\n c.append(b[i])\\nif len(a) > len(b):\\n c.append(a[-1])\\nprint(*c)"}
{"id": "1836", "input": "import sys\\nimport math\\nfrom collections import defaultdict\\nfrom itertools import combinations\\nfrom itertools import permutations\\ninput = lambda : sys.stdin.readline().rstrip()\\nread = lambda : list(map(int, input().split()))\\ndef write(*args, sep=\"\\n\"):\\n for i in args:\\n sys.stdout.write(\"{}\".format(i) + sep)\\nINF = float('inf')\\nMOD = int(1e9 + 7)\\n\\nfor _ in range(int(input())):\\n n = int(input())\\n arr = sorted([input() for", "gt": "i in range(n)], key=lambda x:len(x))\\n\\n zero_cnt, one_cnt = 0, 0\\n for i in arr:\\n zero_cnt += i.count('0')\\n one_cnt += i.count('1')\\n total = (zero_cnt//2) + (one_cnt//2)\\n \\n ans = 0\\n\\n for i in arr:\\n if total >= len(i)//2:\\n total -= len(i)//2 \\n ans += 1\\n \\n print(ans)\\n"}
{"id": "1837", "input": "n, m = list(map(int, input().split()))\\np = [0] * n\\ne = []\\nfor i in range(m):\\n q, w = list(map(int, input().split()))\\n p[w - 1] += 1\\n p[q - 1] += 1\\n e.append([min(q, w),", "gt": "max(q, w)])\\ndp = [1] * n\\ne.sort()\\nfor i in range(m):\\n dp[e[i][1] - 1] = max(dp[e[i][1] - 1], dp[e[i][0] - 1] + 1)\\nans = 0\\nfor i in range(n):\\n ans = max(ans, dp[i] * p[i])\\nprint(ans)\\n"}
{"id": "1838", "input": "n = int(input())\\nA = list(map(int, input().split()))\\n\\ncnt = 0\\nfor i in range(n):\\n cnt += (A[i] == i)\\n\\nif cnt == n:\\n print(n)\\nelse:\\n ind =", "gt": "False\\n for i in range(n):\\n ind |= (A[i] != i and A[A[i]] == i)\\n if ind:\\n print(cnt + 2)\\n else:\\n print(cnt + 1)"}
{"id": "1839", "input": "n,m,q=list(map(int,input().split()))\\na=input().split()\\nc={x:([x],[]) for x in a}\\nfor i in range(m):\\n t,x,y=input().split()\\n if t=='2':\\n sign=1\\n else: sign=0\\n if c[x][0] is c[y][1-sign]:\\n print(\"NO\")\\n continue\\n print(\"YES\")\\n if c[x][0] is c[y][sign]:\\n continue\\n c1,c2=c[x],c[y]\\n if len(c1[0])+len(c1[1])<len(c2[0])+len(c2[1]):\\n c1,c2=c2,c1\\n s1,a1=c1\\n if sign==0:\\n", "gt": "s2,a2=c2\\n else:\\n a2,s2=c2\\n s1+=s2\\n a1+=a2\\n cs=s1,a1\\n for x in s2:\\n c[x]=cs\\n ca=a1,s1\\n for x in a2:\\n c[x]=ca\\nfor i in range(q):\\n x,y=input().split()\\n if c[x][0] is c[y][0]:\\n print(1)\\n elif c[x][0] is c[y][1]:\\n print(2)\\n else:\\n print(3)\\n"}
{"id": "1840", "input": "n = int(input())\\nh = [False] * n\\nv = [False] * n\\nresult = [ ]\\nfor i in range(n * n):\\n a, b = list(map(int,", "gt": "input().split()))\\n a -= 1\\n b -= 1\\n if not h[a] and not v[b]:\\n h[a] = v[b] = True\\n result.append(i + 1)\\nprint(' '.join(map(str, result)))\\n"}
{"id": "1841", "input": "# -*- coding: utf-8 -*-\\nimport sys\\nfrom operator import itemgetter\\nfrom fractions import gcd\\nfrom math import ceil, floor\\nfrom copy import deepcopy\\nfrom itertools import accumulate\\nfrom collections import Counter\\nimport math\\nfrom functools import reduce\\nfrom bisect import bisect_right\\nsys.setrecursionlimit(200000)\\ninput = sys.stdin.readline\\ndef ii(): return int(input())\\ndef mi(): return map(int, input().rstrip().split())\\ndef lmi(): return list(map(int, input().rstrip().split()))\\ndef li(): return list(input().rstrip())\\ndef debug(x): print(\"debug: \", x, file=sys.stderr)\\n# template\\n\\n\\nclass BIT:\\n def __init__(self, x, d=0):\\n if isinstance(x, int):\\n self.size = x\\n self.tree = [d for _ in range(self.size + 1)]\\n elif isinstance(x, list):\\n self.size = len(x)\\n self.tree = [d for _ in range(self.size + 1)]\\n self.build(x)\\n else:\\n raise TypeError\\n\\n def build(self, arr):\\n if isinstance(arr, list):\\n raise TypeError\\n for num, x in enumerate(arr):\\n self.add0(num, x)\\n\\n def sum(self, i):\\n s = self.tree[0]\\n while i > 0:\\n s += self.tree[i]\\n i -= (i & -i)\\n return s\\n\\n def add(self, i, a):\\n if(i == 0):\\n return\\n while (i <= self.size):\\n self.tree[i] += a\\n i += (i & -i)\\n\\n def bisect_left(self, w):\\n if w <= 0:\\n return 0\\n x = 0\\n r = 1\\n while (r <", "gt": "self.size):\\n r <<= 1\\n k = r\\n while (k > 0):\\n if x + k <= self.size and self.tree[x + k] < w:\\n w -= self.tree[x + k]\\n x += k\\n k >>= 1\\n return x + 1\\n\\n def query(self, l, r):\\n return self.sum(r - 1) - self.sum(l - 1)\\n\\n def sum0(self, i):\\n return self.sum(i + 1)\\n\\n def add0(self, i, a):\\n self.add(i + 1, a)\\n\\n def query0(self, l, r):\\n return self.sum(r) - self.sum(l)\\n\\n def __getitem__(self, item):\\n _tmp = item.indices(self.size + 1)\\n return [self.sum(i) - self.sum(i - 1) for i in range(_tmp[0], _tmp[1], _tmp[2])]\\n\\n def __str__(self):\\n return str(self[1:self.size + 1])\\n\\n# END CUT HERE\\n\\n\\ndef main():\\n s, b = mi()\\n a = lmi()\\n d = []\\n g = []\\n for i in range(b):\\n _d, _g = mi()\\n d.append(_d)\\n g.append(_g)\\n tmp = [(d[i], g[i]) for i in range(b)]\\n tmp.sort(key=lambda x: x[0])\\n d.sort()\\n # print(tmp)\\n # print(d)\\n bit = BIT(b)\\n for i in range(b):\\n bit.add0(i, tmp[i][1])\\n for i in range(s):\\n tmp = bisect_right(d, a[i])\\n # print(tmp)\\n print(bit.sum(tmp), end=\" \")\\n print()\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1842", "input": "import sys\\nn,m=list(map(int,sys.stdin.readline().split()))\\n\\nA=list(map(int,sys.stdin.readline().split()))\\n\\nAns=[1]\\n\\nE={}\\nE[A[-1]]=1\\nfor i in range(n-2,-1,-1):\\n if(A[i] in E):\\n Ans.append(Ans[-1])\\n", "gt": "else:\\n E[A[i]]=1\\n Ans.append(Ans[-1]+1)\\n\\nAnswer=\"\"\\nfor i in range(m):\\n x=int(sys.stdin.readline())\\n x-=1\\n x=n-1-x\\n Answer+=str(Ans[x])+\"\\n\"\\nsys.stdout.write(Answer)\\n"}
{"id": "1843", "input": "import math\\na,b,c=map(int,input().split())\\nD = b ** 2 - 4 * a * c\\nx1 = (-b", "gt": "+ math.sqrt(D)) / (2 * a)\\nx2 = (-b - math.sqrt(D)) / (2 * a)\\nans1=max(x1,x2)\\nans=min(x1,x2)\\nprint(ans1)\\nprint(ans)"}
{"id": "1844", "input": "from math import floor,log\\nfor _ in", "gt": "range(int(input())):\\n n=int(input())\\n p=(n*(n+1))//2\\n f=floor(log(n,2))\\n p-=2*(2**(f+1)-1)\\n print(p)\\n"}
{"id": "1845", "input": "from sys import *\\n\\nmaxn = 3 * 10 ** 5 + 5\\n\\nfre = [0 for i in range(maxn)]\\nisprime = [1 for i in range(maxn)]\\nprime = []\\ndivi = [0 for i in range(maxn)]\\nfact = [1] * 10\\n\\ndef nCr(n, r):\\n if n < r:\\n return 0\\n if n == r:\\n return 1\\n pro = 1\\n for i in range(r):\\n pro *= (n - i)\\n pro //= fact[r]\\n return pro\\n\\nn = int(stdin.readline())\\narr = list(map(int, stdin.readline().split()))\\nfor i in arr:\\n if i is 1:\\n print(1)\\n return\\n fre[i] += 1\\n\\ndivi[1] = n\\nfor i in range(2, maxn):\\n if isprime[i] is 1:\\n prime.append(i)\\n for j in range(1, maxn):\\n if i *", "gt": "j >= maxn:\\n break\\n isprime[i * j] = 0\\n divi[i] += fre[i * j]\\n\\nfor i in range(1, 10):\\n fact[i] = fact[i - 1] * i\\n\\nmobius = [0 for i in range(maxn)]\\n\\nfor i in range(1, maxn):\\n mobius[i] = 1\\nfor p in prime:\\n if p * p >= maxn:\\n break\\n x = p * p\\n for j in range(x, maxn, x):\\n mobius[j] = 0\\nfor p in prime:\\n for j in range(p, maxn, p):\\n mobius[j] *= -1 \\n \\nfor r in range(2, 10):\\n coprime = 0\\n for d in range(1, maxn):\\n ncr = nCr(divi[d], r)\\n coprime += mobius[d] * ncr\\n if coprime > 0:\\n print(r)\\n return\\nprint(-1)"}
{"id": "1846", "input": "import copy\\nimport fractions\\nimport itertools\\nimport numbers\\nimport string\\nimport sys\\n\\n###\\n\\ndef to_basex(num, x):\\n while num > 0:\\n yield num % x\\n num //= x\\n\\ndef from_basex(it, x):\\n ret = 0\\n p = 1\\n for d in it:\\n ret += d*p\\n p *= x\\n return ret\\n\\n###\\n\\ndef core():\\n n = int(input())\\n a =", "gt": "[int(x) for x in input().split()]\\n \\n m = min(a)\\n s = sum(a)\\n ans = s\\n for ai in a:\\n for d in range(1, ai+1):\\n if ai % d == 0:\\n cand = s - ai - m + ai//d + m*d\\n ans = min(ans, cand)\\n \\n print(ans)\\n\\n\\ncore()\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"}
{"id": "1847", "input": "import sys;\\nsys.stdin = open('input.txt', 'r')\\nsys.stdout = open('output.txt', 'w')\\nn=int(sys.stdin.readline());\\n\\na=[int(x) for x in sys.stdin.readline().split()]\\nfront=[0]*(len(a)+2)\\nfor i in range(n):\\n front[i+1]=front[i]+ (1 if", "gt": "(a[i]>=0) else 0 ) \\nback=[0]*(len(a)+2)\\nfor i in range(n-1,-1,-1):\\n back[i+1]=back[i+2]+ (1 if (a[i]<=0) else 0)\\nans=len(a)+1\\nfor i in range(1,n):\\n ans=min(ans,front[i]+back[i+1])\\nprint(\"%d\"%ans)\\n \\n"}
{"id": "1848", "input": "import sys\\nfrom collections import deque\\n\\ndef solve():\\n xadj, yadj = [0, 0, - 1, 1, -1, -1, 1, 1], [1, -1, 0, 0, -1, 1, -1, 1]\\n x0, y0, x1, y1, = rv()\\n n, = rv()\\n good = set()\\n visited = dict()\\n for seg in range(n):\\n r, a, b, = rv()\\n for c in range(a, b + 1): good.add((r, c))\\n points = deque()\\n points.append((x0, y0, 0))\\n visited[(x0, y0)] = 0\\n", "gt": "while len(points) > 0:\\n cur = points.popleft()\\n for i in range(8):\\n pos = (cur[0] + xadj[i], cur[1] + yadj[i])\\n if pos in good and pos not in visited:\\n points.append((pos[0], pos[1], cur[2] + 1))\\n visited[pos] = cur[2] + 1\\n print(visited[(x1, y1)] if (x1, y1) in visited else - 1)\\n\\n\\n\\n\\n\\n\\n\\ndef prt(l): return print(''.join(l))\\ndef rv(): return map(int, input().split())\\ndef rl(n): return [list(map(int, input().split())) for _ in range(n)]\\nif sys.hexversion == 50594544 : sys.stdin = open(\"test.txt\")\\nsolve()"}
{"id": "1849", "input": "from collections import defaultdict\\nn = int(input())\\nA = [int(x) for x in input().split()]\\nD = defaultdict(int)\\nfor a in A: D[a] += 1\\nS = set(D.keys())\\nans = len(S) -", "gt": "1\\nwhile S:\\n for k in D:\\n D[k] -= 1\\n if D[k] <= 0 and k in S:\\n S.remove(k)\\n ans += len(S) - 1\\nprint(ans + 1)\\n"}
{"id": "1850", "input": "n = int(input())\\nout = []\\n\\nMOD = 998244353 \\n\\nfor i in range(1, n + 1):\\n if i == n:\\n out.append(10)\\n else:\\n nex = 2 * 9 * pow(10, n - i - 1, MOD) * 10\\n if i < n", "gt": "- 1:\\n nex += (n - 1 - i) * 9 * 9 * pow(10, n - i - 2, MOD) * 10\\n out.append(nex % MOD)\\n \\n\\nprint(' '.join(map(str,out)))\\n#print(sum((i + 1) * out[i] for i in range(n)))\\n#print(n * pow(10, n, MOD))\\n"}
{"id": "1851", "input": "n,p=map(int,input().split())\\na=list(map(int,input().split()))\\nb=list(map(int,input().split()))\\nr=a[p-1]+b[0]\\ncou=0\\nfor i in range(p-1):\\n", "gt": "if a[i]+b[-1]<=r:\\n cou+=1;del b[-1]\\nprint(p-cou)"}
{"id": "1852", "input": "n = int(input())\\na = list(map(int, input().split()))\\nmaxi = 0\\nans = 0\\nfor i in range(n):\\n", "gt": "a[i] -= 1\\n maxi = max(maxi, a[i])\\n if maxi == i:\\n ans += 1\\nprint(ans)\\n"}
{"id": "1853", "input": "3\\n\\nimport array\\nimport math\\nimport os\\nimport sys\\n\\n\\nDEBUG = 'DEBUG' in os.environ\\n\\n\\ndef inp():\\n return sys.stdin.readline().rstrip()\\n\\n\\ndef dprint(*value, sep=' ', end='\\n'):\\n if DEBUG:\\n print(*value, sep=sep, end=end)\\n\\n\\ndef solve(N, M, G):\\n if N == 2:\\n return [0, 1]\\n\\n degv = [set() for _ in range(5)]\\n for i in range(M):\\n d = len(G[i])\\n if d == 0 or d >= 5:\\n return []\\n degv[d].add(i)\\n\\n layer_vcount = 1 << (N - 1)\\n vs = degv[1]\\n levels = bytearray(M)\\n ans = []\\n for level in range(1, N):\\n #dprint('level', level, [x for x in levels])\\n #dprint('vs', vs)\\n #dprint('layer_vcount', layer_vcount)\\n\\n if len(vs) not in (layer_vcount - 1, layer_vcount):\\n return []\\n if len(vs) == layer_vcount - 1:\\n if ans:\\n return []\\n if level == 1:\\n sp_deg_off = -1\\n else:\\n sp_deg_off = 1\\n else:\\n sp_deg_off = 0\\n #dprint('sp_deg_off', sp_deg_off)\\n\\n ndeg = 3 if level < N - 1 else 2\\n us = set()\\n ss = set()\\n\\n for v in vs:\\n #dprint('v', v)\\n levels[v] = level\\n p = None\\n for u in G[v]:\\n if levels[u] == 0:\\n", "gt": "if p is not None:\\n return []\\n p = u\\n break\\n #dprint(' p', p)\\n if p is None:\\n return []\\n deg = len(G[p])\\n #dprint(' deg', deg)\\n\\n if deg == ndeg:\\n us.add(p)\\n elif deg == ndeg + sp_deg_off:\\n ss.add(p)\\n elif sp_deg_off == 0 and deg == ndeg + 1:\\n ss.add(p)\\n else:\\n return []\\n\\n #dprint('us', us)\\n #dprint('ss', ss)\\n\\n if sp_deg_off != 0:\\n if len(ss) != 1:\\n return []\\n (sp,) = list(ss)\\n ans = [sp]\\n us.add(sp)\\n\\n if sp_deg_off == 0:\\n if level == N - 2:\\n if ss:\\n return []\\n if not ans:\\n li = list(us)\\n li.sort()\\n return li\\n if len(ss) > 1:\\n return []\\n\\n vs = us\\n layer_vcount >>= 1\\n\\n return ans\\n\\n\\ndef main():\\n N = int(inp())\\n M = (1 << N) - 2\\n G = [[] for _ in range(M)]\\n for _ in range(M - 1):\\n a, b = [int(e) - 1 for e in inp().split()]\\n G[a].append(b)\\n G[b].append(a)\\n\\n ans = solve(N, M, G)\\n print(len(ans))\\n if ans:\\n print(*[v + 1 for v in ans])\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1854", "input": "n, m= list(map(int, input().split()))\\ns=set()\\nfor i in range(m):\\n x,y=list(map(int, input().split()))\\n s.add((x,y))\\n\\nif m*2 == n*(n-1) or n<2 or n==2 and m==1:\\n print('NO')\\n return\\n\\nx, y = 0,0\\nfor i in range(1,n+1):\\n for j in range(i+1,n+1):\\n if", "gt": "(i, j) not in s and (j, i) not in s:\\n x=i\\n y=j\\n break\\nx-=1\\ny-=1\\nprint('YES')\\nl = list(range(1,n+1))\\nif x == 1:\\n y,x=x,y\\nif y == 0:\\n x, y=y,x\\nl[x], l[0] = 1, l[x]\\nl[y], l[1] = 2, l[y]\\nprint(*l)\\nl[y]=1\\nprint(*l)\\n"}
{"id": "1855", "input": "n=int(input())\\nl=[int(c) for c in input().split()]\\nll=[]\\nres=[]\\nhead=0\\ndia=0\\nfor i in range(1,n):\\n if l[i]==1:\\n l[i]=0\\n ll.append(i)\\n else:\\n res.append((head+1,i+1))\\n l[head]-=1\\n dia+=1\\n head=i\\n l[head]-=1\\nif l[head]>0 and len(ll)>0:\\n res.append((ll[0]+1,head+1))\\n l[head]-=1\\n del(ll[0])\\n dia+=1\\nif l[0]>0 and len(ll)>0:\\n", "gt": "res.append((ll[0]+1,1))\\n l[0]-=1\\n del(ll[0])\\n dia+=1\\nfor i in ll:\\n for j in range(n):\\n if l[j]>0:\\n res.append((j+1,i+1))\\n l[j]-=1\\n break\\nif len(res)<n-1:\\n print(\"NO\")\\nelse:\\n print(\"YES \"+str(dia))\\n print(n-1)\\n for p in res:\\n print(p[0],end =\" \")\\n print(p[1])"}
{"id": "1856", "input": "n,k=map(int,input().split())\\nL=list(map(int,input().split()))\\nind=[]\\nfor i in range(n):\\n if", "gt": "L[i]>n-k:ind.append(i)\\nm=1\\nfor i in range(len(ind)-1):\\n m*=(ind[i+1]-ind[i])\\n m%=998244353\\nprint(((n*(n+1)//2)-((n-k)*((n-k)+1))//2),m)"}
{"id": "1857", "input": "import sys\\ninput = sys.stdin.readline\\n\\nn = int(input())\\n\\ndef MakeSet(x):\\n x.parent = x\\n x.rank = 0\\n\\ndef Union(x, y):\\n xRoot = Find(x)\\n yRoot = Find(y)\\n if xRoot.rank > yRoot.rank:\\n yRoot.parent = xRoot\\n elif xRoot.rank < yRoot.rank:\\n xRoot.parent = yRoot\\n elif xRoot != yRoot:\\n yRoot.parent = xRoot\\n xRoot.rank = xRoot.rank + 1\\n\\ndef Find(x):\\n if x.parent == x:\\n return x\\n else:\\n x.parent = Find(x.parent)\\n return x.parent\\n\\nclass Node:\\n def __init__ (self, label):\\n self.label = label\\n def __str__(self):\\n return self.label\\n\\nused", "gt": "= [0] * 26\\nnodes = [Node(ch) for ch in range(26)]\\n[MakeSet(node) for node in nodes] \\n \\nfor _ in range(n):\\n s = input().strip()\\n prev = -1\\n for c in s:\\n val = ord(c) - 97\\n used[val] = 1\\n if prev != -1:\\n Union(nodes[prev], nodes[val])\\n prev = val\\n\\nouts = [0] * 26\\nfor node in nodes:\\n outs[Find(node).label] += 1\\n\\ncount = 0\\nfor val in outs:\\n if val != 0:\\n count += 1\\n\\nprint(count + sum(used) - 26)\\n \\n"}
{"id": "1858", "input": "n", "gt": "= int(input())\\n\\nprint((n*(n-1)*(n-2)*(n-3)*(n-4))**2//120)"}
{"id": "1859", "input": "n = int(input())\\nif n <= 2:\\n print(\"No\")\\nelse:\\n print(\"Yes\")\\n print(1, (n + 1) // 2)\\n ans = []\\n for", "gt": "i in range(1, n + 1):\\n if i != (n + 1) // 2:\\n ans.append(i)\\n print(n - 1, *ans)\\n"}
{"id": "1860", "input": "# \\nimport collections, atexit, math, sys, bisect \\n\\nsys.setrecursionlimit(1000000)\\ndef getIntList():\\n return list(map(int, input().split())) \\n\\ntry :\\n #raise ModuleNotFoundError\\n import numpy\\n def dprint(*args, **kwargs):\\n #print(*args, **kwargs, file=sys.stderr)\\n # in python 3.4 **kwargs is invalid???\\n print(*args, file=sys.stderr)\\n dprint('debug mode')\\nexcept Exception:\\n def dprint(*args, **kwargs):\\n pass\\n\\n\\n\\ninId = 0\\noutId = 0\\nif", "gt": "inId>0:\\n dprint('use input', inId)\\n sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\\nif outId>0:\\n dprint('use output', outId)\\n sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\\n atexit.register(lambda :sys.stdout.close()) #idle 中不会执行 atexit\\n \\nN, = getIntList()\\n#print(N)\\n\\nif N%2==0:\\n print(N//2)\\n return\\n\\nfor i in range(2,110000):\\n if N%i==0:\\n print( (N-i)//2 +1)\\n return\\n\\nprint(1)\\n\\n\\n"}
{"id": "1861", "input": "n =", "gt": "int(input())\\nprint(2**(n+1) - 2)\\n"}
{"id": "1862", "input": "def gen(a, b):\\n gener = ''\\n for i in range(k):\\n if a[i] == b[i]:\\n gener += a[i]\\n else:\\n if 'S' not in (a[i], b[i]):\\n gener += 'S'\\n elif 'E' not in (a[i], b[i]):\\n gener += 'E'\\n else:\\n gener += 'T'\\n return gener\\n\\n\\nn, k = list(map(int, input().split()))\\ncards = []\\ndiff = set()\\nfor", "gt": "i in range(n):\\n s = input()\\n cards.append(s)\\n diff.add(s)\\nans = 0\\nwas = set()\\nfor i in range(n):\\n for j in range(i + 1, n):\\n aaa = gen(cards[i], cards[j])\\n if aaa in diff and max(cards[i], cards[j], aaa) + min(cards[i], cards[j], aaa) not in was:\\n ans += 1\\n was.add(max(cards[i], cards[j], aaa) + min(cards[i], cards[j], aaa))\\nprint(ans)\\n"}
{"id": "1863", "input": "read = lambda: map(int, input().split())\\nn = int(input())\\na = list(read())\\nwas = [0] * (n + 1)\\nbal = ans = 0\\nfor", "gt": "i in a:\\n if was[i]:\\n bal -= 1\\n else:\\n bal += 1\\n was[i] = 1\\n ans = max(ans, bal)\\nprint(ans)"}
{"id": "1864", "input": "import sys\\n\\nn=int(sys.stdin.readline())\\nA=[]\\nB=[]\\ndiff=0\\nAns=\"\"\\nfor i in range(n):\\n x,y=list(map(int,sys.stdin.readline().split()))\\n if(diff+x<=500):\\n", "gt": "diff+=x\\n Ans+=\"A\"\\n else:\\n diff-=y\\n Ans+=\"G\"\\nif(abs(diff)<=500):\\n sys.stdout.write(Ans)\\nelse:\\n print(-1)\\n"}
{"id": "1865", "input": "#import sys\\n\\n#fin = open(\"input.txt\", 'r')\\n#fout = open(\"output.txt\", 'w')\\n\\n#fin = open(\"input.txt\", 'r')\\n#fout =", "gt": "open(\"output.txt\", 'w')\\n\\nn = int(input())\\na = list(map(int, input().split()))\\n\\nif 1 not in a:\\n print(1)\\nelse:\\n print(-1)\\n"}
{"id": "1866", "input": "import operator\\n\\n\\nn = int(input())\\nxs = list(map(int, str.split(input())))\\nif xs == sorted(xs):\\n\\n print(0)\\n\\nelse:\\n\\n swaps = []\\n counter = 0\\n while xs:\\n\\n i =", "gt": "xs.index(min(xs))\\n if i:\\n\\n swaps.append(str.format(\""}
{"id": "1867", "input": "n = int(input())\\nout = []\\ndef p(a,b,d):\\n out.append(str(a + 1 + d) + ' ' + str(b+1+d))\\n\\np2 = 1\\nwhile 2 * p2 <= n:\\n p2 *= 2\\n\\nfor d in", "gt": "(0, n - p2):\\n bit = 1\\n while bit < p2:\\n for i in range(p2):\\n if i ^ bit > i:\\n p(i, i ^ bit, d)\\n bit *= 2\\nprint(len(out))\\nprint('\\n'.join(out))\\n"}
{"id": "1868", "input": "import collections\\n\\nn = int(input())\\nAs = list(map(int, input().split()))\\n\\ndef solve(n, As):\\n counter = collections.Counter(As)\\n candidates = []\\n prev_freq = 0\\n for num, freq in counter.most_common():\\n if prev_freq and prev_freq!= freq:\\n break\\n candidates.append(num)\\n prev_freq = freq\\n lr = {cand:[] for cand", "gt": "in candidates}\\n for i, a in enumerate(As, 1):\\n if a in lr:\\n lr[a].append(i)\\n minspan = float('inf')\\n for pos in list(lr.values()):\\n if pos[-1] - pos[0] < minspan:\\n minspan = pos[-1] - pos[0]\\n LR = (pos[0], pos[-1])\\n return LR\\n\\nprint(*solve(n, As))\\n"}
{"id": "1869", "input": "n,m,a=map(int,input().split())\\nb=list(map(int,input().split()))\\nfor i in range(m):\\n if i==0:\\n diffs=[b[0]]\\n else:\\n diffs.append(b[i]-b[i-1])\\npowers=[a%998244353]\\nfor i in range(30):\\n powers.append(powers[-1]**2%998244353)\\ndef power(x,y,binpowers):\\n prod=1\\n bits=bin(y)[2:]\\n bits=bits[::-1]\\n", "gt": "for i in range(len(bits)):\\n if bits[i]==\"1\":\\n prod*=binpowers[i]\\n prod%=998244353\\n return prod\\nmaxi=b[-1]\\nprod1=power(a,n-2*maxi,powers)\\nfor guy in diffs:\\n newprod=power(a,guy,powers)\\n newprod=(newprod*(newprod+1))//2\\n newprod%=998244353\\n prod1*=newprod\\n prod1%=998244353\\nprint(prod1)"}
{"id": "1870", "input": "\\nfrom sys import stdin\\n\\nn = int(stdin.readline())\\na = list(map(int,stdin.readline().split()))\\na = [0] + a\\n\\nans = n\\n\\ndp = [float(\"inf\")] * (n+1)\\ndp[0] = 0\\nfor i in range(1,n+1):\\n\\n nmin = float(\"inf\")\\n for j in", "gt": "range(i-1,-1,-1):\\n if a[j] <= nmin:\\n dp[i] = min(dp[i] , dp[j] + max(0,a[i]-a[j]) + (i-j-1) )\\n nmin = min(nmin,a[j])\\n\\n#print (dp)\\nfor i in range(n+1):\\n ans = min(ans , dp[i] + n-i)\\nprint (ans)\\n\\n"}
{"id": "1871", "input": "read = lambda: list(map(int, input().split()))\\nn, c = read()\\nt = list(read())\\ncnt = 1\\nfor i in range(1,", "gt": "n):\\n if t[i] - t[i - 1] > c:\\n cnt = 1\\n else:\\n cnt += 1\\nprint(cnt)\\n"}
{"id": "1872", "input": "\"\"\"\\nCodeforces Round 251 Div 2 Problem B\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\ndef read(mode=2):\\n # 0: String\\n # 1: List of strings\\n # 2: List of integers\\n inputs = input().strip()\\n if mode == 0:\\n return inputs\\n if mode", "gt": "== 1:\\n return inputs.split()\\n if mode == 2:\\n return [int(x) for x in inputs.split()]\\n\\ndef write(s=\"\\n\"):\\n if isinstance(s, list): s = \" \".join(s)\\n s = str(s)\\n print(s, end=\"\")\\n\\n################################################### SOLUTION\\nn,x = read()\\nc = read()\\nc.sort()\\nprint(sum(max(x-i,1)*c[i] for i in range(n)))"}
{"id": "1873", "input": "from math import sin, cos, pi\\n\\nn, r = map(int, input().split())\\n\\nprint(n * r**2 * sin(pi / n) *", "gt": "cos(pi * (n // 2) / n) / cos(pi * (n // 2 - 1) / n))"}
{"id": "1874", "input": "a, b = map(int, input().split(' '))\\nl = list(map(int, input().split(' ')))\\nstot = 0\\nssq =", "gt": "0\\nfor i in range(1, b+1):\\n stot += l.count(i)\\n ssq += (l.count(i)**2)\\n\\nprint(int((stot**2 - ssq)/2))"}
{"id": "1875", "input": "from math import sqrt\\n\\na, b, c = list(map(int, input().split()))\\n# a, b, c = 2, 5, 3\\n\\nV1 = a ** 3 * sqrt(2) /", "gt": "12\\nV2 = sqrt(2) * (b ** 3) / 6\\nV3 = ((5 + sqrt(5)) / 24) * (c ** 3)\\n\\nprint(V1 + V2 + V3)\\n"}
{"id": "1876", "input": "# calculate convex of polygon v.\\n# v is list of complexes stand for points.\\ndef convex(v, eps=1e-8):\\n\\n # fetch the seed point\\n v.sort(key=lambda x:(x.real,x.imag))\\n v = v[0:1] + sorted(v[1:], key=lambda x:(x-v[0]).imag/abs(x-v[0]))\\n\\n n = 1\\n for i in range(2, len(v)):\\n while n > 1 and ((v[n]-v[n-1])*(v[i]-v[n]).conjugate()).imag>-eps:\\n n -= 1\\n else:\\n n += 1\\n v[n] = v[i]\\n\\n v[n+1:] = []\\n\\n return v\\n\\n# calculate the area of a polygon v, anti-clockwise.\\n# v is list of complexes stand for points.\\ndef area(v):\\n ans = 0\\n for i in range(2, len(v)):\\n ans += ((v[i]-v[i-1])*(v[i-1]-v[0]).conjugate()).imag\\n return ans * 0.5\\n\\nn = int(input())\\nv = [complex(*tuple(map(int, input().split()))) for i in range(0, n)]\\n\\nw = convex(v)\\nn = len(w)\\n\\nans = 0\\n\\ndef tri(i, j, k): return abs(((w[i]-w[j])*(w[i]-w[k]).conjugate()).imag) * 0.5\\n\\nfor i in", "gt": "range(0, n):\\n \\n for j in range(i+2, n):\\n\\n if i == 0 and j == n-1: continue\\n \\n l = i + 1\\n r = j\\n while l < r-1:\\n k = l+r>>1\\n if tri(i, j, k) > tri(i, j, k-1):\\n l = k\\n else:\\n r = k\\n \\n s1 = tri(i, j, l)\\n\\n l = j - n + 1\\n r = i\\n while l < r-1:\\n k = l+r>>1\\n if tri(i, j, k) > tri(i, j, k-1):\\n l = k\\n else:\\n r = k\\n \\n s2 = tri(i, j, l)\\n\\n ans = max(ans, s1 + s2)\\n\\nif n == 3:\\n for p in v:\\n if not p in w:\\n w.append(p)\\n ans = max(ans, area(w))\\n w.pop()\\n \\nprint(ans)\\n"}
{"id": "1877", "input": "rr = lambda: input().strip()\\nrri = lambda: int(rr())\\nrrm = lambda: list(map(int, rr().split()))\\nMOD = 10**9 + 7\\n\\nclass DSU:\\n def __init__(self, N):\\n #R * C is the source, and isn't a grid square\\n self.par = list(range(N+1))\\n self.rnk = [0] * (N+1)\\n self.sz = [1] * (N+1)\\n\\n def find(self, x):\\n if self.par[x] != x:\\n self.par[x] = self.find(self.par[x])\\n return self.par[x]\\n\\n def union(self, x, y):\\n xr, yr = self.find(x), self.find(y)\\n if xr == yr: return\\n if self.rnk[xr] < self.rnk[yr]:\\n xr, yr = yr, xr\\n if self.rnk[xr]", "gt": "== self.rnk[yr]:\\n self.rnk[xr] += 1\\n\\n self.par[yr] = xr\\n self.sz[xr] += self.sz[yr]\\n\\n def size(self, x):\\n return self.sz[self.find(x)]\\n \\ndef solve(N, K, edges):\\n graph = [[] for _ in range(N)]\\n dsu = DSU(N)\\n for u,v,w in edges:\\n u-=1;v-=1\\n if w==0: #red\\n dsu.union(u, v)\\n\\n ans = pow(N, K, MOD)\\n for x in range(N):\\n if dsu.find(x) == x:\\n ans -= pow(dsu.size(x), K, MOD)\\n ans %= MOD\\n return ans\\n\\nfor tc in range(1):#rri()):\\n N, K = rrm()\\n edges = [rrm() for _ in range(N-1)]\\n print(solve(N, K, edges))\\n"}
{"id": "1878", "input": "n = int(input())\\ns = input()\\nx = 0\\ny = 0\\nans = 0\\npred = -1\\nfor c in s:\\n if c == 'U':\\n y += 1\\n else:\\n x += 1\\n if", "gt": "x == y:\\n continue\\n if x > y:\\n cur = 0\\n else:\\n cur = 1\\n if cur != pred and pred != -1:\\n ans += 1\\n pred = cur\\nprint(ans)\\n"}
{"id": "1879", "input": "n = int(input())\\nr = 0\\nfor i in range(n):\\n a = list(map(int, input().split(' ')))\\n", "gt": "r += (a[2] - a[0] + 1) * (a[3] - a[1] + 1)\\nprint(r)"}
{"id": "1880", "input": "t, sx, sy, ex, ey = map(int, input().split())\\nd = {'W':max(0, sx - ex), 'E':max(0, ex - sx), 'N':max(0, ey - sy), 'S':max(0,", "gt": "sy - ey)}\\nfor (i, c) in enumerate(input(), 1):\\n if d[c] > 0:\\n d[c] -= 1\\n if any(d.values()) == False:\\n print(i)\\n break\\nelse:\\n print(-1)"}
{"id": "1881", "input": "s = input()\\n\\nx = int(s[0] +", "gt": "s[2] + s[4] + s[3] + s[1])\\nprint(str(x**5)[-5:])"}
{"id": "1882", "input": "def getIntList():\\n return list(map(int, input().split()));\\nn, k = getIntList();\\np=getIntList();\\nchoosed=[False]*256;\\nleft=[i for i in range(256)];\\nfor i, x in enumerate(p):\\n if not choosed[x]:\\n best=x;\\n #print(x-1, max(-1, x-k));\\n for j inrange(x-1, max(-1, x-k), -1):\\n #print('try ',j)\\n if not choosed[j]:\\n best=j;\\n else:\\n if", "gt": "x-left[j]<k:\\n best=left[j];"}
{"id": "1883", "input": "# -*- coding: utf-8 -*-\\n\"\"\"\\nCreated on Mon Jan 8 10:20:50 2018\\n\\n@author: yanni\\n\"\"\"\\n\\n#import random\\n\\nn, T = [int(x) for x in input().split()]\\n#n, T = [100000,10000*10000]\\nprob = []\\nvals = [set() for stuff in range(n+2)]\\nfor i in range(n):\\n a, t = [int(x) for x in input().split()]\\n #a = random.randint(1,n)\\n #t = random.randint(1, 10000)\\n prob.append((i+1,a,t))\\nprob.sort(key = lambda tup: tup[2])\\ncurrindex = 0\\nmaxindex = -1\\nsolve = set()\\nmem = set()\\ntimeleft = T\\ntarget =", "gt": "1\\n\\nfor currindex in range(n):\\n i, a, t = prob[currindex]\\n if (timeleft < t):\\n break\\n if (timeleft >= t and a >= target):\\n vals[a].add(currindex)\\n solve.add(currindex)\\n timeleft -= t\\n if (len(solve) == target):\\n maxindex = currindex\\n #print(target)\\n for p in vals[target]:\\n solve.remove(p)\\n timeleft += prob[p][2]\\n target += 1\\n\\nbestsolve = solve | vals[target-1]\\nsolvelist = [x for x in bestsolve if x<=maxindex]\\ntarget = len(solvelist)\\nprint(target)\\nprint(target)\\nfor p in solvelist:\\n print(prob[p][0], end=\" \")\\nprint()"}
{"id": "1884", "input": "import sys\\ndef Z(s):\\n return int(s)-1\\n\\nn=int(sys.stdin.readline())\\n\\nHotels=[False]*(n)\\n\\nRep=[0]*(n+1)\\nChains=[]\\n\\nType=list(map(int,sys.stdin.readline().split()))\\nfor i in range(n):\\n if(Type[i]==1):\\n Hotels[i]=True\\nA=list(map(Z,sys.stdin.readline().split()))\\n\\nfor item in A:\\n Rep[item]+=1\\nfor i in range(n):\\n if(Hotels[i]):\\n Chains.append([i])\\n x=A[i]\\n if(x==-1):\\n continue\\n", "gt": "while(A[x]!=-1 and Rep[x]<=1):\\n Chains[-1].append(x)\\n x=A[x]\\n if(Rep[x]<=1):\\n Chains[-1].append(x)\\n\\n\\n \\n \\nif(n==1):\\n print(1)\\n print(1)\\nelse:\\n \\n X=max(Chains,key=len)\\n\\n\\n\\n sys.stdout.write(str(len(X))+\"\\n\")\\n sys.stdout.write(str(X[-1]+1))\\n\\n for i in range(len(X)-2,-1,-1):\\n sys.stdout.write(\" \"+str(X[i]+1)) \\n \\n"}
{"id": "1885", "input": "# python3\\n\\ndef readline(): return tuple(map(int, input().split()))\\n\\n\\ndef ceil_div(num, den): return (num - 1) // den + 1\\n\\n\\ndef main():\\n n, x1, x2 = readline()\\n c = readline()\\n\\n xx = (x1, x2)\\n\\n servers = sorted(enumerate(c, start=1), key=lambda p: p[1])\\n for (i, a) in enumerate(servers):\\n for (j, x) in enumerate(xx):\\n kj = ceil_div(x, a[1])\\n if", "gt": "i + kj < n and (n - i - kj) * servers[i + kj][1] >= sum(xx) - x:\\n print(\"Yes\")\\n l1 = servers[i:i+kj]\\n l2 = servers[i+kj:]\\n if j: l1, l2 = l2, l1\\n print(len(l1), len(l2))\\n print(\" \".join(str(d[0]) for d in l1))\\n print(\" \".join(str(d[0]) for d in l2))\\n return\\n print(\"No\")\\n\\n\\nmain()\\n\\n\\n\\n\\n# Made By Mostafa_Khaled\\n"}
{"id": "1886", "input": "n = int(input())\\nans = 0\\nans = ans + (n * (n-1) * (n-2) * (n-3) * (n-4)) // (2*3*4*5)\\nans = ans + (n * (n-1) *", "gt": "(n-2) * (n-3) * (n-4) * (n-5)) // (2*3*4*5*6)\\nans = ans + (n * (n-1) * (n-2) * (n-3) * (n-4) * (n-5) * (n-6)) // (2*3*4*5*6*7)\\nprint(ans)"}
{"id": "1887", "input": "s = str(input())\\ns", "gt": "= (s[:1].upper() + s[1:]).rstrip()\\nprint(s)\\n"}
{"id": "1888", "input": "n = int(input())\\nh1 = list(map(int, input().split()))\\nh2 = list(map(int, input().split()))\\n\\nr1 = r2 = 0\\nfor i", "gt": "in range(n):\\n r1, r2 = max(r1, r2 + h1[i]), max(r2, r1 + h2[i])\\n\\nprint(max(r1, r2))\\n"}
{"id": "1889", "input": "data = input().split(\" \")\\nn = int(data[0])\\nm = int(data[1])\\ndebts = []\\ntotal = 0\\nfor i in range(n):\\n debts.append(0)\\nfor i in range(m):\\n data = input().split(\" \")\\n", "gt": "data = [int(x) for x in data]\\n debts[data[0]-1] -= data[2]\\n debts[data[1]-1] += data[2]\\n\\nfor i in range(len(debts)):\\n if debts[i] < 0:\\n total += (debts[i]*-1)\\n\\nprint(total)"}
{"id": "1890", "input": "def cons(l):\\n m = 0\\n res = 0\\n for v in l:\\n if v:\\n res += 1\\n if res > m:\\n m = res\\n else:\\n res = 0\\n return m\\n\\nn, m, q = list(map(int, input().split()))\\ngrid = []\\ncurr", "gt": "= [0] * n\\nfor i in range(n):\\n grid.append(list(map(int, input().split())))\\n curr[i] = cons(grid[i])\\n\\nfor _ in range(q):\\n i, j = list(map(int, input().split()))\\n i -= 1\\n j -= 1\\n grid[i][j] = 0 if grid[i][j] else 1\\n curr[i] = cons(grid[i])\\n print(max(curr))\\n"}
{"id": "1891", "input": "a = input()\\nk = int(input())\\nn = len(a)\\nans = 0\\nMOD = 10 ** 9 + 7\\nm = 1 - pow(2, n * k, MOD)\\nm *= pow(1 - pow(2, n, MOD), MOD - 2, MOD)\\nm %= MOD\\nfor", "gt": "i in range(n - 1, -1, -1):\\n if a[i] == '0' or a[i] == '5': \\n ans += (m * pow(2, i, MOD)) % MOD\\nans = ans % MOD\\nif ans < 0:\\n ans += MOD\\nprint(ans)\\n \\n"}
{"id": "1892", "input": "ii = lambda: int(input())\\nmi = lambda: list(map(int, input().split()))\\nli = lambda: list(mi())\\nfrom bisect import bisect_left as lb, bisect_right as ub\\n\\nn, k, A, B = mi()\\na = li()\\na.sort()\\n\\ndef f(l, r):\\n cnt = ub(a, r) - lb(a, l)\\n if cnt ==", "gt": "0:\\n return A\\n if l == r:\\n return B * cnt\\n m = (l + r) >> 1\\n return min(B * cnt * (r - l + 1), f(l, m) + f(m + 1, r))\\n\\nprint(f(1, 2 ** n))\\n"}
{"id": "1893", "input": "n = int(input())\\ndp = [0] * (n + 1)\\nmaxlev = 0\\nmod = 1000000007\\nlst = \"s\"\\ndp[0] = 1\\nfor i in range(n):\\n s = input()\\n if lst == \"f\":\\n for j in reversed(range(1, maxlev+2)):\\n dp[j] = dp[j-1]\\n maxlev += 1\\n dp[0]", "gt": "= 0\\n else:\\n sum = 0\\n for j in reversed(range(0, maxlev+1)):\\n sum = (sum + dp[j]) % mod\\n dp[j] = sum\\n lst = s\\nres = 0\\nfor i in range(0, maxlev + 1):\\n res = (res + dp[i]) % mod\\nprint(res)"}
{"id": "1894", "input": "n, t =", "gt": "map(int, input().split())\\nprint(n*pow(1.000000011, t))"}
{"id": "1895", "input": "import sys\\nfrom math import *\\n\\ndef minp():\\n return sys.stdin.readline().strip()\\n\\ndef mint():\\n return int(minp())\\n\\ndef mints():\\n return map(int, minp().split())\\n\\nn, m = mints()\\na = list(minp())\\nx = 0\\nt = 0\\nd = 1\\nfor i in range(n-1):\\n b = list(minp())\\n l = x\\n r = x\\n wall = 0\\n while True:\\n t += 1\\n if b[x] == '.':\\n break\\n if x + d == m or x + d < 0 or a[x+d] ==", "gt": "'#':\\n wall += 1\\n d = -d\\n if wall == 2:\\n print(\"Never\")\\n return\\n elif a[x+d] == '+':\\n wall = 0\\n a[x+d] = '.'\\n d = -d\\n elif l <= x+d and x+d <= r:\\n if d == 1:\\n t += r-x-1\\n x = r\\n else:\\n t += x-l-1\\n x = l\\n else:\\n x += d\\n r = max(r,x)\\n l = min(l,x)\\n a, b = b, a\\nprint(t)"}
{"id": "1896", "input": "import time\\n\\nn, m =map(int, input().split())\\n\\nnames={None:0}\\n\\ncount={i:0 for i in range(1, m+1)}\\n\\na=[0]*(n+1)\\n\\nfor i in range(n):\\n l=list(input().split())\\n if l[0]=='2':\\n if l[1] not in names:\\n names[l[1]]=len(names)\\n a[i]=names[l[1]]\\n count[a[i]]=count[a[i]]+1\\n # else a[i] stays 0\\n\\ndense=[set() for _ in range(m+1)]\\n\\nbulk=set()\\n\\n# filling dense array of arrays\\nfor i in range(n):\\n if a[i]==0:\\n bulk.clear()\\n continue\\n if a[i] in bulk: continue\\n for j in bulk:\\n dense[j].add(a[i])\\n dense[a[i]].add(j)\\n bulk.add(a[i])\\n\\nres=0\\nhappy=set()\\nunhappy=set()\\nmindep=99\\n\\nindependent=set()\\ndependent=set()\\nfor i in range(1, m+1):\\n if len(dense[i])==0: independent.add(i)\\n else:\\n dependent.add(i)\\n if len(dense[i])<mindep:\\n mindep=len(dense[i])\\n\\n#", "gt": "print([i for i in dependent if mindep==len(dense[i])])\\n\\nfor k in list(dependent):\\n # iterate to... too sly\\n happy.clear()\\n unhappy.clear()\\n bulk.clear()\\n bulk.update(dependent)\\n happy.add(k)\\n bulk.remove(k)\\n for j in dense[k]:\\n if j in bulk:\\n unhappy.add(j)\\n bulk.remove(j)\\n\\n # now making least connected happy\\n while bulk:\\n mini = min([len(dense[i]) for i in bulk])\\n for i in list(bulk):\\n if len(dense[i])==mini and (i in bulk):\\n happy.add(i)\\n bulk.remove(i)\\n for j in dense[i]:\\n if j in bulk:\\n unhappy.add(j)\\n bulk.remove(j)\\n continue\\n\\n res=max(res,len(happy))\\n\\nprint(res+len(independent))"}
{"id": "1897", "input": "n", "gt": "= int(input())\\nprint(3*n*(n+1)+1)"}
{"id": "1898", "input": "arr = []\\nfor i in input():\\n arr.append(i)\\nn = len(arr)\\nres = 0\\nadd = [0] * (n + 10)\\nadd[n] = 1 / n\\nfor i in range(n - 1, 0, -1):\\n add[i] = add[i + 1] + 1 / i\\nfor i in range(n):\\n if arr[i] in ['I', 'E', 'A', 'O', 'U',", "gt": "'Y']:\\n x = min(i, n - i - 1)\\n y = max(i, n - i - 1)\\n res += x + 1\\n res += (x + 1) * (add[x + 2] - add[y + 1])\\n res += (n + 1) * add[y + 1] - (n - y)\\nprint(res)"}
{"id": "1899", "input": "n = int(input())\\nfor i in range(1,n):\\n if i%2 == 1:\\n print('I hate that',end=' ')\\n else:\\n", "gt": "print('I love that',end=' ')\\nif n%2 == 1:\\n print('I hate it',end=' ')\\nelse:\\n print('I love it',end=' ')"}
{"id": "1900", "input": "n, s, m, k = map(int, input().split())\\na = list(map(int, input().split()))\\nnt = [-1 for i in range(n+1)]\\nfor i in range(s):\\n l, r = map(int, input().split())\\n l-=1\\n for j in range(l, r):\\n nt[j] = max(nt[j], r)\\n\\ndp = [[0 for i in range(m+1)] for i in range(n+1)]\\nsum = [0 for i in range(n+1)]\\ndef solve(mid):\\n for i in range(n+1):\\n for j in range(m+1):\\n dp[i][j] = 0\\n for i in range(n):\\n if a[i] <= mid:\\n", "gt": "sum[i+1] = 1\\n else:\\n sum[i+1] = 0\\n sum[i+1] += sum[i]\\n for i in range(0, n+1):\\n for j in range(m+1):\\n if i > 0:\\n dp[i][j] = max(dp[i][j], dp[i-1][j])\\n if nt[i] != -1 and j < m:\\n dp[nt[i]][j+1] = max(dp[nt[i]][j+1], dp[i][j] + sum[nt[i]] - sum[i])\\n return dp[n][m]\\n\\nlo, hi, ans = 1, 10**9, -1\\nwhile lo <= hi:\\n mid = (lo+hi)//2\\n if(solve(mid) >= k):\\n ans = mid\\n hi = mid-1\\n else:\\n lo = mid+1\\n\\nprint(ans)"}
{"id": "1901", "input": "def main():\\n _, k, m = [int(x) for x in input().split()]\\n a = []\\n last = (\"-1\", 0)\\n a.append(last)\\n for ai in input().split():\\n if last[0] == ai:\\n last = (ai, last[1]+1)\\n a[-1] = last\\n else:\\n last = (ai, 1)\\n a.append(last)\\n\\n if last[1] == k:\\n a.pop()\\n last = a[-1]\\n a.pop(0)\\n\\n s1 = 0\\n while len(a) > 0 and a[0][0] == a[-1][0]:\\n if len(a) == 1:\\n s = a[0][1] * m\\n", "gt": "r1 = s % k\\n if r1 == 0:\\n print(s1 % k)\\n else:\\n print(r1 + s1)\\n return\\n join = a[0][1] + a[-1][1]\\n\\n if join < k:\\n break\\n elif join % k == 0:\\n s1 += join\\n a.pop()\\n a.pop(0)\\n else:\\n s1 += (join // k) * k\\n a[0] = (a[0][0], join % k)\\n a.pop()\\n break\\n\\n s = 0\\n for ai in a:\\n s += ai[1]\\n\\n print(s*m + s1)\\n\\n\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "1902", "input": "#python3\\n# utf-8\\n\\nnodes_nr, edges_nr = (int(x) for x in input().split())\\nnode_idx___cost = [int(x) for x in input().split()]\\nnode_idx___neigh_idxes = [[] for x in range(nodes_nr)]\\nfor _ in range(edges_nr):\\n node1_idx, node2_idx = (int(x) - 1 for x in input().split())\\n node_idx___neigh_idxes[node1_idx].append(node2_idx)\\n node_idx___neigh_idxes[node2_idx].append(node1_idx)\\n\\nnode_idx___is_visited = [False for x in", "gt": "range(nodes_nr)]\\n\\nans = 0\\nfor node_idx in range(nodes_nr):\\n if node_idx___is_visited[node_idx]:\\n continue\\n stack = [node_idx]\\n node_idx___is_visited[node_idx] = True\\n cheapest_cost = node_idx___cost[node_idx]\\n while stack:\\n curr_node_idx = stack.pop()\\n for neigh_idx in node_idx___neigh_idxes[curr_node_idx]:\\n if node_idx___is_visited[neigh_idx]:\\n continue\\n stack.append(neigh_idx)\\n cheapest_cost = min(cheapest_cost, node_idx___cost[neigh_idx])\\n node_idx___is_visited[neigh_idx] = True\\n ans += cheapest_cost\\nprint(ans)\\n"}
{"id": "1903", "input": "class Ddict:\\n def __init__(self):\\n self.dicts={}\\n def add(self,key):\\n d=self.dicts\\n for i in key:\\n if i not in d:\\n d[i]={}\\n d=d[i]\\n d[' ']=''\\n def find(self,key):\\n if key=='':\\n return '',''\\n d=self.dicts\\n q=[]\\n h=[key[0]]\\n for i in key:\\n if i not in d:\\n if ' ' in d and len(d)==1:\\n return ''.join(q),''.join(h)\\n return '',''\\n q.append(i)\\n if len(d)!=1:\\n h=q[:]\\n d=d[i]\\n", "gt": "if ' ' in d and len(d)==1:\\n return ''.join(q),''.join(h)\\n return '',''\\nwords = Ddict()\\nans=0\\nwhile True:\\n try:\\n x=input()\\n if not x:\\n break\\n except:\\n break\\n ans+=len(x)+1\\n ws=[[]]\\n for i in x:\\n if i in '.,?!\\'- ':\\n if ws[-1]:\\n ws.append([])\\n else:\\n ws[-1].append(i)\\n ws=list([''.join(e) for e in ws])\\n for w in ws:\\n next_word,helped_word = words.find(w)\\n if next_word and next_word!=helped_word:\\n ans-=len(next_word)-len(helped_word)-1\\n words.add(w)\\nprint(ans)\\n"}
{"id": "1904", "input": "n, m, d = list(map(int, input().split()))\\n\\na = []\\nb = []\\n\\nfor i in range(n):\\n a.append(list(map(int, input().split())))\\n\\nfor i in range(m):\\n b.append(list(map(int, input().split())))\\n\\na = sorted(a, key=lambda x: x[0] + (1- x[1] * 1e-10))\\nb = sorted(b, key=lambda x: x[0] + (1- x[1] * 1e-10))\\n\\ntc, td = 0, 0\\n\\ntc += a[-1][0]\\ntc += b[-1][0]\\ntd += a[-1][1]\\ntd += b[-1][1]\\n\\nai = n - 1\\nbi = m - 1\\n\\nif td > d:\\n print(0)\\n return\\n\\nwhile ai > 0:\\n t =", "gt": "ai - 1\\n if td + a[t][1] <= d:\\n td += a[t][1]\\n tc += a[t][0]\\n ai -= 1\\n continue\\n else:\\n break\\n \\ncmax = tc\\n\\nwhile bi > 0:\\n bi -= 1\\n tc += b[bi][0]\\n td += b[bi][1]\\n \\n while td > d and ai < n:\\n tc -= a[ai][0]\\n td -= a[ai][1]\\n ai += 1\\n \\n if ai == n:\\n break\\n \\n if td <= d:\\n cmax = max(cmax, tc)\\n \\nprint(cmax)"}
{"id": "1905", "input": "input()\\nres_h = 0\\nres_ha = 0\\nres_har = 0\\nres_hard = 0\\nfor s, a in zip(input(), list(map(int, input().split()))):\\n if s == 'h':\\n res_h += a\\n elif s == 'a':\\n", "gt": "res_ha = min(res_ha + a, res_h)\\n elif s == 'r':\\n res_har = min(res_har + a, res_ha)\\n elif s == 'd':\\n res_hard = min(res_hard + a, res_har)\\nprint(res_hard)\\n"}
{"id": "1906", "input": "nmq = input().split(' ')\\nn, m, q = int(nmq[0]), int(nmq[1]), int(nmq[2])\\nmt = []\\nfor i in range(0, n):\\n mt.append([])\\n for j in range(0, m):\\n mt[-1].append((i, j))\\nres = []\\nfor i in range(0, n):\\n res.append([])\\n for j in range(0, m):\\n res[-1].append(0)\\nfor i in range(0, q):\\n ins = input().split(' ')\\n if ins[0] == '1':\\n r = int(ins[1]) - 1\\n b = mt[r][0]\\n for j in range(0, m-1):\\n mt[r][j] =", "gt": "mt[r][j+1]\\n mt[r][m-1] = b\\n if ins[0] == '2':\\n c = int(ins[1]) - 1\\n b = mt[0][c]\\n for j in range(0, n-1):\\n mt[j][c] = mt[j+1][c]\\n mt[n-1][c] = b\\n if ins[0] == '3':\\n r = int(ins[1]) - 1\\n c = int(ins[2]) - 1\\n x = int(ins[3])\\n p = mt[r][c]\\n res[p[0]][p[1]] = x\\nfor i in range(0, n):\\n for j in range(0, m-1):\\n print(res[i][j],' ', end='')\\n print(res[i][-1])\\n \\n"}
{"id": "1907", "input": "n = int(input())\\na = [2, 3 ,5, 7]\\nans = 0\\nimport operator\\nimport itertools\\nimport functools\\nfor i in range(1, 5):\\n for p", "gt": "in itertools.combinations(a, i):\\n x = functools.reduce(operator.mul, p)\\n ans += (-1) ** (i + 1) * (n // x)\\n\\nprint(n - ans)\\n"}
{"id": "1908", "input": "import sys\\n\\ndef inside(a,b):\\n return ((a[0]-b[0])**2 + (a[1]-b[1])**2) < (a[2]+b[2])**2\\n\\n\\ndef main():\\n pi = 3.14159265358979323\\n n = int(sys.stdin.readline())\\n a = []\\n p = [-1]*n\\n for i in range(n):\\n x,y,r = map(int,sys.stdin.readline().split())\\n a.append([x,y,r])\\n\\n for i in range(n):\\n for j in range(n):\\n if i==j :\\n continue\\n if inside(a[i],a[j]):\\n if a[i][2] < a[j][2]:\\n if p[i] == -1:\\n p[i] = j\\n elif a[p[i]][2]>a[j][2]:\\n p[i] = j\\n else:\\n if p[j] == -1:\\n p[j] = i\\n elif a[p[j]][2]>a[i][2]:\\n p[j] = i\\n\\n q", "gt": "= []\\n for i in range(n):\\n if p[i] == -1:\\n q.append((i,True))\\n\\n s = len(q)\\n ans = 0.0\\n for i in range(s):\\n c, b = q[i]\\n for j in range(n):\\n if p[j] == c:\\n q.append((j,True))\\n ans+= pi * a[c][2] * a[c][2]\\n\\n q = q[s:]\\n while len(q)!=0 :\\n c,b = q.pop()\\n for j in range(n):\\n if p[j] == c:\\n q.append((j,not b))\\n if b:\\n ans+= pi * a[c][2] * a[c][2]\\n else:\\n ans-= pi * a[c][2] * a[c][2]\\n\\n print(ans)\\n\\n\\nmain()"}
{"id": "1909", "input": "def xmax(x, y):\\n if x[1] > y[1]:\\n return x\\n return y\\n\\nclass SegTree:\\n def __init__(self, init_val, n, ide_ele, seg_func):\\n self.segfunc = seg_func\\n self.num = 2**(n-1).bit_length()\\n self.ide_ele = ide_ele\\n self.seg=[self.ide_ele]*2*self.num\\n for i in range(n):\\n self.seg[i+self.num-1]=init_val[i] \\n for i in range(self.num-2,-1,-1) :\\n self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) \\n \\n def update(self, k, x):\\n ll = k\\n k += self.num-1\\n self.seg[k] = (ll, self.seg[k][1] + x)\\n while k+1:\\n k = (k-1)//2\\n self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\\n\\n def update2(self, k, x):\\n k += self.num-1\\n self.seg[k] = x\\n while k+1:\\n k = (k-1)//2\\n self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\\n \\n def query(self, p, q):\\n if q<=p:\\n return self.ide_ele\\n p += self.num-1\\n q += self.num-2\\n res=self.ide_ele\\n while q-p>1:\\n if p&1 == 0:\\n res = self.segfunc(res,self.seg[p])\\n if q&1 == 1:\\n res = self.segfunc(res,self.seg[q])\\n q", "gt": "-= 1\\n p = p//2\\n q = (q-1)//2\\n if p == q:\\n res = self.segfunc(res,self.seg[p])\\n else:\\n res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])\\n return res\\n\\nimport sys;input=sys.stdin.readline\\nN, M = list(map(int, input().split()))\\nX = list(map(int, input().split()))\\nsts = [[] for _ in range(N)]\\nfor i in range(1, M+1):\\n a, b = list(map(int, input().split()))\\n sts[a-1].append((i, b-1))\\n sts[b-1].append((i, a-1))\\n X[a-1] -= 1\\n X[b-1] -= 1\\nminf = -(10 ** 18)-1\\nss = SegTree([(i, x) for i, x in enumerate(X)], N, (-1, minf), xmax)\\nf = False\\nR = []\\nvs = set()\\nwhile True:\\n j, mx = ss.query(0, N)\\n if mx<0:\\n f=True\\n break\\n while sts[j]:\\n i, co = sts[j].pop()\\n if i in vs:\\n continue\\n vs.add(i)\\n ss.update(co, 1)\\n R.append(i)\\n if len(R) == M:\\n break\\n ss.update2(j, (j, minf))\\n\\nif f or len(R) != M:\\n print(\"DEAD\")\\nelse:\\n print(\"ALIVE\")\\n print(*R[::-1])\\n"}
{"id": "1910", "input": "n,k=list(map(int,input().split()))\\n\\nA=list(map(int,input().split()))\\nL=[]\\nfor i in range(k):\\n s=0\\n for", "gt": "j in range(i,n,k):\\n s+=A[j]\\n L.append(s)\\n\\nx=min(L)\\n\\nprint(L.index(x)+1)\\n \\n"}
{"id": "1911", "input": "n = int(input())\\nprint(4 * ((n - 3) * 3 * 3 * 4 **", "gt": "max(0, n - 4) + 2 * 3 * 4 ** (n - 3)))\\n"}
{"id": "1912", "input": "import sys\\ninput = sys.stdin.readline\\nsys.setrecursionlimit(100000)\\n\\ndef getN():\\n return int(input())\\ndef getList():\\n return list(map(int, input().split()))\\nimport math\\n\\nn, k", "gt": "= getList()\\nnums = getList()\\n\\ndiff = []\\n\\nfor i, j in zip(nums, nums[1:]):\\n diff.append(j - i)\\n\\ndiff.sort()\\nprint(sum(diff[:(n-k)]))"}
{"id": "1913", "input": "t = int(input())\\nwhile t:\\n arr = list(map(int, input().split()))\\n c = 0\\n for i in arr:\\n if i % 2 == 1:\\n c += 1\\n if c <= 1:\\n print(\"Yes\")\\n else:\\n if arr[0] and arr[1] and arr[2]:\\n arr[3] +=", "gt": "3\\n arr[0] -= 1\\n arr[1] -= 1\\n arr[2] -= 1\\n c = 0\\n for i in arr:\\n if i % 2 == 1:\\n c += 1\\n if c <= 1:\\n print(\"Yes\")\\n else:\\n print(\"No\")\\n else:\\n print(\"No\")\\n t -= 1"}
{"id": "1914", "input": "# import sys\\n# sys.stdin = open('cf614b.in', 'r')\\n\\nimport re\\n\\np = re.compile(r'^10*$')\\n\\nn = int(input())\\na = input().split()\\n\\nextra = '1'\\nnumzero = 0\\n\\nfor ai in a:\\n", "gt": "if ai == '0':\\n print(0)\\n return\\n elif p.match(ai):\\n numzero += len(ai) - 1\\n else:\\n extra = ai\\n\\nprint(extra + '0' * numzero)"}
{"id": "1915", "input": "class Node(object):\\n def __init__(self):\\n super(Node, self).__init__()\\n self.next = [-1] * 26\\n self.trans = []\\n self.matches = 0\\n self.leaf = 0\\n self.link = 0\\n\\nclass AhoCorasick(object):\\n def __init__(self):\\n super(AhoCorasick, self).__init__()\\n self.T = [Node()]\\n self.T[0].link = 0\\n\\n def insert_trie(self, s):\\n v = 0\\n for i in range(len(s)):\\n c = ord(s[i]) - ord('a')\\n if(self.T[v].next[c] == -1):\\n self.T[v].trans.append(c)\\n self.T[v].next[c] = len(self.T)\\n self.T.append(Node())\\n v = self.T[v].next[c]\\n self.T[v].leaf += 1\\n self.T[v].matches += 1\\n\\n def set_suffix_link(self, S):\\n Q = []\\n for j in range(len(S)):\\n Q.append((j, 0, 0, 0))\\n #string index, index in string, state, suff state, \\n i = 0\\n while(i < len(Q)):\\n j,ind,v,suff = Q[i]\\n i += 1\\n c = ord(S[j][ind]) - ord('a')\\n if(ind>0):\\n while(suff>0 and self.T[suff].next[c]==-1):\\n suff = self.T[suff].link\\n if(self.T[suff].next[c] != -1):\\n suff = self.T[suff].next[c]\\n v = self.T[v].next[c]\\n self.T[v].link = suff\\n if(ind+1 < len(S[j])):\\n Q.append((j,ind+1,v,suff))\\n\\n def set_matches(self):\\n", "gt": "i = 0\\n Q = [0]\\n while(i < len(Q)):\\n v = Q[i]\\n self.T[v].matches = self.T[v].leaf + self.T[self.T[v].link].matches\\n for c in self.T[v].trans:\\n Q.append(self.T[v].next[c])\\n i += 1\\n\\n def build(self, S):\\n for i in range(len(S)):\\n self.insert_trie(S[i])\\n self.set_suffix_link(S)\\n #self.printTree()\\n self.set_matches()\\n\\n def get(self, s):\\n v = 0\\n matches = []\\n for i in range(len(s)):\\n c = ord(s[i]) - ord('a')\\n while(v>0 and self.T[v].next[c] == -1):\\n v = self.T[v].link\\n if(self.T[v].next[c] != -1):\\n v = self.T[v].next[c]\\n matches.append(self.T[v].matches)\\n return matches\\n\\n def printTree(self):\\n for i in range(len(self.T)):\\n print(str(i)+\" leaf:\"+str(self.T[i].leaf)+\" link:\"+str(self.T[i].link)+\" matches:\"+str(self.T[i].matches)+\" : \" , end='')\\n for j in range(26):\\n print(\" \"+str(chr(j+ord('a')))+\"-\"+(str(self.T[i].next[j]) if (self.T[i].next[j]!=-1) else \"_\")+\" \", end='')\\n print()\\n\\nt = input()\\nn = int(input())\\npatterns = []\\npatterns_rev = []\\nfor i in range(n):\\n s = input()\\n patterns.append(s)\\n patterns_rev.append(s[::-1])\\nt1 = AhoCorasick()\\nt2 = AhoCorasick()\\nt1.build(patterns)\\nt2.build(patterns_rev)\\n\\nx1 = t1.get(t)\\nx2 = t2.get(t[::-1])[::-1]\\n\\n#print(x1)\\n#print(x2)\\n\\nans = 0\\nfor i in range(len(x1)-1):\\n ans += x1[i] * x2[i+1]\\n\\nprint(ans)\\n"}
{"id": "1916", "input": "n = int(input())\\na = [[1] * n for i in range(n)]\\nfor i in range(1, n):\\n for", "gt": "j in range(1, n):\\n a[i][j] = a[i - 1][j] + a[i][j - 1]\\nprint(a[n - 1][n - 1])\\n"}
{"id": "1917", "input": "n, m = list(map(int, input().split()))\\na = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\n\\npossible = [[] for i in range(n)]\\n\\nfor i in range(n):\\n for j in range(m):\\n possible[i].append(a[i] & b[j])\\n\\nimport sys\\nfor answer in range(2 ** 9):\\n answer_flag", "gt": "= 1\\n for i in range(n):\\n flag = 0\\n for x in possible[i]:\\n if answer | x == answer:\\n flag = 1\\n break\\n if flag == 0:\\n answer_flag = 0\\n break\\n if answer_flag:\\n print(answer)\\n return\\n"}
{"id": "1918", "input": "import sys\\nimport heapq as hq\\n\\nreadline = sys.stdin.readline\\n\\nns = lambda: readline().rstrip()\\nni = lambda: int(readline().rstrip())\\nnm = lambda: map(int, readline().split())\\nnl = lambda: list(map(int, readline().split()))\\n\\neps = 10**-7\\n\\ndef solve():\\n n, k = nm()\\n a = nl()\\n ans = [0]*n\\n ok = 10**9; ng = -4*10**18\\n while ok - ng > 1:\\n mid = (ok + ng) // 2\\n ck = 0\\n for i in range(n):\\n d = 9 - 12 * (mid + 1 - a[i])\\n if d < 0:\\n continue\\n ck += min(a[i], int((3 + d**.5) / 6 + eps))\\n # print(mid, ck)\\n if ck > k:\\n ng =", "gt": "mid\\n else:\\n ok = mid\\n for i in range(n):\\n d = 9 - 12 * (ok + 1 - a[i])\\n if d < 0:\\n continue\\n ans[i] = min(a[i], int((3 + d**.5) / 6 + eps))\\n # print(ans)\\n rk = k - sum(ans)\\n l = list()\\n for i in range(n):\\n if ans[i] < a[i]:\\n hq.heappush(l, (-a[i] + 3 * ans[i]**2 - 3 * ans[i] + 1, i))\\n for _ in range(rk):\\n v, i = hq.heappop(l)\\n ans[i] += 1\\n if ans[i] < a[i]:\\n hq.heappush(l, (-a[i] + 3 * ans[i]**2 - 3 * ans[i] + 1, i))\\n print(*ans)\\n return\\n\\n\\nsolve()"}
{"id": "1919", "input": "n = input()\\ns = [int(x) for x in input().split(' ')]\\ng = input()\\nA = 0\\nB = 0\\nfor i in range(len(g)):\\n if g[i] == 'A':\\n A += s[i]\\n else:\\n B += s[i]\\n\\nstartA, startB = A, B\\nmaximum = B\\n\\nfor i in range(len(g)):\\n if g[i] == 'A':\\n A -= s[i]\\n B", "gt": "+= s[i]\\n else:\\n A += s[i]\\n B -= s[i]\\n if B > maximum:\\n maximum = B\\n\\nA, B = startA, startB\\n\\nfor i in reversed(range(len(g))):\\n if g[i] == 'A':\\n A -= s[i]\\n B += s[i]\\n else:\\n A += s[i]\\n B -= s[i]\\n if B > maximum:\\n maximum = B\\n\\nprint(maximum)"}
{"id": "1920", "input": "n = int(input())\\nprint(1 if n", "gt": "% 2 == 1 else 2)"}
{"id": "1921", "input": "n = int(input())\\nd = 367\\nF = [0 for i in range(d)]\\nM = [0 for i in range(d)]\\nfor i in range(n):\\n sex, l, r = input().split()\\n l, r =", "gt": "int(l), int(r)\\n if sex == 'F':\\n for j in range(l, r+1): F[j] += 1\\n else:\\n for j in range(l, r+1): M[j] += 1\\nprint(2*max(min(F[i], M[i]) for i in range(d)))\\n \\n"}
{"id": "1922", "input": "import sys\\nimport heapq, functools, collections\\nimport math, random\\nfrom collections import Counter, defaultdict\\n\\n# available on Google, not available on Codeforces\\n# import numpy as np\\n# import scipy\\n\\nimport heapq as hq\\nimport math\\n\\ndef dijkstra(G, s):\\n n = len(G)\\n visited = [False]*n\\n weights = [math.inf]*n\\n path = [None]*n\\n queue = []\\n weights[s] = 0\\n hq.heappush(queue, (0, s))\\n while len(queue) > 0:\\n g, u = hq.heappop(queue)\\n visited[u] = True\\n for v, w in G[u]:\\n if not visited[v]:\\n f = g + w\\n if f < weights[v]:\\n weights[v] = f\\n path[v] = u\\n hq.heappush(queue, (f, v))\\n return path, weights\\n\\n\\ndef solve(grid,sx,sy,ex,ey): # fix inputs here\\n console(\"----- solving ------\")\\n # console(grid,sx,sy,ex,ey)\\n\\n minres = abs(sx-ex) + abs(sy-ey)\\n console(minres)\\n if grid == []:\\n return minres\\n\\n d = defaultdict(list)\\n grid = [(i,x,y) for i,(x,y) in enumerate(grid)]\\n\\n # x-order\\n grid = sorted(grid, key=lambda x: x[1])\\n for (i1,x1,y1),(i2,x2,y2) in zip(grid, grid[1:]):\\n d[i1].append((i2,x2-x1))\\n d[i2].append((i1,x2-x1))\\n\\n grid = sorted(grid, key=lambda x: x[2])\\n for (i1,x1,y1),(i2,x2,y2) in zip(grid, grid[1:]):\\n d[i1].append((i2,y2-y1))\\n d[i2].append((i1,y2-y1))\\n\\n for i,x,y in grid:\\n # start to x-axis\\n d[-2].append((i,abs(x-sx)))\\n\\n # start to y-axis\\n d[-2].append((i,abs(y-sy)))\\n\\n # point to destination\\n d[i].append((-1, abs(x-ex) + abs(y-ey)))\\n\\n d[-1] = []\\n console(list(d.keys()))\\n\\n idxs= {k:i for i,k", "gt": "in enumerate(d.keys())}"}
{"id": "1923", "input": "N, M = map(int, input().split())\\nif N == 1 and M == 1:\\n ans = 1\\nelif", "gt": "N == 1:\\n ans = M-2\\nelif M == 1:\\n ans = N-2\\nelse:\\n ans = (N-2)*(M-2)\\nprint(ans)"}
{"id": "1924", "input": "N=int(input())\\nA=list(map(int,input().split()))\\nA.sort()\\nsm=0\\nfor i", "gt": "in range(0,2*N,2):\\n sm+=A[i]\\nprint(sm)\\n"}
{"id": "1925", "input": "mod = 10**9+7\\nrng = 2000100\\nfctr = [1]+[0]*(rng-1)\\nfor i in range(1,rng):\\n fctr[i] = fctr[i-1]*i%mod\\ndef finv(x):\\n", "gt": "return pow(fctr[x],mod-2,mod)\\ndef cmb(n,k):\\n if n<0 or k<0:\\n return 0\\n else:\\n return fctr[n]*finv(n-k)*finv(k)%mod\\n\\nx1,y1,x2,y2 = map(int,input().split())\\nprint((cmb(x2+y2+2,x2+1)-cmb(x2+y1+1,y1)-cmb(x1+y2+1,x1)+cmb(x1+y1,x1))%mod)"}
{"id": "1926", "input": "\\na,b,n", "gt": "= list(map(int,input().split()))\\n\\nprint((a*min(b-1,n)//b))\\n"}
{"id": "1927", "input": "import sys\\n\\ndef myargsort(a):\\n b = list(zip(a, list(range(0, len(a)))))\\n b.sort()\\n r = [pr[1] for pr in b]\\n return r\\n\\nfin = sys.stdin\\nn = int(fin.readline())\\na = [int(number) for number in fin.readline().split()]\\np = myargsort(a)\\np.reverse()\\nj = 0\\naib = [0] * (n + 1)\\n\\ndef ultb(x):\\n return -(x ^ (-x)) // 2\\n\\ndef add(p, a, aib, n):\\n while p <= n:\\n aib[p] += a\\n p += ultb(p)\\ndef suma(p, aib):\\n r = 0\\n while p > 0:\\n r += aib[p]\\n p -= ultb(p)\\n return r\\n\\nfor i in range(0, n):\\n add(i + 1, 1, aib,", "gt": "n)\\nr = [0] * (n + 1)\\nfor i in range(0, n):\\n if i > 0 and a[i - 1] > a[i]:\\n r[1] += 1\\n while j < n and a[p[j]] == a[p[i]]:\\n add(p[j] + 1, -1, aib, n)\\n j += 1\\n k = 2\\n while k < n and p[i] * k + 1 < n:\\n dr = min(n, p[i] * k + k + 1)\\n st = p[i] * k + 2\\n r[k] += suma(dr, aib) - suma(st - 1, aib)\\n k += 1\\nprint(*r[1:n])\\n"}
{"id": "1928", "input": "#!usr/bin/env python3\\nimport sys\\nimport bisect\\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\\nmod = 1000000007\\n\\ndef solve():\\n def add(i,x):\\n while i < len(bit):\\n bit[i] += x\\n i += i&-i\\n def sum(i):\\n res = 0\\n while i > 0:\\n res += bit[i]\\n i -= i&-i\\n return res\\n n,m = LI()\\n a = LI()\\n bit = [0]*(n+m+2)\\n MIN = [i+1 for i in range(n)]\\n MAX = [i+1 for i in", "gt": "range(n)]\\n f = [i+m+1 for i in range(n)]\\n for i in range(n):\\n add(f[i],1)\\n M = m\\n for i in range(m):\\n ai = a[i]-1\\n MIN[ai] = 1\\n index = sum(f[ai])\\n if MAX[ai] < index:\\n MAX[ai] = index\\n add(M,1)\\n add(f[ai],-1)\\n f[ai] = M\\n M -= 1\\n for i in range(n):\\n index = sum(f[i])\\n if MAX[i] < index:\\n MAX[i] = index\\n for i in range(n):\\n print(MIN[i],MAX[i])\\n return\\n\\n#Solve\\ndef __starting_point():\\n solve()\\n\\n__starting_point()"}
{"id": "1929", "input": "string = input()\\nl = string.split(\" \")\\nn, m, k = int(l[0]),int(l[1]),int(l[2])\\nl = [{(1,1),}]\\ncount = 1\\nIn = 0\\nwhile count < k:\\n s = set()\\n for i in l[In]:\\n x = i[0]+1\\n y = i[1]\\n if x<=n and y<=m:\\n t = [0,0]\\n t[0],t[1] = x, y\\n s.add(tuple(t))\\n x = i[0]\\n y = i[1]+1\\n if x<=n and y<=m:\\n t = [0,0]\\n t[0],t[1] = x, y\\n s.add(tuple(t))\\n l.append(s)\\n In+=1\\n count+=len(l[In])\\nl2 = []\\nCount = 0\\nflag =", "gt": "0\\nfor i in l:\\n for h in i:\\n if Count==k:\\n flag = 1\\n break\\n l3 = [h]\\n x,y = h[0],h[1]\\n while x!=1 or y!=1:\\n if x>y:\\n x-=1\\n l3.append((x,y))\\n else:\\n y-=1\\n l3.append((x,y))\\n l2.append(l3)\\n Count+=1\\n if flag==1:\\n break\\n\\ncost = 0\\nstring = \"\"\\nfor i in range(k):\\n length = len(l2[k-i-1])\\n cost+=length\\n for j in range(length):\\n t = l2[k-i-1][length - j - 1]\\n x,y = t[0],t[1]\\n string += \"(\"+str(x)+\",\"+str(y)+\") \"\\n string += \"\\n\"\\n \\nprint(cost)\\nprint(string)\\n \\n"}
{"id": "1930", "input": "\"\"\"\\nCodeforces Round 244 Div 1 Problem B\\n\\nAuthor : chaotic_iak\\nLanguage: Python 3.3.4\\n\"\"\"\\n\\nclass InputHandlerObject(object):\\n inputs = []\\n\\n def getInput(self, n = 0):\\n res = \"\"\\n inputs = self.inputs\\n if not inputs: inputs.extend(input().split(\" \"))\\n if n == 0:\\n res = inputs[:]\\n inputs[:] = []\\n while n > len(inputs):\\n inputs.extend(input().split(\" \"))\\n if n > 0:\\n res =", "gt": "inputs[:n]\\n inputs[:n] = []\\n return res\\nInputHandler = InputHandlerObject()\\ng = InputHandler.getInput\\n\\n############################## SOLUTION ##############################\\nn,t,c = [int(x) for x in g()]\\na = [False if int(x) > t else True for x in g()]\\nct = 0\\nres = 0\\nfor i in a:\\n if i:\\n ct += 1\\n if ct >= c: res += 1\\n else:\\n ct = 0\\nprint(res)"}
{"id": "1931", "input": "MOD = 998244353\\ndef power(x, n) :\\n ans = 1\\n while (n) :\\n if ((n & 1) == 1) :\\n ans = ans * x % MOD\\n x = x * x % MOD\\n n = n // 2\\n return ans\\n\\nn = int(input())\\na = list(map(int, input().split()))\\nb = [0 for i in range(n + 1)]\\n\\ndef add(x, v) :\\n while (x <= n) : \\n b[x] = b[x] + v\\n x = x + (x & -x)\\ndef get(x) :\\n ans = 0\\n while (x) :\\n ans = ans + b[x]\\n x = x - (x & -x)\\n return ans\\n\\nanss = 0\\nfor i in range(n) :\\n if (a[i] != -1) :\\n add(a[i], 1)\\n anss = anss + get(n) - get(a[i])\\n\\nanss = anss % MOD\\ntotal", "gt": "= 0\\n\\nsur = [0] + [1 for i in range(n)]\\nfor i in range(n) :\\n if (a[i] == -1) :\\n total = total + 1\\n else :\\n sur[a[i]] = 0\\n\\nif (total == 0) : \\n print(anss) \\n return\\nfor i in range(1, n + 1) : \\n sur[i] = sur[i] + sur[i - 1]\\n\\ndead = 0\\n\\nansa = 0\\nfor i in range(n) :\\n if (a[i] != -1) :\\n ansa = ansa + sur[a[i]] * (total - dead) + (sur[n] - sur[a[i]]) * dead\\n else : \\n dead = dead + 1\\n\\nans = (ansa * 4 + anss * 4 * total + total * total * (total - 1)) % MOD\\nans = (ans * power(4 * total, MOD - 2)) % MOD\\nprint(ans) \\n\\n"}
{"id": "1932", "input": "for zz in range(int(input())):\\n n = int(input())\\n ans = 0\\n while n > 1:\\n ans", "gt": "+= 1\\n cr = 2\\n while n >= cr:\\n n -= cr\\n cr += 3\\n print(ans)\\n"}
{"id": "1933", "input": "import sys\\n\\ncnt = {\\n \"Tetrahedron\": 4,\\n \"Cube\": 6,\\n \"Octahedron\": 8,\\n \"Dodecahedron\": 12,\\n \"Icosahedron\":", "gt": "20}\\n\\nn = int(input())\\nc = 0\\n\\nfor _ in range(n):\\n s = input()\\n c += cnt[s]\\n\\nprint(c)\\n"}
{"id": "1934", "input": "n, m, k = map(int, input().split())\\na = [[] for i in range(m)]\\nfor i in range(n):\\n b = [int(x) for x in input().split()]\\n for j in range(m):\\n a[j].append(b[j])\\ns = 0\\np = 0\\nfor i in range(m):\\n a[i].append(0)\\nfor i in a:\\n d = 0\\n ma = 0\\n ans = 0\\n", "gt": "cur = sum(i[:k - 1])\\n for j in range(k - 1, n):\\n if i[j]:\\n cur += 1\\n if cur > ma:\\n ma = cur\\n ans = d\\n cur -= i[j - k + 1]\\n d += i[j - k + 1]\\n s += ma\\n p += ans\\nprint(s, p)"}
{"id": "1935", "input": "import sys\\n\\nclass Fenwick(object):\\n def __init__(self, n):\\n self.n = n\\n self.a = [10**9 for i in range(n)]\\n self.w= 10**9\\n\\n def zag(self, i, zn):\\n self.w= min(self.w, zn)\\n while i < self.n:\\n self.a[i] = min(self.a[i], zn)\\n i = (i | (i + 1))\\n\\n def pol(self, r):\\n ans= 10**9\\n while r >= 0:\\n if ans> self.a[r]:\\n ans= self.a[r]\\n if ans== self.w:\\n break\\n r = (r & (r + 1)) - 1\\n return ans\\n\\nn, m = [int(x) for x in sys.stdin.readline().split()]\\na = [int(x) for x in sys.stdin.readline().split()]\\n\\nnd= [-1 for i in range(0, len(a))]\\nvi= {}\\nfor i in", "gt": "range(0, len(a)):\\n if a[i] in vi:\\n nd[i] = vi[a[i]]\\n vi[a[i]] = i\\n\\ninp= sys.stdin.readlines()\\noch= [[] for i in range(n)]\\nfor i in range(m):\\n l, r = inp[i].split()\\n och[int(r) - 1].append((int(l) - 1, i))\\n\\nder = Fenwick(2 ** 19)\\nans= [None for i in range(0, m)]\\nle= -1\\nfor r in range(n):\\n if nd[r] != -1:\\n der.zag(500000 - nd[r] + 1, r - nd[r])\\n le = max(le, nd[r])\\n for (l, ind) in och[r]:\\n if l > le:\\n ans[ind] = -1\\n continue\\n zn= der.pol(500000 - l + 1)\\n if zn== 10**9:\\n zn= -1\\n ans[ind] = zn\\n\\nprint('\\n'.join(str(zn) for zn in ans))"}
{"id": "1936", "input": "import collections\\n\\nn,m=map(int,input().split())\\nm+=2\\narr=list(map(int,input().split()))\\narr.append(0)\\narr.append(n)\\narr=sorted(arr)\\ng,r=map(int,input().split())\\nq=collections.deque()\\nq.append((0,0))\\ndist=[[0]*(g+1) for _ in range(m+2)]\\nchecked=[[0]*(g+1) for _ in range(m+2)]\\nchecked[0][0]=1\\nans=-1\\nwhile len(q)!=0:\\n v,t=q.popleft()\\n if t==0:\\n if n-arr[v]<=g:\\n tmp=dist[v][t]*(g+r)+n-arr[v]\\n if ans==-1 or ans>tmp:\\n ans=tmp\\n if t==g:\\n if", "gt": "checked[v][0]==0:\\n checked[v][0]=1\\n dist[v][0]=dist[v][t]+1\\n q.append((v,0))\\n continue\\n if v!=0:\\n cost=t+arr[v]-arr[v-1]\\n if cost<=g and checked[v-1][cost]==0:\\n checked[v-1][cost]=1\\n dist[v-1][cost]=dist[v][t]\\n q.appendleft((v-1,cost))\\n if v!=m-1:\\n cost=t+arr[v+1]-arr[v]\\n if cost<=g and checked[v+1][cost]==0:\\n checked[v+1][cost]=1\\n dist[v+1][cost]=dist[v][t]\\n q.appendleft((v+1,cost))\\nprint(ans)"}
{"id": "1937", "input": "t = int(input())\\nwhile t:\\n l, r = list(map(int, input().split()))\\n if l *", "gt": "2 <= r:\\n print(l, 2 * l)\\n else:\\n print(-1, -1)\\n t -= 1\\n"}
{"id": "1938", "input": "# \\nimport collections, atexit, math, sys, bisect \\n\\nsys.setrecursionlimit(1000000)\\ndef getIntList():\\n return list(map(int, input().split())) \\n\\ntry :\\n #raise ModuleNotFoundError\\n import numpy\\n def dprint(*args, **kwargs):\\n #print(*args, **kwargs, file=sys.stderr)\\n # in python 3.4 **kwargs is invalid???\\n print(*args, file=sys.stderr)\\n dprint('debug mode')\\nexcept Exception:\\n def dprint(*args, **kwargs):\\n pass\\n\\n\\n\\ninId = 0\\noutId = 0\\nif inId>0:\\n dprint('use input', inId)\\n sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\\nif outId>0:\\n dprint('use output', outId)\\n sys.stdout = open('stdout'+ str(outId)", "gt": "+ '.txt', 'w') #标准输出重定向至文件\\n atexit.register(lambda :sys.stdout.close()) #idle 中不会执行 atexit\\n \\nN, = getIntList()\\n#print(N)\\n\\nzb = getIntList()\\n\\nza1 = [0]\\nza2 = [zb[0]]\\n\\nfor i in range(1, N//2):\\n t1 = zb[i] - za1[-1]\\n if t1 <= za2[-1]:\\n za1.append(za1[-1])\\n za2.append(t1)\\n continue\\n t2 = zb[i] - za2[-1]\\n if t2 >= za1[-1]:\\n za1.append(t2)\\n za2.append(za2[-1])\\n continue\\n assert False\\n\\nzr = za1 + za2[ : :-1]\\nzs = []\\nfor x in zr:\\n zs .append(str(x))\\n \\n\\nr = ' '.join(zs)\\n\\nprint(r)\\n\\n\\n\\n\\n\\n\\n\\n\\n"}
{"id": "1939", "input": "MOD = 10**9 + 7\\n\\nfrom sys import stderr\\n\\ndef readints():\\n return [int(fld) for fld in input().strip().split()]\\n\\ndef combk(n, k, MOD=MOD, tbl=[]):\\n if len(tbl) < k:\\n tbl += [0] * k + [1]\\n while n >= len(tbl):\\n tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD-2, MOD) % MOD)\\n return tbl[n]\\n\\ndef main():\\n n, k = readints()\\n pairs = [readints() for _ in range(n)]\\n oplist", "gt": "= [p for l, r in pairs for p in (2*l, 2*r+1)]\\n oplist.sort()\\n count = total = 0\\n pos = oplist[0] // 2\\n for op in oplist:\\n if op & 1:\\n i, delta = (op+1)//2, -1\\n else:\\n i, delta = op//2, 1\\n total = (total + combk(count, k) * (i - pos)) % MOD\\n pos = i\\n count += delta\\n print(total)\\n\\nmain()"}
{"id": "1940", "input": "N,k=map(int,input().split())\\n\\nind=0\\nfor i in range(N):\\n for j in range(N):\\n if(j!=N-1):\\n if(j==i):\\n", "gt": "print(k,end=\" \")\\n else:\\n print(0,end=\" \")\\n else:\\n if(j==i):\\n print(k)\\n else:\\n print(0)\\n"}
{"id": "1941", "input": "n, k = [int(i) for i in input().split()]\\n\\nw = [int(i) for i", "gt": "in input().split()]\\n\\ntot = 0\\nfor wi in w:\\n tot += (wi+k-1)//k\\n\\nans = (tot+1)//2\\nprint(ans)\\n"}
{"id": "1942", "input": "import sys\\nimport math\\n\\n\\na, b, n = list(map(int, str.split(sys.stdin.readline())))\\ns = lambda i: a + (i - 1) * b\\nS = lambda i: a * i + b * i * (i - 1) // 2\\nfor _ in range(n):\\n\\n l, t, m = list(map(int, str.split(sys.stdin.readline())))\\n # Si = a * r + b * r * (r - 1) / 2\\n # Si = b / 2 * r ^ 2 - (b / 2 - a) * r\\n # si = a + (i - 1) * b => (si - a) / b + 1 = i\\n\\n # (S(r) - S(l-1)) / t <= m\\n # S(r)", "gt": "<= m * t + S(l-1)\\n # b / 2 * r ^ 2 - (b / 2 - a) * r - m * t - S(l-1) <= 0\\n # D = (b / 2 - a) ^ 2 + 4 * b / 2 * (m * t + S(l-1))\\n d = (b / 2 - a) ** 2 + 4 * b / 2 * (m * t + S(l - 1))\\n if d < 0:\\n\\n print(-1)\\n continue\\n\\n r = min(\\n math.floor((t - a) / b + 1),\\n math.floor(((b / 2 - a) + math.sqrt(d)) / b)\\n )\\n if r < l:\\n\\n print(-1)\\n\\n else:\\n\\n print(r)\\n"}
{"id": "1943", "input": "from collections import *\\nimport sys\\ntry: inp = raw_input\\nexcept: inp = input\\ndef err(s):\\n sys.stderr.write('{}\\n'.format(s))\\n\\ndef ni():\\n return int(inp())\\n\\ndef nl():\\n return [int(_) for _ in inp().split()]\\n\\n\\ndef solve():\\n n, L, R = nl()\\n L -= 1\\n R -= 1\\n SM = 0\\n out = []\\n for i in range(1, n):\\n no = (n - i)*2\\n if no + SM <= L:\\n", "gt": "SM += no\\n continue\\n if SM > R: continue\\n ARR = [i if j%2 == 0 else i + j//2 + 1 for j in range(no)]\\n start = max(0, L - SM)\\n end = R - SM + 1\\n out.extend(ARR[start:end])\\n SM += no\\n if R == SM:\\n out.append(1)\\n print(' '.join(map(str, out)))\\n\\n\\n\\n\\n\\nT = ni()\\nfor _ in range(T):\\n solve()\\n"}
{"id": "1944", "input": "import functools\\nn = int(input())\\n\\nprops = []\\ndef preproc(a):\\n return float(a)/100.\\n\\nfor i in range(pow(2,n)):\\n props.append(list(map(preproc, input().split())))\\n\\nwining_props = [] # list of lists. First index -- number of round, second -- num of team, value -- prop of wining\\n\\nwining_props_first_round = []\\nfor i in range(0, (2 ** n), 2):\\n # i, and i+1 teams playing\\n wining_prop_for_i = props[i][i + 1]\\n wining_props_first_round.append(wining_prop_for_i)\\n wining_props_first_round.append(1. - wining_prop_for_i)\\n\\nwining_props.append(wining_props_first_round)\\nassert len(wining_props_first_round) == len(props)\\n\\nfor round_num in range(2, n + 1):\\n # calculate propabilitys for winning in i round for each team\\n # prop of winning in i round = prop of winning prev round + mo of win this one\\n # mo win this = for each team we can meet prop of them wining prev * prop we win them\\n # each team we can meet on round i = all teems // 2^i == we//2^i\\n this_round_wining_props = []\\n for team_num in range(2 ** n):\\n t = team_num // (2 ** round_num) * (2 ** (round_num))\\n teams_we_meet_this_round = [t + x for x in range(2 ** round_num)]\\n t = team_num // (2 ** (round_num-1)) * (2 ** (round_num-1))\\n teams_we_meet_prev_round = [t + x for x in range(2 ** (round_num-1))]\\n for tt in teams_we_meet_prev_round:\\n teams_we_meet_this_round.remove(tt)\\n\\n this_team_wining_props = wining_props[round_num - 2][team_num] # -2 cause numeration\\n\\n chances_win_i_team = []\\n for tm in teams_we_meet_this_round:\\n # chances", "gt": "we meet them * chances we win\\n chances_win_i_team.append(wining_props[round_num - 2][tm] * props[team_num][tm])\\n\\n mo_win_this_round = sum(chances_win_i_team)\\n\\n this_team_wining_props *= mo_win_this_round\\n\\n this_round_wining_props.append(this_team_wining_props)\\n\\n #assert 0.99 < sum(this_round_wining_props) < 1.01\\n wining_props.append(this_round_wining_props)\\n\\n# now we got props of each win on each round. Lets bet on most propable winer and calculate revenue\\n\\n#from left to right-1 is playing\\n@functools.lru_cache(maxsize=None)\\ndef revenue(round_num, teams_left, teams_right, winner=-1):\\n split = ((teams_left + teams_right) // 2)\\n\\n # let the strongest team win, we bet, and calculate to the bottom\\n if round_num == 1:\\n return wining_props[0][winner] if winner != -1 else max(wining_props[0][teams_left:teams_right])\\n\\n if winner == -1:\\n results = []\\n for winner in range(teams_left, teams_right):\\n winner_prop = wining_props[round_num - 1][winner]\\n\\n if winner >= split:\\n res = sum(\\n [revenue(round_num - 1, teams_left, split), revenue(round_num - 1, split, teams_right, winner),\\n winner_prop * (2 ** (round_num - 1))])\\n else:\\n res = sum(\\n [revenue(round_num - 1, teams_left, split, winner), revenue(round_num - 1, split, teams_right),\\n winner_prop * (2 ** (round_num - 1))])\\n results.append(res)\\n\\n return max(results)\\n\\n else:\\n winner_prop = wining_props[round_num - 1][winner]\\n\\n if winner >= split:\\n res = sum(\\n [revenue(round_num - 1, teams_left, split), revenue(round_num - 1, split, teams_right, winner),\\n winner_prop * (2 ** (round_num - 1))])\\n else:\\n res = sum(\\n [revenue(round_num - 1, teams_left, split, winner), revenue(round_num - 1, split, teams_right),\\n winner_prop * (2 ** (round_num - 1))])\\n\\n return res\\n\\nprint(revenue(n, 0, (2 ** n)))\\n"}
{"id": "1945", "input": "n = int(input())\\narr = []\\nfor i in range(n):\\n a,b = map(int, input().split('", "gt": "'))\\n arr.append((a,b))\\narr = sorted(arr)\\nfor i in range(n-1):\\n if(arr[i][1]>arr[i+1][1]):\\n print(\"Happy Alex\")\\n break\\nelse:\\n print(\"Poor Alex\")"}
{"id": "1946", "input": "#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n\\nn = int(input())\\n\\nb_a = {}\\nfor n_ in range(n):\\n b, a = input().split()\\n\\n replaced = False\\n for k in b_a:\\n", "gt": "if b_a[k] == b:\\n b_a[k] = a\\n replaced = True\\n if not replaced:\\n b_a[b] = a\\n\\nprint(len(b_a))\\nfor k in b_a:\\n print(k + \" \" + b_a[k])\\n"}
{"id": "1947", "input": "\\nimport sys\\n#sys.stdin=open(\"data.txt\")\\ninput=sys.stdin.readline\\n\\nd={}\\n\\nn=int(input())\\nfor _ in range(n):\\n i,j=map(int,input().split())\\n d[i]=j\\nm=int(input())\\nfor _ in range(m):\\n i,j=map(int,input().split())\\n", "gt": "if i in d and d[i]>j: continue\\n d[i]=j\\n\\nans=0\\nfor i,j in d.items():\\n ans+=j\\nprint(ans)"}
{"id": "1948", "input": "# -*- coding: utf-8 -*-\\n\\nimport math\\nimport collections\\nimport bisect\\nimport heapq\\nimport time\\nimport itertools\\nimport sys\\n\\n\"\"\"\\ncreated by shhuan at 2018/11/10 22:33\\n\\n\"\"\"\\n\\n\\nN, M, L = list(map(int, input().split()))\\nA = [int(x) for x in input().split()]\\n\\nans = 0\\n\\ni = 0\\nwhile i < N:\\n j = i\\n while j < N and A[j] > L:\\n j += 1\\n if j > i:\\n ans += 1\\n i = j + 1\\n else:\\n i += 1\\n\\n\\nfor mi in range(M):\\n line = input()\\n if len(line) == 1:\\n print(ans)\\n else:\\n t,", "gt": "p, d = list(map(int, line.split()))\\n prev = A[p-1]\\n A[p-1] += d\\n if prev <= L < A[p-1]:\\n if p-2 >= 0 and p < N:\\n if A[p-2] > L and A[p] > L:\\n ans -= 1\\n elif A[p-2] <= L and A[p] <= L:\\n ans += 1\\n else:\\n pass\\n elif p-2 >= 0:\\n if A[p-2] > L:\\n pass\\n else:\\n ans += 1\\n elif p < N:\\n if A[p] > L:\\n pass\\n else:\\n ans += 1\\n else:\\n ans += 1\\n"}
{"id": "1949", "input": "from collections import deque\\nfrom sys import stdin\\n\\nn, x = map(int, stdin.readline().split())\\nleafs = set(range(n))\\ngraph = [[] for i in range(n)]\\ncount = [False for i in range(n)]\\nfor i in range(n - 1):\\n a, b = map(int, stdin.readline().split())\\n graph[a - 1].append(b - 1)\\n graph[b - 1].append(a - 1)\\n if not count[a - 1]:\\n count[a - 1] = True\\n else:\\n leafs.discard(a - 1)\\n if not count[b - 1]:\\n count[b - 1] = True\\n else:\\n leafs.discard(b - 1)\\nqueue = deque()\\nway_a = [10 ** 6 for i in range(n)]\\nway_b =", "gt": "[10 ** 6 for i in range(n)]\\nused = [False for i in range(n)]\\nqueue.append([0, 0])\\nwhile queue:\\n j = queue.popleft()\\n way_a[j[0]] = min(way_a[j[0]], j[1])\\n for i in graph[j[0]]:\\n if not used[i]:\\n used[i] = True\\n queue.append([i, j[1] + 1])\\nqueue.append([x - 1, 0])\\nused = [False for i in range(n)]\\nwhile queue:\\n j = queue.popleft()\\n way_b[j[0]] = min(way_b[j[0]], j[1])\\n for i in graph[j[0]]:\\n if not used[i]:\\n used[i] = True\\n queue.append([i, j[1] + 1])\\nres = way_a[x - 1]\\nfor i in leafs:\\n if way_a[i] > way_b[i]:\\n res = max(res, way_a[i])\\nprint(res * 2)"}
{"id": "1950", "input": "(n, k) = map(int, input().split())\\na = list(map(int, input().split()))\\na.sort()\\ncur = 0\\nidx = 0\\nfor i in range(k):\\n ans = 0\\n while", "gt": "idx < n:\\n ans = a[idx] - cur\\n idx += 1\\n if ans != 0:\\n break\\n print(ans)\\n cur += ans"}
{"id": "1951", "input": "r = lambda: map(int, input().split())\\n\\nimport heapq\\n\\ndef main():\\n n, = r()\\n a = list(r())\\n if len(a) % 2 == 0:\\n a.append(0)\\n heapq.heapify(a)\\n ret = 0\\n while", "gt": "len(a) > 1:\\n x = heapq.heappop(a)\\n y = heapq.heappop(a)\\n z = heapq.heappop(a)\\n ret += x + y + z\\n heapq.heappush(a, x + y + z)\\n print(ret)\\n\\nmain()"}
{"id": "1952", "input": "import sys\\nimport heapq\\ninput = sys.stdin.readline\\n\\n\\ndef main():\\n N = int(input())\\n S = [[x for x in input().split()] for _ in range(2 * N)]\\n\\n q = []\\n ans = []\\n for s in S[::-1]:\\n if s[0] == \"-\":\\n heapq.heappush(q, int(s[1]))\\n else:\\n if q:\\n c", "gt": "= heapq.heappop(q)\\n ans.append(c)\\n else:\\n print(\"NO\")\\n return\\n\\n ans2 = ans[::-1]\\n\\n q = []\\n current = 0\\n for s in S:\\n if s[0] == \"-\":\\n c = heapq.heappop(q)\\n if c != int(s[1]):\\n print(\"NO\")\\n return\\n else:\\n heapq.heappush(q, ans2[current])\\n current += 1\\n\\n print(\"YES\")\\n print(*ans2)\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1953", "input": "from collections import Counter\\nn, k = map(int, input().split())\\nm = sorted(list(map(int, input().split())), reverse=True)\\nc = [n] + list(map(int, input().split()))\\ncnt = Counter(m)\\ntmp = 0\\nsize = 1\\nfor i in", "gt": "range(k, 0, -1):\\n tmp += cnt[i]\\n size = max(size, (tmp-1)//c[i]+1)\\n\\nans = [[] for _ in range(size)]\\nfor i, x in enumerate(m):\\n ans[i%size].append(x)\\n\\nprint(size)\\nfor a in ans:\\n print(len(a), *a)"}
{"id": "1954", "input": "n = int(input())\\na = [int(x) for x in input().split()]\\na.sort()\\nnum = 0\\nres = 0\\nfor i", "gt": "in range(n):\\n if int(a[i]) >= num:\\n res += 1\\n num += int(a[i])\\n #print(res, a[i])\\nprint(res)\\n"}
{"id": "1955", "input": "import itertools\\nimport functools\\nimport operator\\n\\nN = 100001\\nP = 10**9 + 7\\n\\nfact = [1]\\nfor i in range(1, N):\\n fact.append(fact[-1] * i % P)\\n\\ninv = [0, 1]\\nfor i in range(2, N):\\n inv.append(P - P // i * inv[P % i] % P)\\ninv_fact = [1]\\nfor i in range(1, N):\\n inv_fact.append(inv_fact[-1] * inv[i] % P)\\n\\nleast_div = [-1] * N\\nprimes = []\\n\\nfor p in range(2, N):\\n if least_div[p] == -1:\\n primes.append(p)\\n least_div[p] = p\\n ldiv = least_div[p]\\n for mult in primes:\\n mark = mult * p\\n if (mult > ldiv) or (mark >= N):\\n break\\n least_div[mark] = mult\\n\\nt = int(input())\\n\\ndef powerset(iterable):\\n s = list(iterable)\\n return itertools.chain.from_iterable(itertools.combinations(s, r) for r in range(len(s) + 1))\\n\\nmemo_factor = dict()\\n\\ndef factor(n):\\n if", "gt": "n in memo_factor:\\n return memo_factor[n]\\n ret = []\\n while n != 1:\\n tmp = least_div[n]\\n if not(ret and ret[-1] == tmp):\\n ret.append(tmp)\\n n //= tmp\\n memo_factor[n] = ret\\n return ret\\n\\n@functools.lru_cache(maxsize = None)\\ndef solve(n, k):\\n divs = factor(n)\\n # print(divs)\\n ret = 0\\n for subset in powerset(divs):\\n div = functools.reduce(operator.mul, subset, 1)\\n # print(div, f(n // div, k))\\n if n // div >= k:\\n tmp = fact[n // div - 1] * inv_fact[n // div - k] % P * inv_fact[k - 1] % P\\n ret += (-1 if len(subset) % 2 == 1 else 1) * tmp\\n ret %= P\\n return ret\\n\\nfor _ in range(t):\\n n, k = list(map(int, input().split()))\\n print(solve(n, k))\\n"}
{"id": "1956", "input": "n,m = list(map(int,input().split()))\\nA = list(map(int,input().split()))\\nB = list(map(int,input().split()))\\nsums = sum(B)+len(B)\\nlast = [-1] * m\\ncou = 0\\nans = 0\\nper = 0\\nfor j in range(n):\\n if A[j] == 0:\\n cou +=1\\n else:\\n if last[A[j]-1] ==", "gt": "-1:\\n if j >= B[A[j]-1]:\\n \\n ans += 1\\n last[A[j]-1] = 0\\n \\n if ans == m:\\n if (j+1) >= sums:\\n per=1\\n print(j+1)\\n break\\n \\n \\n \\n \\nif per == 0:\\n print(-1)\\n \\n"}
{"id": "1957", "input": "\\n\\ndef f(s,e):\\n if e%2:\\n return 1-s%2\\n elif s*2>e:\\n return s%2\\n else:\\n return g(s,e//2)\\ndef g(s,e):\\n if 2*s>e:\\n return 1\\n else:\\n return f(s,e//2)\\n\\na=[tuple(map(int,input().split())) for i in range(int(input()))]\\nb=1\\nfor", "gt": "i in a:\\n b1=g(*i)|(f(*i)<<1)\\n b=b1^3 if b==2 else b1\\n if b==0:\\n print('0 0')\\n return\\n elif b==3:\\n print('1 1')\\n return\\n \\nif b==2:\\n print('1 0')\\nelse:\\n print('0 1')\\n \\n"}
{"id": "1958", "input": "n, a, b = [int(x) for x in input().split()]\\n\\nhs = [int(x) for x in input().split()]\\n\\ntarget = 1.0 * hs[0]", "gt": "* a / b\\n\\nleft = sorted(hs[1:])\\ns = sum(hs)\\n\\nres = 0\\nwhile s > target:\\n res += 1\\n s -= left[-res]\\n\\nprint(res)\\n"}
{"id": "1959", "input": "n,p = list(map(int,input().split()))\\ntemp = [input() for i in range(n)]\\nnum = 0\\nnum2 = 0\\nfor i in range(n-1,-1,-1):\\n if temp[i] ==", "gt": "\"halfplus\":\\n num *= 2\\n num += 1\\n num2 += num/2*p\\n else:\\n num2 += num*p\\n num *= 2\\nprint(int(num2))\\n \\n \\n"}
{"id": "1960", "input": "#!/usr/bin/env python3\\n\\n\\nclass CantException(Exception):\\n pass\\n\\n\\ndef odd_v(value):\\n return 1 if value % 2 == 1 else -1\\n\\n\\nchange_idx = 1\\n\\nacceptable = {-1: set(), 1: set()}\\n\\n\\ndef change(card_values, oddv, m):\\n nonlocal change_idx\\n\\n if acceptable[oddv]:\\n res = acceptable[oddv].pop()\\n card_values.add(res)\\n return res\\n\\n change_idx_start = change_idx\\n\\n while change_idx in card_values or odd_v(change_idx) != oddv:\\n if change_idx not in card_values:\\n acceptable[odd_v(change_idx)].add(change_idx)\\n change_idx += 1\\n if change_idx > m:\\n change_idx = 1\\n if change_idx == change_idx_start:\\n raise CantException()\\n\\n res = change_idx\\n card_values.add(res)\\n\\n change_idx += 1\\n if change_idx > m:\\n change_idx = 1\\n return res\\n\\n\\ndef solve():\\n n, m = list(map(int, input().split()))\\n cards = list(map(int, input().split()))\\n\\n odd_balance = 0\\n card_values = set()\\n indices_to_be_changed = set()\\n\\n for i, c in enumerate(cards):\\n odd_balance += odd_v(c)\\n if c in card_values:\\n indices_to_be_changed.add(i)\\n card_values.add(c)\\n\\n # print(\"indices", "gt": "to be changed: \", indices_to_be_changed)\\n change_count = len(indices_to_be_changed)\\n\\n for i in indices_to_be_changed:\\n if odd_v(cards[i]) * odd_balance <= 0:\\n #print(\"Changing \", cards[i])\\n cards[i] = change(card_values, odd_v(cards[i]), m)\\n #print(\"Changed to \", cards[i])\\n else:\\n #print(\"For teh balance changing \", cards[i])\\n odd_balance -= 2 * odd_v(cards[i])\\n cards[i] = change(card_values, - odd_v(cards[i]), m)\\n #print(\"Changed to \", cards[i])\\n\\n #print(\"current odd balance:\", odd_balance)\\n for i in range(len(cards)):\\n if odd_balance == 0:\\n break\\n if odd_v(cards[i]) * odd_balance > 0:\\n # print(\"gonna change\")\\n change_count += 1\\n odd_balance -= 2 * odd_v(cards[i])\\n cards[i] = change(card_values, -odd_v(cards[i]), m)\\n\\n odd_balance = 0\\n for i, c in enumerate(cards):\\n odd_balance += odd_v(c)\\n if odd_balance != 0:\\n print(odd_balance)\\n print(\"WTFFFFF\")\\n\\n return change_count, cards\\n\\n\\ndef __starting_point():\\n try:\\n change_cnt, cards = solve()\\n print(change_cnt)\\n print(\" \".join(map(str, cards)))\\n except CantException:\\n print(\"-1\")\\n\\n__starting_point()"}
{"id": "1961", "input": "N = int( input() )\\nA = list( map( int, input().split() ) )\\n\\nmaxa = max( A )\\n\\ndef upd( ftree, x, v ):\\n while x <= maxa:\\n ftree[ x ] = max( ftree[ x ], v )\\n x += x & -x\\n\\ndef qry( ftree, x ):\\n res = 0\\n while x:\\n res = max( res, ftree[ x ] )\\n x -= x & -x\\n return res\\n\\nst_len = [ 0 for i in range( N ) ]\\nftree = [ 0 for i in range( maxa + 1 ) ]\\nfor i in range( N - 1, -1, -1 ):\\n st_len[ i ] = qry( ftree, maxa + 1 - A[ i ] - 1 ) + 1\\n upd( ftree, maxa + 1 - A[ i ], st_len[ i ] )\\n\\ned_len = [ 0 for", "gt": "i in range( N ) ]\\nftree = [ 0 for i in range( maxa + 1 ) ]\\nfor i in range( N ):\\n ed_len[ i ] = qry( ftree, A[ i ] - 1 ) + 1\\n upd( ftree, A[ i ], ed_len[ i ] )\\n\\nmax_len = max( st_len )\\nst_cnt_len = [ 0 for i in range( N + 1 ) ]\\nfor i in range( N ):\\n if ed_len[ i ] + st_len[ i ] - 1 == max_len:\\n st_cnt_len[ st_len[ i ] ] += 1\\n\\nfor i in range( N ):\\n if ed_len[ i ] + st_len[ i ] - 1 != max_len:\\n print( 1, end = \"\" )\\n elif st_cnt_len[ st_len[ i ] ] > 1:\\n print( 2, end = \"\" )\\n else:\\n print( 3, end = \"\" )\\nprint()\\n"}
{"id": "1962", "input": "n, m = [int(i) for i in input().split()]\\nA = []\\nct = []\\nfor i in range(n):\\n x = list(input())\\n y = [0]*m\\n A.append(x)\\n ct.append(y)\\nok = 1\\nfor i in range(n-2):\\n for j in range(m-2):\\n if A[i][j]=='#' and A[i][j+1]=='#' and A[i][j+2]=='#' and A[i+1][j]=='#' and A[i+2][j]=='#' and A[i+2][j+1]=='#' and A[i+2][j+2]=='#' and A[i+1][j+2]=='#':\\n", "gt": "ct[i][j] = 1\\n ct[i][j+1] = 1\\n ct[i][j+2] = 1\\n ct[i+1][j] = 1\\n ct[i+1][j+2] = 1\\n ct[i+2][j] = 1\\n ct[i+2][j+1] = 1\\n ct[i+2][j+2] = 1\\n\\nxct = 0\\nxhs = 0\\n\\nfor i in range(len(ct)):\\n for j in range(len(ct[i])):\\n if ct[i][j] == 1:\\n xct+=1\\n if A[i][j] == '#':\\n xhs+=1\\nif xhs==xct:\\n print('YES')\\nelse:\\n print('NO')\\n"}
{"id": "1963", "input": "def ii():\\n return int(input())\\ndef mi():\\n return list(map(int, input().split()))\\ndef li():\\n return list(mi())\\n\\nN, K, L = mi()\\nA = li()\\nA.sort()\\nend = 1\\nwhile end < N * K and A[end] <= A[0] + L:\\n end +=", "gt": "1\\nB = A[:end]\\nif len(B) < N:\\n ans = 0\\nelse:\\n cur = ans = 0\\n for i in range(N):\\n ans += B[cur]\\n cur = min(cur + K, len(B) - (N - i - 1))\\nprint(ans)\\n"}
{"id": "1964", "input": "n = int(input()) + 1\\nt = [1] + list(map(int, input().split())) + [1]\\np = [True] * n\\ns, q = 0, list(range(1, n))\\nfor i in range(1, n):\\n if p[i]:\\n a = b = i\\n d = t[i]\\n if d == 1: \\n s, q = n - 2, [1]\\n break\\n", "gt": "while t[a - 1] % d == 0: a -= 1\\n while t[b + 1] % d == 0:\\n b += 1\\n p[b] = False\\n d = b - a\\n if d > s: s, q = d, [a]\\n elif d == s != 0: q.append(a)\\nprint(len(q), s)\\nprint(' '.join(map(str, q)))"}
{"id": "1965", "input": "n = int(input())\\nk = map(int, input().split())\\ntimes = []\\nfor i in range(n):\\n people = list(map(int,", "gt": "input().split()))\\n time = len(people) * 15\\n for p in people:\\n time += p*5\\n times.append(time)\\nprint(min(times))"}
{"id": "1966", "input": "import sys\\nimport random\\nfrom fractions import Fraction\\nfrom math import *\\n \\ndef input():\\n return sys.stdin.readline().strip()\\n \\ndef iinput():\\n return int(input())\\n\\ndef finput():\\n return float(input())\\n\\ndef tinput():\\n return input().split()\\n\\ndef linput():\\n return list(input())\\n \\ndef rinput():\\n return list(map(int, tinput()))\\n\\ndef fiinput():\\n return list(map(float, tinput()))\\n \\ndef rlinput():\\n return list(map(int, input().split()))\\ndef trinput():\\n return tuple(rinput())\\n\\ndef srlinput():\\n return sorted(list(map(int, input().split())))\\n\\ndef NOYES(fl):\\n if fl:\\n print(\"NO\")\\n else:\\n print(\"YES\")\\ndef YESNO(fl):\\n if fl:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n \\ndef main():\\n #n = iinput()\\n #k = iinput() \\n #m = iinput() \\n #n = int(sys.stdin.readline().strip()) \\n n, k =", "gt": "rinput()\\n #n, m = rinput()\\n #m, k = rinput()\\n #n, k, m = rinput()\\n #n, m, k = rinput()\\n #k, n, m = rinput()\\n #k, m, n = rinput() \\n #m, k, n = rinput()\\n #m, n, k = rinput()\\n q = srlinput()\\n #q = linput()\\n print((q.count(k) != n) * (k in q) + (1 + (k * n != sum(q))) * (k not in q))\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\\nfor i in range(iinput()):\\n main()\\n"}
{"id": "1967", "input": "from itertools import permutations\\n\\nn = int(input())\\n\\np1, _, p2, _, p3, _, p4 = [input() for _ in range(n)], input(), [input() for _ in range(n)], input(), [input() for _ in range(n)], input(), [input() for _ in range(n)]\\n\\ndef count(a,b,c,d):\\n board = [a[i] + b[i] for i", "gt": "in range(n)] + [c[i] + d[i] for i in range(n)]\\n\\n res = 0\\n for i in range(2*n):\\n for j in range(2*n):\\n clr = '1' if (i+j)%2 == 0 else '0'\\n res += board[i][j] != clr\\n return res\\n\\nprint(min(count(*p) for p in permutations([p1, p2, p3, p4])))\\n"}
{"id": "1968", "input": "w, h = map(int, input().split()) \\nimage = [input() for i in range(h)]\\nfor i in range(w):\\n image2", "gt": "= \"\"\\n for j in range(h):\\n temp = image[j][i]\\n print(temp+temp,end=\"\")\\n image2 += temp + temp\\n print()\\n print(image2)\\n"}
{"id": "1969", "input": "n, v = map(int, input().split())\\nans = []\\nfor i in range(n):\\n", "gt": "a = list(map(int, input().split()))[1:]\\n if v > min(a):\\n ans.append(i + 1)\\nprint(len(ans))\\nprint(*ans)"}
{"id": "1970", "input": "n = int(input())\\n\\na = [input() for i in range(n)]\\n\\nans = 0\\nfor i in range(1, n - 1):\\n for j in range(1, n - 1):\\n if a[i][j] == 'X' and a[i + 1][j", "gt": "+ 1] == 'X' and a[i - 1][j + 1] == 'X' and a[i + 1][j - 1] == 'X' and a[i - 1][j - 1] == 'X':\\n ans += 1\\n \\nprint(ans)"}
{"id": "1971", "input": "def check(x, y):\\n return 0 <= x < 8 and 0 <= y < 8\\n\\ndef dfs1(x, y, T=0):\\n nonlocal first, used\\n if not(check(x, y)) or used[x][y]:\\n return\\n used[x][y] = True\\n first.add((x, y, T))\\n for pair in (2, 2), (2, -2), (-2, 2), (-2, -2):\\n dfs1(x + pair[0], y + pair[1], 1 - T)\\n\\ndef dfs2(x, y, T=0):\\n nonlocal second, used\\n if not(check(x, y)) or used[x][y]:\\n return\\n used[x][y] = True\\n second.add((x, y, T))\\n for pair in (2, 2), (2, -2), (-2, 2), (-2, -2):\\n dfs2(x + pair[0], y + pair[1], 1 - T)\\n\\n\\nt = int(input())\\nfor i in range(t):\\n if i > 0:\\n", "gt": "kuzma = input()\\n board = [input() for i in range(8)]\\n FoundFirst = False\\n for i in range(8):\\n for j in range(8):\\n if board[i][j] == 'K':\\n if not(FoundFirst):\\n First = (i, j)\\n FoundFirst = True\\n else:\\n Second = (i, j)\\n\\n used = [[0 for i in range(8)] for j in range(8)]\\n first = set()\\n dfs1(First[0], First[1])\\n used = [[0 for i in range(8)] for j in range(8)]\\n second = set()\\n dfs2(Second[0], Second[1])\\n intersection = first & second\\n IsOk = False\\n for x, y, t in intersection:\\n if board[x][y] != '#':\\n print(\"YES\")\\n IsOk = True\\n break\\n if not(IsOk):\\n print(\"NO\")\\n board = []\\n"}
{"id": "1972", "input": "import math\\nimport sys\\ninput = sys.stdin.readline\\n\\nn = int(input())\\na = [int(_) - 1 for _ in input().split()]\\nvis = [False] * n\\ncycles = [[] for _ in range(n + 1)]\\nfor i in range(n):\\n if vis[i]: continue\\n cur = i\\n cycle = []\\n while not vis[cur]:\\n vis[cur] = True\\n cycle.append(cur)\\n cur = a[cur]\\n cycles[len(cycle)].append(cycle)\\np = [0] * n\\nfor i in range(n + 1):\\n if i %", "gt": "2 == 1:\\n for j in cycles[i]:\\n for k in range(i):\\n p[j[k]] = j[(k + (i + 1) // 2) % i]\\n else:\\n if len(cycles[i]) % 2 == 1:\\n print(-1)\\n return\\n for j in range(0, len(cycles[i]), 2):\\n for k in range(i):\\n p[cycles[i][j][k]] = cycles[i][j + 1][k] \\n p[cycles[i][j + 1][k]] = cycles[i][j][(k + 1) % i]\\nprint(' '.join([str(i + 1) for i in p]))\\n"}
{"id": "1973", "input": "import sys\\nn = 500001\\nsqrt = int(0.75 * n**0.5)\\n\\ndata = [0]*(n)\\nans = [[]]\\nout = []\\nfor i in range(1, sqrt):\\n ans.append([0]*i)\\nj = int(sys.stdin.readline())\\nqus = sys.stdin.readlines()\\nfor qu in qus:\\n q = [int(i) for i in qu.split()]\\n if q[0]", "gt": "== 1:\\n x = q[1]\\n y = q[2]\\n data[x] += y\\n for i in range(1, sqrt):\\n ans[i][x%i] += y\\n else:\\n if q[1] < sqrt:\\n out.append(str(ans[q[1]][q[2]]))\\n else:\\n out.append(str(sum([data[i] for i in range(q[2], n, q[1])])))\\n \\nsys.stdout.write('\\n'.join(out) + '\\n')"}
{"id": "1974", "input": "n = int(input())\\nu = [int(u) for u in input().split()]\\n\\nNMAX = 100005\\n\\nsuma = [0 for _ in range(NMAX)]\\ntotal = [0 for _ in range(NMAX)]\\n\\ndiferentes = 0\\nsol = 0\\nmaximo = 1\\n\\nfor i, v in enumerate(u):\\n if total[v] == 0:\\n diferentes += 1\\n else:\\n suma[total[v]] -= 1\\n total[v] += 1\\n suma[total[v]] += 1\\n\\n maximo = max(maximo, total[v])\\n\\n", "gt": "#print(i, v, \":\", diferentes)\\n #print(suma)\\n #print(total)\\n #print(maximo, \":\", suma[maximo], suma[maximo+1], diferentes-1)\\n #print(maximo, \":\", suma[maximo-1], suma[maximo], diferentes-1)\\n\\n if diferentes <= 1:\\n sol = i\\n\\n if suma[maximo-1] == diferentes-1 and suma[maximo] == 1:\\n sol = i\\n\\n if suma[maximo] == diferentes-1 and suma[1] == 1:\\n sol = i\\n\\n if suma[1] == diferentes:\\n sol = i\\n \\n #print(\"SOL\", sol)\\n\\nprint(sol+1)\\n"}
{"id": "1975", "input": "import sys\\ninput = lambda: sys.stdin.readline().rstrip()\\n\\nN, M = list(map(int, input().split()))\\nX = []\\nfor _ in range(N):\\n a, b = list(map(int, input().split()))\\n X.append((a, b))\\nY = []\\nfor _ in range(M):\\n c, d = list(map(int, input().split()))\\n c, d = c, d+1\\n Y.append((c, d))\\nY.sort(key = lambda x: -x[0])\\n\\nZ", "gt": "= [0] * 1001001\\nfor a, b in X:\\n for c, d in Y:\\n if c >= a:\\n Z[c-a] = max(Z[c-a], d - b)\\n\\nans = 1 << 30\\nma = 0\\nfor i in range(1001000)[::-1]:\\n ma = max(ma, Z[i])\\n ans = min(ans, ma + i)\\nprint(ans)\\n\\n"}
{"id": "1976", "input": "n, m = map(int, input().split())\\nprint(n + m - 1)\\nfor i in range(1,", "gt": "m + 1):\\n print(1, i)\\nfor i in range(2, n + 1):\\n print(i, 1)"}
{"id": "1977", "input": "import sys\\nfrom operator import itemgetter\\n\\nn, m, k, q = list(map(int, input().split()))\\nquery = sorted((list(map(int, line.split()))\\n for line in sys.stdin), key=itemgetter(2))\\ntimes = [q[2] for q in query]\\n\\n\\ndef solve(ti):\\n imos = [[0]*(m+1) for _ in range(n+1)]\\n for i in range(ti):\\n imos[query[i][0]][query[i][1]] += 1\\n\\n for i in range(n+1):\\n for j in range(m):\\n imos[i][j+1] += imos[i][j]\\n for j in range(m+1):\\n for i in range(n):\\n imos[i+1][j] +=", "gt": "imos[i][j]\\n for i in range(k, n+1):\\n for j in range(k, m+1):\\n if imos[i][j] - imos[i-k][j] - imos[i][j-k] + imos[i-k][j-k] == k*k:\\n return True\\n return False\\n\\n\\ninf = len(times)+1\\nok, ng = inf, 0\\nwhile abs(ok - ng) > 1:\\n mid = (ok + ng) >> 1\\n if mid >= k*k and solve(mid):\\n ok = mid\\n else:\\n ng = mid\\n\\nprint(times[ok-1] if ok != inf else -1)\\n"}
{"id": "1978", "input": "from array import array\\ninf = (1 << 30)\\n\\ndef main():\\n (n,k) = [int(x) for x in input().split(' ')]\\n Matrix = []\\n for i in range(n):\\n Matrix.append(array('b',[ord(x) for x in input()]))\\n dp = [array('l', [inf for j in range(n)]) for i in range(n)]\\n direct = [[ord('d') for j in range(n)] for i in range(n)]\\n opt = \"\"\\n for s in range (2 * n - 1):\\n opchar = chr(ord('z') + 1)\\n positions = []\\n for i in range(0, s+1):\\n j = s - i;\\n if j < n and i < n:\\n if(i > 0 and j > 0):\\n if(dp[i-1][j] < dp[i][j-1]):\\n dp[i][j] = dp[i-1][j]\\n direct[i][j] =", "gt": "'l'\\n else:\\n dp[i][j] = dp[i][j-1]\\n direct[i][j] = 'd'\\n elif i > 0:\\n dp[i][j] = dp[i-1][j]\\n direct[i][j] = 'l'\\n elif j > 0:\\n dp[i][j] = dp[i][j-1]\\n direct[i][j] = 'd'\\n else:\\n dp[i][j] = 0\\n direct[i][j] = 'e'\\n if(dp[i][j] < k and Matrix[i][j] is not ord('a')):\\n dp[i][j]+=1\\n Matrix[i][j] = ord('a')\\n if(Matrix[i][j] < ord(opchar) and dp[i][j] <= k):\\n opchar = chr(Matrix[i][j])\\n for i in range(0, s+1):\\n j = s - i;\\n if j < n and i < n:\\n if(Matrix[i][j] is not ord(opchar)):\\n dp[i][j] = inf\\n ans = \"\"\\n a,b = (n-1,n-1)\\n while(direct[a][b] is not 'e'):\\n ans += chr(Matrix[a][b])\\n if(direct[a][b] is 'l'):\\n a-=1\\n else:\\n b-=1\\n ans += chr(Matrix[0][0])\\n print(ans[::-1])\\n\\nmain()\\n"}
{"id": "1979", "input": "n = int(input())\\nINF = 10 ** 18\\ng = [[INF for i in range(n)] for _ in range(n)]\\nfor i in range(n):\\n s = input().rstrip()\\n for j in range(n):\\n if s[j] == '1':\\n g[i][j] = 1\\n g[i][i] = 0\\nfor k in range(n):\\n for i in range(n):\\n for j in range(n):\\n", "gt": "g[i][j] = min(g[i][j], g[i][k] + g[k][j])\\nm = int(input())\\np = [int(i) - 1 for i in input().split()]\\nptr = 1\\nans = [p[0]]\\nwhile ptr + 1 < len(p):\\n s = ans[-1]\\n if g[s][p[ptr]] + 1 != g[s][p[ptr + 1]]:\\n ans.append(p[ptr])\\n ptr += 1\\nans.append(p[-1])\\nprint(len(ans))\\nfor i in ans:\\n print(i + 1, end=\" \")"}
{"id": "1980", "input": "from collections import Counter\\n\\nn = int(input())\\na = [int(x) for x in input().split()]\\nb = [int(x) for x in input().split()]\\n\\naidx = [-1]*n\\nbidx = [-1]*n\\n\\nfor", "gt": "i, (ai, bi) in enumerate(zip(a, b)):\\n aidx[ai-1] = i\\n bidx[bi-1] = i\\n\\ndiffs = [(aidx[i] - bidx[i]) % n for i in range(n)]\\nprint(max(Counter(diffs).values()))\\n"}
{"id": "1981", "input": "import sys\\nit = iter(sys.stdin.readlines())\\ninput = it.__next__\\nn, k = list(map(int, input().split()))\\nd, c = [0] * n, [0] * n\\nfor i in range(n):\\n a, b = list(map(int, input().split()))\\n d[i], c[i] = a, k - b\\n\\np, r, pre, suf, sm, mx = list(range(n)), [0] * n, c[:], c[:], c[:], c[:]\\n\\ndef find(x):\\n if x != p[x]:\\n p[x] = find(p[x])\\n return p[x]\\n\\ndef union(x, y, w):\\n x, y = find(x), find(y)\\n z = y if r[y]", "gt": "> r[x] else x\\n r[x] += r[x] == r[y]\\n mx[z] = max(mx[x], mx[y], suf[x] + pre[y])\\n pre[z] = max(pre[x], sm[x] + pre[y])\\n suf[z] = max(suf[x] + sm[y], suf[y])\\n sm[z] = sm[x] + sm[y]\\n p[x] = p[y] = z\\n return mx[z] - w ** 2\\n\\nans = max(0, max(c))\\nfor w, i in sorted((d[i + 1] - d[i], i) for i in range(n - 1)):\\n ans = max(ans, union(i, i + 1, w))\\nprint(ans)\\n"}
{"id": "1982", "input": "n, m = map(int, input().split())\\na = [0] + list(map(int, input().split()))\\nb = [0] + [set() for i in range(n) ]\\nk = 0\\nf = [0] * (n + 1)\\nf[1] = a[1]\\nfor i in range(n-1):\\n x, y = map(int, input().split())\\n b[x].add(y)\\n b[y].add(x)\\n \\nfrom collections import deque\\nd", "gt": "= deque()\\nd.append(1)\\nwhile len(d) > 0:\\n t = d.popleft()\\n if len(b[t]) == 0:\\n if f[t] <= m:\\n k += 1\\n for i in b[t]:\\n b[i].remove(t)\\n if a[i] == 0 and f[t] <= m:\\n f[i] = 0\\n else: \\n f[i] = f[t] + 1\\n d.append(i)\\nprint(k)"}
{"id": "1983", "input": "t = int(input())\\nfor _ in range(t):\\n n, k = map(int, input().split())\\n n", "gt": "-= k**2\\n if n<0:\\n print(\"NO\")\\n elif n%2 == 0:\\n print(\"YES\")\\n else:\\n print(\"NO\")"}
{"id": "1984", "input": "#list(map(int,input().split()))\\nt=int(input())\\nfor _ in", "gt": "range(t):\\n n=int(input())\\n it=list(map(int,input().split()))\\n print(len(set(it)))\\n"}
{"id": "1985", "input": "def put():\\n return list(map(int, input().split()))\\ndef diff(x,y):\\n ans = 0\\n for i in range(n*m):\\n if s[x][i]!= s[y][i]:\\n ans+=1\\n return ans\\ndef find(i):\\n if i==p[i]:\\n return i\\n p[i] = find(p[i])\\n return p[i]\\ndef union(i,j):\\n if rank[i]>rank[j]:\\n i,j = j,i\\n elif rank[i]==rank[j]:\\n rank[j]+=1\\n p[i]= j\\ndef dfs(i,p):\\n if i!=0:\\n print(i,p)\\n for j in tree[i]:\\n if j!=p:\\n dfs(j,i)\\n\\nn,m,k,w = put()\\ns =", "gt": "['']*k \\nfor i in range(k):\\n for j in range(n):\\n s[i]+=input()\\nedge = []\\nk+=1\\nrank = [0]*(k)\\np = list(range(k))\\ncost = 0\\ntree = [[] for i in range(k)]\\n\\nfor i in range(k):\\n for j in range(i+1,k):\\n if i==0:\\n z=n*m\\n else:\\n z = diff(i-1,j-1)*w\\n edge.append((z,i,j))\\n\\nedge.sort()\\nfor z,i,j in edge:\\n u = find(i)\\n v = find(j)\\n if u!=v:\\n union(u,v)\\n cost+= z\\n tree[i].append(j)\\n tree[j].append(i)\\n\\nprint(cost)\\ndfs(0,-1)\\n"}
{"id": "1986", "input": "def main():\\n from sys import stdin\\n k, n = map(int, stdin.readline().split())\\n a = list(map(int, stdin.readline().split()))\\n b = list(map(int, stdin.readline().split()))\\n res = set()\\n for i in range(k):\\n # putting b[0] on place i\\n our = set()\\n curr = b[0]\\n for j in range(i, -1,", "gt": "-1):\\n our.add(curr)\\n curr -= a[j]\\n first = curr\\n good = True\\n curr = b[0]\\n for j in range(i + 1, k):\\n curr += a[j]\\n our.add(curr)\\n for elem in b:\\n if elem not in our:\\n good = False\\n break\\n if good:\\n res.add(first)\\n print(len(res))\\n \\n \\nmain()"}
{"id": "1987", "input": "import sys\\n\\n(n, k) = [int(x) for x in sys.stdin.readline().strip().split()]\\n\\nans = -999999999999999999999999999999999999999999\\n\\nfor i in", "gt": "range(0, n):\\n (f, t) = [int(x) for x in sys.stdin.readline().strip().split()]\\n ans = max(ans, f-max(0,t-k))\\n\\nprint(ans)\\n"}
{"id": "1988", "input": "t = input()\\nt = t.split()\\nn = int(t[0])\\nc1 = int(t[1])\\nc2 = int(t[2])\\nt = input()\\nd = 0\\nfor i in t:\\n if(i==\"1\"):\\n d", "gt": "= d+1\\n\\nmin = 10**1488\\nfor i in range(1, d+1):\\n t = c1*i + i*c2*(((n//i)-1)**2) + c2*(n%i)*(2*(n//i)-1)\\n if t<min:\\n min = t\\n\\nprint(min)"}
{"id": "1989", "input": "#!/usr/bin/env python3\\nimport sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nfor _ in range(t):\\n n = int(input())\\n s = input().rstrip()\\n words = []\\n for i", "gt": "in range(n):\\n if (n - i) % 2 == 0:\\n words.append((s[i:] + s[:i], i+1))\\n else:\\n words.append((s[i:] + s[:i][::-1], i+1))\\n words.sort()\\n print(words[0][0])\\n print(words[0][1])\\n"}
{"id": "1990", "input": "INF = 10 ** 10\\ndef merge(l, r):\\n res = l + r\\n \\n i = j = k = 0\\n while i < len(l) and j < len(r):\\n if l[i] < r[j]:\\n res[k] = l[i]\\n k += 1\\n i += 1\\n else:\\n res[k] = r[j]\\n k += 1\\n j += 1\\n while i < len(l):\\n res[k] = l[i]\\n k += 1\\n i += 1\\n while j < len(r):\\n res[k] = r[j]\\n k += 1\\n j += 1\\n\\n return res\\n\\ndef solve(fl, fr, l, r):\\n if l == r:\\n return 0\\n \\n mid = (l + r) // 2\\n res = solve(fl, fr, l, mid) + solve(fl, fr, mid + 1, r)\\n\\n i, j =", "gt": "l, mid + 1\\n while i <= mid:\\n while j <= r and fr[j] < fl[i]:\\n j += 1\\n res += j - mid - 1\\n i += 1\\n fl[l: r + 1] = merge(fl[l: mid + 1], fl[mid + 1: r + 1])\\n fr[l: r + 1] = merge(fr[l: mid + 1], fr[mid + 1: r + 1])\\n return res\\n\\ndef __starting_point():\\n n = int(input())\\n a = list(map(int, input().split()))\\n\\n fl, cnt = [],"}
{"id": "1991", "input": "# reproduction of solution № 66039386 by @windhunterSB\\nimport sys\\n\\n\\n# inf = open('input.txt', 'r')\\n# reader = (line.rstrip() for line in inf)\\nreader = (s.rstrip() for s in sys.stdin)\\n\\nn = int(next(reader))\\noperations = next(reader)\\n\\n# inf.close()\\n\\nleft_sum = [0] * (n + 2) # for s[:i+1]\\nright_sum = [0] * (n + 2) # for s[i:][::-1]\\nleft_min = [0] * (n + 2) # min - validation of bracket sequence\\nright_min = [0] * (n + 2) \\nleft_max = [0] * (n + 2) # max - depth of bracket sequence\\nright_max = [0] * (n + 2)\\ntext = [0] * (n + 2) # entered text, letters marked as 0\\n\\nop_map = {'(': 1,\\n ')': -1}\\nans = []\\ni", "gt": "= 1 # cursor loc i >= 1\\nfor op in operations:\\n if op == 'L':\\n i = max(1, i - 1)\\n elif op == 'R':\\n i += 1\\n else:\\n text[i] = op_map.get(op, 0)\\n \\n left_sum[i] = left_sum[i - 1] + text[i]\\n left_min[i] = min(left_min[i - 1], left_sum[i])\\n left_max[i] = max(left_max[i - 1], left_sum[i])\\n \\n right_sum[i] = right_sum[i + 1] - text[i] # -text[i] cause of symmetry\\n right_min[i] = min(right_min[i + 1], right_sum[i])\\n right_max[i] = max(right_max[i + 1], right_sum[i])\\n \\n correct = left_min[i] >= 0 and right_min[i + 1] >= 0 and left_sum[i] == right_sum[i + 1]\\n status = max(left_max[i], right_max[i + 1]) if correct else -1\\n ans.append(status)\\n \\nprint(*ans)\\n"}
{"id": "1992", "input": "from math import *\\n\\ndef r1(t):\\n return t(input())\\n\\ndef r2(t):\\n return [t(i) for i in input().split()]\\n\\nfor _ in range(r1(int)):\\n n = r1(int)\\n a = r2(int)\\n g = True\\n for i in range(n):\\n if a[i] != i + 1:\\n g = False\\n", "gt": "break\\n if g:\\n print(0)\\n continue\\n\\n g = True\\n c = 0\\n p = False\\n for i in range(n):\\n if a[i] != i + 1:\\n if p == False:\\n c += 1\\n p = True\\n else:\\n p = False\\n print(min(c, 2))\\n"}
{"id": "1993", "input": "n, m, k = map(int, input().split())\\narr = [0] * n\\npl = [0] * n\\nz = 0\\nfor i in input().split():\\n j = int(i)\\n arr[j - 1] = z\\n pl[z] = j - 1\\n z += 1\\n#print(arr, pl)\\nr = 0\\nfor", "gt": "i in input().split():\\n j = int(i) - 1\\n c = arr[j]\\n r += c // k + 1\\n if c != 0:\\n pl[c - 1], pl[c] = pl[c], pl[c - 1]\\n arr[pl[c]] += 1\\n arr[j] -= 1\\n #print(arr, pl)\\nprint(r)"}
{"id": "1994", "input": "\"\"\"\\n Author : Arif Ahmad\\n Date : \\n Algo : \\n Difficulty : \\n\"\"\"\\nfrom sys import stdin, stdout\\nfrom collections import deque\\n\\ng = None # contains the actual graph\\nh = None # h[x][y] represents the component in which cell (x,y) belongs\\nr = None\\nc = None\\nvisited = None\\ntotal = None\\ncomp = None\\ndx = [-1, 0, 0, 1]\\ndy = [0, -1, 1, 0]\\n\\n\\ndef bfs(x, y):\\n nonlocal total\\n \\n q = deque([(x, y)])\\n total += 1\\n visited[x][y] = True\\n h[x][y] = comp\\n while q:\\n x, y = q.pop()\\n #print('comp:', comp, 'cell:', x, y)\\n for k in range(4):\\n #print('loop:', k)\\n nx = x + dx[k]\\n ny = y + dy[k]\\n #print(visited)\\n #print('new cell:', nx, ny, 'check:', nx>=0 , nx<r , ny>=0 , ny<c , visited[nx][ny]==False , g[nx][ny]=='.')\\n if nx>=0 and nx<r and ny>=0 and ny<c and visited[nx][ny]==False and g[nx][ny]=='.':\\n q.appendleft((nx, ny))\\n total += 1\\n visited[nx][ny] = True\\n h[nx][ny] = comp\\n\\n\\ndef main():\\n nonlocal g,", "gt": "h, r, c, visited, comp, total\\n\\n r, c = [int(_) for _ in stdin.readline().split()]\\n\\n g = []\\n for i in range(r):\\n line = stdin.readline()\\n g.append(list(line))\\n\\n component = []\\n h = [[-1 for i in range(c)] for j in range(r)]\\n visited = [[False for i in range(c)] for j in range(r)]\\n #print(visited)\\n\\n for i in range(r):\\n for j in range(c):\\n if visited[i][j] == False and g[i][j] == '.':\\n comp = len(component)\\n total = 0\\n #print('calling bfs', i, j)\\n bfs(i, j)\\n component.append(total)\\n\\n for x in range(r):\\n for y in range(c):\\n if g[x][y] == '*':\\n ans = 0\\n idx = set()\\n for k in range(4):\\n nx = x + dx[k]\\n ny = y + dy[k]\\n if nx>=0 and nx<r and ny>=0 and ny<c and g[nx][ny]=='.':\\n idx.add(h[nx][ny])\\n for item in idx:\\n #print(component[item])\\n ans += component[item]\\n ans += 1\\n ans %= 10\\n g[x][y] = str(ans)\\n\\n #print(component)\\n for i in range(r):\\n stdout.write(''.join(g[i]))\\n\\n \\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1995", "input": "s = input()\\nn = len(s)\\np = [0] * n\\nk = 0\\nfor i in range(1, n):\\n while k != 0 and s[k] != s[i]:\\n k = p[k - 1]\\n if s[k] == s[i]:\\n k += 1\\n p[i] = k\\na = []\\nk = n\\nwhile", "gt": "k != 0:\\n a += [k]\\n k = p[k - 1]\\nc = [0] * (n + 1)\\nfor i in range(n):\\n c[p[i]] += 1\\nfor i in range(n - 1, 1, -1):\\n c[p[i - 1]] += c[i]\\nprint(len(a))\\nfor t in reversed(a):\\n print(t, c[t] + 1)"}
{"id": "1996", "input": "s=input()\\ndef shift(x,k):\\n x=x[-k:]+x[:-k]\\n return x\\nfor i", "gt": "in range(int(input())):\\n l,r,k=tuple(map(int,input().split()))\\n l-=1\\n k%=(r-l)\\n s=s[:l]+shift(s[l:r],k)+s[r:]\\nprint(s)\\n"}
{"id": "1997", "input": "n=int(input())\\nc=set('qwertyuiopasdfghjklzxcvbnm')\\nch=False\\nk=0\\nfor i in range(n-1):\\n s=input()\\n if ch:\\n if s[0]!='.':\\n k+=1\\n else:\\n if s[0]=='.':\\n", "gt": "c.difference_update(set(s[2:]))\\n elif s[0]=='!':\\n c.intersection_update(set(s[2:]))\\n else:\\n if s[2] in c:\\n c.remove(s[2])\\n if len(c)==1:\\n ch=True\\ninput()\\nprint(k)"}
{"id": "1998", "input": "import sys\\nfin = sys.stdin\\nn = int(fin.readline())\\nut = [-1] * n\\nvc = [[] for i in range(0, n)]\\ncvc = [[] for i in range(0, n)]\\nnr = [0] * n\\nfor i in range(0, n - 1):\\n a, b = [int(number) for number in fin.readline().split()]\\n a -= 1\\n b -= 1\\n vc[a].append(b)\\n cvc[b].append(a)\\n nr[a] += 1\\nsize = [0] * n\\nmx = [0] * n\\ndef nonzero(x):\\n if not x:\\n return 0\\n return 1\\nstk = []\\nsize = [0] * n\\nfor i in range(0, n):\\n if nr[i] == 0:\\n stk.append(i)\\n size[i] = 1\\norder = []\\nwhile nonzero(stk):\\n x = stk.pop(-1)\\n order.append(x)\\n for p in cvc[x]:\\n nr[p] -= 1\\n if nr[p] ==", "gt": "0:\\n stk.append(p)\\nh = [0] * n\\nfor i in range(n - 1, -1, -1):\\n x = order[i]\\n for p in vc[x]:\\n h[p] = h[x] + 1\\n#parcurg\\nfor x in order:\\n for p in vc[x]:\\n size[x] += size[p]\\n#maximum\\ndef solv(tp, mx):\\n for x in order:\\n if h[x] % 2 == tp:\\n r = 999999999\\n for p in vc[x]:\\n r = min(r, size[p] - mx[p] + 1)\\n if r == 999999999:\\n r = 1\\n mx[x] = r\\n else:\\n r = 0\\n for p in vc[x]:\\n r += size[p] - mx[p]\\n mx[x] = r + 1\\nsolv(0, mx)\\nprint(size[0] - mx[0] + 1, end = ' ')\\nsolv(1, mx)\\nprint(size[0] - mx[0] + 1)\\n"}
{"id": "1999", "input": "def sum_zeroth(arr):\\n res = 0\\n for elem in arr:\\n res += elem[0]\\n return res\\n\\nn, a, b, k = list(map(int, input().split()))\\ndata = input()\\ndist = []\\npp = 0\\n\\nlast = 0\\nfor i in range(n):\\n if data[i] == '1':\\n dist.append((last, i))\\n pp += (i - last) // b\\n last = i + 1\\n\\ndist.append((last,", "gt": "n))\\npp += (n - last) // b\\npos = []\\nminp = pp - a + 1\\nfnd = False\\n\\nfor elem in dist:\\n cur = elem[0] - 1\\n while (cur + b) < elem[1]:\\n cur += b\\n pos.append(cur + 1)\\n if len(pos) == minp:\\n fnd = True\\n break\\n if fnd:\\n break\\n\\nprint(minp)\\nprint(' '.join(map(str, pos)))\\n"}
{"id": "2000", "input": "n = int(input())\\n\\nxs = [int(x) for x in input().split()]\\n\\npos = {}\\nfor i, x in enumerate(xs):\\n while x", "gt": "in pos:\\n del pos[x]\\n x *= 2\\n pos[x] = i\\n\\nks = sorted(list(pos.keys()), key=lambda k: pos[k])\\n\\nprint(len(ks))\\nprint(\" \".join(map(str, ks)))\\n"}
