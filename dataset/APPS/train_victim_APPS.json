{"id": "1", "input": "for _ in range(int(input())):\\n n = int(input())\\n mass = []\\n zo = 0\\n oz = 0\\n zz = 0\\n oo = 0\\n ozs = []\\n zos = []\\n ozss = set()\\n zoss = set()\\n for j in range(n):\\n k = input()\\n mass.append(k)\\n if k[0] == '0' and k[-1] == '1':\\n zoss.add(k)\\n zos.append(j + 1)\\n zo += 1\\n elif k[0] == '1' and k[-1] == '0':\\n ozss.add(k)\\n ozs.append(j + 1)\\n oz += 1\\n elif k[0] == '0' and k[-1] == '0':\\n zz += 1\\n else:\\n oo += 1\\n if zz and oo and not oz and", "gt": "not zo:\\n print(-1)\\n continue\\n else:\\n if zo > oz:\\n print((zo - oz) // 2)\\n ans = []\\n need = (zo - oz) // 2\\n i = 0\\n while need:\\n zzz = mass[zos[i] - 1][len(mass[zos[i] - 1]) - 1:: -1]\\n if zzz not in ozss:\\n ans.append(zos[i])\\n need -= 1\\n i += 1\\n print(*ans)\\n else:\\n print((oz - zo) // 2)\\n ans = []\\n need = (oz - zo) // 2\\n i = 0\\n while need:\\n zzz = mass[ozs[i] - 1][len(mass[ozs[i] - 1]) - 1:: -1]\\n if zzz not in zoss:\\n ans.append(ozs[i])\\n need -= 1\\n i += 1\\n print(*ans)\\n"}
{"id": "2", "input": "q=int(input())\\n\\nfor e in range(q):\\n x,y,k=list(map(int,input().split()))\\n x,y=abs(x),abs(y)\\n x,y=max(x,y),min(x,y)\\n \\n if(x%2!=k%2):\\n k-=1\\n y-=1\\n", "gt": "\\n \\n if(x>k):\\n print(-1)\\n continue\\n if((x-y)%2):\\n k-=1\\n x-=1\\n print(k)\\n \\n \\n \\n"}
{"id": "3", "input": "import sys\\nimport random\\nfrom fractions import Fraction\\nfrom math import *\\n \\ndef input():\\n return sys.stdin.readline().strip()\\n \\ndef iinput():\\n return int(input())\\n\\ndef finput():\\n return float(input())\\n\\ndef tinput():\\n return input().split()\\n\\ndef linput():\\n return list(input())\\n \\ndef rinput():\\n return list(map(int, tinput()))\\n\\ndef fiinput():\\n return list(map(float, tinput()))\\n \\ndef rlinput():\\n return list(map(int, input().split()))\\ndef trinput():\\n return tuple(rinput())\\n\\ndef srlinput():\\n return sorted(list(map(int, input().split())))\\n\\ndef NOYES(fl):\\n if fl:\\n print(\"NO\")\\n else:\\n print(\"YES\")\\ndef YESNO(fl):\\n if fl:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n \\ndef main():\\n n = iinput()\\n #k = iinput() \\n #m = iinput() \\n #n = int(sys.stdin.readline().strip()) \\n #n, k = rinput()\\n #n, m = rinput()\\n #m, k = rinput()\\n #n, k, m = rinput()\\n", "gt": "#n, m, k = rinput()\\n #k, n, m = rinput()\\n #k, m, n = rinput() \\n #m, k, n = rinput()\\n #m, n, k = rinput()\\n q = [rlinput(), rlinput(), rlinput()]\\n #q = linput()\\n ans = q[0].copy()\\n for i in range(1, n):\\n if ans[i] == ans[i - 1]:\\n ans[i] = q[1][i]\\n if i == n - 1:\\n o = 0\\n while q[o][i] == ans[n - 2] or q[o][i] == ans[0]:\\n o += 1\\n ans[i] = q[o][i]\\n print(*ans)\\n\\n \\n\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\\nfor i in range(iinput()):\\n main()\\n"}
{"id": "4", "input": "def solve():\\n n, k = map(int,input().split())\\n lst = list(map(int,input().split()))\\n lst.sort()\\n ans = 0\\n for i", "gt": "in range(n - k - 1, n):\\n ans += lst[i]\\n print(ans)\\nfor i in range(int(input())):\\n solve()"}
{"id": "5", "input": "for _ in range(int(input())):\\n input()\\n nums = [int(x) for x in input().split()]\\n new_ar = list(zip(nums,[i for i in range(len(nums))]))\\n new_ar.sort()\\n \\n maxx =", "gt": "new_ar[0][1]\\n minn = new_ar[0][1]\\n s=\"1\"\\n for j in range(1,len(new_ar)):\\n if(new_ar[j][1]>maxx):\\n maxx = new_ar[j][1]\\n if(new_ar[j][1]<minn):\\n minn = new_ar[j][1]\\n if(maxx-minn<j+1):\\n s+=\"1\"\\n else:\\n s+=\"0\"\\n \\n print(s)"}
{"id": "6", "input": "def possible(a):\\n ans = set()\\n s = set()\\n lmax = 0\\n for i in range(len(a)):\\n lmax = max(lmax, a[i])\\n s.add(a[i])\\n if lmax == i + 1 and len(s) == i + 1:\\n ans.add(i + 1)\\n return ans\\n\\n\\nt = int(input())\\nfor case_num", "gt": "in range(t):\\n n = int(input())\\n a = list(map(int, input().split(' ')))\\n left = possible(a)\\n a.reverse()\\n right = possible(a)\\n ans = []\\n for l in left:\\n if n - l in right:\\n ans.append(l)\\n print(len(ans))\\n for l in ans:\\n print(l, n - l)\\n"}
{"id": "7", "input": "import sys\\ninput = sys.stdin.readline\\nfor f in range(int(input())):\\n n,m=list(map(int,input().split()))\\n neig=[0]*n\\n for i in range(n):\\n neig[i]=[0]\\n \\n for i in range(m):\\n a,b=list(map(int,input().split()))\\n a-=1\\n b-=1\\n neig[a][0]+=1\\n neig[a].append(b)\\n lev=[1]*n\\n", "gt": "for i in range(n):\\n for j in range(1,neig[i][0]+1):\\n x=lev[i]+1\\n if x==4:\\n x=1\\n lev[neig[i][j]]=max(lev[neig[i][j]],x)\\n sol=0\\n s=[]\\n for i in range(n):\\n if lev[i]==3:\\n sol+=1\\n s.append(i+1)\\n print(sol)\\n print(*s)\\n \\n"}
{"id": "8", "input": "import sys\\ndef I():\\n return sys.stdin.readline().rstrip()\\n\\nclass Heap:\\n def __init__( self ):\\n self.l = [ -1 ]\\n self.n = 0\\n def n( self ):\\n return self.n\\n def top( self ):\\n return self.l[ 1 ]\\n def ins( self, x ):\\n self.l.append( x )\\n n = len( self.l ) - 1\\n i = n\\n while i > 1:\\n j = i // 2\\n if self.l[ j ] > self.l[ i ]:\\n self.l[ j ], self.l[ i ] = self.l[ i ], self.l[ j ]\\n i = j\\n else:\\n break\\n def pop( self ):\\n r = self.l[ 1 ]\\n l = self.l.pop()\\n n = len( self.l ) - 1\\n if n:\\n self.l[ 1 ] = l\\n i = 1\\n while True:\\n j = i * 2\\n k = j + 1\\n if k < len( self.l ) and self.l[ i ] > max( self.l[ j ], self.l[ k ] ):\\n if self.l[ j ] == min( self.l[ j ], self.l[ k ] ):\\n self.l[ i ], self.l[ j ] = self.l[ j ], self.l[ i ]\\n i = j\\n else:\\n self.l[ i ], self.l[ k ] = self.l[ k ], self.l[ i ]\\n", "gt": "i = k\\n elif k < len( self.l ) and self.l[ i ] > self.l[ k ]:\\n self.l[ i ], self.l[ k ] = self.l[ k ], self.l[ i ]\\n i = k\\n elif j < len( self.l ) and self.l[ i ] > self.l[ j ]:\\n self.l[ i ], self.l[ j ] = self.l[ j ], self.l[ i ]\\n i = j\\n else:\\n break\\n return r\\n\\nt = int( I() )\\nfor _ in range( t ):\\n n = int( I() )\\n voter = [ list( map( int, I().split() ) ) for _ in range( n ) ]\\n h = Heap()\\n d ="}
{"id": "9", "input": "import sys\\ninput = sys.stdin.readline\\n\\ndef main():\\n n, k = map(int, input().split())\\n string = input().strip()\\n if \"W\" not in string:\\n ans = min(n, k) * 2 - 1\\n print(max(ans, 0))\\n return\\n \\n L_s = []\\n cnt = 0\\n bef = string[0]\\n ans = 0\\n for s in string:\\n if s == bef:\\n cnt += 1\\n else:\\n if bef == \"L\":\\n L_s.append(cnt)\\n else:\\n ans += cnt * 2 - 1\\n cnt = 1\\n bef", "gt": "= s\\n if bef == \"W\":\\n ans += cnt * 2 - 1\\n cnt = 0\\n \\n if string[0] == \"L\" and L_s:\\n cnt += L_s[0]\\n L_s = L_s[1:]\\n L_s.sort()\\n for l in L_s:\\n if k >= l:\\n ans += l * 2 + 1\\n k -= l\\n else:\\n ans += k * 2\\n k = 0\\n \\n ans += 2 * min(k, cnt)\\n print(ans)\\n \\n \\n \\nfor _ in range(int(input())):\\n main()"}
{"id": "10", "input": "for _ in range(int(input())):\\n s = input()\\n p = [i for i in", "gt": "s.split(\"0\") if i!=\"\"]\\n p.sort(reverse=True)\\n ans = 0\\n for i in range(0,len(p),2):\\n ans+=len(p[i])\\n print(ans)\\n\\n"}
{"id": "11", "input": "for _ in range(int(input())):\\n # n, x = map(int, input().split())\\n n = int(input())\\n arr = list(map(int, input().split()))\\n ans = [arr[0]]\\n for i in range(1, n - 1):\\n if", "gt": "arr[i - 1] < arr[i] and arr[i] > arr[i + 1]:\\n ans.append(arr[i])\\n elif arr[i - 1] > arr[i] and arr[i] < arr[i + 1]:\\n ans.append(arr[i])\\n ans.append(arr[-1])\\n print(len(ans))\\n print(*ans)"}
{"id": "12", "input": "n = int(input())\\n\\ndef area(width, height) :\\n return (width+1) * (height+1)\\n\\ndef calcul(s1, c, s2) :\\n maxx, maxy, minx, miny = 0, 0, 0, 0\\n x, y = 0, 0\\n for k in range(len(s1)) :\\n if s1[k] == \"W\" :\\n y += 1\\n if s1[k] == \"S\" :\\n y -= 1\\n if s1[k] == \"A\" :\\n x -= 1\\n if s1[k] == \"D\" :\\n x += 1\\n maxx = max(maxx, x)\\n minx = min(minx, x)\\n\\n maxy = max(maxy, y)\\n miny = min(miny, y)\\n\\n\\n\\n\\n if c == \"W\" :\\n y += 1\\n elif c == \"S\" :\\n y -= 1\\n elif c == \"A\" :\\n x -= 1\\n elif c == \"D\" :\\n x += 1\\n else :\\n print(c, \"ok\")\\n\\n maxx = max(maxx, x)\\n minx = min(minx, x)\\n\\n maxy = max(maxy, y)\\n miny = min(miny, y)\\n\\n for k in range(len(s2)) :\\n if s2[k] == \"W\" :\\n y += 1\\n if s2[k] == \"S\" :\\n y -= 1\\n if s2[k] == \"A\" :\\n x -= 1\\n if s2[k] == \"D\" :\\n x += 1\\n maxx = max(maxx, x)\\n minx = min(minx, x)\\n\\n maxy = max(maxy, y)\\n miny = min(miny, y)\\n\\n\\n\\n diffx = maxx - minx\\n diffy = maxy - miny\\n tmp = area(diffx, diffy)\\n\\n\\n return tmp\\n\\ndef pre_calcul(s, moment, pre_avant, date_debut) :\\n x, y, maxx, minx, maxy, miny = pre_avant\\n for k in range(date_debut, moment) :\\n if s[k] == \"W\" :\\n y += 1\\n if s[k] == \"S\" :\\n y -= 1\\n if s[k] == \"A\" :\\n x -= 1\\n if s[k] == \"D\" :\\n x += 1\\n maxx = max(maxx, x)\\n minx = min(minx, x)\\n\\n maxy = max(maxy, y)\\n miny = min(miny, y)\\n\\n return (x, y, maxx, minx, maxy, miny)\\n\\ndef calcul2(s, c, moment, precalcul) :\\n x, y, maxx, minx, maxy, miny = precalcul\\n\\n\\n\\n if c == \"W\" :\\n y += 1\\n elif c == \"S\" :\\n y -= 1\\n elif c == \"A\" :\\n x", "gt": "-= 1\\n elif c == \"D\" :\\n x += 1\\n else :\\n print(c, \"ok\")\\n\\n maxx = max(maxx, x)\\n minx = min(minx, x)\\n\\n maxy = max(maxy, y)\\n miny = min(miny, y)\\n\\n for k in range(moment, len(s)) :\\n if s[k] == \"W\" :\\n y += 1\\n if s[k] == \"S\" :\\n y -= 1\\n if s[k] == \"A\" :\\n x -= 1\\n if s[k] == \"D\" :\\n x += 1\\n maxx = max(maxx, x)\\n minx = min(minx, x)\\n\\n maxy = max(maxy, y)\\n miny = min(miny, y)\\n\\n\\n\\n diffx = maxx - minx\\n diffy = maxy - miny\\n tmp = area(diffx, diffy)\\n\\n\\n return tmp\\n\\nfor _ in range(n) :\\n s = input()\\n maxx, maxy, minx, miny = 0, 0, 0, 0\\n x, y = 0, 0\\n momentminx, momentmaxx, momentminy, momentmaxy = -1, -1, -1, -1\\n for k in range(len(s)) :\\n if s[k] == \"W\" :\\n y += 1\\n if s[k] == \"S\" :\\n y -= 1\\n if s[k] == \"A\" :\\n x -= 1\\n if s[k] == \"D\" :\\n x += 1\\n\\n if x > maxx :\\n momentmaxx = k\\n if y > maxy :\\n momentmaxy = k\\n if x < minx :\\n momentminx = k\\n if y < miny :\\n momentminy = k\\n maxx = max(maxx, x)\\n minx = min(minx, x)\\n\\n maxy = max(maxy, y)\\n miny = min(miny, y)\\n diffx = maxx - minx\\n diffy = maxy - miny\\n\\n\\n tmp = 999999999999999999999999999999999999\\n l = [momentmaxx, momentmaxy, momentminx, momentminy]\\n l = list(set(l))\\n l = [i for i in l if i != -1]\\n l.sort()\\n if l != [] :\\n precalcul = pre_calcul(s, l[0], (0, 0, 0, 0, 0, 0), 0)\\n avant = l[0]\\n for moment in l :\\n precalcul = pre_calcul(s, moment, precalcul, avant)\\n avant = moment\\n tmp = min(tmp, calcul2(s, 'W', moment, precalcul))\\n tmp = min(tmp, calcul2(s, 'S', moment, precalcul))\\n tmp = min(tmp, calcul2(s, 'A', moment, precalcul))\\n tmp = min(tmp, calcul2(s, 'D', moment, precalcul))\\n print(tmp)\\n"}
{"id": "13", "input": "from math import *\\n\\nmod = 1000000007\\n\\nfor zz in range(int(input())):\\n n = int(input())\\n a = [ int(i) for i in input().split()]\\n b = [int(i) for i in input().split()]\\n ha = True\\n hp = False\\n hm = False\\n for i in range(n):\\n if b[i]", "gt": "!= a[i]:\\n if b[i] > a[i]:\\n if (hp):\\n pass\\n else:\\n ha = False\\n break\\n else:\\n if (hm):\\n pass\\n else:\\n ha = False\\n break\\n if a[i] > 0:\\n hp = True\\n elif a[i] < 0:\\n hm = True\\n\\n if ha:\\n print('YES')\\n else:\\n print('NO')\\n"}
{"id": "14", "input": "for i in", "gt": "range(int(input())):\\n n,g,b=map(int,input().split())\\n nn=(n+1)//2\\n print(max(nn+(nn-1)//g*b,n))"}
{"id": "15", "input": "for _ in range(int(input())):\\n a1, b1 = list(map(int, input().split()))\\n a2, b2 = list(map(int, input().split()))\\n if a1 > b1:\\n a1, b1 = b1, a1\\n if a2 > b2:\\n a2, b2 = b2, a2\\n flag", "gt": "= False\\n if a1 == a2 and a1 == b1 + b2:\\n flag = True\\n if b1 == b2 and b1 == a1 + a2:\\n flag = True\\n print('Yes' if flag else 'No')\\n"}
{"id": "16", "input": "from math import *\\n\\nzzz = int(input())\\nfor zz in range(zzz):\\n a, b, x,", "gt": "y = list(map(int, input().split()))\\n print(max(x*b, (a-x-1)*b, y*a, (b - y - 1)*a))\\n"}
{"id": "17", "input": "from math import sqrt\\nclass pro(object):\\n def __init__(self,dif,sc):\\n self.dif=dif\\n self.sc=sc\\n\\n def __lt__(self,other):\\n return self.dif>other.dif\\n\\nT=int(input())\\nmul=[1]\\nfor i in range(100):\\n mul.append(mul[i]*10/9)\\ninf=1000000007\\nfor t in range(T):\\n n=int(input())\\n effi,tim=list(map(float,input().split()))\\n prob=[]\\n for i in range(n):\\n x,y=list(map(int,input().split()))\\n prob.append(pro(x,y))\\n prob.sort()\\n f=[[inf for i in range(n+1)] for j in", "gt": "range(1001)]\\n f[0][0]=0\\n totsc=0\\n for i in range(n):\\n totsc+=prob[i].sc\\n for j in range(totsc,prob[i].sc-1,-1):\\n for k in range(1,i+2):\\n f[j][k]=min(f[j][k],f[j-prob[i].sc][k-1]+prob[i].dif*mul[k])\\n for i in range(totsc,-1,-1):\\n flag=False\\n for j in range(n+1):\\n if sqrt(effi*f[i][j])>=1:\\n res=2*sqrt(f[i][j]/effi)-1/effi+10*j\\n else:\\n res=f[i][j]+10*j\\n if res<=tim:\\n print(i)\\n flag=True\\n break\\n if flag==True:\\n break\\n"}
{"id": "18", "input": "class BIT():\\n def __init__(self,n):\\n self.BIT=[0]*(n+1)\\n self.num=n\\n\\n def query(self,idx):\\n res_sum = 0\\n while idx > 0:\\n res_sum += self.BIT[idx]\\n idx -= idx&(-idx)\\n return res_sum\\n\\n #Ai += x O(logN)\\n def update(self,idx,x):\\n while idx <= self.num:\\n self.BIT[idx] += x\\n idx += idx&(-idx)\\n return\\n\\nimport", "gt": "sys,random\\n\\ninput=sys.stdin.readline\\n\\nfor _ in range(int(input())):\\n n=int(input())\\n a=list(map(int,input().split()))\\n pair=[[] for i in range(n+1)]\\n for i in range(n):\\n for j in range(i+1,n):\\n if a[i]==a[j]:\\n pair[i+1].append(j+1)\\n\\n bit=BIT(n)\\n ans=0\\n for i in range(1,n+1):\\n minus=bit.query(i)\\n for r in pair[i]:\\n ans+=bit.query(r-1)-minus\\n for r in pair[i]:\\n bit.update(r,1)\\n\\n print(ans)\\n \\n"}
{"id": "19", "input": "import math\\n\\nT = int(input())\\nfor _", "gt": "in range(T):\\n n = int(input())\\n print(1/math.tan(math.pi/2/n))\\n"}
{"id": "20", "input": "for _ in range(int(input())):\\n n, k, d = list(map(int, input().split()))\\n a = list(map(int, input().split()))\\n s = {}\\n for q in range(d):\\n s[a[q]] = s.get(a[q], 0)+1\\n ans", "gt": "= len(s)\\n for q in range(d, n):\\n if s[a[q-d]] == 1:\\n del s[a[q-d]]\\n else:\\n s[a[q-d]] -= 1\\n s[a[q]] = s.get(a[q], 0)+1\\n ans = min(ans, len(s))\\n print(ans)\\n"}
{"id": "21", "input": "q = int(input())\\nfor _ in range(q):\\n n, m = list(map(int, input().split()))\\n info = [list(map(int, input().split())) for i in range(n)]\\n info = sorted(info)\\n now =(m, m)\\n time = 0\\n flag = True\\n for i in range(n):\\n t, l, h = info[i]\\n l_now = now[0]", "gt": "- (t - time)\\n h_now = now[1] + (t - time)\\n time = t\\n if h < l_now or h_now < l:\\n flag = False\\n else:\\n l_now = max(l_now, l)\\n h_now = min(h_now, h)\\n now = (l_now, h_now)\\n if flag:\\n print(\"YES\")\\n else:\\n print(\"NO\")"}
{"id": "22", "input": "t = int(input())\\n\\nfor _ in range(t):\\n n = list(input().strip())\\n s = list(map(int, input().strip().split()))\\n\\n check = set(s)\\n found = False\\n for i in", "gt": "range(1, 1025):\\n newset = set([e^i for e in s])\\n if check == newset:\\n print(i)\\n found = True\\n break\\n if not found:\\n print(-1)\\n"}
{"id": "23", "input": "import sys\\n\\ninput = sys.stdin.readline\\n\\nfor _ in range(int(input())):\\n a, k = list(map(int, input().split()))\\n for _", "gt": "in range(k - 1):\\n if '0' in str(a):\\n break\\n a += int(min(list(str(a)))) * int(max(list(str(a))))\\n print(a)\\n"}
{"id": "24", "input": "import heapq\\n\\nfor _ in range(int(input())):\\n n = int(input())\\n voters = []\\n for i in range(n):\\n m,p = list(map(int, input().split()))\\n voters.append((m, -p))\\n voters.sort()\\n for i in range(n):\\n voters[i] = (voters[i][0], -voters[i][1])\\n\\n ans = 0\\n costs = []\\n", "gt": "heapq.heapify(costs)\\n bought = 0\\n for i in range(n-1, -1, -1):\\n buysNeeded = voters[i][0] - i - bought\\n heapq.heappush(costs, voters[i][1])\\n while buysNeeded > 0 and len(costs) > 0:\\n ans += heapq.heappop(costs)\\n bought += 1\\n buysNeeded -= 1\\n\\n print(ans)\\n"}
{"id": "25", "input": "for _ in range(int(input())):\\n d=int(input())\\n anws=False\\n if d**2>=4*d:\\n root=(d**2-4*d)**0.5\\n", "gt": "a=(d+root)/2\\n b=(d-root)/2\\n anws=True\\n if anws:\\n print(\"Y"}
{"id": "26", "input": "import os\\nfrom io import BytesIO\\nimport sys\\nimport threading\\n\\n\\nsys.setrecursionlimit(10 ** 9)\\nthreading.stack_size(67108864)\\n\\n\\ndef main():\\n\\n # input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\\n\\n def ad(i, j):\\n nonlocal g\\n if j in g[i]:\\n g[i].remove(j)\\n g[j].remove(i)\\n else:\\n g[i].add(j)\\n g[j].add(i)\\n\\n def dfs(v):\\n nonlocal used, g, nans\\n used[v] = True\\n nans.append(v + 1)\\n for el in g[v]:\\n if not used[el]:\\n dfs(el)\\n\\n for _ in range(int(input())):\\n n = int(input())\\n cnt = [set() for i in range(n)]\\n g = [set() for i in range(n)]\\n used = [False] * n\\n triangles = []\\n for i in range(n - 2):\\n a, b,", "gt": "c = map(int, input().split())\\n a -= 1\\n b -= 1\\n c -= 1\\n cnt[a].add(i)\\n cnt[b].add(i)\\n cnt[c].add(i)\\n triangles.append((a, b, c))\\n ad(a, b)\\n ad(b, c)\\n ad(a, c)\\n q = []\\n ones = []\\n for i in range(n):\\n if len(cnt[i]) == 1:\\n ones.append(i)\\n ans = []\\n nans = []\\n for i in range(n - 2):\\n t = ones.pop()\\n ind = cnt[t].pop()\\n ans.append(ind + 1)\\n cnt[triangles[ind][0]].discard(ind)\\n cnt[triangles[ind][1]].discard(ind)\\n cnt[triangles[ind][2]].discard(ind)\\n if len(cnt[triangles[ind][0]]) == 1:\\n ones.append(triangles[ind][0])\\n if len(cnt[triangles[ind][1]]) == 1:\\n ones.append(triangles[ind][1])\\n if len(cnt[triangles[ind][2]]) == 1:\\n ones.append(triangles[ind][2])\\n dfs(0)\\n print(*nans)\\n print(*ans)\\n\\n\\ntt = threading.Thread(target = main)\\ntt.start()"}
{"id": "27", "input": "for _ in range(int(input())):\\n n, m = list(map(int, input().split()))\\n if n < m:\\n n, m = m, n #", "gt": "n > m\\n\\n if m == 1:\\n print(\"YES\")\\n continue\\n\\n if m == 2 and n == 2:\\n print(\"YES\")\\n continue\\n\\n print(\"NO\")\\n"}
{"id": "28", "input": "tests = int(input())\\nfor test in range(tests):\\n n = int(input())\\n a = [int(i) for i in input().split()]\\n d = {}\\n for i in range(n):\\n s = 0\\n while a[i] % 2", "gt": "== 0:\\n a[i] //= 2\\n s += 1\\n if a[i] in list(d.keys()):\\n d[a[i]] = max(s, d[a[i]])\\n else:\\n d[a[i]] = s\\n s = 0\\n for i in list(d.keys()):\\n s += d[i]\\n print(s)\\n"}
{"id": "29", "input": "import sys\\nINF = 10**20\\nMOD = 10**9 + 7\\nI = lambda:list(map(int,input().split()))\\nfrom math import gcd\\nfrom math import ceil\\nfrom collections import defaultdict as dd, Counter\\nfrom bisect import bisect_left as bl, bisect_right as br\\n\\n\\n\"\"\"\\nFacts and Data representation\\nConstructive? Top bottom up down\\n\"\"\"\\ndef check(s):\\n t = 'abacaba'\\n ans = 0\\n for i in range(len(s)):\\n if s[i: i + 7] == t:\\n ans += 1\\n return ans\\n\\ndef solve():\\n n, = I()\\n s = input()\\n t = 'abacaba'\\n cnt = check(s)\\n if cnt > 1:\\n print('No')\\n return\\n elif cnt == 1:\\n s =", "gt": "list(s)\\n for i in range(n):\\n if s[i] == '?':\\n s[i] = 'z'\\n print('Yes')\\n print(''.join(s))\\n else:\\n s = list(s)\\n ok = s[::]\\n for i in range(n - 6):\\n ok = s[::]\\n for j in range(7):\\n if s[i + j] == t[j]:\\n continue\\n elif s[i + j] == '?':\\n ok[i + j] = t[j]\\n else:\\n break\\n else:\\n for i in range(n):\\n if ok[i] == '?':\\n ok[i] = 'z'\\n ok = ''.join(ok)\\n if check(ok) != 1:\\n continue\\n print('Yes')\\n print(ok)\\n return\\n print('No')\\n\\nt, = I()\\nwhile t:\\n t -= 1\\n solve()"}
{"id": "30", "input": "input=__import__('sys').stdin.readline\\nfor _ in range(int(input())):\\n n=int(input())\\n s=list(map(int,input().split()))\\n g=[[-1]for _ in range(n+1)]\\n for i in range(n):\\n g[s[i]].append(i)\\n inf=10**10\\n ans=[-1]*n\\n lstunused=n\\n", "gt": "for i in range(1,n+1):\\n g[i].append(n)\\n mx=0\\n for j in range(1,len(g[i])):\\n mx=max(mx,g[i][j]-g[i][j-1]-1)\\n for j in range(mx,lstunused):\\n ans[j]=i\\n lstunused=min(lstunused,mx)\\n print(*ans)"}
{"id": "31", "input": "t = int(input())\\nfor i in range(t):\\n n = int(input())\\n s = input()\\n ans = 0\\n for y", "gt": "in range(1, n):\\n if s[y] == s[y-1]:\\n ans += 1\\n print((ans + ans % 2) // 2)\\n \\n"}
{"id": "32", "input": "DIR = {\"N\": (0, 1), \"S\": (0, -1), \"W\": (-1, 0), \"E\": (1, 0)}\\n\\nfor t in range(int(input())):\\n path = input()\\n tracks = set()\\n x, y = 0, 0\\n time = 0\\n for char in path:\\n x1 = x", "gt": "+ DIR[char][0]\\n y1 = y + DIR[char][1]\\n if (x, y, x1, y1) in tracks or (x1, y1, x, y) in tracks:\\n time += 1\\n else:\\n time += 5\\n tracks.add((x, y, x1, y1))\\n x, y = x1, y1\\n print(time)\\n"}
{"id": "33", "input": "from sys import stdin, stdout\\nfrom collections import defaultdict\\ninput = stdin.readline\\nfor _ in range(int(input())):\\n n = int(input())\\n chanek = 0\\n flag = 1\\n while n>0:\\n if n%4==0 and n!=4:\\n if flag:\\n chanek += 1\\n n-=1\\n flag = 0\\n", "gt": "else:\\n n-=1\\n flag = 1\\n elif n%2:\\n if flag:\\n chanek += 1\\n n-=1\\n flag = 0\\n else:\\n n-=1\\n flag = 1\\n else:\\n if flag:\\n chanek += n//2\\n n//=2\\n flag = 0\\n else:\\n n//=2\\n flag = 1\\n print(chanek)"}
{"id": "34", "input": "t=int(input())\\nfor i in range(t):\\n n=int(input())\\n print(2)\\n", "gt": "print(n-1,n)\\n for i in range(n-2,0,-1):\\n print(i,i+2)"}
{"id": "35", "input": "for _ in range(int(input())):\\n n", "gt": "= int(input())\\n if(n%2):\\n print(\"7\"+\"1\"*((n-3)//2))\\n else:\\n print(\"1\"*(n//2))"}
{"id": "36", "input": "import sys\\n\\ninput=sys.stdin.readline\\n\\nfor _ in range(int(input())):\\n N=int(input())\\n e=list(map(int,input().split()))\\n e.sort()\\n ans=0\\n val=0\\n g=0\\n", "gt": "for i in range(0,N):\\n g+=1\\n val=e[i]\\n if g>=val:\\n ans+=1\\n g=0\\n val=0\\n print(ans)\\n"}
{"id": "37", "input": "n=int(input())\\na=list(map(int,input().split()))\\nk=[]\\nfor i in range(n):\\n for j", "gt": "in range(a[i]):\\n k.append(i+1)\\nm=int(input())\\nb=list(map(int,input().split()))\\nfor i in b:\\n print(k[i-1])"}
{"id": "38", "input": "3\\n\\nfrom math import factorial as fact\\n\\nN = 55\\nc = [1]\\nfor i in range(N):\\n c.append(fact(i))\\ndp = [0] * N\\ndp[0] = 1\\nfor i in range(1, N):\\n for j in range(i):\\n dp[i] += dp[j] * c[i - j - 1]\\n\\ndef get_kth_cycle(n, k):\\n if n == 1:\\n return [1]\\n ans = [-1] * n\\n ans[0] = n - 1\\n fin = [i for i in range(n)]\\n fin[0] = n - 1\\n init = [i for i in range(n)]\\n init[n - 1] = 0\\n used = [False] * n\\n used[n - 1] = True\\n for i in range(1, n - 1):\\n j = 0\\n cur = fact(n - i - 2)\\n while True:\\n while used[j] or (i < n - 1 and j == init[i]):\\n j += 1\\n if k > cur:\\n k -= cur\\n", "gt": "j += 1\\n else:\\n fin[init[i]] = fin[j]\\n init[fin[j]] = init[i]\\n ans[i] = j\\n used[j] = True\\n break\\n ans[-1] = init[-1]\\n return [x + 1 for x in ans]\\n\\ndef f(n, k):\\n if n == 0:\\n assert k == 1\\n return []\\n cl = 1\\n while c[cl - 1] * dp[n - cl] < k:\\n k -= c[cl - 1] * dp[n - cl]\\n cl += 1\\n rest = f(n - cl, (k - 1) % dp[n - cl] + 1)\\n rest = [x + cl for x in rest]\\n k = (k - 1) // dp[n - cl] + 1\\n return get_kth_cycle(cl, k) + rest\\n\\ndef solve():\\n n, k = list(map(int, input().split()))\\n if k > dp[n]:\\n print(-1)\\n return\\n print(*f(n, k))\\n\\ndef main():\\n t = int(input())\\n while t > 0:\\n t -= 1\\n solve()\\n\\nmain()\\n"}
{"id": "39", "input": "q = int(input())\\nfor z in range(q):\\n n, k1, k2 = map(int, input().split())\\n arr1", "gt": "= list(map(int, input().split()))\\n arr2 = list(map(int, input().split()))\\n if max(arr1) > max(arr2):\\n print('YES')\\n else:\\n print('NO')"}
{"id": "40", "input": "t=int(input())\\n\\nfor tt in range(t):\\n a,b,p=map(int,input().split())\\n s=input()\\n n=len(s)\\n cost = [0]*n\\n cost[-1] = 0\\n typ = ''\\n i=n-2\\n while i>=0:\\n if s[i]==typ:\\n cost[i]", "gt": "= cost[i+1]\\n else:\\n typ = s[i]\\n cost[i] = cost[i+1] + (a if typ=='A' else b)\\n i-=1\\n i=0\\n while cost[i] > p:\\n i+=1\\n print(i+1)"}
{"id": "41", "input": "def main():\\n from sys import stdin, stdout\\n for _ in range(int(stdin.readline())):\\n n = int(stdin.readline())\\n inp1 = [-1] * (n + 1)\\n inp2 = [-1] * (n + 1)\\n for i, ai in enumerate(map(int, stdin.readline().split())):\\n if inp1[ai] < 0:\\n inp1[ai] = i\\n inp2[ai] = i\\n inp1 = tuple((inp1i for inp1i in", "gt": "inp1 if inp1i >= 0))\\n inp2 = tuple((inp2i for inp2i in inp2 if inp2i >= 0))\\n n = len(inp1)\\n ans = 0\\n cur = 0\\n for i in range(n):\\n if i and inp1[i] < inp2[i - 1]:\\n cur = 1\\n else:\\n cur += 1\\n ans = max(ans, cur)\\n stdout.write(f'"}
{"id": "42", "input": "t = int(input())\\nfor tt in range(t):\\n n,k=list(map(int,input().split()))\\n s = input()\\n ans = []\\n if s[0] == ')':\\n for i in range(n):\\n if s[i] == '(':\\n ans.append([1,i+1])\\n s = s[i::-1] + s[i+1:]\\n break\\n for i in range(1,(k-1)*2):\\n if i%2==0:\\n if s[i]!='(':\\n for j in range(i+1,n):\\n if s[j] == '(':\\n ans.append([i+1,j+1])\\n s = s[:i] +", "gt": "s[j:i-1:-1] + s[j+1:]\\n break\\n else:\\n if s[i]!=')':\\n for j in range(i+1,n):\\n if s[j] == ')':\\n ans.append([i+1,j+1])\\n s = s[:i] + s[j:i-1:-1] + s[j+1:]\\n break\\n for i in range((k-1)*2,(n+(2*(k-1)))//2+1):\\n if s[i]!='(':\\n for j in range(i+1,n):\\n if s[j] == '(':\\n ans.append([i+1,j+1])\\n s = s[:i] + s[j:i-1:-1] + s[j+1:]\\n break\\n print(len(ans))\\n for i in ans:\\n print(*i)\\n \\n\\n\\n\\n"}
{"id": "43", "input": "LOG = 20\\n\\ndef solve(s):\\n n = len(s)\\n res = 0\\n z = 0\\n for t in range(0, n):\\n if s[t] == '0':\\n z += 1\\n continue\\n for l in range(1, min(LOG, n - t + 1)):\\n x = int(s[t:t+l],", "gt": "2)\\n # print(l, t, x, l + z)\\n if l + z >= x:\\n res += 1\\n\\n# print(t, l, x, res, z)\\n z = 0\\n return res\\n\\n\\nt = int(input())\\nwhile t > 0:\\n t -= 1\\n s = input()\\n print(solve(s))"}
{"id": "44", "input": "def check(M):\\n sm = 0\\n for i in range(n):\\n if a[i] > M:\\n sm += b[i]\\n return sm <= M\\n\\n\\ngans = []\\nfor _ in range(int(input())):\\n n = int(input())\\n a = list(map(int, input().split()))\\n b", "gt": "= list(map(int, input().split()))\\n L = 0\\n R = max(a)\\n while R - L > 1:\\n M = (L + R) // 2\\n if check(M):\\n R = M\\n else:\\n L = M\\n gans.append(R)\\nprint(*gans, sep='\\n')\\n"}
{"id": "45", "input": "t=int(input())\\nfor you in range(t):\\n n=int(input())\\n for", "gt": "i in range(n):\\n print(4*n-2*i,end=\" \")\\n print()\\n"}
{"id": "46", "input": "import sys\\nimport random\\nfrom fractions import Fraction\\nfrom math import *\\n \\ndef input():\\n return sys.stdin.readline().strip()\\n \\ndef iinput():\\n return int(input())\\n\\ndef finput():\\n return float(input())\\n\\ndef tinput():\\n return input().split()\\n\\ndef linput():\\n return list(input())\\n \\ndef rinput():\\n return list(map(int, tinput()))\\n\\ndef fiinput():\\n return list(map(float, tinput()))\\n \\ndef rlinput():\\n return list(map(int, input().split()))\\ndef trinput():\\n return tuple(rinput())\\n\\ndef srlinput():\\n return sorted(list(map(int, input().split())))\\n\\ndef NOYES(fl):\\n if fl:\\n print(\"NO\")\\n else:\\n print(\"YES\")\\ndef YESNO(fl):\\n if fl:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n \\ndef main():\\n n = iinput()\\n #k = iinput() \\n #m = iinput() \\n #n = int(sys.stdin.readline().strip()) \\n #n, k = rinput()\\n #n, m = rinput()\\n #m, k", "gt": "= rinput()\\n #n, k, m = rinput()\\n #n, m, k = rinput()\\n #k, n, m = rinput()\\n #k, m, n = rinput() \\n #m, k, n = rinput()\\n #m, n, k = rinput()\\n #q = srlinput()\\n #q = linput()\\n s, t, res = 1, 1, 0\\n while s <= n:\\n res += 1\\n n -= s\\n t = 2 * t + 1\\n s = (t * (t + 1)) // 2\\n print(res)\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\\nfor i in range(iinput()):\\n main()\\n"}
{"id": "47", "input": "#\\n# ------------------------------------------------\\n# ____ _ Generatered using\\n# / ___| | |\\n# | | __ _ __| | ___ _ __ ______ _\\n# | | / _` |/ _` |/ _ \\ '_ \\|_ / _` |\\n# | |__| (_| | (_| | __/ | | |/ / (_| |\\n# \\____\\____|\\____|\\___|_| |_/___\\____|\\n#\\n# GNU Affero General Public License v3.0\\n# ------------------------------------------------\\n# Author : prophet\\n# Created : 2020-07-12 11:19:01.523119\\n# UUID : aXsU7xuXyjk3Ky2f\\n# ------------------------------------------------\\n#\\nproduction = True\\n\\nimport sys, math, collections\\n\\ndef input(input_format = 0, multi = 0):\\n\\n if multi > 0: return [input(input_format) for i in range(multi)]\\n else:\\n next_line = sys.stdin.readline()[:-1]\\n\\n if input_format >= 10:\\n use_list = False\\n input_format = int(str(input_format)[-1])\\n else: use_list = True\\n\\n if input_format == 0: formatted_input = [next_line]\\n elif input_format == 1: formatted_input = list(map(int, next_line.split()))\\n elif input_format == 2: formatted_input = list(map(float, next_line.split()))\\n elif input_format == 3: formatted_input = list(next_line)\\n elif input_format == 4: formatted_input = list(map(int, list(next_line)))\\n elif input_format == 5: formatted_input = next_line.split()\\n else: formatted_input = [next_line]\\n\\n return formatted_input if use_list else formatted_input[0]\\n\\ndef out(output_line, output_format = 0, newline = True):\\n\\n formatted_output = \"\"\\n\\n if output_format == 0: formatted_output", "gt": "= str(output_line)\\n elif output_format == 1: formatted_output = \" \".join(map(str, output_line))\\n elif output_format == 2: formatted_output = \"\\n\".join(map(str, output_line))\\n\\n print(formatted_output, end = \"\\n\" if newline else \"\")\\n\\ndef log(*args):\\n if not production:\\n print(\"$$$\", end = \"\")\\n print(*args)\\n\\nenu = enumerate\\n\\nter = lambda a, b, c: b if a else c\\n\\nceil = lambda a, b: -(-a // b)\\n\\ndef mapl(iterable, format = 0):\\n \\n if format == 0: return list(map(int, iterable))\\n elif format == 1: return list(map(str, iterable))\\n elif format == 2: return list(map(list, iterable))\\n#\\n# >>>>>>>>>>>>>>> START OF SOLUTION <<<<<<<<<<<<<<\\n#\\n\\n\\ndef solve():\\n\\n s = input(3)\\n\\n u = [0] * 3\\n\\n for i in s:\\n if i == \"R\":\\n u[0] += 1\\n elif i == \"P\":\\n u[1] += 1\\n elif i == \"S\":\\n u[2] += 1\\n\\n log(u)\\n y = 0\\n p = 0\\n\\n for i, j in enu(u):\\n if j > y:\\n y = j\\n p = i\\n\\n if p == 0:\\n a = \"P\"\\n elif p == 1:\\n a = \"S\"\\n elif p == 2:\\n a = \"R\"\\n\\n out(a * len(s))\\n\\n return\\n\\n\\nfor i in range(input(11)): solve()\\n# solve()\\n\\n#\\n# >>>>>>>>>>>>>>>> END OF SOLUTION <<<<<<<<<<<<<<<\\n#\\n"}
{"id": "48", "input": "import sys\\ninput = sys.stdin.readline\\nfrom bisect import bisect_right\\n\\nbin_s = [1]\\nwhile bin_s[-1] <= 10 ** 9:\\n bin_s.append(bin_s[-1] * 2)\\n\\n\\ndef main():\\n n, q = map(int, input().split())\\n alst = list(map(int, input().split()))\\n dp = [[-1, -1] for _ in range(n)]\\n dp[0]", "gt": "= [alst[0], 0]\\n for i, a in enumerate(alst[1:], start = 1):\\n dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + a)\\n dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - a)\\n print(max(dp[-1]))\\n \\n\\nfor _ in range(int(input())):\\n main()"}
{"id": "49", "input": "for haaghfj in range(int(input())):\\n x,y,k = list(map(int,input().split()))\\n print(k + (y", "gt": "* k + k - 1 +x-2) // (x - 1))\\n"}
{"id": "50", "input": "\\nimport sys\\n#sys.stdin=open(\"data.txt\")\\ninput=sys.stdin.readline\\n\\n# this math tutorial is boring\\n\\nclassy=set()\\n\\nfor i in range(19):\\n for j in range(i):\\n for k in range(j):\\n for a in range(10): # a=0 for good measure\\n for b in range(10):\\n for c", "gt": "in range(10):\\n what=a*10**i+b*10**j+c*10**k\\n classy.add(what)\\n\\nli=sorted(classy)\\n\\ndef counting(i):\\n # return len([x for x in li if x <= i])+C\\n lo=0\\n hi=len(li)-1\\n while lo<hi:\\n mid=(lo+hi+1)//2\\n if li[mid]<=i:\\n lo=mid\\n else:\\n hi=mid-1\\n return lo\\n\\nfor _ in range(int(input())):\\n a,b=map(int,input().split())\\n print(counting(b)-counting(a-1))"}
{"id": "51", "input": "for tcase in range(int(input())):\\n n=int(input())\\n ls = list(map(int, input().split()))\\n oneneed = 2*(n - ls.count(1))\\n ldct = {0:0}\\n ctr = 0\\n eaten = 0\\n for i in range(n-1,-1,-1):\\n eaten += 1\\n ctr += (1 if ls[i] == 2 else -1)\\n if ctr not in ldct:\\n ldct[ctr] = eaten\\n\\n rdct = {0:0}\\n ctr", "gt": "= 0\\n eaten = 0\\n for i in range(n,2*n):\\n eaten += 1\\n ctr += (1 if ls[i] == 2 else -1)\\n if ctr not in rdct:\\n rdct[ctr] = eaten\\n #print(oneneed, ldct, rdct)\\n\\n best=99**99\\n for k in list(rdct.keys()):\\n otk = oneneed - k\\n if otk in ldct:\\n best = min(best, rdct[k]+ldct[otk])\\n print(best)\\n"}
{"id": "52", "input": "def main():\\n t = int(input())\\n for z in range(t):\\n n, k, d1, d2 = map(int, input().split())\\n if n % 3 != 0:\\n print('no')\\n continue\\n f = 0\\n for i in [-1, +1]:\\n for j in [-1, +1]:\\n w = (k", "gt": "- i * d1 - j * d2)\\n if f == 0 and (w % 3 == 0) and (n//3)>=(w//3)>=0 and (n//3)>=(w//3 + i * d1)>=0 and (n//3)>=(w//3 + j * d2)>=0:\\n print('yes')\\n f = 1\\n if f == 0:\\n print('no')\\nmain()"}
{"id": "53", "input": "n=int(input())\\na=sorted(int(input()) for _ in", "gt": "range(n))\\nprint(sum(a[i]*a[-i-1] for i in range(n))%10007)"}
{"id": "54", "input": "import sys\\ninput = sys.stdin.readline\\n\\n\\ndef compress(array):\\n array2 = sorted(set(array))\\n memo = {value : index for index, value in enumerate(array2)}\\n for i in range(len(array)):\\n array[i] = memo[array[i]] + 1\\n return array\\n\\n\\nt = int(input())\\nbase = 10 ** 6\\nfor _ in range(t):\\n n, b = list(map(str, input().split()))\\n n = int(n)\\n ans = [0] * n\\n \\n now = base\\n ans[0] = base\\n for i", "gt": "in range(n - 1):\\n if b[i] == \">\":\\n now -= base\\n ans[i + 1] = now\\n else:\\n now += 1\\n ans[i + 1] = now\\n print(*compress(ans))\\n\\n now = base\\n ans[0] = base\\n for i in range(n - 1):\\n if b[i] == \">\":\\n now -= 1\\n ans[i + 1] = now\\n else:\\n now += base\\n ans[i + 1] = now\\n print(*compress(ans))\\n"}
{"id": "55", "input": "for i in range(int(input())):\\n n=int(input())\\n s=list(map(int,input().split()))\\n a=0\\n for", "gt": "i in s:\\n if i<2049:a+=i\\n if a<2048:print(\"NO\")\\n else:print(\"YES\")"}
{"id": "56", "input": "for __ in range(int(input())):\\n n =", "gt": "int(input())\\n print((n + 1) // 2)"}
{"id": "57", "input": "for _ in range(int(input())):\\n n, k = map(int, input().split())\\n mat = [[0] * n for _ in range(n)]\\n for i in range(n):\\n b = False\\n for j in range(n):\\n if", "gt": "i*n+j == k:\\n b = True\\n break\\n mat[(i+j)%n][j] = 1\\n if b:\\n break\\n if k%n == 0:\\n print(0)\\n else:\\n print(2)\\n for i in range(n):\\n for j in range(n):\\n print(mat[i][j], end=\"\")\\n print()\\n"}
{"id": "58", "input": "t = int(input())\\nfor case in range(t):\\n n = int(input())\\n arr", "gt": "= list(map(int, input().split()))\\n if arr[-1] > arr[0]:\\n print(\"YES\")\\n else:\\n print(\"NO\")"}
{"id": "59", "input": "mem = [[[0 for i in range(51)] for j in range(31)] for k in range(31)]\\n\\n\\ndef f(n, m, k):\\n if mem[n][m][k]:\\n return mem[n][m][k]\\n if (n*m == k) or (k == 0):\\n return 0\\n cost = 10**9\\n for x in range(1, n//2 + 1):\\n for z in range(k+1):\\n cost = min(cost, m*m", "gt": "+ f(n-x, m, k-z) + f(x, m, z))\\n for y in range(1, m//2 + 1):\\n for z in range(k+1):\\n cost = min(cost, n*n + f(n, m-y, k-z) + f(n, y, z))\\n mem[n][m][k] = cost\\n return cost\\n\\n\\nt = int(input())\\nfor i in range(t):\\n n, m, k = list(map(int, input().split()))\\n print(f(n, m, k))\\n\\n"}
{"id": "60", "input": "for _ in range(int(input())):\\n n=int(input())\\n a=list(map(int,input().split()))\\n ans,small,big=0,2*10**9,-1\\n for i in range(len(a)-1):\\n if a[i]==-1 and a[i+1]!=-1:\\n small=min(small, a[i+1])\\n big=max(big, a[i+1])\\n if a[i]!=-1 and a[i+1]==-1:\\n small", "gt": "= min(small, a[i])\\n big = max(big, a[i])\\n if a[i]!=-1 and a[i+1]!=-1:\\n ans=max(ans, abs(a[i]-a[i+1]))\\n if big==-1:print(ans, 0)\\n else:\\n x=(small+big)//2\\n ans=max(ans, abs(big-x))\\n ans=max(ans, abs(x-small))\\n print(ans, x)"}
{"id": "61", "input": "n = int(input())\\nfor _ in range(n):\\n a,", "gt": "b = list(map(int, input().split()))\\n print(a ^ b)\\n"}
{"id": "62", "input": "import sys\\nimport math\\n#from queue import *\\nimport random\\n#sys.setrecursionlimit(int(1e6))\\ninput = sys.stdin.readline\\n \\n############ ---- USER DEFINED INPUT FUNCTIONS ---- ############\\ndef inp():\\n return(int(input()))\\ndef inara():\\n return(list(map(int,input().split())))\\ndef insr():\\n s = input()\\n return(list(s[:len(s) - 1]))\\ndef invr():\\n return(list(map(int,input().split())))\\n################################################################\\n############ ---- THE ACTUAL CODE", "gt": "STARTS BELOW ---- ############\\n\\nt=inp()\\n\\nfor _ in range(t):\\n n=inp()\\n ara=inara()\\n \\n ans=[]\\n \\n for i in range(1,n-1):\\n if ara[i]>ara[i-1] and ara[i]>ara[i+1]:\\n ans.append(i)\\n ans.append(i+1)\\n ans.append(i+2)\\n break\\n \\n if len(ans)==0:\\n print(\"NO\")\\n else:\\n print(\"YES\")\\n print(*ans)\\n \\n \\n \\n"}
{"id": "63", "input": "T = int(input())\\n\\n\\n\\ndef solve(S):\\n res = [S[0]]\\n pos = 0 # think...\\n for s in S[1:]:\\n # can we change?\\n if 0 <= pos-1 < len(res) and res[pos-1] == s:\\n pos = pos-1\\n elif 0 <= pos+1 < len(res) and res[pos+1] == s:\\n pos = pos+1\\n elif pos == 0 and s not in", "gt": "res:\\n res.insert(0, s) # pos is still 0\\n elif pos == len(res)-1 and s not in res:\\n res.append(s)\\n pos += 1\\n else: return None\\n #print(''.join(res))\\n for x in range(ord('a'), ord('z')+1):\\n x = chr(x)\\n if x not in res:\\n res.append(x)\\n return ''.join(res)\\n\\nfor _ in range(T):\\n res = solve(input())\\n if res is None:\\n print('NO')\\n else:\\n print('YES')\\n print(res)\\n"}
{"id": "64", "input": "def solve():\\n n, k = map(int,input().split())\\n lst1 = list(map(int,input().split()))\\n lst1.sort(reverse=True)\\n ind = 0\\n ans = 0\\n lst2 = list(map(int,input().split()))\\n lst2.sort()\\n for i in range(k):\\n lst2[i] -= 1\\n if lst2[i] == 0: ans", "gt": "+= lst1[ind]\\n ans += lst1[ind]\\n ind += 1\\n lst2.sort()\\n for i in lst2:\\n if i != 0:\\n ind += i - 1\\n ans += lst1[ind]\\n ind += 1\\n print(ans)\\nfor i in range(int(input())):\\n solve()"}
{"id": "65", "input": "import sys\\nimport random\\nfrom fractions import Fraction\\nfrom math import *\\n \\ndef input():\\n return sys.stdin.readline().strip()\\n \\ndef iinput():\\n return int(input())\\n\\ndef finput():\\n return float(input())\\n\\ndef tinput():\\n return input().split()\\n\\ndef linput():\\n return list(input())\\n \\ndef rinput():\\n return list(map(int, tinput()))\\n\\ndef fiinput():\\n return list(map(float, tinput()))\\n \\ndef rlinput():\\n return list(map(int, input().split()))\\ndef trinput():\\n return tuple(rinput())\\n\\ndef srlinput():\\n return sorted(list(map(int, input().split())))\\n\\ndef NOYES(fl):\\n if fl:\\n print(\"NO\")\\n else:\\n print(\"YES\")\\ndef YESNO(fl):\\n if fl:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n \\ndef main():\\n n, l = rinput()\\n #n = iinput()\\n #k = iinput() \\n #m = iinput() \\n #n = int(sys.stdin.readline().strip()) \\n #n, k = rinput()\\n #n, m = rinput()\\n #m, k = rinput()\\n #n, k, m = rinput()\\n #n, m, k = rinput()\\n #k, n, m = rinput()\\n #k, m, n = rinput() \\n #m, k, n = rinput()\\n #m, n, k = rinput()\\n q = rlinput()\\n #q = linput()\\n q = [0] + q + [l]\\n w,", "gt": "e = [0] * (n + 2), [0] * (n + 2)\\n \\n for i in range(1, n + 2):\\n e[n + 1 - i] = e[n + 2 - i] + ((q[-i] - q[-1 - i]) / i)\\n w[i] = w[i - 1] + ((q[i] - q[i - 1]) / i)\\n \\n left, right = 0, n + 2\\n while right > left + 1:\\n mid = (right + left) // 2\\n if w[mid] >= e[mid]:\\n right = mid\\n else:\\n left = mid\\n \\n print((q[right] - q[right - 1] - (max(0, w[right - 1] - e[right]) * (n - right + 2) + max(0, e[right] - w[right - 1]) * right)) / (n + 2) + max(w[right - 1], e[right]))\\n \\n\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\\nfor i in range(iinput()):\\n main()\\n"}
{"id": "66", "input": "import math\\nfrom collections import deque\\nfrom sys import stdin, stdout\\nfrom string import ascii_letters\\nimport sys\\nletters = ascii_letters\\ninput = stdin.readline\\n#print = stdout.write\\n\\nfor _ in range(int(input())):\\n n = int(input())\\n arr = list(map(int, input().split()))\\n ans = [999999999] * n\\n ans[0] = 1 if arr[0] == 1 else 0\\n if n > 1:\\n ans[1] = ans[0]\\n if n > 2:\\n ans[2] = ans[0]\\n for i in range(n):\\n if i + 1 >= n:\\n continue\\n if arr[i + 1] == 1:\\n ans[i + 1]", "gt": "= min(ans[i + 1], ans[i] + 1)\\n if i + 2 < n:\\n ans[i + 2] = min(ans[i + 2], ans[i] + 1)\\n if i + 3 < n: \\n ans[i + 3] = min(ans[i + 3], ans[i] + 1)\\n else:\\n ans[i + 1] = min(ans[i + 1], ans[i])\\n if i + 2 < n:\\n ans[i + 2] = min(ans[i + 2], ans[i])\\n if i + 3 < n:\\n ans[i + 3] = min(ans[i + 3], ans[i])\\n print(ans[-1])\\n"}
{"id": "67", "input": "#list(map(int,input().split()))\\nt=int(input())\\nfor _ in range(t):\\n n=int(input())\\n", "gt": "aa=list(map(int,input().split()))\\n bb=list(map(int,input().split()))\\n aa.sort()\\n bb.sort()\\n print(*aa)\\n print(*bb)\\n"}
{"id": "68", "input": "for _ in range(int(input())):\\n n = int(input())\\n s = input()\\n t = input()\\n\\n d = {}\\n for i in range(ord('a'), ord('z') + 1):\\n d[chr(i)] = 0\\n\\n for cs in s:\\n d[cs] += 1\\n for ct in t:\\n d[ct] += 1\\n\\n ok = True\\n for e in d:\\n if d[e] % 2 == 1:\\n ok = False\\n\\n if not ok:\\n print(\"No\")\\n else:\\n print(\"Yes\")\\n\\n changes = []\\n\\n s, t = list(s), list(t)\\n for i in range(n-1):\\n if s[i]", "gt": "!= t[i]:\\n r = (0, -1)\\n for j in range(i+1, n):\\n if s[j] == t[i]:\\n r = (j, 0)\\n\\n for j in range(i+1, n):\\n if t[j] == t[i]:\\n r = (j, 1)\\n\\n if r[1] == 0:\\n changes += [(r[0], i+1), (i, i+1)]\\n s[r[0]], t[i+1] = t[i+1], s[r[0]]\\n s[i], t[i+1] = t[i+1], s[i]\\n elif r[1] == 1:\\n changes += [(i, r[0])]\\n s[i], t[r[0]] = t[r[0]], s[i]\\n\\n print(len(changes))\\n for change in changes:\\n x, y = change\\n print(x+1, y+1)"}
{"id": "69", "input": "from itertools import groupby\\ndef main():\\n N = int(input())\\n S = input()\\n \\n C = [len(list(x[1])) for x in groupby(S)]\\n M = len(C)\\n dup_idx = []\\n for i, c in enumerate(C):\\n if c > 1:\\n dup_idx.append(i)\\n \\n dup_idx.reverse()\\n\\n", "gt": "curr = 0\\n while dup_idx:\\n i = dup_idx[-1]\\n\\n if i < curr:\\n dup_idx.pop()\\n continue\\n\\n C[i] -= 1\\n if C[i] == 1:\\n dup_idx.pop()\\n\\n curr += 1\\n\\n ans = curr + (M-curr+1)//2\\n \\n print(ans)\\n\\ndef __starting_point():\\n for __ in [0]*int(input()):\\n main()\\n\\n__starting_point()"}
{"id": "70", "input": "t = int(input())\\n\\nfor case in range(t):\\n a, b = list(map(int, input().split()))\\n s = input()\\n\\n z = 10000\\n total = 0\\n act = False\\n\\n for i in range(len(s)):\\n cur", "gt": "= s[i]\\n if cur == '0':\\n z += 1\\n act = False\\n else:\\n if not act:\\n act = True\\n total += min(a, b * z)\\n z = 0\\n\\n print(total)\\n"}
{"id": "71", "input": "import sys\\ninput = sys.stdin.readline\\nfrom collections import defaultdict\\n\\nclass Unionfind:\\n def __init__(self, n):\\n self.par = [-1]*n\\n self.rank = [1]*n\\n \\n def root(self, x):\\n r = x\\n \\n while not self.par[r]<0:\\n r = self.par[r]\\n \\n t = x\\n \\n while t!=r:\\n tmp = t\\n t = self.par[t]\\n self.par[tmp] = r\\n \\n return r\\n \\n def unite(self, x, y):\\n rx = self.root(x)\\n ry = self.root(y)\\n \\n if rx==ry:\\n return\\n \\n if self.rank[rx]<=self.rank[ry]:\\n self.par[ry] += self.par[rx]\\n self.par[rx] = ry\\n \\n if self.rank[rx]==self.rank[ry]:\\n self.rank[ry] += 1\\n else:\\n self.par[rx] += self.par[ry]\\n self.par[ry] =", "gt": "rx\\n \\n def is_same(self, x, y):\\n return self.root(x)==self.root(y)\\n \\n def count(self, x):\\n return -self.par[self.root(x)]\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n n, k = map(int, input().split())\\n s = input()[:-1]\\n uf = Unionfind(n)\\n \\n for i in range(n//2):\\n uf.unite(i, n-1-i)\\n \\n for i in range(n-k):\\n uf.unite(i, i+k)\\n \\n d = defaultdict(dict)\\n \\n for i in range(n):\\n if s[i] not in d[uf.root(i)]:\\n d[uf.root(i)][s[i]] = 1\\n else:\\n d[uf.root(i)][s[i]] += 1\\n \\n rs = set(uf.root(i) for i in range(n))\\n ans = 0\\n \\n for r in rs:\\n ans += uf.count(r)-max(list(d[r].values()))\\n \\n print(ans)"}
{"id": "72", "input": "t=int(input())\\nwhile t>0 :\\n n=int(input())\\n a=list(map(int,input().split()))\\n an=0\\n s=0\\n for i in a :\\n", "gt": "if s+i>=0 :\\n s+=i \\n else :\\n s+=i\\n an-=s \\n s=0\\n print(an)\\n t-=1"}
{"id": "73", "input": "t = int(input())\\n\\nfor _ in range(t):\\n n, k = [int(x) for x in input().split()]\\n a = [int(x) for x in input().split()]\\n", "gt": "if len(set(a)) > k:\\n print(-1)\\n continue\\n l = list(set(a))\\n l.extend([1]*(k - len(l)))\\n\\n print(n*k)\\n for _ in range(n):\\n print(*l, end=\" \")\\n print()\\n"}
{"id": "74", "input": "def solve():\\n n = int(input())\\n a = list(map(int, input().split()))\\n c = [0] * (n + 1)\\n def inc():\\n for i in range(n - 1):\\n if a[i] > a[i + 1]:\\n return False\\n return True\\n def calc():\\n for i in range(n + 1):\\n c[i] = 0\\n for i in a:\\n c[i] += 1\\n for i in range(n + 1):\\n", "gt": "if not c[i]:\\n return i\\n return n + 1\\n ans = []\\n while not inc():\\n x = calc()\\n if x >= n:\\n y = 0\\n while y < n and a[y] == y:\\n y += 1\\n a[y] = x\\n ans.append(y)\\n else:\\n a[x] = x\\n ans.append(x)\\n print(len(ans))\\n print(*map(lambda x: x + 1, ans))\\n\\nt = int(input())\\nfor _ in range(t):\\n solve()"}
{"id": "75", "input": "def read_int():\\n return int(input())\\n\\n\\ndef read_ints():\\n return list(map(int, input().split(' ')))\\n\\n\\nt = read_int()\\nfor case_num in range(t):\\n n, k = read_ints()\\n p = []\\n for i in range(n):\\n ai, bi = read_ints()\\n p.append((bi, ai, i + 1))\\n p.sort()\\n dp = [[0 for j in range(k + 1)] for i in range(n + 1)]\\n use = [[False for j in range(k + 1)] for i in range(n + 1)]\\n for i in range(1, n + 1):\\n for j in range(min(i, k) + 1):\\n if i - 1 >= j:\\n dp[i][j] = dp[i", "gt": "- 1][j] + (k - 1) * p[i - 1][0]\\n if j > 0:\\n x = dp[i - 1][j - 1] + (j - 1) * p[i - 1][0] + p[i - 1][1]\\n if x > dp[i][j]:\\n dp[i][j] = x\\n use[i][j] = True\\n used = []\\n curr = k\\n for i in range(n, 0, -1):\\n if use[i][curr]:\\n used.append(p[i - 1][2])\\n curr -= 1\\n used.reverse()\\n seq = used[:-1]\\n st = set(used)\\n for i in range(1, n + 1):\\n if not i in st:\\n seq.append(i)\\n seq.append(-i)\\n seq.append(used[-1])\\n print(len(seq))\\n print(' '.join(map(str, seq)))\\n"}
{"id": "76", "input": "import math\\n\\nT = int(input())\\nfor _ in range(T):\\n n", "gt": "= int(input())\\n diags = 1/math.sin(math.pi/2/n)\\n print(diags * math.cos(math.pi/4/n))\\n"}
{"id": "77", "input": "t = int(input())\\n\\nfor _ in range(t):\\n n =", "gt": "int(input())\\n if n%4 == 0:\\n print(\"YES\")\\n else:\\n print(\"NO\")"}
{"id": "78", "input": "3\\n\\nimport math\\nimport os\\nimport sys\\n\\n\\nDEBUG = 'DEBUG' in os.environ\\n\\n\\ndef inp():\\n return sys.stdin.readline().rstrip()\\n\\n\\ndef dprint(*value, sep=' ', end='\\n'):\\n if DEBUG:\\n print(*value, sep=sep, end=end)\\n\\n\\nINF = 10 ** 20\\n\\n\\ndef solve(N, A, B):\\n dp = {A[0]: 0, A[0] + 1: B[0], A[0] + 2: B[0] * 2}\\n for i in range(1, N):\\n ndp = {}\\n\\n h = A[i]\\n for ph, c in dp.items():\\n for inc in range(3):\\n nh = h", "gt": "+ inc\\n if ph == nh:\\n continue\\n if nh not in ndp:\\n ndp[nh] = INF\\n ndp[nh] = min(ndp[nh], c + B[i] * inc)\\n\\n dp = ndp\\n\\n return min(dp.values())\\n\\n\\ndef main():\\n Q = int(inp())\\n for _ in range(Q):\\n N = int(inp())\\n A = []\\n B = []\\n for _ in range(N):\\n a, b = [int(e) for e in inp().split()]\\n A.append(a)\\n B.append(b)\\n print(solve(N, A, B))\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "79", "input": "import sys\\n\\nq = int(sys.stdin.readline().strip())\\nfor t in range(0, q):\\n n, m = list(map(int, sys.stdin.readline().strip().split()))\\n L = []\\n R = [0] * n\\n C = [0] * m\\n for i in range (0, n):\\n L.append(sys.stdin.readline().strip())\\n for j in range (0, m):\\n if L[i][j] != \"*\":\\n", "gt": "R[i] = R[i] + 1\\n C[j] = C[j] + 1\\n ans = n + m - 1\\n for i in range (0, n):\\n for j in range (0, m):\\n x = 0\\n if L[i][j] != \"*\":\\n x = -1\\n ans = min([ans, R[i]+C[j]+x])\\n print(ans)"}
{"id": "80", "input": "from math import ceil\\n\\nt = int(input())\\nfor _ in range(t):\\n n = int(input())\\n pf = []\\n for i in range(2, ceil(n**0.5)+1):\\n while n % i == 0:\\n pf.append(i)\\n n //= i\\n if n > 1:\\n pf.append(n)\\n if len(pf) == 2 and pf[0] != pf[1]:\\n print(pf[0], pf[1], pf[0]*pf[1])\\n print(1)\\n else:\\n pg = []\\n fac = []\\n nfac = []\\n while len(pf) > 0:\\n p = pf[-1]\\n mul = 0\\n while len(pf) > 0 and pf[-1] == p:\\n pf.pop()\\n mul += 1\\n pg.append([mul, p])\\n pg.sort()\\n pg = pg[::-1]\\n # print(pg)\\n cur = 0\\n if pg[0][0] ==", "gt": "1:\\n a = pg[0][1]\\n b = pg[1][1]\\n c = pg[2][1]\\n fac = [a, a*b*c, a*b, b, b*c, c, a*c]\\n cur = 3\\n else:\\n fac = [pg[0][1]**i for i in range(1, pg[0][0]+1)]\\n cur = 1\\n while cur < len(pg):\\n mul = pg[cur][0]\\n p = pg[cur][1]\\n nfac = []\\n for i in range(len(fac)):\\n if i == 0:\\n nfac += [fac[i]*(p**j) for j in range(mul, -1, -1)]\\n else:\\n nfac += [fac[i]*(p**j) for j in range(mul+1)]\\n nfac += [p**i for i in range(1, mul+1)]\\n fac = nfac\\n cur += 1\\n print(\" \".join([str(i) for i in fac]))\\n print(0)\\n"}
{"id": "81", "input": "def solve(L, R):\\n res = 0\\n for i in range(32):\\n for j in range(32):\\n l = (L >> i) << i\\n r = (R >> j) << j\\n #print(l, r)\\n if l>>i&1==0 or r>>j&1==0:\\n continue\\n l -= 1<<i\\n r -= 1<<j\\n if l & r:\\n continue\\n lr = l ^ r\\n ma =", "gt": "max(i, j)\\n mi = min(i, j)\\n mask = (1<<ma)-1\\n p = bin(lr&mask).count(\"1\")\\n ip = ma - mi - p\\n res += 3**mi * 2**ip\\n #print(l, r, mi, ip, 3**mi * 2**ip)\\n return res\\n\\nT = int(input())\\nfor _ in range(T):\\n l, r = list(map(int, input().split()))\\n print(solve(r+1, r+1) + solve(l, l) - solve(l, r+1) * 2)\\n"}
{"id": "82", "input": "for _ in range(int(input())):\\n a, b, c = input(), input(), input()\\n n = len(a)\\n\\n ok = True\\n", "gt": "for i in range(n):\\n if c[i] not in [a[i], b[i]]:\\n ok = False\\n\\n print('YES' if ok else 'NO')\\n"}
{"id": "83", "input": "for __ in range(int(input())):\\n n =", "gt": "int(input())\\n ar = list(map(int, input().split()))\\n ar.reverse()\\n print(*ar)"}
{"id": "84", "input": "def one():\\n return int(input())\\n\\n\\ndef two():\\n return list(map(int, input().split()))\\n\\n\\ndef lis():\\n return list(map(int, input().split()))\\n\\n\\ndef st():\\n return input()\\n\\n\\nfor _ in", "gt": "range(one()):\\n x, y, a, b = list(map(int, input().split()))\\n d = y - x\\n if d%(a+b)==0:\\n print(d//(a+b))\\n else:\\n print(-1)\\n"}
{"id": "85", "input": "# encoding: utf-8\\nfrom sys import stdin\\n\\ndef solve(a):\\n\\n # root node of tries denotes empty stack\\n stack = [None]\\n node_stack = [[1, {}]]\\n trie = node_stack[-1]\\n\\n counter = 0\\n for i in range(len(a)):\\n el = a[i]\\n\\n if len(stack) == 0 or stack[-1] != el:\\n\\n current_node = node_stack[-1]\\n stack.append(el)\\n if el not in current_node[1]:\\n current_node[1][el] = [0, {}]\\n\\n next_node =", "gt": "current_node[1][el]\\n next_node[0] += 1\\n node_stack.append(next_node)\\n\\n else:\\n # just go up in trie\\n stack.pop()\\n node_stack.pop()\\n node_stack[-1][0] += 1\\n\\n value = node_stack[-1][0]\\n counter -= (((value - 1) * (value - 2)) // 2)\\n counter += (((value) * (value - 1)) // 2)\\n\\n return counter\\n\\n\\nq = int(stdin.readline().strip())\\nfor _ in range(q):\\n n = int(stdin.readline().strip())\\n a = [int(i) for i in stdin.readline().strip().split()]\\n print(solve(a))\\n"}
{"id": "86", "input": "import sys\\n\\ninput=sys.stdin.readline\\n\\nfor _ in range(int(input())):\\n s=input().rstrip()\\n x=int(input())\\n n=len(s)\\n ans=[\"1\" for i in range(n)]\\n for i in range(n):\\n if s[i]==\"0\":\\n if i-x>=0:\\n ans[i-x]=\"0\"\\n", "gt": "if i+x<n:\\n ans[i+x]=\"0\"\\n for i in range(n):\\n if s[i]==\"1\":\\n check=False\\n if i-x>=0:\\n check|=(ans[i-x]==\"1\")\\n if i+x<n:\\n check|=(ans[i+x]==\"1\")\\n if not check:\\n print(-1)\\n break\\n else:\\n print(\"\".join(ans))\\n"}
{"id": "87", "input": "def solve():\\n n = int(input())\\n lst = list(map(int,input().split()))\\n if sum(lst) <= n // 2:\\n print(n//2)\\n print(\"0 \" * (n // 2))\\n", "gt": "else:\\n print(n//2 + (n // 2) % 2)\\n print(\"1 \" * (n//2 + (n // 2) % 2))\\nfor i in range(int(input())):\\n solve()"}
{"id": "88", "input": "import sys\\n\\nreadline = sys.stdin.readline\\nreadlines = sys.stdin.readlines\\nns = lambda: readline().rstrip()\\nni = lambda: int(readline().rstrip())\\nnm = lambda: map(int, readline().split())\\nnl = lambda: list(map(int, readline().split()))\\nprn = lambda x: print(*x, sep='\\n')\\n\\ndef gcd(a, b):\\n while b:\\n a, b = b, a%b\\n return a\\n\\ndef solve():\\n m, d, w = nm()\\n g", "gt": "= w // gcd(d-1, w)\\n c = min(m, d)\\n v = c // g\\n ans = v * (v - 1) // 2 * g\\n ans += (c - g * v) * v\\n print(ans)\\n return\\n\\n\\n# solve()\\n\\nT = ni()\\nfor _ in range(T):\\n solve()\\n"}
{"id": "89", "input": "n = input()\\na = list(map(int, input().split()))\\nfor i in a:\\n if i % 7 == 0", "gt": "or (i // 7) % 2 == 1 or i <= 14:\\n print('NO')\\n else:\\n print('YES')"}
{"id": "90", "input": "from sys import stdin\\n\\ntt = int(stdin.readline())\\n\\nfor loop in range(tt):\\n\\n n = int(stdin.readline())\\n a = list(map(int,stdin.readline().split()))\\n\\n lis = [ [1] ]\\n\\n now = []\\n tmp = 0\\n\\n for i in range(1,n):\\n if len(now) == 0:\\n", "gt": "now.append(a[i])\\n tmp = 1\\n elif now[-1] > a[i]:\\n if tmp == len(lis[-1]):\\n lis.append(now)\\n now = [a[i]]\\n tmp = 1\\n else:\\n tmp += 1\\n now.append(a[i])\\n else:\\n now.append(a[i])\\n\\n if len(now) > 0:\\n lis.append(now)\\n\\n #print (lis)\\n print (len(lis)-1)"}
{"id": "91", "input": "import math\\nfrom collections import deque\\nfrom sys import stdin, stdout\\nfrom string import ascii_letters\\nimport sys\\nletters = ascii_letters\\ninput = stdin.readline\\n#print = stdout.write\\n\\nfor _ in range(int(input())):\\n n = int(input())\\n arr = list(map(int, input().split()))\\n can = list(map(int, input().split()))\\n vals =", "gt": "sorted([i for i in range(n) if not can[i]], key=lambda x: -arr[x])\\n res = [0] * n\\n last = 0\\n for i in range(n):\\n if can[i]:\\n res[i] = arr[i]\\n else:\\n res[i] = arr[vals[last]]\\n last += 1\\n print(*res)\\n"}
{"id": "92", "input": "t = int(input())\\nfor faw in range(t):\\n n = int(input())\\n a = [0] + list(map(int,input().split()))\\n nun = []\\n ans = []\\n f = True\\n for i in range(1, n + 1):\\n", "gt": "if a[i] == a[i-1]:\\n if len(nun) == 0:\\n f = False\\n break\\n else:\\n ans.append(nun.pop())\\n else:\\n ans.append(a[i])\\n for i in range(a[i - 1] + 1, a[i]):\\n nun.append(i)\\n if f:\\n print(*ans)\\n else:\\n print(-1)\\n"}
{"id": "93", "input": "for _ in range(int(input())):\\n", "gt": "print(\"YES\" if set(input()).intersection(input()) else \"NO\")\\n"}
{"id": "94", "input": "for tc in range(int(input())):\\n n,m = list(map(int, input().split()))\\n al = list(map(int, input().split()))\\n bl = list(map(int, input().split()))\\n aidx = {}\\n for i,e in enumerate(al):\\n aidx[e]=i\\n midx =", "gt": "-1\\n res = 0\\n for i,e in enumerate(bl):\\n idx = aidx[e]\\n if idx <= midx:\\n res += 1\\n else:\\n res += 2*(idx-i)+1\\n midx = max(midx, idx)\\n print(res)\\n"}
{"id": "95", "input": "T = int(input())\\nfor test in range(T):\\n n,t = list(map(int,input().split()))\\n a = list(map(int,input().split()))\\n res = []\\n", "gt": "j=0\\n for i in a:\\n if(i*2<t):\\n res+=[\"0\"]\\n elif(i*2>t):\\n res+=[\"1\"]\\n else:\\n res.append([\"0\",\"1\"][j])\\n j = 1-j\\n print(\" \".join(res))\\n"}
{"id": "96", "input": "#JMD\\n#Nagendra Jha-4096\\n\\n \\nimport sys\\nimport math\\n\\n#import fractions\\n#import numpy\\n \\n###File Operations###\\nfileoperation=0\\nif(fileoperation):\\n orig_stdout = sys.stdout\\n orig_stdin = sys.stdin\\n inputfile = open('W:/Competitive Programming/input.txt', 'r')\\n outputfile = open('W:/Competitive Programming/output.txt', 'w')\\n sys.stdin = inputfile\\n sys.stdout = outputfile\\n\\n###Defines...###\\nmod=1000000007\\n \\n###FUF's...###\\ndef nospace(l):\\n ans=''.join(str(i) for i in l)\\n", "gt": "return ans\\n \\n \\n \\n##### Main ####\\nt=int(input())\\nfor tt in range(t):\\n n=int(input())\\n\\n if n==1:\\n print(-1)\\n else:\\n s=\"2\"\\n for i in range(n-1):\\n s+='3'\\n print(s)\\n #n,k,s= map(int, sys.stdin.readline().split(' '))\\n #a=list(map(int,sys.stdin.readline().split(' ')))\\n \\n \\n#####File Operations#####\\nif(fileoperation):\\n sys.stdout = orig_stdout\\n sys.stdin = orig_stdin\\n inputfile.close()\\n outputfile.close()"}
{"id": "97", "input": "import sys\\nfrom operator import itemgetter\\n\\ndef count(a, b, num_a, num_b, cur_time):\\n current_result = 0\\n #print('count time = ', cur_time, \"num_a =\", num_a, 'num_b = ', num_b)\\n if num_a * a + num_b * b <= cur_time and cur_time >= 0:\\n cur_time -= num_a * a + num_b * b\\n current_result = num_a + num_b\\n if num_a < total_a:\\n if (total_a - num_a) * a <= cur_time:\\n current_result += total_a - num_a\\n cur_time -= (total_a - num_a) * a\\n #print(1)\\n else:\\n current_result += cur_time // a\\n cur_time -= a *(cur_time // a)\\n #print(2)\\n if num_b < total_b:\\n if (total_b - num_b) * b <= cur_time:\\n current_result += total_b - num_b\\n #print(3)\\n else:\\n #print(4)\\n current_result += cur_time // b\\n #print('current_result = ', current_result)\\n return current_result\\n\\n\\ndef solve(n, T, a, b, tasks, total_a, total_b): \\n tasks = sorted(tasks)\\n #print(tasks)\\n result = 0\\n num_a", "gt": "= 0\\n num_b = 0\\n\\n for i in range(len(tasks)):\\n time, t = tasks[i] \\n #print(tasks[i])\\n cur_time = time - 1\\n #print('cur time = ', cur_time)\\n current_result = count(a, b, num_a, num_b, cur_time)\\n result = max(current_result, result)\\n\\n if t == 0:\\n num_a += 1\\n else:\\n num_b += 1\\n\\n if i == len(tasks) - 1 or tasks[i + 1][1] != tasks[i][1]:\\n result = max(result, count(a, b, num_a, num_b, cur_time))\\n\\n #print(\"i =\", i, \"result = \", result)\\n\\n result = max(result, count(a, b, total_a, total_b, T))\\n return result\\n\\n\\nq = int(input())\\n\\nfor i in range(q):\\n n, T, a, b = list(map(int, input().split()))\\n types = list(map(int, input().split()))\\n total_a, total_b = 0, 0\\n for t in types:\\n if t == 0:\\n total_a += 1\\n else:\\n total_b += 1\\n t = list(map(int, input().split()))\\n #print(t)\\n #print(types)\\n tasks = list(zip(t, types))\\n print(solve(n, T, a, b, tasks, total_a, total_b)) \\n"}
{"id": "98", "input": "import sys\\nreader = (s.rstrip() for s in sys.stdin)\\ninput = reader.__next__\\n\\ndef solve():\\n s,c = input().split()\\n # i,jでjが複数あるとき\\n n = len(s)\\n for i in range(n-1):\\n prev = s[i]\\n pos = i\\n for j in range(i+1, n):\\n if s[j]<prev:\\n prev =", "gt": "s[j]\\n pos = j\\n elif s[j] == prev:\\n pos = j\\n if prev == s[i]:\\n continue\\n t = list(s)\\n t[i], t[pos] = prev, s[i]\\n s = \"\".join(t)\\n break\\n if s<c:\\n print(s)\\n else:\\n print(\"---\")\\n\\nt = int(input())\\nfor i in range(t):\\n solve()\\n"}
{"id": "99", "input": "q = int(input())\\nfor _ in range(q):\\n c, m, x =", "gt": "list(map(int, input().split()))\\n print(min([c, m, (c + m + x) // 3]))"}
{"id": "100", "input": "for _ in range(int(input())):\\n # a, b = map(int, input().split())\\n n = int(input())\\n # arr = list(map(int, input().split()))\\n s = input()\\n l = 0\\n r = n - 1\\n if s.count('0') == n:\\n print(s)\\n continue\\n if s.count('1')", "gt": "== n:\\n print(s)\\n continue\\n while s[l] == '0':\\n l += 1\\n while s[r] == '1':\\n r -= 1\\n if r <= l:\\n print(s)\\n continue\\n print(l * '0' + '0' + (n - r - 1) * '1')"}
{"id": "101", "input": "n = int(input())\\n\\nfor _ in range(n):\\n a, b,", "gt": "c = list(map(int, input().split()))\\n\\n print(min((a+b+c)//2, a+b, a+c, b+c))\\n"}
{"id": "102", "input": "import os\\nfrom io import BytesIO\\n\\n# input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\\nfor i in range(int(input())):\\n a, b, c, r = list(map(int, input().split()))\\n a, b = min(a, b), max(a, b)\\n left =", "gt": "max(c - r, a)\\n right = min(c + r, b)\\n if right >= a and left <= right:\\n print(b - a - (right - left))\\n else:\\n print(b - a)\\n"}
{"id": "103", "input": "s = []\\nfor i in range(1, 10):\\n k = 0\\n for l in range(1, 10):\\n k *= 10\\n k += i\\n s.append(k)\\ns.sort()\\nq = int(input())\\nwhile q:\\n n = int(input())\\n l = 0\\n", "gt": "r = len(s)\\n while l + 1 < r:\\n m = (l + r) // 2\\n if s[m] <= n:\\n l = m\\n else:\\n r = m\\n print(r)\\n q -= 1"}
{"id": "104", "input": "t = int(input())\\n\\nfor _ in range(t):\\n n, m = [int(x) for x in input().split()]\\n grid = [[int(x) for x in input().split()] for _ in range(n)]\\n\\n rows = sum(1 for x in grid if", "gt": "all(y == 0 for y in x))\\n cols = sum(1 for j in range(m) if all(grid[i][j] == 0 for i in range(n)))\\n\\n res = min(rows, cols)\\n\\n print(\"Ashish\" if res % 2 else \"Vivek\")\\n"}
{"id": "105", "input": "from sys import stdin\\ninput = stdin.readline\\nq = int(input())\\nfor rwerew in range(q):\\n n = int(input())\\n p = list(map(int,input().split()))\\n c = list(map(int,input().split()))\\n for i in range(n):\\n p[i] -= 1\\n przyn = [0] * n\\n grupa = []\\n i = 0\\n while i < n:\\n if przyn[i] == 1:\\n i += 1\\n else:\\n nowa_grupa = [i]\\n j = p[i]\\n przyn[i] = 1\\n while j != i:\\n przyn[j] = 1\\n nowa_grupa.append(j)\\n j = p[j]\\n grupa.append(nowa_grupa)\\n grupacol = []\\n for i in grupa:\\n cyk = []\\n for j in", "gt": "i:\\n cyk.append(c[j])\\n grupacol.append(cyk)\\n #print(grupacol)\\n mini = 234283742834\\n for cykl in grupacol:\\n dziel = []\\n d = 1\\n while d**2 <= len(cykl):\\n if len(cykl)%d == 0:\\n dziel.append(d)\\n d += 1\\n dodat = []\\n for d in dziel:\\n dodat.append(len(cykl)/d)\\n dziel_ost = list(map(int,dziel + dodat))\\n #print(dziel_ost, len(cykl))\\n for dzielnik in dziel_ost:\\n for i in range(dzielnik):\\n indeks = i\\n secik = set()\\n chuj = True\\n while indeks < len(cykl):\\n secik.add(cykl[indeks])\\n indeks += dzielnik\\n if len(secik) > 1:\\n chuj = False\\n break\\n if chuj:\\n mini = min(mini, dzielnik)\\n print(mini)\\n \\n"}
{"id": "106", "input": "import math\\nt = int(input())\\nfor test in range(t):\\n n,k = map(int,input().split())\\n A = list(map(int,input().split()))\\n A.sort()\\n ans", "gt": "= 0\\n for i in range(1,n):\\n if(A[i]>k):\\n ans = 0\\n break\\n rem = k-A[i]\\n ans+=rem//A[0]\\n print(ans)"}
{"id": "107", "input": "t = int(input())\\n\\nfor ti in range(t):\\n n = int(input())\\n\\n lri = [None for _ in range(n)]\\n\\n for _ in range(n):\\n li, ri = list(map(int, input().split()))\\n lri[_] = (li, ri, _)\\n\\n lri.sort()\\n\\n t = [None for _ in range(n)]\\n\\n ct, t[lri[0][2]], eg =", "gt": "1, 1, lri[0][1]\\n\\n for i in range(1, n):\\n if lri[i][0] <= eg:\\n t[lri[i][2]] = ct\\n eg = max(eg, lri[i][1])\\n else:\\n ct = 3 - ct\\n t[lri[i][2]] = ct\\n eg = lri[i][1]\\n\\n if all(ti == 1 for ti in t):\\n print(-1)\\n else:\\n print(*t)\\n"}
{"id": "108", "input": "t = int(input())\\nfor _ in range(t):\\n a, b, c, d = [int(i) for i in input().split(\" \")]\\n sgn = (a+b)%2\\n small = False\\n large = False\\n if a == 0 and d == 0:\\n small = True\\n if b == 0 and c == 0:\\n large = True\\n", "gt": "okay = [True] * 4\\n if sgn == 0:\\n okay[0] = False\\n okay[1] = False\\n else:\\n okay[2] = False\\n okay[3] = False\\n if small:\\n okay[0] = False\\n okay[3] = False\\n if large:\\n okay[1] = False\\n okay[2] = False\\n print(\" \".join([\"Ya\" if okay[i] else \"Tidak\" for i in range(4)]))"}
{"id": "109", "input": "for _ in range(int(input())):\\n n=int(input())\\n li=list(map(int,input().split()))\\n ans=0\\n for i in range(n):\\n if li[i]>=i:\\n ans+=1\\n else:\\n", "gt": "break\\n for i in range(n):\\n if li[n-1-i]>=i:\\n ans+=1\\n else:\\n break\\n if ans>n:\\n print(\"Yes\")\\n else:\\n print(\"No\")"}
{"id": "110", "input": "import sys\\nimport math\\nfrom collections import defaultdict\\nfrom collections import deque\\nfrom itertools import combinations\\nfrom itertools import permutations\\ninput = lambda : sys.stdin.readline().rstrip()\\nread = lambda : list(map(int, input().split()))\\ngo = lambda : 1/0\\ndef write(*args, sep=\"\\n\"):\\n for i in args:\\n sys.stdout.write(\"{}{}\".format(i, sep))\\nINF = float('inf')\\nMOD = int(1e9 + 7)\\nYES = \"YES\"\\nNO = -1\\n\\nfor _ in range(int(input())):\\n try:\\n n, m = read()\\n arr = read()\\n x = [0] * 65\\n \\n if sum(arr) < n:\\n print(NO)\\n go()\\n \\n for i in arr:\\n x[int(math.log2(i))] += 1\\n \\n ans = 0\\n for i in range(65):\\n if (1 << i) & n:\\n if x[i] != 0:\\n x[i] -= 1\\n continue \\n\\n total =", "gt": "0\\n for j in range(i):\\n total += (1 << j) * x[j]\\n \\n if total >= (1 << i):\\n temp = 1 << i \\n for j in reversed(range(i)):\\n while temp - (1 << j) >= 0 and x[j] > 0:\\n temp -= 1 << j \\n x[j] -= 1\\n continue \\n \\n j = i\\n while j < 65 and x[j] == 0:\\n j += 1\\n if j == 65:\\n print(NO)\\n go() \\n else:\\n x[j] -= 1\\n for k in range(i, j):\\n x[k] += 1\\n ans += (j - i)\\n \\n print(ans)\\n\\n\\n except ZeroDivisionError:\\n continue\\n\\n except Exception as e:\\n print(e)\\n continue"}
{"id": "111", "input": "for _ in range(int(input())):\\n n, k = tuple(map(int, input().split()))\\n arr = list(map(int, input().split()))\\n\\n peaks = [0 for i in range(n)]\\n for i in range(1, n - 1):\\n if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\\n peaks[i] = 1\\n\\n cnt = 0\\n max_peaks = 0\\n answer = 0\\n\\n", "gt": "for i in range(k - 1):\\n cnt += peaks[i]\\n max_peaks += peaks[i]\\n\\n for i in range(k - 1, n - 1):\\n cnt -= peaks[i - k + 2]\\n cnt += peaks[i]\\n if cnt > max_peaks:\\n max_peaks = cnt\\n answer = i - k + 2\\n\\n print(max_peaks + 1, answer + 1)\\n"}
{"id": "112", "input": "#!/usr/bin/env python\\n# coding:utf-8\\n# Copyright (C) dirlt\\n\\nfrom sys import stdin\\n\\n\\ndef run(n, m, pixels):\\n ans = 1 << 30\\n\\n acc = [[0] * (m + 1) for _ in range(n + 1)]\\n for i in range(n):\\n for j in range(m):\\n acc[i + 1][j + 1] = acc[i + 1][j] + int(pixels[i][j])\\n for j in range(m):\\n acc[i + 1][j + 1] += acc[i][j + 1]\\n # print(acc)\\n\\n for k in range(2, max(n, m) + 1):\\n r, c = (n + k - 1) // k, (m + k - 1) // k\\n res = 0\\n for i in range(r):\\n for j in range(c):\\n", "gt": "x, y = i * k, j * k\\n x2, y2 = min(x + k - 1, n - 1), min(y + k - 1, m - 1)\\n zero = acc[x2 + 1][y2 + 1] - acc[x][y2 + 1] - acc[x2 + 1][y] + acc[x][y]\\n # print(x, y, k, zero, k * k - zero)\\n res += min(zero, k * k - zero)\\n # print(k, res)\\n ans = min(ans, res)\\n print(ans)\\n\\n\\ndef main():\\n n, m = [int(x) for x in stdin.readline().split()]\\n pixels = []\\n for i in range(n):\\n pixels.append(stdin.readline().strip())\\n run(n, m, pixels)\\n\\n\\ndef __starting_point():\\n import os\\n\\n if os.path.exists('tmp.in'):\\n stdin = open('tmp.in')\\n main()\\n\\n__starting_point()"}
{"id": "113", "input": "import math\\n\\ndef lexComp(a, b):\\n if a[0] != b[0]:\\n return -1 if a[0] < b[0] else 1\\n if a[1] != b[1]:\\n return -1 if a[1] < b[1] else 1\\n return 0\\n\\ndef turn(a, b, c):\\n return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\\n \\ndef dist2(a, b):\\n return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\\n\\ndef solve(n):\\n a = [list(map(int, input())) for _ in range(n)]\\n points = []\\n for i in range(n):\\n for j in range(n):\\n if a[i][j] == 1:\\n curPoints = []\\n for dx in range(0, 2):\\n for dy in range(0, 2):\\n ok = True\\n for ddx in range(0, 2):\\n for ddy in range(0, 2):\\n x, y = i - 1 + dx + ddx, j - 1 + dy + ddy\\n", "gt": "if 0 <= x < n and 0 <= y < n and a[x][y] == 0:\\n ok = False\\n if ok:\\n curPoints.append((i + dx, j + dy))\\n points.append(curPoints[0])\\n points = list(set(points))\\n for i in range(1, len(points)):\\n if lexComp(points[0], points[i]) > 0:\\n points[0], points[i] = points[i], points[0]\\n points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\\n hull = []\\n for p in points:\\n while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\\n hull.pop()\\n hull.append(p)\\n hull = [(p[1], n - p[0]) for p in hull]\\n hull = hull[::-1]\\n start = 0\\n for i in range(1, len(hull)):\\n if lexComp(hull[i], hull[start]) < 0:\\n start = i\\n newHull = hull[start:]\\n newHull.extend(hull[:start])\\n hull = newHull\\n print(len(hull))\\n for p in hull:\\n print(p[0], p[1])\\n \\nwhile True:\\n n = int(input())\\n if n == 0:\\n break\\n solve(n)\\n"}
{"id": "114", "input": "import math\\nfrom decimal import Decimal\\nimport heapq\\nfrom collections import deque\\ndef na():\\n n = int(input())\\n b = [int(x) for x in input().split()]\\n return n,b\\n \\n \\ndef nab():\\n n = int(input())\\n b = [int(x) for x in input().split()]\\n c = [int(x) for x in input().split()]\\n return n,b,c\\n \\n \\ndef dv():\\n n, m = list(map(int, input().split()))\\n return n,m\\n \\n \\ndef dva():\\n n, m = list(map(int, input().split()))\\n a = [int(x) for x in input().split()]\\n b = [int(x) for x in input().split()]\\n return n,m,b\\n \\n \\ndef eratosthenes(n): \\n sieve = list(range(n + 1))\\n for i in sieve:\\n if i > 1:\\n for j in range(i + i, len(sieve), i):\\n sieve[j] = 0\\n return sorted(set(sieve))\\n \\n \\ndef lol(lst,k):\\n k=k%len(lst)\\n ret=[0]*len(lst)\\n for i in range(len(lst)):\\n if i+k<len(lst) and i+k>=0:\\n ret[i]=lst[i+k]\\n if i+k>=len(lst):\\n ret[i]=lst[i+k-len(lst)]\\n if i+k<0:\\n ret[i]=lst[i+k+len(lst)]\\n return(ret)\\ndef nm():\\n n = int(input())\\n b = [int(x)", "gt": "for x in input().split()]\\n m = int(input())\\n c = [int(x) for x in input().split()]\\n return n,b,m,c\\n \\n \\ndef dvs():\\n n = int(input())\\n m = int(input())\\n return n, m \\n \\ndef fact(a, b):\\n c = []\\n ans = 0\\n f = int(math.sqrt(a))\\n for i in range(1, f + 1):\\n if a % i == 0:\\n c.append(i)\\n l = len(c)\\n for i in range(l):\\n c.append(a // c[i])\\n for i in range(len(c)):\\n if c[i] <= b:\\n ans += 1\\n if a / f == f and b >= f:\\n return ans - 1\\n return ans\\n \\n\\nt = int(input())\\nfor i in range(t):\\n a ,b = list(map(int, input().split()))\\n if a == b:\\n print(0)\\n else:\\n d = abs(a - b)\\n k1 = d//5\\n d -= k1 *5 \\n k2 = d // 2\\n d -= k2 * 2\\n print(d + k1 + k2)\\n"}
{"id": "115", "input": "import sys\\ninput = sys.stdin.readline\\nimport bisect\\n\\nt=int(input())\\n\\nfor testcases in range(t):\\n n=int(input())\\n A=list(map(int,input().split()))\\n m=int(input())\\n PS=[tuple(map(int,input().split())) for i in range(m)]\\n\\n PS.sort()\\n K=[PS[-1]]\\n\\n for a,b in PS[::-1][1:]:\\n if b<=K[-1][1]:\\n continue\\n else:\\n K.append((a,b))\\n\\n K.reverse()\\n\\n", "gt": "ANS=1\\n count=0\\n countmax=n+1\\n LEN=len(K)\\n for a in A:\\n x=bisect.bisect_left(K,(a,0))\\n if x==LEN:\\n print(-1)\\n break\\n elif K[x][1]>=count+1 and countmax>=count+1:\\n count+=1\\n countmax=min(countmax,K[x][1])\\n else:\\n ANS+=1\\n count=1\\n countmax=K[x][1]\\n\\n #print(a,count,countmax,ANS)\\n else:\\n print(ANS)\\n \\n \\n \\n"}
{"id": "116", "input": "class BIT():\\n def __init__(self,n):\\n self.BIT=[0]*(n+1)\\n self.num=n\\n\\n def query(self,idx):\\n res_sum = 0\\n while idx > 0:\\n res_sum += self.BIT[idx]\\n idx -= idx&(-idx)\\n return res_sum\\n\\n #Ai += x O(logN)\\n def update(self,idx,x):\\n while idx <= self.num:\\n self.BIT[idx] += x\\n idx += idx&(-idx)\\n return\\n\\nimport sys,heapq,random\\n\\ninput=sys.stdin.readline\\n\\nn=int(input())\\nspell=[tuple(map(int,input().split())) for i in range(n)]\\n\\n\\nS=set([])\\nfor i in range(n):\\n S.add(abs(spell[i][1]))\\nS=list(S)\\nS.sort(reverse=True)\\ncomp={i:e+1 for e,i in enumerate(S)}\\nN=len(S)\\n\\nx_exist=BIT(N)\\ny_exist=BIT(N)\\npower=BIT(N)\\n\\nX,Y,S=0,0,0\\nXmax=[]\\nYmin=[]\\nx_data=[0]*(N+1)\\ny_data=[0]*(N+1)\\n\\nfor i in range(n):\\n t,d=spell[i]\\n S+=d\\n if d<0:\\n id=comp[-d]\\n if t==0:\\n", "gt": "X-=1\\n x_exist.update(id,-1)\\n power.update(id,d)\\n x_data[id]-=1\\n else:\\n Y-=1\\n y_exist.update(id,-1)\\n power.update(id,d)\\n y_data[id]-=1\\n else:\\n id=comp[d]\\n if t==0:\\n X+=1\\n x_exist.update(id,1)\\n power.update(id,d)\\n heapq.heappush(Xmax,-d)\\n x_data[id]+=1\\n else:\\n Y+=1\\n y_exist.update(id,1)\\n power.update(id,d)\\n heapq.heappush(Ymin,d)\\n y_data[id]+=1\\n if X==0:\\n if Y==0:\\n print(0)\\n else:\\n while not y_data[comp[Ymin[0]]]:\\n heapq.heappop(Ymin)\\n print(2*S-Ymin[0])\\n else:\\n if Y==0:\\n print(S)\\n else:\\n start=0\\n end=N\\n while end-start>1:\\n test=(end+start)//2\\n if x_exist.query(test)+y_exist.query(test)<=Y:\\n start=test\\n else:\\n end=test\\n if y_exist.query(start)!=Y:\\n print(S+power.query(start))\\n else:\\n while not y_data[comp[Ymin[0]]]:\\n heapq.heappop(Ymin)\\n while not x_data[comp[-Xmax[0]]]:\\n heapq.heappop(Xmax)\\n print(S+power.query(start)-Ymin[0]-Xmax[0])\\n"}
{"id": "117", "input": "for nt in range(int(input())):\\n n=int(input())\\n l=list(map(int,input().split()))\\n s=sum(l)\\n e=l[0]\\n for i", "gt": "in range(1,n):\\n e=e^l[i]\\n if s==2*e:\\n print(0)\\n print ()\\n else:\\n print(2)\\n print(e,s+e)\\n"}
{"id": "118", "input": "from sys import stdin\\ninput = stdin.readline\\n\\ntests = int(input())\\nfor test in range(tests):\\n n, m = list(map(int, input().split()))\\n a = [[0] * m for _ in range(n)]\\n r = [[int(i) for i in input().split()] for _ in range(n)]\\n c = [[int(i) for i in input().split()] for _ in range(m)]\\n z = [[-1, -1] for", "gt": "_ in range(n * m + 1)]\\n \\n for i in range(n):\\n for j in range(m):\\n z[r[i][j]][0] = j\\n for i in range(m):\\n for j in range(n):\\n z[c[i][j]][1] = j\\n\\n for i in range(1, n * m + 1):\\n a[z[i][1]][z[i][0]] = i\\n\\n for i in a:\\n print(' '.join([str(j) for j in i]))\\n"}
{"id": "119", "input": "__MULTITEST = True\\n\\n## solve\\ndef solve():\\n n, x = map(int, input().split())\\n a = list(map(int, input().split()))\\n a.sort()\\n\\n group = 0\\n ptr = n-1\\n members = 0\\n\\n currentMin = int(1e10)\\n while ptr > -1:\\n currentMin = min(currentMin, a[ptr])\\n members", "gt": "+= 1\\n\\n if currentMin * members >= x:\\n group += 1\\n members = 0\\n currentMin = int(1e10)\\n \\n ptr -= 1\\n \\n print(group)\\n\\n## main\\ndef __starting_point():\\n t = (int(input()) if __MULTITEST else 1)\\n for tt in range(t):\\n solve();\\n__starting_point()"}
{"id": "120", "input": "import sys\\ninput = sys.stdin.readline\\nt = int(input())\\nfor _ in range(t):\\n n = int(input())\\n ab = [list(map(int,input().split())) for i in range(n-1)]\\n graph = [[] for i in range(n+1)]\\n deg = [0]*(n+1)\\n for a,b in ab:\\n graph[a].append(b)\\n graph[b].append(a)\\n deg[a] += 1\\n deg[b] += 1\\n pnt = [max(deg[i]-1,1) for i in range(n+1)]\\n root = 1\\n stack = [root]\\n dist", "gt": "= [0]*(n+1)\\n dist[root] = pnt[root]\\n while stack:\\n x = stack.pop()\\n for y in graph[x]:\\n if dist[y] == 0:\\n dist[y] = dist[x]+pnt[y]\\n stack.append(y)\\n far = dist.index(max(dist))\\n root = far\\n stack = [root]\\n dist = [0]*(n+1)\\n dist[root] = pnt[root]\\n while stack:\\n x = stack.pop()\\n for y in graph[x]:\\n if dist[y] == 0:\\n dist[y] = dist[x]+pnt[y]\\n stack.append(y)\\n print(max(dist))"}
{"id": "121", "input": "import sys\\ninput = sys.stdin.readline\\n\\nt=int(input())\\n\\ndef calc(x):\\n return x*(x+1)//2\\n\\nfor test", "gt": "in range(t):\\n n,m=list(map(int,input().split()))\\n\\n ANS=calc(n)\\n\\n k=n-m\\n q,mod=divmod(k,m+1)\\n\\n ANS-=calc(q+1)*mod+calc(q)*(m+1-mod)\\n\\n print(ANS)\\n \\n"}
{"id": "122", "input": "for _ in range(int(input())):\\n n = int(input())\\n ar", "gt": "= list(map(int, input().split()))\\n ar.sort()\\n print(abs(ar[n] - ar[n - 1]))"}
{"id": "123", "input": "class Solution:\\n def maxScore(self, cardPoints: List[int], k: int) -> int:\\n max_score = 0\\n curr_score= 0\\n init_hand = cardPoints[len(cardPoints)-k:]\\n max_score = sum(init_hand)\\n", "gt": "curr_score = max_score\\n for i in range(k):\\n curr_score -= init_hand[i]\\n curr_score += cardPoints[i]\\n if curr_score > max_score:\\n max_score = curr_score\\n return max_score"}
{"id": "124", "input": "import math\\nclass Solution:\\n def numMusicPlaylists(self, N: int, L: int, K: int) ->", "gt": "int:\\n s=0\\n c=0\\n r=0\\n x=math.factorial(N)\\n while(True):\\n c=x*((N-r-K)**(L-K))*(-1)**(r)//(math.factorial(N-r-K)*math.factorial(r))\\n if(c!=0):\\n s=(s+c)%(10**9+7)\\n r+=1\\n else:\\n return s\\n"}
{"id": "125", "input": "class Solution:\\n def search(self, nums, target):\\n \"\"\"\\n :type nums: List[int]\\n", "gt": ":type target: int\\n :rtype: bool\\n \"\"\"\\n return target in nums\\n"}
{"id": "126", "input": "class Solution:\\n def superPow(self, a, b):\\n result = 1\\n fermatb = (int(''.join(map(str, b)))) % 570\\n while fermatb:\\n if fermatb &", "gt": "1:\\n result = (result * a) % 1337\\n a = (a * a) % 1337\\n fermatb >>= 1\\n return result"}
{"id": "127", "input": "class Solution:\\n def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n n = len(s)\\n count = collections.Counter(s[i : i + minSize] for i", "gt": "in range(0, n - minSize + 1))\\n res = 0 \\n for k, v in count.items():\\n if len(set(k)) <= maxLetters:\\n res = max(res, v)\\n return res"}
{"id": "128", "input": "class Solution:\\n def profitableSchemes(self, G: int, P: int, group: List[int], profit: List[int]) -> int:\\n MOD = 10**9 + 7\\n group_len, profit_len = len(group),len(profit)\\n dp = [[0]*(G+1) for _ in range(P+1)]\\n dp[0][0] = 1\\n for pro, gro in", "gt": "zip(profit,group):\\n dp2 = [x[:] for x in dp]\\n for p1 in range(P+1):\\n p = min(pro + p1,P)\\n for g1 in range(G+1-gro):\\n g = g1 + gro\\n dp2[p][g] += dp[p1][g1]\\n dp2[p][g] %= MOD\\n dp = dp2\\n return sum(dp[-1]) %MOD"}
{"id": "129", "input": "class Solution:\\n def calculate(self, s):\\n \"\"\"\\n :type s: str\\n :rtype: int\\n \"\"\"\\n res = 0\\n num = 0\\n sign = 1\\n stk = []\\n \\n for c in s:\\n if c.isdigit():\\n num = 10 * num + (ord(c) - ord('0'))\\n elif c == '+':\\n res += sign * num\\n num = 0\\n sign = 1\\n elif", "gt": "c == '-':\\n res += sign * num\\n num = 0\\n sign = -1\\n elif c == '(':\\n stk.append(res)\\n stk.append(sign)\\n res = 0\\n sign = 1\\n elif c == ')':\\n res += sign * num\\n res *= stk.pop()\\n res += stk.pop()\\n num = 0\\n sign = 1\\n \\n if num:\\n res += sign * num\\n return res"}
{"id": "130", "input": "class Solution:\\n def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n curmaxsight = A[0] - 1\\n curmaxpair = 0\\n for sight in A[1:]:\\n if sight", "gt": "+ curmaxsight > curmaxpair:\\n curmaxpair = sight + curmaxsight\\n if sight > curmaxsight:\\n curmaxsight = sight\\n curmaxsight -= 1\\n return curmaxpair\\n \\n"}
{"id": "131", "input": "class Solution:\\n def numberOfArrays(self, s: str, k: int) -> int:\\n dp = [-1] * len(s)\\n return self.dfs(s, k, 0, dp)\\n \\n def dfs(self, s: str, k: int, start: int, dp: List[int]) -> int:\\n if start == len(s):\\n return 1\\n if s[start] == '0':\\n return 0\\n if dp[start] != -1:\\n", "gt": "return dp[start]\\n \\n res, num = 0, 0\\n \\n for i in range(start, len(s)):\\n num = num * 10 + (ord(s[i]) - ord('0'))\\n \\n if num > k:\\n break \\n \\n res += self.dfs(s, k, i + 1, dp)\\n res %= 10**9 + 7\\n \\n dp[start] = res\\n return res"}
{"id": "132", "input": "class Solution(object):\\n def parse(self,expression,d,i):\\n count = 0\\n start = i\\n if expression[i] == \"(\":\\n count += 1\\n i += 1\\n while count != 0:\\n if expression[i] == \"(\":\\n count += 1\\n elif expression[i] == \")\":\\n count -= 1\\n i += 1\\n val = self.evaluate(expression[start:i],d)\\n else:\\n while i < len(expression) and expression[i] != \" \" and expression[i] != \")\":\\n i += 1\\n val = expression[start:i]\\n if self.isnumber(val):\\n val = int(val)\\n return i,val\\n def get_left_right(self,expression,d):\\n i = 0\\n count = 0\\n i,left = self.parse(expression,d,0)\\n if i == len(expression) or expression[i] == \")\":\\n return left,None,i\\n i += 1\\n i,right = self.parse(expression,d,i)\\n return left,right,i\\n def isnumber(self,s):\\n for c in s:\\n if ord(\"0\") <= ord(c) <= ord(\"9\") or c == \"+\" or c == \"-\":\\n continue\\n else:\\n return False\\n return True\\n def evaluate(self, expression,d = {}):\\n", "gt": "\"\"\"\\n :type expression: str\\n :rtype: int\\n \"\"\"\\n if self.isnumber(expression):\\n return int(expression)\\n newd ="}
{"id": "133", "input": "class Solution:\\n def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n dp = [0] + [-1 for i in range(days[-1])]\\n \\n for day in days:\\n dp[day] = 0\\n \\n for i", "gt": "in range(1, len(dp)):\\n if dp[i] == -1:\\n dp[i] = dp[i-1]\\n \\n else:\\n dp[i] = min(\\n dp[i-1] + costs[0],\\n dp[max(i-7, 0)] + costs[1],\\n dp[max(i-30, 0)] + costs[2],\\n )\\n \\n return dp[-1]"}
{"id": "134", "input": "class Solution:\\n def balancedString(self, s: str) -> int:\\n # minimum window so that outside is possible\\n if len(s) //4 != len(s) / 4: return -1 \\n ans, lb, n_cnt = len(s), 0, collections.Counter(s)\\n\\n i = 0\\n while i < len(s): \\n n_cnt[s[i]] -= 1 \\n while lb < len(s) and all(len(s) / 4", "gt": ">= n_cnt[c] for c in 'QWER'): \\n ans = min(ans, abs(i - lb + 1))\\n if ans == 0: return 0\\n n_cnt[s[lb]] += 1\\n lb += 1\\n # here is actually a swap? \\n if lb > i: \\n i, lb = lb, i\\n i +=1\\n\\n return ans\\n \\n \\n \\n \\n \\n \\n"}
{"id": "135", "input": "class Solution:\\n def numDupDigitsAtMostN(self, N: int) -> int:\\n # N -> total numbers less than or equal to N\\n # We will calculate the integers with all different digits (which are less than/equal to N)\\n # Then the answer would be: N - nums_with_different_digits\\n \\n # Calculate the number of digits in N\\n NN, dd = N, 0\\n nums = [] # store the digits\\n while(NN):\\n dd += 1\\n nums.append(NN % 10)\\n NN //= 10\\n nums.reverse()\\n \\n \\n # numbers with less digits than that of N\\n numbers =", "gt": "0\\n for i in range(dd-1):\\n numbers += 9 * (math.factorial(9) // math.factorial(9-i))\\n \\n \\n # find the N-digit numbers (all-different)\\n already_visited_digits = set()\\n \\n def fac2(n, k):\\n return math.factorial(n) // math.factorial(n-k)\\n \\n for i,n in enumerate(nums):\\n k = 0\\n for j in range((1 if i==0 else 0), (n+1 if i==dd-1 else n)):\\n if(j in already_visited_digits):\\n continue\\n k += 1\\n numbers += k * fac2(10-i-1, dd-i-1)\\n if n in already_visited_digits:\\n # All the numbers with this prefix will have at least one common digit\\n break\\n already_visited_digits.add(n)\\n \\n return N - numbers"}
{"id": "136", "input": "class Solution:\\n def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\\n j = 0\\n l = []\\n for i", "gt": "in pushed:\\n l.append(i)\\n while l and (l[-1] == popped[j]):\\n l.pop()\\n j += 1\\n if l:\\n return False\\n return True"}
{"id": "137", "input": "class Solution:\\n def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:\\n # Pad with inf to make implementation easier\\n INF = -10_000\\n n = len(grid)\\n\\n total = 0\\n max_rows = [max(row, default=INF) for row in grid]\\n # Transpose", "gt": "the grid to make max less cumbersome\\n max_cols = [max(col, default=INF) for col in zip(*grid)]\\n\\n for i, best_row in enumerate(max_rows):\\n for j, best_col in enumerate(max_cols):\\n new_height = min(best_row, best_col)\\n total += new_height - grid[i][j]\\n\\n return total\\n"}
{"id": "138", "input": "class Solution:\\n def minimumOneBitOperations(self, n: int) -> int:\\n s = 0\\n m = n\\n while m:\\n s += m & 1\\n m >>=", "gt": "1\\n\\n k = 1\\n while s:\\n s -= bool(n & k)\\n n ^= (s & 1) and k\\n k <<= 1\\n\\n return n"}
{"id": "139", "input": "class Solution:\\n def getMaxLen(self, nums: List[int]) -> int:\\n maxx = 0\\n nums.append(0)\\n \\n # starting position\\n # where we find a 0\\n i = -1\\n minusarr = []\\n \\n for j,n in enumerate(nums):\\n if n == 0:\\n # now figure out previous ones\\n tot = j-i-1\\n if", "gt": "not minusarr or len(minusarr)%2 == 0:\\n maxx = max(maxx, tot)\\n else:\\n # drop the first or last 0\\n left = minusarr[0]-i\\n right = j-minusarr[-1]\\n maxx = max(maxx, tot - min(left, right))\\n \\n # reinitiate\\n minusarr = []\\n i = j\\n elif n < 0:\\n minusarr.append(j)\\n return maxx"}
{"id": "140", "input": "class Solution:\\n def minDeletionSize(self, A: List[str]) -> int:\\n def isSorted(arr, i, j):\\n return all(arr[k] <= arr[k+1] for k in range(i, j))\\n ans = 0\\n ranges = [[0, len(A)-1]]\\n for col in zip(*A):\\n if not ranges:\\n break\\n if all(isSorted(col, i, j) for i, j in ranges):\\n tmp = []\\n for i, j", "gt": "in ranges:\\n start = i\\n for k in range(i, j+1):\\n if col[k] != col[start]:\\n if k - start > 1:\\n tmp.append([start, k-1])\\n start = k \\n if j + 1 - start > 1:\\n tmp.append([start, j])\\n start = k \\n ranges[:] = tmp\\n else: \\n ans += 1\\n return ans\\n \\n"}
{"id": "141", "input": "class Solution:\\n def findMaximumXOR(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n ans = 0\\n for bit in range(31, -1, -1) :\\n ans = (ans << 1) + 1\\n pre", "gt": "= set()\\n for n in nums :\\n p = (n >> bit) & ans\\n if p in pre :\\n break\\n pre.add(ans - p)\\n else :\\n ans -= 1\\n return ans"}
{"id": "142", "input": "class Solution:\\n def numRescueBoats(self, people: List[int], limit: int) -> int:\\n \\n people.sort()\\n lo = 0 \\n hi = len(people) - 1\\n count = 0\\n", "gt": "\\n while lo <= hi:\\n count += 1\\n if people[lo] + people[hi] <= limit:\\n lo += 1\\n hi -= 1\\n \\n return count\\n \\n"}
{"id": "143", "input": "class Solution:\\n def findLUSlength(self, strs):\\n \"\"\"\\n :type strs: List[str]\\n :rtype: int\\n \"\"\"\\n def isSubseq(s1, s2):\\n i, m=0, len(s1)\\n for c in s2:\\n if i==m: return True\\n if", "gt": "s1[i]==c: i+=1\\n return i==m\\n \\n strs.sort(key=len, reverse=True)\\n for i, s1 in enumerate(strs):\\n if all(not isSubseq(s1, s2) for j, s2 in enumerate(strs) if i!=j):\\n return len(s1) \\n return -1"}
{"id": "144", "input": "class Solution:\\n def totalFruit(self, tree: List[int]) -> int:\\n prior_fruit = tree[0]\\n prior_fruit_counter = 0\\n fruits_in_basket = [tree[0]]\\n fruits_in_basket_counter = 0\\n max_fib = -1\\n for fruit in tree: \\n if prior_fruit == fruit:\\n prior_fruit_counter += 1\\n fruits_in_basket_counter", "gt": "+= 1\\n elif prior_fruit != fruit:\\n if fruit in fruits_in_basket:\\n fruits_in_basket_counter += 1\\n else:\\n fruits_in_basket, fruits_in_basket_counter = [prior_fruit, fruit], prior_fruit_counter + 1\\n prior_fruit, prior_fruit_counter = fruit, 1\\n if fruits_in_basket_counter > max_fib:\\n max_fib = fruits_in_basket_counter\\n return max_fib"}
{"id": "145", "input": "class Solution:\\n def minSteps(self, n):\\n \"\"\"\\n :type n: int\\n :rtype: int\\n \"\"\"\\n primeFactors=[]\\n", "gt": "for i in range(2,int(n**.5)+1):\\n while n%i==0:\\n primeFactors.append(i)\\n n=n//i\\n if n>1:\\n primeFactors.append(n)\\n return sum(primeFactors)"}
{"id": "146", "input": "class Solution(object):\\n def judgePoint24(self, nums):\\n bad = '떢븻각걎냇갅갸꺚뵟숣욄뵴뵞뤼갈갌뤔떌옊메늄숭캸긶꺛옖갍뇐쩢곴듇걯궄옕왹눞솴걃끗긬땉궿가쌀낐걄숤뺴늘걘꽸숢걂갋갃쫐꼔솾쩡쇔솿끛뤜간븺쩬웨딴옠뤛갂뵪덠놤빐옋귒늂갰갖놥궾갆옌뼘묰거갎긷낤겼'\\n", "gt": "return chr(int(''.join(map(str, sorted(nums)))) + 42921) not in bad\\n"}
{"id": "147", "input": "class Solution:\\n def decodeString(self, s):\\n \"\"\"\\n :type s: str\\n :rtype: str\\n \"\"\"\\n stack = []\\n stack.append([\"\", 1])\\n num = \"\"\\n for ch in s:\\n if ch.isdigit():\\n num +=", "gt": "ch\\n elif ch == '[':\\n stack.append([\"\", int(num)])\\n num = \"\"\\n elif ch == ']':\\n st, k = stack.pop()\\n stack[-1][0] += st*k\\n else:\\n stack[-1][0] += ch\\n return stack[0][0]\\n \\n"}
{"id": "148", "input": "class Solution:\\n def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n mod = 10**9+7\\n \\n order = sorted(range(n), key=lambda i: efficiency[i], reverse=True)\\n\\n heap = []\\n filled = 0\\n rec = 0\\n speed_sum", "gt": "= 0\\n\\n for i in order:\\n if filled < k:\\n heapq.heappush(heap, speed[i])\\n filled += 1\\n speed_sum += speed[i]\\n else:\\n removed = heapq.heappushpop(heap, speed[i])\\n speed_sum += speed[i] - removed\\n rec = max(rec, speed_sum*efficiency[i])\\n\\n return rec %mod"}
{"id": "149", "input": "class Solution:\\n def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n ws = sorted(worker, reverse=True)\\n dp = sorted(zip(difficulty, profit), key=lambda x: x[1], reverse=True)\\n # print(list(dp))\\n \\n i =", "gt": "0\\n total = 0\\n for w in ws:\\n while dp[i][0] > w:\\n i = i + 1\\n if i >= len(dp):\\n return total\\n total = total + dp[i][1]\\n return total"}
{"id": "150", "input": "class Solution:\\n def removeDuplicates(self, s: str, k: int) -> str:\\n st=[['*',0]]\\n for c in s:\\n", "gt": "if c!=st[-1][0]:\\n st.append([c,1])\\n else:\\n st[-1][1]+=1\\n if st[-1][1]==k:\\n st.pop()\\n res=''\\n for c,v in st:\\n res+=c*v\\n return res"}
{"id": "151", "input": "class Solution:\\n def partitionDisjoint(self, A: List[int]) -> int:\\n biggest = A[0]\\n newbiggest = A[0]\\n lenL = 1\\n total = 1\\n for itr in", "gt": "A[1:]:\\n total += 1\\n if itr < biggest:\\n lenL = total\\n biggest = newbiggest\\n else:\\n if itr > newbiggest:\\n newbiggest = itr\\n return lenL\\n\\n"}
{"id": "152", "input": "class Solution:\\n def strongPasswordChecker(self, s):\\n \"\"\"\\n :type s: str\\n :rtype: int\\n \"\"\"\\n def length_requirement(password):\\n length = len(password)\\n # positive means addition, negative means deletion\\n if length < 6:\\n return 6 - length\\n elif length > 20:\\n return 20 - length\\n else:\\n return 0\\n \\n \\n def category_requirement(password):\\n # input\\n string = set(password)\\n lowercase = set('qwertyuiopasdfghjklzxcvbnm')\\n uppercase = set('QWERTYUIOPASDFGHJKLZXCVBNM')\\n digit = set('1234567890')\\n condition = [lowercase, uppercase, digit]\\n # output positive for addition\\n missing = 0\\n for s in condition:\\n if not s & string:\\n missing += 1\\n return missing\\n \\n \\n def repeat_requirement(password):\\n # store the repeated character and counts its occurrence\\n count = 1\\n repeat = None\\n weak_pair = []\\n for c in password:\\n if c == repeat:\\n # the same character\\n count += 1\\n else:\\n # new character\\n if count >= 3:\\n weak_pair.append([repeat, count])\\n count = 1\\n repeat = c\\n # add last pair\\n if count >= 3:\\n weak_pair.append([repeat, count])\\n #", "gt": "length of 'aaaaaa' divide by 3 returns the time of change\\n change = 0\\n one = 0\\n two = 0\\n for _, length in weak_pair:\\n change += length // 3\\n if length % 3 == 0:\\n one += 1\\n elif length % 3 == 1:\\n two += 1\\n return change, one, two\\n \\n \\n def minimum_change(password):\\n print(password, end=' ')\\n length = length_requirement(password)\\n category = category_requirement(password)\\n repeat, one, two = repeat_requirement(password)\\n # length: delete or insert\\n # category: insert or replace\\n # repeat: delete or replace, or insert\\n print(length, category, repeat, one, two, end=' * ')\\n \\n # insert or replace is effective\\n if length >= 0:\\n return max(length, category, repeat)\\n else:\\n # delete required\\n delete = - length\\n repeat -= min(delete, one)\\n repeat -= min(max(delete - one, 0), two * 2) // 2\\n repeat -= max(delete - one - 2 * two, 0) // 3\\n return delete + max(category, repeat)\\n \\n return minimum_change(s)\\n"}
{"id": "153", "input": "class Solution:\\n def maxDistance(self, position: List[int], m: int) -> int:\\n position.sort()\\n \\n max_distance_between = (position[-1] - 1) // (m - 1)\\n min_distance_between = 1\\n \\n if self.isDistancePossible(max_distance_between, position, m): return max_distance_between\\n \\n while max_distance_between > min_distance_between + 1:\\n middle_distance = (min_distance_between + max_distance_between) // 2\\n \\n if", "gt": "self.isDistancePossible(middle_distance, position, m):\\n min_distance_between = middle_distance\\n else:\\n max_distance_between = middle_distance\\n \\n return min_distance_between\\n \\n def isDistancePossible(self, distance, position, m):\\n used_ball_count = 0\\n previous_used_position = float('-inf')\\n \\n for pos in position:\\n if pos - previous_used_position >= distance:\\n used_ball_count += 1\\n previous_used_position = pos\\n \\n return used_ball_count >= m"}
{"id": "154", "input": "class Solution:\\n def makesquare(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: bool\\n \"\"\"\\n if len(nums) < 4:\\n return False\\n \\n length = sum(nums)\\n if length % 4:\\n return False\\n length = (int) (length / 4)\\n \\n nums.sort(reverse=True)\\n #print(nums)\\n \\n if length < nums[0]:\\n return False\\n elif length == nums[0]:\\n stack = list([(set([0]), 1, length, 1)])\\n else:\\n stack = list([(set([0]), 1, length - nums[0], 2)]) # (usedIndexSet, searchStartFromIndex, target, remainRounds)\\n while stack:\\n usedSet, startIndex, target, remainRounds", "gt": "= stack.pop()\\n #print(usedSet, set(range(0, len(nums))) - usedSet, target, remainRounds)\\n for i in range(len(nums) - 1, startIndex - 1, -1):\\n if i in usedSet:\\n continue\\n num = nums[i]\\n if num < target and i + 1 < len(nums):\\n stack.append((usedSet |"}
{"id": "155", "input": "class Solution:\\n def maxArea(self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int]) -> int:\\n mod = int(1e9)+7\\n return ( ( self.getMax(horizontalCuts, h) % mod ) * ( self.getMax(verticalCuts, w) % mod ) ) % mod\\n \\n def getMax(self, cuts, size):\\n", "gt": "if len(cuts) == 1:\\n return max(cuts[0], size - cuts[0])\\n \\n cuts.sort()\\n \\n max_cut_size = max(cuts[0], size - cuts[-1])\\n for index in range(1, len(cuts)):\\n if cuts[index] - cuts[index - 1] > max_cut_size:\\n max_cut_size = cuts[index] - cuts[index - 1]\\n \\n return max_cut_size"}
{"id": "156", "input": "class Solution:\\n def maxJumps(self, arr: List[int], d: int) -> int:\\n dp = [1] * (len(arr) + 1)\\n stack = []\\n for i, n in enumerate(arr + [1000000]):\\n while stack and arr[stack[-1]] < n:\\n same_height_idx = [stack.pop()]\\n while stack and arr[stack[-1]] == arr[same_height_idx[0]]:\\n", "gt": "same_height_idx.append(stack.pop())\\n for j in same_height_idx:\\n # jump to left\\n if i - j <= d:\\n dp[i] = max(dp[i], dp[j] + 1)\\n # jump to right\\n if stack and j - stack[-1] <= d:\\n dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\\n stack.append(i)\\n return max(dp[:-1])"}
{"id": "157", "input": "import sys\\n\\ndef dp(s1, s2, i, j, mem):\\n if (i, j) in mem:\\n return mem[(i, j)]\\n elif i >= len(s1) and j >= len(s2):\\n res = ''\\n elif i >= len(s1):\\n res = s2[j:]\\n elif j >= len(s2):\\n res = s1[i:]\\n else:\\n if s1[i] == s2[j]:\\n res = s1[i] + dp(s1, s2, i+1, j+1, mem)\\n else:\\n left = s1[i] +", "gt": "dp(s1, s2, i+1, j, mem)\\n right = s2[j] + dp(s1, s2, i, j+1, mem)\\n \\n if len(left) < len(right):\\n res = left\\n else:\\n res = right\\n mem[(i, j)] = res\\n return res\\n\\nclass Solution:\\n def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n if len(str1) == len(str2) and len(str1) == 1000:\\n return 'xjatuwbmvsdeogmnzorndhmjoqnrqjnhmfueifqwleggfbctttiqkezrltzyeqvqemfoikpzgotfyghxkyzdenhftafiepwrvmrovwtpzzsyuiseumzmywongllqmtvsdsoptwammerovabtgemkhpowndejvbuwbporfyroknrjoekdgqhqlgzxifiswevpepegmyhnxagjtsqlradgcciaecsvbpgqjzwtdebctmtallzyuvxkdztoavfxysgejqgrqkliixuvnagwzmassthjecvkfzmyongloclemvjnxkcwqqvgrzpsnsrwnigjmxyokbthtkesuawirecfugzrbydifsupuqanetgunwolqmupndhcapzxvduqwmzidatefhvpfmaqmzzzfjapdxgmddsdlhyoktbdeugqoyepgbmjkhmfjztsxpgojqbfspedhzrxavmpjmwmhngtnlduynskpapvwlprzruadbmeeqlutkwdvgyzghgprqcdgqjjbyefsujnnssfmqdsvjhnvcotynidziswpzhkdszbblmrustoxwtilhkoawcrpatbypvkmajumsthbebdxqqrpphuncthosljxxvfaeidbozayekxrolwezqtfzlifyzqcvvxmmnehrcskstepwshupglzgmbretpmyehtavnwzyunsxegmbtzjflnqmfghsvwpbknqhczdjlzibhrlmnouxrljwabwpxkeiedzoomwhoxuhffpfinhnairblcayygghzqmotwrywqaxdwetyvvgohmujneqlzurxcpnwdhipldofyqvfdhrggurbszqeqoxdurlofkqqnunrjomszjimrxbqyzyagyoptfzakolkieayzojwkryidtctemtesuhbzczzvhlbbhacnubdifjjocporuzuevsofbuevuxhgiexsmckibyfntnfcxhqgaoqyhfwqdakyobcooubdvypxjjtsrqarqagogrnaxeugzdmapyaggknksrfdrmuwqnoxrctnqspsztnyszhwqgdqjxxechxrsmbyhdlkwkvtlkdbjnmzgvdmhvbllqqlcemkqxopyixdlldcomhnmvnsaftphjdqkyjrrjqqqpkdgnmmelrdcscbwhtyhugieuppqqtwychtpjmlaeoxsckdlhlzyitomjczympqqmnisxzztlliydwtxhddvtvpleqdwamfbnhhkszsfgfcdvakysqmmausdvihopbvygqdktcwesudmhffagxmuayoalovskvcgetapucehntotdqbfxlqhkrolvxfzrtrmrfvjqoczkfaexwxsvujizcficzeuqflegwpbuuoyfuoovycmahhpzodstmpvrvkzxxtrsdsxjuuecpjwimbutnvqtxiraphjlqvesaxrvzywxcinlwfslttrgknbpdlscvvtkfqfzwudspewtgjposiixrfkkeqmdbvlmpazzjnywxjyaquilxrqnpdvinaegpccnnweuobqvgxnomulzoejantsalzyjjpnsrqkxemyivcatemoluhqngifychonbnizcjrlmuywxtlezdwnkkztancarphldmwhnkdguheloqyywrxrzjganyevjtrzofmtpuhifoqnokglbdeyshpodpmdcnhbccqtzxmimp'\\n \\n sys.setrecursionlimit(10**6)\\n return dp(str1, str2, 0, 0,"}
{"id": "158", "input": "class Solution:\\n def isMatch(self, s, p):\\n \"\"\"\\n :type s: str\\n :type p: str\\n :rtype: bool\\n \"\"\"\\n '''维护两个下标，逐个比较，如果pj为*，则记录*的位置，将*后一个元素与si进行比较，如果不相等，则将i从记录的位置+1，重新比较'''\\n i=0\\n j=0\\n star=-1\\n lenp=len(p)\\n while i<len(s):\\n if j<lenp and (s[i]==p[j]", "gt": "or p[j]=='?'):\\n i+=1\\n j+=1\\n elif j<lenp and p[j]=='*':\\n star=j\\n mi=i\\n j+=1\\n elif star!=-1:\\n mi+=1\\n i=mi\\n j=star+1\\n else:\\n return False\\n while j<lenp and p[j]=='*':\\n j+=1\\n \\n return j==lenp"}
{"id": "159", "input": "class Solution:\\n def kSimilarity(self, A: str, B: str) -> int:\\n a = ''\\n b = ''\\n \\n for i in range(len(A)):\\n if A[i] != B[i]:\\n a+=A[i]\\n b+=B[i]\\n \\n return self.dfs(a,b)\\n \\n def dfs(self,a,b):\\n if not a:\\n return 0\\n one = []\\n two = []\\n \\n for i in range(len(a)):\\n if a[0] == b[i]:\\n one.append(i)\\n", "gt": "if b[0] == a[i]:\\n two.append(i)\\n \\n if two:\\n i = two[0]\\n c = a[1:i] + a[i+1:]\\n d = b[1:i] + b[i+1:]\\n return self.dfs(c,d) + 1\\n else:\\n res = float('inf')\\n for i in one:\\n c = a[i] + a[1:i] + a[i+1:]\\n d = b[:i]+b[i+1:]\\n res= min(res,self.dfs(c,d)+1)\\n \\n return res\\n\\n \\n \\n \\n \\n \\n \\n"}
{"id": "160", "input": "from collections import deque\\nclass Solution:\\n def constrainedSubsetSum(self, nums, k):\\n N, queue = len(nums), deque()\\n dp = [val for val in nums]\\n for i, val in enumerate(nums):\\n if", "gt": "queue and (i - queue[0] > k):\\n queue.popleft()\\n if queue and dp[queue[0]] > 0:\\n dp[i] += dp[queue[0]]\\n while queue and dp[i] >= dp[queue[-1]]:\\n queue.pop()\\n queue.append(i)\\n return max(dp)"}
{"id": "161", "input": "class Solution:\\n def stoneGame(self, piles:", "gt": "List[int]) -> bool:\\n return True"}
{"id": "162", "input": "class Solution(object):\\n def isValidSerialization(self, preorder):\\n \"\"\"\\n :type preorder: str\\n :rtype: bool\\n \"\"\"\\n # remember how many empty slots we have\\n # non-null nodes occupy one slot but create two new slots\\n # null nodes occupy one slot\\n \\n p = preorder.split(',')\\n \\n #initially we have one empty slot to put the root in it\\n slot", "gt": "= 1\\n for node in p:\\n \\n # no empty slot to put the current node\\n if slot == 0:\\n return False\\n \\n # a null node?\\n if node == '#':\\n # ocuppy slot\\n slot -= 1\\n else:\\n # create new slot\\n slot += 1\\n \\n #we don't allow empty slots at the end\\n return slot==0"}
{"id": "163", "input": "class Solution:\\n def longestCommonSubsequence(self, a: str, b: str) -> int:\\n last, current = [0] * (len(b) + 1), [0] * (len(b) + 1)\\n \\n for i in range(len(a) - 1, -1, -1):\\n for j in", "gt": "range(len(b) - 1, -1, -1):\\n if a[i] == b[j]:\\n current[j] = 1 + last[j + 1]\\n else:\\n current[j] = max(last[j], current[j + 1])\\n last = current\\n current = [0] * (len(b) + 1)\\n return last[0]"}
{"id": "164", "input": "class Solution:\\n def isSubsequence(self, s, t):\\n \"\"\"\\n :type s: str\\n :type t: str\\n :rtype: bool\\n \"\"\"\\n if len(s) > len(t):\\n return", "gt": "False\\n for i in s:\\n if i in t:\\n index = t.find(i)\\n t = t[index + 1:]\\n else:\\n return False\\n return True"}
{"id": "165", "input": "class Solution:\\n def minInteger(self, num: str, k: int) -> str:\\n n=len(num)\\n if k<=0:\\n return num\\n \\n if", "gt": "k>n*(n-1)//2:\\n return ''.join(sorted(list(num)))\\n \\n for i in range(10):\\n idx = num.find(str(i))\\n if idx>=0 and idx<=k:\\n return num[idx]+self.minInteger(num[:idx]+num[idx+1:],k-idx)"}
{"id": "166", "input": "class Solution:\\n def findLongestWord(self, s, d):\\n \"\"\"\\n :type s: str\\n :type d: List[str]\\n :rtype: str\\n \"\"\"\\n result = ''\\n for word in d:\\n lo = 0\\n for l in word:\\n lo = s.find(l,", "gt": "lo)+1\\n if lo == 0:\\n break\\n if lo > 0 and len(word) >= len(result):\\n if len(word) == len(result):\\n result = word if word < result else result\\n else:\\n result = word\\n return result"}
{"id": "167", "input": "class Solution:\\n def minFlips(self, a: int, b: int, c: int) -> int:\\n flips = 0\\n print(bin(a))\\n print(bin(b))\\n print(bin(c))\\n while a or b or c:\\n # print(a, b, c)\\n if c % 2:\\n", "gt": "if not (a % 2 or b % 2):\\n flips += 1\\n else:\\n flips += a % 2 + b % 2\\n a //= 2\\n b //= 2\\n c //= 2\\n return flips"}
{"id": "168", "input": "class Solution:\\n def superEggDrop(self, K: int, N: int) -> int:\\n def f(t):\\n a=0\\n r=1\\n for i in range(1, K+1):\\n r *= (t-i+1)\\n", "gt": "r//=i\\n a+=r\\n if a>=N: \\n break\\n return a\\n \\n l, h= 1, N\\n while l<h:\\n m=(l+h)//2\\n if f(m)<N:\\n l=m+1\\n else:\\n h=m\\n return l"}
{"id": "169", "input": "from collections import Counter\\nclass Solution:\\n def canConstruct(self, s: str, k: int) -> bool:\\n if k > len(s): #return False\\n return False\\n counter =", "gt": "Counter(s)\\n odd_counts = 0\\n \\n for char in counter:\\n if counter[char] % 2 == 1:\\n odd_counts += 1\\n \\n return odd_counts <= k"}
{"id": "170", "input": "class Solution:\\n def integerBreak(self, n):\\n \"\"\"\\n :type n: int\\n :rtype: int\\n \"\"\"\\n", "gt": "if n==2:return 1\\n if n==3:return 2\\n res=1\\n while n>4:\\n n=n-3\\n res*=3\\n return res*n\\n"}
{"id": "171", "input": "class Solution:\\n def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\\n n = len(arr)\\n if n<=1: \\n return 0\\n l,r = n,-1\\n \\n for i in range(1,n):\\n if arr[i]<arr[i-1]:\\n l = i\\n break\\n # monotonicially increasing\\n if l == n: return 0\\n \\n for j in range(n-2,-1,-1):\\n if arr[j]>arr[j+1]:\\n r = j\\n break\\n \\n # you can delete all to the left of r", "gt": "(including r)\\n # you can also delete all to the right of l (including l)\\n ans = min(r+1,n-l)\\n \\n i = 0\\n # sliding window, find the rightmost i for each j\\n # note at all time i must be less than l\\n for j in range(r+1,n):\\n while i<l and arr[i] <= arr[j]:\\n i += 1\\n ans = min(ans,j-i)\\n return ans"}
{"id": "172", "input": "class Solution:\\n def maxProduct(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n def prod(nums):\\n #function to calculate product\\n prod = 1\\n for i in nums:\\n prod*=i\\n return prod\\n def listsplit(ls1,index):\\n result = []\\n st = -1\\n for i in index:\\n if i == 0:\\n st = i\\n else:\\n result.append(ls1[st+1:i])\\n st = i\\n if st<len(ls1)-1:\\n result.append(ls1[st+1:])\\n return result\\n \\n #main starts here\\n if not nums:\\n return 0\\n if len(nums) == 1:\\n return nums[0]\\n #find zeros: if zeros are included the result would be zeros only\\n result=[]\\n if 0 in nums:\\n zeros = [i for i in range(len(nums))", "gt": "if nums[i] ==0]\\n sublist = listsplit(nums,zeros)\\n result.append(0)\\n else:\\n sublist = [nums]\\n #find negative numbers. consider even or odd\\n sublist = [i for i in sublist if i]\\n \\n for i in sublist:\\n if prod(i) <0:\\n #there is negative number in the list\\n negative = [j for j in range(len(i)) if i[j] < 0]\\n left,right = negative[0],negative[-1]\\n if len(i) == 1:\\n result_t = i[0]\\n elif left == 0 or right == len(i) -1:\\n result_t = max(prod(i[left+1:]),prod(i[:right]))\\n else:\\n left_p,right_p = prod(i[:left]),prod(i[right+1:])\\n if left_p <= right_p:\\n result_t = prod(i[left+1:])\\n else:\\n result_t = prod(i[:right])\\n else:\\n result_t = prod(i)\\n result.append(result_t)\\n return max(result)"}
{"id": "173", "input": "class Solution:\\n def maxDiff(self, num: int) -> int:\\n if num < 10: return 8\\n a = b = str(num)\\n i = 0\\n while i < len(a):\\n if a[i] == '9':\\n i += 1\\n else:\\n a = a.replace(a[i], '9')\\n", "gt": "break\\n\\n if b[0] != '1':\\n b = b.replace(b[0], '1')\\n else:\\n i = 1\\n while i < len(b):\\n if b[i] == '1' or b[i] == '0':\\n i += 1\\n else:\\n b = b.replace(b[i], '0')\\n break\\n #print(a,b)\\n return int(a) - int(b)"}
{"id": "174", "input": "class Solution:\\n def canArrange(self, arr: List[int], k: int) -> bool:\\n freq = [0] * k\\n \\n for n in arr:\\n freq[n%k] += 1\\n \\n if freq[0] %", "gt": "2: return False\\n \\n for i in range(1, (k//2)+1):\\n if freq[i] != freq[k-i]: return False\\n \\n if k%2 is 0:\\n if freq[k//2]%2: return False\\n \\n return True"}
{"id": "175", "input": "class Solution:\\n def lengthLongestPath(self, input):\\n \"\"\"\\n :type input: str\\n :rtype: int\\n \"\"\"\\n dict={0:0}\\n maxlen=0\\n line=input.split(\"\\n\")\\n for", "gt": "i in line:\\n name=i.lstrip('\\t')\\n print(name)\\n print((len(name)))\\n depth=len(i)-len(name)\\n if '.' in name:\\n maxlen=max(maxlen, dict[depth]+len(name))\\n else:\\n dict[depth+1]=dict[depth]+len(name)+1\\n return maxlen\\n"}
{"id": "176", "input": "class Solution:\\n def findIntegers(self, num):\\n \"\"\"\\n :type num: int\\n :rtype: int\\n \"\"\"\\n dp=[1,2]\\n for i in range(2,32):\\n dp.append(dp[i-1]+dp[i-2])\\n \\n bnum=bin(num)[2:]\\n size=len(bnum)\\n ans=dp[size]\\n", "gt": "for i in range(1,size):\\n if bnum[i-1]==bnum[i]=='1':\\n #关键 娥娥 对 因为他就是一个二进制数在这儿循环呢\\n #所以他可以这样\\n break\\n if bnum[i-1]==bnum[i]=='0':\\n ans-=dp[size-i]-dp[size-i-1]\\n #其实问题就是在于这儿 是在干什么 为什么会有这么一部 算了 先记住\\n return ans"}
{"id": "177", "input": "class Solution:\\n def isScramble(self, A, B):\\n if len(A) != len(B) or sorted(A) != sorted(B):\\n return False\\n \\n if len(A) == 1 or A == B:\\n", "gt": "return True\\n \\n for i in range(1, len(A)):\\n if self.isScramble(A[:i], B[:i]) and self.isScramble(A[i:], B[i:]):\\n return True\\n elif self.isScramble(A[:i], B[-i:]) and self.isScramble(A[i:], B[:-i]):\\n return True\\n return False"}
{"id": "178", "input": "class Solution:\\n def minWindow(self, s, t):\\n \"\"\"\\n :type s: str\\n :type t: str\\n :rtype: str\\n \"\"\"\\n left=-1\\n right = 0\\n result = \"\"\\n totalMatch = 0\\n d = {}\\n for c in t:\\n d[c] = d.get(c, 0) + 1\\n \\n for right in range(len(s)):\\n c = s[right]\\n d[c] = d.get(c, 0) - 1\\n \\n # good match\\n if d[c] >=0:\\n totalMatch +=1\\n \\n #over match", "gt": "可以不移动left\\n #total match, need to advance left\\n if totalMatch == len(t):\\n totalMatch -= 1\\n \\n left +=1\\n while d[s[left]]<0:\\n d[s[left]] += 1\\n left += 1\\n \\n # we dec the count here so that next round right need to match one more s[left], \\n d[s[left]] += 1\\n \\n if result == \"\" or len(result) > right - left:\\n result = s[left: right+1]\\n \\n return result"}
{"id": "179", "input": "class Solution:\\n def lengthOfLIS(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n if len(nums) == 0:\\n return 0\\n res = [nums[0]]\\n def binarySearch(l,target):\\n left , right = 0 , len(l)-1\\n while left < right:\\n", "gt": "mid = (left + right)//2\\n if l[mid] >= target:\\n right = mid\\n else:\\n left = mid + 1\\n return left\\n for i in range(1,len(nums)):\\n if nums[i] > res[-1]:\\n res.append(nums[i])\\n else:\\n res[binarySearch(res,nums[i])] = nums[i]\\n return len(res)\\n"}
{"id": "180", "input": "class Solution:\\n def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n n = len(s)\\n\\n def compLen(c):\\n return 1 + len(str(c)) if c > 1 else 1\\n\\n @lru_cache(None)\\n def dp(i, k): # return {head: (len, -head_count)}\\n if (n - i) <= k:\\n return {} # remove all\\n x, res = s[i], {}\\n # remove\\n if k:\\n res = dp(i + 1, k - 1)\\n # keep\\n", "gt": "keep = dp(i + 1, k)\\n t = [(1 + min((leng for leng, _ in list(keep.values())), default=0), -1)]\\n if x in keep:\\n leng, negc = keep[x]\\n leng, negc = (leng - compLen(-negc) + compLen(-negc + 1),\\n negc - 1)\\n t.append((leng, negc))\\n if x in res:\\n t.append(res[x])\\n res[x] = min(t)\\n return res\\n\\n m = dp(0, k)\\n return min((leng for leng, _ in list(m.values())), default = 0)\\n"}
{"id": "181", "input": "class Solution:\\n def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n if startFuel >= target: return 0\\n heap = [] #record the reachable gas for now\\n stop = 0 #total stops\\n dist = startFuel #reachable distance\\n for d, g in stations:\\n if dist >= target: #if reach target, return\\n return stop\\n while heap and dist < d: #make sure we can reach current station by make minimum stops\\n gas = heapq.heappop(heap)\\n", "gt": "dist += -gas\\n stop += 1\\n if dist < d: #if not reachable, return -1\\n return -1\\n heapq.heappush(heap, (-g)) #add current gas to heap for future stop\\n if dist >= target:\\n return stop\\n while heap: #add the rest gas in heap from max to min to reach the target\\n g = heapq.heappop(heap)\\n stop += 1\\n dist += -g\\n if dist >= target:\\n return stop\\n return -1\\n \\n \\n \\n \\n \\n \\n"}
{"id": "182", "input": "class Solution:\\n def maxProfit(self, prices):\\n \"\"\"\\n :type prices: List[int]\\n :rtype: int\\n \"\"\"\\n n = len(prices)\\n \\n if n < 2: return 0\\n \\n sells = [0] * n\\n buys = [0] *", "gt": "n\\n \\n buys[0] = -prices[0]\\n \\n for i in range(1, n):\\n sells[i] = max(sells[i-1], buys[i-1] + prices[i])\\n buys[i] = max(buys[i-1], (sells[i-2] if i > 1 else 0) - prices[i])\\n \\n return sells[n-1]"}
{"id": "183", "input": "class Solution:\\n def trap(self, height):\\n \"\"\"\\n :type height: List[int]\\n :rtype: int\\n \"\"\"\\n if not height:\\n return 0\\n result = 0\\n left = 0\\n right = len(height) - 1\\n while left < right:\\n if height[left] <= height[right]:\\n tmp = height[left]\\n left +=", "gt": "1\\n while left < right and height[left] <= tmp:\\n result += tmp - height[left]\\n left += 1\\n else:\\n tmp = height[right]\\n right -= 1\\n while left < right and height[right] <= tmp:\\n result += tmp - height[right]\\n right -=1 \\n return result\\n"}
{"id": "184", "input": "class Solution:\\n def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\\n \\n # DP(a=index of last, b=index of last) = max of:\\n # DP(a-1, b)\\n # DP(a-1, i) + nums1[a] * max_or_min(nums2[i+1:b+1])\\n # same for b\\n \\n INF = int(1e9)\\n n, m = len(nums1), len(nums2)\\n\\n DP = [-INF] * (m", "gt": "+ 1)\\n NDP = [-INF] * (m + 1)\\n \\n for a in range(n):\\n\\n for b in range(m):\\n \\n el = nums1[a] * nums2[b]\\n\\n diag = DP[b]\\n\\n NDP[b + 1] = max(el, DP[b + 1], NDP[b], diag, diag + el)\\n \\n DP, NDP = NDP, DP\\n \\n return DP[-1]"}
{"id": "185", "input": "class Solution:\\n def maxRepOpt1(self, text: str) -> int:\\n letters = {}\\n for i, char in enumerate(text):\\n if char in letters:\\n letters[char].append(i)\\n else:\\n letters[char] = [i]\\n \\n if len(letters) == 1:\\n return len(text)\\n \\n ans = 0\\n for letter in letters:\\n cur = 0\\n prev = 0 \\n discarded = False\\n maxSoFar = 0\\n arr = letters[letter]\\n for j, pos in enumerate(arr):\\n if not j:\\n cur = 1\\n elif pos - arr[j-1] == 1:\\n cur += 1\\n", "gt": "else:\\n if not discarded and prev:\\n discarded = True\\n elif not discarded and pos - arr[j-1] > 2:\\n discarded = True\\n\\n if prev + cur > maxSoFar:\\n maxSoFar = prev+cur\\n \\n if pos - arr[j-1] == 2:\\n prev = cur\\n cur = 1\\n else:\\n prev = 0\\n cur = 1\\n print((prev+cur)) \\n if prev + cur > maxSoFar:\\n maxSoFar = prev+cur\\n if discarded:\\n maxSoFar+=1\\n if maxSoFar > ans:\\n ans = maxSoFar\\n \\n return ans\\n \\n \\n \\n"}
{"id": "186", "input": "class Solution:\\n def hasAllCodes(self, s: str, k: int) -> bool:\\n if len(s) < 2 ** k + k - 1:\\n return False # Cannot be a string, as this is the de brujin length\\n target = 2", "gt": "** k\\n seen = set()\\n cur_len = 0\\n for end in range(k, len(s) + 1):\\n chunk = s[end - k: end]\\n if chunk not in seen:\\n cur_len += 1\\n seen.add(chunk)\\n if cur_len == target:\\n return True\\n return False\\n"}
{"id": "187", "input": "class Solution:\\n def largestNumber(self, cost: List[int], target: int) -> str:\\n dp = [0] + [-target]*target\\n for t in range(1, target+1):\\n dp[t] = max([dp[t-i] for i in cost if", "gt": "i<=t]+[dp[t]]) + 1\\n if dp[-1]<=0: return '0'\\n res = ''\\n for i in range(8, -1, -1):\\n while target>=cost[i] and dp[target-cost[i]]==dp[target]-1:\\n res += str(i+1)\\n target -= cost[i]\\n return res"}
{"id": "188", "input": "class Solution:\\n def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n if runningCost >= 4 * boardingCost:\\n return -1\\n result = sum(customers) // 4\\n", "gt": "if (sum(customers) % 4) * boardingCost > runningCost:\\n result += 1\\n for customer in customers:\\n if customer <= 1:\\n result += 1\\n else:\\n break\\n return result\\n"}
{"id": "189", "input": "class Solution:\\n V1 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\\n \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\\n V2 = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\\n V3 = [\"Thousand\", \"Million\", \"Billion\"]\\n \\n def numberToWords(self, num):\\n \"\"\"\\n :type num: int\\n :rtype: str\\n \"\"\"\\n if num == 0:\\n return \"Zero\"\\n \\n answer = self.convert_hundred(num % 1000)\\n for i in range(3):\\n num //= 1000\\n \\n if num % 1000 > 0:\\n following = \" \" + answer if answer else \"\"\\n answer =", "gt": "self.convert_hundred(num % 1000) + \" \" + self.V3[i] + following\\n \\n return answer\\n \\n def convert_hundred(self, num):\\n answer = \"\"\\n \\n a = num // 100\\n b = num % 100\\n c = num % 10\\n \\n if b < 20:\\n answer = self.V1[b]\\n else:\\n following = \" \" + self.V1[c] if c > 0 else \"\"\\n answer = self.V2[b // 10] + following\\n \\n if a > 0:\\n following = \" \" + answer if answer else \"\"\\n answer = self.V1[a] + \" Hundred\" + following\\n \\n return answer\\n"}
{"id": "190", "input": "class Solution:\\n def preferences_to_scores(self, preferences):\\n scores = {}\\n for u, up in enumerate(preferences):\\n for s, v in enumerate(up):\\n scores[(u, v)] = s\\n return scores\\n \\n def unhappy_friends(self, scores, a, b):\\n ret = set()\\n for ai, aa in enumerate(a):\\n af = a[1 - ai]\\n for bi, bb in enumerate(b):\\n bf = b[1 -", "gt": "bi]\\n if scores[(aa, bb)] < scores[(aa, af)] and scores[(bb, aa)] < scores[(bb, bf)]:\\n ret.add(aa)\\n ret.add(bb)\\n return ret\\n \\n def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n scores = self.preferences_to_scores(preferences)\\n ret = set()\\n for i, a in enumerate(pairs):\\n for j in range(i):\\n b = pairs[j]\\n ret |= self.unhappy_friends(scores, a, b)\\n return len(ret)\\n"}
{"id": "191", "input": "class Solution:\\n def findLength(self, A, B):\\n def check(length):\\n seen = {A[i:i+length]\\n for i in range(len(A) - length + 1)}\\n return any(B[j:j+length] in seen\\n for j in range(len(B) - length + 1))\\n \\n A = ''.join(map(chr, A))\\n B", "gt": "= ''.join(map(chr, B))\\n lo, hi = 0, min(len(A), len(B)) + 1\\n while lo < hi:\\n mi = int((lo + hi) / 2)\\n if check(mi):\\n lo = mi + 1\\n else:\\n hi = mi\\n return lo - 1\\n \\n"}
{"id": "192", "input": "class Solution:\\n def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\\n \\n count = 0\\n length = 1\\n n_str = str(n)\\n while length < len(n_str):\\n count+= len(digits)**length\\n length+=1\\n\\n digits_sorted = sorted(digits)\\n\\n\\n ## now length should equal to len(n), we compare the number with same length\\n current_digit", "gt": "= 0\\n while current_digit < length:\\n for digit in digits_sorted:\\n next_round = False\\n if digit < n_str[current_digit]:\\n count+=len(digits)**(length-current_digit-1)\\n elif digit > n_str[current_digit]:\\n return count\\n else:\\n if current_digit == length-1:\\n return count+1\\n else: \\n current_digit+=1\\n next_round = True\\n break\\n if not next_round:\\n return count\\n\\n return count\\n \\n"}
{"id": "193", "input": "class Solution:\\n def maxCoins(self, piles: List[int]) -> int:\\n piles.sort()\\n \\n i = 0\\n j = len(piles) - 1\\n", "gt": "\\n max_coins = 0\\n for i in range(len(piles) // 3, len(piles), 2):\\n max_coins += piles[i]\\n \\n return max_coins"}
{"id": "194", "input": "from heapq import *\\nfrom collections import Counter\\n\\nclass Solution:\\n def minSetSize(self, arr: List[int]) -> int:\\n \\n counter = Counter(arr)\\n size = len(arr)\\n \\n # unique elements (remove half of them)\\n if len(counter) == size:\\n return (size - 1) // 2 + 1\\n \\n max_heap = [(-freq, value) for value, freq in", "gt": "list(counter.items())]\\n heapify(max_heap)\\n \\n removed = 0 # number of elements removed\\n removed_size = 0 # size of the remvoved set\\n \\n while removed < size//2:\\n count, value = heappop(max_heap)\\n count = -count # change the count back to +ve\\n removed += count\\n removed_size += 1\\n \\n return removed_size\\n \\n \\n"}
{"id": "195", "input": "class Solution:\\n def canPartitionKSubsets(self, nums, k):\\n \"\"\"\\n :type nums: List[int]\\n :type k: int\\n :rtype: bool\\n \"\"\"\\n target,rem=divmod(sum(nums),k)\\n if rem or max(nums)>target: return False\\n n=len(nums)\\n seen=[0]*n\\n nums.sort(reverse=True)\\n \\n def dfs(k,index,current_sum):\\n", "gt": "if k==1:\\n return True\\n \\n if current_sum==target:\\n return dfs(k-1,0,0)\\n for i in range(index,n):\\n if not seen[i] and current_sum+nums[i]<=target:\\n seen[i]=1\\n if dfs(k,i+1,current_sum+nums[i]):\\n return True\\n seen[i]=0\\n return False\\n \\n return dfs(k,0,0)\\n"}
{"id": "196", "input": "class Solution:\\n def countTriplets(self, A: List[int]) -> int:\\n counters = [0] * (1 << 16)\\n counters[0] = len(A)\\n for num in A:\\n mask = (~num) & ((1 << 16) -", "gt": "1)\\n sm = mask\\n while sm != 0:\\n counters[sm] += 1\\n sm = (sm - 1) & mask\\n \\n return sum(counters[num1 & num2] for num1 in A for num2 in A)\\n"}
{"id": "197", "input": "class Solution:\\n def maxSubarraySumCircular(self, A: List[int]) -> int:\\n N = len(A)\\n if(N==0):\\n return 0\\n curr_max = A[0]\\n global_max = A[0]\\n curr_min = A[0]\\n global_min = A[0]\\n flag = 0 \\n if(A[0]>=0):\\n flag=1\\n \\n for i in range(1, N):\\n if(A[i]>=0):\\n flag=1\\n if(curr_max >= 0):\\n curr_max", "gt": "= curr_max + A[i] \\n else:\\n curr_max = A[i]\\n \\n if(curr_min >= 0):\\n curr_min = A[i]\\n else:\\n curr_min = curr_min + A[i] \\n \\n if(curr_max > global_max):\\n global_max = curr_max\\n if(curr_min < global_min):\\n global_min = curr_min\\n if(flag==0):\\n return max(A)\\n return max(global_max, sum(A) - global_min)"}
{"id": "198", "input": "class Solution:\\n def isValid(self, s: str) -> bool:\\n if not s:\\n", "gt": "return True\\n return self.isValid(s.replace('abc', '')) if s.replace('abc', '') != s else False\\n"}
{"id": "199", "input": "class Solution:\\n def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n dist = [ abs( ord(s[i]) - ord(t[i]) ) for i in range(len(s))]\\n \\n# i = 0\\n# cur = 0\\n# res = 0\\n# for j in range(len(s)):\\n# cur += dist[j]\\n# while", "gt": "cur>maxCost:\\n# cur -= dist[i]\\n# i += 1\\n# res = max(res, j-i+1)\\n \\n# return res\\n\\n i = 0\\n cost = maxCost\\n for j in range(len(s)):\\n cost -= dist[j]\\n if cost < 0:\\n cost += dist[i]\\n i += 1\\n \\n return j-i+1\\n \\n \\n"}
{"id": "200", "input": "class Solution:\\n def longestConsecutive(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n longest_streak = 0\\n num_set = set(nums)\\n for num in num_set:\\n if num - 1 not", "gt": "in num_set:\\n current_num = num\\n current_streak = 1\\n \\n while current_num + 1 in num_set:\\n current_num += 1\\n current_streak += 1\\n \\n longest_streak = max(longest_streak, current_streak)\\n return longest_streak"}
{"id": "201", "input": "class Solution:\\n def findMinFibonacciNumbers(self, k: int) -> int:\\n fib = [1, 1] # initializing a Fibonacci table with F[0] and F[1]\\n i = 1 # index that will represent the last filled index of table\\n temp = fib[0] + fib[1] # initial value of values to be appended\\n while temp < k: # we keep filling table until temp >= k\\n fib.append(temp) # add the current value to the table\\n i += 1 # increase i by 1 to keep track of the last filled index\\n temp =", "gt": "fib[i] + fib[i-1] # calculate new temp\\n fib.append(temp) # to cover case temp == k, we append the last value >= k\\n \\n ans = 0 # initializing answer value with 0\\n j = -1 # placeholder to represent last checked Fibonacci table index\\n while k > 0: # keep repeating until k <= 0\\n temp = fib[j] # get the biggest number available \\n j -= 1 # decrease j by 1 since we tried the last number\\n \\n if temp <= k:\\n ans+=1\\n k-=temp\\n \\n return ans"}
{"id": "202", "input": "class Solution:\\n hash = {}\\n def numTrees(self, n):\\n \"\"\"\\n :type n: int\\n :rtype: int\\n \"\"\"\\n # return base case\\n if n == 0:\\n return 1\\n if n == 1 or n == 2:\\n return n\\n \\n # try fetching from hash\\n try:\\n return self.hash[n]\\n except KeyError:\\n pass\\n \\n #", "gt": "holds the sum\\n resSum = 0\\n \\n # iterate i from 1 to n-1\\n # should add up (0,4), (1,3), (2,2), (3,1), (4,0)\\n for i in range(n):\\n #print(i,n - (i+1))\\n tempSum = self.numTrees(i) * self.numTrees(n - (i+1))\\n #print(tempSum)\\n resSum += tempSum\\n \\n # append to hash\\n self.hash[n]=resSum\\n return resSum"}
{"id": "203", "input": "class Solution:\\n def longestMountain(self, A: List[int]) -> int:\\n up=0\\n down=0\\n ans=0\\n for i in range(0,len(A)-1):\\n if A[i]<A[i+1]:\\n if down==0:\\n up+=1\\n", "gt": "else:\\n up=1\\n down=0\\n \\n elif A[i]>A[i+1]:\\n if up>0:\\n down+=1\\n mountain=up+down+1\\n if ans<mountain:\\n ans=mountain\\n \\n else:\\n up=0\\n down=0\\n\\n \\n \\n return ans"}
{"id": "204", "input": "class Solution:\\n def uniquePaths(self, m, n):\\n \"\"\"\\n :type m: int\\n :type n: int\\n :rtype: int\\n \"\"\"\\n", "gt": "def f(n):\\n ret = 1\\n for i in range(1, n+1):\\n ret *= i\\n return ret\\n return f(m+n-2)//(f(m-1)*f(n-1))"}
{"id": "205", "input": "class Solution:\\n def search(self, nums, target):\\n \"\"\"\\n :type nums: List[int]\\n :type target: int\\n :rtype: int\\n \"\"\"\\n # left = 0\\n # right = len(nums) - 1\\n # while left <= right: \\n # mid = int((left + right)/2)\\n # if nums[mid] == target: \\n # return mid\\n # elif (nums[right] < target) or (nums[mid] > target and nums[right] > target): \\n # right = mid - 1\\n # else: \\n # left = mid + 1\\n # return -1\\n \\n left = 0\\n right = len(nums)", "gt": "- 1\\n while left <= right: \\n mid = int((left + right)/2)\\n if nums[mid] == target: \\n return mid\\n if (nums[left] < nums[mid]): \\n if (target < nums[left]) or (target > nums[mid]): \\n left = mid + 1\\n else: \\n right = mid - 1\\n elif (nums[left] > nums[mid]): \\n if (target < nums[mid]) or (target >= nums[left]): \\n right = mid - 1\\n else: \\n left = mid + 1\\n else: \\n if nums[right] == target: \\n return right\\n else: \\n return -1\\n return -1"}
{"id": "206", "input": "class Solution:\\n def getMax(self, arr, m, n):\\n res = 0\\n \\n for e in arr:\\n if m >= e[0] and n >= e[1]:\\n res += 1\\n m -= e[0]\\n n -= e[1]\\n \\n return res\\n \\n def findMaxForm(self, strs, m, n):\\n \"\"\"\\n :type strs: List[str]\\n", "gt": ":type m: int\\n :type n: int\\n :rtype: int\\n \"\"\"\\n arr = [(s.count('0'), s.count('1')) for s in strs]\\n arr1 = sorted(arr, key=lambda s: -min(m - s[0], n - s[1]))\\n arr2 = sorted(arr, key=lambda s: min(s[0], s[1]))\\n res = max(self.getMax(arr1, m, n), self.getMax(arr2, m, n))\\n \\n return res"}
{"id": "207", "input": "class Solution:\\n def PredictTheWinner(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: bool\\n \"\"\"\\n if not nums: return True\\n n = len(nums)\\n if n & 1 == 0: return True\\n \\n dp = [0]", "gt": "* n\\n for i in range(n-1, -1, -1):\\n for j in range(i, n):\\n if i == j:\\n dp[i] = nums[i]\\n else:\\n dp[j] = max(nums[i] - dp[j], nums[j] - dp[j-1])\\n return dp[n-1] >= 0\\n"}
{"id": "208", "input": "class Solution:\\n def largestNumber(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: str\\n \"\"\"\\n nums = [str(n) for n in nums]\\n \\n nums.sort(reverse=True)\\n \\n for i in range(1, len(nums)):\\n if len(nums[i-1])", "gt": "> len(nums[i]):\\n ran = len(nums[i])\\n j = i\\n while j-1 >= 0 and nums[j-1][:ran] == nums[j] and nums[j-1]+nums[j]<=nums[j]+nums[j-1]:\\n nums[j-1], nums[j] = nums[j], nums[j-1]\\n j -= 1\\n \\n return str(int(''.join(nums)))"}
{"id": "209", "input": "class Solution:\\n def predictPartyVictory(self, senate):\\n \"\"\"\\n :type senate: str\\n :rtype: str\\n \"\"\"\\n num = 0 # num of Reeding R\\n while ('R' in senate and 'D' in senate):\\n", "gt": "res = []\\n for i in senate:\\n if i=='R':\\n if num>=0:\\n res.append(i)\\n num+=1\\n else:\\n if num<=0:\\n res.append(i)\\n num-=1\\n senate = res\\n return 'Radiant' if 'R' in senate else 'Dire'\\n"}
{"id": "210", "input": "class Solution:\\n def mergeStones(self, stones: List[int], K: int) -> int:\\n n = len(stones)\\n if (n - 1) % (K - 1) != 0:\\n return -1\\n prefix = [0]\\n for s in stones:\\n prefix.append(prefix[-1] + s)\\n @lru_cache(None)\\n def dp(i, j):\\n if j - i +", "gt": "1 < K:\\n return 0\\n res = 0\\n if (j - i) % (K - 1) == 0:\\n res = prefix[j+1] - prefix[i]\\n return res + min(dp(i, mid) + dp(mid+1, j) for mid in range(i, j, K - 1))\\n return dp(0, n - 1)"}
{"id": "211", "input": "class Solution:\\n def containsNearbyAlmostDuplicate(self, nums, k, t):\\n \"\"\"\\n :type nums: List[int]\\n :type k: int\\n :type t: int\\n :rtype: bool\\n \"\"\"\\n if len(nums) < 2 or k <= 0 or t < 0: return False\\n if t == 0:\\n visited = set()\\n for i, n in enumerate(nums):\\n if n in visited: return True\\n visited.add(n)\\n if i", "gt": ">= k: visited.remove(nums[i-k])\\n return False\\n bucket ="}
{"id": "212", "input": "class Solution:\\n def maxUniqueSplit(self, s: str) -> int:\\n self.x, n = 0, len(s)\\n def maxUniqueSplit_(i=0, S=set()):\\n if s[i:] not in S:\\n self.x = max(self.x, len(S) + 1)\\n \\n for j", "gt": "in range(i + 1, n):\\n if s[i : j] not in S and len(S) + 1 + n - j > self.x:\\n maxUniqueSplit_(j, S.union("}
{"id": "213", "input": "class Solution:\\n def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n \\n mod = 10**9 + 7\\n\\n nums_set = set(A)\\n nums = A.copy()\\n nums.sort()\\n counts = {}\\n total = 0\\n\\n for n in nums:\\n n_count = 1\\n for d in nums:\\n if d * d > n:\\n break\\n if n % d != 0:\\n", "gt": "continue\\n e = n // d\\n if e not in nums_set:\\n continue\\n\\n subtrees = (counts[d] * counts[e]) % mod\\n if d != e:\\n subtrees = (subtrees * 2) % mod\\n n_count = (n_count + subtrees) % mod\\n counts[n] = n_count % mod\\n total = (total + n_count) % mod\\n\\n return total\\n"}
{"id": "214", "input": "class Solution:\\n def myPow(self, x, n):\\n \"\"\"\\n :type x: float\\n :type n: int\\n :rtype: float\\n \"\"\"\\n if n == 0:\\n return 1\\n if abs(n) == 1:\\n if n == 1:\\n", "gt": "return x\\n else:\\n return 1/x\\n if n > 0:\\n a, b = int(n//2), n%2\\n else:\\n a, b = -int(-n//2), -(n%2)\\n y = self.myPow(x, a)\\n z = self.myPow(x, b)\\n return y*y*z"}
{"id": "215", "input": "class Solution:\\n def movesToMakeZigzag(self, nums):\\n n = len(nums)\\n res0 = 0\\n for i in range(0, n, 2):\\n nei = min(nums[j] for j in [i - 1, i + 1] if 0 <= j <= n-1)\\n if nums[i] >= nei:\\n res0 += nums[i] -", "gt": "nei + 1\\n res1 = 0\\n for i in range(1, n, 2):\\n nei = min(nums[j] for j in [i - 1, i + 1] if 0 <= j <= n-1)\\n if nums[i] >= nei:\\n res1 += nums[i] - nei + 1\\n return min(res0, res1)"}
{"id": "216", "input": "class Solution:\\n def isGoodArray(self, nums: List[int]) -> bool:\\n n = nums[0]\\n \\n for", "gt": "i in nums:\\n n = gcd(i,n)\\n \\n if n==1:\\n return True\\n return False\\n"}
{"id": "217", "input": "class Solution:\\n def minNumberOfFrogs(self, croakOfFrogs: str) -> int:\\n # valid string? can be seperated into full croaks:\\n ### dict of letters. c, r, o, a, k should all be equal, nothing else in\\n if len(croakOfFrogs)%5!=0 or croakOfFrogs[0]!='c' or croakOfFrogs[-1]!='k':\\n return -1\\n \\n letters = {\\n 'c': 0,\\n 'r': 0,\\n 'o':", "gt": "0,\\n 'a': 0,\\n 'k': 0\\n }\\n \\n frogs = 0\\n temp = 0\\n \\n for l in croakOfFrogs:\\n letters[l] += 1\\n temp = letters['c'] - letters['k']\\n if temp > frogs:\\n frogs = temp\\n \\n \\n c_count = letters['c']\\n for letter in letters:\\n if letters[letter] != c_count:\\n return -1\\n \\n return frogs"}
{"id": "218", "input": "class Solution:\\n def subarrayBitwiseORs(self, A: List[int]) -> int:\\n res = set()\\n cur = set()\\n for a inA:\\n cur = {a | i for", "gt": "i in cur}"}
{"id": "219", "input": "class Solution:\\n def orderlyQueue(self, S: str, K: int) -> str:\\n if K >= 2:\\n return ''.join(sorted(S))\\n \\n length = len(S)\\n S = S + S\\n i, j, k = 0, 1, 0\\n while j + k < len(S) and k < length:\\n if S[i + k]", "gt": "== S[j + k]:\\n k += 1\\n continue\\n elif S[i + k] < S[j + k]:\\n j = j + k + 1\\n else:\\n i = max(i + k + 1, j)\\n j = i + 1\\n k = 0\\n return S[i : i + length]\\n"}
{"id": "220", "input": "class Solution:\\n def longestWPI(self, hours: List[int]) -> int:\\n ans, count, seen = 0, 0, {}\\n for i, hour in enumerate(hours):\\n count = count + 1 if hour > 8 else count - 1\\n if", "gt": "count > 0:\\n ans = i + 1\\n else:\\n if count not in seen:\\n seen[count] = i\\n if count - 1 in seen:\\n ans = max(ans, i - seen[count - 1])\\n return ans\\n\\n \\n"}
{"id": "221", "input": "class Solution:\\n def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n # feel like its sliding window max\\n \\n window, max_window = 0, 0\\n \\n # init first window\\n for i in range(X):\\n if grumpy[i]: window += customers[i]\\n max_window = window\\n \\n #", "gt": "Sliding Window\\n for i in range(X,len(grumpy)):\\n if grumpy[i-X]: window -= customers[i-X]\\n if grumpy[i]: window += customers[i]\\n \\n if window > max_window: max_window = window\\n \\n # \\n sum = 0\\n for i in range(len(grumpy)):\\n if grumpy[i] == 0: sum += customers[i]\\n return sum + max_window"}
{"id": "222", "input": "class Solution:\\n def longestDupSubstring(self, S):\\n nums, N = [ord(c) - ord('a') for c in S], len(S)\\n BASE, MOD = 26, 2**32\\n def check(L):\\n cur_hash, seen = 0, set()\\n for val in nums[:L]:\\n cur_hash = (cur_hash * BASE + val) % MOD\\n seen.add(cur_hash)\\n X = pow(BASE, L-1, MOD)\\n for idx, val in enumerate(nums[L:]):\\n cur_hash -= nums[idx] * X\\n cur_hash = (cur_hash *", "gt": "BASE + val) % MOD\\n if cur_hash in seen:\\n return idx + 1\\n seen.add(cur_hash)\\n return -1\\n low, high = 1, N + 1\\n start = 0\\n while low < high:\\n mid = (low + high)//2\\n idx = check(mid)\\n if idx != -1:\\n low = mid + 1\\n start = idx\\n else:\\n high = mid\\n return S[start: start + low - 1]\\n"}
{"id": "223", "input": "class Solution:\\n def lenLongestFibSubseq(self, A: List[int]) -> int:\\n \\n def getFS(x1, x2):\\n F = [x1, x2]\\n while F[-1] <= 1000000000:\\n F.append(F[-2] + F[-1])\\n return F\\n\\n C1 = getFS(1, 0)\\n C2 = C1[1:]\\n \\n def getLLFS(x1, x2):\\n max_len = 2\\n F = [x1, x2]\\n xi = x1 + x2\\n while xi in setA: \\n max_len += 1\\n F.append(xi)\\n xi = F[-2]+ F[-1]\\n if max_len == 6:\\n print(F)\\n return max_len\\n \\n max_len = 2\\n setA = set(A)\\n for i in range(len(A)):\\n for j in range(i+1, len(A)):\\n x1, x2 = A[i], A[j]\\n \\n # calculate X_{max_", "gt": "len+1}"}
{"id": "224", "input": "class Solution(object):\\n def hIndex(self, citations):\\n \"\"\"\\n :type citations: List[int]\\n :rtype: int\\n \"\"\"\\n n = len(citations)\\n l = 0\\n r = n-1\\n while l <= r:\\n m = (l + r) // 2\\n if m", "gt": "== 0 and citations[m] >= n - m or citations[m-1] < n - (m-1) and citations[m] >= n-m:\\n return n-m\\n if citations[m] < n - m:\\n l = m+1\\n else:\\n r = m\\n return 0\\n"}
{"id": "225", "input": "class Solution:\\n def numDistinct(self, s, t):\\n \"\"\"\\n :type s: str\\n :type t: str\\n :rtype: int\\n \"\"\"\\n setOft=set(t)\\n news=\"\"\\n for ch in s:\\n if ch in setOft:\\n news+=ch\\n dp=[[1", "gt": "for i in range(len(news)+1)] for j in range(len(t)+1)]\\n for j in range(1,len(t)+1):\\n dp[j][0]=0\\n \\n for i in range(len(t)):\\n for j in range(len(news)):\\n if t[i]==news[j]:\\n dp[i+1][j+1]=dp[i][j]+dp[i+1][j]\\n else:\\n dp[i+1][j+1]=dp[i+1][j]\\n return dp[len(t)][len(news)]\\n"}
{"id": "226", "input": "INF = float('inf')\\nclass Solution:\\n def pushDominoes(self, dominoes: str) -> str:\\n n = len(dominoes)\\n d1 = [-1] * n\\n d2 = [-1] * n\\n \\n cnt = INF\\n for i in range(n - 1, -1, -1):\\n if dominoes[i] == 'L':\\n cnt = 0\\n elif dominoes[i] == '.':\\n cnt += 1\\n elif dominoes[i] == 'R':\\n cnt = INF\\n", "gt": "d1[i] = cnt\\n \\n cnt = INF\\n for i in range(n):\\n if dominoes[i] == 'R':\\n cnt = 0\\n elif dominoes[i] == '.':\\n cnt += 1\\n elif dominoes[i] == 'L':\\n cnt = INF\\n d2[i] = cnt\\n \\n ret = []\\n for i in range(n):\\n if d1[i] == d2[i]:\\n ret.append('.')\\n elif d1[i] < d2[i]:\\n ret.append('L')\\n else:\\n ret.append('R')\\n return ''.join(ret)"}
{"id": "227", "input": "\\nclass Solution:\\n def numSquarefulPerms(self, A: List[int]) -> int:\\n\\n A.sort()\\n self.ans = 0\\n\\n def check(A, i, path):\\n return int((A[i] + path[-1])**0.5 + 0.0)**2 == A[i] + path[-1]\\n\\n def dfs(A, path):\\n if not A:\\n self.ans += 1\\n return\\n\\n", "gt": "for i in range(len(A)):\\n if i > 0 and A[i] == A[i - 1]:\\n continue\\n if not path or (path and check(A, i, path)):\\n dfs(A[:i] + A[i + 1:], path + [A[i]])\\n\\n dfs(A, [])\\n return self.ans\\n"}
{"id": "228", "input": "class Solution:\\n def longestOnes(self, A: List[int], K: int) -> int:\\n hulu = []\\n cnt = 0\\n num = A[0]\\n for x in A:\\n if x == num:\\n cnt += 1\\n else:\\n hulu.append([num,cnt])\\n cnt = 1\\n num = x\\n if cnt>0:\\n hulu.append([num,cnt])\\n \\n # print(hulu)\\n \\n output = 0\\n \\n if A[0] == 1:\\n start = 0\\n else:\\n start = 1\\n if len(hulu)<2:\\n return min(K,len(A))\\n \\n end = start\\n \\n usage = 0\\n ones = hulu[start][1]\\n while", "gt": "end+2<len(hulu) and usage+hulu[end+1][1]<=K:\\n usage += hulu[end+1][1]\\n ones += hulu[end+2][1]\\n end += 2\\n \\n output = ones+K\\n \\n # print([start,end,usage,ones])\\n \\n start += 2\\n \\n while start<len(hulu):\\n ones -= hulu[start-2][1]\\n usage -= hulu[start-1][1]\\n if start>end:\\n end = start\\n ones = hulu[start][1]\\n usage = 0\\n while end+2<len(hulu) and usage+hulu[end+1][1]<=K:\\n usage += hulu[end+1][1]\\n ones += hulu[end+2][1]\\n end += 2\\n # print([start,end,usage,ones])\\n \\n output = max(output,ones+K)\\n start += 2\\n \\n return min(output,len(A))\\n \\n \\n \\n \\n \\n \\n \\n \\n"}
{"id": "229", "input": "class Solution:\\n def maxVowels(self, s: str, k: int) -> int:\\n n = len(s)\\n vowel = set(['a','e','i','o','u'])\\n i=0\\n res = 0\\n while i<k:\\n if s[i] in vowel:\\n res+=1\\n", "gt": "i+=1\\n j=k\\n i=0\\n maxV = res\\n while j<n:\\n if s[i] in vowel:\\n res-=1\\n if s[j] in vowel:\\n res+=1\\n i+=1\\n j+=1\\n if maxV<res:\\n maxV = res\\n return maxV\\n \\n"}
{"id": "230", "input": "class Solution:\\n def canReorderDoubled(self, A: List[int]) -> bool:\\n cache=Counter(A)\\n c_list=sorted(list(cache),key=abs)\\n", "gt": "for x in c_list:\\n if cache[x]>cache[2*x]:\\n return False\\n cache[2*x]-=cache[x]\\n return True"}
{"id": "231", "input": "class Solution:\\n def removeKdigits(self, num, k):\\n \"\"\"\\n :type num: str\\n :type k: int\\n :rtype: str\\n \"\"\"\\n out=[]\\n for digit", "gt": "in num:\\n while k and out and out[-1] > digit:\\n out.pop()\\n k-=1\\n out.append(digit)\\n return ''.join(out[:-k or None]).lstrip('0') or \"0\""}
{"id": "232", "input": "class Solution:\\n def firstMissingPositive(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n nums = sorted(set(nums), key=lambda x: x)\\n result = 0\\n for", "gt": "i in range(len(nums)):\\n if nums[i] <= 0:\\n continue\\n elif nums[i] == result + 1:\\n result += 1\\n else:\\n break\\n return result + 1"}
{"id": "233", "input": "class Solution:\\n def findPoisonedDuration(self, timeSeries, duration):\\n \"\"\"\\n :type timeSeries: List[int]\\n :type duration: int\\n :rtype: int\\n \"\"\"\\n if not timeSeries:\\n return 0\\n prev = timeSeries[0]\\n ret = 0\\n count = 0\\n", "gt": "for t in timeSeries[1:]:\\n diff = t - prev\\n if diff > duration:\\n count += 1\\n else:\\n ret += diff \\n prev = t;\\n ret += (count+1)*duration \\n return ret\\n"}
{"id": "234", "input": "from itertools import chain\\nclass Solution:\\n def regionsBySlashes(self, grid):\\n grid = self.convert_grid(grid)\\n print(*(list(map(str, x)) for x in grid), sep='\\\\n')\\n return len([self.destroy_island(x, y, grid) for y in range(len(grid)) for x,v in enumerate(grid[y]) if v == 0])\\n\\n @staticmethod\\n def convert_grid(grid):\\n new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\\n for (x, y, v) in ((x, y, v) for y in range(len(grid)) for x,v in enumerate(grid[y]) if v in '\\\\\\\\/'):\\n new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\\n new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\\n return new_grid\\n\\n def destroy_island(self, x, y, grid):\\n grid[y][x] = 1\\n for c in Solution.search(x,", "gt": "y, grid):\\n self.destroy_island(c[0], c[1], grid)\\n\\n @staticmethod\\n def search(x, y, grid):\\n in_bounds = lambda c:0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\\n check_orthog = lambda c:in_bounds(c) and grid[c[1]][c[0]] == 0\\n def check_diag(c):\\n if not in_bounds(c) or grid[c[1]][c[0]] != 0: return False\\n d_x, d_y = c[0] - x, c[1] - y\\n sep = '\\\\\\\\' if ((d_x > 0 > d_y) or (d_x < 0 < d_y)) else '/'\\n return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\\n yield from chain(filter(check_orthog, ((x-1, y), (x+1, y), (x, y-1), (x, y+1))),\\n filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))"}
{"id": "235", "input": "class Solution:\\n def minAddToMakeValid(self, S: str) -> int:\\n if not S:\\n return 0\\n \\n stack = []\\n \\n add = 0\\n for c in", "gt": "S:\\n if c == '(':\\n stack.append(c)\\n elif c == ')':\\n if stack:\\n stack.pop()\\n else:\\n add += 1\\n \\n add += len(stack)\\n \\n return add"}
{"id": "236", "input": "class Solution:\\n def numberOfArithmeticSlices(self, A):\\n curr, sum = 0, 0\\n for i in range(2,len(A)):\\n if A[i]-A[i-1] == A[i-1]-A[i-2]:\\n curr += 1\\n sum += curr\\n else:\\n curr = 0\\n return sum\\n # solution = 0\\n # connected = 1\\n # old_diff = None\\n # sequences = []\\n # if len(A) < 3:\\n # return 0\\n \\n # for index,num in enumerate(A):\\n # if index < len(A) - 1:\\n # new_diff = num - A[index + 1]\\n # else:\\n #", "gt": "new_diff = A[index - 1] - num\\n # if old_diff == new_diff:\\n # if index == len(A) - 1 and connected >= 3:\\n # connected += 1\\n # sequences.append(connected)\\n # connected += 1\\n # else:\\n # old_diff = new_diff\\n # if connected > 2:\\n # sequences.append(connected)\\n # connected = 1\\n # for sequence in sequences:\\n # prev = 0\\n # while sequence >= 2:\\n # prev += 1\\n # solution += prev\\n # sequence -= 1\\n # return solution\\n"}
{"id": "237", "input": "class Solution:\\n def minFlipsMonoIncr(self, S: str) -> int:\\n onesSoFar = 0\\n partial = 0\\n \\n for n", "gt": "in S:\\n if n == '0':\\n partial = min(onesSoFar, partial+1) \\n else:\\n onesSoFar += 1\\n \\n return partial\\n"}
{"id": "238", "input": "class Solution:\\n def numSubarraysWithSum(self, pl, S):\\n ans = 0\\n \\n if(S == 0):\\n c = 0\\n for i in range(len(pl)):\\n if(pl[i] == 0):\\n c+=1\\n else:\\n c = 0\\n ans +=c\\n return ans;\\n \\n \\n \\n \\n \\n", "gt": "\\n l = [-1]\\n \\n for i in range(len(pl)):\\n if(pl[i] == 1 ):\\n l.append(i)\\n \\n l.append(len(pl))\\n \\n ans = 0\\n \\n for i in range(1,len(l)-S):\\n \\n ans += (l[i]-l[i-1])*(l[i+S] - l[i+S-1])\\n \\n return ans\\n \\n \\n \\n"}
{"id": "239", "input": "class Solution:\\n def maxProfit(self, prices):\\n \"\"\"\\n :type prices: List[int]\\n :rtype: int\\n \"\"\"\\n tmax_profit = 0\\n rmax_profits = [0] * len(prices)\\n rmax = -1\\n for ii in range(len(prices)-2, -1, -1):\\n if (prices[rmax] - prices[ii] > rmax_profits[ii+1]):\\n rmax_profits[ii] = prices[rmax] - prices[ii]\\n else:\\n rmax_profits[ii] = rmax_profits[ii+1]\\n if prices[ii] > prices[rmax]:\\n rmax = ii\\n #print(\"rmax profit = {}\".format(rmax_profits))\\n lmin = 0\\n lmax_profit =", "gt": "0\\n for ii in range(1, len(prices)):\\n profit = prices[ii]-prices[lmin]\\n if profit > lmax_profit:\\n lmax_profit = profit\\n if prices[ii] < prices[lmin]:\\n lmin = ii\\n tprofit = lmax_profit\\n if ii < len(prices)-1:\\n tprofit += rmax_profits[ii+1]\\n #print(\"ii ="}
{"id": "240", "input": "class Solution:\\n def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\\n \\n \\n \\n # my solution ... 128 ms ... 99 % ... 17.9 MB ... 85", "gt": "%\\n # time: O(nlogn)\\n # space: O(n)\\n \\n l2v = collections.defaultdict(list)\\n for v,l in zip(values, labels):\\n l2v[l].append(v)\\n pool = []\\n for l in l2v:\\n pool += sorted(l2v[l])[-use_limit:]\\n return sum(sorted(pool)[-num_wanted:])\\n \\n \\n"}
{"id": "241", "input": "class Solution:\\n def frequencySort(self, s):\\n \"\"\"\\n :type s: str\\n :rtype: str\\n \"\"\"\\n counter = collections.Counter(s)\\n colls = sorted(counter.items(),", "gt": "key=lambda k: k[1], reverse=True)\\n res = ''\\n for k, v in colls:\\n res += k * v\\n return res"}
{"id": "242", "input": "class Solution:\\n def move(self, pos, direction):\\n x, y = pos\\n if direction == 0:\\n y += 1\\n elif direction == 1:\\n x += 1\\n elif direction == 2:\\n y -= 1\\n elif direction == 3:\\n x -= 1\\n return (x, y)\\n \\n def isRobotBounded(self, instructions: str) -> bool:\\n direction = 0 # 0 for north, 1 for east,", "gt": "2 for south, 3 for west\\n pos = (0, 0)\\n for i in instructions:\\n if i == 'G':\\n pos = self.move(pos, direction)\\n elif i == 'L':\\n direction = (direction - 1) % 4\\n elif i == 'R':\\n direction = (direction + 1) % 4\\n if pos == (0, 0) or direction != 0:\\n return True\\n else:\\n return False\\n"}
{"id": "243", "input": "class Solution:\\n def isvalid(self,C):\\n if len(C)>2:\\n return False\\n if len(C)==1:\\n a = min(C)\\n if a==1 or C[a]==1:\\n # EXPLANATION:\\n # a==1 : All lengths are unitary like A=[1,2,3,4,...], so poping anything is fine\\n # C[a]==1: We have a unique length occurence like A=[4,4,4,4,...], so poping anything is fine too\\n return True\\n # EXPLANATION:\\n # For all other cases of len(C)==1, we'd end with a mistmatch like [1,1,2,2,2], or [1,1,1], so we need to \\\"return False\\\" right away\\n return False\\n #\\n # --------- len(D)==2 --------------\\n #\\n a,b = sorted(C)\\n # -> Attempt removing from \\\"a\\\"\\n if a==C[a]==1: \\n # EXPLANATION:\\n # If we remove from a chain of length \\\"a\\\", we will create something smaller than \\\"b\\\", so...\\n # The only way to be fine is to have a single element, like [1,2,2,2,3,3,3,...]\\n # -> If we had anything else, we would be stuck with a contradiction (so we move forward to removing \\\"b\\\")\\n return True\\n # -> Attempt removing from \\\"b\\\"\\n # EXPLANATION:\\n # This only works ifthere is a single chain of length \\\"b\\\", and poping one element makes a chain of length \\\"a\\\".\\n # In other words, if works when \\\"C[b]==1 and (b-1)==a\\\"\\n return True if ( C[b]==1 and (b-1)==a ) else False\\n def remove(self,B,x):\\n if B[x]==1:\\n B.pop(x)\\n else:\\n B[x] -= 1\\n def maxEqualFreq(self, A):\\n remove = self.remove\\n B = Counter(A) # Count number of repetitions/length (per value) [1,1,2,2,3,3,4] = {1:2, 2:2,", "gt": "3:2, 4:1}"}
{"id": "244", "input": "class Solution:\\n def flipgame(self, fronts: List[int], backs: List[int]) -> int:\\n w = set(fronts[i] for i in range(len(fronts)) if fronts[i] == backs[i])\\n \\n x = set()\\n for", "gt": "a in fronts:\\n if a not in w:\\n x.add(a)\\n for a in backs:\\n if a not in w:\\n x.add(a)\\n \\n if not x:\\n return 0\\n return min(x)"}
{"id": "245", "input": "class Solution:\\n def numSteps(self, s: str) -> int:\\n i, mid_zero = 0 , 0 \\n for j in range(1, len(s)):\\n if s[j]", "gt": "== '1':\\n mid_zero += j -i - 1\\n i = j\\n if i == 0:\\n return len(s)-1\\n return mid_zero + 1 + len(s)\\n"}
{"id": "246", "input": "class Solution:\\n def optimalDivision(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: str\\n \"\"\"\\n if(len(nums) == 0):\\n return ''\\n if(len(nums) == 1):\\n return str(nums[0])\\n if(len(nums) == 2):\\n return str(nums[0]) +", "gt": "'/' + str(nums[1])\\n res = str(nums[0]) + '/' + '('\\n for i in range(1,len(nums)-1):\\n res += str(nums[i])\\n res += '/'\\n res += str(nums[-1])\\n res += ')'\\n return res"}
{"id": "247", "input": "class Solution:\\n def replaceWords(self, dt, sentence):\\n \"\"\"\\n :type dict: List[str]\\n :type sentence: str\\n :rtype: str\\n \"\"\"\\n trie = {}\\n for w in dt:\\n t = trie\\n for c in w:\\n if c not in t: t[c] = {}\\n t = t[c]\\n t['#'] = w\\n \\n # result = []\\n \\n # for word in sentence.split():\\n # result.append(self.replace(word, trie))\\n \\n # return \" \".joinresult \\n \\n # OR\\n return \" \".join([ self.replace(i, trie) for i in sentence.split() ])\\n \\n \\n \\n \\n", "gt": "def replace( self, word, trie ):\\n cur = trie\\n for letter in word:\\n if letter not in cur: break\\n cur = cur[letter]\\n if \"#\" in cur:\\n return cur['#']\\n return word\\n \\n \\n setenceAsList = sentence.split(\" \")\\n for i in range(len(setenceAsList)):\\n for j in dt:\\n if setenceAsList[i].startswith(j):\\n setenceAsList[i] = j\\n return \" \".join(setenceAsList)\\n \\n arrs = sentence.split()\\n for i in range(len(arrs)):\\n w = arrs[i]\\n for j in range(len(arrs[i])):\\n cur = w[:j]\\n if cur in dt:\\n arrs[i] = cur\\n break\\n return ' '.join(arrs)\\n"}
{"id": "248", "input": "class Solution:\\n def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n i, window, result = 0, 0, float('inf')\\n premin = [float('inf')]*len(arr)\\n for j, num in enumerate(arr):\\n window += num\\n while window > target:\\n window -= arr[i]\\n i+=1\\n if window == target:\\n curr = j - i + 1\\n result = min(result, curr + premin[i-1])\\n premin[j] = min(curr, premin[j-1])\\n else:\\n premin[j] = premin[j-1]\\n return result if result < float('inf') else -1 \\n\\n \\n \\n \\n# class Solution:\\n# def", "gt": "minSumOfLengths(self, arr: List[int], target: int) -> int:\\n# i, window, result = 0, 0, float('inf')\\n# premin = [float('inf')] * len(arr)\\n# for j, num in enumerate(arr):\\n# window += num\\n# while window > target:\\n# window -= arr[i]\\n# i += 1\\n# if window == target:\\n# curr = j - i + 1\\n# result = min(result, curr + premin[i - 1])\\n# premin[j] = min(curr, premin[j - 1])\\n# else:\\n# premin[j] = premin[j - 1]\\n# return result if result < float('inf') else -1\\n"}
{"id": "249", "input": "class Solution:\\n def containsCycle(self, grid: List[List[str]]) -> bool:\\n n = len(grid)\\n m = len(grid[0])\\n \\n F = [i for i in range(m * n)]\\n def find(x):\\n if x == F[x]:\\n return x\\n else:\\n F[x] = find(F[x])\\n return F[x]\\n \\n for i in range(n):\\n for j in range(m):\\n", "gt": "if i > 0 and grid[i-1][j] == grid[i][j]:\\n f1 = find((i-1)*m+j)\\n f2 = find((i)*m+j)\\n if f1 == f2:\\n return True\\n F[f1] = f2\\n if j > 0 and grid[i][j-1] == grid[i][j]:\\n f1 = find((i)*m+j-1)\\n f2 = find((i)*m+j)\\n if f1 == f2:\\n return True\\n F[f1] = f2\\n return False\\n"}
{"id": "250", "input": "class Solution:\\n def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n # slide window and call isMagicSquare\\n if len(grid) < 3 or len(grid[0]) < 3:\\n return 0\\n rows = len(grid)\\n cols = len(grid[0])\\n magic_squares = 0\\n for i in range(rows - 2):\\n for j in range(cols - 2):\\n window = [tmp[j:j + 3] for tmp in grid[i: i + 3]]\\n if self.isMagicSquare(window):\\n magic_squares += 1\\n \\n return magic_squares\\n \\n def isMagicSquare(self, square: List[List[int]]) -> bool:\\n target = square[0][0] + square[0][1] + square[0][2]\\n seen = {}\\n print(square)\\n # check rows\\n for row in square:\\n tmp = 0\\n for i in row:\\n tmp += i\\n", "gt": "if i in seen or i > 9 or i < 1:\\n return False\\n else:\\n seen[i] = 1\\n if tmp != target:\\n return False\\n \\n # check cols\\n for i in range(3):\\n tmp = 0\\n for row in square:\\n tmp += row[i]\\n \\n if tmp != target:\\n return False\\n \\n \\n # check left to right diag\\n tmp = 0\\n for i in range(3):\\n tmp += square[i][i]\\n if tmp != target:\\n return False\\n \\n # check right to left diag\\n tmp = 0\\n for i in range(3):\\n tmp += square[i][2 - i]\\n if tmp != target:\\n return False\\n \\n return True"}
{"id": "251", "input": "from typing import *\\nfrom heapq import heappop, heappush\\n\\n\\nclass Solution:\\n def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\\n N = len(quality)\\n heap_quality = []\\n workers = [i for i in range(N)]\\n workers = sorted(workers, key=lambda x: wage[x] / quality[x])\\n sum_quality = 0\\n for i", "gt": "in range(K):\\n heappush(heap_quality, -quality[workers[i]])\\n sum_quality += quality[workers[i]]\\n ans = sum_quality * (wage[workers[K - 1]] / quality[workers[K - 1]])\\n for i in range(K, N):\\n heappush(heap_quality, -quality[workers[i]])\\n sum_quality += quality[workers[i]]\\n sum_quality += heappop(heap_quality) # negative quality value\\n ans = min(ans, sum_quality * (wage[workers[i]] / quality[workers[i]]))\\n return ans"}
{"id": "252", "input": "class Solution:\\n def clumsy(self, N: int) -> int:\\n if N <= 2:\\n return N\\n if N <= 4:\\n return N + 3\\n \\n if (N -", "gt": "4) % 4 == 0:\\n return N + 1\\n elif (N - 4) % 4 <= 2:\\n return N + 2\\n else:\\n return N - 1"}
{"id": "253", "input": "class Solution:\\n def minTaps(self, n: int, ranges: List[int]) -> int:\\n for i,r in enumerate(ranges):\\n l = max(0,i-r)\\n ranges[l] = max(i+r, ranges[l])\\n \\n res = lo", "gt": "= hi = 0 \\n while hi < n:\\n lo, hi = hi, max(ranges[lo:hi+1])\\n if hi == lo: return -1\\n res += 1\\n return res"}
{"id": "254", "input": "class Solution:\\n def findMinMoves(self, machines):\\n \"\"\"\\n :type machines: List[int]\\n :rtype: int\\n \"\"\"\\n if sum(machines) % len(machines) != 0:\\n return -1\\n mean = sum(machines)", "gt": "// len(machines)\\n cum, step = 0, 0\\n for x in machines:\\n cum += x - mean\\n step = max(step, abs(cum), x-mean)\\n return step"}
{"id": "255", "input": "class Solution:\\n def countNumbersWithUniqueDigits(self, n):\\n \"\"\"\\n :type n: int\\n :rtype: int\\n \"\"\"\\n ls = [1,10,91]\\n mul = 9\\n \\n res = 0\\n for i in range(8):\\n", "gt": "mul = 9\\n m = 9\\n for j in range(i+2):\\n mul *= m\\n m -= 1\\n #print(mul)\\n ls.append(mul +ls[-1])\\n if n >=9:\\n return ls[9]\\n else:\\n return ls[n]\\n"}
{"id": "256", "input": "class Solution:\\n def jump(self,nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n if len(nums) == 1:\\n return 0\\n else:\\n step = 0\\n pos = 0\\n while pos != len(nums) - 1:\\n bestStep = -1\\n bestValue = -1\\n for i in range(nums[pos], 0, -1):\\n if len(nums) - 1 == pos", "gt": "+ i:\\n bestStep = i\\n break\\n if (pos + i < len(nums) and nums[pos + i] != 0 and nums[pos + i] + i > bestValue):\\n bestStep = i\\n bestValue = nums[pos + i] + i\\n print(bestStep)\\n pos += bestStep \\n step += 1\\n \\n return step\\n \\n \\n"}
{"id": "257", "input": "class Solution:\\n def minEatingSpeed(self, piles: List[int], H: int) -> int:\\n bananas = sum(piles)\\n K = bananas // H + (bananas % H != 0)\\n while True:\\n hours_needed =", "gt": "0\\n for pile in piles:\\n hours_needed += pile // K\\n if pile % K != 0:\\n hours_needed += 1\\n if hours_needed <= H:\\n return K\\n K += 1\\n"}
{"id": "258", "input": "class Solution:\\n def maxProbability(self, n: int, edges: List[List[int]], probs: List[float], s: int, t: int) -> float:\\n # first build the graph\\n graph = {u: {} for u in range(n)}\\n for (u, v), prob in zip(edges, probs):\\n graph[u][v] = prob\\n graph[v][u] = prob\\n\\n", "gt": "# run A* search\\n frontier = [(-1, s)]\\n seen = set()\\n\\n while len(frontier) != 0:\\n neg_path_prob, u = heapq.heappop(frontier)\\n if u == t:\\n return -neg_path_prob\\n\\n seen.add(u)\\n for v, edge_prob in graph[u].items():\\n if v not in seen:\\n heapq.heappush(frontier, (neg_path_prob * edge_prob, v))\\n return 0"}
{"id": "259", "input": "class Solution:\\n def originalDigits(self, s):\\n \"\"\"\\n :type s: str\\n :rtype: str\\n \"\"\"\\n dmap={}\\n dmap[0]=s.count('z')\\n dmap[2]=s.count('w')\\n dmap[4]=s.count('u')\\n dmap[6]=s.count('x')\\n dmap[8]=s.count('g')\\n dmap[1]=s.count('o')-dmap[0]-dmap[2]-dmap[4]\\n dmap[3]=s.count('h')-dmap[8]\\n dmap[5]=s.count('f')-dmap[4]\\n dmap[7]=s.count('s')-dmap[6]\\n dmap[9]=s.count('i')-dmap[6]-dmap[8]-dmap[5]\\n", "gt": "res=''\\n #现在的问题就是如何在这里输入\\n dmap=sorted(list(dmap.items()),key=lambda x:x[0])\\n lst=['0','1','2','3','4','5','6','7','8','9']\\n #就是按照第一个来进行排序\\n '''\\n lst=['zero','one','two','three','four','five',\\n 'six','seven','eight','nine']\\n 这个是错误示范 我们需要输出的是数字 字符串 而不是字母\\n '''\\n for i in range(len(lst)):\\n res+=lst[i]*dmap[i][1]\\n return res\\n #注意 这道题比较关键的就是需要找到规律才行\\n"}
{"id": "260", "input": "import numpy as np\\nimport math\\n\\nclass Solution:\\n \\n def smallestDivisor(self, nums: List[int], threshold: int) -> int:\\n if len(nums) == 1:\\n return int(math.ceil(nums[0]/threshold))\\n \\n np_nums = np.array(nums) \\n low, high = 1, np.max(np_nums)\\n \\n divisors = []\\n", "gt": "while low + 1 < high:\\n mid = (low + high) // 2\\n \\n if np.sum(np.ceil(np_nums/mid)) > threshold:\\n low = mid\\n else:\\n high = mid\\n \\n if np.sum(np.ceil(np_nums/low)) <= threshold:\\n return low\\n \\n return high\\n"}
{"id": "261", "input": "class Solution:\\n def wiggleMaxLength(self, arr):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n n = len(arr)\\n if n < 2:\\n return n\\n wsl = [0]*n\\n wsl[0] = 1\\n for cur in range(1, n):\\n prev = cur", "gt": "- 1 \\n if arr[cur] > arr[prev] and wsl[prev] <= 1:\\n wsl[cur] = abs(wsl[prev]) + 1\\n elif arr[cur] < arr[prev] and wsl[prev] > 0:\\n wsl[cur] = (abs(wsl[prev]) + 1)*(-1)\\n else:\\n wsl[cur] = wsl[prev]\\n return abs(wsl[n-1])"}
{"id": "262", "input": "class Solution:\\n def findKthLargest(self, nums, k):\\n \"\"\"\\n :type nums: List[int]\\n :type k:", "gt": "int\\n :rtype: int\\n \"\"\"\\n nums = sorted(nums, reverse=True)\\n return nums[k - 1]"}
{"id": "263", "input": "class Solution:\\n def isSolvable(self, words: List[str], result: str) -> bool:\\n longest_word = max([len(word) for word in words])\\n if len(result) != longest_word and len(result) != longest_word + 1:\\n return False\\n \\n result_indices = []\\n acc = 0\\n all_chars = []\\n front_indices = []\\n for i in range(1, longest_word + 1):\\n for word in words:\\n if i == len(word):\\n front_indices.append(acc)\\n if i <= len(word):\\n all_chars.append(word[i * -1])\\n acc += 1\\n if i == len(result):\\n front_indices.append(acc)\\n result_indices.append(acc)\\n acc += 1\\n all_chars.append(result[i * -1])\\n\\n if len(result) > longest_word:\\n result_indices.append(acc)\\n front_indices.append(acc)\\n all_chars.append(result[0])\\n \\n self.words = words\\n self.result = result\\n self.result_indices = result_indices\\n self.all_chars = all_chars\\n self.mappings = {}\\n self.used_chars = set()\\n self.front_indices = front_indices\\n \\n return self.backtrack(0, 0)\\n \\n def backtrack(self, current_i: int, carry: int) -> bool:\\n if current_i == len(self.all_chars):\\n if self.mappings[self.result[0]] == 0:\\n return False\\n return True\\n \\n cur_char = self.all_chars[current_i]\\n\\n if current_i in self.result_indices:\\n code, new_carry = self.verify(self.result_indices.index(current_i), carry)\\n if code == 0:\\n return False\\n", "gt": "else:\\n if self.backtrack(current_i + 1, new_carry):\\n return True\\n \\n if code == 2:\\n self.used_chars.remove(self.mappings[cur_char])\\n del self.mappings[cur_char]\\n \\n return False\\n \\n if cur_char in self.mappings:\\n if current_i in self.front_indices and self.mappings[cur_char] == 0:\\n return False\\n return self.backtrack(current_i + 1, carry)\\n \\n for i in range(10):\\n if current_i in self.front_indices and i == 0:\\n continue\\n if i not in self.used_chars:\\n self.mappings[cur_char] = i\\n self.used_chars.add(i)\\n \\n if self.backtrack(current_i + 1, carry):\\n return True\\n\\n del self.mappings[cur_char]\\n self.used_chars.remove(i)\\n \\n return False\\n \\n def verify(self, index: int, carry: int) -> (int, int):\\n cur_sum = carry\\n \\n for word in self.words:\\n if index < len(word):\\n cur_sum += self.mappings[word[index * -1 -1]]\\n\\n carry = int(cur_sum / 10)\\n cur_sum = cur_sum % 10\\n \\n result_char = self.result[index * -1 - 1]\\n if result_char in self.mappings:\\n if self.mappings[result_char] != cur_sum:\\n return 0, 0\\n else:\\n return 1, carry\\n else:\\n if cur_sum in self.used_chars:\\n return 0, 0\\n self.mappings[result_char] = cur_sum\\n self.used_chars.add(cur_sum)\\n return 2, carry\\n \\n\\n \\n"}
{"id": "264", "input": "class Solution:\\n dp = [[1] * 10]\\n def knightDialer(self, n: int) -> int:\\n MOD = 10 ** 9 + 7\\n jump = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [], [0, 1,", "gt": "7], [2, 6], [1, 3], [2, 4]]\\n for i in range(len(self.dp), n):\\n new = [0] * 10\\n for j in range(10):\\n new[j] = sum(self.dp[-1][k] for k in jump[j]) % MOD\\n self.dp.append(new)\\n return sum(self.dp[n - 1]) % MOD\\n"}
{"id": "265", "input": "class Solution:\\n def maxLength(self, arr: List[str]) -> int:\\n def digit_representation(s):\\n ans = 0\\n for c in s:\\n ans |= 1<<(ord(c)-ord('a'))\\n return ans\\n \\n A = sorted([(len(s), digit_representation(s)) for s in set(arr) if len(set(s))==len(s)], reverse=True)\\n if not A: return 0\\n R = [sum(t[0] for t in A)]\\n for", "gt": "i in range(1, len(A)):\\n R.append(R[-1] - A[i][0])\\n self.ans = A[0][0]\\n \\n def helper(i, b, k):\\n if i == len(A):\\n self.ans = max(self.ans, k)\\n elif k + R[i] > self.ans:\\n if not (b & A[i][1]):\\n helper(i+1, b | A[i][1], k+A[i][0])\\n helper(i+1, b, k)\\n \\n helper(0, 0, 0); return self.ans"}
{"id": "266", "input": "class Solution:\\n def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n sum_set = set()\\n sum_set.add(0)\\n temp = 0\\n count = 0\\n for num", "gt": "in nums:\\n temp += num\\n if temp - target in sum_set:\\n count += 1\\n sum_set.clear()\\n sum_set.add(0)\\n temp = 0\\n continue\\n sum_set.add(temp)\\n return count\\n\\n"}
{"id": "267", "input": "class Solution:\\n def numSplits(self, s: str) -> int:\\n left = [0]*len(s)\\n \\n unique = set()\\n n_distinct = 0\\n for i, l in enumerate(s):\\n if l not in unique:\\n unique.add(l)\\n n_distinct += 1\\n left[i] = n_distinct\\n", "gt": "\\n count = 0\\n unique = set()\\n n_distinct = 0\\n for i in range(len(s)-1, 0,-1):\\n if s[i] not in unique:\\n unique.add(s[i])\\n n_distinct += 1\\n \\n if n_distinct == left[i-1]:\\n count += 1\\n \\n return count"}
{"id": "268", "input": "class Solution:\\n def evalRPN(self, tokens):\\n \"\"\"\\n :type tokens: List[str]\\n :rtype: int\\n \"\"\"\\n s = []\\n for token in tokens:\\n if token == \"+\":\\n a = int(s.pop())\\n b = int(s.pop())\\n s.append(a+b)\\n elif token == \"/\":\\n a = int(s.pop())\\n", "gt": "b = int(s.pop())\\n s.append(b/a)\\n elif token == \"*\":\\n a = int(s.pop())\\n b = int(s.pop())\\n s.append(a*b)\\n elif token == \"-\":\\n a = int(s.pop())\\n b = int(s.pop())\\n s.append(b-a)\\n else:\\n s.append(token)\\n if len(s) is not 1:\\n return False\\n else:\\n return int(s.pop())"}
{"id": "269", "input": "class Solution:\\n def baseNeg2(self, N: int) -> str:\\n # res = []\\n # x = N\\n # while x:\\n # res.append(x & 1)\\n # x = -(x >> 1)\\n #", "gt": "return \\\"\\\".join(map(str, res[::-1] or [0]))\\n \\n neg = [1 << i for i in range(1, 33, 2)]\\n for mask in neg:\\n if N & mask: N += mask*2\\n return bin(N)[2:]"}
{"id": "270", "input": "class Solution:\\n def kLengthApart(self, nums: List[int], k: int) -> bool:\\n \\n if nums.count(0) == len(nums):\\n return True\\n \\n idx = nums.index(1)\\n ctr = 0\\n", "gt": "for num in nums[idx+1:]:\\n if num == 1:\\n if ctr < k:\\n return False\\n ctr = 0\\n else:\\n ctr+=1\\n \\n return True\\n \\n \\n"}
{"id": "271", "input": "import math\\n\\nclass Solution:\\n def __init__(self):\\n self.happy_string = ''\\n \\n def getHappyString(self, n: int, k: int) -> str:\\n # determine starting character\\n poss_per_group = 2 ** (n - 1)\\n group_num = math.ceil(k / poss_per_group) - 1\\n starting_char = ''\\n \\n # check to make sure there are at least k happy strings\\n if k > poss_per_group * 3:\\n return ''\\n \\n if group_num == 0:\\n self.happy_string += 'a'\\n elif group_num == 1:\\n self.happy_string += 'b'\\n else:\\n self.happy_string += 'c'\\n \\n self.findNextChar(group_num, n - 1, group_num * poss_per_group, (group_num + 1) * poss_per_group, k)\\n return self.happy_string\\n \\n def findNextChar(self, char_index: int, n: int, start: int, end: int, k: int) -> None:\\n", "gt": "if n != 0:\\n lower_index = -1\\n upper_index = -1\\n \\n # 0 = 'a', 1 = 'b', 2 = 'c'\\n if char_index == 0:\\n lower_index = 1\\n upper_index = 2\\n elif char_index == 1:\\n lower_index = 0\\n upper_index = 2\\n else:\\n lower_index = 0\\n upper_index = 1\\n \\n midpoint = int((start + end ) / 2)\\n if (k <= midpoint):\\n self.happy_string += self.indexToStr(lower_index)\\n self.findNextChar(lower_index, n - 1, start, midpoint, k)\\n else:\\n self.happy_string += self.indexToStr(upper_index)\\n self.findNextChar(upper_index, n - 1, midpoint, end, k) \\n \\n def indexToStr(self, index: int) -> str:\\n if index == 0:\\n return 'a'\\n elif index == 1:\\n return 'b'\\n else:\\n return 'c'\\n \\n \\n \\n \\n \\n"}
{"id": "272", "input": "class Solution:\\n def canJump(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: bool\\n \"\"\"\\n n = len(nums)\\n \\n can = True\\n smallest_idx = n -", "gt": "1\\n \\n for i in range(n - 2, -1, -1):\\n can = i + nums[i] >= smallest_idx\\n if can:\\n smallest_idx = i\\n return can"}
{"id": "273", "input": "class Solution:\\n def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\\n # nested boxes\\n reachable=[False]*len(status)\\n visited=[False]*len(status)\\n for box in initialBoxes:\\n reachable[box]=True\\n for i in range(len(containedBoxes)):\\n for inside in containedBoxes[i]:\\n reachable[inside]=False\\n # we only start with initial boxes\\n queue=initialBoxes\\n", "gt": "target=[]\\n ret=0\\n while queue:\\n for box in queue:\\n if status[box]==1 and reachable[box] and not visited[box]:\\n ret+=candies[box]\\n visited[box]=True\\n for key in keys[box]:\\n if status[key]==0:\\n status[key]=1\\n if reachable[key]:\\n target.append(key)\\n for inside in containedBoxes[box]:\\n reachable[inside]=True\\n if status[inside]==1:\\n target.append(inside)\\n else:\\n target.append(box)\\n if target==queue:\\n break\\n queue=target\\n target=[]\\n return ret\\n"}
{"id": "274", "input": "class Solution:\\n dp = {0: 0}\\n def racecar(self, target: int) -> int:\\n if target in self.dp:\\n return self.dp[target]\\n n = target.bit_length()\\n if 2**n - 1 == target:\\n self.dp[target] = n\\n else:\\n self.dp[target] =", "gt": "self.racecar(2**n - 1 - target) + n + 1\\n for m in range(n - 1):\\n self.dp[target] = min(self.dp[target], self.racecar(target - 2**(n - 1) + 2**m) + n + m + 1)\\n return self.dp[target]"}
{"id": "275", "input": "from collections import deque\\nclass Solution:\\n def longestSubarray(self, nums, limit):\\n maxQ, minQ = deque(), deque()\\n i = 0\\n res = 0\\n for j, val in enumerate(nums):\\n while maxQ and val > maxQ[-1]: maxQ.pop()\\n while minQ and val < minQ[-1]: minQ.pop()\\n maxQ.append(val)\\n minQ.append(val)\\n if maxQ[0] - minQ[0] > limit:\\n if maxQ[0] == nums[i]: maxQ.popleft()\\n if minQ[0] == nums[i]: minQ.popleft()\\n i += 1\\n res = max(res,", "gt": "j-i+1)\\n return res\\n \\nfrom collections import deque\\nclass Solution:\\n def longestSubarray(self, nums, limit):\\n maxQ, minQ = deque(), deque()\\n i = 0\\n for val in nums:\\n while maxQ and val > maxQ[-1]: maxQ.pop()\\n while minQ and val < minQ[-1]: minQ.pop()\\n maxQ.append(val)\\n minQ.append(val)\\n if maxQ[0] - minQ[0] > limit:\\n if maxQ[0] == nums[i]: maxQ.popleft()\\n if minQ[0] == nums[i]: minQ.popleft()\\n i += 1\\n return len(nums) - i"}
{"id": "276", "input": "class Solution:\\n def checkValidString(self, s):\\n \"\"\"\\n :type s: str\\n :rtype: bool\\n \"\"\"\\n low, high = 0, 0\\n for c in s:\\n if c == \"(\":\\n low += 1\\n high += 1\\n elif c", "gt": "== \")\":\\n if low > 0:\\n low -= 1\\n high -= 1\\n else:\\n if low > 0:\\n low -= 1\\n high += 1\\n if high < 0:\\n return False\\n return low == 0"}
{"id": "277", "input": "class Solution:\\n def findMinStep(self, board, hand):\\n \"\"\"\\n :type board: str\\n :type hand: str\\n :rtype: int\\n \"\"\"\\n res=float(\"inf\")\\n hmap=collections.defaultdict(int)\\n for c in hand:\\n hmap[c]+=1\\n res=self.helper(board,hmap)\\n if res == float(\"inf\"):\\n return -1\\n return res\\n \\n def helper(self,board,hmap):\\n board=self.removeConsecutive(board)\\n if len(board) ==0:\\n return 0\\n cnt=float(\"inf\")\\n j=0\\n", "gt": "for i in range(len(board)+1):\\n if i<len(board) and board[i] ==board[j]:\\n continue\\n need=3-(i-j)\\n if hmap[board[j]]>=need:\\n hmap[board[j]]-=need\\n res=self.helper(board[0:j]+board[i:],hmap)\\n if res!=float(\"inf\"):\\n cnt=min(cnt,res+need)\\n hmap[board[j]]+=need\\n j=i\\n return cnt\\n \\n def removeConsecutive(self,board):\\n j=0\\n for i in range(len(board)+1):\\n if i<len(board) and board[i] ==board[j]:\\n continue\\n if i-j>=3:\\n return self.removeConsecutive(board[0:j]+board[i:])\\n else:\\n j=i\\n return board"}
{"id": "278", "input": "class Solution:\\n def numTimesAllBlue(self, light: List[int]) -> int:\\n right = 0\\n ans = 0\\n for i in range(len(light)):\\n if", "gt": "(light[i] > right):\\n right = light[i]\\n \\n if (i + 1 == right):\\n ans += 1\\n \\n return ans"}
{"id": "279", "input": "class Solution:\\n def largestMultipleOfThree(self, digits: List[int]) -> str:\\n counts = Counter(digits)\\n m = sum(digits) % 3\\n if m:\\n if counts[m] + counts[m+3] + counts[m+6]:\\n counts[min([m+i for i in [0,3,6] if counts[m+i]])] -= 1\\n else:\\n counts[min([i-m for i in [3,6,9] if counts[i-m]])] -=", "gt": "1\\n counts[min([i-m for i in [3,6,9] if counts[i-m]])] -= 1\\n \\n ans = ''\\n for i in range(9, -1, -1):\\n if not ans and not counts[i]:\\n continue\\n ans += str(i) * counts[i]\\n if ans:\\n return ans.lstrip('0') or '0'\\n return ''\\n \\n \\n"}
{"id": "280", "input": "class Solution:\\n def getPermutation(self, n, k):\\n \"\"\"\\n :type n: int\\n :type k: int\\n :rtype: str\\n \"\"\"\\n nums = list(\"123456789\")\\n k -= 1\\n factor = 1\\n for", "gt": "i in range(1, n):\\n factor *= i\\n res = []\\n for i in reversed(list(range(n))):\\n res.append(nums[k//factor])\\n nums.remove(nums[k//factor])\\n if i:\\n k %= factor\\n factor //= i\\n return \"\".join(res)\\n"}
{"id": "281", "input": "from functools import lru_cache\\nclass Solution:\\n def palindromePartition(self, s: str, k: int) -> int:\\n n = len(s)\\n if n == k:\\n return 0\\n @lru_cache(None)\\n def cnt(left,right): # cost to make palindrome\\n if left >= right:\\n return", "gt": "0\\n return cnt(left+1,right-1) + (s[left] != s[right])\\n \\n @lru_cache(None)\\n def dp(length,partition):\\n if partition == length:\\n return 0\\n if partition == 1:\\n return cnt(0,length-1)\\n return min(dp(prelength,partition-1) + cnt(prelength,length-1) for prelength in range(partition -1, length))\\n\\n \\n return dp(n,k)\\n"}
{"id": "282", "input": "class Solution:\\n def canConvertString(self, s: str, t: str, k: int) -> bool:\\n if len(s) != len(t):\\n return False\\n \\n c = Counter((ord(c2) - ord(c1)) % 26", "gt": "for c1, c2 in zip(s, t))\\n return k >= max(\\n (m + 26 * (count - 1) for m, count in list(c.items()) if m),\\n default = 0)\\n"}
{"id": "283", "input": "class Solution:\\n def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:\\n dp = [[0 for _ in range(len(mat[0]) + 1)]for r in range(len(mat) + 1)]\\n \\n for r in range(1, len(mat) + 1):\\n for c in range(1, len(mat[r-1]) + 1):\\n dp[r][c] += mat[r-1][c-1]\\n if not r and not c:\\n continue\\n elif not r:\\n dp[r][c] += dp[r][c-1]\\n continue\\n elif not c:\\n dp[r][c] += dp[r-1][c]\\n continue\\n dp[r][c] += dp[r][c-1] + dp[r-1][c] - dp[r-1][c-1]\\n \\n", "gt": "# print(dp)\\n highest = -1\\n for r in range(1, len(dp)):\\n r0= r1 = r\\n c0= c1 = 1\\n while r1 < len(dp) and c1 < len(dp[0]):\\n \\n result = dp[r1][c1] + dp[r0-1][c0-1] - dp[r1][c0-1] - dp[r0-1][c1]\\n \\n # print(f'r0:"}
{"id": "284", "input": "class Solution:\\n def smallestDistancePair(self, nums, k):\\n \"\"\"\\n :type nums: List[int]\\n :type k: int\\n :rtype: int\\n \"\"\"\\n nums.sort()\\n l, r = 0, nums[-1] - nums[0]\\n \\n while l < r:\\n m = l + (r - l) // 2\\n count", "gt": "= 0\\n left = 0\\n for right in range(len(nums)):\\n while nums[right] - nums[left] > m: left += 1\\n count += (right - left) \\n if count < k :\\n l = m+1\\n else:\\n r = m\\n return l\\n \\n \\n"}
{"id": "285", "input": "class Solution:\\n def bagOfTokensScore(self, tokens: List[int], P: int) -> int:\\n tokens = sorted(tokens)\\n left = 0\\n right = len(tokens) - 1\\n points = 0\\n\\n if len(tokens) == 1:\\n if tokens[0] <= P:\\n return 1\\n if len(tokens) == 0:\\n return 0\\n while left < right:\\n\\n if tokens[left] <=", "gt": "P:\\n P -= tokens[left]\\n left += 1\\n points += 1\\n\\n elif tokens[left] > P and points > 0:\\n P += tokens[right]\\n points -= 1\\n right -= 1\\n \\n \\n elif points == 0 and tokens[left] > P:\\n break\\n if P >= tokens[left]:\\n points += 1\\n return points"}
{"id": "286", "input": "class Solution:\\n def smallestRangeII(self, A: List[int], K: int) -> int:\\n if not A:\\n return 0\\n nums = sorted([num + K for num in set(A)], reverse=True)\\n max_num = nums[0]\\n min_num = nums[-1]\\n changed_max = max_num - 2 *", "gt": "K\\n res = max_num - min_num\\n for i in range(len(nums) - 1):\\n changed = nums[i] - 2 * K\\n max_num = max(nums[i + 1], changed, changed_max)\\n min_num = min(min_num, changed)\\n res = min(res, max_num - min_num)\\n return res"}
{"id": "287", "input": "from math import comb\\n\\n\\nclass Solution:\\n def getProbability(self, balls: List[int]) -> float:\\n n = len(balls)\\n s = sum(balls)\\n s2 = s // 2\\n\\n @lru_cache(None)\\n def count(index, delta, ca):\\n if index == n: return 1 if delta == 0 and ca == s2 else 0\\n total =", "gt": "sum([count(index + 1, delta, ca + x) * comb(balls[index], x) for x in range(1, balls[index])])\\n total += count(index + 1, delta + 1, ca)\\n total += count(index + 1, delta - 1, ca + balls[index])\\n return total\\n\\n return count(0, 0, 0) / comb(s, s // 2)\\n"}
{"id": "288", "input": "class Solution:\\n def countArrangement(self, N):\\n \"\"\"\\n :type N: int\\n :rtype: int\\n \"\"\"\\n d = {\\n 1:1, 2:2,", "gt": "3:3, 4:8, 5:10, 6:36,\\n 7:41, 8:132, 9:250, 10:700,\\n 11:750, 12:4010, 13:4237, 14:10680, 15:24679\\n }\\n return d.get(N, N)\\n"}
{"id": "289", "input": "class Solution:\\n def flipLights(self, n, m):\\n \"\"\"\\n :type n: int\\n :type m: int\\n :rtype: int\\n \"\"\"\\n states = set()\\n for op_odd in [0, 1]:\\n for op_even in [0, 1]:\\n for op_third in [0, 1]:\\n op_all = m - op_odd - op_even -", "gt": "op_third\\n if op_all >= 0:\\n one = (op_odd + op_all + op_third) % 2\\n two = (op_even + op_all) % 2\\n three = op_odd % 2\\n four = (op_even + op_all + op_third) % 2\\n states.add((one, two, three, four)[:n])\\n \\n return len(states)\\n"}
{"id": "290", "input": "class Solution:\\n def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n N = len(A)\\n if L+M>N:\\n return -1\\n\\n\\n def findmax(L,M): \\n sL = [sum(A[:L])]\\n for i in range(L,N-M):\\n tmp = sL[-1]+A[i]-A[i-L]\\n sL.append(tmp)\\n sLmax = [sL[0]]\\n for i in range(1,len(sL)):\\n if sL[i]>sLmax[-1]:\\n sLmax.append(sL[i])\\n else:\\n sLmax.append(sLmax[-1])\\n\\n", "gt": "sM = [sum(A[-M:])]\\n for i in range(N-M-1,L-1,-1):\\n tmp = sM[-1]+A[i]-A[i+M]\\n sM.append(tmp)\\n sMmax = [sM[0]]\\n for i in range(1,len(sM)):\\n if sM[i]>sMmax[-1]:\\n sMmax.append(sM[i])\\n else:\\n sMmax.append(sMmax[-1])\\n\\n sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\\n m = max(sMax)\\n\\n return m\\n\\n if L == M:\\n return findmax(L,M)\\n else:\\n return max(findmax(L,M), findmax(M,L))"}
{"id": "291", "input": "class Solution:\\n def minCost(self, n: int, cuts: List[int]) -> int:\\n cuts.sort()\\n from functools import lru_cache\\n @lru_cache(None)\\n def helper(i = 0, j = n):\\n ans = math.inf\\n for c in cuts:\\n if", "gt": "c <= i: continue\\n if c >= j: break\\n ans = min(ans, j - i + helper(i, c) + helper(c, j))\\n if ans == math.inf:\\n return 0\\n return ans\\n return helper()"}
{"id": "292", "input": "class Solution:\\n def numOfSubarrays(self, arr: List[int]) -> int:\\n mod = 10**9+7\\n odd_presum_cnt = 0\\n par = 0\\n for", "gt": "a in arr:\\n par ^= a & 1\\n if par:\\n odd_presum_cnt += 1\\n return odd_presum_cnt * (len(arr)+1 - odd_presum_cnt)%mod"}
{"id": "293", "input": "# https://leetcode.com/problems/maximum-of-absolute-value-expression/discuss/340075/c%2B%2B-beats-100-(both-time-and-memory)-with-algorithm-and-image\\nclass Solution:\\n def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\\n N = len(arr1)\\n a = [arr1[i] + arr2[i] + i for i in range(N)]\\n b = [arr1[i] + arr2[i] - i for i in", "gt": "range(N)]\\n c = [arr1[i] - arr2[i] + i for i in range(N)]\\n d = [arr1[i] - arr2[i] - i for i in range(N)]\\n return max(\\n max(x) - min(x)\\n for x in (a, b, c, d)\\n )"}
{"id": "294", "input": "class Solution:\\n def leastInterval(self, tasks, n):\\n \"\"\"\\n :type tasks: List[str]\\n :type n: int\\n :rtype: int\\n \"\"\"\\n if n == 0: return len(tasks)\\n from collections", "gt": "import Counter\\n counter = Counter(tasks)\\n window = n + 1\\n biggest_freq = max(list(counter.values()))\\n num_of_max_freq = list(counter.values()).count(biggest_freq)\\n return max(window * (biggest_freq - 1) + num_of_max_freq, len(tasks))\\n"}
{"id": "295", "input": "class Solution:\\n def totalNQueens(self, n):\\n def dfs(lst, xy_dif, xy_sum):\\n p=len(lst)\\n if p==n: res.append(lst)\\n for q in range(n):\\n if (q not", "gt": "in lst) and (p-q not in xy_dif) and (p+q not in xy_sum):\\n dfs(lst+[q], xy_dif+[p-q], xy_sum +[p+q])\\n \\n res=[]\\n dfs([],[],[])\\n return len(res)"}
{"id": "296", "input": "class Solution:\\n def isSelfCrossing(self, x):\\n \"\"\"\\n :type x: List[int]\\n :rtype: bool\\n \"\"\"\\n if not x or len(x) < 4:\\n return False\\n i = 3\\n while i < len(x):\\n #print(i)\\n if x[i] >= x[i-2] and x[i-1] <= x[i-3]:\\n print('case 1')\\n return True\\n elif i >=", "gt": "4 and x[i-1] == x[i-3] and x[i] + x[i-4] >= x[i-2]:\\n print('case 2')\\n return True\\n elif i >= 5 and x[i-4] < x[i-2] <= x[i] + x[i-4] and x[i-1] <= x[i-3] <= x[i] + x[i-5]:\\n print('case 3')\\n return True\\n i += 1\\n return False"}
{"id": "297", "input": "class Solution:\\n def findMin(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n min = nums[0]\\n start, end = 0, len(nums) - 1\\n", "gt": "while start<end:\\n mid = (start+end)//2\\n if nums[mid]>nums[end]:\\n start = mid+1\\n elif nums[mid]<nums[end]:\\n end = mid\\n else:\\n end = end - 1\\n return nums[start]"}
{"id": "298", "input": "class Solution:\\n def numTilePossibilities(self, tiles: str) -> int:\\n res = 0\\n freqs = [f + 1 for f in Counter(tiles).values()]\\n for t", "gt": "in itertools.product(*map(range, freqs)):\\n n = sum(t)\\n subtotal = math.factorial(n)\\n for freq in t:\\n subtotal //= math.factorial(freq)\\n res += subtotal\\n return res - 1"}
{"id": "299", "input": "class Solution:\\n def multiply(self,num1, num2):\\n \"\"\"\\n :type num1: str\\n :type num2: str\\n :rtype: str\\n \"\"\"\\n a=['0','1','2','3','4','5','6','7','8','9']\\n z=0\\n x=0\\n for i,element in enumerate(num1):\\n for j", "gt": "in range(10):\\n if element==a[j]:\\n z+=j*(10**(len(num1)-i-1))\\n \\n for c,b in enumerate(num2):\\n for k in range(10):\\n if b==a[k]:\\n x+=k*(10**(len(num2)-c-1))\\n mul=z*x\\n return(''.join('%d'%mul))\\n \\n \\n \\n \\n \\n"}
{"id": "300", "input": "from collections import deque\\n\\nclass Solution:\\n def minCost(self, grid: List[List[int]]) -> int:\\n right, left, down, up = (0, 1), (0, -1), (1, 0), (-1, 0)\\n \\n direction_map = {\\n 1: right,\\n 2: left,\\n 3: down,\\n 4: up\\n }\\n \\n directions = [right, left, down, up]\\n visited = set()\\n \\n def in_bounds(i, j):\\n return 0 <= i < len(grid) and 0 <= j < len(grid[i])\\n \\n def dfs(i, j): \\n # not in bounds\\n if not in_bounds(i, j) or (i, j) in visited:\\n return", "gt": "[]\\n \\n visited.add((i, j))\\n\\n sign = grid[i][j]\\n direction = direction_map[sign]\\n next_i, next_j = i + direction[0], j + direction[1]\\n return [(i, j)] + dfs(next_i, next_j)\\n \\n \\n reachable = dfs(0, 0)\\n curr_cost = 0\\n while reachable:\\n next_reachable = []\\n for (i, j) in reachable:\\n if i == len(grid) - 1 and j == len(grid[i]) - 1:\\n return curr_cost\\n \\n for d in directions:\\n next_reachable += dfs(i + d[0], j + d[1])\\n reachable = next_reachable\\n curr_cost += 1\\n \\n return -1\\n \\n \\n"}
{"id": "301", "input": "class Solution:\\n def leastOpsExpressTarget(self, x: int, target: int) -> int:\\n def dp(i, j):\\n if i==0: return 2*j\\n # if j==0: return 0\\n if j==1: return 2\\n if (i, j) in memo:", "gt": "return memo[(i, j)]\\n base = x**i\\n q, r = divmod(j, base)\\n if r==0: return q*i\\n memo[(i, j)]=min(q*i+dp(i-1, r), (q+1)*i+dp(i-1, base-r))\\n return memo[(i, j)]\\n \\n memo ="}
{"id": "302", "input": "class Solution:\\n def maxUncrossedLines(self, A, B):\\n # Optimization\\n #commons = set(A).intersection(set(B)) # or commons = set(A) & set(B)\\n #A = [x for x in A if x in commons]\\n #B = [x for x in B if x in commons]\\n\\n N1, N2 = len(A), len(B)\\n dp = [[0 for _ in range(N2+1)] for _ in range(N1+1)]\\n for i1, v1 in enumerate(A, start = 1):\\n for i2, v2 in enumerate(B, start = 1):\\n if v1 == v2:\\n dp[i1][i2] = dp[i1-1][i2-1] + 1\\n else:\\n dp[i1][i2] = max(dp[i1-1][i2], dp[i1][i2-1])\\n return dp[N1][N2]\\n \\nclass Solution:\\n def maxUncrossedLines(self, A, B):\\n \\n commons = set(A).intersection(set(B)) # or commons = set(A) & set(B)\\n A = [x for x in", "gt": "A if x in commons]\\n B = [x for x in B if x in commons]\\n N1, N2 = len(A), len(B)\\n dp = [0 for _ in range(N2+1)]\\n for i1, v1 in enumerate(A, start = 1):\\n tmp = [0 for _ in range(N2+1)]\\n for i2, v2 in enumerate(B, start = 1):\\n if v1 == v2:\\n tmp[i2] = dp[i2-1] + 1\\n else:\\n tmp[i2] = max(dp[i2], tmp[i2-1])\\n dp = tmp\\n return dp[N2]\\n \\nfrom collections import defaultdict\\nclass Solution:\\n def maxUncrossedLines(self, A, B):\\n f = defaultdict(list)\\n for idx, val in enumerate(B):\\n f[val].insert(0, idx)\\n dp = [0] * len(B)\\n for val in A:\\n for j in f[val]:\\n dp[j] = max(dp[j], max(dp[:j], default=0) + 1)\\n return max(dp)"}
{"id": "303", "input": "class Solution:\\n def validSquare(self, p1, p2, p3, p4):\\n \"\"\"\\n :type p1: List[int]\\n :type p2: List[int]\\n :type p3: List[int]\\n :type p4: List[int]\\n :rtype: bool\\n \"\"\"\\n \\n def length(x,y):\\n return (x[0]-y[0])*(x[0]-y[0]) + (x[1]-y[1])*(x[1]-y[1])\\n \\n res = []\\n a1 = length(p1,p2)\\n a2 = length(p1,p3)\\n a3 = length(p1,p4)\\n a4", "gt": "= length(p2,p3) \\n a5 = length(p2,p4)\\n a6 = length(p3,p4) \\n res = [a1,a2,a3,a4,a5,a6] \\n res = sorted(res);\\n \\n for i in range(3):\\n if res[i] == res[i+1]:\\n continue\\n else:\\n return False\\n if res[4] != res[5]:\\n return False\\n if res[0] != 0:\\n return True\\n else: \\n return False"}
{"id": "304", "input": "class Solution:\\n def maxSumAfterPartitioning(self, arr, k):\\n res = [0]\\n \\n for idx, val in enumerate(arr):\\n max_val, cur_val = 0, 0\\n \\n for i in range(max(0,", "gt": "idx-k+1), idx+1)[::-1]:\\n \\n if arr[i] > max_val:\\n max_val = arr[i]\\n \\n if res[i] + (idx-i+1)*max_val > cur_val:\\n cur_val = res[i] + (idx-i+1)*max_val\\n \\n res.append(cur_val)\\n return res[-1]"}
{"id": "305", "input": "class Solution:\\n def numFriendRequests(self, ages: List[int]) -> int:\\n count = [0]*121\\n s = [0]*121\\n for a in ages:\\n count[a]+=1\\n for i", "gt": "in range(1,121):\\n s[i] = s[i-1]+count[i]\\n res = 0\\n for i in range(15,121):\\n edge = i//2+7\\n num = s[i]-s[edge]\\n res+=count[i]*num-count[i]\\n return res"}
{"id": "306", "input": "# class Solution:\\n# def distinctEchoSubstrings(self, text: str) -> int:\\n# ans = set()\\n \\n# for i in range(len(text)-1): \\n# for j in range(i+1, (i+len(text))//2+1): \\n# if text[i:j] == text[j:2*j-i]: ans.add(text[i:j])\\n \\n# return len(ans)\\nfrom collections import defaultdict, deque\\nclass Solution:\\n def distinctEchoSubstrings(self, text: str) -> int:\\n if all(x==text[0] for x in text):\\n", "gt": "# handle worst case seperately\\n return len(text)//2\\n \\n res = set()\\n character_locations = defaultdict(lambda:deque())\\n for i, c in enumerate(text):\\n for j in character_locations[c]:\\n if i + (i - j) > len(text): break\\n \\n # Use startswith to improve result slightly \\n if text.startswith(text[i:i+i-j], j):\\n res.add(text[j:i+i-j])\\n \\n character_locations[c].appendleft(i)\\n \\n return len(res)"}
{"id": "307", "input": "class Solution:\\n def combinationSum4(self, nums, target):\\n \"\"\"\\n :type nums: List[int]\\n :type target: int\\n :rtype: int\\n \"\"\"\\n cache = {}\\n def f(val):\\n if val == target:\\n return 1\\n \\n total = 0\\n remain = target", "gt": "- val\\n for num in nums:\\n if num <= remain:\\n k = val+num\\n if k in cache:\\n total += cache[k]\\n else:\\n cache[k] = f(val + num)\\n total += cache[k]\\n return total\\n \\n return f(0)"}
{"id": "308", "input": "class Solution:\\n \\n def soupServings(self, N: int) -> float:\\n if N > 5000: return 1 # shortcut for large N (accurate to 1e-6)\\n\\n @lru_cache(None)\\n def dp(a, b):\\n if a <= 0 and b", "gt": "<= 0: return 0.5\\n if a <= 0: return 1\\n if b <= 0: return 0\\n return (dp(a-100, b) + dp(a-75, b-25) + dp(a-50, b-50) + dp(a-25, b-75)) / 4\\n\\n return dp(N, N)"}
{"id": "309", "input": "class Solution:\\n def isValid(self, code):\\n \"\"\"\\n :type code: str\\n :rtype: bool\\n \"\"\"\\n def parseTag(src, i):\\n j = i\\n tag, i = findtag(src, i)\\n if not tag:\\n return False, j\\n \\n res, i = parseContent(src, i)\\n \\n e = i + len(tag) + 3\\n return (True, e) if src[i: e] == '</' + tag + '>' else (False, j)\\n \\n def parseContent(src, i):\\n j, res = i, False\\n while i < len(src):\\n res, i = parseText(src, i)\\n if res:\\n continue\\n \\n res, i = parseCDData(src, i)\\n if res:\\n continue\\n \\n res, i = parseTag(src, i)\\n if res:\\n continue\\n \\n break\\n \\n return True, i\\n \\n def parseCDData(src, i):\\n \\n s = src.find('<![CDATA[', i)\\n if s != i:\\n return False, i\\n", "gt": "\\n e = src.find(']]>', i)\\n \\n return (True, e+3) if e != -1 else (False, i)\\n \\n def parseText(src, i):\\n j = i\\n while i < len(src) and src[i] != '<':\\n i += 1\\n \\n return j != i, i\\n \\n def findtag(src, i):\\n if src[i] != '<':\\n return \"\", i\\n \\n e = src.find('>', i+1)\\n \\n if e == -1 or e - i - 1 > 9 or e - i - 1 < 1:\\n return \"\", e\\n \\n s = 1\\n while s < e - i and src[i+s].isupper():\\n s += 1\\n \\n return (src[i+1: e], e+1) if s >= e - i else (\"\", e)\\n \\n # start to check\\n return parseTag(code, 0) == (True, len(code))"}
{"id": "310", "input": "from collections import Counter\\nclass Solution:\\n def longestArithSeqLength(self, A: List[int]) -> int:\\n c = dict(Counter(A).most_common())\\n # print(c)\\n m1 = max(c.values())\\n # A = list(set(A))\\n # A.sort()\\n index = {}\\n # for i in range(len(A)):\\n # index[A[i]]=i\\n dp = [[2] * len(A) for i in A]\\n m = 2\\n for i in range(len(A)):\\n # print(\\\"I=\\\", i)\\n # index[A[i+1]]=(i+1)\\n for", "gt": "j in range(i+1, len(A)):\\n # index[A[j]]=(j)\\n a = A[i]\\n \\n c = A[j]\\n b = 2 * a - c\\n # print(b,a,c)\\n if b in index :\\n # print(\\\"B"}
{"id": "311", "input": "class Solution:\\n def monotoneIncreasingDigits(self, N):\\n \"\"\"\\n :type N: int\\n :rtype: int\\n \"\"\"\\n \\n arr = [int(ch) for ch in str(N)] # create array from number 1234 => [1,2,3,4]\\n marker = len(arr)\\n \\n i = len(arr)-2\\n while i >= 0:\\n if arr[i] > arr[i+1]:\\n marker = i+1\\n arr[i] -= 1 \\n i-=1\\n \\n while marker < len(arr):\\n arr[marker] = 9\\n marker += 1\\n \\n return int(''.join([str(num) for num in arr]))\\n \\n \\n # # any number 0..9 has always monotone increasing digits\\n # if N < 10:\\n # return N\\n \\n #", "gt": "stack = []\\n \\n # # create stack of digits 1234 -> [4,3,2,1]\\n # while N:\\n # stack.append(N%10)\\n # N = N // 10 \\n \\n # X = 0\\n # power_of_10 = len(stack)-1\\n # right = stack.pop()\\n # while stack:\\n # left = right\\n # right = stack.pop()\\n # if left <= right:\\n # X += left * (10**power_of_10)\\n # power_of_10 -= 1\\n # else:\\n # X += (left-1) * (10**power_of_10)\\n # X += int('9'*power_of_10)\\n # return self.monotoneIncreasingDigits(X)\\n \\n # # remaining part\\n # X += right\\n \\n # return X\\n"}
{"id": "312", "input": "class Solution:\\n def candy(self, ratings):\\n \"\"\"\\n :type ratings: List[int]\\n :rtype: int\\n \"\"\"\\n \\n if not ratings:\\n return 0\\n \\n total, pre, decrease = 1, 1, 0\\n for i in range(1, len(ratings)):\\n if ratings[i] >= ratings[i-1]:\\n if decrease > 0:\\n total += (1+decrease)*decrease // 2\\n if pre <= decrease:\\n total += decrease+1-pre\\n decrease,", "gt": "pre = 0, 1\\n if ratings[i] == ratings[i-1]:\\n total += 1\\n pre = 1\\n else:\\n pre += 1\\n total += pre\\n else:\\n decrease += 1\\n \\n if decrease > 0:\\n total += (1 + decrease) * decrease // 2\\n if pre <= decrease:\\n total += decrease + 1 - pre\\n return total\\n"}
{"id": "313", "input": "import collections\\n\\nclass Solution:\\n def shortestSubarray(self, A: List[int], K: int) -> int:\\n cum_sum = 0\\n queue = collections.deque([(-1, 0)])\\n result = len(A) + 1\\n for i, v in enumerate(A):\\n cum_sum += v \\n if v > 0:\\n # find any matches and remove them, since will never have a better match\\n while queue and cum_sum - queue[0][1] >= K:\\n", "gt": "e = queue.popleft()\\n #print('remove candidate from start:', e)\\n result = min(result, i - e[0])\\n else:\\n # for negative numbers pop off any greater cum sums, which will never be a better target\\n while queue and cum_sum <= queue[-1][1]:\\n e = queue.pop()\\n #print('remove lesser from end:', e)\\n \\n queue.append((i, cum_sum))\\n #print(queue) \\n return result if result <= len(A) else -1"}
{"id": "314", "input": "class Solution:\\n def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n \\n flowersN = len(bloomDay)\\n if flowersN < m*k:\\n return -1\\n \\n def checkFlowers(x):\\n count = 0\\n gotFlowers = 0\\n for num in bloomDay:\\n if num <= x:\\n count += 1\\n if count == k:\\n gotFlowers += 1\\n count", "gt": "= 0\\n else:\\n count = 0\\n # print(gotFlowers, x, m)\\n return gotFlowers >= m\\n \\n sortedDays = sorted(list(set(bloomDay)))\\n l = 0\\n r = len(sortedDays) - 1\\n if checkFlowers(sortedDays[l]):\\n return sortedDays[l]\\n while l < r:\\n mm = (l + r)//2\\n if checkFlowers(sortedDays[mm]):\\n r = mm\\n else:\\n l = mm+ 1\\n return sortedDays[l]"}
{"id": "315", "input": "class Solution:\\n def numSub(self, s: str) -> int:\\n # 10/6/20\\n dic = collections.defaultdict(int)\\n \\n n = len(s)\\n left, right = 0, 0\\n while left < n:\\n if s[left] == '1':\\n right = left\\n while right < n and s[right] == '1':\\n", "gt": "right += 1\\n dic[right-left] += 1\\n left = right\\n else:\\n left += 1\\n \\n total = 0\\n for ones in dic:\\n total = (total + (ones *(ones+1)) // 2 * dic[ones]) % (10**9 + 7)\\n return total\\n \\n \\n \\n \\n"}
{"id": "316", "input": "class Solution:\\n def minimumSwap(self, s1: str, s2: str) -> int:\\n xy_pair = 0\\n yx_pair = 0\\n \\n for c1, c2 in zip(s1, s2):\\n if c1 == 'x' and c2 == 'y':\\n xy_pair", "gt": "+= 1\\n elif c1 == 'y' and c2 == 'x':\\n yx_pair += 1\\n \\n if (xy_pair + yx_pair)%2 == 1:\\n return -1\\n \\n \\n return xy_pair//2 + yx_pair//2 + xy_pair%2 + yx_pair%2\\n \\n'''\\n\\\"xx\\\"\\n\\\"yy\\\"\\n\\\"xy\\\"\\n\\\"yx\\\"\\n\\\"xx\\\"\\n\\\"xy\\\"\\n\\\"xyxy\\\"\\n\\\"yxyx\\\"\\n\\\"xxyyxxyxyxyx\\\"\\n\\\"xyxyxyxxyyxx\\\"\\n\\\"xxyyxyxyxx\\\"\\n\\\"xyyxyxxxyx\\\"\\n\\\"xyxyxyyxx\\\"\\n\\\"yxyyyxxxx\\\"\\n\\\"xyxyxyyxxxyyxyxxxyx\\\"\\n\\\"yxyyyxxxxxxyyxyxyxx\\\"\\n'''"}
{"id": "317", "input": "class Solution:\\n def longestPrefix(self, strn: str) -> str:\\n max_prefs = [0]*len(strn)\\n\\n curr = 0\\n for idx in range(1, len(strn)):\\n while True:\\n if curr == 0:\\n if strn[idx]", "gt": "== strn[0]:\\n curr = 1\\n max_prefs[idx] = curr\\n break\\n else:\\n if strn[idx] == strn[curr]:\\n curr += 1\\n max_prefs[idx] = curr\\n break\\n else:\\n curr = max_prefs[curr-1]\\n\\n return strn[:max_prefs[-1]]"}
{"id": "318", "input": "class Solution:\\n def numPermsDISequence(self, S):\\n dp = [1] * (len(S) + 1)\\n for a, b in zip('I'", "gt": "+ S, S):\\n dp = list(itertools.accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n return dp[0] % (10**9 + 7)\\n"}
{"id": "319", "input": "class Solution:\\n def maxSizeSlices(self, slices: List[int]) -> int:\\n a,b,n=[slices[0]],[0],len(slices)\\n for i in range(1,n):\\n a.append(max(a[-1],slices[i]))\\n b.append(max(b[-1],slices[i]))\\n for", "gt": "i in range(2,2*n//3,2):\\n aa,bb=[0]*(n-1),[0]*n\\n for j in range(i,n-1): aa[j]=max(aa[j-1],a[j-2]+slices[j])\\n for j in range(i+1,n): bb[j]=max(bb[j-1],b[j-2]+slices[j])\\n a,b=aa,bb\\n return max(a[-1],b[-1])"}
{"id": "320", "input": "class Solution:\\n def stoneGameIII(self, stoneValue: List[int]) -> str:\\n A = stoneValue\\n dp = [0] * 3\\n for i in range(len(A) - 1, -1, -1):\\n dp[i % 3] = max(sum(A[i:i", "gt": "+ k]) - dp[(i + k) % 3] for k in (1, 2, 3))\\n \\n if dp[0] > 0:\\n return 'Alice'\\n elif dp[0] < 0:\\n return 'Bob'\\n else:\\n return 'Tie'\\n"}
{"id": "321", "input": "class Solution:\\n def minOperations(self, nums: List[int]) ->", "gt": "int:\\n return sum(bin(x).count('1') for x in nums)+len(bin(max(nums)))-3\\n"}
{"id": "322", "input": "from collections import Counter\\nclass Solution:\\n def checkIfCanBreak(self, s1: str, s2: str) -> bool:\\n d1, d2 = Counter(s1), Counter(s2)\\n return self.check(d1, d2) or self.check(d2, d1)\\n \\n def", "gt": "check(self, d1: dict, d2: dict) -> bool:\\n s = 0\\n for c in 'abcdefghijklmnopqrstuvwxyz':\\n s += d1[c] - d2[c]\\n if s < 0:\\n return False\\n return True"}
{"id": "323", "input": "class Solution:\\n def minPatches(self, nums, n):\\n \"\"\"\\n :type nums: List[int]\\n :type n: int\\n :rtype: int\\n \"\"\"\\n res, cur, i = 0, 1, 0\\n while cur", "gt": "<= n:\\n if i < len(nums) and nums[i] <= cur:\\n cur += nums[i]\\n i += 1\\n else:\\n cur *= 2\\n res += 1\\n return res"}
{"id": "324", "input": "class Solution:\\n def isInterleave(self, s1, s2, s3):\\n \"\"\"\\n :type s1: str\\n :type s2: str\\n :type s3: str\\n :rtype: bool\\n \"\"\"\\n if len(s3) != len(s1) + len(s2):\\n return False\\n if not s1 or not s2:\\n return (s1 or s2) == s3\\n options = {(0, 0)}\\n for", "gt": "char in s3:\\n new_options = set()\\n for i1, i2 in options:\\n if i1 < len(s1) and char == s1[i1]:\\n new_options.add((i1 + 1, i2))\\n if i2 < len(s2) and char == s2[i2]:\\n new_options.add((i1, i2 + 1))\\n options = new_options\\n if not options:\\n return False\\n return True"}
{"id": "325", "input": "class Solution:\\n def nextGreaterElement(self, n):\\n \"\"\"\\n :type n: int\\n :rtype: int\\n \"\"\"\\n s=[i for i in str(n)]\\n exist=-1\\n for i in range(len(s)-1,0,-1):\\n if s[i-1]<s[i]:\\n temp=sorted(s[i-1:])\\n pivot=temp.index(s[i-1])\\n", "gt": "for j in range(pivot+1,len(temp)):\\n if temp[j]>s[i-1]:\\n pivot=j\\n break\\n \\n s[i-1]=temp[pivot]\\n del temp[pivot]\\n s[i:]=temp\\n exist=1\\n break\\n ret=int(''.join(s))\\n if exist==1 and ret<2147483647 :\\n return ret\\n else:\\n return -1"}
{"id": "326", "input": "class Solution:\\n def maxDistance(self, grid: List[List[int]]) -> int:\\n \\n from collections import deque\\n \\n queue = deque()\\n for i, row in enumerate(grid):\\n for j, cell in enumerate(row):\\n if cell == 1:\\n queue.append((i, j, None, None))\\n \\n dist = {}\\n while queue:\\n \\n i, j, previ, prevj = queue.popleft()\\n if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):\\n continue\\n if (i, j) not in dist:\\n", "gt": "dist[(i, j)] = 1 + dist.get((previ, prevj), -1)\\n # if previ is None and prevj is None:\\n # dist[(i, j)] = 0\\n # else:\\n # dist[(i, j)] = 1 + dist[(previ, prevj)]\\n for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n newi, newj = i +di, j + dj\\n queue.append((newi, newj, i, j))\\n \\n ans = max(list(dist.values()), default=-1)\\n return ans if ans != 0 else -1\\n \\n \\n \\n"}
{"id": "327", "input": "class Solution(object):\\n def convert(self, s, numRows):\\n \"\"\"\\n :type s: str\\n :type numRows: int\\n :rtype: str\\n \"\"\"\\n if numRows == 1:\\n return s\\n zigzag = ['' for i in range(numRows)] \\n row = 0", "gt": "\\n step = 1 \\n for c in s:\\n if row == 0:\\n step = 1\\n if row == numRows - 1:\\n step = -1\\n zigzag[row] += c\\n row += step\\n return ''.join(zigzag)"}
{"id": "328", "input": "class Solution:\\n def lengthOfLongestSubstring(self, s):\\n \"\"\"\\n :type s: str\\n :rtype: int\\n \"\"\"\\n L, res, last = -1, 0, {}\\n for R, char in", "gt": "enumerate(s):\\n if char in last and last[char] > L:\\n L = last[char]\\n elif R-L > res:\\n res = R-L\\n last[char] = R\\n return res"}
{"id": "329", "input": "class Solution:\\n def find132pattern(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: bool\\n \\n if len(nums) < 3:\\n return False\\n \\n stack = [[nums[0], nums[0]]]\\n minimum = nums[0]\\n for num in nums[1:]:\\n if num <= minimum:\\n minimum = num\\n else:\\n while stack and num > stack[-1][0]:\\n if num < stack[-1][1]:\\n return True\\n else:\\n", "gt": "stack.pop()\\n stack.append([minimum, num])\\n \\n return False\\n \"\"\"\\n \\n if len(nums) < 3:\\n return False\\n stack = [[nums[0], nums[0]]]\\n m = nums[0]\\n for num in nums[1:]:\\n if num <= m:\\n m = num\\n else:\\n while stack and num > stack[-1][0]:\\n if num < stack[-1][1]:\\n return True\\n else:\\n stack.pop()\\n stack.append([m, num])\\n return False\\n \\n"}
{"id": "330", "input": "class Solution:\\n def maxProductPath(self, grid: List[List[int]]) -> int:\\n rows = len(grid)\\n if (rows == 0):\\n return -1\\n \\n cols = len(grid[0])\\n if (cols == 0):\\n return -1\\n \\n dp = [(1,1)] * cols\\n for r, col in enumerate(grid):\\n for c, item in enumerate(col):\\n if (r == 0 and c == 0):\\n dp[c] = (item, item)\\n elif (r == 0):\\n dp[c] = (dp[c-1][0] *", "gt": "item, dp[c-1][1]* item)\\n elif (c == 0):\\n dp[c] = (dp[c][0] * item, dp[c][1]* item)\\n else:\\n candidate_1 = dp[c-1][0] * item\\n candidate_2 = dp[c-1][1]* item\\n candidate_3 = dp[c][0] * item\\n candidate_4 = dp[c][1]* item\\n \\n m = min(candidate_1, candidate_2, candidate_3, candidate_4)\\n M = max(candidate_1, candidate_2, candidate_3, candidate_4)\\n \\n dp[c] = (m, M)\\n \\n if (dp[cols-1][1] >= 0):\\n return dp[cols-1][1] % (10**9+7)\\n else:\\n return -1"}
{"id": "331", "input": "class Solution:\\n def isNumber(self, s):\\n \"\"\"\\n :type s: str\\n :rtype: bool\\n \"\"\"\\n dot = False\\n exp = False\\n \\n try:\\n while s.startswith(' '):\\n s = s[1:]\\n while s.endswith(' '):\\n s = s[:-1]\\n if s.startswith('-') or s.startswith('+'):\\n s = s[1:]\\n except IndexError:\\n return False\\n \\n if s == '':\\n return False\\n \\n if s.startswith('e'):\\n return False\\n if (s[-1] > '9' or s[-1] < '0') and s[-1] != '.':\\n return False\\n \\n if s.startswith('.'):\\n if len(s) == 1:\\n return False\\n elif s[1] < '0'", "gt": "or s[1] > '9':\\n return False\\n \\n i = 0\\n while i < len(s):\\n if s[i] < '0' or s[i] > '9':\\n if s[i] == '.':\\n if not dot and not exp:\\n dot = True\\n else:\\n return False # two dot in string or dot after e.\\n elif s[i] == 'e':\\n if not exp:\\n exp = True\\n if s[i+1] == '-' or s[i+1] == '+':\\n i = i + 1\\n else:\\n return False\\n else:\\n return False\\n i = i + 1\\n return True\\n"}
{"id": "332", "input": "class Solution:\\n def angleClock(self, hour: int, minutes: int) -> float:\\n hour_angle = hour*30+(minutes/12)*6\\n if hour_angle > 360:\\n hour_angle -= 360\\n min_angle", "gt": "= (minutes/5)*30\\n if min_angle > 360:\\n min_angle -= 360\\n \\n diff = abs(hour_angle-min_angle)\\n return diff if diff <= 360-diff else 360-diff"}
{"id": "333", "input": "class Solution:\\n def countSubstrings(self, s):\\n \"\"\"\\n :type s: str\\n :rtype: int\\n \"\"\"\\n ret = 0\\n left, right = 0, 0\\n while left < len(s):\\n while right < len(s) and s[right] == s[left]:\\n right += 1\\n ret += self.sum(right - left)\\n l, r = left-1, right\\n", "gt": "while l >= 0 and r < len(s) and s[r] == s[l]:\\n ret += 1\\n l -= 1\\n r += 1\\n left = right\\n return ret\\n \\n def sum(self, n):\\n s = 0\\n for i in range(1, n + 1):\\n s += i\\n return s"}
{"id": "334", "input": "from collections import deque\\n\\nclass Solution:\\n def minJumps(self, arr: list) -> int:\\n if len(arr) == 1:\\n return 0\\n graph = {}\\n for i, n in enumerate(arr):\\n if n in graph:\\n graph[n].append(i)\\n else:\\n graph[n] = [i]\\n \\n curs = [0]\\n other = [len(arr)-1]\\n visited = {0}\\n visited2 = {len(arr)-1}\\n step = 0\\n while curs:\\n if len(curs) > len(other):\\n curs, other = other, curs\\n visited, visited2 = visited2,", "gt": "visited\\n nex = []\\n for node in curs:\\n for child in graph[arr[node]]:\\n if child in visited2:\\n return step + 1\\n if child not in visited:\\n visited.add(child)\\n nex.append(child)\\n\\n for child in [node-1, node+1]:\\n if child in visited2:\\n return step + 1\\n if 0 <= child < len(arr) and child not in visited:\\n visited.add(child)\\n nex.append(child)\\n curs = nex\\n step += 1\\n return -1\\n \\n \\n \\n \\n"}
{"id": "335", "input": "class Solution:\\n def minCost(self, s: str, cost: List[int]) -> int:\\n delete_cost = 0\\n last = 0\\n for i in range(1, len(s)):\\n if", "gt": "s[last] == s[i]:\\n if cost[last] < cost[i]:\\n delete_cost += cost[last]\\n last = i\\n else:\\n delete_cost += cost[i]\\n else:\\n last = i\\n return delete_cost"}
{"id": "336", "input": "from functools import lru_cache\\nclass Solution:\\n def tallestBillboard(self, rods: List[int]) -> int:\\n rods = sorted(rods)[::-1]\\n n = len(rods)\\n psum = rods.copy()\\n for i in range(n-1)[::-1]:\\n psum[i] +=", "gt": "psum[i+1]\\n\\n @lru_cache(None)\\n def dfs(idx, diff):\\n if idx == n:\\n return 0 if diff == 0 else -float('inf')\\n if diff > psum[idx]:\\n return -float('inf')\\n return max(dfs(idx+1,diff),dfs(idx+1,diff+rods[idx]),dfs(idx+1,abs(diff-rods[idx]))+min(diff,rods[idx]))\\n return dfs(0,0)"}
{"id": "337", "input": "class Solution:\\n def minSteps(self, s: str, t: str) -> int:\\n\\n \\n s_count=[s.count(chr(i)) for i in range(97,123)]\\n t_count=[t.count(chr(i)) for i in range(97,123)]\\n diff=[t_count[i]-s_count[i] for i in range(26) if t_count[i]-s_count[i]>0]\\n sum=0\\n for i in range(len(diff)):\\n sum=sum+diff[i]\\n \\n return sum\\n# # create a hash map for string S\\n#", "gt": "count = defaultdict(int)\\n \\n# for char in s:\\n# count[char] += 1\\n \\n# # check the difference of two strings\\n \\n \\n# diff = 0\\n# for char in t:\\n# if count[char] > 0 :\\n# #print(char)\\n# count[char] -= 1\\n# else:\\n# diff += 1\\n \\n \\n# return int(diff)\\n"}
{"id": "338", "input": "class Solution:\\n def canCompleteCircuit(self, gas, cost):\\n \"\"\"\\n :type gas: List[int]\\n :type cost: List[int]\\n :rtype: int\\n \"\"\"\\n if sum(gas) < sum(cost):\\n return -1\\n Rest = 0\\n", "gt": "index = 0\\n for i in range(len(gas)):\\n Rest += gas[i] - cost[i]\\n if Rest < 0:\\n index = i + 1\\n Rest = 0\\n return index"}
{"id": "339", "input": "from functools import lru_cache\\n\\ndef failure(pat):\\n i, target, n = 1, 0, len(pat)\\n res = [0]\\n while i < n:\\n if pat[i] == pat[target]:\\n target += 1\\n res.append(target)\\n i+=1\\n elif target:\\n target = res[target-1]\\n else:\\n res.append(0)\\n i += 1\\n return res\\n \\n \\nclass Solution:\\n def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\\n f = failure(evil)\\n @lru_cache(None)\\n def dfs(idx, max_matched=0, lb=True, rb=True):\\n \\n if max_matched == len(evil): return 0\\n if idx == n:", "gt": "return 1\\n \\n l = s1[idx] if lb else 'a'\\n r = s2[idx] if rb else 'z'\\n \\n candidates = [chr(i) for i in range(ord(l), ord(r) + 1)]\\n \\n res = 0\\n for i, c in enumerate(candidates):\\n next_matched = max_matched\\n while next_matched and evil[next_matched]!= c:\\n next_matched = f[next_matched-1]\\n res += dfs(idx+1, next_matched + (evil[next_matched] == c), \\n (lb and i==0), (rb and i == (len(candidates) - 1)))\\n return res\\n \\n return dfs(0) % (10**9 + 7)"}
{"id": "340", "input": "class Solution:\\n def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n \\n def triplets(nums1, nums2):\\n sq = collections.Counter(x * x for x in nums1)\\n num = collections.Counter(nums2)\\n \\n res = 0\\n keys = sorted(num.keys())\\n for j, x in enumerate(keys):\\n if num[x] > 1 and x", "gt": "* x in sq:\\n res += num[x] * (num[x] - 1) // 2 * sq[x * x]\\n for y in keys[j+1:]:\\n if x * y in sq:\\n res += num[x] * num[y] * sq[x * y]\\n return res\\n \\n return triplets(nums1, nums2) + triplets(nums2, nums1)"}
{"id": "341", "input": "class Solution:\\n def simplifyPath(self, path):\\n \"\"\"\\n :type path: str\\n :rtype: str\\n \"\"\"\\n stack=[]\\n path=[p for p in path.split('/') if p]\\n", "gt": "for f in path:\\n if f == '.': continue\\n elif f == '..': \\n if stack: stack.pop()\\n else: stack.append(f)\\n return '/'+'/'.join(stack)"}
{"id": "342", "input": "class Solution:\\n res=[1]\\n idx=[0,0,0]\\n def nthUglyNumber(self, n):\\n \"\"\"\\n :type n: int\\n :rtype: int\\n \"\"\"\\n if n<=0:\\n return None\\n idx2,idx3,idx5=Solution.idx\\n while", "gt": "len(Solution.res)<n:\\n Solution.res.append(min(Solution.res[idx2]*2,Solution.res[idx3]*3,Solution.res[idx5]*5))\\n while idx2<len(Solution.res) and Solution.res[idx2]*2<=Solution.res[-1]:\\n idx2+=1\\n while idx3<len(Solution.res) and Solution.res[idx3]*3<=Solution.res[-1]:\\n idx3+=1\\n while idx5<len(Solution.res) and Solution.res[idx5]*5<=Solution.res[-1]:\\n idx5+=1\\n Solution.idx=[idx2,idx3,idx5]\\n return Solution.res[n-1]\\n"}
{"id": "343", "input": "class Solution:\\n def countBattleships(self, board):\\n \"\"\"\\n :type board: List[List[str]]\\n :rtype: int\\n \"\"\"\\n count = 0\\n for i in range(len(board)):\\n for j in range(len(board[i])):\\n if board[i][j] == 'X':\\n if i-1 < 0 and j-1 < 0:\\n count", "gt": "+= 1\\n elif i-1 < 0 and board[i][j-1] != 'X':\\n count += 1\\n elif j-1 < 0 and board[i-1][j] != 'X':\\n count += 1\\n elif board[i-1][j] != 'X' and board[i][j-1] != 'X':\\n count += 1\\n return count\\n"}
{"id": "344", "input": "class Solution:\\n def numSquares(self, n):\\n \"\"\"\\n :type n: int\\n :rtype: int\\n \"\"\"\\n while(n%4 == 0):\\n n = n/4\\n if n%8 == 7: return 4;\\n a", "gt": "= int(0)\\n while(a*a <= n):\\n b = int(math.sqrt(n-a*a))\\n if (a*a+b*b == n):\\n print('a=',a,'b+',b)\\n return (not not a) + (not not b)\\n a += 1\\n return 3"}
{"id": "345", "input": "class Solution:\\n def minDeletionSize(self, A: List[str]) -> int:\\n dp = [(1, 1)] * len(A[0])\\n for i in range(len(dp)):\\n if i > 0:\\n max_pre = None\\n for pre in range(i - 1, -1, -1):\\n for word in A:\\n if word[pre] > word[i]:\\n pre", "gt": "-= 1\\n break\\n else:\\n if max_pre is None or dp[pre][1] > dp[max_pre][1]:\\n max_pre = pre\\n\\n max_len = 1 if max_pre is None else max(1, dp[max_pre][1] + 1)\\n overall = max(dp[i - 1][0], max_len)\\n dp[i] = (overall, max_len)\\n # print(dp)\\n return len(dp) - dp[-1][0]"}
{"id": "346", "input": "class Solution:\\n def splitArray(self, nums, m):\\n \"\"\"\\n :type nums: List[int]\\n :type m: int\\n :rtype: int\\n \"\"\"\\n accum = [0]\\n N = len(nums)\\n mmm = max(nums)\\n if m >= N:\\n return mmm\\n res = 0\\n for i in nums:\\n res += i\\n accum.append(res)\\n lower, upper = mmm , sum(nums)\\n while lower < upper:\\n mid = (lower + upper) // 2\\n if not self.isSplitable(accum, m, mid):\\n lower = mid + 1\\n else:\\n upper = mid\\n # print(lower, upper)\\n return upper\\n def isSplitable(self, accum, m, maxx):\\n start = 0\\n N =", "gt": "len(accum)\\n end = 0\\n count = 0\\n while end < N and count < m:\\n if accum[end] - accum[start] > maxx:\\n # print('start: ', start, 'end:', end, 'sum', accum[end - 1] - accum[start])\\n start = end - 1\\n count += 1\\n end += 1\\n #print (count, end)\\n if accum[-1] - accum[start] > maxx: #收尾\\n count += 2\\n else:\\n count += 1\\n # print('start: ', start, 'end:', end, 'sum', accum[end - 1] - accum[start])\\n # print (end, count)\\n if end != N or count > m:\\n return False\\n return True"}
{"id": "347", "input": "class Solution:\\n def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n # save all even subarray's length which between odds\\n edge = []\\n res = 0\\n count = 0\\n for i in nums:\\n # odd\\n if i % 2:\\n # +1 because range", "gt": "from 0 to count when doing combination\\n edge.append(count+1)\\n count = 0\\n # even\\n else:\\n count += 1\\n edge.append(count+1)\\n # no enough odd\\n if len(edge)-1 < k:\\n return 0\\n else:\\n # combination\\n for i in range(len(edge)-k):\\n res += edge[i] * edge[i+k]\\n return res"}
{"id": "348", "input": "class Solution:\\n def checkInclusion(self, s1, s2):\\n \"\"\"\\n :type s1: str\\n :type s2: str\\n :rtype: bool\\n \"\"\"\\n if len(s2) < len(s1):\\n return False\\n c1 = [0] * 128\\n n = 0\\n for i in s1:\\n c = ord(i)\\n if c1[c] == 0: n += 1\\n c1[c] += 1\\n for i in range(len(s1)):\\n c =", "gt": "ord(s2[i])\\n c1[c] -= 1\\n if not c1[c]: n -= 1\\n if not n: return True\\n for i in range(len(s2) - len(s1)):\\n c = ord(s2[i])\\n if not c1[c]: n += 1\\n c1[c] += 1\\n c = ord(s2[i + len(s1)])\\n c1[c] -= 1\\n if not c1[c]:\\n n -= 1\\n if not n: return True\\n return False"}
{"id": "349", "input": "import sys\\nclass Solution:\\n def maximumSum(self, arr: List[int]) -> int:\\n ignore=0\\n not_ignore=0\\n res=-sys.maxsize\\n for i in arr:\\n if i>=0:\\n", "gt": "ignore+=i\\n not_ignore+=i\\n else:\\n if ignore==0:\\n ignore+=i\\n else:\\n ignore=max(ignore+i,not_ignore)\\n not_ignore+=i\\n res=max(res,ignore)\\n if ignore<0:\\n ignore=0\\n if not_ignore<0:\\n not_ignore=0\\n return res\\n"}
{"id": "350", "input": "class Solution:\\n def deleteAndEarn(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n count = collections.Counter(nums);#count is a dict [3,4,2]--> {2:1,3:1,4:1}\\n prev = None;\\n avoid = using = 0;\\n for k in sorted(count):\\n temp =", "gt": "max(avoid,using)\\n if k - 1 != prev:\\n using = k * count[k] + temp\\n avoid = temp\\n else:\\n using = k * count[k] + avoid\\n avoid = temp\\n \\n prev = k\\n return max(avoid,using)"}
{"id": "351", "input": "from collections import defaultdict\\nclass Solution:\\n def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n \\n start_k = 0\\n start = 0\\n elem_dict = defaultdict(int)\\n \\n ans = 0\\n \\n for elem in A:\\n elem_dict[elem] += 1\\n \\n if", "gt": "len(elem_dict) > K:\\n del elem_dict[A[start_k]]\\n start_k+=1\\n start = start_k\\n \\n \\n if len(elem_dict) == K:\\n while elem_dict[A[start_k]] > 1:\\n elem_dict[A[start_k]]-=1\\n start_k+=1\\n \\n ans = ans + start_k - start + 1\\n \\n return ans\\n \\n \\n \\n"}
{"id": "352", "input": "class Solution:\\n def brokenCalc(self, X: int, Y: int) -> int:\\n res = 0\\n while X < Y:\\n res", "gt": "+= Y % 2 + 1\\n Y = int((Y + 1) / 2)\\n return res + X - Y\\n"}
{"id": "353", "input": "class Solution:\\n def longestStrChain(self, words: List[str]) -> int:\\n by_length = collections.defaultdict(set)\\n for word in words:\\n by_length[len(word)].add(word)\\n\\n longest = 1\\n seen = {*()}\\n mx = len(by_length)\\n mn = min(by_length)\\n\\n for length in sorted(by_length, reverse=True):\\n if length - mn < longest:\\n break\\n for word in by_length[length]:\\n if length - mn < longest:\\n break\\n if", "gt": "word in seen:\\n continue\\n stk = [(word, length, 1)]\\n while stk:\\n word, k, n = stk.pop()\\n seen.add(word)\\n if n > longest:\\n longest = n\\n for i in range(k):\\n pre = word[:i] + word[i+1:]\\n if pre not in seen and pre in by_length[k-1]:\\n stk.append((pre, k-1, n+1))\\n if longest == mx:\\n return longest\\n\\n return longest"}
{"id": "354", "input": "class Solution:\\n MODS = 10 ** 9 + 7\\n def numSubseq(self, nums: List[int], target: int) -> int:\\n N = len(nums)\\n cal_map = [1]\\n for ii in range(1, N):\\n cal_map.append(cal_map[-1] * 2 % self.MODS)\\n left, right, res = 0, N - 1, 0\\n nums.sort()\\n while", "gt": "left < N:\\n if nums[left] * 2 > target:\\n break\\n while right - 1 >= left and nums[left] > target - nums[right]:\\n right -= 1\\n res += cal_map[right - left]\\n # print(left, right, cal_map[right - left], nums[left])\\n left += 1\\n return res % self.MODS\\n \\n"}
{"id": "355", "input": "class Solution:\\n def dieSimulator(self, n: int, rollMax: List[int]) -> int:\\n a,b,m=[deque([0]*x) for x in rollMax],[1]*6,1000000007\\n for", "gt": "x in a: x[-1]=1\\n for _ in range(n-1):\\n s=sum(b)%m\\n for i,x in enumerate(a):\\n x.append((s-b[i])%m)\\n b[i]=(b[i]+x[-1]-x.popleft())%m\\n return sum(b)%m"}
{"id": "356", "input": "class Solution(object):\\n def findKthNumber(self, n, k):\\n \"\"\"\\n :type n: int\\n :type k: int\\n :rtype: int\\n \"\"\"\\n s,nn=0,str(n)\\n while nn:\\n if not k: return s\\n c,m=0,10**(len(nn)-1)\\n mm,p,t=(m-1)//9,int(nn)//m,0\\n for i in range(1 if not s else", "gt": "0,p):\\n cc=c+m+mm\\n if cc>=k:\\n s=10*s+i\\n k-=c+1\\n nn='9'*(len(nn)-1)\\n t=1\\n break\\n c=cc\\n if not t:\\n cc=c+int(nn)-(m*p)+1+mm\\n if cc>=k:\\n s=10*s+p\\n k-=c+1\\n nn=nn[1:]\\n else:\\n c=cc\\n for i in range(p+1,10):\\n cc=c+mm\\n if cc>=k:\\n s=10*s+i\\n k-=c+1\\n nn='9'*(len(nn)-2)\\n break\\n c=cc\\n return s"}
{"id": "357", "input": "class Solution:\\n def searchMatrix(self, matrix, target):\\n \"\"\"\\n :type matrix: List[List[int]]\\n :type target: int\\n :rtype: bool\\n \"\"\"\\n if not matrix or target is None:\\n return False\\n \\n rows, cols = len(matrix), len(matrix[0])\\n low, high = 0, rows * cols - 1\\n \\n while", "gt": "low <= high:\\n mid = (low + high) // 2\\n num = matrix[mid // cols][mid % cols]\\n \\n if num == target:\\n return True\\n elif num < target:\\n low = mid + 1\\n else:\\n high = mid - 1\\n \\n return False\\n"}
{"id": "358", "input": "class Solution:\\n def maxDistToClosest(self, seats: List[int]) -> int:\\n ans = 0 \\n for seat, group", "gt": "in itertools.groupby(seats):\\n if not seat:\\n k = len(list(group))\\n ans = max(ans, (k+1)//2)\\n return max(ans, seats.index(1),seats[::-1].index(1))\\n \\n"}
{"id": "359", "input": "class Solution:\\n def findReplaceString(self, s: str, indexes: List[int], sources: List[str], targets: List[str]) -> str:\\n l = []\\n for i, tgt, rpl in zip(indexes, sources, targets):\\n if s[i:i + len(tgt)] == tgt:\\n", "gt": "l.append((i, tgt, rpl))\\n l.sort()\\n j = 0\\n s = list(s)\\n for i, tgt, rpl in l:\\n s[i + j:i + j + len(tgt)] = rpl\\n j += len(rpl) - len(tgt)\\n return ''.join(s)"}
{"id": "360", "input": "class Solution:\\n def minFallingPathSum(self, A: List[List[int]]) -> int:\\n dp = [A[0][:], [0 for _ in A[0]]]\\n for i in range(1, len(A)):\\n for j in range(len(A[i])):\\n dp[i & 1][j] =", "gt": "min([dp[(i - 1) & 1][j + k] for k in (-1, 0, 1) if 0 <= j + k < len(A[i])]) + A[i][j]\\n return min(dp[(len(A) - 1) & 1])\\n"}
{"id": "361", "input": "class Solution:\\n def shipWithinDays(self, weights: List[int], D: int) -> int:\\n left = max(weights)\\n right = left * len(weights) // D\\n while left < right: \\n mid = left + (right - left) // 2\\n c = 0 \\n", "gt": "d = 1 \\n for w in weights:\\n if c + w <= mid:\\n c += w\\n else:\\n d += 1\\n c = w\\n if d > D:\\n left = mid + 1\\n else:\\n right = mid\\n return left"}
{"id": "362", "input": "from functools import lru_cache\\nclass Solution:\\n def tilingRectangle(self, n: int, m: int) -> int:\\n if (n == 11 and m == 13) or (m == 11 and n == 13):\\n return 6\\n \\n @lru_cache\\n def dfs(x, y):\\n if x % y == 0:\\n return x // y\\n if y % x == 0:\\n", "gt": "return y // x\\n \\n res = x * y\\n for i in range(1, (x // 2) + 1):\\n res = min(res, dfs(x-i, y) + dfs(i, y))\\n \\n for k in range(1, (y // 2) + 1):\\n res = min(res, dfs(x, y-k) + dfs(x, k))\\n \\n return res\\n \\n return dfs(n, m)"}
{"id": "363", "input": "class Solution:\\n def numberWays(self, hats: List[List[int]]) -> int:\\n # assign hat to people\\n n = len(hats)\\n dic = collections.defaultdict(list)\\n for i,hat in enumerate(hats):\\n for h in hat:\\n dic[h].append(i)\\n \\n # mask for people: ways\\n bfs = {0:1}\\n target = (1<<n)-1\\n res", "gt": "= 0\\n for h in range(1,41):\\n new_bfs = bfs.copy()\\n for p in dic[h]:\\n for mask,cnt in list(bfs.items()):\\n new_mask = (1<<p)|mask\\n if new_mask!=mask:\\n if new_mask not in new_bfs:\\n new_bfs[new_mask]=0\\n new_bfs[new_mask]+= cnt\\n bfs = new_bfs\\n return bfs[target]%(10**9+7) if target in bfs else 0\\n"}
{"id": "364", "input": "class Solution:\\n def numEnclaves(self, A: List[List[int]]) -> int:\\n def dfs(i, j):\\n if not (0<=i<len(A) and 0<=j<len(A[i])):\\n return\\n if A[i][j]==0:\\n return\\n A[i][j]=0\\n dfs(i-1, j)\\n dfs(i+1, j)\\n dfs(i, j-1)\\n dfs(i, j+1)\\n", "gt": "for i in range(len(A)):\\n for j in range(len(A[i])):\\n if A[i][j]==0:\\n continue\\n if (i==0 or j==0 or i==len(A)-1 or j==len(A[i])-1):\\n dfs(i, j)\\n res = sum([sum(row) for row in A])\\n return res"}
{"id": "365", "input": "class Solution:\\n def canMeasureWater(self, x, y, z):\\n \"\"\"\\n :type x: int\\n :type y: int\\n :type z: int\\n :rtype: bool\\n \"\"\"\\n if x > y:\\n x, y = y, x\\n if z < 0 or z > x+y:\\n return False\\n if x == 0:\\n return z == y or z == 0\\n if z %", "gt": "x == 0:\\n return True\\n if y % x == 0:\\n return False\\n a = x\\n b = y%x\\n while a > 1 and b > 1:\\n a = a%b\\n a, b = b, a\\n if b == 0:\\n m = a\\n else:\\n m = b\\n if z%m == 0:\\n return True\\n return False"}
{"id": "366", "input": "class Solution:\\n def uniqueLetterString(self, s: str) -> int:\\n chrLoc = defaultdict(list)\\n ct = 0\\n md = 1000000007\\n l = len(s)\\n for i, c in enumerate(s):\\n chrLoc[c].append(i)\\n \\n for c in chrLoc:\\n locs = [-1] + chrLoc[c] + [l]\\n loc_ct = len(locs)\\n #print(c,", "gt": "locs)\\n for i in range(1, loc_ct-1): \\n leftWingSpan = locs[i] - locs[i-1] #i-mostRecently + 1\\n rightWingSpan = locs[i+1] - locs[i] # l-i\\n ct += ((leftWingSpan % md) * (rightWingSpan % md)) % md\\n #print(leftWingSpan,rightWingSpan, c, i)\\n ct %= md \\n \\n return ct"}
{"id": "367", "input": "class Solution:\\n def longestSubstring(self, s, k):\\n \"\"\"\\n :type s: str\\n :type k: int\\n :rtype: int\\n \"\"\"\\n", "gt": "for c in set(s):\\n if s.count(c) < k:\\n return max(self.longestSubstring(sp, k) for sp in s.split(c))\\n return len(s)"}
{"id": "368", "input": "class Solution:\\n def findDuplicate(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n if len(nums) == 0:\\n return None\\n slow = fast = nums[0]\\n while True:\\n", "gt": "slow = nums[slow]\\n fast = nums[nums[fast]]\\n if slow == fast:\\n break\\n fast = nums[0]\\n while slow != fast:\\n slow = nums[slow]\\n fast = nums[fast]\\n return slow"}
{"id": "369", "input": "class Solution:\\n def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n \\n satisfaction.sort()\\n total, res = 0,0\\n \\n", "gt": "while satisfaction and satisfaction[-1]+total > 0:\\n total += satisfaction.pop()\\n res += total\\n \\n return res\\n"}
{"id": "370", "input": "class Solution:\\n def minFlips(self, mat: List[List[int]]) -> int:\\n m = len(mat)\\n n = len(mat[0])\\n \\n start = sum(val << (i*n + j) for i, row in enumerate(mat) for j, val in enumerate(row))\\n \\n queue = collections.deque([(start, 0)])\\n seen = { start }\\n \\n dirs = [[0, 0], [0,1], [1, 0], [0, -1], [-1, 0]]\\n while queue:\\n # print(queue)\\n current, d = queue.popleft()\\n if current == 0:\\n return d\\n \\n # for each index in matrix find neighbour\\n for i in range(len(mat)):\\n for j in", "gt": "range(len(mat[0])):\\n next_state = current\\n \\n # importants dirs has [0, 0] we need flip the current element and neigbour\\n for dir_ in dirs:\\n new_i = i + dir_[0]\\n new_j = j + dir_[1]\\n \\n if new_i >= 0 and new_i < len(mat) and new_j >= 0 and new_j < len(mat[0]):\\n next_state ^= (1 << (new_i * n + new_j )) # 0 xor 1 = 1, 1 xor 1 = 0\\n \\n if next_state not in seen:\\n seen.add(next_state)\\n queue.append((next_state, d + 1))\\n \\n return -1\\n"}
{"id": "371", "input": "from collections import defaultdict\\n\\n\\nclass Solution:\\n MAXPRIME=100001\\n isPrime=[0 for _ in range(MAXPRIME+1)]\\n isPrime[0]=-1;isPrime[1]=-1 #0 and 1 are not prime numbers\\n for i in range(2,MAXPRIME):\\n if isPrime[i]==0: #i is prime\\n for multiple in range(i*i,MAXPRIME+1,i):\\n if isPrime[multiple]==0:\\n isPrime[multiple]=i\\n isPrime[i] = i\\n\\n def largestComponentSize(self, A: List[int]) -> int:\\n label = defaultdict(int)\\n\\n def findRoot(key):\\n if label[key] > 0:\\n label[key] = findRoot(label[key])\\n return label[key]\\n else:\\n return key\\n \\n", "gt": "def mergeRoot(k1, k2):\\n r1, r2 = findRoot(k1), findRoot(k2) \\n if r1 != r2:\\n r1, r2 = min(r1, r2), max(r1, r2)\\n label[r1] += label[r2]\\n label[r2] = r1\\n return r1\\n\\n for x in A:\\n root_id = 0\\n prime_factors = set()\\n while Solution.isPrime[x]!=-1:\\n p = Solution.isPrime[x]\\n root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\\n x //= p\\n label[root_id] -= 1\\n \\n return -min(label.values())\\n"}
{"id": "372", "input": "from collections import defaultdict\\n\\nclass Solution:\\n def numBusesToDestination(self, routes: List[List[int]], S: int, T: int) -> int:\\n if S == T:\\n return 0\\n # sequence_to_route_id dict\\n # if when adding sequence ids to this dict, they are part of another route,\\n # merge them\\n max_int = 10**6\\n start_routes = set()\\n end_routes = set()\\n route_connections = defaultdict(lambda: set())\\n sequence_to_route_id_dict = {}\\n route_to_minbuscount = defaultdict(lambda: max_int)\\n for r_id, r in enumerate(routes):\\n for s in r:\\n if", "gt": "s == S:\\n start_routes.add(r_id)\\n route_to_minbuscount[r_id] = 1\\n if s == T:\\n end_routes.add(r_id)\\n if s in sequence_to_route_id_dict:\\n route_connections[r_id].add(sequence_to_route_id_dict[s])\\n route_connections[sequence_to_route_id_dict[s]].add(r_id)\\n sequence_to_route_id_dict[s] = r_id\\n \\n # print(route_connections)\\n # print(start_routes)\\n # print(end_routes)\\n \\n current_route_buscount = [(s,1) for s in start_routes]\\n for r_id, buscount in current_route_buscount:\\n # print(current_route_buscount)\\n # print(dict(route_to_minbuscount))\\n for connection in route_connections[r_id]:\\n if route_to_minbuscount[connection] > buscount+1:\\n route_to_minbuscount[connection] = buscount+1\\n current_route_buscount.append((connection,buscount+1))\\n result = min(route_to_minbuscount[x] for x in end_routes)\\n return -1 if result == max_int else result\\n\\n"}
{"id": "373", "input": "class Solution:\\n cache = {}\\n def isMatch(self, s, p):\\n \"\"\"\\n :type s: str\\n :type p: str\\n :rtype: bool\\n \"\"\"\\n \\n if (s, p) in self.cache:\\n return self.cache[(s, p)]\\n if not p:\\n return not s\\n if p[-1] == '*':\\n if self.isMatch(s, p[:-2]):\\n self.cache[(s, p)] = True\\n", "gt": "return True\\n if s and (s[-1] == p[-2] or p[-2] == '.') and self.isMatch(s[:-1], p):\\n self.cache[(s, p)] = True\\n return True\\n if s and (p[-1] == s[-1] or p[-1] == '.') and self.isMatch(s[:-1], p[:-1]):\\n self.cache[(s, p)] = True\\n return True\\n self.cache[(s, p)] = False\\n return False"}
{"id": "374", "input": "class Solution:\\n def maxProfit(self, k, prices):\\n \"\"\"\\n :type k: int\\n :type prices: List[int]\\n :rtype: int\\n \"\"\"\\n length = len(prices)\\n v = p = 0\\n pairs, profits = [], []\\n \\n while p < length:\\n \\n v = p\\n while v < length - 1 and prices[v] >= prices[v+1]:\\n v += 1\\n \\n p = v+1\\n while p < length and prices[p] >= prices[p-1]:\\n p += 1\\n", "gt": "\\n \\n while pairs and prices[v] < prices[pairs[-1][0]]:\\n heapq.heappush(profits, prices[pairs[-1][0]] - prices[pairs[-1][1] - 1])\\n pairs.pop()\\n \\n while pairs and prices[p-1] >= prices[pairs[-1][1] - 1]:\\n heapq.heappush(profits, prices[v] - prices[pairs[-1][1] - 1])\\n v = pairs[-1][0]\\n pairs.pop()\\n \\n pairs.append((v, p))\\n \\n while pairs:\\n heapq.heappush(profits, prices[pairs[-1][0]] - prices[pairs[-1][1] - 1])\\n pairs.pop()\\n \\n \\n ans = 0\\n while k != 0 and profits:\\n ans += -heapq.heappop(profits)\\n k -= 1\\n return ans"}
{"id": "375", "input": "class Solution:\\n def shortestSuperstring(self, A: List[str]) -> str:\\n A = [a for i, a in enumerate(A) if all(a not in b for j, b in enumerate(A) if i != j)]\\n\\n def memo(f):\\n dic = {}\\n\\n def f_alt(*args):\\n if args not in dic:\\n dic[args] = f(*args)\\n return dic[args]\\n return f_alt\\n\\n def merge(w1,", "gt": "w2):\\n for k in range(len(w2), -1, -1):\\n if w1.endswith(w2[:k]):\\n return w1+w2[k:]\\n\\n @memo\\n def find_short(tup, last):\\n if len(tup) == 1:\\n return A[tup[0]]\\n mtup = tuple(t for t in tup if t != last)\\n return min((merge(find_short(mtup, t), A[last]) for t in mtup), key=len)\\n\\n tup = tuple(range(len(A)))\\n\\n return min((find_short(tup, i) for i in range(len(A))), key=len)\\n"}
{"id": "376", "input": "class Solution:\\n def maximumGap(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n if not nums or len(nums)", "gt": "== 1:\\n return 0\\n sorted_gap=0\\n nums=list(set(nums))\\n nums.sort()\\n for curr in range(len(nums[:-1])):\\n gap=nums[curr+1]-nums[curr]\\n if gap>sorted_gap:\\n sorted_gap=gap\\n \\n return sorted_gap"}
{"id": "377", "input": "class Solution:\\n def minScoreTriangulation(self, A: List[int]) -> int:\\n N = len(A)\\n dp = [[0]*N for _ in range(N)]\\n \\n for i", "gt": "in range(N-2, -1, -1):\\n for j in range(i+2, N):\\n dp[i][j] = min(dp[i][k]+dp[k][j]+A[i]*A[j]*A[k] for k in range(i+1, j))\\n \\n return dp[0][-1]\\n \\n \\n"}
{"id": "378", "input": "class Solution:\\n def NOD(self, a, b):\\n if a == b:\\n return a\\n c = max(a,b)\\n d = a + b - c\\n c = c%d\\n c = c if c>0 else d\\n return self.NOD(c,d)\\n def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\\n const = 10**9 + 7\\n nod = self.NOD(A, B)\\n nok = int(A*B/nod)\\n C, D = min(A, B), max(A, B)\\n k_C = nok//C\\n k_D = nok//D\\n", "gt": "k = k_C + k_D - 1\\n div = N//k\\n mod = N - div*k\\n k_C_cur = (mod*k_C)//k\\n k_D_cur = mod - k_C_cur\\n #print(k_C, k_D, k, div, mod, k_C_cur, k_D_cur)\\n while True:\\n C_num = k_C_cur*C\\n D_num = k_D_cur*D\\n if -C < C_num - D_num < D:\\n return (div*nok + max(C_num, D_num))%const\\n elif C_num - D_num <= -C:\\n k_D_cur -= 1\\n k_C_cur += 1\\n else:\\n k_D_cur += 1\\n k_C_cur -= 1"}
{"id": "379", "input": "class Solution:\\n def canPartition(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: bool\\n \"\"\"\\n _sum=sum(nums)\\n div,mod=divmod(_sum,2)\\n if mod!=0:\\n return False\\n target=[div]*2\\n self._len=len(nums)\\n nums.sort(reverse=True)\\n def dfs(index,target):\\n", "gt": "if index==self._len:\\n return True\\n num=nums[index]\\n for i in range(2):\\n if target[i]>=num:\\n target[i]-=num\\n if dfs(index+1,target):return True\\n target[i]+=num\\n return False\\n return dfs(0,target)\\n \\n \\n \\n"}
{"id": "380", "input": "class Solution:\\n def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\\n d2 = {nums2[i]:i for i in range(len(nums2))}\\n _nums1 = []\\n _nums2 = []\\n prev_i, prev_j = 0, 0\\n for i in range(len(nums1)):\\n if nums1[i] in", "gt": "d2:\\n _nums1.append(sum(nums1[prev_i:i]))\\n _nums2.append(sum(nums2[prev_j:d2[nums1[i]]]))\\n _nums1.append(nums1[i])\\n _nums2.append(nums1[i])\\n prev_i = i+1\\n prev_j = d2[nums1[i]]+1\\n _nums1.append(sum(nums1[prev_i:]))\\n _nums2.append(sum(nums2[prev_j:]))\\n print(_nums1)\\n print(_nums2)\\n n = len(_nums1)\\n ans = 0\\n for i in range(n):\\n ans += max(_nums1[i], _nums2[i])\\n return ans % (10**9 + 7)"}
{"id": "381", "input": "class Solution:\\n def validIPAddress(self, IP):\\n \"\"\"\\n :type IP: str\\n :rtype: str\\n \"\"\"\\n if \":\" in IP:\\n res = self.validIPv6(IP)\\n return \"IPv6\" if res else \"Neither\"\\n elif \".\" in IP:\\n res = self.validIPV4(IP)\\n return \"IPv4\" if res else \"Neither\"\\n else:\\n return \"Neither\"\\n \\n def validIPV4(self, IP):\\n charSet = set(list(\"0123456789\"))\\n parts = IP.split(\".\")\\n if len(parts) != 4:\\n return False\\n for part in parts:\\n if len(part) < 1:\\n return False\\n for c in part:\\n if c not in charSet:\\n return False\\n if not (0 <= int(part) <= 255):\\n return False\\n \\n if part[0] == '0' and", "gt": "len(part) > 1: # invalid leading zero\\n return False\\n return True\\n \\n def validIPv6(self, IP):\\n charSet = set(list(\"0123456789abcdefABCDEF\"))\\n parts = IP.split(\":\")\\n if len(parts) != 8:\\n return False\\n zeroFlag = False\\n omtFlag = False\\n for part in parts:\\n if len(part) == 0:\\n omtFlag = True\\n \\n if self.allZero(part):\\n zeroFlag = True\\n \\n if len(part) > 4:\\n return False\\n \\n for c in part:\\n if c not in charSet:\\n return False\\n if zeroFlag and omtFlag:\\n return False\\n return True\\n \\n def allZero(self, s):\\n for i in range(len(s)):\\n if s[i] != '0':\\n return False\\n return True\\n"}
{"id": "382", "input": "class Solution:\\n def minSubArrayLen(self, k, nums):\\n \"\"\"\\n :type k: int\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n if not nums:\\n return 0\\n _min = float('inf')\\n _sum = 0\\n j", "gt": "= 0\\n \\n \\n for i ,n in enumerate(nums):\\n _sum += n\\n while _sum>=k:\\n _min = min(i-j+1, _min)\\n _sum -= nums[j]\\n j+=1\\n return _min if _min!=float('inf') else 0\\n \\n"}
{"id": "383", "input": "class Solution:\\n def findPeakElement(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n if not nums:\\n return -1\\n \\n start = 0\\n end = len(nums) -1\\n while start + 1 < end:\\n mid = (start +", "gt": "end) // 2\\n if nums[mid] > nums[mid - 1]:\\n if nums[mid] > nums[mid + 1]:\\n return mid\\n else:\\n start = mid\\n else:\\n end = mid\\n if nums[start] > nums[end]:\\n return start\\n else:\\n return end\\n \\n \\n"}
{"id": "384", "input": "from collections import deque\\nclass Solution:\\n def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\\n\\n \\n def bfs(graph, seed, removed):\\n queue = deque(seed)\\n visited = seed\\n \\n while len(queue) > 0:\\n node = queue.popleft()\\n for next_node in range(len(graph[node])):\\n if graph[node][next_node] == 0 or next_node in visited or next_node == removed:\\n continue\\nvisited.add(next_node)\\n queue.append(next_node)\\n return len(visited)\\n \\n best = len(graph)\\n best_remove = initial[0]\\n initial = set(initial)\\n \\n for remove_node in initial:\\n initial_removed = initial - {remov", "gt": "e_node}"}
{"id": "385", "input": "class Solution:\\n def sumSubseqWidths(self, A: List[int]) -> int:\\n A.sort()\\n ret, mod, p = 0, 10 ** 9 + 7, 1\\n for i in range(len(A)):", "gt": "\\n ret += (A[i] - A[len(A) - i - 1]) * p % mod\\n p = (p << 1) % mod\\n return ret % mod"}
{"id": "386", "input": "class Solution:\\n def kthFactor(self, n: int, k: int) -> int:\\n i = 0\\n for j in range(1, n+1):\\n", "gt": "if n % j == 0:\\n i += 1\\n if i == k:\\n return j\\n return -1\\n \\n"}
{"id": "387", "input": "class Solution:\\n def countVowelPermutation(self, n: int) -> int:\\n a = 1\\n e = 1\\n i = 1\\n o = 1\\n u = 1\\n res = 0\\n M = 1e9+7\\n\\n for x in range(n-1):\\n a1 = e\\n e1 = (a + i) % M\\n", "gt": "i1 = (a + e + u + o) % M\\n o1 = (i + u) % M\\n u1 = a\\n a = a1\\n e = e1\\n i = i1\\n o = o1\\n u = u1\\n \\n res = int((a+e+i+o+u) % M)\\n return res"}
{"id": "388", "input": "class Solution:\\n def rankTeams(self, votes: List[str]) -> str:\\n '''\\n ABC\\n ACB\\n X 1 2 3\\n A 2 0 0\\n B 0 1 1\\n C 0 1 1\\n '''\\n \\n mem = {}\\n for vote in votes:\\n for i in range(len(vote)):\\n team", "gt": "= vote[i]\\n if team not in mem:\\n mem[team] = [0 for _ in range(len(vote))]\\n mem[team][i] += 1\\n \\n standings = []\\n for k, v in mem.items():\\n standings.append(tuple(v) + (-ord(k), k))\\n \\n standings.sort(reverse=True)\\n \\n res = [s[-1] for s in standings]\\n return ''.join(res)"}
{"id": "389", "input": "class Solution(object): \\n def hIndex(self, citations): \\n \"\"\" \\n :type citations: List[int] \\n :rtype: int \\n \"\"\" \\n \\n n=len(citations) \\n \\n if", "gt": "n>0: \\n citations.sort() \\n citations.reverse() \\n h=0 \\n \\n while h<n and citations[h]-1>=h: \\n h+=1 \\n return h \\n else: \\n return 0"}
{"id": "390", "input": "class Solution:\\n def splitArraySameAverage(self, A):\\n N, S = len(A), sum(A)\\n if N == 1: return False\\n A = [z * N - S for z in A] \\n mid, left, right = N//2, {A[0]}, {A[-1]}\\n\\n\\n if not any((S*size) % N == 0 for size in range(1, mid+1)): return False\\n\\nfor i in range(1, mid): left |= {z + A[i] for", "gt": "z in left}"}
{"id": "391", "input": "import math\\n\\nclass Solution:\\n def winnerSquareGame(self, n: int) -> bool:\\n dp: List[int] = [0] * (n+1)\\n candidates: List[int] = []\\n for j in range(1, int(math.sqrt(n))+1):\\n candidates.append(j*j)\\n for i", "gt": "in range(n):\\n if not dp[i]:\\n for can in candidates:\\n if i + can < n:\\n dp[i+can] = 1\\n elif i + can == n:\\n return 1\\n return dp[-1]"}
{"id": "392", "input": "class Solution:\\n def getMaxRepetitions(self, s1, n1, s2, n2):\\n \"\"\"\\n :type s1: str\\n :type n1: int\\n :type s2: str\\n :type n2: int\\n :rtype: int\\n \"\"\"\\n if", "gt": "s2=='aac' and n2==100:\\n return 29999\\n i,j=0,0\\n l1=len(s1)\\n l2=len(s2)\\n while i//l1<n1:\\n if s1[i%l1]==s2[j%l2]:\\n j+=1\\n if j%l2==0:\\n if j//l2==1:\\n ii=i\\n elif i%l1==ii%l1:\\n return (((n1*l1-ii-1)*(j//l2-1))//(i-ii)+1)//n2\\n i+=1\\n return (j//l2)//n2"}
{"id": "393", "input": "class Solution:\\n def numWays(self, s: str) -> int:\\n n = s.count('1')\\n if n % 3 != 0: return 0\\n if n == 0: return (((len(s) - 1) * (len(s)", "gt": "- 2)) // 2) % (10**9 + 7)\\n m = n // 3\\n L = s.split('1')\\n return ((len(L[m]) + 1) * (len(L[2*m]) + 1)) % (10**9 + 7)\\n \\n"}
{"id": "394", "input": "class Solution:\\n def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n \\n def enough(num):\\n total = num//a + num//b + num//c -num//ab - num//bc - num//ac + num//abc\\n return total>=n\\n \\n \\n ab = (a*b)//math.gcd(a,b)\\n ac", "gt": "= (a*c)//math.gcd(a,c)\\n bc = (b*c)//math.gcd(b,c)\\n abc = (a*bc)//math.gcd(a,bc)\\n \\n \\n left , right = 1, min(a,b,c)*n\\n \\n while left < right:\\n mid = left+ (right-left)//2\\n if enough(mid): right = mid\\n else : left = mid + 1\\n \\n return left"}
{"id": "395", "input": "class Solution:\\n def minMoves2(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n aa", "gt": "= sorted(nums)\\n median = aa[len(nums)//2] \\n \\n return sum([abs(i-median) for i in aa])"}
{"id": "396", "input": "class Solution:\\n def oddEvenJumps(self, A: List[int]) -> int:\\n def findNextHighestIdx(B: List[int]) -> List[int]:\\n next_idx_list = [None] * len(B)\\n stack = []\\n for i in B:\\n while stack and stack[-1] < i:\\n next_idx_list[stack.pop()] = i\\n stack.append(i)\\n return next_idx_list\\n\\n N = len(A)\\n B = sorted(range(N), key=lambda i: A[i])\\n oddnextidx = findNextHighestIdx(B)\\n", "gt": "B.sort(key=lambda i: -A[i])\\n evennextidx = findNextHighestIdx(B)\\n \\n odd = [False] * N\\n odd[N-1] = True\\n even = [False] * N\\n even[N-1] = True\\n \\n for i in range(N-2, -1, -1):\\n if oddnextidx[i] is not None:\\n odd[i] = even[oddnextidx[i]]\\n if evennextidx[i] is not None:\\n even[i] = odd[evennextidx[i]]\\n \\n return sum(odd)"}
{"id": "397", "input": "class Solution:\\n def smallestRepunitDivByK(self, K: int) -> int:\\n if K % 2 == 0 or K % 5 == 0: return -1\\n r", "gt": "= 0\\n for N in range(1, K + 1):\\n r = (r * 10 + 1) % K\\n if not r: return N"}
{"id": "398", "input": "class Solution:\\n def countDigitOne(self, n):\\n \"\"\"\\n :type n: int\\n :rtype: int\\n \"\"\"\\n ones, m = 0, 1\\n while m <= n:\\n ones += (n //", "gt": "m + 8) // 10 * m + (n // m % 10 == 1) * (n % m + 1)\\n m *= 10\\n return ones"}
{"id": "399", "input": "class Solution:\\n def subarraySum(self, nums, k):\\n \"\"\"\\n :type nums: List[int]\\n :type k: int\\n :rtype: int\\n \"\"\"\\n \\n dic = {}\\n numSum = 0\\n dic[0] = 1\\n ans = 0\\n for", "gt": "i in range(len(nums)):\\n numSum += nums[i]\\n if (numSum - k) in dic:\\n ans += dic[numSum - k]\\n if numSum in dic:\\n dic[numSum] += 1\\n else:\\n dic[numSum] = 1\\n return ans"}
{"id": "400", "input": "class Solution:\\n def numDecodings(self, s):\\n \"\"\"\\n :type s: str\\n :rtype: int\\n \"\"\"\\n if not s:\\n return 0\\n \\n def num_decode(i):\\n # Number of ways to decode s[i:]\\n if i == len(s):\\n return 1\\n \\n \\n if i not in memo: \\n num_ways = 0\\n \\n", "gt": "if s[i] in single_digit_codes:\\n num_ways += num_decode(i + 1)\\n \\n if s[i:i+2] in double_digit_codes:\\n num_ways += num_decode(i + 2)\\n \\n memo[i] = num_ways\\n return memo[i]\\n single_digit_codes = set(str(x) for x in range(1, 10))\\n double_digit_codes = set(str(x) for x in range(10, 27))\\n memo ="}
{"id": "401", "input": "class Solution:\\n def largestRectangleArea(self, heights):\\n \"\"\"\\n :type heights: List[int]\\n :rtype: int\\n \"\"\"\\n \\n if not heights:\\n return 0\\n stack = [0]\\n heights.append(0)\\n # print(heights)\\n max_area = 0\\n for i in range(len(heights)):\\n # print(stack)\\n if heights[i] >= stack[-1]:\\n stack.append(heights[i])\\n else:\\n k = len(stack) - 1\\n count = 0\\n while heights[i] < stack[k] and k >= 0:\\n count", "gt": "+= 1\\n # print(count)\\n # print(stack[k])\\n area = count * stack[k]\\n if max_area < area:\\n max_area = area\\n k -= 1\\n # print(max_area)\\n stack = stack[:-count] + [heights[i],] * (count + 1)\\n # print((count + 1) * stack[k])\\n # if max_area < (count + 1) * heights[i]:\\n # max_area = (count + 1) * heights[i]\\n return max_area\\n"}
{"id": "402", "input": "#5:09\\n'''\\nnums = [3,6,5,1,8]\\nsum_nums = 23\\nmod3_sum_nums = 2\\nmod3_dict = {0:[3,6], 1:[1], 2:[5,8]}\\nhelper([5,8], [1]) -> 5\\n\\n\\n\\n\\n\\n'''\\n\\nfrom collections import defaultdict\\nclass Solution:\\n def helper(self, l1, l2):\\n if len(l1) < 1 and len(l2) <2:\\n sum_remove = 0\\n elif len(l1) < 1:\\n sum_remove = min(l2)\\n l2.remove(sum_remove)\\n sum_remove += min(l2)\\n \\n elif len(l2) <2:\\n sum_remove = min(l1)\\n \\n else:\\n sum_remove1 = min(l1)\\n sum_remove2 = min(l2)\\n l2.remove(sum_remove2)\\n sum_remove2 += min(l2)\\n sum_remove", "gt": "= min(sum_remove1, sum_remove2)\\n \\n return sum_remove\\n \\n \\n def maxSumDivThree(self, nums: List[int]) -> int:\\n sum_nums = sum(nums)\\n mod3_sum_nums = sum_nums%3\\n if mod3_sum_nums == 0:\\n return sum_nums\\n \\n mod3_dict = defaultdict(list)\\n for i,num in enumerate(nums):\\n mod3_dict[num%3].append(num)\\n \\n \\n if mod3_sum_nums ==1:\\n sum_remove = self.helper(mod3_dict[1], mod3_dict[2])\\n \\n else:\\n sum_remove = self.helper(mod3_dict[2], mod3_dict[1])\\n \\n if sum_remove >0:\\n return sum_nums - sum_remove\\n else:\\n return 0\\n \\n \\n"}
{"id": "403", "input": "import heapq\\n\\ndef solve(b,s,t):\\n def create_priority_item(c, t):\\n dx = c[0]-t[0]\\n dy = c[1]-t[1]\\n d2 = dx*dx + dy*dy\\n return (d2, c)\\n\\n b = set(tuple(_b) for _b in b)\\n s = tuple(s)\\n t = tuple(t)\\n # heap = [(-1,s)]\\n heap = [s]\\n visited = set()\\n iter = -1\\n while heap:\\n iter += 1\\n if iter > 1.1e6:\\n return False\\n # _, c = heapq.heappop(heap)\\n c = heap.pop()\\n if c in visited or c in b or c[0] < 0 or c[0] >=1e6 or c[1]<0 or c[1]>=1e6:\\n continue\\n if c == t:\\n #", "gt": "found!\\n return True\\n # search neighbors:\\n dx = c[0] - s[0]\\n dy = c[1] - s[1]\\n if dx*dx + dy*dy > 200*200:\\n return True\\n\\n visited.add(c)\\n\\n\\n # heapq.heappush(heap, create_priority_item((c[0]+1, c[1] ), t))\\n # heapq.heappush(heap, create_priority_item((c[0]-1, c[1] ), t))\\n # heapq.heappush(heap, create_priority_item((c[0] , c[1]+1), t))\\n # heapq.heappush(heap, create_priority_item((c[0] , c[1]-1), t))\\n heap.append((c[0]+1, c[1] ))\\n heap.append((c[0]-1, c[1] ))\\n heap.append((c[0] , c[1]+1))\\n heap.append((c[0] , c[1]-1))\\n # we live in a cavity :(\\n return False\\n\\ndef solve_both(b,s,t):\\n return solve(b,s,t) and solve(b,t,s)\\n\\n\\n\\n\\nclass Solution:\\n def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\\n return solve_both(blocked, source, target)\\n"}
{"id": "404", "input": "class Solution:\\n def increasingTriplet(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: bool\\n \"\"\"\\n n1 = n2 = float('inf')\\n for n in", "gt": "nums:\\n if n <= n1:\\n n1 = n\\n elif n <= n2:\\n n2 = n\\n else:\\n return True\\n return False"}
{"id": "405", "input": "class Solution:\\n def largestSumOfAverages(self, A: List[int], K: int) -> float:\\n #if not A: return 0\\n #if len(A)==1: return A[0]\\n # Real Run Time is a little bit UNSTABLE\\n N = len(A)\\n P = [0] * (N+1)\\n for i in range(1,N+1): P[i] =", "gt": "P[i-1] + A[i-1]\\n \\n # Table[a] = optimal for A[a:] with k subsets, initially k=1\\n Table = [(P[N]-P[i])/(N-i) for i in range(N)]\\n for k in range(2, K+1):\\n for i in range(K-k,N-k+1):\\n Table[i] = max((P[j]-P[i])/(j-i) + Table[j] for j in range(i+1,N-k+2))\\n \\n return Table[0]"}
{"id": "406", "input": "class Solution:\\n def new21Game(self, N: int, K: int, W: int) -> float:\\n dp = [0] * (N + W)\\n for i in range(K, N + 1):\\n dp[i] = 1\\n \\n", "gt": "S = min(W, N - K + 1)\\n for i in range(K - 1, -1, -1):\\n dp[i] = S / W\\n S += dp[i] - dp[i + W]\\n return dp[0]"}
{"id": "407", "input": "class Solution:\\n def ladderLength(self, beginWord, endWord, wordList):\\n \\n wordDict = set(wordList)\\n if not endWord in wordDict:\\n return 0\\n \\n visited = set()\\n \\n beginSet = set()\\n beginSet.add(beginWord)\\n visited.add(beginWord)\\n \\n endSet = set()\\n endSet.add(endWord)\\n visited.add(endWord)\\n \\n lenWord = len(beginWord)\\n \\n distance = 1\\n \\n while len(beginSet) > 0 and len(endSet) > 0:\\n \\n # make sure begin set is smaller than endSet\\n if len(beginSet) > len(endSet):\\n beginSet,", "gt": "endSet = endSet, beginSet\\n \\n # extend begin set\\n newSet = set()\\n for w in beginSet:\\n for i in range(lenWord):\\n part1 = w[:i]\\n part2 = w[i+1:]\\n for alpha in 'abcdefghijklmnopqrstuvwxyz':\\n target = part1 + alpha + part2\\n \\n if target in endSet:\\n return distance + 1\\n elif (not target in visited) and (target in wordDict):\\n newSet.add(target)\\n visited.add(target)\\n \\n beginSet = newSet\\n distance += 1\\n return 0"}
{"id": "408", "input": "class Solution:\\n def scoreOfParentheses(self, S: str) -> int:\\n ans, val = 0, 1\\n for i in range(len(S) - 1):\\n if S[i: i+2]", "gt": "== '((': val *= 2\\n if S[i: i+2] == '()': ans += val\\n if S[i: i+2] == '))': val //= 2\\n return ans"}
{"id": "409", "input": "class Solution:\\n def findBestValue(self, arr: List[int], target: int) -> int:\\n arr.sort()\\n n = len(arr)\\n for i in range(n):\\n", "gt": "sol = round(target / n)\\n if arr[i] >= sol:\\n return sol\\n target -= arr[i]\\n n -= 1\\n return arr[-1]"}
{"id": "410", "input": "class Solution:\\n def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\\n oneArrSum = sum(arr)\\n twoArr = arr + arr\\n \\n def findMaxSub(array):\\n if len(array) == 1:\\n return array[0]\\n \\n cur = 0\\n small = 0\\n ret = -999999\\n for i in array:\\n cur += i\\n small = cur if cur < small else small\\n ret", "gt": "= cur - small if cur - small > ret else ret\\n \\n return 0 if ret < 0 else ret\\n \\n if not arr:\\n return 0\\n if k == 1:\\n return findMaxSub(arr)\\n \\n ret = findMaxSub(twoArr)\\n if oneArrSum > 0 and k > 2:\\n ret += (k-2)*oneArrSum\\n return ret % (10**9 + 7)"}
{"id": "411", "input": "class Solution:\\n def getKth(self, lo: int, hi: int, k: int)", "gt": "-> int:\\n return sorted(range(lo, hi + 1), key='寒寒寓寙寔寗寚寢寕寥寘寠寛寛寣寣寖寞實實寙寙寡寡寜審寜屁寤寤寤尼寗寬察察寧寧寧寴寚尿寚寯寢寢寢尺寝寪寪寪寝寝层层寥寲寥寲寥寥尽尽寘寭寭寭寠寠寠尸寨居寨寠寨寨寵寵寛寨局局寛寛寰寰寣寰寣尮寣寣尻尻寞屈寫寫寫寫寫尩寞寸寞尶屃屃屃尗實寞寳寳實實寳寳實就實尀尾尾尾尀寙屋寮寮寮寮寮寻寡尬寡寻寡寡尹尹審屆屆屆審審寡寡審寶審尧寶寶寶專寜尴審審屁屁屁尕寜尃寜屎寱寱寱尢寤寱寱寱寤寤尯尯寤対寤対尼尼尼対察屉屉屉寬寬寬屉寬寤寬对寬寬尪尪察对对对察察尷尷屄寬屄将屄屄尘尘寧将察察寴寴寴屑寧尥寧屑寴寴寴将寧寧尲尲寧寧封封尿封尿尓尿尿封封寚屌屌屌寯寯寯尠寯屌寯寧寯寯导导寢寯尭尭寢寢导导寢导寢導尺尺尺导寪寯屇屇屇屇屇尉寪尛寪屇寢寢寢导寪寷寷寷寪寪尨尨寷屔寷寷寷寷尉尉寝寪尵尵寪寪寪屡层射层寪层层尖尖寝层射射寝寝屏屏寲屏寲屏寲寲尣尣寥屏寲寲寲寲寲射寥寿寥寿尰尰尰寿寥寥寿寿寥寥寿寿尽少尽尌尽尽寿寿寠寲届届届届届届寭尌寭尞寭寭届届寭寥寥寥寭寭寺寺寭寺寭屗尫尫尫屗寠屗寺寺寺寺寺寲寠尌寠將尸尸尸寺居寭寭寭居居將將居寭居將尙尙尙尳寨居將將寠寠寠寺寵屒寵屒寵寵屒屒寨寵尦尦寨寨屒屒寵寵寵寭寵寵將將寨専寨寨尳尳尳屟寨専寨屟専専専尳局寨専専局局尔尔局小局寵専専専小寛寵屍屍屍屍屍小寰屍寰屍寰寰尡尡寰寰屍屍寰寰寨寨寰寨寰専寽寽寽屚寣寽寰寰尮尮尮寽寣屚寣寰寽寽寽尩寣寽寽寽寣寣小小尻尊尻寰尻尻寽寽寫寰寰寰屈屈屈寰屈尊屈屈屈屈尊尊寫尜尜尜寫寫屈屈寣尊寣尗寣寣寽寽寫展寸寸寸寸寸尗寫展寫展尩尩尩展寸寫展展寸寸寸寸寸寰寸寰尊尊尊展寞尅寫寫尶尶尶寸寫屢寫尶寫寫屢屢屃尅尅尅屃屃寫寫屃尅屃屢尗尗尗就寞尒屃屃尅尅尅尒寞尒寞寸屐屐屐寸寳屐屐屐寳寳屐屐寳屐寳尒尤尤尤屼實寳屐屐寳寳寳尒寳寫寳寫寳寳尅尅實尀尀尀實實尀尀就寳就屝就就尀尀實屝實實尀尀尀就實尬實尀尀尀尀屝尾實尒尒尾尾對對尾寳尾屪尀尀尀對寡寳寳寳屋屋屋屪屋寳屋對屋屋屋屋寮屋對對寮寮尟尟寮尟寮尹屋屋屋尚寮對實實實實實尚寮尀寮屘寻寻寻屘寮寻寻寻寮寮屘屘尬屘尬寻尬尬屘屘寡寮屘屘寻寻寻尧寻寻寻寻寻寻寳寳寡對對對寡寡專專尹寮尹履尹尹寻寻屆履寮寮寮寮寮岄屆履屆寮專專專履屆屆寮寮屆屆專專尚履尚尀尚尚尴尴審尕屆屆專專專屆寡尕寡專寡寡寻寻寶屓屓屓寶寶屓屓寶屓寶尕屓屓屓屆審屓寶寶尧尧尧屓審屿審尧屓屓屓寶寶寶寶寶寶寶寮寮寶寮寶寮專專專屓審尃尃尃審審審屠尴尃尴寶尴尴屠屠審尴尃尃審審屠屠尃審尃寶尃尃尴尴屁尯審審尃尃尃尃屁'.__getitem__)[k - 1]"}
{"id": "412", "input": "class Solution:\\n def wordBreak(self, s, wordDict):\\n n = len(s)\\n dp = [False for i in range(n+1)]\\n dp[0]", "gt": "= True\\n for i in range(1,n+1):\\n for w in wordDict:\\n if dp[i-len(w)] and s[i-len(w):i]==w:\\n dp[i]=True\\n return dp[-1]\\n"}
{"id": "413", "input": "from math import comb\\nfrom math import pow\\nclass Solution:\\n\\n \\n \\n def numRollsToTarget(self, d: int, f: int, target: int) -> int:\\n if(target < d*1 or target > d*f ):\\n return 0\\n target = target - d\\n sum = 0\\n i = 0\\n j=0\\n while(i <= target):\\n y =", "gt": "target - i\\n if(j%2 == 0):\\n \\n sum =int( (sum + comb(d, j) * comb(y+d-1,y)) )\\n else:\\n sum =int( (sum - comb(d, j) * comb(y+d-1,y)))\\n #print( comb(d, j) * comb(y+d-1,y))\\n #print('i ="}
{"id": "414", "input": "class Solution:\\n def breakPalindrome(self, palindrome: str) -> str:\\n if len(palindrome) == 1:\\n return ''\\n for i, val in enumerate(palindrome):\\n if val != 'a' and", "gt": "i != len(palindrome) // 2:\\n return palindrome[:i] + 'a' + palindrome[i+1:]\\n elif val == 'a' and i == len(palindrome) - 1:\\n return palindrome[:-1] + 'b'\\n"}
{"id": "415", "input": "class Solution:\\n def getWinner(self, arr: List[int], k: int) -> int:\\n win=0\\n \\n curr = arr[0]\\n mx=0\\n \\n \\n", "gt": "for i in range(1,len(arr)): \\n if arr[i] > curr:\\n curr=arr[i]\\n win=0\\n \\n win=win+1\\n if win==k:\\n break\\n \\n return curr"}
{"id": "416", "input": "class Solution:\\n def minSwap(self, A: List[int], B: List[int]) -> int:\\n \\n n = len(A)\\n \\n if n == 1:\\n return 0\\n \\n dp = [[float('inf'), float('inf')] for _ in range(n)]\\n dp[0] = [0,1] #[natural, swapped]\\n", "gt": "\\n for i in range(1, n):\\n if A[i-1] < A[i] and B[i-1] < B[i]:\\n dp[i] = [dp[i-1][0], dp[i-1][1]+1]\\n if A[i-1] < B[i] and B[i-1] < A[i]:\\n dp[i] = [min(dp[i][0],dp[i-1][1]), min(dp[i][1],dp[i-1][0]+1)]\\n \\n print(dp)\\n \\n\\n return min(dp[-1])\\n"}
{"id": "417", "input": "class Solution:\\n def catMouseGame(self, graph: List[List[int]]) -> int:\\n N = len(graph)\\n\\n # What nodes could play their turn to\\n # arrive at node (mouse, cat, turn) ?\\n def parents(mouse, cat, turn):\\n prev_turn = 3 - turn\\n if prev_turn == MOUSE: \\n for m2 in graph[mouse]:\\n yield m2, cat, prev_turn\\n else:\\n for c2 in graph[cat]:\\n if c2:\\n yield mouse, c2, prev_turn\\n\\n DRAW, MOUSE, CAT = 0, 1, 2\\n colors = collections.defaultdict(int)\\n\\n # degree[node] : the number of neutral children of this node\\n degree = {}\\n for mouse in range(N):\\n for cat in range(N):\\n degree[mouse, cat, MOUSE] = len(graph[mouse])\\n degree[mouse, cat, CAT] = len(graph[cat]) - (0 in graph[cat]) # cat can not be at hole 0\\n\\n # enqueued : all nodes that are colored\\n queue = collections.deque([])\\n for cat in range(N):\\n for turn in [MOUSE, CAT]:\\n # color MOUSE for all node with mouse=0\\n mouse = 0\\n colors[mouse, cat, turn] = MOUSE\\n queue.append((mouse, cat, turn, MOUSE))\\n # color CAT for all node with mouse = cat !=0, cat can not be", "gt": "at hole 0\\n if cat > 0:\\n mouse = cat\\n colors[mouse, cat, turn] = CAT\\n queue.append((mouse, cat, turn, CAT))\\n\\n # percolate\\n while queue:\\n mouse, cat, turn, color = queue.popleft()\\n for prev_mouse, prev_cat, prev_turn in parents(mouse, cat, turn):\\n # if this parent is not colored :\\n if colors[prev_mouse, prev_cat, prev_turn] is DRAW:\\n # if the parent can make a winning move (ie. mouse to MOUSE), do so\\n if prev_turn == color: # winning move\\n colors[prev_mouse, prev_cat, prev_turn] = color\\n queue.append((prev_mouse, prev_cat, prev_turn, color))\\n if prev_mouse == 1 and prev_cat == 2 and prev_turn == MOUSE: \\n return color\\n # else, this parent has degree[parent]--, and enqueue if all children\\n # of this parent are colored as losing moves\\n else:\\n degree[prev_mouse, prev_cat, prev_turn] -= 1\\n if degree[prev_mouse, prev_cat, prev_turn] == 0:\\n colors[prev_mouse, prev_cat, prev_turn] = 3 - prev_turn\\n queue.append((prev_mouse, prev_cat, prev_turn, 3 - prev_turn))\\n if prev_mouse == 1 and prev_cat == 2 and prev_turn == MOUSE: \\n return color\\n\\n return colors[1, 2, 1] # mouse at 1, cat at 2, MOUSE turn"}
{"id": "418", "input": "class Solution:\\n def findMedianSortedArrays(self, nums1, nums2):\\n \"\"\"\\n :type nums1: List[int]\\n :type nums2: List[int]\\n :rtype: float\\n \"\"\"\\n nums =", "gt": "nums1 + nums2\\n nums.sort()\\n if len(nums) % 2 == 1:\\n return float(nums[len(nums)//2])\\n return (nums[len(nums)//2-1] + nums[len(nums)//2]) / 2"}
{"id": "419", "input": "class Solution:\\n def integerReplacement(self, n):\\n \"\"\"\\n :type n: int\\n :rtype: int\\n \"\"\"\\n '''\\n if n == 1:\\n return 0\\n if not (n & 1):\\n return self.integerReplacement(n//2) + 1\\n return min(self.integerReplacement(n+1), self.integerReplacement(n-1)) + 1\\n '''\\n ans = 0\\n", "gt": "while n > 1:\\n if n % 2 == 0:\\n n = n // 2\\n elif n % 4 == 1 or n == 3:\\n n -= 1\\n else:\\n n += 1\\n ans += 1\\n return ans\\n"}
{"id": "420", "input": "class Solution:\\n def bulbSwitch(self, n):\\n \"\"\"\\n :type n: int\\n :rtype: int\\n", "gt": "\"\"\"\\n if n == 0:\\n return 0\\n else:\\n return int(n**0.5)\\n \\n"}
{"id": "421", "input": "class Solution:\\n def findTheLongestSubstring(self, s: str) -> int:\\n s = s + 'a'\\n bits, dp = {'a':0,'e':1,'i':2,'o':3,'u':4}, {0:-1}\\n res = 0\\n key = 0\\n for i, char in enumerate(s): \\n if", "gt": "char in bits:\\n if key in dp:\\n res = max(res, i-dp[key] - 1)\\n key = key ^ (1 << bits[char])\\n if key not in dp:\\n dp[key] = i\\n return res\\n \\n"}
{"id": "422", "input": "class Solution:\\n def lastSubstring(self, s: str) -> str:\\n #mx = \\\"\\\"\\n #for i in range(len(s)):\\n # mx = max(mx,s[i:])\\n #return mx\\n index = {c: i for i, c in enumerate(sorted(set(s)))}\\n", "gt": "cur, radix, max_val, max_i = 0, len(index), 0, 0\\n for i in range(len(s)-1, -1, -1):\\n cur = index[s[i]] + cur/radix\\n if cur > max_val:\\n max_val, max_i = cur, i\\n return s[max_i:]"}
{"id": "423", "input": "class Solution(object):\\n def longestPalindrome(self, s):\\n \"\"\"\\n :type s: str\\n :rtype: str\\n \"\"\"\\n size = len(s)\\n if size <= 1 or s == s[::-1]:\\n return s\\n start, maxlen = 0, 1\\n for idx in range(1, size):\\n add2 = s[idx - maxlen - 1: idx + 1]\\n if", "gt": "idx - maxlen - 1 >= 0 and add2 == add2[::-1]:\\n start = idx - maxlen - 1\\n maxlen += 2\\n continue\\n add1 = s[idx - maxlen: idx + 1]\\n if add1 == add1[::-1]:\\n start = idx - maxlen\\n maxlen += 1\\n return s[start: (start + maxlen)]"}
{"id": "424", "input": "from collections import defaultdict\\n\\nclass Solution:\\n def longestSubsequence(self, arr: List[int], difference: int) -> int:\\n", "gt": "count_dict = defaultdict(int)\\n for num in arr:\\n count_dict[num] = count_dict[num-difference] + 1\\n return max(count_dict.values())\\n"}
{"id": "425", "input": "class Solution:\\n def largestOverlap(self, A, B) -> int:\\n leng = len(A[0])\\n\\n # convert A, B to binary\\n a = 0\\n b = 0\\n for i in range(0, leng * leng):\\n row = int(i % leng)\\n col = int(i / leng)\\n a = (a << 1) + A[col][row]\\n b = (b << 1) + B[col][row]\\n\\n maxsum = 0\\n for i in range(-leng + 1, leng):\\n if i < 0:\\n mask = ('0' * abs(i) + '1' * (leng - abs(i))) * leng\\n bp =", "gt": "(b & int(mask, 2)) << abs(i)\\n elif i > 0:\\n mask = ('1' * (leng - abs(i)) + '0' * abs(i)) * leng\\n bp = (b & int(mask, 2)) >> abs(i)\\n else:\\n bp = b\\n\\n for j in range(-leng + 1, leng):\\n if j < 0:\\n bpp = bp >> (leng * abs(j))\\n elif j > 0:\\n bpp = (bp << (leng * abs(j))) & ((2 ** (leng * leng)) - 1)\\n else:\\n bpp = bp\\n maxsum = max(maxsum, bin(a & bpp).count('1'))\\n\\n return maxsum"}
{"id": "426", "input": "class Solution:\\n def get_half(self,dividend,divisor):\\n abs_dividend = abs(dividend)\\n abs_divisor = abs(divisor)\\n num = divisor\\n num_temp=0\\n result=1\\n result_temp=0\\n while (num<=dividend):\\n num_temp=num\\n num+=num\\n result_temp=result\\n result+=result\\n return num_temp,result_temp\\n \\n def divide(self, dividend, divisor):\\n \"\"\"\\n :type dividend: int\\n :type divisor: int\\n :rtype: int\\n \"\"\"\\n MAX_INT = 2147483647\\n if divisor", "gt": "== 0:\\n return MAX_INT\\n abs_dividend = abs(dividend)\\n abs_divisor = abs(divisor)\\n if abs_dividend <abs_divisor:\\n return 0\\n minus_flag = (dividend is abs_dividend) is (divisor is abs_divisor)\\n final_result=0\\n while(abs_dividend>=abs_divisor):\\n num,result=self.get_half(abs_dividend,abs_divisor)\\n abs_dividend-=num\\n final_result+=result\\n \\n if minus_flag==1:\\n if final_result>MAX_INT:\\n return MAX_INT\\n return final_result\\n else:\\n if 0-final_result<0-MAX_INT-1:\\n return 0-MAX_INT\\n return 0-final_result"}
{"id": "427", "input": "class Solution:\\n def reorderedPowerOf2(self, n: int) -> bool:\\n \\n n_len = len(str(n))\\n n = Counter(str(n))\\n \\n p = 1\\n", "gt": "while len(str(p)) <= n_len:\\n if len(str(p)) == n_len and Counter(str(p)) == n:\\n return True\\n p *= 2\\n \\n return False"}
{"id": "428", "input": "class Solution:\\n def countOrders(self, n: int) -> int:\\n \\n if n == 1:\\n return 1\\n \\n \\n p = (n-1)*2+1\\n \\n dp = [0 for", "gt": "i in range(n+1)]\\n dp[1] = 1\\n M= 10**9+7\\n for i in range(2,n+1):\\n \\n p = (i-1)*2+1\\n \\n dp[i] = (dp[i-1]%M * ((p*(p+1))//2)%M)%M\\n \\n return dp[n]\\n"}
{"id": "429", "input": "import heapq\\nfrom collections import deque, defaultdict\\nclass Solution:\\n def shortestPathAllKeys(self, grid: List[str]) -> int:\\n m,n = len(grid),len(grid[0])\\n key_lock_loc = {ch:(i,j) for i,row in enumerate(grid) for j,ch in enumerate(row) if ch not in {'.','#'}}\\n key_cnt = sum(key_lock in ('a','b','c','d','e','f')for key_lock in key_lock_loc)\\n \\n def bfs_from(src):\\n i,j = key_lock_loc[src]\\n seen = defaultdict(lambda: False)\\n seen[i,j] = True\\n # only locations which are not wall will be put into the queue\\n dque = deque([(i,j,0)]) \\n dist = {}\\n while dque:\\n i,j,d = dque.popleft()\\n ch = grid[i][j]\\n if ch != src and ch != '.': # reaches lock or key\\n dist[ch] = d\\n continue\\n # '#' or '.'\\n for x,y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)):\\nif not (0<=x<m and 0<=y<n) or grid[x][y] == '#' or seen[x,y]:\\n continue\\n seen[x,y] = True\\n dque.append((x,y,d+1))\\n return dist\\n \\n dists = {key_lock:bfs_from(key_lock) for key_lock", "gt": "in key_lock_loc}"}
{"id": "430", "input": "class Solution:\\n def getHint(self, secret, guess):\\n \"\"\"\\n :type secret: str\\n :type guess: str\\n :rtype: str\\n \"\"\"\\n s_count = collections.defaultdict(int)\\n g_count = collections.defaultdict(int)\\n bull_cnt = 0\\n # first iteration can get bull_cnt immediately\\n for s, g in zip(secret, guess):\\n if s == g: bull_cnt += 1\\n # keep two", "gt": "counters for non matching chars \\n else:\\n s_count[s] += 1\\n g_count[g] += 1\\n # if char in both s_count and g_count, the min of the two is the cow_cnt for this char \\n cow_cnt = sum(min(s_count[x], g_count[x]) for x in g_count if x in s_count) \\n return \""}
{"id": "431", "input": "class Solution:\\n def distinctSubseqII(self, s: str) -> int:\\n n = len(s)\\n MOD = 10**9 + 7\\n seen = dict()\\n \\n a = 1\\n for i in range(n):\\n char", "gt": "= s[i]\\n b = 2 * a\\n if char in seen:\\n b -= seen[char]\\n \\n b %= MOD\\n seen[char] = a\\n a = b\\n return a - 1\\n \\n"}
{"id": "432", "input": "class Solution:\\n def sumSubarrayMins(self, A: List[int]) -> int:\\n stack = []\\n result = 0\\n A = [0] + A + [0]\\n\\n for i, x in enumerate(A):\\n", "gt": "while stack and x < A[stack[-1]]:\\n j = stack.pop()\\n result += A[j] * (i - j) * (j - stack[-1])\\n stack.append(i)\\n\\n return result % (10**9 + 7)\\n"}
{"id": "433", "input": "class Solution:\\n def isPossibleDivide(self, s: List[int], k: int) -> bool:\\n if len(s) % k != 0:\\n return False\\n \\n ctr = collections.Counter(s)\\n \\n for _ in range(len(s) // k):\\n mn = []\\n for i in ctr:\\n if mn == [] and ctr[i] > 0:\\n mn = [i]\\n elif ctr[i] > 0:\\n if i < mn[0]:\\n mn", "gt": "= [i]\\n\\n for i in range(k):\\n ctr[mn[0] + i] -= 1\\n if ctr[mn[0] + i] < 0:\\n return False\\n \\n return True\\n \\n def isPossibleDivide(self, s: List[int], k: int) -> bool:\\n \\n c = [0]*k # keeps count\\n if s == [2,4,6]: return False\\n for n in s:\\n c[n % k] += 1\\n return len(set(c)) == 1"}
{"id": "434", "input": "class Solution:\\n def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:\\n if len(arr) < k:\\n return 0\\n bar = k * threshold\\n total = 0\\n window = sum(arr[:k])\\n", "gt": "if window >= bar:\\n total += 1\\n for i in range(k, len(arr)):\\n window -= arr[i - k]\\n window += arr[i]\\n if window >= bar:\\n total += 1\\n return total"}
{"id": "435", "input": "class Solution:\\n def longestSubarray(self, nums: List[int]) -> int:\\n if not 0 in nums:\\n return len(nums) - 1\\n ans = 0\\n tot = 0\\n prev = 0\\n", "gt": "\\n for n in nums:\\n if n == 1:\\n tot += 1\\n else:\\n ans = max(tot+prev, ans)\\n prev = tot\\n tot = 0\\n return max(prev+tot, ans)\\n \\n"}
{"id": "436", "input": "# Calculate the prefix sum and count it.\\n# In c++ and java, a % K + K takes care of the cases where a < 0.\\n# Python\\n\\nclass Solution: \\n def subarraysDivByK(self, A, K):\\n res = 0\\n prefix = 0\\n count = [1] + [0] * K\\n for a in A:\\n prefix = (prefix + a) % K\\n res += count[prefix]\\n count[prefix] += 1\\n return res\\n \\n# If a subarray is divisible by K, it has to be a multiple of K\\n\\n# a-b=n*k, a = running total, b = any previous subarray sum, same as original prefix sum problems.\\n\\n# We want", "gt": "to solve for b, so using basic algebra, b=a-n*k\\n\\n# We don't know what n is, so we can get rid of n by modding every element by k\\n# (b%k) = (a%k) - (n*k)%k\\n\\n# since n*k is a multiple of k and k goes into it evenly, the result of the (n *k)%k will be 0\\n\\n# therefore\\n# b%k = a%k\\n\\n# is the same as the formula we defined earlier, a-b=n*k\\n\\n# where b = running total, a = any previous subarray sum\\n\\n# So we just have to see if running total mod k is equal to any previous running total mod k\\n"}
{"id": "437", "input": "import functools\\nclass Solution:\\n @functools.lru_cache()\\n def minDays(self, n: int) -> int:\\n if n <=", "gt": "1:\\n return n\\n \\n return 1 + min(n%2 + self.minDays(n//2), n%3 + self.minDays(n//3))\\n \\n"}
{"id": "438", "input": "class Solution:\\n def decodeAtIndex(self, S: str, K: int) -> str:\\n size = 0\\n # Find size = length of decoded string\\n for c in S:\\n if c.isdigit():\\n size *=", "gt": "int(c)\\n else:\\n size += 1\\n for c in reversed(S):\\n K %= size\\n if K == 0 and c.isalpha():\\n return c\\n\\n if c.isdigit():\\n size /= int(c)\\n else:\\n size -= 1\\n"}
{"id": "439", "input": "class Solution:\\n def findLatestStep(self, arr: List[int], m: int) -> int:\\n A = arr\\n if m == len(A): \\n return m\\n length = [0] * (len(A) + 2)\\n res = -1\\n for i, a in enumerate(A):\\n", "gt": "left, right = length[a - 1], length[a + 1]\\n if left == m or right == m:\\n res = i\\n length[a - left] = length[a + right] = left + right + 1\\n return res"}
{"id": "440", "input": "class Solution:\\n def maxTurbulenceSize(self, A: List[int]) -> int:\\n if len(A) == 1: return 1\\n prev = A[1]\\n maxcount = count = 1 + int(A[0] != A[1])\\n print(count)\\n lastcomp = A[0] < A[1]\\n \\n for a", "gt": "in A[2:]:\\n comp = prev < a\\n if prev == a:\\n count = 0\\n elif comp == lastcomp:\\n count = 1\\n lastcomp = comp\\n count += 1\\n maxcount = max(maxcount, count)\\n prev = a\\n return maxcount"}
{"id": "441", "input": "class Solution:\\n def mirrorReflection(self, p: int, q: int) -> int:\\n while p % 2 == 0 and q % 2 == 0:\\n p = p // 2\\n q = q // 2\\n", "gt": "if p % 2 == 1 and q % 2 == 0:\\n return 0\\n elif p % 2 == 1 and q % 2 == 1:\\n return 1\\n else :\\n return 2"}
{"id": "442", "input": "class Solution:\\n def consecutiveNumbersSum(self, N: int) -> int:\\n res = 1\\n \\n # Remove all even factors\\n while N % 2 == 0:\\n N //= 2\\n \\n # Count all odd factors\\n idx = 3 \\n while idx * idx <=", "gt": "N:\\n count = 0\\n \\n # found an odd factor\\n while N % idx == 0:\\n N //= idx\\n count += 1\\n \\n res *= count + 1\\n idx += 2\\n \\n return res if N == 1 else res * 2"}
{"id": "443", "input": "class Solution:\\n def minSwaps(self, grid: List[List[int]]) -> int:\\n start=1\\n swap=0\\n n=len(grid)\\n zeros_ingrid=n-1\\n while zeros_ingrid>0:\\n swapped_grid=False\\n for i in range(len(grid)):\\n", "gt": "if sum(grid[i][start:])==0:\\n swap+=i\\n grid.remove(grid[i])\\n swapped_grid=True\\n zeros_ingrid-=1\\n start+=1\\n break\\n if not swapped_grid:\\n return -1\\n return swap\\n \\n \\n \\n \\n"}
{"id": "444", "input": "class Solution:\\n def increment_index(self, nums, index):\\n index += 1\\n while index < len(nums):\\n nums[index] += 1\\n index += (index & -index)\\n\\n def prefix_sum(self, nums, index):\\n index += 1\\n current_sum = 0\\n while index > 0:\\n current_sum += nums[index]\\n index -= (index & -index)\\n return current_sum\\n\\n def numTeams(self, rating):\\n if len(rating) < 3:\\n return 0\\n\\n n = len(rating)\\n sorted_nums = rating.copy()\\n sorted_nums.sort()\\n\\n index = {}\\n for i in range(n):\\n index[sorted_nums[i]] = i\\n\\n fenwick_tree = [0] * (len(sorted_nums) + 1)\\n\\n lesser_before =", "gt": "[0] * n\\n for i in range(n):\\n rate_i = rating[i]\\n index_i = index[rate_i]\\n lesser_before[i] = self.prefix_sum(fenwick_tree, index_i)\\n self.increment_index(fenwick_tree, index[rating[i]])\\n\\n for i in range(len(fenwick_tree)):\\n fenwick_tree[i] = 0\\n\\n lesser_after = [0] * n\\n for i in range(n - 1, -1, -1):\\n rate_i = rating[i]\\n index_i = index[rate_i]\\n lesser_after[i] = self.prefix_sum(fenwick_tree, index_i)\\n self.increment_index(fenwick_tree, index[rating[i]])\\n\\n num_teams = 0\\n for i in range(n - 1):\\n num_teams += lesser_before[i] * (n - 1 - i - lesser_after[i])\\n num_teams += (i - lesser_before[i]) * lesser_after[i]\\n\\n return num_teams\\n"}
{"id": "445", "input": "class Solution:\\n def nthPersonGetsNthSeat(self, n: int) ->", "gt": "float:\\n return 1 / min(n, 2.0) \\n \\n"}
{"id": "446", "input": "class Solution:\\n def minDifference(self, nums: List[int]) -> int:\\n if len(nums) <= 4:\\n return 0\\n else:\\n # nums = sorted(nums)\\n nums.sort()\\n threeZero", "gt": "= nums[-1] - nums[3]\\n twoOne = nums[-2] - nums[2]\\n oneTwo = nums[-3] - nums[1]\\n zeroThree = nums[-4] - nums[0]\\n return min(threeZero,twoOne,oneTwo,zeroThree)"}
{"id": "447", "input": "# O(n) time and space\\n# Hashmap and array\\n# Count number then count occurrence:\\n# Count the occurrences of each number using HashMap;\\n# Keep a count of different occurences\\n# From small to big, for each unvisited least frequent element, deduct from k the multiplication with the number of elements of same occurrence, check if reaching 0, then deduct the corresponding unique count remaining.\\nclass", "gt": "Solution:\\n def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\\n freq = collections.Counter(arr)\\n distinct = len(freq)\\n freq_count = collections.Counter(list(freq.values()))\\n \\n idx = 1\\n while k>0:\\n if k - idx*freq_count[idx] >= 0:\\n k -= idx*freq_count[idx]\\n distinct -= freq_count[idx]\\n idx += 1\\n else:\\n # can't remove all, but can remove partially\\n # [2,4,1,8,3,5,1,3], 3\\n return distinct - k // idx\\n return distinct\\n \\n \\n"}
{"id": "448", "input": "class Solution:\\n def removeDuplicateLetters(self, s):\\n \"\"\"\\n :type s: str\\n :rtype: str\\n \"\"\"\\n rindex = {c: i for i, c in enumerate(s)}\\n result = ''\\n for", "gt": "i, c in enumerate(s):\\n if c not in result:\\n while c < result[-1:] and i < rindex[result[-1]]:\\n result = result[:-1]\\n result += c\\n return result"}
{"id": "449", "input": "class Solution:\\n def checkSubarraySum(self, nums, k):\\n \"\"\"\\n :type nums: List[int]\\n :type k: int\\n :rtype: bool\\n \"\"\"\\n if k==0:\\n j=0\\n for i in range(0,len(nums)):\\n if nums[i]==0:\\n if", "gt": "j<i:\\n return True\\n else:\\n j=i+1\\n return False\\n dic="}
{"id": "450", "input": "class Solution:\\n def findMin(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n if len(nums) <= 3:\\n return min(nums)\\n lo = 0\\n hi = len(nums) - 1\\n mid = (hi + lo) // 2\\n if nums[mid] < nums[mid-1]", "gt": "and nums[mid] < nums[mid+1]:\\n return nums[mid]\\n if nums[mid] > nums[lo] and nums[mid] > nums[hi]:\\n # pivot on the right side\\n return self.findMin(nums[mid:])\\n #elif nums[mid] < nums[lo] and nums[mid] < nums[hi]:\\n else:\\n #pivot on the left side\\n return self.findMin(nums[:mid+1])"}
{"id": "451", "input": "class Solution:\\n def validUtf8(self, data):\\n \"\"\"\\n :type data: List[int]\\n :rtype: bool\\n \"\"\"\\n count=0\\n for x in data:\\n if count==0:\\n if x>>5==0b110:\\n count=1\\n elif x>>4==0b1110:\\n count=2\\n elif x>>3==0b11110:\\n count=3\\n elif x>>7==1:\\n return False\\n else:\\n if x>>6!=0b10:\\n return False\\n count-=1\\n return count==0\\n \\n \\n # class Solution {\\n # public:\\n # bool validUtf8(vector<int>& data) {\\n # int cnt = 0;\\n # for (int d : data) {\\n # if (cnt ==0) {\\n # if ((d >> 5)", "gt": "== 0b110) cnt = 1;"}
{"id": "452", "input": "import math\\nclass Solution:\\n def isRationalEqual(self, S: str, T: str) -> bool:\\n if len(S) == 0 or len(T) == 0:\\n return False\\n def process(s):\\n if s[-1] == '.':\\n s = s[:-1]\\n stack, repeat_9 = [], False\\n for i, x in enumerate(s):\\n if x != ')':\\n stack.append(x)\\n else:\\n tmp = ''\\n while stack[-1] != '(':\\n tmp += stack.pop()\\n if len(tmp) == tmp.count('9'):\\n repeat_9 =", "gt": "True\\n stack.pop()\\n return ''.join(stack) + tmp[::-1] * (24 // len(tmp)), repeat_9\\n return ''.join(stack), repeat_9\\n \\n x, y = process(S), process(T)\\n if x[0].count('.') == 0 or y[0].count('.') == 0:\\n return float(x[0]) == float(y[0])\\n l = max(len(x[0]), len(y[0]))\\n if x[0][:17] == y[0][:17]:\\n return True\\n if x[1] or y[1]:\\n m = min(len(x[0].split('.')[1]), len(y[0].split('.')[1]))\\n if round(float(x[0]), m) == round(float(y[0]), m):\\n return True\\n \\n return False\\n \\n"}
{"id": "453", "input": "class Solution:\\n def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\\n N = len(jobDifficulty)\\n if N < d: \\n return -1\\n \\n dp = [jobDifficulty[0]]\\n for j in jobDifficulty[1:]:\\n dp.append(max(dp[-1], j))\\n\\n for i in range(1, d):\\n \\n dp_curr = [0] * N\\n \\n stack =", "gt": "[]\\n for j in range(i, N):\\n dp_curr[j] = dp[j - 1] + jobDifficulty[j]\\n \\n while stack and jobDifficulty[stack[-1]] <= jobDifficulty[j]:\\n dp_curr[j] = min(dp_curr[j], dp_curr[stack[-1]] - jobDifficulty[stack[-1]] + jobDifficulty[j])\\n stack.pop()\\n \\n if stack:\\n dp_curr[j] = min(dp_curr[j], dp_curr[stack[-1]]) \\n stack.append(j)\\n \\n dp = dp_curr\\n return dp[-1]"}
{"id": "454", "input": "class Solution:\\n def minCost(self, houses: List[int], Cost: List[List[int]], m: int, n: int, target: int) -> int:\\n @lru_cache(None)\\n def dfs(i, j, k):\\n if i == len(houses):\\n if j == target:\\n return 0\\n else:\\n return float('inf')\\n \\n if houses[i] != 0:\\n return dfs(i + 1, int(houses[i] != k)", "gt": "+ j, houses[i])\\n \\n cost = float('inf')\\n for index, c in enumerate(Cost[i]):\\n cost = min(cost, dfs(i + 1, int(index + 1 != k) + j, index + 1) + c)\\n \\n return cost\\n \\n return dfs(0, 0, 0) if dfs(0, 0, 0) != float('inf') else -1\\n \\n"}
{"id": "455", "input": "class Solution:\\n def maximumSwap(self, num):\\n \"\"\"\\n :type num: int\\n :rtype: int\\n \"\"\"\\n s = str(num)\\n nums = [int(_) for _ in s]\\n dp = [-1]*len(nums)\\n for i in range(len(nums)-1,-1,-1):\\n if i==len(nums)-1:\\n dp[i] = i\\n else:\\n dp[i] = i if nums[i]>nums[dp[i+1]] else dp[i+1]\\n \\n for i", "gt": "in range(len(nums)):\\n if nums[i] != nums[dp[i]]:\\n nums[i],nums[dp[i]] = nums[dp[i]],nums[i]\\n break\\n res = 0\\n for num in nums:\\n res = res*10 + num\\n return res\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n"}
{"id": "456", "input": "from collections import deque\\n\\nclass Solution:\\n def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n grids = targetGrid\\n num_to_range = dict()\\n for i, row in enumerate(targetGrid):\\n for j, val in enumerate(row):\\n if val not in num_to_range:\\n # up, down, left, right\\n num_to_range[val] = [i, i, j, j]\\n num_to_range[val][0] = min(num_to_range[val][0], i)\\n num_to_range[val][1] = max(num_to_range[val][1], i)\\n num_to_range[val][2] = min(num_to_range[val][2], j)\\n num_to_range[val][3] = max(num_to_range[val][3], j)\\n #print(num_to_range)\\n \\n m = len(grids)\\n n = len(grids[0])\\n grid_list = [[list() for j in range(n)] for i in range(m)]\\n for num, val in list(num_to_range.items()):\\n for i in range(val[0], val[1]+1):\\n for j in range(val[2], val[3]+1):\\ngrid_list[i][j].append(num)\\n\\n paths = {val: set() for", "gt": "val in list(num_to_range)}"}
{"id": "457", "input": "class Solution:\\n def canCross(self, stones):\\n \"\"\"\\n :type stones: List[int]\\n :rtype: bool\\n \"\"\"\\n if stones == []: return False\\n if len(stones) == 1: return True\\n diff = [0]*len(stones)\\n \\n for i in range(1,len(stones)):\\n if stones[i] - stones[i-1] > i: return False\\n \\n stk = [(0, 0)]\\n dictt", "gt": "="}
{"id": "458", "input": "class Solution:\\n def coinChange(self, coins: List[int], amount: int) -> int:\\n coins.sort(reverse=True)\\n n, res = len(coins), amount + 1\\n\\n def dfs(index, target, cnt):\\n nonlocal res\\n if cnt + (target + coins[index] - 1) // coins[index] >= res:\\n return\\n\\n if target % coins[index] == 0:\\n res", "gt": "= cnt + target // coins[index]\\n return\\n\\n if index == n - 1:\\n return\\n\\n for i in range(target // coins[index], -1, -1):\\n dfs(index + 1, target - coins[index] * i, cnt + i)\\n\\n dfs(0, amount, 0)\\n return -1 if res > amount else res"}
{"id": "459", "input": "class Solution:\\n def minSubarray(self, nums: List[int], p: int) -> int:\\n need = sum(nums) % p\\n if need == 0:\\n return 0\\n pos = {0: -1}\\n total = 0\\n ans = float('inf')\\n for i, num in", "gt": "enumerate(nums):\\n total = (total + num) % p\\n target = (total - need) % p\\n if target in pos:\\n ans = min(ans, i - pos[target])\\n pos[total] = i\\n return ans if ans < len(nums) else -1"}
{"id": "460", "input": "class Solution:\\n def characterReplacement(self, s, k):\\n \"\"\"\\n :type s: str\\n :type k: int\\n :rtype: int\\n \"\"\"\\n if s == \"\":\\n return 0\\n count = {}\\n lo = 0\\n hi = 0\\n max_letter = 0\\n for hi in range(len(s)):\\n try:\\n count[s[hi]] +=", "gt": "1\\n except:\\n count[s[hi]] = 1\\n if count[s[hi]] > max_letter:\\n max_letter = count[s[hi]]\\n if max_letter < hi - lo + 1 - k:\\n if max_letter == count[s[lo]]:\\n max_letter -= 1\\n count[s[lo]] -= 1\\n lo += 1\\n return hi - lo + 1"}
{"id": "461", "input": "class Solution:\\n def arrayNesting(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n best = 0\\n n = len(nums)\\n p = []\\n for i in range(len(nums)):\\n j = i\\n current =", "gt": "0\\n while nums[j] != -1:\\n current += 1\\n n -= 1\\n k = j\\n j = nums[j]\\n nums[k] = -1\\n best = max(best,current)\\n if n <= best:\\n return best\\n return best\\n"}
{"id": "462", "input": "class Solution:\\n def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n def dfs(i):\\n", "gt": "if manager[i] != -1:\\n informTime[i] += dfs(manager[i])\\n manager[i] = -1\\n return informTime[i]\\n return max(list(map(dfs, manager)))\\n \\n \\n"}
{"id": "463", "input": "#[Runtime: 452 ms, faster than 97.27%] Hash\\n#O(MN)\\n#1. traverse all cells and mark server as (x, y)\\n#2. put each server (x, y) into serveral bucket named x1, x2, .., and y1, y2, ..\\n# e.g. each xbucket[x1] maintains the number of servers on line x1\\n#3. enumerate all server (x', y'), and see if there is at least 2", "gt": "server on xbucket[x'] or ybucket[y'] \\nclass Solution:\\n def countServers(self, grid: List[List[int]]) -> int:\\n xbucket, ybucket, server = [0] * len(grid), [0] * len(grid[0]), []\\n for x, row in enumerate(grid):\\n for y, cell in enumerate(row):\\n if cell:\\n server.append((x, y))\\n xbucket[x] += 1\\n ybucket[y] += 1\\n return sum(xbucket[x] > 1 or ybucket[y] > 1 for x, y in server)"}
{"id": "464", "input": "class Solution:\\n def maxValueAfterReverse(self, nums: List[int]) -> int:\\n n = len(nums)\\n base = sum([abs(nums[i] - nums[i+1]) for i in range(n - 1)])\\n if (n <= 2):\\n return base\\n \\n #best = base\\n #for i in range(n-1):\\n # for j in range(i+1, n):\\n # guess = switch(nums, i, j, base)\\n # if guess > best:\\n # best = guess\\n \\n inds = sorted(list(range(n)), key=lambda x: nums[x])\\n return base + max(options(inds, nums))\\n \\n \\ndef switch(nums, i, j, base=0):\\n i_inc = ((abs(nums[j] - nums[i-1]) - abs(nums[i] - nums[i-1])) if (i > 0) else 0)\\n j_inc = ((abs(nums[j+1] - nums[i]) - abs(nums[j+1] - nums[j]))", "gt": "if (j < len(nums) - 1) else 0)\\n return base + i_inc + j_inc\\n \\n \\n\\ndef options(inds, nums):\\n a,b = findRange(inds)\\n d,c = findRange(inds[::-1])\\n yield 0\\n yield 2 * (nums[c] - nums[b])\\n\\n i = max(a, b)\\n j = max(c, d)\\n n = len(nums)\\n yield switch(nums, i, n-1)\\n yield switch(nums, j, n-1)\\n \\n yield switch(nums, 0, i-1)\\n yield switch(nums, 0, j-1)\\n \\n \\n \\n \\n\\ndef findRange(inds):\\n seen = set()\\n for i, idx in enumerate(inds):\\n if (idx + 1) in seen or (idx - 1) in seen:\\n return (idx + 1, idx) if (idx + 1) in seen else (idx-1, idx)\\n seen.add(idx)\\n \\n"}
{"id": "465", "input": "class Solution:\\n def minOperations(self, n:", "gt": "int) -> int:\\n return (n*n)>>2\\n \\n"}
{"id": "466", "input": "class Solution:\\n def minCut(self, s):\\n \"\"\"\\n :type s: str\\n :rtype: int\\n \"\"\"\\n # acceleration\\n if s == s[::-1]: return 0\\n if any(s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1] for i in range(1, len(s))): return 1\\n # algorithm\\n cut = [x for x in range(-1,len(s))] # cut numbers in worst case (no palindrome)\\n for i in range(len(s)):\\n r1, r2 =", "gt": "0, 0\\n # use i as origin, and gradually enlarge radius if a palindrome exists\\n # odd palindrome\\n while r1 <= i < len(s)-r1 and s[i-r1] == s[i+r1]:\\n cut[i+r1+1], r1 = min(cut[i+r1+1], cut[i-r1]+1), r1 + 1\\n # even palindrome\\n while r2 <= i < len(s)-r2-1 and s[i-r2] == s[i+r2+1]:\\n cut[i+r2+2], r2 = min(cut[i+r2+2], cut[i-r2]+1), r2 + 1\\n return cut[-1]"}
{"id": "467", "input": "class Solution:\\n def maskPII(self, S: str) -> str:\\n if '@' in S:\\n name, domain = S.split('@')\\n return name[0].lower() + '*****' + name[-1].lower() + '@' + domain.lower()\\n else:\\n number", "gt": "= ''\\n for c in S:\\n if c.isdigit():\\n number += c\\n if len(number) == 10:\\n return '***-***-' + number[-4:]\\n else:\\n return '+' + '*'*(len(number)-10) + '-***-***-' + number[-4:]\\n \\n"}
{"id": "468", "input": "# 1390. Four Divisors\\n# version 2, with optimized prime-finding.\\n\\nimport math\\n\\ndef remove (lst, index):\\n assert lst\\n tail = len (lst) - 1\\n lst[index], lst[tail] = lst[tail], lst[index]\\n lst.pop ()\\n\\ndef swap_min (lst):\\n if not lst: return\\n argmin = min (range (len (lst)), key = lambda i: lst[i])\\n lst[0], lst[argmin] = lst[argmin], lst[0]\\n\\ndef find_primes (top):\\n candidates = list (range (2, top))\\n primes = []\\n while candidates:\\n # here, candidates[0] is the least element.\\n latest_prime = candidates[0]\\n primes.append (latest_prime)\\n remove (candidates, 0)\\n for i in range (len (candidates) - 1, -1, -1):\\n if candidates[i] % latest_prime == 0:\\n remove (candidates, i)\\n\\n swap_min (candidates)\\n # before continuing, set candidates[0] to be the least element.\\n return primes\\n\\ndef find_prime_factor (n, primes):\\n for p in primes:\\n if n % p ==", "gt": "0:\\n return p\\n\\ndef div4 (n, primes, setprimes):\\n if n <= 3:\\n return 0\\n elif n in setprimes:\\n return 0\\n else:\\n p1 = find_prime_factor (n, primes)\\n if p1 is None:\\n return 0\\n p2 = find_prime_factor (n // p1, primes)\\n if p2 is None:\\n p2 = n // p1\\n if p1 * p2 == n and p1 != p2:\\n # success\\n return (1 + p1) * (1 + p2)\\n elif p1 ** 3 == n:\\n # success\\n return (1 + p1) * (1 + p1**2)\\n else:\\n return 0\\n\\ndef sum_four_divisors (arr):\\n top = math.ceil (math.sqrt (max (arr) + 5))\\n primes = find_primes (top)\\n setprimes = set (primes)\\n return sum (div4 (elem, primes, setprimes) for elem in arr)\\n\\nclass Solution:\\n def sumFourDivisors(self, nums: List[int]) -> int:\\n return sum_four_divisors(nums)"}
{"id": "469", "input": "class Solution:\\n def fractionToDecimal(self, numerator, denominator):\\n \"\"\"\\n :type numerator: int\\n :type denominator: int\\n :rtype: str\\n \"\"\"\\n if numerator*denominator < 0:\\n add_negative = True\\n else:\\n add_negative = False\\n numerator, denominator = abs(numerator), abs(denominator)\\n \\n integer_part = int(numerator//denominator)\\n new_numerator = numerator-integer_part*denominator\\n dict_residuals = {}\\n digit_location = 0\\n digit_array = []\\n residual = new_numerator\\n if residual == 0:\\n if add_negative:\\n return \"-\"+str(integer_part)\\n else:\\n return str(integer_part)\\n is_repeating = True\\n dict_residuals[residual]", "gt": "= 0\\n while True:\\n new_digit, residual = self.single_digit(residual, denominator)\\n digit_location += 1\\n if residual == 0:\\n dict_residuals[residual] = digit_location\\n digit_array.append(str(new_digit))\\n is_repeating = False\\n break\\n elif residual in dict_residuals.keys():\\n digit_array.append(str(new_digit))\\n is_repeating = True\\n break\\n else:\\n dict_residuals[residual] = digit_location\\n digit_array.append(str(new_digit))\\n \\n if not is_repeating:\\n result = str(integer_part)+\".\"+\"\".join(digit_array)\\n else:\\n loc = dict_residuals[residual]\\n result = str(integer_part)+\".\"+\"\".join(digit_array[0:loc])+\"(\"+\"\".join(digit_array[loc:])+\")\"\\n if add_negative:\\n return \"-\"+result\\n else:\\n return result\\n \\n def single_digit(self, value, denominator):\\n return int((10*value)//denominator), (10*value)%denominator"}
{"id": "470", "input": "class Solution:\\n def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\\n \\n leftset, rightset = set(leftChild), set(rightChild)\\n roots = []\\n for i in range(n):\\n if i not in leftset and i not in rightset: \\n roots.append(i)\\n if", "gt": "len(roots) > 1: return False\\n if not roots: return False\\n root = roots[0]\\n \\n nodes = []\\n def dfs(root):\\n if root == -1: return \\n if len(nodes) > n: return\\n nodes.append(root)\\n dfs(leftChild[root])\\n dfs(rightChild[root])\\n dfs(root)\\n return len(nodes) == n"}
{"id": "471", "input": "class Solution:\\n def threeSumMulti(self, A: List[int], target: int) -> int:\\n counter = collections.Counter(A)\\n i, res, l, ckey = 0, 0, len(counter), sorted(list(counter.keys()))\\n if target % 3 == 0:\\n res += math.comb(counter[target // 3], 3)\\n for i in range(l):\\n ni = ckey[i]\\n nk = target - (2 * ni)\\n if ni != nk and nk >= 0:\\n res += math.comb(counter[ni], 2) * counter[nk]\\n for i in range(l):\\n for j in range(i + 1, l):\\n ni, nj = ckey[i], ckey[j]\\n nk = target - ni - nj\\n if ni < nj < nk <= 100:\\n res += counter[ni] * counter[nj] * counter[nk]\\n return res % (10**9 + 7)\\n", "gt": "# while i < l:\\n # j = i\\n # while j < l:\\n # ni, nj = ckey[i], ckey[j]\\n # nk = target - ni - nj\\n # if ni == nk == nj:\\n # res += math.comb(counter[ni], 3)\\n # elif nj == nk:\\n # res += math.comb(counter[nj], 2) * counter[ni]\\n # elif ni == nk:\\n # res += math.comb(counter[nk], 2) * counter[nj]\\n # elif ni == nj:\\n # res += math.comb(counter[ni], 2) * counter[nk]\\n # else:\\n # res += counter[ni] * counter[nj] * counter[nk]\\n # print(ni, nj, nk, res)\\n # j += 1\\n # i += 1\\n # return res % (10**9 + 7)\\n"}
{"id": "472", "input": "class Solution:\\n def expandIsland(self, grid, i, j):\\n edges = [(i, j)]\\n while edges:\\n next_edges = []\\n for edge in edges:\\n ei, ej = edge\\n if ei >= 0 and ei < len(grid) and ej >= 0 and ej < len(grid[ei]) and grid[ei][ej] == '1':\\n grid[ei][ej] = '2'\\n next_edges.append((ei + 1,", "gt": "ej))\\n next_edges.append((ei, ej + 1))\\n next_edges.append((ei - 1, ej))\\n next_edges.append((ei, ej - 1))\\n edges = next_edges\\n \\n def numIslands(self, grid):\\n \"\"\"\\n :type grid: List[List[str]]\\n :rtype: int\\n \"\"\"\\n island_count = 0\\n for i in range(len(grid)):\\n for j in range(len(grid[i])):\\n if grid[i][j] == '1':\\n island_count += 1\\n self.expandIsland(grid, i, j)\\n return island_count"}
{"id": "473", "input": "class Solution:\\n def canReach(self, arr: List[int], start: int) -> bool:\\n \\n dq = collections.deque([start])\\n visited = set([start])\\n \\n while dq:\\n \\n curr = dq.pop()\\n \\n if arr[curr] == 0:\\n return True\\n \\n if (curr + arr[curr])", "gt": "not in visited and (curr + arr[curr]) < len(arr):\\n dq.appendleft(curr + arr[curr])\\n visited.add(curr + arr[curr])\\n if (curr - arr[curr]) not in visited and (curr - arr[curr]) >= 0:\\n dq.appendleft(curr - arr[curr])\\n visited.add(curr - arr[curr])\\n \\n return False"}
{"id": "474", "input": "class Solution:\\n def countTriplets(self, arr: List[int]) -> int:\\n n = len(arr)\\n res = xors = 0\\n freq = collections.defaultdict(int, {0:1})\\n _sum = collections.defaultdict(int)\\n", "gt": "for i in range(n):\\n xors ^= arr[i]\\n res += freq[xors] * i - _sum[xors]\\n freq[xors] += 1\\n _sum[xors] += i+1\\n \\n return res\\n \\n"}
{"id": "475", "input": "class Solution:\\n def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n let=Counter(letters)\\n sc={}\\n for i in range(26):\\n sc[chr(i+ord('a'))]=score[i]\\n word={}\\n for w in words:\\n word[w]=Counter(w)\\n self.ans=0\\n used=[]\\n def run(x,cur,let):\\n if x==len(words):\\n return\\n for i in range(x,len(words)):\\n if", "gt": "i not in used:\\n tmp=dict(let)\\n bx=True\\n d=0\\n for k,v in word[words[i]].items():\\n if k not in let:\\n bx=False\\n break\\n let[k]-=v\\n d+=(sc[k]*v)\\n if let[k]<0:\\n bx=False\\n break\\n if bx:\\n used.append(i)\\n run(i+1,cur+d,let)\\n if cur+d>self.ans:\\n self.ans=max(self.ans,cur+d)\\n used.pop()\\n let=tmp\\n let=tmp\\n run(0,0,let)\\n return self.ans"}
{"id": "476", "input": "class Solution:\\n def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\\n # B: partial sum of A\\n # C: partial sum of B\\n # Use prefix sum to precompute B and C\\n A = nums\\n B, C = [0] * (n + 1), [0] * (n + 1)\\n for i in range(n):\\n B[i + 1] = B[i] + A[i]\\n C[i + 1] = C[i] + B[i + 1]\\n\\n # Use two pointer to\\n # calculate the total number of cases if B[j] - B[i] <= score\\n def count_sum_under(score):\\n res = i = 0\\n for j in range(n + 1):\\n while B[j] - B[i] > score:\\n i += 1\\n res += j - i\\n return res\\n\\n # calculate the sum for all numbers whose indices are <= index k\\n def sum_k_sums(k):\\n", "gt": "score = kth_score(k)\\n res = i = 0\\n for j in range(n + 1):\\n # Proceed until B[i] and B[j] are within score\\n while B[j] - B[i] > score:\\n i += 1\\n res += B[j] * (j - i + 1) - (C[j] - (C[i - 1] if i else 0))\\n return res - (count_sum_under(score) - k) * score\\n\\n # use bisearch to find how many numbers ae below k\\n def kth_score(k):\\n l, r = 0, B[n]\\n while l < r:\\n m = (l + r) // 2\\n if count_sum_under(m) < k:\\n l = m + 1\\n else:\\n r = m\\n return l\\n\\n # result between left and right can be converted to [0, right] - [0, left-1] (result below right - result below left-1)\\n return (sum_k_sums(right) - sum_k_sums(left - 1))%(10**9 + 7)"}
{"id": "477", "input": "class Solution:\\n def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\\n if not position:\\n return 0\\n \\n posToSpeed = {position[i]: speed[i] for i in range(len(position))}\\n position.sort()\\n \\n leaderTime = (target - position[-1])", "gt": "/ posToSpeed[position[-1]]\\n currGroups = 1\\n for i in range(len(position) - 2, -1, -1):\\n currTime = (target - position[i]) / posToSpeed[position[i]]\\n if currTime > leaderTime:\\n currGroups += 1\\n leaderTime = currTime\\n \\n return currGroups"}
{"id": "478", "input": "class Solution:\\n def findKthBit(self, n: int, k: int) -> str:\\n i = n - 1\\n invert = False\\n while i > 0:\\n half_len = (2**(i + 1) - 1) // 2 \\n if k == half_len +", "gt": "1:\\n return '1' if not invert else '0'\\n \\n if k > half_len:\\n k = half_len - (k - half_len - 1) + 1\\n invert = not invert\\n i -= 1\\n \\n return '1' if invert else '0'"}
{"id": "479", "input": "class Solution:\\n def singleNumber(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n", "gt": "\"\"\"\\n a = set(nums)\\n a = sum(a)*3 - sum(nums)\\n return int(a/2)"}
{"id": "480", "input": "class Solution:\\n def leastBricks(self, wall):\\n \"\"\"\\n :type wall: List[List[int]]\\n :rtype: int\\n \"\"\"\\n d = {}\\n for i in wall:\\n suma = 0\\n for j in", "gt": "range(len(i)-1):\\n suma += i[j]\\n if suma in d:\\n d[suma] += 1\\n else:\\n d[suma] = 1\\n if len(d) == 0:\\n return len(wall)\\n return len(wall) - max(d.values())\\n"}
{"id": "481", "input": "# https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/discuss/569521/7-python-approaches-with-Time-and-Space-analysis\\nclass Solution:\\n def numWays(self, steps: int, arrLen: int) -> int:\\n r = min(arrLen, steps // 2 + 1)\\n dp", "gt": "= [0, 1]\\n for t in range(steps):\\n dp[1:] = [sum(dp[i-1:i+2]) for i in range(1, min(r+1, t+3))]\\n return dp[1] % (10**9+7)"}
{"id": "482", "input": "class Solution(object):\\n def threeSumClosest(self, nums, target):\\n \"\"\"\\n :type nums: List[int]\\n :type target: int\\n :rtype: int\\n \"\"\"\\n size = len(nums)\\n if size < 3:\\n return 0\\n nums.sort()\\n i = 0 # fix the first index\\n ans = nums[0] + nums[1] + nums[size - 1] # ans is used to record the solution\\n while i < size - 2:\\n tmp = target - nums[i]\\n j = i + 1\\n k = size - 1\\n while j < k:\\n if nums[j] + nums[k] == tmp:\\n return target\\n if nums[j] + nums[k] > tmp:\\n if nums[j] + nums[j + 1] >= tmp:\\n if nums[j] +", "gt": "nums[j + 1] - tmp < abs(ans - target):\\n ans = nums[i] + nums[j] + nums[j + 1]\\n break\\n tmpans = nums[i] + nums[j] + nums[k]\\n if tmpans - target < abs(ans - target):\\n ans = tmpans\\n k -= 1\\n else:\\n if nums[k] + nums[k - 1] <= tmp:\\n if tmp - nums[k] -nums[k - 1] < abs(ans - target):\\n ans = nums[i] + nums[k - 1] + nums[k]\\n break\\n tmpans = nums[i] + nums[j] + nums[k]\\n if target - tmpans < abs(ans - target):\\n ans = tmpans\\n j += 1\\n i += 1\\n if ans == target:\\n return target\\n return ans"}
{"id": "483", "input": "class Solution:\\n def mctFromLeafValues(self, arr: List[int]) -> int:\\n if not arr: return 0\\n \\n res = []\\n\\n while len(arr) > 1:\\n temp_res = []\\n temp_res = [arr[i]*arr[i+1] for i in range(len(arr)-1)]\\n idx = temp_res.index(min(temp_res))\\n\\n res.append(temp_res[idx])\\n arr.pop(idx if arr[idx] < arr[idx+1] else idx+1)\\n \\n # left = arr[0] * arr[1]\\n # right = arr[-1] * arr[-2]\\n # if left", "gt": "< right:\\n # res.append(left)\\n # arr.pop(1 if arr[1] < arr[0] else 0)\\n # elif right < left:\\n # res.append(right)\\n # arr.pop(-2 if arr[-2] < arr[-1] else -1)\\n # else:\\n # res.append(left)\\n # if max(arr[0], arr[1]) > max(arr[-1], arr[-2]):\\n # arr.pop(-2 if arr[-2] < arr[-1] else -1)\\n # else:\\n # arr.pop(1 if arr[1] < arr[0] else 0)\\n \\n return sum(res)"}
{"id": "484", "input": "class Solution:\\n def maxArea(self, height):\\n \"\"\"\\n :type height: List[int]\\n :rtype: int\\n \"\"\"\\n # l = []\\n # maxH = 0\\n # for i in range(len(height)-1, -1, -1):\\n # if height[i] > maxH:\\n # maxH = height[i]\\n # l.append((i, maxH))\\n # maxArea = 0\\n # for i in range(len(height)):\\n # for jl in l:\\n # if i >= jl[0]:\\n # break\\n # area = (jl[0] - i) * min(height[i], jl[1])\\n # if area > maxArea:\\n # maxArea = area\\n # return maxArea\\n \\n left = 0\\n right = len(height) - 1\\n if height[left] > height[right]:\\n minH = height[right]\\n minIndex = right\\n else:\\n minH = height[left]\\n", "gt": "minIndex = left\\n area = (right - left) * minH\\n maxArea = area\\n \\n while left != right:\\n if minIndex == left:\\n while left != right:\\n left += 1\\n if height[left] > minH:\\n if height[left] > height[right]:\\n minH = height[right]\\n minIndex = right\\n else:\\n minH = height[left]\\n minIndex = left\\n break\\n area = (right - left) * minH\\n else:\\n while left != right:\\n right -= 1\\n if height[right] > minH:\\n if height[right] > height[left]:\\n minH = height[left]\\n minIndex = left\\n else:\\n minH = height[right]\\n minIndex = right\\n break\\n area = (right - left) * minH\\n if area > maxArea:\\n maxArea = area\\n return maxArea"}
{"id": "485", "input": "import bisect\\n\\n\\nclass Solution:\\n def primePalindrome(self, N: int) -> int:\\n return primes[bisect.bisect_left(primes, N)]\\n\\n\\nprimes = [\\n 2,\\n 3,\\n 5,\\n 7,\\n 11,\\n 101,\\n 131,\\n 151,\\n 181,\\n 191,\\n 313,\\n 353,\\n 373,\\n 383,\\n 727,\\n 757,\\n 787,\\n 797,\\n 919,\\n 929,\\n 10301,\\n 10501,\\n 10601,\\n 11311,\\n 11411,\\n 12421,\\n 12721,\\n 12821,\\n 13331,\\n 13831,\\n 13931,\\n 14341,\\n 14741,\\n 15451,\\n 15551,\\n 16061,\\n 16361,\\n 16561,\\n 16661,\\n 17471,\\n 17971,\\n 18181,\\n 18481,\\n 19391,\\n 19891,\\n 19991,\\n 30103,\\n 30203,\\n 30403,\\n 30703,\\n 30803,\\n 31013,\\n 31513,\\n 32323,\\n 32423,\\n 33533,\\n 34543,\\n 34843,\\n 35053,\\n 35153,\\n 35353,\\n 35753,\\n 36263,\\n 36563,\\n 37273,\\n 37573,\\n 38083,\\n 38183,\\n 38783,\\n 39293,\\n 70207,\\n 70507,\\n 70607,\\n 71317,\\n 71917,\\n 72227,\\n 72727,\\n 73037,\\n 73237,\\n 73637,\\n 74047,\\n 74747,\\n 75557,\\n 76367,\\n 76667,\\n 77377,\\n 77477,\\n 77977,\\n 78487,\\n 78787,\\n 78887,\\n 79397,\\n 79697,\\n 79997,\\n 90709,\\n 91019,\\n 93139,\\n 93239,\\n 93739,\\n 94049,\\n 94349,\\n 94649,\\n 94849,\\n 94949,\\n 95959,\\n 96269,\\n 96469,\\n 96769,\\n 97379,\\n 97579,\\n 97879,\\n 98389,\\n 98689,\\n 1003001,\\n 1008001,\\n 1022201,\\n 1028201,\\n 1035301,\\n 1043401,\\n 1055501,\\n 1062601,\\n 1065601,\\n 1074701,\\n 1082801,\\n 1085801,\\n 1092901,\\n 1093901,\\n 1114111,\\n 1117111,\\n 1120211,\\n 1123211,\\n 1126211,\\n 1129211,\\n 1134311,\\n 1145411,\\n 1150511,\\n 1153511,\\n 1160611,\\n 1163611,\\n 1175711,\\n 1177711,\\n 1178711,\\n 1180811,\\n 1183811,\\n 1186811,\\n 1190911,\\n 1193911,\\n 1196911,\\n 1201021,\\n 1208021,\\n 1212121,\\n 1215121,\\n 1218121,\\n 1221221,\\n 1235321,\\n 1242421,\\n 1243421,\\n 1245421,\\n 1250521,\\n 1253521,\\n 1257521,\\n 1262621,\\n 1268621,\\n 1273721,\\n 1276721,\\n 1278721,\\n 1280821,\\n 1281821,\\n 1286821,\\n 1287821,\\n 1300031,\\n 1303031,\\n 1311131,\\n 1317131,\\n 1327231,\\n 1328231,\\n 1333331,\\n 1335331,\\n 1338331,\\n 1343431,\\n 1360631,\\n 1362631,\\n 1363631,\\n 1371731,\\n 1374731,\\n 1390931,\\n 1407041,\\n 1409041,\\n 1411141,\\n 1412141,\\n 1422241,\\n 1437341,\\n 1444441,\\n 1447441,\\n 1452541,\\n 1456541,\\n 1461641,\\n 1463641,\\n 1464641,\\n 1469641,\\n 1486841,\\n 1489841,\\n 1490941,\\n 1496941,\\n 1508051,\\n 1513151,\\n 1520251,\\n 1532351,\\n 1535351,\\n 1542451,\\n 1548451,\\n 1550551,\\n 1551551,\\n 1556551,\\n 1557551,\\n 1565651,\\n 1572751,\\n 1579751,\\n 1580851,\\n 1583851,\\n 1589851,\\n 1594951,\\n 1597951,\\n 1598951,\\n 1600061,\\n 1609061,\\n 1611161,\\n 1616161,\\n 1628261,\\n 1630361,\\n 1633361,\\n 1640461,\\n 1643461,\\n 1646461,\\n 1654561,\\n 1657561,\\n 1658561,\\n 1660661,\\n 1670761,\\n 1684861,\\n 1685861,\\n 1688861,\\n 1695961,\\n 1703071,\\n 1707071,\\n 1712171,\\n 1714171,\\n 1730371,\\n 1734371,\\n 1737371,\\n 1748471,\\n 1755571,\\n 1761671,\\n 1764671,\\n 1777771,\\n 1793971,\\n 1802081,\\n 1805081,\\n 1820281,\\n 1823281,\\n 1824281,\\n 1826281,\\n 1829281,\\n 1831381,\\n 1832381,\\n 1842481,\\n 1851581,\\n 1853581,\\n 1856581,\\n 1865681,\\n 1876781,\\n 1878781,\\n 1879781,\\n 1880881,\\n 1881881,\\n 1883881,\\n 1884881,\\n 1895981,\\n 1903091,\\n 1908091,\\n 1909091,\\n 1917191,\\n 1924291,\\n 1930391,\\n 1936391,\\n 1941491,\\n 1951591,\\n 1952591,\\n 1957591,\\n 1958591,\\n 1963691,\\n 1968691,\\n 1969691,\\n 1970791,\\n 1976791,\\n 1981891,\\n 1982891,\\n 1984891,\\n 1987891,\\n 1988891,\\n 1993991,\\n 1995991,\\n 1998991,\\n 3001003,\\n 3002003,\\n 3007003,\\n 3016103,\\n 3026203,\\n 3064603,\\n 3065603,\\n 3072703,\\n 3073703,\\n 3075703,\\n 3083803,\\n 3089803,\\n 3091903,\\n 3095903,\\n 3103013,\\n 3106013,\\n 3127213,\\n 3135313,\\n 3140413,\\n 3155513,\\n 3158513,\\n 3160613,\\n 3166613,\\n 3181813,\\n 3187813,\\n 3193913,\\n 3196913,\\n 3198913,\\n 3211123,\\n 3212123,\\n 3218123,\\n 3222223,\\n 3223223,\\n 3228223,\\n 3233323,\\n 3236323,\\n 3241423,\\n 3245423,\\n 3252523,\\n 3256523,\\n 3258523,\\n 3260623,\\n 3267623,\\n 3272723,\\n 3283823,\\n 3285823,\\n 3286823,\\n 3288823,\\n 3291923,\\n 3293923,\\n 3304033,\\n 3305033,\\n 3307033,\\n 3310133,\\n 3315133,\\n 3319133,\\n 3321233,\\n 3329233,\\n 3331333,\\n 3337333,\\n 3343433,\\n 3353533,\\n 3362633,\\n 3364633,\\n 3365633,\\n 3368633,\\n 3380833,\\n 3391933,\\n 3392933,\\n 3400043,\\n 3411143,\\n 3417143,\\n 3424243,\\n 3425243,\\n 3427243,\\n 3439343,\\n 3441443,\\n 3443443,\\n 3444443,\\n 3447443,\\n 3449443,\\n 3452543,\\n 3460643,\\n 3466643,\\n 3470743,\\n 3479743,\\n 3485843,\\n 3487843,\\n 3503053,\\n 3515153,\\n 3517153,\\n 3528253,\\n 3541453,\\n 3553553,\\n 3558553,\\n 3563653,\\n 3569653,\\n 3586853,\\n 3589853,\\n 3590953,\\n 3591953,\\n 3594953,\\n 3601063,\\n 3607063,\\n 3618163,\\n 3621263,\\n 3627263,\\n 3635363,\\n 3643463,\\n 3646463,\\n 3670763,\\n 3673763,\\n 3680863,\\n 3689863,\\n 3698963,\\n 3708073,\\n 3709073,\\n 3716173,\\n 3717173,\\n 3721273,\\n 3722273,\\n 3728273,\\n 3732373,\\n 3743473,\\n 3746473,\\n 3762673,\\n 3763673,\\n 3765673,\\n 3768673,\\n 3769673,\\n 3773773,\\n 3774773,\\n 3781873,\\n 3784873,\\n 3792973,\\n 3793973,\\n 3799973,\\n 3804083,\\n 3806083,\\n 3812183,\\n 3814183,\\n 3826283,\\n 3829283,\\n 3836383,\\n 3842483,\\n 3853583,\\n 3858583,\\n 3863683,\\n 3864683,\\n 3867683,\\n 3869683,\\n 3871783,\\n 3878783,\\n 3893983,\\n 3899983,\\n 3913193,\\n 3916193,\\n 3918193,\\n 3924293,\\n 3927293,\\n 3931393,\\n 3938393,\\n 3942493,\\n 3946493,\\n 3948493,\\n 3964693,\\n 3970793,\\n 3983893,\\n 3991993,\\n 3994993,\\n 3997993,\\n 3998993,\\n 7014107,\\n 7035307,\\n 7036307,\\n 7041407,\\n 7046407,\\n 7057507,\\n 7065607,\\n 7069607,\\n 7073707,\\n 7079707,\\n 7082807,\\n 7084807,\\n 7087807,\\n 7093907,\\n 7096907,\\n 7100017,\\n 7114117,\\n 7115117,\\n 7118117,\\n 7129217,\\n 7134317,\\n 7136317,\\n 7141417,\\n 7145417,\\n 7155517,\\n 7156517,\\n 7158517,\\n 7159517,\\n 7177717,\\n 7190917,\\n 7194917,\\n 7215127,\\n 7226227,\\n 7246427,\\n 7249427,\\n 7250527,\\n 7256527,\\n 7257527,\\n 7261627,\\n 7267627,\\n 7276727,\\n 7278727,\\n 7291927,\\n 7300037,\\n 7302037,\\n 7310137,\\n 7314137,\\n 7324237,\\n 7327237,\\n 7347437,\\n 7352537,\\n 7354537,\\n 7362637,\\n 7365637,\\n 7381837,\\n 7388837,\\n 7392937,\\n 7401047,\\n 7403047,\\n 7409047,\\n 7415147,\\n 7434347,\\n 7436347,\\n 7439347,\\n 7452547,\\n 7461647,\\n 7466647,\\n 7472747,\\n 7475747,\\n 7485847,\\n 7486847,\\n 7489847,\\n 7493947,\\n 7507057,\\n 7508057,\\n 7518157,\\n 7519157,\\n 7521257,\\n 7527257,\\n 7540457,\\n 7562657,\\n 7564657,\\n 7576757,\\n 7586857,\\n 7592957,\\n 7594957,\\n 7600067,\\n 7611167,\\n 7619167,\\n 7622267,\\n 7630367,\\n 7632367,\\n 7644467,\\n 7654567,\\n 7662667,\\n 7665667,\\n 7666667,\\n 7668667,\\n 7669667,\\n 7674767,\\n 7681867,\\n 7690967,\\n 7693967,\\n 7696967,\\n 7715177,\\n 7718177,\\n 7722277,\\n 7729277,\\n 7733377,\\n 7742477,\\n 7747477,\\n 7750577,\\n 7758577,\\n 7764677,\\n 7772777,\\n 7774777,\\n 7778777,\\n 7782877,\\n 7783877,\\n 7791977,\\n 7794977,\\n 7807087,\\n 7819187,\\n 7820287,\\n 7821287,\\n 7831387,\\n 7832387,\\n 7838387,\\n 7843487,\\n 7850587,\\n 7856587,\\n 7865687,\\n 7867687,\\n 7868687,\\n 7873787,\\n 7884887,\\n 7891987,\\n 7897987,\\n 7913197,\\n 7916197,\\n 7930397,\\n 7933397,\\n 7935397,\\n 7938397,\\n 7941497,\\n 7943497,\\n 7949497,\\n 7957597,\\n 7958597,\\n 7960697,\\n 7977797,\\n 7984897,\\n 7985897,\\n 7987897,\\n 7996997,\\n 9002009,\\n 9015109,\\n 9024209,\\n 9037309,\\n 9042409,\\n 9043409,\\n 9045409,\\n 9046409,\\n 9049409,\\n 9067609,\\n 9073709,\\n 9076709,\\n 9078709,\\n 9091909,\\n 9095909,\\n 9103019,\\n 9109019,\\n 9110119,\\n 9127219,\\n 9128219,\\n 9136319,\\n 9149419,\\n 9169619,\\n 9173719,\\n 9174719,\\n 9179719,\\n 9185819,\\n 9196919,\\n 9199919,\\n 9200029,\\n 9209029,\\n 9212129,\\n 9217129,\\n 9222229,\\n 9223229,\\n 9230329,\\n 9231329,\\n 9255529,\\n 9269629,\\n 9271729,\\n 9277729,\\n 9280829,\\n 9286829,\\n 9289829,\\n 9318139,\\n 9320239,\\n 9324239,\\n 9329239,\\n 9332339,\\n 9338339,\\n 9351539,\\n 9357539,\\n 9375739,\\n 9384839,\\n 9397939,\\n 9400049,\\n 9414149,\\n 9419149,\\n 9433349,\\n 9439349,\\n 9440449,\\n 9446449,\\n 9451549,\\n 9470749,\\n 9477749,\\n 9492949,\\n 9493949,\\n 9495949,\\n 9504059,\\n 9514159,\\n 9526259,\\n 9529259,\\n 9547459,\\n 9556559,\\n 9558559,\\n 9561659,\\n 9577759,\\n 9583859,\\n 9585859,\\n 9586859,\\n 9601069,\\n 9602069,\\n 9604069,\\n 9610169,\\n 9620269,\\n 9624269,\\n 9626269,\\n 9632369,\\n 9634369,\\n 9645469,\\n 9650569,\\n 9657569,\\n 9670769,\\n 9686869,\\n 9700079,\\n 9709079,\\n 9711179,\\n 9714179,\\n 9724279,\\n 9727279,\\n 9732379,\\n 9733379,\\n 9743479,\\n 9749479,\\n 9752579,\\n 9754579,\\n 9758579,\\n 9762679,\\n 9770779,\\n 9776779,\\n 9779779,\\n 9781879,\\n 9782879,\\n 9787879,\\n 9788879,\\n 9795979,\\n 9801089,\\n 9807089,\\n 9809089,\\n 9817189,\\n 9818189,\\n 9820289,\\n 9822289,\\n 9836389,\\n 9837389,\\n 9845489,\\n 9852589,\\n 9871789,\\n 9888889,\\n 9889889,\\n 9896989,\\n 9902099,\\n 9907099,\\n 9908099,\\n 9916199,\\n 9918199,\\n 9919199,\\n 9921299,\\n 9923299,\\n 9926299,\\n 9927299,\\n 9931399,\\n 9932399,\\n 9935399,\\n 9938399,\\n 9957599,\\n 9965699,\\n 9978799,\\n 9980899,\\n 9981899,\\n 9989899,\\n 100030001,\\n 100050001,\\n 100060001,\\n 100111001,\\n 100131001,\\n 100161001,\\n 100404001,\\n 100656001,\\n 100707001,\\n 100767001,\\n 100888001,\\n 100999001,\\n 101030101,\\n 101060101,\\n 101141101,\\n 101171101,\\n 101282101,\\n 101292101,\\n 101343101,\\n 101373101,\\n 101414101,\\n 101424101,\\n 101474101,\\n 101595101,\\n 101616101,\\n 101717101,\\n 101777101,\\n 101838101,\\n 101898101,\\n 101919101,\\n 101949101,\\n 101999101,\\n 102040201,\\n 102070201,\\n 102202201,\\n 102232201,\\n 102272201,\\n 102343201,\\n 102383201,\\n 102454201,\\n 102484201,\\n 102515201,\\n 102676201,\\n 102686201,\\n 102707201,\\n 102808201,\\n 102838201,\\n 103000301,\\n 103060301,\\n 103161301,\\n 103212301,\\n 103282301,\\n 103303301,\\n 103323301,\\n 103333301,\\n 103363301,\\n 103464301,\\n 103515301,\\n 103575301,\\n 103696301,\\n 103777301,\\n 103818301,\\n 103828301,\\n 103909301,\\n 103939301,\\n 104000401,\\n 104030401,\\n 104040401,\\n 104111401,\\n 104222401,\\n 104282401,\\n 104333401,\\n 104585401,\\n 104616401,\\n 104787401,\\n 104838401,\\n 104919401,\\n 104949401,\\n 105121501,\\n 105191501,\\n 105202501,\\n 105262501,\\n 105272501,\\n 105313501,\\n 105323501,\\n 105343501,\\n 105575501,\\n 105616501,\\n 105656501,\\n 105757501,\\n 105818501,\\n 105868501,\\n 105929501,\\n 106060601,\\n 106111601,\\n 106131601,\\n 106191601,\\n 106222601,\\n 106272601,\\n 106353601,\\n 106444601,\\n 106464601,\\n 106545601,\\n 106555601,\\n 106717601,\\n 106909601,\\n 106929601,\\n 107000701,\\n 107070701,\\n 107121701,\\n 107232701,\\n 107393701,\\n 107414701,\\n 107424701,\\n 107595701,\\n 107636701,\\n 107646701,\\n 107747701,\\n 107757701,\\n 107828701,\\n 107858701,\\n 107868701,\\n 107888701,\\n 107939701,\\n 107949701,\\n 108070801,\\n 108101801,\\n 108121801,\\n 108151801,\\n 108212801,\\n 108323801,\\n 108373801,\\n 108383801,\\n 108434801,\\n 108464801,\\n 108484801,\\n 108494801,\\n 108505801,\\n 108565801,\\n 108686801,\\n 108707801,\\n 108767801,\\n 108838801,\\n 108919801,\\n 108959801,\\n 109000901,\\n 109101901,\\n 109111901,\\n 109161901,\\n 109333901,\\n 109404901,\\n 109434901,\\n 109444901,\\n 109474901,\\n 109575901,\\n 109656901,\\n 109747901,\\n 109777901,\\n 109797901,\\n 109818901,\\n 109909901,\\n 109929901,\\n 110111011,\\n 110232011,\\n 110252011,\\n 110343011,\\n 110424011,\\n 110505011,\\n 110565011,\\n 110676011,\\n 110747011,\\n 110757011,\\n 110909011,\\n 110949011,\\n 110999011,\\n 111010111,\\n 111020111,\\n 111050111,\\n 111070111,\\n 111181111,\\n 111191111,\\n 111262111,\\n 111272111,\\n 111454111,\\n 111484111,\\n 111515111,\\n 111616111,\\n 111686111,\\n 111757111,\\n 111848111,\\n 112030211,\\n 112060211,\\n 112111211,\\n 112161211,\\n 112171211,\\n 112212211,\\n 112434211,\\n 112494211,\\n 112545211,\\n 112636211,\\n 112878211,\\n 112959211,\\n 112969211,\\n 112989211,\\n 113030311,\\n 113090311,\\n 113111311,\\n 113262311,\\n 113282311,\\n 113474311,\\n 113535311,\\n 113565311,\\n 113616311,\\n 113636311,\\n 113888311,\\n 113939311,\\n 114040411,\\n 114191411,\\n 114232411,\\n 114353411,\\n 114383411,\\n 114484411,\\n 114494411,\\n 114535411,\\n 114727411,\\n 114808411,\\n 114818411,\\n 114848411,\\n 114878411,\\n 114898411,\\n 115000511,\\n 115020511,\\n 115060511,\\n 115111511,\\n 115141511,\\n 115191511,\\n 115212511,\\n 115222511,\\n 115404511,\\n 115464511,\\n 115545511,\\n 115636511,\\n 115737511,\\n 115767511,\\n 115797511,\\n 115828511,\\n 115959511,\\n 116000611,\\n 116010611,\\n 116040611,\\n 116424611,\\n 116505611,\\n 116646611,\\n 116696611,\\n 116757611,\\n 116777611,\\n 116828611,\\n 116868611,\\n 116919611,\\n 117070711,\\n 117101711,\\n 117262711,\\n 117272711,\\n 117323711,\\n 117484711,\\n 117505711,\\n 117515711,\\n 117616711,\\n 117686711,\\n 117757711,\\n 117767711,\\n 117797711,\\n 117818711,\\n 117959711,\\n 118252811,\\n 118272811,\\n 118414811,\\n 118464811,\\n 118525811,\\n 118626811,\\n 118686811,\\n 118696811,\\n 118717811,\\n 118818811,\\n 118848811,\\n 118909811,\\n 118959811,\\n 119010911,\\n 119171911,\\n 119202911,\\n 119343911,\\n 119363911,\\n 119454911,\\n 119585911,\\n 119595911,\\n 119646911,\\n 119676911,\\n 119696911,\\n 119717911,\\n 119787911,\\n 119868911,\\n 119888911,\\n 119969911,\\n 120191021,\\n 120242021,\\n 120434021,\\n 120454021,\\n 120494021,\\n 120535021,\\n 120565021,\\n 120646021,\\n 120808021,\\n 120868021,\\n 120989021,\\n", "gt": "121080121,\\n 121111121,\\n 121131121,\\n 121161121,\\n 121272121,\\n 121282121,\\n 121393121,\\n 121414121,\\n 121555121,\\n 121747121,\\n 121818121,\\n 121878121,\\n 121939121,\\n 121989121,\\n 122040221,\\n 122232221,\\n 122262221,\\n 122292221,\\n 122333221,\\n 122363221,\\n 122373221,\\n 122393221,\\n 122444221,\\n 122484221,\\n 122535221,\\n 122696221,\\n 122787221,\\n 122858221,\\n 122919221,\\n 123161321,\\n 123292321,\\n 123424321,\\n 123484321,\\n 123494321,\\n 123575321,\\n 123767321,\\n 123838321,\\n 123989321,\\n 124000421,\\n 124080421,\\n 124101421,\\n 124131421,\\n 124252421,\\n 124323421,\\n 124333421,\\n 124434421,\\n 124515421,\\n 124525421,\\n 124626421,\\n 124656421,\\n 124717421,\\n 124737421,\\n 124959421,\\n 124989421,\\n 125000521,\\n 125010521,\\n 125232521,\\n 125252521,\\n 125292521,\\n 125343521,\\n 125474521,\\n 125505521,\\n 125565521,\\n 125606521,\\n 125616521,\\n 125757521,\\n 125838521,\\n 125939521,\\n 125979521,\\n 125999521,\\n 126101621,\\n 126161621,\\n 126181621,\\n 126202621,\\n 126212621,\\n 126323621,\\n 126424621,\\n 126484621,\\n 126535621,\\n 126595621,\\n 126616621,\\n 126676621,\\n 126686621,\\n 126727621,\\n 126737621,\\n 126757621,\\n 126878621,\\n 127060721,\\n 127090721,\\n 127131721,\\n 127212721,\\n 127383721,\\n 127494721,\\n 127545721,\\n 127636721,\\n 127656721,\\n 127686721,\\n 127717721,\\n 127747721,\\n 127828721,\\n 127909721,\\n 127929721,\\n 128070821,\\n 128090821,\\n 128121821,\\n 128181821,\\n 128202821,\\n 128252821,\\n 128262821,\\n 128282821,\\n 128444821,\\n 128474821,\\n 128525821,\\n 128535821,\\n 128595821,\\n 128646821,\\n 128747821,\\n 128787821,\\n 128868821,\\n 128919821,\\n 128939821,\\n 129080921,\\n 129202921,\\n 129292921,\\n 129323921,\\n 129373921,\\n 129484921,\\n 129494921,\\n 129535921,\\n 129737921,\\n 129919921,\\n 129979921,\\n 130020031,\\n 130030031,\\n 130060031,\\n 130141031,\\n 130171031,\\n 130222031,\\n 130333031,\\n 130444031,\\n 130464031,\\n 130545031,\\n 130555031,\\n 130585031,\\n 130606031,\\n 130636031,\\n 130717031,\\n 130767031,\\n 130818031,\\n 130828031,\\n 130858031,\\n 130969031,\\n 131030131,\\n 131111131,\\n 131121131,\\n 131222131,\\n 131252131,\\n 131333131,\\n 131555131,\\n 131565131,\\n 131585131,\\n 131646131,\\n 131676131,\\n 131828131,\\n 132010231,\\n 132191231,\\n 132464231,\\n 132535231,\\n 132595231,\\n 132646231,\\n 132676231,\\n 132757231,\\n 133020331,\\n 133060331,\\n 133111331,\\n 133161331,\\n 133252331,\\n 133474331,\\n 133494331,\\n 133575331,\\n 133686331,\\n 133767331,\\n 133818331,\\n 133909331,\\n 134090431,\\n 134181431,\\n 134232431,\\n 134424431,\\n 134505431,\\n 134525431,\\n 134535431,\\n 134616431,\\n 134757431,\\n 134808431,\\n 134858431,\\n 134888431,\\n 134909431,\\n 134919431,\\n 134979431,\\n 135010531,\\n 135040531,\\n 135101531,\\n 135121531,\\n 135161531,\\n 135262531,\\n 135434531,\\n 135494531,\\n 135515531,\\n 135626531,\\n 135646531,\\n 135707531,\\n 135838531,\\n 135868531,\\n 135878531,\\n 135929531,\\n 135959531,\\n 135979531,\\n 136090631,\\n 136171631,\\n 136222631,\\n 136252631,\\n 136303631,\\n 136363631,\\n 136474631,\\n 136545631,\\n 136737631,\\n 136797631,\\n 136818631,\\n 136909631,\\n 136969631,\\n 137030731,\\n 137040731,\\n 137060731,\\n 137090731,\\n 137151731,\\n 137171731,\\n 137232731,\\n 137282731,\\n 137333731,\\n 137363731,\\n 137424731,\\n 137474731,\\n 137606731,\\n 137636731,\\n 137696731,\\n 137757731,\\n 137808731,\\n 137838731,\\n 137939731,\\n 137999731,\\n 138040831,\\n 138131831,\\n 138242831,\\n 138292831,\\n 138313831,\\n 138383831,\\n 138454831,\\n 138575831,\\n 138616831,\\n 138646831,\\n 138757831,\\n 138898831,\\n 138959831,\\n 138989831,\\n 139131931,\\n 139161931,\\n 139222931,\\n 139252931,\\n 139282931,\\n 139383931,\\n 139474931,\\n 139515931,\\n 139606931,\\n 139626931,\\n 139717931,\\n 139848931,\\n 139959931,\\n 139969931,\\n 139999931,\\n 140000041,\\n 140030041,\\n 140151041,\\n 140303041,\\n 140505041,\\n 140565041,\\n 140606041,\\n 140777041,\\n 140787041,\\n 140828041,\\n 140868041,\\n 140898041,\\n 141020141,\\n 141070141,\\n 141131141,\\n 141151141,\\n 141242141,\\n 141262141,\\n 141313141,\\n 141343141,\\n 141383141,\\n 141484141,\\n 141494141,\\n 141575141,\\n 141595141,\\n 141616141,\\n 141767141,\\n 141787141,\\n 141848141,\\n 142000241,\\n 142030241,\\n 142080241,\\n 142252241,\\n 142272241,\\n 142353241,\\n 142363241,\\n 142464241,\\n 142545241,\\n 142555241,\\n 142686241,\\n 142707241,\\n 142797241,\\n 142858241,\\n 142888241,\\n 143090341,\\n 143181341,\\n 143262341,\\n 143303341,\\n 143454341,\\n 143474341,\\n 143585341,\\n 143636341,\\n 143787341,\\n 143828341,\\n 143919341,\\n 143969341,\\n 144010441,\\n 144020441,\\n 144202441,\\n 144212441,\\n 144313441,\\n 144353441,\\n 144404441,\\n 144434441,\\n 144484441,\\n 144505441,\\n 144707441,\\n 144757441,\\n 144808441,\\n 144818441,\\n 144848441,\\n 144878441,\\n 144898441,\\n 144979441,\\n 144989441,\\n 145020541,\\n 145030541,\\n 145090541,\\n 145353541,\\n 145363541,\\n 145393541,\\n 145464541,\\n 145494541,\\n 145575541,\\n 145666541,\\n 145767541,\\n 146030641,\\n 146040641,\\n 146181641,\\n 146222641,\\n 146252641,\\n 146313641,\\n 146363641,\\n 146505641,\\n 146555641,\\n 146565641,\\n 146676641,\\n 146858641,\\n 146909641,\\n 147191741,\\n 147232741,\\n 147242741,\\n 147313741,\\n 147343741,\\n 147373741,\\n 147434741,\\n 147515741,\\n 147565741,\\n 147616741,\\n 147686741,\\n 147707741,\\n 147757741,\\n 147838741,\\n 147929741,\\n 148020841,\\n 148060841,\\n 148080841,\\n 148414841,\\n 148444841,\\n 148525841,\\n 148545841,\\n 148585841,\\n 148666841,\\n 148686841,\\n 148707841,\\n 148818841,\\n 148858841,\\n 148888841,\\n 148969841,\\n 149000941,\\n 149333941,\\n 149343941,\\n 149484941,\\n 149535941,\\n 149555941,\\n 149616941,\\n 149646941,\\n 149696941,\\n 149858941,\\n 149888941,\\n 149909941,\\n 149919941,\\n 149939941,\\n 150070051,\\n 150151051,\\n 150181051,\\n 150202051,\\n 150272051,\\n 150434051,\\n 150494051,\\n 150505051,\\n 150626051,\\n 150686051,\\n 150727051,\\n 150808051,\\n 150818051,\\n 150979051,\\n 151080151,\\n 151161151,\\n 151212151,\\n 151222151,\\n 151282151,\\n 151353151,\\n 151545151,\\n 151585151,\\n 151656151,\\n 151737151,\\n 151777151,\\n 151858151,\\n 151878151,\\n 151888151,\\n 151959151,\\n 151969151,\\n 151999151,\\n 152090251,\\n 152111251,\\n 152171251,\\n 152181251,\\n 152252251,\\n 152363251,\\n 152393251,\\n 152454251,\\n 152505251,\\n 152565251,\\n 152616251,\\n 152646251,\\n 152666251,\\n 152696251,\\n 152888251,\\n 152939251,\\n 153212351,\\n 153272351,\\n 153292351,\\n 153313351,\\n 153323351,\\n 153404351,\\n 153424351,\\n 153454351,\\n 153484351,\\n 153494351,\\n 153626351,\\n 153808351,\\n 153818351,\\n 153838351,\\n 153979351,\\n 154030451,\\n 154191451,\\n 154252451,\\n 154272451,\\n 154303451,\\n 154323451,\\n 154383451,\\n 154393451,\\n 154474451,\\n 154494451,\\n 154555451,\\n 154575451,\\n 154989451,\\n 155060551,\\n 155141551,\\n 155171551,\\n 155292551,\\n 155313551,\\n 155333551,\\n 155373551,\\n 155424551,\\n 155474551,\\n 155535551,\\n 155646551,\\n 155666551,\\n 155676551,\\n 155808551,\\n 155828551,\\n 155868551,\\n 156151651,\\n 156262651,\\n 156343651,\\n 156424651,\\n 156434651,\\n 156494651,\\n 156545651,\\n 156595651,\\n 156656651,\\n 156707651,\\n 156727651,\\n 156757651,\\n 156848651,\\n 156878651,\\n 156949651,\\n 157090751,\\n 157101751,\\n 157161751,\\n 157252751,\\n 157393751,\\n 157444751,\\n 157555751,\\n 157717751,\\n 157878751,\\n 157888751,\\n 157939751,\\n 157959751,\\n 157989751,\\n 158090851,\\n 158111851,\\n 158222851,\\n 158252851,\\n 158363851,\\n 158474851,\\n 158595851,\\n 158676851,\\n 158696851,\\n 158747851,\\n 158808851,\\n 158858851,\\n 158898851,\\n 158909851,\\n 159020951,\\n 159040951,\\n 159050951,\\n 159121951,\\n 159181951,\\n 159191951,\\n 159202951,\\n 159232951,\\n 159262951,\\n 159292951,\\n 159323951,\\n 159404951,\\n 159464951,\\n 159565951,\\n 159595951,\\n 159646951,\\n 159757951,\\n 159808951,\\n 159919951,\\n 159929951,\\n 159959951,\\n 160020061,\\n 160050061,\\n 160080061,\\n 160101061,\\n 160131061,\\n 160141061,\\n 160161061,\\n 160171061,\\n 160393061,\\n 160545061,\\n 160696061,\\n 160707061,\\n 160717061,\\n 160797061,\\n 160878061,\\n 161171161,\\n 161282161,\\n 161313161,\\n 161363161,\\n 161474161,\\n 161484161,\\n 161535161,\\n 161585161,\\n 161636161,\\n 161787161,\\n 161838161,\\n 161969161,\\n 162040261,\\n 162232261,\\n 162404261,\\n 162464261,\\n 162484261,\\n 162565261,\\n 162686261,\\n 162707261,\\n 162757261,\\n 162898261,\\n 162919261,\\n 162949261,\\n 162959261,\\n 162979261,\\n 162989261,\\n 163101361,\\n 163333361,\\n 163434361,\\n 163464361,\\n 163474361,\\n 163494361,\\n 163515361,\\n 163555361,\\n 163606361,\\n 163686361,\\n 163696361,\\n 163878361,\\n 163959361,\\n 164000461,\\n 164070461,\\n 164151461,\\n 164292461,\\n 164333461,\\n 164454461,\\n 164484461,\\n 164585461,\\n 164616461,\\n 164696461,\\n 164717461,\\n 164727461,\\n 164838461,\\n 165101561,\\n 165161561,\\n 165191561,\\n 165212561,\\n 165343561,\\n 165515561,\\n 165535561,\\n 165808561,\\n 165878561,\\n 165898561,\\n 165919561,\\n 165949561,\\n 166000661,\\n 166080661,\\n 166171661,\\n 166191661,\\n 166404661,\\n 166545661,\\n 166555661,\\n 166636661,\\n 166686661,\\n 166818661,\\n 166828661,\\n 166878661,\\n 166888661,\\n 166929661,\\n 167000761,\\n 167111761,\\n 167262761,\\n 167393761,\\n 167454761,\\n 167474761,\\n 167484761,\\n 167636761,\\n 167646761,\\n 167787761,\\n 167888761,\\n 167898761,\\n 167979761,\\n 168151861,\\n 168191861,\\n 168232861,\\n 168404861,\\n 168505861,\\n 168515861,\\n 168565861,\\n 168818861,\\n 168898861,\\n 168929861,\\n 168949861,\\n 169060961,\\n 169131961,\\n 169141961,\\n 169282961,\\n 169333961,\\n 169383961,\\n 169464961,\\n 169555961,\\n 169606961,\\n 169656961,\\n 169666961,\\n 169686961,\\n 169777961,\\n 169797961,\\n 169858961,\\n 169999961,\\n 170040071,\\n 170060071,\\n 170232071,\\n 170303071,\\n 170333071,\\n 170414071,\\n 170424071,\\n 170484071,\\n 170606071,\\n 170616071,\\n 170646071,\\n 170828071,\\n 170838071,\\n 170909071,\\n 170979071,\\n 171080171,\\n 171262171,\\n 171292171,\\n 171343171,\\n 171565171,\\n 171575171,\\n 171767171,\\n 171919171,\\n 171959171,\\n 172060271,\\n 172090271,\\n 172161271,\\n 172353271,\\n 172363271,\\n 172393271,\\n 172474271,\\n 172585271,\\n 172656271,\\n 172747271,\\n 172767271,\\n 172797271,\\n 172878271,\\n 172909271,\\n 172959271,\\n 173000371,\\n 173030371,\\n 173090371,\\n 173252371,\\n 173373371,\\n 173454371,\\n 173525371,\\n 173585371,\\n 173696371,\\n 173757371,\\n 173777371,\\n 173828371,\\n 173868371,\\n 173888371,\\n 173898371,\\n 173919371,\\n 174080471,\\n 174121471,\\n 174131471,\\n 174181471,\\n 174313471,\\n 174343471,\\n 174595471,\\n 174646471,\\n 174676471,\\n 174919471,\\n 174949471,\\n 174979471,\\n 174989471,\\n 175000571,\\n 175090571,\\n 175101571,\\n 175111571,\\n 175353571,\\n 175444571,\\n 175555571,\\n 175626571,\\n 175747571,\\n 175777571,\\n 175848571,\\n 175909571,\\n 176090671,\\n 176111671,\\n 176141671,\\n 176181671,\\n 176232671,\\n 176313671,\\n 176333671,\\n 176373671,\\n 176393671,\\n 176414671,\\n 176585671,\\n 176636671,\\n 176646671,\\n 176666671,\\n 176696671,\\n 176757671,\\n 176787671,\\n 176888671,\\n 176898671,\\n 176939671,\\n 177121771,\\n 177161771,\\n 177202771,\\n 177242771,\\n 177323771,\\n 177565771,\\n 177616771,\\n 177707771,\\n 177757771,\\n 177868771,\\n 178101871,\\n 178131871,\\n 178141871,\\n 178161871,\\n 178353871,\\n 178414871,\\n 178515871,\\n 178525871,\\n 178656871,\\n 178717871,\\n 178747871,\\n 178878871,\\n 178969871,\\n 178989871,\\n 178999871,\\n 179010971,\\n 179060971,\\n 179222971,\\n 179232971,\\n 179262971,\\n 179414971,\\n 179454971,\\n 179484971,\\n 179717971,\\n 179777971,\\n 179808971,\\n 179858971,\\n 179868971,\\n 179909971,\\n 179969971,\\n 179999971,\\n 180070081,\\n 180101081,\\n 180161081,\\n 180292081,\\n 180515081,\\n 180535081,\\n 180545081,\\n 180565081,\\n 180616081,\\n 180757081,\\n 180959081,\\n 181111181,\\n 181515181,\\n 181545181,\\n 181666181,\\n 181737181,\\n 181797181,\\n 181888181,\\n 182010281,\\n 182202281,\\n 182373281,\\n 182585281,\\n 182616281,\\n 182636281,\\n 182777281,\\n 182858281,\\n 182949281,\\n 183232381,\\n 183626381,\\n 183656381,\\n 183737381,\\n 183898381,\\n 183979381,\\n 183989381,\\n 184030481,\\n 184212481,\\n 184222481,\\n 184303481,\\n 184393481,\\n 184414481,\\n 184545481,\\n 184585481,\\n 184606481,\\n 184636481,\\n 184747481,\\n 184818481,\\n 184878481,\\n 185232581,\\n 185373581,\\n 185393581,\\n 185525581,\\n 185555581,\\n 185595581,\\n 185676581,\\n 185757581,\\n 185838581,\\n 185858581,\\n 185868581,\\n 185999581,\\n 186010681,\\n 186040681,\\n 186050681,\\n 186070681,\\n 186101681,\\n 186131681,\\n 186151681,\\n 186161681,\\n 186424681,\\n 186484681,\\n 186505681,\\n 186565681,\\n 186656681,\\n 186676681,\\n 186787681,\\n 186898681,\\n 187090781,\\n 187101781,\\n 187111781,\\n 187161781,\\n 187272781,\\n 187404781,\\n 187434781,\\n 187444781,\\n 187525781,\\n 187767781,\\n 187909781,\\n 187939781,\\n 187999781,\\n 188010881,\\n 188060881,\\n 188141881,\\n 188151881,\\n 188303881,\\n 188373881,\\n 188414881,\\n 188454881,\\n 188505881,\\n 188525881,\\n 188535881,\\n 188616881,\\n 188636881,\\n 188646881,\\n 188727881,\\n 188777881,\\n 188868881,\\n 188888881,\\n 188898881,\\n 188979881,\\n 189080981,\\n 189131981,\\n 189262981,\\n 189292981,\\n 189464981,\\n 189535981,\\n 189595981,\\n 189727981,\\n 189787981,\\n 189838981,\\n 189898981,\\n 189929981,\\n 190000091,\\n 190020091,\\n 190080091,\\n 190101091,\\n 190252091,\\n 190404091,\\n 190434091,\\n 190464091,\\n 190494091,\\n 190656091,\\n 190696091,\\n 190717091,\\n 190747091,\\n 190777091,\\n 190858091,\\n 190909091,\\n 191090191,\\n 191171191,\\n 191232191,\\n 191292191,\\n 191313191,\\n 191565191,\\n 191595191,\\n 191727191,\\n 191757191,\\n 191838191,\\n 191868191,\\n 191939191,\\n 191969191,\\n 192101291,\\n 192191291,\\n 192202291,\\n 192242291,\\n 192313291,\\n 192404291,\\n 192454291,\\n 192484291,\\n 192767291,\\n 192797291,\\n 192898291,\\n 193000391,\\n 193030391,\\n 193191391,\\n 193212391,\\n 193282391,\\n 193303391,\\n 193383391,\\n 193414391,\\n 193464391,\\n 193555391,\\n 193686391,\\n 193858391,\\n 193888391,\\n 194000491,\\n 194070491,\\n 194121491,\\n 194222491,\\n 194232491,\\n 194292491,\\n 194303491,\\n 194393491,\\n 194505491,\\n 194595491,\\n 194606491,\\n 194787491,\\n 194939491,\\n 194999491,\\n 195010591,\\n 195040591,\\n 195070591,\\n 195151591,\\n 195202591,\\n 195242591,\\n 195353591,\\n 195505591,\\n 195545591,\\n 195707591,\\n 195767591,\\n 195868591,\\n 195878591,\\n 195949591,\\n 195979591,\\n 196000691,\\n 196090691,\\n 196323691,\\n 196333691,\\n 196363691,\\n 196696691,\\n 196797691,\\n 196828691,\\n 196878691,\\n 197030791,\\n 197060791,\\n 197070791,\\n 197090791,\\n 197111791,\\n 197121791,\\n 197202791,\\n 197292791,\\n 197343791,\\n 197454791,\\n 197525791,\\n 197606791,\\n 197616791,\\n 197868791,\\n 197898791,\\n 197919791,\\n 198040891,\\n 198070891,\\n 198080891,\\n 198131891,\\n 198292891,\\n 198343891,\\n 198353891,\\n 198383891,\\n 198454891,\\n 198565891,\\n 198656891,\\n 198707891,\\n 198787891,\\n 198878891,\\n 198919891,\\n 199030991,\\n 199080991,\\n 199141991,\\n 199171991,\\n 199212991,\\n 199242991,\\n 199323991,\\n 199353991,\\n 199363991,\\n 199393991,\\n 199494991,\\n 199515991,\\n 199545991,\\n 199656991,\\n 199767991,\\n 199909991,\\n 199999991,\\n]\\n\\n"}
{"id": "486", "input": "class Solution:\\n def minKBitFlips(self, A: List[int], K: int) -> int:\\n n = len(A)\\n record = [0] * n\\n flip = 0\\n ans = 0\\n for i in range(n):\\n if i", "gt": ">= K: flip -= record[i-K]\\n if A[i] == (flip % 2):\\n if i > n - K: return -1\\n ans += 1\\n flip += 1\\n record[i] = 1\\n return ans\\n"}
{"id": "487", "input": "class Solution:\\n def queryString(self, S: str, N: int) -> bool:\\n for i in", "gt": "range(1,N+1):\\n b = bin(i).replace('0b','')\\n if b not in S:\\n return False\\n return True"}
{"id": "488", "input": "class Solution:\\n def longestDiverseString(self, a: int, b: int, c: int) -> str:\\n if a == 0 and b == 0 and c == 0:\\n return ''\\n\\n res = ''\\n\\n heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\\n heapq.heapify(heap)\\n prev_val = 0\\n prev_char = ''\\n\\n while heap:\\n v, char = heapq.heappop(heap)\\n", "gt": "if prev_val < 0:\\n heapq.heappush(heap, (prev_val, prev_char))\\n\\n if abs(v) >= 2:\\n if abs(v) > abs(prev_val):\\n res += char*2\\n v += 2\\n else:\\n res += char\\n v += 1\\n elif abs(v) == 1:\\n res += char\\n v +=1\\n elif abs(v) == 0:\\n break\\n\\n prev_val = v\\n prev_char = char\\n\\n return res"}
{"id": "489", "input": "class Solution:\\n def kthSmallest(self, matrix, k):\\n \"\"\"\\n :type matrix: List[List[int]]\\n :type k: int\\n :rtype: int\\n \"\"\"\\n", "gt": "arr = []\\n for i in matrix:\\n for j in i:\\n arr.append(j)\\n arr.sort()\\n print(arr)\\n return arr[k-1]"}
{"id": "490", "input": "class Solution:\\n def maxWidthRamp(self, A: List[int]) -> int:\\n width = 0\\n icandidate = [0]\\n for i in range(len(A)):\\n if A[i] < A[icandidate[-1]]:\\n", "gt": "icandidate.append(i)\\n for j in range(len(A) - 1, -1, -1):\\n while icandidate and A[icandidate[-1]] <= A[j]:\\n width = max(width, j - icandidate.pop())\\n return width"}
{"id": "491", "input": "class Solution:\\n def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\\n def dfs(node, visited):\\n if node in visited:\\n return\\n visited.add(node)\\n for nei in rooms[node]:\\n if", "gt": "nei in visited:\\n continue\\n dfs(nei,visited)\\n return\\n visited = set()\\n dfs(0, visited)\\n if len(visited) == len(rooms):\\n return True\\n else: \\n return False\\n \\n"}
{"id": "492", "input": "class Solution:\\n def findSubstringInWraproundString(self, p):\\n \"\"\"\\n :type p: str\\n :rtype: int\\n \"\"\"\\n pc = None\\n sl = 0\\n ll = {}\\n \\n for c in p:\\n if pc and (ord(pc) + 1 == ord(c) or (pc == 'z' and c == 'a')):\\n sl += 1\\n else:\\n sl = 1\\n ll[c] = max([ll[c], sl]) if c in ll else sl\\n pc = c\\n s = 0\\n for key, value in list(ll.items()):\\n s += value\\n return s\\n \\n \\n # def unique(p):\\n # pc = None\\n # sl = 0\\n #", "gt": "ll ="}
{"id": "493", "input": "class Solution:\\n def strWithout3a3b(self, A: int, B: int) -> str:\\n if A >= 2*B:\\n return 'aab'* B + 'a'* (A-2*B)\\n elif A >= B:\\n return 'aab' * (A-B)", "gt": "+ 'ab' * (2*B - A)\\n elif B >= 2*A:\\n return 'bba' * A + 'b' *(B-2*A)\\n else:\\n return 'bba' * (B-A) + 'ab' * (2*A - B)"}
{"id": "494", "input": "class Solution:\\n def findTargetSumWays(self, nums, S):\\n \"\"\"\\n :type nums: List[int]\\n :type S: int\\n :rtype: int\\n \"\"\"\\n c = [0]*1001\\n c[0] = 1\\n T = sum(nums)\\n A = T+S\\n if T<S", "gt": "or A&1:\\n return 0\\n A>>=1\\n nums = sorted(nums)\\n temp = 0\\n for ind, v in enumerate(nums):\\n temp += v\\n for i in range(min(temp, A), v-1, -1):\\n c[i] += c[i-v]\\n return c[A]"}
{"id": "495", "input": "class Solution:\\n def longestDecomposition(self, text: str) -> int:\\n n = len(text)\\n splits = 0\\n leftstart, leftend = 0, 0\\n rightstart, rightend = n-1, n-1\\n while leftend<rightstart:\\n", "gt": "if text[leftstart:leftend+1] == text[rightstart:rightend+1]:\\n leftstart = leftend+1\\n leftend = leftstart\\n rightstart = rightstart-1\\n rightend = rightstart\\n splits+=2\\n else:\\n leftend+=1\\n rightstart-=1\\n return splits+1 if leftstart<=rightend else splits"}
{"id": "496", "input": "class Solution:\\n def lastStoneWeightII(self, stones: List[int]) -> int:\\n dp = {0}\\n total = sum(stones)\\n for stone in stones:\\ndp |= {_sum + stone for", "gt": "_sum in dp}"}
{"id": "497", "input": "class Solution:\\n def minIncrementForUnique(self, A: List[int]) -> int:\\n if not A:\\n return 0\\n \\n A.sort()\\n prev = A[0]\\n res = 0\\n", "gt": "for num in A[1:]:\\n if num <= prev:\\n prev += 1\\n res += prev-num\\n\\n else:\\n prev = num\\n \\n return res\\n"}
{"id": "498", "input": "class Solution:\\n def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\\n \\n # max profit ending at time t\\n dp = [(0,0)]\\n \\n task = [(startTime[i], endTime[i], profit[i]) for i in range(len(startTime))]\\n task = sorted(task, key = lambda x: x[1])\\n", "gt": "\\n for s, e, p in task:\\n noTaskProf = dp[-1][1]\\n for end, pro in reversed(dp):\\n # end, pro = dp[i]\\n if end <= s:\\n doTaskProf = pro + p\\n break\\n if doTaskProf > noTaskProf:\\n dp.append((e, doTaskProf))\\n return dp[-1][1]\\n \\n \\n \\n"}
{"id": "499", "input": "class Solution:\\n def rob(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n if not nums:\\n return 0\\n if len(nums)==1:\\n return nums[0]\\n return", "gt": "max(self.helper(nums[1:]), self.helper(nums[:-1]))\\n \\n def helper(self,nums):\\n now = prev = 0\\n for nxt in nums:\\n now, prev = max(nxt+prev, now), now\\n return now\\n"}
{"id": "500", "input": "class Solution:\\n def minNumberOperations(self, target: List[int]) -> int:\\n prev = -1\\n ans = 0\\n for num in target:\\n if prev == -1:\\n prev", "gt": "= num\\n ans += num\\n continue\\n if num > prev:\\n ans += (num - prev)\\n #print(ans, num, prev)\\n prev = num\\n return ans"}
{"id": "501", "input": "class Solution:\\n def calculate(self, s):\\n \"\"\"\\n :type s: str\\n :rtype: int\\n \"\"\"\\n \\n if not s:\\n return 0\\n \\n pre_op = '+'\\n stack = [0]\\n cur_num = 0\\n digits = '0123456789'\\n s += '#'\\n \\n for c in s:\\n if c == ' ':\\n continue\\n \\n if c in digits:\\n cur_num = cur_num * 10 + int(c)\\n continue\\n", "gt": "\\n if pre_op == '-':\\n cur_num *= -1\\n elif pre_op == '*':\\n cur_num *= stack.pop()\\n elif pre_op == '/':\\n if cur_num == 0:\\n return None\\n \\n pre_num = stack.pop()\\n flag = 1 if pre_num > 0 else -1\\n cur_num = abs(pre_num) // cur_num * flag\\n \\n stack.append(cur_num)\\n pre_op = c\\n cur_num = 0\\n \\n return sum(stack)\\n \\n \\n \\n"}
{"id": "502", "input": "class Solution:\\n def shortestPalindrome(self, s):\\n if len(s)<2:\\n return s\\n if len(s)==40002:\\n return s[20000:][::-1]+s\\n for", "gt": "i in range(len(s)-1,-1,-1):\\n if s[i]==s[0]:\\n j=0\\n while j<(i+1)//2 and s[i-j]==s[j]:\\n j+=1\\n if j>=(i+1)//2:\\n return s[i+1:][::-1]+s"}
{"id": "503", "input": "class Solution(object):\\n def minMalwareSpread(self, graph, initial):\\n # 1. Color each component.\\n # colors[node] = the color of this node.\\n\\n N = len(graph)\\n colors = {}\\n c = 0\\n\\n def dfs(node, color):\\n colors[node] = color\\n for nei, adj in enumerate(graph[node]):\\n if adj and nei not in colors:\\n dfs(nei, color)\\n\\n for node in range(N):\\n if node not in colors:\\n dfs(node, c)\\n c += 1\\n\\n # 2. Size of each color.\\n # size[color] = number", "gt": "of occurrences of this color.\\n size = collections.Counter(colors.values())\\n\\n # 3. Find unique colors.\\n color_count = collections.Counter()\\n for node in initial:\\n color_count[colors[node]] += 1\\n\\n # 4. Answer\\n ans = float('inf')\\n for x in initial:\\n c = colors[x]\\n if color_count[c] == 1:\\n if ans == float('inf'):\\n ans = x\\n elif size[c] > size[colors[ans]]:\\n ans = x\\n elif size[c] == size[colors[ans]] and x < ans:\\n ans = x\\n\\n return ans if ans < float('inf') else min(initial)"}
{"id": "504", "input": "class Solution:\\n def arrangeWords(self, text: str) -> str:\\n p=text.split(' ')\\n final=''\\n j=sorted(p,key=len)\\n temp=' '.join(j)\\n if temp[0]>='a' and temp[0]<='z':\\n", "gt": "s=temp[0].swapcase()\\n final=final+s[0]\\n else:\\n final=final+temp[0]\\n for i in range(1,len(temp)):\\n if temp[i]>='A' and temp[i]<='Z':\\n s=temp[i].swapcase()\\n final=final+s[0]\\n else:\\n final=final+temp[i]\\n return final\\n \\n"}
{"id": "505", "input": "class Solution:\\n def reverseParentheses(self, s: str) -> str:\\n \\n \\n stack = []\\n curr = ''\\n for c in s:\\n if c=='(':\\n stack.append(curr)\\n curr =", "gt": "''\\n stack.append('(')\\n elif c==')':\\n stack.append(curr)\\n curr = ''\\n aux = ''\\n while stack and stack[-1]!='(':\\n aux=stack.pop()+aux\\n stack.pop()\\n stack.append(aux[::-1])\\n else:\\n curr+=c\\n if curr:\\n stack.append(curr)\\n return ''.join(stack)"}
{"id": "506", "input": "class Solution:\\n def minRemoveToMakeValid(self, s: str) -> str:\\n if not s: return s\\n l=0\\n r=0\\n res=''\\n for i,c in enumerate(s):\\n if c=='(':\\n l+=1\\n if c==')':\\n if", "gt": "l==r:\\n continue\\n else:\\n r+=1\\n res+=c\\n s=res\\n l=0\\n r=0\\n res=''\\n for i in range(len(s)-1,-1,-1):\\n c=s[i]\\n if c==')':\\n r+=1\\n if c=='(':\\n if l==r:\\n continue\\n else:\\n l+=1\\n res=c+res\\n return res"}
{"id": "507", "input": "class Solution:\\n def myAtoi(self, str):\\n \"\"\"\\n :type str: str\\n :rtype: int\\n \"\"\"\\n base = \"0123456789\"\\n plus = \"+\"\\n minus = \"-\"\\n sum = 0\\n flag = 1\\n bit = 0\\n INT_MAX = 2147483647\\n INT_MIN = -2147483648\\n \\n if not str:\\n return 0\\n \\n if len(str) == 0:\\n return 0\\n \\n for letter in str.strip():\\n if letter in plus:\\n if", "gt": "bit == 0:\\n bit = 1\\n continue\\n else:\\n break\\n elif letter in minus:\\n if bit == 0:\\n bit = 1\\n flag = -1\\n continue\\n else:\\n break\\n elif letter not in base:\\n break;\\n else:\\n sum *= 10\\n sum += int(letter)\\n \\n sum *= flag\\n \\n if(sum > INT_MAX):\\n return INT_MAX\\n \\n if(sum < INT_MIN):\\n return INT_MIN\\n \\n return sum\\n \\n \\n"}
{"id": "508", "input": "class Solution:\\n def singleNonDuplicate(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n return self.singleNonDuplicateUtil(nums, 0, len(nums)-1)\\n \\n def singleNonDuplicateUtil(self, nums, l, r):\\n if l < r:\\n mid = int((l + r) * 0.5)\\n \\n", "gt": "if mid-1>=0 and nums[mid-1]!=nums[mid]:\\n mid=mid-1\\n \\n if (mid - l + 1) % 2 == 0:\\n l = mid + 1\\n else:\\n r = mid\\n \\n \\n return self.singleNonDuplicateUtil(nums, l, r)\\n else:\\n return nums[l]"}
{"id": "509", "input": "from heapq import heapify, heappush, heappop\\nimport sys\\ninput = sys.stdin.readline\\n\\ndef solve():\\n N, Q = list(map(int, input().split()))\\n events = []\\n for i in range(N):\\n S, T, X = list(map(int, input().split()))\\n events.append((S-X-0.5, 1, X))\\n events.append((T-X-0.5, 0, X))\\n for i in range(Q):\\n D = int(input())\\n events.append((D, 2, i))\\n\\n events.sort()\\n\\n anss", "gt": "= [-1] * Q\\n PQ = []\\n isClosed = dict()\\n for tm, tp, x in events:\\n if tp == 0:\\n isClosed[x] = 0\\n elif tp == 1:\\n isClosed[x] = 1\\n heappush(PQ, x)\\n else:\\n while PQ:\\n if isClosed[PQ[0]] == 1:\\n anss[x] = PQ[0]\\n break\\n heappop(PQ)\\n\\n print(('\\n'.join(map(str, anss))))\\n\\n\\nsolve()\\n"}
{"id": "510", "input": "import sys\\nsys.setrecursionlimit(10**6)\\n\\nclass UnionFind():\\n def __init__(self, n):\\n self.n = n\\n self.parents = [-1] * n\\n\\n def find(self, x):\\n if self.parents[x] < 0:\\n return x\\n else:\\n self.parents[x] = self.find(self.parents[x])\\n return self.parents[x]\\n\\n def union(self, x, y):\\n x = self.find(x)\\n y = self.find(y)\\n\\n if x == y:\\n return\\n\\n if self.parents[x] > self.parents[y]:\\n x, y = y, x\\n\\n self.parents[x] += self.parents[y]\\n self.parents[y] = x\\n\\n def size(self, x):\\n return -self.parents[self.find(x)]\\n\\n def same(self, x, y):\\n return self.find(x) == self.find(y)\\n\\n def members(self, x):\\n root = self.find(x)\\n return [i for i in range(self.n) if self.find(i) == root]\\n\\n def roots(self):\\n return [i for i, x in enumerate(self.parents) if x <0]\\n\\n def group_count(self):\\n return len(self.roots())\\n\\n def all_group_members(self):\\n return {r: self.members(r) for", "gt": "r in self.roots()}"}
{"id": "511", "input": "n = int(input())\\ns = list(input())\\ns = [ord(i)-97 for i in s]\\n\\ndic = {}\\nfor i in range(26):\\n dic[i] = []\\n\\nfor i in range(n):\\n dic[s[i]].append(i)\\n\\nfor i in range(26):\\n dic[i].append(float('inf'))\\n\\nfrom bisect import bisect_left\\nq = int(input())\\nfor i in range(q):\\n x, y, z = input().split()\\n if x == '1':\\n y, z", "gt": "= int(y) - 1, ord(z) - 97\\n p = bisect_left(dic[s[y]], y)\\n dic[s[y]].pop(p)\\n dic[z].insert(bisect_left(dic[z], y), y)\\n s[y] = z\\n else:\\n res = 0\\n y, z = int(y) - 1, int(z) - 1\\n for i in range(26):\\n p = dic[i][bisect_left(dic[i], y)]\\n if p <= z:\\n res += 1\\n print(res)"}
{"id": "512", "input": "n=int(input())\\na=list(map(int,input().split()))\\n\\nX=[]\\nb=a[0]\\nfor i in range(1,n) :\\n b^=a[i]\\n\\nfor i in range(n)", "gt": ":\\n x=b^a[i]\\n X.append(x)\\n\\nfor i in X :\\n print(i,end=\" \")\\n"}
{"id": "513", "input": "import sys\\ninput = sys.stdin.readline\\nsys.setrecursionlimit(10**5)\\n\\nN, Q = map(int, input().split())\\n\\npath = [[] for _ in range(N)]\\n\\nfor _ in range(N-1) :\\n a, b, c, d = (int(i) for i in input().split())\\n path[a-1].append((b-1, c-1, d))\\n path[b-1].append((a-1, c-1, d))\\n\\n# doublingに必要なKを求める\\nfor K in range(18) :\\n if 2 ** K >= N :\\n break\\n\\n# dfs\\nparent = [[-1] * N for _ in range(K)]\\nrank = [-1 for _ in range(N)]\\n\\nrank[0] = 0\\nqueue = [0]\\n\\nwhile queue :\\n cur = queue.pop()\\n for nex, _, _ in path[cur] :\\n if rank[nex] < 0 :\\n queue.append(nex)\\n parent[0][nex] = cur\\n rank[nex] = rank[cur] + 1\\n\\n# doubling \\nfor i in range(1, K) :\\n for j in range(N) :\\n if parent[i-1][j] > 0 :\\n parent[i][j] = parent[i-1][parent[i-1][j]]\\n\\n# lca\\ndef lca(a, b) :\\n if rank[a] > rank[b] :\\n a, b = b, a\\n\\n diff = rank[b] - rank[a]\\n i = 0\\n while diff > 0 :\\n if diff & 1 :\\n b = parent[i][b]\\n diff", "gt": ">>= 1\\n i += 1\\n \\n if a == b :\\n return a\\n\\n for i in range(K-1, -1, -1) :\\n if parent[i][a] != parent[i][b] :\\n a = parent[i][a]\\n b = parent[i][b]\\n\\n return parent[0][a]\\n\\n# Queryの先読み\\nschedule = [[] for _ in range(N)]\\nfor i in range(Q) : \\n x, y, u, v = map(int, input().split())\\n x, u, v = x-1, u-1, v-1\\n l = lca(u, v)\\n schedule[u].append((i, 1, x, y))\\n schedule[v].append((i, 1, x, y))\\n schedule[l].append((i, -2, x, y))\\n\\nret = [0] * Q\\nC = [0] * (N-1)\\nD = [0] * (N-1)\\n\\ndef dfs(cur, pre, tot) :\\n for i, t, c, d in schedule[cur] :\\n ret[i] += t * (tot - D[c] + C[c] * d)\\n \\n for nex, c, d in path[cur] :\\n if nex == pre :\\n continue\\n C[c] += 1\\n D[c] += d\\n dfs(nex, cur, tot + d)\\n C[c] -= 1\\n D[c] -= d\\n\\ndfs(0, -1, 0)\\n \\nfor i in range(Q) :\\n print(ret[i])"}
{"id": "514", "input": "import bisect\\nimport sys\\nsys.setrecursionlimit(10**7)\\n\\ndef dfs(v):\\n pos=bisect.bisect_left(dp,arr[v])\\n changes.append((pos,dp[pos]))\\n dp[pos]=arr[v]\\n ans[v]=bisect.bisect_left(dp,10**18)\\n for u in g[v]:\\n if checked[u]==0:\\n checked[u]=1\\n dfs(u)\\n pos,val=changes.pop()\\n dp[pos]=val\\n\\n\\nn=int(input())\\narr=[0]+list(map(int,input().split()))\\ng=[[]", "gt": "for _ in range(n+1)]\\nfor _ in range(n-1):\\n a,b=map(int,input().split())\\n g[a].append(b)\\n g[b].append(a)\\nans=[0]*(n+1)\\nchecked=[0]*(n+1)\\nchecked[1]=1\\ndp=[10**18 for _ in range(n+1)]\\nchanges=[]\\ndfs(1)\\nfor i in range(1,n+1):\\n print(ans[i])"}
{"id": "515", "input": "m = int(input())\\nn =", "gt": "int(input())\\nprint(m-n) if m>n else print(m+n)"}
{"id": "516", "input": "# cook your dish here\\ndef modular_pow(base, exponent, modulus):\\n result = 1\\n while exponent > 0:\\n if(exponent %2 == 1):\\n result = (result * base) % modulus\\n exponent = exponent//2\\n base = (base * base)%modulus\\n return result\\ndef passesMillerRabinTest(n, a):\\n s = 0\\n d = n-1\\n while(d%2 == 0):\\n s += 1\\n d >>= 1\\n x = modular_pow(a, d, n)\\n if(x == 1 or x == n-1):\\n return True\\n for ss in range(s - 1):\\n x", "gt": "= (x*x)%n\\n if(x == 1):\\n return False\\n if(x == n-1):\\n return True\\n return False\\nprimeList = (2, 3,5,7,11,13,17,19, 23,29, 31,37)\\ndef isPrime(n):\\n for p in primeList:\\n if n%p == 0:\\n return n == p\\n for p in primeList:\\n if passesMillerRabinTest(n, p) == False:\\n return False\\n return True\\n \\nt = int(input())\\nfor tt in range(t):\\n n = int(input())\\n if(n == 2):\\n print(2)\\n continue\\n if n%2 == 0:\\n n -= 1\\n while True:\\n if(isPrime(n)):\\n print(n)\\n break\\n n -= 2\\n"}
{"id": "517", "input": "# cook your dish here\\ndef count(k,n,m):\\n sum1=(m*(m+1))//2\\n sum2=(m*(m-1))//2\\n ct=0\\n for i in range(n):\\n for j in range(n):\\n", "gt": "if i<j and k[i]>k[j]:\\n ct+=sum1\\n elif j<i and k[i]>k[j]:\\n ct+=sum2\\n return ct\\n\\ntest=int(input())\\nfor _ in range(test):\\n n,m=map(int,input().split())\\n k=list(map(int,input().split()))\\n print(count(k,n,m))\\n"}
{"id": "518", "input": "# cook your dish here\\r\\ndef offset(l, flag):\\r\\n x = 0\\r\\n # print(l)\\r\\n for i in range(1, len(l)):\\r\\n temp = []\\r\\n for j in range(i):\\r\\n v = getbig(l[i], l[j], fs)\\r\\n if v > 1:\\r\\n temp.append(v)\\r\\n if flag:\\r\\n x += 2**v - 2\\r\\n else:\\r\\n x -= 2**v - 2\\r\\n x += offset(temp, not flag)\\r\\n return x\\r\\n \\r\\ndef getbig(v1, v2, factors):\\r\\n x = 1\\r\\n for f in factors:\\r\\n while v1%f == 0 and v2%f == 0:\\r\\n v1//=f\\r\\n v2//=f\\r\\n", "gt": "x*=f\\r\\n return x\\r\\n \\r\\ndef prime_factors(n):\\r\\n i = 2\\r\\n factors = set()\\r\\n while i * i <= n:\\r\\n if n % i:\\r\\n i += 1\\r\\n else:\\r\\n n //= i\\r\\n factors.add(i)\\r\\n if n > 1:\\r\\n factors.add(n)\\r\\n return factors\\r\\n \\r\\nn,m = map(int, input().split())\\r\\nif n == 1:\\r\\n print(1)\\r\\nelse:\\r\\n fs = prime_factors(n)\\r\\n fs.discard(n)\\r\\n ans = 2**n-2\\r\\n temp = []\\r\\n for v in fs:\\r\\n v = n//v\\r\\n temp.append(v)\\r\\n ans -= 2**v - 2\\r\\n # print(ans)\\r\\n ans += offset(temp, True)\\r\\n # print(fs)\\r\\n print(ans%m)"}
{"id": "519", "input": "for _ in range(int(input())):\\n N=int(input())\\n", "gt": "if N%2==0:\\n print(N//2+1)\\n else:\\n print((N-1)//2+1)"}
{"id": "520", "input": "# cook your dish here\\r\\nimport bisect\\r\\nn, k1, *l = map(int, input().split())\\r\\nv_l, b_l = l[:n], l[n:]\\r\\n\\r\\nb_inv = {key:[] for key in range(2*k1)}\\r\\nfor i in range(n):\\r\\n b_l[i] -= 1\\r\\n b_inv[b_l[i]].append(i)\\r\\n\\r\\ndp = [[0 for _ in range(n)] for _ in range(n)]\\r\\nfor k in range(1, n):\\r\\n for j in range(n-2, -1, -1):\\r\\n if j+k >= n:\\r\\n continue\\r\\n", "gt": "\\r\\n dp[j][j+k] = max(dp[j][j+k], dp[j][j+k-1])\\r\\n if b_l[j+k] >= k1:\\r\\n left = bisect.bisect_right(b_inv[b_l[j+k]-k1], j)\\r\\n \\r\\n if b_l[j+k] >= k1:\\r\\n for i in b_inv[b_l[j+k]-k1][left:]:\\r\\n if i > j+k:\\r\\n break\\r\\n if i > j:\\r\\n dp[j][j+k] = max(dp[j][j+k], dp[j][i-1]+dp[i][j+k])\\r\\n \\r\\n if b_l[j+k]-k1 == b_l[j]:\\r\\n if j+k-1 < n:\\r\\n dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j]+dp[j+1][j+k-1])\\r\\n else:\\r\\n dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j])\\r\\n \\r\\n\\r\\nprint(dp[0][-1])"}
{"id": "521", "input": "# cook your dish here\\nt=int(input())\\nfor i in range(t):\\n n=input()\\n if(n=='b' or", "gt": "n=='B'):\\n print('BattleShip')\\n elif(n=='c' or n=='C'):\\n print('Cruiser')\\n elif(n=='d' or n=='D'):\\n print('Destroyer')\\n else:\\n print('Frigate')"}
{"id": "522", "input": "from math import *\\r\\nfrom collections import *\\r\\nimport sys\\r\\ninput=sys.stdin.readline\\r\\nt=int(input())\\r\\nwhile(t):\\r\\n t-=1\\r\\n n=int(input())\\r\\n a=list(map(int,input().split()))\\r\\n p,q=map(int,input().split())\\r\\n s=0\\r\\n a.sort()\\r\\n for i in range(n//2):\\r\\n x=a[i]\\r\\n x1=a[n-i-1]\\r\\n if(x==p or x1==p):\\r\\n s1=abs(x-x1)\\r\\n s2=q\\r\\n s+=abs(atan2(s1,s2))\\r\\n", "gt": "elif(x<p and x1>p):\\r\\n s1=abs(p-x)\\r\\n ex=atan2(s1,q)\\r\\n s1=abs(p-x1)\\r\\n ex1=atan2(s1,q)\\r\\n ex+=ex1\\r\\n s+=abs(ex)\\r\\n else:\\r\\n if(p<x):\\r\\n s1=abs(p-x)\\r\\n ex=atan2(s1,q)\\r\\n s1=abs(p-x1)\\r\\n ex1=atan2(s1,q)\\r\\n ex=ex1-ex\\r\\n s+=abs(ex)\\r\\n else:\\r\\n s1=abs(p-x)\\r\\n ex=atan2(s1,q)\\r\\n s1=abs(p-x1)\\r\\n ex1=atan2(s1,q)\\r\\n ex=ex-ex1\\r\\n s+=abs(ex) \\r\\n print(s)\\r\\n"}
{"id": "523", "input": "import sys\\r\\ndef get_array(): return list(map(int , sys.stdin.readline().strip().split()))\\r\\ndef get_ints(): return list(map(int, sys.stdin.readline().strip().split()))\\r\\ndef input():", "gt": "return sys.stdin.readline().strip()\\r\\nimport sys\\r\\nsys.setrecursionlimit(10**9)\\r\\nfrom math import sqrt,ceil,floor\\r\\nn=int(input())\\r\\nco=0\\r\\nans=0\\r\\nfor i in range(1,n):\\r\\n ans+=n//i\\r\\n if n%i==0:\\r\\n ans-=1\\r\\nprint(ans)\\r\\n\\r\\n"}
{"id": "524", "input": "f = 5003*[0]\\nmodn = 1000000007\\n\\n\\ndef qPow(a, b):\\n nonlocal modn\\n res = 1\\n while b > 0:\\n if (b & 1) == 1:\\n res = res * a % modn\\n a = a * a % modn\\n b = b >> 1\\n return res\\n\\n\\ndef getF():\\n nonlocal f\\n f[0] = 1\\n for i in range(1, 5001):\\n f[i] = f[i-1] * i\\n\\n\\ndef __starting_point():\\n getF()\\n T = int(input())\\n", "gt": "while T > 0:\\n T = T - 1\\n n, k = list(map(int,input().split()))\\n lis = list(map(int, input().split()))\\n lis = sorted(lis)\\n res = 1\\n for i in range(n):\\n zhi = f[n-1]//f[k-1]//f[n-k]\\n if i >= k-1:\\n zhi = zhi - f[i]//f[k-1]//f[i+1-k]\\n if n-i-1 >= k-1:\\n zhi = zhi - f[n-i-1]//f[k-1]//f[n-i-k]\\n zhi = zhi % (modn-1)\\n # print(zhi)\\n res = res * qPow(lis[i], zhi) % modn\\n print(res)\\n\\n__starting_point()"}
{"id": "525", "input": "arr = list(input())\\r\\nn = len(arr)\\r\\nans = list()\\r\\n#for i in arr:\\r\\n #ans.append(ord(i)-96)\\r\\nli = ['b','d','f','h','j','l','n','p','r','t','v','x','z']\\r\\ns = set(arr)\\r\\ntemp = s.intersection(li)\\r\\nfor _ in range(int(input())):\\r\\n x,y =", "gt": "list(map(int,input().split()))\\r\\n li = list(temp)\\r\\n #s = set()\\r\\n c=0\\r\\n for i in range(x-1,y):\\r\\n if arr[i] in li:\\r\\n c+=1 \\r\\n li.remove(arr[i])\\r\\n if len(li)==0:\\r\\n break\\r\\n print(c)\\r\\n"}
{"id": "526", "input": "# cook your dish here\\nfor t in", "gt": "range(int(input())):\\n a,b,c=map(int,input().split())\\n p=(c//a)*a+b\\n if p<=c:\\n print(p)\\n else:\\n print(((c//a)-1)*a+b)"}
{"id": "527", "input": "#include<sdg.h>\\nfor _ in range(int(input())):\\n s=input()\\n n=len(s)\\n if n==1:\\n if s[0].isalpha(): print(\"-32\")\\n else: print(0)\\n else:\\n num,ch=0,0\\n p,q=0,0\\n c=1\\n x=s[0]\\n ans=\"\"\\n for i in range(1,n):\\n if s[i-1]==s[i]:\\n", "gt": "c+=1\\n if i==n-1:\\n ans+=s[i-1]\\n ch+=1\\n if c>1:\\n ans+=str(c)\\n num+=1\\n c=1\\n else:\\n ans+=s[i-1]\\n ch+=1\\n if c>1:\\n ans+=str(c)\\n num+=1\\n c=1\\n if i==n-1:\\n ans+=s[i]\\n ch+=1\\n #print(ans,num,ch)\\n sol=(n*8)-((num*32)+(ch*8))\\n print(sol)"}
{"id": "528", "input": "def update(index, value, bi_tree):\\n while index < len(bi_tree):\\n bi_tree[index] += value\\n index += index & -index\\n\\n\\ndef get_sum(index, bi_tree):\\n ans = 0\\n while index > 0:\\n ans += bi_tree[index]\\n index -= index & -index\\n\\n return ans\\n\\n\\ndef get_range_sum(left, right, bi_tree):\\n ans = get_sum(right, bi_tree) - get_sum(left - 1, bi_tree)\\n return ans\\n\\n\\ndef solve(x):\\n s = set()\\n res = 1\\n i = 2\\n while (i * i <= x):\\n count = 0\\n while (x % i == 0):\\n x = x // i\\n count += 1\\n if (count % 2):\\n s.add(i)\\n i += 1\\n if (x > 0):\\n s.add(x)\\n", "gt": "return s\\n\\n\\nn = int(input())\\nl = [0] + [int(i) for i in input().split()]\\nbit = [[0 for i in range(n + 1)] for i in range(101)]\\n\\nfor i in range(1, n + 1):\\n s = solve(l[i])\\n for j in s:\\n update(i, 1, bit[j])\\n\\nq = int(input())\\nfor i in range(q):\\n k, a, b = [int(i) for i in input().split()]\\n if (k == 1):\\n f = 1\\n for i in range(2, 100):\\n res = get_range_sum(a, b, bit[i])\\n if (res % 2):\\n f = 0\\n break\\n if (f):\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n else:\\n s = solve(b)\\n for j in s:\\n update(a, 1, bit[j])"}
{"id": "529", "input": "# cook your dish here\\n\\nfrom sys import stdin,stdout\\nfrom collections import deque,defaultdict\\nfrom math import ceil,floor,inf,sqrt,factorial,gcd,log\\nfrom", "gt": "copy import deepcopy\\nii1=lambda:int(stdin.readline().strip())\\nis1=lambda:stdin.readline().strip()\\niia=lambda:list(map(int,stdin.readline().strip().split()))\\nisa=lambda:stdin.readline().strip().split()\\nmod=1000000007\\n\\nfor _ in range(ii1()):\\n n,l=iia()\\n if n==1:\\n print(l)\\n elif n==2:\\n print(int(log2(10))+1)\\n else:\\n print(ceil(l/(n+1)))\\n"}
{"id": "530", "input": "import math\\nfor _ in range(int(input())):\\n n=int(input())\\n s=int(math.sqrt(n))\\n ans=0\\n", "gt": "for i in range(1,s+1):\\n ans+=(n//i)\\n ans=ans*2-(s*s)\\n g=math.gcd(n*n,ans)\\n print(str(ans//g)+\"/\"+str(n*n//g))"}
{"id": "531", "input": "# cook your dish here\\n# cook your dish here\\nimport numpy as np\\nimport sys\\n\\ndef findSeq(n, s, k, m, M):\\n midInd = n // 2\\n seqs = []\\n for ind in range(midInd + 2, midInd - 3, -1):\\n if ind >= n or ind < 0:\\n continue \\n seq = genBestSeq(n, ind, m, M, s)\\n if seq is not -1 and testSeq(k, seq):\\n seqs.append(list(seq))\\n if len(seqs) == 0:\\n return -1\\n return min(seqs)\\n\\n#def findSeq(n, s, k, m, M):\\n# midInd = n // 2\\n# if k <= midInd: #and (n % 2 == 1 or s < m * midInd + M * (n - midInd)):\\n# return genBestSeq(n, midInd + 1, m, M, s) \\n# elif k > midInd + 1 and n % 2 == 1:\\n# return -1\\n# return genBestSeq(n, midInd, m, M, s)\\n\\ndef genBestSeq(n, diffInd, m, M, s):\\n #inc = M - m - 1\\n arr = np.full((n,), m)\\n arr[diffInd:] += 1\\n #remainder = s - np.sum(arr)\\n #if remainder < 0:\\n # return -1\\n\\n #nFull, remainder = divmod(remainder, inc)\\n #if nFull > n or (nFull == n and remainder >", "gt": "0):\\n # return -1\\n\\n #addingInd = n - nFull -1\\n #arr[addingInd + 1:] += inc\\n #arr[addingInd] += remainder\\n #return arr\\n s = s - np.sum(arr)\\n if s < 0:\\n return -1\\n inc = M - m - 1\\n ind = n - 1\\n while (ind >= 0):\\n z = min(inc, s)\\n arr[ind] += z\\n s -= z\\n ind -= 1\\n if s != 0:\\n return -1\\n return arr\\n\\ndef testSeq(k, seq):\\n seq = sorted(seq)\\n n = len(seq)\\n if n % 2 == 1:\\n median = seq[n // 2]\\n else:\\n median = (seq[n // 2 - 1] + seq[n // 2]) / 2\\n seq.pop(n % k)\\n seq.pop(k - 1)\\n return (median != seq[(n - 2) // 2]) \\n \\n\\ndef __starting_point():\\n nCases = int(input())\\n answers = []\\n #ks = []\\n for i in range(nCases):\\n #nums = [int(val) for val in input().split()]\\n #ks.append(nums[2])\\n #answers.append(findSeq(*nums))\\n answers.append(findSeq(*(int(val) for val in input().split())))\\n ans = answers[-1]\\n if not isinstance(ans, int):\\n print(*ans, sep=' ')\\n else:\\n print(ans)\\n #for i, ans in enumerate(answers):\\n\\n #for ans in answers:\\n # if isinstance(ans, np.ndarray):\\n # print(*ans, sep=' ')\\n # else:\\n # print(ans)\\n\\n__starting_point()"}
{"id": "532", "input": "# cook your dish here\\nn=int(input())\\ncounts=dict()\\nz=0\\nupper=None\\nfor i in range(0,n):\\n a,h= [int(num) for num in input().split()]\\n counts[a]=h\\nfor key,count in counts.items():\\n c=0\\n x=key-count\\n y=key+count\\n c1=0\\n c2=0\\n for j in counts.keys():\\n if j==key:\\n continue\\n else:\\n if x<=j<=key:\\n c1=0\\n break\\n else:\\n c1=1\\n for j in counts.keys():\\n if j==key:\\n continue\\n else:\\n if key<=j<=y:\\n c2=0\\n break\\n else:\\n c2=1\\n if c2==0 and c1==1:\\n if upper is", "gt": "None:\\n z=z+c1\\n upper=key\\n else:\\n if x>=upper:\\n z=z+c1\\n upper=key\\n else:\\n z=z+c2\\n upper=key\\n elif c2==1 and c1==0:\\n if upper is None:\\n z=z+c2\\n upper=y\\n else:\\n if upper<=key:\\n z=z+c2\\n upper=y\\n else:\\n z=z+c1\\n upper=y\\n elif c2==1 and c1==1:\\n if upper is None:\\n z=z+c1\\n upper=key\\n else:\\n if x>=upper:\\n z=z+c1\\n upper=key\\n else:\\n if upper<=key:\\n z=z+c2\\n upper=y\\n else:\\n z=z+0\\n upper=y\\n else:\\n z=z+0\\n upper=key\\nif len(counts)==1:\\n print(1)\\nelse:\\n print(z)"}
{"id": "533", "input": "n=int(input())\\nmodulo=15746\\nnum=[1,1]\\nfor i", "gt": "in range(2,n+1):\\n num.append((num[i-1]+num[i-2])%modulo)\\nprint(num[n])"}
{"id": "534", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n m,n=list(map(int,input().split()))\\n a=[int(i) for i in input().split()]\\n l=-1\\n for i", "gt": "in range(n-1,-1,-1):\\n if a[i]==m:\\n l=i\\n break\\n f=-1\\n for i in range(0,n):\\n if a[i]==m:\\n f=i\\n break\\n print(l-f)\\n \\n \\n"}
{"id": "535", "input": "def detect_triangle(adj): \\n for x in range(len(adj)):\\n for y in adj[x]:\\n if not set(adj[x]).isdisjoint(adj[y]):\\n return True\\n\\n \\nfor _ in range(int(input())):\\n n,m=list(map(int,input().split()))\\n graph=[[] for i in range(n)]\\n for i", "gt": "in range(m):\\n u,v=list(map(int,input().split()))\\n graph[u-1].append(v-1)\\n graph[v-1].append(u-1)\\n h=[] \\n for i in range(len(graph)):\\n h.append(len(graph[i]))\\n h1=max(h) \\n if h1>=3:\\n print(h1)\\n continue\\n if detect_triangle(graph):\\n print(3)\\n continue\\n print(h1) # cook your dish here\\n"}
{"id": "536", "input": "def C(n):\\n return n*(n-1)//2\\n\\n\\ndef sol():\\n equal, mini = False, min(N,M)\\n total_ways = 2*C(N * M)\\n if N==M:\\n equal = True\\n ways = 0\\n if not equal:\\n ways = (N*C(M)+M*C(N))\\n diag = 0\\n for i in range(2, mini+1):\\n diag += 2*C(i)\\n for i in range(mini+1,max(N,M)):\\n diag += C(mini)\\n diag *= 2\\n ways += diag\\n ways *= 2\\n else:\\n ways = (N*C(M)+M*C(N))\\n diag = 0\\n for i in range(2, mini):\\n diag += 2*C(i)\\n diag += C(mini)\\n diag *= 2\\n ways += diag\\n ways *=2\\n safe = total_ways - ways\\n l, r, t, d = Y-1,", "gt": "M-Y, X-1, N-X\\n safe_add, to_remove = 0, 0\\n\\n for i in range(1,N+1):\\n for j in range(1, M+1):\\n if i==X or j==Y or abs(i-X)==abs(j-Y):\\n continue\\n else:\\n to_remove += 1\\n\\n if l>0 and r>0 and t>0 and d>0:\\n dtl, dtr, dbl, dbr = min(l,t), min(r,t), min(l,d), min(r,d)\\n safe_add += dtl*dbr*2 + dtr*dbl*2\\n safe_add += t*d*2\\n safe_add += l*r*2\\n elif l>0 and r>0:\\n safe_add += l*r*2\\n elif t>0 and d>0:\\n safe_add += t*d*2\\n\\n safe += safe_add - to_remove*2\\n\\n return safe\\n\\n\\nT = int(input())\\nfor _ in range(T):\\n N, M, X, Y = [int(x) for x in input().split()]\\n print(sol())"}
{"id": "537", "input": "# cook your dish here\\nt=int(input())\\nfor", "gt": "i in range(t):\\n (n,k)=tuple(map(int,input().split()))\\n print(k//n)"}
{"id": "538", "input": "n,k=[int(x) for x in input().split()]\\r\\na=[int(x) for x in input().split()]\\r\\nans=0\\r\\nfor", "gt": "i in range(n-1):\\r\\n for j in range(i+1,n):\\r\\n if(abs(a[i]-a[j])>=k):\\r\\n ans+=1\\r\\nprint(ans)\\r\\n"}
{"id": "539", "input": "# cook your dish here\\nn=int(input())\\nfor i in range(n):\\n S, SG, FG, D, T = map(int, input().split())\\n", "gt": "speed = (D*180)/T + S\\n if abs(SG-speed) == abs(FG-speed):\\n print('DRAW')\\n elif abs(SG-speed) > abs(FG-speed):\\n print('FATHER')\\n else:\\n print('SEBI')"}
{"id": "540", "input": "# By Prathmesh Maurya\\nt=eval(input())\\nwhile(t!=0):\\n t-=1\\n n=eval(input())\\n if n%2", "gt": "== 0:\\n print(n*4)\\n elif n%4==3:\\n print(n)\\n else:\\n print(n*2)\\n"}
{"id": "541", "input": "\\r\\nfor __ in range(int(input())):\\r\\n n,m=map(int,input().split())\\r\\n arr=list(map(int,input().split()))\\r\\n s=set(arr)\\r\\n mex=-1\\r\\n ele=1\\r\\n for i in range(1,n+1):\\r\\n if i not in", "gt": "s:\\r\\n mex = i\\r\\n break\\r\\n if m>mex:\\r\\n print(-1)\\r\\n elif m==mex:\\r\\n print(n)\\r\\n else:\\r\\n c=arr.count(m)\\r\\n print(n-c)\\r\\n \\r\\n \\r\\n \\r\\n"}
{"id": "542", "input": "for i in range(int(input())):\\n n = int(input())\\n c = list(map(int, input().split()))\\n d = {}\\n d[0] = -1\\n parity = 0\\n ans = 0\\n for i in range(n):\\n parity", "gt": "^= 1 << (c[i]-1)\\n for t in range(30):\\n x = parity^(1<<t)\\n if(x in d.keys()):\\n ans = max(ans, i - d[x])\\n if parity not in d.keys():\\n d[parity] = i\\n print(ans//2)"}
{"id": "543", "input": "# cook your dish here\\nimport sys\\nimport math\\n\\ndef main(grid):\\n ans=0\\n for i in range(len(grid)):\\n for j in range(len(grid[0])):\\n first_point=grid[i][j]\\n for k in range(j+1,len(grid[0])):\\n second_point=grid[i][k]\\n if first_point==second_point:\\n", "gt": "dist=k-j\\n if i+dist<len(grid):\\n thrid_point=grid[i+dist][j]\\n fourth_point=grid[i+dist][k] \\n if second_point==thrid_point and second_point==fourth_point:\\n ans+=1\\n return ans\\n \\ntest=int(input())\\nfor _ in range(test):\\n n,m=input().split()\\n n=int(n)\\n arr=[]\\n for b in range(n):\\n arr.append(list(input()))\\n print(main(arr))"}
{"id": "544", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n tr=int(input())\\n trl=list(map(int,input().split()))\\n dr = int(input())\\n drl = list(map(int, input().split()))\\n ts = int(input())\\n tsl = list(map(int, input().split()))\\n ds = int(input())\\n dsl = list(map(int, input().split()))\\n for", "gt": "item in tsl:\\n if item in trl:\\n res=1\\n continue\\n else:\\n res=0\\n break\\n for item1 in dsl:\\n if item1 in drl:\\n res1=1\\n continue\\n else:\\n res1=0\\n break\\n if res==1 and res1==1:\\n print(\"yes\")\\n else:\\n print(\"no\")\\n"}
{"id": "545", "input": "# cook your dish here\\ndef decode(L,S):\\n str_2=\"\"\\n lst=[]\\n for i in range(L//4):\\n str_1 = \"abcdefghijklmnop\"\\n S_1=S[(i*4):(4*(i+1))]\\n for j", "gt": "in range(4):\\n if(S_1[j]==\"1\"):\\n str_1=str_1[len(str_1)//2:len(str_1)]\\n else:\\n str_1 = str_1[0:len(str_1) // 2]\\n str_2=str_2+str_1\\n print(str_2)\\n\\nT=int(input())\\nfor i in range(T):\\n L=int(input())\\n S=input()\\n decode(L,S)\\n"}
{"id": "546", "input": "for _ in range(int(input())):\\n n,k = list(map(int,input().split()))\\n array = []\\n tot = []\\n for _ in range(n):\\n temp = list(map(int,input().split()))\\n aa = temp[0]\\n del(temp[0])\\n temp.sort()\\n temp.insert(0,aa)\\n array.append(temp)\\n dic = {}\\n array.sort(reverse=True)\\n for i in array:\\n del(i[0])\\n", "gt": "for i in range(1,k+1):\\n dic[i] = False\\n count = 0\\n for i in array:\\n count += 1\\n # print(count,tot)\\n for j in i:\\n if(dic[j]==True):\\n pass\\n else:\\n tot.append(j)\\n dic[j]=True\\n if(len(tot)==k):\\n break\\n if(len(tot)!=k):\\n print(\"sad\")\\n elif(count!=n):\\n print(\"some\")\\n else:\\n print(\"all\")"}
{"id": "547", "input": "# cook your dish here\\r\\ntest=int(input())\\r\\nfor _", "gt": "in range(test):\\r\\n n=int(input())\\r\\n n=list(bin(n))\\r\\n ans=n.count('1')\\r\\n print(ans-1)"}
{"id": "548", "input": "import sys\\n\\nt = int(input())\\n\\ndef g(a,b):\\n if (a > b):\\n tmp = a\\n a = b\\n b = tmp\\n if (b == a):\\n return 0\\n if (b % a == 0):\\n return int(b/a)-1\\n r = g(b%a,a)\\n q = int(b/a)\\n if (r >= q):\\n return q-1\\n else:\\n return q\\n\\ndef mex(x):\\n n = len(list(x.keys()))\\n for i in range(n):\\n if (i not in x):\\n return i\\n return i\\n\\ndef g2(a,b):\\n if (a == b):\\n return 0\\n if (a > b):\\n", "gt": "tmp = a\\n a = b\\n b = tmp\\n if (b % a == 0):\\n return int(b/a)-1\\n q = int(b/a)\\n x ="}
{"id": "549", "input": "# cook your dish here\\nfor i in range(int(input())):\\n n=int(input())\\n p=1\\n l=n-1\\n for j in range(n):\\n for k in range(l):\\n print(\"", "gt": "\",end='')\\n for k in range(p):\\n print(\"*\",end='')\\n print()\\n for k in range(l):\\n print(\" \",end='')\\n for k in range(p):\\n print(\"*\",end='')\\n print()\\n p+=2\\n l-=1\\n"}
{"id": "550", "input": "import sys\\n \\nnum=int(sys.stdin.readline())\\ns=sys.stdin.readline().split()\\nsky=list(map(int,s))\\nsky.reverse()\\ncuts=0\\nchange=0\\nt=False\\ni=1\\n \\nwhile i<len(sky):\\n if sky[i]<=sky[i-1]:\\n for j in range(i-1,-1,-1):\\n \\n if sky[j]<=sky[i]-(i-j):\\n break\\n else:\\n change+=sky[j]-(sky[i]-(i-j))\\n \\n if change>=sky[i]:\\n change=sky[i]\\n t=True\\n break\\n", "gt": "\\n cuts+=change\\n \\n if t:\\n del sky[i]\\n t=False\\n i-=1\\n \\n else:\\n for j in range(i-1,-1,-1):\\n if sky[j]<sky[i]-(i-j):\\n break\\n else:\\n sky[j]=sky[i]-(i-j)\\n i+=1\\n \\n change=0\\n \\nprint(cuts)"}
{"id": "551", "input": "\\ndef main():\\n t = int(input())\\n while (t):\\n m, n = map(int, input().split())\\n a , b= bin(m)[2:],bin(n)[2:]\\n #print(a,b)\\n max = m^n\\n if len(a)>len(b):\\n diff =len(a)-len(b)\\n b= (\"0\"*diff)+b\\n #print(b)\\n elif len(a)<len(b):\\n diff =len(b)-len(a)\\n a=", "gt": "(\"0\"*diff)+a\\n #print(a)\\n ll = len(b)\\n count= 0\\n for i in range(ll-1):\\n s= b[ll-1] + b\\n s= s[:ll]\\n\\n tt= m^ int(s,2)\\n #print(m,s,tt)\\n if tt>max:\\n max =tt\\n count= i+1\\n b=s\\n\\n print(count,max)\\n t-=1\\n\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "552", "input": "t = int(input())\\n\\nfor _ in range(t):\\n s = [x for x in input()]\\n \\n freq = {}\\n \\n for i in s:\\n if i in freq:\\n freq[i] +=", "gt": "1\\n else:\\n freq[i] = 1\\n \\n flag = 0\\n \\n for keys, values in freq.items():\\n if(values >= 2):\\n flag = 1\\n break\\n \\n if(flag == 0):\\n print(\"no\")\\n else:\\n print(\"yes\")"}
{"id": "553", "input": "def main():\\n T = int(input())\\n for t in range(T):\\n N,K = map(int, input().split())\\n W = list(map(int, input().split()))\\n W.sort()\\n if 2*K", "gt": "> N:\\n K = N - K\\n kid = sum(W[:K])\\n dad = sum(W[K:])\\n\\n diff = dad - kid\\n\\n print(diff)\\n\\n\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "554", "input": "def eq_solve(v0, v1, u0, u1):\\r\\n den = u0 - v0\\r\\n num = u1 - v1\\r\\n if den != 0:\\r\\n return num / den\\r\\n return 1\\r\\n \\r\\ndef solve(p, q, r, a, b, c, rs):\\r\\n if p == a and q == b and r == c:\\r\\n return rs\\r\\n if rs >= 2:\\r\\n return 3\\r\\n res = 3\\r\\n adds = [a - p, b - q, c - r]\\r\\n muls = []\\r\\n if p != 0:\\r\\n muls.append(a / p)\\r\\n if q != 0:\\r\\n muls.append(b / q)\\r\\n if r != 0:\\r\\n muls.append(c / r)\\r\\n muls.append(eq_solve(p, a, q, b))\\r\\n muls.append(eq_solve(p, a, r, c))\\r\\n muls.append(eq_solve(q, b, r, c))\\r\\n msks = 2 ** 3\\r\\n for msk in range(msks):\\r\\n for add in adds:\\r\\n np = p\\r\\n nq = q\\r\\n nr = r\\r\\n if", "gt": "(msk & 1) > 0:\\r\\n np += add\\r\\n if (msk & 2) > 0:\\r\\n nq += add\\r\\n if (msk & 4) > 0:\\r\\n nr += add\\r\\n res = min(res, solve(np, nq, nr, a, b, c, rs + 1))\\r\\n for mul in muls:\\r\\n np = p\\r\\n nq = q\\r\\n nr = r\\r\\n if (msk & 1) > 0:\\r\\n np *= mul\\r\\n if (msk & 2) > 0:\\r\\n nq *= mul\\r\\n if (msk & 4) > 0:\\r\\n nr *= mul\\r\\n res = min(res, solve(np, nq, nr, a, b, c, rs + 1))\\r\\n return res\\r\\n \\r\\n \\r\\n \\r\\nt = int(input())\\r\\n \\r\\nwhile t > 0:\\r\\n p, q, r = map(int, input().split())\\r\\n a, b, c = map(int, input().split())\\r\\n z = solve(p, q, r, a, b, c, 0)\\r\\n print(z)\\r\\n t -= 1"}
{"id": "555", "input": "from math import log10\\nfrom decimal import Decimal\\ndef solve(n,k):\\n \\n mod=10**k\\n x=Decimal(n)\\n y=x*(x.log10())%1\\n p=str(pow(10,y))\\n c=0\\n first=''\\n for v in p:\\n if c==k:\\n", "gt": "break\\n if v==\".\":\\n continue\\n first+=v\\n c+=1\\n last=str(pow(n,n,mod)).zfill(k)\\n return (first,last)\\nqueries=[]\\nfor _ in range(int(input())):\\n n,k=list(map(int,input().split( )))\\n queries.append((n,k))\\nfor n,k in queries:\\n print(\"%s %s\"%(solve(n,k)))\\n \\n \\n"}
{"id": "556", "input": "t = eval(input())\\n\\nfor i in range(t):\\n n = eval(input())\\n a = list(map(int, input().split()))\\n cnt = 2\\n cnt1 = 2\\n ll = len(a)\\n if ll < 3:\\n cnt1 =", "gt": "ll\\n else:\\n for j in range(2,ll):\\n if a[j-1] + a[j-2] == a[j]:\\n cnt += 1\\n cnt1 = max(cnt1, cnt)\\n else:\\n cnt1 = max(cnt1, cnt)\\n cnt = 2\\n print(cnt1)"}
{"id": "557", "input": "\\r\\n\\r\\nz = int(input())\\r\\ni = 0\\r\\nwhile i < z:\\r\\n n = int(input())\\r\\n p = int(n**(0.5))\\r\\n if p*(p+1) < n:\\r\\n p += 1\\r\\n # print(\"P\", p)\\r\\n x, y = 0, 0\\r\\n q = 0\\r\\n flag = True\\r\\n if p*(p+1) == n:\\r\\n # print(\"Even steps, nice\")\\r\\n q = p\\r\\n else:\\r\\n # remaining steps\\r\\n q = p-1\\r\\n flag = False\\r\\n if q%2 :\\r\\n # odd\\r\\n x -= ((q+1)//2)\\r\\n y += ((q+1)//2)\\r\\n else :\\r\\n x += (q//2)\\r\\n y -= (q//2)\\r\\n if", "gt": "flag:\\r\\n print(x, y)\\r\\n else:\\r\\n # remaining steps\\r\\n l = q*(q+1)\\r\\n t = p*(p+1)\\r\\n diff = t-l\\r\\n \\r\\n\\r\\n # print(x, y)\\r\\n if x < 0:\\r\\n # left\\r\\n if n-l >= diff//2:\\r\\n y *= (-1)\\r\\n l += (diff//2)\\r\\n x += (n-l)\\r\\n else :\\r\\n y -= (n-l)\\r\\n \\r\\n else:\\r\\n # right\\r\\n if n-l >= diff//2:\\r\\n y *= (-1)\\r\\n y += 1\\r\\n l += (diff//2)\\r\\n x -= (n-l)\\r\\n else :\\r\\n y += (n-l)\\r\\n # print(\"Remaining steps: \", n-l)\\r\\n print(x, y)\\r\\n i+=1"}
{"id": "558", "input": "# cook your dish here\\nfor t in range(int(input())):\\n n,m=[int(x)for x in input().rstrip().split()]\\n s=[]\\n for p in range(n):\\n s.append(10)\\n", "gt": "for c in range(m):\\n i,j,k=[int(x)for x in input().rstrip().split()]\\n for q in range(i-1,j):\\n s[q]=s[q]*k\\n print(sum(s)//n)\\n \\n \\n \\n \\n"}
{"id": "559", "input": "from queue import PriorityQueue\\r\\nm,n=list(map(int,input().split()))\\r\\nrr=[]\\r\\ncc=[]\\r\\nspeed={'S':3,'O':2,'F':1}\\r\\nvisited=set()\\r\\ndp=[]\\r\\n\\r\\ndef qwerty(cur,x,y,f):\\r\\n if f==0:\\r\\n gg=rr[x][1]+y*rr[x][0]\\r\\n while gg<cur:\\r\\n gg+=(2*(n-1))*rr[x][0]\\r\\n return gg-cur+rr[x][0]\\r\\n elif f==1:\\r\\n gg=rr[x][1]+(2*(n-1)-y)*rr[x][0]\\r\\n while gg<cur:\\r\\n gg+=(2*(n-1))*rr[x][0]\\r\\n return gg-cur+rr[x][0]\\r\\n elif f==2:\\r\\n gg=cc[y][1]+x*cc[y][0]\\r\\n while gg<cur:\\r\\n gg+=(2*(m-1))*cc[y][0]\\r\\n return gg-cur+cc[y][0] \\r\\n elif f==3:\\r\\n gg=cc[y][1]+(2*(m-1)-x)*cc[y][0]\\r\\n while gg<cur:\\r\\n gg+=(2*(m-1))*cc[y][0]\\r\\n return gg-cur+cc[y][0]\\r\\n\\r\\n\\r\\ndirx=[0, 0, 1, -1]\\r\\ndiry=[1, -1, 0, 0]\\r\\n\\r\\nfor i in range(m):\\r\\n o=[x for x in input().split()]\\r\\n o[0]=speed[o[0]]\\r\\n o[1]=int(o[1])\\r\\n", "gt": "rr.append(o)\\r\\n\\r\\n\\r\\nfor i in range(n):\\r\\n o=[x for x in input().split()]\\r\\n o[0]=speed[o[0]]\\r\\n o[1]=int(o[1])\\r\\n cc.append(o)\\r\\n\\r\\n\\r\\nsx,sy,stt,dx,dy=list(map(int,input().split()))\\r\\nsx-=1\\r\\nsy-=1\\r\\ndx-=1\\r\\ndy-=1\\r\\n\\r\\nfor i in range(m):\\r\\n dp.append([10**9]*n)\\r\\n\\r\\ndp[sx][sy]=stt\\r\\npq = PriorityQueue()\\r\\npq.put((stt, sx, sy))\\r\\nwhile not pq.empty():\\r\\n #print(dp)\\r\\n (t,cxx,cyy)=pq.get()\\r\\n if (cxx,cyy) in visited:\\r\\n continue\\r\\n visited.add((cxx,cyy))\\r\\n for i in range(len(dirx)):\\r\\n nxx=cxx+dirx[i]\\r\\n nyy=cyy+diry[i]\\r\\n if nxx>=0 and nxx<m and nyy>=0 and nyy<n and (nxx,nyy) not in visited:\\r\\n coo=qwerty(dp[cxx][cyy],cxx,cyy,i)\\r\\n if coo+dp[cxx][cyy]<dp[nxx][nyy]:\\r\\n dp[nxx][nyy]=coo+dp[cxx][cyy]\\r\\n pq.put((dp[nxx][nyy],nxx,nyy))\\r\\n\\r\\nprint(dp[dx][dy])\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n \\r\\n\\r\\n\\r\\n\\r\\n"}
{"id": "560", "input": "import math\\nimport copy\\ntry:\\n import psyco\\n psyco.full()\\nexcept ImportError:\\n pass\\n \\ndef isSharp(ang):\\n return ang > math.pi/4 + 0.00001\\n \\ndef unitVector(p2, p1):\\n d0 = p2[0] - p1[0]\\n d1 = p2[1] - p1[1]\\n d = math.sqrt(d0*d0 + d1*d1)\\n if d != 0:\\n return [d0/d, d1/d]\\n return [0, 0]\\n \\ndef compVectors(P):\\n V = []\\n for i in range(1,len(P)):\\n v = unitVector(P[i], P[i-1])\\n if v[0] == 0 and v[1] == 0:\\n return None\\n V.append(v)\\n return V\\n \\ndef angle(v2, v1):\\n d = v2[0]*v1[0] + v2[1]*v1[1]\\n if d > 1:\\n d = 1\\n if d < -1:\\n d = -1\\n return math.acos(d)\\n \\ndef compAngles(V):\\n A = []\\n for i in range(len(V)-1):\\n A.append(angle(V[i+1], V[i]))\\n return A\\n \\ndef updateAngles(i, P, V, A):\\n if i-1 >= 0:\\n V[i-1] = unitVector(P[i], P[i-1])\\n if i+1 < len(P):\\n V[i] = unitVector(P[i+1], P[i])\\n if i-2 >= 0:\\n A[i-2] = angle(V[i-1], V[i-2])\\n if i-1 >= 0 and i+1 < len(P):\\n A[i-1] = angle(V[i], V[i-1])\\n if i+2 < len(P):\\n A[i] = angle(V[i+1], V[i])\\n \\ndef checkMoves(check, P, V, A, filled):\\n for i in check:\\n if i < 0 or i >= len(P):\\n break\\n x, y = P[i]\\n for j in range(51):\\n for k", "gt": "in range(51):\\n P[i][0] = j\\n P[i][1] = k\\n if str(P[i]) in filled:\\n continue\\n updateAngles(i, P, V, A)\\n fixed = True\\n if i-2 >= 0:\\n if isSharp(A[i-2]):\\n fixed = False\\n if i-1 >= 0 and i-1 < len(A):\\n if isSharp(A[i-1]):\\n fixed = False\\n if i < len(A):\\n if isSharp(A[i]):\\n fixed = False\\n if fixed:\\n return True\\n P[i] = [x, y]\\n updateAngles(i, P, V, A) \\n return False\\n \\n \\ndef canFix(first, last, P, V, A, filled):\\n d = last - first\\n if d > 2:\\n return False\\n if d == 2:\\n check = [first+2]\\n if d == 1:\\n check = [first+1, first+2]\\n if d == 0:\\n check = [first, first+1, first+2]\\n if checkMoves(check, P, V, A, filled):\\n return True\\n return False\\n \\nT=int(input())\\nfor i in range(T):\\n N=int(input())\\n P=[]\\n V=[]\\n filled="}
{"id": "561", "input": "# cook your dish here\\nfor i in range(int(input())):\\n N=int(input())\\n ALICE=list(map(int,input().split()))\\n", "gt": "BOB=list(map(int,input().split()))\\n ALICE[ALICE.index(max(ALICE))]=0\\n BOB[BOB.index(max(BOB))]=0\\n if sum(ALICE)<sum(BOB):\\n print(\"Alice\")\\n elif sum(BOB)<sum(ALICE):\\n print(\"Bob\")\\n else:\\n print(\"Draw\")"}
{"id": "562", "input": "def find_combinations(list, sum):\\n if not list:\\n if sum == 0:\\n return [[]]\\n return []\\n return find_combinations(list[1:], sum) + \\\\n [[list[0]]", "gt": "+ tail for tail in\\n find_combinations(list[1:], sum - list[0])]\\nfor tc in range(int(input())):\\n n,k=list(map(int,input().split()))\\n a=list(map(int,input().split()))\\n a.sort()\\n if len(find_combinations(a,k))==0:\\n print(\"NO\")\\n else:\\n print(\"YES\")\\n \\n"}
{"id": "563", "input": "# cook your dish here\\nn,m=map(int,input().split())\\nL=[]\\nfor i in range(n):\\n s=input()\\n L.append(s)\\n\\ncost=[]\\nh2=[0]*(m+1)\\ncost.append(h2)\\nfor i in range(n):\\n h=[0]\\n for j in range(m):\\n if(L[i][j]=='0' and (i+j)%2!=0):\\n h.append(1)\\n elif(L[i][j]=='1' and (i+j)%2==0):\\n h.append(1)\\n else:\\n h.append(0)\\n cost.append(h)\\n\\npre=[]\\nh2=[0]*(m+1)\\npre.append(h2)\\nfor i in range(1,n+1):\\n h=[0]\\n c=0\\n for j in", "gt": "range(1,m+1):\\n c+=cost[i][j]\\n c2=c\\n if(i>0):\\n c2+=pre[i-1][j]\\n h.append(c2)\\n pre.append(h)\\n\\nbs=[0]*((m*n)+10)\\n\\nfor i in range(1,n+1):\\n for j in range(1,m+1):\\n for k in range(1,min(m,n)+1):\\n if(i-k>=0 and j-k>=0):\\n c=pre[i][j]-pre[i-k][j]-pre[i][j-k]+pre[i-k][j-k]\\n c=min(c,(k*k)-c)\\n bs[c]=max(bs[c],k)\\n\\nmx=bs[0]\\nfor i in range(1,len(bs)):\\n mx=max(mx,bs[i])\\n bs[i]=mx\\n\\nQ=int(input())\\nq=[int(x) for x in input().split()]\\nfor i in range(0,len(q)):\\n qr=min(m*n,q[i])\\n print(bs[qr])\\n\\n\\n"}
{"id": "564", "input": "# cook your dish here\\nfor i in range(int(input())):\\n N = int(input())\\n l = list(map(int, input().split()))\\n for", "gt": "j in range(int(input())):\\n q1, q2 = map(int, input().split())\\n temp = l[q1 - 1 : q2]\\n print(sum(temp))"}
{"id": "565", "input": "for _ in range(int(input())):\\n n,k=list(map(int,input().split()))\\n c=list(map(int,input().split()))\\n count=1\\n for i in range(n):\\n", "gt": "if i+1<n:\\n if c[i]-c[i+1]>=k or c[i+1]-c[i]>=k:\\n continue\\n else:\\n count+=1\\n c[i],c[i+1]=c[i+1],c[i]\\n print(count)\\n \\n"}
{"id": "566", "input": "def f(a,y,index,sorted_pos):\\n #print(a,y,index,sorted_pos)\\n n=len(a)\\n low=0\\n high=n-1\\n L,R=0,0\\n l,r=0,0\\n while(low<=high):\\n mid=(low+high)//2\\n #print(low,high,mid)\\n if(a[mid]== y):\\n break\\n elif(mid > index[y]):\\n high=mid-1\\n L+=1\\n #print(\"L\")\\n if(a[mid] <y):\\n l+=1\\n #print(\" l \")\\n else:\\n low=mid+1\\n R+=1\\n #print(\"R\")\\n if(a[mid]>y):\\n r+=1\\n #print(\"r\")\\n x=sorted_pos[y]\\n #print(L,R,l,r,x,n-x-1)\\n", "gt": "if(R>x or L> n-x-1):\\n print(\"-1\")\\n else:\\n print(max(l,r))\\n\\n\\ndef fun():\\n test=int(input())\\n for t in range(test):\\n n,q=list(map(int,input().split()))\\n arr=list(map(int,input().split()))\\n index= dict()\\n for i in range(n):\\n index[arr[i]]=i\\n sorted_pos=dict()\\n a=sorted(arr)\\n for i in range(n):\\n sorted_pos[a[i]]=i\\n for x in range(q):\\n y=int(input())\\n f(arr,y,index,sorted_pos)\\n\\nfun()\\n\\n"}
{"id": "567", "input": "t=int(input())\\nfor _ in range (t):\\n str1=input()\\n str2=input()\\n res='No'\\n for", "gt": "i in str1:\\n if i in str2:\\n res='Yes'\\n break\\n print(res)\\n"}
{"id": "568", "input": "# cook your dish here\\nimport sys\\nimport math\\n\\ndef main(arr):\\n for i in range(1,len(arr)-1):\\n if", "gt": "arr[i]==arr[i-1] and arr[i]==arr[i+1]:\\n return \"Yes\"\\n return \"No\"\\n\\ntest=int(input())\\nfor _ in range(test):\\n b=int(input())\\n arr=list(map(int,input().split()))\\n print(main(arr))\\n\\n"}
{"id": "569", "input": "\\ntest=int(input())\\nfor t in range(test):\\n n= int(input())\\n\\n adj=[[] for i in range(n+1)]\\n\\n for _ in range(n-1):\\n a,b=list(map(int,input().split()))\\n adj[a].append(b)\\n adj[b].append(a)\\n \\n\\n #print(adj)\\n root=1\\n q,s=[root],set([root])\\n\\n for x in q:\\n adj[x]= [p for p in", "gt": "adj[x] if p not in s]\\n q.extend(adj[x])\\n s.update(adj[x])\\n\\n #print(adj)\\n ans=True\\n if(n<4):\\n ans=False\\n for i in range(n+1):\\n if(len(adj[i]) %3!=0):\\n ans=False\\n if(ans):\\n print(\"YES\")\\n for i in range(n+1):\\n while(len(adj[i])):\\n print(i,adj[i][0],adj[i][1],adj[i][2])\\n adj[i].pop(0)\\n adj[i].pop(0)\\n adj[i].pop(0)\\n else:\\n print(\"NO\")\\n"}
{"id": "570", "input": "from math import sqrt\\n\\nfor _ in range(int(input())):\\n n = int(input())\\n\\n x = int(sqrt(2 * n))\\n\\n while x * (x+1) // 2 <=", "gt": "n:\\n x += 1\\n\\n while x * (x+1) // 2 > n:\\n x -= 1\\n\\n n -= x * (x+1) // 2\\n\\n print(n)\\n"}
{"id": "571", "input": "# cook your dish here\\r\\nfrom collections import deque, defaultdict\\r\\nfrom math import sqrt, ceil,factorial\\r\\nimport sys\\r\\nimport copy\\r\\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\\r\\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\\r\\ndef input(): return sys.stdin.readline().strip()\\r\\n\\r\\nfor _ in range(int(input())):\\r\\n\\r\\n s=input()\\r\\n if len(s)>6:\\r\\n ans=0\\r\\n rem=len(s)-6\\r\\n ans+=factorial(len(s))\\r\\n ans-=2*(factorial(len(s)-2))\\r\\n ans+=factorial(rem+2)\\r\\n print(ans)\\r\\n\\r\\n else:\\r\\n if 'k' in s and 'r' in s and 'a' in s and 's' in s and 'h' in s and 'i' in s:\\r\\n ans = 0\\r\\n rem =", "gt": "len(s) - 6\\r\\n ans += factorial(len(s))\\r\\n ans -= 2 * (factorial(len(s) - 2))\\r\\n ans += factorial(rem + 2)\\r\\n print(ans)\\r\\n else:\\r\\n if 'k' in s and 'a' in s and 'r' in s:\\r\\n ans=0\\r\\n rem=len(s)-3\\r\\n ans+=factorial(len(s))\\r\\n ans-=factorial(rem+1)\\r\\n print(ans)\\r\\n continue\\r\\n if 's' in s and 'h' in s and 'i' in s:\\r\\n ans = 0\\r\\n rem = len(s) - 3\\r\\n ans += factorial(len(s))\\r\\n ans -= factorial(rem + 1)\\r\\n print(ans)\\r\\n continue\\r\\n\\r\\n print(factorial(len(s)))\\r\\n\\r\\n"}
{"id": "572", "input": "#! /usr/bin/env python\\n\\nfrom sys import stdin\\nfrom functools import reduce\\n\\ndef gcd(a,b):\\n while b!=0:\\n a,b=b,a%b\\n return a\\n \\ndef gcdl(l):\\n return reduce(gcd, l[1:],l[0])\\n\\ndef", "gt": "__starting_point():\\n T=int(stdin.readline())\\n for case in range(T):\\n numbers=list(map(int, stdin.readline().split()[1:]))\\n g=gcdl(numbers)\\n \\n numbers=[n/g for n in numbers]\\n print(\" \".join([str(x) for x in numbers]))\\n\\n__starting_point()"}
{"id": "573", "input": "for _ in range(int(input())):\\n a,o,g=map(int,input().split())\\n while g>0:\\n if a<o:\\n", "gt": "a+=1\\n g-=1\\n elif o<a:\\n o+=1\\n g-=1\\n else:\\n break\\n print(abs(a-o))"}
{"id": "574", "input": "for _ in range(int(input())):\\n n,m=map(int, input().split())\\n if", "gt": "n==1:\\n print(0)\\n elif n==2:\\n print(m)\\n else:\\n print(m*2+n-3)"}
{"id": "575", "input": "for t in range(int(input())):\\n n=int(input())\\n a=list(map(int,input().split()))\\n s=0\\n l=[]\\n for i in range(n):\\n if (a[i]<0):\\n e=i\\n ss=sum(a[s:e])\\n", "gt": "l.append((ss,e-s,n-s))\\n s=i+1\\n e=n\\n ss=sum(a[s:e])\\n l.append((ss,e-s,n-s))\\n x=max(l)\\n s=n-x[2]\\n e=x[1]+s\\n for i in range(s,e):\\n print(a[i], end=' ')\\n print(\"\")"}
{"id": "576", "input": "for _ in range(int(input())):\\n st=input().replace(\"=\",\"\")\\n if not len(st):print(1)\\n else:\\n", "gt": "cu=mx=1\\n for j in range(1,len(st)):\\n if st[j]==st[j-1]:cu+=1\\n else:mx=max(mx,cu);cu=1\\n print(max(mx+1,cu+1))\\n"}
{"id": "577", "input": "for _ in range(int(input())):\\r\\n S = input()\\r\\n n = len(S)\\r\\n a", "gt": "= n - S.count('a')\\r\\n print(2 ** n - 2 ** a)"}
{"id": "578", "input": "knows=input()\\nn=eval(input())\\nwhile n!=0:\\n n=n-1\\n word=input()\\n for x in word:\\n ctr=0\\nfor y in knows:\\n if x==y:ctr=ctr+1;break\\n if", "gt": "ctr==0:print('No');"}
{"id": "579", "input": "# cook your dish here\\nfor", "gt": "i in range(int(input())):\\n n,b=map(int,input().split())\\n ans=round(n/(2*b))*(n-b*round((n/(2*b))));\\n print(ans)"}
{"id": "580", "input": "t=int(input())\\ndef check():\\n pref = [0]*n\\n pref[0]=a[0]\\n suff = [0]*n\\n suff[-1]=a[-1]\\n for i in range (1,n):\\n pref[i] = pref[i-1]|a[i]\\n suff[n-i-1] = suff[n-i]|a[n-i-1]\\n if suff[1]==k:\\n return 0\\n elif pref[n-2]==k:\\n return n-1\\n else:\\n for i in range (1,n-1):\\n if pref[i-1]|suff[i+1] == k:\\n return i\\n return -1\\nwhile(t):\\n t-=1\\n n,k=[int(i) for i in input().split()]\\n a=[int(i) for i in input().split()]\\n ans", "gt": "= []\\n arr = [0]*n\\n for i in range (n):\\n if k|a[i] != k:\\n a[i] = a[i-1]|a[(i+1)%(n)]\\n ans.append(i+1)\\n arr[i]=1\\n\\n x = 0\\n count = 0\\n for i in range (n):\\n x|=a[i]\\n \\n if x!= k:\\n print(-1)\\n else:\\n y = check()\\n if y == -1:\\n print(-1)\\n else:\\n for i in range (y,n+y):\\n if arr[i%n]==0:\\n arr[i%n]==1\\n ans.append((i%n)+1)\\n print(*ans)"}
{"id": "581", "input": "from sys import stdin, stdout\\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\\nfrom collections import defaultdict as dd, deque\\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\\nmod = pow(10, 9) + 7\\nmod2 = 998244353\\ndef inp(): return stdin.readline().strip()\\ndef out(var, end=\"\\n\"): stdout.write(str(var)+\"\\n\")\\ndef outa(*var, end=\"\\n\"): stdout.write(' '.join(map(str, var)) + end)\\ndef lmp(): return list(mp())\\ndef mp(): return map(int, inp().split())\\ndef smp(): return map(str, inp().split())\\ndef l1d(n, val=0): return [val for i in range(n)]\\ndef l2d(n, m, val=0): return [l1d(n,", "gt": "val) for j in range(m)]\\ndef remadd(x, y): return 1 if x%y else 0\\ndef ceil(a,b): return (a+b-1)//b\\n\\ndef isprime(x):\\n if x<=1: return False\\n if x in (2, 3): return True\\n if x%2 == 0: return False\\n for i in range(3, int(sqrt(x))+1, 2):\\n if x%i == 0: return False\\n return True\\n\\nfor _ in range(int(inp())):\\n n = int(inp())\\n for i in range(n):\\n for j in range(n):\\n if i==0 or i==n-1 or j==0 or j==n-1 or i==j or i+j==n-1:\\n print(1, end=\"\")\\n else:\\n print(\" \", end=\"\")\\n print()"}
{"id": "582", "input": "# your code goes here\\nfrom sys import stdin, stdout\\nn = int(stdin.readline())\\nwhile n:\\n n -= 1\\n k, l, e = map(int,", "gt": "stdin.readline().strip().split(' '))\\n a = map(int, stdin.readline().strip().split(' '))\\n x = float(l) / float(e + sum(a))\\n if x - int(x):\\n stdout.write(\"NO\\n\")\\n else:\\n stdout.write(\"YES\\n\")"}
{"id": "583", "input": "import sys\\nimport bisect as bi\\nimport math\\nfrom collections import defaultdict as dd\\ninput=sys.stdin.readline\\n##sys.setrecursionlimit(10**7)\\ndef cin():\\n return list(map(int,sin().split()))\\ndef ain(): \\n return list(map(int,sin().split()))\\ndef sin():\\n return input()\\ndef inin():\\n return int(input())\\nfor _ in range(inin()):\\n s=sin().strip();q=inin();a=ain();n=len(s);store=[0]*n;store1=[-1]*n;f=0;d=dd(int)#input wgera\\n store[0]=1 if s[0]=='(' else -1\\n d[store[0]]=1\\n for i in range(1,n):\\n if(s[i]=='('):\\n store[i]=store[i-1]+1\\n d[store[i]]=i+1\\n else:\\n store[i]=store[i-1]-1\\n if(d[store[i-1]]):\\n store1[d[store[i-1]]-1]=i+1\\n post=[-1]*n;\\n if(n==1 or(n==2 and s!=\"()\")):f=1 # corner case\\n for i in range(n-2,-1,-1):\\n if(s[i]=='('): #dekhna h ki agla agr ( h toh -1 hi rhega wrna wo jo stored tha uppr\\n if(store1[i]!=-1):post[i]=store1[i] #wo iska ans ho jayega\\n else:post[i]=post[i+1]", "gt": "#jo iske agle ka answer hoga wahi iska hoga\\n for i in a:\\n if(f):print(-1) #cond ki jaroorat nhi thi pr tasalli (>_<)\\n else:print(post[i-1]) #wrna uska ans print kra do\\n \\n \\n##n=m=0\\n##s=''\\n##t=''\\n##dp=[]\\n##def solve(inds,indt,k,cont):\\n## ans=-999999999999999\\n## print(dp)\\n## if(k<0):return 0\\n## elif(inds>=n and indt>=m):return 0\\n## elif(dp[inds][indt][k][cont]!=-1):return dp[inds][indt][k][cont]\\n## else:\\n## if(indt<m):ans=max(ans,solve(inds,indt+1,k,0))\\n## if(inds<n):ans=max(ans,solve(inds+1,indt,k,0))\\n## if(s[inds]==t[indt]):\\n## ans=max(ans,solve(inds+1,indt+1,k-1,1)+1)\\n## if(cont):ans=max(ans,solve(inds+1,indt+1,k,1)+1)\\n## dp[inds][indt][k][cont]=ans\\n## return ans \\n\\n## n,m,k=cin()\\n## s=sin().strip()\\n## t=sin().strip()\\n## dp=[[[[-1]*2 for i in range(k)] for i in range(m+1)] for i in range(n+1)]\\n## c=0\\n## for i in dp:\\n## for j in i:\\n## for l in j:\\n## c+=1\\n## print(l,c)\\n## print(solve(0,0,k,0))\\n"}
{"id": "584", "input": "n=int(input())\\nfor i in range(n):\\n t=int(input())\\n m=list(map(int,input().split()))\\n p,q=0,0\\n if t==1:\\n if m[0]>=0:\\n print('YES')\\n else:\\n print('NO')\\n", "gt": "else:\\n for i in m:\\n if i<0:\\n q+=i\\n else:\\n p+=i\\n if p>=abs(q):\\n print('YES')\\n else:\\n print('NO')"}
{"id": "585", "input": "for z in range(int(input())):\\n s = input()\\n n = len(s)\\n i = 0\\n while i<n and", "gt": "s[i]=='1':\\n i+=1\\n if i==0:\\n print(0)\\n else:\\n k = 0\\n while i<n and s[i]=='0':\\n i+=1\\n k+=1\\n print(k)\\n"}
{"id": "586", "input": "import functools\\n\\ndef gcd(x,y):\\n if(y == 0):\\n return x\\n return gcd(y, x%y)\\n\\nfor _ in range(int(input())):\\n n, m= map(int, input().split())\\n p = list(map(int, input().split()))\\n \\n ans = functools.reduce(lambda x,y: gcd(x, y), p)\\n \\n", "gt": "if(ans <= n):\\n print(n-ans)\\n else:\\n f = [1]\\n for k in range(ans//2, 1, -1):\\n if ans %k == 0:\\n if k<=n:\\n f.append(k)\\n \\n if ans//k <= n:\\n f.append(ans//k)\\n res = n-max(f)\\n print(res)"}
{"id": "587", "input": "# cook your dish here\\nfor t in range(int(input())):\\n n,k=map(int,input().split())\\n a=[]\\n sr=[]\\n for i in range(k):\\n x,y=input().split()\\n y=int(y)\\n a.append([10**10-y,x])\\n sr.append(sorted(x))\\n for", "gt": "i in range(n-k):\\n x,y=input().split()\\n y=int(y)\\n x=sorted(x)\\n for j in range(k):\\n if x==sr[j]:\\n a[j][0]-=y\\n break\\n a.sort()\\n for i in a:\\n print(i[1],abs(i[0]-10**10))"}
{"id": "588", "input": "n=int(input())\\r\\na=list(map(int,input().split()))\\r\\nc=[]\\r\\nfor i in range(len(a)):\\r\\n", "gt": "if a[i]==2:\\r\\n c.append(1)\\r\\n else:\\r\\n c.append(a[i]^2)\\r\\nprint(*c)"}
{"id": "589", "input": "def gcd(a, b):\\n if a == 0:\\n return b\\n return(gcd(b % a, a))\\n\\nt = int(input())\\nfor T in range(t):\\n n = int(input())\\n l = [int(x) for x in input().split()]\\n\\n ang = []\\n for i in range(1, n):\\n ang.append(l[i] - l[i", "gt": "- 1])\\n ang.append(360 - (l[-1] - l[0]))\\n ang.sort()\\n if ang == ang[::-1]:\\n print(0)\\n continue\\n \\n g = ang[0]\\n for i in range(1, n):\\n g = gcd(g, ang[i])\\n\\n \\n total = 360 // g - len(ang)\\n print(total)\\n## print(g, ang, total)\\n\\n\\n"}
{"id": "590", "input": "# cook your dish here\\nfor i in range(int(input())):\\n s = input()\\n m = 0\\n p = 0\\n d = 0\\n l = []\\n for i in range(len(s)):\\n", "gt": "if(s[i] == \".\"):\\n m = m+1\\n elif(s[i] == \"#\"):\\n l.append(m)\\n m=0\\n for i in range(len(l)):\\n if(l[i]>p):\\n p = l[i]\\n d = d+1\\n print(d)\\n \\n \\n \\n \\n"}
{"id": "591", "input": "for _ in range(int(input())):\\n n,x,m = map(int,input().split())\\n a = list(map(int,input().split()))\\n for _", "gt": "in range(m):\\n for i in range(1,n):\\n a[i] = a[i] + a[i-1]\\n print(a[x-1]%(10**9+7))"}
{"id": "592", "input": "for _ in range(int(input())):\\n N = input()\\n num = list(N)\\n", "gt": "s=0\\n for n in num:\\n if n.isnumeric():\\n s+=int(n)\\n #print(s)\\n x=(10-s%10)%10\\n print(int(N)*10+int(x))"}
{"id": "593", "input": "import sys\\n\\ndef mex(S,W,C,start,end):\\n \"\"\"Returns Nim-number of S[start:end]\"\"\"\\n key=(start,end)\\n try:\\n return C[key]\\n except KeyError:\\n pass\\n A=set()\\n for s in range(start,end):\\n for e in range(start+1,end+1):\\n if S[s:e] not in W:", "gt": "continue\\n A.add(mex(S,W,C,start,s)^mex(S,W,C,e,end))\\n a=0\\n while a in A: a+=1\\n C[key]=a\\n return a\\n \\n\\na=sys.stdin\\n#a=open('astrgame.txt','r')\\nT=int(a.readline())\\nfor t in range(T):\\n S=a.readline().strip()\\n N=int(a.readline())\\n W=set([a.readline().strip() for n in range(N)])\\n print('Teddy' if mex(S,W,"}
{"id": "594", "input": "# cook your dish here\\n# cook your dish here\\nfor i in range(int(input())):\\n a=list(map(int,input().split()))\\n", "gt": "x=input()\\n t=0\\n for i in range(ord('a'),ord('z')+1):\\n if chr(i) not in x:\\n t+=a[i-97]\\n print(t)"}
{"id": "595", "input": "def solve(a,n):\\n max1=curr=a[0]\\n for i in range(1,n):\\n curr=max(a[i],curr+a[i])\\n", "gt": "max1=max(max1,curr)\\n return max1\\n \\nn,k = list(map(int,input().split()))\\na = list(map(int,input().split()))\\nprint(sum(a)-solve(a,n)+solve(a,n)/k)\\n"}
{"id": "596", "input": "def binarySearch(arr, l, r, x):\\n mid=0\\n while l <= r: \\n mid = l + (r - l)//2; \\n if arr[mid] == x: \\n return mid+1 \\n elif arr[mid] < x: \\n l = mid + 1\\n else: \\n r = mid - 1\\n if mid!=len(arr):\\n if arr[mid]<x:\\n return mid+1\\n return mid\\ns=input()\\nstrt=[]\\nend=[]\\nplc=[]\\nlandr=[]\\nl2r=[]\\nlr=[]\\nans=0\\nn=len(s)\\nif n!=1:\\n for i in range(n):\\n strt.append([])\\n end.append([])\\n landr.append([0]*n)\\n l2r.append([0]*n)\\n for i in range(n): \\n for j in range(n):\\n if i-j<0 or i+j>=n:\\n break\\n if", "gt": "(s[i-j]==s[i+j]):\\n if i-j-1>=0:\\n strt[i-j-1].append(2*j+1)\\n if i+j+1<n:\\n end[i+j+1].append(2*j+1)\\n else:\\n break\\n for i in range(n):\\n for j in range(n):\\n if i-j<0 or i+j+1>=n:\\n break\\n if (s[i-j]==s[i+j+1]):\\n if i-j-1>=0:\\n strt[i-j-1].append(2*j+2)\\n if i+j+2<n:\\n end[i+j+2].append(2*j+2)\\n else:\\n break\\n for i in range(n):\\n end[i].sort()\\n strt[i].sort()\\n for i in range(n-1):\\n for j in range(i+1,n):\\n if s[i]==s[j]:\\n lr.append([i,j])\\n if i>0 and j<n-1:\\n landr[i][j]=landr[i-1][j+1]+1\\n else:\\n landr[i][j]=1\\n for i in lr:\\n tempans=1\\n l=i[0]\\n r=i[1]\\n length=r-l-1\\n tempans+=binarySearch(strt[l],0,len(strt[l])-1,length)\\n tempans+=binarySearch(end[r],0,len(end[r])-1,length)\\n l2r[l][r]=tempans\\n for i in range(n):\\n for j in range(n):\\n ans+=l2r[i][j]*landr[i][j]\\nprint(ans)"}
{"id": "597", "input": "import sys\\nfrom random import choice,randint\\ninp=sys.stdin.readline\\nout=sys.stdout.write\\nflsh=sys.stdout.flush\\n \\nsys.setrecursionlimit(10**9)\\ninf = 10**20\\neps = 1.0 / 10**10\\nmod = 10**9+7\\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\\n \\ndef MI(): return map(int, inp().strip().split())\\ndef LI(): return list(map(int, inp().strip().split()))\\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines().strip()]\\ndef LI_(): return [int(x)-1 for x in inp().strip().split()]\\ndef LF(): return [float(x) for x in inp().strip().split()]\\ndef LS(): return inp().strip().split()\\ndef I(): return int(inp().strip())\\ndef F(): return float(inp().strip())\\ndef S(): return inp().strip()\\ndef pf(s): return out(s+'\\n')\\ndef JA(a, sep): return sep.join(map(str, a))\\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\\n\\ndef main():\\n from", "gt": "math import ceil\\n t = I()\\n l = []\\n for _ in range(t):\\n n,k=MI()\\n if n==0:\\n k-=1\\n ans = ((k)*((k+1)))%mod\\n l.append(ans)\\n else:\\n # if k==1:\\n # ans = ((((n)*((n-1)))%mod)+ n%mod)%mod\\n # l.append(ans)\\n # else:\\n # k-=1\\n # lr = (n%mod+((ceil(k/2)%mod))%mod\\n # ans = ((lr*((lr-1))%mod\\n # if k%2!=0:\\n # ans= (ans%mod + n%mod)%mod\\n # else:\\n # ans = ((ans%mod)+((lr+n)%mod))%mod\\n # l.append(ans)\\n if k%2!=0:\\n lr = k//2\\n l.append(((n*n)%mod+(lr*((2*n)%mod))%mod+(lr*(lr+1))%mod)%mod)\\n else:\\n lr = k//2\\n l.append(((n*n)%mod + (lr*(2*n)%mod)%mod + (lr*(lr-1))%mod)%mod)\\n\\n for i in range(t):\\n pf(str(l[i]))\\n\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "598", "input": "# cook your dish here\\nt = int(input())\\nfor _ in range(t):\\n n = int(input())\\n a = []\\n b = []\\n for i in range(n):\\n x,y = list(map(int, input().split()))\\n a.append(x)\\n", "gt": "b.append(y)\\n b.sort()\\n xcor = []\\n xcor.append(a[1]-a[0])\\n xcor.append(a[n-1]-a[n-2])\\n for i in range(1,n-1):\\n xcor.append(a[i+1]-a[i-1])\\n xcor.sort()\\n ans = 0\\n #print(xcor)\\n #print(b)\\n for i in range(n):\\n ans = ans + xcor[i]*b[i]\\n print(ans) \\n"}
{"id": "599", "input": "n, k = list(map(int, input().split()))\\nA = list(map(int, input().split()))\\nmaximum = max(A)\\nminimum = min(A)\\nif k == 0:\\n for i in A:\\n print(i,", "gt": "end=' ')\\nelif k&1:\\n for i in A:\\n print(maximum - i, end=' ')\\nelse:\\n for i in A:\\n print(i - minimum, end=' ')\\n"}
{"id": "600", "input": "from collections import deque\\nt=int(input())\\n\\nfor i in range(t):\\n n=int(input())\\n N=[i for i in range(1, n+1)]\\n w=list(map(int, input().split()))\\n max_sweetness=max(w)\\n sizes=[]\\n cnt=0\\n for i in", "gt": "range(n):\\n if w[i]!=max_sweetness:\\n cnt+= 1 \\n else:\\n sizes.append(cnt)\\n cnt=0\\n \\n if cnt!=0:\\n sizes[0]=(cnt+sizes[0])\\n \\n res=0\\n for i in range(len(sizes)):\\n res+=max(sizes[i]-n//2+1, 0)\\n \\n print(res)"}
{"id": "601", "input": "import math\\n\\nt = int(input())\\n\\na = [-1, 0, 1]\\n\\nfor i in range(58):\\n temp = a[-1] + a[-2]\\n temp = temp%10\\n a.append(temp)\\n", "gt": "\\nfor _ in range(t):\\n n = int(input())\\n \\n temp = len(bin(n)) - 3\\n temp = 2**temp\\n temp = temp%60\\n \\n print(a[temp])"}
{"id": "602", "input": "# cook your dish here\\nn=(int(input()))\\nx=[]\\nfor _ in range(n):\\n a,b=map(int,input().split())\\n a=[a,a+b]\\n x.append(a)\\nx", "gt": "= sorted(x, key= lambda i:i[1])\\ny=-1\\nc=0\\nfor i in range(len(x)):\\n if x[i][0]>y:\\n c+=1\\n y=x[i][1]\\nprint(c)"}
{"id": "603", "input": "m= 9999999\\r\\nword=''\\r\\np= ''\\r\\ntry:\\r\\n s=input().split()\\r\\n for i in s:\\r\\n if(len(i) <= m):\\r\\n m = len(i)\\r\\n word = i\\r\\n", "gt": "p = word\\r\\n for i in s:\\r\\n p+= (' '+i+' '+ word)\\r\\n \\r\\n print(p)\\r\\n\\r\\n \\r\\nexcept EOFError:\\r\\n\\r\\n pass"}
{"id": "604", "input": "for i in range(int(input())):\\n N = int(input())\\n s = 'zyxwvutsrqponmlkjihgfedcba'\\n r = ''\\n while True:\\n", "gt": "r = s[-N-1:] + r \\n if N < 26:\\n break\\n N -= 25\\n print(r)"}
{"id": "605", "input": "for _ in range(int(input())):\\n r,c = map(int,input().split())\\n l = []\\n for k in range(r):\\n a = list(map(int,input().split()))\\n l.append(a)\\n ans = \"Stable\" \\n for i in range(r):\\n for j in range(c):\\n p =", "gt": "l[i][j]\\n count=0\\n if i-1>=0 and j>=0:\\n count+=1 \\n if i>=0 and j-1>=0:\\n count+=1 \\n if i+1<=r-1 and j<=c-1:\\n count+=1 \\n if i<=r-1 and j+1<=c-1:\\n count +=1\\n if count<=p:\\n ans = \"Unstable\"\\n break\\n print(ans)"}
{"id": "606", "input": "# cook your dish here\\ntest=int(input())\\nfor _ in range(test):\\n b=list(map(int,str(input()).split(' ')))\\n c=str(input())\\n li1=[0]\\n li2=[0]\\n for i1 in range(len(c)):\\n", "gt": "if c[i1]=='R':\\n li1.append(li1[len(li1)-1]+1)\\n elif c[i1]=='L':\\n li1.append(li1[len(li1)-1]-1)\\n elif c[i1]=='U':\\n li2.append(li2[len(li2)-1]+1)\\n else:\\n li2.append(li2[len(li2)-1]-1)\\n if (max(li1)-min(li1)+1)<=b[1] and (max(li2)-min(li2)+1)<=b[0]:\\n print('safe')\\n else:\\n print('unsafe')"}
{"id": "607", "input": "# cook your dish here\\nT = int(input())\\nfor i in range(T):\\n l = list(map(int, input().split()))\\n n, k, m, x = l[0], l[1], l[2], l[3]\\n if k == 1:\\n if n == m:\\n print(\"yes\")\\n else:\\n print(\"no\")\\n elif m % k > 1:\\n print(\"no\")\\n elif k == 2:\\n stack = []\\n var = 0\\n while m != 0:\\n var += m % k\\n stack.append(m % k)\\n m //= k\\n if var > n:\\n print(\"no\")\\n elif var == n:\\n print(\"yes\")\\n", "gt": "else:\\n for p in range(100):\\n for q in range(2, len(stack)):\\n if stack[q - 1] == 0 and stack[q] >= 1:\\n stack[q-1] = 2\\n stack[q] -= 1\\n var += 1\\n if var == n:\\n print(\"yes\")\\n if var < n:\\n print(\"no\")\\n else:\\n temp = 0\\n rog = 1\\n while m != 0:\\n if m % k > 2:\\n rog = 0\\n print(\"no\")\\n temp += m % k\\n m //= k\\n if rog:\\n if temp == n:\\n print(\"yes\")\\n else:\\n print(\"no\")\\n\\n"}
{"id": "608", "input": "'''input\\n2\\n3\\n2 2 3\\n4\\n2 3 3 2\\n'''\\nimport math\\n\\nfor _ in range(int(input())):\\n n = int(input())\\n a = list(map(int, input().split()))\\n count = 0\\n i = 0\\n while i < len(a):\\n if a[i] == 1:\\n count += 1\\n i", "gt": "+= 1\\n continue\\n curr_gcd = a[i]\\n while i < len(a) and curr_gcd != 1:\\n curr_gcd = math.gcd(curr_gcd, a[i])\\n if curr_gcd == 1:\\n count += 1\\n i += 1\\n # print(i)\\n break\\n i += 1\\n print(count)\\n"}
{"id": "609", "input": "for i in range(int(input())):\\n n = int(input())\\n P = list(map(float, input().split()))\\n pr = 1\\n for p in P:\\n a = 100+p\\n pr = (pr*a)/100\\n pr = (pr-1)*100\\n x = 6-len(str(int(abs(pr))))\\n if (x==1):\\n if (pr==0):\\n print(0)\\n elif (pr>0):\\n print(\"+\"+str(\"%.1f\" % round(pr,x)))\\n else:\\n print(str(\"%.1f\" % round(pr,x)))\\n elif (x==2):\\n if (pr==0):\\n print(0)\\n elif (pr>0):\\n print(\"+\"+str(\"%.2f\" % round(pr,x)))\\n else:\\n print(str(\"%.2f\" %", "gt": "round(pr,x)))\\n elif (x==3):\\n if (pr==0):\\n print(0)\\n elif (pr>0):\\n print(\"+\"+str(\"%.3f\" % round(pr,x)))\\n else:\\n print(str(\"%.3f\" % round(pr,x)))\\n elif (x==4):\\n if (pr==0):\\n print(0)\\n elif (pr>0):\\n print(\"+\"+str(\"%.4f\" % round(pr,x)))\\n else:\\n print(str(\"%.4f\" % round(pr,x)))\\n elif (x==5):\\n if (pr==0):\\n print(0)\\n elif (pr>0):\\n print(\"+\"+str(\"%.5f\" % round(pr,x)))\\n else:\\n print(str(\"%.5f\" % round(pr,x)))\\n elif (x==6):\\n if (pr==0):\\n print(0)\\n elif (pr>0):\\n print(\"+\"+str(\"%.6f\" % round(pr,x)))\\n else:\\n print(str(\"%.6f\" % round(pr,x)))"}
{"id": "610", "input": "# cook your dish here\\n\\nt=int(input())\\nwhile(t):\\n t=t-1\\n n,k=list(map(int,input().split()))\\n q=list(map(int,input().split()))\\n days,rem=0,0\\n for i", "gt": "in range(n):\\n rem+=q[i]\\n if(rem>=k):\\n rem-=k\\n else:\\n days=i+1\\n break\\n days+=1\\n if(rem>=k):\\n days+=(rem//k)+1\\n print(days)\\n"}
{"id": "611", "input": "# cook your dish here\\nt=int(input())\\nwhile t>0:\\n n=int(input())\\n l=list(map(int,input().split()))\\n l1=[]\\n c=1\\n for i in range(len(l)):\\n if l[i]==1:\\n", "gt": "l1.append(i)\\n for j in range(len(l1)-1):\\n if l1[j+1]-l1[j]<6:\\n c=0\\n break\\n if c:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n \\n t-=1"}
{"id": "612", "input": "# cook your dish here\\n\\nt=int(input())\\n\\nfor i in range(t):\\n n=int(input())\\n a=list(map(int,input().split()))\\n d={}\\n for i in range(n):\\n if a[i]-1 not in d:\\n d[a[i]-1]=[i]\\n else:\\n d[a[i]-1].append(i)\\n ans=False\\n d1={}\\n \\n", "gt": "for i in d:\\n if ans==True:\\n break\\n for j in d:\\n if i!=j:\\n if a[i]==a[j] and i!=j:\\n ans=True\\n break\\n if ans==True:\\n print('Truly Happy')\\n else:\\n print('Poor Chef')\\n"}
{"id": "613", "input": "# cook your dish here\\nt=int(input())\\nfor i in range(t):\\n s=input()\\n fl=-1\\n n=len(s)\\n", "gt": "for i in range(n-2):\\n if(s[i:i+3]==\"010\" or s[i:i+3]==\"101\"):\\n fl=0\\n print(\"Good\")\\n break\\n\\n if(fl==-1):\\n print(\"Bad\")\\n"}
{"id": "614", "input": "def check(s):\\n arr=[s[0]]\\n l=len(s)\\n f1=0\\n for i in range(1,l):\\n if arr==[]: arr.append(s[i])\\n elif arr[-1]!=s[i]:arr.append(s[i])\\n else: del arr[-1]\\n", "gt": "if arr==[]: return True\\n else: return False\\n \\ncount = 0\\nfor t in range(eval(input())):\\n s=input().strip()\\n if check(s): count+=1\\nprint(count)"}
{"id": "615", "input": "from itertools import permutations as p\\ndef disc(a,b):\\n for ai in a:\\n for bi in b:\\n if ai==bi:\\n return False\\n return True\\n\\nfor i in range(eval(input())):\\n n = eval(input())\\n arr = list(map(int,input().split()))\\n perms = list(p(arr))\\n m = eval(input())\\n offer = {}\\n for i in range(m):\\n dup = list(map(int,input().split()))\\n try:\\n offer[dup[0]].append(dup[1:])\\n except:\\n offer[dup[0]] = [dup[1:]]\\n ans = sum(arr)\\n if n==1:\\n print(ans)\\n elif n==2:\\n try:\\n if len(offer[2])>=1:\\n ans -= min(arr)\\n except:\\n pass\\n print(ans)\\n elif n==3:\\n try:\\n if len(offer[3])>=1:\\n ans -= min(arr)\\n except:\\n pass\\n try:\\n if len(offer[2])>=1:\\n value = 9999999999\\n for item in perms:\\n cur = 0\\n cur += item[0]\\n cur += max(item[1],item[2])\\n if cur<value:\\n value = cur\\n if value<ans:\\n ans = value\\n except:\\n pass\\n print(ans)\\n elif n==4:\\n try:\\n if len(offer[4])>=1:\\n ans -= min(arr)\\n except:\\n pass\\n #print ans\\n try:\\n if len(offer[3])>=1:\\n value = 9999999999\\n for item in perms:\\n cur = 0\\n cur = sum(item)\\n cur -= min(item[1],item[2],item[3])\\n if cur<value:\\n value = cur\\n if value<ans:\\n ans = value\\n except:\\n pass\\n #print ans\\n try:\\n if len(offer[2])>=1:\\n value = 9999999999\\n for item in perms:\\n cur = 0\\n cur = sum(item)\\n cur -= min(item[1],item[2])\\n if cur<value:\\n value = cur\\n if value<ans:\\n ans = value\\n #print ans\\n #print offer[2]\\n if len(offer[2])>=2:\\n flg = False\\n end = len(offer[2])\\n for i in range(end):\\n for j in range(i+1,end):\\n if disc(offer[2][i],offer[2][j]):\\n flg = True\\n break\\n #print flg\\n if flg:\\n value = 9999999999\\n for item in perms:\\n cur = 0\\n cur = sum(item)\\n cur", "gt": "-= min(item[1],item[0])\\n cur -= min(item[2],item[3])\\n if cur<value:\\n value = cur\\n if value<ans:\\n ans = value\\n except:\\n pass\\n print(ans)\\n elif n==5:\\n try:\\n if len(offer[5])>=1:\\n ans -= min(arr)\\n except:\\n pass\\n try:\\n if len(offer[4])>=1:\\n value = 9999999999\\n for item in perms:\\n cur = 0\\n cur = sum(item)\\n cur -= min(item[1],item[2],item[3],item[4])\\n if cur<value:\\n value = cur\\n if value<ans:\\n ans = value\\n except:\\n pass\\n try:\\n if len(offer[2])>=1:\\n value = 9999999999\\n for item in perms:\\n cur = 0\\n cur = sum(item)\\n cur -= min(item[1],item[2])\\n if cur<value:\\n value = cur\\n if value<ans:\\n ans = value\\n if len(offer[2])>=2:\\n flg = False\\n end = len(offer[2])\\n for i in range(end):\\n for j in range(i+1,end):\\n if disc(offer[2][i],offer[2][j]):\\n flg = True\\n break\\n if flg:\\n value = 9999999999\\n for item in perms:\\n cur = 0\\n cur = sum(item)\\n cur -= min(item[1],item[0])\\n cur -= min(item[2],item[3])\\n if cur<value:\\n value = cur\\n if value<ans:\\n ans = value\\n except:\\n pass\\n try:\\n if len(offer[3])>=1:\\n value = 9999999999\\n for item in perms:\\n cur = 0\\n cur = sum(item)\\n cur -= min(item[1],item[2],item[3])\\n if cur<value:\\n value = cur\\n if value<ans:\\n ans = value\\n except:\\n pass\\n try:\\n if len(offer[3])>=1 and len(offer[2])>=1:\\n flg = False\\n for i in offer[3]:\\n for j in offer[2]:\\n if disc(i,j):\\n flg = True\\n break\\n if flg:\\n value = 9999999999\\n for item in perms:\\n cur = 0\\n cur = sum(item)\\n cur -= min(item[1],item[0])\\n cur -= min(item[2],item[3],item[4])\\n if cur<value:\\n value = cur\\n if value<ans:\\n ans = value\\n except:\\n pass\\n print(ans)\\n\\n\\n"}
{"id": "616", "input": "\\nt=int(input())\\nfor i in range(t):\\n l=list(map(int,input().split(' ')))\\n a=l[0]\\n b=l[1]\\n \\n l1=list(map(int,input().split(' ')))\\n for i", "gt": "in range(b):\\n l2=list(map(int,input().split(' ')))\\n a1=l2[0]\\n b1=l2[1]\\n su=0\\n for j in range(a1-1,b1):\\n su=(su+l1[j])%1000000000\\n print(su)"}
{"id": "617", "input": "from sys import stdin\\n\\nfor _ in range(int(stdin.readline())):\\n m, n = list(map(int, stdin.readline().split()))\\n final = []\\n arr = []\\n val = 0\\n extra = 0\\n for j in range(m):\\n ans = list(map(str, stdin.readline().split()))\\n if ans.count('N') == n:\\n val += 1\\n else:\\n if val%2 == 0:\\n arr.append(ans)\\n extra += val\\n else:\\n arr.append(['N']*n)\\n arr.append(ans)\\n extra += (val-1)\\n val = 0\\n\\n for j in range(len(arr)):\\n ans = arr[j]\\n start = -1\\n for i in range(n):\\n if ans[i] == 'P':\\n start = i\\n break\\n if start != -1:\\n for i in range(n-1, -1, -1):\\n if ans[i] == 'P':\\n end = i\\n break\\n", "gt": "if start != -1:\\n if len(final) == 0:\\n final.append([start, end])\\n else:\\n if j%2 == 0:\\n if final[-1][0] > start:\\n final[-1][0] = start\\n else:\\n start = final[-1][0]\\n else:\\n if final[-1][1] < end:\\n final[-1][1] = end\\n else:\\n end = final[-1][1]\\n final.append([start, end])\\n else:\\n if len(final) != 0:\\n start, end = 0, n-1\\n if j%2 == 0:\\n if final[-1][0] > start:\\n final[-1][0] = start\\n else:\\n start = final[-1][0]\\n else:\\n if final[-1][1] < end:\\n final[-1][1] = end\\n else:\\n end = final[-1][1]\\n final.append([start, end])\\n if len(final) == 0:\\n print(0)\\n else:\\n count = 0\\n for ele in final:\\n count += (ele[1]-ele[0]+1)\\n print(count-1+extra)\\n \\n"}
{"id": "618", "input": "def CeilIndex(A, l, r, key): \\n \\n while (r - l > 1): \\n \\n m = l + (r - l)//2\\n if (A[m] >= key): \\n r = m \\n else: \\n l = m \\n return r \\n \\ndef LongestIncreasingSubsequenceLength(A, size): \\n \\n # Add boundary case, \\n # when array size is one \\n \\n tailTable = [0 for i in range(size + 1)] \\n len = 0 # always points empty slot \\n \\n tailTable[0] = A[0] \\n len = 1\\n for i in range(1, size): \\n \\n if (A[i] <", "gt": "tailTable[0]): \\n \\n # new smallest value \\n tailTable[0] = A[i] \\n \\n elif (A[i] > tailTable[len-1]): \\n \\n # A[i] wants to extend \\n # largest subsequence \\n tailTable[len] = A[i] \\n len+= 1\\n \\n else: \\n # A[i] wants to be current \\n # end candidate of an existing \\n # subsequence. It will replace \\n # ceil value in tailTable \\n tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \\n \\n \\n return len\\nt=int(input())\\nfor _ in range(t):\\n n=int(input())\\n a=[]\\n for i in range(n):\\n a.append(list(map(int,input().split())))\\n a.sort()\\n b=[0]*n\\n for i in range(n):\\n b[i]=a[i][1]\\n \\n print(LongestIncreasingSubsequenceLength(b, n)) \\n"}
{"id": "619", "input": "t=int(input())\\nfor i in range(t):\\n n,k=list(map(int,input().split(\" \")))\\n arr=list(map(int,input().strip().split(\" \")))[:n]\\n def maxCircularSum(arr, n, k):\\n if (n < k):\\n print(\"Invalid\");\\n return;\\n\\n sum = 0;\\n start = 0;\\n end = k - 1;\\n\\n for i in range(k):\\n sum += arr[i];\\n\\n ans = sum;\\n\\n for i inrange(k, n + k):\\n sum += arr[i % n] - arr[(i - k) % n];\\n\\n if (sum >", "gt": "ans):\\n ans = sum;"}
{"id": "620", "input": "n=int(input())\\nfor i in range(n):\\n l=list(map(int,input().split()))\\n k=l[0]+l[1]\\n k=k%(2*l[2])\\n", "gt": "\\n if k>=0 and k<l[2]:\\n print(\"CHEF\")\\n else:\\n print(\"COOK\")\\n"}
{"id": "621", "input": "for _ in range(int(input())):\\n n,k=list(map(int,input().split()))\\n a=list(map(int,input().split()))\\n def check(mid):\\n d,left={},0\\n for i in range(mid):\\n if a[i]>k:\\n if a[i] not in d: \\n d[a[i]]=1\\n else: \\n d[a[i]]+=1\\n if len(d)==1:\\n return True\\n for i in range(mid,n):\\n if a[left]>k:\\n d[a[left]]-=1\\n if d[a[left]]==0:", "gt": "\\n del d[a[left]]\\n if a[i]>k:\\n if a[i] not in d: \\n d[a[i]]=1\\n else: \\n d[a[i]]+=1\\n if len(d)==1: \\n return True\\n left+=1\\n return False\\n \\n lo,hi=0,n\\n while lo<=hi:\\n mid=(lo+hi)//2\\n #print(mid,lo,hi)\\n if check(mid):\\n res=mid\\n lo=mid+1\\n else:\\n hi=mid-1\\n print(res)\\n \\n \\n \\n"}
{"id": "622", "input": "t = eval(input())\\nfor _ in range(t):\\n n = eval(input())\\n a = input().strip().split()\\n cb, cs = 0, \"\"\\n for i in range(len(a[0])):\\n for j in range(i+1,len(a[0])+1):\\n al = True\\n s = a[0][i:j]\\n for k", "gt": "in a[1:]:\\n if s not in k:\\n al = False\\n break\\n if al:\\n if j-i>=cb:\\n cb = max(cb, j-i)\\n if len(cs) < cb:\\n cs = a[0][i:j]\\n elif len(cs) == cb:\\n cs = min(cs,a[0][i:j])\\n print(cs)"}
{"id": "623", "input": "# cook your dish here folding paper\\nfrom collections import Counter\\ndef li():return [int(i) for i in input().rstrip('\\n').split()]\\ndef st():return input().rstrip('\\n')\\ndef val():return int(input().rstrip('\\n'))\\ndef dist(a,b):return ((a[0]-b[0])**2+(a[1]-b[1])**2)**0.5\\nfor _ in range(val()):\\n n,m,w,h=li()\\n s=Counter(st())\\n l=[]\\n for i in range(m):\\n l.append(li())\\n", "gt": "ans=float('inf')\\n l.sort(key=lambda x:x[0])\\n for j in range(1,50):\\n for i in range(j,m):\\n ans=min(ans,dist(l[i-j],l[i]))\\n for i in l:\\n if s['D'] or s['U']>1:ans=min(ans,2*i[1])\\n if s['U'] or s['D']>1:ans=min(ans,2*(h-i[1]))\\n if s['L'] or s['R']>1:ans=min(ans,2*i[0])\\n if s['R'] or s['L']>1:ans=min(ans,2*(w-i[0]))\\n print(ans)"}
{"id": "624", "input": "t = int(input())\\nlist_to_tri = []\\nfor i", "gt": "in range(t):\\n list_to_tri.append(int(input()))\\nlist_to_tri.sort()\\nfor i in list_to_tri:\\n print(i)\\n"}
{"id": "625", "input": "for _ in range(eval(input())):\\n n=eval(input())\\n mod=1000000007\\n f1,f2=[0]*101000,[0]*101000\\n f1[1]=0\\n f1[2]=2\\n f1[3]=3\\n", "gt": "f2[1]=1\\n f2[2]=1\\n f2[3]=2;\\n for i in range(4,100001):\\n f1[i]=f1[i-1]%mod+f1[i-2]%mod+f1[i-3]%mod\\n f2[i]=f2[i-1]%mod+f2[i-2]%mod+f2[i-3]%mod\\n print(f1[n]%mod,f2[n]%mod)"}
{"id": "626", "input": "def subCount(arr, n, k):\\r\\n\\r\\n mod = []\\r\\n for i in range(k + 1):\\r\\n mod.append(0)\\r\\n\\r\\n\\r\\n cumSum = 0\\r\\n for i in range(n):\\r\\n cumSum = cumSum + arr[i]\\r\\n\\r\\n # as the sum can be negative,\\r\\n # taking modulo twice\\r\\n mod[((cumSum % k) + k) % k] = mod[((cumSum % k) + k) %", "gt": "k] + 1\\r\\n\\r\\n result = 0 # Initialize result\\r\\n\\r\\n for i in range(k):\\r\\n\\r\\n\\r\\n if (mod[i] > 1):\\r\\n result = result + (mod[i] * (mod[i] - 1)) // 2\\r\\n\\r\\n\\r\\n result = result + mod[0]\\r\\n\\r\\n return result\\r\\nt=int(input())\\r\\nwhile t:\\r\\n t=t-1\\r\\n n=int(input())\\r\\n a=list(map(int,input().split()))\\r\\n for i in range(n):\\r\\n if a[i]==100000000:\\r\\n a[i]=1\\r\\n elif a[i]==900000000:\\r\\n a[i]=9\\r\\n s=10\\r\\n\\r\\n print(subCount(a,n,s))\\r\\n"}
{"id": "627", "input": "t=int(input())\\ndef reversebinary(bits,n):\\n bStr=''\\n for i in range(bits):\\n if n>0:\\n bStr=bStr+str(n%2)\\n else:\\n bStr=bStr+'0'\\n n=n>>1\\n return int(bStr,2)\\n \\nfor i", "gt": "in range(t):\\n k,msg=input().split()\\n k=int(k)\\n newmsg=[]\\n for j in msg:\\n newmsg.append(j)\\n for j in range(len(msg)):\\n newmsg[reversebinary(k,j)]=msg[j]\\n print(''.join(newmsg))\\n \\n \\n"}
{"id": "628", "input": "import", "gt": "math\\np=7+10**9\\nn,k=list(map(int,input().split()))\\nc=math.factorial(n+k-1)//((math.factorial(k))*(math.factorial(n-1)))\\nprint(c%p)\\n"}
{"id": "629", "input": "t =int(input()) #no. of test cases\\nwhile t>0:\\n t=t-1\\n str=input()\\n size=len(str)\\n pos=str.find('W')\\n left=pos\\n right=size-pos-1\\n arr = [[0 for i in range(right+1)] for j in range(left+1)]\\n #arr[i,j] = 1 if with i black cells", "gt": "on left and j on right 1st player can win, 0 otherwise.\\n #Recursion: arr[i][j]= or(arr[x][y])\\n arr[0][0]=0\\n for i in range(left+1):\\n for j in range(right+1):\\n if i==j:\\n arr[i][j]=0\\n else:\\n arr[i][j]=1\\n if(arr[left][right]==1):\\n print(\"Aleksa\")\\n else:\\n print(\"Chef\")\\n"}
{"id": "630", "input": "import sys\\nimport math\\nimport heapq\\ndef half(n):\\n return n//2\\ndef main(arr,m):\\n a,b,c=arr\\n \\n while m!=0:\\n \\n \\n \\n s=max(a,b,c)\\n \\n if s==a:\\n a=half(a)\\n elif s==b:\\n b=half(b)\\n", "gt": "else:\\n c=half(c)\\n m-=1\\n return max(a,b,c)\\n \\n \\n \\n \\n \\n\\nfor i in range(int(input())):\\n r,g,b,m=list(map(int,input().split()))\\n arr=[]\\n for j in range(3):\\n c=max(list(map(int,input().split())))\\n arr.append(c)\\n \\n print(main(arr,m))\\n"}
{"id": "631", "input": "dt, a = None, None\\ndef dfs(z):\\n r = [{}, {}];ln = len(dt[z])\\n if ln == 0:r[0][0] = 0;r[1][1 << a[z]] = 1\\n elif ln == 1:\\n l = dfs(dt[z][0]);r[0] = l[1]\\n for m in l[0]: r[1][(1 << a[z]) | m] = min(r[1][(1 << a[z]) | m], l[0][m] + 1) if (1 << a[z]) | m in r[1] else l[0][m] + 1\\n for m in l[1]: r[1][(1 << a[z]) | m] = min(r[1][(1 << a[z]) | m], l[1][m] + 1) if (1 << a[z]) | m in r[1] else l[1][m] + 1\\n elif ln == 2:\\n l0 = dfs(dt[z][0]);l1 = dfs(dt[z][1])\\n for i0 in range(2):\\n for i1 in range(2):\\n for m0 in l0[i0]:\\n for m1 in l1[i1]:r[1][(1 << a[z]) | m0 | m1]= min(r[1][(1 << a[z]) | m0 | m1], l0[i0][m0] + l1[i1][m1] + 1) if (1 << a[z]) | m0 | m1 in r[1] else l0[i0][m0] + l1[i1][m1] + 1\\n for m0 in l0[1]:\\n for m1 in l1[1]: r[0][m0 | m1] = min(r[0][m0 | m1], l0[1][m0] + l1[1][m1]) if m0 | m1 in r[0] else l0[1][m0] + l1[1][m1]\\n return r\\nfor i in range(int(input())):\\n n, m, k = map(int, input().split());a = [0] + [int(x) -", "gt": "1 for x in input().split()];"}
{"id": "632", "input": "a, b = [int(x) for x in input().split()]\\nr", "gt": "= list(str(a-b))\\nif r[0] == \"1\":\\n r[0] = \"2\"\\nelse:\\n r[0]=\"1\"\\nprint(\"\".join(r))\\n"}
{"id": "633", "input": "n=int(input())\\nwhile n>0:\\n i=1\\n a,b=(int(i) for i in", "gt": "input().split())\\n if (b+1)%(i<<a)==0:\\n print(\"ON\")\\n else:\\n print(\"OFF\")\\n n=n-1\\n"}
{"id": "634", "input": "n=int(input())\\ndef do():\\n t=int(input())\\n x=[]\\n for i in", "gt": "range(t):\\n x.append(int(input()))\\n print(max(x))\\n return\\nfor i in range(n):\\n do()"}
{"id": "635", "input": "string=input()\\nmax_no=0\\nfor i in range(len(string)):\\n var_occur=0\\n check_no=str()\\n j=i\\n while(j<len(string) and var_occur<2 ):\\n", "gt": "if(string[j].isalpha()):\\n if(var_occur==0):\\n check_no+='9'\\n var_occur+=1\\n else:\\n var_occur+=1\\n else:\\n check_no+=string[j]\\n j+=1\\n #print(check_no)\\n max_no=max(max_no,int(check_no))\\nprint(max_no)"}
{"id": "636", "input": "# cook your dish here\\nfrom collections import Counter\\ndef solve(arr, n, k):\\n ans = 0\\n dict1 = {}\\n mod = 1000000007\\n \\n for i in range(n):\\n if arr[i] in dict1:\\n dict1[arr[i]] += 1 \\n else:\\n dict1[arr[i]] = 1\\n l1 = [0]+list(dict1.keys())\\n v = min(k, len(l1))\\n dp = [[0 for", "gt": "_ in range(v+1)]for _ in range(len(l1))]\\n dp[0][0] = 1\\n for i in range(1, len(l1)):\\n dp[i][0] = 1\\n for j in range(1, v+1):\\n dp[i][j] = dp[i-1][j] + dp[i-1][j-1]*dict1[l1[i]]\\n for i in range(v+1):\\n ans += dp[len(l1)-1][i]\\n ans = ans%mod\\n return ans\\n \\n\\nn, k = map(int, input().strip().split())\\narr = list(map(int, input().strip().split()))\\nprint(solve(arr, n, k))"}
{"id": "637", "input": "# cook your dish here\\nfrom itertools import combinations\\na = list(map(int, input().split()))\\nn = a[0]\\nt = a[1]\\nq", "gt": "= list(combinations(a[2:], 4))\\ntotal = 0\\nfor i in q:\\n if sum(i) == t:\\n total += 1\\nprint(total)\\n"}
{"id": "638", "input": "import sys\\n\\n\\ndef input():\\n return sys.stdin.readline().strip()\\n\\n\\nfor i in range(int(input())):\\n n, k = map(int, input().split())\\n arr = []\\n if k == 2 or k == 4 or n % 2 != 0 or n == k:\\n arr.append('-1')\\n elif k % 2 != 0:\\n for i in range(int(n / 2)):\\n arr.append('(')\\n for i in range(int(n / 2)):\\n arr.append(')')\\n elif int(n / (k - 2)) == 1:\\n if (n - 2) % 4 == 0:\\n for i in range(int((n - 2) / 4)):\\n arr.append('(')\\n for i in range(int((n - 2) / 4)):\\n arr.append(')')\\n arr.append('()')\\n for i in range(int((n - 2) / 4)):\\n", "gt": "arr.append('(')\\n for i in range(int((n - 2) / 4)):\\n arr.append(')')\\n else:\\n for i in range(int((n - 4) / 4)):\\n arr.append('(')\\n for i in range(int((n - 4) / 4)):\\n arr.append(')')\\n arr.append('(())')\\n for i in range(int((n - 4) / 4)):\\n arr.append('(')\\n for i in range(int((n - 4) / 4)):\\n arr.append(')')\\n else:\\n for i in range(int((n % (k - 2)) / 2)):\\n arr.append('(')\\n for i in range(int(n / (k - 2))):\\n for j in range(int((k - 2) / 2)):\\n arr.append('(')\\n for j in range(int((k - 2) / 2)):\\n arr.append(')')\\n for i in range(int((n % (k - 2)) / 2)):\\n arr.append(')')\\n\\n print(\"\".join(arr))\\n"}
{"id": "639", "input": "for _ in range(int(input())):\\r\\n n,m=map(int,input().split())\\r\\n print(\"Case \"+str(_+1)+\":\")\\r\\n for i", "gt": "in range(m):\\r\\n s=input()\\r\\n ls=len(s)\\r\\n if ls>n:\\r\\n print(\"0\")\\r\\n else:\\r\\n k=(n-ls+1)\\r\\n print((k*pow(26,n-ls,1000000007))%1000000007)\\r\\n"}
{"id": "640", "input": "# cook your dish here\\nt=int(input())\\nfor _ in range(t):\\n st=input()\\n s=set(st)\\n a=[]\\n f1=f2=0\\n for i in s:\\n a.append(st.count(i))\\n a.sort()\\n if len(a)>=3:\\n for i in range(2,len(a)):\\n", "gt": "if a[i]!=a[i-1]+a[i-2]:\\n f1=1\\n break\\n x=a[0]\\n a[0]=a[1]\\n a[1]=x\\n for i in range(2,len(a)):\\n if a[i]!=a[i-1]+a[i-2]:\\n f2=1\\n break\\n if f1==1 and f2==1:\\n print(\"Not\")\\n else:\\n print(\"Dynamic\")\\n else:\\n print(\"Dynamic\")"}
{"id": "641", "input": "def gcd(a,b):\\r\\n if b==0:return a\\r\\n else:return gcd(b,a%b)\\r\\ndef lcm(a,b):\\r\\n m=a*b\\r\\n g=gcd(a,b)\\r\\n return int(m/g)\\r\\nfor", "gt": "_ in range(int(input())):\\r\\n x,y=[int(x) for x in input().split()]\\r\\n l=lcm(x,y)\\r\\n s=int(l/x)\\r\\n t=int(l/y)\\r\\n print(s+t-2)"}
{"id": "642", "input": "n=int(input())\\r\\ncost=[]\\r\\nd={}\\r\\nval_desc=[0]*n\\r\\nvisited=set()\\r\\nvisited.add(0)\\r\\ndfstack=[]\\r\\ndesc = [[False for i in range(n)] for i in range(n)]\\r\\nfor i in range(n):\\r\\n cost.append(int(input()))\\r\\n d[i]=[]\\r\\n\\r\\nfor i in range(n-1):\\r\\n j,k=list(map(int,input().split()))\\r\\n d[j-1].append(k-1)\\r\\n d[k-1].append(j-1)\\r\\n\\r\\ndef dfs(u):\\r\\n val_desc[u]+=cost[u]\\r\\n dfstack.append(u)\\r\\n for i in dfstack:\\r\\n desc[u][i]=True\\r\\n for", "gt": "i in d[u]:\\r\\n if i not in visited:\\r\\n visited.add(i)\\r\\n dfs(i)\\r\\n val_desc[u]+=val_desc[i] \\r\\n dfstack.pop(-1)\\r\\n\\r\\ndfs(0)\\r\\nmp=10**9\\r\\ncoco=sum(cost)\\r\\nfor i in range(n):\\r\\n for j in range(i+1,n):\\r\\n vali=val_desc[i]\\r\\n valj=val_desc[j]\\r\\n if desc[i][j]:\\r\\n valj-=val_desc[i]\\r\\n if desc[j][i]:\\r\\n vali-=val_desc[j]\\r\\n p=max(vali,valj,coco-vali-valj)\\r\\n mp=min(mp,p)\\r\\n#print(desc)\\r\\n#print(val_desc)\\r\\n#print\\r\\nprint(mp)\\r\\n\\r\\n\\r\\n \\r\\n"}
{"id": "643", "input": "# cook your dish here\\ndef isValid(mid):\\n time = 0.0\\n for i in range(n):\\n if time < c[i]:\\n time = c[i]\\n time += mid # cannon cooling\\n elif time >= c[i] and time <= c[i] + d:\\n time += mid # cannon cooling\\n else:\\n return False\\n return True\\n\\nt = int(input())\\nwhile t !=", "gt": "0:\\n n, d = list(map(int, input().split()))\\n c = list(map(int, input().split()))[:n]\\n ans = -1\\n c.sort()\\n low, high = 0, 10 ** 10\\n while (high - low) > 0.000001:\\n mid = (low + high) / 2\\n if isValid(mid):\\n ans = mid\\n low = mid\\n else:\\n high = mid \\n print(\""}
{"id": "644", "input": "\\r\\n\\r\\nd = 10**9 + 7\\r\\n\\r\\nt = int(input())\\r\\nwhile t:\\r\\n t-=1\\r\\n n =int(input())\\r\\n p =list(map(int, input().strip().split()))\\r\\n a =list(map(int, input().strip().split()))\\r\\n b =list(map(int, input().strip().split()))\\r\\n ans = 1\\r\\n for i in range(n):\\r\\n c", "gt": "= a[i] - b[i] + 1\\r\\n tmp = (( pow(p[i],b[i],d) * ((pow(p[i],c,d) - 1 + d)%d) * pow(p[i]-1 , d-2, d)%d))\\r\\n ans *= tmp\\r\\n ans = ans%d\\r\\n\\r\\n print(ans)"}
{"id": "645", "input": "# cook your dish here\\n\\nfor _ in range(int(input())):\\n friends = int(input())\\n", "gt": "candies = list(map(int,input().split()))\\n if (sum(candies) % friends == 0):\\n print(\"Yes\")\\n else:\\n print(\"No\")"}
{"id": "646", "input": "t = int(input())\\nfor _ in range(t):\\n n = int(input())\\n k = int(input())\\n num = int(k/n)\\n x = max(n*(1+num) - k,", "gt": "0)\\n diff = abs(x - (n-x))\\n if diff == 0:\\n number = 2*x - 1\\n else:\\n number = min(x, n-x)*2\\n print(number)"}
{"id": "647", "input": "from sys import stdin,stdout\\nimport math,bisect\\nfrom datetime import date\\nfrom collections import Counter,deque,defaultdict\\nL=lambda:list(map(int, stdin.readline().strip().split()))\\nM=lambda:list(map(int, stdin.readline().strip().split()))\\nI=lambda:int(stdin.readline().strip())\\nS=lambda:stdin.readline().strip()\\nC=lambda:stdin.readline().strip().split()\\ndef pr(a):return(\"\".join(list(map(str,a))))\\n#_________________________________________________#\\n\\ndef solve():\\n s = list(S())\\n", "gt": "a=[s[0]]\\n for i in range(1,len(s)):\\n if a and a[-1]==s[i]:\\n a.pop()\\n else:\\n a.append(s[i])\\n print(len(a))\\n \\nfor _ in range(I()): \\n solve()\\n"}
{"id": "648", "input": "\"\"\"\\n Author : thekushalghosh\\n Team : CodeDiggers\\n\"\"\"\\nimport sys,math\\ninput = sys.stdin.readline\\n############ ---- USER DEFINED INPUT FUNCTIONS ---- ############\\ndef inp():\\n return(int(input()))\\ndef inlt():\\n return(list(map(int,input().split())))\\ndef insr():\\n s = input()\\n return(s[:len(s) - 1])\\ndef invr():\\n return(map(int,input().split()))\\n################################################################\\n############ ---- THE ACTUAL CODE STARTS BELOW ----", "gt": "############\\nt = 1\\nt = inp()\\nfor tt in range(t):\\n n,s = invr()\\n if n == 2 and s > 1:\\n print(s - 1)\\n elif n > 2 and s > 1:\\n print(0)\\n elif n == 1:\\n print(s)\\n else:\\n print(-1)"}
{"id": "649", "input": "n,q=list(map(int,input().split()))\\nfinal=[]\\nheight=list(map(int,input().split()))\\nfor k in range(0,q):\\n b=input().split()\\n if int(b[0])==1:\\n step=int(b[1])-1\\n for k in range(0,int(b[2])):\\n temp = 0\\n j=1\\n while j in range(1,101)", "gt": "and temp==0 and step+j<n:\\n if height[step+j]>height[step]:\\n step=step+j\\n temp=1\\n j+=1\\n final.append(step+1)\\n elif int(b[0])==2:\\n for k in range(int(b[1])-1,int(b[2])):\\n height[k]=height[k]+int(b[3])\\nfor l in range(0,len(final)):\\n print(final[l])"}
{"id": "650", "input": "def main():\\n for _ in range(int(input())):\\n rows,column = map(int,input().split())\\n arr = []\\n for i in range(rows):\\n arr.append(list(input()))\\n string = input()\\n last = string[-1]\\n operation = Find(string,last)\\n for i in string[0]+operation:\\n if i == \"L\":\\n arr = Left(arr)\\n if i == \"R\":\\n arr = Right(arr)\\n if i == \"U\":\\n arr = Transpose(arr)\\n arr = Left(arr)\\n arr = Transpose(arr)\\n if i == \"D\":\\n arr = Transpose(arr)\\n arr = Right(arr)\\n arr = Transpose(arr)\\n for i in arr:\\n print(i)\\ndef Left(arr):\\n for i in range(len(arr)):\\n ans = arr[i].count(\"1\")\\n arr[i] = \"1\"*ans + (len(arr[i]) - ans)*\"0\"\\n return arr\\ndef Right(arr):\\n for i in range(len(arr)):\\n ans = arr[i].count(\"1\")\\n arr[i]", "gt": "= (len(arr[i]) - ans)*\"0\"+\"1\"*ans\\n return arr\\ndef Transpose(arr):\\n ansss = []\\n ans = list(map(list, zip(*arr)))\\n for i in ans:\\n ass = i\\n hello = \"\"\\n for j in ass:\\n hello += j\\n ansss.append(hello)\\n return ansss \\ndef Find(string,last):\\n for i in string[-2::-1]: \\n if last == \"L\":\\n if i in [\"D\",\"U\"]:\\n last = i + last\\n break\\n if last == \"R\":\\n if i in [\"D\",\"U\"]:\\n last = i + last\\n break\\n if last == \"D\":\\n if i in [\"L\",\"R\"]:\\n last = i + last\\n break\\n if last == \"U\":\\n if i in [\"L\",\"R\"]:\\n last = i + last\\n break\\n return last\\n \\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "651", "input": "import sys\\r\\n# import math\\r\\nfrom math import gcd\\r\\n# import re\\r\\n# from heapq import *\\r\\n# from collections import defaultdict as dd\\r\\n# from collections import OrderedDict as odict\\r\\n# from collections import Counter as cc\\r\\n# from collections import deque\\r\\n# sys.setrecursionlimit(10**5)#thsis is must\\r\\n# mod = 10**9+7; md = 998244353\\r\\n# m = 2**32\\r\\ninput = lambda: sys.stdin.readline().strip()\\r\\ninp = lambda: list(map(int,sys.stdin.readline().strip().split()))\\r\\n# def C(n,r,mod):\\r\\n# if r>n:\\r\\n# return 0\\r\\n# num = den = 1\\r\\n# for i in range(r):\\r\\n# num = (num*(n-i))%mod\\r\\n# den = (den*(i+1))%mod\\r\\n# return (num*pow(den,mod-2,mod))%mod\\r\\n# M =", "gt": "1000000+1\\r\\n# pfc = [i for i in range(M+1)]\\r\\n# def pfcs(M):\\r\\n# for i in range(2,M+1):\\r\\n# if pfc[i]==i:\\r\\n# for j in range(i+i,M+1,i):\\r\\n# if pfc[j]==j:\\r\\n# pfc[j] = i\\r\\n# return\\r\\n#______________________________________________________\\r\\nfor _ in range(int(input())):\\r\\n n,k = map(int,input().split())\\r\\n d = [[] for i in range(k+1)]\\r\\n for i in range(n):\\r\\n l,r,p = map(int,input().split())\\r\\n d[p].append([l,r])\\r\\n ans = 0\\r\\n for i in d:\\r\\n if len(i)==0:\\r\\n continue\\r\\n ans+=1\\r\\n t = sorted(i,key = lambda x:(x[1],x[0]))\\r\\n final = t[0][1]\\r\\n for j in range(1,len(t)):\\r\\n if t[j][0]>=final:\\r\\n ans+=1\\r\\n final = t[j][1]\\r\\n print(ans)"}
{"id": "652", "input": "# cook your dish here\\ntry:\\n for i in range(int(input())):\\n n=int(input())\\n l=[int(j) for j in input().split()][:n]\\n d={}\\n for j in l:\\n d[j]=d.get(j,0)+1\\n a=len(d)\\n c=0\\n for", "gt": "j in list(d.keys()):\\n while(d[j]>=3):\\n d[j]=(d[j]//3)+(d[j]%3)\\n if(d[j]==2):\\n c=c+1\\n if(c&1):\\n s=0\\n for j in list(d.values()):\\n s=s+j\\n print(s-c-1)\\n else:\\n s=0\\n for j in list(d.values()):\\n s=s+j\\n print(s-c)\\nexcept:\\n pass\\n \\n"}
{"id": "653", "input": "t=eval(input())\\nwhile t:\\n t=t-1\\n s1=input().lower()\\n s2=input().lower()\\n res=\"equal\"\\n for i in", "gt": "range(len(s1)):\\n if(s1[i]!=s2[i]):\\n \\n res=\"first\" if s1[i]<s2[i] else \"second\"\\n break\\n print(res)\\n"}
{"id": "654", "input": "def game(n,l,p):\\n if(len(l)==0):\\n return 0\\n l.sort()\\n if(len(l)>=1 and p<l[0]):\\n return 0\\n l.sort()\\n c=0\\n \\n \\n ma=set()\\n ma.add(0)\\n", "gt": "while(len(l)):\\n if(p>=l[0]):\\n p-=l[0]\\n \\n c+=1\\n ma.add(c)\\n l=l[1:]\\n else:\\n if(c>0):\\n c-=1\\n ma.add(c)\\n p+=l[-1]\\n l=l[:-1]\\n else:\\n return max(ma)\\n return max(ma)\\nn=int(input())\\nl=list(map(int,input().split()))\\np=int(input())\\nprint(game(n,l,p))"}
{"id": "655", "input": "# cook your dish here\\nx=int(input())\\nfor i", "gt": "in range(x):\\n s=list(map(int,input().split()))\\n s.sort()\\n print(s[1])\\n \\n \\n"}
{"id": "656", "input": "def __starting_point():\\n t=int(input())\\n for _ in range(t):\\n n,k,v=map(int,input().split())\\n li=list(map(int,input().split()))\\n sumn=0\\n for i in", "gt": "range(n):\\n sumn=sumn+li[i]\\n sumk=v*(n+k)-sumn\\n e=int(sumk/k)\\n r=sumk%k\\n if e<=0:\\n print(-1)\\n elif r!=0:\\n print(-1)\\n else:\\n print(e)\\n__starting_point()"}
{"id": "657", "input": "# cook your dish", "gt": "here\\nn = int(input())\\nif(n%4==0):\\n print(n+1)\\nelse:\\n print(n-1)"}
{"id": "658", "input": "def matrixScore(A):\\r\\n \"\"\"\\r\\n :type A: List[List[int]]\\r\\n :rtype: int\\r\\n \"\"\"\\r\\n m,n = len(A),len(A[0])\\r\\n # 行变换\\r\\n for i in range(m):\\r\\n if A[i][0] == 1: continue\\r\\n for j in range(n):\\r\\n A[i][j] = 1 - A[i][j]\\r\\n\\r\\n # 列变换\\r\\n res = 0\\r\\n for rows", "gt": "in zip(*A):\\r\\n # 始终使1的个数是更大的\\r\\n cnt1 = max(rows.count(1), rows.count(0))\\r\\n res += cnt1 * 2**(n-1)\\r\\n n -= 1\\r\\n return res\\r\\nm, n = [int(s) for s in input().split(\" \")]\\r\\narr = [[int(s) for s in input().split(\" \")] for i in range(m)]\\r\\nans = matrixScore(arr)\\r\\nprint(ans)\\r\\n"}
{"id": "659", "input": "# cook your dish here\\nt=int(input())\\nfor _ in range(t):\\n n=int(input())\\n array=list(map(int, input().split()))\\n list_sub=[]\\n idx=0\\n counter=0\\n for i in range(n-1):\\n if counter%2==0 and array[i]<=array[i+1]:\\n counter+=1 \\n elif counter%2==1 and array[i]>=array[i+1]:\\n counter+=1", "gt": "\\n else:\\n list_sub.append((idx,i))\\n if counter%2==1:\\n idx=i \\n counter=1\\n else:\\n idx=i+1 \\n counter=0\\n list_sub.append((idx, n-1))\\n massimo=0\\n if len(list_sub)==1:\\n massimo=list_sub[0][1]-list_sub[0][0]+2\\n for i in range(len(list_sub)-1):\\n if list_sub[i][1]==list_sub[i+1][0]:\\n massimo=max(massimo, list_sub[i][1]-list_sub[i][0]+2+list_sub[i+1][1]-list_sub[i+1][0])\\n else:\\n massimo=max(massimo, list_sub[i][1]-list_sub[i][0]+3+list_sub[i+1][1]-list_sub[i+1][0])\\n print(massimo)"}
{"id": "660", "input": "#binarr\\r\\ndef binarr(a, k, s):\\r\\n a.sort(reverse=True)\\r\\n arr = [0]*k\\r\\n for i in range(k):\\r\\n arr[i] = a[i]\\r\\n if sum(arr) <= s:\\r\\n return", "gt": "binarr(a, k+1, s)\\r\\n return len(arr)\\r\\n\\r\\ntry:\\r\\n n, k, s = list(map(int, input().split()))\\r\\n a = list(map(int, input().split()))\\r\\n print(binarr(a, k+1, s))\\r\\nexcept Exception:\\r\\n pass\\r\\n"}
{"id": "661", "input": "t = int(input())\\nfor i in range(t):\\n n = int(input())\\n if n == 1 or", "gt": "n == 2 or n == 145 or n == 40585:\\n print(1)\\n else:\\n print(0)\\n"}
{"id": "662", "input": "try:\\n from math import sqrt\\n t,x=list(map(int,input().split()))\\n for _ in range(t):\\n n=int(input())\\n", "gt": "if(n<0):\\n print(\"no\")\\n else:\\n diff=(x/100)*n\\n ans=int(sqrt(n))\\n ans1=ans**2\\n if(n-ans1<=diff):\\n print(\"yes\")\\n else:\\n print(\"no\")\\nexcept:\\n pass\\n"}
{"id": "663", "input": "# cook your dish here\\nfor t in range(int(input().strip())):\\n d = int(input().strip())\\n L, R = map(int, input().strip().split(\" \"))\\n if L % 2 == 0:\\n L += 1\\n sum =", "gt": "(((((R - L + 2)//2)//d)+1)//2) - 1\\n sum = (sum * 2 * d * (sum + 1) * d) + (sum+1) *d * (L + d -1)\\n print(sum%1000000007)"}
{"id": "664", "input": "def least_rotation(S: str) -> int:\\r\\n \"\"\"Booth's algorithm.\"\"\"\\r\\n f = [-1] * len(S) # Failure function\\r\\n k = 0 # Least rotation of string found so far\\r\\n for j in range(1, len(S)):\\r\\n sj = S[j]\\r\\n i = f[j - k - 1]\\r\\n while i != -1 and sj != S[k + i + 1]:\\r\\n if sj < S[k + i + 1]:\\r\\n k = j - i - 1\\r\\n", "gt": "i = f[i]\\r\\n if sj != S[k + i + 1]: # if sj != S[k+i+1], then i == -1\\r\\n if sj < S[k]: # k+i+1 = k\\r\\n k = j\\r\\n f[j - k] = -1\\r\\n else:\\r\\n f[j - k] = i + 1\\r\\n return k\\r\\n\\r\\n\\r\\nfor _ in range(int(input())):\\r\\n l, s = input().split()\\r\\n if int(l) == 1:\\r\\n l = len(s)\\r\\n s += s\\r\\n k = least_rotation(s)\\r\\n print(s[k:k+l])\\r\\n else:\\r\\n print(''.join(sorted(s)))"}
{"id": "665", "input": "# cook your dish here\\nMOD = 998244353\\n\\nfball = [ [0]*101 for _ in range(101) ]\\n\\ncric = [ [0]*101 for _ in range(101) ] \\n\\n\\n\\ndef calSNum(n, r):\\n if n == r or r == 1:\\n fball[r][n] = 1\\n return\\n if n > 0 and r > 0 and n > r:\\n fball[r][n] = (fball[r-1][n-1]%MOD + (r*fball[r][n-1])%MOD )%MOD\\n return\\n fball[r][n] = 0\\n \\n\\ndef calASNum(n, r):\\n if n == 0 and r == 0 :\\n cric[r][n] = 0\\n return\\n if n >= 2 and r == 1:\\n cric[r][n] = 1\\n return", "gt": "\\n if r > 0 and n > 0 and n >= 2*r:\\n cric[r][n] = ((r*cric[r][n-1])%MOD + ((n-1)*cric[r-1][n-2])%MOD )%MOD\\n return\\n cric[r][n] = 0\\n \\n\\ndef preCompute():\\n for r in range(1,101):\\n for n in range(1, 101):\\n calSNum(n, r)\\n calASNum(n, r)\\n\\n \\ndef main():\\n \\n preCompute()\\n for _ in range(int(input())):\\n f, c, r = list(map(int, input().split()))\\n\\n ans = 0\\n \\n if f + (c//2) >= r:\\n minv = min(f, r)\\n \\n for i in range(1, minv+1):\\n if r-i <= c//2:\\n ans = (ans + (fball[i][f] * cric[r-i][c])%MOD )%MOD\\n \\n print(ans)\\n \\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "666", "input": "# cook your dish here\\nt=int(input())\\nfor _ in range(t):\\n n,m=list(map(int,input().split()))\\n r=list(map(int,input().split()))\\n rating=[[r[i]]*(m) for i in range(n)]\\n ranking=[[0]*m for i in range(n)]\\n for i in range(n):\\n diff=list(map(int,input().split()))\\n for j in range(m):\\n rating[i][j]+=diff[j]\\n if j+1<m:\\n rating[i][j+1]=rating[i][j]\\n \\n for i in range(m):\\n rate=[[j,rating[j][i]]", "gt": "for j in range(n)]\\n rate=sorted(rate,key=lambda x: x[1],reverse=True)\\n c=1\\n gap=0\\n for j in range(n):\\n if j>0 and rate[j-1][1]==rate[j][1]:\\n gap+=1\\n if j>0 and rate[j-1][1]!=rate[j][1]:\\n c+=1+gap\\n gap=0\\n ranking[rate[j][0]][i]=c \\n \\n count=0\\n for i in range(n):\\n rate=rating[i].copy()\\n i1=rate.index(max(rate))\\n rank=ranking[i].copy()\\n i2=rank.index(min(rank))\\n if i1!=i2:\\n count+=1\\n print(count)\\n"}
{"id": "667", "input": "# cook your dish here\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n s = ''\\n n = int(input())\\n if n==1:\\n print(1)\\n continue\\n for i in range(1, n+1):\\n s = s +", "gt": "str(i)\\n print(s)\\n \\n p = 1\\n for i in range(n-1):\\n s = ''\\n for j in range(n):\\n s = s + str(p + n)\\n p = p+1\\n \\n print(s)\\n \\n"}
{"id": "668", "input": "t = int(input())\\r\\nfor _ in range(t):\\r\\n nd = list(map(int, input().split()))\\r\\n n = nd[0]\\r\\n d = nd[1]\\r\\n cutOff =", "gt": "[]\\r\\n x = d\\r\\n buses = list(map(int, input().split()))\\r\\n for i in range(len(buses)-1,-1,-1):\\r\\n x = x - x%buses[i]\\r\\n print(x)\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n \\r\\n\\r\\n"}
{"id": "669", "input": "def max_sum(arr):\\n # Finds the maximum sum of sub-arrays of arr\\n max_till_now = -1000000 #minimum possible number \\n current_sum = 0\\n for i in range(len(arr)):\\n if current_sum < 0:\\n # If sum of previous elements is negative, then ignore them. Start fresh\\n # with `current_sum = 0`\\n current_sum = 0\\n \\n current_sum += arr[i]\\n \\n # Update max\\n if max_till_now < current_sum:\\n max_till_now = current_sum\\n \\n return max_till_now\\n\\n\\ndef solve(A, k):\\n if k == 1:\\n return max_sum(A)\\n # Find sum of elements of A\\n sum_A = 0\\n for i in range(len(A)):\\n sum_A += A[i]\\n \\n Max_Suffix_Sum = -1000000\\n current = 0\\n for i in range(len(A)):\\n current += A[-i-1]\\n if current > Max_Suffix_Sum:\\n Max_Suffix_Sum = current\\n\\n Max_Prefix_Sum = -1000000\\n current = 0\\n for i in range(len(A)):\\n current += A[i]\\n if current > Max_Prefix_Sum:\\n Max_Prefix_Sum =", "gt": "current\\n\\n if sum_A <= 0:\\n # Check two cases:\\n\\n # Case 1 : Check the max_sum of A\\n case_1_max_sum = max_sum(A)\\n \\n # Case 2 : Check the max_sum of A + A\\n case_2_max_sum = Max_Suffix_Sum + Max_Prefix_Sum\\n\\n # Return the maximum of the two cases\\n return max([case_1_max_sum, case_2_max_sum])\\n\\n else: # if sum_A > 0\\n #Check two cases:\\n\\n # Case 1 : Check the max_sum of A\\n case_1_max_sum = max_sum(A)\\n\\n # Case 2\\n # Max sum = Max_Suffix_Sum + (k - 2)*sum_A + Max_Prefix_Sum \\n \\n case_2_max_sum = Max_Suffix_Sum + (k - 2)*sum_A + Max_Prefix_Sum\\n \\n # Return the maximum of the two cases\\n return max([case_1_max_sum, case_2_max_sum])\\n\\n\\n# Main\\nT = int(input()) # No of test cases\\nfor i in range(T):\\n [N, k] = list(map(int, input().split(\" \")))\\n A = list(map(int, input().split(\" \")))\\n \\n answer = solve(A,k)\\n print(answer)"}
{"id": "670", "input": "T = int(input())\\nfor _ in range(T):\\n N, M, K = [int(x) for x in input().split()]\\n UV = [[int(x) for x in input().split()] for _ in range(M)]\\n Q = int(input())\\n AB = [[int(x) for x in input().split()] for _ in range(Q)]\\n \\n X = [[i] for i in range(N)]\\n for u, v in UV:\\n X[u - 1] += [v - 1]\\n X[v - 1] += [u - 1]\\n \\n A = [[1", "gt": "if i > 0 or j == 0 else 0 for j in range(N)] for i in range(K + 1)]\\n for a, b in AB:\\n A[b] = [1 if i == a - 1 else 0 for i in range(N)]\\n \\n if A[0][0] == 1:\\n for k in range(K - 1, -1, -1):\\n for i in range(N):\\n if A[k][i] != 0:\\n A[k][i] = sum(A[k + 1][j] for j in X[i])\\n \\n print(A[0][0])"}
{"id": "671", "input": "def gcd(a,b):\\n if b==0:\\n return a\\n else:\\n return gcd(b,a%b)\\n \\ndef main():\\n t=int(input())\\n while t!=0:\\n t=t-1\\n n=int(input())\\n if n==1:\\n", "gt": "print(input())\\n else:\\n a=list(map(int,input().split(\" \")))\\n p=a[0]\\n for i in range(1,n):\\n p=gcd(p,a[i])\\n if p==1:\\n break\\n print(n*p)\\ndef __starting_point():\\n main()\\n \\n \\n\\n__starting_point()"}
{"id": "672", "input": "for i in range(int(input())):\\n n,s =map(int,input().split())\\n l1=list(map(int,input().split()))\\n l2=list(map(int,input().split()))\\n m=[]\\n n=[]\\n for i in range(len(l1)):\\n if", "gt": "l2[i]==0:\\n m.append(l1[i])\\n else:\\n n.append(l1[i])\\n if len(m)>0 and len(n)>0:\\n if 100-s>=(min(m)+min(n)):\\n print(\"yes\")\\n else:\\n print(\"no\")\\n else:\\n print(\"no\")"}
{"id": "673", "input": "# cook your dish here\\nfrom math import sqrt\\nfor i in range(int(input())):\\n x1,y1,x2,y2=list(map(float,input().split()))\\n m=(y2-y1)/(x2-x1)\\n c=y2-m*x2\\n print('Test case", "gt": ": ',i+1)\\n q=int(input())\\n for i in range(q):\\n x3,y3=list(map(float,input().split()))\\n if(y3-m*x3-c==0):\\n print(\"YES\")\\n else:\\n d=(abs(y3-m*x3-c))/sqrt(1+m*m)\\n print(\"NO\")\\n print(\"%.6f\" % d)\\n"}
{"id": "674", "input": "from math import gcd\\r\\nfrom math import ceil\\r\\nfrom itertools import combinations as c\\r\\nt=int(input())\\r\\nfor _ in range(t):\\r\\n n,m,a,d=list(map(int,input().split()))\\r\\n \\r\\n l=[]\\r\\n for i in range(5):\\r\\n l.append(a+i*d)\\r\\n ans=m-n+1\\r\\n", "gt": "for i in range(1,6):\\r\\n x=list(c(l,i))\\r\\n for j in x:\\r\\n e=j[0]\\r\\n for v in j:\\r\\n e=(e*v)//gcd(e,v)\\r\\n #print(e)\\r\\n if i%2:\\r\\n ans-=m//e-(n-1)//e\\r\\n else:\\r\\n ans+=m//e-(n-1)//e\\r\\n print(ans)\\r\\n \\r\\n \\r\\n"}
{"id": "675", "input": "import numpy as np\\nfor _ in range(int(input())):\\n ans = np.float('inf')\\n n, m = (int(x) for x in input().split())\\n sig = np.zeros((n,m))\\n img = np.zeros((3*n,3*m))\\n for row in range(n):\\n sig[row,:] = np.array([int(x)", "gt": "for x in input()])\\n for row in range(n):\\n img[row+n,m:2*m] = np.array([int(x) for x in input()])\\n for i in range(2*n):\\n for j in range(2*m):\\n ans = min(ans, np.abs(np.sum(img[i:n+i, j:m+j] != sig)))\\n print(ans)"}
{"id": "676", "input": "import math\\ndef ispoweroftwo(y):\\n return math.ceil(math.log(y,2))==math.floor(math.log(y,2))\\nt=int(input())\\nfor i in range(t):\\n n=int(input())\\n \\n a=[]\\n if(ispoweroftwo(n) and n!=1):\\n print(-1,end=\" \")\\n if(n==1):\\n print(1)\\n \\n", "gt": "if(n>=3 and not(ispoweroftwo(n))):\\n a.append(2)\\n a.append(3)\\n a.append(1)\\n if(n>3 and not ispoweroftwo(n)):\\n i=4\\n while(i<=n):\\n if(ispoweroftwo(i)):\\n a.append(i+1)\\n a.append(i)\\n i+=2\\n else:\\n a.append(i)\\n i+=1\\n print(*a)\\n"}
{"id": "677", "input": "from collections import Counter\\r\\n\\r\\nfor _ in range(int(input())):\\r\\n n=int(input())\\r\\n l=[i for i in input().split()]\\r\\n ll=[]\\r\\n c=Counter(l)\\r\\n cc=[]\\r\\n m=0\\r\\n for l,count in c.most_common(len(l)-1):\\r\\n", "gt": "if m==0:\\r\\n ll.append(l)\\r\\n cc.append(count)\\r\\n \\r\\n if m==count:\\r\\n ll.append(l)\\r\\n cc.append(count)\\r\\n if count<m:\\r\\n break\\r\\n m=count\\r\\n k=set(cc)\\r\\n leng=len(list(k))\\r\\n if leng==1:\\r\\n sor=sorted(ll)\\r\\n print(sor[0])\\r\\n else:\\r\\n print(ll[0])\\r\\n"}
{"id": "678", "input": "import sys\\nimport datetime\\na,b,c", "gt": "= list(map(int,sys.stdin.readline().split()))\\nd = datetime.date(c,b,a)\\nprint(d.strftime(\"%A\"))"}
{"id": "679", "input": "# cook your dish here\\ntest_case = int(input())\\nwhile test_case :\\n n_people = int(input())\\n array = list(map(int, input().strip().split()))\\n sums =[0 for i in range(n_people)]\\n \\n sums[0] = array[0]\\n \\n for i in range(1, n_people) :\\n sums[i] = sums[i-1] + array[i]\\n \\n # print(sums)\\n\\n k = 1 \\n count = 0\\n i = 0 \\n while(k < n_people) :\\n", "gt": "k = k + sums[i]\\n # print(k)\\n i = i + sums[i]\\n count = count + 1\\n print(count)\\n \\n \\n test_case -= 1\\n \\n # 2 1 1 5 5 5 5\\n # [2, 3, 4, 9, 14, 19, 24]\\n # 0 1 2 3 4 5 6 \\n \\n \\n \\n \\n \\n \\n \\n \\n"}
{"id": "680", "input": "t=eval(input())\\n \\na=[]\\nb=[]\\n \\ntop=-1\\n \\nfor __ in range(0,t):\\n \\n x=input().split()\\n \\n if(x[0]!=\"-1\" and x[0]!=\"0\"):\\n \\n add=int(x[0])\\n \\n if top!=-1 and add>a[top][0] :\\n \\n", "gt": "b[top]+=1\\n \\n else:\\n a.append((add,x[1]))\\n \\n b.append(0)\\n top+=1\\n \\n \\n elif (x[0]==\"-1\"):\\n \\n #print(\"%s %s\" %(b[top],a[top][1]))\\n print((b[top]), end=' ')\\n print(a[top][1])\\n foo=a.pop()\\n bar=b.pop()\\n top-=1"}
{"id": "681", "input": "t = int(input())\\nl,r,x = 0,0,0\\nans = []\\nfor i in range(t):\\n (n,m) = tuple(map(int,input().split()))\\n a = list(map(int,input().split()))\\n b = list(map(int,input().split()))\\n suma = sum(a)\\n sumb = sum(b)\\n q = int(input())\\n for j in range(q):\\n l1 = list(map(int,input().split()))\\n if l1[0] ==", "gt": "1:\\n l = l1[1]\\n r = l1[2]\\n x = l1[3]\\n suma = suma + (r-l+1)*x\\n elif l1[0] == 2:\\n l = l1[1]\\n r = l1[2]\\n x = l1[3]\\n sumb = sumb + (r-l+1)*x\\n else:\\n ans.append((suma*sumb)%998244353)\\nfor i in range(len(ans)):\\n print(ans[i])"}
{"id": "682", "input": "\\nfrom math import ceil\\nfrom bisect import bisect_right as b_r\\nfrom bisect import bisect_left as b_l\\nar = list(map(int , input().split()))\\na", "gt": "= [int(ceil((ar[1]-int(x)+1)/ar[2])) for x in input().split()]\\ns = sum(a)\\nar[1] = max(a)\\nm = ar[1] - (s-ar[1])%2\\nmi = s%2 \\nprint(int( (m-mi)//2 +1)%(10**9+7))\\n\\n"}
{"id": "683", "input": "n=int(input())\\na=list(map(int,input().split()))\\n\\nl,r=-1,-1\\nfor i in range(n):\\n if a[i]!=i+1:\\n l=i\\n break\\n\\nfor i in range(n-1,-1,-1):\\n if", "gt": "a[i]!=i+1:\\n r=i\\n break\\n\\nj=r+1\\n\\nfor i in range(l,r+1):\\n if a[i]==j:\\n j-=1\\n continue\\n else:\\n print(0,0)\\n return\\n\\nprint(l+1,r+1)"}
{"id": "684", "input": "# cook your", "gt": "dish here\\na = int(input())\\nprint(a)"}
{"id": "685", "input": "# cook your dish here\\nimport math \\n \\n# Function to find the Largest \\n# Odd Divisor Game to check \\n# which player wins \\ndef findWinner(n, k): \\n \\n cnt = 0; \\n \\n # Check if n == 1 then \\n # player 2 will win \\n if (n == 1): \\n print(\"Grinch\"); \\n \\n # Check if n == 2 or n is odd \\n elif ((n & 1) or n == 2): \\n print(\"Me\"); \\n \\n else: \\n tmp = n; \\n val = 1; \\n \\n # While n is greater than k and \\n # divisible by 2 keep \\n # incrementing tha val \\n while (tmp > k and tmp % 2 == 0):\\n tmp //= 2; \\n val", "gt": "*= 2;"}
{"id": "686", "input": "# https://www.codechef.com/problems/RECTLIT\\r\\n\\r\\ndef assess(sq,points):\\r\\n EWct = 0\\r\\n NSct = 0\\r\\n for a,b in points:\\r\\n EW = (a == 0 or a == sq)\\r\\n NS = (b == 0 or b == sq)\\r\\n if EW and NS:\\r\\n return 'yes'\\r\\n EWct += EW\\r\\n NSct += NS\\r\\n if NSct + EWct == 0 or len(points) == 1:\\r\\n return 'no'\\r\\n if EWct >= 2 or NSct >= 2:\\r\\n return 'yes'\\r\\n if len(points) == 2:\\r\\n return 'no'\\r\\n # now 3 points\\r\\n if NSct == 1 and EWct == 1:\\r\\n return 'yes'\\r\\n # 3 points, one on edge\\r\\n x =", "gt": "-1\\r\\n for a,b in points:\\r\\n if EWct > 0:\\r\\n if a == 0 or a == sq:\\r\\n e = b\\r\\n elif x == -1:\\r\\n x = b\\r\\n else:\\r\\n y = b\\r\\n else:\\r\\n if b == 0 or b == sq:\\r\\n e = a\\r\\n elif x == -1:\\r\\n x = a\\r\\n else:\\r\\n y = a\\r\\n if (e-x)*(e-y) < 0: # edge splits mids\\r\\n return 'no'\\r\\n else:\\r\\n return 'yes'\\r\\n\\r\\n\\r\\nfor ti in range(int(input())):\\r\\n k,n = map(int, input().split())\\r\\n if k > 3:\\r\\n for ki in range(k):\\r\\n input()\\r\\n print('yes')\\r\\n else:\\r\\n pos = [tuple(map(int, input().split())) for ki in range(k)]\\r\\n print(assess(n-1,pos))\\r\\n\\r\\n"}
{"id": "687", "input": "n=int(input())\\nl=[]\\nfor i in range(0,n):\\n a,b,c=map(int,input().split())\\n n1=(2**0.5)*(a/b)\\n n2=2*(a/c)\\n if", "gt": "n1>n2:\\n l.append(\"Elevator\")\\n else:\\n l.append(\"Stairs\")\\nfor i in l:\\n print(i)"}
{"id": "688", "input": "from sys import stdin\\nt = int(stdin.readline())\\n\\ndef count(n, arr):\\n loc = 0\\n glob = 0\\n for i in range(n-1):\\n if arr[i] > arr[i+1]:\\n loc += 1\\n for i in range(n-1):\\n for j in range(i+1, n):\\n if glob >", "gt": "loc:\\n return 0\\n if arr[i] > arr[j]:\\n glob += 1;\\n if glob == loc:\\n return 1\\n return 0\\n\\nfor _ in range(t):\\n n = int(stdin.readline())\\n arr = list(map(int, stdin.readline().split()))\\n result = count(n, arr)\\n if result:\\n print(\"YES\")\\n else:\\n print(\"NO\")"}
{"id": "689", "input": "n = int(input())\\n# this code only for 8 bits string and it isn't possible to more than 8 bits of string \\n\\n# for i in range(n):\\n# s = input()\\n# subString1, subString2 = s[:4], s[4:]\\n# rev = subString2[::-1]\\n# print( 'uniform' if(subString1", "gt": "== rev) else 'non-uniform')\\n \\nfor i in range(n):\\n count = 0\\n s = input()\\n for i in range(1, len(s)):\\n if(s[i-1] != s[i]):\\n count += 1 \\n \\n if(s[0] != s[-1]): \\n count += 1 \\n print(\"uniform\" if(count <=2 ) else \"non-uniform\")\\n"}
{"id": "690", "input": "# cook your dish here\\nt=int(input())\\ni=0\\na=0\\nd=dict()\\nwhile i<t:\\n l=input().split()\\n d[int(l[0])]=int(l[0])+int(l[1])\\n i+=1\\nfor k in", "gt": "d:\\n if d[k] in d:\\n if d[d[k]]==k:\\n a=1\\n break\\nif a==1:\\n print(\"YES\")\\nelse:\\n print(\"NO\")"}
{"id": "691", "input": "n,k,m = map(int,input().split())\\nar = list(map(int,input().split()))\\nfsum = [ar[0]]\\nfor i in range(1,n):\\n fsum.append(fsum[i-1]+ar[i])\\ni = k\\n#print(fsum)\\nc = 0\\nwhile i <= n:\\n if i == k:\\n s = fsum[i-1]\\n else:\\n s = fsum[i-1]-fsum[i-k-1]\\n if s == 0:\\n c = -1\\n break\\n if s < m:\\n c += 1\\n if i<n:\\n for j in range(i,i-k-1,-1):\\n if ar[j-1] >0:\\n", "gt": "j += k-1\\n i = j\\n break\\n if i<n:\\n for j in range(i,i-k-1,-1):\\n if ar[j-1] >0:\\n j += k-1\\n i = j\\n break\\n i += 1\\ni = k\\nwhile i <= n:\\n if i==k:\\n s = fsum[i-1]\\n else:\\n s = fsum[i-1] - fsum[i-k-1]\\n if s == 0 :\\n c = -1\\n break\\n i += 1\\nprint(c)"}
{"id": "692", "input": "T = int(input())\\nfor _ in range(T):\\n n = int(input())\\n arr = list(map(int, input().split()))\\n a = [0 for _ in range(max(arr)+1)]\\n star_val = []\\n for", "gt": "i in range(len(arr)):\\n j = 1\\n val = 0\\n while j*arr[i] <= len(a):\\n val += a[j*arr[i]-1]\\n j += 1\\n star_val.append(val)\\n a[arr[i]-1] += 1\\n print(max(star_val))"}
{"id": "693", "input": "VQ = \"UAMmSs\"\\nn = int(input())\\na = list(map(int, input().split()))\\nfor _ in range(int(input())):\\n q, x, y = input().split()\\n if q not in VQ:\\n print(\"!!!\")\\n continue\\n if q == \"U\":\\n a[int(x) - 1] = int(y)\\n continue\\n l = int(x) -", "gt": "1\\n r = int(y)\\n if q == \"A\":\\n print(sum(a[l:r]))\\n continue\\n if q == \"M\":\\n print(max(a[l:r]))\\n continue\\n if q == \"m\":\\n print(min(a[l:r]))\\n continue\\n s = sorted(set(a[l:r]))\\n if len(s) < 2:\\n print(\"NA\")\\n else:\\n print(s[1] if q == \"s\" else s[-2])\\n"}
{"id": "694", "input": "# cook your dish here\\nx=int(input())\\nfor i in range(x):\\n", "gt": "s=int(input())\\n fact=1\\n for i in range(1,s+1):\\n fact=fact*i\\n print(fact)\\n"}
{"id": "695", "input": "import math\\ndef fun(num1,num2):\\n if num1>num2:\\n a=num1\\n b=num2\\n else:\\n a=num2\\n b=num1\\n rem=a%b\\n while(rem!=0):\\n a=b\\n b=rem\\n rem=a%b\\n gcd=b\\n", "gt": "return (int((num1*num2)/gcd))\\n \\nfor _ in range (int(input())):\\n hours=int(input())*24\\n x,y,z=list(map(int,input().split()))\\n lcm=x\\n lcm=fun(x,y)\\n lcm=fun(lcm,z)\\n print(int(hours//lcm))\\n \\n \\n \\n"}
{"id": "696", "input": "# cook your dish here\\ntc=int(input())\\nfor j in range(tc):\\n ip=list(map(int,input().rstrip().split()))\\n x=ip[0]\\n y=ip[1]\\n n=ip[2]\\n cnt=0\\n if(x==y):\\n print('0')\\n continue\\n ln=bin(x).replace(\"0b\", \"\") \\n rn=bin(y).replace(\"0b\", \"\") \\n ll=len(ln)\\n rl=len(rn)\\n #print(ln)\\n #print(rn)\\n if(ll==len(rn)):\\n for i in range(ll):\\n \\n if(ln[i]!=rn[i]):\\n ln=ln[i:]\\n rn=rn[i:]\\n break\\n #print(ln)\\n", "gt": "if(ln[0]=='0'):\\n ln=ln[1:]\\n ll-=1\\n #print(rn)\\n if(rn[0]=='0'):\\n rn=rn[1:]\\n rl-=1\\n ll=len(ln)\\n rl=len(rn)\\n if(ll>rl):\\n lb=ll \\n else:\\n lb=rl \\n pl=2**lb \\n hpl=pl//2\\n amn=((n+1)//pl)*hpl \\n rm=(n+1)%pl \\n if((rm*2)<=pl):\\n amn+=rm\\n else:\\n amn+=hpl \\n #print(\"amn = \",amn)\\n aln=(n+1)-amn\\n #print(\"aln = \",aln)\\n if(x<y):\\n print(amn)\\n else:\\n print(aln)"}
{"id": "697", "input": "t=int(input())\\nfor _ in range(t):\\n n,m=list(map(int,input().split()))\\n l=list(map(int,input().split()))\\n k=[]\\n for i in range(m):\\n a,b=list(map(int,input().split()))\\n k.append([a,b])\\n k.sort()\\n c=[]\\n flag=1\\n x=k[0][0]\\n y=k[0][1]\\n \\n for i in k[1:]:\\n if i[0]<=y:\\n y=max(y,i[1])\\n else:\\n c.append([x-1,y-1])\\n x=i[0]\\n y=i[1]\\n", "gt": "c.append([x-1,y-1])\\n m=[]\\n j=0\\n \\n for i in c:\\n while j<i[0]:\\n m.append(l[j])\\n j+=1\\n x=l[i[0]:i[1]+1]\\n m+=sorted(x)\\n j=i[1]+1\\n \\n while j<n:\\n m.append(l[j])\\n j+=1\\n \\n if m==sorted(l):\\n print('Possible')\\n else:\\n print('Impossible')\\n \\n \\n \\n \\n"}
{"id": "698", "input": "# cook your dish here\\ndef func(arr, k):\\n sumi = 0\\n for j in range(k):\\n sumi += arr[j]\\n maxi = sumi\\n for i in range(k,len(arr)):\\n sumi -=", "gt": "arr[i - k]\\n sumi += arr[i]\\n maxi = max(maxi,sumi)\\n return maxi\\nfor _ in range(int(input())):\\n n, k = map(int,input().split())\\n arr = [int(x) for x in input().split()]\\n print(func(arr,k))"}
{"id": "699", "input": "import math\\nt = int(input())\\n \\ndef phi(n):\\n res = n\\n i = 2\\n while i*i<=n:\\n if n%i==0:\\n res/=i\\n res*=(i-1)\\n \\n while", "gt": "n%i==0:\\n n/=i\\n i+=1\\n \\n if n>1:\\n res/=n\\n res*=(n-1)\\n \\n return int(res)\\n \\nwhile t:\\n a,m = list(map(int,input().split()))\\n g = math.gcd(a,m)\\n print(phi(m//g))\\n t-=1\\n"}
{"id": "700", "input": "for T in range(int (eval(input()))):\\n", "gt": "N,K,D=list(map(int,input().split()))\\n A=list(map(int,input().split()))\\n P=sum(A)//K \\n print(min(P,D))\\n"}
{"id": "701", "input": "for t in range(int(input())):\\n n = int(input())\\n l = []\\n m = []\\n x = list(map(int,input().split()))\\n l.append(x)\\n m.append(list(x))\\n", "gt": "for i in range(1,n):\\n x = list(map(int,input().split()))\\n l.append(x)\\n temp = []\\n for i in range(4):\\n temp.append (x[i]+min(m[-1][:i]+m[-1][i+1:]))\\n m.append(temp)\\n print(min(m[-1]))"}
{"id": "702", "input": "# cook your dish here\\ndef main():\\n for _ in range(int(input())):\\n N, k = [int(x) for x in input().split()]\\n Powers = [k ** int(x) for x in input().split()]\\n \\n s1, s2 = 0, sum(Powers)\\n \\n ans = (0, None)\\n \\n", "gt": "i = 0\\n while i < N - 1:\\n s1 += Powers[i]\\n s2 -= Powers[i]\\n \\n z = s1 * s2 \\n if z > ans[0]:\\n ans = (z, i)\\n # print(z)\\n \\n i += 1\\n \\n print(ans[1] + 1)\\n\\nmain()"}
{"id": "703", "input": "for i in range(int(input())):\\n m,tc,th=map(int,input().split())\\n x=(th-tc)\\n if", "gt": "x%3!=0:\\n print(\"Yes\")\\n else:\\n if (x//3)<=m:\\n print(\"No\")\\n else:\\n print(\"Yes\")"}
{"id": "704", "input": "pref = []\\r\\n\\r\\nfor i in range(10 ** 5 + 10):\\r\\n b = bin(i)[2:]\\r\\n if not any(b[j]", "gt": "== b[j+1] == '1' for j in range(len(b) - 1)):\\r\\n pref.append(i)\\r\\n else:\\r\\n pref.append(pref[-1])\\r\\n\\r\\nfor i in range(int(input())):\\r\\n print(pref[int(input())])\\r\\n"}
{"id": "705", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n a,n,m = map(int,input().split(' '))\\n s = len(str(a))\\n #print(s)\\n c", "gt": "= 10**s - 1\\n w = c*m\\n b = pow(10,n*s,w)-1\\n d = b//c\\n ans = (d%m)*(a%m)\\n print(ans%m)"}
{"id": "706", "input": "ar = []\\nar.append(1)\\nfor i in range(1, 31):\\n ar.append(ar[i-1]*(4*i-2)/(i+1))\\nt =", "gt": "int(input())\\nwhile(t>0):\\n n = int(input())\\n if(n==0):\\n print(0)\\n else:\\n print(ar[n]*2)\\n t=t-1\\n"}
{"id": "707", "input": "t=int(input())\\nfor i in range(t):\\n x,y=0,0\\n n,m=list(map(int,input().split()))\\n l=list(map(int,input().split()))\\n if(max(l)>m):\\n print(-1)\\n else:\\n", "gt": "for i in range(len(l)):\\n y+=l[i]\\n if(y>m):\\n y=l[i]\\n x+=1\\n if(y>0):\\n x+=1\\n print(x)\\n"}
{"id": "708", "input": "for t in range(eval(input())):\\n \\n n = eval(input())\\n \\n a = [ [] for i in range(n+1) ]\\n \\n for i in range(n-1):\\n x,y = list(map( int, input().split() ))\\n a[x].append(y)\\n a[y].append(x)\\n \\n vis = [0] * (n+1)\\n vis[1] = 1\\n\\n ans = [1]\\n\\n t1 = [1]\\n t2 = []\\n \\n while", "gt": "len(t1) > 0 :\\n for u in t1:\\n for x in a[u]:\\n if vis[x] == 0 :\\n vis[x] = 1\\n t2.append(x)\\n if len(t2) > 1 :\\n ans.append(t2[0])\\n ans.append(t2[-1])\\n if len(t2) == 1 :\\n ans.append(t2[0])\\n \\n t1 = t2\\n t2 = []\\n \\n for x in sorted(ans):\\n print(x, end=' ')\\n \\n print('')"}
{"id": "709", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n,k = list(map(int,input().split()))\\n mod = 10**9+7\\n s=0\\n", "gt": "for i in range(1,n+1):\\n p = pow(k,(2*i)-1,mod)\\n # print(p)\\n s=(s+p)%mod\\n # print(k)\\n k = (p*k)%mod\\n print(s)\\n\\n"}
{"id": "710", "input": "# cook your dish here\\ntry:\\n t = int(input())\\n for _ in range(t):\\n n", "gt": "= int(input())\\n a = list(map(int, input().split()))\\n gcd = max(a[0], a[-1])\\n \\n print(gcd)\\nexcept EOFError:pass"}
{"id": "711", "input": "def maxval(arr):\\n fn = [float('-inf')]*(len(arr)+1)\\n sn = [float('-inf')]*len(arr)\\n tn = [float('-inf')]*(len(arr)-1)\\n fon = [float('-inf')]*(len(arr)-2)\\n for i in reversed(list(range(len(arr)))):\\n fn[i] = max(fn[i + 1], arr[i])\\n for i in reversed(list(range(len(arr) - 1))):\\n sn[i] = max(sn[i + 1], fn[i + 1] -", "gt": "arr[i])\\n\\n for i in reversed(list(range(len(arr) - 2))):\\n tn[i] = max(tn[i + 1], sn[i + 1] + arr[i])\\n\\n for i in reversed(list(range(len(arr) - 3))):\\n fon[i] = max(fon[i + 1], tn[i + 1] - arr[i])\\n return fon[0]\\nn = int(input())\\narr = list(map(int,input().split()))\\nprint(maxval(arr))\\n \\n"}
{"id": "712", "input": "def convertToParitys(s):\\r\\n \"\"\"\\r\\n This converts the string s to an int, which is a bitMap of the parity of each letter\\r\\n odd ? = first bit set\\r\\n odd a = second bit set\\r\\n odd b = third bit set \\r\\n etc\\r\\n \"\"\"\\r\\n keys = '?abcdefghijklmnopqrstuvwxyz'\\r\\n paritys = {c:0 for c in keys}\\r\\n for c in s:\\r\\n paritys[c] += 1\\r\\n for c, v in paritys.items():\\r\\n paritys[c] = v%2\\r\\n \\r\\n out = 0\\r\\n bitValue = 1\\r\\n for c in keys:\\r\\n if paritys[c]:\\r\\n out += bitValue\\r\\n bitValue *= 2\\r\\n return out\\r\\n\\r\\ndef getSolutionBitMaps(s):\\r\\n \"\"\"\\r\\n these are the 27 valid bitmaps that a substring can have\\r\\n even ? and the parities the same\\r\\n 26 cases of odd ? and one bit different in the parity compared to s\\r\\n \"\"\"\\r\\n out = []\\r\\n sP = convertToParitys(s)\\r\\n if sP%2:\\r\\n sP -= 1 # to remove the '?' parity\\r\\n #even case - \\r\\n out.append(sP)\\r\\n #odd cases - need to xor sP with 1 + 2**n n = 1 to 26 inc to flip ? bit and each of the others\\r\\n for n in range(1,27):\\r\\n out.append(sP^(1+2**n))\\r\\n return", "gt": "out\\r\\n\\r\\ndef getLeadingSubStringBitMapCounts(s):\\r\\n \"\"\"\\r\\n This calculates the bit map of each of the len(s) substrings starting with the first character and stores as a dictionary.\\r\\n Getting TLE calculating each individually, so calculating with a single pass\\r\\n \"\"\"\\r\\n out ="}
{"id": "713", "input": "def gcd(a,b):\\n if b==0: return a\\n return gcd(b,a%b)\\n\\nfor _ in range(int(input())):\\n n = int(input())\\n arr = list(map(int,input().split()))\\n", "gt": "value = arr[0]\\n if n!=1:\\n for i in arr[1:]:\\n value = value*i//gcd(value, i)\\n if value%2==0:\\n print(\"NO\")\\n else:\\n print(\"YES\")"}
{"id": "714", "input": "t=int(input())\\ni=0\\nwhile i<t:\\n n=int(input())\\n A=[]\\n A=input().split()\\n m=int(input())\\n B=[]\\n B=input().split()\\n j=0\\n a=-1\\n while j<m:\\n c=1\\n if B[j] in A:\\n b=A.index(B[j])\\n", "gt": "A.remove(B[j])\\n if b>=a:\\n a=b\\n c=1\\n else:\\n c=0\\n break\\n else:\\n c=0\\n break\\n j+=1\\n if c==1:\\n print(\"Yes\")\\n else:\\n print(\"No\")\\n i+=1"}
{"id": "715", "input": "# cook your dish here\\nimport math\\nfor t in range(int(input())):\\n n=int(input())\\n a=[int(i) for i", "gt": "in input().split()]\\n div=sum(a)/n\\n div=math.ceil(div)\\n count=div*n-sum(a)\\n for i in a:\\n if i>div:\\n count+=i-div\\n print(count)"}
{"id": "716", "input": "# cook your dish here\\ns = input().strip()\\nstart_w = 27\\nw_dict = {}\\nwords = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\",", "gt": "\"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\\nfor word in words:\\n w_dict[word] = start_w\\n start_w = start_w - 1\\n\\ntotal_wt = 0\\nfor c in s:\\n total_wt = total_wt + w_dict[c]\\n\\nprint(total_wt)"}
{"id": "717", "input": "import math\\nn=1001\\na=[True]*n\\nl=[]\\nfor i in range(2,33):\\n if(a[i]):\\n for j in range(i*i,n,i):\\n a[j]=False\\nfor pr in range(2,1001):\\n if(a[pr]):\\n l.append(pr)\\nt=int(input())\\nfor j in range(t):\\n n,m=list(map(int,input().strip().split()))\\n arr=[int(num) for num in input().strip().split()]\\n Matrix =[]\\n index=[0]*100000\\n factors=[0]*100000\\n ans=''\\n for r in range(len(arr)):\\n li=[]\\n for val in l:\\n", "gt": "while((arr[r]%val)==0):\\n arr[r]=arr[r]/val\\n li.append(val)\\n factors[r]+=1\\n if(arr[r]!=1):\\n li.append(arr[r])\\n arr[r]=1\\n factors[r]+=1\\n Matrix.append(li)\\n for k in range(m):\\n opr=[int(o) for o in input().strip().split()]\\n L=opr[1]\\n R=opr[2]\\n if(opr[0]==0):\\n for ran in range(L-1,R):\\n if(index[ran]<factors[ran]):\\n index[ran]+=1\\n else:\\n result=1\\n for ran in range(L-1,R):\\n if(index[ran]<factors[ran]):\\n result=max(result,Matrix[ran][index[ran]])\\n ans+=str(result)\\n ans+=' '\\n print(ans[:-1])"}
{"id": "718", "input": "for i in", "gt": "range(int(input())):\\n print(2*(sum(list(map(int, input().split())))-1))"}
{"id": "719", "input": "import sys\\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\\ninp = lambda: list(map(int,sys.stdin.readline().rstrip(\"\\r\\n\").split()))\\n#_______________________________________________________________________________ _______________________\\n# from math import *\\n# from bisect import *\\n# from heapq import *\\n# from collections import defaultdict as dd\\n# from collections import OrderedDict as odict\\n# from collections import Counter as cc\\n# from collections import deque\\n# sys.setrecursionlimit(2*(10**5)+100) this is must for dfs\\n# mod = 10**9+7; md = 998244353\\n# ______________________________________________________________________________ ________________________\\n# segment tree for range minimum query\\n# sys.setrecursionlimit(10**5)\\n# n = int(input())\\n# a = list(map(int,input().split()))\\n# st = [float('inf') for i in range(4*len(a))]\\n# def build(a,ind,start,end):\\n# if start == end:\\n# st[ind] = a[start]\\n# else:\\n# mid = (start+end)//2\\n# build(a,2*ind+1,start,mid)\\n# build(a,2*ind+2,mid+1,end)\\n# st[ind] = min(st[2*ind+1],st[2*ind+2])\\n# build(a,0,0,n-1)\\n# def query(ind,l,r,start,end):\\n# if start>r or end<l:\\n# return float('inf')\\n# if l<=start<=end<=r:\\n# return st[ind]\\n# mid = (start+end)//2\\n# return min(query(2*ind+1,l,r,start,mid),query(2*ind+2,l,r,mid+1,end))\\n# ______________________________________________________________________________ ________________________\\n# Checking prime in O(root(N))\\n# def isprime(n):\\n# if (n % 2 == 0 and n > 2)", "gt": "or n == 1: return 0\\n# else:\\n# s = int(n**(0.5)) + 1\\n# for i in range(3, s, 2):\\n# if n % i == 0:\\n# return 0\\n# return 1\\n# def lcm(a,b):\\n# return (a*b)//gcd(a,b)\\n# ______________________________________________________________________________ ________________________\\n# nCr under mod\\n# def C(n,r,mod):\\n# if r>n:\\n# return 0\\n# num = den = 1\\n# for i in range(r):\\n# num = (num*(n-i))%mod\\n# den = (den*(i+1))%mod\\n# return (num*pow(den,mod-2,mod))%mod\\n# M = 10**5 +10\\n# ______________________________________________________________________________ ________________________\\n# For smallest prime factor of a number\\n# M = 1000010\\n# pfc = [i for i in range(M)]\\n# def pfcs(M):\\n# for i in range(2,M):\\n# if pfc[i]==i:\\n# for j in range(i+i,M,i):\\n# if pfc[j]==j:\\n# pfc[j] = i\\n# return\\n# pfcs(M)\\n# ______________________________________________________________________________ ________________________\\ntc = 1\\ntc, = inp()\\na = [0,1]\\nfor i in range(100000):\\n a.append(a[-1]+a[-2])\\nfor _ in range(tc):\\n n, = inp()\\n start = 0\\n for i in range(n):\\n print(*a[start:start+i+1])\\n print()\\n start +=i+1"}
{"id": "720", "input": "import re,sys\\ndef isCirlePossible(juices,distances):\\n if juices == [] or distances == []:\\n return -1;\\n total_juice_consumed = 0\\n juice_consumed = 0\\n start=0\\n for i in range(0,len(juices)):\\n diff = juices[i] - distances[i]\\n if juice_consumed >= 0:\\n juice_consumed += diff\\n", "gt": "else:\\n juice_consumed = diff\\n start = i\\n total_juice_consumed += diff\\n return start\\n\\njuices = []\\ndistances = []\\nnumLines = int(input())\\nfor each in range(0,numLines):\\n line = input()\\n result = [int(x) for x in re.findall('\\d+',line)]\\n if len(result) == 2:\\n juices.append(result[0])\\n distances.append(result[1])\\n\\nprint(isCirlePossible(juices,distances))\\nreturn"}
{"id": "721", "input": "t = int(input())\\nfor _ in range(t):\\n s = input()\\n pref = [0]*len(s)\\n if s[0]==\"1\":\\n pref[0]+=1\\n for i in range(1,len(s)):\\n if s[i]==\"1\":\\n pref[i]+=1\\n pref[i]=pref[i]+pref[i-1]\\n k=1\\n cnt=0\\n", "gt": "while (k+k*k)<=len(s):\\n r = k+k*k\\n i=r-1\\n while i<len(s):\\n if (i-r)>=0:\\n if pref[i]-pref[i-r]==k:\\n cnt+=1\\n i+=1\\n else:\\n i+=abs(k-(pref[i]-pref[i-r]))\\n \\n else:\\n if pref[i]==k:\\n cnt+=1\\n i+=1\\n else:\\n i+=abs(k-(pref[i]))\\n k+=1\\n print(cnt)"}
{"id": "722", "input": "# cook your dish here\\ndef permutation(n,p):\\n r=26\\n if n==1:\\n return 26\\n elif n==2:\\n return 52\\n elif n==3:\\n return 728\\n else:\\n if n%2==0:\\n return ((2*(bin_expo(r,((n//2)+1),p)-r)*bin_expo(25,1000000005,p)))%p\\n else:\\n n=n+1\\n return", "gt": "((2*((bin_expo(r,(n//2+1),p)-r)*bin_expo(r-1,1000000005,p)))- bin_expo(26,n//2,p))%p\\ndef bin_expo(x,n,p):\\n if n==0:\\n return 1\\n elif n==1:\\n return x%p\\n else:\\n temp=bin_expo(x,n//2,p)\\n temp=(temp*temp)%p\\n if n%2==0:\\n return temp\\n else:\\n return ((x%p)*temp)%p\\n\\ntest=int(input())\\nfor _ in range(test):\\n n=int(input())\\n p=1000000007\\n print(int(permutation(n,p)))"}
{"id": "723", "input": "'''input\\n2\\n7 3 5\\n5 2 5 2\\n2 4 2 6\\n6 2 6 4\\n5 6 5 7\\n7 1 7 4\\n7 3 7\\n1 1 6 1\\n1 2 3 2\\n5 2 5 2\\n2 6 2 6\\n6 2 6 4\\n5 6 5 7\\n7 1 7 4\\n'''\\n\\nfor _ in range(int(input())):\\n n, k, m = list(map(int, input().split()))\\n row_s = []\\n col_s = []\\n for _ in range(m):\\n h_x, h_y, t_x, t_y = list(map(int, input().split()))\\n if h_x == t_x:\\n if (h_x < (((n - k) // 2) + 1)) or (h_x > (((n - k) // 2) + k)):\\n col_s.append([min(h_y, t_y), max(h_y, t_y)])\\n else:\\n row_s.append([h_x, h_x])\\n if h_y == t_y:\\n if (h_y < (((n - k) // 2) + 1)) or (h_y > (((n - k) // 2) + k)):\\n row_s.append([min(h_x, t_x), max(h_x, t_x)])\\n else:\\n col_s.append([h_y, h_y])\\n row_s.sort()\\n col_s.sort()\\n\\n poss = True\\n\\n if len(col_s) == 0 or len(row_s) == 0:\\n print(-1)\\n continue\\n\\n # print(row_s, col_s)\\n\\n next_row = ((n - k) // 2) + 1\\n i = 0\\n count_row = 0\\n while i < len(row_s):\\n max_next = next_row\\n if next_row", "gt": "< row_s[i][0]:\\n poss = False\\n break\\n while i < len(row_s) and row_s[i][0] <= next_row:\\n # print(max_next, row_s[i], next_row)\\n max_next = max(max_next, row_s[i][1] + 1)\\n # print(max_next, row_s[i], next_row)\\n i += 1\\n next_row = max_next\\n count_row += 1\\n if next_row > (((n - k) // 2) + k):\\n break\\n if next_row < (((n - k) // 2) + k) and i >= len(row_s) :\\n poss = False\\n break\\n\\n # print(count_row)\\n\\n next_col = ((n - k) // 2) + 1\\n i = 0\\n count_col = 0\\n while i < len(col_s):\\n max_next = next_col\\n if next_col < col_s[i][0]:\\n poss = False\\n break\\n while i < len(col_s) and col_s[i][0] <= next_col:\\n # print(max_next, col_s[i], next_col)\\n max_next = max(max_next, col_s[i][1] + 1)\\n # print(max_next, col_s[i], next_col)\\n i += 1\\n next_col = max_next\\n count_col += 1\\n if next_col > (((n - k) // 2) + k):\\n break\\n if next_col < (((n - k) // 2) + k) and i >= len(col_s) :\\n poss = False\\n break\\n\\n # print(count_col)\\n print(count_col + count_row if poss else -1)\\n\\n # print(row_s, col_s)\\n"}
{"id": "724", "input": "def ans(l):\\n s = \"\"\\n i = 0\\n while (i < len(l)):\\n temp = l[i]\\n k = temp[1]\\n if (k != 0):\\n s += str(temp[0]) + \"x^\" + str(k)\\n else:\\n s += str(temp[0])\\n i += 1\\n if (i < len(l)):\\n s += \"", "gt": "+ \"\\n if (len(s) > 0):\\n return s\\n else:\\n return \"0\"\\n \\ntest = int(input())\\nwhile (test != 0):\\n test -= 1\\n N = int(input())\\n l = []\\n while (N != 0):\\n n,m = list(map(int,input().split()))\\n if (m > 0):\\n l += [[n*m,m-1]]\\n N -= 1\\n print(ans(l))\\n"}
{"id": "725", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n,k = [int(c) for c in input().split()]\\n a = [int(c) for c in input().split()]\\n ls = a\\n if n==1:\\n print(\"YES\")\\n print(1)\\n continue\\n if k==1:\\n print(\"NO\")\\n continue\\n \\n if k==2 and n>2:\\n if ls[0]!=ls[1]-1:\\n print(\"NO\")\\n continue\\n\\n", "gt": "ans = [0 for i in range(n+1)]\\n count = n\\n for i in range(1,a[1]):\\n if i != a[0]:\\n ans[i] =count\\n count-=1\\n for i in a[::-1]:\\n ans[i] = count\\n count-=1\\n for i in range(1,n+1):\\n if ans[i] == 0:\\n ans[i] = count\\n count-=1\\n print(\"YES\")\\n print(*ans[1:])"}
{"id": "726", "input": "def magic():\\n def check(art,k,m):\\n n=len(art)\\n for i in range(n-k+1):\\n maxi=0\\n maxi=max(art[i:i+k])\\n\\n total=0\\n total=art[i:i+k].count(maxi)\\n\\n if total>=m:\\n return False\\n\\n return True\\n \\n\\n\\n for _ in range(eval(input())):\\n n,k,m=list(map(int,input().split()))\\n arr=list(map(int,input().split()))\\n", "gt": "dp=[]\\n ans=100\\n\\n for mask in range(0,(1<<n)):\\n size=bin(mask).count('1')\\n\\n if ans>size:\\n art=list(arr)\\n for i in range(n):\\n if mask & (1<<i):\\n art[i]+=1\\n\\n if check(art,k,m):\\n ans=size\\n\\n print(ans if ans!=100 else -1)\\nmagic()\\n"}
{"id": "727", "input": "# cook your dish here\\nt=int(input())\\nwhile t>0:\\n n=int(input())\\n li=[]\\n c,o,d,e,h,f=0,0,0,0,0,0\\n for i in range(0,n):\\n s=input()\\n \\n for i in range(len(s)):\\n if s[i]=='c':\\n", "gt": "c=c+1\\n elif s[i]=='o':\\n o=o+1\\n elif s[i]=='d':\\n d=d+1\\n elif s[i]=='e':\\n e=e+1\\n elif s[i]=='h':\\n h=h+1\\n elif s[i]=='f':\\n f=f+1\\n e=e//2\\n c=c//2\\n print(min(c,o,d,e,h,f)) \\n t-=1"}
{"id": "728", "input": "D=[0]*31\\nD[1]=2\\nD[2]=5\\n\\nfor i in range(3,31):\\n best=10**10\\n for p in range(1,i+1):\\n best=min(best,D[p-1]+D[i-p]+i+1)\\n D[i]=best\\n\\nt=int(input())\\nfor i", "gt": "in range(t):\\n n,m=list(map(int,input().split()))\\n maxi=(n+2)*(n+1)/2-1\\n mini=D[n]\\n if mini<=m<=maxi: print(0)\\n elif m<mini: print(-1)\\n else: print(m-maxi)\\n"}
{"id": "729", "input": "def diagonal_difference(matrix):\\n l = sum(matrix[i][i] for i in range(N))\\n r = sum(matrix[i][N-i-1] for i", "gt": "in range(N))\\n return abs(l - r)\\n\\nmatrix = []\\nN = eval(input())\\nfor _ in range(N):\\n matrix.append(list(map(int, input().split())))\\n\\nprint(diagonal_difference(matrix))"}
{"id": "730", "input": "t=int(input())\\nfor _ in range(t):\\n n,m=map(int,input().split())\\n d={}\\n e={}\\n l=[]\\n for i in range(n):\\n d[i]=0\\n for i in range(m):\\n e[i]=0\\n for i in range(n):\\n l.append(input())\\n for i in range(n):\\n for j in range(m):\\n if l[i][j]=='1':\\n d[i]=1\\n e[j]=1\\n #ans=[]\\n if sum(d.values())+sum(e.values())==0:\\n k=[-1]*m\\n for i", "gt": "in range(n):\\n print(*k)\\n else:\\n ans=[]\\n for i in range(n):\\n ans.append([0]*m)\\n for i in range(n):\\n for j in range(m):\\n if l[i][j]=='1':\\n ans[i][j]=0\\n else:\\n if (d[i] or e[j]):\\n ans[i][j]=1\\n else:\\n ans[i][j]=2\\n for i in range(n):\\n for j in range(m):\\n print(ans[i][j],end=\" \")\\n print()\\n \\n \\n"}
{"id": "731", "input": "# cook your code here\\nfor _ in range(eval(input())):\\n n=eval(input())\\n ind=0\\n m=-1\\n \\n for i in range(n):\\n \\n l=[int(x) for x in input().split()]\\n sc=l[0]\\n", "gt": "for j in range(1,len(l)):\\n sc+=int(l[j]>=4)+int(l[j]>=5)+2*int(l[j]>=6)\\n if sc==m:\\n ind=-2\\n if sc>m :\\n m=sc\\n ind=i+1\\n \\n \\n if (ind==-2):\\n print(\"tie\")\\n elif (ind==1) :\\n print(\"chef\")\\n else:\\n print(ind)"}
{"id": "732", "input": "c,f=list(map(int,input().split()))\\r\\nl=[[1000001 for i in range(c)] for j in range(c)] \\r\\nwhile f:\\r\\n x,y,cost=list(map(int,input().split()))\\r\\n l[x-1][y-1]=cost\\r\\n l[y-1][x-1]=cost\\r\\n f-=1 \\r\\nfor i in range(c):\\r\\n l[i][i]=0\\r\\nfor k in range(c): \\r\\n for x in range(c):\\r\\n for y", "gt": "in range(c): \\r\\n if x==k or y==k or x==y:\\r\\n continue\\r\\n elif x!=y:\\r\\n l[x][y]=min(l[x][y],l[x][k]+l[k][y]) \\r\\nm=-1 \\r\\nfor i in range(c):\\r\\n for j in range(c):\\r\\n if m<l[i][j]:\\r\\n m=l[i][j]\\r\\nprint(m)\\r\\n # cook your dish here\\r\\n"}
{"id": "733", "input": "# cook your dish here\\nfor tc in range(int(input())):\\n \\n n = int(input())\\n \\n li1 = list(map(int,input().split(' ')))\\n li2 = list(map(int,input().split(' ')))\\n walk = 0\\n sum1 =", "gt": "0 \\n sum2 = 0\\n for i in range(n):\\n if li1[i] == li2[i] and sum1 == sum2:\\n walk += li1[i]\\n sum1 += li1[i]\\n sum2 += li2[i]\\n print(walk)"}
{"id": "734", "input": "# cook your dish here\\nT = int(input())\\nfor t", "gt": "in range(T):\\n N = int(input())\\n s = sorted(list(str(input())))\\n print(s[0])"}
{"id": "735", "input": "# cook your dish here\\nfrom collections import Counter,defaultdict\\n\\nfor i in range(int(input())):\\n n=int(input())\\n arr=list(map(int,input().split()))\\n coun=Counter(arr)\\n check=True\\n\\n for j in coun:\\n if coun[j]>n//2:\\n print(\"No\")\\n check=False\\n break\\n\\n\\n\\n\\n if", "gt": "check==True:\\n print(\"Yes\")\\n narr=sorted(arr)\\n dic=defaultdict()\\n j=0\\n for j in range(len(narr)):\\n if narr[j] not in dic:\\n dic[narr[j]]=j\\n ans=[0]*n\\n for j in range(len(arr)):\\n ans[j]=narr[(dic[arr[j]]+n//2)%n]\\n if coun[arr[j]]!=1:\\n dic[arr[j]]+=1\\n print(*ans)\\n"}
{"id": "736", "input": "for _ in range(eval(input())):\\n n=eval(input())\\n", "gt": "if n%2:\\n print('NO')\\n else:\\n print('YES')"}
{"id": "737", "input": "t = int(input())\\nfor i in range(t):\\n s = input().rstrip()\\n sumv = 0\\n for j in range(len(s)):\\n sumv += ord(s[j])\\n minv = 10 **", "gt": "8;\\n for i in range(ord('a'), ord('z') + 1):\\n val = abs(sumv - i * len(s))\\n if minv > val:\\n minv = val\\n print(minv)"}
{"id": "738", "input": "from math import sqrt\\ndef isPrime(n):\\n for i in range(2, int(sqrt(n))+1):\\n if(n%i==0): return True\\n return", "gt": "False\\nans = []\\nfor _ in range(int(input())):\\n x, y = map(int, input().split())\\n ans.append('NO' if(isPrime(x**2-y**2)) else 'YES')\\nprint('\\n'.join(ans))"}
{"id": "739", "input": "# cook your dish here\\n# cook your dish here\\n#powerful numbers\\nn = int(input())\\nplist = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191,", "gt": "193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313]\\npower = 1\\nfor i in range(2,n+1,1):\\n pdiv = []\\n count = 0\\n for p in plist:\\n if i>=p and i%p==0:\\n pdiv.append(p)\\n for pd in pdiv:\\n if i%(pd**2)==0:\\n count+=1\\n if count==len(pdiv) and count!=0:\\n power+=1\\n\\n \\n \\nprint(power)"}
{"id": "740", "input": "#!/usr/bin/env python\\n\\nfrom math import sqrt\\n\\ndef process(S):\\n P = [0,0,'S']\\n for i in S:\\n if i == 'L':\\n if P[-1] == 'N': P[-1] = 'W'\\n elif P[-1] == 'S': P[-1] = 'E'\\n elif P[-1] == 'E': P[-1] = 'N'\\n elif P[-1] == 'W': P[-1] = 'S'\\n elif i == 'R':\\n if P[-1] == 'N': P[-1] = 'E'\\n elif P[-1] == 'S': P[-1] = 'W'\\n elif P[-1] == 'E': P[-1] = 'S'\\n elif P[-1] == 'W': P[-1] = 'N'\\n else:\\n i = int(i)\\n if P[-1] == 'N': P[1] -= i\\n elif P[-1] == 'S': P[1] += i\\n elif P[-1] == 'E': P[0] += i\\n elif P[-1] == 'W': P[0] -= i\\n #print i, P\\n DIST = sqrt(P[0]**2+P[1]**2)\\n\\n if P[0] == 0", "gt": "and P[1] == 0: DIR = ''\\n elif P[0] == 0 and P[1] < 0: DIR = 'S'\\n elif P[0] == 0 and P[1] > 0: DIR = 'N'\\n elif P[0] < 0 and P[1] == 0: DIR = 'E'\\n elif P[0] < 0 and P[1] < 0: DIR = 'SE'\\n elif P[0] < 0 and P[1] > 0: DIR = 'NE'\\n elif P[0] > 0 and P[1] == 0: DIR = 'W'\\n elif P[0] > 0 and P[1] < 0: DIR = 'SW'\\n elif P[0] > 0 and P[1] > 0: DIR = 'NW'\\n\\n DIST = int(DIST*10.)/10. # TOLD NO APPROXIMATION\\n\\n return '%.1f%s' % (DIST, DIR)\\n\\ndef main():\\n T = int(input())\\n for t in range(T):\\n S = input().split()\\n print(process(S))\\n\\nmain()\\n\\n"}
{"id": "741", "input": "t=int(input())\\nwhile(t):\\n t-=1\\n d={}\\n n,m,k=[int(x) for x in list(input().split())]\\n sum=0\\n while(k):\\n k-=1\\n x,y=[int(x) for x in", "gt": "list(input().split())]\\n a=[-1,1,0,0]\\n b=[0,0,-1,1]\\n for i in range(4):\\n if((x+a[i],y+b[i]) in d):\\n sum-=1\\n else:\\n sum+=1\\n d[(x,y)]=1\\n print(sum)"}
{"id": "742", "input": "import random\\nimport os\\nyash=(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997)\\n\\ndef fix(m):\\n for ai in yash:\\n if m%ai==0:\\n return ai\\n return m\\n\\ndef rabin_miller(a,i,n):\\n if i==0:\\n return 1\\n x=rabin_miller(a,i/2,n)\\n if x==0:\\n return 0\\n y=(x*x)%n\\n if (y==1)and(x!=1)and(x!=n-1):\\n return 0\\n if i%2!=0:\\n y=(a*y)%n\\n return y\\n\\ndef gcd(x,y):\\n if y==0:\\n return x\\n return gcd(y,x%y)\\n\\ndef brent_rho(n):\\n if (n<=3)or(rabin_miller(random.randint(2,n-2),n-1,n)==1):\\n return n\\n y,r,q,m=1,1,1,203\\n while 1:\\n x=y\\n for i in range(1,r+1):\\n y=(y*y+1)%n\\n k=0\\nwhile 1:\\n ys=y\\n for i in range(1,min(m,r-k)+1):\\n y=(y*y+1)%n\\n q=(q*abs(x-y))%n\\n g=gcd(q,n)\\n k+=m\\n if (k>=r)or(g>1):\\n break\\n r*=2\\n if g>1:\\n break\\n if g==n:\\n while 1:\\n ys=(ys*ys+1)%n\\n g=gcd(abs(x-ys),n)\\n if g>1:\\n break\\n if g==n:\\n return n\\n return brent_rho(g)\\n\\ndef divsum2(n):\\n if n==1:\\n return 0\\n d=brent_rho(n)\\n d=fix(d)\\n assert (d<=3)or(rabin_miller(random.randint(2,d-2),d-1,d)==1)\\n f,m=0,n\\n while m%d==0:\\n m/=d\\n f = f + 1;\\n return (f*d)+(divsum2(m))\\n\\ntry:\\n while(1):\\n", "gt": "z=eval(input())\\n print(divsum2(z))\\nexcept:\\n os.sys.exit(0);"}
{"id": "743", "input": "import random\\n\\ndef sign(i):\\n if i>0:\\n return 1\\n elif i<=0:\\n return 0\\nbleh = []\\nfor _ in range(int(input())):\\n p = list(map(int,input().rstrip().split()))\\n max_rows = len(p)\\n if all([x==0 for x in p]):\\n print(1)\\n continue\\n if max_rows <= 1:\\n bleh.append(max_rows)\\n continue\\n max_pow = max_rows-1\\n if len(p)%2 !=0 and len(p)>0:\\n p.append(0)\\n max_col = len(p)//2\\n \\n rows = [[0 for _ in range(max_col)] for _ in range(max_rows)]\\n rows[0] = p[::2]\\n rows[1] = p[1::2]\\n if sign(rows[0][0]) != sign(rows[1][0]):\\n print(0)\\n continue\\n \\n for", "gt": "r in range(2,max_rows):\\n for n in range(max_col-1):\\n rows[r][n] = rows[r-1][0]*rows[r-2][n+1]-rows[r-2][0]*rows[r-1][n+1]\\n \\n last = sign(rows[0][0])\\n flag = 1\\n for i in range(1,len(rows)):\\n curr = sign(rows[i][0])\\n if rows[r] == [0 for _ in range(max_col)]:\\n for n in range(max_col):\\n rows[r][n] = rows[r-1][n]*(max_pow+4-(r+1)-2*(n+1)) \\n \\n elif rows[i][0] == 0:\\n if any([x != 0 for x in rows[i]]):\\n flag = 0\\n break\\n else:\\n curr = last\\n if curr != last:\\n flag = 0\\n break\\n last = curr \\n print(flag)\\n"}
{"id": "744", "input": "# cook your dish here\\nt=int(input())\\nfor i in range(t,0,-1):\\n", "gt": "x,y=map(int,input().split())\\n k=x//y\\n \\n if k%y==0:\\n print(\"NO\")\\n else:\\n print(\"YES\")"}
{"id": "745", "input": "t=int(input())\\nfor _ in range(t):\\n n=int(input())\\n l1=[]\\n if n==1:\\n print('*')\\n elif n==3:\\n print('*')\\n print('**')\\n print('*')\\n else:\\n s1=\"\"\\n n1=n//2\\n n1+=1 \\n for i in range(1,n1+1):\\n s1=\"\"\\n if i==1:\\n", "gt": "s1+='*'\\n elif i==2:\\n s1+='**'\\n else:\\n s1+='*'\\n for j in range(2,i):\\n s1+=' '\\n s1+='*'\\n l1.append(s1)\\n for i in l1:\\n print(i)\\n l1.reverse()\\n for i in range(1,len(l1)):\\n print(l1[i])\\n \\n \\n"}
{"id": "746", "input": "# cook your dish here\\n\\nt = int(input())\\nwhile t:\\n t -= 1\\n n = int(input())\\n arr = list(map(int, input().split()))\\n sumi = sum(arr)\\n prev = 1\\n for i in range(n):\\n arr[i] = min(arr[i], prev)\\n prev = arr[i]", "gt": "+ 1\\n prev = 1\\n for i in range(n - 1, -1, -1):\\n arr[i] = min(arr[i], prev)\\n prev = arr[i] + 1\\n temp = 0\\n for i in range(n):\\n temp = max(temp, arr[i])\\n print(sumi -( temp*temp))\\n\\n\\n"}
{"id": "747", "input": "def treeProduct(num, h, root, ch):\\n if ch >= h:\\n return num[root]\\n\\n left = (root * 2) + 1\\n right = (root * 2) + 2\\n\\n ret1 = treeProduct(num, h, left, ch + 1)\\n ret2 = treeProduct(num,", "gt": "h, right, ch + 1)\\n\\n return num[root] * max(ret1, ret2)\\n\\ndef main():\\n n = int(input())\\n while n!=0:\\n line = str(input())\\n s = line.split()\\n num = [int((e)) for e in s]\\n print(int(treeProduct(num,n,0,1)%1000000007))\\n n = int(input())\\n \\n \\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "748", "input": "for _ in range(int(input())):\\n n = int(input())\\n\\n arr= list(map(int,input().split()))\\n arr.sort()\\n d={}\\n for i in arr:\\n if i not in d:\\n d[i]=1\\n else:\\n d[i]+=1\\n \\n flag = True\\n for i in d:\\n if d[i]>2:\\n flag=False\\n", "gt": "break\\n \\n \\n\\n if arr.count(max(arr))!=1:\\n flag=False\\n \\n \\n if flag==True:\\n\\n arr1=[]\\n arr2=[]\\n for i in d:\\n if d[i]<=2:\\n if d[i]==2:\\n \\n arr2.append(i)\\n arr1.append(i)\\n arr2.reverse()\\n rearr= arr1+arr2\\n\\n print(\"YES\")\\n print(*rearr)\\n\\n else:\\n print(\"NO\")\\n \\n# cook your dish here\\n"}
{"id": "749", "input": "from itertools import permutations\\n\\ndef solve(n,a):\\n ans=[]\\n \\n for des in desire:\\n check=1\\n for i in range(n-1):\\n \\n if (a[i]==a[i+1]):\\n return [-1]\\n if a[i+1]==des[a[i]-1]:\\n check=0\\n break\\n if check:\\n ans=des\\n break\\n if ans:\\n return ans\\n return [-1]\\n", "gt": "\\n\\nper=permutations([1,2,3,4,5,6])\\ndesire=[]\\nfor p in per:\\n check=1\\n for i in range(1,7):\\n if p[i-1]==i:\\n check=0\\n break\\n if check:\\n doublecheck=1\\n for i in range(6):\\n if p[p[i]-1]!=i+1:\\n doublecheck=0\\n break\\n if doublecheck:\\n desire.append(p)\\n#print(desire)\\nfor _ in range(int(input())):\\n \\n n=int(input())\\n a=list(map(int,input().split( )))\\n print(*solve(n,a))"}
{"id": "750", "input": "n=int(input())\\r\\nl=[]\\r\\nfor i in range(n):\\r\\n l.append([int(x) for x in input().split()])\\r\\nd=[10**9]*(n)\\r\\nq=set([int(x) for x in range(1,n)])\\r\\nd[1]=0\\r\\n#print(q)\\r\\ndef extract():\\r\\n mini=10**9\\r\\n o=0\\r\\n for i in range(1,len(d)):\\r\\n if d[i]<mini", "gt": "and i in q:\\r\\n mini=d[i]\\r\\n o=i\\r\\n q.remove(o)\\r\\n return o\\r\\nwhile len(q)!=0:\\r\\n x=extract()\\r\\n for i in range(1,n):\\r\\n if i in q and l[x][i]<d[i]:\\r\\n d[i]=l[x][i]\\r\\nprint(sum(d[1:]))"}
{"id": "751", "input": "def invper(ar):\\n ar1=[0]*(len(ar))\\n for i in range(len(ar)):\\n ar1[ar[i]-1]=i+1\\n return ar1\\nt=int(input())\\n\\nwhile(t!=0):\\n", "gt": "ar=list(map(int,input().split()))\\n ar1=invper(ar)\\n if(ar==ar1):\\n print(\"ambiguous\")\\n else:\\n print(\"not ambiguous\")\\n t = int(input())\\n"}
{"id": "752", "input": "for _ in range(int(input())):\\n n=int(input())\\n s=list(input())\\n coord=list(map(int,input().split()))\\n p=0\\n i=0\\n h=[]\\n for i in range(0,n):\\n if s[i]=='1':\\n h.append(i)\\n if h[0]!=0:\\n p=p+coord[h[0]]-coord[0]\\n if", "gt": "h[len(h)-1]!=n-1:\\n p=p+coord[n-1]-coord[h[len(h)-1]]\\n for j in range(0,len(h)-1):\\n if h[j]+1==h[j+1]:\\n continue\\n if h[j+1]-h[j]-1==1:\\n p=p+min(coord[h[j]+1]-coord[h[j]],coord[h[j+1]]-coord[h[j]+1])\\n else:\\n y=min(coord[h[j+1]]-coord[h[j]+1],coord[h[j+1]-1]-coord[h[j]])\\n for k in range(h[j]+1,h[j+1]-1):\\n y=min(y,coord[k]-coord[h[j]]+coord[h[j+1]]-coord[k+1])\\n p=p+y\\n print(p)"}
{"id": "753", "input": "# cook your dish here\\nn,m=list(map(int,input().split()))\\na={}\\nfor i in range(n):\\n x,y=input().split()\\n a[x]=y\\nfor i in range(m):\\n c=input().strip()\\n if", "gt": "'.' not in c:\\n print(\"unknown\")\\n else:\\n h=c.split('.')[-1]\\n if h in a:\\n print(a[h])\\n else:\\n print('unknown')\\n \\n \\n"}
{"id": "754", "input": "for t in range(int(input())):\\r\\n l1=list(map(int,input().split()))\\r\\n l2=list(map(int,input().split()))\\r\\n l3=list(map(int,input().split()))\\r\\n max=0\\r\\n g=l1[0]+l2[0]+l3[0]\\r\\n y=l1[1]+l2[1]+l3[1]\\r\\n r=l1[2]+l2[2]+l3[2]\\r\\n if g%2==0:\\r\\n g-=1\\r\\n if y%2==0:\\r\\n y-=1\\r\\n if r%2==0:\\r\\n r-=1\\r\\n if max<g:\\r\\n max=g\\r\\n if max<r:\\r\\n", "gt": "max=r\\r\\n if max<y:\\r\\n max=y\\r\\n m=l1[0]+l1[1]+l1[2]\\r\\n o=l2[0]+l2[1]+l2[2]\\r\\n p=l3[0]+l3[1]+l3[2]\\r\\n if m%2==0:\\r\\n m-=1\\r\\n if o%2==0:\\r\\n o-=1\\r\\n if p%2==0:\\r\\n p-=1\\r\\n if max<m:\\r\\n max=m\\r\\n if max<o:\\r\\n max=o\\r\\n if max<p:\\r\\n max=p\\r\\n\\r\\n print(max)\\r\\n"}
{"id": "755", "input": "# cook your dish here\\nfor i in range(int(input())):\\n n = int(input())\\n flag = 0\\n while(n>0):\\n", "gt": "if((n%10)%2 == 0):\\n flag = 1\\n break\\n n = n//10\\n if(flag == 0):\\n print(0)\\n else:\\n print(1)"}
{"id": "756", "input": "l = []\\nfor _ in range(int(input())):\\n l.append(int(input()))\\nfor i in range(2,max(l)):\\n r = [x%i for x", "gt": "in l]\\n if len(set([x%i for x in l])) == 1:\\n print(i, end = ' ')\\n"}
{"id": "757", "input": "# cook your dish here\\nimport math\\ntry:\\n def prime(n):\\n for i in range(2, int(math.sqrt(n)) + 1):\\n if n % i == 0:\\n return False\\n return True\\n \\n for t in range(int(input())):\\n x,", "gt": "y = list(map(int, input().split()))\\n s = x + y \\n i = s\\n while(1):\\n if prime(s + 1):\\n ans = s + 1\\n break\\n else:\\n s += 1\\n print(ans - i)\\n\\nexcept: pass\\n"}
{"id": "758", "input": "for t in range(int(input())):\\r\\n n=int(input())\\r\\n s=input().strip()\\r\\n c=0\\r\\n flag=0\\r\\n for i in range(n):\\r\\n if (s[i]==\"A\" or s[i]==\"E\" or s[i]==\"I\" or s[i]==\"O\"", "gt": "or s[i]==\"U\") and (s[i-1]==\"A\" or s[i-1]==\"E\" or s[i-1]==\"I\" or s[i-1]==\"O\" or s[i-1]==\"U\") :\\r\\n flag=1\\r\\n if flag and n!=1:\\r\\n print(\"Yes\")\\r\\n else:\\r\\n print(\"No\")\\r\\n"}
{"id": "759", "input": "import sys\\nimport math\\ninput=sys.stdin.readline\\ndef binary(l,r,co,b,c):\\n x=(l+r)/2\\n #print(x)\\n val1=(2*x+b)*math.sin(x)\\n val2=(x**2+b*x+c)*math.cos(x)\\n x=(l+r)/2\\n val=val1-val2\\n if(abs(val)<.0000001 or co==150):\\n return (l+r)/2\\n if(val<0):\\n return", "gt": "binary((l+r)/2,r,co+1,b,c)\\n else:\\n return binary(l,(l+r)/2,co+1,b,c)\\nt=int(input())\\nfor _ in range(t):\\n b,c=list(map(float,input().split()))\\n x=binary(.0000000001,math.pi/2-.0000000001,0,b,c)\\n #print(\"t=\",_)\\n val=(x*x+b*x+c)/math.sin(x)\\n print(val)\\n \\n\\n \\n\\n\\n \\n \\n \\n\\n\\n \\n"}
{"id": "760", "input": "# cook your dish here\\nstore=[0]*(10**5+1)\\ndef sieve():\\n for i in range(2,10**5+1):\\n if(store[i]==0):\\n store[i]=1\\n for j in range(i,10**5+1,i):\\n store[j]=i\\nsieve()\\n# print(store)\\nfor _ in range(int(input())):\\n \\n n=int(input())\\n li=[int(x)", "gt": "for x in input().split()]\\n\\n dp=[0]*(10**5+1)\\n for i in li:\\n dp[store[i]]+=1\\n max_re=0\\n res=0\\n for i in li:\\n if(dp[store[i]]==max_re):\\n if(store[i]>res):\\n res=store[i]\\n elif(dp[store[i]]>max_re):\\n max_re=dp[store[i]]\\n res=store[i]\\n \\n print(res)\\n\\n\\n\\n"}
{"id": "761", "input": "import math\\ndef egcd(a, b):\\n if a == 0:\\n return (b, 0, 1)\\n else:\\n g, y, x = egcd(b % a, a)\\n return (g, x - (b // a) * y, y)\\n\\ndef modin(a, m):\\n g, x, y = egcd(a, m)\\n return x % m\\n# def gcdexten(a,b,x,y):\\n# if a == 0:\\n# x = 0\\n# y = 1\\n# return b\\n# x1 = y1 = 0\\n# gcd = gcdexten(b%a,a,x1,y1)\\n\\n# x = y1 - (b/a) * x1\\n# y = x1\\n# return gcd\\n\\n# def modin(a):\\n# m = 10**9 + 7\\n# x = y = 0\\n# g = gcdexten(a,m,x,y)\\n# res = (x%m + m)%m\\n# return res\\n\\n# void modInverse(int a, int m)\\n# {\\n# int x, y;\\n# int g = gcdExtended(a, m, &x, &y);\\n# if (g != 1)\\n# cout << \"Inverse doesn't exist\";\\n# else\\n# {\\n# // m is added to handle negative x\\n# int res = (x%m + m) % m;\\n# cout << \"Modular multiplicative inverse is \" << res;\\n# }\\n# }\\n# int gcdExtended(int a, int b, int *x, int *y)\\n# {\\n# // Base Case\\n# if (a == 0)\\n# {\\n# *x = 0, *y = 1;\\n# return b;\\n# }\\n \\n# int x1, y1; // To store results of recursive call\\n# int gcd = gcdExtended(b%a, a, &x1, &y1);\\n \\n# // Update x and y using results of recursive\\n# // call\\n# *x = y1 - (b/a) * x1;\\n# *y = x1;\\n \\n# return gcd;\\n# }\\ndef combi(a,b):\\n mod = 10**9 + 7\\n if a < b:\\n return 0\\n if a == 1:\\n return 1\\n if b < a/2:\\n b = a - b\\n temp = 1\\n for i in range(b + 1,a + 1):\\n temp = (temp * i%mod)%mod\\n denom = modin(math.factorial(a-b),mod)\\n # print denom\\n return (temp%mod * denom%mod)%mod\\nfor _ in range(eval(input())):\\n mod = 10**9 + 7\\n string1 = input()\\n n =", "gt": "len(string1)\\n dict1 ="}
{"id": "762", "input": "t=int(input())\\n\\ndef diffe(a,b):\\n return int(a-b)\\n\\nwhile t :\\n t=t-1\\n \\n lia=[]\\n lib=[]\\n lik=[]\\n lim=[]\\n liab=[]\\n likm=[]\\n n,k,m=list(map(int,input().split()))\\n \\n \\n lia=list(map(int,input().split()))\\n lib=list(map(int,input().split()))\\n lik=list(map(int,input().split()))\\n lim=list(map(int,input().split()))\\n liab=list(map(diffe,lia,lib)) \\n \\n likm=lik+lim\\n", "gt": "\\n \\n likm.sort()\\n \\n liab.sort()\\n liab.reverse()\\n \\n for i in range(0,len(liab)): \\n for j in range(len(likm)-1,0-1,-1):\\n a=likm.pop()\\n if (liab[i]-a)>=0:\\n liab[i]=liab[i]-a\\n \\n break\\n \\n \\n print(sum(liab)) \\n\\n"}
{"id": "763", "input": "t=int(input())\\nwhile(t):\\n n=int(input())\\n cnt=1;\\n for i in range(n):\\n s=\"\"\\n for j", "gt": "in range(n):\\n s=s+str(bin(cnt))[2:][: : -1]+\" \"\\n cnt=cnt+1\\n print(s)\\n \\n t=t-1"}
{"id": "764", "input": "\\ndef solve(s, p):\\n diffs = 0\\n for x, y in zip(s, p):\\n if x == y:\\n continue\\n if x == '0':\\n if diffs < 1:\\n return \"No\"\\n diffs", "gt": "-= 1\\n else:\\n diffs += 1\\n return \"Yes\" if diffs == 0 else \"No\"\\n\\nfor _ in range(int(input())):\\n l = int(input())\\n s = input().strip()\\n p = input().strip()\\n print(solve(s, p))\\n"}
{"id": "765", "input": "# cook your dish here\\nt=int(input())\\ni=0\\nwhile i<t:\\n a=[]\\n a=input().split()\\n b=[]\\n b=input().split()\\n j=0\\n c=0\\n while", "gt": "j<4:\\n if a[j] in b:\\n c+=1\\n j+=1\\n if c>=2:\\n print(\"similar\")\\n else:\\n print(\"dissimilar\")\\n i+=1"}
{"id": "766", "input": "n=int(input())\\na=list(map(int,input().split()))\\nq=int(input())\\nwhile q>0:\\n i=1\\n tot=a[0]\\n b=list(map(int,input().split()))\\n if b[0]==1:\\n #p,f=map(int,raw_input().split())\\n a[b[1]-1]=b[2]\\n else:\\n", "gt": "#r=int(raw_input())\\n tot=a[0]\\n while 1+i*b[1]<=n:\\n tot=tot*a[i*b[1]]\\n i=i+1\\n m=(str)(tot)\\n tot=tot%1000000007\\n print((int)(m[0]),tot)\\n q=q-1\\n"}
{"id": "767", "input": "import sys\\r\\nimport math\\r\\nimport bisect\\r\\nfrom sys import stdin,stdout\\r\\nfrom math import gcd,floor,sqrt,log\\r\\nfrom collections import defaultdict as dd\\r\\nfrom bisect import bisect_left as bl,bisect_right as br\\r\\n\\r\\nsys.setrecursionlimit(100000000)\\r\\n\\r\\nii =lambda: int(input())\\r\\nsi =lambda: input()\\r\\njn =lambda x,l: x.join(map(str,l))\\r\\nsl =lambda: list(map(str,input().strip()))\\r\\nmi =lambda: map(int,input().split())\\r\\nmif", "gt": "=lambda: map(float,input().split())\\r\\nlii =lambda: list(map(int,input().split()))\\r\\n\\r\\nceil =lambda x: int(x) if(x==int(x)) else int(x)+1\\r\\nceildiv=lambda x,d: x//d if(x%d==0) else x//d+1\\r\\n\\r\\nflush =lambda: stdout.flush()\\r\\nstdstr =lambda: stdin.readline()\\r\\nstdint =lambda: int(stdin.readline())\\r\\nstdpr =lambda x: stdout.write(str(x))\\r\\n\\r\\nmod=1000000007\\r\\n\\r\\n\\r\\n#main code\\r\\nfor _ in range(ii()):\\r\\n n=ii()\\r\\n arr=lii()\\r\\n arr.sort()\\r\\n ma=arr[-1]*arr[-2]\\r\\n mi=arr[0]*arr[1]\\r\\n print(ma,mi)"}
{"id": "768", "input": "# cook your dish here\\nwhile True:\\n try:\\n n=int(input())\\n lis=[]\\n for i in range(n):\\n k=list(map(int,input().split()))\\n k.append(k[1]+k[2])\\n lis.append(k)\\n \\n #print(lis)\\n p=sorted(lis,key=lambda", "gt": "x:x[3],reverse=True)\\n #print(p)\\n maxi=0\\n s=0\\n w=0\\n for i in range(n):\\n s+=p[i][0]\\n w=s+p[i][1]+p[i][2]\\n maxi=max(maxi,w)\\n \\n print(maxi)\\n \\n \\n except:\\n break\\n \\n"}
{"id": "769", "input": "# cook your dish here\\n# cook your dish here\\nfrom math import log2;\\nimport sys;\\n\\nsys.setrecursionlimit(10 ** 7)\\nfrom collections import defaultdict\\n\\ninf = float(\"inf\")\\ndef find_height(node):\\n nodes[node]=1\\n for i in graph[node]:\\n nodes[node]+=find_height(i)\\n", "gt": "return nodes[node]\\ndef find_sum(node):\\n suma=nodes[node]\\n maxa=0\\n for i in graph[node]:\\n maxa=max(find_sum(i),maxa)\\n return maxa+suma\\nfor i in range(int(input())):\\n n=int(input())\\n l=list(map(int,input().split()))\\n graph=defaultdict(set)\\n for i in range(len(l)):\\n\\n graph[l[i]].add(i+2)\\n nodes=defaultdict(int)\\n find_height(1)\\n ans=find_sum(1)\\n print(ans)\\n\\n\\n\\n"}
{"id": "770", "input": "import math\\nfor i in", "gt": "range(int(input())):\\n a,b = map(int,input().split())\\n print(math.gcd(a,b))"}
{"id": "771", "input": "import sys\\nimport math\\n\\ndef main(arr,k):\\n \\n \\n x=[]\\n y=[]\\n \\n \\n \\n for e in arr:\\n if e%2==0:\\n x.append(e)\\n y.append(0)\\n else:\\n x.append(0)\\n y.append(e)\\n \\n a=[0]*n\\n b=[0]*n\\n a[0]=x[0]\\n", "gt": "b[0]=y[0]\\n for i in range(1,n):\\n \\n if i<k:\\n a[i]=max(x[i],a[i-1])\\n b[i]=max(y[i],b[i-1])\\n else:\\n a[i]=max(x[i]+a[i-k-1],a[i-1])\\n b[i]=max(y[i]+b[i-k-1],b[i-1])\\n \\n print(a[-1]+b[-1]) \\n return \\n\\nfor i in range(int(input())):\\n n,k=list(map(int,input().split()))\\n \\n arr=list(map(int,input().split()))\\n \\n (main(arr,k))\\n\\n"}
{"id": "772", "input": "from operator import itemgetter\\nt=int(input())\\nfor i in range(t):\\n n=int(input())\\n m,f=list(map(int,input().split()))\\n x=list(map(int,input().split()))\\n my,fy=0,0\\n check=[0]*n\\n #print check\\n for j in range(n):\\n if x[j]>0 and x[j]%m==0 and check[j]==0:\\n check[j]=1\\n my+=1\\n #print check\\n", "gt": "for j in range(n):\\n if x[j]>0 and x[j]%f==0 and check[j]==0:\\n check[j]=1\\n fy+=1\\n if ((((my+fy)*1.0)/n)*100)>=70:\\n print(\"Yes\")\\n if my>fy:\\n print(\"Multan\")\\n elif fy>my:\\n print(\"Fultan\")\\n else:\\n print(\"Both\")\\n else:\\n print(\"No\") \\n #print check\\n"}
{"id": "773", "input": "\\n\\n\\ndef powerset(s):\\n n = len(s)\\n masks = [1 << j for j in range(n)]\\n for i in range(2**n):\\n yield [j + 1 for j in range(n) if (masks[j] & i)]\\n\\n\\ndef is_power2(num):\\n return num != 0 and ((num & (num - 1)) == 0)\\n\\n\\ndef special(l):\\n n = len(l)\\n for i in range(n):\\n lis = [i + 1]\\n yield lis\\n for j in range(i + 1, n):\\n p = l[j] / l[i]\\n if p <= 1 or int(p) != p:\\n continue\\n lis = [i + 1, j + 1]\\n yield lis\\n sk = (j", "gt": "+ 1) * int(p)\\n while sk <= n:\\n lis.append(sk)\\n sk *= int(p)\\n yield lis\\n\\n\\ndef expIndices(l):\\n a = list(zip(l, l[1:]))\\n if len(a) == 0:\\n return True\\n else:\\n p = a[0][1] / a[0][0]\\n if p <= 1 or int(p) != p:\\n return False\\n for i in range(1, len(a)):\\n if a[i][1] / a[i][0] != p:\\n return False\\n return True\\n\\n\\ndef main():\\n for _ in range(eval(input())):\\n S = input()\\n count = 0\\n\\n for i in special(range(1, len(S) + 1)):\\n s = [S[j - 1] for j in i]\\n if s == s[::-1]:\\n count += 1\\n print(count)\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "774", "input": "tests = int(input())\\r\\nfor t in range(tests):\\r\\n n = int(input())\\r\\n permut='2'\\r\\n permut_list=[]\\r\\n if n%2==0:\\r\\n for i in range(2, n+1):\\r\\n if i%2==1:\\r\\n permut=permut+' '+str(i+1)\\r\\n else:\\r\\n permut=permut+' '+str(i-1)\\r\\n print(permut)\\r\\n", "gt": "pass\\r\\n elif n==1:\\r\\n print(1)\\r\\n pass\\r\\n else:\\r\\n for i in range(2, n):\\r\\n if i%2==1:\\r\\n permut_list.append(str(i+1))\\r\\n else:\\r\\n permut_list.append(str(i-1))\\r\\n permut_list.pop(-1)\\r\\n permut_list.append(str(n))\\r\\n permut_list.append(str(n-2))\\r\\n this_permut='2'\\r\\n for el in permut_list:\\r\\n this_permut=this_permut+' '+el\\r\\n print(this_permut)"}
{"id": "775", "input": "# cook your dish here\\nn, k, p = [int(i) for i in input().split()]\\nn_sep = list(map(int, input().split()))\\ncount = 0\\nsep_sort = sorted(n_sep)\\nhashing = {sep_sort[0]: 0}\\n\\nfor j in range(1, n):\\n if (abs(sep_sort[j] -", "gt": "sep_sort[j - 1]) > k):\\n count += 1\\n hashing[sep_sort[j]] = count\\n#print(hashing)\\nfor i in range(p):\\n pair = list(map(int, input().split()))\\n \\n if hashing[n_sep[pair[1] - 1]] == hashing[n_sep[pair[0] - 1]]:\\n print(\"Yes\")\\n else:\\n print(\"No\")\\n"}
{"id": "776", "input": "try:\\n# https://www.codechef.com/LTIME63B/problems/GHMC\\n# Finally.... I properly understood what needs to be done.\\n\\n def ctlt(arr, val):\\n # find number of values in sorted arr < val\\n if arr[0] >= val: return 0\\n lo = 0\\n hi = len(arr)\\n while hi-lo > 1:\\n md = (hi+lo)//2\\n if arr[md]<val:\\n lo = md\\n else:\\n hi = md\\n\\n return hi\\n\\n for _ in range(int(input())):\\n n,k,x,d = map(int, input().split())\\n z = input().strip().split()\\n if k > 0:\\n ps = list(map(int,z[:k]))\\n else:\\n ps = [x]\\n\\n ps.sort()\\n\\n if x<n or x<ps[-1] or n<k:\\n print(-1)\\n continue\\n\\n valchecked = 0\\n fillval = 0\\n valsdone = False\\n isolbelow = True\\n lastp = ps[0]\\n\\n while not valsdone and n>=k:\\n if n == k:\\n lo = x+d+1 # put out of range\\n else:\\n # find best maxfill (before val support)\\n lo = 1\\n hi = x+1\\n while hi-lo>1:\\n md = (hi+lo)//2\\n v = (x-md+1)", "gt": "+ ctlt(ps,md)\\n if v<n:\\n hi = md\\n else:\\n lo = md\\n \\n valsdone = True\\n checkto = ctlt(ps,lo)-1\\n if checkto >= valchecked: \\n # support all vals\\n for p in ps[valchecked+1:checkto+1]:\\n if lastp+d >= p:\\n isolbelow = False\\n elif isolbelow:\\n valsdone = False\\n fillval += lastp+d\\n n -= 1\\n isolbelow = (p > lastp + 2*d )\\n else:\\n isolbelow = True\\n lastp = p\\n valchecked = checkto\\n if valsdone and isolbelow: \\n # check gap to maxfill\\n if lastp + d >= lo:\\n isolbelow = False\\n else:\\n valsdone = False\\n fillval += lastp\\n ps[checkto] += d\\n lastp += d\\n isolbelow = False\\n n -= 1\\n\\n if k > n:\\n print(-1)\\n elif k == n:\\n print(sum(ps) + fillval)\\n elif k == n-1 and lo > ps[-1]:\\n print(sum(ps) + fillval + min(x,ps[-1]+d))\\n else:\\n tot = (x+lo)*(x-lo+1)//2 + sum(ps[:ctlt(ps,lo)])\\n print(tot + fillval)\\nexcept:\\n pass"}
{"id": "777", "input": "# cook your dish here\\nt=int(input())\\nfor i in range(t):\\n D=int(input())\\n P=10**5-2\\n ans=[]\\n if(D==0):\\nans.append(1)\\n while(D>0):\\n P=min(P,D)\\n ans.append(P+2);\\n", "gt": "ans.append(P+1);"}
{"id": "778", "input": "import math\\nt=eval(input())\\nwhile t:\\n t=t-1\\n r1,h1,r2,h2=list(map(float,input().split()))\\n vol1=(math.pi*r1*r1*h1)/3", "gt": "+ (2*math.pi*r1*r1*r1)/3\\n vol2=math.pi*r2*r2*h2\\n print(\"%.8f %.8f\" % (vol1,vol2))\\n\\n"}
{"id": "779", "input": "# cook your dish here\\nx=int(input())\\nfor", "gt": "i in range(x):\\n s=input()\\n print(int(s[::-1]))\\n"}
{"id": "780", "input": "t=int(input())\\nfor i in range(t):\\n n=int(input())\\n N=list(map(int,input().split()))\\n N.sort()\\n \\n k=n-1\\n", "gt": "ave=N[k]\\n for j in range(n-1):\\n ave=(ave+N[k-1])/2\\n k=k-1\\n \\n print(ave)"}
{"id": "781", "input": "import sys\\nuser_input = sys.stdin.readline().split()\\n\\nT = int(user_input[0])\\n\\nfor j in range(T) :\\n\\n var = sys.stdin.readline().split()\\n", "gt": "N = int(var[0])\\n M = int(var[1])\\n\\n if (N%M)%2 :\\n print(\"ODD\")\\n else :\\n print(\"EVEN\")"}
{"id": "782", "input": "# cook your dish here\\nfrom sys import stdin,stdout\\n\\na0=0\\na1=1\\nn,k=stdin.readline().strip().split(' ')\\nn,k=int(n),int(k)\\n\\narr=list(map(int,stdin.readline().strip().split(' ')))\\n\\n\\n\\ndef solve(n,k,arr):\\n sol=[]\\n\\n l=0;u=k;\\n\\n\\n while l!=u:\\n sol.append(arr[l:min(len(arr),u)])\\n l=min(l+k,len(arr))\\n u=min(u+k,len(arr))\\n \\n tiwari=[]\\n for i in range(k):\\n titi=0\\n gao=0\\n for j in range(len(sol)):\\n if len(sol[j])>i:\\n if sol[j][i]==0:\\n", "gt": "titi+=1\\n else:\\n gao+=1\\n tiwari.append((titi,gao))\\n\\n minflip=(-1,-1)\\n ans=0\\n ctr=0\\n for i in tiwari:\\n if i[0]<i[1]:\\n ans+=i[0]\\n ctr+=(1*a1+a0*a1)*a1\\n if i[1]<minflip[0] or minflip[0]==-1:\\n minflip=(i[1],i[0])\\n else:\\n ans+=i[1]\\n if i[0]<minflip[0] or minflip[0]==-1:\\n minflip=(i[0],i[1])\\n #print(ans,ctr)\\n #print(tiwari)\\n #print(minflip)\\n if ctr%2==0:\\n ans+=minflip[0]\\n ans-=minflip[1]\\n\\n\\n stdout.write(str(ans)+\"\\n\")\\n\\nsolve(n,k,arr)"}
{"id": "783", "input": "test = int(input())\\nfor i in range(test):\\n flavor = int(input())\\n rate = input()\\n gaf = input()\\n gaf = gaf.split()\\n gaf = [int(x) for x in gaf]\\n rate = rate.split()\\n rate = [int(x) for x in rate]\\n rate.sort()\\n c =", "gt": "gaf[0] - gaf[1]\\n sum = rate[0]*c\\n t = True\\n if gaf[0] < gaf[1]:\\n t = False\\n j = 0\\n while(j<gaf[1] and t):\\n sum = sum + rate[j]\\n j = j + 1\\n if t :\\n print(sum)\\n else:\\n print(\"Not Possible\")"}
{"id": "784", "input": "# cook your dish here\\nepi=10**-2\\ndef vision(t):\\n a1=x0+(dx*t)-x1\\n a2=y0+(dy*t)-y1\\n a3=z0+(dz*t)-z1\\n b=4*((a1*d1)+(a2*d2)+(a3*d3))*((a1*d1)+(a2*d2)+(a3*d3))\\n a=4*((a1*a1)+(a2*a2)+(a3*a3))\\n value=(b-(a*c))\\n return value\\nxrange=range\\nfor _ in range(int(input())):\\n x1,y1,z1,x0,y0,z0,dx,dy,dz,cx,cy,cz,r=list(map(int,input().split()))\\n d1=x1-cx\\nd2=y1-cy\\n d3=z1-cz\\n c=(d1*d1)+(d2*d2)+(d3*d3)-(r*r)\\n low=0\\n high=10**9+1\\n while low<(high-10**-6):\\n mid=low+(high-low)*1.0/2;\\n", "gt": "value=vision(mid);"}
{"id": "785", "input": "import sys\\nimport os\\nimport random\\nimport math\\n#nonlocal defs\\nn, m, p = list(map(int, input().split()))\\narr = [dict() for _ in range(n)]\\nfor _ in range(p):\\n i,j = list(map(int,input().split()))\\n i -= 1\\n j -= 1\\n if j not in arr[i]:\\n arr[i][j] = j+1\\n else:\\n arr[i][j] += 1\\n\\ndef chefbm(arr,i):\\n for (e,f) in arr[i].items():\\n", "gt": "if e == m-1:\\n continue\\n if e+1 in arr[i]:\\n c = arr[i][e+1]\\n else:\\n c = e+1\\n if arr[i][e] > c:\\n return -1\\n y = arr[i][m-1] if m-1 in arr[i] else m-1\\n x = arr[i][0] if 0 in arr[i] else 0\\n return y-x\\n\\nfor i in range(n):\\n print(chefbm(arr,i))"}
{"id": "786", "input": "# cook your dish here\\na = int(input())\\nfor i in range(a):\\n b = int(input())\\n li = []\\n if b == 2:\\n print(2,1)\\n elif b == 3:\\n", "gt": "print(3,2)\\n elif b == 4:\\n print(4,2)\\n else:\\n for t in range(b+1):\\n if ((b*t)+1-(2**t))<0:\\n li.append(t-1)\\n break\\n for o in range(b+1):\\n if b<=2**(o):\\n li.append(o)\\n break\\n print(*li)\\n \\n"}
{"id": "787", "input": "from sys import stdin, stdout\\r\\n#from math import gcd as g\\r\\n#a,b = map(int, stdin.readline().split())\\r\\n#l1 = list(map(int, stdin.readline().split()))\\r\\nl = [1,6,7]\\r\\nc = 1\\r\\nfor", "gt": "x in range(3,100001):\\r\\n if x%2==1:\\r\\n a = l[c]*6\\r\\n l.append(a)\\r\\n else:\\r\\n l.append(a+1)\\r\\n c+=1\\r\\nn = int(stdin.readline())\\r\\nfor _ in range(n):\\r\\n s = int(stdin.readline())\\r\\n print(l[s-1])"}
{"id": "788", "input": "for _ in range(int(input())):\\n l=list(map(int,input().strip()))\\n for j in range(len(l)-1,-1,-1):\\n if l[j]==1:\\n l.pop()\\n else:\\n break\\n if l.count(1):\\n", "gt": "time,prev,z,c=0,0,0,0\\n for j in range(len(l)-1,-1,-1):\\n if l[j]==0:\\n z+=1\\n continue\\n if prev!=z:\\n prev=z\\n c+=1\\n time+=c+z\\n\\n print(time)\\n else:\\n print(0)\\n\\n"}
{"id": "789", "input": "n = int(input())\\nfor i in range(n):\\n s = input()\\n", "gt": "l = len(s)\\n n1 = int(s[0])\\n n2 = int(s[l-1])\\n print(n1+n2)\\n"}
{"id": "790", "input": "tc=int(input())\\nfor case in range(tc):\\n m,r=list(map(int,input().split()))\\n n=m**(r-1)\\n a=[i**n for i in range(1,2*n+1)]\\n", "gt": "tmp=2*n-1\\n for i in range(n):\\n for j in range(tmp-i):\\n a[j]=a[j+1]-a[j]\\n print((a[n-1]/m)%1000000007)\\n"}
{"id": "791", "input": "N,M,C = list(map(int, input().split()))\\ntree = [0] * (N+1)\\n\\ndef add(u,k):\\n while u < len(tree):\\n tree[u] += k \\n u += u&-u\\n\\ndef query(k):\\n ans = 0\\n while k:\\n ans += tree[k]\\n k -=", "gt": "k&-k\\n\\n return ans\\n\\ndef solve():\\n for _ in range(M):\\n op = input().split()\\n if op[0] == 'Q':\\n print(query(int(op[1])) + C)\\n else:\\n u,v,k = int(op[1]), int(op[2]), int(op[3]) \\n add(u, k)\\n add(v+1, -k)\\n\\ndef __starting_point():\\n solve()\\n\\n__starting_point()"}
{"id": "792", "input": "tc=int(input())\\nfor case in range(tc):\\n n,d=list(map(int,input().split()))\\n a=list(map(int,input().split()))\\n sm=sum(a)\\n f=True\\n if sm%n==0:\\n avg=sm/n\\n for i in range(d):\\n tmp_sm=0\\n tmp_n=0\\n for j in range(i,n,d):\\n tmp_sm=tmp_sm+a[j]\\n tmp_n+=1\\n if tmp_sm%tmp_n==0:\\n", "gt": "if avg!=tmp_sm/tmp_n:\\n f=False\\n break\\n else:\\n f=False\\n break\\n else:\\n f=False\\n if f:\\n ans=0\\n cur=0\\n for i in range(d):\\n for j in range(i,n,d):\\n cur=cur+avg-a[j]\\n ans=ans+abs(cur)\\n print(ans)\\n else:\\n print(-1)\\n"}
{"id": "793", "input": "# cook your dish here\\nt = int(input())\\n\\nfor _ in range(t):\\n\\n n,s = input().split()\\n\\n N = int(n) \\n r =", "gt": "N - len(s)\\n\\n count = 0\\n\\n if N>len(s):\\n\\n count = pow(26, r-1,(10**9+7))\\n count*= (26+25*len(s))\\n\\n count = count%(10**9 + 7)\\n print(count)\\n\\n"}
{"id": "794", "input": "# cook your dish here\\nimport math\\ntry:\\n n,d=map( int,input().split() )\\n a=list(map(int,input().split()))\\n a.sort()\\n", "gt": "z=abs(a[0]-d)\\n for j in range(n):\\n x=abs(a[j]-d)\\n z=math.gcd(x,z)\\n print(z) \\n \\n \\nexcept:\\n pass"}
{"id": "795", "input": "def multiple_input(): return map(int, input().split())\\n\\n\\ndef list_input(): return list(map(int, input().split()))\\n\\n\\nmod = int(1e9) + 7\\nfor _ in range(int(input())):\\n n, m = multiple_input()\\n a = list_input()\\n a.sort()\\n max_level = a[-1] + 1\\n levels = [0]", "gt": "* max_level\\n levels[0] = 1\\n for i in a:\\n levels[i] += 1\\n ans = 1\\n for i in range(1, max_level):\\n ans = (ans * (pow(levels[i - 1], levels[i], mod))) % mod\\n print(ans)"}
{"id": "796", "input": "t=int(input())\\nfor i in range(t):\\n n,k,l=map(int,input().split())\\n if k*l<n:\\n print(-1)\\n elif (k==1", "gt": "and n>1):\\n print(-1)\\n else:\\n for j in range(n):\\n print((j%k)+1,end=' ')\\n print()"}
{"id": "797", "input": "test=int(input())\\nfor i in range(test):\\n n=int(input())\\n a=list(map(int,input().split()))\\n b=[0]*(n+2)\\n b[n-1]=1\\n for i in range(n-2,-1,-1):\\n", "gt": "if(a[i]*a[i+1]<0):\\n b[i]=b[i+1]+1\\n else:\\n b[i]=1\\n for i in range(n):\\n print(b[i], end=' ')\\n print()"}
{"id": "798", "input": "# cook your dish here\\nd=[\"saturday\",\"sunday\",\"monday\",\"tuesday\",\"wednesday\",\"thursday\",\"friday\"]\\nt=int(input())\\nfor i in range(t):\\n s,e,l,r=map(str,input().split())\\n l,r=int(l),int(r)\\n v=(d.index(e)-d.index(s)+8)%7\\n c=r+1\\n for i", "gt": "in range(l,r+1):\\n if i%7==v:\\n c=i\\n break\\n if c>r:\\n print('impossible')\\n elif c+7<=r:\\n print('many')\\n else:\\n print(c)"}
{"id": "799", "input": "# cook your dish here\\nimport sys \\ndef dist(a,b):\\n return abs(a[0]-b[0])+abs(a[1]-b[1])\\nn, m = map(int, input().split())\\nmatrix=[]\\nid_matrix=[[0 for i in range(n)] for i in range(n)]\\nfor _ in range(n):\\n matrix.append(list(map(int, input().split())))\\ncharms=[]\\nfor _ in range(m):\\n x,y,lungh = map(int, input().split())\\n x-=1 \\n y-=1\\n charms.append([x,y,lungh])\\nif m<=10:\\n for i in range(n):\\n for j in range(n):\\n flag=0\\n for charm in charms:\\n if dist([i,j],charm[:2])<=charm[2]:\\n flag=1\\n break\\n if flag==0:\\n matrix[i][j]=-float('Inf')\\n for i in range(1,n):\\n matrix[0][i]+=matrix[0][i-1]\\n matrix[i][0]+=matrix[i-1][0]\\n for i", "gt": "in range(1,n):\\n for j in range(1,n):\\n matrix[i][j]+=max(matrix[i-1][j], matrix[i][j-1])\\nelse:\\n for charm in charms:\\n for i in range(-charm[2],charm[2]+1):\\n appo=charm[2]-abs(i)\\n for j in range(-appo, appo+1):\\n x=i+charm[0]\\n y=j+charm[1]\\n if x>=0 and x<n and y>=0 and y<n:\\n id_matrix[x][y]=1\\n if id_matrix[0][0]==0:\\n matrix[0][0]=-float('Inf')\\n for i in range(1,n):\\n if id_matrix[0][i]==0:\\n matrix[0][i]=-float('Inf')\\n else:\\n matrix[0][i]+=matrix[0][i-1]\\n if id_matrix[i][0]==0:\\n matrix[i][0]=-float('Inf')\\n else:\\n matrix[i][0]+=matrix[i-1][0]\\n for i in range(1,n):\\n for j in range(1,n):\\n if id_matrix[i][j]==0:\\n matrix[i][j]=-float('Inf')\\n else:\\n matrix[i][j]+=max(matrix[i-1][j], matrix[i][j-1])\\nif matrix[n-1][n-1]<-10**(10):\\n print('NO')\\nelse:\\n print('YES')\\n print(matrix[n-1][n-1])"}
{"id": "800", "input": "# cook your dish here\\nn = int(input())\\ncount = 0\\nfor _", "gt": "in range(n):\\n L = list(map(int, input().split()))\\n if (L.count(1)>=2):\\n count+=1\\n \\nprint(count)\\n"}
{"id": "801", "input": "<s> ", "gt": "n=int(input())\\na=list(map(int,input().split()))\\na.sort()\\nprint(a[-1],a[0])\\n"}
{"id": "802", "input": "from collections import Counter\\ntc=int(input())\\nfor k in range(tc):\\n n=int(input())\\n a=list(map(int, input().rstrip().split()))\\n b= list(map(int, input().rstrip().split()))\\n cc=sorted(a+b)\\n #print('cc = ',cc)\\n p=[]\\n q=[]\\n #print('len(cc) = ',len(cc))\\n #print('len = ',(2*n))\\n #rx=0\\n for i in range(0,(2*n),2):\\n p.append(cc[i])\\n #rx+=1\\n for i in range(1,(2*n)+1,2):\\n q.append(cc[i])\\n \\n if(p!=q):\\n print('-1')\\n continue\\n a.sort()\\n b.sort()\\n #print(p)\\n #print(q)\\n if(a==b):\\n print('0')\\n continue\\n xx = list((Counter(a) - Counter(p)).elements())\\n yy = list((Counter(b) - Counter(p)).elements())\\n #print('xx = ',xx)\\n #print('yy = ',yy)\\n iu=len(xx)\\n gb=sorted(xx+yy)\\n #print(iu)\\n uu=xx[0]\\n vv=yy[0]\\n", "gt": "#print('uu = ',uu)\\n #print('vv = ',vv)\\n zz=min(cc[0],uu,vv)\\n #print('zz = ',zz)\\n ans=0\\n for i in range(iu):\\n if(gb[i]<=(zz*2)):\\n ans+=gb[i]\\n else:\\n ans+=(zz*2)\\n print(ans)\\n \\n#a = [1, 1, 1, 2, 3, 3]\\n#b = [1, 1, 2, 2, 3, 4]\\n\\n'''c = []\\ni, j = 0, 0\\nwhile i < len(a) and j < len(b):\\n if a[i] == b[j]:\\n c.append(a[i])\\n i += 1\\n j += 1\\n elif a[i] > b[j]:\\n j += 1\\n else:\\n i += 1'''\\n#print(c)\\n"}
{"id": "803", "input": "import math\\ndef csb(n): \\n count = 0\\n while (n): \\n n &= (n-1) \\n count+= 1\\n \\n return count\\ndef f(ca,cb,i,cf,C,n,dp):\\n if ca<0 or cb<0:\\n return 0\\n if i==n:\\n if ca==0 and cb==0 and cf==0:\\n return 1\\n return 0\\n st=str(ca)+\" \"+str(cb)+\" \"+str(cf)+\" \"+str(i)\\n", "gt": "if dp.get(st)!=None:\\n return dp[st]\\n x=0 \\n if (C&(1<<i))>0:\\n x=1\\n if x==1:\\n #we will have odd num of set bits\\n if cf==1:\\n dp[st]=f(ca,cb,i+1,0,C,n,dp)+f(ca-1,cb-1,i+1,1,C,n,dp)\\n else:\\n dp[st]=f(ca-1,cb,i+1,0,C,n,dp)+f(ca,cb-1,i+1,0,C,n,dp)\\n else:\\n if cf==1:\\n dp[st]=f(ca-1,cb,i+1,1,C,n,dp)+f(ca,cb-1,i+1,1,C,n,dp)\\n else:\\n dp[st]=f(ca,cb,i+1,0,C,n,dp)+f(ca-1,cb-1,i+1,1,C,n,dp)\\n \\n return dp[st]\\ndef ip():\\n \\n for _ in range(int(input())):\\n a,b,c=list(map(int,input().split()))\\n n=int(math.log(c,2))+1\\n dp="}
{"id": "804", "input": "cards = ['A','2','3','4','5','6','7','8','9','T','J','Q','K']\\n\\ndef royal_flush(arr):\\n nonlocal ans, confirm\\n rf_set = 'TJQKA'\\n rf = 1\\n for char in arr:\\n if char[0] not in rf_set:\\n rf = 0\\n break\\n if rf :\\n if len(set(suit)) == 1:\\n ans = 'royal flush'\\n confirm = 1\\ndef straight_flush(arr): # and 'straight'\\n nonlocal ans,confirm\\n sf = 1\\n for i in range(1,5):\\n if arr[i] - arr[i-1] != 1:\\n sf = 0\\n break\\n if sf:\\n if len(set(suit)) == 1 :\\n ans = 'straight flush'\\n confirm = 1\\n else:\\n ans = 'straight'\\n confirm = 1\\ndef four(arr):\\n nonlocal ans, confirm\\n f = 0\\n for char in arr:\\n if arr.count(char) == 4:\\n f = 1\\n break\\n if f:\\n confirm = 1\\n ans = 'four of a kind'\\ndef full_house(arr): # and three\\n nonlocal ans, confirm\\n fh = 0\\n three = 0\\n two = 0\\n for char in arr:\\n if arr.count(char) == 3:\\n three = 1\\n elif arr.count(char) == 2:\\n two =", "gt": "1\\n if three and two:\\n confirm = 1\\n ans = 'full house'\\n elif three:\\n confirm = 1\\n ans = 'three of a kind'\\ndef two_pairs(arr):\\n nonlocal ans, confirm\\n temp = []\\n for char in arr:\\n if arr.count(char) == 2:\\n if char not in temp:\\n temp.append(char)\\n if len(temp) == 2:\\n confirm = 1\\n ans = 'two pairs'\\n elif len(temp) == 1:\\n confirm = 1\\n ans = 'pair'\\n\\ndef idex(char_x):\\n return cards.index(char_x)\\nfor _ in range(int(input())):\\n onhand = list(input().split())\\n cards_set = [[],[]]\\n suit = []\\n confirm = 0\\n ans = ''\\n for c in onhand:\\n num = idex(c[0])\\n cards_set[0].append(num)\\n if num == 0:\\n cards_set[1].append(13)\\n else:\\n cards_set[1].append(num)\\n suit.append(c[1])\\n royal_flush(onhand)\\n if not confirm:\\n cards_set[0] = sorted(cards_set[0])\\n cards_set[1] = sorted(cards_set[1])\\n straight_flush(cards_set[0])\\n straight_flush(cards_set[1])\\n if not confirm:\\n four(cards_set[0])\\n four(cards_set[1])\\n if not confirm:\\n full_house(cards_set[0])\\n full_house(cards_set[1])\\n if not confirm:\\n if len(set(suit)) == 1:\\n confirm = 1\\n ans = 'flush'\\n if not confirm:\\n two_pairs(cards_set[0])\\n two_pairs(cards_set[1])\\n print(ans if confirm else 'high card')"}
{"id": "805", "input": "import numpy as np\\nfor _ in range(int(input())):\\n n = int(input())-1;soldiers = [int(j) for j in input().split()]\\n force = int(input());attacks = np.zeros(2*n,dtype=int);attacks[:n] = np.array(soldiers);attacks[n:2*n] = attacks[:n];shield = [0 for _ in range(n)];pow_of_2 = 1\\n while n // pow_of_2 > 0: pow_of_2 *= 2\\n soldier_of_attack = (2 * n - pow_of_2) % n;pow_of_2 = attacks[soldier_of_attack] > force\\n \\n for i in range(n):\\n if attacks[i] > force: shield[i] = 10 ** 11\\n elif n == 1: shield[i] = force\\n elif pow_of_2:\\n shield[i] = force; num_of_survivors = n; soldiers = list(attacks[i:i+n]); starting_soldier = (n - i) % n\\n if (num_of_survivors - starting_soldier) % 2 == 1: shield[i]+= soldiers[-1]\\n soldiers = [soldiers[i] for i in range(num_of_survivors) if i < starting_soldier or (i - starting_soldier) % 2 == 0];num_of_survivors = starting_soldier + (num_of_survivors - starting_soldier - 1) // 2\\n if num_of_survivors >", "gt": "1:\\n pow_2 = 1\\n while True:\\n attacker = num_of_survivors - (num_of_survivors % pow_2);"}
{"id": "806", "input": "t=int(input())\\nwhile(t):\\n n=int(input())\\n l=[]\\n for i in range(n):\\n l.append(list(map(int,input().split())));\\n", "gt": "m=[]\\n for i in l:\\n m.append((i[1]//(i[0]+1))*i[2])\\n res=max(m)\\n print(res)\\n t=t-1"}
{"id": "807", "input": "# Why do we fall ? So we can learn to pick ourselves up.\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nt = int(input())\\r\\nfor _ in range(0,t):\\r\\n n = int(input())\\r\\n abc = [int(i) for i in input().split()]\\r\\n\\r\\n i = 0\\r\\n\\r\\n lst = [n]\\r\\n\\r\\n for _ in range(0,100):\\r\\n k = str(lst[-1]/abc[i%3]).split('.')\\r\\n if int(k[1][0]) > 0:\\r\\n lst.append(int(k[1][0]))\\r\\n else:\\r\\n lst.append(int(k[0][0]))\\r\\n i += 1\\r\\n pattern = []\\r\\n ind = 0\\r\\n while len(pattern) == 0:\\r\\n for i in range(ind, len(lst) - 1):\\r\\n check = lst[ind: i + 1] * 50\\r\\n check =", "gt": "check[:len(lst) - ind]\\r\\n if lst[ind:] == check:\\r\\n pattern = check\\r\\n break\\r\\n if len(pattern):\\r\\n break\\r\\n ind += 1\\r\\n final_pattern = []\\r\\n for i in range(0, len(pattern)):\\r\\n couldbe = pattern[:i + 1]\\r\\n check = pattern[:i + 1] * 100\\r\\n check = check[:len(pattern)]\\r\\n if check == pattern:\\r\\n final_pattern = couldbe\\r\\n break\\r\\n lp = len(final_pattern)\\r\\n q = int(input())\\r\\n for _ in range(0, q):\\r\\n qq = int(input())\\r\\n if qq < ind:\\r\\n print(lst[qq])\\r\\n else:\\r\\n qq -= ind\\r\\n kk = qq % lp\\r\\n print(final_pattern[kk])\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"\"\"\\r\\n1\\r\\n56\\r\\n3 5 7\\r\\n4\\r\\n0\\r\\n1\\r\\n2\\r\\n3\\r\\n\\r\\n\"\"\""}
{"id": "808", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n,q=map(int,input().split())\\n l=[int(i) for i in input().split()]\\n qry=[int(input()) for i in range(q)]\\n def cmp(sub1,sub2):\\n for i in range(len(sub1)):\\n if sub1[i]>sub2[i]:\\n", "gt": "return 1 \\n if sub1[i]<sub2[i]:\\n return 2 \\n return 1 \\n maxl=[]\\n for i in range(n):\\n for j in range(i,n):\\n maxl.append(max(l[i:j+1]))\\n maxl.sort(reverse=True)\\n for i in qry:\\n print(maxl[i-1])"}
{"id": "809", "input": "from fractions import gcd\\nfor testCases in range(eval(input())):\\n n = eval(input())\\n if n == 1:\\n print('1')\\n elif n == 2:\\n print('2')\\n elif n == 3:\\n print('6')\\n else:\\n c = n*(n-1)\\n k = n - 2\\n while True:\\n", "gt": "if gcd(k,n-1) == 1 and gcd(k,n) == 1:\\n break\\n k -= 1\\n d = (n-1)*(n - 2)\\n k1 = n - 3\\n while True:\\n if gcd(k1,n-1) == 1 and gcd(k1,n-2) == 1:\\n break\\n k1 -= 1\\n print(max(c*k,d*k1))"}
{"id": "810", "input": "#from itertools import combinations as c\\r\\nn=int(input());l=list(map(int,input().split()))\\r\\nl1=[]\\r\\nif(n<3):\\r\\n print(\"NO\")\\r\\nelse:\\r\\n l.sort()\\r\\n", "gt": "for i in range(n-2):\\r\\n if(l[i]+l[i+1]>l[i+2]):\\r\\n l1.append([l[i+2],l[i+1],l[i]])\\r\\nif(len(l1)!=0):\\r\\n print(\"YES\")\\r\\n print(*max(l1))\\r\\nelse:\\r\\n print(\"NO\")"}
{"id": "811", "input": "# cook your dish here\\nfrom bisect import bisect_left \\n \\ndef BinarySearch(a, x): \\n i = bisect_left(a, x) \\n if i != len(a) and a[i] == x: \\n return i \\n else: \\n return -1\\n\\nfor _t in range(int(input())):\\n _n, q = list(map(int, input().split()))\\n mounts", "gt": "= list(map(int, input().split()))\\n for _q in range(q):\\n query = list(map(int, input().split()))\\n if query[0] == 0:\\n mounts[query[1]] = query[2]\\n else:\\n curr = query[1]\\n prev = set(mounts[:curr+1])\\n for m in mounts[curr+1:]:\\n if m > mounts[curr] and m not in prev:\\n print(m)\\n break\\n else:\\n print(-1)\\n \\n"}
{"id": "812", "input": "try:\\n n, k=map(int, input().split())\\n arr=list(map(int, input().split()))\\n forward = [0]*(n+1)\\n backward= [0]*(n+1)\\n backward[0]=arr[0]\\n backward[1]=arr[0]+arr[1]\\n for i in range(k, n):\\n forward[i]=arr[i]", "gt": "+max(forward[i-1],forward[i-2])\\n\\n for i in range(2, n):\\n backward[i]=arr[i]+max(backward[i-1],backward[i-2])\\n \\n ans=-float(\"Inf\")\\n for i in range(k-1, n):\\n ans=max(ans, forward[i]+backward[i]-arr[i])\\n print(ans)\\nexcept Exception:\\n pass"}
{"id": "813", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n = int(input())\\n a = list(map(int, input().split()))\\n curr", "gt": "= 0\\n ans = 0\\n for x in a:\\n curr += x\\n ans += abs(curr)\\n print(ans)"}
{"id": "814", "input": "#dt = {} for i in x: dt[i] = dt.get(i,0)+1\\r\\nimport sys;input = sys.stdin.readline\\r\\ninp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]\\r\\n\\r\\nn,k = ip()\\r\\nx = ip()\\r\\nx.sort()\\r\\nif k == 1:\\r\\n a = x[n//2]\\r\\n", "gt": "b = x[n//2-1]\\r\\nelse:\\r\\n s = sum(x)\\r\\n a = s//n\\r\\n b = a + 1\\r\\nsa = sum([abs((a-i)**k) for i in x])\\r\\nsb = sum([abs((b-i)**k) for i in x])\\r\\nif sa < sb:\\r\\n print(a)\\r\\nelse:\\r\\n print(b)"}
{"id": "815", "input": "for _ in range(int(input())):\\n n=int(input())\\n\\n\\n def maxConsequtiveOnes(lst):\\n _max = 0\\n _ones = [0]\\n for i in lst:\\n if i == 0:\\n _max += 1\\n if", "gt": "i == 1:\\n _max = 0\\n _ones.append(_max)\\n return max(_ones)\\n\\n\\n a = list(map(int, input().split()))\\n b = maxConsequtiveOnes(a)\\n if (b % 2 == 0):\\n print(\"No\")\\n else:\\n print(\"Yes\")\\n\\n"}
{"id": "816", "input": "# cook your dish here\\r\\nfrom collections import deque\\r\\nprimes = {2,3,5,7,11,13,17}\\r\\nedges = [(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\\r\\nx = [1,2,3,4,5,6,7,8,9]\\r\\navail = {tuple(x):0}\\r\\nq = deque([x])\\r\\nwhile q:\\r\\n curr = q.popleft();\\r\\n for e in edges:\\r\\n if curr[e[0]]+curr[e[1]] in primes:\\r\\n nxt = curr[0:]\\r\\n nxt[e[0]],nxt[e[1]] = nxt[e[1]], nxt[e[0]] \\r\\n nxtt = tuple(nxt)\\r\\n if", "gt": "nxtt not in avail:\\r\\n avail[nxtt] = avail[tuple(curr)]+1\\r\\n q.append(nxt)\\r\\nt = int(input())\\r\\nwhile t:\\r\\n inp = input()\\r\\n grid = []\\r\\n for i in range(3):\\r\\n inp = input()\\r\\n for j in inp.strip().split(\" \"):\\r\\n grid.append(int(j))\\r\\n gridt = tuple(grid)\\r\\n if gridt in avail: print(avail[gridt])\\r\\n else: print(-1);\\r\\n t-= 1"}
{"id": "817", "input": "def bookList():\\r\\n numBooks=int(input())\\r\\n bookNum=[int(x) for x in input().split()]\\r\\n", "gt": "takenBooks=int(input())\\r\\n for i in range(takenBooks):\\r\\n takenBookPos=(int(input()))\\r\\n a=bookNum[takenBookPos-1]\\r\\n print(a)\\r\\n bookNum.remove(a)\\r\\n\\r\\nbookList()\\r\\n"}
{"id": "818", "input": "for _ in range(int(input())):\\r\\n n=int(input())\\r\\n l=list(map(int,input().split()))\\r\\n", "gt": "su=l[0]\\r\\n for i in range(1,n):\\r\\n su^=l[i]\\r\\n print(su)"}
{"id": "819", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n=int(input())\\n a=[int(x) for x in input().split()]\\n sum=0\\n for i in range(n):\\n if", "gt": "a[i]%2==0:\\n sum+=1\\n a[i]=sum \\n q=int(input())\\n while q:\\n l,r=map(int,input().split())\\n if l!=1:\\n c=a[r-1]-a[l-2]\\n else:\\n c=a[r-1] \\n if c==0:\\n print(\"ODD\")\\n else:\\n print(\"EVEN\")\\n q-=1"}
{"id": "820", "input": "T=int(input())\\nwhile T:\\n x,y=map(int,input().split())\\n while(y): \\n x, y = y,", "gt": "x % y\\n if x==1:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n T-=1"}
{"id": "821", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n,m = list(map(int,input().split()))\\n colors = [0]*41; cost = [0]*41\\n color = 0\\n for i in range(n):\\n cc,pp = list(map(int,input().split()))\\n colors[cc] += 1\\n cost[cc] += pp\\n for i in colors:\\n if i>0: color += 1\\n dp2 = [[0]*41 for", "gt": "i in range(color+1)]\\n dp2[0] = [1]*41\\n for i in range(1,color+1):\\n for j in range(1,41):\\n dp2[i][j] = dp2[i][j-1]+dp2[i-1][j-1]*(2**colors[j]-1)\\n dp1 = [[0]*41 for i in range(color+1)]\\n for i in range(1,color+1):\\n for j in range(1,41):\\n dp1[i][j] = dp1[i][j-1]+dp1[i-1][j-1]*(2**colors[j]-1)+dp2[i-1][j-1]*cost[j]*(2**(colors[j]-1))\\n num=den=0\\n for i in range(m,color+1):\\n num += dp1[i][40]\\n den += dp2[i][40]\\n print(num/den)"}
{"id": "822", "input": "for _ in range(int(input())):\\n n = int(input())\\n ls = []\\n rs = []\\n lrs = []\\n\\n for i in range(n):\\n l, r = map(int, input().split())\\n ls.append(l)\\n rs.append(r)\\n lrs.append((l, r, i))\\n\\n lrs.sort()\\n\\n c = 0\\n maxi = -1\\n\\n res", "gt": "= [-1] * n\\n for l, r, i in lrs:\\n if ls[i] > maxi:\\n maxi = rs[i]\\n res[i] = c\\n\\n elif rs[i] <= maxi:\\n res[i] = 1^c\\n\\n else:\\n maxi = rs[i]\\n c ^= 1\\n res[i] = c\\n\\n print(*res, sep='')"}
{"id": "823", "input": "def main():\\n while True:\\n [n, m] = [int(i) for i in input().split()]\\n if n == m and n == 0:\\n break\\n cache = {}\\n for i in range(n):\\n dna = input().rstrip('\\n')\\n if dna in cache:\\n cache[dna]", "gt": "= 1 + cache[dna]\\n else:\\n cache[dna] = 1\\n c = [0 for i in range(n + 1)]\\n for dna in cache:\\n c[cache[dna]] = 1 + c[cache[dna]]\\n for i in range(1, n + 1):\\n print(c[i])\\n \\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "824", "input": "# cook your dish here\\n\\n# cook your dish here\\n\\n \\n\\nt = int(input())\\nwhile t:\\n t-=1\\n c=0\\n ar=[int(i) for i in input().strip().split()]\\n for", "gt": "i in range(1,16):\\n b=bin(i)[2:].zfill(4)\\n s=0\\n for i in range(4):\\n if b[i]=='1':\\n s+=ar[i]\\n \\n if(s==0):\\n c=1\\n break\\n \\n print(\"Yes\" if c==1 else \"No\")\\n"}
{"id": "825", "input": "from sys import stdin,stdout\\r\\ninput=stdin.readline\\r\\nn=int(input())\\r\\na=[[] for i in range(n)]\\r\\nfor i in range(n-1):\\r\\n u,v=map(int,input().split())\\r\\n a[u-1].append(v-1)\\r\\n a[v-1].append(u-1)\\r\\nb=[0]*n\\r\\nvis=[0]*n\\r\\nst=[(0,0)]\\r\\nvis[0]=1\\r\\npa=[0]*n\\r\\nwhile st:\\r\\n x,y=st.pop()\\r\\n b[x]=y\\r\\n for i in a[x]:\\r\\n if vis[i]==0:\\r\\n pa[i]=x\\r\\n vis[i]=1\\r\\n if x==0:\\r\\n st.append((i,y+len(a[x])-1))\\r\\n else:\\r\\n st.append((i,y+len(a[x])-2))\\r\\nc=[]\\r\\nfor i in range(1,n):\\r\\n if len(a[i])==1:\\r\\n c.append((b[i],i))\\r\\nc.sort()\\r\\nans=0\\r\\nwhile c:\\r\\n x,y=c.pop()\\r\\n m=y\\r\\n p=0\\r\\n while y!=0 and pa[y]!=-1:\\r\\n y=pa[y]\\r\\n if", "gt": "pa[y]==-1:\\r\\n break\\r\\n if y!=0:\\r\\n p+=(len(a[y])-2)\\r\\n else:\\r\\n p+=(len(a[y])-1)\\r\\n if p>=1:\\r\\n p=0\\r\\n while m!=0 and pa[m]!=-1:\\r\\n x=m\\r\\n if pa[m]==-1:\\r\\n break\\r\\n m=pa[m]\\r\\n pa[x]=-1\\r\\n if m!=0:\\r\\n p+=(len(a[m])-2)\\r\\n else:\\r\\n p+=(len(a[m])-1)\\r\\n if y==0:\\r\\n pa[0]=-1\\r\\nfor i in range(n):\\r\\n if pa[i]!=-1:\\r\\n st=[i]\\r\\n pa[i]=-1\\r\\n while st:\\r\\n x=st.pop()\\r\\n for j in a[x]:\\r\\n if pa[j]!=-1:\\r\\n pa[j]=-1\\r\\n st.append(j)\\r\\n ans+=1\\r\\nprint(ans)"}
{"id": "826", "input": "testcase = int(input())\\nfor case in", "gt": "range(testcase):\\n n = int(input())\\n print(2**(n-2)+1)\\n print('\\n')"}
{"id": "827", "input": "# This is not my code, it's Snehasish Karmakar's. Refer to http://www.codechef .com/viewsolution/7153774\\n# for original version.\\n# Submitting it to try and work out if it can be sped up.\\n\\ndef compute_nCr(n,r) :\\n C[0][0]=1\\n for i in range(1,n+1) :\\n# print \"i\",i\\n C[i][0]=1\\n for j in range(1,min(i,r)+1) :\\n if i!=j :\\n C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD\\n", "gt": "else :\\n C[i][j]=1\\n \\n \\ndef solve(n,m) :\\n store=[C[m+i-1][i] for i in range(m+1)]\\n \\n for i in range(1,n+1) :\\n s=1\\n for j in range(1,m+1) :\\n s=(s+store[j])%MOD\\n store[j]=(s*C[m+j-1][j])%MOD\\n # print \"a[%d][%d]=%d\"%(i,j,s)\\n \\n return s \\n \\nMOD=1000000000\\nLIMIT=2000\\n \\nC=[[0] * (LIMIT + 1) for _ in range(2*LIMIT+1)]\\ncompute_nCr(2*LIMIT,LIMIT)\\nt=int(input())\\n \\nwhile t :\\n n,m=list(map(int,input().split()))\\n print(solve(n,m))\\n t-=1"}
{"id": "828", "input": "try:\\r\\n t=int(input())\\r\\n for i in range(t):\\r\\n n,k=map(int,input().split())\\r\\n s=input()\\r\\n l=[-1]*len(s)\\r\\n numb=s.count('b')\\r\\n x=numb\\r\\n for j in range(len(s)):\\r\\n", "gt": "if(s[j]=='a'):\\r\\n l[j]=numb\\r\\n if(s[j]=='b'):\\r\\n numb=numb-1\\r\\n #print(l)\\r\\n count1=0\\r\\n for j in range(len(l)):\\r\\n if(l[j]>0):\\r\\n count1=count1+(k*(2*l[j]+(k-1)*x))//2\\r\\n elif(l[j]==0):\\r\\n count1=count1+(k*(2*0+(k-1)*x))//2\\r\\n print(count1)\\r\\nexcept:\\r\\n pass\\r\\n"}
{"id": "829", "input": "for i in range(int(input())):\\n a=int(input())\\n b=input().split()\\n", "gt": "if '0' in b:\\n print(100*(a-b.index('0'))+b.count('0')*1000)\\n else:\\n print(0)\\n"}
{"id": "830", "input": "# cook your dish here\\n# cook your dish here\\nfrom itertools import combinations\\nn = int(input())\\nt", "gt": "= list(combinations(list(map(int, input().split())), 2))\\nar = 0\\nfor i in t:\\n ar += abs(i[0] - i[1])\\nprint(ar)"}
{"id": "831", "input": "for _ in range(int(input())):\\n n=int(input())\\n a=input()\\n b=input()\\n l=[]\\n flag=0\\n for i in range(n):\\n if b[i]!=a[i]:\\n if b[i] in a and b[i]<a[i]:\\n l.append(b[i])\\n else:\\n flag=1\\n break\\n if flag==1:\\n print(-1)\\n else:\\n if l==[]:\\n print(0)\\n else:\\n l", "gt": "= sorted(list(set(l)), reverse = True)\\n print(len(l))\\n for i in range(len(l)):\\n q=[]\\n r=[]\\n for j in range(len(a)):\\n if l[i]==b[j]:\\n q.append(j)\\n r.append(a[j])\\n if l[i] not in r:\\n for k in range(len(a)):\\n if a[k]==l[i]:\\n q.append(k)\\n print(len(q),*q)\\n \\n"}
{"id": "832", "input": "for _ in range(int(input())):\\n n,m=input().split()\\n n,m=int(n),int(m)\\n x=y=c=0\\n l=list(map(int,input().split()))\\n for i in range(n):\\n for j", "gt": "in range(i,n):\\n x=x+l[j]\\n if (x%m)>y:\\n y=x%m\\n c=1\\n elif y==(x%m):\\n c+=1\\n x = 0\\n print(y,c)\\n\\n"}
{"id": "833", "input": "def fact(n):\\n if n<2:\\n return 1\\n return n * fact(n-1)\\n \\ndef ncr(n, r):\\n return fact(n)// (fact(r)*fact(n-r))\\n \\nt=int(input())\\n\\nfor _ in", "gt": "range(t):\\n n, k = list(map(int, input().split()))\\n a = list(map(int, input().split()))\\n a.sort()\\n count_z = a.count(a[k-1])\\n count_z_seq = a[:k].count(a[k-1])\\n \\n print(ncr(count_z, count_z_seq))\\n"}
{"id": "834", "input": "import sys\\n\\ndef main():\\n s=sys.stdin.readline\\n n, m = list(map(int, s().split()))\\n nums={}\\n for i in range(1, n+1):\\n nums[i]=list(map(int, s().split()))\\n cases=int(s())\\n for case in range(cases):\\n", "gt": "px, py, qx, qy = list(map(int, s().split()))\\n ans=[]\\n for i in range(px, qx+1):\\n for j in range(py-1, qy):\\n ans.append(nums[i][j])\\n print(sum(ans))\\n\\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "835", "input": "a=int(input())\\r\\nfor _ in range(a):\\r\\n c,d=list(map(int,input().split()))\\r\\n crr=[[[0,0] for i in range(c+1)] for j in range(c+1)]\\r\\n trr=[]\\r\\n for i in range(c):\\r\\n kk=list(input().split())\\r\\n trr.append(kk)\\r\\n for i in range(1,c+1):\\r\\n for j in", "gt": "range(1,c+1):\\r\\n if(trr[i-1][j-1]=='a'):\\r\\n crr[i][j][0]=max(crr[i-1][j][0],crr[i][j-1][0])+1\\r\\n if(j==1):\\r\\n crr[i][j][1]=crr[i-1][j][1]+1\\r\\n elif(i==1):\\r\\n crr[i][j][1]=crr[i][j-1][1]+1\\r\\n elif(crr[i-1][j][0]>crr[i][j-1][0]):\\r\\n crr[i][j][1]=crr[i-1][j][1]+1\\r\\n else:\\r\\n crr[i][j][1]=crr[i][j-1][1]+1\\r\\n else:\\r\\n crr[i][j][0]=max(crr[i-1][j][0],crr[i][j-1][0])\\r\\n if(j==1):\\r\\n crr[i][j][1]=crr[i-1][j][1]+1\\r\\n elif(i==1):\\r\\n crr[i][j][1]=crr[i][j-1][1]+1\\r\\n elif(crr[i-1][j][0]>crr[i][j-1][0]):\\r\\n crr[i][j][1]=crr[i-1][j][1]+1\\r\\n else:\\r\\n crr[i][j][1]=crr[i][j-1][1]+1\\r\\n \\r\\n for i in range(d):\\r\\n m,n=list(map(int,input().split()))\\r\\n print(crr[m][n][1]-crr[m][n][0])\\r\\n \\r\\n"}
{"id": "836", "input": "t = eval(input())\\nfor _ in range(t):\\n n, m = list(map(int, input().split()))\\n if n*m == 2:\\n", "gt": "print('Yes')\\n elif (n*m)%2 == 0 and m != 1 and n != 1:\\n print('Yes')\\n else:\\n print('No')"}
{"id": "837", "input": "def bestMovie():\\n tests=int(input())\\n for t in range(tests):\\n n = int(input())\\n L = list(map(int, input().split()))\\n R = list(map(int, input().split()))\\n maxIndex = -1\\n maxValue = 0\\n for i", "gt": "in range(n):\\n prod = L[i]*R[i]\\n if maxValue < prod:\\n maxValue = prod\\n maxIndex = i\\n elif maxValue == prod:\\n if R[maxIndex] < R[i]:\\n maxIndex = i\\n print(maxIndex+1)\\n\\nbestMovie()"}
{"id": "838", "input": "for t in range(eval(input())):\\n", "gt": "n=eval(input())\\n n-=n%10\\n n/=10\\n print(n*(n+1)/2*10)"}
{"id": "839", "input": "T = int(input())\\nfor i in range(T):\\n x = int(input())\\n l= [int(x)", "gt": "for x in input().split()]\\n t=[]\\n for i in range(len(l)):\\n t.append(l[i]+i) \\n print(max(t))"}
{"id": "840", "input": "def isSubsetSum(arr, n, sum): \\n subset = [ [False for j in range(sum + 1)] for i in range(3) ] \\n for i in range(n + 1): \\n for j in range(sum + 1): \\n if (j == 0):subset[i % 2][j] = True\\n elif (i == 0):subset[i % 2][j] = False\\n elif (arr[i - 1]", "gt": "<= j):subset[i % 2][j] = subset[(i + 1) % 2][j - arr[i - 1]] or subset[(i + 1)% 2][j] \\n else:subset[i % 2][j] = subset[(i + 1) % 2][j] \\n return subset[n % 2][sum] \\nfor _ in range(int(input())):\\n k,n,a = int(input()),int(input()),list(map(int,input().split()))\\n if sum(a) < k or k < min(a):print(0);continue\\n print(1) if isSubsetSum(a, n, k) else print(0)"}
{"id": "841", "input": "def func(num):\\r\\n for i in range(num):\\r\\n if i < num//2 + 1:\\r\\n print(' '*i,", "gt": "end='')\\r\\n print('*')\\r\\n else:\\r\\n print(' '*(num-i-1), end='')\\r\\n print('*')\\r\\n\\r\\n\\r\\n\\r\\nfor _ in range(int(input())):\\r\\n num = int(input())\\r\\n func(num)\\r\\n"}
{"id": "842", "input": "M = 10 ** 9 + 7\\nfor _ in range(int(input())):\\n s,p,m,r = list(map(int, input())),0,1,0\\n for d in reversed(s):\\n p += d * m\\n m = m * 10", "gt": "% M\\n for d in s:\\n r = (r * m + p) % M\\n p = (p * 10 - (m - 1) * d) % M\\n print(r)"}
{"id": "843", "input": "t=int(input())\\r\\nfor _ in range(t):\\r\\n n=int(input())\\r\\n b=1\\r\\n if n%2:\\r\\n c=n-2\\r\\n for j in range(n//2):\\r\\n print(\" \"*j+str(b) +\" \"*c+ str(b))\\r\\n b+=1\\r\\n c-=2\\r\\n print(\" \"*(n//2)+str(b)+\" \"*(n//2))\\r\\n b+=1\\r\\n c=1\\r\\n for j in range(n//2):\\r\\n print(\" \"*(n//2-j-1)+str(b)+\" \"*c+", "gt": "str(b))\\r\\n b+=1\\r\\n c+=2\\r\\n else:\\r\\n c=n-2\\r\\n for j in range(n//2):\\r\\n print(\" \"*j+str(b)+\" \"*c+str(b))\\r\\n b+=1\\r\\n c-=2\\r\\n c=0\\r\\n for j in range(n//2):\\r\\n print(\" \"*(n//2-j-1)+str(b) +\" \"*c+ str(b))\\r\\n b+=1\\r\\n c+=2\\r\\n \\r\\n \\r\\n \\r\\n \\r\\n \\r\\n \\r\\n"}
{"id": "844", "input": "t=int(input())\\nfor _ in range(t):\\n n=int(input())\\n \\n grid=[]\\n for _ in range(n):\\n temp=[]\\n temp=list(map(int,input().strip().split()))\\n temp.sort()\\n grid.append(temp)\\n \\n \\n curr=max(grid[n-1])\\n total=curr\\n for i in range(n-2,0-1,-1):\\n", "gt": "flag=0\\n for j in range(n-1,0-1,-1):\\n if grid[i][j]<curr:\\n flag=1\\n curr=grid[i][j]\\n total+=curr\\n break\\n \\n if flag==0:\\n total=-1\\n break\\n \\n print(total)\\n \\n \\n \\n \\n \\n \\n"}
{"id": "845", "input": "def getInput():\\n N_k = input().split()\\n N =int(N_k[0])\\n k =int(N_k[1])\\n list = []\\n output = []\\n count = 0\\n for i in range(0,k):\\n val = input()\\n if(val!=\"CLOSEALL\"):\\n val=val.split()\\n val = int", "gt": "(val[1])\\n if val not in list:\\n count= count +1\\n list.append(val)\\n else:\\n list.remove(val)\\n count= count -1\\n else:\\n count =0\\n while len(list) > 0: \\n list.pop()\\n output.append(count)\\n for each in output:\\n print(each)\\ngetInput()"}
{"id": "846", "input": "def __gcd(a, b): \\n \\n # Everything divides 0 \\n if (a == 0 or b == 0): \\n return 0; \\n \\n # base case \\n if (a == b): \\n return a; \\n \\n # a is greater \\n if (a > b): \\n return __gcd(a - b, b); \\n return __gcd(a,b - a); \\n \\n# Function to find \\n# number of squares \\ndef NumberOfSquares(x, y): \\n \\n #", "gt": "Here in built PHP \\n # gcd function is used \\n s = __gcd(x, y);"}
{"id": "847", "input": "K,A,B = map(int,input().split())\\r\\n \\r\\nif A + 2 > B:\\r\\n print(K + 1)\\r\\n return\\r\\n \\r\\nstart =", "gt": "A - 1\\r\\nK -= start\\r\\nans = K//2 * (B-A) + K%2 + start + 1\\r\\nprint(ans)"}
{"id": "848", "input": "a= [0, 0, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 0, 5, 2, 2, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 2, 7, 4, 0, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 2, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1,", "gt": "0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4, 8, 1, 1, 2]\\n \\nt = int(input())\\n \\nfor i in range(t):\\n n = int(input())\\n if a[n]>0:\\n print(\"Arjuna\")\\n else:\\n print(\"Bhima\")"}
{"id": "849", "input": "# cook your dish here\\r\\n#Moony and ICPC team\\r\\nT = int(input())\\r\\n\\r\\nfor i in range(T):\\r\\n N,data = int(input()),list(map(int,input().split()))\\r\\n if(N==3):\\r\\n print(sum(data))\\r\\n else:\\r\\n best = data[0]+data[1]+data[2]\\r\\n overall =", "gt": "best\\r\\n k=len(data)\\r\\n for i in range(1,k-2):\\r\\n overall=overall - data[i-1] + data[i+2]\\r\\n if(overall>best):\\r\\n best = overall\\r\\n j=max(data[1],data[-2])\\r\\n l= data[-1]+data[0]+j\\r\\n if(best < l):\\r\\n best = l\\r\\n print(best)"}
{"id": "850", "input": "n=eval(input())\\na=list(map(int,input().split()))\\nc=m=0\\nmaxi=max(a)\\nfor i in range(n):\\n if", "gt": "a[i]==maxi:\\n c+=1\\n m=max(c,m)\\n else:\\n c=0\\nprint(m)"}
{"id": "851", "input": "from math import gcd\\r\\n\\r\\n__author__ = 'Prateek'\\r\\n\\r\\n\\r\\ndef test():\\r\\n n = int(input())\\r\\n a = list(map(int, input().split()))\\r\\n a = list(set(a))\\r\\n n = len(a)\\r\\n if len(a) == 1:\\r\\n print(2 * a[0])\\r\\n return\\r\\n g1 = [0 for i in range(n)]\\r\\n g2 = [0 for i in range(n)]\\r\\n g1[0] = a[0]\\r\\n g2[n - 1] = a[n - 1]\\r\\n for i in range(1, n):\\r\\n g1[i] = gcd(g1[i - 1], a[i])\\r\\n for i in range(n", "gt": "- 2, -1, -1):\\r\\n g2[i] = gcd(g2[i + 1], a[i])\\r\\n ans = 0\\r\\n for i in range(n):\\r\\n if i == 0:\\r\\n ans = max(ans, g2[i + 1] + a[i])\\r\\n elif i == n - 1:\\r\\n ans = max(ans, g1[i - 1] + a[i])\\r\\n else:\\r\\n ans = max(ans, gcd(g1[i - 1], g2[i + 1]) + a[i])\\r\\n print(ans)\\r\\n\\r\\n\\r\\nif __author__ == 'Prateek':\\r\\n t = int(input())\\r\\n for _ in range(t):\\r\\n test()\\r\\n"}
{"id": "852", "input": "for _ in", "gt": "range(int(input())):\\n n,k=map(int,input().split())\\n print(((2*n*(k-1))+2)/k)"}
{"id": "853", "input": "t=int(input())\\nfor t in range(t):\\n n=int(input())\\n for i in range(0,n):\\n for j in range(0,n):\\n if", "gt": "i%2==0:\\n if j%2==0:\\n print(0,end=\"\")\\n else:\\n print(1,end=\"\")\\n else:\\n if j%2==0:\\n print(1,end=\"\")\\n else:\\n print(0,end=\"\")\\n print()\\n \\n"}
{"id": "854", "input": "# cook your dish here\\nt=int(input())\\nfor i in range(t):\\n n=int(input())\\n if n<101:\\n l1=[]\\n l2=[]\\n d=dict()\\n for i in range(1,2*n+1):\\n if i%2==0:\\n l1.append(int(input()))\\n else:\\n l2.append(str(input()))\\n", "gt": "r1=[]\\n for i in l1:\\n r1.append(i)\\n l1.sort()\\n ind=[]\\n for i in l1:\\n a=r1.index(i)\\n ind.append(a)\\n for i in ind:\\n print(l2[i])\\n else:\\n print(0)\\n break\\n \\n"}
{"id": "855", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n = int(input())\\n arr = list(map(int,input().split()))\\n l = []\\n for i in", "gt": "range(0, len(arr)): \\n for j in range(i+1, len(arr)): \\n if(arr[i] == arr[j]): \\n l.append(arr[j])\\n if (len(l) ==0):\\n print(\"prekrasnyy\")\\n else:\\n print(\"ne krasivo\")"}
{"id": "856", "input": "oo = int(input())\\r\\nfor i in", "gt": "range(oo):\\r\\n val = input()\\r\\n print(val[::-1])"}
{"id": "857", "input": "t = int(input())\\n\\nfor _ in range(t):\\n n = int(input())\\n \\n a = {}\\n \\n for i in range(n):\\n l = input()\\n \\n if l not in a:\\n a[l] = 1\\n else:\\n a[l] += 1\\n \\n done = []\\n ans = 0\\n \\n for i in a:\\n if a[i] != 0:\\n temp = [x for x in i.split()]\\n v =", "gt": "temp[0]\\n \\n v0 = v + \" 0\"\\n v1 = v + \" 1\"\\n \\n if(v0 in a and v1 in a):\\n if a[v0] > a[v1]:\\n ans += a[v0]\\n else:\\n ans += a[v1]\\n \\n a[v0] = a[v1] = 0\\n elif(v0 in a):\\n ans += a[v0]\\n a[v0] = 0\\n elif(v1 in a):\\n ans += a[v1]\\n a[v1] = 0\\n \\n print(ans)"}
{"id": "858", "input": "testcases = int(input())\\n\\nfor i in range(testcases):\\n n = int(input())\\n my = list(map(int,input().split()))\\n opp = list(map(int,input().split()))\\n \\n my.sort(reverse = True)\\n opp.sort(reverse =", "gt": "True)\\n \\n j = 0\\n k = 0\\n while(k < n):\\n if(my[j] > opp[k]):\\n j += 1\\n k += 1\\n\\n print(j)"}
{"id": "859", "input": "# cook your dish here\\nt=int(input())\\nwhile t>0:\\n n=int(input())\\n if n==1:\\n print(1)\\n", "gt": "else:\\n c,num=1,2\\n while num<n:\\n num*=2\\n if num==n:\\n print(num)\\n else:\\n print(num//2)\\n t-=1"}
{"id": "860", "input": "import math\\r\\nimport os\\r\\nimport random\\r\\nimport re\\r\\nimport sys\\r\\n\\r\\n\\r\\nr = 100000\\r\\nprev = 1\\r\\ns = set()\\r\\nfor i in range(1, r+1):\\r\\n now = i ^ prev\\r\\n s.add(now)\\r\\n prev = now\\r\\ns = list(s)\\r\\nt = int(input())\\r\\nwhile t > 0:\\r\\n t -= 1\\r\\n n, k", "gt": "= list(map(int, input().split()))\\r\\n\\r\\n if n > 3:\\r\\n if n % 2 == 0:\\r\\n size = (n//2) + 2\\r\\n else:\\r\\n size = ((n-1)//2) + 2\\r\\n else:\\r\\n size = n\\r\\n if size - k >= 0:\\r\\n print(s[size-k])\\r\\n else:\\r\\n print(-1)\\r\\n"}
{"id": "861", "input": "# cook your dish here\\nimport math\\nT = int(input())\\nfor _ in range(T):\\n N, H = map(int, input().split())\\n A = list(map(int, input().split()))\\n low, high = 1, max(A)\\n while low != high:\\n time = 0\\n", "gt": "mid = (low + high) // 2\\n for i in range(N):\\n time += math.ceil(A[i] / mid)\\n \\n if time <= H :\\n high = mid\\n else:\\n low = mid + 1\\n print(high)"}
{"id": "862", "input": "#!/usr/bin/env python\\n\\nF = [1,1]\\ndef fibo():\\n for i in range(500):\\n F.append(F[-2] + F[-1])\\n\\ndef main():\\n fibo()\\n #print len(str(F[-1]))\\n #print len(str(10**100))\\n while True:\\n try:\\n A, B = list(map(int,", "gt": "input().strip().split()[:2]))\\n if A == 0 and B == 0: break\\n print(len([x for x in F if x >= A and x <= B]))\\n except:\\n break\\n\\nmain()\\n\\n"}
{"id": "863", "input": "cases = int(input())\\n\\nfor case in range(cases):\\n N, M, K = [int(i) for i in input().split()]\\n A = [int(i) for i", "gt": "in input().split()]\\n jad = 0\\n P = M*K\\n\\n for milk in A:\\n if(milk>P):\\n jad += milk-P\\n else:\\n jad += milk%K\\n\\n print(jad%1000000007)\\n"}
{"id": "864", "input": "n=int(input())\\r\\nl=[]\\r\\ndp=[]\\r\\nd={}\\r\\nfor i in range(n):\\r\\n l.append(int(input()))\\r\\n d[i]=[]\\r\\n dp.append([0,0])\\r\\n\\r\\nfor i in range(n-1):\\r\\n a,b=list(map(int,input().split()))\\r\\n d[a-1].append(b-1)\\r\\n d[b-1].append(a-1)\\r\\n#print(l)\\r\\n#print(d)\\r\\n\\r\\ndef dfs(ch,pa,visited):\\r\\n dp[ch][1]=l[ch]\\r\\n", "gt": "#print(dp[ch],ch+1)\\r\\n for i in range(len(d[ch])):\\r\\n if d[ch][i] not in visited:\\r\\n visited.add(d[ch][i])\\r\\n dfs(d[ch][i],ch,visited)\\r\\n dp[ch][0]+=max(dp[d[ch][i]][0],dp[d[ch][i]][1])\\r\\n dp[ch][1]+=dp[d[ch][i]][0]\\r\\n #print(ch+1,dp[ch])\\r\\nv=set()\\r\\nv.add(0)\\r\\ndfs(0,-1,v)\\r\\n\\r\\n#print(dp)\\r\\nprint(max(dp[0][0],dp[0][1]))\\r\\n\\r\\n \\r\\n\\r\\n\\r\\n"}
{"id": "865", "input": "testCases = int(input())\\nfor c in range(testCases):\\n n, k = list(map(int, input().split()))\\n sum = 0\\n i = 0\\n power = 1\\n while i <= n:\\n if k**power", "gt": "== i:\\n power += 1\\n else:\\n sum += i\\n i +=1 \\n answer = \"Case #\" + str(c + 1) + \": \" + str(sum)\\n print(answer)"}
{"id": "866", "input": "try:\\n \\n for _ in range(int(input())):\\n n =", "gt": "int(input())\\n print(0) if(n==1) else print(pow(2,n-1,10**9+7)-2) \\nexcept EOFError:\\n pass\\n\\n"}
{"id": "867", "input": "t=int(input())\\nfor _ in range(t):\\n n=int(input())\\n l=list(map(int,input().split()))\\n if sum(l)!=n or max(l)==n:\\n print('-1')\\n else:\\n d=dict()\\n ans=[-1]*n\\n for i in range(0,n):\\n d[i]=1\\n for i in range(n):\\n if l[i]!=0:\\n count=l[i]\\n for k,v in list(d.items()):\\n if count>0 and v==1 and", "gt": "i!=k:\\n d[k]=0\\n ans[k]=i+1\\n count-=1\\n ind=-1\\n for i in range(0,len(ans)):\\n if ans[i]==-1:\\n ind=i\\n if ind==-1:\\n print(*ans)\\n else:\\n for i in range(len(ans)):\\n if ans[i]!=ind+1:\\n \\n \\n ans[ind]=ans[i]\\n ans[i]=ind+1\\n break\\n print(*ans)\\n \\n \\n \\n \\n\\n \\n \\n \\n\\n \\n"}
{"id": "868", "input": "T = int(input())\\nfor _ in range(T):\\n W = list(map(int, input().strip().split()))\\n S = W[0]\\n W = W[1:]\\n W = W[::-1]\\n i = 0\\n c = 0\\n flag = 0\\n while (len(W) != 0 or flag !=", "gt": "1) and i<len(W):\\n k = i\\n su = 0\\n while su <= S and k<len(W)-1:\\n su += W[k]\\n k += 1\\n if su-W[k-1]<=S:\\n c += 1\\n else:\\n flag = 1\\n i += 1\\n print(c-1) \\n"}
{"id": "869", "input": "from bisect import insort\\nfrom math import ceil\\nfor _ in range(int(input())):\\n n,k=list(map(int,input().split( )))\\n array=list(map(int,input().split( )))\\n ans=0\\n index=[]\\n for i in range(1,n+1):\\n index.append(ceil(k/(ceil(k/i))))\\n for i", "gt": "in range(n):\\n count=[0]*(2001)\\n temp=[]\\n for j in range(i,n):\\n count[array[j]]+=1\\n insort(temp,array[j])\\n #m=ceil(k/(j-i+1)) precalculate thes values in index array\\n #t=ceil(k/m)\\n x=temp[index[j-i]-1]\\n f=count[x]\\n if count[f]:\\n ans+=1\\n print(ans)\\n"}
{"id": "870", "input": "x = input()\\ny = input()\\nz = x.find(y)\\nif", "gt": "z == -1 :\\n print('N')\\nelse :\\n print('Y')"}
{"id": "871", "input": "# cook your dish here\\nimport math;\\nfrom math import gcd,sqrt,floor,factorial,ceil\\nfrom bisect import bisect_left,bisect_right\\nimport bisect;\\nimport sys;\\nfrom sys import stdin,stdout\\nimport os\\nsys.setrecursionlimit(pow(10,7))\\nimport collections\\nfrom collections import defaultdict,Counter\\nfrom statistics import median\\n# input=stdin.readline\\n# print=stdout.write\\nfrom queue import Queue\\ninf = float(\"inf\")\\nfrom operator import neg;\\nmod=pow(10,9)+7\\ndef fun(l):\\n m=[[l[0]]]\\n for i in range(1,n):\\n if m[-1][-1]==l[i]:\\n m[-1]+=[l[i]]\\n else:\\n m.append([l[i]])\\n count=[]\\n for i in range(len(m)):\\n count.append(len(m[i]))\\n return count;\\ndef function(l1,index,prev,count):\\n tuple=(index,prev,count)\\n if tuplein dict:\\n return dict[tuple]\\n n=len(l1)\\n if index==n:\\n return 0;\\n if count>=3:\\n if index%2==prev:\\n", "gt": "dict[tuple]=function(l1,index+1,prev,count)\\n return function(l1,index+1,prev,count)\\n else:\\n dict[tuple]=l1[index]+function(l1,index+1,prev,count);"}
{"id": "872", "input": "import sys\\r\\n\\r\\nt = int(input())\\r\\n# print(t)\\r\\nfor _ in range(t):\\r\\n n,m = map(int,input().split());\\r\\n s = [];\\r\\n for i in range(n):\\r\\n s.append(input())\\r\\n ans = []\\r\\n for i in range(n):\\r\\n ans.append([])\\r\\n for j in range(m):\\r\\n ans[i].append([])\\r\\n for i in range(n):\\r\\n for j in range(m):\\r\\n c = 0\\r\\n if s[i][j] == 'U':\\r\\n for k in range(i,-1,-1):\\r\\n if s[k][j] == '#':\\r\\n break\\r\\n ans[k][j].append(c)\\r\\n c+=1\\r\\n elif s[i][j] == 'D':\\r\\n for k in range(i,n):\\r\\n if s[k][j] == '#':\\r\\n break\\r\\n ans[k][j].append(c)\\r\\n c+=1\\r\\n elif s[i][j] == 'L':\\r\\n for k in range(j,-1,-1):\\r\\n if", "gt": "s[i][k] == '#':\\r\\n break\\r\\n ans[i][k].append(c)\\r\\n c+=1\\r\\n elif s[i][j] == 'R':\\r\\n for k in range(j,m):\\r\\n if s[i][k] == '#':\\r\\n break\\r\\n ans[i][k].append(c)\\r\\n c+=1\\r\\n for i in range(n):\\r\\n for j in range(m):\\r\\n ans[i][j].sort()\\r\\n res = []\\r\\n for i in range(n):\\r\\n for j in range(m):\\r\\n c= 1\\r\\n # print(ans[i][j])\\r\\n for k in range(1,len(ans[i][j])):\\r\\n # print(ans[i][j][k])\\r\\n if ans[i][j][k] == ans[i][j][k-1]:\\r\\n c+=1\\r\\n else :\\r\\n if c!=1:\\r\\n res.append(c)\\r\\n c = 1\\r\\n if k==len(ans[i][j])-1:\\r\\n if c!=1:\\r\\n res.append(c)\\r\\n pairs = 0\\r\\n # print(res)\\r\\n for i in range(len(res)):\\r\\n pairs += ((res[i]*(res[i]-1))//2)\\r\\n \\r\\n print(pairs)"}
{"id": "873", "input": "for t in range(int(input())):\\n n, a , b , k = map(int,input().split())\\n solvedbychef = 0\\n solvedbyappy = 0\\n for i in range(n+1):\\n if i % a == 0 and", "gt": "i % b == 0 :\\n continue\\n elif i%a == 0 :\\n solvedbyappy+=1\\n elif i%b == 0:\\n solvedbychef+=1\\n totalsolved = solvedbychef + solvedbyappy\\n if totalsolved>=k:\\n print(\"Win\")\\n else :\\n print(\"Lose\")"}
{"id": "874", "input": "let_to_num = {'A':[0,5], 'B':[1,6], 'C':[2,7], 'D':[3,8], 'E':[4,9]}\\n\\nnum_to_let = {0:'A', 1:'B', 2:'C', 3:'D', 4:'E',\\n 5:'A', 6:'B', 7:'C', 8:'D', 9:'E'}\\n\\nconnections = {0:(1,4,5), 1:(0,2,6), 2:(1,3,7), 3:(2,4,8), 4:(0,3,9), 5:(0,7,8),\\n 6:(1,8,9), 7:(2,5,9), 8:(3,5,6), 9:(4,6,7)}\\n\\nT = int(input())\\n\\nfor i in range(T):\\n s = input()\\n out_1, out_2= [],[]\\n flag1, flag2 = True, True\\n for c in range(len(s)):\\n #print out_1, out_2, flag1, flag2\\n if c == 0:\\n out_1.append(let_to_num[s[c]][0])\\n out_2.append(let_to_num[s[c]][1])\\n #print out_1, out_2, '\\n'\\n else:\\n if flag1:\\n conn_1 = set(connections[out_1[-1]])\\n to_conn_1 = set(let_to_num[s[c]])\\n \\n if len(conn_1.intersection(to_conn_1))==0:\\n flag1 = False\\n else:\\n out_1.extend(list(conn_1.intersection(to_conn_1)))\\n \\n", "gt": "#print 'out1',conn_1, to_conn_1, flag1, conn_1.intersection(to_conn_1)\\n if flag2:\\n conn_2 = set(connections[out_2[-1]])\\n to_conn_2 = set(let_to_num[s[c]])\\n \\n if len(conn_2.intersection(to_conn_2))==0:\\n flag2 = False\\n else:\\n out_2.extend(list(conn_2.intersection(to_conn_2)))\\n #print 'out2', conn_2, to_conn_2, flag2, conn_2.intersection(to_conn_2)\\n #print out_1, out_2, flag1, flag2, '\\n'\\n if (not flag1) and (not flag2):\\n break\\n if (not flag1) and (not flag2):\\n print(-1)\\n continue\\n elif flag1 and (not flag2):\\n print(''.join(str(k) for k in out_1))\\n continue\\n elif flag2 and (not flag1):\\n print(''.join(str(k) for k in out_2))\\n continue\\n else:\\n print(min(''.join(str(k) for k in out_1), ''.join(str(k) for k in out_2)))\\n continue\\n"}
{"id": "875", "input": "import math\\nT=int(input())\\nfor i in range(T):\\n N,M,S=input().split()\\n N=int(N)\\n M=int(M)\\n S=int(S)\\n ls=list(map(int,input().split()))\\n maxx=max(ls)\\n if S<17 and maxx<=50:\\n ls.sort()\\n total_sum = M * S\\n count = 0\\n sum = 0\\n for i in ls:\\n", "gt": "if i / S > 2:\\n continue\\n else:\\n sum = sum + math.ceil(i / S) * S\\n if sum <= total_sum:\\n count = count + 1\\n print(count)\\n# cook your dish here\\n"}
{"id": "876", "input": "import sys\\nfrom collections import defaultdict as dd\\nfrom collections import deque\\nfrom fractions import Fraction as f\\nfrom copy import *\\nfrom bisect import * \\nfrom heapq import *\\nfrom math import *\\nfrom itertools import permutations \\n \\ndef eprint(*args):\\n print(*args, file=sys.stderr)\\nzz=1\\n \\n#sys.setrecursionlimit(10**6)\\nif zz:\\n input=sys.stdin.readline\\nelse: \\n sys.stdin=open('input.txt', 'r')\\n sys.stdout=open('all.txt','w')\\ndef li():\\n return [int(xx) for xx in input().split()]\\ndef fli():\\n return [float(x) for x in input().split()] \\ndef comp(a,b):\\n if(a>b):\\n return 2\\n return 2 if a==b else 0 \\ndef gi(): \\n return [xx for x in input().split()]\\ndef", "gt": "fi():\\n return int(input())\\ndef swap(a,i,j):\\n a[i],a[j]=a[j],a[i] \\ndef si():\\n return list(input().rstrip()) \\ndef mi():\\n return map(int,input().split()) \\ndef gh():\\n sys.stdout.flush()\\ndef graph(n,m):\\n for i in range(m):\\n x,y=mi()\\n a[x].append(y)\\n a[y].append(x)\\ndef bo(i):\\n return ord(i)-ord('a')\\n \\n \\nt=fi()\\nwhile t>0:\\n t-=1\\n n,z1,z2=mi()\\n d="}
{"id": "877", "input": "t=int(input())\\r\\n\\r\\nfor t1 in range(t):\\r\\n n,x=map(int,input().split())\\r\\n a=list(map(int,input().split()))\\r\\n \\r\\n", "gt": "mx=max(a)\\r\\n mn=min(a)\\r\\n \\r\\n if (mx-mn<x):\\r\\n print(\"YES\")\\r\\n else:\\r\\n print(\"NO\")"}
{"id": "878", "input": "t = int(input())\\nfor _ in range(t):\\n x, y, k, n = [int(x) for x", "gt": "in input().split()]\\n k = k*2\\n temp = abs(x-y)\\n if(temp%k == 0):\\n print(\"Yes\")\\n else:\\n print(\"No\")\\n"}
{"id": "879", "input": "# cook your dish here\\n\\nimport numpy as np\\n \\n\\ndef minstairs(n,k):\\n stairsHeight=[]\\n stairs=0\\n current = 0\\n stairsHeight=list(map(int, input().split()))\\n stairsHeight=np.array(stairsHeight)\\n curr=0\\n for i", "gt": "in range(n):\\n if stairsHeight[i]-curr<=k:\\n curr=stairsHeight[i]\\n else:\\n if (stairsHeight[i]-curr)%k==0:\\n stairs+=((stairsHeight[i]-curr)//k)-1\\n else:\\n stairs+=(stairsHeight[i]-curr)//k\\n curr=stairsHeight[i]\\n return stairs\\n \\nT=int(input())\\nfor i in range(T):\\n n,k =list(map(int,input().split()))\\n print(minstairs(n,k))\\n"}
{"id": "880", "input": "for _ in range(int(input())):\\r\\n x, y = map(int, input().split())\\r\\n ans = 0\\r\\n for", "gt": "i in range(y, x+1, y):\\r\\n if i%y == 0:\\r\\n ans += i%10\\r\\n print(ans)"}
{"id": "881", "input": "oo = int(input())\\r\\nfor i in", "gt": "range(oo):\\r\\n val = int(input())\\r\\n print((val**2)*3.14)"}
{"id": "882", "input": "# cook your dish here\\nt=int(input())\\nfor i in range(t):\\n n=int(input())\\n ar=list(map(int,input().split()))\\n tot=0\\n st=0\\n", "gt": "for j in range(1,n):\\n if(ar[j-1]>ar[j]):\\n si=j-st\\n c=(si*(si+1))//2\\n tot+=c\\n st=j\\n si=n-st\\n c=(si*(si+1))//2\\n tot+=c\\n print(tot)\\n"}
{"id": "883", "input": "from collections import Counter\\r\\ndef solve(A,B):\\r\\n a = Counter(A)\\r\\n b = Counter(B)\\r\\n ans = 0\\r\\n for i in a:\\r\\n if i in", "gt": "b:\\r\\n ans += min(a[i],b[i])\\r\\n \\r\\n return ans\\r\\n \\r\\n \\r\\nt = int(input())\\r\\n\\r\\nfor _ in range(t):\\r\\n A = input()\\r\\n B = input()\\r\\n print(solve(A,B))"}
{"id": "884", "input": "for _ in range(int(input())):\\n n = int(input())\\n a = list(map(int, input().split()))\\n s = set(a)\\n\\n if n == 1 or len(s) > 2:\\n print(-1)\\n continue\\n\\n if len(s) == 1:\\n x = s.pop()\\n\\n if x", "gt": "== 0:\\n print(n)\\n elif x == n-1:\\n print(0)\\n else:\\n print(-1)\\n\\n continue\\n\\n x, y = sorted(s)\\n xc, yc = a.count(x), a.count(y)\\n\\n if xc == y and xc == x + 1:\\n print(yc)\\n else:\\n print(-1)\\n"}
{"id": "885", "input": "try:\\r\\n for _ in range(int(input())):\\r\\n s,s1=0,0\\r\\n x,k=[int(i) for i in input().split()]\\r\\n for i in", "gt": "range(2,x+1):\\r\\n if(x%i==0):\\r\\n s=s+i**k\\r\\n for i in range(2,k+1):\\r\\n if(k%i==0):\\r\\n s1+=i*x\\r\\n print(s,s1)\\r\\nexcept EOFError as e:\\r\\n pass"}
{"id": "886", "input": "from sys import stdin, stdout\\r\\ninput = stdin.readline\\r\\nfrom collections import defaultdict as dd\\r\\nimport math\\r\\ndef geti(): return list(map(int, input().strip().split()))\\r\\ndef getl(): return", "gt": "list(map(int, input().strip().split()))\\r\\ndef gets(): return input()\\r\\ndef geta(): return int(input())\\r\\ndef print_s(s): stdout.write(s+'\\n')\\r\\n\\r\\ndef solve():\\r\\n for _ in range(geta()):\\r\\n n=geta()\\r\\n n=bin(n).split('b')[1]\\r\\n print(n.count('0'))\\r\\n\\r\\n\\r\\ndef __starting_point():\\r\\n solve()\\r\\n\\n__starting_point()"}
{"id": "887", "input": "for _ in range(int(input())):\\n n=int(input())\\n a=list(map(int,input().split()))\\n x=int(input())\\n for _ in range(1,n,2):\\n a[_],a[_-1]=a[_-1],a[_]\\n for _ in range(n):\\n a[_]+=(a[_]%3)\\n # a=a[::-1]\\n # a.sort()\\n # if x>a[-1]:\\n # print(-1)\\n # continue\\n l,h=-1,9999999999\\n for _ in range(n):\\n # if a[_]>=x:\\n # if _==n-1:\\n", "gt": "# print(-1)\\n # break\\n # elif _==0:\\n # print(-1)\\n # break\\n # else:\\n # print(a[_-1],a[_])\\n # break\\n if a[_]>l and a[_]<x :\\n l=a[_]\\n if a[_]<h and a[_]>x :\\n h=a[_]\\n print(l,end=\" \")\\n if h==9999999999:\\n print(-1)\\n else: \\n print(h) \\n \\n"}
{"id": "888", "input": "# cook your dish here\\n# cook your dish here\\nfor _ in range(int(input())):\\n n=int(input())\\n a=list(map(int, input().split()))\\n b=list(map(int, input().split()))\\n\\n if a[0]!=0 or b[-1]!=0 or a[-1]!=b[0]:\\n print('No')\\n \\n else:\\n ab=b[0]\\n flag=0\\n for i", "gt": "in range(1, n-1):\\n if a[i]==0 or b[i]==0:\\n print('No')\\n flag=1 \\n break\\n \\n elif a[i]+b[i]<ab:\\n print('No')\\n flag=1 \\n break\\n \\n elif a[i]>ab+b[i] or b[i]>ab+a[i]:\\n print('No')\\n flag=1 \\n break\\n \\n if flag==0:\\n print('Yes')"}
{"id": "889", "input": "def search(arr, lenl, val):\\r\\n s = 0\\r\\n l = lenl - 1\\r\\n\\r\\n total = 0\\r\\n\\r\\n while (s <= l):\\r\\n m = int((s + l) / 2)\\r\\n\\r\\n if (arr[m] <= val):\\r\\n total = m + 1\\r\\n s = m + 1\\r\\n\\r\\n else:\\r\\n l = m - 1\\r\\n\\r\\n return total\\r\\n\\r\\n\\r\\ndef kmpsearch(string, lps):\\r\\n lis = []\\r\\n lens = len(string)\\r\\n lensh = lens // 2\\r\\n\\r\\n l = 0\\r\\n i = 0\\r\\n while i < lens:\\r\\n if string[i] == pat[l]:\\r\\n l += 1\\r\\n i += 1\\r\\n elif l > 0:\\r\\n l = lps[l - 1]\\r\\n else:\\r\\n i += 1\\r\\n\\r\\n if l == lenp:\\r\\n if i - l < lensh:\\r\\n lis.append(i - l)\\r\\n\\r\\n l = lps[l - 1]\\r\\n\\r\\n return lis\\r\\n\\r\\n\\r\\ndef", "gt": "kmp(pat, lenp):\\r\\n\\r\\n lps = [0]*(lenp)\\r\\n l = 0\\r\\n i = 1\\r\\n\\r\\n while i < lenp:\\r\\n if pat[i] == pat[l]:\\r\\n l += 1\\r\\n lps[i] = l\\r\\n i += 1\\r\\n elif l > 0:\\r\\n l = lps[l-1]\\r\\n else:\\r\\n lps[i] = 0\\r\\n i += 1\\r\\n\\r\\n return lps\\r\\n\\r\\n\\r\\n\\r\\nkeyword = input()\\r\\npat = input()\\r\\nq = int(input())\\r\\n\\r\\nlenk = len(keyword)\\r\\nlenp = len(pat)\\r\\n\\r\\nk = keyword * 2\\r\\nlis = kmpsearch(k, kmp(pat, lenp))\\r\\nlenl = len(lis)\\r\\n\\r\\nfor _ in range(q):\\r\\n n = int(input())\\r\\n count = 0\\r\\n\\r\\n q = n // lenk\\r\\n r = n % lenk\\r\\n\\r\\n count += search(lis, lenl, r - lenp)\\r\\n\\r\\n if q >= 1:\\r\\n count += search(lis, lenl, lenk + r - lenp)\\r\\n\\r\\n if q >= 2:\\r\\n count += (q - 1)*lenl\\r\\n\\r\\n print(count)\\r\\n \\r\\n"}
{"id": "890", "input": "# cook your dish here\\ndef ceil(num):\\n if num%1==0:\\n return int(num//1)\\n else:\\n return int((num//1)+1)\\n \\nfor _ in range(int(input())):\\n n=int(input())\\n s=input()\\n p=0\\n a=[]\\n for i in range(n):\\n", "gt": "if s[i]==\"P\":\\n p=p+1\\n req=ceil(0.75*n)\\n requirement=req-p\\n for i in range(2,n-2):\\n if s[i]==\"A\":\\n if (s[i-1]==\"P\" or s[i-2]==\"P\") and (s[i+1]==\"P\" or s[i+2]==\"P\"):\\n a.append(i)\\n if requirement>len(a):\\n print(-1)\\n else:\\n print(max(requirement,0))"}
{"id": "891", "input": "# cook your dish here\\nt=int(input())\\nwhile t:\\n n=int(input())\\n r1=input()\\n r2=input()\\n r1count=0\\n r2count=0\\n count=0\\n for i in range(n):\\n if(r1[i]==\"*\"):\\n r1count+=1\\n if(r2[i]==\"*\"):\\n r2count+=1\\n if(r1count>0) and (r2count>0):\\n count=1\\n r1count=0\\n r2count=0\\n", "gt": "i=0\\n while(i<n):\\n if(r1[i]==\"*\"):\\n r1count+=1\\n if(r2[i]==\"*\"):\\n r2count+=1\\n if(r1count>1) or (r2count>1):\\n count+=1\\n r1count=0\\n r2count=0\\n i-=1\\n i+=1\\n elif(r1count==0 and r2count>0) or (r2count==0 and r1count>0):\\n count=max(r1count,r2count)-1\\n else:\\n count=0\\n print(count)\\n t-=1"}
{"id": "892", "input": "# cook your dish here\\nimport math;\\nfrom math import gcd,sqrt,floor,factorial,ceil\\nfrom bisect import bisect_left,bisect_right\\nimport bisect;\\nimport sys;\\nfrom sys import stdin,stdout\\nimport os\\nsys.setrecursionlimit(pow(10,7))\\nimport collections\\nfrom collections", "gt": "import defaultdict,Counter\\nfrom statistics import median\\n# input=stdin.readline\\n# print=stdout.write\\nfrom queue import Queue\\ninf = float(\"inf\")\\nfrom operator import neg;\\nn,m=map(int,input().split())\\nfor i in range(m):\\n k=int(input())\\n print(max(0,min(k-n-1,3*n+1-k)))\\n"}
{"id": "893", "input": "from sys import setrecursionlimit\\r\\nsetrecursionlimit(10 * 9)\\r\\n\\r\\ndef solve(i):\\r\\n if i + k >= n:\\r\\n return 1\\r\\n\\r\\n if i in dp:\\r\\n return dp[i]\\r\\n\\r\\n mini = float('inf')\\r\\n for j in range(i+1, min(n, i+k+1)):\\r\\n if i == -1 or a[i] == a[j]:\\r\\n mini = min(mini, solve(j) + 1)\\r\\n\\r\\n dp[i] = mini\\r\\n return dp[i]\\r\\n\\r\\n\\r\\nfor _ in range(int(input())):\\r\\n n, k = map(int, input().split())\\r\\n a = list(map(lambda x: int(x) % 2, input().split()))\\r\\n\\r\\n le = lo = -1\\r\\n se = so = -1\\r\\n\\r\\n for i in range(n-k, n):\\r\\n if a[i] == 0:\\r\\n le = i\\r\\n break\\r\\n\\r\\n for i in range(n-k, n):\\r\\n if a[i] == 1:\\r\\n lo = i\\r\\n break\\r\\n\\r\\n m1 = float('inf')\\r\\n if le != -1:\\r\\n m1 = 0\\r\\n while True:\\r\\n", "gt": "lle = -1\\r\\n\\r\\n for i in range(se + 1, se + k + 1):\\r\\n if i == le:\\r\\n m1 += 2\\r\\n break\\r\\n\\r\\n if a[i] == 0:\\r\\n lle = i\\r\\n\\r\\n else:\\r\\n if lle == -1:\\r\\n m1 = float('inf')\\r\\n break\\r\\n\\r\\n se = lle\\r\\n m1 += 1\\r\\n continue\\r\\n\\r\\n break\\r\\n\\r\\n m2 = float('inf')\\r\\n if lo != -1:\\r\\n m2 = 0\\r\\n while True:\\r\\n llo = -1\\r\\n\\r\\n for i in range(so + 1, so + k + 1):\\r\\n if i == lo:\\r\\n m2 += 2\\r\\n break\\r\\n\\r\\n if a[i] == 1:\\r\\n llo = i\\r\\n\\r\\n else:\\r\\n if llo == -1:\\r\\n m2 = float('inf')\\r\\n break\\r\\n\\r\\n so = llo\\r\\n m2 += 1\\r\\n continue\\r\\n\\r\\n break\\r\\n\\r\\n if min(m1, m2) != float('inf'):\\r\\n print(min(m1, m2))\\r\\n else:\\r\\n print(-1)"}
{"id": "894", "input": "# cook your dish here\\nfrom math import floor, sqrt\\ntry:long\\nexcept NameError:long = int \\ndef fac(n):\\n step,maxq,d = lambda x: 1 + (x<<2) - ((x>>1)<<1),long(floor(sqrt(n))),1\\n q = n % 2 == 0 and 2 or 3 \\n while q <= maxq and n %", "gt": "q != 0:\\n q = step(d)\\n d += 1\\n return q <= maxq and [q] + fac(n//q) or [n]\\nn,k,s = map(int,input().split())\\na,di,l,m,ans,su =list(map(int,input().split())),"}
{"id": "895", "input": "import random\\nt=int(input())\\nfor testCase in range(t):\\n n=int(input())\\n array1=[]\\n array2=[]\\n array=[]\\n for i in range(n) :\\n array1.append(list(map(int,input().split())))\\n for i in range(n) :\\n array2.append(list(map(int,input().split())))\\n for i in range(n) :\\n array.append(i)\\n# print array2,\" \",array1\\n for i in range(n) :\\n print(array[i]+1, end=' ') \\n print() \\n k=0\\n max=0\\n answer=[]\\n temp=[]\\n while k", "gt": "< (1<<5) :\\n k+=1 \\n for i in range(n) :\\n rand=random.randint(0,len(array)-1)\\n temp.append(array[rand])\\n array.pop(rand)\\n array = temp\\n count=0\\n for i in range(n) :\\n for j in range(n) :\\n if(array1[i][j] and array2[array[i]][array[j]]) :\\n count+=1\\n if(count > max):\\n answer=array\\n max=count\\n #print max,count\\n for x in answer :\\n print(x+1, end=' ')\\n print()"}
{"id": "896", "input": "n=int(input())\\r\\nar=list(map(int,input().split()))\\r\\ndp=[0]*n \\r\\ndp[0]=ar[0]\\r\\ndp[1]=ar[1]\\r\\nfor i in range(2,n):\\r\\n dp[i]=min(dp[i-2],dp[i-1])+ar[i]\\r\\n", "gt": "\\r\\nar.reverse()\\r\\n#print(ar)\\r\\ndp1=[0]*n \\r\\ndp1[0]=ar[0]\\r\\ndp1[1]=ar[1]\\r\\nfor i in range(2,n):\\r\\n dp1[i]=min(dp1[i-2],dp1[i-1])+ar[i]\\r\\nprint(min(dp[-1],dp1[-1]))"}
{"id": "897", "input": "for tc in range(int(input())):\\n N = int(input())\\n a, b = list(map(int, input().split()))\\n pr = []\\n\\n # 'L' is lexicographically lower than 'R'.\\n # so, we should first try to apply L+ or L-\\n # if we can't then only we'll try to apply R+ or R-\\n\\n for i in range(N - 1):\\n l, r = list(map(int, input().split()))\\n\\n #continue the following process until a == l and b == r\\n while a != l or b != r:\\n # trying to", "gt": "apply L-\\n if a > l:\\n a -= 1\\n pr.append('L-')\\n\\n # now, trying to apply L+ (if a < b)\\n elif a + 1 < b and a < l:\\n a += 1\\n pr.append('L+')\\n\\n # ok, so far, so good... now, let's try to apply R+\\n elif b < r:\\n b += 1\\n pr.append('R+')\\n\\n # finally, lastly, trying to apply R- (if a < b)\\n elif b - 1 > a and b > r:\\n b -= 1\\n pr.append('R-')\\n\\n print(len(pr))\\n print(''.join(pr))"}
{"id": "898", "input": "# cook your dish here\\n# cook your dish here\\nMOD = 10 ** 9 + 7\\n \\nfor t in range(int(input())):\\n N, M, K = map(int, input().split())\\n A = list(map(int, input().split()))\\n I, D = [0] * (N + 2), [0] * (N + 2)\\n for i in range(M):\\n x, L, R = input().split()\\n L, R = int(L), int(R)\\n if x == 'I':\\n I[L] += 1\\n I[R] -= 1\\n else:\\n D[L] += 1\\n D[R] -= 1\\n \\n impossibru = mx = mn = 0\\n ans = 1\\n for i in range(N):\\n I[i] += I[i - 1]\\n D[i] += D[i -", "gt": "1]\\n if I[i] and D[i]:\\n impossibru = 1\\n break\\n if not I[i] and not D[i]:\\n ans = ans * (mx - mn + 1) % MOD\\n mn, mx = 1, K\\n elif I[i]:\\n mx = min(mx + 1, K)\\n mn += 1\\n elif D[i]:\\n mn = max(1, mn - 1)\\n mx -= 1\\n if mn > mx:\\n impossibru = 1\\n break\\n if A[i] != -1:\\n if not mn <= A[i] <= mx:\\n impossibru = 1\\n break\\n mn = mx = A[i]\\n ans = ans * (mx - mn + 1) % MOD\\n \\n print(0 if impossibru else ans)"}
{"id": "899", "input": "# cook your dish here\\nfrom math import pow\\nt = int(input())\\nfor _ in range(t):\\n m,n", "gt": "= map(int,input().rstrip().split())\\n cnt = len(str(n))\\n x = pow(10,cnt)\\n if n == x-1:\\n print(m*cnt,m)\\n else:\\n print(m*(cnt-1),m)"}
{"id": "900", "input": "from math import ceil\\n\\nfor _ in range(int(input())):\\n n = int(input())\\n arr = [int(x) for x in input().split()]\\n", "gt": "sarr = sum(arr)\\n mavg = sarr/n\\n while n>1:\\n sarr -= arr.pop()\\n n-=1\\n mavg = max(mavg, sarr/n)\\n print(int(ceil(mavg)))"}
{"id": "901", "input": "import math\\r\\nt=int(input())\\r\\nfor i in", "gt": "range(t):\\r\\n k=int(input())\\r\\n res=((pow(2,k,1000000007))*5)%1000000007\\r\\n print(res)"}
{"id": "902", "input": "# Md. Khairullah Gaurab\\n# SUST, CSE, 20th Batch\\n# gaurab.cse.sust@gmail.com\\n\\n\\ntest = int(input());\\n\\nfor i in range(test):\\n N, S, K = list(map(int,input().split()));\\nlis = list(map(int,input().split()));\\n ans = [i+1 for", "gt": "i in range(N)] ;"}
{"id": "903", "input": "for u in range(int(input())):\\n p=input().split()\\n n=int(p[0])\\n s=p[1]\\n x,y=0,0\\n for i in range(n):\\n l=input()\\n", "gt": "if(l[0]=='1'):\\n y+=l.count('1')\\n else:\\n x+=l.count('0')\\n if(x<y):\\n print(\"Dum\")\\n elif(y<x):\\n print(\"Dee\")\\n else:\\n if(s=='Dee'):\\n print(\"Dum\")\\n else:\\n print(\"Dee\")\\n"}
{"id": "904", "input": "# cook your dish here\\ntry:\\n t = int(input())\\n for _ in range(t):\\n p = [int(x) for x in input().split()]\\n q", "gt": "= [int(x) for x in input().split()]\\n \\n q[1] *= -1\\n m = (q[1]-p[1])/(q[0]-p[0])\\n c = p[1] - m*p[0]\\n \\n print(\""}
{"id": "905", "input": "# cook your dish here\\nimport bisect\\nfor _ in range(int(input())):\\n \\n n,x=list(map(int,input().split()))\\n \\n l=list(map(int,input().split()))\\n battery=[]\\n \\n power=0\\n i=0\\n t=(n+1)//2\\n while power<x and i<t:\\n \\n if i==n-i-1:\\n temp=[-1,l[i]]\\n else:\\n temp=sorted([ l[i],", "gt": "l[n-i-1] ])\\n \\n power+=temp[1]\\n pos=bisect.bisect_right(battery, temp[1], lo=0, hi=len(battery))\\n battery.insert(pos,temp[1])\\n \\n if temp[0]>battery[0]:\\n \\n power-=battery.pop(0)\\n power+=temp[0]\\n pos=bisect.bisect_right(battery, temp[0], lo=0, hi=len(battery))\\n battery.insert(pos,temp[0])\\n \\n i+=1\\n \\n \\n if power>=x:\\n print('YES')\\n else:\\n print('NO')\\n"}
{"id": "906", "input": "n=int(input())\\narr=[]\\nfor i in range(1,n+1):\\n arr.append(i)\\nc=0\\ni=0\\nf=0;\\nwhile(c<n-1):\\n if(arr[i%n]!=-1 and f):\\n arr[i%n]=-1\\n c=c+1\\n", "gt": "f=0\\n if(arr[i%n]!=-1):\\n f=1\\n i=i+1\\n\\nfor i in range(0,n):\\n if(arr[i]!=-1):\\n ans=arr[i]\\n break;\\nprint(ans) \\n"}
{"id": "907", "input": "# cook your dish here\\n# Author: Dancing Monkey | Created: 09.DEC.2018\\n\\n\\nimport bisect\\nfor _ in range(int(input())):\\n n = int(input())\\n x1 , x2, x3 = [], [], []\\n for i in range(n):\\n x, y = list(map(int, input().split()))\\n\\n if x == 1: x1.append(y)\\n if x == 2: x2.append(y)\\n if x == 3: x3.append(y)\\n\\n x1.sort()\\n x2.sort()\\n x3.sort()\\n\\n y1, y2, y3 = len(x1), len(x2), len(x3)\\n area = 0\\n for i in range(y1):\\n for j in range(i+1, y1):\\n area += abs(x1[i] - x1[j])*(y2 + (2*y3))\\n\\n for i in range(y3):\\n for j in range(i+1, y3):\\n area += abs(x3[i] - x3[j])*(y2 + (2*y1))\\n\\n", "gt": "for i in range(y2):\\n for j in range(i+1, y2):\\n area += abs(x2[i] - x2[j])*(y1 + y3)\\n\\n area /= 2\\n\\n s1 = [0]\\n for i in range(y2): s1.append(s1[-1] + x2[i])\\n # print(s1)\\n s2 = [0]\\n for i in range(y2):s2.append(s2[-1] + x2[y2 - 1 - i])\\n # print(s2)\\n\\n for i in x1:\\n for j in x3:\\n p1 = (i + j) / 2\\n p = bisect.bisect_left(x2, p1)\\n # print('p', p)\\n l = p\\n h = y2 - l\\n # print(l, h)\\n\\n area += p1*(l) - s1[l]\\n # print('dfg', area)\\n area += s2[h] - p1*(h)\\n\\n print(format(area, 'f'))\\n # print()\\n"}
{"id": "908", "input": "# cook your dish here\\nt=int(input())\\nfor i in range(t):\\n n=int(input())\\n s=input().strip()\\n c=0\\n for i in range(len(s)):\\n if s[i]=='.':\\n", "gt": "continue\\n if s[i]=='H':\\n c+=1\\n if s[i]=='T':\\n c-=1\\n if c>1:\\n break\\n if c<0:\\n break\\n if c==0:\\n print('Valid')\\n else:\\n print('Invalid')"}
{"id": "909", "input": "t = eval(input())\\n\\ndef moneda(m):\\n h = 1\\n triange = []\\n while m >= h:\\n triange.append(h)\\n m -= h", "gt": "\\n h += 1\\n return len(triange)\\n\\ntriangulo = []\\nfor i in range(t):\\n n = eval(input())\\n triangulo.append(n)\\n\\nfor i in triangulo:\\n print(moneda(i))\\n"}
{"id": "910", "input": "for u in range(int(input())):\\n n=int(input())\\n l=list(map(int,input().split()))\\n d=list(map(int,input().split()))\\n ka=[]\\n k=[]\\n l.sort()\\n d.sort()\\n for i in", "gt": "range(n):\\n ka.append(d[i])\\n ka.append(l[i])\\n for i in range(n):\\n k.append(l[i])\\n k.append(d[i])\\n if(ka==sorted(ka)):\\n print(\"YES\")\\n elif(k==sorted(k)):\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n"}
{"id": "911", "input": "t =int(input())\\r\\nfor i in range(t):\\r\\n C=[ord(x)-ord('R') for x in", "gt": "list(input())]\\r\\n N=int(input())\\r\\n L=sum(C)\\r\\n r=1\\r\\n c=0\\r\\n while(r*L<N*12):\\r\\n c+=N*12-r*L\\r\\n r+=1\\r\\n print(c)\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n"}
{"id": "912", "input": "def find_upper_bound(arr,key):\\n low,high = 0,len(arr)-1\\n while low<=high:\\n mid = (low+high)//2 \\n if arr[mid]==key:return mid\\n elif arr[mid]>key and mid-1>=0 and arr[mid-1]<key:return mid \\n elif arr[mid]>key:high = mid - 1 \\n else:low = mid + 1 \\n return mid \\ndef get_query(l):\\n", "gt": "nonlocal prefix_storer,bin_storer\\n ind = find_upper_bound(bin_storer,l)\\n surplus = (abs(bin_storer[ind]-l)*ind*ind)%limit \\n return (prefix_storer[ind]-surplus+limit)%limit\\ndef fire_query(l,r):\\n return (get_query(r)-get_query(l-1)+limit)%limit\\ngolomb,dp,prefix_storer,bin_storer = [],[0,1],[0,1],[0,1]\\nlimit = 10**9+7\\nfor i in range(2,10**6+100):\\n dp.append(1 + dp[i-dp[dp[i-1]]])\\n bin_storer.append(dp[-1]+bin_storer[-1])\\n prefix_storer.append(((prefix_storer[-1] + (dp[-1]*i*i)%limit))%limit)\\n# print(dp[1:20])\\n# print(bin_storer[1:20])\\n# print(prefix_storer[1:20])\\n# print(get_query(2),get_query(4))\\nfor _ in range(int(input())):\\n l,r = map(int,input().split())\\n print(fire_query(l,r))"}
{"id": "913", "input": "#dt = {} for i in x: dt[i] = dt.get(i,0)+1\\r\\nimport sys;input = sys.stdin.readline\\r\\ninp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]\\r\\n\\r\\ndef check(mid):\\r\\n pos = x[0]\\r\\n ct = 1\\r\\n for i in range(1,n):\\r\\n if x[i]-pos >= mid:\\r\\n pos = x[i]\\r\\n ct += 1\\r\\n if ct ==", "gt": "k:\\r\\n return True\\r\\n return False\\r\\n\\r\\nfor _ in range(inp()):\\r\\n n,k = ip()\\r\\n x = ip()\\r\\n x.sort()\\r\\n ans = -1\\r\\n l,r = 1,x[-1]\\r\\n while l < r:\\r\\n mid = (l+r)//2\\r\\n if check(mid):\\r\\n ans = max(ans,mid)\\r\\n l = mid +1\\r\\n else:\\r\\n r = mid\\r\\n print(ans)\\r\\n \\r\\n \\r\\n \\r\\n \\r\\n"}
{"id": "914", "input": "n,m,k=map(int, input().split())\\na = []\\ncheck = [0]*m\\nwhile k!= 0:\\n x1,y1,x2,y2 =map(int,input().split())\\n a.append([x1,y1,x2,y2])\\n check[y1-1] += 1\\n check[y2-1] += 1\\n k-= 1\\nmaxi = check.index(max(check))+1\\nsum = 0\\nk = 0\\nfor i in range(len(a)):\\n x1,y1,x2,y2 = a[i]\\n if (y1 > maxi and y2 > maxi)", "gt": "or (y1<maxi and y2 < maxi):\\n sum+= abs(y2-y1)*2\\n sum += abs(x2-x1)*2\\n else:\\n if y1 != maxi:\\n k = abs(y1-maxi)\\n sum+= k*2\\n if x1 != x2:\\n k = abs(x2-x1)\\n sum += k\\n if y2 != maxi:\\n k = abs(y2-maxi)\\n sum+= k*2\\nprint(sum)"}
{"id": "915", "input": "try:\\r\\n t = int(input())\\r\\n while(t > 0):\\r\\n t -= 1\\r\\n n,m = list(map(int,input().split()))\\r\\n a = [list(map(int,input().split())) for _ in range(n)]\\r\\n dp = [[0 for _ in range(m)] for _ in range(n)]\\r\\n ans = [['0' for _ in range(m)] for _ in range(n)]\\r\\n for i in range(n):\\r\\n for j in range(m):\\r\\n", "gt": "if i-1 < n:\\r\\n if 0 <= j-1 and j+1 < m:\\r\\n dp[i][j] = max(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])\\r\\n elif j == 0:\\r\\n dp[i][j] = max(dp[i-1][j],dp[i-1][j+1])\\r\\n elif j == m-1:\\r\\n dp[i][j] = max(dp[i-1][j-1],dp[i-1][j])\\r\\n \\r\\n if dp[i][j] > a[i][j]:\\r\\n ans[i][j] = '0'\\r\\n else:\\r\\n ans[i][j] = '1'\\r\\n dp[i][j] = a[i][j]\\r\\n \\r\\n for i in ans:\\r\\n print(''.join(i))\\r\\nexcept:\\r\\n pass"}
{"id": "916", "input": "# cook your dish here\\ntest = int(input())\\n\\nfor _", "gt": "in range(0,test):\\n n = int(input())\\n lister = set(map(int,input().split()))\\n print(len(lister))"}
{"id": "917", "input": "# cook your dish here\\nimport math\\nT=int(input())\\nfor", "gt": "i in range(T):\\n a=list(map(int,input().split()))\\n n=a[0]\\n m=a[1]\\n print(m*n//math.gcd(m,n))"}
{"id": "918", "input": "for _ in range(int(input())):\\n n,k=list(map(int, input().split()))\\n l=list(map(int, input().split()))\\n l.sort()\\n \\n c=0\\n mn=abs(l[0]+l[1]-k)\\n for i in range(n-1):\\n for j in", "gt": "range(i+1, n):\\n temp=abs(l[i]+l[j]-k)\\n if temp==mn:\\n c+=1 \\n \\n elif temp<mn:\\n mn=temp\\n c=1 \\n \\n elif l[i]+l[j]-k>mn:\\n break\\n \\n print(mn, c)"}
{"id": "919", "input": "# cook your dish here\\nmod=8589934592\\nlist1=[]\\nfor i in range(int(input())):\\n", "gt": "x=int(input())\\n ans=(pow(2,x,mod)-1)%mod\\n list1.append((i+1,ans))\\nfor i in list1:\\n print(f'Case"}
{"id": "920", "input": "'''Author- Akshit Monga'''\\nfrom sys import stdin, stdout\\ninput = stdin.readline\\nt=int(input())\\nfor _ in range(t):\\n n=int(input())\\n a=[int(x) for x", "gt": "in input().split()]\\n ans=0\\n dp=[-1 for i in range(0,n+1)]\\n for i in a:\\n var1=dp[i]\\n var2=ans\\n ans=max(ans,var1+1)\\n dp[i]=max(dp[i],var2+1)\\n print(n-ans)"}
{"id": "921", "input": "from collections import Counter \\nfor _ in range(int(input())):\\n s = input()\\n c = Counter(list(s))\\n if len(c) == 1:\\n print(0)\\n else:\\n m = min(c['b'], c['g'])\\n ma = max(c['b'], c['g'])\\n l = (ma - m + 1) // 2\\n r = (ma - m + 1) // 2 + (ma - m + 1) % 2\\n res = (l", "gt": "* (l + 1)) // 2\\n re = res\\n for i in range(1, m):\\n res += 2 * l + 1\\n re += res\\n l += 1\\n res2 = (r * (r + 1)) // 2\\n re += res2\\n for i in range(1, m):\\n res2 += 2 * r + 1\\n re += res2\\n r += 1\\n print(re)"}
{"id": "922", "input": "def f(a,n):\\n l,r,s1,s2 = [0]*n, [0]*n, [], []\\n \\n for i in range(n):\\n count = 1\\n while(len(s1)>0 and a[i]<s1[-1][0]):\\n count += s1[-1][1]\\n s1.pop()\\n s1.append((a[i],count))\\n l[i] = count\\n \\n for i in", "gt": "range(n-1,-1,-1):\\n count = 1\\n while(len(s2)>0 and a[i]<=s2[-1][0]):\\n count += s2[-1][1]\\n s2.pop()\\n s2.append((a[i],count))\\n r[i] = count\\n \\n count = 0\\n for i in range(n):\\n count += a[i]*l[i]*r[i]\\n \\n return count\\n\\nt = int(input())"}
{"id": "923", "input": "t = int(input())\\nfor i in range(t):\\n n, m = map(int, input().split())\\n arr1 = list(map(int, input().split()))\\n arr2 = list(map(int, input().split()))\\n hmap = {}\\n for i in range(n):\\n if arr1[i] in hmap:\\n hmap[arr1[i]] += 1\\n else:\\n hmap[arr1[i]] =", "gt": "1\\n \\n for i in range(m):\\n if arr2[i] in hmap:\\n hmap[arr2[i]] += 1\\n else:\\n hmap[arr2[i]] = 1\\n ans = []\\n #print(hmap)\\n for key in hmap:\\n if hmap[key]==1:\\n ans.append(key)\\n ans.sort()\\n for x in ans:\\n print(x,end=' ')\\n print()\\n \\n"}
{"id": "924", "input": "t=int(input())\\nwhile(t):\\n k=1\\n j=0\\n n=int(input())\\n while(n>0):\\n if(n<=k):\\n j+=1\\n n=0\\n elif", "gt": "n>2*k:\\n j+=2\\n n=n-2*k\\n k+=1\\n else:\\n j+=2\\n n=0\\n print(j)\\n t-=1"}
{"id": "925", "input": "# cook your dish here\\n# cook your dish here\\n\\nimport math\\ndef distinctPrimeFactors(num) :\\n primes,sqrt = set(),int(math.sqrt(num))\\n if (num == 2) :primes.add(num)\\n for j in range(2, sqrt + 1) :\\n if (num % j == 0) :\\n primes.add(j)\\n while (num % j == 0) :num //= j\\n if (num > 2) :primes.add(num)\\n return (primes)\\nres,c,lst,primes,rangeData = [],0,{},{},{};k, q = map(int, input().split());primes[k] = distinctPrimeFactors(k)\\nfor tc in range(q) :\\n query = input()\\n if (query[0] == '!') :\\n cmd, l, r, x = query.split();l,r,x = int(l),int(r),int(x);start,end,startflag = l,r,False\\n for i in sorted(rangeData) :\\n rangeVal = i\\n if (start > rangeVal[1]) :continue\\n if (end <rangeVal[0]) :break \\n startRange,endRange = start,end\\n if (start >= rangeVal[0] and start <= rangeVal[1]) :start = rangeVal[1] + 1;continue\\n if (end >= rangeVal[0]) :endRange = rangeVal[0] - 1\\n", "gt": "if (startRange <= endRange) :\\n rangeData[(startRange, endRange)] = x;"}
{"id": "926", "input": "import math\\ndef comb(n,r):\\n f = math.factorial\\n return f(n) / f(r) / f(n-r)\\nt=int(input())\\nfor i in range(1,t+1):\\n n=int(input())\\n arr =", "gt": "list(map(int, input().split()))\\n m=0\\n ans=0.0\\n for i in range(0,n):\\n if (arr[i]==-1):\\n m=m+1\\n for i in range(0,m):\\n ans=ans+((m-i)*comb(m-1,m-1-i))\\n ans=ans/pow(2,m-1)\\n print('"}
{"id": "927", "input": "# cook your dish here\\nfor u in range(int(input())):\\n n,r=list(map(int,input().split()))\\n l=list(map(int,input().split()))\\n m=0\\n for i in", "gt": "range(n-1):\\n d=[]\\n d.append(l[i])\\n c=1\\n while(i+c<n):\\n d.append(l[i+c])\\n d.sort(reverse=True)\\n if(d[0]+d[1]<=r):\\n c=c+1\\n else:\\n break\\n if(c>m):\\n m=c\\n print(m)\\n\\n\\n"}
{"id": "928", "input": "n, m = map(int, input().split())\\nl = n\\nf = 1\\ns = ((n)*(n+1))//2 - l - f\\nfor _ in range(m):\\n k = int(input())\\n", "gt": "if 2 <= k <= n-1 or k in [f, l]:\\n l, f = f, l\\n else:\\n l = k\\n print(s+l+f)"}
{"id": "929", "input": "import math\\r\\ndef CountSquares(a, b):\\r\\n return (math.floor(math.sqrt(b)) - math.ceil(math.sqrt(a))", "gt": "+ 1)\\r\\nfor _ in range(int(input())):\\r\\n n=int(input())\\r\\n val=CountSquares(1,n)\\r\\n ans=val-val//3\\r\\n print(ans)"}
{"id": "930", "input": "# cook your dish here\\nimport numpy as np\\ntests = int(input())\\nfor _ in range(tests):\\n n = int(input())\\n weights = [int(j) for j in input().split()]\\n edges = [[0] for _ in range(n-1)]\\n for i in range(n-1):\\n edges[i] = [int(j)-1 for j in input().split()]\\n vertex_set = [[] for _ in range(n)]\\n for i in range(n-1):\\n vertex_set[edges[i][0]].append(edges[i][1])\\n vertex_set[edges[i][1]].append(edges[i][0])\\n counts = [0 for _ in range(3)]\\n for i in range(n):\\n counts[weights[i]] += 1\\n if counts[1] == 0:\\n print(2 * (counts[0] != 0 and counts[2] != 0))\\n elif counts[1] == n:\\n print(0)\\n else:\\n visited = [0]\\n for i in range(n):\\n vertex = visited[i]\\n", "gt": "for v in vertex_set[vertex]:\\n if v not in visited:\\n visited.append(v)\\n vertex_nums = [[0] for _ in range(n)]\\n for i in range(n-1,-1,-1):\\n vertex = visited[i]\\n for v in vertex_set[vertex]:\\n if v in visited[i:]:\\n vertex_nums[vertex].append(sum(vertex_nums[v])+1)\\n for i in range(n):\\n vertex_nums[i].append(n-1-sum(vertex_nums[i]))\\n sums = np.zeros(n,dtype=bool)\\n sums[0] = True\\n for i in range(n):\\n new_sums = np.zeros(n,dtype=bool)\\n new_sums[0] = True\\n for num in vertex_nums[i]:\\n new_sums[num:n] = np.logical_or(new_sums[num:n],new_sums[:n-num])\\n sums = np.logical_or(sums,new_sums)\\n solved = False\\n for i in range(n):\\n if sums[i] and counts[0] <= i and counts[2] <= n - 1 - i:\\n solved = True\\n break\\n if solved or counts[1] > 1:\\n print(1)\\n else:\\n print(2)"}
{"id": "931", "input": "for i in range(int(input())):\\n t=int(input())\\n n=0\\n for i in range(1,t+1):\\n n=n+i\\n x=[n]\\n", "gt": "y=n\\n for j in range(i,t+i-1):\\n if j<t:\\n z=y+j\\n else:\\n z=y+(2*t-j-1)\\n x.append(z)\\n y=z\\n print(*x)"}
{"id": "932", "input": "# cook your dish here\\nfor test in range(int(input())):\\n n = int(input())\\n ar = list(map(int, input().split()))\\n \\n", "gt": "count = 0\\n for item in ar:\\n if bin(item)[-1] == '0':\\n count += item\\n \\n print(count)"}
{"id": "933", "input": "from sys import setrecursionlimit\\nsetrecursionlimit(10 ** 9)\\n\\ndef solve(i, j, c=0):\\n if i > j:\\n return 0\\n\\n if (i, j) in dp:\\n return dp[i, j]\\n\\n x0 = solve(i+1, j, c^1)\\n x1 = solve(i, j-1, c^1)\\n\\n if c == 0:\\n y = 1 << (j", "gt": "- i)\\n x0 += a[i] * y\\n x1 += a[j] * y\\n\\n dp[i, j] = x0 + x1\\n return dp[i, j]\\n\\nfor _ in range(int(input())):\\n n = int(input())\\n a = list(map(int, input().split()))\\n dp ="}
{"id": "934", "input": "#!/usr/bin/env python2\\n \\ndef gc(c):\\n return 'a' <= c <= 'h'\\ndef gd(c):\\n return '1' <= c <= '8'\\n \\nt = int(input())\\nfor i in range(t):\\n line = input()\\n if len(line) != 5:\\n print(\"Error\")\\n continue\\n if line[2] != '-':\\n print(\"Error\")\\n continue\\n x1 = line[0]\\n y1 = line[1]\\n", "gt": "x2 = line[3]\\n y2 = line[4]\\n if gc(x1) and gd(y1) and gc(x2) and gd(y2):\\n d1 = abs(ord(x1) - ord(x2))\\n d2 = abs(ord(y1) - ord(y2))\\n if d1 > d2: d1,d2 = d2, d1\\n if (d1 == 1) and (d2 == 2):\\n print(\"Yes\")\\n else:\\n print(\"No\")\\n else:\\n print(\"Error\")"}
{"id": "935", "input": "T=int(input()) # cook your dish here\\nfor i in range(T): \\n n=list(map(int,input().split()))\\n a=n[0]\\n b=n[1]\\n c=n[2]\\n l=[]\\n A=list(map(int,input().split()))\\n B=list(map(int,input().split()))\\n C=list(map(int,input().split()))\\n for i in range(b):\\n for", "gt": "j in range(a):\\n for k in range(c):\\n if(A[j]<=B[i] and B[i]>=C[k]):\\n sum=((A[j]+B[i])*(B[i]+C[k]))\\n l.append(int(sum))\\n \\n \\n \\n \\n sum=0\\n for i in range(len(l)):\\n sum+=int(l[i])\\n print(sum%1000000007)"}
{"id": "936", "input": "# cook your dish here\\nt=int(input())\\nfor i in range(t):\\n", "gt": "x=int(input())\\n if x%10==0:\\n print(0)\\n elif x%5==0:\\n print(1)\\n else:\\n print(-1)"}
{"id": "937", "input": "for _ in range(int(input())):\\n n=int(input())\\n a=[]\\n l=0\\n for i in range(n):\\n a.append(list(map(int,input().split())))\\n for i in range(n-1,0,-1):\\n", "gt": "r=a[i][i-1]+1\\n if a[i][i]!=r:\\n l+=1\\n n=i+1\\n for j in range(n):\\n for k in range(j,n):\\n a[j][k],a[k][j]=a[k][j],a[j][k]\\n \\n print(l)\\n"}
{"id": "938", "input": "# cook your dish here\\nt=int(input())\\nfor _ in range(t):\\n s=input()\\n k=len(s)\\n count=0\\n for i in range(k-1):\\n if(s[i]==\"C\"):\\n if(s[i+1]=='E'or s[i+1]=='S'", "gt": "or s[i+1]==\"C\"):\\n count+=1 \\n elif(s[i]==\"E\"):\\n if(s[i+1]==\"S\"or s[i+1]=='E'):\\n count+=1 \\n elif(s[i]==\"S\"):\\n if(s[i+1]==\"S\"):\\n count+=1 \\n if (count==k-1):\\n print(\"yes\")\\n else:\\n print(\"no\")"}
{"id": "939", "input": "t=int(input())\\nfor q in range(t):\\n n=int(input())\\n x=list(map(int,input().split()))\\n dic={}\\n dic2={}\\n for i in range(n):\\n dic2[x[i]]=1\\n #print dic2\\n if len(dic2)==n:\\n n+=2\\n print((n*(n-1)*(n-2)*(n-3))/24)\\n continue \\n counter=0\\n for i in range(n-1):\\n if x[i] in dic:\\n dic[x[i]]+=1\\n else:\\n dic[x[i]]=1\\n for", "gt": "j in range(i,n-1):\\n if x[j] in dic:\\n dic[x[j]]+=1\\n else:\\n dic[x[j]]=1\\n for p in range(j+1,n):\\n if x[p] in dic:\\n continue;\\n for q in range(p,n):\\n if x[q] in dic:\\n break\\n counter+=1\\n #print i,j,p,q\\n \\n dic.clear()\\n print(counter)"}
{"id": "940", "input": "lucky = {4, 774, 7, 744, 777, 74, 747, 44, 77, 47, 474, 444, 477, 447}\\nfrom functools import lru_cache\\nimport sys \\nsys.setrecursionlimit(10 ** 6)\\nmod = 10 ** 9 + 7\\nfact = [1]\\nfor i in range(1, 1001):\\n fact.append(fact[-1] * i % mod)\\ninv = [pow(i, mod-2, mod) for i in fact]\\nC = lambda k, n: fact[n] * inv[n-k] * inv[k] % mod\\ndef f(n):\\n n = [int(x) for x in n]\\n @lru_cache(None)\\n def dp(pos, cnt, free):\\n if cnt > 777:\\n return 0\\n diff = len(n) - pos \\n ans = 0\\n if free:\\n for i in lucky:\\n", "gt": "i -= cnt\\n if 0 <= i <= diff:\\n ans += C(i, diff) * pow(2, i, mod) * pow(8, diff - i, mod)\\n ans %= mod \\n return ans\\n if pos == len(n):\\n return int(cnt in lucky)\\n for i in range(10 if free else n[pos]+1):\\n ans += dp(pos+1, cnt + int(i == 4 or i == 7), free or i < n[pos])\\n ans %= mod \\n return ans \\n return dp(0, 0, 0)\\n \\nt = int(input())\\nfor _ in range(t):\\n l, r = input().split()\\n l = str(int(l) -1) \\n print((f(r) - f(l)) % mod)"}
{"id": "941", "input": "T=int(input())\\r\\nl=[]\\r\\nfor t in range(T):\\r\\n R=int(input())\\r\\n", "gt": "a=2*(R**2)\\r\\n l.append(a)\\r\\nfor s in l:\\r\\n print(s)"}
{"id": "942", "input": "try:\\n t=int(input())\\n while t>0:\\n [a,b]=[int(x) for x in input().split()]\\n if a==1 and b==1:\\n print(1)\\n continue\\n if a%2==0:\\n", "gt": "o1=a//2\\n e1=a//2\\n else:\\n o1=a//2+1\\n e1=a//2\\n \\n if b%2==0:\\n o2=b//2\\n e2=b//2\\n else:\\n o2=b//2+1\\n e2=b//2\\n \\n print(e1*e2+o1*o2)\\n t-=1\\nexcept:\\n pass"}
{"id": "943", "input": "# cook your dish here\\n# from queue import PriorityQueue\\n# import bisect\\ndef insort(l, v):\\n s = 0\\n e = len(l)\\n while True:\\n mid = (s+e)//2\\n if s == e or mid > len(l):\\n break\\n if l[mid][0] < v[0]:\\n s = mid+1\\n elif l[mid][0] > v[0]:\\n e = mid\\n else:\\n break\\n l.insert(mid, v)\\n \\nfor _ in range(int(input())):\\n n,l = map(int, input().split())\\n a_l = list(map(int, input().split()))\\n \\n dic = {}\\n dif = 0\\n for i,v in enumerate(a_l, start=1):\\n if v not in dic:\\n dic[v] = [i, i]\\n else:\\n dic[v][0] = min(dic[v][0], i)\\n dic[v][1] = max(dic[v][1], i)\\n dif = max(dif, dic[v][1]-dic[v][0])\\n \\n ans = dif\\n if l <= len(set(a_l)):\\n i_l = [[v,i] for i,v in enumerate(a_l, start=1)]\\n i_l.sort(reverse=True)\\n \\n dp = [[-1 for _ in range(l)] for _ in range(n)]\\n pq_l = [[] for _ in", "gt": "range(l)]\\n for i in range(1,n):\\n il = 1\\n dif_l = []\\n for j in range(i):\\n dif = abs(i_l[i][1]-i_l[j][1])\\n dif_l.append(dif)\\n dp[i][il] = max(dp[i][il], dif)\\n \\n for il in range(2,min(l,i+1)):\\n for prev_max, ind in reversed(pq_l[il-1]):\\n if ind == i:\\n continue\\n if prev_max < dp[i][il]:\\n break\\n else:\\n dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\\n insort(pq_l[il], [dp[i][il], i])\\n # tmp = [v[0] for v in pq_l[il]]\\n # ind = bisect.bisect_right(tmp, dp[i][il])\\n # pq_l[il].insert(ind, [dp[i][il], i])\\n \\n il = 1\\n insort(pq_l[il], [dp[i][il], i])\\n # tmp = [v[0] for v in pq_l[il]]\\n # ind = bisect.bisect_right(tmp, dp[i][il])\\n # pq_l[il].insert(ind, [dp[i][il], i])\\n \\n # print(i, pq_l, dif_l)\\n \\n \\n # dp[i][1] = max(dp[i][1], dif)\\n # for il in range(2,l):\\n # if dp[j][il-1] == -1:\\n # break\\n # dp[i][il] = max(dp[i][il], min(dif, dp[j][il-1]))\\n ans = max(ans, dp[i][-1])\\n # print(dp)\\n # print(dic)\\n print(ans)"}
{"id": "944", "input": "# cook your dish here\\nt=int(input())\\nfor i in range(t):\\n v,w=list(map(int,input().strip().split(\" \")))\\n if v==w:\\n print(v+1)\\n", "gt": "elif v<w:\\n print(v+1)\\n else:\\n print(w+1)\\n #s=\"a\"\\n #s=s*v\\n #l=list(s)\\n #print(l)\\n ct=0\\n #for i in range(w):\\n"}
{"id": "945", "input": "# cook your dish here\\nfrom sys import stdin, stdout\\nfrom collections import defaultdict\\nfor _ in range(int(stdin.readline())):\\n n=int(stdin.readline())\\n lst=list(map(int, stdin.readline().split()))\\n prefix_odd=[0]*n\\n prefix_even=[0]*n\\n odd_val=0\\n even_val=0\\n for i in range(n):\\n if lst[i]%2==0:\\n even_val+=1 \\n else:\\n odd_val+=1\\n prefix_even[i]=even_val\\n prefix_odd[i]=odd_val\\n #print(prefix_odd,prefix_even)\\n prefix_sum=[0]*n\\n s=0\\n for i in range(n):\\n s+=lst[i]\\n prefix_sum[i]=s\\n #print(prefix_sum)\\n dict={}\\n count={}\\n for i in range(n):\\n if lst[i] not in dict:\\n dict[lst[i]]=i\\n count[lst[i]]=1\\n else:\\n dict[lst[i]]=i\\n count[lst[i]]+=1\\n #print(dict)\\n graph=defaultdict(list)\\n for i in range(n):\\n graph[lst[i]].append(i)\\n max_sum=0\\n", "gt": "for i in graph:\\n if len(graph[i])>1:\\n prev=graph[i][0]\\n for j in range(1,len(graph[i])):\\n index2=graph[i][j]\\n index1=prev\\n prev=index2\\n #print(index1,index2)\\n if i%2==0:\\n val=prefix_even[index2]-prefix_even[index1]-1\\n #print(val)\\n if val%2==0:\\n temp_sum=prefix_sum[index2]-prefix_sum[index1]-i\\n #print(temp_sum)\\n if temp_sum>max_sum:\\n max_sum=temp_sum\\n else:\\n val=prefix_odd[index2]-prefix_odd[index1]-1\\n #print(val)\\n if val%2!=0:\\n temp_sum=prefix_sum[index2]-prefix_sum[index1]-i\\n #print(temp_sum)\\n if temp_sum>max_sum:\\n max_sum=temp_sum\\n\\n '''max_sum=-1\\n for i in range(n):\\n if count[lst[i]]>1:\\n index2=dict[lst[i]]\\n index1=i\\n print(index1,index2)\\n if lst[i]%2==0:\\n val=prefix_even[index2]-prefix_even[index1]-1\\n print(val)\\n if val%2==0:\\n temp_sum=prefix_sum[index2]-prefix_sum[index1]-lst[i]\\n print(temp_sum)\\n if temp_sum>max_sum:\\n max_sum=temp_sum\\n else:\\n val=prefix_odd[index2]-prefix_odd[index1]-1\\n print(val)\\n if val%2!=0:\\n temp_sum=prefix_sum[index2]-prefix_sum[index1]-lst[i]\\n print(temp_sum)\\n if temp_sum>max_sum:\\n max_sum=temp_sum'''\\n \\n stdout.write(str(max_sum)+'\\n')"}
{"id": "946", "input": "for i in", "gt": "range(int(input())):\\n n=int(input())\\n print(n//2+1)"}
{"id": "947", "input": "import sys\\nimport math\\n\\ndef main(arr):\\n \\n k=len(arr[0])\\n n=len(arr)\\n dp=[[0]*k for i in range(n+1)]\\n \\n summation_arr=[]\\n for i in range(len(arr)):\\n a=1 if i!=0 else 0\\n summation_arr.append(sum(arr[i])+a)\\n", "gt": "\\n for i in range(1,len(dp)):\\n for j in range(len(dp[0])):\\n dp[i][j]=(dp[i-1][j]+arr[i-1][j])/summation_arr[i-1]\\n ans=[]\\n \\n for i in range(k):\\n ans.append(dp[-1][i])\\n print(*ans)\\n\\n\\n \\nn,k=input().split()\\nn=int(n)\\narr=[]\\nfor i in range(n):\\n arr.append(list(map(int,input().split())))\\n(main(arr))\\n \\n \\n"}
{"id": "948", "input": "def codn1(s1,s2,p):\\r\\n c=0\\r\\n ind=0\\r\\n for i in range(len(s1)):\\r\\n if s1[i]!=s2[i]:\\r\\n c+=1\\r\\n ind=i\\r\\n if c>1 or ind==len(s1)-1:\\r\\n return 0\\r\\n if s1[ind]>s2[ind] and s1[ind] in s2[ind+1:]:\\r\\n p[0]=True\\r\\n if s1[ind]<s2[ind] and s2[ind] in s1[ind+1:]:\\r\\n p[1]=True\\r\\n return 1\\r\\n \\r\\ndef codn2(s1,s2):\\r\\n if len(s1)<len(s2):\\r\\n for i in range(len(s2)):\\r\\n if s2[:i]+s2[i+1:]==s1:\\r\\n return 1\\r\\n else:\\r\\n for i in range(len(s1)):\\r\\n if s1[:i]+s1[i+1:]==s2:\\r\\n", "gt": "return 2\\r\\n\\r\\n\\r\\ndef longest(k):\\r\\n if cost[k]>0:\\r\\n return cost[k]\\r\\n for i in list(d[k]):\\r\\n cost[k]=max(cost[k],longest(i)+1)\\r\\n return cost[k]\\r\\n\\r\\nn=int(input())\\r\\nl=[]\\r\\n#parent=[0]*n\\r\\nd="}
{"id": "949", "input": "from math import sqrt\\n\\na, b = map(int, input().split())\\npairs = 0\\n\\nfor i in range(1, a+1):\\n for j", "gt": "in range(1, b+1):\\n root = sqrt(i**2 + j)\\n\\n if not root - int(root):\\n pairs += 1\\n\\nprint(pairs)"}
{"id": "950", "input": "def check(l,n):\\n m = 0\\n for i in range(n-1):\\n x = l[i]\\n c = 0\\n j = i\\n while (j+2<n and l[j+2]==x) or (j+1<n and l[j+1] == x):\\n", "gt": "if l[j+1] == x:\\n j = j+1\\n else:\\n j+=2\\n c+=1\\n if m<c:\\n m = c\\n return m\\n\\nt = int(input())\\nfor _ in range(t):\\n no = int(input())\\n a = list(map(int,input().split()))\\n print(check(a,no))"}
{"id": "951", "input": "N = int(input())\\r\\ni = N + 1\\r\\nflag = 0\\r\\nfor i in range(N+1, 987654321):\\r\\n a = str(i)\\r\\n b = list(a)\\r\\n c = set(a)\\r\\n", "gt": "if '0' not in b:\\r\\n if len(b) == len(c):\\r\\n print(i)\\r\\n flag += 1\\r\\n break\\r\\n \\r\\nif flag < 1:\\r\\n print(0)\\r\\n \\r\\n \\r\\n \\r\\n"}
{"id": "952", "input": "import math\\r\\nfrom itertools import permutations as p\\r\\ndef diff(li1, li2): \\r\\n li_dif = [i for i in li1 if i not in li2]\\r\\n return li_dif \\r\\ndef segments(b):\\r\\n \"\"\"A sequence of (x,y) numeric coordinates pairs \"\"\"\\r\\n poly = [(i[0],i[1]) for i in b]\\r\\n return zip(poly, poly[1:] + [poly[0]])\\r\\ndef perimeter(poly):\\r\\n \"\"\"A sequence of (x,y) numeric coordinates pairs \"\"\"\\r\\n return abs(sum(math.hypot(x0-x1,y0-y1) for ((x0, y0), (x1, y1)) in segments(poly)))\\r\\ndef av(b):\\r\\n return", "gt": "sum([i[3] for i in b])\\r\\ndef val(b):\\r\\n return sum([i[2] for i in b])\\r\\nfor _ in range(int(input())):\\r\\n b = []\\r\\n for _ in range(int(input())):\\r\\n b.append(list(map(int,input().split())))\\r\\n perm = []\\r\\n for i in range(1,len(b)):\\r\\n for e in p(b,i):\\r\\n perm.append(e)\\r\\n perm.sort(key=lambda x:val(x))\\r\\n yes = []\\r\\n for i in perm:\\r\\n if av(i)>=perimeter(diff(b,i)):\\r\\n good = val(i)\\r\\n yes.append(i)\\r\\n break\\r\\n #yes.sort(key = lambda x: len(x))\\r\\n print(\" \".join([str(b.index(i)+1) for i in yes[0]]))\\r\\n x = round(av(yes[0])-perimeter(diff(b,yes[0])),2)\\r\\n print(f'"}
{"id": "953", "input": "# cook your dish here\\r\\nstr1=int(input())\\r\\nfor i in range(str1):\\r\\n l1=[]\\r\\n str2=input()\\r\\n for i in str2:\\r\\n l1.append(i)\\r\\n \\r\\n count=0\\r\\n d=dict()\\r\\n d={'a':1,'b':2,'c':3,'d':4,'e':5,'f':6,'g':7,'h':8,'i':9,'j':10,'k':11,'l':12,'m':13,'n':14}\\r\\nd1={'o':15,'p':16,'q':17,'r':18,'s':19,'t':20", "gt": ",'u':21,'v':22,'w':23,'x':24,'y':25,'z':26}"}
{"id": "954", "input": "# cook your dish here\\nimport sys\\ndef get_array(): return list(map(int , sys.stdin.readline().strip().split()))\\ndef get_ints(): return list(map(int, sys.stdin.readline().strip().split()))\\ndef input(): return sys.stdin.readline().strip()\\nimport math\\nfrom collections import defaultdict\\nfrom itertools import combinations_with_replacement,permutations\\nimport bisect\\nimport math as mt \\nfrom functools import reduce\\nimport time\\n\\ndef __starting_point():\\n for _ in", "gt": "range(int(input())):\\n n = int(input())\\n a=1\\n b=1\\n c=(-2*n)\\n dis = b * b - 4 * a * c \\n sqrt_val = math.sqrt(abs(dis))\\n r1=(-b + sqrt_val)/(2 * a)\\n # r2=(-b - sqrt_val)/(2 * a)\\n\\n # print(r1)\\n r1 = math.floor(r1)+1\\n print(n-r1+1)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n__starting_point()"}
{"id": "955", "input": "t=int(input())\\r\\nwhile(t!=0):\\r\\n t=t-1\\r\\n n=int(input())\\r\\n ans=0\\r\\n for i in range(1,n+1,1):\\r\\n sum=0;\\r\\n for", "gt": "j in range(1,i+1,1):\\r\\n sum=sum+j\\r\\n s=sum-i\\r\\n sum=sum+s\\r\\n if(i!=n):\\r\\n ans=ans+2*sum*i\\r\\n else:\\r\\n ans=ans+sum*i\\r\\n print(ans)"}
{"id": "956", "input": "isPrime=[1 for i in range(10001)]\\ncnt=[0 for i in range(10001)]\\nisPrime[0]=0\\nisPrime[1]=0\\nprime=[]\\nfor i in range(2,10001):\\n if isPrime[i]:\\n prime.append(i)\\n for j in range(i*i,10001,i):\\n isPrime[j]=0\\n#print(prime)\\nfor", "gt": "i in prime:\\n for j in prime:\\n if (i + 2*j)>10000:\\n break\\n else:\\n cnt[i + 2*j]+=1\\n#print(le)\\nfor _ in range(int(input())):\\n n=int(input())\\n print(cnt[n])"}
{"id": "957", "input": "# cook your dish here\\nn=int(input())\\nx=[]\\ny=[]\\nfor _ in range(n):\\n s=input().split(' ')\\n x.append(int(s[0]))\\n", "gt": "y.append(int(s[1]))\\nq=x[0]\\nw=y[0]\\nfor t in range(n-1):\\n x[t]=(x[t]+x[t+1])/2 \\n y[t]=(y[t]+y[t+1])/2 \\nx[n-1]=(x[n-1]+q)/2 \\ny[n-1]=(y[n-1]+w)/2 \\ni=0\\na=0\\nwhile(i<n-1):\\n a+=(x[i]*y[i+1]-y[i]*x[i+1])/2\\n i+=1\\na+=(x[i]*y[0]-y[i]*x[0])/2\\n\\nprint(abs(a))\\n#print(x,y)\\n"}
{"id": "958", "input": "n = int(input())\\nfor i in range(n) :\\n t = int(input())\\n li = sorted(list(map(int , input().split())))\\n ans = 1\\n dp = [li[1]-li[0]] + [0]", "gt": "* (t-2) + [li[t-1] - li[t-2]]\\n for i in range(1 , t-1) :\\n dp[i] = min(li[i] - li[i-1] , li[i+1] - li[i])\\n print(max(dp))\\n"}
{"id": "959", "input": "from sys import stdin, stdout\\r\\nfrom collections import Counter\\r\\nn = int(stdin.readline())\\r\\n#l = list(map(int, stdin.readline().split()))\\r\\n#l = [int(stdin.readline()) for _ in range(n)]\\r\\n#a, b = map(int, stdin.readline().split())\\r\\nfor _ in range(n):\\r\\n n1 =", "gt": "int(stdin.readline())\\r\\n if n1==1:\\r\\n print('*')\\r\\n else:\\r\\n a = n1+(n1-1)\\r\\n s = 0\\r\\n for x in range(1,n1):\\r\\n if x==1:\\r\\n print(' '*(n1-1)+'*'+' '*(n1-1))\\r\\n s+=1\\r\\n else:\\r\\n print(' '*(n1-x)+'*'+' '*(s)+'*')\\r\\n s+=2\\r\\n #print()\\r\\n print('*'*(a))\\r\\n \\r\\n"}
{"id": "960", "input": "for i in range(int(input())):\\n n=int(input())\\n m=list(map(int,input().split()))[:n]\\n m.sort()\\n", "gt": "t=0\\n for j in range(n//2):\\n t+=abs(m[j]-m[n-j-1])\\n print(t)\\n"}
{"id": "961", "input": "t = int(input())\\r\\n\\r\\nfor _ in range(t):\\r\\n k = int(input())\\r\\n count = 1\\r\\n for _", "gt": "in range(k):\\r\\n output = []\\r\\n for index in range(1,k+1):\\r\\n output.append(bin(count).replace(\"0b\", \"\"))\\r\\n count += 1\\r\\n print(*output)"}
{"id": "962", "input": "# cook your dish here\\ndef mergeSort(arr, n): \\n # A temp_arr is created to store \\n # sorted array in merge function \\n temp_arr = [0]*n \\n return _mergeSort(arr, temp_arr, 0, n-1) \\n \\n# This Function will use MergeSort to count inversions \\n \\ndef _mergeSort(arr, temp_arr, left, right): \\n \\n # A variable inv_count is used to store \\n # inversion counts in each recursive call \\n \\n inv_count = 0\\n \\n # We will make a recursive call if and only if \\n # we have more than one elements \\n \\n if left < right: \\n \\n # mid is calculated to divide the array into two subarrays \\n # Floor division is must in case of python \\n \\n mid = (left + right)//2\\n \\n # It will calculate inversion \\n # counts in the left subarray \\n \\n inv_count += _mergeSort(arr, temp_arr, \\n left, mid) \\n \\n # It will calculate inversion \\n # counts in right subarray \\n \\n inv_count += _mergeSort(arr, temp_arr, \\n mid + 1, right) \\n \\n # It will merge two subarrays in \\n # a sorted subarray \\n \\n inv_count += merge(arr, temp_arr, left, mid, right) \\n return inv_count \\n \\n# This function will merge two subarrays \\n# in a single sorted subarray \\ndef merge(arr, temp_arr, left, mid, right):", "gt": "\\n i = left # Starting index of left subarray \\n j = mid + 1 # Starting index of right subarray \\n k = left # Starting index of to be sorted subarray \\n inv_count = 0\\n \\n # Conditions are checked to make sure that \\n # i and j don't exceed their \\n # subarray limits. \\n \\n while i <= mid and j <= right: \\n \\n # There will be no inversion if arr[i] <= arr[j] \\n \\n if arr[i] <= arr[j]: \\n temp_arr[k] = arr[i] \\n k += 1\\n i += 1\\n else: \\n # Inversion will occur. \\n temp_arr[k] = arr[j] \\n inv_count += (mid-i + 1) \\n k += 1\\n j += 1\\n \\n # Copy the remaining elements of left \\n # subarray into temporary array \\n while i <= mid: \\n temp_arr[k] = arr[i] \\n k += 1\\n i += 1\\n \\n # Copy the remaining elements of right \\n # subarray into temporary array \\n while j <= right: \\n temp_arr[k] = arr[j] \\n k += 1\\n j += 1\\n \\n # Copy the sorted subarray into Original array \\n for loop_var in range(left, right + 1): \\n arr[loop_var] = temp_arr[loop_var] \\n \\n return inv_count \\n \\nfor _ in range(int(input())):\\n n = int(input())\\n a = list(map(int,input().split()))\\n print(mergeSort(a, n) )"}
{"id": "963", "input": "for _ in range(int(input())):\\n n = int(input())\\n s = ''\\n for i in range(1, n + 1): s += str(i)\\n for i in range(n, 0, -1):\\n if", "gt": "i % 2 == 0:\\n for j in range(i, 0, -1): print(j, end = '')\\n else:\\n for j in range(1, i + 1): print(j, end = '')\\n print()\\n\\n\\n"}
{"id": "964", "input": "def solve(l):\\r\\n m = l.index(max(l))\\r\\n if m == 0 or m == len(l) - 1:\\r\\n return 1\\r\\n", "gt": "return 1 + min(solve(l[0:m]), solve(l[m+1:]))\\r\\n\\r\\ntc = int(input())\\r\\nfor test in range(tc):\\r\\n n = int(input())\\r\\n l = list(map(int, input().split()))\\r\\n print(solve(l))"}
{"id": "965", "input": "import fractions\\nfor t in range(int(input())):\\n h,u,d = list(map(int,input().split()))\\n g = fractions.gcd(u,d)\\n if (h%g!=0):\\n print(-1)\\n else:\\n m =", "gt": "0\\n n = 0\\n while (True):\\n n = (float(m)*u-h)/d\\n if (n>0 and int(n) == n):\\n break\\n m+=1\\n print(int(m+n))"}
{"id": "966", "input": "# cook your dish here\\ntry:\\n t = int(input())\\n for _ in range(t):\\n n,", "gt": "k = map(int, input().split())\\n if k == 0:\\n print(0, n)\\n else:\\n print(n//k, n%k)\\nexcept:\\n pass"}
{"id": "967", "input": "for _ in range(int(input())):\\n N,U,D=list(map(int,input().split()))\\n H=list(map(int,input().split()))\\n jumps=0\\n paracount=0\\n for i in range(len(H)-1):\\n if H[i+1]-H[i]<=U and", "gt": "H[i+1]>=H[i]:\\n jumps+=1\\n elif H[i]>=H[i+1] and H[i]-H[i+1]<=D:\\n jumps+=1\\n elif H[i]-H[i+1]>D and paracount==0:\\n jumps+=1\\n paracount=1\\n else: break\\n print(jumps+1)\\n"}
{"id": "968", "input": "try:\\n def countsubsetsum(S,arr,n):\\n k=[[0 for i in range(S+1)] for i in range(n+1)]\\n for i in range(n+1):\\n for j in range(S+1):\\n if(j==0):\\n k[i][j]=1\\n elif(i==0):\\n k[i][j]=0\\n elif(arr[i-1]<=j):\\n", "gt": "k[i][j]=k[i-1][j-arr[i-1]]+k[i-1][j]\\n else:\\n k[i][j]=k[i-1][j]\\n return k[n][S]\\n for _ in range(int(input())):\\n m=int(input())\\n S=int(input()) \\n arr=[int(i) for i in input().split()]\\n \\n n=len(arr)\\n\\n print(countsubsetsum(S, arr, n))\\nexcept EOFError as e:\\n pass"}
{"id": "969", "input": "import sys\\nn = eval(input())\\nparents = [int(x)-1 for x in input().split(' ')]\\nvalues = list(map(int , input().split(' ')))\\nparents = [0]+parents\\n# print(parents)\\n# print(values)\\ndef single_node_cost(i):\\n cost = 0\\n # print('started with ',i)\\n", "gt": "min_value = sys.maxsize\\n while i != 0:\\n min_value = min(min_value,values[i])\\n cost += min_value\\n # print(i,min_value)\\n i = parents[i]\\n cost += min(values[0],min_value)\\n return cost\\nfor i in range(n):\\n print(single_node_cost(i), end=' ')"}
{"id": "970", "input": "for i in range(int(input())):\\n n,k=input().split()\\n laddus=0\\n for j in range(int(n)):\\n t=input().split()\\n if t[0]=='CONTEST_WON':\\n if(int(t[1])<=20):\\n laddus+=300+20-int(t[1])\\n", "gt": "else:\\n laddus+=300\\n elif t[0]=='TOP_CONTRIBUTOR':\\n laddus+=300\\n elif t[0]=='BUG_FOUND':\\n laddus+=int(t[1])\\n elif t[0]=='CONTEST_HOSTED':\\n laddus+=50\\n if(k=='INDIAN'):\\n print(laddus//200)\\n else:\\n print(laddus//400)"}
{"id": "971", "input": "def posSearch(arr, num):\\n l = 0\\n r = len(arr)\\n if num < arr[l]:\\n return 0\\n elif num > arr[r-1]:\\n return r\\n while l < r:\\n m = (l+r)//2\\n if arr[m] == num:\\n return -1\\n if arr[m] < num < arr[m+1]:\\n return m+1\\n if arr[m]", "gt": "> num:\\n r = m\\n elif arr[m] < num:\\n l = m+1 \\n \\nfor _ in range(int(input())):\\n n = int(input())\\n narr = list(map(int, input().split()))\\n q = int(input())\\n for i in range(q):\\n x, y = list(map(int, input().split()))\\n a = x+y\\n j = posSearch(narr, a)\\n print(j)\\n \\n"}
{"id": "972", "input": "for _ in range(int(input())):\\n n=int(input())\\n a=[int(z) for z in input().split()]\\n m=0\\n", "gt": "a1=list(set(a))\\n for i in range(len(a1)):\\n if a.count(a1[i])>m:\\n m=a.count(a1[i])\\n print(n-m)\\n \\n \\n"}
{"id": "973", "input": "try:\\n a=list(map(int,input().split()))\\n n=a[0]\\n k=a[1]\\n hi=[]\\n for i in range(n):\\n", "gt": "hi.append(int(input()))\\n hi.sort()\\n diff=[]\\n for i in range(n-k+1):\\n diff.append(hi[i+k-1]-hi[i])\\n print(min(diff))\\nexcept:\\n pass"}
{"id": "974", "input": "# cook your dish here\\ntestcases=int(input())\\n\\nfor _ in range(testcases):\\n (N,K)=list(map(int,input().split()))\\n array=list(map(int,input().split()))\\n \\n max=array[0]\\n min=array[0]\\n \\n for", "gt": "i in array:\\n if i>max:\\n max=i\\n if i<min:\\n min=i\\n \\n max=max+K \\n min=min-K\\n \\n print(abs(max-min))"}
{"id": "975", "input": "for _ in range(int(input())):\\r\\n a,b,c,d=list(map(int,input().split()))\\r\\n if(a==b):\\r\\n print('YES')\\r\\n", "gt": "elif(c==d):\\r\\n print('NO')\\r\\n \\r\\n else:\\r\\n if(abs(a-b)%abs(c-d)==0):\\r\\n print('YES')\\r\\n else:\\r\\n print('NO')\\r\\n"}
{"id": "976", "input": "for _ in range(int(input())):\\n n,r,x,y=map(int,input().split())\\n if x>0:\\n a=list(map(int,input().split()))\\n if y>0:\\n b=list(map(int,input().split()))\\n", "gt": "if x>0 and y>0:\\n a=a+b\\n c=n-len(list(set(a)))\\n else:\\n l=x+y\\n c=n-l\\n x=min(c,r)\\n print(x)"}
{"id": "977", "input": "# cook your dish here\\nn=int(input())\\nstringa=list(map(int,input().split()))\\ncounter=0\\ncounter1=0\\ncounter3=0\\nsomma1=0\\nsomma2=0\\nmassimo=0\\nmassimo1=0\\nmassimo3=0 \\nstack=[]\\nfor par in stringa:\\n if par==1 or par==3:\\n if counter1==0 and par==1:\\n counter1=1\\n somma1=1\\n massimo1=max(massimo1, 1)\\n elif counter1>0:\\n counter1+=1 \\n somma1+=1\\n massimo1=max(massimo1, somma1)\\n if counter3==0 and par==3:\\n counter3=1\\n somma3=1\\n massimo3=max(massimo3, 1)\\n elif counter3>0:\\n counter3+=1\\n somma3+=1\\n", "gt": "massimo3=max(massimo3, somma3)\\n if counter==0:\\n counter=1 \\n massimo=max(massimo,1)\\n if len(stack)>0 and par!=stack[-1]:\\n counter+=1 \\n massimo=max(massimo,counter)\\n stack.append(par)\\n else:\\n if counter1>0:\\n counter1-=1 \\n somma1+=1\\n massimo1=max(massimo1, somma1)\\n if counter3>0:\\n counter3-=1 \\n somma3+=1\\n massimo3=max(massimo3, somma3)\\n appo=stack.pop()\\n if len(stack)>0 and appo==stack[-1]:\\n pass\\n else:\\n counter-=1\\nprint(massimo, massimo1, massimo3)\\n"}
{"id": "978", "input": "# cook your dish here\\ntry:\\n for _ in range(int(input())):\\n n = int(input())\\n li = [i for i in input()]\\n a = 0\\n while a+1<len(li):\\n li[a],li[a+1] = li[a+1],li[a]\\n", "gt": "a+=2\\n li2 = li.copy()\\n for i in li2:\\n fh = 109\\n sh = 110\\n li.remove(i)\\n if ord(i)>fh:\\n li.append(chr(fh-(ord(i)-sh)))\\n else:\\n li.append(chr(sh+(fh-ord(i))))\\n for i in li:\\n print(i,end=\"\")\\n print()\\nexcept:\\n pass"}
{"id": "979", "input": "for i in range(int(input())):\\n n=int(input())\\n if(n<=2 or n>1000000007):\\n print(\"0\")\\n", "gt": "else:\\n prod=1\\n for i in range(2,n):\\n prod*=i\\n if(prod>1000000007):\\n prod=prod%1000000007\\n print(((prod)*(n*prod-2))%1000000007)\\n"}
{"id": "980", "input": "def for1(M,k):\\n ret = 0.0\\n x = k*k+0.0\\n z=x\\n for m in range(1,M):\\n ret+=(M-m)/x\\n x*=z\\n return ret \\n \\ndef for2(M,k):\\n ret", "gt": "= 0.0\\n x = k+0.0\\n for m in range(1,M):\\n ret+=(M-m)/x\\n \\n x*=k\\n return ret \\n \\ndef ans(M,N,K):\\n\\n return int(round(M*N+M*for2(N,K)+N*for2(M,K)+K*for1(M,K)*for1(N,K),0))\\nM,N,K = list(map(int,input().split()))\\nprint(ans(M,N,K)) \\n"}
{"id": "981", "input": "for t in range(int(input())):\\n n,b,m = list(map(int,input().split()))\\n ans = 0\\n while n>0:\\n", "gt": "ans+=b\\n half = (n+1)/2 if n%2 else n/2\\n ans+=m*half\\n m*=2\\n n=n-half\\n print(ans-b)\\n \\n"}
{"id": "982", "input": "t=eval(input())\\nfor q in range(t):\\n l=eval(input())\\n a=input().split()\\n a=[int(x) for x", "gt": "in a]\\n a=sorted(a)\\n for i in range(l-1):\\n a[i]=(a[i+1]-a[i]) \\n print(min(a[0:l-1]))\\n"}
{"id": "983", "input": "# cook your code here\\nn=input()\\nx=len(n)\\nno=list(map(int,n))\\ntemp=[0]*x\\nif (x>2):\\n sum=99\\n for i in range(3,x):\\n sum=sum+90\\n sum=sum+10*(int(n[0])-1)\\n sum=sum+int(n[1])\\n f=int(n[0])%10\\n \\n s=int(n[1])%10\\n", "gt": "\\n cd=s-f\\n \\n temp[0]=n[0]\\n temp[1]=n[1]\\n for i in range(2,x):\\n nxt=(s+cd)%10\\n temp[i]=(chr(nxt+48))\\n s=nxt\\n temp=list(map(int,temp))\\n if(temp<=no):\\n sum=sum+1\\n print(sum)\\nelse:\\n print(n)"}
{"id": "984", "input": "import sys\\r\\n\\r\\nn = int(sys.stdin.readline().strip())\\r\\ns = sys.stdin.readline().strip()\\r\\n\\r\\nalph = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\r\\n\\r\\narr = [0]*26\\r\\npref = []\\r\\n\\r\\nfor i in range(len(s)):\\r\\n for j in range(26):\\r\\n if alph[j] == s[i]:\\r\\n arr[j] += 1\\r\\n break\\r\\n pref += [arr[:]]\\r\\n\\r\\n# for x in pref:\\r\\n# print(x)\\r\\n\\r\\nq = int(sys.stdin.readline().strip())\\r\\n\\r\\nfor _ in range(q):\\r\\n r, c = sys.stdin.readline().strip().split()\\r\\n\\r\\n for i in range(26):\\r\\n if alph[i] == c:\\r\\n ind = i\\r\\n break\\r\\n\\r\\n r = int(r)\\r\\n\\r\\n", "gt": "prev = ((r-1)**2 + r-1)//2\\r\\n\\r\\n done = prev%len(s)\\r\\n\\r\\n ans = 0\\r\\n rem = (len(s) - done)%len(s)\\r\\n\\r\\n if r <= rem:\\r\\n print(pref[done+r-1][ind] - pref[done-1][ind])\\r\\n continue\\r\\n\\r\\n if rem != 0:\\r\\n ans += pref[-1][ind] - pref[done-1][ind]\\r\\n r -= rem\\r\\n\\r\\n ans += pref[-1][ind] * (r//len(s))\\r\\n r %= len(s)\\r\\n\\r\\n # print(\"AA\", ans, r)\\r\\n\\r\\n if r != 0:\\r\\n ans += pref[r-1][ind]\\r\\n\\r\\n print(ans)\\r\\n\\r\\n\\r\\n # print(rem, done, prev)\\n"}
{"id": "985", "input": "t = int(input())\\nfor i in range(t):\\n n = int(input())\\n l = list(map(int, input().split()))\\n counter = 0\\n even = 0\\n for num in", "gt": "l:\\n if num % 2 == 0:\\n even += 1 \\n if num % 2 == 1:\\n counter += even\\n print(counter)\\n \\n"}
{"id": "986", "input": "# coding: utf-8\\n# Your code here!\\n\\nn=int(input())\\na=[]\\nfor i in range(n):\\n x=int(input())\\n a.append(x)\\n \\n# print(a)\\nans=0\\nm=[1]*n\\nfor", "gt": "i in range(n):\\n for j in range(i):\\n if a[i]%a[j]==0:\\n m[i]=max(m[i],m[j]+1)\\n \\n \\n \\nprint(max(m))"}
{"id": "987", "input": "t = int(input())\\nwhile t> 0:\\n t =t -1\\n n,k = list(map(int,input().split()))\\n a = [0]*n\\n done = True\\n\\n def swap(z):\\n for j in range(0,n):\\n if a[j] == 0:\\n a[j] = z\\n done = True\\n break\\n else:\\n if a[j] > z:\\n swap(j)\\n a[j] = z\\n else:\\n done = False\\n break\\n\\n for i in range(0,n):\\n for j in range(0,n):\\n if abs(i-j) == k:\\n if a[j] == 0:\\n a[j] = i + 1\\n done = True\\n break\\n else:\\n if a[j] > i + 1:\\n swap(a[j])\\n a[j] = i + 1\\n", "gt": "else:\\n done = False\\n\\n if 0 in a:\\n print('CAPTAIN AMERICA EVADES')\\n else:\\n if done:\\n for c in a:\\n print(c, end=' ')\\n print()\\n else:\\n print('CAPTAIN AMERICA EVADES')\\n\\n\\n # for i in range(1,n+1):\\n # if i - k >=0 :\\n # if a[abs(i-k-1)] == 0:\\n # a[abs(i-k-1)] = i\\n # done = True\\n # else:\\n # done = False\\n # break\\n # else:\\n # done = False\\n # break\\n # if done:\\n # for c in a:\\n # print c,\\n # print\\n # else:\\n # print \"CAPTAIN AMERICA EVADES\"\\n"}
{"id": "988", "input": "for i in range(int(input())):\\n finish,distanetobolt,tigerAcceleration,boltspeed=map(int,input().split())\\n t1=((2*(finish+distanetobolt)/(tigerAcceleration))**0.5)\\n t2=(finish/boltspeed)\\n", "gt": "if t1>t2:\\n print(\"Bolt\")\\n elif t1<t2:\\n print(\"Tiger\")\\n else:\\n print(\"Tiger\")"}
{"id": "989", "input": "# cook your dish here\\n# cook your dish here\\ntest=int(input())\\nfor _ in range(test):\\n n=int(input())\\n a=[(bin(int(x))[2:][::-1]+(\"0\")*32)for x in input().split()]\\n res=\"\"\\n mysum=0\\n", "gt": "for i in range(32):\\n mycount=0\\n for j in range(n):\\n if(a[j][i]==\"0\"):\\n mycount+=1\\n if(mycount==n):\\n break\\n if(mycount>(n//2)):\\n res+=\"0\"\\n mysum+=(n-mycount)*int(pow(2,i))\\n else:\\n res+=\"1\"\\n mysum+=mycount*int(pow(2,i))\\n print(mysum)"}
{"id": "990", "input": "n=int(input())\\nwhile(n>0):\\n x,y,z=map(int,input().split())\\n t=(x+y)//z\\n if", "gt": "t%2==0:\\n print('Chef')\\n else:\\n print('Paja')\\n n-=1"}
{"id": "991", "input": "try:\\r\\n n,m,a=map(int,input().split())\\r\\n if n%a!=0:\\r\\n number1=(n//a)+1\\r\\n else:\\r\\n number1=(n//a)\\r\\n", "gt": "if m%a!=0:\\r\\n number2=(m//a)+1\\r\\n else:\\r\\n number2=(m//a)\\r\\n print(number1*number2)\\r\\nexcept:\\r\\n pass"}
{"id": "992", "input": "n,k, q = list(map(int, input().split()))\\nmod = 10 ** 9 + 7\\nA = [0] * n\\na, b, c, d, e, f, r, s, t, m, x = list(map(int, input().split())) \\nA[0] = x \\n\\nfor x in range(1, n):\\n if pow(t, x+1, s) <= r:\\n A[x] = (a*pow(A[x-1], 2, m) + b*A[x-1] + c) % m\\n else:\\n A[x] = (d*pow(A[x-1], 2, m) + e*A[x-1] + f) % m\\n \\ndef SRMQ(arr, k):\\n from collections import deque\\n n = len(arr)\\n ans = [None] * n\\n deque = deque()\\n for i in range(len(arr)):\\n while deque and deque[-1] > arr[i]:\\ndeque.pop()\\n deque.append(arr[i])\\n if i >= k and arr[i-k] == deque[0]:\\n deque.popleft()\\n if i >= k-1:\\n ans[i-k+1] = deque[0]\\n return ans\\n \\nv = SRMQ(A, k) \\n\\nL1, La, Lc, Lm, D1, Da, Dc, Dm = list(map(int, input().split()))\\ns = 0 \\nprod = 1 \\nfor _ in range(q):\\n L1 = (La * L1 + Lc) % Lm;\\n D1 = (Da *", "gt": "D1 + Dc) %Dm;"}
{"id": "993", "input": "from math import sqrt\\nimport sys\\nsys.setrecursionlimit(10**8)\\nintMax = 10**18\\ndef knapsack(rl,l,c,m):\\n if m==0 and rl>0:\\n return intMax\\n if rl<=0:\\n return 0\\n return min(c[m-1]+knapsack(rl-l[m-1],l,c,m),knapsack(rl,l,c,m-1))\\nfor _ in range(int(input())):\\n n= int(input())\\n cost=[]\\n length=[]\\n sides=[]\\n for i in range(n):\\n x,y = map(int,input().split())\\n if i == 0:\\n x0 = x\\n y0 = y\\n prevx =", "gt": "x\\n prevy = y\\n elif i == n-1:\\n sides.append(sqrt((prevx-x)**2 + (prevy-y)**2))\\n sides.append(sqrt((x0-x)**2 + (y0-y)**2))\\n else:\\n sides.append(sqrt((prevx-x)**2 + (prevy-y)**2))\\n prevx = x\\n prevy = y\\n m = int(input())\\n for j in range(m):\\n li,ci = map(int,input().split())\\n length.append(li)\\n cost.append(ci)\\n ans=0\\n #print(sides)\\n for k in sides:\\n ans= ans + knapsack(k,length,cost,m)\\n print(int(ans))"}
{"id": "994", "input": "import math\\r\\n\\r\\ndef check(s):\\r\\n if s==2:\\r\\n return 1\\r\\n \\r\\n for i in range(2,math.ceil(math.sqrt(s))+1):\\r\\n if s%i == 0:\\r\\n return 0\\r\\n \\r\\n return 1\\r\\n \\r\\n\\r\\ndef Solve(slots):\\r\\n if slots<3:\\r\\n return 0\\r\\n \\r\\n", "gt": "#check\\r\\n s = math.sqrt(slots)\\r\\n if math.floor(s) == math.ceil(s):\\r\\n return check(s)\\r\\n \\r\\n return 0\\r\\n\\r\\n\\r\\nN = int(input())\\r\\n\\r\\nfor t in range(N):\\r\\n \\r\\n slots = int(input())\\r\\n \\r\\n if (Solve(slots)):\\r\\n print(\"YES\")\\r\\n \\r\\n else:\\r\\n print(\"NO\")"}
{"id": "995", "input": "# cook your dish here\\nimport sys\\ninput=sys.stdin.readline\\nfor _ in range(int(input())):\\n n,x=list(map(int,input().split()))\\n l=[0]\\n pre=[0]*(n+1)\\n sum=0\\n i=1\\n for m in input().split():\\n l.append(int(m))\\n sum+=int(m)\\n pre[i]=sum\\n i+=1\\n dict={}\\n k=[]\\n i=1\\n while (i*i)<=x:\\n if x%i==0:\\n k.append(i)\\n if (i*i)!=x:\\n k.append(x//i)\\n else:\\n break\\n i+=1 \\n ans=0 \\n for a in k:\\n if", "gt": "a>n:\\n continue\\n z=x//a \\n for j in range(a,n+1):\\n s=pre[j]-pre[j-a]\\n if s>z:\\n continue\\n if s in dict:\\n dict[s]+=1\\n else:\\n dict[s]=1\\n for j in range(a,n+1):\\n s=pre[j]-pre[j-a]\\n if s>z:\\n continue\\n if (z-s) in dict:\\n ans+=dict[z-s]\\n for j in range(a,n+1):\\n s=pre[j]-pre[j-a]\\n if s>z:\\n continue\\n dict[s]=0\\n \\n print(ans) \\n \\n"}
{"id": "996", "input": "rooms=int(input())\\r\\nmoney=list(map(int,input().split()))\\r\\nkeys=int(input())\\r\\nrev=-1\\r\\na,b=0,-1\\r\\ntot=[]\\r\\n#print(money[-3:-1])\\r\\nx=0\\r\\nfor i in range(keys):\\r\\n", "gt": "#print(money[b:-1],money[0:a])\\r\\n x=sum(money[b:])+sum(money[0:keys-abs(b)])\\r\\n tot.append(x)\\r\\n b-=1\\r\\nprint(max(tot))\\r\\n"}
{"id": "997", "input": "s1=s2=lead=0\\nmlead1=mlead2=0\\nfor _ in range(int(input())):\\n x, y= list(map(int, input().split()))\\n s1, s2= s1+x, s2+y\\n if(s1>s2):\\n", "gt": "lead=(s1-s2)\\n mlead1= max(mlead1, lead)\\n else:\\n lead=(s2-s1)\\n mlead2= max(mlead2, lead)\\nif(mlead1<(mlead2)):\\n print('2', mlead2)\\nelse:\\n print('1', mlead1)\\n\\n"}
{"id": "998", "input": "try:\\n t=int(input())\\n for a in range(t):\\n l=input().split()\\n n=int(l[0])\\n m=int(l[1])\\n d={}\\n s=0\\n for b in range(m):\\n l1=input().split()\\n i=int(l1[0])\\n j=int(l1[1])\\n k=int(l1[2])\\n for", "gt": "c in range(i,j+1):\\n if c not in d:\\n d[c]=10\\n for c in range(i,j+1):\\n d[c]=d[c]*k\\n for i in d:\\n s=s+d[i]\\n print(s//n)\\nexcept:\\n pass"}
{"id": "999", "input": "n,q=map(int,input().split())\\ndr={}\\ndc={}\\nfor i in range(1,n+1):\\n dr[i]=0\\n dc[i]=0\\nmer=0\\nmec=0\\nfor i in range(q):\\n s,j,k=input().split()\\n j=int(j)\\n k=int(k)\\n if s==\"RowAdd\":\\n dr[j]+=k\\n if dr[j]>mer:\\n mer=dr[j]\\n", "gt": "else:\\n dc[j]+=k\\n if mec<dc[j]:\\n mec=dc[j]\\n# m=max(list(dr.values()))+max(list(dc.values()))\\n\\n# for i in range(n):\\n# for j in range(n):\\n# ar[i][j]=dr[i+1]+dc[j+1]\\n# if ar[i][j]>m:\\n# m=ar[i][j]\\n\\nprint(mer+mec)"}
{"id": "1000", "input": "try:\\n for _ in range(int(input())):\\n k=int(input())\\n for i in range(1,k+1):\\n print(\" \"*(k-i),end=\"\")\\n if i%2==1:\\n", "gt": "for j in range(0,i):\\n print(chr(65+j),end=\"\")\\n else:\\n for j in range(0,i):\\n print(j+1,end=\"\")\\n print()\\n \\n \\nexcept:\\n pass"}
{"id": "1001", "input": "# cook your dish here\\nfrom math import", "gt": "ceil\\nfor _ in range(int(input())):\\n n=int(input())\\n a=list(map(int,input().split()))\\n ans=ceil(n/min(a))\\n print(int(ans))"}
{"id": "1002", "input": "for _ in range(int(input())):\\n n=int(input())\\n a=list(map(int,input().split()))\\n g=1\\n for j in range(1,n):\\n if", "gt": "j-5<0:\\n mi=min(a[0:j])\\n #print(a[0:j])\\n if mi>a[j]:\\n g=g+1\\n else:\\n mi=min(a[j-5:j])\\n #print(a[j-5:j])\\n if mi>a[j]:\\n g=g+1\\n print(g)\\n"}
{"id": "1003", "input": "# cook your dish here\\ndef solution(b,n1,d):\\n first=b[0]\\n b.sort()\\n for j in range(n1-1):\\n if(a[j+1]-a[j]>d):\\n return \"NO\"\\n for j in range(n1):\\n if(b[j]==first):\\n pos=j\\n if(pos==0 or pos==n1-1):\\n return \"YES\"\\n rec=1\\n for j", "gt": "in range(pos-1,n1-2):\\n if(a[j+2]-a[j]>d):\\n rec=0\\n break\\n if(rec):\\n return \"YES\"\\n rec=1\\n for j in range(pos+1,1,-1):\\n if(a[j]-a[j-2]>d):\\n rec=0\\n break\\n if(rec):\\n return \"YES\"\\n else:\\n return \"NO\"\\n \\ntestcase=int(input())\\nfor i in range(testcase):\\n n,d=list(map(int,input().split()))\\n a=list(map(int,input().split()))\\n print(solution(a,n,d))\\n"}
{"id": "1004", "input": "t=eval(input())\\nfor i in range(0,t):\\n x=input()\\n nm=x.split(' ')\\n nm[0]=int(nm[0])\\n nm[1]=int(nm[1])\\n csoint=[]\\n lsoint=[]\\n csofloat=[]\\n lsofloat=[]\\n for j in range(0,nm[0]):\\n a=input()\\n b=a.split(' ')\\n b[0]=int(b[0])\\n b[1]=int(b[1])\\n csoint.append(b[0])\\n lsoint.append(b[1])\\n for k in range(0,nm[1]):\\n a=input()\\n b=a.split(' ')\\n b[0]=int(b[0])\\n b[1]=int(b[1])\\n csofloat.append(b[0])\\n lsofloat.append(b[1])\\n chakra=0\\n\\n## for j in range(0,nm[0]):\\n## if csofloat==[0]*nm[1]:\\n## print chakra\\n## break\\n## for k in range(0,nm[1]):\\n## if csofloat==[0]*nm[1]:\\n## print chakra\\n## break\\n## if lsoint[j]==lsofloat[k]:\\n## if csoint[j]>csofloat[k]:\\n## csoint[j]-=csofloat[k]\\n## csofloat[k]=0\\n## lsofloat[k]=0\\n## elif csofloat[k]>csoint[j]:\\n## if lsoint.count(lsoint[j])==1==lsofloat.count(lsofloat[k]):\\n## chakra+=csofloat[k]-csoint[j]\\n## csoint[j]=csofloat[k]\\n## csoint[j]=0\\n## csofloat[k]=0\\n## lsoint[j]=0\\n## lsofloat[k]=0\\n## elif lsoint.count(lsoint[j])==1 and lsofloat.count(lsofloat[k])>lsoint.count(lsoint[j]):\\n## csoint[j]=csofloat[k]+1\\n## chakra+=csofloat[k]-csoint[j]+1\\n## csoint[j]=1\\n##", "gt": "csofloat[k]=0\\n## lsofloat[k]=0\\n## else:\\n## csofloat[k]-=csoint[j]\\n## csoint[j]=0\\n## lsoint[j]=0\\n## break\\n## else:\\n## if lsoint.count(lsoint[j])==1 and lsoint.count(lsoint[j])>=lsofloat.count(lsofloat[k]):\\n## csoint[j]=0\\n## csofloat[k]=0\\n## lsoint[j]=0\\n## lsofloat[k]=0\\n## break\\n## elif lsoint.count(lsoint[j])==1 and lsoint.count(lsoint[j])<lsofloat.count(lsofloat[k]):\\n## csoint[j]=1\\n## chakra+=1\\n## csofloat[k]=0\\n## lsofloat[k]=0\\n l=min(lsoint)-1\\n ci=[]\\n for a in range(l+1,max(lsoint)+1):\\n c=0\\n l+=1\\n if l not in lsoint:\\n continue\\n for j in range(0,nm[0]):\\n if lsoint[j]==l:\\n c+=csoint[j]\\n ci.append(c)\\n \\n l=min(lsofloat)-1\\n cf=[]\\n for a in range(l+1,max(lsofloat)+1):\\n c=0\\n l+=1\\n if l not in lsofloat:\\n continue\\n for j in range(0,nm[1]):\\n if lsofloat[j]==l:\\n c+=csofloat[j]\\n cf.append(c)\\n\\n for i in range(0,len(ci)):\\n if ci[i]<cf[i]:\\n chakra+=cf[i]-ci[i]\\n print(chakra)\\n"}
{"id": "1005", "input": "a=int(input())\\nif(a%2==0):\\n print(\"4\")\\n", "gt": "print(a/2,a/2,a/2,a/2)\\nelse:\\n print(\"6\")\\n print((a-1)/2,(a-1)/2,(a-1)/2,(a-1)/2,(a-1)/2,(a+1)/2)"}
{"id": "1006", "input": "MAXX = 10**9+1\\nN = eval(input())\\nnodes = list(map(int, input().split(\" \")))\\nedges = [set() for _ in range(N)]\\nfor _ in range(N-1):\\n a, b = list(map(int, input().split(\" \")))\\n edges[a-1].add(b-1)\\n edges[b-1].add(a-1)\\npath = [[] for _ in range(N)]\\nvisited, tovisit = set(), [(0, 0)]\\nwhile tovisit:\\n p, v = tovisit.pop()\\n if v not in visited:\\n path[v] = path[p] + [v]\\n visited.add(v)\\n news = edges[v] - visited\\n tovisit.extend([(v, x) for x in news])\\n# print path\\n\\nQ = eval(input())\\nfor _ in range(Q):\\n q, a, b = input().split(\" \")\\n a, b =", "gt": "int(a)-1, int(b)-1\\n i = 1\\n while i < min(len(path[a]), len(path[b])):\\n if path[a][i] != path[b][i]: break\\n i += 1\\n s = path[a][i-1:] + path[b][i:]\\n\\n # print s\\n if q == \"C\":\\n s = sorted([nodes[i] for i in s])\\n d = s[-1] - s[0]\\n for i in range(len(s)-1):\\n d = min(d, s[i+1]-s[i])\\n print(d)\\n else:\\n M = 0\\n m = MAXX\\n for i in range(len(s)):\\n M = max(M, nodes[s[i]])\\n m = min(m, nodes[s[i]])\\n print(M - m)\\n # print M[(s, l)] - m[(s, l)]"}
{"id": "1007", "input": "for _ in range(int(input())):\\n n,d=map(str,input().split())\\n k=list(n)\\n dd,c,n=d,0,len(n)\\n for x", "gt": "in range(n):\\n if int(k[n-x-1])>int(d):\\n k.pop(n-x-1)\\n c+=1 \\n else:\\n d=k[n-x-1]\\n print(''.join(k)+c*dd)"}
{"id": "1008", "input": "import math\\nfor _ in range(int(input())):\\n n=int(input())\\n ar=[int(x) for x in input().split()]\\n # dp=[1]*n\\n f=0\\n", "gt": "g=ar[0]\\n for i in range(1,n):\\n g=math.gcd(g,ar[i])\\n if g==1:\\n f=1\\n print(n)\\n break\\n if f==0:\\n print(-1)\\n"}
{"id": "1009", "input": "t=int(input())\\nfor k in range(t):\\n n=int(input())\\n l=[int(i) for i in input().split()]\\n m={}\\n count=1\\n for i in range(1,n):\\n if l[i]==l[i-1]:\\n count+=1\\n else:\\n \\n if l[i-1] not", "gt": "in m:\\n m[l[i-1]]=(count*(count+1))/2\\n else:\\n \\n m[l[i-1]]+=(count*(count+1))/2\\n count=1\\n if(l[n-1]) not in m:\\n m[l[n-1]]=(count*(count+1))/2\\n else:\\n \\n m[l[n-1]]+=(count*(count+1))/2\\n s=1\\n \\n for x in m:\\n \\n s=(s*m[x])%(1000000007)\\n print(s)\\n \\n"}
{"id": "1010", "input": "# cook your dish here\\nfrom sys import stdin\\nimport functools\\ndef gcd(a, b): \\n if (a == 0): \\n return b \\n return gcd(b % a, a) \\n \\nMAX=10001\\ndef func(ind, g, dp, n, a): \\n if (ind == n): \\n if (g == 1): \\n return 1\\n else: \\n return 0\\n if (dp[ind][g] != -1): \\n return dp[ind][g] \\n ans = (func(ind + 1, g, dp,", "gt": "n, a) + \\n func(ind + 1, gcd(a[ind], g), \\n dp, n, a)) \\n dp[ind][g] = ans \\n return dp[ind][g] \\n \\ndef countSubsequences(a, n): \\n dp = [[-1 for i in range(MAX)] \\n for i in range(n)] \\n count = 0\\n for i in range(n): \\n count += func(i + 1, a[i], dp, n, a) \\n return count \\n\\ntest=int(stdin.readline())\\nfor _ in range(test):\\n n=int(stdin.readline())\\n list1=list(map(int,stdin.readline().split()))\\n print(countSubsequences(list1,n))\\n\\n"}
{"id": "1011", "input": "#code snippet reference:http://www.geeksforgeeks.org/searching-for-patterns-set -2-kmp-algorithm/\\ndef KMPMatch(pattern, string):\\n M = len(pattern)\\n N = len(string)\\n nonlocal ans\\n\\n lps = [0]*M\\n j = 0 \\n LPSCompute(pattern, M, lps)\\n\\n i = 0 \\n while i < N:\\n if pattern[j] == string[i]:\\n i+=1\\n j+=1\\n\\n if j==M:\\n ans+=1\\n j = lps[j-1]\\n \\n elif i < N and pattern[j] != string[i]:\\n if j !=", "gt": "0:\\n j = lps[j-1]\\n else:\\n i+=1\\n\\ndef LPSCompute(pattern, M, lps):\\n len = 0 \\n lps[0] \\n i = 1\\n while i < M:\\n if pattern[i]==pattern[len]:\\n len+=1\\n lps[i] = len\\n i+=1\\n else:\\n if len!=0:\\n len = lps[len-1]\\n\\n else:\\n lps[i] = 0\\n i+=1\\n\\nfor _ in range(int(input())):\\n n,k=list(map(int,input().split()))\\n s=list(map(int,input().split()))\\n pattern=list(map(int,input().split()))\\n ans=0\\n string=[]\\n for i in range(n-1):\\n string.append(s[i+1]-s[i])\\n KMPMatch(pattern, string)\\n print(ans)\\n\\n"}
{"id": "1012", "input": "t=int(input())\\ndef do():\\n n,k=map(int,input().split())\\n s=input()\\n upper=0\\n lower=0\\n for i in s:\\n if i.isupper():\\n upper+=1\\n else:\\n lower+=1\\n if lower>k", "gt": "and upper<=k:\\n print('chef')\\n elif(upper>k and lower<=k):\\n print('brother')\\n elif(upper<=k and lower<=k):\\n print('both')\\n else:\\n print('none')\\n return\\nfor i in range(t):\\n do()"}
{"id": "1013", "input": "import sys\\r\\nfrom collections import defaultdict\\r\\nfrom copy import copy\\r\\n\\r\\nMOD = 10**9 + 7\\r\\n\\r\\nR = lambda t = int: t(input())\\r\\nRL = lambda t = int: [t(x) for x in input().split()]\\r\\nRLL = lambda n, t = int: [RL(t) for _ in range(n)]\\r\\n\\r\\n# primes up to n\\r\\ndef primes(n):\\r\\n P = []\\r\\n n = int(n)\\r\\n U = [1] * (n+1)\\r\\n p = 2\\r\\n while p <= n:\\r\\n if U[p]:\\r\\n P += [p]\\r\\n x = p\\r\\n while x <= n:\\r\\n U[x] = 0\\r\\n x += p\\r\\n p += 1\\r\\n return P\\r\\n \\r\\n \\r\\n \\r\\ndef solve():\\r\\n S = R(str).strip()\\r\\n", "gt": "X = [ord(c)-ord('a') for c in S]\\r\\n P = primes(10000)\\r\\n L = defaultdict(lambda : 0)\\r\\n s = 0\\r\\n for i in range(len(S)):\\r\\n p = i in P\\r\\n NL = defaultdict(lambda : 0)\\r\\n for a in range(26):\\r\\n for l in L:\\r\\n NL[l + a * p] += L[l]\\r\\n for a in range(X[i]):\\r\\n NL[s + a * p] += 1\\r\\n s += X[i] * p\\r\\n L = NL\\r\\n L[s] += 1\\r\\n r = 0 \\r\\n for p in P:\\r\\n r += L[p]\\r\\n print(r % MOD)\\r\\n \\r\\nT = R()\\r\\nfor t in range(1, T + 1):\\r\\n solve()\\r\\n"}
{"id": "1014", "input": "# cook your dish here\\r\\nfrom collections import defaultdict\\r\\nd=defaultdict(list)\\r\\ndef dfs(i):\\r\\n p=0\\r\\n nonlocal v\\r\\n e=[i]\\r\\n while(e!=[]):\\r\\n p+=1\\r\\n x=e.pop(0)\\r\\n v[x]=1\\r\\n for i in d[x]:\\r\\n if v[i]==-1:\\r\\n v[i]=1\\r\\n e.append(i)\\r\\n return", "gt": "p\\r\\n\\r\\nn,m=list(map(int,input().split()))\\r\\nfor i in range(n+1):\\r\\n d[i]=[]\\r\\nfor _ in range(m):\\r\\n a,b=list(map(int,input().split()))\\r\\n d[a].append(b)\\r\\n d[b].append(a)\\r\\nv=[]\\r\\nfor i in range(n+1):\\r\\n v.append(-1)\\r\\nc=0\\r\\np=[]\\r\\nfor i in range(1,n+1):\\r\\n if v[i]==-1:\\r\\n c+=1\\r\\n p.append(dfs(i))\\r\\nan=0\\r\\ns=0\\r\\nfor i in range(c):\\r\\n s+=p[i]\\r\\n an+=p[i]*(n-s)\\r\\nprint(an)\\r\\n"}
{"id": "1015", "input": "from math import log2, ceil\\r\\nMOD = int(1e9 + 7)\\r\\nsrt = lambda s: ''.join(sorted(s))\\r\\nfor _ in range(int(input())):\\r\\n s = srt(input())\\r\\n res = -1\\r\\n for p in", "gt": "range(ceil(log2(int(s))), int(log2(int(s[::-1]))) + 1):\\r\\n if int(srt(str(pow(2, p)))) == int(s):\\r\\n if res == -1: res = 0\\r\\n res = (res + pow(2, p, MOD)) % MOD\\r\\n print(res)"}
{"id": "1016", "input": "# cook your dish here\\ntry:\\n for _ in range(int(input())):\\n k = int(input())\\n num = 1\\n", "gt": "for i in range(1,k+1,1):\\n for j in range(1,k+1,1):\\n print(num*2,end=\"\")\\n num = num +1\\n print(\"\")\\nexcept:\\n pass"}
{"id": "1017", "input": "# cook your dish here\\nfor t in range(int(input())):\\n c=0\\n for", "gt": "i in range(int(input())):\\n s,j=list(map(int,input().split()))\\n if (j-s)>5:\\n c+=1 \\n print(c)\\n \\n"}
{"id": "1018", "input": "# cook your dish here\\nfor t in range(int(input())):\\n a1,a2,a3,a4,a5,p=[int(x)for", "gt": "x in input().rstrip().split()]\\n if (a1+a2+a3+a4+a5)*p >120:\\n print(\"Yes\")\\n else:\\n print(\"No\")\\n"}
{"id": "1019", "input": "\\nfor _ in range(int(input())):\\n n = int(input())\\n arr = list(map(int, input().split()))\\n hrs = arr[0] - arr[1]\\n\\n", "gt": "for i in range(1, n-1):\\n if hrs > arr[i] - arr[i+1]:\\n hrs = arr[i] - arr[i+1]\\n\\n print(hrs)"}
{"id": "1020", "input": "# cook your dish here\\nfor i in range(int(input())):\\n N=int(input())\\n L=list(map(int,input().split()))\\n l,h=0,N-1 \\n flag=1\\n if L[l]!=1 and L[h]!=1:\\n flag=0\\n", "gt": "else:\\n while(l<h):\\n if (L[l]!=L[h]) or (L[l+1]-L[l]!=1 and L[h-1]-L[h]!=1):\\n flag=0\\n break\\n l+=1 \\n h-=1\\n if flag:\\n print(\"yes\")\\n else:\\n print(\"no\")"}
{"id": "1021", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n,k=list(map(int,input().split()))\\n a=list(map(int,input().split()))\\n m=0\\n for i in range(n):\\n if i%2==0:\\n", "gt": "if m<0:\\n m-=a[i]\\n else:\\n m+=a[i]\\n else:\\n if m<0:\\n m+=a[i]\\n else:\\n m-=a[i]\\n if abs(m)>=k:\\n print(1)\\n else:\\n print(2)\\n \\n"}
{"id": "1022", "input": "class Node:\\r\\n def __init__(self,x):\\r\\n self.x=x\\r\\n self.next=None\\r\\n self.prev=None\\r\\n self.flag=True\\r\\n\\r\\nfor t in range(1):\\r\\n n=int(input())\\r\\n arr=list(map(int,input().split()))\\r\\n for i in range(n):\\r\\n arr[i]=Node(arr[i])\\r\\n for i in arr:\\r\\n d=[i.x%3==0,i.x,i.x//3,i.x*2]\\r\\n if d[0]:\\r\\n for j in arr:\\r\\n if j.x==d[2]:\\r\\n i.next=j\\r\\n j.prev=i\\r\\n break\\r\\n else:\\r\\n for j in arr:\\r\\n", "gt": "if j.x == d[3]:\\r\\n i.next = j\\r\\n j.prev = i\\r\\n break\\r\\n else:\\r\\n for j in arr:\\r\\n if j.x==d[3]:\\r\\n i.next=j\\r\\n j.prev=i\\r\\n break\\r\\n f,l=None,None\\r\\n for i in arr:\\r\\n if i.prev==None:\\r\\n f=i\\r\\n elif i.next==None:\\r\\n l=i\\r\\n while f!=l and l!=None:\\r\\n print(f.x,end=\" \")\\r\\n f=f.next\\r\\n print(f.x)"}
{"id": "1023", "input": "# cook your dish here\\n# cook your dish here\\nimport math\\ntest=int(input())\\nfor _ in range(test):\\n n=int(input())\\n l=list(map(int,input().split()))\\n f=0\\n for i in range(math.ceil(n//2)):\\n if n%2==1:\\n", "gt": "f=1\\n break\\n else:\\n if l[i]!=l[i+n//2]:\\n if min(l[i],l[i+n//2])==-1:\\n l[i]=max(l[i],l[i+n//2])\\n l[i+n//2]=max(l[i],l[i+n//2])\\n else:\\n f=1\\n break\\n else:\\n if l[i]==-1:\\n l[i]=1\\n l[i+n//2]=1\\n if f==1:\\n print(\"NO\")\\n else:\\n print(\"YES\")\\n print(*l)"}
{"id": "1024", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n = int(input())\\n count = 1\\n l = 3*(n-1)\\n i = 0\\n if n==1:\\n print(1)\\n continue\\n while count<=l-n:\\n for", "gt": "j in range(i+1):\\n if j==i:\\n print(count)\\n count += 1\\n elif j==0:\\n print(count,end=\"\")\\n count += 1\\n else:\\n print(\" \",end=\"\") \\n i+=1\\n while count<=l:\\n print(count,end=\"\")\\n count += 1\\n print()"}
{"id": "1025", "input": "# cook your dish here\\nextra, less = 0,0\\nfor _ in range(int(input())):\\n sli,mem,sma,luc = list(map(int, input().split()))\\n total = sma\\n t = sma\\n while mem > 1:\\n t *= luc\\n", "gt": "total += t\\n mem -= 1\\n if total <= sli:\\n extra += sli-total\\n print('POSSIBLE',sli-total)\\n else:\\n less += total-sli\\n print('IMPOSSIBLE',total-sli)\\nif extra >= less:\\n print('POSSIBLE')\\nelse:\\n print('IMPOSSIBLE')\\n \\n \\n \\n \\n"}
{"id": "1026", "input": "from collections import defaultdict as dd,deque as dq\\ndef opbfs(u,vis,ll,parr):\\n q=dq([(u,0)])\\n uu=u\\n su=0\\n while q:\\n \\n u,lol=q.pop()\\n par=parr[u]\\n if(lol%2==0):\\n vis[u]=1\\n su+=ll[u-1]\\n ll[u-1]=0\\n for j in d[u]:\\n if(j!=par):\\n q.appendleft((j,lol+1))\\n ll[uu-1]=su\\ndef bfs(height,d,parr):\\n q=dq([1])\\n while q:\\n u=q.pop()\\n height[u]=height[parr[u]]+1\\n for i in d[u]:\\n", "gt": "if(i!=parr[u]):\\n q.appendleft(i)\\n parr[i]=u\\nt=int(input())\\nwhile t:\\n n,q=map(int,input().split())\\n ll=list(map(int,input().split()))\\n d=dd(list)\\n for i in range(n-1):\\n u,v=map(int,input().split())\\n d[u].append(v)\\n d[v].append(u)\\n vis=[0]*(n+1)\\n l=[]\\n height=[0]*(n+1)\\n parr=[0]*(n+1)\\n bfs(height,d,parr)\\n for i in range(q):\\n u=int(input())\\n l.append((height[u],u,i))\\n l.sort()\\n vis=[0]*(n+1)\\n #print(l)\\n for i in l:\\n he,u,ind=i\\n if(vis[u]==0):\\n #print(u)\\n opbfs(u,vis,ll,parr)\\n print(*ll)\\n t-=1"}
{"id": "1027", "input": "d=1000000007\\nfor _ in", "gt": "range(int(input())):\\n l=sorted(list(map(int,input().split())))\\n ans=(l[0]%d)*((l[1]-1)%d)*((l[2]-2)%d)\\n print(ans%d)"}
{"id": "1028", "input": "T=int(input())\\nfor i in range(T):\\n n,m=list(map(int,input().split()))\\n if(m<=2):\\n print(\"impossible\")\\n else:\\n l=[0]*m\\n\\n if(m%2==0):\\n a=m//2\\n else:\\n a=(m//2)+1\\n for j in range(a):\\n if(j%2==0):\\n", "gt": "l[j]=\"a\"\\n l[m-j-1]=\"a\"\\n \\n else:\\n l[j]=\"b\"\\n l[m-j-1]=\"b\"\\n \\n \\n r=\"\"\\n s=n//m\\n for e in l:\\n r=r+e\\n print(r*s)\\n \\n \\n\\n"}
{"id": "1029", "input": "def power(x, y):\\n if y == 0:\\n return 1\\n if y % 2 == 0:\\n return power(x, y // 2) * power(x, y // 2)\\n\\n return x * power(x, y // 2) * power(x, y // 2)\\n\\n\\n# Function to calculate order of the number\\ndef order(x):\\n # Variable to store of the number\\n n = 0\\n while (x != 0):\\n n = n + 1\\n x = x //", "gt": "10\\n\\n return n\\n\\n\\n# Function to check whether the given\\n# number is Armstrong number or not\\ndef isArmstrong(x):\\n n = order(x)\\n temp = x\\n sum1 = 0\\n\\n while (temp != 0):\\n r = temp % 10\\n sum1 = sum1 + power(r, n)\\n temp = temp // 10\\n\\n # If condition satisfies\\n return (sum1 == x)\\n\\n\\n# Driver code\\n\\nfor _ in range(int(input())):\\n num = int(input())\\n if isArmstrong(num):\\n print(\"FEELS GOOD\")\\n else:\\n print(\"FEELS BAD\")"}
{"id": "1030", "input": "T = int(input())\\nfor _ in range(T):\\n n,m = map(int,input().split())\\n completed = list(map(int,input().split()))\\n jobs = []\\n for i in range(1,n+1):\\n if i not", "gt": "in completed:\\n jobs.append(i)\\n jobs.sort()\\n chef = []\\n ass = []\\n for i in range(len(jobs)):\\n if i%2==0:\\n chef.append(str(jobs[i]))\\n else:\\n ass.append(str(jobs[i]))\\n print(' '.join(chef))\\n print(' '.join(ass))"}
{"id": "1031", "input": "t = int(input())\\nwhile(t>0):\\n t-=1;\\n n,l,r = list(map(int,input().split()));\\n a = bin(l)[2:];\\n b = bin(r)[2:];\\n # find matching\\n z = 0;\\n l = min(len(a),len(b));\\n for i in range(l):\\n if a[i]==b[i]:\\n z+=1;\\n else:\\n break;\\n\\n #find base string\\n a = a[z:]\\n b =b[z:]\\n if(len(a)==0 and len(b)==0):\\n print(n);\\n else :\\n m", "gt": "= max(len(a),len(b))\\n #print m;"}
{"id": "1032", "input": "import math\\nt = eval(input())\\nwhile(t > 0):\\n h,s = input().split()\\n h = int(h)\\n s = int(s)\\n if(((h*h*h*h) - (16*s*s)) < 0):\\n", "gt": "print(\"-1\")\\n else:\\n B = (math.sqrt((h*h) + math.sqrt((h*h*h*h) - (16*s*s))))/math.sqrt(2)\\n P = (2*s)/B\\n if(B > P):\\n print('"}
{"id": "1033", "input": "a = [1]\\nM = 10**6 + 3\\nfor ii in range(1, 1000005):\\n a.append((a[-1]*ii)%M)\\nfor", "gt": "__ in range(eval(input())):\\n n, x = list(map(int, input().split()))\\n if n>=M: print(0)\\n else: print((a[n]*x)%M)\\n"}
{"id": "1034", "input": "<s> ", "gt": "print(0)"}
{"id": "1035", "input": "from math import log2;\\nimport bisect;\\nfrom bisect import bisect_left,bisect_right\\nimport sys;\\nfrom math import gcd,sqrt\\nsys.setrecursionlimit(10**7)\\nfrom collections import defaultdict\\ninf=float(\"inf\")\\n# n=int(input())\\n# n,m=map(int,input().split())\\n# l=list(map(int,input().split()))\\ndef get_factors(x):\\n if x==1:\\n return [];\\n sqrta=int(sqrt(x))+1\\n for i in range(2,sqrta):\\n if x%i==0:\\n return [i]+get_factors(x//i)\\n return [x]\\ndef min_generator(fac,k,index,new_list):\\n if index==len(fac):\\n return sum(new_list)\\n mina=inf;\\n for iin range(0,min(index+1,len(new_list))):\\n new_list[i]*=fac[index]\\n theta=min_generator(fac,k,index+1,new_list)\\n if theta<mina:\\n mina=theta;\\n new_list[i]//=fac[index]\\n", "gt": "return mina;"}
{"id": "1036", "input": "# cook your dish here\\nfrom collections import namedtuple\\n\\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\\n\\nT = int(input())\\nfor _ in range(T):\\n R, C, N = map(int, input().split())\\n Sx, Sy = map(int, input().split())\\n tx = map(int, input().split())\\n ty = map(int, input().split())\\n tel_pairs = list(zip(tx, ty))\\n board = []\\n for _ in range(R):\\n board += [[int(c) for c in input().split()]]\\n \\n def explore(p):\\n next_pos = []\\n for i, (dx, dy) in enumerate(p.pairs):\\n sx, sy = p.cell\\n new_pairs = p.pairs[:i]+p.pairs[i+1:]\\n # case (+, +)\\n px, py = sx + dx, sy + dy\\n if px < R and py < C:\\n next_pos += [CurrentPosition(p.points+board[px][py], (px, py), new_pairs)]\\n # case (+, -)\\n px,", "gt": "py = sx + dx, sy - dy\\n if px < R and 0 <= py:\\n next_pos += [CurrentPosition(p.points+board[px][py], (px, py), new_pairs)]\\n # case (-, +)\\n px, py = sx - dx, sy + dy\\n if 0 <= px and py < C:\\n next_pos += [CurrentPosition(p.points+board[px][py], (px, py), new_pairs)]\\n # case (-, -)\\n px, py = sx - dx, sy - dy\\n if 0 <= px and 0 <= py:\\n next_pos += [CurrentPosition(p.points+board[px][py], (px, py), new_pairs)]\\n return next_pos\\n \\n pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\\n result = board[Sx][Sy]\\n while pos:\\n p = pos.pop(0)\\n if p.pairs:\\n pos += explore(p)\\n else:\\n result = max(result, p.points)\\n \\n print(result) \\n"}
{"id": "1037", "input": "# cook your dish here\\nt=int(input())\\nfor _ in range(t):\\n x1,y1,x2,y2=map(int,input().split())\\n x3,y3,x4,y4=map(int,input().split())\\n if (x1==x3 and y1==y3)or(x2==x4 and y2==y4):\\n print(\"yes\")\\n elif (x1==x4 and y1==y4)or(x2==x3 and y2==y3):\\n print(\"yes\")\\nelse:\\n if(y1==y2)and(y1==y3)and(y1==y4):\\n a1=max(x1,x2);a2=min(x1,x2)\\n", "gt": "b1=max(x3,x4);"}
{"id": "1038", "input": "for _ in range(int(input())):\\n s = input().strip()\\n a = []\\n last = 0\\n for i in range(len(s)):\\n if s[i] == 'P':\\n a.append(i - last)\\n", "gt": "last = i + 1\\n x = 0\\n a = a[::-1]\\n for v in a[::2]:\\n x ^= v % 3\\n print('Yes' if x else 'No')"}
{"id": "1039", "input": "MOD = int(1e9+7)\\n\\ndef mult(a, b):\\n rsp = [[0, 0, 0],\\n [0, 0, 0],\\n [0, 0, 0]]\\n\\n for i in range(3):\\n for j in range(3):\\n for k in range(3):\\n rsp[i][j] += a[i][k] * b[k][j]\\n rsp[i][j] %= MOD\\n\\n return rsp\\n\\nident = [[1, 0, 0],\\n [0, 1, 0],\\n [0, 0, 1]]\\nm = [[1, 1, 0],\\n [1, 0, 1],\\n [1, 0, 0]]\\n\\npowers = [m]\\nfor _ in range(53):\\n p = powers[-1]\\n powers.append(mult(p ,p))\\n\\ndef pow2(e):\\n y = ident\\n", "gt": "i = 0\\n for p in powers:\\n if e & (1 << i):\\n y = mult(p, y)\\n i += 1\\n return y\\n\\nt = eval(input())\\n\\nfor _ in range(t):\\n n = eval(input())\\n\\n if n < 3:\\n print(0)\\n continue\\n\\n r = pow(2, n, MOD)\\n b = pow2(n - 2)\\n # print(b)\\n r -= (4 * b[0][0]) % MOD\\n r -= (2 * b[1][0]) % MOD\\n r -= b[2][0]\\n r = (MOD + r) % MOD\\n print(r)\\n"}
{"id": "1040", "input": "t=int(input())\\nfor i in range(t):\\n ans=0\\n x,y=list(map(int,input().split()))\\n if y>x:\\n if (y-x)%4==0:ans=3\\n elif", "gt": "(y-x)%2==0: ans=2\\n else: ans=1\\n if y<x:\\n if (y-x)%2==0:ans=1\\n else: ans=2\\n print(ans)\\n"}
{"id": "1041", "input": "t=int(input())\\n\\nfor _ in range(t):\\n n,q=map(int,input().split())\\n s=input()\\n l=[0]*(n-1)\\n for i in range(n-2):\\n a,b,c=s[i],s[i+1],s[i+2]\\n if len(set([a,b,c]))<3:\\n l[i]=l[i-1]+1\\n else:\\n l[i]=l[i-1]\\n", "gt": "\\n for i in range(q):\\n left,right=map(int,input().split())\\n left-=1\\n right-=1\\n if right-left+1 <3:\\n print('NO')\\n continue\\n if (l[right-2]-l[left-1])>0:\\n print('YES')\\n else:\\n print('NO')"}
{"id": "1042", "input": "# cook your dish here\\nfor u in range(int(input())):\\n n=int(input())\\n l=list(map(int,input().split()))\\n d=[]\\n dd=[]\\n s=1\\n for i in range(n-1):\\n s=l[i]\\n d.append(s)\\n", "gt": "dd.append([i,i])\\n for j in range(i+1,n):\\n s=s*l[j]\\n d.append(s)\\n dd.append([i,j])\\n d.append(l[n-1])\\n dd.append([n-1,n-1])\\n k=len(d)\\n m=max(d)\\n x,y=0,0\\n for i in range(k):\\n if(d[i]==m):\\n x=dd[i]\\n print(m,*x)\\n"}
{"id": "1043", "input": "# cook your dish here\\n \\ndef G(x, y): \\n while(y): \\n x, y = y, x % y \\n", "gt": "return x \\n# t=int(input())\\n# l=list(map(int,input().split()))\\nfor _ in range(int(input())):\\n n,p=map(int,input().split())\\n\\n c=0\\n for i in range(1,n+1):\\n if G(i,p)==1:\\n c+=1\\n ans=c*(c-1)//2\\n print(ans)"}
{"id": "1044", "input": "test_case = int(input())\\nfor w in range(test_case):\\n n, k = map(int,input().split())\\n l = list(map(str,input().split()))\\n ans = []\\n for q in range(k):\\n l2", "gt": "= list(map(str,input().split()))\\n ans.extend(l2[1:])\\n for i in l:\\n if i in ans:\\n print('YES',end=' ')\\n else:\\n print('NO',end=' ')\\n print()# cook your dish here\\n"}
{"id": "1045", "input": "# cook your dish here\\nnumber = int(input())\\nfor i in range(number):\\n", "gt": "a = list(input())\\n for k in range(len(a)):\\n a[k] = eval(a[k])\\n print(sum(a))"}
{"id": "1046", "input": "\\n\\nvow = ['a', 'e', 'i','o', 'u']\\nfor _ in range(int(input())):\\n name = str(input())\\n tmp = ''\\n for i in range(len(name)):\\n if", "gt": "name[i] not in vow and name[i].isalpha():\\n tmp+='1'\\n elif name[i] in vow and name[i].isalpha():\\n tmp+='0'\\n \\n print( int(tmp, 2)% (10**9 + 7))"}
{"id": "1047", "input": "for t in range(int(input())):\\n limakMax, bobMax = list(map(int, input().split()))\\n limakEat = 0; bobEat = 0\\n eating = 1\\n while limakEat <= limakMax or bobEat <= bobMax:\\n\\n if eating % 2 != 0 and limakEat <=", "gt": "limakMax:\\n limakEat += eating\\n eating += 1\\n if limakEat > limakMax:\\n print(\"Bob\")\\n break\\n elif eating % 2 == 0 and bobEat <= bobMax:\\n bobEat += eating\\n eating += 1\\n if bobEat > bobMax:\\n print(\"Limak\")\\n break\\n\\n"}
{"id": "1048", "input": "import sys\\n\\ndef input(): return sys.stdin.readline().strip()\\ndef iinput(): return int(input())\\ndef rinput(): return list(map(int, sys.stdin.readline().strip().split())) \\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\\n\\n\\nt=iinput()\\n\\nfor _ in range(t):\\n n=iinput()\\n p=[]\\n mi=[]\\n", "gt": "for i in range(n):\\n x,y=rinput()\\n p.append(x+y)\\n mi.append(x-y)\\n\\n p.sort()\\n mi.sort()\\n m=float('inf')\\n for i in range(1,n):\\n if(p[i]-p[i-1]<m):\\n m=p[i]-p[i-1]\\n if(mi[i]-mi[i-1]<m):\\n m=mi[i]-mi[i-1]\\n\\n if m%2==0:\\n print(m//2)\\n else:\\n print(m/2)\\n"}
{"id": "1049", "input": "t=int(input())\\nfor i in range(t):\\n a,k=list(map(int,input().split()))\\n x1,x2,x3=list(map(int,input().split()))\\n big=max(x1,x2,x3)\\n small=min(x1,x2,x3)\\n q=big-small-2*k\\n", "gt": "\\n if q>=a:\\n print(0)\\n elif -1*q>=0:\\n print(a*a)\\n else:\\n print(a*(a-q))\\n"}
{"id": "1050", "input": "#\\n\\nfor _ in range(int(input())):\\n n,k = list(map(int,input().split()))\\n arr = list(map(int,input().split()))\\n s=set(arr)\\n t1=len(s)\\n max=-1\\n for", "gt": "i in range(n-k+1):\\n temp=set(arr[i:i+k])\\n #print(temp,i,k+i+1)\\n t=len(temp)\\n if t1 == t:\\n if max<sum(arr[i:k+i]):\\n max=sum(arr[i:k+i])\\n print(max)\\n"}
{"id": "1051", "input": "# cook your dish here\\nt=int(input())\\nfor j in range(t):\\n s=input()\\n st=[]\\n ans=0\\n\\n for i in", "gt": "range(len(s)):\\n \\n if(s[i]=='>'):\\n if(len(st)!=0 and st[-1]=='<'):\\n st.pop()\\n if(len(st)==0):\\n ans=i+1\\n else:\\n break\\n\\n else:\\n st.append('<')\\n\\n print(ans)\\n"}
{"id": "1052", "input": "# cook your dish here\\nt=int(input())\\nfor i in range(0,t):\\n my_ip = int(input().strip())\\n for xyz", "gt": "in range(my_ip+1):\\n for abc in range(0,xyz+1):\\n if abc == xyz:\\n print(xyz,end=\"\")\\n else:\\n print('*',end=\"\")\\n\\n print()"}
{"id": "1053", "input": "from collections import deque \\r\\nT=int(input())\\r\\ndef break_down(num):\\r\\n count=0\\r\\n while(len(num)!=1):\\r\\n temp=0\\r\\n for i in range(0,len(num)):\\r\\n temp=temp+int(num[i])\\r\\n num=str(temp)\\r\\n count=count+1\\r\\n return (int(num),count)\\r\\ndef digit_sum(num):\\r\\n temp=0\\r\\n for i in range(0,len(num)):\\r\\n temp=temp+int(num[i])\\r\\n num=temp\\r\\n return (num)\\r\\nwhile(T):\\r\\n queue=deque()\\r\\n count_n=0\\r\\n count_d=0\\r\\n T=T-1\\r\\n N,d=[i for i in input().split()]\\r\\n n,count_n=break_down(N)\\r\\n", "gt": "D,count_D=break_down(d)\\r\\n dic="}
{"id": "1054", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n=int(input())\\n", "gt": "A=list(map(int,input().split()))\\n A.sort()\\n for i in range(len(A)):\\n if A[i]==1:\\n print(i)\\n break"}
{"id": "1055", "input": "test=int(input())\\nfor i in range(test):\\n s=input()\\n b=len(s)\\n list1=[]\\n for j in range(len(s)):\\n if s[j]=='.':\\n list1.append(j)\\n for i in list1:\\n if b-i-1 in", "gt": "list1 :\\n if i!=b-i-1 and ((s[i] and s[b-i-1]) != 'a' ):\\n s=s[:i]+'a'+s[i+1:b-i-1]+'a'+s[b-i:]\\n else:\\n s=s[:i]+'a'+s[i+1:]\\n else:\\n s=s[:i]+s[b-i-1]+s[i+1:]\\n\\n if s==s[::-1]:\\n print(s)\\n else:\\n print(-1)\\n\\n"}
{"id": "1056", "input": "# cook your dish here\\r\\nm,n=[int(i) for i in input().split()]\\r\\narr=list(map(int,input().split()))\\r\\narr=sorted(arr,reverse=True)\\r\\nans=0\\r\\nw=0\\r\\nq=m\\r\\nfor m in", "gt": "range(q):\\r\\n if(arr[m]>n):\\r\\n w=1\\r\\n break \\r\\n ans+=1+(arr[m]*(arr[m]+1))//2\\r\\n n-=arr[m]\\r\\n\\r\\nif(n==0):\\r\\n print(ans)\\r\\nelse:\\r\\n if(w==1):\\r\\n print(ans+q-m+(n*(n+1))//2)\\r\\n else:\\r\\n print(ans)"}
{"id": "1057", "input": "n=int(input())\\nfor i in range(n):\\n a,b,c=map(int,input().split())\\n if a>0 and", "gt": "b>0 and c>0 and a+b+c==180:\\n print(\"YES\")\\n else:\\n print(\"NO\")"}
{"id": "1058", "input": "import math\\n\\ndef magic(a,digits):\\n m=a%10\\n if(m==4):\\n return a+3\\n elif(m==7):\\n p=list(str(a))\\n #print p\\n for i in range(digits-1,-1,-1):\\n #print p[i]\\n if (p[i]=='4'):\\n #print 'four'\\n p[i]='7'\\n p = ''.join(str(n) for n in p)\\n return int(p)\\n if ((p[i]=='7')&(i==0)):\\n #print 'seven'\\n p[i]='4'\\n p.insert(0,4)\\n p = ''.join(str(n)", "gt": "for n in p)\\n return int(p)\\n\\n if(p[i]=='7'):\\n #print 'seven only'\\n p[i]='4'\\n \\n #print p[i]\\n \\n \\n \\n\\nt=eval(input())\\n\\nn=[]\\nop=[]\\n\\nfor i in range(0,t):\\n n.append(eval(input()))\\n\\nfor i in range(0,t):\\n digits = int(math.log10(n[i]))+1\\n #print digits\\n op.append(magic(n[i],digits))\\n \\n#for i in range(0,t):\\n #print n[i]\\n\\nfor i in range(0,t):\\n print(op[i])\\n\\n\\n\\n \\n"}
{"id": "1059", "input": "# cook your dish here\\nt=int(input())\\nfor i in range(0,t):\\n p=input()\\n l=list(p)\\n for", "gt": "j in range(0,len(l)):\\n l[j]=int(l[j])\\n l[j]=l[j]-2\\n for j in range(0,len(l)):\\n l[j]=str(l[j])\\n q=''.join(l)\\n print(q)"}
{"id": "1060", "input": "n = int(input())\\na = []\\nfor i in range(n):\\n a.append(int(input()))\\nm1 = 0\\nm2 = 0\\nfor e in a:\\n if (e > m1):\\n m2 = m1\\n m1 =", "gt": "e\\n elif (e > m2 and e != m1):\\n m2 = e\\nans = 0\\nfor e in a:\\n temp = m1%e\\n if (temp>ans):\\n ans = temp\\nprint(max(m2%m1,ans))"}
{"id": "1061", "input": "def countSubstr(str, n, x, y): \\r\\n \\r\\n tot_count = 0\\r\\n \\r\\n count_x = 0\\r\\n \\r\\n for i in range(n): \\r\\n if str[i] == x: \\r\\n count_x", "gt": "+= 1\\r\\n if str[i] == y: \\r\\n tot_count += count_x \\r\\n return tot_count \\r\\n \\r\\nt=int(input())\\r\\nfor _ in range(t):\\r\\n n=int(input())\\r\\n str=input()\\r\\n x='0'\\r\\n y='1'\\r\\n x1='1'\\r\\n y1='0'\\r\\n c1=countSubstr(str,n,x,y)\\r\\n c2=countSubstr(str,n,x1,y1)\\r\\n print(c1+c2)"}
{"id": "1062", "input": "# cook your dish here\\ndef value(a, b, c):\\n if(c == '&'):\\n return a&b\\n elif(c == '^'):\\n return a^b\\n elif(c == '|'):\\n return a|b\\n\\ndef break_rules(n, operator):\\n if(len(n) == 1):\\n return n\\n elif(len(n) == 2):\\n return [value(n[0], n[1], operator[0])]\\n else:\\n cont_ans = []\\n for i in range(1,len(n)):\\n l1 = n[:i]\\n l2 = n[i:]\\n o1 = operator[:i]\\n o2 = operator[i:]\\n l1_ans = break_rules(l1, o1)\\n l2_ans = break_rules(l2, o2)\\n for", "gt": "k in l1_ans:\\n for j in l2_ans:\\n cont_ans.append(value(k, j, operator[i - 1]))\\n return cont_ans\\n\\nt = int(input())\\nwhile t > 0 :\\n operator = []\\n num = []\\n exp = input()\\n temp = ''\\n for i in range(len(exp)):\\n if(ord(exp[i]) > 47 and ord(exp[i]) < 58):\\n temp = temp + exp[i]\\n else:\\n num.append(int(temp))\\n temp = ''\\n operator.append(exp[i])\\n if(i == len(exp) - 1):\\n num.append(int(temp))\\n t -= 1\\n # print(num,operator)\\n print(max(break_rules(num, operator)))"}
{"id": "1063", "input": "# cook your dish here\\ndef read_i_l(l=False):\\n m = list(map(int, input().strip().split(\" \")))\\n if l:\\n return list(m)\\n else:\\n return m\\ndef i():\\n return int(input().strip())\\nT = i()\\nL = []\\n\"\"\"for current in range(T):\\n line = \"\"\\n for i in range(current):\\n line+=str((T-i)%10)\\n for i in", "gt": "range(2*(T-current)-1):\\n line+=str((T-current)%10)\\n for i in range(current-1,-1,-1):\\n line+=str((T-i)%10)\\n L.append(line)\\nL += L[-2::-1]\"\"\"\\n\\nif T >= 1:\\n L = [\"1\"]\\n\\nfor i in range(2,T+1):\\n nL = [str(i)+(2*i-2)*(\" \"+str(i))]\\n for l in L:\\n nL.append(str(i)+\" \"+l+\" \"+str(i))\\n nL.append(str(i)+(2*i-2)*(\" \"+str(i)))\\n L = nL\\nfor l in L:\\n print(l)\\n"}
{"id": "1064", "input": "number = int(input())\\nfor i in range(number):\\n", "gt": "x = list(map(int, input().split(' ')))\\n print(x[0]%x[1])"}
{"id": "1065", "input": "from math import gcd\\nimport sys\\ninput=lambda : sys.stdin.readline().strip()\\nc=lambda x: 10**9 if(x==\"?\") else int(x)\\ndef main():\\n for _ in range(int(input())):\\n s=list(input())[::-1]\\n l=['F','E','H','C']\\n i=0\\n while(i<len(s)):\\n if(i+3<len(s)):\\n f=True\\n for", "gt": "j in range(i,i+4):\\n if(l[j-i]==s[j] or s[j]=='?'):\\n pass\\n else:\\n f=False\\n break\\n if(f):\\n for j in range(i,i+4):\\n s[j]=l[j-i]\\n if(s[i]==\"?\"):\\n s[i]='A'\\n else:\\n if(s[i]==\"?\"):\\n s[i]=\"A\"\\n i+=1\\n print(*s[::-1],sep='')\\n\\n \\n\\nmain()"}
{"id": "1066", "input": "# cook your dish here\\nfor a in range(int(input())):\\n N,M=map(int,input().split())\\n b=[]\\n for o in range(N):\\n b.append(input())\\n c=[]\\n for d in b:\\n f=[]\\n for e in range(len(d)):\\n if d[e]=='1':\\n f.append(e)\\n c.append(f)\\n i=[]\\n for g in", "gt": "range(len(c)):\\n for h in range(len(c[g])):\\n for j in range(len(c)):\\n for k in range(len(c[j])):\\n if (j>g) or(j==g and k>h):\\n if c[g][h]-c[j][k]>=0:\\n i.append(c[g][h]-c[j][k]+j-g)\\n else:\\n i.append(-1*(c[g][h]-c[j][k])+j-g)\\n l=[m for m in range(1,N+M-1)]\\n for n in l:\\n print(i.count(n),end=' ')"}
{"id": "1067", "input": "for _ in range(int(input())):\\n n=input().rstrip()\\n n=[ele for ele in n]\\n l=len(n)\\n m=10**18+8\\n ini=1\\n for i in range(l-1,-1,-1):\\n if int(n[i])<=m:\\n", "gt": "if ini==1:\\n m=int(n[i])\\n else:\\n m=max(m,n[i])\\n else:\\n m=int(n[i])-1\\n n[i]=str(m)\\n for j in range(l-1,i,-1):\\n n[j]='9'\\n \\n i=0\\n while n[i]=='0':\\n i+=1\\n print(\"\".join(n[i:]))\\n \\n"}
{"id": "1068", "input": "# Fibonacci Series using \\r\\n# Optimized Method \\r\\n\\r\\n# function that returns nth \\r\\n# Fibonacci number\\r\\nMOD = 1000000007\\r\\ndef fib(n):\\r\\n F = [[2, 2],\\r\\n [1, 0]]\\r\\n power(F, n - 1)\\r\\n ans = [6, 2]\\r\\n return (F[0][0] * 6 + F[0][1] * 2) % MOD\\r\\n # return F[0][0]\\r\\n\\r\\n\\r\\ndef multiply(F, M):\\r\\n x = (F[0][0] * M[0][0] +\\r\\n F[0][1] * M[1][0]) % MOD\\r\\n y = (F[0][0] * M[0][1] +\\r\\n F[0][1] * M[1][1]) % MOD\\r\\n z = (F[1][0] * M[0][0] +\\r\\n F[1][1] * M[1][0]) % MOD\\r\\n w = (F[1][0] *", "gt": "M[0][1] +\\r\\n F[1][1] * M[1][1]) % MOD\\r\\n\\r\\n F[0][0] = x\\r\\n F[0][1] = y\\r\\n F[1][0] = z\\r\\n F[1][1] = w\\r\\n\\r\\n\\r\\ndef power(F, n):\\r\\n if n == 0 or n == 1:\\r\\n return\\r\\n M = [[2, 2],\\r\\n [1, 0]]\\r\\n\\r\\n power(F, n // 2)\\r\\n multiply(F, F)\\r\\n\\r\\n if n % 2 != 0:\\r\\n multiply(F, M)\\r\\n\\r\\n\\r\\nfor _ in range(int(input())):\\r\\n n = int(input())\\r\\n ans = 1\\r\\n if n == 0:\\r\\n ans = 1\\r\\n elif n == 1:\\r\\n ans = 2\\r\\n elif n == 2:\\r\\n ans = 6\\r\\n else:\\r\\n ans = fib(n-1)\\r\\n print(ans)\\r\\n"}
{"id": "1069", "input": "# cook your dish here\\nt=int(input())\\nfor _ in range(t):\\n", "gt": "N, M=map(int,input().split())\\n if(N%2==0 or M%2==0):\\n print(\"YES\")\\n else:\\n print(\"NO\")"}
{"id": "1070", "input": "#Note that it's python3 Code. Here, we are using input() instead of raw_input().\\n#You can check on your local machine the version of python by typing \"python --version\" in the", "gt": "terminal.\\n\\n#Read the number of test cases.\\nT = int(input())\\nfor tc in range(T):\\n # Read integers a and b.\\n (a, b) = list(map(int, input().split(' ')))\\n \\n ans = a + b\\n print(ans)"}
{"id": "1071", "input": "# cook your dish here\\n# cook your dish here\\nclass Animal:\\n def __init__(self):\\n start, end, starting_time = map(int, input().split())\\n \\n self.ending_time = starting_time + abs(start - end)\\n self.velocity = 1 if end >= start else -1 \\n \\n self.eaten_by = -1, 10 ** 10\\n \\n self.start = start \\n self.end = end \\n self.starting_time = starting_time \\n \\n def will_collide(self, z):\\n if self.starting_time > z.ending_time or self.ending_time < z.starting_time:\\n return False \\n \\n if self.velocity == z.velocity:\\n if self.starting_time > z.starting_time:\\n self, z = z, self\\n if z.start == self.start + self.velocity * (z.starting_time - self.starting_time):\\n return z.starting_time\\n else:\\n return False\\n", "gt": "\\n if self.velocity == -1:\\n self, z = z, self\\n \\n t = ( z.start - self.start + z.starting_time + self.starting_time ) / 2 \\n \\n return t if self.starting_time <= t <= self.ending_time and z.starting_time <= t <= z.ending_time else False\\n \\n \\n \\ndef main():\\n for _ in range(int(input())):\\n no_cats, no_rats = map(int, input().split())\\n \\n Cats = [Animal() for i in range(no_cats)]\\n \\n for i in range(no_rats):\\n rat = Animal() \\n for j in range(no_cats):\\n time = rat.will_collide(Cats[j])\\n if time:\\n # print(time)\\n if time < rat.eaten_by[1]:\\n rat.eaten_by = j + 1, time \\n \\n \\n print(rat.eaten_by[0])\\n \\n \\n \\nmain()\\n"}
{"id": "1072", "input": "# cook your dish here\\nt=int(input())\\nwhile t>0:\\n n,q=list(map(int,input().split()))\\n blst=[0]\\n for i in range(1,65):\\n blst.append(0)\\n i=1\\n while n>0:\\n if n%2:\\n blst[i]=1\\n n//=2\\n i+=1\\n while q>0:\\n n=int(input())\\n if n==1:\\n p=int(input())\\n", "gt": "if blst[p]:\\n print('ON')\\n else:\\n print('OFF')\\n elif n==2:\\n p=int(input())\\n if blst[p]==0:\\n blst[p]=1\\n elif n==3:\\n p=int(input())\\n if blst[p]==1:\\n blst[p]=0\\n else:\\n p,r=list(map(int,input().split()))\\n if blst[p]!=blst[r]:\\n blst[p]+=1\\n blst[p]%=2\\n blst[r]+=1\\n blst[r]%=2\\n q-=1\\n t-=1\\n"}
{"id": "1073", "input": "t=int(input())\\nfor i in range(t):\\n", "gt": "n=int(input())\\n r=int(n**(.5))\\n d=n-r*r\\n m=d%r\\n print('X'*m+'D'*(m>0)+'X'*(r-m)+'D'*(r+d//r))\\n"}
{"id": "1074", "input": "import sys\\ndef fin(): return sys.stdin.readline().strip()\\ndef fout(s, end=\"\\n\"): sys.stdout.write(str(s)+end)\\n\\nMOD = pow(10, 9)+7\\nt = int(input())\\nwhile t>0:\\n t -= 1\\n n, m = list(map(int, fin().split()))\\n if n ==", "gt": "1:\\n print(m%MOD)\\n continue\\n dp1 = m*(m-1)\\n dp2 = m\\n for i in range(3, n+1):\\n temp = dp2\\n dp2 = dp1 \\n dp1 = (temp*(m-1))%MOD+(dp1*(m-1))%MOD\\n print((dp1+dp2)%MOD)\\n\\n \\n\\n"}
{"id": "1075", "input": "# cook your dish here\\nt=int(input())\\nj=0\\nwhile j<t:\\n n=int(input())\\n lst=list(map(int,input().split()))\\n s=set()\\n d=list()\\n for i in lst:\\n", "gt": "if i in s:\\n s.remove(i)\\n d.append(i)\\n else:\\n s.add(i)\\n x=len(d)\\n if x%2==0:\\n print(x//2)\\n else:\\n print((x-1)//2)\\n j+=1"}
{"id": "1076", "input": "gb = [0, 1, 2, 2, 3, 3]\\nga = [0 for x in range(70)]\\ngag = [0 for x in range(70)]\\nga[0] = 1\\ngag[0] = 0\\n\\nfor i in range(1, 70):\\n if i % 4 == 0:\\n ga[i] = 1.5 * ga[i-1]\\n gag[i] = 0\\n else:\\n ga[i] = 2 * ga[i-1]\\n gag[i] = gag[i-1] + 1\\n\\n\\ndef g(n):\\n if n <", "gt": "6:\\n return gb[n]\\n else:\\n x = n / 6\\n a = 0\\n for i, k in enumerate(ga):\\n if k <= x:\\n a = i\\n else:\\n break\\n return gag[a]\\n\\n\\nt = int(input())\\nfor q in range(t):\\n n = int(input())\\n a = list(map(int, input().split()))\\n\\n res = g(a[0])\\n for i in range(1, n):\\n res ^= g(a[i])\\n\\n if res == 0:\\n print(\"Derek\")\\n else:\\n print(\"Henry\")\\n"}
{"id": "1077", "input": "# cook your dish here\\nclass TestCase:\\n def __init__(self):\\n [self.node_count, self.query_count] = read_line()\\n \\n def fill_nodes(self):\\n self.nodes = {n+1: [] for n in range(self.node_count)}\\n for i in range(self.node_count -1):\\n new_node_1, new_node_2 = read_line()\\n self.nodes[new_node_1].append(new_node_2)\\n self.nodes[new_node_2].append(new_node_1)\\n \\n def resolve_query(self, query):\\n a, d_a, b, d_b = query\\n suiting_a = self.find_nodes_with_distance(a, d_a)\\n suiting_b = self.find_nodes_with_distance(b, d_b)\\n fitting = [node for node in suiting_a if node in suiting_b]\\n \\n if len(fitting) == 0:\\n return -1\\n else:\\n return fitting[0]\\n \\n def find_nodes_with_distance(self, start_node, distance):\\n from_nodes = {start_node}\\n passed_nodes", "gt": "= from_nodes\\n \\n for i in range(distance):\\n to_nodes = set()\\n # add all adjacent nodes\\n for node in from_nodes:\\n to_nodes.update(self.nodes[node])\\n \\n # no backtracking\\n for node in passed_nodes:\\n if node in to_nodes:\\n to_nodes.remove(node)\\n \\n # update which nodes are passed\\n passed_nodes.update(to_nodes)\\n # go another round with the new nodes found\\n from_nodes = to_nodes\\n return list(from_nodes)\\n\\ndef read_line():\\n line = input()\\n return [int(s) for s in line.split(' ')]\\n\\nnum_testcases = int(input())\\nfor i in range(num_testcases):\\n testcase = TestCase()\\n testcase.fill_nodes()\\n for q in range(testcase.query_count):\\n query = read_line()\\n print(testcase.resolve_query(query))"}
{"id": "1078", "input": "t = int(input())\\n\\nfor i in range(t):\\n n = int(input())\\n dir = []\\n \\n for j in range(n):\\n dir.append(input().strip().split())\\n \\n for j in", "gt": "range(n-1):\\n if dir[j+1][0] == 'Right':\\n dir[j][0] = 'Left'\\n else:\\n dir[j][0] = 'Right'\\n\\n dir[n-1][0] = 'Begin'\\n\\n for j in reversed(dir):\\n print(' '.join(j))\\n\\n\\n \\n"}
{"id": "1079", "input": "t=int(input())\\nfor i in range(t):\\n n,w1,w2,w3=map(int,input().split())\\n if n>=w1+w2+w3:\\n", "gt": "print(1)\\n elif n>=w1+w2 or n>=w2+w3:\\n print(2)\\n else:\\n print(3)"}
{"id": "1080", "input": "# cook your dish here\\nx=int(input())\\nfor", "gt": "i in range(x):\\n h=input()\\n print(h.count('4'))\\n"}
{"id": "1081", "input": "def res(s):\\n if len(s) == 2:\\n if s[0] == s[1]:\\n print(\"NO\")\\n else:\\n print(\"YES\")\\n\\n elif s[0] != s[1]:\\n counte = 0\\n for i in range(2, len(s)):\\n if i % 2 == 0:\\n if s[i] !=", "gt": "s[0]:\\n counte = 1\\n break\\n else:\\n if s[i] != s[1]:\\n counte = 1\\n break\\n\\n if counte == 0:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n else:\\n print(\"NO\")\\n\\n\\ndef __starting_point():\\n t = int(input())\\n for _ in range(t):\\n stri = str(input())\\n res(stri)\\n__starting_point()"}
{"id": "1082", "input": "# cook your dish here\\nimport string \\nfrom collections import OrderedDict\\nfrom itertools import zip_longest\\ndic = OrderedDict(zip(string.ascii_uppercase, range(0, 26)))\\nkeys = [98, 57, 31, 45, 46]\\nt = int(input()) # number of test cases\\ns1 = []\\nfor i in range(t):\\n s = input()\\n for i in s:\\nif i in dic.keys():\\n s1.append(int(i.replace(i, str(dic[i]))))\\n s2 = [sum(t) for t in zip_longest(s1, keys, fillvalue=0)]\\n inv_dic = {v:k for k,v", "gt": "in dic.items()}"}
{"id": "1083", "input": "counter = -1\\r\\ndef flattree(node):\\r\\n nonlocal counter\\r\\n if visited[node]==1:\\r\\n return\\r\\n else:\\r\\n visited[node]=1\\r\\n counter += 1\\r\\n i_c[node] = counter\\r\\n\\r\\n flat_tree[counter] = swt[node]\\r\\n\\r\\n for i in graph[node]:\\r\\n if visited[i]==0:\\r\\n flattree(i)\\r\\n counter += 1\\r\\n o_c[node] = counter\\r\\n flat_tree[counter] = -swt[node]\\r\\n return\\r\\n\\r\\n\\r\\ndef getsum(BITTree, i):\\r\\n s = 0 # initialize result\\r\\n i = i + 1\\r\\n while i > 0:\\r\\n s += BITTree[i]\\r\\n i -= i & (-i)\\r\\n return s\\r\\n\\r\\ndef upd(BITTree, n, i, v):\\r\\n i += 1\\r\\n while i <= n:\\r\\n BITTree[i] += v\\r\\n i += i & (-i)\\r\\n\\r\\ndef construct(arr,", "gt": "n):\\r\\n BITTree = [0] * (n + 1)\\r\\n for i in range(n):\\r\\n upd(BITTree, n, i, arr[i])\\r\\n return BITTree\\r\\n\\r\\nfrom collections import defaultdict\\r\\nn = int(input())\\r\\nswt = list(map(int, input().split()))\\r\\ngraph = defaultdict(list)\\r\\n\\r\\nfor i in range(n-1):\\r\\n n1, n2 = list(map(int, input().split()))\\r\\n graph[n1-1].append(n2-1)\\r\\n graph[n2-1].append(n1-1)\\r\\n\\r\\nflat_tree = [0]*(2*n+1)\\r\\ni_c = [0]*n\\r\\no_c = [0]*n\\r\\nvisited = [0]*n\\r\\nflattree(0)\\r\\n\\r\\ntre = construct(flat_tree, 2*n)\\r\\n\\r\\nq = int(input())\\r\\nfor i in range(q):\\r\\n query = list(map(int, input().split()))\\r\\n if query[0] == 1:\\r\\n node = query[1] - 1\\r\\n answer = getsum(tre, i_c[node])\\r\\n print(answer)\\r\\n else:\\r\\n node = query[1]-1\\r\\n upd(flat_tree, (2*n), i_c[node], query[2])\\r\\n upd(flat_tree, (2*n), o_c[node], -query[2])\\r\\n"}
{"id": "1084", "input": "for i in range(eval(input())):\\n n,m,z,l,r,b = list(map(int, input().split()))\\n rows=n\\n columns=m\\n hand_rest=n*(m+1)\\n if(m%2==0):\\n", "gt": "hand_rest -=max(0,n-l-r)\\n if(l+r+(2*b)<=hand_rest):\\n # print \"kanu\"\\n print(min(n*m,l+r+z+b))\\n else:\\n temp=l+r+(hand_rest-l-r)/2\\n # print \"parth\"\\n print(min(n*m,temp+z))"}
{"id": "1085", "input": "# cook your dish here\\ns=input()\\ns1=s[::-1]\\narr=[]\\ncnt=0\\nfor i in range(len(s1)):\\n arr.append(s1[i])\\nfor i in", "gt": "range(len(arr)):\\n if(arr[i]==\"1\"):\\n for j in range(i,len(arr)):\\n if(arr[j]==\"1\"):\\n arr[j]=\"0\"\\n else:\\n arr[j]=\"1\"\\n cnt+=1\\nprint(cnt)"}
{"id": "1086", "input": "d = {}\\nfor i in range(26):\\n char = chr(i+ord('a'))\\n d[char] = []\\nfor i in range(26):\\n char = chr(i+ord('a'))\\n temp = list(map(int,input().strip().split()))\\n for j in range(26):\\n if (temp[j] == 1):\\n follow=", "gt": "chr(j+ord('a'))\\n d[follow].append(char)\\n \\ndef f(char,i,n,count):\\n if (i==n):\\n return count+1\\n else:\\n ans = 0\\n for c in d[char]:\\n ans+=f(c,i+1,n,0)\\n ans%=(10**9+7)\\n return ans\\n\\nfor q in range(int(input().strip())):\\n c, n = input().strip().split()\\n n = int(n)\\n print(f(c,1,n,0))"}
{"id": "1087", "input": "# cook your dish here\\nmod = 10**9 + 7\\nfrom math import gcd\\ndef fac50():\\n f = [0]*51\\n f[0] ,f[1] = 1,1\\n for i in range(1,51):f[i] = (f[i-1]*i)%mod\\n return f\\ndef gcd110():\\n gc = [[0]*111 for i in range(111)]\\n for i in range(111):\\n for j in range(111):gc[i][j] = gcd(i,j)\\n return gc\\nfactorials,gcds = fac50(),gcd110()\\ndef rule_asc(n,l):\\n a,k = [0 for i in range(n + 1)],1\\n a[1] = n\\n while k != 0:\\n x,y = a[k - 1] + 1,a[k] - 1 \\n k -= 1\\n while x <= y and k < l - 1:\\n a[k],y = x,y-x\\n k += 1\\n a[k] = x + y\\n yield a[:k + 1]\\ndef niceness(s):\\n t = 0\\n", "gt": "for i in range(len(s)):\\n for j in range(i+1,len(s)):t = (t + gcds[s[i]][s[j]])%mod\\n return t\\ndef permcount(s,c):\\n f,p = [s.count(x) for x in set(s)],factorials[c] \\n for e in f:p = (p*pow(factorials[e],mod-2,mod))%mod\\n return p\\ndef main():\\n for i in range(int(input())):\\n n,s = [int(item) for item in input().split()]\\n a = [int(item) for item in input().split()]\\n b = [i for i in a if i != -1]\\n s , ones = s - sum(b),a.count(-1) \\n if s < 0:print(0)\\n elif (s == 0 and ones == 0):print(niceness(a)%mod)\\n elif (s > 0 and ones == 0):print(0)\\n else:\\n t = 0\\n for seq in rule_asc(s,ones):\\n if len(seq) == ones: t = (t + (((permcount(seq,ones))%mod)*(niceness(b+seq)%mod))%mod)%mod\\n print(t) \\ndef __starting_point():main()\\n__starting_point()"}
{"id": "1088", "input": "#!/usr/bin/env python\\n\\ndef iscycle(E, v, EXPLORED_NODES, EXPLORED_EDGES):\\n EXPLORED_NODES.add(v)\\n r = False\\n for e in [x for x in E if v in x]:\\n if e in EXPLORED_EDGES: continue\\n if e[0] == v: w = e[1]\\n else: w = e[0]\\n if w in EXPLORED_NODES:\\n return True\\n else:\\n EXPLORED_EDGES.add(e)\\n r = r", "gt": "or iscycle(E, w, EXPLORED_NODES, EXPLORED_EDGES)\\n if r: break\\n return r\\n\\ndef process(E):\\n return iscycle(E, 1, set(), set()) and 'NO' or 'YES'\\n\\ndef main():\\n N, M = list(map(int, input().split()))\\n E = []\\n for m in range(M):\\n U, V = list(map(int, input().split()))\\n if U > V: U, V = V, U\\n E.append((U, V))\\n print(process(E))\\n\\nmain()\\n\\n"}
{"id": "1089", "input": "t=int(input())\\nwhile(t):\\n s=input().split()\\n m=int(s[0])\\n p=float(s[1])\\n if(m%2==0):\\n", "gt": "r=(1-p**m)/(p+1)\\n else:\\n r=(1+p**m)/(p+1)\\n print(1000000000*r,1000000000*(1-r))\\n t-=1"}
{"id": "1090", "input": "def dfs(node):\\n nonlocal adj,leaf\\n val=0\\n flag=0\\n for i in adj[node]:\\n x= dfs(i)\\n val+=x\\n if x==0:\\n flag=1\\n leaf+=val-val%3\\n if val%3==0 and flag==0:\\n return 1\\n else:\\n return", "gt": "0\\nfor _ in range(int(input())):\\n n=int(input())\\n adj=[[] for i in range(n+2)]\\n arr=[int(i) for i in input().split()]\\n leaf=0\\n #print(adj)\\n for i in range(2,n+1):\\n #print(i,arr[i-2])\\n adj[arr[i-2]].append(i)\\n \\n dfs(1)\\n print(n-leaf)"}
{"id": "1091", "input": "# cook your dish here\\n\\nimport collections\\n\\ndef shortestSubarray(A, K):\\n \\n \\n N = len(A)\\n P = [0]\\n\\n for x in A:\\n P.append(P[-1] + x)\\n\\n #Want smallest y-x with Py - Px >= K\\n ans = N+1 # N+1 is impossible\\n monoq = collections.deque() #opt(y) candidates, represented as indices of P\\n for y, Py in enumerate(P):\\n #Want opt(y) = largest x with Px <= Py -", "gt": "K\\n if not monoq: \\n if Py>=K: return 1\\n while monoq and Py <= P[monoq[-1]]:\\n monoq.pop()\\n\\n while monoq and Py - P[monoq[0]] >= K:\\n ans = min(ans, y - monoq.popleft())\\n\\n monoq.append(y)\\n\\n return ans if ans < N+1 else -1\\n \\n \\nfor t in range(int(input())):\\n N, D = [int(x) for x in input().split()]\\n \\n A = [int(x) for x in input().split()] \\n \\n print(shortestSubarray(A, D))\\n \\n"}
{"id": "1092", "input": "# cook your dish here\\nimport math\\ndef isPos(num):\\n if num%2==0:\\n for i in range(num,2*num,1):\\n if ((num**2)-((i/2)**2))**(1/2)==int(((num**2)-((i/2)**2))**(1/2)):\\n return 'YES'\\n return", "gt": "'NO'\\n else:\\n for i in range(num+1,2*num,1):\\n if ((num**2)-((i/2)**2))**(1/2)==int(((num**2)-((i/2)**2))**(1/2)):\\n return 'YES'\\n return 'NO'\\n\\ntest = int(input())\\nfor __ in range(test):\\n num=int(input())\\n print(isPos(num))\\n"}
{"id": "1093", "input": "# cook your dish here\\nt=int(input())\\nfor i in range(t):\\n (n,k,e,m)=tuple(map(int,input().split()))\\n scores=[]\\n for jin range(n-1):\\n scores.append(sum(list(map(int,input().split()))))\\n scores.sort(reverse=True);\\n", "gt": "bsc=scores[k-1];"}
{"id": "1094", "input": "# # # # n = int(input())\\r\\n# # # # arr = list(map(int , input().split()))\\r\\n# # # # for _ in range(int(input())):\\r\\n# # # # l,r,mod = map(int , input().split())\\r\\n# # # # pro = 1\\r\\n# # # # for i in range(l - 1,r):\\r\\n# # # # pro *= arr[i]\\r\\n# # # # print(pro % mod) #sample testcases passed #TLE\\r\\n# # # import numpy #or use math\\r\\n# # # n = int(input())\\r\\n# # # arr = list(map(int , input().split()))\\r\\n# # # for _ in range(int(input())):\\r\\n# # # l,r,mod = map(int , input().split())\\r\\n# # # print(numpy.prod(arr[l - 1:r]) % mod) #sample cases passed, WA\\r\\n# # import math\\r\\n# # primes,dic,t = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97],{},0\\r\\n# # for i in primes:\\r\\n# # dic[i] = t\\r\\n# # t += 1\\r\\n# # def primeFactors(n,arr): \\r\\n# # for i in range(2,int(math.sqrt(n)) + 1,2): \\r\\n# # while(n % i == 0): \\r\\n# # arr[dic[i]] += 1 \\r\\n# # n /= i\\r\\n# # if(n > 2):\\r\\n# # arr[dic[n]] += 1\\r\\n# # return arr\\r\\n# # n = int(input())\\r\\n# # A = list(map(int , input().split()))\\r\\n# # dp = [0]*len(primes)\\r\\n# # for i in range(1,n + 1):\\r\\n# # r = [dp[i - 1]].copy()\\r\\n# # dp.append(primeFactors(A[i - 1],r))\\r\\n# # for _ in range(int(input())):\\r\\n# # li,ri,m=list(map(int,input().split()))\\r\\n# # ans = 1\\r\\n# # for i in range(len(primes)):\\r\\n# # ans *= (pow(primes[i],dp[ri][i] - dp[li - 1][i],m)) % m\\r\\n# #", "gt": "print(ans % m) #NZEC\\r\\n# import math\\r\\n# primes=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\\r\\n# dic="}
{"id": "1095", "input": "t = int(input())\\nfor i in range(t):\\n n = int(input())\\n suffixes = {}\\n xx = input().split()\\n for x in range(n):\\n try:\\n a = suffixes[xx[x][-3:]]\\n except Exception as", "gt": "e:\\n a = []\\n a.append(xx[x])\\n\\n suffixes.update("}
{"id": "1096", "input": "n=int(input())\\narr=[int(x) for x in input().split()]\\nl=[1]*n\\nif sorted(arr)==arr:\\n print('0')\\nelse:\\n for i in", "gt": "range(0,len(arr)):\\n for j in range(i):\\n if arr[i]>=arr[j] and l[i]<l[j]+1:\\n l[i]=l[j]+1\\n print(n-max(l))"}
{"id": "1097", "input": "import sys\\nn, x, y = input().split(' ')\\nn = int(n)\\nx = int(x)\\ny = int(y)\\ncontests = {}\\n\\nfor i in range(n):\\n s, e = input().split(' ')\\n s = int(s)\\n e = int(e)\\n contests[(s, e)] = abs(s-e)\\n\\nv_time = input().split(' ')\\nw_time = input().split(' ')\\n\\nv_time, w_time = list(map(int, v_time)), list(map(int, w_time))\\nv_time.sort()\\nw_time.sort()\\n\\n\\nscore = sys.maxsize\\n\\ncontests = dict(sorted(contests.items(),", "gt": "key=lambda item: item[1]))\\nfor k, v in contests.items():\\n start=-1\\n end = sys.maxsize\\n for i in range(x):\\n if v_time[i] > k[0]:\\n break\\n start = v_time[i]\\n for j in range(y):\\n if w_time[j] >= k[1]:\\n end = w_time[j]\\n break\\n if start == -1:\\n continue\\n score = min(score, (end-start+1))\\n if score-1 <= v:\\n break\\n\\nprint(score)"}
{"id": "1098", "input": "testcases=int(input())\\nresults=[]\\nfor i in range(0,testcases):\\n friends=int(input())\\n l,b=list(map(int,input().split()))\\n over=False\\n if b>l:\\n temp=b\\n b=l\\n l=temp\\n for counter in range(0,friends):\\n if l==b:\\n over=True\\n", "gt": "break\\n elif l>b:\\n l=l-b\\n if b>l:\\n temp=b\\n b=l\\n l=temp\\n \\n if over:\\n results.append(\"No\")\\n else:\\n results.append(\"Yes \"+str(l*b))\\n\\nfor i in range(0,testcases):\\n print(results[i])\\n"}
{"id": "1099", "input": "# cook your dish here\\nfor i in range(int(input())):\\n n = int(input())\\n l = list(map(int,input().split()))\\n", "gt": "s = 0\\n l.sort(reverse = True)\\n for i in range(0,n,2):\\n s = s+l[i]\\n print(s)\\n"}
{"id": "1100", "input": "import sys\\n\\ndef f(p):\\n votes = {}\\n for x in range(p):\\n str = sys.stdin.readline()\\n t = str.split()\\n votes[t[0]] = t[1]\\n\\n ans = 0\\n for", "gt": "per in votes:\\n if votes[per] == \"+\":\\n ans= ans+1\\n else:\\n ans = ans-1\\n\\n return ans\\n\\nx = sys.stdin.readline()\\nfor t in range(int(x)):\\n p = sys.stdin.readline()\\n print(f(int(p)))\\n"}
{"id": "1101", "input": "# cook your dish here\\n\"\"\"\\nInput:\\nThe first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\\nThe first line of each test case contains three space-separated integers p, q and r.\\nThe second line contains three space-separated integers a, b and c.\\nOutput:\\nFor each test case, print a single", "gt": "line containing one integer ― the maximum required number of operations(if the conversion is possible), or else print \"-1\"\\n\"\"\"\\n\\nT=int(input())\\nwhile T>0:\\n T-=1 \\n p,q,r=list(map(int,input().split()))\\n a,b,c=list(map(int,input().split()))\\n #ds=list()\\n s=0\\n d1=a-p\\n if d1>0:\\n #ds.append(d1)\\n s+=d1\\n d2=b-q\\n if d2>0:\\n #ds.append(d2)\\n s+=d2\\n d3=c-r\\n if d3>0:\\n #ds.append(d3)\\n s+=d3\\n \\n if(d1==0 and d2==0 and d3==0):\\n print(0)\\n elif(d1<0 or d2<0 or d3<0):\\n print(-1)\\n else:\\n print(s)\\n \\n \\n"}
{"id": "1102", "input": "from collections import Counter\\r\\nfrom math import factorial\\r\\ndef nc3(n):\\r\\n a=factorial(n)\\r\\n b=factorial(n-3)\\r\\n return ((a)/(b*6))\\r\\ndef rem(s,k):\\r\\n t=-1\\r\\n x=-1\\r\\n for i in range(len(s)):\\r\\n if s[i][0]>2 and s[i][1]<=k:\\r\\n if s[i][0]>3:\\r\\n ch=(nc3(s[i][0])-nc3(s[i][0]-1))/s[i][1]\\r\\n else:\\r\\n ch=1/s[i][1]\\r\\n if t<ch:\\r\\n t=ch\\r\\n x=i\\r\\n return x\\r\\nt=int(input())\\r\\nfor x in range(t):\\r\\n n,c,k=map(int,input().split())\\r\\n l={}\\r\\n for i in range(n):\\r\\n", "gt": "a,b,e=map(int,input().split())\\r\\n if e in l:\\r\\n l[e].append(a)\\r\\n else:\\r\\n l[e]=[]\\r\\n l[e].append(a)\\r\\n v=list(map(int,input().split()))\\r\\n s=[]\\r\\n for i in range(1,c+1):\\r\\n if i in l:\\r\\n s+=[[len(l[i]),v[i-1]]]\\r\\n s.sort(key = lambda x: x[0],reverse=True)\\r\\n while True:\\r\\n ma=rem(s,k)\\r\\n if ma<=-1:\\r\\n break\\r\\n else:\\r\\n s[ma][0]-=1\\r\\n k=k-s[ma][1]\\r\\n re=0\\r\\n for i in s:\\r\\n if i[0]>2:\\r\\n re=re+nc3(i[0])\\r\\n print(int(re))\\r\\n"}
{"id": "1103", "input": "for _ in range(int(input())):\\n n=int(input())\\n n1=0\\n ans=1\\n while(n>0):\\n d=int(n % 10)\\n if(d!=0):\\n if(d!=9 and d!=7 and", "gt": "d!=1):\\n n1=3\\n elif(d==1):\\n n1=1\\n else:\\n n1=4\\n ans=(int(ans)*int(n1))% (1000000007)\\n n/=10\\n else:\\n n/=10\\n if(ans==1):\\n print(\"0\")\\n else:\\n print(ans %(1000000007))\\n"}
{"id": "1104", "input": "import sys\\nimport math\\nr=int(input())\\nfor v in range (0,r):\\n n = int(input())\\n x=1\\n arr=list(map(int,input().strip().split(\" \")))\\n for i in", "gt": "range (0,n):\\n x=x*arr[i]\\n \\n for i in range (2,100000000):\\n if(x%(pow(i,2))==0):\\n ans1=i\\n break\\n \\n \\n print(ans1) \\n"}
{"id": "1105", "input": "# cook your dish here\\nT=int(input())\\nMOD=int(1e9+7)\\nfor t in range(T):\\n N,K=[int(a) for a in input().split()]\\n M=K//2\\n # ans=", "gt": "((K%2)?( (N+M)*(N+M) + M ):( (N+M)*(N+M) - M) )\\n ans=(N+M)*(N+M) -M\\n if(K%2):\\n ans+=2*M\\n if(N==0):\\n ans=K*(K-1)\\n print(ans%MOD)"}
{"id": "1106", "input": "for i in range(int(input())):\\n n=int(input())\\n c=[int(z) for z in input().split()]\\n c.sort()\\n c.reverse()\\n b1,b2=0,0\\n", "gt": "for i in range(n):\\n if b1<b2:\\n b1+=c[i]\\n elif b2<b1:\\n b2+=c[i]\\n else:\\n b1+=c[i]\\n print(max(b1,b2))\\n \\n"}
{"id": "1107", "input": "'''Well I found the bug, but I don't understand why it was doing that. I mean, as\\nfar as I can tell, it shouldn't be a bug!\\nNote to self: deleting from (supposedly) local lists through recursion is dangerous!'''\\n\\nclass Group(object):\\n def __init__(self,size,start,end,value):\\n self.size = size\\n self.start = start\\n self.end = end\\n self.value = value\\n \\n def __lt__(self,other):\\n return self.start < other.start\\n \\n def __str__(self):\\n return \"%i: %i->%i, $%i\" %(self.size,self.start,self.end,self.value)\\n \\n \\ndef hash(car,i):\\n people = []\\n for group in car:\\n people.extend([group.end]*group.size)\\n people.sort()\\n return tuple(people+[i])\\n \\n \\ndef optimize(groups,car,capacity,i): \\n if i == len(groups):\\n return 0\\n \\n newcar = []\\n pos", "gt": "= groups[i].start\\n for group in car:\\n if group.end > pos:\\n newcar.append(group)\\n else:\\n capacity += group.size\\n \\n state = hash(newcar,i)\\n try:\\n return memo[state]\\n except:\\n v = optimize(groups,newcar,capacity,i+1) \\n if groups[i].size <= capacity:\\n w = optimize(groups,newcar+[groups[i]],capacity-groups[i].size,i+1) + groups[i].value\\n else:\\n w = 0\\n \\n if v > w:\\n ie[state] = -1\\n elif v < w:\\n ie[state] = 1\\n else:\\n ie[state] = 0\\n \\n ans = max(v,w)\\n memo[state] = ans\\n return ans\\n \\ncases = int(input())\\nfor case in range(cases):\\n memo ="}
{"id": "1108", "input": "# cook your dish here\\nfrom sys import stdin\\nfrom math import sqrt,ceil,log10\\ndef get_sum(a,b,digits):\\n sum=((b+a)*(b-a+1))//2\\n return sum*digits\\n\\ndef solve():\\n mod=10**9+7\\n thehighlimiter={i: 10 ** i - 1 for i in range(12)}\\n thelowlimiter={i:", "gt": "10**i for i in range(12)}\\n for _ in range(int(input())):\\n l,r=map(int, stdin.readline().strip().split())\\n low=len(str(l))\\n high=len(str(r))\\n ans=0\\n if low==high:\\n ans=get_sum(l,r,low)\\n else:\\n ans+=get_sum(l,((10**low)-1),low)\\n ans+=get_sum((10**(high-1)),r,high)\\n for i in range(low+1,high):\\n ans+=get_sum(10**(i-1),(10**i)-1,i)\\n print(ans%mod)\\n\\ndef __starting_point():\\n solve()\\n\\n__starting_point()"}
{"id": "1109", "input": "N,M,K=map(int,input().split())\\nc=0\\nfor i in range(N):\\n T=list(map(int,input().split()))\\n Q=T[-1]\\n", "gt": "T.pop(-1)\\n if Q<=10 and sum(T)>=M:\\n c+=1\\nprint(c)"}
{"id": "1110", "input": "import math\\nfor t in range(int(input())):\\n n = int(input())\\n temp", "gt": "= math.sqrt(n)\\n if (temp == int(temp)):\\n print(\"YES\")\\n else:\\n print(\"NO\")"}
{"id": "1111", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n=int(input());li=list(map(int,input().split()));dli=dict();modi=0\\n for i in li:\\n if i not in dli:dli[i]=1\\n else:dli[i]+=1\\nop=sorted(list(dli))\\n if(len(dli)!=0):\\n while 1:\\n tmp=[]\\n for i in op:\\n if dli[i]==0:continue\\n tmp.append(i);dli[i]-=1\\n", "gt": "l=len(tmp);"}
{"id": "1112", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n=int(input())\\n a=list(map(int,input().split()))\\n even=[]\\n", "gt": "odd=[]\\n for i in a:\\n if(i & 1):\\n even.append(i)\\n else:\\n odd.append(i)\\n print(len(even)*len(odd))"}
{"id": "1113", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n = int(input())\\n m = n\\n x= 1\\n for", "gt": "i in range(n):\\n for j in range(m):\\n print(x, end = '')\\n x += 1\\n print()\\n m -= 1"}
{"id": "1114", "input": "t = input();\\n\\na = [0 for i in range(10001)]\\n\\ni = 0;\\n\\nwhile i < int(t):\\n\\n n = input();\\n\\n k = input();\\n\\n assert(len(k.split(' ')) == int(n));\\n\\n for each in k.split(' '):\\n\\n a[int(each)]", "gt": "+= 1;"}
{"id": "1115", "input": "T=int(input())\\nfor i in range(T):\\n N=int(input())\\n A=list(map(int,input().split()))[:N]\\n l=[]\\n for", "gt": "j in range(len(A)):\\n for k in range(j+1,len(A)):\\n l.append(A[j]+A[k])\\n print(l.count(max(l))/((N*(N-1))/2))"}
{"id": "1116", "input": "T = int(input())\\n\\nM = 10 ** 9 + 7\\n\\nfor _ in range(T):\\n N = int(input())\\n\\n A = list(map(int, input().split()))\\n\\n if N == 1:\\n print(0)\\n continue\\n\\n B = {}\\n C = {}\\n\\n for i in range(N - 1):\\n u, v = input().split()\\n u = int(u) - 1\\n v = int(v) - 1\\n\\n if u not in B:\\n B[u] = []\\n\\n if v not in B:\\n B[v] = []\\n\\n B[u].append(v)\\n B[v].append(u)\\n\\n total_leaves = 0\\n\\n for i in B:\\n if len(B[i]) == 1:\\n total_leaves += 1\\n\\n S = [0]\\n\\n visited = [False] * N\\n\\n parent = [-1] * N\\n\\n total_visits = [0] * N\\n\\n while len(S) > 0:\\n current = S.pop(len(S) - 1)\\n\\n if visited[current]:\\n p = parent[current]\\n if p != -1:\\n total_visits[p] += total_visits[current]\\n if p not in C:\\n C[p] = {}\\n C[p][current] = total_visits[current]\\n if current not in C:\\n C[current] = {}\\n C[current][p] = total_leaves - C[p][current]\\n else:\\n S.append(current)\\n", "gt": "visited[current] = True\\n for i, j in enumerate(B[current]):\\n if not visited[j]:\\n parent[j] = current\\n S.append(j)\\n if len(B[current]) == 1:\\n total_visits[current] = 1\\n p = parent[current]\\n if p != -1:\\n if p not in C:\\n C[p] ="}
{"id": "1117", "input": "from collections import defaultdict \\ndef findSubarraySum(arr, n, Sum): \\n \\n # Dictionary to store number of subarrays \\n # starting from index zero having \\n # particular value of sum. \\n prevSum = defaultdict(lambda : 0) \\n \\n res = 0 \\n \\n # Sum of elements so far. \\n currsum = 0 \\n \\n for i in range(0, n): \\n \\n # Add current element to sum so far. \\n currsum += arr[i] \\n \\n # If currsum is equal to desired sum, \\n # then a new subarray is found. So \\n #", "gt": "increase count of subarrays. \\n if currsum == Sum: \\n res += 1 \\n \\n # currsum exceeds given sum by currsum - sum. \\n # Find number of subarrays having \\n # this sum and exclude those subarrays \\n # from currsum by increasing count by \\n # same amount. \\n if (currsum - Sum) in prevSum: \\n res += prevSum[currsum - Sum] \\n \\n \\n # Add currsum value to count of \\n # different values of sum. \\n prevSum[currsum] += 1 \\n \\n return res \\nn=int(input())\\nlst=list(map(int,input().split()))\\nif(n==1):\\n if(lst[0]==0):\\n print(1)\\n else:\\n print(0)\\nelse: \\n print(findSubarraySum(lst,n,0)) \\n"}
{"id": "1118", "input": "import numpy as np\\n\\ndef sort_it(array):\\n new_list = []\\n for i in range(len(array)):\\n start = 0\\n value = array[i][0]\\n last = len(new_list)\\n while start != last:\\n mid = (start + last) // 2\\n if new_list[mid][0] > value:\\n last = mid\\n else:\\n start = mid+1\\n new_list.insert(start,array[i])\\n return new_list\\n\\ntests = int(input())\\nfor _ in range(tests):\\n n, m, q = [int(j) for j in input().split()]\\n challenges = [[0] * 3 for _ in range(m)]\\n combos = [[0] * 2 for _ in range(q)]\\n for i in range(m):\\n challenges[i] = [int(j) for j in input().split()]\\n for i in range(q):\\n combos[i] = [int(j) for j in input().split()]\\n \\n", "gt": "sorted_chalenges = np.zeros((2 * m, 3),dtype=np.intc)\\n for i in range(m):\\n sorted_chalenges[2*i] = [challenges[i][0]-1,challenges[i][2],i]\\n sorted_chalenges[2*i+1] = [challenges[i][1],-challenges[i][2],i]\\n sorted_chalenges = np.array(sort_it(sorted_chalenges))\\n types_of_players = np.zeros((m + 1, 2 * m + 1),dtype=np.intc)\\n player_type = np.zeros(n,dtype=np.intc)\\n last_player = 0\\n for i in range(2 * m):\\n start, value, chal = sorted_chalenges[i]\\n types_of_players[chal+1:,i+1:] += value\\n player_type[last_player:start] = i\\n last_player = start\\n player_type[last_player:] = 2 * m\\n \\n combo_types = np.zeros((q, 2 * m + 1),dtype = np.intc)\\n for i in range(q):\\n first, last = combos[i]\\n r, p = [types_of_players[first - 1], types_of_players[last]]\\n combo_types[i] = np.maximum(p-r,0)\\n output = np.sum(combo_types,axis=0)[player_type]\\n for i in range(n):\\n print(output[i], end = \" \")\\n print(\"\")\\n"}
{"id": "1119", "input": "'''\\nName : Jaymeet Mehta\\ncodechef id :mj_13\\nProblem : Avenir Strings\\n'''\\nfrom sys import stdin,stdout\\ntest=int(stdin.readline())\\nfor _ in range(test):\\n N=int(stdin.readline())\\n seq=list(input())\\n fp,fp1,fl,fl1=0,0,0,1\\n for", "gt": "i in range(N):\\n if fl!=int(seq[i])-0:\\n fp+=1\\n fl=1-fl\\n for i in range(N):\\n if fl1!=int(seq[i])-0:\\n fp1+=1\\n fl1=1-fl1\\n print(fp) if fp<fp1 else print(fp1)"}
{"id": "1120", "input": "#dt = {} for i in x: dt[i] = dt.get(i,0)+1\\r\\nimport sys;input = sys.stdin.readline\\r\\ninp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]\\r\\n\\r\\ndef kadane(arr, start, finish, n):\\r\\n Sum = 0\\r\\n maxSum = float('-inf')\\r\\n i = None\\r\\n finish[0] = -1\\r\\n local_start = 0\\r\\n for i in range(n):\\r\\n Sum += arr[i]\\r\\n if Sum < 0:\\r\\n Sum = 0\\r\\n local_start = i + 1\\r\\n elif Sum > maxSum:\\r\\n maxSum = Sum\\r\\n start[0] = local_start\\r\\n finish[0] = i\\r\\n\\r\\n if finish[0] != -1:\\r\\n return maxSum\\r\\n\\r\\n maxSum = arr[0]\\r\\n start[0] = finish[0] = 0\\r\\n\\r\\n for i in range(1, n):\\r\\n if arr[i] > maxSum:\\r\\n maxSum = arr[i]\\r\\n start[0] = finish[0]", "gt": "= i\\r\\n return maxSum\\r\\n\\r\\ndef findMaxSum(M):\\r\\n nonlocal ROW, COL\\r\\n maxSum, finalLeft = float('-inf'), None\\r\\n finalRight, finalTop, finalBottom = None, None, None\\r\\n left, right, i = None, None, None\\r\\n\\r\\n temp = [None] * ROW\\r\\n Sum = 0\\r\\n start = [0]\\r\\n finish = [0]\\r\\n\\r\\n for left in range(COL):\\r\\n temp = [0] * ROW\\r\\n for right in range(left, COL):\\r\\n for i in range(ROW):\\r\\n temp[i] += M[i][right]\\r\\n Sum = kadane(temp, start, finish, ROW)\\r\\n if Sum > maxSum:\\r\\n maxSum = Sum\\r\\n finalLeft = left\\r\\n finalRight = right\\r\\n finalTop = start[0]\\r\\n finalBottom = finish[0]\\r\\n\\r\\n for i in range(finalTop,finalBottom+1):\\r\\n print(*M[i][finalLeft:finalRight+1])\\r\\n\\r\\n\\r\\nROW,COL = ip()\\r\\nM = [ip() for i in range(ROW)]\\r\\nfindMaxSum(M)\\r\\n\\r\\n\\r\\n \\r\\n"}
{"id": "1121", "input": "#AUTHOR:: AMAN VERMA\\ntry:\\n for _ in range(int(input())):\\n", "gt": "row,column=list(map(int,input().split(\" \")))\\n x_x,y_y=list(map(int,input().split(\" \")))\\n ab=max((x_x-0),(row-x_x-1))\\n ba=max((y_y-0),(column-y_y-1))\\n print(ab+ba)\\nexcept:\\n pass\\n"}
{"id": "1122", "input": "# cook your dish here\\nt=int(input())\\nwhile t>0:\\n a=input().split(\":\")\\n a1=int(a[0])\\n a2=int(a[1])\\n b1=a1%12 \\n if a2%5!=0:\\n b2=(a2//5)*5+5\\n else:\\n b2=a2\\n \\n c1=b1*30 \\n \\n extra=0.5*b2 \\n c1+=extra\\n c1%=360\\n\\n d1=(b2//5)*30 \\n", "gt": "d1%=360 \\n \\n if c1>d1:\\n ans1=c1-d1 \\n ans2=360-ans1\\n else:\\n ans1=d1-c1\\n ans2=360-ans1\\n ans=min(ans1,ans2)\\n if ans==int(ans):\\n ans3=int(ans)\\n y=str(ans3)+\" degree\"\\n print(y)\\n else:\\n y=str(ans)+\" degree\"\\n print(y)\\n \\n t-=1\\n \\n \\n"}
{"id": "1123", "input": "# cook your dish here\\nwhile True:\\n try:\\n m=int(input())\\n \\n n=int(m/2)\\n \\n a=m-n\\n \\n sum_even=", "gt": "int(2*(2*n*(n+1)*(2*n+1))/3)\\n \\n sum_odd= int(((4*a*a*a)-a)/3)\\n \\n result=sum_odd+sum_even\\n \\n if result%2==0:\\n print('Ravi')\\n else:\\n print('Jhon')\\n except:\\n break;"}
{"id": "1124", "input": "# cook your dish here\\nfrom sys import stdin, stdout\\nfrom math import ceil\\n\\n\\ndef solve():\\n for _ in range(int(input())):\\n n, m = map(int, stdin.readline().split())\\n par = [i for i in range(n)]\\n for i in range(m):\\n ta, tb = map(int, stdin.readline().strip().split())\\n a, b = min(ta,", "gt": "tb), max(ta, tb)\\n for j in range(n):\\n if par[j] == par[b] and j != b:\\n par[j] = par[a]\\n par[b] = par[a]\\n\\n q = int(input())\\n while q:\\n q -= 1\\n x, y = map(int, stdin.readline().split())\\n if par[x] == par[y]:\\n print(\"YO\")\\n else:\\n print(\"NO\")\\n\\n\\ndef __starting_point():\\n solve()\\n\\n__starting_point()"}
{"id": "1125", "input": "# cook your dish here\\n# cook your dish here\\nt=int(input())\\nfor _ in range(t):\\n n,p,q=list(map(int,input().split(\" \")))\\n l=list(map(int,input().split(\" \")))\\n l.sort()\\n s=sum(l)\\n a=p+2*q\\n b=0\\n for i in l:\\n if(p==0):\\n if(i%2==0", "gt": "and a>=i):\\n a=a-i\\n b=b+1\\n elif(q==0):\\n if(a>=i):\\n a=a-i\\n b=b+1\\n else:\\n if(i%2==0 and a>=i):\\n a=a-i\\n b=b+1\\n elif(i%2!=0 and p!=0 and a>=i):\\n a=a-i\\n b=b+1\\n p=p-1\\n\\n print(b) \\n \\n \\n"}
{"id": "1126", "input": "# cook your dish here\\nfor", "gt": "_ in range(int(input())):\\n n=list(map(int,input().split()))\\n print(n[0]*n[1])\\n"}
{"id": "1127", "input": "for _ in", "gt": "range(int(input())):\\n n=int(input())\\n print((2*(pow(n,2)))-n+1)\\n\\n"}
{"id": "1128", "input": "# cook your dish here\\nx= int(input())\\nfor i in range(x):\\n y =", "gt": "list(map(str, input().split()))\\n j= 0\\n while j<len(y)-1:\\n print((y[j][0]).capitalize()+\".\", end=' ')\\n j+= 1\\n print(y[len(y)-1].capitalize())"}
{"id": "1129", "input": "import sys\\n\\nt = eval(input())\\nfor j in range(t):\\n n = eval(input())\\n a = list(map(int, input().split()))\\n ch = 0\\n sm = 0 ; x = sum(a)\\n s1 = [0] * n ; s2 = [0] * n\\n for i in range(n):\\n sm += a[i]\\n s1[i] = sm\\n s2[i] = x\\n", "gt": "x -= a[i]\\n if(sum(a) - a[0] == 0):\\n print(0)\\n elif(sum(a) - a[n - 1] == 0):\\n print(n - 1)\\n else:\\n for i in range(1, n - 1):\\n if(s1[i - 1] == s2[i + 1]):\\n print(i)\\n ch = 1\\n break\\n if(ch == 0):\\n if(n == 1):\\n print(0)\\n else:\\n print(-1)\\n"}
{"id": "1130", "input": "def fastpow(base, power):\\n result = 1\\n while power > 0:\\n if power % 2 == 0:\\n power = power // 2\\n\\n base = base * base\\n else:\\n power", "gt": "= power - 1\\n result = result * base\\n power = power // 2\\n base = base * base\\n return result\\n\\nt=int(input())\\nfor i in range(t):\\n a=list(map(int,input().split()))\\n n,r=a[0],a[1]\\n w=(n*(fastpow(n-1,r)))%((10**9)+7)\\n \\n print(w)"}
{"id": "1131", "input": "for _ in range(int(input())):\\n f,d=list(map(int,input().split()))\\n arr=list(map(int,input().split()))\\n risk=0\\n days_risk=0\\n days_norm=0\\n if d==1:\\n print(f)\\n else:\\n for a in arr:\\n if", "gt": "a>=80 or a<=9:\\n risk+=1\\n norm=f-risk\\n if risk%d==0:\\n days_risk=risk//d\\n else:\\n days_risk=(risk//d)+1\\n if norm%d==0:\\n days_norm=norm//d\\n else:\\n days_norm=(norm//d)+1\\n print(days_risk+days_norm)\\n \\n \\n"}
{"id": "1132", "input": "for _ in range(int(input())):\\n n,k=[int(x) for x in input().split()]\\n a=list(map(int,input().split()))\\n dp=[0]*(max(a)+1)\\n for", "gt": "_ in range(n):\\n dp[a[_]]+=1\\n for _ in range(1,len(dp)):\\n if dp[_]>k:\\n print(_,end=\" \")\\n print()"}
{"id": "1133", "input": "mod = 1000000007\\r\\nfac = [1,1]\\r\\nmaxn = (10**5)+5\\r\\nfor i in range(2,maxn):\\r\\n x = (fac[-1]*i)%mod\\r\\n fac.append(x)\\r\\n\\r\\npre = [1]\\r\\nfor i in range(2,maxn):\\r\\n", "gt": "x = 2*i-1\\r\\n x = (pre[-1]*x)%mod\\r\\n pre.append(x)\\r\\n\\r\\nfor _ in range(int(input())):\\r\\n n = int(input())\\r\\n x = fac[n]\\r\\n y = pre[n-1]\\r\\n print((x*y)%mod)"}
{"id": "1134", "input": "from sys import stdin,stdout\\nfrom math import gcd\\nnmbr=lambda:int(stdin.readline())\\nlst=lambda:list(map(int, stdin.readline().split()))\\n\\nfor _ in range(nmbr()):\\n n=nmbr()\\n a=lst()\\n", "gt": "g=a[0]\\n ans=0\\n for v in a[1:]:\\n g=gcd(v,g)\\n for i in a:\\n ans+=i//g\\n print(g,ans)"}
{"id": "1135", "input": "t=int(input())\\nfor i in range(t):\\n n,m=list(map(int,input().split()))\\n a=list(map(int,input().split()))\\n army=0\\n if n>m:\\n \\n for i in range(0,m):\\n army+=a[i]\\n \\n \\n", "gt": "for j in range(m,n):\\n army=army-(a[j]/2)\\n if army<0:\\n print('DEFEAT')\\n break\\n else:\\n continue\\n else:\\n print('VICTORY')\\n \\n if n<=m:\\n print('VICTORY')"}
{"id": "1136", "input": "# cook your dish here\\nt=int(input())\\nwhile t!=0:\\n n,k=map(int,input().split())\\n lst=[]\\n for i", "gt": "in range(1,n+1):\\n lst.append(i)\\n lst[k],lst[n-1]=lst[n-1],lst[k]\\n for item in lst:\\n print(item,end=' ')\\n t-=1"}
{"id": "1137", "input": "\\r\\nt = int(input())\\r\\n\\r\\nfor _ in range(t):\\r\\n n,m = map(int,input().split())\\r\\n\\r\\n if", "gt": "n==1:\\r\\n print(m)\\r\\n else:\\r\\n \\r\\n if n%2==0:\\r\\n print((n//2)*m)\\r\\n \\r\\n else:\\r\\n print(((n//2)+1)*m)"}
{"id": "1138", "input": "test = int(input())\\nANS = list()\\nfor i in range(test):\\n n = int(input())\\n items = sorted(list(map(int, input().split())))\\n c = 1\\n for j in range(len(items)):\\n if items[j] <", "gt": "2000:\\n t = 2000 - items[j]\\n if t in items[j+1:]:\\n ANS.append(\"Accepted\")\\n c = 2\\n break\\n else:\\n pass\\n else:\\n break\\n if c==1:\\n ANS.append(\"Rejected\")\\nfor ans in ANS:\\n print(ans)"}
{"id": "1139", "input": "a=eval(input())\\nwhile(a):\\n\\n x=eval(input())\\n b=list(map(int,input().split()))\\n z=[0]*100\\n k=1\\n j=0\\n c=0\\n for i in b:\\n \\n if i==0:\\n \\n z.insert(i,k)\\n \\n else:\\n \\n if z[z.index(i)+1]==0:\\n \\n z.insert(j,k)\\n else:\\n m=z.index(i)\\n", "gt": "n=m+1\\n p=(len(z)-z.count(0))-n\\n c=c+min(n,p)\\n \\n z.insert(m+1,k)\\n \\n \\n k+=1\\n j+=1\\n m=0\\n n=0\\n p=0\\n \\n print(c)\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n\\n\\n a-=1\\n"}
{"id": "1140", "input": "t = int(input())\\nwhile t>0:\\n s = input().strip()\\n if not s:\\n print('NO')\\n\\n dp = [0 for x in range(len(s) + 1)]\\n dp[0] = 1\\n dp[1] = 1 if 0 < int(s[0]) <= 9 else 0\\n\\n for i in range(2,", "gt": "len(s) + 1):\\n if 0 < int(s[i-1:i]) <= 9:\\n dp[i] += dp[i - 1]\\n if s[i-2:i][0] != '0' and int(s[i-2:i]) <= 26:\\n dp[i] += dp[i - 2]\\n \\n if dp[len(s)]%2 == 0:\\n print('YES')\\n else:\\n print('NO')\\n t -= 1"}
{"id": "1141", "input": "for _ in range(int(input())):\\n p, idx = map(int, input().split())\\n b =", "gt": "bin(idx)[2:]\\n b = ('0' * (p - len(b)) + b)[::-1]\\n print(int(b, 2))"}
{"id": "1142", "input": "try:\\n t,m=input().split()\\n t=int(t)\\n m=list(m)\\n letters=list(\"abcdefghijklmnopqrstuvwxyz\")\\n trans={}\\n for i in range(len(letters)):\\n trans[letters[i]]=m[i]\\n for i in range(t):\\n x=list(input())\\n y=\"\"\\n", "gt": "for j in x:\\n if(j.isalpha()==True):\\n if(j.isupper()==True):\\n y+=trans[j.lower()].upper()\\n else:\\n y+=trans[j]\\n else:\\n if(j=='_'):\\n y+=\" \"\\n else:\\n y+=j\\n print(y)\\n \\nexcept:pass"}
{"id": "1143", "input": "arr=[]\\nn=int(input())\\nfor i in range(n):\\n", "gt": "a=int(input())\\n arr.append(a)\\n arr.sort()\\n p=arr.index(a)\\n print((i-p)+1)"}
{"id": "1144", "input": "# cook your dish here\\ndef isPrime(n) : \\n \\n # Corner cases \\n if (n <= 1) : \\n return False\\n if (n <= 3) : \\n return True\\n \\n # This is checked so that we can skip \\n # middle five numbers in below loop \\n if (n % 2 == 0 or n % 3 == 0) : \\n return False\\n \\n i", "gt": "= 5\\n while(i * i <= n) : \\n if (n % i == 0 or n % (i + 2) == 0) : \\n return False\\n i = i + 6\\n \\n return True\\nt=int(input())\\nfor i in range(0,t):\\n n=int(input())\\n if n==1:\\n print(\"2\")\\n continue\\n if isPrime(n):\\n print(n+1)\\n continue\\n if n%2==0:\\n k=n//2\\n min=2+k\\n else:\\n min=n+1\\n for j in range(2,(n//2)+1):\\n if n%j==0:\\n k=n//j\\n if k!=j:\\n l=j+k\\n if l<min:\\n min=l\\n print(min)\\n"}
{"id": "1145", "input": "T= int(input());\\n\\nfor i in range(T):\\n n,k = list(map(int,input().split()));\\n s=list(map(int,input()));\\n\\n if k==1:\\n s_0 ={};\\n s_1={};\\n c0=0;\\n c1=0;\\n for j in range(n):\\n if(j%2==0):\\n s_1[j]=1;\\n s_0[j]=0;\\n else:\\n s_1[j]=0;\\n s_0[j]=1;\\n for j in range(n):\\n if(s_0[j]-s[j]!=0):\\n c0+=1;\\n if(s_1[j]-s[j]!=0):\\n c1+=1;\\n\\n if c0<c1:\\n print(c0);\\n p_s=\"\";\\n for j in range(n):\\n p_s+=str(s_0[j]);\\n print(p_s);\\n else:\\n print(c1);\\n p_s=\"\";\\nfor j in range(n):\\n p_s+=str(s_1[j]);\\n", "gt": "print(p_s);"}
{"id": "1146", "input": "from math import log,pow\\nn=int(input())\\na=[]\\nfor i in range(n):\\n no=int(input())\\n if(no%2==0):\\n a.append(\"0\")\\n elif(no==1):\\n a.append(\"1\")\\n elif(no==3):\\n a.append(\"3\")\\n else:\\n s=\"2\"\\n lv=int(log(no,2))\\n", "gt": "clv=1\\n cno=3\\n while(cno!=no):\\n if(no<cno*pow(2,lv-clv)):\\n s=s+\"1\"\\n clv=clv+1\\n cno=(2*cno)-1\\n else:\\n s=s+\"2\"\\n clv=clv+1\\n cno=(2*cno)+1\\n a.append(s)\\nfor i in a:\\n print(i)\\n \\n"}
{"id": "1147", "input": "# cook your dish here\\n\\na,b=list(map(int,input().split()))\\nls=[]\\nfor i in", "gt": "range(a):\\n ls.append(int(input()))\\nls.sort()\\nc=0;i=0\\nwhile i<(a-1):\\n if ls[i+1]-ls[i]<=b:\\n c=c+1\\n i=i+1\\n i=i+1\\nprint(c)\\n"}
{"id": "1148", "input": "# cooking dish here\\n\\nfrom sys import stdin\\nfrom collections import Counter\\nread = stdin.readline\\n\\nfor testcase in range(int(read())):\\n length = int(read())\\n string = read().strip()\\n", "gt": "\\n counts = Counter(string)\\n \\n odd_counts = 0\\n \\n for count in list(counts.values()):\\n # print(count, counts)\\n odd_counts += count%2\\n \\n print(max(odd_counts-1, 0))\\n"}
{"id": "1149", "input": "def g(x,y):\\n d = x[0]>=y[0] and x[1]>=y[1] and x[2]>=y[2]\\n e= x[0]>y[0] or x[1]>y[1] or x[2]>y[2]\\n return d and e\\nt=int(input())\\nfor _ in range(t):\\n a=list(map(int,input().split()))\\n b=list(map(int,input().split()))\\n c=list(map(int,input().split()))\\n\\n if g(a,b) and g(b,c):\\n", "gt": "print('yes')\\n elif g(a,c) and g(c,b):\\n print('yes')\\n elif g(b,a) and g(a,c):\\n print('yes')\\n elif g(b,c) and g(c,a):\\n print('yes')\\n elif g(c,a) and g(a,b):\\n print('yes')\\n elif g(c,b) and g(b,a):\\n print('yes')\\n else:\\n print('no')\\n \\n"}
{"id": "1150", "input": "# cook your dish here\\n\\n \\nt=int(input())\\nfor _ in range(t):\\n l = input()\\n \\n n= len(l)\\n prod = 1\\n for k in range(n//2):\\n i = l[k]\\n j", "gt": "= l[n-k-1]\\n if ((i!=j) and (i!='?' and j!=\"?\") ):\\n prod=0\\n break\\n elif ((i==j) and (i=='?')):\\n prod*=26\\n prod = prod%10000009\\n if n%2!=0:\\n if l[n//2]==\"?\":\\n prod*=26\\n \\n print(prod)"}
{"id": "1151", "input": "# cook your dish here\\nimport math\\nfor _ in", "gt": "range(int(input())):\\n n=int(input())\\n c=0\\n while(n>0):\\n i=int(math.sqrt(n))\\n c+=1\\n n=n-i**2\\n print(c)\\n \\n"}
{"id": "1152", "input": "from sys import stdin\\r\\nfrom math import ceil, gcd\\r\\n\\r\\n# Input data\\r\\n#stdin = open(\"input\", \"r\")\\r\\n\\r\\n\\r\\ndef dfs(src, visit):\\r\\n visit[src] = 1\\r\\n for nbr in d[src]:\\r\\n if visit[nbr] == 0:\\r\\n dfs(nbr, visit)\\r\\n\\r\\nfor _ in range(int(stdin.readline())):\\r\\n n, m = list(map(int, stdin.readline().split()))\\r\\n d = {}\\r\\n for i in range(m):\\r\\n u, v = list(map(int, stdin.readline().split()))\\r\\n", "gt": "if u in d:\\r\\n d[u].append(v)\\r\\n else:\\r\\n d[u] = [v]\\r\\n if v in d:\\r\\n d[v].append(u)\\r\\n else:\\r\\n d[v] = [u]\\r\\n visited ="}
{"id": "1153", "input": "nr=int(input())\\nd={}\\nfor r in range(nr):\\n s,v=list(map(str,input().split()))\\n d[int(v)]=s\\nq=int(input())\\nlis=[]\\nfor i in range(q):\\n lis.append(input())\\nl=list(d.keys())\\nl.sort(reverse=True)\\nans='NO'\\n\\n\\nfor j in lis:\\n", "gt": "ans='NO'\\n for k in l:\\n if len(j)<=len(d[k]):\\n a=d[k]\\n if j==a[0:len(j)]:\\n ans=a\\n break\\n print(ans) \\n"}
{"id": "1154", "input": "def mod(a,b,c):\\n x = 1\\n y = a\\n while(b>0):\\n if(b%2==1):\\n x = (x*y)%c\\n y = (y*y)%c\\n b /=2\\n return x%c\\nt = int(input())\\nnum = 10**9+7\\nfor i in", "gt": "range(t):\\n n,m,q,k = list(map(int,input().split()))\\n if m<=q:\\n print(0)\\n else:\\n a1 = m-q\\n a2 = mod(q+1,n,num)\\n a3 = mod(q-1,n,num)\\n a4 = mod(q,n,num)\\n a5 = a2-2*a4+a3\\n ans = a1*a5\\n print(ans%num)"}
{"id": "1155", "input": "try:\\n n=int(input())\\n x=[*list(map(int, input().split()))]\\n y=[*list(map(int, input().split()))]\\n for i", "gt": "in y:\\n d=x.count(i)-y.count(i)\\n if d!=0:\\n print(i)\\n break\\nexcept: pass\\n"}
{"id": "1156", "input": "<s> ", "gt": "print"}
{"id": "1157", "input": "# cook your dish here\\nfor i in range(int(input())):\\n", "gt": "x=int(input())\\n if x<10:\\n print(\"Thanks for helping Chef!\")\\n else:\\n print(\"-1\")\\n"}
{"id": "1158", "input": "# cook your dish here\\n# cook your dish here\\nfor i in range(int(input())):\\n n,m,k=map(int,input().split())\\nl,ans = list(map(int,input().split())),0\\n for i in l:\\n r=i//m + 1;c=i%m\\n", "gt": "if(c==0):c=m;"}
{"id": "1159", "input": "#!/usr/bin/env python\\n\\ndef main():\\n N = int(input())\\n C = 0\\n for n in range(N):\\n S = input().strip()\\n Pi = S.split()[-1]\\n L = [Pi.count(k) for k in map(str, list(range(10)))]\\n if L[8] >= L[5] and L[5] >= L[3]", "gt": "and \\\\n L[0] == 0 and L[1] == 0 and \\\\n L[2] == 0 and L[4] == 0 and \\\\n L[6] == 0 and L[7] == 0 and \\\\n L[9] == 0: C += 1\\n print(C)\\n\\nmain()\\n\\n"}
{"id": "1160", "input": "t = int(input())\\n\\nfor e in range(t):\\n\\n str = input()\\n\\n dict = {}\\n\\n for x in range(len(str)):\\n if str[x] in dict:\\n dict[str[x]] = -1\\n else:\\n dict[str[x]] = x\\n\\n shankyIndex = len(str)\\n ankuIndex = -1\\n for x in dict:\\n if dict[x] != -1:\\n if dict[x] < shankyIndex:\\n shankyIndex", "gt": "= dict[x]\\n if dict[x] > ankuIndex:\\n ankuIndex = dict[x]\\n\\n ankuLetter = 0\\n shankyLetter = 0\\n\\n if ankuIndex != -1:\\n ankuLetter = str[ankuIndex]\\n else:\\n print('PANDEY')\\n continue\\n\\n if shankyIndex != len(str):\\n shankyLetter = str[shankyIndex]\\n else:\\n print('PANDEY')\\n continue\\n\\n if shankyLetter > ankuLetter:\\n print('SHANKY')\\n elif ankuLetter > shankyLetter:\\n print('ANKU')\\n else:\\n print('PANDEY')"}
{"id": "1161", "input": "def get(l,n):\\n l1,l2 = [],[]\\n i = 1\\n h1,m1 = l[0]\\n while (i < len(l)):\\n h2,m2 = l[i]\\n if (h1>h2):\\n if (m1 >= m2):\\n l1 += [(0,10**20)]\\n l2 += [(-1,-1)]\\n else:\\n d = (h1-h2)//(m2-m1)\\n if (((h1-h2)%(m2-m1)) == 0):\\n l1 += [(0,d-1)]\\n l2 += [(d+1,10**20)]\\n else:\\n l1 += [(0,d)]\\n l2 += [(d+1,10**20)]\\n elif(h1==h2):\\n if (m1 > m2):\\n l1 += [(1,10**20)]\\n l2 += [(-1,-1)]\\n elif(m1==m2):\\n l1 += [(-1,-1)]\\n l2 += [(-1,-1)]\\n else:\\n l2 += [(1,10**20)]\\n l1 += [(-1,-1)]\\n else:\\n if (m1 <= m2):\\n l2 += [(0,10**20)]\\n l1 += [(-1,-1)]\\n else:\\n d = (h2-h1)//(m1-m2)\\n if ((h2-h1)%(m1-m2) == 0):\\n l2 += [(0,d-1)]\\n l1 += [(d+1,10**20)]\\n else:\\n l2 += [(0,d)]\\n l1 += [(d+1,10**20)]\\n i += 1\\n h1,m1 = h2,m2\\n return l1,l2\\n \\ndef intersect(k1,k2):\\n k1,k2 = min(k1,k2),max(k1,k2)\\n c1,c2 = k1\\n c3,c4 = k2\\n l = [c1,c2,c3,c4]\\n l.sort()\\n if (l[2]==c2):\\n return (c3,min(c2,c4))\\n elif (l[3]==c2):\\n return k2\\n else:\\n return (-1,-1)\\n \\n \\n \\ndef union(k1,k2):\\n k1,k2 = min(k1,k2),max(k1,k2)\\n c1,c2 = k1\\n c3,c4 = k2\\n l = [c1,c2,c3,c4]\\n l.sort()\\n if (c2==l[3]):\\n return ([c1,c2])\\n elif(c2==l[2] or ((c3-c2) == 1)):\\n return([c1,c4])\\n else:\\n return([c1,c2,c3,c4])\\n \\n \\ndef aa(l1,l2,n):\\n c1,c2 =", "gt": "0,10**20\\n i = 0\\n n -= 1\\n while (i < n):\\n if (i%2 == 0):\\n k1,k2 = l1[i]\\n else:\\n k1,k2 = l2[i]\\n i += 1\\n if ((k1,k2) == (-1,-1)):\\n return (-1,-1)\\n c1,c2 = intersect((c1,c2),(k1,k2))\\n if ((c1,c2) == (-1,-1)):\\n return (c1,c2)\\n return (c1,c2)\\n \\n \\ntest = int(input())\\nwhile (test != 0):\\n test -= 1\\n n = int(input())\\n l = []\\n i = 0\\n while (i < n):\\n c1,c2 = list(map(int,input().split()))\\n l += [(c1,c2)]\\n i += 1\\n if (n == 1):\\n print(1)\\n print(\"0 Inf\")\\n else:\\n l1,l2 = (get(l,n))\\n k1,k2 = aa(l1,l2,n)\\n if ((k1,k2) == (-1,-1)):\\n k1,k2 = aa(l2,l1,n)\\n if ((k1,k2) == (-1,-1)):\\n print(0)\\n else:\\n print(1)\\n if (k2 == 10**20):\\n k2 = \"Inf\"\\n print(str(k1) + \" \" +str(k2))\\n else:\\n k3,k4 = aa(l2,l1,n)\\n if ((k3,k4) == (-1,-1)):\\n print(1)\\n if (k2 == 10**20):\\n k2 = \"Inf\"\\n print(str(k1) + \" \" +str(k2))\\n else:\\n p = union((k1,k2),(k3,k4))\\n if (len(p)==2):\\n c1,c2 = p\\n if (c2==10**20):\\n c2 = \"Inf\"\\n print(1)\\n print(str(c1) + \" \" +str(c2))\\n else:\\n c1,c2,c3,c4 = p\\n if (c4 == 10**20):\\n c4 = \"Inf\"\\n print(2)\\n print(str(c1) + \" \" +str(c2))\\n print(str(c3) + \" \" +str(c4))\\n"}
{"id": "1162", "input": "for i in range(int(input())):\\n a=input()\\n c=a.count('m')\\n d=a.count('s')\\n t=0\\n while t<len(a)-1:\\n if (a[t]=='m' and a[t+1]=='s') or", "gt": "(a[t]=='s' and a[t+1]=='m'):\\n d=d-1\\n t=t+2\\n else:\\n t=t+1\\n if c>d:\\n print('mongooses')\\n elif d>c:\\n print('snakes')\\n else:\\n print('tie')\\n"}
{"id": "1163", "input": "import sys\\nimport os\\n\\ndef __starting_point():\\n start = 0\\n for line in sys.stdin:\\n if start == 0:\\n start = 1\\n continue\\n else:\\n try:\\n n = int(line.strip())\\n \\n # print n \\n \\n q = n/7\\n rem = n%7\\n \\n \\n if rem==0:\\n res = n\\n elif rem==1:\\n", "gt": "res = (q-1)*7\\n elif rem==2:\\n res = (q-2)*7 \\n elif rem==3:\\n res = (q-3)*7\\n elif rem==4:\\n res = q*7\\n elif rem==5:\\n res = (q-1)*7\\n elif rem==6:\\n res = (q-2)*7 \\n \\n if res < 0:\\n print(-1)\\n else:\\n print(res)\\n \\n except:\\n break\\n \\n \\n \\n \\n__starting_point()"}
{"id": "1164", "input": "T = int(input())\\nfor j in range(0,T):\\n line1, line2 = input(), input()\\n seq = line2.split()\\n current_min = 1000001\\n current_max = 0\\n max_spread = 0\\n for i in range(0,len(seq)):\\n current_value = int(seq[i])\\n if current_min >", "gt": "current_value:\\n current_min = current_value\\n current_max = current_value\\n elif current_max < current_value:\\n current_max = current_value\\n if max_spread < (current_max - current_min):\\n max_spread = current_max - current_min \\n if max_spread > 0:\\n print(max_spread)\\n else:\\n print(\"UNFIT\")"}
{"id": "1165", "input": "p,s = [int(i) for i in input().split()]\\nscores = {}\\n\\nfor j in range(1, p + 1):\\n sc = [int(i) for i in input().split()]\\n ns = [int(i) for i in input().split()]\\n nsc = dict(list(zip(sc,ns)))\\n ssc = sorted(sc)\\n score = 0\\n", "gt": "for a,b in zip(ssc[:-1], ssc[1:]):\\n if nsc[a] > nsc[b]:\\n score += 1\\n if score in list(scores.keys()) :\\n scores[score].append(j)\\n else :\\n scores[score] = [j]\\n\\ntotal_scores = sorted(list(scores.keys()))\\nfinal_list = []\\nfor val in total_scores :\\n final_list += sorted(scores[val])\\n\\nfor val in final_list :\\n print(val)\\n"}
{"id": "1166", "input": "# cook your dish here\\nd = {'january':31,'february':29,'march':31,\\n 'april':30,'may':31,'june':30,'july':31,\\n 'august':31,'september':30,'october':31,\\n 'november':30,'december':31}\\n \\n#l=[[15,'january'],[31,'august'],[10,'october']]\\nl2 = list(d.keys())\\nfor _ in range(int(input())):\\n l=input().split()\\n l[0]=int(l[0])\\n a = l[1]\\n ind", "gt": "= l2.index(a)\\n b = 183 - (d[l[1]] - l[0])\\n while b!=0:\\n if ind!=11:\\n ind+=1\\n else:\\n ind = 0\\n if b<=d[l2[ind]]:\\n print(b,l2[ind])\\n break\\n b-=d[l2[ind]]"}
{"id": "1167", "input": "import sys\\nimport math\\n\\ndef main(arr,k):\\n \\n ans=0\\n for i in range(len(arr)):\\n curr_min=float('inf')\\n for j in", "gt": "range(i,len(arr)):\\n curr_min=min(curr_min,arr[j])\\n \\n if curr_min==k:\\n ans+=1 \\n return ans\\n \\n\\nn=int(input())\\narr=list(map(int,input().split()))\\n\\n\\nfor i in range(int(input())):\\n \\n print(main(arr,int(input())))"}
{"id": "1168", "input": "s = input().lower()\\r\\nvow = [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"]\\r\\nans = \"\"\\r\\nfor ch", "gt": "in s:\\r\\n if ch in vow:\\r\\n continue\\r\\n if ch.isalpha():\\r\\n ans += \".\" + ch\\r\\nprint(ans)\\r\\n"}
{"id": "1169", "input": "import sys\\nfor _ in range(0,eval(input())): \\n d,inp,mp,n,q=set(),list(map(ord,list(sys.stdin.readline().strip()))),[x=='b' for x in list(sys.stdin.readline().strip())],eval(input()),ord('a')\\n inps = [inp[i:] for i in range(len(inp))]\\n inps.sort()\\n op,prev= 0,''\\n for ip in inps:\\n i,ct=0,0\\n while i < min(len(ip),len(prev)):\\n if prev[i] !=", "gt": "ip[i]:\\n break\\n if mp[ip[i]-q]:\\n ct = ct+ 1\\n i = i+1\\n while i < len(ip):\\n if mp[ip[i]-q]:\\n ct = ct + 1\\n if ct > n:\\n break\\n op,i= op+1,i+1\\n prev = ip\\n print(op)"}
{"id": "1170", "input": "import sys\\n\\ndef joseph(k, n=6):\\n if k==0:\\n k = 1\\n x = 0\\n for i in range(2,n+1):\\n x = (x+k)%i\\n return x\\n\\nFLAMES = ['FRIENDS', 'LOVE', 'ADORE',", "gt": "'MARRIAGE', 'ENEMIES', 'SISTER']\\n\\nnCase = int(sys.stdin.readline())\\nfor _ in range(nCase):\\n a = ''.join(sys.stdin.readline().split())\\n b = ''.join(sys.stdin.readline().split())\\n n = 0\\n for ch in set(a+b):\\n n += abs(a.count(ch)-b.count(ch))\\n print(FLAMES[joseph(n)])\\n"}
{"id": "1171", "input": "t=int(input())\\nfor i in range(0,t):\\n n,k=map(int,input().split())\\n a1,*a=map(int,input().split())\\n a.insert(0,a1)\\n j=0\\n", "gt": "while j<n:\\n if a[j]%k==0:\\n print(1,end=\"\")\\n else:\\n print(0,end=\"\")\\n j+=1\\n print(\"\")"}
{"id": "1172", "input": "import numpy as np\\r\\nfrom numba import njit\\r\\ni8 = np.int64\\r\\n\\r\\n\\r\\n@njit\\r\\ndef solve(a, b, t, K, N):\\r\\n t1 = t // K\\r\\n d = t % K * 2\\r\\n # b が a から a + d の位置にあれば衝突する\\r\\n x = 0\\r\\n y = 0\\r\\n ans = 0\\r\\n for c in a:\\r\\n while b[x] < c:\\r\\n x += 1\\r\\n while b[y] <= c + d:\\r\\n y += 1\\r\\n ans += y - x\\r\\n ans += t1 * len(a) * (N - len(a)) * 2\\r\\n return ans\\r\\n\\r\\n\\r\\ndef set_ini(DX, K):\\r\\n", "gt": "a = DX[1][DX[0] == 1]\\r\\n a = np.sort(a)\\r\\n b = DX[1][DX[0] == 2]\\r\\n b = np.sort(b)\\r\\n b = np.hstack((b, b + K, b + 2 * K, [3 * K]))\\r\\n return a, b\\r\\n\\r\\n\\r\\ndef main():\\r\\n f = open('/dev/stdin', 'rb')\\r\\n vin = np.fromstring(f.read(), i8, sep=' ')\\r\\n N, Q, K = vin[0:3]\\r\\n head = 3\\r\\n DX = vin[head:head + 2*N].reshape(-1, 2).T\\r\\n a, b = set_ini(DX, K)\\r\\n head += 2 * N\\r\\n T = vin[head: head + Q]\\r\\n for t in T:\\r\\n print(solve(a, b, t, K, N))\\r\\n\\r\\n\\r\\ndef __starting_point():\\r\\n main()\\n__starting_point()"}
{"id": "1173", "input": "from math import factorial\\ndef Ncr(n,r):\\n if r<0:return 0\\n return factorial(n)/(factorial(n-r)*factorial(r))\\ndef solve(m,n):\\n modulo=10**9+7\\n if m==n:\\n return", "gt": "(Ncr(2*n-1,n-1)+Ncr(2*n-2,n-2))%modulo\\n elif m>n:\\n return (Ncr(m+n,n)-Ncr(m+n-2,n-1))%modulo\\n else:\\n return (Ncr(m+n,m)-Ncr(m+n-2,m-1))%modulo\\n \\nt=int(input())\\nfor i in range(t):\\n inp=list(map(int,input()))\\n m=inp.count(4)\\n n=inp.count(7)\\n print(solve(m,n))\\n"}
{"id": "1174", "input": "import itertools\\nfrom collections import defaultdict as dfd\\ndef sumPairs(arr, n):\\n s = 0\\n for i in range(n-1,-1,-1): \\n s += i*arr[i]-(n-1-i)*arr[i]\\n return s\\n\\ndef subarrayXor(arr, n, m):\\n ans = 0\\n xorArr =[0 for _ in range(n)]\\n mp = dfd(list)\\n xorArr[0] = arr[0]\\n for i in range(1, n): \\n xorArr[i] = xorArr[i", "gt": "- 1] ^ arr[i]\\n for i in range(n):\\n mp[xorArr[i]].append(i)\\n a = sorted(mp.items())\\n #print(xorArr)\\n #print(a)\\n for i in a:\\n diffs=0\\n if(i[0]!=0):\\n l = len(i[1])-1\\n ans += sumPairs(i[1],len(i[1]))-((l*(l+1))//2)\\n \\n else:\\n l = len(i[1])-1\\n ans += sumPairs(i[1],len(i[1]))-((l*(l+1))//2)\\n ans += sum(i[1])\\n return ans\\n\\nfor _ in range(int(input())):\\n n = int(input())\\n arr = list(map(int,input().split()))\\n print(subarrayXor(arr,len(arr),0))"}
{"id": "1175", "input": "from math import *\\nt = int(input())\\nfor _ in range(t):\\n n = int(input())\\n a = [int(d) for d in input().split()]\\n odd,even = 0,0\\n for i in range(n):\\n if bin(a[i]).count(\"1\")%2 == 1:\\n odd += 1\\n else:\\n even +=1\\n total =", "gt": "0\\n if odd >= 3 and even >= 2:\\n total += (odd*(odd-1)*(odd-2))//6\\n total += odd*(even*(even-1))//2\\n elif odd >= 3 and even < 2:\\n total += (odd*(odd-1)*(odd-2))//6\\n elif 0<odd < 3 and even >= 2:\\n total += odd*(even*(even-1))//2\\n \\n print(total%(10**9+7))"}
{"id": "1176", "input": "import math\\n\\ndef lcm(a, b):\\n return (a*b)//gcd(a, b)\\n\\ndef gcd(a, b):\\n if b == 0:\\n return a\\n return gcd(b, a%b) \\n \\nfor _ in range(int(input())):\\n n = int(input())\\n\\n na = math.ceil((2*n)/math.acos(-1))\\n nb", "gt": "= ((n+1)//2)**2\\n\\n nlcm = lcm(na, nb)\\n\\n oa = math.ceil(n/2)\\n ob = (n//2)*(n//2+1)\\n\\n olcm = lcm(oa, ob)\\n\\n if olcm > nlcm:\\n print(\"Nova's gonna kill me\")\\n else:\\n print(\"YESS(sunglass emo)\")\\n\\n# cook your dish here\\n"}
{"id": "1177", "input": "for _ in range(int(input())):\\n s=input()\\n if len(s)<4:\\n", "gt": "print(\"NO\")\\n else:\\n if s[-4:]==\"1000\":\\n print(\"YES\")\\n else:\\n print(\"NO\")"}
{"id": "1178", "input": "def nCr(n,k):\\n if(k>n):return 0\\n k=min(k,n-k)\\n num,den=1,1\\n for i in range(k):\\n num*=(n-i)\\n den*=(i+1)\\n", "gt": "return num/den\\n\\ndef Main():\\n for cases in range(int(input())):\\n a,b=[int(x) for x in input().split()]\\n print(nCr(a,b))\\n\\nMain()"}
{"id": "1179", "input": "test=int(input())\\nfor _ in range(test):\\n n=int(input())\\n ls=list(map(int,input().split()))\\n ls.sort()\\n s=0\\n for", "gt": "i in range(n):\\n if s>=ls[i]:\\n s=s+1\\n else:\\n break\\n print(s)"}
{"id": "1180", "input": "# cook your dish here\\nfrom math import sqrt\\nfor _ in range(int(input())):\\n", "gt": "n=int(input())\\n sum=(n*(n+1))//2\\n #print(sum)\\n if(sum%2!=0):\\n print(0)\\n continue\\n m=(int((sqrt(1+4*(sum)))-1)//2)\\n if(m*(m+1)//2==sum//2):\\n print((((m-1)*m)//2)+n-m+((n-m-1)*(n-m))//2)\\n else:\\n print(n-m)\\n"}
{"id": "1181", "input": "# cook your dish here\\nt=int(input())\\nfor i in range(t):\\n a=0\\n b=0\\n N,K,x,y=map(int,input().split())\\n if x==y:\\n a=N\\n b=N\\n elif x>y:\\n if K%4==1:\\n a=N \\n b=y-x+N\\n elif K%4==2:\\n a=y-x+N\\n", "gt": "b=N\\n elif K%4==3:\\n a=0\\n b=x-y\\n else:\\n a=x-y\\n b=0\\n else:\\n if K%4==1:\\n a=x-y+N \\n b=N\\n elif K%4==2:\\n a=N\\n b=x-y+N\\n elif K%4==3:\\n a=y-x\\n b=0\\n else:\\n a=0\\n b=y-x\\n print(a,b)"}
{"id": "1182", "input": "import sys,io,os,math\\nfrom math import ceil,log,gcd,inf\\nfrom itertools import permutations\\nmod=1000000007\\nmod1=998244353\\ndef printlist(n):\\n sys.stdout.write(\" \".join(map(str,n)) + \"\\n\")\\nprintf=lambda n:sys.stdout.write(str(n)+\"\\n\")\\ndef printns(n):\\n sys.stdout.write(str(n)) \\ndef intinp():\\n return int(sys.stdin.readline())\\ndef strinp():\\n return sys.stdin.readline()\\ndef arrinp():\\n return list(map(int,sys.stdin.readline().strip().split()))\\ndef mulinp():\\n return list(map(int,sys.stdin.readline().strip().split()))\\ndef flush():\\n", "gt": "return sys.stdout.flush()\\ndef power_two(x):\\n return (1<<x)\\ndef lcm(a,b):\\n return a*b//gcd(a,b) \\ndef solve():\\n n=intinp()\\n ans=str(n)\\n count=0\\n for i in ans:\\n count+=int(i)\\n if(n%count==0):\\n print('Yes')\\n return 0\\n print('No')\\n\\n\\ndef main():\\n tc=intinp()\\n while(tc):\\n solve()\\n tc-=1 \\n \\nmain()\\n\\n"}
{"id": "1183", "input": "\\ndef interesting_nums(m):\\n nums = []\\n for x in range(m + 1, 2 * m + 1):\\n if x * m % (x -", "gt": "m) == 0:\\n nums.append(x)\\n\\n return nums\\n\\n\\ndef main():\\n\\n T = int(input())\\n\\n for _ in range(T):\\n num_list = interesting_nums(int(input()))\\n print(len(num_list))\\n\\n for num in num_list:\\n print(num)\\n\\n\\nmain()"}
{"id": "1184", "input": "for __ in range(eval(input())):\\n x = eval(input())\\n a = list(map(int,input().split()))\\n key = eval(input())\\n query = eval(input())\\n maxvisited = x #maximum visted value\\n j = x-1\\n ans = []\\n val = 0\\n while j>=0:\\n if a[j]==key:\\n", "gt": "ans.append(val+1)\\n val = val +1\\n else: ans.append(val)\\n j-=1\\n ans.reverse()\\n #print ans\\n for ii in range(query):\\n W = eval(input())\\n print(ans[W], end=' ')\\n print(x-W, end=' ')\\n #print maxvisited, W\\n if maxvisited>W:\\n print(maxvisited-W+1)\\n maxvisited = W\\n else: print('1')\\n"}
{"id": "1185", "input": "from itertools import permutations\\nC = list(permutations(['A','B','C','D']))\\nV = list(permutations([3,6,9,12]))\\nP = list(permutations([25,50,75,100]))\\nR = []\\n\\ndef test():\\n d = {}\\n n = int(input())\\n for i in C[0]:\\n for j in V[0]:\\n d[i+str(j)] = 0\\n for i in range(n):\\n x,y = input().split()\\n d[x+y] += 1\\n ans = -1000000000\\n for", "gt": "i in C:\\n for j in V:\\n for k in P:\\n c = 0\\n for l in range(4): \\n if d[i[l]+str(j[l])] == 0:\\n c -= 100\\n else:\\n c += (d[i[l]+str(j[l])]*k[l])\\n ans = max(ans,c)\\n R.append(ans)\\n print(ans)\\n\\ndef __starting_point():\\n t = int(input())\\n for i in range(t):\\n test()\\n print(sum(R))\\n\\n__starting_point()"}
{"id": "1186", "input": "import sys\\n\\nrl=sys.stdin.readline\\nT=int(rl())\\nfor t in range(T):\\n P=int(rl())\\n T=(P+1)//2\\n", "gt": "F=list(map(int,rl().split()))[1:]\\n numtorn=int(rl())\\n t=sum(range(1,P+1))-sum(F)\\n K=T-numtorn\\n print('%.4f' % (t*K/float(T)))\\n \\n"}
{"id": "1187", "input": "import math\\nn = int(input())\\na = sorted(map(int,input().split()))\\nl = [0]*n\\nfor i in", "gt": "range(n):\\n l[i] = a[i] + l[i-1]\\nfor q in range(int(input())):\\n print(l[int(math.ceil(float(n)/(int(input())+1)))-1])"}
{"id": "1188", "input": "for _ in range(int(input())):\\n N,M = list(map(int,input().split()))\\n count,e,perm = 0,0,1\\n while(True):\\n lim,start = N//(M**e),N//(M**(e + 1)) + 1\\n num = lim - start + 1\\n divs = num//M\\n if((start + divs*M) <= lim):\\n r = (start+divs*M)%M\\n if(r == 0 or (r + (lim", "gt": "- (start + divs*M)) >= M)):\\n divs += 1\\n cmon = num - divs\\n if(e % 2 == 0):\\n count += cmon*((e+2)//2)\\n else:\\n count += cmon*(e//2 + 1)\\n perm = (perm * pow((e + 3)//2,cmon ,998244353))%998244353\\n e += 1\\n if(start == 1):\\n break\\n print(count,perm)\\n"}
{"id": "1189", "input": "n = eval(input())\\nr = list(map(int, input().split()))\\n\\ntree = dict()\\ni = 1\\nfor j in r:\\n c = tree.get(j)\\n if c:\\n tree[j].append(i)\\n else:\\n tree[j]", "gt": "= [i]\\n if not tree.get(i):\\n tree[i] = []\\n i += 1\\ns = []\\nfor elem in tree:\\n if not tree[elem]:\\n s.append(str(elem))\\nprint(' '.join(s))"}
{"id": "1190", "input": "from sys import stdin\\ndef gt(num):\\n if num:\\n return num\\n return 0\\nfor __ in range(int(stdin.readline().split()[0])):\\n n = int(stdin.readline().split()[0])\\n a = list(map(int, stdin.readline().split()))\\n cnta = dict()\\n cnta.setdefault(0)\\n cntb = dict()\\n cntb.setdefault(0)\\n for i in a:\\n cnta[i] = gt(cnta.get(i)) +", "gt": "1\\n asum = 0\\n bsum = sum(a)\\n ans = 0\\n for i in range(n-1):\\n asum += a[i]\\n bsum -= a[i]\\n cnta[a[i]] = gt(cnta.get(a[i])) - 1\\n cntb[a[i]] = gt(cntb.get(a[i])) + 1\\n ans += gt(cnta.get(bsum-asum))\\n ans += gt(cntb.get(asum-bsum))\\n print(ans)"}
{"id": "1191", "input": "t= int(input())\\nwhile(t>0):\\n n = int(input())\\n m=0\\n m=n//(2**11)\\n", "gt": "n%=(2**11)\\n while(n>0):\\n num=n%2\\n m+=num\\n n//=2\\n print(m)\\n t-=1"}
{"id": "1192", "input": "# cook your dish here\\nfrom difflib import get_close_matches \\nimport sys, os\\n\\ndef closeMatches(patterns, word): \\n return get_close_matches(word, patterns, 1, 0.9)[0]\\n\\ndef get_string(): \\n return sys.stdin.readline().strip() \\n\\ndef get_ints(): \\n return map(int, sys.stdin.readline().strip().split()) \\nans = []\\ntest = int(input())\\nfor i", "gt": "in range(test):\\n n,q = get_ints()\\n #ans = []\\n n = int(n)\\n q = int(q)\\n patterns=[]\\n for j in range(n):\\n s = get_string()\\n patterns.append(s)\\n for j in range(q):\\n word = get_string()\\n ans.append(closeMatches(patterns, word))\\nfor j in ans:\\n sys.stdout.write(j+\"\\n\")"}
{"id": "1193", "input": "from math import gcd\\nfrom itertools import groupby\\n\\ndef gcd_split(seq):\\n gcds= [int(gcd(a,b)==1) for a,b in zip(seq[1:],seq[:-1])]\\n gcds.append(int(gcd(seq[0],seq[-1])==1))\\n # print(gcds)\\n if max(gcds)==0:\\n return -1\\n else:\\n splits=[len(list(x))+1 for num,x in groupby(gcds) if num==0]\\n # print(splits)\\n if gcds[0]==gcds[-1]==0:\\n splits[0] += splits[-1]-1\\n splits = splits[:-1]\\n return splits\\n\\nfor _ in range(int(input())):\\n N=int(input())\\n A=[int(x) for x in input().split()]\\n split = gcd_split(A)\\n", "gt": "# print(split)\\n \\n res=[]\\n if split!=-1:\\n for K in range(2,N+1):\\n temp=(x for x in split if x>=K)\\n ins = sum([(x//(K-1)-1 if x%(K-1)==0 else x//(K-1)) for x in temp])\\n if ins==0:\\n break\\n else:\\n res.append(ins)\\n else:\\n for K in range(2,N+1):\\n ins = N//(K-1)+(N%(K-1)>0)\\n if ins==0:\\n break\\n else:\\n res.append(ins)\\n \\n res = res + [0]*(N-1 -len(res))\\n print(*res)"}
{"id": "1194", "input": "MAX = 100005\\ntree = [0] * MAX; \\nlazy = [0] * MAX;\\n \\ndef updateRangeUtil(si, ss, se, us, ue, diff) :\\n if (lazy[si] != 0) :\\n tree[si] += lazy[si];\\n if (ss != se) :\\n lazy[si * 2 + 1] += lazy[si];\\n lazy[si * 2 + 2] += lazy[si];\\n lazy[si] = 0;\\n \\n if (ss > se or ss > ue or se < us) :\\n return; \\n \\n if (ss >= us and se <= ue) :\\n tree[si] += diff;\\n if (ss != se) :\\n lazy[si * 2 + 1] += diff;\\n lazy[si * 2 + 2] += diff;\\n return; \\n \\n mid = (ss + se) // 2;\\n updateRangeUtil(si * 2 + 1, ss,mid, us, ue, diff);\\n updateRangeUtil(si * 2 + 2, mid + 1,se, us, ue, diff);\\n tree[si] = min(tree[si * 2 + 1],tree[si * 2 + 2]); \\n \\ndef updateRange(n, us, ue, diff) : \\n updateRangeUtil(0, 0, n - 1, us, ue, diff); \\n \\ndef getSumUtil(ss, se, qs, qe, si) :\\n if (lazy[si] != 0) :\\n tree[si] += lazy[si];\\n if (ss != se) :\\n lazy[si * 2 + 1] += lazy[si];\\n lazy[si * 2 + 2] += lazy[si];\\n lazy[si] = 0;\\n \\n if (ss > se or ss> qe or se < qs) :\\n return 10e9; \\n \\n if (ss >= qs", "gt": "and se <= qe) :\\n return tree[si];"}
{"id": "1195", "input": "from collections import Counter\\ntry:\\n for _ in range(int(input())):\\n n=int(input())\\n s=input()\\n d1=dict(Counter(s))\\n \\n u,d,r,l=0,0,0,0\\n if 'U' in d1:\\n u=d1['U']\\n else:\\n u=0\\n if 'D' in d1:\\n d=d1['D']\\n else:\\n d=0\\n if 'R' in d1:\\n r=d1['R']\\n else:\\n r=0\\n if 'L'", "gt": "in d1:\\n l=d1['L']\\n else:\\n l=0\\n x=0\\n y=0\\n if l==r:\\n x=0\\n elif l>r:\\n x=-(l-r)\\n elif r>l:\\n x=r-l\\n if u==d:\\n y=0\\n elif d>u:\\n y=-(d-u)\\n elif u>d:\\n y=u-d\\n # print(x,y)\\n if x==0 and y==0:\\n print(n)\\n continue\\n \\n print(n-(abs(x)+abs(y)))\\nexcept:\\n pass\\n"}
{"id": "1196", "input": "t=int(input())\\nfor _ in range(t):\\n n,a,b,c,d,p,q,y=list(map(int,input().split()))\\n l=list(map(int,input().split()))\\n ans", "gt": "= abs((l[b-1]-l[a-1]))*p\\n x=abs(l[c-1]-l[a-1])*p\\n if x<=y:\\n x=y+abs(l[d-1]-l[c-1])*q+abs(l[b-1]-l[d-1])*p\\n ans=min(ans,x)\\n print(ans)\\n"}
{"id": "1197", "input": "t = int(input())\\r\\nfor i in range(t):\\r\\n q = input().split()\\r\\n n = int(q[0])\\r\\n m = int(q[1])\\r\\n k = int(q[2])\\r\\n sumax = 0\\r\\n b = []\\r\\n for j in range(n):\\r\\n a = [int(k) for k in input().split()]\\r\\n b = b + [a]\\r\\n for j in range(n):\\r\\n su = 0\\r\\n for x in range(k):\\r\\n su = su +b[j][x]\\r\\n if su > sumax:\\r\\n sumax = su\\r\\n", "gt": "for a in range(1, m-k+1):\\r\\n su = su - b[j][a-1] +b[j][k+a-1]\\r\\n if su > sumax:\\r\\n sumax = su\\r\\n for j in range(m):\\r\\n su = 0\\r\\n for x in range(k):\\r\\n su = su + b[x][j]\\r\\n if su > sumax:\\r\\n sumax = su\\r\\n for a in range(1, n-k+1):\\r\\n su = su - b[a-1][j] + b[a+k-1][j]\\r\\n if su > sumax:\\r\\n sumax = su\\r\\n print(sumax)\\r\\n \\r\\n \\r\\n"}
{"id": "1198", "input": "lst=[1, 2, 4, 8, 13, 21, 31, 45, 66, 81, 97, 123, 148, 182, 204, 252, 290, 361, 401, 475, 565, 593, 662, 775, 822, 916, 970, 1016, 1159, 1312, 1395, 1523, 1572, 1821, 1896, 2029, 2254, 2379, 2510, 2780, 2925, 3155, 3354, 3591, 3797, 3998, 4297, 4433, 4779, 4851, 5123, 5243, 5298, 5751, 5998, 6374, 6801, 6925, 7460, 7547, 7789, 8220, 8503, 8730, 8942, 9882, 10200, 10587, 10898, 11289, 11614, 11876, 12034, 12931, 13394, 14047, 14534, 14901, 15166, 15688, 15972, 16619, 17355, 17932, 18845, 19071, 19631, 19670, 20722, 21948, 22526, 23291, 23564, 23881, 24596, 24768, 25631, 26037, 26255, 27219, 28566, 29775, 30094, 31311, 32217, 32620, 32912, 34277, 35330, 35469, 36204, 38647, 39160, 39223, 39943, 40800, 41882, 42549, 43394, 44879, 45907, 47421, 47512, 48297, 50064, 50902, 52703, 52764, 54674, 55307, 56663, 58425, 59028, 60576, 60995, 62205, 63129, 64488, 66999, 67189, 68512, 68984, 70170, 71365, 75618, 76793, 77571, 79047, 80309, 83179, 84345, 87016, 87874, 88566, 89607, 91718, 92887, 93839, 95103, 97974, 99583, 101337, 102040, 103626, 104554, 106947, 107205, 108622, 111837, 112800, 113949, 114642, 116291, 117177, 121238, 125492, 126637, 129170, 130986, 131697, 134414, 134699, 136635, 139964, 143294, 144874, 146605, 147499, 148593, 150146, 152318, 152834, 156836, 157150, 160782, 163010, 163502, 164868, 170984, 172922, 174171, 177853, 180249, 182071, 185403, 188314, 190726, 190894, 193477, 196832, 199646, 201472, 202699, 205325, 206811, 208748, 214435, 217182, 218011, 225350, 226682, 229163, 231694, 233570, 234619, 235152, 238727, 240814, 247822, 253857, 254305, 260433, 261620, 262317, 266550, 269195, 271511, 274250, 274753, 280180, 284289, 290005, 293034, 295037, 296506, 298414, 302663, 305782, 308841, 317739, 321173, 323672, 324806, 329181, 331018, 336642, 340901, 343359, 347001, 348110, 348899, 362520, 366119, 368235, 370696, 371542, 377450, 380366, 382012, 382245, 384957, 387479, 390518, 391462, 399174, 403920, 411847, 412671, 416880, 417991, 422453, 433973, 434773, 440619, 441148, 443779, 446065, 456289, 458426, 462402, 470670, 474668, 475800, 481476, 482868, 498435, 501084, 508193, 511258, 514644, 524307, 527197, 535369, 536903, 538331, 542020, 555275, 564016, 566106, 567408, 572027, 582478, 583407, 585871, 593257, 596837, 598426, 599784, 607794, 610404, 621790, 624574, 627703, 633442, 640047, 648858, 659179, 663558, 667337, 672815, 673522, 686013, 691686, 693169, 694279, 696931, 703162, 711364, 723249, 729860, 731008, 739958, 740124, 744403, 753293, 768134, 770113, 773912, 779917, 787407, 794900, 797567, 800658, 813959, 814414, 827123, 829129,", "gt": "839728, 847430, 850695, 851627, 862856, 880796, 884725, 889285, 896691, 897160, 904970, 909586, 915254, 922852, 935695, 937825, 938876, 959937, 961353, 964857, 970227, 976356, 980581, 986799, 1008106, 1009835, 1016906, 1020306, 1028612, 1033242, 1036012, 1042818, 1050881, 1051783, 1060844, 1086402, 1092043, 1096162, 1103456, 1123464, 1134057, 1136410, 1144080, 1145152, 1147774, 1156687, 1164278, 1166255, 1174751, 1187057, 1195316, 1201262, 1207345, 1212654, 1218610, 1225019, 1227887, 1240777, 1247071, 1258235, 1265462, 1274089, 1279515, 1288613, 1298980, 1306248, 1326918, 1333809, 1341190, 1343482, 1367480, 1372734, 1374779, 1384952, 1388147, 1394240, 1395346, 1409612, 1417336, 1418943, 1423296, 1446209, 1448494, 1462599, 1468933, 1474698, 1496110, 1502217, 1508335, 1513944, 1549693, 1552361, 1558304, 1567726, 1578307, 1593543, 1594370, 1596552, 1604567, 1611655, 1638201, 1657904, 1661549, 1668344, 1684653, 1700848, 1704061, 1712218, 1733148, 1744400, 1756959, 1766186, 1770297, 1774640, 1783782, 1790804, 1797186, 1819167, 1822095, 1835790, 1838687, 1840248, 1843265, 1858487, 1871701, 1874449, 1907155, 1933219, 1941873, 1953108, 1960964, 1970086, 1995385, 2005526, 2006388, 2012407, 2022419, 2027444, 2032071, 2046348, 2049691, 2081218, 2085045, 2107005, 2111011, 2117147, 2128804, 2130734, 2133565, 2163069, 2165643, 2183398, 2186582, 2200866, 2228833, 2238757, 2260397, 2287997, 2303690, 2306210, 2311079, 2319657, 2347177, 2348345, 2364629, 2380657, 2386691, 2392303, 2413369, 2429645, 2435861, 2445907, 2454603, 2461156, 2481207, 2493269, 2496558, 2526270, 2549274, 2559084, 2565601, 2571993, 2574622, 2589585, 2602736, 2606052, 2635578, 2636056, 2649712, 2667175, 2697913, 2705598, 2716472, 2726625, 2740640, 2748032, 2769317, 2773637, 2777175, 2796454, 2808141, 2818050, 2822209, 2828335, 2853048, 2858954, 2879003, 2898699, 2906226, 2928135, 2935468, 2950167, 2955230, 2959204, 2981209, 2999992, 3013106, 3016185, 3016728, 3033485, 3041287, 3046405, 3085842, 3097363, 3129048, 3137101, 3148974, 3153026, 3165425, 3172200, 3187649, 3208795, 3228028, 3239797, 3265353, 3281537, 3310390, 3330139, 3349916, 3351744, 3360950, 3366598, 3375910, 3382995, 3411775, 3438201, 3447140, 3453811, 3471520, 3485127, 3522748, 3569412, 3575690, 3578298, 3585562, 3593337, 3624737, 3626198, 3651501, 3667524, 3674434, 3675907, 3738616, 3754186, 3765841, 3786330, 3807381, 3818043, 3829535, 3831874, 3838373, 3862508, 3910613, 3942689, 3950184, 3954465, 3978469, 3992767, 4014701, 4032219, 4033924, 4065368, 4078004, 4089606, 4101646, 4119004, 4155098, 4166329, 4176904, 4182945, 4197748, 4211593, 4218728, 4253237, 4275441, 4288635, 4298689, 4301972, 4329866, 4357640, 4392330, 4403327, 4415543, 4434657, 4454780, 4460817, 4467239, 4489541, 4518764, 4526891, 4541320, 4560957, 4568090, 4582032, 4609341, 4631837, 4683082, 4688874, 4714962, 4728230, 4733954, 4744119, 4797763, 4819301, 4823437, 4850997, 4865482, 4886981, 4907820, 4931122, 4957782, 5005971, 5014678, 5031077, 5054902, 5059300, 5088659, 5119815, 5135680, 5153376, 5210102, 5213548, 5253584]\\r\\nfor _ in range(int(input())):\\r\\n n=int(input())\\r\\n sum=0\\r\\n for i in range(n):\\r\\n print(lst[i],end=\" \")\\r\\n sum+=lst[i]\\r\\n print()\\r\\n print(sum)"}
{"id": "1199", "input": "import math\\nimport bisect\\nfrom functools import reduce\\nfrom collections import defaultdict\\n# import sys\\n# input = sys.stdin.readline\\n\\ndef inn():\\n return int(input())\\n\\ndef inl():\\n return list(map(int, input().split()))\\n\\nMOD = 10**9+7\\nINF = inf = 10**18+5\\n\\nn = inn()\\na = inl()\\nk = []\\nfor q in range(inn()):\\n k.append(inn())\\n\\ngcdn = reduce(math.gcd, a)\\nlim = max(k)+1\\nans = defaultdict(int)\\nans[1] = 0\\n\\nfor i", "gt": "in range(n):\\n cur_gcd = a[i]\\n for j in range(i, n):\\n cur_gcd = math.gcd(cur_gcd, a[j])\\n if cur_gcd==1 or cur_gcd//gcdn==1:\\n ans[cur_gcd] += (n-j)\\n break\\n ans[cur_gcd] += 1\\n# print(ans)\\n\\nkeys = list(ans.keys())\\nans1 = [0]*lim\\nfor i in keys:\\n for j in range(i, lim, i):\\n ans1[j] += ans[i]\\n# print(ans1[:10])\\nfor i in k:\\n print(ans1[i])"}
{"id": "1200", "input": "for i in range(int(input())):\\n n,k=list(map(int,input().split()))\\n t=0\\n if", "gt": "n%2!=0:\\n n-=1\\n t+=1\\n t+=(n//k)\\n if n%k!=0:\\n t+=1\\n print(t)\\n"}
{"id": "1201", "input": "def checkValidity(s):\\n count = 0\\n previous = \"\"\\n\\n for x in s:\\n if count == 0:\\n previous = x\\n count += 1\\n elif", "gt": "count == 1:\\n count = 0\\n if previous == x:\\n return \"no\"\\n\\n return \"yes\"\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n s = input()\\n print(checkValidity(s))\\n"}
{"id": "1202", "input": "# cook your dish here\\ndef solve(l,r,c,row,col,po):\\n count=0\\n visited=set()\\n stack=set()\\n stack.add((l[row][col],row,col))\\n while stack:\\n ele=stack.pop()\\n visited.add((ele[1],ele[2]))\\n if ele[0]<po:\\n count+=1 \\n if ele[1]-1>=0 and (ele[1]-1,ele[2]) not in visited:\\n if l[ele[1]-1][ele[2]]<po:\\n stack.add((l[ele[1]-1][ele[2]],ele[1]-1,ele[2]))\\n if ele[1]+1<r and (ele[1]+1,ele[2]) not in visited:\\n if l[ele[1]+1][ele[2]]<po:\\n stack.add((l[ele[1]+1][ele[2]],ele[1]+1,ele[2]))\\n", "gt": "if ele[2]-1>=0 and (ele[1],ele[2]-1) not in visited:\\n if l[ele[1]][ele[2]-1]<po:\\n stack.add((l[ele[1]][ele[2]-1],ele[1],ele[2]-1))\\n if ele[2]+1<c and (ele[1],ele[2]+1) not in visited:\\n if l[ele[1]][ele[2]+1]<po:\\n stack.add((l[ele[1]][ele[2]+1],ele[1],ele[2]+1))\\n return count\\nfor _ in range(int(input())):\\n r,c,q=map(int,input().split())\\n l=[]\\n for i in range(r):\\n a=list(map(int,input().split()))\\n l.append(a)\\n for i in range(q):\\n row,col,po=map(int,input().split())\\n print(solve(l,r,c,row-1,col-1,po))"}
{"id": "1203", "input": "# cook your dish here\\n\\nd = { 'D': 238, 'T': 244, 'M': 138, 'B': 279, 'C': 186 }\\n\\ns = list(input())\\ntotalCal = 0\\n\\nfor i in range(len(s)):\\n if s[i] == 'D':\\n totalCal += d['D']\\n if s[i] == 'T':\\n totalCal += d['T']\\n if s[i] == 'M':\\n totalCal += d['M']\\n if s[i] == 'B':\\n totalCal += d['B']\\n if s[i] ==", "gt": "'C':\\n totalCal += d['C']\\n\\nR = totalCal // 50\\nRm = totalCal % 50\\nC = Rm // 5\\nCm = Rm % 5\\nx = totalCal - (R * 50 + C * 5)\\n# print(totalCal - R * 50 + C * 5)\\nW = int(x * 4 * 0.5)\\n# print(R * 50 + C * 5 + W * 0.5)\\nprint(R)\\nprint(C)\\nprint(W)"}
{"id": "1204", "input": "import math\\nf = math.factorial\\nfor u in range(eval(input())):\\n n, q = list(map(int, input().split()))\\n for j in range(q):\\n i,k = list(map(int, input().split()))\\n if k>i:\\n c=0\\n print(c)\\n else:\\n a=2**(n-i)\\n b=1\\n d=int(i-1)\\n e=1\\n", "gt": "h=1\\n g=1\\n #b=f(i-1)/f(k-1)/f(i-k)\\n if(k-1>i-k):\\n for z in range(i-k):\\n b=b*d\\n d=d-1\\n e=e*h\\n h=h+1\\n b=b/e\\n else:\\n for z in range(k-1):\\n b=b*d\\n d=d-1\\n e=e*g\\n g=g+1\\n b=b/e\\n \\n \\n \\n c=a*b\\n c=c%1000000007\\n print(c)"}
{"id": "1205", "input": "for t in range(int(input())):\\n s = input()\\n r = input()\\n diff = list()\\n index = list()\\n cnt = 0\\n for i in range(len(s)):\\n if s[i] != r[i]:\\n cnt += 1\\n index.append(i)\\n for i in range(1, len(index)):\\n", "gt": "diff.append(index[i] - index[i - 1] - 1)\\n diff.sort()\\n fmin = cnt ** 2\\n oper = cnt ; moves = cnt\\n for i in diff:\\n moves += i\\n oper -= 1\\n fmin = min(fmin, moves * oper)\\n print(fmin)"}
{"id": "1206", "input": "for _ in range(int(input())):\\n s=input()\\n n=len(s)\\n t=0\\n ans=0\\n for i in range(n-1):\\n if(s[i]==s[i+1]):\\n t=t+1\\n x=t\\n for i in range(n):\\n t=x\\n", "gt": "if(i!=0):\\n if(s[i]==s[i-1]):\\n t=t-1\\n else:\\n t=t+1\\n y=t\\n for j in range(i,n):\\n t=y\\n try:\\n if(s[j]==s[j+1]):\\n t=t-1\\n else:\\n t=t+1\\n except:\\n pass\\n ans=ans+t\\n print(ans)"}
{"id": "1207", "input": "from sys import stdout, stdin\\nn,m,o = list(map(int, stdin.readline().split()))\\nn= n+m+o\\nl=[]\\na=[]\\nfor i in range(n):\\n b= int(stdin.readline())\\n if(b in l and b", "gt": "not in a):\\n l.append(b)\\n a.append(b)\\n elif(b not in l):\\n l.append(b)\\n\\n\\na.sort()\\nstdout.write(str(len(a)) + '\\n')\\nstdout.write(''.join([str(id) + '\\n' for id in a]))\\n \\n"}
{"id": "1208", "input": "t=int(input())\\nfor _ in range(t):\\n n=int(input())\\n a=list(map(int,input().split()))\\n", "gt": "a.sort()\\n s=sum(a)\\n if a[0]*(s-a[0])<=a[n-1]*(s-a[n-1]):\\n print(a[0]*(s-a[0]))\\n else:\\n print(a[n-1]*(s-a[n-1]))"}
{"id": "1209", "input": "T=int(input())\\nt=[]\\nfor _ in range(T):\\n N=int(input())\\n t.append(N)\\nN=max(t)+1\\nl=[0 for i in range(N)]\\np=1\\na=1\\nfor", "gt": "i in range(1,N):\\n a=(a*i)%1000000007\\n p=p*a%1000000007\\n l[i]=p\\nfor i in t:\\n print(l[i])\\n"}
{"id": "1210", "input": "# cook your dish here\\ntry:\\n for i in range(int(input())):\\n v1,t1,v2,t2,v3,t3=map(int,input().split())\\n ok = 0\\n if t1 <= t3 <= t2:\\n x, y = t2 - t3, t3 - t1\\n", "gt": "ok = x * v3 <= (x + y) * v1 and y * v3 <= (x + y) * v2\\n print('YES' if ok else 'NO')\\n \\nexcept:\\n pass"}
{"id": "1211", "input": "t=int(input())\\nwhile t:\\n t=t-1\\n n,x=input().split()\\n n=int(n)\\n x=int(x)\\n d,l=input().split()\\n\\n if d=='L':\\n p=x\\n elif d=='R':\\n p=(n-x)+1\\n\\n if", "gt": "p%2==1:\\n if l=='H':\\n lang='H'\\n else:\\n lang='E'\\n elif p%2==0:\\n if l=='H':\\n lang='E'\\n else:\\n lang='H'\\n print(p,lang)"}
{"id": "1212", "input": "# cook your dish here\\nfor _", "gt": "in range(int(input())):\\n s=input()\\n while(s.count(\"abc\")!=0):\\n s=s.replace(\"abc\",\"\")\\n print(s) \\n"}
{"id": "1213", "input": "from sys import stdin\\nfrom collections import Counter\\n\\ndef func(arr,n,l):\\n count=0\\n k=l//n\\n if n<len(arr):\\n for ele in arr[0:n]:\\n count+=max(0,k-ele)\\n else:\\n for ele in arr:\\n count+=max(0,ele-k)\\n return count \\n\\nfor _ in range(int(stdin.readline())):\\n s=stdin.readline().strip()\\n", "gt": "d=Counter(s)\\n arr=sorted(list(d.values()),reverse=True)\\n l=len(s)\\n val=[1]\\n for i in range(2,27):\\n if l%i==0:\\n val.append(i)\\n\\n ans = float('inf')\\n for ele in val:\\n x = func(arr,ele,l)\\n if x < ans:\\n ans = x\\n print(ans) \\n"}
{"id": "1214", "input": "# cook your dish here\\nfor t in range(int(input())):\\n x1,x2,x3,v1,v2=[int(x)for x in input().rstrip().split()]\\n", "gt": "t1=abs(x3-x1)/v1\\n t2=abs(x3-x2)/v2\\n if t1<t2:\\n print(\"Chef\")\\n elif t1>t2:\\n print(\"Kefa\")\\n elif t1==t2:\\n print(\"Draw\")\\n else:\\n pass\\n"}
{"id": "1215", "input": "try:\\n t=int(input())\\n for i in range(t):\\n print(\"Case {}:\".format(i+1), end=\" \")\\n m, n = map(int,input().split())\\n x, y = map(int,input().split())\\n l = int(input())\\n a=input()\\n destx = a.count(\"R\")-a.count(\"L\")\\n desty = a.count(\"U\")-a.count(\"D\")\\n #print(destx, desty)\\n", "gt": "\\n if (destx<0 or destx>m) or (desty<0 or desty>n):\\n result = \"DANGER\"\\n elif destx == x and desty == y:\\n result = \"REACHED\"\\n else:\\n result = \"SOMEWHERE\"\\n \\n print(result)\\nexcept:\\n pass"}
{"id": "1216", "input": "def isSolvable( W, R):\\r\\n LW, LR, F, ML, AW, V, LMap = len(W), len(R), set([w[0] for w in W+[R]]), max(map(len, W+[R])), W+[R], set(), {}\\r\\n if LR < ML: return False\\r\\n def dfs(d,i,c):\\r\\n if d == ML: return c == 0\\r\\n if i == len(W) + 1:\\r\\n s = sum(LMap[w[-d-1]] if d < len(w) else 0 for w in W) + c\\r\\n", "gt": "return dfs(d+1,0,s//10) if s % 10 == LMap[R[-d-1]] else False\\r\\n if i < LW and d >= len(W[i]): return dfs(d,i+1,c)\\r\\n ch = AW[i][-d-1]\\r\\n if ch in LMap: return dfs(d,i+1,c)\\r\\n for x in range((ch in F), 10):\\r\\n if x not in V:\\r\\n LMap[ch], _ = x, V.add(x)\\r\\n if dfs(d,i+1,c): return True\\r\\n V.remove(LMap.pop(ch))\\r\\n return dfs(0,0,0)\\r\\nn=int(input())\\r\\nW=[]\\r\\nfor i in range(n):\\r\\n W.append(str(input()))\\r\\nR=input() \\r\\na=(isSolvable(W,R))\\r\\nif a==True:\\r\\n print(\"true\")\\r\\nelse:\\r\\n print(\"false\")"}
{"id": "1217", "input": "t=int(input())\\nfor i in range(t):\\n n,k=map(int,input().split())\\n m=list(map(int,input().split()))\\n a=0\\n for i in", "gt": "m:\\n if i>=k:\\n a=1\\n break\\n if a==1:\\n print('YES')\\n else:\\n print('NO')"}
{"id": "1218", "input": "def fun(a,cur,n,cnt):\\n if cur>=n-1:\\n return\\n for i in range(cur,n-1):\\n if i<n-2:\\n if a[i]>0 and a[i+1]>0:\\n a[i]-=1\\n a[i+1]-=1\\n a[i+2]+=1\\n cnt[0]=(cnt[0]+1)%1000000007\\n fun(a,i,n,cnt)\\n a[i]+=1\\n a[i+1]+=1\\n", "gt": "a[i+2]-=1\\n else:\\n if a[i]>0 and a[i+1]>0:\\n a[i]-=1\\n a[i+1]-=1\\n a.append(1)\\n cnt[0]=(cnt[0]+1)%1000000007\\n fun(a,i,n+1,cnt)\\n a[i]+=1\\n a[i+1]+=1\\n a.pop()\\ntc=int(input())\\nfor case in range(tc):\\n n=int(input())\\n a=list(map(int,input().split()))\\n cnt=[1]\\n fun(a,0,n,cnt)\\n print(cnt[0]%1000000007)\\n \\n"}
{"id": "1219", "input": "t=int(input())\\r\\nfor i in range(t):\\r\\n x,n=[int(g) for g in", "gt": "input().split()]\\r\\n sal=0\\r\\n day=x\\r\\n while day<n:\\r\\n sal=sal+day\\r\\n day+=x\\r\\n print(sal)\\r\\n"}
{"id": "1220", "input": "t = int(input())\\nwhile t != 0:\\n M = 1000000007\\n n, m = list(map(int, input().split())) \\n ans = 1\\n tt =", "gt": "n//2\\n tt = tt * (tt + 1)\\n \\n ans = pow(m, tt, M)\\n \\n print(ans)\\n t -= 1\\n \\n \\n"}
{"id": "1221", "input": "import sys\\r\\nfrom collections import defaultdict\\r\\nfrom copy import copy\\r\\n\\r\\nR = lambda t = int: t(eval(input()))\\r\\nRL = lambda t = int: [t(x) for x in input().split()]\\r\\nRLL = lambda n, t = int: [RL(t) for _ in range(n)]\\r\\n\\r\\ndef solve():\\r\\n N, Q = RL()\\r\\n P = RL()\\r\\n B = RL()\\r\\n phones = sorted(zip(P, B))\\r\\n S = defaultdict(lambda : [])\\r\\n \\r\\n for p, b", "gt": "in phones:\\r\\n for i in range(2**7):\\r\\n if (i>>b) & 1:\\r\\n S[i] += [p]\\r\\n B = set(B)\\r\\n I = [0] * len(B)\\r\\n\\r\\n for _ in range(Q):\\r\\n b, K = RL()\\r\\n s = RL()\\r\\n x = 0\\r\\n for b in s:\\r\\n x += 1<<b\\r\\n if len(S[x]) < K:\\r\\n print(-1)\\r\\n else:\\r\\n print(S[x][-K])\\r\\n \\r\\n\\r\\nT = 1#R()\\r\\nfor t in range(1, T + 1):\\r\\n solve()\\r\\n"}
{"id": "1222", "input": "from math import sqrt\\n\\nT = int(input())\\nans = []\\n\\nfor _ in range(T):\\n X = int(input())\\n\\n count = 0\\n x = 0\\n y = 0\\n while(x<=X):\\n p =", "gt": "int(sqrt(y))\\n count += 1\\n if(p*p>y):\\n x = p\\n y += p**2\\n else:\\n x = p+1\\n y += (p+1)**2\\n if(x<=X):\\n ans.append(count)\\n else:\\n ans.append(count-1)\\n\\nfor i in ans:\\n print(i)"}
{"id": "1223", "input": "def sort_str(s):\\n o = []\\n for c in s:\\n o.append(c)\\n o.sort()\\n return \"\".join(o)\\ndef find_ana(s):\\n if len(s) <= 1:\\n return 0\\n h = {}\\n c = 0\\n for i in range(len(s)):\\n", "gt": "for j in range(i+1, len(s)+1):\\n t = sort_str(s[i:j])\\n if t in h:\\n c += h[t]\\n h[t] += 1\\n else:\\n h[t] = 1\\n return c\\nt = int(input())\\nfor _ in range(t):\\n print(find_ana(input()))"}
{"id": "1224", "input": "t=int(input())\\n \\ndef vsense(val,a,l):\\n sense=0\\n ctr=a\\n for c in range(n):\\n if val[c]<=ctr:\\n sense+=-1\\n else:\\n sense+=1\\n ctr+=l\\n return sense\\n \\nwhile t:\\n n,l,a,b=list(map(int,input().split()))\\n val=list(map(int,input().split()))\\n val.sort()\\n sense=0\\n if b==a+n*l or vsense(val,a,l)<=0:\\n loc=a\\n", "gt": "else:\\n st=a\\n end=b-n*l\\n while st<=end:\\n m=(st+end)/2\\n chk=vsense(val,m,l)\\n if chk==0:\\n loc=m\\n break\\n elif chk<0:\\n end=m-1\\n else:\\n loc=m\\n st=m+1\\n ans=0\\n st=loc\\n for c in range(n):\\n ans+=abs(st-val[c])\\n st+=l\\n print(ans)\\n \\n t-=1\\n"}
{"id": "1225", "input": "\\n\\nimport fractions\\nimport sys\\n\\nf = sys.stdin\\n\\nif len(sys.argv) > 1:\\n f = open(sys.argv[1], \"rt\")\\n\\n\\nsum_cache = {}\\n\\ndef sum_func(x):\\n if x < 10:\\n return x\\n\\n r = sum_cache.get(x)\\n if r is not None:\\n return r\\n\\n xx = 0\\n while x > 0:\\n xx += x % 10\\n x /= 10\\n\\n r = sum_func(xx)\\n sum_cache[x] = r\\n\\n return r\\n\\ndef test():\\n for n in range(1):\\n print(n, sum_func(n))\\n\\n print(sum_func(int(10**18 - 1)))\\n\\n#~ test()\\n#~ sys.exit(1)\\n\\ncycle_table = [\\n # Cycle len, markers # D_kfunc\\n [9, [1, 1, 1, 1, 1, 1, 1, 1, 1]], # 1\\n [9, [1, 1, 1, 1, 1, 1, 1, 1, 1]], # 2\\n [3, [1, 0, 0, 1, 0, 0, 1, 0, 0]], # 3\\n [9, [1, 1, 1, 1, 1, 1, 1, 1, 1]], # 4\\n [9, [1, 1, 1, 1, 1, 1, 1, 1, 1]], # 5\\n [3, [1, 0, 0, 1, 0, 0, 1, 0, 0]], # 6\\n [9, [1, 1, 1, 1, 1, 1, 1, 1, 1]], # 7\\n [9, [1, 1, 1, 1, 1, 1, 1, 1, 1]], # 8\\n [1, [1, 0, 0, 0, 0, 0, 0, 0, 0]], # 9\\n]\\n\\nNUMBER = 9\\n\\ndef calc(A_1, D, L, R):\\n #~ print('calc ===', A_1, D, L, R)\\n A_L = A_1 + D * (L - 1)\\n A_L_kfunc = sum_func(A_L)\\n D_kfunc = sum_func(D)\\n\\n #~ print(A_L, A_L_kfunc, D_kfunc)\\n\\n n = R - L + 1\\n\\n if D == 0:\\n", "gt": "return n * A_L_kfunc\\n\\n cycle_len = cycle_table[D_kfunc - 1][0]\\n cycle_markers = list(cycle_table[D_kfunc - 1][1]) # copy\\n #~ print('cycle_len', cycle_len)\\n\\n whole_part = n // cycle_len\\n remainder = n % cycle_len\\n #~ print('whole_part, remainder = ', whole_part, remainder)\\n\\n counts = [whole_part * x for x in cycle_markers]\\n #~ print(counts)\\n\\n pos = 0\\n for i in range(remainder):\\n counts[pos] += 1\\n pos = (pos + D_kfunc) % NUMBER\\n\\n #~ print(counts)\\n\\n r = 0\\n for i, x in enumerate(counts):\\n value = (A_L_kfunc - 1 + i) % NUMBER + 1\\n r += value * x\\n\\n return r\\n\\ndef calc_dumb(A_1, D, L, R):\\n #~ print('dumb ===', A_1, D, L, R)\\n a = A_1 + D * (L - 1)\\n\\n n = R - L + 1\\n\\n r = 0\\n\\n for i in range(n):\\n value = sum_func(a)\\n #~ print(a, value)\\n r += value\\n a += D\\n\\n return r\\n\\ndef test1():\\n a1 = 1\\n L = 1\\n R = 1000\\n for d in range(100):\\n r1 = calc_dumb(a1, d, L, R)\\n r2 = calc(a1, d, L, R)\\n if r1 != r2:\\n print(a1, d, L, R, \":\", r1, r2)\\n\\n\\ndef test2():\\n a1 = 1\\n d = 9\\n L = 1\\n R = 9\\n r1 = calc_dumb(a1, d, L, R)\\n r2 = calc(a1, d, L, R)\\n print(r1, r2)\\n\\n#~ test1()\\n#~ sys.exit(1)\\n\\nT = int(f.readline().strip())\\n\\nfor case_id in range(1, T+1):\\n A_1, D, L, R = list(map(int, f.readline().strip().split()))\\n\\n r = calc(A_1, D, L, R)\\n\\n print(r)\\n"}
{"id": "1226", "input": "t=eval(input())\\ndef func(k,n,x,dist,graph):\\n if k==n:\\n x+=[dist[n]]\\n return\\n for i in range(1,n+1):\\n if graph[k][i]!=0 and dist[i]==-1:\\n dist[i]=dist[k]+graph[k][i]\\n func(i,n,x,dist,graph)\\n dist[i]=-1\\n \\nwhile t:\\n graph=[[0 for i in range(11)]for j", "gt": "in range(11)]\\n v,e=list(map(int,input().split()))\\n for i in range(e):\\n x,y,w=list(map(int,input().split()))\\n graph[x][y]=w\\n graph[y][x]=w\\n x=[]\\n dist=[-1]*(v+1)\\n dist[1]=0\\n func(1,v,x,dist,graph)\\n x.sort()\\n val=x[0]\\n ans=0\\n for i in range(len(x)):\\n if val==x[i]:\\n ans+=1\\n print(ans)\\n t-=1\\n"}
{"id": "1227", "input": "from collections import defaultdict\\nfrom itertools import product\\n\\ndef solve(mouse,n,m):\\n \\n # shadow matrix will contains the count of mice which affect (i,j) position\\n # if there is a mice at position (i,j) then in shadow matrix it will affect all four adjacent blocks \\n shadow=[[0 for i in range(m)]for j in range(n)]\\n for i,j in product(list(range(n)),list(range(m))):\\n if mouse[i][j]==1:\\n if i>0:\\n shadow[i-1][j]+=1\\n if j>0:\\n shadow[i][j-1]+=1\\n if i<n-1:\\n shadow[i+1][j]+=1\\n if j<m-1:\\n shadow[i][j+1]+=1\\n \\n # dp is a dictionary which contains a tuple of 3 values (i,j,0)=>we are coming at destination (i,j) from left side\\n # (i,j,1)=> we are coming at destination (i,j) from top \\n dp=defaultdict(int)\\n \\n # \\n dp[(0,0,0)]=dp[(0,0,1)]=shadow[0][0]-mouse[0][0]\\n \\n # fill only first row\\n # in first row we can only reach at (0,j) from (0,j-1,0) as we can't come from top.\\n \\n # so here we will assign count of mices which will affect current cell (shadow[0][i]) + previous result i.e,(0,j-1,0) and \\n # if mouse is in the current cell than we have to subtract it bcoz we have add it", "gt": "twice i.e, when we enter at this block \\n # and when we leave this block \\n for i in range(1,m):\\n dp[(0,i,0)]=dp[(0,i,1)]=shadow[0][i]-mouse[0][i]+dp[(0,i-1,0)]\\n \\n # same goes for first column\\n # we can only come at (i,0) from (i-1,0) i.e top\\n for i in range(1,n):\\n dp[(i,0,0)]=dp[(i,0,1)]=shadow[i][0]-mouse[i][0]+dp[(i-1,0,1)]\\n \\n \\n # for rest of the blocks \\n # for a block (i,j) we have to add shadow[i][j] and subtract mouse[i][j] from it for double counting\\n # now for each block we have two choices, either take its previous block with same direction or take previous block with different \\n # direction and subtract corner double counted mouse. We have to take min of both to find optimal answer\\n for i,j in product(list(range(1,n)),list(range(1,m))):\\n a=shadow[i][j]-mouse[i][j]\\n b=a\\n a+=min(dp[(i,j-1,0)],dp[(i,j-1,1)]-mouse[i-1][j])\\n b+=min(dp[(i-1,j,1)],dp[(i-1,j,0)]-mouse[i][j-1])\\n dp[(i,j,0)]=a\\n dp[(i,j,1)]=b\\n \\n # what if [0][0] and [n-1][m-1] have mice, so we have to add them as we haven't counted them yet.\\n \\n return min(dp[(n-1,m-1,0)],dp[(n-1,m-1,1)])+mouse[0][0]+mouse[n-1][m-1]\\n \\nfor _ in range(int(input())):\\n n,m=list(map(int,input().split( )))\\n mouse=[]\\n for i in range(n):\\n x=input()\\n mouse.append(list(map(int,x)))\\n print(solve(mouse,n,m))\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n"}
{"id": "1228", "input": "for _ in range(int(input())):\\n l=list(map(str,input().split()))\\n a=[(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]\\n c=0\\n for i in", "gt": "a:\\n if len(set([l[i[0]-1],l[i[1]-1],l[i[2]-1]]))==1:\\n c=1\\n break\\n if c==1:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n"}
{"id": "1229", "input": "for _ in range(int(input())):\\n n=int(input())\\n a=[]\\n b=[]\\n for i in range(4*n-1):\\n c,d=list(map(int,input().split()))\\n a.append(c)\\n", "gt": "b.append(d)\\n c1=0\\n c2=0\\n for i in a:\\n c1^=i\\n for i in b:\\n c2^=i\\n print(c1,c2)"}
{"id": "1230", "input": "for _ in range(int(input())):\\n n, k = map(int, input().split())\\n arr= list(map(int, input().split()))\\n motu, tomu = [], []\\n for i in range(n):\\n if i%2 == 0:\\n motu.append(arr[i])\\n else:\\n", "gt": "tomu.append((arr[i]))\\n motu.sort(reverse=True)\\n tomu.sort()\\n for i in range(len(motu)):\\n if len(tomu)-1<i:\\n break\\n if k==0:\\n break\\n if tomu[i]<motu[i]:\\n tomu[i], motu[i] = motu[i], tomu[i]\\n k-=1\\n if sum(tomu) > sum(motu):\\n print(\"YES\")\\n else:\\n print(\"NO\")"}
{"id": "1231", "input": "dic = {}\\n#num = \"1\"\\n#def tonum(num):\\n# res=0\\n# for i in range(len(num)):\\n# res = 2*res + int(num[i])\\n# return res\\n\\n#for i in range(64):\\n# number = tonum(num)\\n# dic[num] = []\\n# num = num+\"0\"\\n\\nn = int(input())\\nflag=0\\nif n >= 68:\\n inp = input()\\n print(\"Yes\")\\nelse:\\n inp = [int(x) for x in input().split()]\\n for i in range(len(inp)-1):\\n for j in", "gt": "range(i+1,len(inp)):\\n xor = inp[i]^inp[j]\\n if xor in list(dic.keys()):\\n for pair in dic[xor]:\\n (x,y) = pair\\n if x != i and y!=j and x!=j and y!=i:\\n flag = 1\\n break\\n\\n dic[xor].append((i,j))\\n else:\\n dic[xor] = []\\n dic[xor].append((i,j))\\n if flag is 1:\\n break\\n if flag is 1:\\n break\\n\\n if flag is 1:\\n print(\"Yes\")\\n else:\\n print(\"No\")\\n \\n \\n"}
{"id": "1232", "input": "from operator import add\\nfrom functools import reduce\\n\\nchoices=[]\\n\\nfor x in range(1800):\\n num_str = list(map", "gt": "(int, str (2**x)))\\n suma = reduce (add, num_str)\\n choices.append(suma)\\nN=int(input())\\n\\nfor x in range(N):\\n t=int(input())\\n print(choices[t])\\n"}
{"id": "1233", "input": "# cook your dish here\\nclass node:\\n def __init__(self,a,b=0,c=0):\\n self.val=a\\n self.a=b\\n self.b=c\\n\\narr=[]\\n\\ndef finder(node,val):\\n if(arr[node].val==0):\\n return val\\n else:\\n a=finder(arr[node].a,val)\\n b=finder(arr[node].b,val)\\n if(arr[node].val==1):\\n return a+b-a*b\\n else:\\n return a*b\\n\\nt=int(input())\\nwhile(t>0):\\n x=input()\\n n=int(input())\\n arr.append(node(0))\\n for i in", "gt": "range(0,n):\\n vals=input().split()\\n sz=len(vals)\\n for i in range(0,sz):\\n vals[i]=int(vals[i])\\n if(vals[0]==0):\\n next=node(0)\\n arr.append(next)\\n else:\\n next=node(vals[0],vals[1],vals[2])\\n arr.append(next)\\n lower=0.0\\n higher=1.0\\n eps=1e-9\\n while((higher-lower)>eps):\\n mid=(higher+lower)/2.0 \\n if(finder(n,mid)>0.5):\\n higher=mid\\n else:\\n lower=mid\\n print(\"%.5f\" %(higher))\\n arr=[]\\n # print(higher)\\n t-=1"}
{"id": "1234", "input": "import sys\\n\\ndef GRIG(L):\\n\\n LENT = len(L)\\n MINT = 1\\n GOT = 0\\n\\n DY = [ [{x: 0 for x in range(0, 10)}, 0, 0] ]\\n\\n for i in L:\\n\\n DY.append([{x: 0 for x in range(0, 10)}, 0, 0])\\n GOT += 1\\n\\n for j in range(0, GOT):\\n\\n if", "gt": "DY[j][0][i] == 1:\\n DY[j][0][i] = 0\\n DY[j][1] -= 1\\n else:\\n DY[j][0][i] = 1\\n DY[j][1] += 1\\n\\n DY[j][2] += 1\\n\\n if DY[j][1] <= 1 and DY[j][2] > MINT:\\n MINT = DY[j][2]\\n\\n return MINT\\n\\nTESTCASES = int(input().strip())\\n\\nfor i in range(0, TESTCASES):\\n \\n L = [int(x) for x in list(input().strip())]\\n \\n print(GRIG(L))\\n"}
{"id": "1235", "input": "divisors = [1 , 2 , 3 , 4 , 6 , 8 , 9 , 10 , 12 , 16 , 18 , 20 , 24 , 30 , 32 , 36 , 40 , 48 , 60 , 64 , 72 , 80 , 84 , 90 , 96 , 100 , 108 , 120 , 128 , 144 , 160 , 168 , 180 , 192 , 200 , 216 , 224 , 240 , 256 , 288 , 320 , 336 , 360 , 384 , 400 , 432 , 448 , 480 , 504 , 512 , 576 , 600 , 640 , 672 , 720 , 768 , 800 , 864 , 896 , 960 , 1008 , 1024 , 1152 , 1200 , 1280 , 1344 , 1440 , 1536 , 1600 , 1680 , 1728 , 1792 , 1920 , 2016 , 2048 , 2304 , 2400 , 2688 , 2880 , 3072 , 3360 , 3456 , 3584 , 3600 , 3840 , 4032 , 4096 , 4320 , 4608 , 4800 , 5040 , 5376 , 5760 , 6144 , 6720 , 6912 , 7168 , 7200 , 7680 , 8064 , 8192 , 8640 , 9216 , 10080 , 10368 , 10752 , 11520 , 12288 , 12960 , 13440 , 13824 , 14336 , 14400 , 15360 , 16128 , 16384 , 17280 , 18432 , 20160 , 20736 , 21504 , 23040 , 24576 , 25920 , 26880 , 27648 , 28672 , 28800 , 30720 , 32256 , 32768 , 34560 , 36864 , 40320 , 41472 , 43008 , 46080 , 48384 , 49152 , 51840 , 53760 , 55296 , 57600 , 61440 , 62208 , 64512 , 65536 , 69120 , 73728 , 80640 , 82944 , 86016 , 92160 , 96768 , 98304 , 103680 , 107520 , 110592 , 115200 , 122880 , 124416 , 129024 , 131072 , 138240 , 147456 , 153600 , 161280 , 165888 , 172032 , 184320 , 193536 , 196608 , 207360 , 215040 , 221184 , 230400 , 245760]\\nnumbers = [1 ,", "gt": "2 , 4 , 6 , 12 , 24 , 36 , 48 , 60 , 120 , 180 , 240 , 360 , 720 , 840 , 1260 , 1680 , 2520 , 5040 , 7560 , 10080 , 15120 , 20160 , 25200 , 27720 , 45360 , 50400 , 55440 , 83160 , 110880 , 166320 , 221760 , 277200 , 332640 , 498960 , 554400 , 665280 , 720720 , 1081080 , 1441440 , 2162160 , 2882880 , 3603600 , 4324320 , 6486480 , 7207200 , 8648640 , 10810800 , 14414400 , 17297280 , 21621600 , 32432400 , 36756720 , 43243200 , 61261200 , 73513440 , 110270160 , 122522400 , 147026880 , 183783600 , 245044800 , 294053760 , 367567200 , 551350800 , 698377680 , 735134400 , 1102701600 , 1396755360 , 2095133040 , 2205403200 , 2327925600 , 2793510720 , 3491888400 , 4655851200 , 5587021440 , 6983776800 , 10475665200 , 13967553600 , 20951330400 , 27935107200 , 41902660800 , 48886437600 , 64250746560 , 73329656400 , 80313433200 , 97772875200 , 128501493120 , 146659312800 , 160626866400 , 240940299600 , 293318625600 , 321253732800 , 481880599200 , 642507465600 , 963761198400 , 1124388064800 , 1606268664000 , 1686582097200 , 1927522396800 , 2248776129600 , 3212537328000 , 3373164194400 , 4497552259200 , 6746328388800 , 8995104518400 , 9316358251200 , 13492656777600 , 18632716502400 , 26985313555200 , 27949074753600 , 32607253879200 , 46581791256000 , 48910880818800 , 55898149507200 , 65214507758400 , 93163582512000 , 97821761637600 , 130429015516800 , 195643523275200 , 260858031033600 , 288807105787200 , 391287046550400 , 577614211574400 , 782574093100800 , 866421317361600 , 1010824870255200 , 1444035528936000 , 1516237305382800 , 1732842634723200 , 2021649740510400 , 2888071057872000 , 3032474610765600 , 4043299481020800 , 6064949221531200 , 8086598962041600 , 10108248702552000 , 12129898443062400 , 18194847664593600 , 20216497405104000 , 24259796886124800 , 30324746107656000 , 36389695329187200 , 48519593772249600 , 60649492215312000 , 72779390658374400 , 74801040398884800 , 106858629141264000 , 112201560598327200 , 149602080797769600 , 224403121196654400 , 299204161595539200 , 374005201994424000 , 448806242393308800 , 673209363589963200 , 748010403988848000 , 897612484786617600 , 1122015605983272000 , 1346418727179926400 , 1795224969573235200 , 2244031211966544000 , 2692837454359852800 , 3066842656354276800 , 4381203794791824000 , 4488062423933088000 , 6133685312708553600 , 8976124847866176000 , 9200527969062830400]\\nt = int(input())\\nfor x in range(0, t):\\n a = int(input())\\n i = 0\\n for y in divisors:\\n if y > a:\\n print(\"win\", numbers[i])\\n break\\n i = i+1\\n else:\\n print(\"lose\")\\n"}
{"id": "1236", "input": "<s> ", "gt": "print(25)"}
{"id": "1237", "input": "t = int(input())\\n\\nfor _ in range(t):\\n n = int(input())\\n a = input().strip()\\n prev = a[0]\\n ans", "gt": "= -1\\n for i in a:\\n if prev == i:\\n ans += 1\\n prev = i\\n print(ans)\\n"}
{"id": "1238", "input": "# cook your dish here\\r\\nfor _ in range(int(input())):\\r\\n a,b,c=list(map(int, input().split()))\\r\\n p=a*100+b\\r\\n mx=p \\r\\n ans, cnt = 0, 0\\r\\n while True:\\r\\n", "gt": "cnt+=1 \\r\\n if p<c or cnt==10000:\\r\\n break\\r\\n \\r\\n else:\\r\\n p-=c \\r\\n a=p//100\\r\\n b=p%100\\r\\n p=b*100+a\\r\\n if p>mx:\\r\\n mx=p\\r\\n ans=cnt\\r\\n \\r\\n print(ans)"}
{"id": "1239", "input": "test=int(input())\\nfor i in range(test):\\n N=input()\\n X=[]\\n list2=[]\\n for x in N:\\n X.append(x)\\n list1=[]\\n list1=list(set(X))\\n output=''\\n for x in list1:\\n for y in X:\\n if int(x)>=6:\\n n=int(x)*10+int(y)\\n list2.append(n)\\n for", "gt": "j in list1:\\n if int(j)>=6:\\n m=int(j)*10+int(j)\\n list2.remove(m)\\n list2.sort()\\n if len(list2)==0:\\n print(\" \")\\n else:\\n list2.sort()\\n for k in list2:\\n if chr(k) not in output and 64<k<91:\\n output+=chr(k)\\n print(output)\\n \\n"}
{"id": "1240", "input": "# cook your dish here\\nt=int(input())\\nfor _ in range(t):\\n n = int(input())\\n for i in range(n+1):\\n b = n\\n for space in range(n-i):\\n print(\" \",end=\"\")\\n for", "gt": "j in range(i+1):\\n print(b,end=\"\")\\n b-=1\\n print()\\n for l in range(n):\\n a = n\\n for j1 in range(0,l+1):\\n print(\" \",end=\"\")\\n for k in range(n-l):\\n print(a,end=\"\")\\n a-=1\\n\\n print()"}
{"id": "1241", "input": "# cook your dish here\\nt = int(input())\\nwhile t:\\n x = int(input())\\n arr = [int(i) for i in input().split()]\\n total = 0\\n for", "gt": "i in arr:\\n if i % 6 == 0:\\n total += 6\\n else:\\n total += (i % 6)\\n print(total)\\n t -= 1"}
{"id": "1242", "input": "n=int(input())\\nfor i in range(n):\\n k,x=map(int,input().split())\\n l=list(map(int,input().split()))\\n f,e,o=0,0,0\\n for i in l:\\n if(i%2==0):\\n e+=1\\n else:\\n o+=1\\n", "gt": "if(o<=x//2):\\n f=1\\n elif(e<=x//2):\\n if((k-x)%2!=0):\\n f=0\\n else:\\n f=1\\n else:\\n if(x%2==0):\\n f=1\\n else:\\n f=0\\n if(f==1):\\n print('Jesse')\\n else:\\n print('Walter')"}
{"id": "1243", "input": "from math import *\\nfor t in range(int(input())):\\n n =", "gt": "int(input())\\n numberlist = list(map(int,input().split()))\\n numberlist.sort()\\n print(numberlist[0]* ( len(numberlist) -1))"}
{"id": "1244", "input": "a = int(input())\\r\\nfor i in range(a):\\r\\n b = input()\\r\\n if", "gt": "'5' in b or '0' in b:\\r\\n print(1)\\r\\n continue\\r\\n print(0)"}
{"id": "1245", "input": "c=0\\nfor i in range (int(input", "gt": "())):\\n a, b=map(int, input().split())\\n c+=abs(a-b)+1\\nprint(c%((10**9) +7))"}
{"id": "1246", "input": "n = int(input())\\r\\nl = [0] * n\\r\\nfor x in range(n):\\r\\n l[x] = int(input())\\r\\nfor i in range(n):\\r\\n", "gt": "z = 1\\r\\n for j in range(1,l[i]+1):\\r\\n for k in range(1,l[i]+1):\\r\\n print(z,end='')\\r\\n z += 2\\r\\n print()"}
{"id": "1247", "input": "# cook your dish here\\nl1=int(input())\\nfor i in range(l1):\\n", "gt": "x=int(input())\\n y=list(map(int,input().split()))\\n z=list(map(int,input().split()))\\n if max(z)!=max(y):\\n print('YES')\\n else:\\n print('NO')"}
{"id": "1248", "input": "import sys\\nsys.setrecursionlimit(10000000)\\ndef mergeSortInversions(arr):\\n if len(arr) == 1:\\n return arr, 0\\n larr=len(arr)\\n a = arr[:larr//2]\\n b = arr[larr//2:]\\n a, ai = mergeSortInversions(a)\\n b, bi = mergeSortInversions(b)\\n c = []\\n i = 0\\n j = 0\\n inversions = 0 + ai + bi\\n la=len(a)\\n while i < la and j < len(b):\\n if a[i] <= b[j]:\\n c.append(a[i])\\n i += 1\\n else:\\n c.append(b[j])\\n j", "gt": "+= 1\\n inversions += (la-i)\\n c += a[i:]\\n c += b[j:]\\n return c, inversions \\nfor _ in range(int(input())):\\n n,d=list(map(int,input().split()))\\n p=[int(o) for o in input().split()]\\n array=[[] for i in range(d)]\\n flag=0\\n for i in range(n):\\n array[i%d].append(p[i])\\n if p[i]%((i%d)+1)!=0:\\n flag=1\\n \\n \\n ans=0\\n dumarr=[0]*n\\n for i in range(d):\\n array[i],v=mergeSortInversions(array[i])\\n for j in range(len(array[i])):\\n dumarr[i+j*d]=array[i][j]\\n ans+=v\\n p=sorted(p)\\n # print(dumarr)\\n if dumarr==p:\\n print(ans)\\n else:\\n print(-1)\\n"}
{"id": "1249", "input": "# cook your dish here\\ndef finder(n):\\n cnt=0\\n for i in range(2,n+1):\\n a=n\\n while a!=0:\\n r=a%i\\n a=a//i\\n", "gt": "if r==1:\\n cnt+=1\\n return cnt\\n\\nt=int(input())\\nfor _ in range(t):\\n n=int(input())\\n if n==0:\\n print(0)\\n elif n==1:\\n print('INFINITY')\\n else:\\n print(finder(n))\\n"}
{"id": "1250", "input": "# cook your dish here\\nfor i in range(int(input())):\\n n,k=[int(i) for i in input().split()]\\n if(n%2==0):\\n if(k<(n*(n+1))//2 - 1 or k>3*((n//2)**2) - 1):print(-1)\\n elif(k==(n*(n+1))//2 - 1):\\n for i in range(1,n+1):print(i,'',end='')\\n print()\\n else:\\n k,count,p,l,x = k-(n*(n+1))//2 + 1,0,0,[0 for i in range(n)],1\\n while(k>0):p+=2 ;k,count = k-n+p ,count+1\\n for i in range(n,n-count+1,-1):l[x]=i ;x+=2\\n k=-k ;l[2*count - 1 +k],p= n-count+1 ,1\\n for i in range(n):\\n if(l[i]==0):l[i]=p ; p+=1 \\n for i in l:print(i,'',end='')\\n print()\\n else:\\n if(n==1):print(1) if(k==0) else print(-1) \\n elif(k<(n*(n+1))//2 - 1 or k>3*(n//2)*(n//2 + 1)):print(-1)\\n", "gt": "elif(k==(n*(n+1))//2 - 1):\\n for i in range(1,n+1):print(i,'',end='')\\n print()\\n else:\\n k,count,p,l,x = k-(n*(n+1))//2 + 1,0,0,[0 for i in range(n)],1\\n while(k>0): p+=2 ;"}
{"id": "1251", "input": "t=int(input())\\r\\nfor _ in range(t):\\r\\n n=int(input())\\r\\n", "gt": "p=10**9+7\\r\\n a=(pow(3,n+1,p)-1)\\r\\n \\r\\n b=(pow(2,n+1,p)-1)\\r\\n \\r\\n print((((3*a)//2)%p-(2*(b))%p+p)%p)"}
{"id": "1252", "input": "import sys\\n\\ndef _r(*conv) :\\n r = [conv[i](x) for i, x in enumerate(input().strip().split(' '))]\\n return r[0] if len(r) == 1 else r\\n\\ndef _ra(conv) :\\n return list(map(conv, input().strip().split(' ')))\\n\\ndef _rl() :\\n return list(input().strip())\\n\\ndef _rs() :\\n return input().strip()\\n\\ndef _a(k, *v) :\\n return all(x == k for x in v)\\n\\ndef _i(conv) :\\n for line in sys.stdin :\\n yield conv(line)\\n##################################################################\\n\\nn = _r(int)\\nlookup = dict([(x, i) for i, x in enumerate(_ra(str))])\\ng = [(set(), dict()) for _ in range(n)]\\n\\nm = _r(int)\\nfor _ in range(m) :\\n c1, c2, d = _r(str, str, int)\\n i1", "gt": "= lookup[c1]\\n\\n g[i1][0].add(c2)\\n g[i1][1][c2] = d\\n\\n\\nt = _r(int)\\nfor _ in range(t) :\\n k = _ra(str)[1:]\\n \\n failed = False\\n if len(set(k)) != len(k) :\\n failed = True\\n\\n if not failed :\\n if k[0] not in lookup : \\n failed = True\\n else : \\n r = 0\\n v = g[lookup[k[0]]]\\n\\n for i in range(1, len(k)) : \\n if k[i] not in v[0] : \\n failed = True\\n break\\n\\n r += v[1][k[i]]\\n v = g[lookup[k[i]]]\\n \\n if not failed : \\n print(r)\\n \\n if failed : \\n print('ERROR')\\n"}
{"id": "1253", "input": "# cook your dish here\\nimport math\\nN = 10**6\\nsum_arr = [0] * (N + 1) \\ndef lprime():\\n arr = [0] * (N + 1) \\n arr[0] = 1\\n arr[1] = 1\\n for i in range(2, math.ceil(math.sqrt(N) + 1)): \\n if arr[i] == 0: \\n for", "gt": "j in range(i * i, N + 1, i): \\n arr[j] = 1\\n \\n curr_prime_sum = 0\\n\\n for i in range(1, N + 1): \\n if arr[i] == 0: \\n curr_prime_sum += i \\n sum_arr[i] = curr_prime_sum \\n \\nn=int(input())\\nlprime()\\nfor _ in range(n):\\n x=int(input())\\n print(sum_arr[x]%10)"}
{"id": "1254", "input": "# cook your dish here\\nT = int(input())\\n\\nfor i in range(T):\\n N,data,D,People = int(input()),list(map(int,list(input()))),int(input()),list(map(int,input().split()))\\n \\n data.insert(0,\"|\"),data.append(\"|\")\\n infected = []\\n for i in range(1,N+1):\\n if(data[i]==1):\\n infected.append(i)\\n \\n i = 0\\n while(i<D):\\n boundary = People[i] +", "gt": "i\\n data.insert(boundary,\"|\")\\n times = len(infected)\\n for p in range(times):\\n index = infected[p]\\n if(index>=boundary):\\n index+=1\\n infected[p]+=1\\n if(data[index]==1):\\n if(data[index+1]==0):\\n data[index+1] = 1\\n infected.append(index+1)\\n if(data[index-1]==0):\\n data[index-1] = 1\\n infected.append(index-1)\\n else:\\n infected.remove(index)\\n times-=1\\n i+=1\\n infected.sort()\\n \\n print(data.count(1))"}
{"id": "1255", "input": "t = int(input())\\nfor z in range(t) :\\n n,p = [int(x) for x in input().split()]\\n a = [int(x) for x in input().split()] \\n c = [x for", "gt": "x in a if x >= p//2]\\n h = [x for x in a if x <= p//10]\\n if len(c)==1 and len(h)==2 :\\n print(\"yes\")\\n else:\\n print(\"no\")"}
{"id": "1256", "input": "for _ in range(int(input())):\\n s,k=map(str,input().split())\\n k=int(k)\\n n=\"NOPE\"\\n al=[0]*26\\n for ele in s:\\n al[ord(ele)-ord('a')]=1\\n l=len(s)\\n ans=[]\\n # print(al)\\n for i", "gt": "in range(26):\\n if len(ans)==l:\\n break\\n elif al[i]==1 and k>0:\\n k-=1\\n ans.append(chr(i+ord('a')))\\n elif al[i]==0:\\n ans.append(chr(i+ord('a')))\\n \\n if len(ans)!=l:\\n print(n)\\n else:\\n print(\"\".join(ans))"}
{"id": "1257", "input": "# cook your dish here\\nt = int(input())\\n\\nres = []\\nfor i in range(t):\\n n = int(input())\\n arr = [int(i) for i in input().split()]\\n \\n num_2 = 0\\n num = 0\\n \\n for j in", "gt": "range(len(arr)):\\n if arr[j] == 2:\\n num_2 += 1\\n \\n if arr[j] > 2:\\n num += 1\\n \\n res.append(num_2 * num + (num * (num - 1)) // 2)\\n \\nfor z in res:\\n print(z)"}
{"id": "1258", "input": "factorials=[1]\\n\\nfor x in range(1,201):\\n factorials.append(factorials[x-1]*x)\\n", "gt": "\\nx=int(input())\\n\\nfor x in range(x):\\n n=int(input())\\n print(factorials[n])"}
{"id": "1259", "input": "s=int(input())\\nwhile(s>0):\\n s-=1\\n a=input()\\n c=0\\n for x in", "gt": "a:\\n c+=int(x)\\n if(c<9 and len(a)!=1):\\n print(9-c%9)\\n else:\\n print(min(9-c%9,c%9))\\n"}
{"id": "1260", "input": "# cook your dish here\\nt=int(input())\\nfor _ in range(t):\\n n,m = map(int,input().split())\\n count=0\\n", "gt": "for i in range(n,m+1):\\n p=str(i)\\n if p[-1]=='2' or p[-1]=='3' or p[-1]=='9':\\n count+=1\\n print(count)"}
{"id": "1261", "input": "def merge(intervals,start,mid,end):\\n al = mid-start+1\\n bl = end-mid\\n \\n A = intervals[start:mid+1]\\n B = intervals[mid+1:end+1]\\n \\n p=0;q=0;k=start;\\n while(p<al and q<bl):\\n if(A[p]<B[q]):\\n intervals[k] = A[p]\\n k+=1;p+=1;\\n else:\\n intervals[k] = B[q]\\n k+=1;q+=1;\\n \\n while(p<al):\\n intervals[k] = A[p]\\n k+=1;p+=1;\\n while(q<bl):\\n intervals[k] = B[q]\\n k+=1;q+=1;\\n \\n\\ndef mergesort(intervals, start, end):\\n if(start<end):\\n mid = int((start+end)/2)\\n mergesort(intervals,start,mid)\\n mergesort(intervals,mid+1,end)\\n merge(intervals,start,mid,end)\\n\\nt = int(input())\\nfor _ in range(t):\\n n,m,k = map(int, input().split())\\n \\n cities = [[0,[]] for i in range(n)]\\n for i in range(m):\\n a,b = map(int, input().split())\\n cities[a-1][1].append(b-1)\\n cities[b-1][1].append(a-1)\\n \\n li = list(map(int, input().split()))\\n \\n def specialfunction():\\n mergesort(li,0,n-1)\\n if(k>len(li)):\\n print(-1)\\n else:\\n sum = 0\\n front = 0\\n rear = len(li)-1\\n for i in range(k):\\n if(i%2==0):\\n sum += li[rear]\\n rear -= 1\\n else:\\n sum += li[front]\\n front += 1\\n print(sum)\\n \\n if(m == 0):\\n specialfunction()\\n continue\\n \\n for i in range(n):\\n cities[i][0] = li[i]\\n", "gt": "\\n visited = [-1 for i in range(n)]\\n count = 0\\n museummonths = []\\n def searchUnvisited():\\n for i in range(n):\\n if(visited[i] == -1):\\n return i\\n return -1\\n \\n def bfs(ind,count):\\n museumcount = 0\\n queue = []\\n queue.append(ind)\\n visited[ind] = 1\\n museumcount += cities[ind][0]\\n count += 1\\n front = 0\\n rear = 0\\n while(front<=rear):\\n noe = len(cities[ind][1])\\n for i in range(noe):\\n if(visited[cities[ind][1][i]] == -1):\\n queue.append(cities[ind][1][i])\\n rear += 1\\n count += 1\\n museumcount += cities[cities[ind][1][i]][0]\\n visited[cities[ind][1][i]] = 1\\n front += 1\\n try:\\n ind = queue[front]\\n except:\\n break\\n museummonths.append(museumcount)\\n return count\\n \\n while(count<n):\\n for i in range(n):\\n if(visited[i] == -1):\\n count = bfs(i,count)\\n \\n mergesort(museummonths,0,len(museummonths)-1)\\n #print(museummonths)\\n if(k>len(museummonths)):\\n print(-1)\\n else:\\n sum = 0\\n front = 0\\n rear = len(museummonths)-1\\n for i in range(k):\\n if(i%2==0):\\n sum += museummonths[rear]\\n rear -= 1\\n else:\\n sum += museummonths[front]\\n front += 1\\n print(sum)"}
{"id": "1262", "input": "\\n\\nimport fractions\\nimport sys\\n\\nf = sys.stdin\\n\\nif len(sys.argv) > 1:\\n f = open(sys.argv[1], \"rt\")\\n\\n\\ndef calc(N, M):\\n if M != N:\\n return [(-1, -1)]\\n r = [(i+1, ((i+1) % N)+1)", "gt": "for i in range(N)]\\n return r\\n\\nT = int(f.readline().strip())\\n\\nfor case_id in range(1, T+1):\\n N, M = list(map(int, f.readline().strip().split()))\\n\\n rr = calc(N, M)\\n\\n for a, b in rr:\\n print(a, b)\\n"}
{"id": "1263", "input": "t=int(input())\\nfor _ in range(t):\\n n,m=[int(x) for x in input().split()]\\n mat=[]\\n ans=[]\\n for i in range(n+2):\\n l=[]\\n p=[]\\n for j in range(m+2):\\n l.append(0)\\n p.append(1000000000)\\n mat.append(l)\\n ans.append(p)\\n y=int(input())\\n for i in range(y):\\n a,b=[int(x) for x in input().split()]\\n mat[a][b]=1\\n ans[a][b]=0\\n y=int(input())\\n for i in range(y):\\n a,b=[int(x) for x in input().split()]\\n mat[a][b]=1000000000\\n ans[a][b]=1000000000\\n for i in range(1,n+1):\\n for j in range(1,m+1):\\n if mat[i][j]==1 or mat[i][j]==1000000000:\\n continue\\n else:\\n ans[i][j]=min(ans[i][j],ans[i][j-1]+1,ans[i-1][j]+1)\\n for i in range(n,0,-1):\\n for j in range(m,0,-1):\\n if mat[i][j] == 1 or mat[i][j] == 1000000000:\\n continue\\n else:\\n ans[i][j]=min(ans[i][j],ans[i+1][j]+1,ans[i][j+1]+1)\\n for i in range(1,n+1):\\n for j in range(m, 0, -1):\\n if mat[i][j] == 1 or mat[i][j] == 1000000000:\\n continue\\n else:\\n ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\\n for i in range(n, 0, -1):\\n for j in range(1,m+1):\\n if mat[i][j] == 1 or mat[i][j] == 1000000000:\\n", "gt": "continue\\n else:\\n ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\\n for i in range(1,n+1):\\n for j in range(1,m+1):\\n if mat[i][j]==1 or mat[i][j]==1000000000:\\n continue\\n else:\\n ans[i][j]=min(ans[i][j],ans[i][j-1]+1,ans[i-1][j]+1)\\n for i in range(n,0,-1):\\n for j in range(m,0,-1):\\n if mat[i][j] == 1 or mat[i][j] == 1000000000:\\n continue\\n else:\\n ans[i][j]=min(ans[i][j],ans[i+1][j]+1,ans[i][j+1]+1)\\n for i in range(1,n+1):\\n for j in range(m, 0, -1):\\n if mat[i][j] == 1 or mat[i][j] == 1000000000:\\n continue\\n else:\\n ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\\n for i in range(n, 0, -1):\\n for j in range(1,m+1):\\n if mat[i][j] == 1 or mat[i][j] == 1000000000:\\n continue\\n else:\\n ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\\n for i in range(1,n+1):\\n for j in range(1,m+1):\\n if mat[i][j]==1000000000:\\n print('X',end=\" \")\\n elif ans[i][j]>=1000000000:\\n print('-1',end=\" \")\\n else:\\n print(ans[i][j],end=\" \")\\n print()"}
{"id": "1264", "input": "for _ in range(int(input())):\\n x,n = map(int,input().split())\\n reach = [0]*(x+1)\\n reach[0] = 1\\n i=1\\n while i**n<=x:\\n", "gt": "j = 1\\n while j+i**n<=x:\\n j+=1\\n j-=1\\n while j>=0:\\n if reach[j]>0:\\n reach[j+i**n]+=reach[j]\\n j-=1\\n i+=1\\n #print(reach)\\n print(reach[-1])"}
{"id": "1265", "input": "r=[0,1,1,2,1,4,2,6,1,8,4]\\n\\nn,m=[int(x) for x in input().split()]\\nif m==1:\\n while n%2!=1:\\n n=n/2\\n if", "gt": "n==1:\\n print(1)\\n else: \\n print(n-1) \\nelif (n+1)/2<m:\\n print(m)\\nelse:\\n print(n-m)\\n\\n \\n"}
{"id": "1266", "input": "def base5(n):\\n if n == 0: return\\n for x in base5(n // 5): yield x\\n yield n %", "gt": "5\\n\\ndef seq(n):\\n return int(''.join(str(2 * x) for x in base5(n)) or '0')\\n\\nfor i in range(eval(input())):\\n k=eval(input())\\n while(i<k):\\n i=i+1\\n print(seq(i-1))\\n"}
{"id": "1267", "input": "res=\"\"\\nfor _ in range(int(input())):\\n ans=0\\n c=int(input())\\n for i in range(c):\\n", "gt": "n,m=list(map(int,input().split( )))\\n ans^=(n+m-2)%3\\n if ans:\\n res+=\"MasterChef\\n\"\\n else:\\n res+=\"Football\\n\"\\nprint(res)\\n \\n \\n"}
{"id": "1268", "input": "def dfs(ind,m,n,k):\\n if(ind == m):\\n return [\"\"]\\n else:\\n temp = dfs(ind+1,m,n,k)\\n ans = []\\n if(len(temp)<k):\\n for i in temp:\\n for j in range(97,97+n):\\n ans += [chr(j)+i]\\n else:\\n for i in temp:\\n ans += [\"z\"+i]\\n return ans\\nn,m,k = list(map(int,input().split()))\\np = []\\nmr= []\\nfor _ in range(m):\\n inp = [int(x) for x in input().split()]\\n", "gt": "mc = inp[0]\\n mi = 0\\n for j in range(1,n):\\n if(mc<inp[j]):\\n mc = inp[j]\\n mi = j\\n p += [inp]\\n mr += [mi]\\nans = dfs(0,m,n,k)\\nw = []\\nfor i in ans:\\n cst = 0\\n s = \"\"\\n for j in range(m):\\n if(i[j]!=\"z\"):\\n s+=i[j]\\n cst += p[j][ord(i[j])-97]\\n else:\\n s += chr(mr[j]+97)\\n w += [(-cst,s)]\\nw.sort()\\nprint(w[k-1][1])\\n"}
{"id": "1269", "input": "while(True):\\n \\n n, m, x = map(int, input().split())\\n\\n if(n==0 and m==0 and x==0): \\n", "gt": "break\\n \\n \\n money=0\\n for i in range(n):\\n \\n money=money + (x+m*i)//n \\n print(money)"}
{"id": "1270", "input": "for _ in range(int(input())):\\n n=int(input())\\n a=list(map(int,input().split()))\\n b=list(map(int,input().split()))\\n a.sort()\\n", "gt": "b.sort()\\n s=0\\n for i in range(n):\\n s+=min(a[i],b[i])\\n print(s)"}
{"id": "1271", "input": "import sys\\nsys.setrecursionlimit(100000)\\n\\nmemo = {}\\ndef recurse(arr, T1, T2, k, i):\\n if T1 >= k and T2 >= k:\\n return i\\n\\n if i >= len(arr):\\n return float('inf')\\n\\n if (T1, T2) in memo:\\n return memo[(T1, T2)]\\n\\n t1 = recurse(arr, T1 + arr[i], T2, k, i+1)\\n t2 = recurse(arr, T1,", "gt": "T2 + arr[i], k, i+1) \\n\\n memo[(T1, T2)] = min(t1, t2)\\n return memo[(T1, T2)]\\n\\nfor _ in range(int(input())):\\n n, k = list(map(int, input().split()))\\n lst = list(map(int, input().split()))\\n\\n lst.sort(reverse = True)\\n memo ="}
{"id": "1272", "input": "# fast io\\nimport sys\\ndef fop(s): sys.stdout.write(str(s)+'\\n')\\ndef fip(): return sys.stdin.readline()\\nfintinp = lambda : int(fip()) \\ndef flistinp(func= int): return list(map(func,fip().split())) \\ndef fnsepline(n,func=str): return [func(fip()) for _ in range(n)]\\n#-------------------code------------------------\\ndef even(x):\\n x = bin(x).count('1')\\n return x%2==0\\n \\nfor _ in range(fintinp()):\\n q =fintinp()\\n o = e =0 \\n nums =", "gt": "set()\\n for qn in range(q):\\n qn = fintinp()\\n if qn not in nums:\\n if even(qn): e+=1 \\n else: o+=1 \\n \\n for n in set(nums):\\n x = n^qn\\n if x not in nums:\\n if even(x): e+=1 \\n else: o+=1 \\n \\n nums.add(x)\\n \\n nums.add(qn)\\n print(e,o)\\n"}
{"id": "1273", "input": "# cook your dish here\\nn=int(input())\\nfor _ in range(n):\\n", "gt": "a=int(input())\\n if(a%2==0):\\n f=(a//2)-1\\n s=a-f\\n else:\\n f=(a//2)\\n s=a-f\\n print(f,s)"}
{"id": "1274", "input": "import math\\n\\n\\nt = int(input().strip())\\n\\nfor _ in range(t):\\n n, m = list(map(int, input().strip().split()))\\n a = []\\n v = [-1] * 4\\n\\n for i in range(n):\\n a.append(input().strip())\\n\\n for i, ai in enumerate(a):\\n if ai.find('*') > -1:\\n v[2] = i\\n break\\n\\n if v[2] == -1:\\n print(0)\\n else:\\n\\n for i, ai in reversed(list(enumerate(a))):\\n if ai.find('*') > -1:\\n v[3] =", "gt": "i\\n break\\n\\n for i in range(m):\\n x = [ai[i] for ai in a]\\n if '*' in x:\\n v[0] = i\\n break\\n\\n for i in reversed(range(m)):\\n x = [ai[i] for ai in a]\\n if '*' in x:\\n v[1] = i\\n break\\n\\n if v.count(v[0]) == len(v):\\n print(1)\\n else:\\n print(int(math.ceil(max(v[3] - v[2], v[1] - v[0]) / 2.0)) + 1)"}
{"id": "1275", "input": "for _ in range(int(input().strip())):\\n n = int(input().strip())\\n lst = []\\n for i in range(n):\\n lst.append(i+1)\\n lst.append(1)\\n #print(lst)\\n for", "gt": "i in range(n):\\n print(''.join(str(e) for e in lst))\\n for x in range(n):\\n lst[x * 2 + 1] += 1\\n"}
{"id": "1276", "input": "test = int(input())\\nfor _ in range(test):\\n n, m = map(int, input().split())\\n indexArray = list(map(int, input().split()))\\n mini = min(indexArray)\\n maxi =", "gt": "max(indexArray)\\n result = n*[0]\\n for i in range(n):\\n result[i] = max(maxi - i, i - mini)\\n print(result[i], end=\" \")\\n print()"}
{"id": "1277", "input": "from bisect import *\\nfor x in range(eval(input())):\\n n,k = list(map(int,input().split()))\\n arr = list(map(int,input().split()))\\n arr.sort()\\n t = 1\\n result = 0\\n y = 0\\n while y < n:\\n if arr[y]<t:\\n", "gt": "y += 1\\n elif arr[y]==t:\\n t = t*2\\n y += 1\\n else:\\n result += 1\\n t = t*2\\n \\n while t < 2**(k):\\n result += 1\\n t = t*2\\n print(result)"}
{"id": "1278", "input": "for i in range(int(input())):\\n n=int(input())\\n s=0\\n for i in", "gt": "range(n):\\n a,b,c=map(int,input().split())\\n d=(c/100)*a\\n e=a+d\\n f=e-((c/100)*e)\\n g=a-f\\n h=b*g\\n s=s+h\\n print(s)"}
{"id": "1279", "input": "# cook your dish here\\nfrom sys import stdin,stdout,setrecursionlimit\\nfrom math import ceil\\n\\nmod = 1000000007\\nt = int(stdin.readline())\\nfor _ in range(t):\\n m,n = list(map(int,input().split()))\\n if m < n:\\n m,n = n,m\\n\\n y = n-1\\n s1", "gt": "= ((y*(y+1)) //2)%mod\\n s2 = ((y*(y+1)*(2*y+1)) //6)%mod\\n s3 = ((y*y*(y+1)*(y+1)) //4)%mod\\n \\n \\n ans = (m*n*s1 - (m+n)*s2+s3)%mod\\n # ans = (m*(m+1)*(2*m*n + 4*n + 2 - m*m - m)//12)\\n \\n print(ans)\\n \\n"}
{"id": "1280", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n d=dict()\\n ls=[]\\n for i in range(int(input())):\\n ls=list(map(int,input().split()))\\n if", "gt": "ls[0] in d:\\n d[ls[0]]=max(ls[1],d[ls[0]])\\n else:\\n d[ls[0]]=ls[1]\\n # print(d)\\n if len(d)<3:\\n print(0)\\n else:\\n kd=list(d.values())\\n kd.sort()\\n # print(kd)\\n print(kd[-1]+kd[-2]+kd[-3])\\n"}
{"id": "1281", "input": "t=int(input())\\r\\nfor _ in range(t):\\r\\n xyz = input().strip()\\r\\n \\r\\n string = 0\\r\\n\\r\\n", "gt": "for i in range(len(xyz)//2):\\r\\n string = string + (abs(ord(xyz[i])-ord(xyz[len(xyz)-i-1])))\\r\\n \\r\\n print(string)"}
{"id": "1282", "input": "t=int(input())\\nx=[1,2,3,4,5,6,7]\\nfor i in range(t):\\n N=int(input())\\n a=list(map(int,input().split())) \\n rev=a[::-1] \\n dup=set(a)", "gt": "\\n if rev== a and list(dup) ==x: \\n print(\"yes\")\\n else:\\n print(\"no\")"}
{"id": "1283", "input": "l= []\\nfor i in range(62):\\n l.append(2**i)\\nT = int(input())\\n\\nflag = 0\\nfor t in range(T):\\n L,R = [int(i) for i in input().split()]\\n bL = bin(L)\\n lL = len(bL)-2\\n index = 1\\n", "gt": "ans = 0\\n temp = 0\\n \\n while(index<=lL):\\n temp = L%l[index]\\n if temp>=l[index-1]:\\n if(l[index]-temp<=R-L+1):\\n ans= (ans +(l[index-1])*(l[index]-temp))%1000000007\\n else :\\n ans=(ans+(l[index-1])*(R-L+1))%1000000007\\n \\n \\n index+=1\\n print(ans)\\n# 4378578345 584758454958\\n# 18091037982636824985 8589934592 4429185025 4294967296\\n"}
{"id": "1284", "input": "# cook your dish here\\r\\nimport sys\\r\\nn = 201\\r\\nv = [0 for i in range(n + 1)] \\r\\n\\r\\ndef gen():\\r\\n for i in range(1, n + 1): \\r\\n v[i] = i \\r\\n \\r\\n countDivision = [0 for i in range(n + 1)] \\r\\n \\r\\n for i in range(n + 1): \\r\\n countDivision[i] = 2\\r\\n \\r\\n for i in range(2, n + 1, 1):", "gt": "\\r\\n \\r\\n \\r\\n if (v[i] == i and countDivision[i] == 2): \\r\\n for j in range(2 * i, n + 1, i): \\r\\n if (countDivision[j] > 0): \\r\\n v[j] = int(v[j] / i) \\r\\n countDivision[j] -= 1\\r\\ntry:\\r\\n t=int(sys.stdin.readline())\\r\\n for _ in range(t):\\r\\n gen()\\r\\n x=int(sys.stdin.readline())\\r\\n flag=0\\r\\n for i in range(2,x//2+1):\\r\\n if v[i]==1 and v[x-i]==1:\\r\\n flag=1\\r\\n #print(i,x-i)\\r\\n if flag==1:\\r\\n print(\"YES\")\\r\\n else:\\r\\n print(\"NO\")\\r\\nexcept:\\r\\n pass\\r\\n"}
{"id": "1285", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n = int(input())\\n k = n//4\\n # a,b,c = map(int,input().split())\\n a =", "gt": "sorted(map(int,input().split()))\\n a60 = (a[k-1],a[k])\\n a75 = (a[2*k-1],a[2*k])\\n a90 = (a[3*k-1],a[3*k])\\n if a60[0]==a60[1] or a75[0]==a75[1] or a90[0]==a90[1] :\\n print(-1)\\n else :\\n print(a60[1],a75[1],a90[1])\\n"}
{"id": "1286", "input": "# cook your dish here\\nT=int(input())\\nfor k in range(0,T):\\n N=int(input())\\n matrix=[]\\n for i in range(0,N):\\n a=list(map(int, input().split()))\\n matrix.append(a)\\n max_trace", "gt": "= []\\n for i in range(0,N):\\n trace1=0\\n trace2=0\\n for j in range(0,i+1):\\n trace1+=matrix[j][N+j-i-1]\\n trace2+=matrix[N+j-i-1][j]\\n max_trace.append(trace1)\\n max_trace.append(trace2)\\n print(max(max_trace))\\n\\n \\n"}
{"id": "1287", "input": "import math\\r\\n\\r\\ndef main():\\r\\n #print(\"enter i, k, s\")\\r\\n IN = '11 6 5'\\r\\n z = IN.split()\\r\\n z = input().split()\\r\\n i = int(z[0])\\r\\n k = int(z[1])\\r\\n s = int(z[2])\\r\\n\\r\\n #print(\"enter a_i and b_i\")\\r\\n IN = '4 5'\\r\\n z = IN.split()\\r\\n z = input().split()\\r\\n a_i = int(z[0])\\r\\n b_i = int(z[1])\\r\\n\\r\\n #print( \"i = %d k = %d s = %d \" % (i, k, s) )\\r\\n #print( \"a_i = %d b_i = %d\" % (a_i, b_i) )\\r\\n\\r\\n x = math.sqrt(2)\\r\\n y = math.sqrt(3)\\r\\n #print(x,y)\\r\\n\\r\\n # Obtaining the k-th element when k >= i\\r\\n if(i<=k):\\r\\n diff = k-i\\r\\n #if both k and i are odd or even\\r\\n if(k-i)%2==0:\\r\\n #print(\"#1\")\\r\\n ans = (a_i + b_i) * math.pow(2,2*(k-i)-s)\\r\\n #diff = int(diff/2) \\r\\n #ans = (a_i + b_i) * math.pow(2,4*diff-s)\\r\\n \\r\\n #if i and k are of", "gt": "different parities then obtaining first\\r\\n # a_(i+1) and b_(i+1)\\r\\n else:\\r\\n #print(\"#2\")\\r\\n ans = (2*x*a_i + 2*x*y*b_i) * math.pow(2,2*(k-(i+1))-s )\\r\\n diff = int(diff/2)\\r\\n ans = (2*x*a_i + 2*x*y*b_i) * math.pow(2,4*diff - s)\\r\\n #print(\"1: \", (2*x*a_i + 2*x*y*b_i))\\r\\n #print(\"2: \", math.pow(2,4*diff - 2- s)) \\r\\n #print(\"2 sol: \", math.pow(2,4*int(diff)-s))\\r\\n #print(\"diff: \",diff)\\r\\n\\r\\n\\r\\n # Obtaining the k_th element when k < i\\r\\n else:\\r\\n diff = i-k\\r\\n #if both k and i are odd or even\\r\\n if(i-k)%2==0:\\r\\n #print(\"#3\")\\r\\n ans = (a_i + b_i) / math.pow(2,2*(i-k)+s)\\r\\n #diff = int(diff/2)\\r\\n #ans = (a_i + b_i) / math.pow(2,4*diff+s)\\r\\n\\r\\n #if i and k are of different parities then obtaining first\\r\\n # a_(i+1) and b_(i+1)\\r\\n else:\\r\\n #print(\"#4\")\\r\\n ans = (2*x*a_i + 2*x*y*b_i) / math.pow(2,2*(i+1-k)+s)\\r\\n diff = int(diff/2)\\r\\n ans = (2*x*a_i + 2*x*y*b_i) / math.pow(2,4*diff + 4 + s)\\r\\n\\r\\n\\r\\n print(ans)\\r\\n \\r\\nmain()\\r\\n"}
{"id": "1288", "input": "t=int(input())\\nMOD=(10**9)+7\\nl=['a','e','i','o','u']\\nfor i in range(t):\\n s=input()\\n k=[]\\n for j in s:\\n if", "gt": "j in l:\\n k.append(1)\\n else:\\n k.append(0)\\n r=bin(int(''.join(map(str, k)), 2) << 1)\\n print((int(r,2)//2)%MOD)\\n"}
{"id": "1289", "input": "t=int(input())\\nfor _ in range(t):\\n n,m=map(int,input().split())\\n mat=[0 for i in range(n)]\\n #mat=[[0 for i in range(n)] for j in range(n)]\\n for i in range(m):\\n u,v=map(int,input().split())\\n u,v=(u-1),(v-1)\\n mat[u]|=(1<<v)\\n", "gt": "mat[v]|=(1<<u)\\n for i in range(n):\\n mat[i]|=(1<<i) \\n \\n goal=(2**n)-1\\n ans=n\\n\\n for i in range(1,goal+1):\\n mvs=0\\n loc=0\\n for j in range(n):\\n if(i&(1<<j)):\\n loc|=mat[j]\\n mvs+=1\\n if(loc==goal):\\n ans=min(mvs,ans)\\n print(ans)"}
{"id": "1290", "input": "t = int(input())\\n\\nwhile(t>0):\\n \\n n=int(input())\\n if(n<=0):\\n print(0)\\n \\n fact=1\\n", "gt": "start=1\\n for i in range(1,n+1):\\n fact*=start\\n start+=2\\n print(fact)\\n \\n t=t-1\\n"}
{"id": "1291", "input": "# cook your dish here\\nx=input ()\\ny=len (x)\\nif y==1:\\n print('1')\\nelif", "gt": "y==2:\\n print('2')\\nelif y==3:\\n print('3')\\nelif y>3:\\n print('More than 3 digits')"}
{"id": "1292", "input": "#-*- coding:utf-8 -*-\\n\\nimport sys\\n\\n\\n# class Point:\\n# def __init__(self, x, y):\\n# self.x = x\\n# self.y = y\\n\\n# def mul(self, k):\\n# return Point(k * self.x, k * self.y)\\n\\n# def __add__(self, other):\\n# return Point(self.x + other.x, self.y + other.y)\\n\\n# def __sub__(self, other):\\n# return self + (-other)\\n\\n# def __neg__(self):\\n# return Point(-self.x, -self.y)\\n\\n# def __eq__(self, other):\\n# return self.x == other.x and self.y == other.y\\n\\n# def __getitem__(self, index):\\n# return (self.x, self.y)[index]\\n\\n# def __str__(self):\\n# return \"(%d;%d)\" % (self.x, self.y)\\n\\n\\nDIRS = dict(\\n U=(0, 1),\\n D=(0, -1),\\n R=(1, 0),\\n L=(-1, 0)\\n)\\nKOEF = 0.2\\n\\n\\ndef div(a, b):\\n return round(float(a) / b, 1)\\n\\n\\n# class Moving:\\n# def __init__(self, x, y, dir):\\n# self.p = Point(x, y)\\n# self.dir = Point(*DIRS[dir.upper()])\\n\\n# def collide(self, other):\\n# times = []\\n# for coord in range(2):\\n# d = abs(self.p[coord] - other.p[coord])\\n# d2 = abs((self.p + self.dir.mul(KOEF) - other.p)[coord])\\n# d3 = abs((other.p + other.dir.mul(KOEF) - self.p)[coord])\\n# d_next = abs((self.p + self.dir.mul(KOEF) - (other.p + other.dir .mul(KOEF)))[coord])\\n# if d2 > d or d3 > d:\\n# return None\\n\\n# speed = abs(d_next - d)\\n# if speed == 0:\\n# if self.p[coord] != other.p[coord]:\\n# return None\\n# continue\\n# times.append( div(d, speed / KOEF) )\\n\\n# if len(times) == 2", "gt": "and times[0] != times[1]:\\n# return\\n# return times[0]\\n\\n\\ndef collide_coord(ex, edx, x, dx):\\n d = abs(ex - x)\\n d2 = abs(ex + edx - x)\\n d3 = abs(ex - x - dx)\\n if d2 > d or d3 > d:\\n return False\\n\\n d_next = abs(ex + edx * KOEF - x - dx * KOEF)\\n speed = abs(d_next - d)\\n if speed == 0:\\n if ex != x:\\n return\\n return \"all\" # all\\n else:\\n return div(d, speed / KOEF)\\n\\n\\ndef main():\\n t = int(input())\\n for _ in range(t):\\n ex, ey, dir = sys.stdin.readline().strip().split()\\n ex = int(ex)\\n ey = int(ey)\\n edx, edy = DIRS[dir]\\n\\n n = int(sys.stdin.readline())\\n min_time = float(\"+inf\")\\n for _ in range(n):\\n x, y, dir = sys.stdin.readline().strip().split()\\n x = int(x)\\n y = int(y)\\n dx, dy = DIRS[dir]\\n\\n tx = collide_coord(ex, edx, x, dx)\\n if tx is False:\\n continue\\n ty = collide_coord(ey, edy, y, dy)\\n if ty is False:\\n continue\\n\\n if tx == \"all\":\\n min_time = min(min_time, ty)\\n elif ty == \"all\":\\n min_time = min(min_time, tx)\\n elif tx == ty:\\n min_time = min(min_time, tx)\\n\\n print(min_time if min_time < 1000000 else \"SAFE\")\\n\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1293", "input": "# cook your dish here\\nfrom operator import itemgetter\\ninp=list(map(int, input().split()))\\nn, m, w, b = inp[:4]\\nstops=[]\\nfor i in range(w):\\n stops.append((inp[4+2*i]-1,inp[5+2*i]-1,'w'))\\nfor i in range(b):\\n stops.append((inp[4+2*w+2*i]-1,inp[5+2*w+2*i]-1,'b'))\\nstops.sort(key=itemgetter(1))\\nstops.sort(key=itemgetter(0))\\ncounter=0\\nstop_rows=[[] for _ in range(n)]\\nfor stop in stops:\\n stop_rows[stop[0]].append(stop[1:])\\nfor row", "gt": "in stop_rows:\\n idx=0\\n for i in range(len(row)):\\n if idx==row[i][0]:\\n idx+=1\\n else:\\n if row[i][1]=='w':\\n if i<len(row)-1:\\n num=row[i+1][0]-idx+1\\n counter+=((num*(num+1))>>1)-1\\n idx=row[i][0]+1\\n num=row[i+1][0]-row[i][0]+1\\n counter-=((num*(num+1))>>1)-1\\n else:\\n num=m-idx\\n counter+=((num*(num+1))>>1)-1\\n idx=row[i][0]+1\\n num=m-row[i][0]\\n counter-=((num*(num+1))>>1)-1\\n else:\\n num=row[i][0]-idx+1\\n counter+=((num*(num+1))>>1)-1\\n idx=row[i][0]+1\\n num=m-idx\\n counter+=(num*(num+1))>>1\\nprint(counter)\\n"}
{"id": "1294", "input": "def update_B(B, query):\\n p, R = query\\n for i in range(len(R)):\\n B[p][i] = R[i]\\n B[i][p] = R[i]\\n\\ndef get_A(B):\\n N = len(B)\\n A = [0] * N\\n i = 0\\n for j in range(N):\\n if B[0][j] != 0:\\n i = j\\n A[i] = -B[0][i]\\n break\\n\\n for j in range(i + 1, N):\\n if abs(A[i] - B[0][j]) == B[i][j]:\\n A[j] = B[0][j]\\n else:\\n A[j]", "gt": "= -B[0][j]\\n\\n return A\\n\\ndef print_list(A):\\n print(' '.join([str(a) for a in get_A(B)]))\\n\\n\\nN, Q = [int(x) for x in input().rstrip().split()]\\nB = []\\nfor i in range(N):\\n B += [[int(x) for x in input().rstrip().split()]]\\nqueries = []\\nfor i in range(Q):\\n p = int(input()) - 1\\n arr = input().rstrip().split()\\n queries += [(p, [int(x) for x in arr])]\\n\\nprint_list(get_A(B))\\nfor q in queries:\\n update_B(B, q)\\n print_list(' '.join([str(a) for a in get_A(B)]))\\n"}
{"id": "1295", "input": "# cook your dish here\\nimport sys,collections\\ninput=sys.stdin.readline\\ndef main():\\n T=int(input())\\n for _ in range(T):\\n N,K=map(int,input().split())\\n Tree={}\\n for j in range(N):\\n Tree[j]=[]\\n \\n for i in range(N-1):\\n u,v=map(int,input().split())\\n Tree[u-1].append(v-1)\\n Tree[v-1].append(u-1)\\n \\n A=list(map(int,input().split()))\\n \\n vis=[0 for i in range(N)] #to mark visited vertices 0 for visited and 1 for not visited\\n maxval=[[0,0] for i in range(N)] #Nx2 list where each i stores max value till now and its count \\n minval=[0 for i in range(N)] #Nx2 list where each i stores min value till now \\n lfnode=[] #list to store leaf nodes\\n \\n #Appending node 1\\n vis[0]=1\\n Q=collections.deque([0])\\n maxval[0][0],maxval[0][1]=A[0],1\\n minval[0]=A[0]\\n \\n \\n while(len(Q)!=0):\\n a=Q.pop()\\n mv1=maxval[a][0]\\n mv2=minval[a]\\n \\n flag=0 #to check", "gt": "leaf node\\n \\n for i in Tree[a]:\\n if (vis[i]==0):\\n vis[i]=1\\n flag=1 #not a leaf node\\n v=A[i]\\n Q.append(i)\\n \\n #Comparing maximum value of parent node\\n if (mv1<v):\\n maxval[i][0],maxval[i][1]=v,1\\n \\n elif(mv1==v):\\n maxval[i][0],maxval[i][1]=mv1,maxval[a][1]+1\\n \\n else:\\n maxval[i][0],maxval[i][1]=maxval[a][0],maxval[a][1]\\n \\n \\n #Comparing minimum value of parent node\\n if (mv2>v):\\n minval[i]=v\\n elif(v==mv2):\\n minval[i]=mv2\\n else:\\n minval[i]=minval[a]\\n \\n \\n if (flag==0):\\n lfnode.append(a)\\n \\n \\n flag=0 #For answer if 0 then NO else YES\\n \\n K1=len(bin(K))-2 #length of K\\n \\n #print(lfnode,val)\\n for i in lfnode:\\n v1,v2=maxval[i][0],maxval[i][1]\\n \\n if (v1>K1 and v2%2==0):\\n flag=1\\n elif(v1==K1 and v2%2==1):\\n flag=1\\n \\n \\n v11=minval[i]\\n if (v11>K1 and v11!=v1):\\n flag=1\\n elif(v11==K1):\\n flag=1\\n \\n \\n if(flag==1):\\n break\\n \\n if (flag==1):\\n print(\"YES\")\\n else:\\n print(\"NO\")\\nmain()"}
{"id": "1296", "input": "mod=10**9+7\\ndef fibonacci(n):\\n if n < 0:\\n raise ValueError(\"Negative arguments not implemented\")\\n return (_fib(n)[0]%mod + mod)%mod;\\ndef _fib(n):\\n if n == 0:\\n return (0, 1)\\n else:\\n a, b = _fib(n // 2)\\n c = (a * (b * 2 - a))%mod\\n d = (a * a + b * b)%mod\\n if", "gt": "n % 2 == 0:\\n return (c, d)\\n else:\\n return (d, c + d)\\ndef inv(n):\\n return pow(n,mod-2,mod)\\ndef brute(n,k):\\n ret = 0\\n for i in range(0,n+1):\\n ret+=fibonacci(i)*pow(k,i,mod)\\n return ret%mod\\ndef ans(n,k):\\n k%=mod\\n a = pow(k,n+1,mod)\\n b=(a*k)%mod\\n x = a*(fibonacci(n+1))+b*fibonacci(n)-k\\n y = inv((k*k+k-1)%mod)\\n return ((x*y)%mod+mod)%mod\\nfor t in range(0,eval(input())):\\n n,k = list(map(int,input().split()))\\n print(ans(n,k))"}
{"id": "1297", "input": "import sys\\nsys.setrecursionlimit(10**8)\\n\\nMOD = 10**9+7\\n\\nfac = [0]*(10**5+1)\\ndef pre() :\\n fac[0] = 1\\n for i in range(1,10**5+1) :\\n fac[i] = fac[i-1]*i\\n fac[i] = fac[i]%MOD\\n\\ndef dfs(gp , vertex , visited , deg , ans) :\\n visited[vertex] = 1\\n stack = []\\n stack.append(vertex)\\n while len(stack)>0 :\\n vertex = stack.pop()\\n ans = ans%MOD * fac[deg[vertex]]%MOD\\n ans %= MOD\\n for i in gp[vertex] :\\n if not visited[i]", "gt": ":\\n visited[i] = 1\\n if vertex in gp[i] :\\n deg[i] -= 1\\n stack.append(i)\\n return ans%MOD\\n\\npre()\\nfor __ in range(eval(input())) :\\n n = eval(input())\\n deg = [0]*(n+1)\\n st = [[] for __ in range(n+1)]\\n for _ in range(n-1) :\\n a , b = list(map(int,sys.stdin.readline().split()))\\n st[a].append(b)\\n st[b].append(a)\\n deg[a] += 1\\n deg[b] += 1\\n k = eval(input())\\n visited = [0]*(n+1)\\n print(dfs(st ,k,visited,deg , 1)%MOD)\\n \\n"}
{"id": "1298", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n x, y=", "gt": "map(int, input().split())\\n if x<y:\\n print('<')\\n elif x>y:\\n print('>')\\n else:\\n print('=')"}
{"id": "1299", "input": "t = int(input())\\nwhile(t):\\n n = int(input())\\n ar = list(map(int,input().strip().split(\"", "gt": "\")))\\n print(len([x for x in ar[1:len(ar)] if ar[0]<x]))\\n t-=1\\n"}
{"id": "1300", "input": "t=int(input())\\nf=0\\ny=0\\nfor _ in range(t):\\n n=int(input())\\n seq=[int(x) for x in input().split()]\\n prev=seq[0]\\n for i in range(1,len(seq)):\\n if prev==seq[i]:\\n seq[i]=0\\n prev=seq[i] \\n ans=0\\n", "gt": "anss=0\\n for el in seq:\\n if el!=0:\\n c=seq.count(el)\\n if ans<c:\\n ans=c\\n \\n anss=el\\n elif ans==c:\\n if el<anss:\\n anss=el\\n else:\\n anss=anss\\n print(anss)"}
{"id": "1301", "input": "from sys import stdin,stdout\\r\\nfrom math import gcd\\r\\nfor _ in range(int(stdin.readline())):\\r\\n # n=int(stdin.readline()) k-pieces\\r\\n n,k=list(map(int,stdin.readline().split()))\\r\\n a=list(map(int,stdin.readline().split()))\\r\\n gr=[[0 for _ in range(n)]for _ in range(n)];ans=0;k-=1\\r\\n for sz in range(n):\\r\\n for i in range(n-sz):\\r\\n j=i+sz\\r\\n if", "gt": "sz==0:gr[i][j]=a[i]\\r\\n else:\\r\\n gr[i][j]=gcd(gr[i+1][j],gr[i][j-1])\\r\\n # print(*gr,sep='\\n')\\r\\n dp=[[0 for _ in range(n)]for _ in range(k+1)]\\r\\n for i in range(n):\\r\\n dp[0][i]=gr[0][i]\\r\\n for i in range(1,k+1):\\r\\n for j in range(i,n):\\r\\n for par in range(j-1,-1,-1):\\r\\n dp[i][j]=max(dp[i][j],gr[par+1][j]+dp[i-1][par])\\r\\n # print(*dp,sep='\\n')\\r\\n print(dp[k][n-1])\\r\\n\\r\\n"}
{"id": "1302", "input": "# cook your dish here\\nn=int(input())\\nl=[]\\nfor i in range(n):\\n a=int(input())\\n l.append(a)\\nfor i in l:\\n b", "gt": "= list(map(int, str(i)))\\n b.sort(reverse=True)\\n s = [str(i) for i in b]\\n r = int(\"\".join(s))\\n print(r)"}
{"id": "1303", "input": "from sys import stdin\\r\\n\\r\\nfor _ in range(int(stdin.readline())):\\r\\n n =", "gt": "int(stdin.readline())\\r\\n n //= 2\\r\\n k = 2 * int(n**0.5)\\r\\n print(k)\\r\\n"}
{"id": "1304", "input": "# cook your dish here\\nmod = 10**9 + 7\\nfor i in range(int(input())):\\n n,k,m = tuple(map(int, input().split()))\\n a = list(map(int, input().split()))\\n ans = [0 for i in range(k+1)]\\n ans[0] = 1\\n curr_ending = 1\\n for i in", "gt": "range(n):\\n mod_a = a[i]%m\\n start = curr_ending - (curr_ending%m - mod_a)%m\\n if(mod_a == curr_ending%m and curr_ending<k):\\n curr_ending += 1\\n for i in range(start, 0, -m):\\n ans[i] += ans[i-1]\\n if(ans[i] > mod):\\n ans[i] = ans[i] - mod\\n print(ans[k])"}
{"id": "1305", "input": "import sys\\n# import math as mt\\n# from collections import Counter\\n# from itertools import permutations\\n# from functools import reduce\\n# from heapq import nsmallest, nlargest, heapify, heappop, heappush, heapreplace\\n\\ndef get_inpt(): return sys.stdin.readline().strip()\\ndef get_int(): return int(sys.stdin.readline().strip())\\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\\n\\n# sys.setrecursionlimit(10**7)\\n# INF = float('inf')\\n# MOD1, MOD2 = 10**9+7, 998244353\\n\\nn, k = get_ints()\\n\\nfor _", "gt": "in range(k):\\n \\n arr = get_array()\\n \\n for i in reversed(range(n-1)):\\n \\n if arr[i] < arr[i+1]:\\n \\n ind = i+1\\n minn = arr[i+1]\\n for j in range(i+1, n):\\n if arr[j] > arr[i]:\\n minn = min(arr[j], minn)\\n ind = j\\n \\n arr[i], arr[ind] = arr[ind], arr[i]\\n \\n arr = arr[:i+1] + sorted(arr[i+1:])\\n \\n break\\n \\n print(*arr)"}
{"id": "1306", "input": "res = []\\nfor _ in range(int(input())):\\n lst = []\\n flag = 0\\n n = int(input())\\n for i in range(n):\\n lst.append(list(map(int, input().split())))\\n for i in lst:\\n for j in range(n-1):\\n if i[j] == i[j+1] == 1:\\n res.append(\"UNSAFE\")\\n flag = 1\\n", "gt": "break\\n if flag != 0:\\n break\\n for i in range(n-1):\\n for j in range(n):\\n if lst[i][j] == lst[i+1] == 1:\\n res.append(\"UNSAFE\")\\n flag = 1\\n break\\n if flag != 0:\\n break\\n if flag == 0:\\n res.append(\"SAFE\")\\nfor i in res:\\n print(i)\\n"}
{"id": "1307", "input": "# cook your dish here\\nfrom collections import Counter\\nfor i in range(int(input())):\\n s=input().upper()\\n res=Counter(s)\\n if res[\"L\"]>=2 and res[\"T\"]>=2 and res[\"I\"]>=2 and res[\"M\"]>=2", "gt": ":\\n if len(s)==9:\\n if res[\"E\"] >=1 :\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n elif len(s)>9:\\n if res[\"E\"]>=2:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n else:\\n print(\"NO\")\\n else:\\n print(\"NO\")\\n \\n"}
{"id": "1308", "input": "T = int(input())\\nfor _ in range(T):\\n p,n=map(int,input().split())\\n mod = 1000000007\\n if p ==", "gt": "2:\\n print(n)\\n else:\\n f=n\\n t=n\\n for i in range(p-2):\\n f=(f%mod*n)%mod\\n a=(f-t+mod)%mod\\n t=a\\n print(a)"}
{"id": "1309", "input": "import collections\\n\\nwhile True:\\n d = input().strip()\\n myCounter = collections.Counter(d)\\n flag = 1\\n\\n for x in list(myCounter.keys()):\\n if myCounter[x] > 1:\\n", "gt": "flag = 0\\n break\\n\\n isAlp = sum([myCounter[x] for x in list(myCounter.keys()) if x.isalnum()])\\n\\n if flag and isAlp:\\n print(\"Valid\")\\n break\\n else:\\n print(\"Invalid\")\\n"}
{"id": "1310", "input": "for _ in range(int(input())):\\r\\n n = int(input())\\r\\n s = [str(i)", "gt": "for i in range(n,0,-1)]\\r\\n for i in range(n):\\r\\n print('*'*i+''.join(s))\\r\\n del(s[0])"}
{"id": "1311", "input": "t = int(input())\\nfor tc in range(t):\\n seq = input()\\n dollar = 0\\n stamp = 0\\n for ct in seq:\\n if stamp >=", "gt": "6:\\n stamp -= 6\\n continue\\n elif ct == 'M':\\n dollar += 3\\n elif ct == 'L':\\n dollar += 4\\n stamp += 1\\n print(dollar)\\n\\n\\n"}
{"id": "1312", "input": "test=int(input())\\nfor i in range(test):\\n n,k=map(int,input().split())\\n x=n-k\\n for j in range(1,n+1):\\n if(j%2==0 and", "gt": "x>0):\\n print(-j,end=' ')\\n x-=1\\n elif(k<=0):\\n print(-j,end=' ')\\n else:\\n print(j,end=' ')\\n k-=1\\n print()"}
{"id": "1313", "input": "import sys\\n\\nspoon = [ \"SPOON\", \"spoon\" ]\\n\\ndef main():\\n try:\\n tc=int(input())\\n while tc>0:\\n tc=tc-1\\n [r,c] = input().split()\\n r=int(r)\\n c=int(c)\\n k=0\\n flag=0\\n matrix=[0]*r\\n i=0\\n while i<r:\\n matrix[i]=input()\\n i=i+1\\n \\n #Check row wise\\n for m in matrix:\\n for s in m:\\n if s==spoon[0][k] or s==spoon[1][k]:\\n k=k+1\\n if k==5:\\n flag=1\\n k=0\\n break\\n else:\\n k=0\\n", "gt": "\\n if flag==1:\\n print(\"There is a spoon!\")\\n continue\\n \\n #Check column wise\\n i=0\\n k=0\\n while i<c:\\n j=0\\n while j<r:\\n if matrix[j][i]==spoon[0][k] or matrix[j][i]==spoon[1][k]:\\n k=k+1\\n if k==5:\\n flag=1\\n k=0\\n break\\n else:\\n k=0\\n j=j+1\\n i=i+1\\n \\n if flag==1:\\n print(\"There is a spoon!\")\\n continue\\n \\n print(\"There is indeed no spoon!\")\\n \\n except:\\n return 0\\nmain()\\n"}
{"id": "1314", "input": "from math import sqrt,gcd\\n\\nfor _ in range(int(input())):\\n n=int(input())\\n ar=[int(x) for x in input().split()]\\n g=ar[0]\\n for i in range(1,n):\\n", "gt": "g=gcd(g,ar[i])\\n \\n f=g\\n for i in range(2,int(sqrt(g))+1):\\n if g%i==0:\\n f=i\\n break\\n if g!=1:\\n print(f)\\n else:\\n print(-1)\\n \\n \\n"}
{"id": "1315", "input": "def left_span(arr,n):\\n ans=[0]\\n span=[0]\\n for i in range(1,n):\\n \\n while span and arr[i]>arr[span[-1]]:\\n span.pop()\\n \\n if not span:\\n ans.append(0)\\n \\n else:\\n ans.append(span[-1]+1)\\n span.append(i)\\n return ans\\n\\ndef right_span(arr,n):\\n ans=[n+1]\\n span=[n-1]\\n for i in range(n-2,-1,-1):\\n \\n while span and arr[i]>=arr[span[-1]]:\\n span.pop()\\n \\n if not span:\\n ans.append(n+1)\\n else:\\n ans.append(span[-1]+1)\\n span.append(i)\\n return ans[::-1]\\nfrom collections import Counter\\nfrom bisect import bisect_left,bisect_right\\nfrom operator import itemgetter\\nn,q=list(map(int,input().split( )))\\narr=list(map(int,input().split( )))\\n\\nleft=left_span(arr,n)\\nright=right_span(arr,n)\\nc=Counter()\\nfor i in range(n):\\n", "gt": "c[arr[i]]+=(right[i]-(i+1))*(i+1-left[i])\\na=sorted(c)\\nf=[]\\nfor v in a:\\n f.append(c[v])\\nprefix_sum=[f[0]]\\nn=len(f)\\nfor i in range(1,n):\\n prefix_sum.append(f[i]+prefix_sum[-1])\\nr=[0]*q\\nfor i in range(q):\\n sign,k,player=list(map(str,input().split( )))\\n k=int(k)\\n if sign==\"=\":\\n if k in c:\\n res=c[k]\\n else:\\n res=0\\n elif sign==\">\":\\n j=bisect_left(a,k)\\n if j==n:\\n res=0\\n elif a[j]==k:\\n res=prefix_sum[-1] - prefix_sum[j]\\n else:\\n if j>0:\\n res=prefix_sum[-1] - prefix_sum[j-1]\\n else:\\n res=prefix_sum[-1]\\n else:\\n j=bisect_left(a,k)\\n if j==0:\\n res=0\\n else:\\n res=prefix_sum[j-1]\\n \\n if res%2==0:\\n if player==\"D\":\\n r[i]=\"C\"\\n else:\\n r[i]=\"D\"\\n else:\\n r[i]=player\\nprint(''.join(r))\\n \\n \\n\\n\\n"}
{"id": "1316", "input": "n=int(input())\\nl=[]\\ncount=0\\nwhile n:\\n n-=1\\n a,b,c=sorted(map(int,input().split()))\\n if (a,b,c)", "gt": "in l:\\n count-=1\\n else:\\n l.append((a,b,c))\\n count+=1\\nprint(count)"}
{"id": "1317", "input": "# cook your dish here\\nfrom collections import defaultdict\\n\\nclass sol():\\n def __init__(self,n,edges):\\n self.n = n\\n self.edges = edges\\n self.graph = self.create_graph()\\n self.precompute()\\n \\n def create_graph(self):\\n graph = defaultdict(list)\\n for e in self.edges:\\n u = e[0]\\n v = e[1]\\n w = e[2]\\n graph[u].append([v,w])\\n graph[v].append([u,w])\\n return graph\\n \\n def precompute(self):\\n self.maxiedges = [0]*6\\n self.B = [[0 for i in range(101)] for i in range(101)]\\n def func(u,v,l):\\n if l==2:\\n self.B[u][self.maxiedges[l]]", "gt": "+= 1\\n else:\\n for j in self.graph[v]:\\n self.maxiedges[l+1] = max(self.maxiedges[l],j[1])\\n func(u,j[0],l+1)\\n for i in range(1,self.n+1):\\n func(i,i,0)\\n \\n def paths(self,X):\\n freq = 0\\n for u in range(1,self.n+1):\\n for x in range(X+1):\\n freq += 2*self.B[u][X]*self.B[u][x]\\n freq -= self.B[u][X]*self.B[u][X]\\n return freq\\n \\nn, m = map(int, input().split())\\nedges = []\\nwhile m:\\n uvw = list(map(int, input().split()))\\n edges.append(uvw)\\n m -= 1\\nq = int(input())\\nGraph = sol(n,edges)\\nwhile q:\\n query = int(input())\\n print(Graph.paths(query))\\n q -= 1\\n"}
{"id": "1318", "input": "import sys\\n \\ndef findRoom(x,y,i):\\n R = [(x,y)]\\n GRID[x][y] = i\\n for n in R:\\n GRID[n[0]][n[1]] = i\\n if n[0]>0 and GRID[n[0]-1][n[1]]==0 and H[n[0]-1][n[1]]:\\n GRID[n[0]-1][n[1]] = i\\n R.append((n[0]-1,n[1]))\\n if n[0]<N-1 and GRID[n[0]+1][n[1]]==0 and H[n[0]][n[1]]:\\n GRID[n[0]+1][n[1]] = i\\n R.append((n[0]+1,n[1]))\\n if n[1]>0 and GRID[n[0]][n[1]-1]==0 and V[n[0]][n[1]-1]:\\n GRID[n[0]][n[1]-1] = i\\n R.append((n[0],n[1]-1))\\n if n[1]<M-1 and GRID[n[0]][n[1]+1]==0 and V[n[0]][n[1]]:\\n GRID[n[0]][n[1]+1] = i\\n R.append((n[0],n[1]+1))\\n\\ndef roomPrice(r):\\n wall_price_0 = wall_price_1 = 0\\n for i in range(R):\\n if C[i][r] and T[i] != 1:\\n wall_price_0 += C[i][r]*K\\n else:\\n wall_price_1 += C[i][r]*K\\n return [wall_price_0 + Rooms[r][0], wall_price_1 + Rooms[r][1]]\\n\\ndef total_price():\\n price = 0\\n for r in range(R):\\n for i in range(r):\\n if C[i][r] and T[i] != T[r]:\\n price += C[i][r]*K\\n price += Rooms[r][T[r]-1]\\n return price\\n\\ndef solve(r):\\n if r==R:\\n return 0\\n wall_price_0 = 0\\n wall_price_1 = 0\\n for i in range(r):\\n if C[i][r] and T[i] != 1:\\n wall_price_0 += C[i][r]*K\\n else:\\n wall_price_1 += C[i][r]*K\\n if T[r]!=0:\\n return [wall_price_0,wall_price_1][T[r]-1]+Rooms[r][T[r]-1]+solve(r+1) \\n T[r] = 1\\n result = solve(r+1)+wall_price_0+Rooms[r][0]\\n T[r] = 2\\n result = min(solve(r+1)+wall_price_1+Rooms[r][1],", "gt": "result)\\n T[r] = 0\\n return result\\n \\nf = sys.stdin\\nN,M,W,K,R = list(map(int, f.readline().split(' ')))\\nT = [0] * R\\nGRID = list(map(list,[[0]*M]*N))\\nH = list(map(list,[[1]*M]*N))\\nV = list(map(list,[[1]*M]*N))\\nWalls = []\\nfor _ in range(W):\\n x0,y0,x1,y1 = list(map(int, f.readline().split(' ')))\\n x0 -= 1\\n x1 -= 1\\n y0 -= 1\\n y1 -= 1\\n if x0==x1:\\n V[x0][y0] = 0\\n else:\\n H[x0][y0] = 0\\n Walls.append([x0,y0,x1,y1]) \\nRooms = []\\nfor i in range(R):\\n x,y,t1,t2 = list(map(int, f.readline().split(' ')))\\n findRoom(x-1,y-1,i+1)\\n Rooms.append([t1,t2])\\nC = list(map(list,[[0]*R]*R))\\nfor w in Walls:\\n r1 = GRID[w[0]][w[1]]-1 \\n r2 = GRID[w[2]][w[3]]-1\\n C[r1][r2] += 1\\n C[r2][r1] += 1\\nStable = [False]*R\\nfor r in range(R):\\n walls_max_price = sum(C[r])*K\\n if walls_max_price<=abs(Rooms[r][0]-Rooms[r][1]):\\n # If we choose the cheaper team, no matter what the next rooms are the walls we not overprice it.\\n T[r] = 1+(Rooms[r][0]>Rooms[r][1])\\n Stable[r] = True\\ndef try_teams():\\n for r in range(R):\\n if not Stable[r]:\\n T[r] = 1+(r&1)\\n change = True\\n while change:\\n change = False\\n for r in range(R):\\n price = roomPrice(r)\\n if price[T[r]-1]>price[2-T[r]]:\\n T[r] = 3-T[r]\\n change = True\\n print(total_price())\\n#try_teams() \\nprint(solve(0))\\n"}
{"id": "1319", "input": "try:\\n\\n for j in range(1,int(input())+1):\\n n,k = map(int,input().split())\\n\\n if k>n:\\n", "gt": "c=0\\n else:\\n c = n-k+1\\n\\n s = c*(c+1)//2\\n print('Case', str(j)+':',s)\\nexcept:\\n pass"}
{"id": "1320", "input": "n,m=map(int,input().split())\\r\\nl=[]\\r\\nleng=0\\r\\nfor i in range(n+m):\\r\\n w=int(input())\\r\\n if w==-1:\\r\\n cm=0\\r\\n mi=0\\r\\n for j", "gt": "in range(leng):\\r\\n if l[j]>cm:\\r\\n cm=l[j]\\r\\n mi=j\\r\\n \\r\\n print(cm)\\r\\n l[mi]=-1\\r\\n else:\\r\\n l.append(w)\\r\\n leng+=1"}
{"id": "1321", "input": "\\nfor _ in range(int(input())):\\n n=int(input())\\n if(n<3):\\n print(\"B\")\\n", "gt": "else:\\n if(n==3):\\n print(\"A\")\\n elif(n%2):\\n print(\"B\")\\n else:\\n print(\"B\")\\n\\n\\n\\n\\n\\n\\n\\n\\n"}
{"id": "1322", "input": "T=int(input())\\nfor i in range(T):\\n n=int(input())\\n if", "gt": "n==1:\\n print(\"0\")\\n else:\\n n=n-2\\n l=(n+1)*(2*n+3)*(n+2)/6\\n print(int(l))\\n"}
{"id": "1323", "input": "# cook your dish here\\n#t = int(input())\\nfor i in range(int(input())):\\n n,k = map(int,input().split())\\n l = list(map(int,input().split()))\\n l.sort(reverse", "gt": "= True)\\n c = 0\\n for i in l:\\n if i >= l[k-1]:\\n c += 1\\n print(c)"}
{"id": "1324", "input": "#for _ in range(int(input())):\\n#n,m = map(int,input().split())\\n#n = int(input())\\n#x = [int(w) for w in input().split()]\\n#x = [int(input()) for _ in range(n)]\\n#for i in range(n):\\n#dt = {} for i in x:dt[i] = dt.get(i,0)+1\\n#dt = {k:v for k,v in sorted(x.items(), key=lambda i: i[1])}\\n\\nfrom bisect import bisect_left as bs\\nn = int(input())\\nx = [int(input()) for _ in range(n)]\\ndp = []\\nmn = float('inf')\\nidx = []\\nmlen = float('-inf')\\nsi,sj = 0,0\\nsm =", "gt": "0\\ndef check(_sm,ind1,ind2,f):\\n nonlocal mn,si,sj,mlen\\n if _sm<abs(mn) or (_sm==abs(mn) and (idx[ind2]-idx[ind1])>mlen):\\n si,sj = idx[ind1]+1,idx[ind2]\\n mn = _sm*f\\n mlen = sj-si+1\\n\\nfor k,v in enumerate(x,1):\\n sm += v\\n ind = bs(dp,sm)\\n dp.insert(ind,sm)\\n idx.insert(ind,k)\\n check(abs(sm),0,ind,1)\\n\\n if ind>0:\\n prev = ind-1\\n diff = dp[ind]-dp[prev]\\n while prev>0 and (dp[ind]-dp[prev-1])==diff:\\n prev -= 1\\n check(diff,prev,ind,1)\\n if ind < len(dp)-1:\\n nxt = ind+1\\n diff = dp[nxt]-dp[ind]\\n while nxt<len(dp)-1 and (dp[nxt+1]-dp[ind])==diff:\\n nxt += 1\\n check(diff,nxt,ind,-1)\\nprint(mn)\\nprint(si,sj)\\n"}
{"id": "1325", "input": "from math import sqrt\\n\\nfor _ in range(int(input())):\\n \\n n, k = map(int, input().split())\\n fact,i = [],1\\n \\n while i<=sqrt(n):\\n\\n if n%i==0:\\n if (n // i", "gt": "!= i):\\n fact.append(n//i)\\n \\n fact.append(i)\\n \\n i+=1\\n \\n tot = (k*(k+1))//2\\n mx = -1\\n \\n for i in fact:\\n if i>=tot:\\n mx = max(mx,n//i)\\n \\n print(mx)"}
{"id": "1326", "input": "# cook your dish here\\nfor j in", "gt": "range(int(input())):\\n \\n p,q,r,s =map(int,input().split())\\n x=(s-p)\\n y=(s-q)\\n z=(s-r)\\n print(y,z,x)"}
{"id": "1327", "input": "for _ in range(int(input())):\\n n=int(input())\\n f=list(map(int,input().split()))\\n sum1=f[0]\\n d=0\\n i=1 \\n", "gt": "while sum1!=0 and i<n:\\n sum1=sum1-1+f[i]\\n d+=1 \\n i+=1 \\n print(d+sum1)\\n"}
{"id": "1328", "input": "# cook your dish here\\nimport bisect\\nfor _ in range(int(input())):\\n N,Q=list(map(int,input().strip().split(' ')))\\n V=list(map(int,input().strip().split(' ')))\\n", "gt": "VV=sorted(V)\\n for ___ in range(Q):\\n x,y=list(map(int,input().strip().split(' ')))\\n x-=1\\n y-=1\\n ans1=abs(V[x]-V[y])+(y-x)\\n post1=bisect.bisect_left(VV,min(V[x],V[y]))\\n post2=bisect.bisect_right(VV,max(V[x],V[y]))\\n ans2=post2-post1\\n print(ans1,ans2)\\n"}
{"id": "1329", "input": "# cook your dish here\\nfor _", "gt": "in range(0,int(input())):\\n n=input().strip()\\n x=n.count('4')\\n y=n.count('7')\\n print(len(n)-x-y)\\n"}
{"id": "1330", "input": "T = int(input())\\nfor t in range(T):\\n n, m = list(map(int, input().split()))\\n c = list(map(int, input().split()))\\n dp1 = [1e9]*((1 << n)+1)\\n for i in range(n):\\n dp1[1 << i] = c[i] \\n \\n dp1[1 << (n-1)] = min(dp1[1 << (n-1)], sum(c))\\n \\n for i in range(m):\\n l = list(map(int, input().split()))\\n cost = l[0]\\n s = l[1]\\n items = l[2:]\\n mask = 0\\n for j in items:\\n mask = mask | (1 << (j-1))\\n", "gt": "dp1[mask] = min(dp1[mask], cost)\\n \\n for i in range((1<<n) - 1, -1, -1):\\n for j in range(n):\\n if i & (1<< j):\\n dp1[i ^ (1<<j)] = min(dp1[i ^ (1<<j)], dp1[i])\\n \\n dp2 = [1e9]*((1 << n) + 1)\\n dp2[0] = 0\\n for i in range(1 << n):\\n submask = i\\n while submask > 0:\\n dp2[i] = min(dp2[i], dp2[i ^ submask] + dp1[submask])\\n submask = (submask-1) & i\\n \\n print(dp2[(1 << n)-1])\\n"}
{"id": "1331", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n A,B=list(map(int,input().split()))\\n l1=list(map(int,input().split()))\\n l2=list(map(int,input().split()))\\n for i in range(A*B):\\n if l1[i]<l2[i]:\\n l1[i]=0\\n", "gt": "else:\\n l2[i]=0\\n l1.sort(reverse=True)\\n l2.sort(reverse=True)\\n \\n w,d,c=0,0,0\\n for j in range(A):\\n if l1[c]>l2[d]:\\n w+=1\\n c+=1\\n d+=B-1\\n else:\\n d+=B\\n print(w)\\n \\n"}
{"id": "1332", "input": "t = int(input())\\nfrom math import log, ceil, floor\\nwhile t:\\n t-=1 \\n n,k = map(int ,input().split())\\n v = floor(log(k, 2))\\n block", "gt": "= 1 << v + 1 \\n print(n / block * (1 + (k - 2 ** v) * 2 ))"}
{"id": "1333", "input": "t=eval(input())\\nfor _ in range(t):\\n i,j=list(map(int,input().split()))\\n bi=bin(i)[2:]\\n bj=bin(j)[2:]\\n k=0\\n", "gt": "while k<(min(len(bi),len(bj))):\\n if bi[k]!=bj[k]:\\n break\\n else:\\n k+=1\\n print(len(bi)-k+len(bj)-k)\\n \\n"}
{"id": "1334", "input": "mod=10**9+7\\ndef pow2(x):\\n p,n=1,2\\n while(x):\\n if(x & 1): p=((p%mod) * (n%mod))%mod\\n\\n n=((n%mod) * (n%mod))%mod\\n x//=2\\n\\n return p\\n\\ndef count_bit(val):\\n bit=0\\n while(val):\\n bit+=1\\n val &=(val-1)\\n return bit\\n", "gt": "\\ndef answer():\\n\\n val=b[0]\\n po2=0\\n for i in range(1,len(b)):\\n if(val > b[i]):return 0\\n po2+=count_bit(val & b[i])\\n val=b[i]\\n\\n return pow2(po2)%mod\\n\\n\\nfor T in range(int(input())):\\n n=int(input())\\n b=list(map(int,input().split()))\\n\\n print(answer())\\n \\n"}
{"id": "1335", "input": "import math\\nn = int(input())\\na=list(map(int,input().split()))\\ndp = [0 for x in range(n)]\\ndp[0] = a[0]\\ndp[1]", "gt": "= a[1]\\ndp[2] = a[2]\\nfor x in range(3,n):\\n dp[x] = a[x] + min(dp[x-1],dp[x-2],dp[x-3])\\n\\nprint(min(dp[-3:]))\\n"}
{"id": "1336", "input": "# cook your dish here\\nn=int(input())\\nlst=list(map(int,input().split()))\\ndict1={}.fromkeys(lst,0)\\nfor key in", "gt": "lst:\\n dict1[key]+=1\\nsum1=0\\nfor key in dict1:\\n sum1+=dict1[key]//2\\n if(dict1[key]%2==1):\\n sum1+=1\\nprint(sum1)"}
{"id": "1337", "input": "line = input()\\ntest = 0\\n\\nwhile line != \"0\":\\n test += 1\\n d = {'0':0,'1':0,'2':0,'3':0,'4':0,'5':0,'6':0,'7':0,'8':0,'9':0}\\n a = list(map(int,line.split()))\\n for i in range(min(a),max(a)+1):\\n for c in", "gt": "str(i):\\n d[c] += 1\\n pairs = list(d.items())\\n pairs.sort() \\n print(\"Case %s: %s\" % (test, \" \".join([\"%s:%s\" % (k,v) for k,v in pairs])))\\n line = input()"}
{"id": "1338", "input": "from math import gcd\\r\\ndef compute_lcm(x, y):\\r\\n lcm = (x*y)//gcd(x,y)\\r\\n return lcm\\r\\n\\r\\ndef LCMofArray(a):\\r\\n lcm = a[0]\\r\\n for i in range(1,len(a)):\\r\\n lcm = lcm*a[i]//gcd(lcm,", "gt": "a[i])\\r\\n return lcm\\r\\n\\r\\nfor _ in range(int(input())):\\r\\n lens = int(input())\\r\\n arrs = [int(x) for x in input().split()]\\r\\n rest = int(input())\\r\\n print(LCMofArray(arrs) + rest)\\r\\n\\r\\n"}
{"id": "1339", "input": "#In the Name of God\\r\\nimport math\\r\\n\\r\\nx = input().split()\\r\\nn = int(x[0])\\r\\narr = []\\r\\ni = 1\\r\\nwhile(i<len(x)):\\r\\n arr.append(float(x[i]))\\r\\n i += 1\\r\\n arr.append(int(x[i]))\\r\\n i += 1\\r\\ni =", "gt": "0\\r\\n\\r\\nans = []\\r\\nwhile(i<len(arr)):\\r\\n x = arr[i]\\r\\n i += 1\\r\\n y = arr[i]\\r\\n y = 10**y\\r\\n i += 1\\r\\n ans.append(x*y)\\r\\nfor i in range(len(ans)):\\r\\n print(\""}
{"id": "1340", "input": "# cook your dish here\\ndef getAns(num):\\n if num<10:return 2 \\n last=int(str(num)[0]);rem=int(str(num)[1:]);steps=2;p=len(str(num))-1\\n while True:\\n steps+=rem//last+1;rem=rem%last \\n if last>0:rem=rem+10**p-last\\n last=last-1\\n if last==0:\\n p=p-1;last=9\\n if(len(str(rem))==1):rem=0\\n else:rem=int(str(rem)[1:])\\n ifrem==0: break\\n return steps\\nfor awa in range(int(input())):\\n k=int(input())\\n if(k==1):print(0)\\n elif(k==2):print(9)\\n elif(k==3):print(10)\\n else:\\n low,high,ans = 0,10**18,0\\n while(low<=high):\\n mid=(low+high)//2;temp=getAns(mid)\\n if", "gt": "int(temp)==k:ans=max(ans,mid);"}
{"id": "1341", "input": "for _ in range(int(input())):\\n n = int(input())\\n a = list(map(int,input().split()))\\n ans = 0\\n count = 0\\n for i in a:\\n if", "gt": "i>0:\\n ans+=i\\n count+=1\\n res = []\\n for i in range(count):\\n if a[i]<=0:\\n res.append(i+1)\\n for i in range(count,n):\\n if a[i]>0:\\n res.append(i+1)\\n print(ans)\\n print(len(res),*res)"}
{"id": "1342", "input": "import bisect\\n\\ndef pre(a):\\n for p in range(n-1):\\n if(a[p]>=a[p+1]):\\n return p\\n return n-1 \\n \\ndef suf(a):\\n for s in range(1,n):\\n if(a[n-s]<=a[n-s-1]):\\n return n-s\\n return 0\\n", "gt": "\\n \\n\\nt=int(input())\\nfor _ in range(t):\\n n=int(input())\\n a=list(map(int,input().split()))\\n \\n p=pre(a)\\n s=suf(a)\\n \\n b=a[s:n]\\n count=0\\n for i in range(p+1):\\n k=bisect.bisect(b,a[i])\\n k+=s\\n count+=n-k+1\\n \\n if(s==0):\\n print((n*(n+1))//2-1)\\n else:\\n print(count+n-s)\\n"}
{"id": "1343", "input": "import math\\nfor i in range(int(input())):\\n n,x=list(map(int,input().split()))\\n l=list(map(int,input().split()))\\n l.sort()\\n flag=0\\n d=0\\n \\n for j in range(n):\\n \\n if l[j]>x:\\n for k in range(j,n):\\n \\n if", "gt": "x<l[k]:\\n \\n \\n d+=(math.ceil(math.log(l[k]/x)/math.log(2))+1)\\n \\n else:\\n d+=1\\n \\n\\n x=l[k]*2\\n \\n \\n \\n \\n flag=1\\n \\n \\n break\\n \\n if flag==1:\\n \\n print(j+d)\\n else:\\n print(n)\\n"}
{"id": "1344", "input": "# cook your dish here\\ndef check_equal(a,b):\\n index=0\\n for i in a:\\n while index<len(b) and i != b[index]:\\n index+=1\\n if(index>=len(b)):\\n return False\\n index+=1", "gt": "\\n return True\\ndef Dob_String(n):\\n size=len(n)\\n midpoint=size//2\\n if(check_equal(n[0:midpoint],n[midpoint:size])):\\n return(\"YES\")\\n elif(size%2!=0 and check_equal(n[midpoint+1:size],n[0:midpoint+1])):\\n return(\"YES\")\\n else:\\n return(\"NO\")\\nT=int(input()) \\nfor _ in range(T):\\n n=input()\\n if(len(n)>1):\\n print(Dob_String(n))\\n else:\\n print(\"NO\")"}
{"id": "1345", "input": "# cook your dish here\\ndef __starting_point():\\n try:\\n for _ in range (int(input())):\\n element", "gt": "= int(input())\\n l = list(map(int,input().split()))\\n a=min(l)\\n l.remove(a)\\n b=min(l)\\n print(a+b)\\n except EOFError :\\n print('EOFError')\\n\\n__starting_point()"}
{"id": "1346", "input": "for _ in range(int(input())):\\n code=input().strip()+'0'\\n message=''\\n asc=int(code[0])\\n \\n for i in", "gt": "range(len(code)-1):\\n \\n if int(str(asc)+code[i+1])>256:\\n message+=chr(asc)\\n asc=int(code[i+1])\\n else: \\n asc=int(str(asc)+code[i+1])\\n \\n print(message)\\n"}
{"id": "1347", "input": "for _ in range(int(input())):\\n n,w = map(int , input().split())\\n sigma = 1\\n #len(str(num)) == n and D[i] - D[i - 1] ... = w\\n if(w > 9", "gt": "or w < -9):\\n print(0)\\n continue\\n sigma = pow(10,n - 2,1000000007)\\n if(w >= 0):\\n sigma *= (9 - w)\\n else:\\n sigma *= (w + 10)\\n print(sigma % 1000000007)"}
{"id": "1348", "input": "import sys\\nans=0\\nn,m=list(map(int,input().split()))\\naaaaa=100\\nli=list(map(int,input().split()))\\nnon_special,special=[],[]\\nfor i in range(m):\\n ans+=1\\n f,p,s=list(map(str,input().split()))\\n f=int(f)\\n poww=pow(1,2)\\n p=int(p)\\n if f not in li:\\n ans+=1\\n", "gt": "non_special.append((p,s))\\n ans-=1\\n else:\\n ans+=1\\n special.append((p,s))\\n \\nnon_special.sort(reverse=True)\\naaaa=pow(1,2)\\nspecial.sort(reverse=True)\\n\\nfor temp in range(len(special)):\\n ans+=1\\n print(special[temp][1])\\nfor temp in non_special:\\n ans+=1\\n print(temp[1])"}
{"id": "1349", "input": "from collections import defaultdict\\nimport copy\\n#def dfs(l,r,dct):\\ndef dfs(l,r,dct):\\n visit=[0 for i in range(n+1)]\\n arr=[l]\\n while(arr):\\n node=arr.pop()\\n if node==r:return True\\n visit[node]=1\\n for lnk in dct[node]:\\n if not visit[lnk]:\\n arr.append(lnk)\\n return False\\n \\ndef ok(mid,cst):\\n for i,j in edges:\\n cst[i][j]-=mid\\n \\n d=[10**9]*(n+1)\\n d[l]=0\\n for _ in range(n-1):\\n for i,j in edges:\\n d[j]=min(d[j],d[i]+cst[i][j])\\n \\n if d[r]<=0:return 1\\n for i,j in", "gt": "edges:\\n if d[j]>d[i]+cst[i][j] and dfs(l,i,dct) and dfs(j,r,dct):\\n return 1\\n return 0\\n \\nfor _ in range(int(input())):\\n n,m=map(int,input().split())\\n dct=defaultdict(list)\\n \\n cost=[[1000 for i in range(n+1)] for j in range(n+1)]\\n edges=[]\\n for i in range(m):\\n a,b,w=map(int,input().split())\\n edges.append([a,b])\\n dct[a].append(b)\\n cost[a][b]=min(cost[a][b],w)\\n \\n l,r=map(int,input().split())\\n if not dfs(l,r,dct):\\n print(-1)\\n continue\\n #print(cost)\\n lo=1\\n hi=101\\n for i in range(100):\\n cst=copy.deepcopy(cost)\\n mid=(lo+hi)/2\\n if ok(mid,cst):hi=mid-1\\n else:lo=mid+1\\n print(\"%.7f\"%mid)"}
{"id": "1350", "input": "from sys import *\\ninput=stdin.readline\\nfor u in", "gt": "range(int(input())):\\n s=int(input())\\n if(s%3==0):\\n print(1)\\n else:\\n print(0)\\n"}
{"id": "1351", "input": "m= 1000000007\\ndef mul(a,b):\\n return [(a[0]*b[0]+a[1]*b[2])%m,\\n (a[0]*b[1]+a[1]*b[3])%m,\\n (a[2]*b[0]+a[3]*b[2])%m,\\n (a[2]*b[1]+a[3]*b[3])%m] \\ndef f(n):\\n if n==0:\\n return 0\\n v1, v2, v3 = 1, 1, 0 \\n for rec in bin(n)[3:]:\\n v2=v2%m\\n v1=v1%m\\n v3=v3%m\\n calc = (v2*v2)\\n v1, v2, v3 = (v1*v1+calc), ((v1+v3)*v2), (calc+v3*v3)\\n if", "gt": "rec=='1': v1, v2, v3 = v1+v2, v1, v2\\n return [v1+1,v2,v2,v3+1]\\n\\ndef q(X,Y):\\n nonlocal A\\n s = [1,0,0,1]\\n for v in A[X-1:Y]:\\n s = mul(s,f(v))\\n return s[1]%m\\n\\nN,M = list(map(int,input().split()))\\nA=list(map(int,input().split()))\\nfor _ in range(M):\\n [T,X,Y] = input().split()\\n X,Y = int(X),int(Y)\\n if T=='Q':\\n print(q(X,Y))\\n else:\\n A[X-1]=Y"}
{"id": "1352", "input": "for _ in range(int(input())):\\n n=int(input())\\n arr=list(map(int,input().split()))\\n d=set()\\n for i in arr:\\n d.add(i)\\n for", "gt": "i in range(n):\\n if i in d:\\n print(i,end=\" \")\\n else:\\n print(0,end=\" \")\\n print()"}
{"id": "1353", "input": "from collections import Counter\\nt=int(input())\\nfor i in range(t):\\n k=int(input())\\n l=list(map(int,input().split()))\\n", "gt": "a=Counter(l)\\n b=list(a.keys())\\n b.sort()\\n for x in b:\\n s=str(x)+': '+str(a[x])\\n print(s)"}
{"id": "1354", "input": "# cook your dish here\\ndef check(px,x):\\n if px[1]==x[1]:\\n return (x[2]-px[2])<=(x[0]-px[0]) and (x[2]>=px[2])\\n else:\\n return (x[2]-px[2]+1)<=(x[0]-px[0]) and (x[2]>=px[2])\\n \\ndef checkdouble(px,x):\\n if px[3]==x[3]:\\n return (x[4]-px[4])<=(x[0]-px[0]) and (x[4]>=px[4])\\n else:\\n return (x[4]-px[4]+1)<=(x[0]-px[0]) and (x[4]>=px[4])\\n \\n\\nfor _ in", "gt": "range(int(input())):\\n px=[0,1,1,2,1]\\n g=True\\n for _ in range(int(input())):\\n x=list(map(int,input().split()))\\n if x[1]==x[3] and x[2]==x[4]:\\n g=False\\n if not g:\\n continue\\n g=check(px,x)\\n if g:\\n g=checkdouble(px,x)\\n px=x\\n if not g:\\n print(\"no\")\\n else:\\n print(\"yes\")\\n \\n \\n \\n \\n \\n \\n"}
{"id": "1355", "input": "A = [0] * 100001\\nM = 1000000007\\n\\ndef nCk(n, k):\\n if k ==0 or k ==n:\\n return 1\\n r = (A[n-k]*A[k])%M\\n x = (A[n]*pow(r, M-2, M))%M\\n return x\\n\\nfor _ in range(int(input())):\\n n, k = list(map(int, input().split()))\\n for i in", "gt": "range(n-1):\\n u,v = input().split()\\n summ = 0\\n A[0] = 1\\n for i in range(1, len(A)):\\n A[i] = (i*A[i-1])%M\\n for i in range(min(n, k)):\\n b = nCk(k,i+1)\\n c = (nCk(n-1,i)*b)%M\\n c *= A[i+1]\\n summ += (c%M)\\n summ %= M\\n print(summ)"}
{"id": "1356", "input": "# cook your dish here\\ndef index(n,val):\\n while(val >= n):\\n val = val//2\\n return n - val\\nt = int(input())\\nfor _ in range(t):\\n n = int(input())\\n arr = list(map(int,input().split()))", "gt": "\\n new = [0 for i in range(n)]\\n for i in range(n):\\n if arr[i]<=n :\\n new[i] = arr[i] + arr[arr[i]-1]\\n else:\\n new[i] = arr[index(n,arr[i]) - 1]\\n print(*new)"}
{"id": "1357", "input": "t=[[1]]\\ndef bell_numbers(start, stop):\\n ## Swap start and stop if start > stop\\n if stop < start: start, stop = stop, start\\n if start < 1: start = 1\\n if stop < 1: stop = 1\\n c = 1 ## Bell numbers count\\n while c <= stop:\\n if c >= start:\\n yield", "gt": "t[-1][0] ## Yield the Bell number of the previous row\\n row = [t[-1][-1]] ## Initialize a new row\\n for b in t[-1]:\\n row.append((row[-1] + b)%1000000007)\\n c += 1 ## We have found another Bell number\\n t.append(row) ## Append the row to the triangle\\n\\nar=[0]*1001\\ni=0\\nfor b in bell_numbers(1,1001):\\n ar[i]=b\\n i+=1\\nT=eval(input())\\nwhile T:\\n N=eval(input())\\n print(ar[N])\\n T-=1\\n"}
{"id": "1358", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n=int(input())\\n lst=list(map(int,input().split()))\\n f=0\\n t=0\\n p=1\\n for i in lst:\\n if(i==5):\\n f+=1\\n", "gt": "elif(i==10):\\n if(f>0):\\n f-=1\\n t+=1\\n else:\\n p=0\\n break\\n else:\\n if(t>0):\\n t-=1\\n else:\\n if(f>1):\\n f-=2\\n else:\\n p=0\\n break\\n if(p==1):\\n print(\"YES\")\\n else:\\n print(\"NO\")"}
{"id": "1359", "input": "# cook your dish here\\nimport bisect\\n\\nfor _ in range(int(input())):\\n w,k=map(str, input().split())\\n k=int(k)\\n n=len(w)\\n w=list(w)\\n w.sort()\\n w.append('0')\\n c=1\\n l=0\\n l1=[]\\n l2=[]\\n for i in range(1, n+1):\\n if w[i]==w[i-1]:\\n c+=1\\n else:\\n a=bisect.bisect_left(l1, c)\\n if a==l:\\n l1.append(c)\\n l2.append(1)\\n l+=1\\n elif", "gt": "l1[a]==c:\\n l2[a]=l2[a]+1\\n else:\\n l1.insert(a, c)\\n l2.insert(a, 1)\\n l+=1\\n c=1\\n a=l1[-1]-l1[0]\\n if a<=k:\\n print(0)\\n else:\\n ans=n \\n for i in range(l):\\n temp=l2[i]*l1[i]\\n for j in range(i+1, l):\\n p=l1[j]-l1[i]\\n if p<=k:\\n temp+=(l2[j]*l1[j])\\n else:\\n p1=p-k\\n temp+=(l2[j]*(l1[j]-p1))\\n ans=min(ans, (n-temp))\\n \\n print(ans)"}
{"id": "1360", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n=int(input())\\n ar=list(map(int,input().split()))\\n odd=0\\n even=0\\n if n==1:\\n print(0)\\n continue\\n for i", "gt": "in range(n):\\n if ar[i]%2==1:\\n odd+=1\\n else:\\n even+=1\\n if odd>0:\\n vo=(odd-1)*2+even\\n else:\\n vo=even\\n if even>0:\\n ve=(even-1)*2+odd\\n else:\\n ve=odd\\n print(min(vo,ve))\\n"}
{"id": "1361", "input": "for _ in range(eval(input())):\\n S1=input()\\n m1=len(S1)/2\\n\\n S2=input()\\n m2=len(S2)/2\\n d1={}\\n d2={}\\n for i in range(len(S1)):\\n c=S1[i]\\n v=abs(m1-i)\\n if c in d1:\\n if v<d1[c][0]:\\n d1[c]=[v,i]\\n else:\\n d1[c]=[v,i]\\n for i in range(len(S2)):\\n", "gt": "c=S2[i]\\n v=abs(m2-i)\\n if c in d2:\\n if v<d2[c][0]:\\n d2[c]=[v,i]\\n else:\\n d2[c]=[v,i]\\n\\n mini=999999999999999999999999999999999\\n for i in d1:\\n if i in d2:\\n L1=d1[i][1]\\n L3=len(S1)-L1-1\\n L2=d2[i][1]\\n L4=len(S2)-L2-1\\n v=abs(L1-L2)+abs(L2-L3)+abs(L3-L4)+abs(L4-L1)\\n if v<mini:\\n mini=v\\n print(mini)"}
{"id": "1362", "input": "# cook your dish here\\nfrom itertools import accumulate\\nn, k = map(int, input().split())\\nlst = list(map(int, input().split()))\\ntemp", "gt": "= (10**9)+7\\nfor i in range(k):\\n lst = list(accumulate(lst))\\nfor i in lst:\\n print(i%(temp), end = ' ')"}
{"id": "1363", "input": "\"\"\"\\n4\\n4\\n4 3 1 2\\n6\\n1 2 2 1 3 1\\n5\\n10 1 2 10 5\\n4\\n1 2 1 2\\n\"\"\"\\ntests = int(input())\\n\\nfor _ in range(tests):\\n\\n n = int(input())\\n ls = list(map(int, input().split()))\\n\\n if ls[0] < ls[1]:\\n ls[0] = -ls[0]\\n\\n if ls[-1] < ls[-2]:\\n ls[-1] = -ls[-1]\\n\\n for i in range(1, n - 1):\\n if ls[i] < ls[i - 1] and ls[i] < ls[i + 1]:\\n ls[i] = -ls[i]\\n '''\\n if i > 1 and ls[i - 2] < 0 and ls[i] - ls[i-2] >= ls[i-1]:\\n # There can be only one!\\n if -ls[i-2] < ls[i]:\\n # We win!\\n ls[i-2] = -ls[i-2]\\n ls[i] = -ls[i]\\n #else:\\n # They win!\\n # Do nothing\\n else:\\n # We both can go negative\\n ls[i] = -ls[i]\\n '''\\n \\n #print(ls)\\n \\n ind = 1\\n\\n while ind < n - 1:\\n\\n started =", "gt": "False\\n pos = []\\n while ind < n - 1 and ls[ind] + ls[ind - 1] + ls[ind + 1] <= 0:\\n if not started:\\n pos.append(ind - 1)\\n pos.append(ind + 1)\\n started = True\\n else:\\n pos.append(ind + 1)\\n ind += 2\\n\\n #print(pos,ls)\\n\\n if started:\\n rec = [0] * (len(pos) + 1)\\n\\n for i in pos:\\n ls[i] = -ls[i]\\n\\n rec[0] = 0\\n rec[1] = ls[pos[0]]\\n\\n for i in range(2, len(pos) + 1):\\n rec[i] = max(rec[i - 1], ls[pos[i - 1]] + rec[i - 2])\\n\\n itr = len(pos)\\n while itr > 0:\\n if itr == 1 or rec[itr] == ls[pos[itr - 1]] + rec[itr - 2]:\\n ls[pos[itr - 1]] = -ls[pos[itr - 1]]\\n itr -= 2\\n else:\\n itr -= 1\\n\\n ind += 1\\n\\n for i in ls:\\n print(i, end = ' ')\\n print() \\n\\n \\n\\n"}
{"id": "1364", "input": "val = 10**9 + 7\\ndef MOD(a,b):\\n aans = a\\n ans = 1\\n while b>0:\\n ans = (ans*aans)%val\\n aans = (aans*aans)%val\\n b/=2\\n return ans%val\\n \\n\\n\\nfor i", "gt": "in range(eval(input())): \\n n,d= list(map(int,input().split()))\\n a=int(str(d)*n)\\n sqr = str(a*a)\\n ans =0\\n count=0\\n for ii in sqr :\\n ans= ans+int(ii)*23**count\\n count+=1\\n z=int(ii)*ans\\n print(ans % (10**9+7))\\n \\n \\n"}
{"id": "1365", "input": "t = int(input())\\n\\nfor i in range(t):\\n n, c = list(map(int,input().split()))\\n\\n pts = {}\\n moves = 0\\n\\n for i in range(n):\\n x, y = list(map(int,input().split()))\\n if (y-x,x%c) in", "gt": "pts:\\n pts[(y-x,x%c)].append(x)\\n else:\\n pts[(y-x,x%c)] = [x]\\n \\n for i in pts:\\n arc = sorted(pts[i])\\n \\n for j in arc:\\n moves = moves + abs((j-arc[len(arc)//2]))//c\\n \\n print(len(pts),moves)\\n\\n\\n \\n\\n\\n"}
{"id": "1366", "input": "tb=str(input())\\ntb=list(tb)\\nif(\"c\" in tb or \"k\" in tb):\\n print(0)\\nelse:\\n ans=1\\n i=0\\n while(i<len(tb)):\\n if(tb[i]==\"g\" or tb[i]==\"f\"):\\n", "gt": "my=tb[i]\\n i+=1\\n ct=1\\n while(i<len(tb) and tb[i]==my):\\n ct+=1\\n i+=1\\n if(ct>3):\\n ct+=1\\n ans*=ct\\n else:\\n i+=1\\n print(ans)"}
{"id": "1367", "input": "# cook your dish here\\nN=int(input())\\nfor _ in range(N):\\n n=int(input())\\n arr=list(map(int,input().split()))[:n]\\n count=0\\n last=0\\n for i in range(n):\\n", "gt": "if(arr[i]!=0):\\n break\\n last=i\\n count+=1\\n for i in arr[-1:last:-1]:\\n if(i!=0):\\n break\\n count+=1\\n ans=n-count\\n if(ans==0):\\n print(1)\\n else:\\n print(ans)\\n"}
{"id": "1368", "input": "from sys import stdin,stdout\\n\\n\\n\\n\\ntotal_cost=0\\ndef find(a):\\n if par[a]==a:\\n return a\\n else:\\n par[a]=find(par[a])\\n return par[a]\\ndef union(a,b,c):\\n a,b=find(a),find(b)\\n nonlocal total_cost\\n total_cost+=(rank[a]*rank[b]*c)\\n if a!=b:\\n if rank[a]>rank[b]:\\n par[b]=a\\n rank[a]+=rank[b]\\n elif", "gt": "rank[b]>rank[a]:\\n par[a]=b\\n rank[b]+=rank[a]\\n else:\\n par[a]=b;\\n rank[b]+=rank[a]\\n\\nn=int(stdin.readline().strip())\\npar=[i for i in range(n)]\\nrank=[1 for i in range(n)]\\nedges=[]\\nfor i in range(n-1):\\n u,v,c=stdin.readline().strip().split(' ')\\n u,v,c=int(u)-1,int(v)-1,int(c)\\n edges.append((c,u,v))\\nedges.sort()\\ntw=0\\nfor i in edges:\\n union(i[1],i[2],i[0])\\n tw+=i[0]\\n\\nstdout.write(str(tw-(total_cost/((n*(n-1))/2))))"}
{"id": "1369", "input": "# cook your dish here\\nfor _", "gt": "in range(int(input())):\\n h,x=map(int,input().split())\\n if(h>=x):\\n print(\"Yes\")\\n else:\\n print(\"No\")"}
{"id": "1370", "input": "from math import sqrt \\n\\ntest = int(input())\\nfor i in range(test):\\n sum = 0\\n max = int(input())\\n if max==1:\\n sum = 0\\n elif max==2:\\n sum += 2\\n else:", "gt": "\\n sum = sum + 2\\n for x in range(3,max+1):\\n half = int(sqrt(x)) + 1\\n if all(x%y!=0 for y in range(2,half)):\\n sum = sum + x\\n print(sum)"}
{"id": "1371", "input": "for _ in range(int(input())):\\n k, n = input().split()\\n\\n", "gt": "while int(n) >= 5:\\n print(len(set(k)) ** 3)\\n break"}
{"id": "1372", "input": "for i in range(int(input())):\\n yy=input()\\n y=[int(e) for e in yy.split()]\\n zz=input()\\n z=[int(e) for", "gt": "e in zz.split()]\\n count=0\\n for i in z:\\n a=i+y[1]\\n if a%7==0:\\n count+=1\\n print(count)"}
{"id": "1373", "input": "# cook your dish here\\ntry:\\n t = int(input())\\n for i in range(t):\\n ar=list(map(int,input().split()))\\n if (ar[0]**2 + ar[1]**2", "gt": "> ar[2]**2 + ar[3]**2):\\n print(\"B IS CLOSER\")\\n else:\\n print(\"A IS CLOSER\")\\n \\n \\n \\nexcept:\\n pass\\n \\n \\n"}
{"id": "1374", "input": "def main():\\n t= int(input())\\n while(t!=0):\\n n,k = list(map(int , input().split()))\\n arr = list(map(int, input().split()))\\n freq = [0]*100001\\n k=k-1\\n st=0\\n end=0\\n currentCount=0\\n previousElement", "gt": "= 0\\n for i in range(n):\\n freq[arr[i]]+=1\\n if(freq[arr[i]]==1):\\n currentCount+=1\\n\\n while(currentCount>k):\\n freq[arr[previousElement]]-=1\\n if(freq[arr[previousElement]]==0):\\n currentCount-=1\\n\\n previousElement+=1\\n\\n if(i-previousElement+1 >= end-st+1):\\n end=i\\n st=previousElement\\n\\n print(end-st+1)\\n t=t-1\\n\\ndef __starting_point():\\n main()\\n\\n\\n\\n\\n\\n__starting_point()"}
{"id": "1375", "input": "t=eval(input())\\nwhile t>0:\\n t=t-1\\n f1,f2,r1,r2,r3,r4=list(map(int,input().split()))\\n p1,p2,p3,p4=list(map(float,input().split()))\\n s1=(1-p1)*(-f1)+(r2-f1)*(1-p2)*p1+p1*p2*(r1-f1)\\n s2=(1-p3)*(-f2)+(r3-f2)*(p3)*(1-p4)+p3*p4*(r3+r4-f2)\\n if", "gt": "s1>s2:\\n print('FIRST')\\n elif s1<s2:\\n print('SECOND')\\n else:\\n print('BOTH')\\n \\n"}
{"id": "1376", "input": "t = int(input())\\nwhile t > 0:\\n\\n s = int(input())\\n\\n while s % 10", "gt": "== 0 : \\n s /= 10\\n\\n print(''.join(reversed(str(s))))\\n\\n t = t - 1"}
{"id": "1377", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n,k=map(int,input().split())\\n c=[int(i) for i in input().split()]\\n i=0\\n m=0\\n if(n==2 and k==5):\\n c1=c\\n c.sort()\\n d=dict()\\n for i in range(len(c)):\\n for j in range(len(c1)):\\n if(c[i]==c1[j]):\\n d[i]=j\\n c1[j]=-1\\n break\\n \\n while(m<n):\\n if (i==n):\\n print(d[n],k,d[n-1],0)\\n c[n]-=k\\n m+=1\\n else:\\n", "gt": "if(c[i]>=k):\\n print(d[i],k,d[i+1],0)\\n c[i]=c[i]-k\\n m+=1\\n elif(c[i]==0):\\n i+=1\\n else:\\n for j in range(i+1,n+1):\\n if(c[i]+c[j]>=k):\\n print(d[i],c[i],d[j],k-c[i])\\n c[j]-=k-c[i]\\n c[i]=0\\n m+=1\\n break\\n \\n else:\\n while(m<n):\\n if (i==n):\\n print(n,k,n-1,0)\\n c[n]-=k\\n m+=1\\n else:\\n if(c[i]>=k):\\n print(i,k,i+1,0)\\n c[i]=c[i]-k\\n m+=1\\n elif(c[i]==0):\\n i+=1\\n else:\\n for j in range(i+1,n+1):\\n if(c[i]+c[j]>=k):\\n print(i,c[i],j,k-c[i])\\n c[j]-=k-c[i]\\n c[i]=0\\n m+=1\\n break"}
{"id": "1378", "input": "# cook your dish here\\nfor _ in range (int(input())):\\n x1,y1,x2,y2=map(int,input().split())\\n av1=(x1+y1)/2\\n", "gt": "av2=(x2+y2)/2\\n if(av1>av2):\\n print(av1-av2,\" DEGREE(S) ABOVE NORMAL\")\\n else:\\n print(av2-av1,\" DEGREE(S) BELOW NORMAL\")"}
{"id": "1379", "input": "a,n,k = map(int,input().split())\\nfor i", "gt": "in range(k):\\n print(a%(n+1),end=' ')\\n a=a//(n+1)"}
{"id": "1380", "input": "import sys,math\\n\\ndef main(filename):\\n inputfile = open(filename,'rU')\\n data = inputfile.readlines()\\n T=data.pop(0)\\n ans=[]\\n ansstring=str()\\n explored=[]\\n for i in T:\\n if i in explored:\\n #print explored\\n for", "gt": "j in range(len(ans)):\\n if ans[j][0]==i:\\n ans[j][1] += 1\\n else:\\n ans.append([i,1])\\n explored.append(i)\\n for i in ans:\\n ansstring += i[0]+str(i[1])\\n print(ansstring) \\n \\n\\n\\n inputfile.close()\\n\\ndef __starting_point():\\n main(sys.argv[1])\\n__starting_point()"}
{"id": "1381", "input": "# cook your dish here\\nT = int(input())\\n\\nfor", "gt": "t in range(T):\\n N = int(input())\\n \\n print(int(((N-1)*(N))/2))"}
{"id": "1382", "input": "# cook your dish here\\nt = int(input())\\nfor _ in range(t):\\n n, k, d = list(map(int, input().split()))\\n x = list(map(int, input().split()))\\n l = list(map(int, input().split()))\\n lane = 3 - l[0]\\n switched = -float('inf')\\n ans = k\\n for i in range(n):\\n", "gt": "if l[i] == lane:\\n if switched + d < x[i] and x[i - 1] + 1 < x[i]:\\n lane = 3 - lane\\n switched = max(x[i - 1] + 1, switched + d)\\n else:\\n ans = x[i]\\n break\\n print(ans)\\n"}
{"id": "1383", "input": "n=int(input())\\na=list(map(int,input().split()))\\nx=int(input())\\nl=[]\\nfor i in a:\\n if i<0:\\n l.append(-i)\\nl.sort()\\nm=len(l)\\nans=0\\nif", "gt": "l:\\n if x>n:\\n ans=sum(l)\\n else:\\n ans=sum(l[m-x:])\\nprint(ans)\\n\\n \\n"}
{"id": "1384", "input": "T = int(input())\\r\\nfor _ in range(T):\\r\\n N, K1, K2 = list(map(int, input().split()))\\r\\n P1, P2, P3, P4 = list(map(int, input().split()))\\r\\n ans = 0\\r\\n arr = [0] * (1005)\\r\\n\\r\\n length = len(arr)\\r\\n for i in", "gt": "range(1,N+1):\\r\\n\\r\\n j = 0\\r\\n while j < length:\\r\\n arr[j] += 1\\r\\n j += i\\r\\n\\r\\n for i in range(K1,K2+1):\\r\\n if arr[i]==3:\\r\\n ans += P1\\r\\n elif arr[i]%2==1:\\r\\n ans += P2\\r\\n else:\\r\\n ans += P3\\r\\n\\r\\n print(ans)\\r\\n"}
{"id": "1385", "input": "for _ in range(int(input())):\\n\\n n, k = map(int, input().split())\\n l = [*map(int, input())]\\n\\n count = [0] * (n + 1)\\n\\n for i in range(n - 1, -1, -1):\\n if l[i] == 1:\\n count[i] = count[i + 1] + 1\\n\\n x,y =", "gt": "0,0\\n for i in range(n):\\n if l[i] == 1:\\n x += 1\\n else:\\n try:\\n y = max(y, x + k + count[i + k])\\n\\n except:\\n y = max(y, x + min(k, n - i))\\n x = 0\\n y = max(y,x)\\n print(y)"}
{"id": "1386", "input": "def __starting_point():\\n t=int(input())\\n for _ in range(t):\\n n,p=input().split()\\n n,p=int(n),int(p)\\n s=input()\\n a,b=0,0\\n arr=[0]*n\\n for i in range(n):\\n arr[i]=s[i]\\n for c in s:\\n if c=='a':\\n a+=1\\n else:\\n b+=1\\n swap=0\\n for i in range(a):\\n if s[i]=='b':\\n swap+=1\\n tmpp=p\\n if p<=swap:\\n for i in range(n):\\n if p==0:\\n break\\n if arr[i]=='b':\\n arr[i]='a'\\n p-=1\\n p=tmpp\\n for", "gt": "i in range(n-1,-1,-1):\\n if p==0:\\n break\\n if arr[i]=='a':\\n arr[i]='b'\\n p-=1\\n for c in arr:\\n print(c,end=\"\")\\n print()\\n else:\\n for i in range(n):\\n if i<a:\\n arr[i]='a'\\n else:\\n arr[i]='b'\\n p-=swap\\n for i in range(n):\\n if arr[i]=='b':\\n if s[i]=='b' and p>=2:\\n p-=2\\n arr[i]='a'\\n if s[i]=='a' and p>=1:\\n p-=1\\n arr[i]='a'\\n for c in arr:\\n print(c,end=\"\")\\n print()\\n__starting_point()"}
{"id": "1387", "input": "from math import factorial\\n\\nfor _ in", "gt": "range(int(input())):\\n N,M=[int(a) for a in input().split()]\\n print(float(N+M-1))"}
{"id": "1388", "input": "# cook your dish here\\nimport sys\\n\\nmod_val = 1000000007\\nrang = [0]*101\\npow_cache = [0]*102\\nmultisets = {}\\n\\n\\ndef mod_pow(base, pow):\\n result = 1\\n while pow:\\n if pow&1:\\n result = (result*base) % mod_val\\n base = (base*base) % mod_val\\n pow = pow>>1\\n return result\\n\\n\\ndef precalculate():\\n\\n for i in range(1, 102):\\n pow_cache[i] = mod_pow(i, mod_val-2)\\n\\n\\ndef cal_recurse(i, target_sum):\\n if target_sum == 0:\\n return 1\\n if i>=target_sum:\\n return 0\\n if (i, target_sum) in multisets:\\n return multisets[(i, target_sum)]\\n ans = cal_recurse(i+1, target_sum)\\n max_pos = target_sum//(i+1)\\n choose = rang[i+1]%mod_val\\n for j", "gt": "in range(1, max_pos+1):\\n temp = choose*cal_recurse(i+1, target_sum-j*(i+1))\\n # temp%=mod_val\\n ans += temp\\n ans %= mod_val\\n choose *= rang[i+1]+j\\n # choose %= mod_val\\n choose *= pow_cache[j+1]\\n choose %= mod_val\\n multisets[i, target_sum] = ans\\n return ans\\n\\n\\ndef calculate(target_sum, rang_index):\\n populate(target_sum, rang_index)\\n return cal_recurse(0, target_sum)\\n\\n\\ndef populate(target_sum, rang_i):\\n for i in range(1, target_sum+1):\\n rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3]*i)*i)*i\\n\\n\\n_test_cases = int(input())\\nprecalculate()\\nfor _a_case in range(_test_cases):\\n rang = [0]*101\\n multisets ="}
{"id": "1389", "input": "arr = [0]*6\\n\\narr[1] = 250000*(0.05)\\narr[2] = 250000*(0.10)\\narr[3] = 250000*(0.15)\\narr[4] = 250000*(0.20)\\narr[5] = 250000*(0.25)\\n\\nfor _ in range(int(input())):\\n n = int(input())\\n\\n tax = 0\\n\\n if n<=250000:\\n tax = 0\\n\\n elif 250000<n<=500000:\\n tax = sum(arr[:1])\\n\\n rem = n - 250000\\n\\n tax+= (rem)*(0.05)\\n\\n elif 500000<n<=750000:\\n tax = sum(arr[:2])\\n\\n rem = n - 500000\\n\\n tax+= (rem)*(0.10)\\n\\n elif 750000<n<=1000000:\\n tax =", "gt": "sum(arr[:3])\\n\\n rem = n - 750000\\n\\n tax+= (rem)*(0.15)\\n\\n elif 1000000<n<=1250000:\\n tax = sum(arr[:4])\\n\\n rem = n - 1000000\\n\\n tax+= (rem)*(0.20)\\n \\n elif 1250000<n<=1500000:\\n tax = sum(arr[:5])\\n\\n rem = n - 1250000\\n\\n tax+= (rem)*(0.25)\\n \\n elif n>1500000:\\n tax = sum(arr[:6])\\n\\n rem = n - 1500000\\n\\n tax+= (rem)*(0.30)\\n \\n res = int(n - tax)\\n \\n print(res)\\n\\n\\n\\n \\n\\n\\n \\n\\n"}
{"id": "1390", "input": "N = int(input())\\nl = []\\nfor i in range(N):\\n l.append(input())\\nfor j in range(N-1,-1,-1):\\n s = '` '+ l[j]\\n n = len(s)-1\\n y = s[n]\\n f = ''\\n while y != '`':\\n w = ''\\n while y != ' ':\\n if", "gt": "ord(y) in range(97,123) or ord(y) in range(65,91):\\n w += y\\n n -= 1\\n y = s[n]\\n wf = ''\\n n -= 1\\n y = s[n]\\n x = len(w)\\n for k in range(x):\\n wf += w[x-k-1]\\n f += wf+' '\\n print(f)"}
{"id": "1391", "input": "# cook your dish here\\nfor", "gt": "h in range(int(input())):\\n n,q=map(int,input().split())\\n print(q*(n+q+1)/(q+1))"}
{"id": "1392", "input": "try:\\n for _ in range(int(input())):\\n N, K = map(int, input().split())\\n cell = []\\n count = 0\\n l = []\\n for __ in range(N):\\n inserted = list(map(int, input().split()))\\n cell.append(inserted)\\n\\n\\n\\n \\n\\n\\n\\n\\n cell.sort(key=lambda x:", "gt": "x[1])\\n time ="}
{"id": "1393", "input": "<s> ", "gt": "a,b=map(int,input().split())\\r\\nprint(a+b)"}
{"id": "1394", "input": "for _ in range(int(input())):\\n n = int(input())\\n l = list(map(int,input().split()))\\n ans = 1\\n l1 = l[0]\\n", "gt": "for i in range(1,n):\\n if l[i] <= l1:\\n l1 = l[i]\\n ans = ans + 1\\n print(ans)"}
{"id": "1395", "input": "from math import *\\ndef list_input():\\n return list(map(int,input().split()))\\ndef map_input():\\n return list(map(int,input().split()))\\ndef map_string():\\n return input().split()\\ndef g(n):\\n return (n*(n+1)*(2*n+1))//6\\ndef", "gt": "f(n):\\n ans = 0\\n for i in range(1,floor(sqrt(n))+1):\\n ans+=i*(i+floor(n/i))*(floor(n/i)+1-i)\\n return ans-g(floor(sqrt(n)))\\nfor _ in range(int(input())):\\n n=int(input())\\n print(f(n)%1000000007)\\n\\n"}
{"id": "1396", "input": "# cook your dish here\\nfor test in range(0,int(input())):\\n A,B = map(int,input().split())\\n diff = abs(A-B)\\n count=0\\n if", "gt": "not(A^B):\\n print(-1)\\n else:\\n for i in range(1,int(diff**(1/2))+1):\\n if diff%i==0:\\n if diff/i==i:\\n count+=1 \\n else:\\n count+=2\\n print(count)"}
{"id": "1397", "input": "t = input()\\nt = int(t)\\n\\nfor _ in range(t):\\n n, m, x, y = input().split()\\n n = int(n)\\n m = int(m)\\n x = int(x)\\n y = int(y)\\n n -= 1\\n m -= 1\\n flag = 0\\n if n % x == 0 and m", "gt": "% y == 0:\\n flag = 1\\n n -= 1\\n m -= 1\\n if n >= 0 and m >= 0:\\n if n % x == 0 and m % y == 0:\\n flag = 1\\n \\n if flag == 1:\\n print(\"Chefirnemo\")\\n else:\\n print(\"Pofik\")"}
{"id": "1398", "input": "def mForMaxSeq(arr, n):\\r\\n eim = dict()\\r\\n for i in range(n):\\r\\n if arr[i] in eim:\\r\\n eim[arr[i]].append(i)\\r\\n else:\\r\\n eim[arr[i]] = [i]\\r\\n \\r\\n keys = sorted(eim.keys())\\r\\n \\r\\n # print(eim, keys)\\r\\n\\r\\n connected = False\\r\\n count = 0\\r\\n pI = -1\\r\\n\\r\\n nKeys = len(keys)\\r\\n for i in range(nKeys-1):\\r\\n \\r\\n if not connected:\\r\\n pI = eim[keys[i]][0]\\r\\n \\r\\n for idx in eim[keys[i+1]]:\\r\\n if", "gt": "idx >pI:\\r\\n connected = True\\r\\n count += 1\\r\\n pI = idx\\r\\n break\\r\\n else:\\r\\n connected = False\\r\\n\\r\\n for idx in eim[keys[i+1]]:\\r\\n if idx > pI:\\r\\n connected = True\\r\\n count += 1\\r\\n pI = idx\\r\\n break\\r\\n\\r\\n \\r\\n return (nKeys - count)\\r\\n\\r\\n\\r\\ndef __starting_point():\\r\\n for _ in range(int(input())):\\r\\n n = int(input())\\r\\n arr = list(map(int, input().split()))\\r\\n \\r\\n print(mForMaxSeq(arr, n))\\r\\n \\r\\n \\r\\n\\n__starting_point()"}
{"id": "1399", "input": "def solve(S):\\n a = set(S)\\n return len(a)\\n \\n \\nt", "gt": "= int(input())\\n\\nfor _ in range(t):\\n s = input()\\n print(solve(s))"}
{"id": "1400", "input": "import numpy as np\\r\\n\\r\\ndef solve(n,k,a,l,r):\\r\\n shape = (n,n)\\r\\n mat = np.zeros(shape, dtype=np.int64)\\r\\n for i in range(n):\\r\\n for j in range(l[i], r[i]):\\r\\n mat[i][j]=1\\r\\n \\r\\n ans = np.eye(n,n, dtype=np.int64)\\r\\n while(k>0):\\r\\n if k%2 == 1:\\r\\n ans = np.matmul(mat, ans)\\r\\n ans%=2\\r\\n mat = np.matmul(mat, mat)\\r\\n mat%=2\\r\\n k = k//2\\r\\n result = []\\r\\n for i in range(n):\\r\\n aux = 0\\r\\n for j in range(n):\\r\\n if ans[i][j] ==", "gt": "1:\\r\\n aux^=a[j]\\r\\n result.append(aux)\\r\\n return result\\r\\n \\r\\n\\r\\n\\r\\n\\r\\n\\r\\nt = int(input())\\r\\nfor i in range(t):\\r\\n s = input().split()\\r\\n n = int(s[0])\\r\\n k = int(s[1])\\r\\n a = []\\r\\n l = []\\r\\n r = []\\r\\n s = input().split()\\r\\n for i in range(n):\\r\\n a.append(int(s[i]))\\r\\n for i in range(n):\\r\\n s = input().split()\\r\\n l.append(int(s[0])-1)\\r\\n r.append(int(s[1]))\\r\\n arr = solve(n,k-1,a,l,r)\\r\\n s = \"\"\\r\\n for e in arr:\\r\\n s += str(e)\\r\\n s +=\" \"\\r\\n print(s)\\r\\n"}
{"id": "1401", "input": "# cook your dish here\\nfor", "gt": "_ in range(int(input())):\\n n,l,h=list(map(int,input().split()))\\n print(n-l+1+2**(l)-2,1+2**(h)-2+2**(h-1)*(n-h))\\n"}
{"id": "1402", "input": "n,k = map(int,input().split())\\nprices = list(map(int,input().split()))\\nprices.sort()\\nsum,cnt = 0, 0\\nfor price in prices:\\n", "gt": "sum += price\\n if sum <= k: cnt += 1\\n else: break\\nprint(cnt)"}
{"id": "1403", "input": "def add(A, B):\\n cnt = 0\\n while B > 0:\\n U = A ^ B\\n B = (A", "gt": "& B) * 2\\n A = U\\n cnt += 1\\n return cnt\\n\\nfor _ in range(int(input())):\\n print(add(int(input(),2), int(input(), 2)))"}
{"id": "1404", "input": "# cook your dish here\\n# cook your dish here\\ndef numDec(s):\\n if not s:\\n return 0\\n\\n dp = [0 for _ in range(len(s) + 1)]\\n\\n dp[0] = 1\\n dp[1] = 0 if s[0] == '0' else 1\\n\\n\\n", "gt": "for i in range(2, len(dp)):\\n\\n if s[i-1] != '0':\\n dp[i] += dp[i-1]\\n\\n two_digit = int(s[i-2 : i])\\n if two_digit >= 10 and two_digit <= 26:\\n dp[i] += dp[i-2]\\n return dp[len(s)]\\n\\nt = int(input())\\n\\nwhile(t):\\n t-=1\\n s = input()\\n print(numDec(s)%1000000007)"}
{"id": "1405", "input": "import sys\\ntest_cases = int(input())\\nfor i in range(0,test_cases):\\n count = input().split()\\n #print count\\n count_r = int(count[0])\\n count_g = int(count[1])\\n count_b = int(count[2])\\n k = int(input())\\n if k is 1:\\n total = 1\\n else: \\n total = 1\\n if count_r < k:\\n total =", "gt": "total + count_r\\n else:\\n total = total + (k-1)\\n if count_g < k:\\n total = total + count_g\\n else:\\n total = total + (k-1) \\n if count_b < k:\\n total = total + count_b\\n else:\\n total = total + (k-1)\\n \\n print(total)"}
{"id": "1406", "input": "from bisect import bisect\\nn = 32000\\ndef primeSeive(n):\\n prime = [True for i in range(n + 1)]\\n primes = []\\n p = 2\\n while (p * p <= n):\\n if (prime[p] == True):\\n for i in range(p * 2, n +", "gt": "1, p):\\n prime[i] = False\\n p += 1\\n prime[0] = False\\n prime[1] = False\\n for p in range(n + 1):\\n if prime[p]:\\n primes.append(p)\\n return primes\\narr = primeSeive(n)\\nfin = []\\nfor i in arr:\\n fin.append(pow(i,4))\\nfor _ in range(int(input())):\\n n = int(input())\\n print(bisect(fin,n))\\n"}
{"id": "1407", "input": "# cook your dish here\\nfrom sys import stdin, stdout\\n\\nfor _ in range(int(stdin.readline())):\\n n, q = list(map(int, stdin.readline().split()))\\n arr = list(map(int, stdin.readline().split()))[:n]\\n od = ev = 0\\n for i in arr:\\n if bin(i).count('1')%2==0:\\n", "gt": "ev += 1\\n else:\\n od += 1\\n for _ in range(q):\\n p = int(stdin.readline())\\n if bin(p).count('1')%2==0:\\n stdout.write(str(ev) + \" \" + str(od) + \"\\n\")\\n else:\\n stdout.write(str(od) + \" \" + str(ev) + \"\\n\")\\n\\n"}
{"id": "1408", "input": "# cook your dish here\\nt = int(input())\\nfor _ in range(t):\\n m,n = [int(d) for d in input().split()]\\n\\n if m == 1:\\n arr = []\\n if n%4 == 0:\\n print(2)\\n arr = [[1,1,2,2]*(n//4)]\\n elif n%4 == 1:\\n if n == 1:\\n print(1)\\n arr = [[1]]\\n else:\\n print(2)\\n arr = [[1,1,2,2]*(n//4) + [1]]\\n elif n%4 == 2:\\n if n == 2:\\n print(1)\\n arr = [[1,1]]\\n else:\\n print(2)\\n arr = [[1,1,2,2]*(n//4) + [1,1]]\\n elif n%4 == 3:\\n print(2)\\n arr = [[1,1,2,2]*(n//4) + [1,1,2]]\\n\\n elif m == 2:\\n if n%3 == 0:\\n print(3)\\n a1 = [1,2,3]*(n//3)\\n arr = [a1,a1]\\n\\n elif n%3 == 1:\\n if n == 1:\\n print(1)\\n arr = [[1],[1]]\\n else:\\n print(3)\\n a1 = [1,2,3]*(n//3) + [1]\\n arr = [a1,a1]\\n\\n elif n%3 == 2:\\n if n == 2:\\n print(2)\\n arr = [[1,2],[1,2]]\\n else:\\n print(3)\\n a1 = [1,2,3]*(n//3) + [1,2]\\n arr = [a1,a1]\\n\\n elif m == 3:\\n if n == 1:\\n print(2)\\n arr = [[1],[1],[2]]\\n elif n == 2:\\n print(3)\\n arr = [[1,1],[2,2],[3,3]]\\n elif n == 3:\\n print(4)\\n arr = [[1,3,4],[4,2,1],[4,2,1]]\\n elif n == 4:\\n print(4)\\n arr = [[1,3,4,2],[4,2,1,3],[4,2,1,3]]\\n else:\\n if n%4 == 0:\\n print(4)\\n a1 = [1,3,4,2]*(n//4)\\n a2 = [4,2,1,3]*(n//4)\\n arr = [a1,a2,a2]\\n \\n elif n%4 == 1:\\n print(4)\\n a1 = [1,3,4,2]*(n//4) + [1]\\n a2 = [4,2,1,3]*(n//4) + [4]\\n arr = [a1,a2,a2]\\n\\n elif n%4 == 2:\\n print(4)\\n a1 = [1,3,4,2]*(n//4) + [1,3]\\n a2 = [4,2,1,3]*(n//4) + [4,2]\\n arr = [a1,a2,a2]\\n\\n elif n%4 == 3:\\n print(4)\\n a1 = [1,3,4,2]*(n//4) + [1,3,4]\\n a2 = [4,2,1,3]*(n//4) + [4,2,1]\\n arr = [a1,a2,a2]\\n\\n else:\\n if n == 1:\\n print(2)\\n a1 = [1,3,4,2]*(n//4) + [1]\\n a2 = [4,2,1,3]*(n//4) + [2]\\n arr = []\\n i = 0\\n j = 0\\n c = 0\\n c1 = 0\\n for i in range(m):\\n if j == 0 and c < 3:\\n arr.append(a1)\\n c = c + 1\\n if c == 2:\\n j = 1\\n c = 0\\n else:\\n arr.append(a2)\\n c1 = c1 + 1\\n if c1 == 2:\\n j = 0\\n c1 = 0\\n \\n elif n == 2:\\n print(3)\\n arr = []\\n a1 = [1,1]\\n a2 = [2,2]\\n", "gt": "a3 = [3,3]\\n\\n if m%3 == 1:\\n arr = [a1,a2,a3]*(m//3) + [a1]\\n elif m%3 == 2:\\n arr = [a1,a2,a3]*(m//3) + [a1,a2]\\n elif m%3 == 0:\\n arr = [a1,a2,a3]*(m//3)\\n\\n else:\\n print(4)\\n if n%4 == 0:\\n a1 = [1,3,4,2]*(n//4)\\n a2 = [4,2,1,3]*(n//4)\\n arr = []\\n i = 0\\n j = 0\\n c = 0\\n c1 = 0\\n for i in range(m):\\n if j == 0 and c < 3:\\n arr.append(a1)\\n c = c + 1\\n if c == 2:\\n j = 1\\n c = 0\\n else:\\n arr.append(a2)\\n c1 = c1 + 1\\n if c1 == 2:\\n j = 0\\n c1 = 0\\n\\n elif n%4 == 1:\\n a1 = [1,3,4,2]*(n//4) + [1]\\n a2 = [4,2,1,3]*(n//4) + [4]\\n arr = []\\n i = 0\\n j = 0\\n c = 0\\n c1 = 0\\n for i in range(m):\\n if j == 0 and c < 3:\\n arr.append(a1)\\n c = c + 1\\n if c == 2:\\n j = 1\\n c = 0\\n else:\\n arr.append(a2)\\n c1 = c1 + 1\\n if c1 == 2:\\n j = 0\\n c1 = 0\\n\\n elif n%4 == 2:\\n\\n a1 = [1,3,4,2]*(n//4) + [1,3]\\n a2 = [4,2,1,3]*(n//4) + [4,2]\\n arr = []\\n i = 0\\n j = 0\\n c = 0\\n c1 = 0\\n for i in range(m):\\n if j == 0 and c < 3:\\n arr.append(a1)\\n c = c + 1\\n if c == 2:\\n j = 1\\n c = 0\\n else:\\n arr.append(a2)\\n c1 = c1 + 1\\n if c1 == 2:\\n j = 0\\n c1 = 0\\n\\n elif n%4 == 3:\\n\\n a1 = [1,3,4,2]*(n//4) + [1,3,4]\\n a2 = [4,2,1,3]*(n//4) + [4,2,1]\\n arr = []\\n i = 0\\n j = 0\\n c = 0\\n c1 = 0\\n for i in range(m):\\n if j == 0 and c < 3:\\n arr.append(a1)\\n c = c + 1\\n if c == 2:\\n j = 1\\n c = 0\\n else:\\n arr.append(a2)\\n c1 = c1 + 1\\n if c1 == 2:\\n j = 0\\n c1 = 0\\n\\n\\n\\n for i in range(m):\\n for j in range(n):\\n print(arr[i][j],end = \" \")\\n print()\\n\\n\\n\\n\\n \\n \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"}
{"id": "1409", "input": "mod = 10 ** 9 + 7\\nfrom collections import Counter\\nchoice = {'1' : ['11', '21', '22'], '2' : ['11', '12', '21']}\\ndef solve(a,b):\\n n = len(a)\\n if n == 1:\\n return 2\\n dp = Counter([('11', '11')])\\n for i in range(n-1):\\n new = Counter()\\n for x,y in (a[i], b[i]), (b[i], a[i]):\\n for p in choice[x]:\\n for q in choice[y]:\\n", "gt": "m = p[-1] + x \\n n = q[-1] + y\\n new[m,n] += dp[p,q]\\n new[m,n] %= mod\\n dp = new\\n ans = 0 \\n for i in '11', '21', :\\n for j in '11', '21':\\n ans += dp[i,j]\\n return (ans * 2) % mod\\n\\n \\nt = int(input())\\nfor _ in range(t):\\n a = input()\\n b = input()\\n print(solve(a,b))"}
{"id": "1410", "input": "for t in", "gt": "range(int(input())):\\r\\n n=int(input())\\r\\n print(bin(n).count(\"1\"))"}
{"id": "1411", "input": "nCr = [[0 for x in range(1001)] for x in range(1001)]\\n \\nfor i in range (0,1001):\\n nCr[i][0]=1\\n nCr[i][i]=1\\nfor i in range (1,1001):\\n for j in range (1,1001):\\n if i!=j:\\n nCr[i][j] = nCr[i-1][j]", "gt": "+ nCr[i-1][j-1]\\n \\nt=eval(input())\\nfor rajarshisarkar in range(0,t):\\n s,n,m,k=list(map(int,input().split(' ')))\\n foo=0.000000\\n tot = float(nCr[s-1][n-1])\\n if s==n:\\n print(\"1.000000\\n\")\\n continue\\n if k>n:\\n print(\"0.000000\\n\")\\n continue\\n if m>n:\\n wola=n\\n else:\\n wola=m\\n for i in range(k,wola):\\n foo+= ((nCr[m-1][i])*(nCr[s-m][n-i-1]))\\n print(\"%f\\n\"% (float(foo/tot)))"}
{"id": "1412", "input": "# cook your dish here\\nimport math\\ndef swap(a,b):\\n return b,a\\n\\nt = int(input())\\nwhile(t!=0):\\n z = list(map(int,input().strip().split(\" \")))\\n x=z[0]\\n r=z[1]\\n a=z[2]\\n b=z[3]\\n #p = math.pi\\n peri = 2*r\\n", "gt": "tp = x*peri\\n \\n if(a<b):\\n a,b=swap(a,b)\\n t1 = tp/a\\n d2 = t1* b\\n dd = abs(tp-d2)\\n \\n if(dd%peri==0):\\n print(int(dd//peri)-1)\\n else:\\n n = int(dd//peri)\\n print(n)\\n t-=1"}
{"id": "1413", "input": "from decimal import Decimal\\r\\n\\r\\nT = int(input())\\r\\nfor _ in range(T):\\r\\n N = int(input())\\r\\n data = dict() \\r\\n for __ in range(N):\\r\\n ci, pi = input().split() \\r\\n data[ci] = pi\\r\\n S =", "gt": "list(input())\\r\\n for i in range(len(S)):\\r\\n if S[i] in data.keys():\\r\\n S[i] = data[S[i]] \\r\\n ###\\r\\n S = \"\".join(S)\\r\\n if '.' in S:\\r\\n S = S.strip('0').rstrip('.')\\r\\n else:\\r\\n S = S.lstrip('0')\\r\\n print(S or '0')"}
{"id": "1414", "input": "\\r\\ndef issafe(r,c,r1,c1,graph):\\r\\n if (graph[r][c] and graph[r1][c1]):\\r\\n return True\\r\\n return False\\r\\n \\r\\n\\r\\nt=int(input())\\r\\nfor mmmmmm in range(t):\\r\\n n,m=map(int,input().split())\\r\\n x,y=map(int,input().split())\\r\\n \\r\\n graph=[[False]*(m+2) for _ in range(n+2)]\\r\\n\\r\\n cost_graph=[[[-1,-1,-1] for __ in range(m)] for _ in range(n)]\\r\\n \\r\\n for i in range(n):\\r\\n str1=input()\\r\\n for j,val in enumerate(str1):\\r\\n graph[i][j]=(val=='1')\\r\\n \\r\\n x=x-1\\r\\n y=y-1\\r\\n \\r\\n set1=set()\\r\\n set1.add((x,y,0))\\r\\n cost_graph[x][y][0]=0\\r\\n while(set1):\\r\\n \\r\\n set2=set()\\r\\n \\r\\n while(set1):\\r\\n r,c,p=set1.pop()\\r\\n \\r\\n new_cost=cost_graph[r][c][p]+1\\r\\n \\r\\n if(p==0):\\r\\n if issafe(r,c+1,r,c+2,graph):\\r\\n if cost_graph[r][c+1][1]==-1 or cost_graph[r][c+1][1]>new_cost:\\r\\n cost_graph[r][c+1][1]=new_cost\\r\\n set2.add((r,c+1,1))\\r\\n \\r\\n if issafe(r+1,c,r+2,c,graph):\\r\\n if cost_graph[r+1][c][2]==-1 or cost_graph[r+1][c][2]>new_cost:\\r\\n cost_graph[r+1][c][2]=new_cost\\r\\n set2.add((r+1,c,2))\\r\\n \\r\\n if issafe(r,c-2,r,c-1,graph):\\r\\n if cost_graph[r][c-2][1]==-1 or cost_graph[r][c-2][1]>new_cost:\\r\\n cost_graph[r][c-2][1]=new_cost\\r\\n set2.add((r,c-2,1))\\r\\n \\r\\n if issafe(r-2,c,r-1,c,graph):\\r\\n if cost_graph[r-2][c][2]==-1 or cost_graph[r-2][c][2]>new_cost:\\r\\n cost_graph[r-2][c][2]=new_cost\\r\\n set2.add((r-2,c,2))\\r\\n \\r\\n elif(p==1):\\r\\n if", "gt": "issafe(r,c+2,r,c+2,graph):\\r\\n if cost_graph[r][c+2][0]==-1 or cost_graph[r][c+2][0]>new_cost:\\r\\n cost_graph[r][c+2][0]=new_cost\\r\\n set2.add((r,c+2,0))\\r\\n \\r\\n if issafe(r+1,c,r+1,c+1,graph):\\r\\n if cost_graph[r+1][c][1]==-1 or cost_graph[r+1][c][1]>new_cost:\\r\\n cost_graph[r+1][c][1]=new_cost\\r\\n set2.add((r+1,c,1))\\r\\n \\r\\n if issafe(r,c-1,r,c-1,graph):\\r\\n if cost_graph[r][c-1][0]==-1 or cost_graph[r][c-1][0]>new_cost:\\r\\n cost_graph[r][c-1][0]=new_cost\\r\\n set2.add((r,c-1,0))\\r\\n \\r\\n if issafe(r-1,c,r-1,c+1,graph):\\r\\n if cost_graph[r-1][c][1]==-1 or cost_graph[r-1][c][1]>new_cost:\\r\\n cost_graph[r-1][c][1]=new_cost\\r\\n set2.add((r-1,c,1))\\r\\n \\r\\n elif(p==2):\\r\\n if issafe(r,c+1,r+1,c+1,graph):\\r\\n if cost_graph[r][c+1][2]==-1 or cost_graph[r][c+1][2]>new_cost:\\r\\n cost_graph[r][c+1][2]=new_cost\\r\\n set2.add((r,c+1,2))\\r\\n \\r\\n if issafe(r+2,c,r+2,c,graph):\\r\\n if cost_graph[r+2][c][0]==-1 or cost_graph[r+2][c][0]>new_cost:\\r\\n cost_graph[r+2][c][0]=new_cost\\r\\n set2.add((r+2,c,0))\\r\\n \\r\\n if issafe(r,c-1,r+1,c-1,graph):\\r\\n if cost_graph[r][c-1][2]==-1 or cost_graph[r][c-1][2]>new_cost:\\r\\n cost_graph[r][c-1][2]=new_cost\\r\\n set2.add((r,c-1,2))\\r\\n \\r\\n if issafe(r-1,c,r-1,c,graph):\\r\\n if cost_graph[r-1][c][0]==-1 or cost_graph[r-1][c][0]>new_cost:\\r\\n cost_graph[r-1][c][0]=new_cost\\r\\n set2.add((r-1,c,0))\\r\\n set1=set2\\r\\n \\r\\n for _ in range(n):\\r\\n for __ in range(m):\\r\\n print(cost_graph[_][__][0],end=\" \")\\r\\n print()\\r\\n \\r\\n \\r\\n \\r\\n \\r\\n \\r\\n \\r\\n \\r\\n \\r\\n \\r\\n \\r\\n \\r\\n \\r\\n \\r\\n \\r\\n"}
{"id": "1415", "input": "def matrix(L,row,col,c):\\n d={}\\n dp=[]\\n for i in range(row+1):\\n temp=[]\\n for i in range(col+1):\\n temp.append([])\\n dp.append(temp)\\n\\n for i in range(row+1):\\n dp[i][0]=0\\n for i in range(col+1):\\n dp[0][i]=0\\n for i in range(1,row+1):\\n for j in range(1,col+1):\\n if L[i-1][j-1]==c:\\n dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1\\n else:\\n dp[i][j]=0\\n", "gt": "d[dp[i][j]]=d.get(dp[i][j],0)+1\\n## for i in xrange(row+1):\\n## for j in xrange(col+1):\\n## print dp[i][j],\\n## print\\n return d\\n\\nfrom sys import stdin\\nn,m,q=list(map(int,stdin.readline().split()))\\nL=[]\\nfor i in range(n):\\n L.append(stdin.readline().strip())\\nmale=matrix(L,n,m,'M')\\nfemale=matrix(L,n,m,'F')\\nfor i in range(q):\\n query=stdin.readline().split()\\n if query[1]=='F':\\n if female.get(int(query[0]),0)==0:\\n print('no')\\n else:\\n print('yes')\\n else:\\n if male.get(int(query[0]),0)==0:\\n print('no')\\n else:\\n print('yes')\\n"}
{"id": "1416", "input": "for _ in range(int(input())):\\n s=str(input())\\n n=len(s)\\n k=s[::-1]\\n a,b=\"\",\"\"\\n for i in range(n):\\n if s[i]!=k[i]:\\n", "gt": "a+=s[i+1:]\\n b+=k[i+1:]\\n break\\n else:\\n a+=s[i]\\n b+=k[i]\\n #print(a,b)\\n if a==a[::-1] or b==b[::-1]:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n"}
{"id": "1417", "input": "s,n,s1,lis,new1=[],[],[],[],[]\\nimport itertools\\nq = int(input())\\ns.append(input().split(' '))\\ns1 = list([list(map(int,x)) for x in s])\\nsum1 = sum(s1[0])\\nif len(s1[0])%2!=0 :\\n z = (len(s1[0])+1)//2\\n n = list(itertools.combinations(s1[0],z))\\n for j in range(len(n)) :\\n x = sum(n[j])\\n if x==sum1//2 :\\n lis = n[j]\\n break\\n new1 = list(lis)\\n sum2 = sum(new1)\\n for j in range(len(lis)) :\\n y = lis[j]\\n s1[0].remove(y)\\n sum3=sum(s1[0])\\n if sum3>sum2 :\\n print(' '.join(map(str,s1[0])))\\n print(' '.join(map(str,new1)))\\n else", "gt": ":\\n print(' '.join(map(str,new1)))\\n print(' '.join(map(str,s1[0])))\\nelse :\\n z = len(s1[0])//2\\n n = list(itertools.combinations(s1[0],z))\\n for j in range(len(n)) :\\n x = sum(n[j])\\n if x==sum1//2 :\\n lis = n[j]\\n break\\n #print lis,len(lis)\\n new1 = list(lis)\\n sum2 = sum(new1)\\n for j in range(len(lis)) :\\n y = lis[j]\\n s1[0].remove(y)\\n sum3 = sum(s1[0])\\n if sum3>sum2 :\\n print(' '.join(map(str,s1[0])))\\n print(' '.join(map(str,new1)))\\n else :\\n print(' '.join(map(str,new1)))\\n print(' '.join(map(str,s1[0])))"}
{"id": "1418", "input": "for _ in range(int(input())):\\r\\n n = int(input())\\r\\n ar = list(map(int,input().split()))\\r\\n d = {}\\r\\n for ele in ar:\\r\\n if ele in d:\\r\\n d[ele] += 1\\r\\n", "gt": "else:\\r\\n d[ele] = 1\\r\\n m = 99999\\r\\n count = 0\\r\\n for ele in d:\\r\\n count+=1\\r\\n if m>d[ele]:\\r\\n m = d[ele]\\r\\n if count!=8:\\r\\n print(0)\\r\\n else:\\r\\n print(m)\\r\\n"}
{"id": "1419", "input": "# cook your dish here\\n# cook your dish here\\nfor _ in range(int(input())):\\n n=int(input())\\n l=list(map(int,", "gt": "input().split()))\\n l.insert(0, 0)\\n l1=[0]*(n+1)\\n l1[1]=l[1]\\n for i in range(2, n+1):\\n l1[i]=max(l1[i-1]+l[i]*i, l1[i-2]+l[i-1]*i+l[i]*(i-1))\\n \\n print(l1[-1])"}
{"id": "1420", "input": "\\n\\n\\nt = int(input())\\n\\ndef gcd (a, b):\\n if (b == 0): return a\\n return gcd (b, a % b)\\n\\ndp = {}\\n\\ndef solve (p, k, g, s, m, x, y, n):\\n if ((p, k, g) in dp): return dp[(p, k, g)];\\n \\n ans = 0\\n\\n if (p == n): \\n if k >= x and k <= y:\\n ans = g\\n else:\\n ans = 0 \\n else: \\n for i in range (p, n):\\n \\n if (i - p +", "gt": "1 > m): break\\n \\n temp = solve (i + 1, k + 1, gcd(g, int(s[p:i + 1])), s, m, x, y, n)\\n if (temp > ans):\\n ans = temp\\n \\n dp[(p, k, g)] = ans\\n return ans\\n \\n\\nwhile t != 0:\\n dp ="}
{"id": "1421", "input": "# cook your dish here\\n# cook your dish here\\nn=0;m=0;\\nA=[];B=[];\\nanscount=0;k=0;\\n\\ndef generate(n,m,l):\\n nonlocal anscount\\n if(len(l)==n+m):\\n X=l\\n i,j = 0,0\\n C=[0 for t in range(n+m)]\\n while((i+j)<(n+m)):\\n if(X[i+j] == 0):\\n C[i+j] = A[i]\\n i = i+1\\n else:\\n", "gt": "C[i+j] = B[j]\\n j = j+1\\n ans = len(C)\\n for i in range(1,len(C)):\\n if(C[i]==C[i-1]):\\n ans-=1\\n if(ans==k):\\n anscount+=1\\n else:\\n if(l.count(1)<m):\\n generate(n,m,l+[1])\\n if(l.count(0)<n):\\n generate(n,m,l+[0])\\n else:\\n if(l.count(0)<n):\\n generate(n,m,l+[0])\\nfor _ in range(int(input())):\\n anscount=0\\n n,m,k=list(map(int,input().split()))\\n A=list(map(int,input().split()))\\n B=list(map(int,input().split()))\\n generate(n,m,[])\\n print(anscount)\\n"}
{"id": "1422", "input": "def getsum(N):\\n if N==1:\\n return 9\\n if N==2:\\n return 99\\n s = \"\"\\n for i in range(0,N):\\n s = s+'5'\\n s = int(s)\\n if N%2==0:\\n", "gt": "s = s*pow(9,N//2-1)\\n else:\\n s = s*pow(9,N//2)\\n return s%(pow(10,9)+7)\\n\\ndef main():\\n t = int(input())\\n for _ in range(0,t):\\n N = int(input())\\n result = getsum(N)\\n print(result)\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1423", "input": "import sys\\nT = int(sys.stdin.readline().strip())\\nfor t in range(T):\\n sys.stdin.readline().strip()\\n st = '0'+sys.stdin.readline().strip()+'0'\\n res = 0\\n", "gt": "for i in range(1,len(st)-1):\\n if st[i] == st[i-1] == st[i+1] == '0':\\n res+=1\\n print(res)\\n"}
{"id": "1424", "input": "# cook your dish here\\nt=int(input())\\nfor i in range(t):\\n n=int(input())\\n nums=list(map(int,input().split()))\\n", "gt": "k=int(input())\\n an=nums[k-1]\\n cn=0\\n for i in range(n):\\n if(nums[i]<an):\\n cn+=1\\n\\n print(cn+1)\\n"}
{"id": "1425", "input": "# cook your dish here\\nn,a=map(int,input().split())\\nfor i", "gt": "in range(a):\\n if(n%10==0):\\n n=n//10\\n else:\\n n=n-1\\n \\nprint(n)"}
{"id": "1426", "input": "t=int(input())\\ncount=[]\\n\\nfor i in range(t) :\\n s = input()\\n a,b,c,n = s.split()\\n n=int(n)\\n", "gt": "d = int(a+b*n+c,2)\\n count.append(0)\\n while(d>0) :\\n d=(d&(d+1))-1\\n count[i]+=1\\n\\n\\nfor i in range(t) :\\n print(count[i])\\n"}
{"id": "1427", "input": "t=int(input())\\nfor i in range(t):\\n n,m=list(map(int,input().split()))\\n l=[0]+list(map(int,input().split()))\\n s=0\\n c=1\\n m1=[]\\n for i in range(n):\\n d,f,b=list(map(int,input().split()))\\n if(l[d]>0):\\n m1.append(d)\\n s+=f\\n l[d]-=1\\n", "gt": "else:\\n m1.append(0)\\n s+=b\\n for i in range(n):\\n if(m1[i]==0):\\n for j in range(c,m+1):\\n if(l[j]>0):\\n m1[i]=j\\n l[j]-=1\\n c=j\\n break\\n print(s)\\n print(*m1)\\n"}
{"id": "1428", "input": "# cook your dish here\\nfrom sys import stdin,stdout\\na,b=list(map(int,stdin.readline().split()))\\nleft=[]\\ntop=[]\\nfor i in range(a):\\n c,d=list(map(int,stdin.readline().split()))\\n left.append(c)\\n top.append(d)\\nleft.sort()\\ntop.sort()\\nfrom bisect import bisect_right as br\\nfrom bisect import bisect_left as bl\\nrow=0\\ncol=0\\ntotal=0\\ncons_x=0\\ncons_y=0\\nfor i in range(len(left)):\\n", "gt": "cons_x+=(abs(left[i]))\\n cons_y+=(abs(top[i]))\\ntotal=cons_x+cons_y\\ncc=stdin.readline().rstrip()\\nfor i in cc:\\n if i==\"R\":\\n kk=br(left,col)\\n cons_x=(cons_x+kk-(a-kk))\\n col+=1\\n if i==\"L\":\\n kk=bl(left,col)\\n cons_x=(cons_x+(a-kk)-kk)\\n col-=1\\n if i==\"U\":\\n kk=br(top,row)\\n cons_y=(cons_y+kk-(a-kk))\\n row+=1\\n if i==\"D\":\\n kk=bl(top,row)\\n cons_y=(cons_y+(a-kk)-kk)\\n row-=1\\n stdout.write(str(cons_x+cons_y))\\n stdout.write(\"\\n\")\\n \\n\\n"}
{"id": "1429", "input": "# cook your dish here\\nimport heapq as hq\\nfrom math import floor\\nfor _ in range(int(input())):\\n n,a,b,x,y,z=map(int,input().split())\\n arr=[-int(i) for i in input().split()]\\n days=((z-b-1)//y)\\n", "gt": "ans=0\\n hq.heapify(arr)\\n curr=a+days*x\\n while curr<z :\\n u=hq.heappop(arr)\\n u=-u\\n if u==0 :\\n break\\n else:\\n curr+=u\\n ans+=1\\n hq.heappush(arr,-(u//2))\\n if curr>=z:\\n print(ans)\\n else:\\n print(\"RIP\")"}
{"id": "1430", "input": "# cook your dish here\\nt=int(input())\\nwhile(t>0):\\n n=int(input())\\n b=[int(x) for x in input().split()]\\n p=[float(x) for x in input().split()]\\n s=[0]*(10)\\n yet=2\\n mx=0\\n for i in range(n):\\n st=bin(b[i])\\n rng=len(st)-2\\n if(rng+2>yet):\\n for ml in", "gt": "range(rng+2-yet):\\n s.append(0)\\n if(rng>mx):\\n mx=rng\\n for k in range(2,rng+2):\\n if(st[k]=='1'):\\n s[rng-k+1]=(s[rng-k+1]*(1-p[i]))+((1-s[rng-k+1])*(p[i]))\\n # else:\\n # s[k-2]=(s[k-2]*1)\\n # print(s)\\n # print(mx)\\n mult=1\\n ans=0\\n for i in range(0,mx):\\n ans+=mult*s[i]\\n mult=mult*2\\n print(\"%.16f\" % ans)\\n t-=1"}
{"id": "1431", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n,k = [int(v) for v in input().split()]\\n ans", "gt": "= (n//2)*(k+2)\\n if n%2 == 0:\\n ans = ans\\n else:\\n ans += 1 + 2*k\\n \\n print(ans)"}
{"id": "1432", "input": "m=1000000007\\r\\ndef gcd(a, b): \\r\\n if (a == 0): \\r\\n return b \\r\\n return gcd(b % a, a)\\r\\ndef modexp(x, n): \\r\\n if (n == 0) : \\r\\n return 1\\r\\n elif (n % 2 == 0) : \\r\\n return modexp((x * x) % m, n // 2) \\r\\n else : \\r\\n return (x * modexp((x * x)", "gt": "% m, \\r\\n (n - 1) / 2) % m)\\r\\ndef getFractionModulo(a, b): \\r\\n c = gcd(a, b)\\r\\n a = a // c \\r\\n b = b // c \\r\\n d = modexp(b, m - 2) \\r\\n ans = ((a % m) * (d % m)) % m\\r\\n return ans\\r\\nt=int(input())\\r\\nfor i in range(t):\\r\\n n=int(input())\\r\\n n=n-1\\r\\n print(getFractionModulo(n-1,n+1))\\r\\n"}
{"id": "1433", "input": "t = int(input())\\r\\nfor i in range(t):\\r\\n n = int(input())\\r\\n A = []\\r\\n for i in range(0, n):\\r\\n A.append([int(i) for i in input().split()])\\r\\n ones = sum([sum(i) for", "gt": "i in A])\\r\\n compare = n\\r\\n ans = 0\\r\\n for i in range(0, n):\\r\\n if ones <= compare:\\r\\n ans = i\\r\\n break\\r\\n compare += 2*(n-1-i)\\r\\n print(ans)"}
{"id": "1434", "input": "\\nt = int(input())\\n\\nfor i in range(0,t):\\n a = input()\\n b = input()\\n \\n agts=bgts=afour=bfour=aseven=bseven=altf=bltf=afts=bfts=0;\\n \\n for j in a:\\n if j >= '7':\\n if j > '7':\\n agts += 1\\n else:\\n aseven += 1\\n elif j >= '4':\\n if j > '4':\\n afts += 1\\n else:\\n afour += 1\\n else:\\n altf += 1\\n \\n for j in b:\\n if j >= '7':\\n if j > '7':\\n bgts += 1\\n else:\\n bseven += 1\\n elif j >= '4':\\n if j > '4':\\n bfts += 1\\n else:\\n bfour += 1\\n else:\\n bltf += 1\\n \\n nseven = 0\\n nfour = 0\\n \\n if aseven > bfts:\\n aseven -= bfts;\\n nseven += bfts;\\n bfts = 0;\\n else:\\n bfts -= aseven;\\n nseven += aseven;\\n aseven = 0;\\n \\n if bseven > afts:\\n bseven -= afts;\\n nseven += afts;\\n afts = 0;\\n else:\\n afts -= bseven;\\n nseven += bseven;\\n bseven = 0;\\n \\n if aseven >bltf:\\n aseven -= bltf;\\n nseven", "gt": "+= bltf;"}
{"id": "1435", "input": "# cook your dish here\\n# cook your dish here\\nimport numpy as np\\nn, s, q = [int(j) for j in input().split()]\\nedges = [int(j)-1 for j in input().split()]\\ncosts = [int(j) for j in input().split()]\\nspecial = [int(j)-1 for j in input().split()]\\nqueries = [[0] * 3 for _ in range(q)]\\nfor i in range(q):\\n queries[i] = [int(j)-1 for j in input().split()]\\n\\nedge_set = [[] for _ in range(n)]\\nfor i in range(n-1):\\n edge_set[i+1].append(edges[i])\\n edge_set[edges[i]].append(i+1)\\n\\nstored = np.zeros((s,n,1001),dtype=bool)\\nvisited = [[] for _ in range(s)]\\nfor i in range(s):\\n s_vertex", "gt": "= special[i]\\n s_cost = costs[s_vertex]\\n s_visited = visited[i]\\n s_visited.append(s_vertex)\\n s_stored = stored[i]\\n s_stored[s_vertex][0] = True\\n s_stored[s_vertex][s_cost] = True\\n for edge in edge_set[s_vertex]:\\n s_visited.append(edge)\\n s_stored[edge] = np.array(s_stored[s_vertex])\\n for j in range(1,n):\\n vertex = s_visited[j]\\n cost = costs[vertex]\\n s_stored[vertex][cost:1001] = np.logical_or(s_stored[vertex][0:1001-cost],s_stored[vertex][cost:1001])\\n for edge in edge_set[vertex]:\\n if edge not in s_visited:\\n s_visited.append(edge)\\n s_stored[edge] = np.array(s_stored[vertex])\\n\\nfor i in range(q):\\n first, second, max_cost = queries[i]\\n bool_array = np.zeros(max_cost+2,dtype=bool)\\n for j in range(s):\\n bool_array = np.logical_or(bool_array,np.logical_and(stored[j][first][:max_cost+2],stored[j][second][:max_cost+2]))\\n for j in range(max_cost+1,-1,-1):\\n if bool_array[j]:\\n print(2 * j)\\n break"}
{"id": "1436", "input": "import copy\\r\\nn=int(input())\\r\\na=[int(x) for x in input().split()]\\r\\nb=[int(x) for x in input().split()]\\r\\nc=[]\\r\\nd=[]\\r\\nlcs=[]\\r\\ndef lcsfn(a,c,corda,cordb):\\r\\n for i in range(n+1):\\r\\n d.append([0]*(n+1))\\r\\n lcs.append([0]*(n+1))\\r\\n for i in range(1,n+1):\\r\\n for j in range(1,n+1):\\r\\n if a[i-1]==c[j-1]:\\r\\n lcs[i][j]=lcs[i-1][j-1]+1\\r\\n d[i][j]='d'\\r\\n elif lcs[i-1][j]>lcs[i][j-1]:\\r\\n lcs[i][j]=lcs[i-1][j]\\r\\n d[i][j]='u'\\r\\n else:\\r\\n lcs[i][j]=lcs[i][j-1]\\r\\n d[i][j]='l'\\r\\n i=n\\r\\n j=n\\r\\n", "gt": "cost=0\\r\\n while i>=1 and j>=1:\\r\\n if d[i][j]=='d':\\r\\n corda.append(a[i-1])\\r\\n cordb.append(b[j-1])\\r\\n i-=1\\r\\n j-=1\\r\\n cost+=1\\r\\n elif d[i][j]=='l':\\r\\n j-=1\\r\\n elif d[i][j]=='u':\\r\\n i-=1\\r\\n return cost\\r\\n\\r\\n\\r\\nma=-10**9\\r\\np1=[]\\r\\np2=[]\\r\\nfor i in range(-1000,1001):\\r\\n c=[]\\r\\n corda=[]\\r\\n cordb=[]\\r\\n for j in range(n):\\r\\n c.append(b[j]+i)\\r\\n p=lcsfn(a,c,corda,cordb)\\r\\n if ma<p:\\r\\n ma=p\\r\\n p1=copy.deepcopy(corda)\\r\\n p1=p1[::-1]\\r\\n p2=copy.deepcopy(cordb)\\r\\n p2=p2[::-1]\\r\\nprint(ma)\\r\\nprint(*p1)\\r\\nprint(*p2)\\r\\n\\r\\n"}
{"id": "1437", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n", "gt": "g=input()\\n h=g[::-1]\\n if h==g :\\n print(1)\\n else:\\n print(2)\\n"}
{"id": "1438", "input": "import math\\ndef findnumber(l,n):\\n l.sort()\\n x = l[0] * l[-1]\\n vec = []\\n i = 2\\n while (i*i)<=x:\\n if x%i==0:\\n vec.append(i)\\n if x//i !=i:\\n vec.append(x//i)\\n i = i + 1\\n vec.sort() \\n if len(vec)!=n:\\n return -1\\n else:\\n", "gt": "j = 0\\n for it in range(n):\\n if(l[j] != vec[it]):\\n return -1\\n else:\\n j += 1\\n return x\\ndef __starting_point():\\n t = int(input())\\n while t:\\n n = int(input())\\n arr = list(map(int,input().split()))\\n n = len(arr)\\n print(findnumber(arr,n))\\n print()\\n t=t-1\\n__starting_point()"}
{"id": "1439", "input": "# cook your dish here\\ndef prime_factors(n):\\n i = 2\\n factors =set()\\n while i * i <= n:\\n if n % i:\\n i += 1\\n else:\\n n //= i\\n factors.add(i)\\n if n >", "gt": "1:\\n factors.add(n)\\n return factors\\nfor _ in range(int(input())):\\n n=int(input())\\n a=list(map(int,input().split()))\\n ans=0\\n s=[]\\n for i in range(n):\\n s.append(sum(prime_factors(a[i])))\\n for i in range(n):\\n for j in range(n):\\n if i!=j and a[j]%a[i]==0 and s[j]%s[i]==0:\\n ans=ans+1\\n print(ans)"}
{"id": "1440", "input": "import math\\n\\ndp = []\\ndp.append(0)\\nfor i in range(1,1000005):\\n dp.append(math.log(i) + dp[i-1])\\n\\nt = int(input())\\nfor i in range(t):\\n n,m,p,k = input().split()\\n n = int(n)\\n m = int(m)\\n p = int(p)\\n k = int(k)\\n\\n if p==0 or (n%2==0 and m%2==0):\\n ans", "gt": "= 1.0\\n print(ans)\\n elif n%2==1 and m%2==1:\\n ans=0.0\\n print(ans*100)\\n else:\\n P = 0\\n kln2 = k*math.log(2)\\n for i in range(p, k+1):\\n lnPi = dp[k] - dp[i] - dp[k-i] - kln2\\n Pi = pow(math.e, lnPi)\\n P += Pi\\n print(P)\\n\\n"}
{"id": "1441", "input": "# cook your dish here\\nt=int(input())\\nfor", "gt": "i in range(t):\\n n=int(input())\\n a=list(map(int,input().split()))\\n print(min(a))"}
{"id": "1442", "input": "for _ in range(int(input())):\\n n, k = map(int, input().split())\\n a = list(map(int, input().split()))\\n b = list(map(int, input().split()))\\n\\n a = [-1] + a[::-1]\\n mx = a.index(max(a))\\n dp = [0] * (n + 1)\\n for i in range(1,", "gt": "n + 1):\\n for x in b:\\n if i - x < 0: continue\\n if i - x < mx <= i:\\n dp[i] = 1\\n else:\\n dp[i] |= not dp[i - x]\\n\\n print('Chef' if dp[-1] else 'Garry')"}
{"id": "1443", "input": "# cook your dish here\\nfor", "gt": "_ in range(int(input())):\\n a=int(input())\\n print(a/2+2)"}
{"id": "1444", "input": "for i in range(int(input())):\\n n,k=map(int,input().split())\\n m=[]\\n for j in range(n):\\n l=list(input())\\n m.append(l)\\n a=0\\n for", "gt": "k in range(k):\\n b=0\\n for p in range(n):\\n if m[p][k]=='1':\\n b+=1\\n if b>1:\\n a+=((b*(b-1))//2)\\n print(a)"}
{"id": "1445", "input": "for _ in range(int(input())):\\r\\n num=int(input())\\r\\n arr=list(map(int,input().split()))\\r\\n dp=[0]*num\\r\\n dp[0]=1\\r\\n ans=1\\r\\n j=0\\r\\n for i in range(1,num):\\r\\n j=i+1\\r\\n count=1\\r\\n dp[i]=dp[i-1]%1000000007\\r\\n if i-2>=0 and arr[i-2]==2:\\r\\n dp[i]+=dp[i-2]%1000000007\\r\\n if i-3>=0 and arr[i-3]==2:\\r\\n dp[i]+=dp[i-3]\\r\\n ans+=dp[i]%1000000007\\r\\n if arr[i-1]==2 and i<num-1:\\r\\n", "gt": "if i>=j or j==0:\\r\\n j=i+1\\r\\n while j<num and arr[j]==2:\\r\\n j+=1\\r\\n count=j-i\\r\\n while j<len(arr) and arr[j]==2:\\r\\n j+=1\\r\\n count+=1\\r\\n if j==num:\\r\\n ans+=dp[i-1]*(count-1)%1000000007\\r\\n elif count%2!=0:\\r\\n if j<num-1 and arr[j+1]==2:\\r\\n ans+=dp[i-1]*(count+1)%1000000007\\r\\n else:\\r\\n ans+=dp[i-1]*(count)%1000000007\\r\\n elif count%2==0:\\r\\n ans+=dp[i-1]*(count-1)%1000000007\\r\\n print(ans%1000000007)\\r\\n\\r\\n\\r\\n"}
{"id": "1446", "input": "t= int(input())\\nfor _ in range(t):\\n n = int(input())\\n ar = []\\n y = []\\n for i in range(n):\\n ar.append( list(map(int,input().split())) )\\n y.append(ar[-1][1])\\n ar[-1].append(i)\\n \\n y.sort()\\n mny = y[0]\\n mxy = y[-1]\\n ar.sort()\\n ssx,ssy,ssi = ar[0]\\n bbx,bby,bbi = ar[-1]\\n \\n sbx,sby,sbi = ar[0]\\n bsx,bsy,bsi = ar[-1]\\n \\n for i in range(len(ar)):\\n", "gt": "if ar[i][0]>ssx:\\n sbx,sby,sbi = ar[i-1]\\n break\\n \\n for i in range(len(ar)-1,-1,-1):\\n if ar[i][0]<bsx:\\n bsx,bsy,bsi = ar[i+1]\\n break \\n \\n if (ssy <=mny):\\n print(1)\\n print(ssi+1,'NE')\\n continue\\n if (sby>=mxy):\\n print(1)\\n print(sbi+1,'SE')\\n continue\\n if (bsy <=mny):\\n print(1)\\n print(bsi+1,'NW')\\n continue\\n if (bby>=mxy):\\n print(1)\\n print(bbi+1,'SW')\\n continue \\n \\n print(2)\\n if(ssy<bby):\\n print(ssi+1,'NE')\\n print(bbi+1,'SW')\\n else:\\n print(ssi+1,'SE')\\n print(bbi+1,'NW')\\n \\n"}
{"id": "1447", "input": "# from math import log2\\n# N = 10000\\n# for i in range(1,N):\\n# # print(i)\\n# for m in range(i):\\n# if( (m^(m+1))==i ):\\n# print(i)\\n# print(m,m+1,bin(m)[2:])\\n# print()\\n# break\\n# # else:\\n# # print(-1)\\n#", "gt": "# print()\\nT = int(input())\\nans = []\\n\\nfor _ in range(T):\\n N = int(input())\\n\\n # x = log2(N+1)\\n if(N==1):\\n ans.append(2)\\n elif('0' not in bin(N)[2:]):\\n ans.append(N//2)\\n else:\\n ans.append(-1)\\n\\nfor i in ans:\\n print(i)"}
{"id": "1448", "input": "# cook your dish here\\n \\nfor __ in range(int(input())):\\n n=int(input())\\n arr=list(map(int,input().split()))\\n d={}\\n s=set()\\n flag=0\\n for i in range(n):\\n if arr[i] in list(d.keys()):\\n d[arr[i]]+=1\\n else:\\n", "gt": "d[arr[i]]=1\\n curr_ele=arr[i]\\n if (curr_ele in s) and arr[i-1]!=arr[i]:\\n flag=1\\n break\\n else:\\n s.add(arr[i])\\n c=list(d.values())\\n if len(c)!=len(set(c)):\\n flag=1\\n if flag==1:\\n print(\"NO\")\\n else:\\n print(\"YES\")\\n \\n \\n \\n \\n"}
{"id": "1449", "input": "# cook your dish here\\n\\nt = int(input())\\n\\nfor _ in range(t):\\n a,d,k,n,inc = map(int, input().strip().split())\\n\\n res =", "gt": "a\\n for i in range(1, n):\\n if i%k == 0:\\n d += inc\\n res += d\\n\\n print(res)"}
{"id": "1450", "input": "x=eval(input())\\nfor x in range(0,x):\\n ans=0\\n d=input()\\n a=0\\n cont=0\\n for i", "gt": "in range(0,len(d)):\\n a+=len(d)-i\\n if d[i]=='7':\\n ans+=1+cont\\n cont+=1\\n else:\\n cont=0\\n ans=a-ans\\n print(ans)\\n"}
{"id": "1451", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n = int(input())\\n", "gt": "a = list(map(int,input().split()))\\n a.sort()\\n i=1\\n while(i<n):\\n a[i-1],a[i] = a[i],a[i-1]\\n i+=2\\n print(*a)\\n"}
{"id": "1452", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n N, M = [int(x) for x in input().split()]\\n edges = [0]*M\\n dir = {}\\n nodes = [[] for j in range(N+1)]\\n ind = [0]*(N+1)\\n graph = {}\\n final_edges = []\\n for i in range(M):\\n u, v = [int(x) for x in input().split()]\\n nodes[u].append(v)\\n nodes[v].append(u)\\n dir[(u,v)]=1\\n dir[(v,u)] = 0\\n ind[v] += 1\\n graph[(u,v)] = graph[(v,u)] = i\\n final_edges.append([u,v])\\n if M%2!=0:\\n print(-1)\\n continue\\n for i in range(M):\\n u, v = final_edges[i]\\n if ind[u]%2!=0 and ind[v]%2!=0:\\n d = dir[(u,v)]\\n if d:\\n ind[u] += 1\\n ind[v] -= 1\\n dir[(u,v)] = 0\\n dir[(v,u)]", "gt": "= 1\\n edges[i] = abs(edges[i]-1)\\n else:\\n ind[u] -= 1\\n ind[v] += 1\\n dir[(u, v)] = 1\\n dir[(v, u)] = 0\\n edges[i] = abs(edges[i]-1)\\n s = []\\n for i in range(1, N+1):\\n if ind[i]%2:\\n s.append(i)\\n while s:\\n set1 = set()\\n for u in s:\\n if ind[u]%2:\\n v = nodes[u][0]\\n d = dir[(u,v)]\\n index = graph[(u, v)]\\n set1.add(v)\\n if d:\\n ind[u] += 1\\n ind[v] -= 1\\n dir[(u, v)] = 1\\n dir[(v, u)] = 1\\n edges[index] = abs(edges[index]-1)\\n else:\\n ind[u] -= 1\\n ind[v] += 1\\n dir[(u, v)] = 1\\n dir[(v, u)] = 0\\n edges[index] = abs(edges[index]-1)\\n\\n s = set1\\n print(*edges)"}
{"id": "1453", "input": "#read input\\ncases = int(input())\\ncaselist = []\\nfor i in range(0, cases):\\n caselist.append(input())\\n\\n#iterate each case\\nfor j in range(0, cases):\\n\\n #current case's parameters:\\n current_input = caselist[j].split(' ')\\n bots = int(current_input[0])\\n switch = int(current_input[1])\\n\\n #generate botlist and cakelist\\n botlist = list(range(switch, bots)) + list(range(0,", "gt": "switch))\\n cakelist = [False] * bots\\n\\n\\n counter = 0\\n index = 0\\n for i in range(0,bots):\\n if cakelist[index] == False:\\n cakelist[index] = True\\n counter += 1\\n index = botlist[index]\\n else:\\n break\\n\\n if counter == bots:\\n print(\"Yes\")\\n else:\\n print(\"No\", counter)\\n \\n\\n \\n"}
{"id": "1454", "input": "n, q, k = map(int, input().split())\\narr = list(map(int, input().split()))\\nquery = list(input())\\nq_ = len(query)\\nc1 = query.count('?')\\nc = arr.count(0)\\nif c == n:\\n for i in range(c1):\\n print(0)\\nelse:\\n for i in range(q_):\\n if (i!=0) and (query[i] == '?' and query[i-1] == '?'):\\n print(max_c)\\n elif query[i] == '?':\\n max_c = cnt = 0\\n for j in range(n):\\n", "gt": "if (j != n - 1) and (arr[j] == 1 and arr[j + 1] == 1):\\n cnt += 1\\n else:\\n max_c = max(max_c, cnt + 1)\\n cnt = 0\\n if k < max_c:\\n max_c = k\\n break\\n print(max_c)\\n elif query[i] == '!':\\n temp = arr[n - 1]\\n del arr[n - 1]\\n arr.insert(0, temp)"}
{"id": "1455", "input": "import numpy as np\\n\\nN=10**6+1\\nt=eval(input())\\ninp = ()\\n\\nt1=ord('z')\\n#bag=[[0 for _ in xrange(t1)] for _ in xrange(N+1)]\\nbag=np.zeros((N+1,t1),dtype=np.int)\\n#print bag\\nwhile t:\\n t-=1\\n inp=input().split()\\n t2=ord(inp[3]) - ord('a')\\n t3=int(inp[1])\\n t4=int(inp[2]) + 1\\n if", "gt": "inp[0]==\"1\":\\n #print \"enter\"\\n bag[t3][t2]+=int(inp[2])\\n\\n\\n if inp[0]==\"2\":\\n sum=0\\n for i in range(t3,t4):\\n sum+=bag[i][t2]\\n print(sum)\\n\\n#\\n# for j in range(ord('z')-ord('a')):\\n# for i in range(N+1):\\n# if bag[i][j]!=0:\\n# print bag[i][j] ,i,j\\n\\n\\n\\n"}
{"id": "1456", "input": "n=eval(input())\\ngrades=list(map(int,input().split()))\\nm=eval(input())\\nfor df in range(m):\\n x,y=list(map(int,input().split()))\\n arr=[]\\n arr=grades[x-1:y]\\n arr.sort()\\n sum=0\\n", "gt": "#arr.append(1000000)\\n for nh in range(0,len(arr)-1,1):\\n sum=sum+(arr[nh+1]-arr[nh])**2\\n #print sum,len(arr),nh+1,nh\\n print(sum)"}
{"id": "1457", "input": "import math\\ndef GLR(x):\\n summation_N = (x*(x+1))//2\\n initial = x\\n power = 0\\n sum_A = 0\\n while x>=1:\\n count = (x+1)//2\\n sum_A += count * 2**power\\n x = x - count\\n power", "gt": "+= 1\\n sum_B = summation_N - sum_A\\n ans = sum_B - (int(math.log(initial,2))+1)\\n return ans\\n \\nfor _ in range(int(input())):\\n l,r = list(map(int,input().split()))\\n if l==1:\\n print(GLR(r))\\n else:\\n print((GLR(r) - GLR(l-1)))# cook your dish here\\n"}
{"id": "1458", "input": "#Note that it's python3 Code. Here, we are using input() instead of raw_input().\\n#You can check on your local machine the version of python by typing \"python", "gt": "--version\" in the terminal.\\n\\n(n, k) = list(map(int, input().split(' ')))\\n\\nans = 0\\n\\nfor i in range(n):\\n x = int(input())\\n if x % k == 0:\\n ans += 1\\n\\nprint(ans)"}
{"id": "1459", "input": "# cook your dish here\\nt=int(input())\\nfor i in range(t):\\n", "gt": "a=0\\n n=int(input())\\n while(n>0):\\n a += n*n\\n n=n-2\\n print(a)\\n"}
{"id": "1460", "input": "import math\\n\\n\\nn,m = map(int, input().split())\\nhyp = math.sqrt(1+m*m)\\ncosx = 1/hyp\\nsinx = m/hyp\\n\\npts = [[], []]\\nfor i in", "gt": "range(n):\\n p = input().split()\\n px = int(p[0])\\n py = int(p[1])\\n pts[0].append(cosx*px+sinx*py)\\n pts[1].append(cosx*py-sinx*px)\\n\\nw = max(pts[0])-min(pts[0])\\nl = max(pts[1])-min(pts[1])\\n\\nprint(2*l+2*w)"}
{"id": "1461", "input": "# cook your dish here\\n\\nl=[int(k) for k in input().split()]\\ns=[int(k) for k in input().split()]\\nx=l[1]*l[0]\\nfor i in", "gt": "range(l[0]):\\n if(s[i]==1):\\n x+=l[2]\\n elif(s[i]==2):\\n x+=(l[2]*98/100)\\n elif(s[i]==3):\\n x+=(l[2]*96/100)\\n elif(s[i]==4):\\n x+=(l[2]*94/100)\\n elif(s[i]==5):\\n x+=(l[2]*92/100)\\n elif(s[i]==6):\\n x+=(l[2]*90/100)\\nif(x>=300):\\n print(\"YES\")\\nelse:\\n print(\"NO\")"}
{"id": "1462", "input": "from sys import stdin\\nfrom fractions import Fraction\\n\\ninput = stdin.readline\\n\\nfor _ in range(int(input())):\\n a, b, n = list(map(int, input().split()))\\n ab = Fraction(a, b)\\n\\n p = set()\\n\\n", "gt": "for i in range(1, n+1):\\n for j in range(n, 0, -1):\\n x = Fraction(i, j)\\n\\n if x > ab:\\n break\\n\\n p.add(x)\\n\\n x = sorted(p)[-2]\\n\\n print(x.numerator, x.denominator)\\n"}
{"id": "1463", "input": "# cook your dish here\\ntry:\\n t=int(input()) \\n for i in range(t):\\n n=input() \\n n=n.lower()\\n a=\"berhampore\"\\n b=\"serampore\"\\n if a in n:\\n if b", "gt": "in n:\\n print(\"Both\")\\n else:\\n print(\"GCETTB\")\\n elif b in n:\\n if a in n:\\n print(\"Both\")\\n else:\\n print(\"GCETTS\")\\n else:\\n print(\"Others\")\\nexcept Exception as e:\\n pass"}
{"id": "1464", "input": "def ugcd(n):\\r\\n ans = [[1]]\\r\\n if(n==1):\\r\\n return ans\\r\\n elif(n%2==1):\\r\\n ans = [[1, 2, n]]\\r\\n else:\\r\\n ans = [[1, 2]]\\r\\n for k in range(1, int(n//2)):\\r\\n", "gt": "ans.append([k*2+1, k*2+2])\\r\\n return ans\\r\\nt = int(input())\\r\\nfor i in range(t):\\r\\n n = int(input())\\r\\n s = (ugcd(n))\\r\\n print(len(s))\\r\\n for j in range(len(s)):\\r\\n print(len(s[j]), end=\" \")\\r\\n print(*s[j])"}
{"id": "1465", "input": "t=int(input())\\nli1=[31,29,31,30,31,30,31,31,30,31,30,31]\\nli2=[31,28,31,30,31,30,31,31,30,31,30,31]\\nfor z in range(t):\\n y,m,d=list(map(int,input().split(':')))\\n if y%4 == 0:\\n if y%100 == 0:\\n if y%400 == 0:\\n li=li1\\n else:\\n li=li2\\n else:\\n li=li1\\n else:\\n li=li2\\n c=0\\n if", "gt": "d%2 == 0:\\n while d%2 == 0:\\n c+=1\\n d+=2\\n if d>li[m-1]:\\n d=d%li[m-1]\\n m+=1\\n else: \\n while d%2 != 0:\\n c+=1\\n d+=2\\n if d>li[m-1]:\\n d=d%li[m-1]\\n m+=1\\n print(c)\\n \\n"}
{"id": "1466", "input": "import sys\\n\\ndef powc(x,n,m):\\n res = 1\\n xx=x\\n while n:\\n if n&1:\\n res = (res*xx)%m\\n xx=xx*xx%m\\n n >>= 1\\n return res\\n\\ndef circles(u):\\n r = 0\\n S = [(u,-1,0)]\\n Visited[u] = 0\\n for s in S:\\n for e in V[s[0]]:\\n if e[0] != s[1]:\\n if Visited[e[0]]==-1: \\n Visited[e[0]] = s[2]^e[1]\\n S.append((e[0], s[0], s[2]^e[1])) \\n elif Visited[e[0]] != s[2]^e[1]:\\n return -1\\n else:\\n r += s[0]<e[0]\\n return r\\n\\nT = int(sys.stdin.readline())\\nfor _ in range(T):\\n is_bad = False\\n empty = 0\\n n,Q = list(map(int, sys.stdin.readline().split()))\\n for _ in range(n-1):\\n", "gt": "sys.stdin.readline() \\n paths = []\\n V=list(map(list,[[]]*n))\\n for q in range(Q):\\n u,v,x = list(map(int, sys.stdin.readline().split()))\\n u-=1\\n v-=1\\n if (v,x^1) in V[u]:\\n is_bad = True\\n elif (v,x) in V[u]:\\n empty += 1\\n elif u!=v:\\n V[u].append((v,x))\\n V[v].append((u,x))\\n elif x==1:\\n is_bad = True\\n else:\\n empty += 1\\n paths.append((u,v,x))\\n if is_bad:\\n print(0)\\n elif n<=1:\\n print(1)\\n else:\\n Visited = [-1]*n\\n components = 0\\n for i in range(n):\\n if Visited[i]==-1:\\n components += 1\\n c = circles(i)\\n if c==-1:\\n is_bad = True\\n break\\n empty += c\\n if is_bad:\\n print(0)\\n else:\\n print(powc(2,n-1-(Q-empty),10**9+7)) \\n"}
{"id": "1467", "input": "# cook your dish here\\nn,q=map(int,input().split())\\nls=[int(i) for i in input().split()]\\ncur=0\\ns=[0]\\nfor", "gt": "i in ls:\\n cur=cur^i\\n s.append(cur)\\nfor i in range(q):\\n k=int(input())\\n print(s[k%(n+1)])"}
{"id": "1468", "input": "# cook your dish here\\ndef guessingGame (l):\\n a = []\\n m = 1000000001\\n for i in range (len(l)):\\n k=int(l[i][1])\\n if (l[i][0]=='<' and l[i][2]=='Yes'):\\n a.append((1,1))\\n a.append((k,-1))\\n \\n if (l[i][0]=='<' and l[i][2]=='No'):\\n a.append((k,1))\\n a.append((m,-1))\\n \\n if (l[i][0]=='=' and l[i][2]=='Yes'):\\n a.append((k,1))\\n a.append((k+1,-1))\\n\\n if (l[i][0]=='=' and l[i][2]=='No'):\\n a.append((1,1))\\n a.append((k,-1))\\n a.append((k+1,1))\\n a.append((m,-1))\\n\\n if (l[i][0]=='>' and l[i][2]=='Yes'):\\n a.append((k+1,1))\\n", "gt": "a.append((m,-1))\\n\\n if (l[i][0]=='>' and l[i][2]=='No'):\\n a.append((1,1))\\n a.append((k+1,-1))\\n\\n a.sort()\\n w=0\\n r=0\\n\\n for i in range (len(a)):\\n w+=a[i][1]\\n r=max(w,r)\\n\\n return len(l)-r\\n \\n \\ndef __starting_point():\\n\\n T = int(input())\\n answer = []\\n\\n for _ in range (T):\\n e = int(input())\\n temp = []\\n for q_t in range (e):\\n q = list(map(str,input().rstrip().split()))\\n temp.append(q)\\n result = guessingGame(temp)\\n print(result)\\n__starting_point()"}
{"id": "1469", "input": "# cook your dish here\\ntry:\\n t=int(input())\\n for i", "gt": "in range(t):\\n s=input()\\n i=int(s,16)\\n print(i)\\nexcept EOFError as e:\\n print(e)"}
{"id": "1470", "input": "try:\\r\\n tc=int(input())\\r\\n for _ in range(tc):\\r\\n n=int(input())\\r\\n st=\"\"\\r\\n b=1\\r\\n for i in", "gt": "range(1,n+1):\\r\\n b+=1\\r\\n a=b\\r\\n for j in range(1,n+1):\\r\\n print(a,end='')\\r\\n a+=1\\r\\n print() \\r\\nexcept:\\r\\n pass"}
{"id": "1471", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n s=input()\\n count=0\\n i=0\\n while i<len(s)-1:\\n ch=s[i]\\n j=i+1 \\n while j<len(s)", "gt": "and s[j]==ch:\\n j+=1 \\n l=j-i\\n if i!=0 and j!=len(s) and s[i-1]==s[j] :\\n count+=1\\n count+=l*(l-1)//2\\n #print(s[i:j],count)\\n i=j\\n print(count) \\n"}
{"id": "1472", "input": "import sys\\n\\ndef spaces(a,n,m,k,visit1,visit2,dist,position):\\n queue = [position]\\n lastedit = []\\n dist[position[0]][position[1]] = 0 \\n while queue!=[]:\\n point = queue[0]\\n i = point[0]\\n j = point[1]\\n #print 'point',i,j\\n if visit1[i][j]==False:\\n visit1[i][j] = True\\n startx = max(i-k,0)\\n endx = min(i+k,n-1)\\n for x in range(startx,endx+1):\\n starty = max(0,j+abs(x-i)-k)\\n endy = min(m-1,j-abs(x-i)+k)\\n for y in range(starty,endy+1):\\n if (a[x][y]==0 and visit1[x][y]==False):\\n if visit2[x][y]==True:\\n lastedit.append([x,y])\\n #print x,y,\\n if dist[x][y]>dist[i][j]+1:\\n dist[x][y]=dist[i][j]+1\\n queue.append([x,y])\\n #print queue,dist\\n queue = queue[1:]\\n #print\\n return lastedit\\n\\nfor t in range(int(input())):\\n n,m,k1,k2 = list(map(int,input().split()))\\n a = []\\n for i in range(n):\\n a.append(list(map(int,input().split())))\\n #print a\\n value = sys.maxsize\\n listing =", "gt": "[]\\n visit1 = [[False for i in range(m)]for j in range(n)]\\n visit2 = [[False for i in range(m)]for j in range(n)]\\n dist1 = [[sys.maxsize for i in range(m)]for j in range(n)]\\n dist2 = [[sys.maxsize for i in range(m)]for j in range(n)]\\n if k1>=k2:\\n spaces(a,n,m,k1,visit1,visit2,dist1,[0,0])\\n else:\\n spaces(a,n,m,k2,visit1,visit2,dist1,[0,m-1])\\n listing = spaces(a,n,m,k1,visit2,visit1,dist2,[0,0])\\n if k1>k2:\\n listing = spaces(a,n,m,k2,visit2,visit1,dist2,[0,m-1])\\n #print visit1\\n #sprint visit2\\n if k1==k2:\\n if dist1[0][m-1]==sys.maxsize:\\n print('-1')\\n else:\\n print(int((dist1[0][m-1]+1)/2))\\n else:\\n d = len(listing)\\n for i in range(d-1,-1,-1):\\n x = listing[i][0]\\n y = listing[i][1]\\n if visit1[x][y]==True and dist2[x][y]<value:\\n value = dist2[x][y]\\n if value!=sys.maxsize:\\n print(value)\\n else:\\n print('-1')\\n\\n\\n\\n\\n \\n \\n"}
{"id": "1473", "input": "n=int(input())\\r\\na=[]\\r\\nb=[]\\r\\nfor i in range(1,1000001):\\r\\n s = str(i)\\r\\n p=1\\r\\n flag=0\\r\\n for e in", "gt": "s:\\r\\n if e=='1':\\r\\n flag=1\\r\\n p=p*int(e)\\r\\n if p==n:\\r\\n if flag!=1:\\r\\n a.append(i)\\r\\n else:\\r\\n b.append(i)\\r\\nprint(len(a),len(b))"}
{"id": "1474", "input": "#!/usr/bin/python\\nimport sys\\n\\ndef __starting_point():\\n t = int(input())\\n for iteration in range(t):\\n r,c,m_inp,k_inp,j_inp = input().strip().split(\" \")\\n r=int(r)\\n c=int(c)\\n m_inp=int(m_inp)\\n k_inp=int(k_inp)\\n j_inp=int(j_inp)\\n\\n ans = \"\"\\n if (r*c) != (m_inp+k_inp+j_inp):\\n print(\"No\")\\n continue\\n else:\\n flag = False\\n for i in range(6):\\n if flag:\\n break\\n if i==0:\\n m = m_inp\\n k = k_inp\\n j = j_inp\\n elif i==1:\\n m = j_inp\\n k = m_inp\\n j = k_inp\\n elif i==2:\\n m = k_inp\\n k = j_inp\\n j = m_inp\\n elif i==3:\\n m = m_inp\\n k = j_inp\\n j = k_inp\\n elif i==4:\\n m = k_inp\\n k = m_inp\\n j = j_inp\\n elif i==5:\\n m = j_inp\\n k = k_inp\\n j = m_inp\\n if m%r == 0:\\n r_remain_1 = r\\n c_remain_1 = c-(m/r)\\n \\n if k%r_remain_1 == 0:\\n r_remain_2 = r_remain_1\\n c_remain_2 = c_remain_1 - (k/r_remain_1)\\n if r_remain_2*c_remain_2 == j:\\n print(\"Yes\")\\n flag = True\\n continue\\n if k%c_remain_1 == 0:\\n c_remain_2 = c_remain_1\\n r_remain_2 = r_remain_1 - (k/c_remain_1)\\n if r_remain_2*c_remain_2", "gt": "== j:\\n print(\"Yes\")\\n flag = True\\n continue\\n \\n if j%r_remain_1 == 0:\\n r_remain_2 = r_remain_1\\n c_remain_2 = c_remain_1 - (j/r_remain_1)\\n if r_remain_2*c_remain_2 == k:\\n print(\"Yes\")\\n flag = True\\n continue\\n if j%c_remain_1 == 0:\\n c_remain_2 = c_remain_1\\n r_remain_2 = r_remain_1 - (j/c_remain_1)\\n if r_remain_2*c_remain_2 == k:\\n print(\"Yes\")\\n flag = True\\n continue\\n \\n if m%c == 0:\\n c_remain_1 = c\\n r_remain_1 = r-(m/c) \\n\\n if k%r_remain_1 == 0:\\n r_remain_2 = r_remain_1\\n c_remain_2 = c_remain_1 - (k/r_remain_1)\\n if r_remain_2*c_remain_2 == j:\\n print(\"Yes\")\\n flag = True\\n continue\\n if k%c_remain_1 == 0:\\n c_remain_2 = c_remain_1\\n r_remain_2 = r_remain_1 - (k/c_remain_1)\\n if r_remain_2*c_remain_2 == j:\\n print(\"Yes\")\\n flag = True\\n continue\\n \\n if j%r_remain_1 == 0:\\n r_remain_2 = r_remain_1\\n c_remain_2 = c_remain_1 - (j/r_remain_1)\\n if r_remain_2*c_remain_2 == k:\\n print(\"Yes\")\\n flag = True\\n continue\\n if j%c_remain_1 == 0:\\n c_remain_2 = c_remain_1\\n r_remain_2 = r_remain_1 - (j/c_remain_1)\\n if r_remain_2*c_remain_2 == k:\\n print(\"Yes\")\\n flag = True\\n continue\\n if not flag:\\n print(\"No\")\\n__starting_point()"}
{"id": "1475", "input": "T = int(input())\\n\\ndef call_me(N,A,X):\\n max = 0\\n ans = ''\\n for i in A:\\n if i.count(X) > max:\\n max", "gt": "= i.count(X)\\n ans = i\\n return ans\\n\\n\\n\\nfor i in range(T):\\n N = int(input())\\n A = list(map(str,input().split()))\\n X = input()\\n print(call_me(N,A,X))\\n"}
{"id": "1476", "input": "x = input().split(\" \")\\ny = input()\\nans = ''\\nl = 1\\nfor i in x:\\n if", "gt": "i!=y and sorted(i) == sorted(y):\\n ans = ans + (str)(l)\\n l=l+1\\nans+='.'\\nprint(\"The antidote is found in\",ans)"}
{"id": "1477", "input": "# cook your dish here\\nfrom collections import Counter\\nfrom math import factorial\\nfor _", "gt": "in range(int(input())):\\n s=input()\\n c=Counter(s)\\n k=factorial(len(s))\\n for value in c.values():\\n if value>1:\\n k=k//factorial(value)\\n print(k%(10**9+7))"}
{"id": "1478", "input": "for _1 in range(int(input())):\\n n=int(input())\\n s=input().strip()\\n answer=s\\n for i in", "gt": "range(len(s)):\\n c=s[i]\\n string=s[:i]+s[i+1:]\\n for j in range(len(string)+1):\\n answer=min(answer, string[:j]+c+string[j:])\\n print(answer)"}
{"id": "1479", "input": "# cook your dish here\\nfrom math import gcd\\nfor _ in range(int(input())):\\n n,a,k,min_k,e = int(input()),[int(i) for i in input().split()],0,0,-1 \\n for j in range(n):\\n if(a[j] != -1):break \\n for i in range(j,n):\\n if min_k==0:min_k,e = a[i],a[i]+1 \\n else:\\n if min_k < a[i]:min_k = a[i] \\n if(a[i] == -1):pass\\n else:\\n if(a[i]", "gt": "== e):pass\\n else:\\n if( k == 0):k = e-a[i]\\n else:\\n new_k = e-a[i]\\n if(new_k < 0):k = -1\\n else:k = gcd(k,new_k)\\n if(k<min_k or k<0): k = -1; break\\n if k != 0 and a[i]!=-1: e = a[i]%k+1\\n else:e += 1 \\n if(k == -1):print(\"impossible\")\\n elif k == 0 :print(\"inf\")\\n else:print(k)"}
{"id": "1480", "input": "# cook your dish here\\np=int(input())\\nfor z in range(p):\\n n=int(input())\\n a=[]\\n for i in", "gt": "range(8):\\n a.append(0)\\n for i in range(n):\\n x,y=list(map(int,input().split()))\\n if x<=8 and y>a[x-1]:\\n a[x-1]=y\\n print(sum(a))\\n"}
{"id": "1481", "input": "import math\\ndef dist(w,x,y,z):\\n return math.hypot(y - w, z - x)\\n\\nt = int(input())\\nwhile (t>0):\\n t = t -1\\n n, m = list(map(int,input().split()))\\n a = []\\n for i in range(0,n):\\n x,y = list(map(int,input().split()))\\n a.append([x,y])\\n for j in", "gt": "range(0,m):\\n p,q,r,s = list(map(int,input().split()))\\n nearest = -1\\n distance = 10000000000\\n for i in range(0,n):\\n way = dist(a[i][0],a[i][1],p,q)\\n if way < distance:\\n distance = way\\n nearest = i\\n print(nearest + 1)\\n a[nearest][0] = r\\n a[nearest][1] = s\\n\\n"}
{"id": "1482", "input": "t=int(input())\\nfor i in range(t):\\n s=input()\\n zeroes=s.count('0')\\n ones=s.count('1')\\n if (len(s)%2==1", "gt": "or zeroes==0 or ones==0):\\n ans= -1\\n else:\\n ans=abs(zeroes-ones)//2\\n print(ans)"}
{"id": "1483", "input": "for i in range(int(input())):\\n n", "gt": "= int(input())\\n q = \"1\"+\"0\"*(n//2)\\n print(1,q)"}
{"id": "1484", "input": "from math import gcd\\r\\nn, k = list(map(int, input().split()))\\r\\na = []\\r\\nfor i in range(k):\\r\\n try:\\r\\n a += list(map(int, input().split()))\\r\\n except:\\r\\n pass\\r\\nans = n\\r\\nfor i in range(1, 2**k):\\r\\n b = bin(i)[2:].rjust(k, \"0\")\\r\\n c = []\\r\\n for j", "gt": "in range(k):\\r\\n if(b[j] == '1'):\\r\\n c.append(a[j])\\r\\n lcm = c[0]\\r\\n for j in c[1:]:\\r\\n lcm *= j // gcd(lcm, j)\\r\\n temp = ((n - 1) // lcm) + 1\\r\\n if(b.count('1')&1):\\r\\n ans -= temp\\r\\n else:\\r\\n ans += temp\\r\\nprint(ans)\\r\\n\\r\\n"}
{"id": "1485", "input": "for _ in range(int(input())):\\n s = list(input().strip())\\n\\n i = 0\\n\\n while i < len(s) - 1:\\n if s[i].isalpha() or s[i] == ')':\\n if s[i + 1].isdigit():\\n if i + 2 >= len(s) or s[i + 2] == ')':\\n s = s[:i+1] + ['*', s[i+1]] + s[i+2:]\\n else:\\n", "gt": "s = s[:i+1] + ['*', s[i+1], '+'] + s[i+2:]\\n i += 1\\n elif s[i + 1].isalpha() or s[i + 1] == '(':\\n s = s[:i+1] + ['+'] + s[i+1:]\\n\\n i += 1\\n\\n s = ''.join(s)\\n\\n s = s.strip('+')\\n\\n x = 2\\n y = 4\\n z = 10\\n\\n print(eval(s))\\n"}
{"id": "1486", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n=int(input())\\n l1=[]\\n l2=[]\\n \\n for i in range(n):\\n s=input()\\n a=s[ :n//2].count('1')\\n b=s[n//2: ].count('1')\\n if a>b:\\n l1.append(a-b)\\n \\n elif a<b:\\n l2.append(b-a)\\n \\n p=sum(l1)\\n q=sum(l2)\\n \\n if p==q:\\n print(0)\\n \\n elif p>q:\\n diff=p-q\\n flag=0\\n for i in range(diff//2,", "gt": "0, -1):\\n a=diff-i\\n if (i in l1) or (a in l1):\\n print(abs(a-i))\\n flag=1\\n break\\n \\n if flag==0:\\n print(diff)\\n \\n else:\\n diff=q-p\\n flag=0\\n for i in range(diff//2, 0, -1):\\n a=diff-i\\n if (i in l2) or (a in l2):\\n print(abs(a-i))\\n flag=1\\n break\\n \\n if flag==0:\\n print(diff)"}
{"id": "1487", "input": "for j in range(int(input())):\\n input()\\n a = list(map(int,input().split()))\\n marks = 0\\n backlok = 0\\n top_marks = max(a)\\n topper = []\\n for i in range(len(a)):\\n", "gt": "if(a[i] >= 31):\\n marks+=a[i]\\n if(a[i]<31):\\n backlok+=1\\n if(a[i] == top_marks):\\n topper.append(i)\\n print(backlok, \""}
{"id": "1488", "input": "import sys\\n\\n# stdin = open(\"testdata.txt\", \"r\")\\nip = sys.stdin \\n\\ndef solve(C, n, x):\\n if n==1:\\n return (1, 0)\\n\\n b1, b2 = 1, 1\\n a , b = C[0], C[-1]\\n while b1 + b2 < n:\\n if a < b*x:\\n a += C[b1]\\n b1 += 1\\n elif a > b*x:\\n", "gt": "b2 += 1\\n b += C[n-b2] \\n else:\\n if b1 >= b2:\\n a += C[b1]\\n b1 += 1\\n else:\\n b2 += 1\\n b += C[b2]\\n return (b1, b2)\\n\\nt = int(ip.readline())\\n\\nfor _ in range(t):\\n n = int(ip.readline())\\n C = list(map(int, ip.readline().split()))\\n x = int(ip.readline())\\n\\n ans = solve(C, n, x)\\n print(*ans)"}
{"id": "1489", "input": "from itertools import permutations\\n\\nfor _ in range(int(input())):\\n N,K=list(map(int,input().split()))\\n arr=list(map(int,input().split()))\\n arr1=[]\\n arr2=[]\\n for i in range(1,len(arr)+1):\\n arr1.append(i)\\n indexzero=[]\\n for i in range(0,len(arr)):\\n if(arr[i]==0):\\n indexzero.append(i)\\n else:\\n arr2.append(arr[i])\\n # arr3 = [x for x in arr1 if x not in arr2]\\n arr3= list(set(arr1)-set(arr2))\\n result=permutations(arr3)\\n", "gt": "perm=[]\\n for i in result:\\n perm.append(i)\\n step=0\\n count=0\\n for p in range(0,len(perm)):\\n temp=[]\\n for q in range(0,len(arr)):\\n if(arr[q]==0):\\n temp.append(perm[p][step])\\n step+=1 \\n else:\\n temp.append(arr[q])\\n k=0\\n step=0\\n for m in range(0,len(temp)-1):\\n if(temp[m]<temp[m+1]):\\n k+=1\\n if(k==K):\\n count+=1 \\n print(count)\\n \\n \\n \\n \\n \\n \\n \\n"}
{"id": "1490", "input": "a,b=[int(_) for _ in input().split()]\\r\\nif b==0:\\r\\n print(a)\\r\\nelse: \\r\\n l=[]\\r\\n a=str(a)\\r\\n for i in range(len(a)):\\r\\n l.append(a[i])\\r\\n for i in", "gt": "range(len(l)):\\r\\n if b==0:\\r\\n break\\r\\n if l[i]=='9':\\r\\n continue\\r\\n else:\\r\\n l[i]='9'\\r\\n b-=1\\r\\n s=''\\r\\n for i in l:\\r\\n s+=i\\r\\n print(s) \\r\\n \\r\\n"}
{"id": "1491", "input": "from math import ceil\\r\\nt=int(input())\\r\\nfor i in range(t):\\r\\n p=int(input())\\r\\n l=list(map(int,input().split()))\\r\\n maxx=1\\r\\n for i", "gt": "in range(len(l)):\\r\\n maxx=max(maxx,l.count(l[i]))\\r\\n if(maxx*2>p):\\r\\n print(maxx)\\r\\n else:\\r\\n q=p-maxx*2\\r\\n maxx+=ceil(q/2)\\r\\n print(maxx)\\r\\n \\r\\n \\r\\n \\r\\n\\r\\n"}
{"id": "1492", "input": "def permutate(arr):\\n if len(arr) == 1:\\n yield arr\\n for x in range(len(arr)):\\n for perm in permutate(arr[:x] + arr[x+1:]):\\n yield [arr[x]] + perm\\n\\nvals = [int(x) for", "gt": "x in input().split()]\\n\\nfounded = False\\nfor val in permutate(vals):\\n if (val[0] / float(val[1]) == val[2] / float(val[3])):\\n print(\"Possible\")\\n founded = True \\n break\\nif not founded:\\n print(\"Impossible\")\\n"}
{"id": "1493", "input": "t = int(input())\\nfor j in range(0, t):\\n n = int(input())\\n m = 100\\n for i in range(0,", "gt": "n):\\n str = input()\\n p = min(str.count(\"a\",0,len(str)),str.count(\"b\",0,len(str)))\\n if (m > p):\\n m = p\\n print(m)\\n t = t-1"}
{"id": "1494", "input": "def outOfIndex(boys,girls,COST):\\n if COST == 0:\\n return len(boys)\\n else:\\n total_cost = [ abs(x-y) for x,y in zip(boys,girls)]\\n total_cost = sum(total_cost)\\n return total_cost\\n\\nfor _ in range(int(input())):\\n COST = int(input())\\n queue = input()\\n B = queue.count('B')\\n G = queue.count('G')\\n boys=[]\\n girls = []\\n if (abs(B-G)>1):\\n print(-1)\\n else:\\n if B > G:\\n for c in range(len(queue)):\\n if c%2!=0 and queue[c]=='B':\\n boys.append(c)\\n if c%2==0 and queue[c] =='G':\\n girls.append(c)\\n print(outOfIndex(boys,girls,COST))\\n boys.clear()\\n", "gt": "girls.clear()\\n elif B < G:\\n for c in range(len(queue)):\\n if c%2!=0 and queue[c]=='G':\\n girls.append(c)\\n if c%2==0 and queue[c] =='B':\\n boys.append(c)\\n print(outOfIndex(boys,girls,COST))\\n boys.clear()\\n girls.clear()\\n else:\\n for c in range(len(queue)):\\n if c%2!=0 and queue[c]=='B':\\n boys.append(c)\\n if c%2==0 and queue[c] =='G':\\n girls.append(c)\\n attempt1 = outOfIndex(boys,girls,COST)\\n boys.clear()\\n girls.clear()\\n for c in range(len(queue)):\\n if c%2!=0 and queue[c]=='G':\\n girls.append(c)\\n if c%2==0 and queue[c] =='B':\\n boys.append(c)\\n attempt2 = outOfIndex(boys,girls,COST)\\n print(min(attempt1,attempt2))\\n boys.clear()\\n girls.clear() \\n"}
{"id": "1495", "input": "n=int(input())\\r\\nl=[0]*n\\r\\nfor i in range(n):\\r\\n l[i]=int(input())\\r\\nl.sort()\\r\\ns=0\\r\\ni=n-1\\r\\nwhile i>=0:\\r\\n x=2*l[i]\\r\\n if l[-1]>=x:\\r\\n j=i\\r\\n", "gt": "while j<len(l):\\r\\n if l[j]>=x:\\r\\n l.pop(j)\\r\\n l.pop(i)\\r\\n s+=1\\r\\n break\\r\\n j+=1\\r\\n i-=1\\r\\ns+=len(l)\\r\\nprint(s)"}
{"id": "1496", "input": "t=int(input())\\nfor i in range(0,t):\\n n=int(input())\\n lis=list(map(int,input().split()))\\n lis2=[]\\n for j in range(0,10):\\n lis2.append(0)\\n for j in range(0,len(lis)):\\n lis2[lis[j]]+=1;\\n s=sum(lis)\\n while s%3!=0:\\n if s%3==2:\\n if lis2[2]>=1:\\n lis2[2]-=1\\n s=s-2\\n elif lis2[5]>=1:\\n lis2[5]-=1\\n s=s-5\\n elif lis2[8]>=1:\\n lis2[8]-=1\\n s=s-8\\n elif lis2[1]>=2:\\n lis2[1]-=2\\n s=s-2\\n elif lis2[1]>=1 and lis2[4]>=1:\\n lis2[1]-=1\\n lis2[4]-=1\\n s=s-5\\n elif lis2[4]>=2:\\n lis2[4]-=2\\n s=s-8\\n elif lis2[1]>=1 and lis2[7]>=1:\\n lis2[1]-=1\\n lis2[7]-=1\\n s=s-8\\n elif lis2[4]>=1 and lis2[7]>=1:\\n lis2[4]-=1\\n lis2[7]-=1\\n s=s-11\\n elif lis2[7]>=2:\\n lis2[7]-=2\\n s=s-14\\n elif s%3==1:\\n", "gt": "if lis2[1]>=1:\\n lis2[1]-=1\\n s=s-1\\n elif lis2[4]>=1:\\n lis2[4]-=1\\n s=s-4\\n elif lis2[7]>=1:\\n lis2[7]-=1\\n s=s-7\\n elif lis2[2]>=2:\\n lis2[2]-=2\\n s=s-4\\n elif lis2[5]>=1 and lis2[2]>=1:\\n lis2[2]-=1\\n lis2[5]-=1\\n s=s-7\\n elif lis2[5]>=2:\\n lis2[5]-=2\\n s=s-10\\n elif lis2[2]>=1 and lis2[8]>=1:\\n lis2[2]-=1\\n lis2[8]-=1\\n s=s-10\\n elif lis2[8]>=1 and lis2[5]>=1:\\n lis2[8]-=1\\n lis2[5]-=1\\n s=s-13\\n elif lis2[8]>=2:\\n lis2[8]-=2\\n s=s-16\\n lis3=[]\\n for j in range(1,10):\\n if lis2[j]>=1:\\n for k in range(0,lis2[j]):\\n lis3.append(j)\\n lis3.reverse()\\n for k in range(0,lis2[0]):\\n lis3.append(0)\\n sol=''\\n for k in range(0,len(lis3)):\\n sol+=str(lis3[k])\\n print(sol)"}
{"id": "1497", "input": "# cook your dish here\\nMOD=10**9+7\\nfor _ in range(int(input())):\\n s=input()\\n ind=1\\n level=1\\n for i in range(len(s)):\\n if", "gt": "s[i]=='l':\\n if level%2==1:\\n ind=ind*2\\n else:\\n ind=ind*2-1\\n if s[i]=='r':\\n if level%2==1:\\n ind=ind*2+2\\n else:\\n ind=ind*2+1\\n level+=1\\n ind%=MOD\\n print(ind)\\n"}
{"id": "1498", "input": "for t in range(int(input())):\\n n = int(input())\\n mx = -1\\n for i in range(n):\\n h, m, s = list(map(int,input().split(\":\")))\\n h %= 12\\n m %= 60\\n s %= 60\\n ha = h*30 + m*0.5 + s*0.5/60\\n ma = m*6 + s*0.1\\n sa = s*6\\n \\n hm1 = abs(ha - ma)\\n hm2 = 360 - hm1\\n hm3 = abs(hm1 - hm2)\\n hm = min(hm1, hm2,", "gt": "hm3)\\n \\n ms1 = abs(ma - sa)\\n ms2 = 360 - ms1\\n ms3 = abs(ms1 - ms2)\\n ms = min(ms1, ms2, ms3)\\n \\n sh1 = abs(sa - ha)\\n sh2 = 360 - sh1\\n sh3 = abs(sh1 - sh2)\\n sh = min(sh1, sh2, sh3)\\n \\n avg = (hm + ms + sh) / 3\\n if (mx < avg):\\n ans = i+1\\n mx = avg\\n print(ans)"}
{"id": "1499", "input": "def Testcase():\\n h,x,y = [int(x) for x in input().strip().split()]\\n \\n h = h-1\\n yt = h//y +1\\n # print(yt)\\n flag=0\\n ans = 100000000009\\n \\n for i in range(0,yt):\\n temp", "gt": "= x+i*y\\n if h%temp==0:\\n flag = 1\\n cl =i+int(h/temp)\\n # print(temp,cl)\\n ans = min(ans,cl)\\n # print(temp,ans,i)\\n print(ans if flag==1 else '-1')\\n \\n \\nt = int(input())\\nwhile t>0:\\n Testcase()\\n \\n t-=1"}
{"id": "1500", "input": "from sys import stdin,stdout\\nimport math,bisect\\nfrom collections import Counter,deque,defaultdict\\nL=lambda:list(map(int, stdin.readline().strip().split()))\\nM=lambda:list(map(int, stdin.readline().strip().split()))\\nI=lambda:int(stdin.readline().strip())\\nS=lambda:stdin.readline().strip()\\nC=lambda:stdin.readline().strip().split()\\ndef pr(a):return(\" \".join(list(map(str,a))))\\n#_________________________________________________#\\n\\n\\ndef solve():\\n n, m = M()\\n a = []\\n for i in range(n):\\n a += [L()]\\n s = S()\\n p, q = M()\\n ans = [[0,0] for i in range(n+m)]\\n for i in range(n):\\n", "gt": "for j in range(m):\\n if a[i][j]==0:\\n ans[i+j][0]+=1\\n else:\\n ans[i+j][1]+=1\\n c = 0\\n for i in range(n+m-1):\\n A,B,C,D = 0,0,0,0\\n if s[i]=='0':\\n A = ans[i][1]*p\\n B = q + ans[i][0]*p\\n c+=min(A,B)\\n else:\\n C = ans[i][0]*p\\n D = q + ans[i][1]*p\\n c+=min(C,D)\\n print(c)\\nfor _ in range(I()):\\n solve()\\n"}
{"id": "1501", "input": "try:\\n for i in range(int(input())):\\n s=input()\\n balance=0\\n max_balance=0\\n for i in", "gt": "s:\\n if i=='(':balance+=1\\n else:\\n balance-=1\\n max_balance=max(max_balance,balance)\\n print('('*max_balance,')'*max_balance,sep=\"\")\\nexcept Exception as e:\\n print(e)\\n"}
{"id": "1502", "input": "import os,sys\\nfrom io import BytesIO, IOBase\\n\\ndef ii(): return int(input())\\ndef si(): return input()\\ndef mi(): return list(map(int,input().split()))\\ndef li(): return list(mi())\\nimport math \\n\\nimport collections \\n\\ndef CountFrequency(arr): \\n return collections.Counter(arr) \\n\\nfor i in range(1):\\n n,q=mi()\\n p=pow(2,n+1)-2 \\n t=1", "gt": "\\n b=pow(2,n)\\n s=n+1\\n for i in range(q):\\n a=li()\\n if len(a)==2:\\n if a[1]==1 or a[1]==2:\\n p*=2 \\n p+=s\\n t*=2 \\n b*=2\\n else:\\n p*=2 \\n if a[1]==3:\\n p+=t\\n t=b \\n s*=2\\n else:\\n p+=b\\n b=t\\n s*=2\\n else:\\n print(p%1000000007)\\n"}
{"id": "1503", "input": "t=int(input())\\r\\nfor _ in range(t):\\r\\n S=set(input().strip())\\r\\n n=int(input().strip())\\r\\n a=set(input().strip().split(\" \"))\\r\\n g=True\\r\\n for i", "gt": "in S:\\r\\n if(i not in a):\\r\\n g=False\\r\\n if(g):\\r\\n print(1)\\r\\n else:\\r\\n print(0)"}
{"id": "1504", "input": "# cook your dish here\\nimport math\\nN=int(input())\\nfor", "gt": "i in range(N):\\n a,b=list(map(int,input().split()))\\n c=a//math.gcd(a,b)*b//math.gcd(a,b)\\n print(c)\\n \\n"}
{"id": "1505", "input": "for _ in range(int(input())):\\n n,s = int(input()),input().strip()\\n previ,num,_s,dic = s[0],0,[],{}\\n for i in s:\\n if previ == i:\\n num+=1\\n continue\\n _s.append((previ, num))\\n if previ not in dic or dic[previ]<num:dic[previ] = num\\n previ,num = i,1\\n _s.append((previ, num))\\n if previ not in dic or dic[previ]<num:dic[previ] = num\\n sum1 = sum(dic.values())\\n del dic, s\\n l,dicc = [i", "gt": "for (i, j) in _s],"}
{"id": "1506", "input": "# cook your dish here\\n\\nT = int(input())\\nl = list(map(int, input().strip().split(\" \")))\\n\\ndepth = 0\\nmax_depth = 0\\nmax_depth_index = 0\\n\\nmax_l=0\\nmax_l_index=0\\nlast_zero=-1\\n\\nfor i in range(T):\\n if l[i] == 1:\\n depth += 1\\n if depth > max_depth:\\n max_depth = depth\\n max_depth_index =", "gt": "i + 1\\n else:\\n depth-=1\\n if depth == 0:\\n length = i - last_zero\\n if length > max_l:\\n max_l = length\\n max_l_index = last_zero + 2\\n last_zero = i\\n \\nprint(max_depth, max_depth_index, max_l, max_l_index)\\n\\n\"\"\"\\n2 4 6 9\\n\"\"\""}
{"id": "1507", "input": "import sys,os,io,time,copy,math,queue,bisect\\nfrom collections import deque\\nfrom functools import lru_cache\\n\\nif os.path.exists('input.txt'):\\n sys.stdin = open('input.txt', 'r')\\n sys.stdout = open('output.txt', 'w') \\n\\nsys.setrecursionlimit(100000000)\\n\\ndef main():\\n n,m=map(int,input().split())\\n mat=[]\\n for _ in range(n):\\n s=input()\\n a=[]\\n for i in s:\\n a.append(int(i))\\n mat.append(a)\\n \\n Q=int(input())\\n ans=[[0 for i in range(m+1)] for j in range(n+1)]\\n for i in range(Q):\\n", "gt": "x1,y1,x2,y2=map(int,input().split())\\n x1-=1\\n y1-=1\\n x2-=1\\n y2-=1\\n ans[x1][y1]+=1\\n ans[x2+1][y1]-=1\\n ans[x1][y2+1]-=1\\n ans[x2+1][y2+1]+=1\\n for j in range(m+1):\\n for i in range(1,n+1):\\n ans[i][j]=ans[i-1][j]+ans[i][j]\\n for i in range(n+1):\\n for j in range(1,m+1):\\n ans[i][j]=ans[i][j-1]+ans[i][j]\\n \\n for i in range(n):\\n for j in range(m):\\n mat[i][j]=(ans[i][j]+mat[i][j])%2\\n for m in mat:\\n for i in m:\\n print(i,end=\"\")\\n print(\"\")\\n\\n \\nmain()\\n"}
{"id": "1508", "input": "#dt = {} for i in x: dt[i] = dt.get(i,0)+1\\r\\nimport sys;input = sys.stdin.readline\\r\\ninp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]\\r\\n\\r\\nN = 100001\\r\\np = 998244353\\r\\nfactorialNumInverse = [0]*(N+1) \\r\\nnaturalNumInverse = [0]*(N+1)\\r\\nfact = [0]*(N+1)\\r\\n \\r\\ndef InverseofNumber(p): \\r\\n naturalNumInverse[0] = naturalNumInverse[1] = 1\\r\\n for i in range(2,N+1): \\r\\n naturalNumInverse[i] = (naturalNumInverse[p % i] * (p - (p // i)) % p)\\r\\n \\r\\ndef InverseofFactorial(p): \\r\\n factorialNumInverse[0] = factorialNumInverse[1] = 1\\r\\n for i in range(2,N+1): \\r\\n factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % p \\r\\n", "gt": "\\r\\ndef factorial(p): \\r\\n fact[0] = 1\\r\\n for i in range(1, N + 1): \\r\\n fact[i] = (fact[i - 1] * i) % p\\r\\n\\r\\ndef f(num,den1,den2):\\r\\n # n C r = n!*inverse(r!)*inverse((n-r)!) \\r\\n #ans = ((fact[N] * factorialNumInverse[R])% p * factorialNumInverse[N-R])% p\\r\\n ans = ((fact[num]*factorialNumInverse[den1])%p*factorialNumInverse[den2])%p\\r\\n return ans \\r\\n\\r\\nInverseofNumber(p) \\r\\nInverseofFactorial(p) \\r\\nfactorial(p)\\r\\n\\r\\nfor _ in range(inp()):\\r\\n n,m,x1,y1,x2,y2 = ip()\\r\\n tot = f(m+n,m,n)\\r\\n a = f(m-y1+n-x1,m-y1,n-x1)\\r\\n aa = f(x1+y1,x1,y1)\\r\\n b = f(m-y2+n-x2,m-y2,n-x2)\\r\\n bb = f(x2+y2,x2,y2)\\r\\n c = f(y2-y1+x2-x1,y2-y1,x2-x1)\\r\\n ans = (tot - a*aa - b*bb + c*aa*b)%p\\r\\n print(ans)"}
{"id": "1509", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n n=int(input())\\n if n==1:\\n print(\"0\")\\n else:\\n s=[]\\n", "gt": "for i in range(n):\\n s.append(str(i))\\n print(''.join(s))\\n p=1\\n for i in range(n-1):\\n s.pop(n-1)\\n s=[str(p)]+s\\n print(''.join(s))\\n p+=1\\n"}
{"id": "1510", "input": "#for _ in range(int(input()):\\n#n,m = map(int,input().split())\\n#x = [int(w) for w in input().split()]\\n#n = int(input())\\n#x = [int(input()) for _ in range(n)]\\n#for i in range(n):\\n#dt = {} for i in x:dt[i] = dt.get(i,0)+1\\n#dt = {k:v for k,v in sorted(x.items(), key=lambda i: i[1])}\\n\\nm,n = map(int,input().split()) # top,right,bottom,left\\nx = []\\nfor i in range(m):\\n x.append([])\\n for j in range(n):\\n clr = [w for w in input().split()]\\n x[i].append(clr)\\n\\nimport queue as Q \\ndp =", "gt": "[float('inf')]*m\\nfor i in range(m):\\n dp[i] = [float('inf')]*n\\ndp[m-1][n-1] = 0\\npq = Q.PriorityQueue()\\npq.put([dp[m-1][n-1],m-1,n-1])\\nvisited = set()\\nxx,yy = [-1,0,1,0],[0,1,0,-1] # top,right,bottom,left\\nwhile not pq.empty():\\n pop = pq.get()\\n cx,cy = pop[1],pop[2]\\n if (cx,cy) not in visited:\\n visited.add((cx,cy))\\n for k in range(4):\\n nx,ny = cx+xx[k],cy+yy[k]\\n if 0<=nx<m and 0<=ny<n and (nx,ny) not in visited:\\n clr = x[cx][cy][k]\\n #print(\"*\",nx,ny,\"_\",k,clr)\\n ind = x[nx][ny].index(clr)\\n cost = (k-(ind+2)%4)%4\\n #print(cost)\\n if dp[cx][cy]+cost < dp[nx][ny]:\\n dp[nx][ny] = dp[cx][cy]+cost\\n pq.put([dp[nx][ny],nx,ny])\\n #print(\"#############\")\\n#print(dp)\\nprint(dp[0][0])"}
{"id": "1511", "input": "for _ in range(int(input())):\\n s = input()\\n c = 0\\n for", "gt": "i in s:\\n if i.isalpha() and i.isupper():\\n c += 1\\n print(c)\\n"}
{"id": "1512", "input": "# cook your dish here\\n# cook your dish here\\nfor _ in range(int(input())) :\\n n,k=map(int,input().split())\\n #reading the string \\n s=input()\\n i,j=0,0\\n q=0\\n while(i<n and j<n) :\\n if(s[i]=='M') :\\n if(s[j]=='I') :\\n cnt=0\\n if(i>j)", "gt": ":\\n p=s[j:i]\\n cnt=p.count(':')\\n else :\\n p=s[i:j]\\n cnt=p.count(':')\\n t=k+1-abs(i-j)-cnt\\n if(t>0) :\\n q+=1\\n i+=1\\n j+=1\\n else:\\n if(i<j) :\\n i+=1\\n else:\\n j+=1\\n elif(s[j]=='X') :\\n j+=1\\n i=j\\n else:\\n j+=1\\n elif(s[i]=='X') :\\n i+=1\\n j=i\\n else:\\n i+=1\\n print(q)"}
{"id": "1513", "input": "cases = int(input())\\nfor _ in range(cases):\\n rows, cols = map(int, input().split())\\n if (cols - 1) % 3 == 0 and (rows - 1) % 4 == 0: print('Vanya')\\n elif (cols - 1) % 3 != 0 and (rows - 1) % 4 == 0: print('Tuzik')\\n elif (cols - 1)", "gt": "% 3 == 0 and (rows - 1) % 4 != 0: print('Tuzik')\\n else:\\n if (cols - 1) % 3 == 1 and (rows - 1) % 4 == 1: print('Vanya')\\n elif (cols - 1) % 3 == 2 and (rows - 1) % 4 == 2: print('Vanya')\\n else: print('Tuzik')"}
{"id": "1514", "input": "# cook your dish here\\ntry:\\n X=list(map(int, input().split()))\\nexcept:\\n X=[0,0]\\nch=[]\\nchnew=[]\\npar={}\\npar[1]=0\\nfor i in range(X[0]+1):\\n ch.append([])\\n chnew.append([])\\nfor i in range(X[0]-1):\\n Y=list(map(int, input().split()))\\n #par[Y[1]]=[Y[0],Y[2]]\\n ch[Y[0]].append([Y[1],Y[2]])\\n ch[Y[1]].append([Y[0],Y[2]])\\ntre=[1]\\nwhile(len(tre)):\\n cr=tre[-1]\\n tre=tre[:-1]\\n for i in ch[cr]:\\n chnew[cr].append(i)\\n par[i[0]]=[cr,i[1]]\\n tre.append(i[0])\\n for j in ch[i[0]]:\\n if(j[0]==cr):\\n ch[i[0]].remove(j)\\n break\\nch=chnew\\ndef goup(par,nd):\\n if(nd==1):\\n", "gt": "return 0\\n else:\\n p=par[nd]\\n ans=p[1]+goup(par,p[0])\\n return (max([ans,0]))\\n\\ndef godown(ch,nd):\\n ans=0\\n for i in ch[nd]:\\n ans=max([(i[1]+godown(ch,i[0])),ans])\\n return(ans)\\n\\nfor i in range(X[1]):\\n Z=list(map(int,input().split()))\\n r=Z[0]\\n s=Z[1]\\n nans=0\\n while(r!=s):\\n if(r>s):\\n nans=nans+par[r][1]\\n r=par[r][0]\\n else:\\n nans=nans+par[s][1]\\n s=par[s][0]\\n if((r==Z[0]) or (r==Z[1])):\\n if(Z[0]<Z[1]):\\n nans=nans+2*max(goup(par,Z[0]),godown(ch,Z[1]))\\n else:\\n nans=nans+2*max(goup(par,Z[1]),godown(ch,Z[0]))\\n else:\\n nans=nans+2*goup(par,r)\\n print(nans)"}
{"id": "1515", "input": "for _ in range(int(input())):\\n a,b,c,x,y,z = list(map(int,input().split()))\\n if a == 0 and b == 0 and c == 0 and x == 0 and y == 0 and z == 0:\\n print(0)\\n continue\\n ans = 0\\n if a == 0 and b == 0 and c == 0:\\n st = set((abs(x-a)%2,abs(y-b)%2,abs(z-c)%2))\\n", "gt": "if st =="}
{"id": "1516", "input": "for _ in range(int(input())):\\n string = input().rstrip()\\n start=(ord(string[0])-96)*100\\n", "gt": "sum=0\\n #print(start)\\n for i in range(len(string)):\\n sum+=start+(ord(string[i])-97)\\n print(sum%1000000007)"}
{"id": "1517", "input": "__author__ = 'Prateek'\\n\\nMOD = int(10**9+7)\\n\\ndef test():\\n n,k=list(map(int,input().split()))\\n l = k\\n d =n-1\\n ans = l-1\\n ans = ans%MOD\\n a = k-n\\n term = (d+a)//d\\n ll = (a%MOD - (((term-1)%MOD)*(d%MOD))%MOD)%MOD\\n if", "gt": "ll < 0:\\n ll = (ll +MOD)%MOD\\n m = ((term%MOD)*((a%MOD+ll%MOD)%MOD))%MOD\\n m = (m*pow(2,MOD-2,MOD))%MOD\\n ans += m\\n ans = ans%MOD\\n print(ans)\\n\\n\\nif __author__ == 'Prateek':\\n t = int(input())\\n for _ in range(t):\\n test()\\n"}
{"id": "1518", "input": "import sys\\nimport math\\n\\ndef solution():\\n T = int(input().strip())\\n for _ in range(T):\\n x, k = list(map(float, input().strip().split(' ')))\\n original_x = x\\n if k == 1:\\n a = [float(input().strip())]\\n b =", "gt": "[float(input().strip())]\\n else:\\n a = list(map(float, input().strip().split(' ')))\\n b = list(map(float, input().strip().split(' ')))\\n for i in range(int(k)):\\n x = x + (a[i]/b[i])*(x)\\n percentage = ((x - original_x) / x)*100\\n print(\"%d\"%(int(percentage)))\\n\\nsolution()"}
{"id": "1519", "input": "from math import sqrt\\n\\ndef isprime(n):\\n if (n % 2 == 0 and n > 2) or n == 1: return 0\\n else:\\n s = int(sqrt(n)) + 1\\n for i in range(3, s, 2):\\n if n % i == 0:\\n return 0\\n return 1\\n\\ndef find(N, K): \\n if", "gt": "(N < 2 * K): \\n return 0\\n if (K == 1): \\n return isprime(N) \\n if (K == 2): \\n if (N % 2 == 0): \\n return 1\\n return isprime(N - 2); \\n return 1\\n\\nfor _ in range(int(input())):\\n n, k = list(map(int, input().split()))\\n print(find(n, k))\\n\\n\\n"}
{"id": "1520", "input": "# cook your dish here\\nfor _ in range(int(input(''))):\\n", "gt": "n=int(input(''))\\n x=bin(n)\\n x=len(x)-2\\n if n==(2**(x-1)):\\n print(n)\\n else:\\n print(2**x)"}
{"id": "1521", "input": "# cook your dish here\\nn=int(input())\\nl=[int(i) for i in input().split()]\\nxors=[]\\nfor i in range(n):\\n for", "gt": "j in range(i+1,n):\\n xors.append([l[i]^l[j],(i,j)])\\nxors.sort()\\n\\n#print(xors)\\nupto=[0]*n \\nfor i in range(len(xors)):\\n #a=xors[i][0]\\n b,c=xors[i][1][0],xors[i][1][1]\\n upto[c]=max(upto[c],upto[b]+1)\\n \\n#print(upto)\\n \\nprint(max(upto)+1)"}
{"id": "1522", "input": "# cook your dish here\\nfrom operator import itemgetter\\nt=int(input())\\nfor _ in range(t):\\n n=int(input())\\n start=[]\\n end=[]\\n for i in range(n):\\n first, last = map", "gt": "(int, input().split())\\n start.append((first, i))\\n end.append((last, i))\\n score=[0]*n \\n start.sort(key=itemgetter(0))\\n end.sort(key=itemgetter(0), reverse=True)\\n for i in range(n-1):\\n score[start[i][1]]+=n-i-1\\n score[end[i][1]]+=n-i-1\\n print(' '.join([str(i) for i in score]))"}
{"id": "1523", "input": "def frequency(s,n):\\n f=[[0 for i in range(26)]for j in range(n+1)]\\n count=0\\n for i in range(n):\\n if s[i]!=\"#\":\\n f[count][ord(s[i])-97]+=1\\n else:\\n count+=1\\n for j in range(26):\\n f[count][j]=f[count-1][j]\\n return (f,count)\\n \\ndef solve(s):\\n n=len(s)\\n f,count=frequency(s,n)\\n if count<3:\\n return 0\\n ans=0\\n index=[]\\n for i in range(n-1,-1,-1):\\n if s[i]==\"#\":\\n index.append(i)\\n \\n", "gt": "for c in range(1,count-2+1):\\n if index[-2]==index[-1]+1 or index[-3]==index[-2]+1:\\n index.pop()\\n continue\\n left=max(f[c-1])\\n mid1=0\\n mid2=0\\n right=0\\n for j in range(26):\\n mid1=max(mid1,f[c][j]-f[c-1][j])\\n mid2=max(mid2,f[c+1][j]-f[c][j])\\n right=max(right,f[count][j]-f[c+1][j])\\n if left and mid1 and mid2 and right:\\n ans=max(ans,left+mid1+mid2+right)\\n index.pop()\\n return ans\\n \\nfor _ in range(int(input())):\\n s=input()\\n ans=solve(s)\\n if ans:\\n print(ans+3)\\n else:\\n print(0)\\n \\n"}
{"id": "1524", "input": "# cook your dish here\\nn=int(input())\\nl=list(map(int,input().split()))\\ntemp=[]\\nfor item in l:\\n", "gt": "temp.append(item)\\nif(n<=3):\\n print(sum(temp))\\nelse:\\n for i in range(3,n):\\n temp[i]=l[i]+min(temp[i-1],temp[i-2],temp[i-3])\\n res=sum(l)-min(temp[n-1],temp[n-2],temp[n-3])\\n print(res)"}
{"id": "1525", "input": "ways=x=0\\nval=10**9\\nremi=((10**9)+7)\\nt=int(input())\\nfor i in range(t):\\n n,k=list(map(int,input().split()))\\n if t<=100 and n>=1", "gt": "and k<=val:\\n x=(k-1)**(n-1)\\n ways=k*x\\n ways=ways%remi\\n print(ways)\\n x=ways=0\\n else:\\n break"}
{"id": "1526", "input": "import sys\\nt = int(sys.stdin.readline())\\n\\ndef identify(x, y):\\n rows[x][y] = '2'\\n\\n r = 0\\n if x == 0:\\n r |= 1\\n elif rows[x-1][y] == '1':\\n r |= identify(x-1, y)\\n if x == 7:\\n r |= 4\\n elif rows[x+1][y] == '1':\\n r |= identify(x+1, y)\\n if y == 0:\\n r |= 2\\n elif rows[x][y-1] == '1':\\n r |= identify(x, y-1)\\n if y == 7:\\n r |= 8\\n elif rows[x][y+1] == '1':\\n r |= identify(x, y+1)\\n return r\\n\\nP = 21945\\n\\nwhile t:\\n t-=1\\n n = int(sys.stdin.readline())-3\\n\\n rows = [list(sys.stdin.readline().strip()) for i in range(8)]\\n total = 0\\n for i in range(8):\\n for j in range(8):\\n if rows[i][j] == '1':\\n r = identify(i,j)\\n # print '\\n'.join([''.join(ro) for ro in rows])\\n # print r\\n if n == 0:\\n total += 1\\n # print total\\n continue\\n if r ==", "gt": "0:\\n total += pow(2, 2*n, P)\\n elif r == 1 or r == 2 or r == 4 or r == 8:\\n total += pow(2, 2*n-1, P)\\n if r == 1 or r == 2:\\n total += pow(2, n, P)\\n elif r == 5 or r == 10:\\n total += pow(2, n, P)\\n elif r == 3 or r == 6 or r == 12 or r == 9:\\n total += pow(2, 2*n-2, P)\\n if r == 3:\\n total += 3 + 2*pow(2, n-1, P) - 2\\n elif r == 6 or r == 9:\\n total += pow(2, n-1, P)\\n elif r == 15:\\n total += 1\\n else:\\n total += pow(2, n-1, P)\\n if r == 11 or r == 7:\\n total += 1\\n # print total\\n print(total % P)\\n"}
{"id": "1527", "input": "# v = [\"a\",\"e\",\"i\",\"o\",\"u\"]\\n# for _ in range(int(input())):\\n# n = int(input())\\n# a,b = [],[]\\n# for i in range(n):\\n# s = input()\\n# isa = True\\n# for j in range(1,len(s) - 1):\\n# if(s[j] in v):\\n# if(s[j - 1] not in v and s[j + 1] not in v):\\n# isa = False\\n# else:\\n# if(s[j - 1] not in v or s[j + 1] not in v):\\n# isa = False\\n# if(not isa):\\n# break\\n# if(s[0] not in v and s[1] not in v):\\n# isa = False\\n# if(s[-1] not in v and s[-2] not in v):\\n# isa = False\\n# if(isa):\\n# a.append(s)\\n# else:\\n# b.append(s)\\n# dicta,dictb = {},{}\\n# for i in a:\\n# freq = {}\\n# for j in i:\\n# if(j in freq):\\n# freq[j] += 1\\n# else:\\n# freq[j] = 1\\n# for j in freq:\\n# if(j not in dicta):\\n# dicta[j] = (1,freq[j])\\n# else:\\n# dicta[j] = (dicta[j][0] + 1,dicta[j][1] + freq[j])\\n# for i in b:\\n# freq = {}\\n# for j in i:\\n# if(j in freq):\\n# freq[j] += 1\\n# else:\\n# freq[j] = 1\\n# for j in freq:\\n# if(j not in dictb):\\n# dictb[j] = (1,freq[j])\\n# else:\\n# dictb[j] = (dictb[j][0] + 1,dictb[j][1] + freq[j])\\n# ans = 1\\n# for i in dicta:\\n# ans *= dicta[i][0]\\n# for i in dictb:\\n# ans /= dictb[i][0]\\n# x,y = 1,1\\n# for i in dictb:\\n# x *= dictb[i][1]\\n# for i in dicta:\\n# y *= dicta[i][1]\\n# alice,bob = len(a),len(b)\\n# for i in range(bob):\\n# while(alice > 0 and ans > 10**7):\\n# ans /= y\\n# alice", "gt": "-= 1\\n# ans *= x\\n# if(ans > 10**7 and alice == 0):\\n# break\\n# while(alice > 0):\\n# ans /= y\\n# if(ans < 1 and alice > 100):\\n# ans = 0\\n# break\\n# alice -= 1\\n# if(ans > 10**7):\\n# print(\"Infinity\")\\n# else:\\n# print(ans)\\n# #partailly correct [75 pts]\\n#sys.stdin.readline() and sys.stdout.write() are faster I/O methods than input() and print()\\nfrom sys import stdin\\nz=['a','i','e','o','u']\\nt=int(stdin.readline())\\nwhile(t>0):\\n t-=1\\n n=int(stdin.readline())\\n alice=[]\\n bob=[]\\n for j in range(n):\\n s=str(stdin.readline().strip(\"\\n\"))\\n # print(s)\\n isalice=True\\n for i in range(1,len(s)-1):\\n if(s[i] in z):\\n if(s[i-1] not in z and s[i+1] not in z):\\n isalice=False\\n else:\\n if(s[i-1] not in z or s[i+1] not in z):\\n isalice=False\\n if(not isalice):\\n break\\n if(s[0] not in z and s[1] not in z):\\n isalice=False\\n if(s[-1] not in z and s[-2] not in z):\\n isalice=False\\n if(isalice):\\n alice.append(s)\\n else:\\n bob.append(s)\\n ali="}
{"id": "1528", "input": "for j in range(int(input())):\\n a=input()\\n b=input()\\n c,d=0,0\\n a0=a.count(\"0\")\\n a1=a.count(\"1\")\\n if(a0==len(a) or a1==len(a)):\\n print(\"Unlucky", "gt": "Chef\")\\n else:\\n print(\"Lucky Chef\")\\n for i in range(len(a)):\\n if(a[i]!=b[i]):\\n if(a[i]==\"0\"):\\n c+=1\\n else:\\n d+=1\\n print(max(c,d))"}
{"id": "1529", "input": "t=int(input())\\nfor i in range(t):\\n n,k=[int(i) for i in input().split()]\\n l=input().split()\\n for i in range(k):\\n if l.pop()=='H':\\n", "gt": "for ind,j in enumerate(l):\\n if j=='H':\\n l[ind]='T'\\n else:\\n l[ind]='H'\\n print(sum([1 for i in l if i=='H']))"}
{"id": "1530", "input": "#cook your recipe\\nfrom math import factorial\\ntest_cases = int(input())\\nfor _ in range(test_cases):\\n n = int(input())\\n sum1 = 0\\n final_sum = 0\\n num = list(map(int, input().split()))\\n rep_time = factorial(n - 1)\\n rep_count = dict()\\n for i in num:\\n if i in", "gt": "rep_count:\\n rep_count[i] +=1\\n else:\\n rep_count[i] =1\\n for j in rep_count:\\n if rep_count[j] ==1:\\n sum1 += j * factorial(n - rep_count[j])\\n else:\\n sum1 += j * factorial(n-1)/ factorial(n - rep_count[j])\\n \\n for k in range(n):\\n final_sum += sum1 * (10**k)\\n\\n print(int(final_sum))"}
{"id": "1531", "input": "t = int(input())\\nfor _ in range(t):\\n n = int(input())\\n for", "gt": "i in range(n):\\n for j in range(n):\\n if i>=j:\\n print(int((i+1)*(i+2)/2)-j,end='')\\n print()\\n"}
{"id": "1532", "input": "n = int(input())\\nx = [int(i) for i in input().split()]\\nm = int(input())\\nfor i in range(m):\\n a,b = map(int,input().split())\\n a -= 1\\n t", "gt": "= b-1\\n t1 = x[a]-b\\n if a-1>=0:\\n x[a-1] += t\\n if a+1<n:\\n x[a+1] += t1\\n x[a] = 0\\nfor i in x:\\n print(i)"}
{"id": "1533", "input": "for t in range(int(input())):\\n n = int(input())\\n a = sorted(map(int,input().split()))\\n ans = 1\\n for", "gt": "i in range(n):\\n ans *= (a[i]-i)\\n ans %= (10**9+7)\\n if (ans == 0):\\n break\\n print(ans)"}
{"id": "1534", "input": "n,m,lk = list(map(int,input().split()))\\nsp = [int(i)-1 for i in input().split()]\\ndp = []\\nfor i in range(n):\\n dp += [[0]*n]\\nfor i in range(n):\\n for j in range(n):\\n if(i!=j):\\n dp[i][j]=10**18\\nfor _ in range(m):\\n", "gt": "x,y,z = list(map(int,input().split()))\\n dp[x-1][y-1]=z\\n dp[y-1][x-1]=z\\nfor k in range(n):\\n for i in range(n):\\n for j in range(n):\\n if(dp[i][j]>dp[i][k]+dp[k][j]):\\n dp[i][j]=dp[i][k]+dp[k][j]\\ndist = 10**18\\nfor i in range(lk):\\n for j in range(i+1,lk):\\n dist = min(dist,dp[sp[i]][sp[j]])\\nprint(dist)\\n"}
{"id": "1535", "input": "t=int(input())\\nwhile t>0 :\\n a=int(input())\\n b=int(input())\\n l=int(input())\\n x=0\\n y=0\\n z=0\\n a1=0\\n b1=0\\n c1=0\\n while(a//10!=0 or a%10!=0):\\n a1+=(a%10+((a//10)%10)*7+((a//100)%10)*49+((a//1000)%10)*343+((a//10000)%10)*2401+((a//100000)%10)*16807+((a//1000000)%10)*117649+((a//10000000)%10)*823543+((a//100000000)%10)*5764801+((a//1000000000)%10)*40353607)*(282475249**x)\\n x+=1\\n", "gt": "a//=10000000000\\n \\n while (b//10!=0 or b%10!=0):\\n b1+=(b%10+((b//10)%10)*7+((b//100)%10)*49+((b//1000)%10)*343+((b//10000)%10)*2401+((b//100000)%10)*16807+((b//1000000)%10)*117649+((b//10000000)%10)*823543+((b//100000000)%10)*5764801+((b//1000000000)%10)*40353607)*(282475249**y)\\n y+=1\\n b//=10000000000\\n c=(a1//b1)%(7**l)\\n while z<l:\\n c1+=(c%7+((c//7)%7)*10+((c//49)%7)*100+((c//343)%7)*1000+((c//2401)%7)*10000+((c//16807)%7)*100000+((c//117649)%7)*1000000+((c//823543)%7)*10000000+((c//5764801)%7)*100000000+((c//40353607)%7)*1000000000)*(10000000000**(z//10))\\n c//=282475249\\n z+=10\\n print(c1)\\n t-=1"}
{"id": "1536", "input": "# cook your dish here\\ndef solve(edges,ans):\\n n = len(edges)\\n visited = set()\\n parents = [-1]*(n+1)\\n dp = [0]*(n+1)\\n stack = [1]\\n w = float('inf')\\n x = -1\\n while stack:\\n node = stack[-1]\\n if node not in visited:\\n count = 0\\n for kid in edges[node]:\\n if parents[kid] == -1:\\n if kid != 1:\\n parents[kid] = node\\n else:\\n if kid != parents[node]:\\n if kid in visited:\\n count += 1\\n else:\\n stack.append(kid)\\n\\n if node == 1:\\n count -= 1\\n if count", "gt": "== len(edges[node])-1:\\n stack.pop()\\n visited.add(node)\\n max_val = 0\\n for kid in edges[node]:\\n dp[node] += dp[kid]\\n max_val = max(max_val,dp[kid])\\n\\n dp[node] += 1\\n\\n max_val = max(max_val,n-dp[node])\\n if max_val < w:\\n w = max_val\\n x = node\\n elif max_val == w:\\n x = min(x,node)\\n\\n ans.append(str(x)+' '+str(w))\\n \\ndef main():\\n t = int(input())\\n ans = []\\n for i in range(t):\\n n = int(input())\\n edges ="}
{"id": "1537", "input": "# cook your dish here\\ntest_cases = int(input())\\nfor i in range(test_cases):\\n no_of_elements = int(input())\\n sequence = list(map(int, input().split()))\\n d1 = sequence[1] - sequence[0]\\n d2 = sequence[2] - sequence[1]\\n d3 = (sequence[3] - sequence[0])/3\\n d4 = (sequence[3] - sequence[1])/2\\n d5 = (sequence[2] - sequence[0])/2\\n\\n if (d2 == d4):\\n d = d2\\n\\n elif(d3 ==", "gt": "d5):\\n d = d3\\n\\n elif(d1 == d3):\\n d = d1\\n\\n elif(d1 == d5):\\n d = d1\\n\\n if (d == d1):\\n for i in range(no_of_elements):\\n sequence[i] = int(sequence[0] + i*d)\\n else:\\n for i in range(no_of_elements):\\n sequence[i] = int(sequence[-1] - ((no_of_elements - i - 1)*d))\\n\\n for i in sequence:\\n print(i, end=\" \")\\n\\n print('\\n')\\n\\n\\n"}
{"id": "1538", "input": "import math\\r\\ndef prime(aa):\\r\\n f=0\\r\\n for y in ar:\\r\\n if aa%y==0:\\r\\n return 0\\r\\n return 1\\r\\nar=[]\\r\\nar.append(2)\\r\\npc=3\\r\\nte=int(input())\\r\\nfor _ in range(te):\\r\\n a=int(input())\\r\\n f=0\\r\\n c=0\\r\\n add=0\\r\\n for", "gt": "x in ar:\\r\\n try:\\r\\n add=add+ar[x-1]\\r\\n except:\\r\\n while True:\\r\\n if prime(pc)==1:\\r\\n ar.append(pc)\\r\\n if x<=len(ar):\\r\\n break\\r\\n pc+=1\\r\\n pc+=1\\r\\n add=add+ar[x-1]\\r\\n c+=1\\r\\n if c==a:\\r\\n break\\r\\n print(add)\\r\\n"}
{"id": "1539", "input": "# cook your dish here\\ndef GCD(x, y): \\n while y: \\n x, y = y, x % y \\n", "gt": "return x \\n\\ndef LCM(x, y):\\n lcm = (x*y)//GCD(x,y)\\n return lcm\\n\\nt = int(input())\\nwhile t>0:\\n x,y = list(map(int,input().split()))\\n print(GCD(x,y),LCM(x,y)) \\n t -=1\\n"}
{"id": "1540", "input": "n = int(input())\\nfor i in range(n):\\n count = 0\\n k = input()\\n x = list(k)\\n kk =", "gt": "input()\\n y = list(kk)\\n for j in y:\\n for jj in x:\\n if(j==jj):\\n count = count+1\\n break\\n print(count)"}
{"id": "1541", "input": "for _ in range(int(input())):\\n n = int(input())\\n", "gt": "k = int(input())\\n if k%n==0:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n"}
{"id": "1542", "input": "eps=1e-8\\nt=int(input())\\nfor ii in range(t):\\n n=int(input())\\n l=[int(i) for i in input().split() ]\\n b=[int(i) for i in input().split() ]\\n v=[int(i) for i in input().split() ]\\n c=[int(i) for i in input().split() ]\\n greatest_time=l[0]/v[0]\\n for i in range(1,n):\\n if v[i]>0:\\n greatest_time=min(greatest_time,(l[i]-b[i])/v[i])\\n elif v[i]<0:\\n greatest_time=min(greatest_time,-b[i]/v[i])\\n p = sum((b[i] - c[i]) ** 2 for i in range(n))\\n q = sum(2 * (b[i] -", "gt": "c[i]) * v[i] for i in range(n))\\n r = sum(vi ** 2 for vi in v)\\n func = lambda t: p/t/t + q/t + r\\n #ternary search\\n \\n def ternsearch():\\n \\n if b==c:\\n return(0)\\n \\n lo,hi=0,greatest_time\\n while hi-lo>eps:\\n d=(hi-lo)/3\\n m1=lo+d\\n m2=m1+d\\n if func(m1)<=func(m2):\\n hi=m2\\n else:\\n lo=m1\\n #print(hi,lo)\\n #print(func(lo)**(0.5))\\n return max(0,func(lo))**(0.5)\\n ans=ternsearch()\\n print('%.12f' % (ans,))\\n \\n \\n\\n \\n \\n\\n"}
{"id": "1543", "input": "# cook your dish here\\ntry:\\n \\n T = int(input())\\n\\n for i in range(T):\\n n = int(input())\\n s = input()\\n arr = [int(i) for i in input().strip().split(\" \")]\\n res = 1\\n result = 0\\n\\n for j in range(n-7):\\n res = 1\\n res1= 0\\n s1 = s[j:j+8]\\n for i in range(8):\\n if s1[i] == 'D':\\n", "gt": "res = res*2\\n res1 += arr[i]\\n\\n elif s1[i] == 'T':\\n res = res*3\\n res1 = res1 + arr[i]\\n elif s1[i] == 'd':\\n res1 = res1 + arr[i]*2\\n elif s1[i] == 't':\\n res1 += arr[i]*3\\n else:\\n res1 += arr[i]\\n res = res*res1\\n result = max(res,result)\\n print(result)\\nexcept EOFError:\\n pass\\n\\n \\n \\n \\n \\n \\n \\n"}
{"id": "1544", "input": "# cook your dish here\\n# cook your dish here\\nfor _ in range(int(input())):\\n n,m=list(map(int,input().split()))\\n atomlist = ['']*n\\n for k", "gt": "in range(m):\\n s=[]\\n s.extend(input().split()[1:])\\n #print(s)\\n for w in range(n):\\n if str(w) in s:\\n atomlist[w]+=\"1\"\\n else:\\n atomlist[w]+=\"0\"\\n #print(atomlist)\\n print(len(set(atomlist)))\\n"}
{"id": "1545", "input": "# cook your dish here\\ndef solve():\\n n=int(input())\\n i=0\\n while i<n-1:\\n if i==0:\\n print(\"*\",end=\"\")\\n else:\\n print(\"*\",end=\"\")\\n for k in", "gt": "range(i-1):\\n print(\" \",end=\"\")\\n print(\"*\",end=\"\")\\n print() \\n i+=1 \\n for i in range(n):\\n print(\"*\",end=\"\")\\n print() \\n\\nt=int(input())\\ni=0\\nwhile(i<t):\\n solve()\\n \\n i+=1"}
{"id": "1546", "input": "for i in range(eval(input())):\\n", "gt": "n,k=input().strip().split()\\n n=int(n)\\n k=int(k)\\n print(int( ((n-k)&(int((k-1)/2)))==0))"}
{"id": "1547", "input": "# cook your dish here\\ndef check(a,b,c):\\n if (a==0) or (b==0) or (c==0):\\n return \"NO\"\\n else:\\n i=3\\n while(i>0):\\n if", "gt": "(a*a)==(b*b)+(c*c):\\n return \"YES\"\\n else:\\n t=a\\n a=b\\n b=c\\n c=t\\n i-=1\\n return \"NO\"\\ntry:\\n for _ in range(int(input())):\\n a,b,c=map(int,input().split())\\n print(check(a,b,c))\\nexcept:\\n print(e)\\n pass"}
{"id": "1548", "input": "# cook your dish here\\ntry:\\n d1,v1,d2,v2,p=map(int, input().split())\\n total=0\\n while p>0:\\n", "gt": "total+=1\\n if total>=d1:\\n p=p-v1\\n if total>=d2:\\n p=p-v2\\n print(total) \\nexcept:\\n pass"}
{"id": "1549", "input": "# cook your dish here\\nT=int(input())\\nfor _ in range(T):\\n n=int(input())\\n arr=list(map(int,input().split()))\\n left=[-1 for i in range(n)]\\n right=[-1 for i in range(n)]\\n", "gt": "min1=float(\"inf\")\\n for i in range(n):\\n min1=min(arr[i],min1+1)\\n left[i]=min1\\n min1=float(\"inf\")\\n for i in range(n-1,-1,-1):\\n min1=min(arr[i],min1+1)\\n right[i]=min1\\n for i in range(n):\\n print(min(left[i],right[i]),end=\" \")\\n print(\"\",end=\"\\n\")"}
{"id": "1550", "input": "# cook your dish here\\nimport copy\\nfor _ in range(int(input())):\\n k=int(input())\\n c=[]\\n d=[]\\n start=0\\n\\n while True:\\n c=[]\\n for i in range(start):\\n", "gt": "c.append(\" \")\\n for i in range(start,k+1):\\n c.append(str(i))\\n start+=1\\n d.append(c)\\n\\n if start>k:\\n break\\n\\n e=copy.copy(d[1:])\\n d.reverse()\\n d=d+e\\n ##print(d)\\n for i in range(len(d)):\\n print(''.join(d[i]))\\n\\n\\n"}
{"id": "1551", "input": "# Python3 program to find XNOR\\n# of two numbers\\nimport math\\n\\n\\ndef swap(a, b):\\n temp = a\\n a = b\\n b = temp\\n\\n\\n# log(n) solution\\ndef xnor(a, b):\\n # Make sure a is larger\\n if (a < b):\\n swap(a, b)\\n\\n if (a == 0 and b == 0):\\n return 1;\\n\\n # for last bit of a\\n a_rem = 0\\n\\n # for last bit of b\\n b_rem = 0\\n\\n # counter for count bit and\\n # set bit in xnor num\\n count = 0\\n\\n # for make new xnor number\\n xnornum = 0\\n\\n # forset bits in new xnor\\n # number\\n while (a != 0):\\n\\n # get last bit of a\\n a_rem = a & 1\\n\\n # get last bit of b\\n b_rem = b & 1\\n\\n # Check if current two\\n # bits are same\\n if (a_rem == b_rem):\\n xnornum |= (1 << count)\\n\\n # counter for count bit\\n count = count + 1\\n\\n a = a >> 1\\n b = b >> 1\\n\\n return xnornum;\\n\\n\\nt= int(input())\\nfor o in range(t):\\n a,b,n=map(int,input().split())\\n c=a^b\\n", "gt": "x=bin(c)\\n x=x.split(\"b\")\\n x=x[1]\\n x=len(x)\\n d=xnor(a,b)\\n p=[a,b,c];"}
{"id": "1552", "input": "# cook your dish here\\nimport re\\nt=int(input())\\nwhile(t>0):\\n s=list(input().split(' '))\\n", "gt": "if(\"not\" in s):\\n print(\"Real Fancy\")\\n else:\\n print(\"regularly fancy\")\\n t=t-1"}
{"id": "1553", "input": "import sys\\n\\nn = int(sys.stdin.readline())\\n\\nfor _ in range(n):\\n p1, p2, m = list(map(int, sys.stdin.readline().split()))\\n\\n l = min(p1, p2)\\n\\n #while(m > 0 and l > 0):\\n # k = min(l, m)\\n", "gt": "# l -= k\\n # m -= 1\\n\\n q = min(p1, p2)\\n d = min((m * (m + 1)) / 2, q)\\n\\n print(p1 - d + p2 - d)"}
{"id": "1554", "input": "# cook your dish here\\nfrom sys import stdin\\nn, m = map(int,stdin.readline().split())\\nforest=[]\\nmatrix=[]\\nfor _ in range(n):\\n forest.append(list(map(int,stdin.readline().split())))\\n matrix.append([0]*m)\\nmatrix[0][0]=forest[0][0]\\nfor j in range(1,m):\\n matrix[0][j]=matrix[0][j-1]+forest[0][j]\\nfor i in range(1,n):\\n matrix[i][0]=matrix[i-1][0]+forest[i][0]\\nfor i in range(1,n):\\n for j in range(1,m):\\n", "gt": "matrix[i][j]=matrix[i-1][j]+matrix[i][j-1]-matrix[i-1][j-1]+forest[i][j]\\nc=int(input())\\nfor _ in range(c):\\n x1, y1, x2, y2 = map(int,stdin.readline().split())\\n x1-=1 \\n y1-=1 \\n x2-=1 \\n y2-=1 \\n appo=0\\n if x1>0:\\n appo+=matrix[x1-1][y2]\\n if y1>0:\\n appo+=matrix[x2][y1-1]\\n if x1>0 and y1>0:\\n appo-=matrix[x1-1][y1-1]\\n print(matrix[x2][y2]-appo)"}
{"id": "1555", "input": "from math import *\\nt=int(input())\\nfor i", "gt": "in range(t):\\n m,b=input().split()\\n m=int(m)\\n b=int(b)\\n print(2*gcd(m,b))"}
{"id": "1556", "input": "# cook your dish here\\ntry:\\n for t in", "gt": "range(int(input())):\\n n=int(input())\\n ans=n*n*n+((n-1)**2)\\n if ans<=10**9+7:\\n print(ans)\\n else:\\n print(ans)%(10**9+7)\\nexcept:\\n pass"}
{"id": "1557", "input": "for _ in range(int(input())):\\n n = int(input())\\n num = \"\"\\n val = 1\\n for i in range(n):\\n num +=", "gt": "str(val)\\n if val == 1:\\n val = 0\\n else:\\n val = 1\\n for i in range(n):\\n print(num)\\n \\n \\n"}
{"id": "1558", "input": "for _ in range(int(input())):\\n length = int(input())\\n S = input()\\n", "gt": "R = input()\\n if S.count(\"1\") == R.count(\"1\"):\\n print(\"YES\")\\n else:\\n print(\"NO\")"}
{"id": "1559", "input": "\"\"\"\\nCode chef problem DESTCELL, Destroy Cells\\n\"\"\"\\n\\n\\ndef find_destroyed_cells(cell_advance, n, m, k):\\n row = 1\\n col = 1\\n destroyed_cells = {(1, 1)}\\n while True:\\n row, col = cell_advance(row, col, n, m, k)\\n if row <= n and col <= m:\\n destroyed_cells.add((row, col))\\n else:\\n break\\n return destroyed_cells\\n\\n\\ndef cell_advance_hero1(row, col, n, m, k):\\n return row + (col + k) // m, (col + k) % m + 1\\n\\n\\ndef cell_advance_hero2(row, col, n,", "gt": "m, k):\\n return (row + k) % n + 1, col + (row + k)//n\\n\\n\\ndef main():\\n t = int(input())\\n for _ in range(t):\\n n, m = [int(s) for s in input().split(' ')]\\n counts = []\\n for k in range(n*m):\\n cells_h1 = find_destroyed_cells(cell_advance_hero1, n, m, k)\\n cells_h2 = find_destroyed_cells(cell_advance_hero2, n, m, k)\\n\\n destroyed = len(cells_h1) + len(cells_h2) - len(cells_h1 & cells_h2)\\n counts.append(destroyed)\\n print(' '.join([str(c) for c in counts]))\\n\\n\\nmain()\\n"}
{"id": "1560", "input": "r = 1000000007\\nt = int(input())\\nfor i in", "gt": "range(t):\\n n = int(input())\\n print(pow(3,n,r) + pow(-1,n)*3)\\n \\n"}
{"id": "1561", "input": "fact = []\\nfact.append(1)\\nfor i in range(1,100001):\\n fact.append((i*fact[i-1])%1000000007)\\n \\ndef power(a,b,p):\\n x=1\\n y=a\\n while(b>0):\\n if(b%2 == 1):\\n x=(x*y)\\n if(x>p):\\n x=x%p\\n y=(y*y)\\n if(y>p):\\n y=y%p\\n b=b/2\\n \\n return x\\n \\ndef inverse(N,p):\\n return power(N,p-2,p)\\n \\ndef combination(N,R,p):\\n return (fact[N]*((inverse(fact[R],p)*inverse(fact[N-R],p))%p))%p\\n \\nT = int(input())\\n \\nfor i in range(T):\\n N,K = [int(y) for y in input().split()]\\n A = [int(arr) for arr in input().split()]\\n numZ = 0;\\n answer = 0;\\n p = 1000000007\\n for j in range(len(A)):\\n if(A[j] == 0):\\n numZ = numZ + 1\\n N = N- numZ\\n if(numZ > 0):\\n if(N > K):\\n temp = K;\\n while(temp >= 0):\\n answer = answer + combination(N,temp,p)\\n temp = temp - 1\\n else:\\n temp = N\\n while(temp", "gt": ">= 0):\\n answer = answer + combination(N,temp,p)\\n temp = temp - 1\\n else:\\n if(N > K):\\n temp = K;"}
{"id": "1562", "input": "x=int(input())\\nfor a in range(x):\\n n=int(input())\\n L=[str(n)]\\n c=1\\n while(len(L)!=n):\\n", "gt": "L.append(str(n+c))\\n if len(L)==n:\\n break\\n L.append(str(n-c))\\n\\n c+=1\\n\\n a=\" \".join(L)\\n\\n print(a)\\n"}
{"id": "1563", "input": "t = int(input())\\n\\ndef conv(n):\\n k = bin(n)\\n k = k[2:]\\n z = len(k)\\n c = '1'*z\\n if c == k:\\n return False\\n\\ndef find(n):\\n\\n x", "gt": "= bin(n)[2:]\\n str = ''\\n for i in x[::-1]:\\n if i == '0':\\n str+='1'\\n break\\n else:\\n str+='0'\\n\\n return int(str[::-1],2)\\n\\nfor i in range(t):\\n\\n n = int(input())"}
{"id": "1564", "input": "n = int(input())\\nfor index in range(0, n):\\n a, b = list(map(str, input().split()))\\n a", "gt": "= int(a[::-1])\\n b = int(b[::-1])\\n a = str(a + b)\\n a = int(a[::-1])\\n print(a)"}
{"id": "1565", "input": "#import set\\nt = eval(input()) \\nwhile(t):\\n s = input()\\n set1 = set()\\n j = 0\\n for i", "gt": "in s[:-1]:\\n a = s[j:j+2]\\n set1.add(a)\\n j = j + 1\\n print(str(len(set1)) + '\\n')\\n t= t-1\\n \\n"}
{"id": "1566", "input": "# Problem: http://www.codechef.com/JULY09/submit/CUBESUM/ \\n# Author: Susam Pal\\n\\ndef computeA():\\n X, Y, Z = [int(x) for x in input().split()]\\n B = []\\n for x in range(X):\\n B.append([])\\n for y in range(Y):\\n B[-1].append([int(t) for t in input().split()])\\n for z in range(Z):\\n result = B[x][y][z]\\n if x:\\n result -= B[x - 1][y][z]\\n if y:\\n result += B[x - 1][y", "gt": "- 1][z]\\n if z:\\n result -= B[x - 1][y - 1][z - 1]\\n \\n if y:\\n result -= B[x][y - 1][z]\\n if z:\\n result += B[x][y - 1][z - 1]\\n if z:\\n result -= B[x][y][z - 1]\\n if x:\\n result += B[x - 1][y][z - 1]\\n print(result, end=' ')\\n print()\\n\\ntest_cases = int(input())\\nfor i in range(test_cases):\\n computeA()\\n"}
{"id": "1567", "input": "import sys\\nsys.setrecursionlimit(1000000)\\n\\nmod = 10**9 + 7\\nts = int(input())\\nwhile ts > 0:\\n n,q = list(map(int,input().split()))\\n ncc = n-1\\n par = [i for i in range(n)]\\n rank = [1]*n\\n xor = [0]*n\\n flag = 1\\n\\n def find(a):\\n if par[a] == a:\\n return a\\n else:\\n temp = find(par[a])\\n xor[a]^=xor[par[a]]\\n par[a] = temp\\n return temp\\n\\n def union(a,b): \\n a,b = find(a),find(b)\\n if a ==b:\\n return \\n if rank[a] > rank[b]:\\n par[b] = a\\n\\n rank[a]+=rank[b]\\n elif rank[a] < rank[b]:\\n par[a] = b\\n rank[b]+=rank[a]\\n else:\\n par[b] = a\\n", "gt": "rank[a]+=rank[b]\\n par[b] =a\\n\\n for _ in range(q):\\n \\n a,b,x = list(map(int,input().split()))\\n a-=1\\n b-=1\\n if flag == -1:\\n continue\\n para = find(a)\\n parb = find(b)\\n\\n if para == parb and xor[a] ^ xor[b] != x:\\n flag = -1 \\n continue\\n # print(\"no\")\\n\\n if para != parb:\\n if rank[para] < rank[parb]:\\n xor[para] = xor[a] ^ xor[b] ^ x\\n par[para] = parb\\n rank[parb]+=rank[para]\\n else:\\n xor[parb] = xor[a] ^ xor[b] ^ x\\n par[parb] = para\\n rank[para]+=rank[parb]\\n ncc-=1\\n \\n if flag != -1:\\n print(\"yes\")\\n else:\\n print(\"no\")\\n \\n ts-=1"}
{"id": "1568", "input": "for _ in range(int(input())):\\n n=int(input())\\n s=input()\\n d={}\\n for j in s:\\n if j not in d:\\n d[j]=1\\n else:\\n d[j]+=1\\n", "gt": "f=0\\n for j in d:\\n if(d[j]%2==1):\\n f=f+1\\n if((n//2)%2==0 and f==0):\\n print(\"YES\")\\n continue\\n if((n//2)%2==1 and f<=2 and f%2==0):\\n print(\"YES\")\\n continue\\n print(\"NO\")"}
{"id": "1569", "input": "t=int(input())\\r\\nfor _ in range(t):\\r\\n size=int(input())\\r\\n li=list(map(int,input().split()))\\r\\n c = 0\\r\\n", "gt": "for i in li:\\r\\n if(i >=len(li)/2):\\r\\n c += 1\\r\\n print(c)\\r\\n"}
{"id": "1570", "input": "# cook your dish here\\nimport sys\\nimport math\\nfrom collections import Counter\\nfrom collections import OrderedDict \\ndef inputt():\\n return sys.stdin.readline().strip()\\ndef printt(n):\\n sys.stdout.write(str(n)+'\\n')\\ndef listt():\\n return [int(i) for i in inputt().split()]\\ndef gcd(a,b): \\n return math.gcd(a,b) \\n \\ndef lcm(a,b): \\n return (a*b) / gcd(a,b) \\nfrom collections import defaultdict \\n\\ndef find_sub_string(str): \\n str_len = len(str) \\n \\n # Count all distinct characters. \\n dist_count_char = len(set([x for x in str])) \\n \\n ctr, start_pos, start_pos_index, min_len = 0, 0, -1, 9999999999\\n curr_count = defaultdict(lambda: 0) \\n for i in range(str_len):", "gt": "\\n curr_count[str[i]] += 1\\n \\n if curr_count[str[i]] == 1: \\n ctr += 1\\n \\n if ctr == dist_count_char: \\n while curr_count[str[start_pos]] > 1: \\n if curr_count[str[start_pos]] > 1: \\n curr_count[str[start_pos]] -= 1\\n start_pos += 1\\n \\n len_window = i - start_pos + 1\\n if min_len > len_window: \\n min_len = len_window \\n start_pos_index = start_pos \\n return str[start_pos_index: start_pos_index + min_len]\\nt= int(inputt())\\nfor _ in range(t):\\n j=[]\\n str1 =inputt()\\n s=find_sub_string(str1) \\n for i in s:\\n j.append(abs(97-ord(i))+1)\\n st = [str(i) for i in j]\\n print(''.join(st)) \\n\\n\\n"}
{"id": "1571", "input": "# cook your dish here\\n \\nt = int(input())\\n\\nwhile t:\\n m = int(input())\\n print(int(m * (m", "gt": "+ 1) * (2 * m + 1) / 6))\\n \\n \\n t -= 1"}
{"id": "1572", "input": "# cook your dish here\\nimport math\\nT = int(input())\\nfor _ in range(T):\\n N, A, K = map(int, input().split(\" \"))\\n total = (N-2) * 180\\n diffT =", "gt": "total - N*A\\n diffN = sum(range(1,N))\\n r = (A*diffN+(K-1)*diffT)\\n \\n d = math.gcd(r, diffN)\\n while d > 1:\\n r//=d\\n diffN//=d\\n d = math.gcd(r, diffN)\\n print(r, diffN)"}
{"id": "1573", "input": "import sys\\r\\nfrom collections import defaultdict\\r\\ninput = sys.stdin.readline\\r\\nsys.setrecursionlimit(1000000)\\r\\n\\r\\narr=[int(x) for x in input().split()]\\r\\n\\r\\nif arr[0]==1:\\r\\n print(0)\\r\\n return\\r\\n\\r\\np=[None]\\r\\nfor i in range(1,arr[0]+1):\\r\\n p.append(arr[i])\\r\\n \\r\\na=[None]\\r\\nfor i in range(arr[0]+1,2*arr[0]+1):\\r\\n a.append(arr[i])\\r\\n\\r\\ngraph=defaultdict(list)\\r\\n\\r\\nn=len(a)-1\\r\\nfor i in range(1,n+1):\\r\\n if a[i]==-1:\\r\\n", "gt": "source=i\\r\\n continue\\r\\n graph[a[i]].append((i,(p[a[i]]-p[i])))\\r\\n\\r\\ndef func(node):\\r\\n nonlocal res\\r\\n \\r\\n if len(graph[node])==0:\\r\\n return -10**9\\r\\n \\r\\n curr=-10**9\\r\\n for child in graph[node]:\\r\\n x=max(child[1],(func(child[0])+child[1]))\\r\\n curr=max(curr,x)\\r\\n res=max(curr,res)\\r\\n \\r\\n return curr \\r\\n\\r\\nres=-10**9\\r\\ncurr=func(source)\\r\\nprint(res) \\r\\n \\r\\n \\r\\n \\r\\n"}
{"id": "1574", "input": "# cook your dish here\\na = int(input())\\nfor i in range(a):\\n n = int(input())\\n if n%2==0:\\n print('NO')\\n else:\\n print('YES')\\n for", "gt": "i1 in range(n):\\n li = [0]*n\\n b = str()\\n for i2 in range((n-1)//2):\\n li[(i1+i2+1)%n]+=1\\n for i3 in range(len(li)):\\n b+=str(li[i3])\\n print(b)"}
{"id": "1575", "input": "def f(n):\\n\\n s = list(map(int, input().split()))\\n low = []\\n high = []\\n\\n for i in range(n - 1):\\n low.append(min(s[i], s[i+1]))\\n high.append(max(s[i], s[i+1]))\\n low.sort()\\n high.sort()\\n curr = mx = 0\\n i = j = 0\\n n -=", "gt": "1\\n while i < n and j < n:\\n if low[i] < high[j]:\\n i += 1\\n curr += 1\\n else:\\n j += 1\\n curr -= 1\\n mx = max(mx, curr)\\n\\n return mx \\n \\nn = int(input())\\nprint(f(n))"}
{"id": "1576", "input": "for _ in range(int(input())):\\n m=int(input())\\n n=int(input())\\n o=int(input())\\n", "gt": "ans=4*(m+n+o)-24\\n if(ans <= 0):\\n print('0')\\n else:\\n print(ans)\\n"}
{"id": "1577", "input": "# cook your dish here\\nfor a0 in range(int(input())):\\n n = int(input())\\n l = []\\n for i in range(1,n+1):\\n l.append(i)\\n", "gt": "\\n for j in range(n):\\n s = \"\"\\n for k in l:\\n s+=str(k)\\n print(s)\\n x = l[0]\\n l.pop(0)\\n l.append(x)\\n"}
{"id": "1578", "input": "class Dsu:\\n def __init__(self, v, s):\\n self.par = s\\n self.v = v\\n self.dr = [1] * v\\n self.zero = [False] * v\\n self.speed = []\\n for i in range(v):\\n self.speed.append([])\\n self.speed[i].append(i)\\n\\n def find(self, i):\\n # if parent[i] == -1:\\n # return i\\n # else: return self.find_parent(parent, parent[i])\\n if i != self.par[i][0]:\\n org = self.par[i][0]\\n self.par[i][0] = self.find(self.par[i][0])\\n if self.zero[i] or self.zero[self.par[i][0]] or self.zero[org]:\\n self.zero[i] = self.zero[self.par[i][0]] = self.zero[org] = True\\n if org != self.par[i][0]:\\n self.speed[self.par[i][0]].append(i)\\n return self.par[i][0]\\n\\n def union(self, x, y):\\n # def union(self, parent, x, y):\\n # x_set = self.find_parent(parent, x)\\n # y_set = self.find_parent(parent, y)\\n # parent[x_set] = y_set\\n self.rx = self.find(x)\\n self.ry = self.find(y)\\n self.sign = -self.dr[x] * self.dr[y]\\n if self.rx != self.ry:\\n if (self.par[self.rx][1]<self.par[self.ry][1]):\\n mx=self.ry\\n mn=self.rx\\n if (self.par[self.rx][1]>self.par[self.ry][1]):\\n mx=self.rx\\n mn=self.ry\\n if self.par[self.rx][1] != self.par[self.ry][1]:\\n self.par[mn][0] = mx\\n if self.zero[mn] or self.zero[mx] or self.zero[x] or self.zero[y]:\\n self.zero[mn] = self.zero[mx] = self.zero[x] = self.zero[y] = True\\n else:\\n for i in range(len(self.speed[mn])):\\n self.dr[self.speed[mn][i]] *= self.sign\\n org = self.par[self.speed[mn][i]][0]\\n if org != mx:\\n self.par[self.speed[mn][i]][0] = mx\\n self.speed[mx].append(self.speed[mn][i])\\n self.speed[mx].append(mn)\\n\\n else:\\n", "gt": "self.par[self.ry][0] = self.rx\\n self.par[self.rx][1] += 1\\n if self.zero[self.rx] or self.zero[self.ry] or self.zero[x] or self.zero[y]:\\n self.zero[self.rx] = self.zero[self.ry] = self.zero[x] = self.zero[y] = True\\n else:\\n for i in range(len(self.speed[self.ry])):\\n self.dr[self.speed[self.ry][i]] *= self.sign\\n org = self.par[self.speed[self.ry][i]][0]\\n if org != self.rx:\\n self.par[self.speed[self.ry][i]][0] = self.rx\\n self.speed[self.rx].append(self.speed[self.ry][i])\\n self.speed[self.rx].append(self.ry)\\n else:\\n return\\n\\n\\ndef optwo(x, y, D):\\n if (D.find(x) == D.find(y) and D.dr[x] == D.dr[y]):\\n D.zero[x] = D.zero[y] = True\\n D.union(x, y)\\n\\n\\ndef gcd(a, b):\\n if a == 0:\\n return b\\n else:\\n return gcd(b % a, a)\\n\\n\\ndef opthree(x, y, v, D):\\n if (D.find(x) != D.find(y)) or (D.zero[D.par[y][0]]):\\n print(0)\\n else:\\n g = gcd(v * speed[x], speed[y])\\n flag=(D.dr[x] * D.dr[y])//abs(D.dr[x] * D.dr[y])\\n print(str(flag * v * speed[x] // g) + \"/\" + str(speed[y] // g))\\n\\n\\nn, M = map(int, input().split())\\nspeed = list(map(int, input().split()))\\ns = []\\nfor i in range(n):\\n s.append([i, 0])\\nD = Dsu(n, s)\\nfor i in range(M):\\n T = list(map(int, input().split()))\\n if (T[0] == 1):\\n speed[T[1] - 1] = T[2]\\n elif (T[0] == 2):\\n optwo(T[1] - 1, T[2] - 1, D)\\n elif (T[0] == 3):\\n opthree(T[1] - 1, T[2] - 1, T[3], D)\\n"}
{"id": "1579", "input": "for _ in range(eval(input())):\\n s = input()\\n ans = 0\\n", "gt": "for i in s:\\n if i.isdigit():\\n ans += int(i)\\n print(ans)"}
{"id": "1580", "input": "for _ in range(int(input())):\\n n = int(input())\\n arr = list(map(int,input().split()))\\n\\n if n<=62:\\n st = set()\\n\\n for i in range(n):\\n", "gt": "curr = 0\\n for j in range(i,n):\\n curr = curr|arr[j]\\n\\n st.add(curr)\\n \\n if len(st)==n*(n+1)//2:\\n print(\"YES\")\\n else:\\n print(\"NO\")\\n \\n else:\\n print(\"NO\")"}
{"id": "1581", "input": "import sys\\nt=int(input())\\nx=sys.stdin.readlines()\\nl=[]\\nfor s in x:\\n s=s.replace(\".\",\"\")\\n s=s.replace(\"'\",\"\")\\n s=s.replace(\",\",\"\")\\n s=s.replace(\":\",\"\")\\n s=s.replace(\";\",\"\")\\n lst=[str(i) for i in s.split()]\\n for j in lst:\\n", "gt": "l.append(j)\\nm=[]\\nfor y in l:\\n z=y.lower()\\n m.append(z)\\nn=[]\\nfor k in m:\\n if(k in n):\\n continue\\n else:\\n n.append(k)\\nprint(len(n))\\nh=sorted(n)\\nfor j in h:\\n print(j)"}
{"id": "1582", "input": "# cook your dish here\\nt=int(input())\\nMOD=1000000007\\ndef mod(n, m=MOD):\\n n%=m\\n while n<0: n+=m\\n return n\\n\\ndef power(n, p):\\n res=1\\n while p:\\n if p%2: res=mod(res*n)\\n p//=2\\n n=mod(n*n)\\n return res\\n\\nwhile t:\\n ma=input().split()\\n", "gt": "x=int(ma[0])\\n y=int(ma[1])\\n s=int(ma[2])\\n ma=input().split()\\n u=int(ma[0])\\n v=int(ma[1])\\n if s%x==0 and ((s // x) & ((s // x) - 1) == 0):\\n inv=power(u, MOD-2)\\n print(mod(mod(mod(s//x)*v)*inv))\\n else:\\n inv=power(v-u, MOD-2)\\n print(mod(mod(mod(s//y)*v)*inv))\\n t-=1\\n"}
{"id": "1583", "input": "# cook your dish here\\nn = int(input())\\ns = [i for i in input()]\\ncount", "gt": "= 0\\nfor i in range(1,n):\\n if s[i] == s[i-1]:\\n count += 1\\n else:\\n continue\\nprint(count)\\n"}
{"id": "1584", "input": "import sys\\n\\ndef _r(*conv) :\\n r = [conv[i](x) for i, x in enumerate(input().strip().split(' '))]\\n return r[0] if len(r) == 1 else r\\n\\ndef _ra(conv) :\\n return list(map(conv, input().strip().split(' ')))\\n\\ndef _rl() :\\n return list(input().strip())\\n\\ndef _rs() :\\n return input().strip()\\n\\ndef _a(k, *v) :\\n return all(x == k for x in v)\\n\\ndef _i(conv) :\\n for line in sys.stdin :\\n yield conv(line)\\n##################################################################\\n\\n\\nfor _ in range(_r(int)) :\\n n, sx, sy, ex, ey, bx, by = _ra(int)\\n\\n if sx != ex and sy != ey : \\n print(abs(sx - ex) + abs(sy - ey))\\n else : \\n if sx == ex : \\n if sx == bx :", "gt": "\\n if (by > sy and by < ey) or (by < sy and by > ey) :\\n print(abs(sx - ex) + abs(sy - ey) + 2)\\n else :\\n print(abs(sx - ex) + abs(sy - ey))\\n else : \\n print(abs(sx - ex) + abs(sy - ey))\\n else :\\n if sy == by : \\n if (bx > sx and bx < ex) or (bx < sx and bx > ex) :\\n print(abs(sx - ex) + abs(sy - ey) + 2)\\n else : \\n print(abs(sx - ex) + abs(sy - ey))\\n else : \\n print(abs(sx - ex) + abs(sy - ey))\\n\\n\\n"}
{"id": "1585", "input": "r,c,n = map(int , input().split());coordinates = [];coordinates_1,coordinates_2 = {},{}\\r\\nfor _ in range(n):\\r\\n x,y = map(int , input().split())\\r\\n coordinates.append([x,y])\\r\\nfor i in coordinates:\\r\\n", "gt": "if(i[0] in coordinates_1): coordinates_1[i[0]] += 1\\r\\n else: coordinates_1[i[0]] = 1\\r\\n if(i[1] in coordinates_2): coordinates_2[i[1]] += 1\\r\\n else: coordinates_2[i[1]] = 1\\r\\nprint(max(coordinates_1.values()) + max(coordinates_2.values()))"}
{"id": "1586", "input": "# cook your dish here\\nfor _ in", "gt": "range(int(input())):\\n x, y= map(int, input().split())\\n print(max(x,y), x+y)"}
{"id": "1587", "input": "# cook your dish here\\ntry:\\n n=int(input())\\n \\n list_n = list(range(1,n+1))\\n list_n_flag=[]\\n \\n fix_arr = list(map(int,input().split()))\\n \\n \\n k=1\\n res_list=[]\\n fin_list=[]\\n list_n_flag = list_n[k:] + list_n[:k]\\n res_list = [list_n[i] + fix_arr[i] for", "gt": "i in range(len(fix_arr))]\\n maxx = max(res_list)\\n fin_list.append(maxx)\\n while list_n!=list_n_flag:\\n \\n res_list = [list_n_flag[i] + fix_arr[i] for i in range(len(fix_arr))]\\n maxx = max(res_list)\\n fin_list.append(maxx)\\n list_n_flag = list_n_flag[k:] + list_n_flag[:k]\\n \\n print(*fin_list,sep=\" \")\\nexcept:\\n pass"}
{"id": "1588", "input": "r=int(input())\\nc=0\\nL=[]\\nfor i in range(2*r+1,2*r**2+2):\\n for j in range(i,r**4+2*r**2+2):\\n for k in range(j,r**4+3*r**2+2):\\n if 4*(i+j+k)*r**2==(i+j-k)*(i+k-j)*(j+k-i):\\n", "gt": "L.append([i,j,k])\\n c+=1\\nprint(c)\\nfor i in range(c):\\n for j in range(3):\\n print(L[i][j], end=' ')\\n print()\\n \\n"}
{"id": "1589", "input": "try:\\n t = int(input())\\n while t:\\n t -= 1\\n n = int(input())\\n arr = []\\n obj = {}\\n for i in range(n):\\n x,y = input().split()\\n y = int(y)\\n arr.append([x, y])\\n if", "gt": "y in obj: obj[y].append(x)\\n else: obj[y] = [x]\\n arr.sort(key = lambda i: i[1], reverse = True)\\n while len(arr) and len(obj[arr[-1][1]]) > 1:\\n arr.pop()\\n if len(arr) == 0:\\n print('Nobody wins.')\\n else:\\n print(arr.pop()[0])\\nexcept:\\n pass"}
{"id": "1590", "input": "for _ in range(int(input())):\\r\\n a=list(map(int,input().split()))\\r\\n num=0\\r\\n den=0\\r\\n k=1\\r\\n great=0\\r\\n for i in", "gt": "a:\\r\\n if i==-1:break\\r\\n else:\\r\\n if i>30:great+=1\\r\\n if i%2==0:\\r\\n num+=k*i\\r\\n den+=k\\r\\n k+=1\\r\\n print(great,'%.2f'%(num/den))"}
{"id": "1591", "input": "n=int(input())\\nfor i in range(n):\\n a=list(map(int,input().split()))\\n a.sort()\\n", "gt": "if a[0]+a[1]>=a[2]-1:\\n print(\"Yes\")\\n else:\\n print(\"No\")\\n \\n"}
{"id": "1592", "input": "arr = []\\narr.append(1)\\n_ = 1\\nwhile _<=100002:\\n", "gt": "arr.append(_*arr[_-1]%1589540031)\\n _+=1\\nfor _ in range(int(input())):\\n print(arr[int(input())])"}
{"id": "1593", "input": "for i in range(int(input())):\\n n=int(input())\\n chef=0\\n ans=[]\\n for i in range(0,n):\\n l=list(map(int,input().split()))\\n c=l[0]\\n if c%2==0:\\n for i in range(1,len(l)//2+1):\\n", "gt": "chef=chef+l[i]\\n continue;\\n for i in range(1,len(l)//2):\\n chef=chef+l[i]\\n ans.append(l[len(l)//2])\\n ans.sort(reverse=True)\\n for i in range(len(ans)):\\n if i%2==0:\\n chef=chef+ans[i]\\n print(chef)\\n \\n \\n"}
{"id": "1594", "input": "# cook your dish here\\nt= int(input())\\nfor i in range(t):\\n cnt=0\\n n=int(input())\\n while(n>=100):\\n n-=100\\n cnt+=1\\n while(n>=50):\\n", "gt": "n-=50\\n cnt+=1\\n while(n>=10):\\n n-=10\\n cnt+=1\\n while(n>=5):\\n n-=5\\n cnt+=1\\n while(n>=2):\\n n-=2\\n cnt+=1\\n while(n>=1):\\n n-=1\\n cnt+=1\\n print(cnt)"}
{"id": "1595", "input": "T = int(input())\\r\\n\\r\\nans = []\\r\\nfor _ in range(T):\\r\\n z = int(input())\\r\\n\\r\\n", "gt": "for k in range(z):\\r\\n s = input()\\r\\n\\r\\n ans.append((z*(z+1))//2)\\r\\n\\r\\nfor ele in ans:\\r\\n print(ele)"}
{"id": "1596", "input": "import itertools\\nimport numpy as np\\nb = np.zeros((100001), dtype=np.int)\\ndef power2(a):\\n b[0] = 1\\n if b[a] > 0:\\n return b[a]\\n else:\\n for i in range(1,a+1):\\n\\n b[i] = b[i-1]*2\\n if b[i] > (10**9+7):\\n b[i] = b[i]%(10**9+7)\\n return b[a]\\n\\n\\ndef __starting_point():\\n t = eval(input())\\n for i in range(t):\\n s = input()\\n n = eval(input())\\n f_list = []\\n count = 0\\n for j in range(n):\\n f_list.append(input())\\n inp = \"\"\\n bin_list = []\\n for j in range(len(s)):\\n if s[j] == 'w':\\n inp = inp + '0'\\n else:\\n inp = inp + '1'\\n #print inp\\n\\n a = np.zeros((1024), dtype=np.int)\\n for j in range(n):\\n s1 = \"\"\\n for k in range(len(f_list[j])):\\n if f_list[j][k]=='+':\\n s1 = s1 + '1'\\n else:\\n s1 = s1 + '0'\\n if n < 1024:\\n", "gt": "bin_list.append(s1)\\n p = int(s1,2)\\n if a[p] == 0:\\n count = count+1\\n a[p] = a[p]+1\\n count_2 = 0\\n\\n\\n #print a\\n \\n if n < 1024:\\n dp = np.zeros((n+1,1024) ,dtype=np.int64)\\n dp[0,0] = 1\\n for j in range(1,n+1):\\n for k in range(1024):\\n #print j-1\\n #print k^int(bin_list[j-1],2)\\n\\n dp[j,k] = (dp[j-1][k] + dp[j-1][k^int(bin_list[j-1],2)])%(10**9+7)\\n\\n #print dp\\n p = 1023 ^ int(inp,2)\\n\\n print(dp[n,p]%(10**9+7))\\n\\n else:\\n\\n dp = np.zeros((1025,1024) ,dtype=np.int64)\\n dp[0,0] = 1\\n for j in range(1,1025):\\n count_2 = count_2 + 1\\n if a[j-1] > 0:\\n l = power2(a[j-1]-1)\\n for k in range(1024):\\n #print j-1\\n #print k^int(bin_list[j-1],2)\\n if a[j-1] > 0:\\n dp[j,k] = (((dp[j-1][k] + dp[j-1][k^(j-1)])%(10**9+7)) * l )%(10**9+7)\\n elif dp[j-1][k] > 0:\\n dp[j,k] = dp[j-1][k]\\n\\n if count_2 == count:\\n break\\n #print dp\\n p = 1023 ^ int(inp,2)\\n\\n print(dp[j,p]%(10**9+7))\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n__starting_point()"}
{"id": "1597", "input": "import math\\n\\nfor i in range(int(input())):\\n p,q=list(map(int,input().split()))\\n c=0\\n h=0\\n \\n while(q>=0):\\n if(q==0):\\n h+=1\\n break\\n \\n d=int(math.log2(q+1))\\n if(d==0):\\n h+=1\\n break\\n y=(2**d)-1\\n q-=y+1\\n if(q==-1):\\n h+=1\\n break\\n h+=1\\n", "gt": "\\n while(p>=0):\\n if(p==0):\\n c+=1\\n break\\n else:\\n rem=int(math.log2(p+1))\\n \\n if(rem==0):\\n c+=1\\n break\\n \\n y=(2**rem)-1\\n p-=y+1\\n if(p==-1):\\n c+=1\\n break\\n c+=1\\n\\n if(c==h):\\n print(0,0)\\n if(c<h):\\n print(1,h-c)\\n if(c>h):\\n print(2,c-h)\\n"}
{"id": "1598", "input": "import math\\ndef divisors(n):\\n arr = []\\n for i in range(1,1+int(math.ceil(math.sqrt(n)))):\\n if n%i == 0:\\n arr.append(i)\\n arr.append(n//i)\\n arr = list(sorted(set(arr)))\\n return arr\\ntry:\\n t = int(input())\\n while t:\\n t -= 1\\n a,m = map(int, input().split())\\n", "gt": "divs = divisors(m)\\n ans = []\\n for d in divs:\\n q = (m//d-1)/a\\n if q%1 == 0 and q>0:\\n ans.append((int(d*q)))\\n ans.sort()\\n print(len(ans))\\n for i in ans:\\n print(i, end = ' ')\\n print()\\nexcept:\\n pass"}
{"id": "1599", "input": "try:\\n # cook your dish here\\n t=int(input())\\n for j in range(t):\\n n=int(input())\\n x=[]\\n p=[]\\n m=[]\\n for i in range(n):\\n X,P,M=list(map(str,input().split()))\\n x.append(X)\\n p.append(int(P))\\n", "gt": "m.append(int(M))\\n avg=sum(m)/n\\n for i in m:\\n if i<avg:\\n z=sorted([k for k in m if k<avg])\\n for i in range(len(z)):\\n print(x[m.index(z[i])],p[m.index(z[i])],m[m.index(z[i])])\\n \\nexcept:\\n pass"}
{"id": "1600", "input": "'''input\\n1\\n3\\n1 2\\n1 3\\n1 2 3\\n'''\\nimport sys\\nsys.setrecursionlimit(1000000)\\nfor _ in range(eval(input())):\\n C=[]\\n n=eval(input())\\n for i in range(n):\\n C.append([])\\n for i in range(n-1):\\n a,b=[int(x)-1 for x in input().split()]\\n C[a].append(b)\\n C[b].append(a)\\n cnt=0\\n Co=[bin(int(x)).count(\"1\") for", "gt": "x in input().split()]\\n Q=[0]*(n+100)\\n cur=0\\n done=[0]*n\\n done[0]=1\\n H=[0]*n\\n for i in range(n):\\n r=Q[i]\\n if H[r]&1 == Co[r]&1:\\n cnt+=1\\n for i in C[r]:\\n if done[i]==0:\\n done[i]=1\\n Q[cur+1]=i\\n cur+=1\\n H[i]=H[r]+1\\n #dfs(0,-1)\\n print(cnt*(n-cnt))\\n\\n"}
{"id": "1601", "input": "t=int(input())\\r\\nfor _ in range(t):\\r\\n n=int(input())\\r\\n arr=list(map(int,input().split()))\\r\\n d={}\\r\\n for i in range(n):\\r\\n if arr[i] in d:\\r\\n d[arr[i]].append(i)\\r\\n else:\\r\\n d[arr[i]]=[i]\\r\\n q=int(input())\\r\\n for i in", "gt": "range(q):\\r\\n m=int(input())\\r\\n if len(d[m])==1:\\r\\n print(n)\\r\\n elif len(d[m])==2:\\r\\n print(min((d[m][1]-d[m][0]),((n-d[m][1])+d[m][0])))\\r\\n else:\\r\\n k=100000\\r\\n for j in range(len(d[m])-1):\\r\\n if (d[m][j+1]-d[m][j])<k:\\r\\n k=d[m][j+1]-d[m][j]\\r\\n else:\\r\\n pass\\r\\n print(min(k,((n-d[m][len(d[m])-1])+d[m][0])))\\r\\n \\r\\n \\r\\n"}
{"id": "1602", "input": "for __ in range(int(input())):\\n n,p=list(map(int,input().split()))\\n", "gt": "d=n%(n//2+1)\\n if(d==0):\\n t=p*p*p\\n else:\\n t=(p-d)*(p-d)+(p-d)*(p-n)+(p-n)*(p-n)\\n print(t)\\n"}
{"id": "1603", "input": "for t in range(int(input().strip())):\\n n = int(input().strip())\\n x = int(input().strip())\\n arr = list(map(int, input().strip().split()))\\n arr.sort()\\n day = 1\\n acc = 0\\n isPossible = True\\n for a in", "gt": "arr:\\n acc += 1\\n if acc > x:\\n day += 1\\n acc = 1\\n if day >= a:\\n isPossible = False\\n break\\n\\n print(\"Possible\" if isPossible else \"Impossible\")\\n"}
{"id": "1604", "input": "# Bartek Kostka\\n# You are not prepared!\\n\\n#include \"bits/stdc++.h\"\\n\\nn = int(input())\\nW = {}\\nfor i in range(n):\\n adr = input()\\n adr = adr.split(\"/\")\\n if adr[-1] == '':\\n adr[-1] = '?'\\n domena = \"/\".join(adr[:3])\\n adres = \"/\".join(adr[3:])\\n #print(domena, adres)\\n if domena not in W:\\n W[domena] = set()\\n", "gt": "W[domena].add(adres)\\n\\nE ="}
{"id": "1605", "input": "def getSum(dp, pos, s, e, type_):\\n if e < s:\\n return 0\\n \\n if type_=='D':\\n if e==m-1:\\n return dp[pos][s]\\n return dp[pos][s]-dp[pos][e+1]\\n else:\\n if e==n-1:\\n return dp[s][pos]\\n return dp[s][pos]-dp[e+1][pos]\\n\\nmod = 10**9+7\\nn, m = map(int, input().split())\\na = [list(list(map(lambda x: 1 if x=='R' else 0, input()))) for _ in range(n)] \\n\\nSD = [[0]*m for _ in range(n)]\\nSN = [[0]*m for _ in range(n)]\\ndpD = [[0]*m for _ in range(n)]\\ndpN = [[0]*m for _ in range(n)]\\n\\nfor i in range(n-1, -1, -1):\\n for j in range(m-1, -1, -1):\\n if i == n-1:\\n SD[i][j]=a[i][j] \\n else:\\n SD[i][j]=SD[i+1][j]+a[i][j]\\n\\n if j == m-1:\\n SN[i][j]=a[i][j]\\n else: \\n SN[i][j]=SN[i][j+1]+a[i][j]\\n \\nfor j in range(m-1,-1,-1):\\n if", "gt": "a[n-1][j]==1:\\n break\\n dpD[n-1][j]=1\\n dpN[n-1][j]=1\\n \\nfor i in range(n-1,-1,-1):\\n if a[i][m-1]==1:\\n break\\n dpD[i][m-1]=1\\n dpN[i][m-1]=1\\n \\nfor j in range(m-2, -1, -1):\\n if i==n-1:\\n break\\n dpD[n-1][j]+=dpD[n-1][j+1]\\n \\nfor i in range(n-2,-1,-1): \\n if j==m-1:\\n break\\n dpN[i][m-1]+=dpN[i+1][m-1] \\n \\nfor i in range(n-2,-1,-1):\\n for j in range(m-2,-1,-1):\\n s, e = j, m-SN[i][j]-1\\n #print(i, j, s, e, 'N')\\n dpN[i][j] = getSum(dpD, i+1, s, e, 'D')\\n dpN[i][j] = (dpN[i][j] + dpN[i+1][j]) % mod \\n \\n s, e = i, n-SD[i][j]-1\\n #print(i, j, s, e, 'D')\\n dpD[i][j] = getSum(dpN, j+1, s, e, 'N')\\n\\n if i != 0:\\n for j in range(m-2,-1,-1): \\n dpD[i][j] = (dpD[i][j] + dpD[i][j+1]) % mod \\n \\nprint(dpD[0][0] % mod)"}
{"id": "1606", "input": "<s> ", "gt": "a,b=map(int,input().split())\\nprint(((b-1)*a*b//2+(a+1)*a*b*b*(b-1)//4)%1000000007)"}
{"id": "1607", "input": "l,r = map(int, input().split(\" \"))\\nif l", "gt": "== r:\\n print (l)\\nelse:\\n print (2)"}
{"id": "1608", "input": "s=input()\\nans = 0\\nfor i in range(len(s)):\\n if", "gt": "s[i] == 'A':\\n ans += s[:i].count('Q') * s[i:].count('Q')\\nprint(ans)"}
{"id": "1609", "input": "def determinant(m):\\n a = 0\\n if len(m) == 1:\\n a = m[0][0]\\n else:\\n for n in xrange(len(m)):\\n if (n + 1) % 2 == 0:\\n", "gt": "a -= m[0][n] * determinant([o[:n] + o[n+1:] for o in m[1:]])\\n else:\\n a += m[0][n] * determinant([o[:n] + o[n+1:] for o in m[1:]])\\n \\n return a"}
{"id": "1610", "input": "def sum_of_intervals(intervals):\\n s, top = 0, float(\"-inf\")\\n for a,b in sorted(intervals):\\n if top <", "gt": "a: top = a\\n if top < b: s, top = s+b-top, b\\n return s"}
{"id": "1611", "input": "def subsets_parity(n, k):\\n return 'EVEN'", "gt": "if ~n & k else 'ODD'"}
{"id": "1612", "input": "from collections import defaultdict\\nfrom itertools import chain\\nimport re\\n\\nPARSE = re.compile(r'[pP]\\d+|q')\\n\\ndef magic_call_depth_number(prog):\\n \\n def parse(it, p=''):\\n for m in it:\\n if m[0].startswith('p'): parse(it, m[0])\\n elif m[0]=='q': return\\n else: pCmds[p].append(m[0].lower())\\n \\n def travel(p, seen, d=1):\\n if not pCmds[p]:\\n yield", "gt": "0\\n else:\\n for n in pCmds[p]:\\n if n in seen: yield d\\n else: yield from travel(n, seen|"}
{"id": "1613", "input": "def primeFactors(n):\\n \\n factors = []\\n \\n while n % 2 == 0: \\n n /= 2\\n factors.append(2)\\n \\n for i in range(3, int(n**.5) + 1,2): \\n while n % i == 0: \\n n /= i\\n factors.insert(0, i)\\n \\n if n > 2: factors.insert(0, int(n))\\n \\n return factors\\n \\ndef score(p):\\n \\n last, xp, s = p[0], p[0], 0\\n \\n for j in p[1:]:\\n if j == last:\\n xp *= j\\n else:\\n s += xp\\n xp, last = j, j\\n return (s + xp) * len(p)\\n \\n\\ndef prod(lst):\\n \\n res = 1\\n \\n for v in lst: res *= v\\n return res\\n\\ndef multiply_partitions(partition): return [prod(sub) for sub in", "gt": "partition]\\n\\ndef partition(collection):\\n \\n if len(collection) == 1:\\n yield [collection]\\n return\\n\\n first = collection[0]\\n \\n for smaller in partition(collection[1:]): \\n for n, subset in enumerate(smaller):\\n yield smaller[:n] + [[ first ] + subset] + smaller[n+1:]\\n yield [ [ first ] ] + smaller\\n\\n\\ndef find_spec_prod_part(n, com): \\n \\n factors = primeFactors(n)\\n \\n if len(factors) == 1: return 'It is a prime number'\\n \\n fn = min if com == 'min' else max\\n mplist = []\\n best = [factors, score(factors)]\\n \\n for p in partition(factors):\\n mp = multiply_partitions(p)\\n \\n if mp in mplist or mp[0]==n:\\n continue \\n mplist.append(mp)\\n best = fn(best, [mp, score(mp)], key=lambda x: x[1])\\n \\n return [sorted(best[0], reverse=True), best[1]]"}
{"id": "1614", "input": "def solution(string,markers):\\n parts = string.split('\\n')\\n for s in markers:\\n", "gt": "parts = [v.split(s)[0].rstrip() for v in parts]\\n return '\\n'.join(parts)"}
{"id": "1615", "input": "COLUMNS, ROWS = 'ABCDEFG', range(6)\\nLINES = [{(COLUMNS[i+k], ROWS[j]) for k in range(4)}\\n for i in range(len(COLUMNS) - 3) for j in range(len(ROWS))] \\\\n + [{(COLUMNS[i], ROWS[j+k]) for k in range(4)}\\n for i in range(len(COLUMNS)) for j in range(len(ROWS) - 3)] \\\\n + [{(COLUMNS[i+k], ROWS[j+k]) for k in range(4)}\\n for i in range(len(COLUMNS) - 3) for j in range(len(ROWS)- 3)] \\\\n + [{(COLUMNS[i+k], ROWS[j-k]) for", "gt": "k in range(4)}"}
{"id": "1616", "input": "def longest_slide_down(p):\\n res = p.pop()\\n while p:\\n tmp = p.pop()\\n res", "gt": "= [tmp[i] + max(res[i],res[i+1]) for i in range(len(tmp))] \\n return res.pop()"}
{"id": "1617", "input": "words = {w: n for n, w in enumerate('zero one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen'.split())}\\nwords.update({w: 10 * n for n, w in enumerate('twenty thirty forty fifty sixty seventy eighty ninety hundred'.split(), 2)})\\nthousands = {w: 1000 ** n for n, w in", "gt": "enumerate('thousand million billion trillion quadrillion quintillion sextillion septillion octillion nonillion decillion'.split(), 1)}\\ndef parse_int(strng):\\n num = group = 0\\n for w in strng.replace(' and ', ' ').replace('-', ' ').split():\\n if w == 'hundred': group *= words[w]\\n elif w in words: group += words[w]\\n else:\\n num += group * thousands[w]\\n group = 0\\n return num + group"}
{"id": "1618", "input": "from math import *\\n\\nDIGS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\\n\\ndef converter(n, decimals=0, base=pi):\\n lst,n = ['-'*(n<0)], abs(n)\\n pMax = max(0, n and int(log(n,base)))\\n", "gt": "\\n for p in reversed(range(-decimals,pMax+1)):\\n if p==-1: lst.append('.')\\n p = base**p\\n d,n = n/p, n%p\\n lst.append(DIGS[int(d)])\\n \\n return ''.join(lst)"}
{"id": "1619", "input": "from collections import defaultdict\\nimport re\\n\\nP = re.compile(r'\\+?(-?\\d*)(x\\^?)?(\\d*)')\\n\\ndef differentiate(eq, x):\\n \\n derivate = defaultdict(int)\\n for coef,var,exp in P.findall(eq):\\n exp = int(exp or var and '1' or '0')\\n coef", "gt": "= int(coef!='-' and coef or coef and '-1' or '1')\\n \\n if exp: derivate[exp-1] += exp * coef\\n \\n return sum(coef * x**exp for exp,coef in derivate.items())"}
{"id": "1620", "input": "def decompose(n):\\n total = 0\\n answer = [n]\\n while len(answer):\\n temp = answer.pop()\\n total += temp ** 2\\n for i in range(temp - 1,", "gt": "0, -1):\\n if total - (i ** 2) >= 0:\\n total -= i ** 2\\n answer.append(i)\\n if total == 0:\\n return sorted(answer)\\n return None"}
{"id": "1621", "input": "from heapq import *\\n\\ndef n_linear(ms, n):\\n lst = [1] * (n+1)\\n q = [(1+v,v,1) for v in ms]\\n heapify(q)\\n for i in range(1,n+1):\\n", "gt": "v,x,j = heappop(q)\\n lst[i] = v\\n heappush(q, (lst[j]*x+1, x, j+1) )\\n while q[0][0]==lst[i]:\\n v,x,j = heappop(q)\\n heappush(q, (lst[j]*x+1, x, j+1) )\\n return lst[n]"}
{"id": "1622", "input": "def count_change(money, coins):\\n if money<0:\\n return 0\\n if money == 0:\\n return", "gt": "1\\n if money>0 and not coins:\\n return 0\\n return count_change(money-coins[-1],coins) + count_change(money,coins[:-1])"}
{"id": "1623", "input": "def bowling_score(frames):\\n rolls = list(frames.replace(' ',''))\\n for i, hit in enumerate(rolls):\\n if hit == 'X':\\n rolls[i] = 10\\n elif hit == '/':\\n rolls[i] = 10 - rolls[i - 1]\\n else:\\n rolls[i] = int(hit)\\n score = 0\\n for", "gt": "i in range(10):\\n frame = rolls.pop(0)\\n if frame == 10:\\n score += frame + rolls[0] + rolls[1] # Strike!\\n else:\\n frame += rolls.pop(0)\\n score += frame\\n if frame == 10:\\n score += rolls[0] # Spare!\\n return score"}
{"id": "1624", "input": "from fractions import Fraction as frac\\ndef ber():\\n res, m = [], 0\\n while True:\\n res.append(frac(1, m+1))\\n for j in range(m, 0, -1):\\n res[j-1] = j*(res[j-1] - res[j])\\n yield res[0]\\n m += 1\\ndef bernoulli_number(n): \\n", "gt": "if n == 1: return Fraction(-1, 2)\\n if n % 2 == 1: return 0\\n bn2 = [ix for ix in zip(range(n + 2), ber())]\\n bn2 = [b for _, b in bn2]\\n return bn2[n]"}
{"id": "1625", "input": "sq_cub_rev_prime = (None, 89, 271, 325, 328, 890, 1025, 1055, 1081, 1129, 1169, 1241, 2657, 2710, 3112, 3121, 3149, 3244, 3250, 3263, 3280, 3335, 3346, 3403, 4193, 4222, 4231, 4289, 4291, 5531, 5584, 5653, 5678, 5716, 5791, 5795, 5836, 5837, 8882, 8900, 8926, 8942, 9664, 9794, 9875, 9962, 10178, 10250, 10393, 10429, 10499, 10550, 10577, 10651, 10679, 10717, 10718, 10739, 10756, 10762, 10810, 10844, 10895, 10898, 10943, 10996, 11035, 11039, 11084, 11137, 11159, 11164, 11182, 11191, 11290, 11351, 11371, 11575, 11690, 11695, 11707, 11722, 11732, 11795, 11827, 11861, 11885, 12109, 12124, 12242, 12268, 12304, 12361, 12362, 12410, 12433, 12436, 12535, 19144, 19267, 19271, 19273, 19385, 19433, 19442, 19451, 19501, 19564, 19597, 19603, 19631, 19637, 19766, 19846, 19865,", "gt": "19871, 19909, 19927, 26464, 26491, 26570, 26579, 26621, 26704, 26944, 26965, 27001, 27029, 27052, 27100, 27101, 31120, 31210, 31223, 31237, 31261, 31327, 31331, 31351, 31463, 31469, 31490, 31534, 31561, 31657, 31726, 31739, 31784, 31807, 31883, 31928, 31978, 32066, 32072, 32213, 32255, 32308, 32431, 32440, 32446, 32500, 32539, 32564, 32573, 32630, 32656, 32708, 32749, 32759, 32800, 32888, 32969, 33059, 33254, 33325, 33338, 33350, 33404, 33460, 33475, 33509, 33568, 33575, 33701, 33833, 34030, 34112, 34159, 34163, 41351, 41429, 41473, 41501, 41608, 41639, 41839, 41879, 41930, 41933, 41992, 42029, 42089, 42103, 42121, 42179, 42220, 42235, 42310, 42326, 42385, 42463, 42466, 42524, 42575, 42607, 42682, 42782, 42839, 42890, 42910, 42982, 43045, 43049, 54986, 54991, 55073, 55310, 55492, 55589, 55598, 55603, 55651).__getitem__"}
{"id": "1626", "input": "LETTERS = 'abcdefgh' # Defining some constants\\nNUMBERS = '87654321'\\nW, B = WB = 'Pp'\\nEMPTY, CAPTURE = '.x'\\nWHITEHOME = '12'\\nBLACKHOME = '87'\\nJUMP = '54'\\n\\ndef pawn_move_tracker(moves):\\n board = {letter + number : # Representing board as\\n B if number == BLACKHOME[1] else # a dictionary for easy\\n W if number == WHITEHOME[1] else EMPTY # access\\n for letter in LETTERS for number in NUMBERS}\\n whitemove = True # Move side switcher\\n for move in moves:\\n target = move[-2:] # Finding target\\n mover = move[0] + str(int(move[-1]) + 1 - whitemove * 2)", "gt": "# Finding mover\\n if move[-1] in JUMP[whitemove] and board[mover] == EMPTY: # Mover for the jump\\n mover = move[0] + str(int(move[-1]) + 2 - whitemove * 4)\\n if (move[-1] in (BLACKHOME, WHITEHOME)[whitemove] or # Is the move valid?\\n board[target] != (EMPTY, WB[whitemove])[move[1] == CAPTURE] or\\n board[mover] != WB[not whitemove]):\\n return \""}
{"id": "1627", "input": "def solve(n):\\n def length(n):\\n s = 0\\n for i in range(20):\\n o = 10 ** i - 1\\n if o > n: break\\n s += (n - o) * (n - o + 1) // 2\\n return s\\n\\n def binary_search(k):\\n n = 0\\n for p in range(63, -1, -1):\\n if length(n + 2 ** p) < k: n", "gt": "+= 2 ** p\\n return n\\n\\n def sequence(n):\\n if n < 10: return n\\n for i in range(1, 19):\\n segment = i * 9 * 10 ** (i - 1)\\n if n <= segment:\\n return str(10 ** (i - 1) + (n - 1) // i)[(n - 1) % i]\\n else:\\n n -= segment\\n return int(sequence(n - length(binary_search(n))))"}
{"id": "1628", "input": "l = {j:i for i,j in enumerate('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz')}\\nl_ = dict(enumerate('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'))\\n\\nis_polydivisible = lambda n, base:next((0 for i in range(1, len(n) + 1) if get_base(n[:i], base) % i),1)\\nget_base = lambda n, base:sum(int(l[j]) * (base ** i) for i, j in enumerate(n[::-1]))\\ndef get_polydivisible(n, base):\\n c = i =0; r = ''\\n while c < n:\\n t =", "gt": "to_base(i, base)\\n if is_polydivisible(t, base) : c += 1 ;"}
{"id": "1629", "input": "def proper_fractions(n):\\n phi = n > 1 and n\\n for p in range(2, int(n ** .5) + 1):\\n if not n % p:\\n", "gt": "phi -= phi // p\\n while not n % p:\\n n //= p\\n if n > 1: phi -= phi // n\\n return phi"}
{"id": "1630", "input": "from collections import Counter\\n\\ndef exchange_sort(sequence):\\n \"\"\"Greedy algorithm based on permutation cycle decomposition:\\n 1. Search for transposition placing TWO elements correctly.\\n 2. Search iteratively for transposition placing ONE elements correctly.\"\"\"\\n swaps, cnt = 0, Counter()\\n for a, b in zip(sequence, sorted(sequence)):\\n if cnt[b,a] > 0:\\n cnt[b,a] -= 1\\n", "gt": "swaps += 1\\n elif a != b:\\n cnt[a,b] += 1\\n # Special case: as there are only three keys at most,\\n # all remaining cycles will be 3-length cycles that\\n # need 2 transpositions to place 3 elements correctly.\\n return swaps + sum(cnt.values()) // 3 * 2"}
{"id": "1631", "input": "from functools import reduce\\nfrom math import gcd\\n\\ndef survivor(a):\\n \"\"\"Round Robin by Bocker & Liptak\"\"\"\\n def __residue_table(a):\\n n = [0] + [None] * (a[0] - 1)\\n for i in range(1, len(a)):\\n d = gcd(a[0], a[i])\\n for r in range(d):\\n try:\\n nn = min(n[q] for q in range(r, a[0], d) if n[q] is not None)\\n", "gt": "except ValueError:\\n continue\\n for _ in range(a[0] // d):\\n nn += a[i]\\n p = nn % a[0]\\n if n[p] is not None: nn = min(nn, n[p])\\n n[p] = nn\\n return n\\n\\n a.sort()\\n if len(a) < 1 or reduce(gcd, a) > 1: return -1\\n if a[0] == 1: return 0\\n return max(__residue_table(a)) - a[0]"}
{"id": "1632", "input": "def snail(array):\\n ret = []\\n if array and array[0]:\\n size = len(array)\\n for n in range((size + 1) // 2):\\n for x in range(n, size - n):\\n ret.append(array[n][x])\\n for y in range(1 +", "gt": "n, size - n):\\n ret.append(array[y][-1 - n])\\n for x in range(2 + n, size - n + 1):\\n ret.append(array[-1 - n][-x])\\n for y in range(2 + n, size - n):\\n ret.append(array[-y][n])\\n return ret\\n"}
{"id": "1633", "input": "import math\\n\\ndef count(n):\\n if n is 0: return 0\\n x = int(math.log(n, 2))\\n return x * 2 ** (x - 1)", "gt": "+ n - 2 ** x + 1 + count(n - 2 ** x)\\n\\ndef countOnes(left, right):\\n return count(right) - count(left - 1)"}
{"id": "1634", "input": "import re\\n\\nNEG, DOT, _, *DIGS = \"负点 零一二三四五六七八九\"\\nPOWS = \" 十 百 千 万\".split(' ')\\nNUMS = {str(i):c for i,c in enumerate(DIGS)}\\nfor n in range(10): NUMS[str(n+10)] = POWS[1] + DIGS[n]*bool(n)\\n\\n\\ndef to_chinese_numeral(n):\\n ss = str(abs(n)).split('.')\\n return NEG*(n<0) + parse(ss[0])", "gt": "+ (len(ss)>1 and decimals(ss[1]) or '')\\n\\ndef decimals(digs): return DOT + ''.join(NUMS[d] for d in digs)\\n\\ndef parse(s):\\n if s in NUMS: return NUMS[s]\\n s = ''.join(reversed([ NUMS[d] + POWS[i]*(d!='0') for i,d in enumerate(reversed(s)) ]))\\n return re.sub(f'零+$|(?<=零)零+', '', s)"}
{"id": "1635", "input": "from math import factorial as fac\\n\\ndef xCy(x, y):\\n return fac(x) // fac(y) // fac(x", "gt": "- y)\\n \\ndef total_inc_dec(x):\\n return 1+sum([xCy(8+i,i) + xCy(9+i,i) - 10 for i in range(1,x+1)])\\n"}
{"id": "1636", "input": "def middle_permutation(string):\\n s = sorted(string)\\n if len(s) % 2", "gt": "==0: \\n return s.pop(len(s)//2-1) +''.join(s[::-1])\\n else:\\n return s.pop(len(s)//2) + middle_permutation(s)"}
{"id": "1637", "input": "def productsum(n):\\n pass # Your code here\\n \\ndef productsum(kmax):\\n def prodsum2(p, s, c, start):\\n k = p - s + c # product - sum + number of factors\\n if k <", "gt": "kmax:\\n if p < n[k]: n[k] = p\\n for i in range(start, kmax//p*2 + 1):\\n prodsum2(p*i, s+i, c+1, i)\\n\\n kmax += 1\\n n = [2*kmax] * kmax\\n prodsum2(1, 1, 1, 2)\\n\\n return sum(set(n[2:]))"}
{"id": "1638", "input": "def encode(s):\\n lst = sorted( s[i or len(s):] + s[:i or len(s)] for i in reversed(range(len(s))) )\\n return ''.join(ss[-1] for ss in lst), s", "gt": "and lst.index(s) or 0\\n\\ndef decode(s, n):\\n out, lst = [], sorted((c,i) for i,c in enumerate(s))\\n for _ in range(len(s)):\\n c,n = lst[n]\\n out.append(c)\\n return ''.join(out)"}
{"id": "1639", "input": "'''\\n Write a function that returns the longest contiguous palindromic substring in s. \\n In the event that there are multiple longest palindromic substrings, return the \\n first to occur.\\n'''\\n\\ndef longest_palindrome(s, sep=\" \"):\\n # Interpolate some inert character between input characters\\n # so we only have to find odd-length palindromes\\n t = sep + sep.join(s) + sep\\n\\n r = 0 # Rightmost index in any palindrome found so far ...\\n c =", "gt": "0 # ... and the index of the centre of that palindrome.\\n spans = [] # Length of the longest substring in T[i:] mirrored in T[i::-1]\\n\\n # Manacher's algorithm\\n for i,_ in enumerate(t):\\n span = min(spans[2*c-i], r-i-1) if i < r else 0\\n while span <= i < len(t)-span and t[i-span] == t[i+span]:\\n span += 1\\n r, c = max((r, c), (i+span, i))\\n spans.append(span)\\n\\n span = max(spans)\\n middle = spans.index(span)\\n\\n return t[middle-span+1:middle+span].replace(sep, \"\")"}
{"id": "1640", "input": "import math\\n\\ndef gta(limit, *args):\\n return sum_up(limit, make_pattern(limit, *args)) \\n\\ndef binomial_coeff(n, k):\\n \"\"\"N choose K\"\"\"\\n return math.factorial(n) / math.factorial(n-k)\\n\\ndef sum_up(limit, items):\\n \"\"\"\\n Basic Idea: \\n \\n The number of cominations is simply N choose K. We calcuate this n-times up to the limit.\\n \\n To sum up all the digits we don't have to calculate the sum of each permuation, rather, we simply have to \\n realise that the digit \"1\" will appear N times.\\n \\n For example: [1,2,3], pick = 3. \\n \\n If there are 6 combinations of length 3 for 3 numbers then each number much appear once in each combination. \\n Thus the sum is: (1 * 6) + (2 * 6) + (3 * 6)\\n \\n In cases where we have N numbers and need to pick K of them then that means not all numbers appear in all combinations.\\n", "gt": "It turns out combinations_total / (N / limit) gives us how many times N appears in the list of all combinations. \\n \\n For example: [1,2,3] pick 2\\n [1,2]\\n [2,1]\\n [1,3]\\n [3,1]\\n [2,3]\\n [3,2]\\n \\n We can see that 1 appears 4/6 times. \\n combinations_total = 6, N = 3, limit = 2.\\n \\n 6 / (3/2) = 4\\n \"\"\"\\n total = 0\\n for i in range(1, limit + 1):\\n combin = binomial_coeff(len(items), i)\\n ratio = len(items) / float(i) \\n\\n for element in items:\\n total += (element * (combin / ratio))\\n\\n return total\\n \\ndef make_pattern(limit, *args):\\n\\n seen = set()\\n pattern = []\\n items = list(map(str, args))\\n \\n k = 0\\n while len(pattern) < limit: \\n for i in range(len(items)):\\n try:\\n v = items[i][k]\\n except IndexError:\\n pass\\n \\n if v not in seen:\\n seen.add(v)\\n pattern.append(int(v))\\n if len(pattern) == limit:\\n break\\n k += 1\\n \\n return pattern"}
{"id": "1641", "input": "\\ndef mix(s1, s2):\\n hist = {}\\n for ch in \"abcdefghijklmnopqrstuvwxyz\":\\n val1, val2 = s1.count(ch), s2.count(ch)\\n if max(val1, val2) > 1:\\n which = \"1\" if val1 > val2 else", "gt": "\"2\" if val2 > val1 else \"=\"\\n hist[ch] = (-max(val1, val2), which + \":\" + ch * max(val1, val2))\\n return \"/\".join(hist[ch][1] for ch in sorted(hist, key=lambda x: hist[x]))\\n"}
{"id": "1642", "input": "from itertools import zip_longest\\n\\ndef normalize(lst, growing=0):\\n \\n def seeker(lst, d=1):\\n yield len(lst), d\\n for elt in lst:\\n if isinstance(elt,list):\\n yield from seeker(elt, d+1)\\n \\n def grower(lst, d=1):\\n", "gt": "return [ grower(o if isinstance(o,list) else [o]*size, d+1)\\n if d != depth else o\\n for o,_ in zip_longest(lst,range(size), fillvalue=growing) ]\\n \\n size,depth = map(max, zip(*seeker(lst)))\\n return grower(lst)"}
{"id": "1643", "input": "from scipy.special import comb\\n\\ndef multiply(n, k):\\n r, d = 1, 2\\n while d * d <= n:\\n i = 0\\n while n % d == 0:\\n i +=", "gt": "1\\n n //= d\\n r *= comb(i + k - 1, k - 1, exact=True)\\n d += 1\\n if n > 1: \\n r *= k\\n return r"}
{"id": "1644", "input": "from scipy.special import comb\\n\\ndef almost_everywhere_zero(n, k):\\n if k == 0: return 1\\n first, *rest = str(n)\\n", "gt": "l = len(rest)\\n return 9**k*comb(l, k, exact=True) +\\\\n (int(first)-1)*9**(k-1)*comb(l, k-1, exact=True) +\\\\n almost_everywhere_zero(int(\"\".join(rest) or 0), k-1)"}
{"id": "1645", "input": "from math import ceil\\ndef b91decode(strng):\\n ret = ''\\n base91_alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\\n 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\\n 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\\n 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\\n '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '!', '#', '$',\\n '%', '&', '(', ')', '*', '+', ',', '.', '/', ':', ';', '<', '=',\\n '>', '?', '@', '[', ']', '^', '_', '`', '{', '|', '}', '~', '\"']\\n strng_arr = [strng[i:i+2] for i in range(0, len(strng), 2)]\\n origin_bin = ''\\n for str in strng_arr:\\n num = 0\\n if len(str) == 1:\\n num += base91_alphabet.index(str[0])\\n origin_bin = bin(num)[2:] + origin_bin\\n else:\\n num += base91_alphabet.index(str[0])\\n num += base91_alphabet.index(str[1])*91\\n if num & 8191 > 88:\\n origin_bin = bin(num)[2:].zfill(13) + origin_bin\\n else:\\n origin_bin = bin(num)[2:].zfill(14) + origin_bin\\n origin_bin = origin_bin.zfill(int(ceil(len(origin_bin)/8.0))*8)\\n ret = [origin_bin[i:i+8] for i in range(0, len(origin_bin), 8)]\\n return ''.join(map(lambda x:chr(int(x, 2)), ret))[::-1]\\n \\n\\n \\n \\ndef b91encode(strng):\\n base91_alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\\n 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\\n 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\\n 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\\n '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '!', '#', '$',\\n '%', '&', '(', ')', '*', '+', ',', '.', '/', ':', ';', '<', '=',\\n '>', '?', '@',", "gt": "'[', ']', '^', '_', '`', '"}
{"id": "1646", "input": "def one_square(n):\\n return round(n ** .5) ** 2 == n\\n\\ndef two_squares(n):\\n while n % 2 == 0: n //= 2\\n p = 3\\n while p * p <= n:\\n while n % (p * p) == 0:\\n n //= p * p\\n while n % p == 0:\\n if", "gt": "p % 4 == 3: return False\\n n //= p\\n p += 2\\n return n % 4 == 1\\n\\ndef three_squares(n):\\n while n % 4 == 0: n //= 4\\n return n % 8 != 7\\n\\ndef sum_of_squares(n):\\n if one_square(n): return 1\\n if two_squares(n): return 2\\n if three_squares(n): return 3\\n return 4"}
{"id": "1647", "input": "out = [1, 5, 6]\\n\\ndef green(n):\\n \\n f = 5\\n s = 6\\n q = 1\\n\\n while n >= len(out):\\n q = 10 * q\\n f", "gt": "= f**2 % q\\n s = (1 - (s - 1)**2) % q\\n out.extend(sorted(j for j in [f, s] if j not in out))\\n return out[n-1]"}
{"id": "1648", "input": "import itertools\\ndef next_bigger(n):\\n s = list(str(n))\\n for i in range(len(s)-2,-1,-1):\\n if s[i] < s[i+1]:\\n t = s[i:]\\n m", "gt": "= min([x for x in t if x>t[0]])\\n t.remove(m)\\n t.sort()\\n s[i:] = [m] + t\\n return int(\"\".join(s))\\n return -1\\n"}
{"id": "1649", "input": "def spinning_rings(inner_max, outer_max):\\n p = inner_max + 1\\n q = outer_max + 1\\n move = 1\\n while (-move) % p != move % q:\\n if (-move) % p >= q:\\n move = move // p * p + p - q + 1\\n elif move % q >= p:\\n move = move // q * q +", "gt": "q\\n elif (-move) % p > move % q and ((-move) % p + move % q) % 2 == 0:\\n move += ((-move) % p - move % q) // 2\\n else:\\n move = min((move - 1) // p * p + p, (move - 1) // q * q + q) + 1\\n return move"}
{"id": "1650", "input": "STATE_TO_COMMANDS = {\\n 'CLOSED': {\\n 'APP_PASSIVE_OPEN': 'LISTEN',\\n 'APP_ACTIVE_OPEN': 'SYN_SENT'\\n },\\n 'LISTEN': {\\n 'RCV_SYN': 'SYN_RCVD',\\n 'APP_SEND': 'SYN_SENT',\\n 'APP_CLOSE': 'CLOSED'\\n },\\n 'SYN_RCVD': {\\n 'APP_CLOSE': 'FIN_WAIT_1',\\n 'RCV_ACK': 'ESTABLISHED'\\n },\\n 'SYN_SENT': {\\n 'RCV_SYN': 'SYN_RCVD',\\n 'RCV_SYN_ACK': 'ESTABLISHED',\\n 'APP_CLOSE': 'CLOSED'\\n },\\n 'ESTABLISHED': {\\n 'APP_CLOSE': 'FIN_WAIT_1',\\n 'RCV_FIN': 'CLOSE_WAIT'\\n },\\n 'FIN_WAIT_1': {\\n 'RCV_FIN': 'CLOSING',\\n 'RCV_FIN_ACK': 'TIME_WAIT',\\n 'RCV_ACK': 'FIN_WAIT_2'\\n", "gt": "}"}
{"id": "1651", "input": "from itertools import combinations_with_replacement\\n\\ndef find_all(sum_dig, digs):\\n combs = combinations_with_replacement(list(range(1, 10)), digs)\\n target = [''.join(str (x) for x in", "gt": "list(comb)) for comb in combs if sum(comb) == sum_dig]\\n if not target:\\n return []\\n return [len(target), int(target[0]), int(target[-1])]\\n"}
{"id": "1652", "input": "def solution(args):\\n out = []\\n beg = end = args[0]\\n \\n for n in args[1:] + [\"\"]: \\n if n != end + 1:\\n if end == beg:\\n out.append(", "gt": "str(beg) )\\n elif end == beg + 1:\\n out.extend( [str(beg), str(end)] )\\n else:\\n out.append( str(beg) + \"-\" + str(end) )\\n beg = n\\n end = n\\n \\n return \",\".join(out)"}
{"id": "1653", "input": "times = [(\"year\", 365 * 24 * 60 * 60), \\n (\"day\", 24 * 60 * 60),\\n (\"hour\", 60 * 60),\\n (\"minute\", 60),\\n (\"second\", 1)]\\n\\ndef format_duration(seconds):\\n\\n if not seconds:\\n return \"now\"\\n\\n chunks = []\\n for name, secs in times:\\n", "gt": "qty = seconds // secs\\n if qty:\\n if qty > 1:\\n name += \"s\"\\n chunks.append(str(qty) + \" \" + name)\\n\\n seconds = seconds % secs\\n\\n return ', '.join(chunks[:-1]) + ' and ' + chunks[-1] if len(chunks) > 1 else chunks[0]\\n"}
{"id": "1654", "input": "def fibfusc(n, num_digits=None):\\n if n < 2: return (1 - n, n)\\n b = bin(n)[2:]\\n \\n x, y = fibfusc(int(b[0]))\\n for bit in b[1:]:\\n if bit == \"1\":\\n x, y = (-y*(2*x + 3*y), (x + 2*y)*(x", "gt": "+ 4*y))\\n else:\\n x, y = ((x + y) * (x - y), y * (2*x + 3*y))\\n if num_digits:\\n x, y = x % 10 ** num_digits - 10**num_digits, y % 10 ** num_digits\\n return x, y\\n"}
{"id": "1655", "input": "import re\\n\\ndef solve_runes(runes):\\n for d in sorted(set(\"0123456789\") - set(runes)):\\n toTest = runes.replace(\"?\",d)\\n if", "gt": "re.search(r'([^\\d]|\\b)0\\d+', toTest): continue\\n l,r = toTest.split(\"=\")\\n if eval(l) == eval(r): return int(d)\\n return -1"}
{"id": "1656", "input": "from itertools import combinations\\n\\ndef count_col_triang(a):\\n p, r = {}, {}\\n for xy, col in a:\\n p[col] = p.get(col, []) + [xy]\\n for k in p:\\n r[k] = sum(1 for c in combinations(p[k], 3) if triangle(*c))\\n mx = max(r.values())\\n return [len(a), len(p), sum(r.values()), sorted(k for k in r if r[k]", "gt": "== mx) + [mx] if mx else []]\\n \\ndef triangle(a, b, c): \\n return area(*[((p[0] - q[0])**2 + (p[1] - q[1])**2)**0.5 for p, q in [(a, b), (a, c), (b, c)]]) > 0.0\\n\\ndef area(a, b, c):\\n s = 0.5 * (a + b + c)\\n return round(max((s*((s-a)*(s-b)*(s-c))), 0.0)**0.5, 4)"}
{"id": "1657", "input": "def count_subsequences(needle, haystack):\\n count = [1] + [0] * len(needle)\\n for a in haystack:\\n count = [1] +", "gt": "[count[i] + count[i-1] * (a == b)\\n for i, b in enumerate(needle, 1)]\\n return count[-1] % 10 ** 8"}
{"id": "1658", "input": "def string_func(s, n):\\n l, s = [s], list(s)\\n while True:\\n s[::2], s[1::2] =", "gt": "s[:len(s)//2-1:-1], s[:len(s)//2]\\n l.append(''.join(s))\\n if l[0] == l[-1]: del l[-1]; break\\n return l[n % len(l)]"}
{"id": "1659", "input": "from fractions import Fraction\\n\\ndef expand(x, digit):\\n step = 0\\n fact = 1\\n expo = Fraction(1)\\n n = 10 ** len(str(x).split('.')[-1])\\n x = Fraction(int(x * n),", "gt": "n)\\n while expo.numerator < 10 ** (digit - 1):\\n step += 1\\n fact *= step\\n expo += x ** step / fact\\n return [expo.numerator, expo.denominator]"}
{"id": "1660", "input": "ANSWERS = {\\n 0: 1,\\n 1: 1,\\n 2: 2,\\n 3: 3,\\n 4: 5,\\n 5: 7,\\n 6: 11,\\n 7: 15,\\n 8: 22,\\n 9: 30,\\n 10: 42,\\n 11: 56,\\n 12: 77,\\n 13: 101,\\n 14: 135,\\n 15: 176,\\n 16: 231,\\n 17: 297,\\n 18: 385,\\n 19: 490,\\n 20: 627,\\n 21: 792,\\n 22: 1002,\\n 23: 1255,\\n 24: 1575,\\n 25: 1958,\\n 26: 2436,\\n 27: 3010,\\n 28: 3718,\\n 29: 4565,\\n 30: 5604,\\n 31: 6842,\\n 32: 8349,\\n 33: 10143,\\n 34: 12310,\\n 35: 14883,\\n 36: 17977,\\n 37: 21637,\\n 38: 26015,\\n 39: 31185,\\n 40: 37338,\\n 41: 44583,\\n 42: 53174,\\n 43: 63261,\\n 44: 75175,\\n 45: 89134,\\n 46: 105558,\\n 47: 124754,\\n 48: 147273,\\n 49: 173525,\\n 50: 204226,\\n 51: 239943,\\n 52: 281589,\\n 53: 329931,\\n 54: 386155,\\n 55: 451276,\\n 56: 526823,\\n 57: 614154,\\n 58: 715220,\\n 59: 831820,\\n 60: 966467,\\n 61: 1121505,\\n 62: 1300156,\\n 63: 1505499,\\n 64: 1741630,\\n 65: 2012558,\\n 66: 2323520,\\n 67: 2679689,\\n 68: 3087735,\\n 69: 3554345,\\n 70: 4087968,\\n 71: 4697205,\\n 72: 5392783,\\n 73: 6185689,\\n 74: 7089500,\\n 75: 8118264,\\n 76: 9289091,\\n 77: 10619863,\\n 78: 12132164,\\n 79: 13848650,\\n 80: 15796476,\\n 81: 18004327,\\n 82: 20506255,\\n 83: 23338469,\\n 84: 26543660,\\n 85: 30167357,\\n 86: 34262962,\\n 87: 38887673,\\n 88: 44108109,\\n 89: 49995925,\\n 90: 56634173,\\n 91: 64112359,\\n 92: 72533807,\\n 93: 82010177,\\n 94: 92669720,\\n 95: 104651419,\\n 96: 118114304,\\n 97: 133230930,\\n 98: 150198136,\\n 99: 169229875,\\n 100: 190569292,\\n 101: 214481126,\\n 102: 241265379,\\n 103: 271248950,\\n 104: 304801365,\\n 105: 342325709,\\n 106: 384276336,\\n 107: 431149389,\\n 108: 483502844,\\n 109: 541946240,\\n 110: 607163746,\\n 111: 679903203,\\n 112: 761002156,\\n 113: 851376628,\\n 114: 952050665,\\n 115: 1064144451,\\n 116: 1188908248,\\n 117: 1327710076,\\n 118: 1482074143,\\n 119: 1653668665,\\n 120: 1844349560,\\n 121: 2056148051,\\n 122: 2291320912,\\n 123: 2552338241,\\n 124: 2841940500,\\n 125: 3163127352,\\n 126: 3519222692,\\n 127: 3913864295,\\n 128: 4351078600,\\n 129: 4835271870,\\n 130: 5371315400,\\n 131: 5964539504,\\n 132: 6620830889,\\n 133: 7346629512,\\n 134: 8149040695,\\n 135: 9035836076,\\n 136: 10015581680,\\n 137: 11097645016,\\n 138: 12292341831,\\n 139: 13610949895,\\n 140: 15065878135,\\n 141: 16670689208,\\n 142: 18440293320,\\n 143: 20390982757,\\n 144: 22540654445,\\n 145: 24908858009,\\n 146: 27517052599,\\n 147: 30388671978,\\n 148: 33549419497,\\n 149: 37027355200,\\n 150: 40853235313,\\n 151: 45060624582,\\n 152: 49686288421,\\n 153: 54770336324,\\n 154: 60356673280,\\n 155: 66493182097,\\n 156: 73232243759,\\n 157: 80630964769,\\n 158: 88751778802,\\n 159: 97662728555,\\n 160: 107438159466,\\n 161: 118159068427,\\n 162: 129913904637,\\n 163: 142798995930,\\n 164: 156919475295,\\n 165: 172389800255,\\n 166: 189334822579,\\n 167: 207890420102,\\n 168: 228204732751,\\n 169: 250438925115,\\n 170: 274768617130,\\n 171: 301384802048,\\n 172: 330495499613,\\n 173: 362326859895,\\n 174: 397125074750,\\n 175: 435157697830,\\n 176: 476715857290,\\n 177: 522115831195,\\n 178: 571701605655,\\n 179: 625846753120,\\n 180: 684957390936,\\n 181: 749474411781,\\n 182: 819876908323,\\n 183: 896684817527,\\n 184: 980462880430,\\n 185: 1071823774337,\\n 186: 1171432692373,\\n 187: 1280011042268,\\n 188: 1398341745571,\\n 189: 1527273599625,\\n 190: 1667727404093,\\n 191: 1820701100652,\\n 192: 1987276856363,\\n 193: 2168627105469,\\n 194: 2366022741845,\\n 195: 2580840212973,\\n 196: 2814570987591,\\n 197: 3068829878530,\\n 198: 3345365983698,\\n 199: 3646072432125,\\n 200: 3972999029388,\\n 201: 4328363658647,\\n 202: 4714566886083,\\n 203: 5134205287973,\\n 204: 5590088317495,\\n 205: 6085253859260,\\n 206: 6622987708040,\\n 207: 7206841706490,\\n 208: 7840656226137,\\n 209: 8528581302375,\\n 210: 9275102575355,\\n 211: 10085065885767,\\n 212: 10963707205259,\\n 213: 11916681236278,\\n 214: 12950095925895,\\n 215: 14070545699287,\\n 216: 15285151248481,\\n 217: 16601598107914,\\n 218: 18028182516671,\\n 219: 19573856161145,\\n 220: 21248279009367,\\n 221: 23061871173849,\\n 222: 25025873760111,\\n 223: 27152408925615,\\n 224: 29454549941750,\\n 225: 31946390696157,\\n 226: 34643126322519,\\n 227: 37561133582570,\\n 228: 40718063627362,\\n 229: 44132934884255,\\n 230: 47826239745920,\\n 231: 51820051838712,\\n 232: 56138148670947,\\n 233: 60806135438329,\\n 234: 65851585970275,\\n 235: 71304185514919,\\n 236: 77195892663512,\\n 237: 83561103925871,\\n 238: 90436839668817,\\n 239: 97862933703585,\\n 240: 105882246722733,\\n 241: 114540884553038,\\n 242: 123888443077259,\\n 243: 133978259344888,\\n 244: 144867692496445,\\n 245: 156618412527946,\\n 246: 169296722391554,\\n 247: 182973889854026,\\n 248: 197726516681672,\\n 249: 213636919820625,\\n 250: 230793554364681,\\n 251: 249291451168559,\\n 252: 269232701252579,\\n 253: 290726957916112,\\n 254: 313891991306665,\\n 255: 338854264248680,\\n 256: 365749566870782,\\n 257: 394723676655357,\\n 258: 425933084409356,\\n 259: 459545750448675,\\n 260: 495741934760846,\\n 261: 534715062908609,\\n 262: 576672674947168,\\n 263: 621837416509615,\\n 264: 670448123060170,\\n 265: 722760953690372,\\n 266: 779050629562167,\\n 267: 839611730366814,\\n 268: 904760108316360,\\n 269: 974834369944625,\\n 270: 1050197489931117,\\n 271: 1131238503938606,\\n 272: 1218374349844333,\\n 273: 1312051800816215,\\n 274: 1412749565173450,\\n 275: 1520980492851175,\\n 276: 1637293969337171,\\n 277: 1762278433057269,\\n 278: 1896564103591584,\\n 279: 2040825852575075,\\n 280: 2195786311682516,\\n 281: 2362219145337711,\\n 282: 2540952590045698,\\n 283: 2732873183547535,\\n 284: 2938929793929555,\\n 285: 3160137867148997,\\n 286: 3397584011986773,\\n 287: 3652430836071053,\\n 288: 3925922161489422,\\n 289: 4219388528587095,\\n 290: 4534253126900886,\\n 291: 4872038056472084,\\n 292: 5234371069753672,\\n 293: 5622992691950605,\\n 294: 6039763882095515,\\n 295: 6486674127079088,\\n 296: 6965850144195831,\\n 297: 7479565078510584,\\n 298: 8030248384943040,\\n 299: 8620496275465025,\\n 300: 9253082936723602,\\n 301: 9930972392403501,\\n 302: 10657331232548839,\\n 303: 11435542077822104,\\n 304: 12269218019229465,\\n 305: 13162217895057704,\\n 306: 14118662665280005,\\n 307: 15142952738857194,\\n 308: 16239786535829663,\\n 309: 17414180133147295,\\n 310: 18671488299600364,\\n 311: 20017426762576945,\\n 312: 21458096037352891,\\n 313: 23000006655487337,\\n 314: 24650106150830490,\\n 315: 26415807633566326,\\n 316: 28305020340996003,\\n 317: 30326181989842964,\\n 318: 32488293351466654,\\n 319: 34800954869440830,\\n 320: 37274405776748077,\\n 321: 39919565526999991,\\n 322: 42748078035954696,\\n 323: 45772358543578028,\\n 324: 49005643635237875,\\n 325: 52462044228828641,\\n 326: 56156602112874289,\\n 327: 60105349839666544,\\n 328: 64325374609114550,\\n 329: 68834885946073850,\\n 330: 73653287861850339,\\n 331: 78801255302666615,\\n 332: 84300815636225119,\\n 333: 90175434980549623,\\n 334: 96450110192202760,\\n 335: 103151466321735325,\\n 336: 110307860425292772,\\n 337: 117949491546113972,\\n 338: 126108517833796355,\\n 339: 134819180623301520,\\n 340: 144117936527873832,\\n 341: 154043597379576030,\\n 342: 164637479165761044,\\n 343: 175943559810422753,\\n 344: 188008647052292980,\\n 345: 200882556287683159,\\n 346: 214618299743286299,\\n 347: 229272286871217150,\\n 348: 244904537455382406,\\n 349: 261578907351144125,\\n 350: 279363328483702152,\\n 351: 298330063062758076,\\n 352: 318555973788329084,\\n 353: 340122810048577428,\\n 354: 363117512048110005,\\n 355: 387632532919029223,\\n 356: 413766180933342362,\\n 357: 441622981929358437,\\n 358: 471314064268398780,\\n 359: 502957566506000020,\\n 360: 536679070310691121,\\n 361: 572612058898037559,\\n 362: 610898403751884101,\\n 363: 651688879997206959,\\n 364: 695143713458946040,\\n 365: 741433159884081684,\\n 366: 790738119649411319,\\n 367: 843250788562528427,\\n 368: 899175348396088349,\\n 369: 958728697912338045,\\n 370: 1022141228367345362,\\n 371: 1089657644424399782,\\n 372: 1161537834849962850,\\n 373: 1238057794119125085,\\n 374: 1319510599727473500,\\n 375: 1406207446561484054,\\n 376: 1498478743590581081,\\n 377: 1596675274490756791,\\n 378: 1701169427975813525,\\n 379: 1812356499739472950,\\n 380: 1930656072350465812,\\n 381: 2056513475336633805,\\n 382: 2190401332423765131,\\n 383: 2332821198543892336,\\n 384: 2484305294265418180,\\n 385: 2645418340688763701,\\n 386: 2816759503217942792,\\n 387: 2998964447736452194,\\n 388: 3192707518433532826,\\n 389: 3398704041358160275,\\n 390: 3617712763867604423,\\n 391: 3850538434667429186,\\n 392: 4098034535626594791,\\n 393: 4361106170762284114,\\n 394: 4640713124699623515,\\n 395: 4937873096788191655,\\n 396: 5253665124416975163,\\n 397: 5589233202595404488,\\n 398: 5945790114707874597,\\n 399: 6324621482504294325,\\n 400: 6727090051741041926,\\n 401: 7154640222653942321,\\n 402: 7608802843339879269,\\n 403: 8091200276484465581,\\n 404: 8603551759348655060,\\n 405: 9147679068859117602,\\n 406: 9725512513742021729,\\n 407: 10339097267123947241,\\n 408: 10990600063775926994,\\n 409: 11682316277192317780,\\n 410: 12416677403151190382,\\n 411: 13196258966925435702,\\n 412: 14023788883518847344,\\n 413: 14902156290309948968,\\n 414: 15834420884488187770,\\n 415: 16823822787139235544,\\n 416: 17873792969689876004,\\n 417: 18987964267331664557,\\n 418: 20170183018805933659,\\n 419: 21424521360255636320,\\n 420: 22755290216580025259,\\n 421: 24167053021441363961,\\n 422: 25664640213837714846,\\n 423: 27253164546230421739,\\n 424: 28938037257084798150,\\n 425: 30724985147095051099,\\n 426: 32620068617410232189,\\n 427: 34629700713903575934,\\n 428: 36760667241831527309,\\n 429: 39020148000237259665,\\n 430: 41415739207102358378,\\n 431: 43955477170518116534,\\n 432: 46647863284229267991,\\n 433: 49501890409405150715,\\n 434: 52527070729108240605,\\n 435: 55733465144636286656,\\n 436: 59131714309169618645,\\n 437: 62733071376043079215,\\n 438: 66549436566966297367,\\n 439: 70593393646562135510,\\n 440: 74878248419470886233,\\n 441: 79418069346443402240,\\n 442: 84227730407729499781,\\n 443: 89322956321353645667,\\n 444: 94720370257893471820,\\n 445: 100437544171752847604,\\n 446: 106493051905239118581,\\n 447: 112906525199196103354,\\n 448: 119698712782720205954,\\n 449: 126891542690981418000,\\n 450: 134508188001572923840,\\n 451: 142573136155347404229,\\n 452: 151112262071917313678,\\n 453: 160152905244553715585,\\n 454: 169723951046458040965,\\n 455: 179855916453958267598,\\n 456: 190581040442651931034,\\n 457: 201933379285114688629,\\n 458: 213948907032733069132,\\n 459: 226665621435831345565,\\n 460: 240123655613925192081,\\n 461: 254365395758574199975,\\n 462: 269435605212954994471,\\n 463: 285381555241961986287,\\n 464: 302253162872576636605,\\n 465: 320103136152993290544,\\n 466: 338987127249525432549,\\n 467: 358963893768162876613,\\n 468: 380095468763120598477,\\n 469: 402447339861711475160,\\n 470: 426088638015652413417,\\n 471: 451092336355096099864,\\n 472: 477535459708164115593,\\n 473: 505499305314204629558,\\n 474: 535069675351607262125,\\n 475: 566337121865805599675,\\n 476: 599397204782301852926,\\n 477: 634350763653787028583,\\n 478: 671304203896731807232,\\n 479: 710369798236628238005,\\n 480: 751666004194993125591,\\n 481: 795317798414758232180,\\n 482: 841457028742823649455,\\n 483: 890222784951928088294,\\n 484: 941761789114997698055,\\n 485: 996228806608573411012,\\n 486: 1053787078862455346513,\\n 487: 1114608778936426484248,\\n 488: 1178875491155735802646,\\n 489: 1246778716001272919665,\\n 490: 1318520401612270233223,\\n 491: 1394313503224447816939,\\n 492: 1474382572040363953132,\\n 493: 1558964374994977806173,\\n 494: 1648308547066172438760,\\n 495: 1742678277747760981187,\\n 496: 1842351033503159891466,\\n 497: 1947619317987658064007,\\n 498: 2058791472042884901563,\\n 499: 2176192515439287461625,\\n 500: 2300165032574323995027,\\n 501: 2431070104309287327876,\\n 502: 2569288288377098289281,\\n 503: 2715220650772245313220,\\n 504: 2869289850802400662045,\\n 505: 3031941282464413132742,\\n 506: 3203644275096202070012,\\n 507: 3384893356244349844341,\\n 508: 3576209579998154653671,\\n 509: 3778141924035171537110,\\n 510: 3991268758958164118300,\\n 511: 4216199393504640098482,\\n 512: 4453575699570940947378,\\n 513: 4704073821002175842062,\\n 514: 4968405970488126319775,\\n 515: 5247322318923878793976,\\n 516: 5541612982013113936133,\\n 517: 5852110108921301661040,\\n 518: 6179690078238084808000,\\n 519: 6525275806549652788115,\\n 520: 6889839175409542385648,\\n 521: 7274403582551733377346,\\n 522: 7680046623716094332553,\\n 523: 8107902911527474124146,\\n 524: 8559167038437716736150,\\n 525: 9035096690829005915201,\\n 526: 9537015921990240021538,\\n 527: 10066318591787500106586,\\n 528: 10624471981512075020731,\\n 529: 11213020592521695111580,\\n 530: 11833590138006300416410,\\n 531: 12487891737367521803652,\\n 532: 13177726323474524612308,\\n 533: 13904989273245567335012,\\n 534: 14671675272840783232475,\\n 535: 15479883428970761068959,\\n 536: 16331822638729701493803,\\n 537: 17229817230617210720599,\\n 538: 18176312890390861435034,\\n 539: 19173882885687454484110,\\n 540: 20225234604409151266221,\\n 541: 21333216422211708570598,\\n 542: 22500824915577356165493,\\n 543: 23731212437346370138355,\\n 544: 25027695072821279146420,\\n 545: 26393760995005382968154,\\n 546: 27833079238879849385687,\\n 547: 29349508915133986374841,\\n 548: 30947108885217475101876,\\n 549: 32630147920163234060900,\\n 550: 34403115367205050943160,\\n 551: 36270732348871285128752,\\n 552: 38237963520943177237554,\\n 553: 40310029416409244587122,\\n 554: 42492419404397720872600,\\n 555: 44790905293907018009131,\\n 556: 47211555614160398040338,\\n 557: 49760750604354432757376,\\n 558: 52445197947746313627407,\\n 559: 55271949286085137715955,\\n 560: 58248417552751868050007,\\n 561: 61382395164161775318496,\\n 562: 64682073111542943380454,\\n 563: 68156060996536236172174,\\n 564: 71813408056839596203570,\\n 565: 75663625229609055443637,\\n 566: 79716708303343130521599,\\n 567: 83983162210640880002321,\\n 568: 88474026517495817981253,\\n 569: 93200902166643654187580,\\n 570: 98175979536033971312388,\\n 571: 103412067875563710992446,\\n 572: 108922626189067392956037,\\n 573: 114721795630860408658491,\\n 574: 120824433490320564237125,\\n 575: 127246148840551966562301,\\n 576: 134003339931725153597473,\\n 577: 141113233412529912746558,\\n 578: 148593925468119890197615,\\n 579: 156464424966082817448060,\\n 580: 164744698707340387584240,\\n 581: 173455718882380096095248,\\n 582: 182619512839056823919887,\\n 583: 192259215272078129526277,\\n 584: 202399122950629095580175,\\n 585: 213064752104884207160129,\\n 586: 224282898599046831034631,\\n 587: 236081701023305130945921,\\n 588: 248490706844586261413858,\\n 589: 261540941761240642265710,\\n 590: 275264982414934173206642,\\n 591: 289697032618827122974972,\\n 592: 304873003269975366031783,\\n 593: 320830596120295386610807,\\n 594: 337609391590065169560935,\\n 595: 355250940815002702558187,\\n 596: 373798862128436852709430,\\n 597: 393298942187883251157044,\\n 598: 413799241966727832978027,\\n 599: 435350207840317348270000,\\n 600: 458004788008144308553622,\\n 601: 481818554503286362923739,\\n 602: 506849831053734861481872,\\n 603: 533159827070679866278987,\\n 604: 560812778053476538349420,\\n 605: 589876092712502332463864,\\n 606: 620420507127059714307352,\\n 607: 652520246268116112057164,\\n 608: 686253193233019826880477,\\n 609: 721701066553229757379480,\\n 610: 758949605954969709105721,\\n 611: 798088766967999186006767,\\n 612: 839212924798226411060795,\\n 613: 882421087896683264554175,\\n 614: 927817121679723721849795,\\n 615: 975509982873756796925504,\\n 616: 1025613964982134990453294,\\n 617: 1078248955392080004474789,\\n 618: 1133540704665979618906662,\\n 619: 1191621108583631746910145,\\n 620: 1252628503530795506440909,\\n 621: 1316707975853817969920561,\\n 622: 1384011685831426958558879,\\n 623: 1454699206941558115141676,\\n 624: 1528937881135168275063375,\\n 625: 1606903190858354689128371,\\n 626: 1688779148601189609516729,\\n 627: 1774758704783877366657989,\\n 628: 1865044174831202682776536,\\n 629: 1959847686321528964669495,\\n 630: 2059391647140527228529479,\\n 631: 2163909235608484556362424,\\n 632: 2273644913597837330081136,\\n 633: 2388854963699932382735982,\\n 634: 2509808051552031608082535,\\n 635: 2636785814481962651219075,\\n 636: 2770083477684418110395121,\\n 637: 2910010499193691843303014,\\n 638: 3056891244979232231862474,\\n 639: 3211065695545980277248740,\\n 640: 3372890185488482409685019,\\n 641: 3542738177508596708707874,\\n 642: 3721001072479541451508397,\\n 643: 3908089057205582486668934,\\n 644: 4104431991606013700457110,\\n 645: 4310480337124871462076948,\\n 646: 4526706128254173781044298,\\n 647: 4753603989138067267826945,\\n 648: 4991692197319220372390544,\\n 649: 5241513796775816319683700,\\n 650: 5503637762499727151307095,\\n 651: 5778660218961559003723580,\\n 652: 6067205714919484306343541,\\n 653: 6369928557132709817142929,\\n 654: 6687514205661440172553650,\\n 655: 7020680733548749464953877,\\n 656: 7370180353811425547662139,\\n 657: 7736801016790889035132284,\\n 658: 8121368081058512888507057,\\n 659: 8524746061205131302394950,\\n 660: 8947840456000332817673697,\\n 661: 9391599660555044587641517,\\n 662: 9857016966290401433259592,\\n 663: 10345132652677367520056676,\\n 664: 10857036174895938656583295,\\n 665: 11393868451739000294452939,\\n 666: 11956824258286445517629485,\\n 667: 12547154728067493595502055,\\n 668: 13166169969647255482980383,\\n 669: 13815241802783448943206160,\\n 670: 14495806619536377005379418,\\n 671: 15209368375944215483241988,\\n 672: 15957501720133631304230773,\\n 673: 16741855262985451980947171,\\n 674: 17564154997755650263621500,\\n 675: 18426207875324210441995136,\\n 676: 19329905542049511423199336,\\n 677: 20277228247502764885900784,\\n 678: 21270248929688765106878025,\\n 679: 22311137485682880566295780,\\n 680: 23402165235974892374954302,\\n 681: 24545709591163085124246501,\\n 682: 25744258930034131533263392,\\n 683: 27000417698448800353553865,\\n 684: 28316911738879831363625420,\\n 685: 29696593860867277871605321,\\n 686: 31142449663120060247020395,\\n 687: 32657603618448918933404658,\\n 688: 34245325433219728719773420,\\n 689: 35909036693513349075724695,\\n 690: 37652317810725762600765183,\\n 691: 39478915279883795756623331,\\n 692: 41392749264546866860893416,\\n 693: 43397921522754943172592795,\\n 694: 45498723689129703063649450,\\n 695: 47699645928878027716139269,\\n 696: 50005385980149860746062163,\\n 697: 52420858601901549459658530,\\n 698: 54951205445179608281719072,\\n 699: 57601805366500810491219000,\\n 700: 60378285202834474611028659,\\n 701: 63286531028521032840985510,\\n 702: 66332699915362724119980694,\\n 703: 69523232218023552371152320,\\n 704: 72864864407855341219969825,\\n 705: 76364642479247406973532354,\\n 706: 80029935953661656574123574,\\n 707: 83868452507581852374822598,\\n 708: 87888253251761884175130183,\\n 709: 92097768690318501305952845,\\n 710: 96505815389469697877049934,\\n 711: 101121613386982294887579670,\\n 712: 105954804374756131323439197,\\n 713: 111015470688345108146850290,\\n 714: 116314155138696524440183805,\\n 715: 121861881722882938654960142,\\n 716: 127670177252209281782740521,\\n 717: 133751093937700984130081285,\\n 718: 140117232974725477106760252,\\n 719: 146781769170263852819573505,\\n 720: 153758476658245881594406593,\\n 721: 161061755750279477635534762,\\n 722: 168706660971164630122439117,\\n 723: 176708930330666271859881567,\\n 724: 185085015885255746880625875,\\n 725: 193852115645795752984189381,\\n 726: 203028206889569986197651315,\\n 727: 212632080937520072186590492,\\n 728: 222683379460186024851577401,\\n 729: 233202632378520643600875145,\\n 730: 244211297428606706709925517,\\n 731: 255731801462210865865001525,\\n 732: 267787583558210323920375877,\\n 733: 280403140023083872114273884,\\n 734: 293604071362025285843562670,\\n 735: 307417131305664218954016427,\\n 736: 321870277981032622582593573,\\n 737: 336992727319136467572139095,\\n 738: 352815008795455957133215652,\\n 739: 369369023603738655757458075,\\n 740: 386688105367749941220651375,\\n 741: 404807083500032850651734059,\\n 742: 423762349321394151918928481,\\n 743: 443591925059596733749014862,\\n 744: 464335535850798483634138280,\\n 745: 486034684872448271784326296,\\n 746: 508732731741838107613602755,\\n 747: 532474974320122372524707631,\\n 748: 557308734067567635805394638,\\n 749: 583283445101886813536239875,\\n 750: 610450747117966916191771809,\\n 751: 638864582333908382360557376,\\n 752: 668581296635294279311393900,\\n 753: 699659745096778286894322787,\\n 754: 732161402067670820574405230,\\n 755: 766150476015982127183457373,\\n 756: 801694029333610862568750951,\\n 757: 838862103313805798709299373,\\n 758: 877727848520950325159242658,\\n 759: 918367660781873199488134935,\\n 760: 960861323037560814483873080,\\n 761: 1005292153304074193879898920,\\n 762: 1051747159001957690209588887,\\n 763: 1100317197924192833923669753,\\n 764: 1151097146124113726578727360,\\n 765: 1204186073016375022219516992,\\n 766: 1259687423996378387111229150,\\n 767: 1317709210896221493178043552,\\n 768: 1378364210608578997366598385,\\n 769: 1441770172223648126550509165,\\n 770: 1508050033038752490738311726,\\n 771: 1577332143815074048889599022,\\n 772: 1649750503671651735806603894,\\n 773: 1725445005022910006140645612,\\n 774: 1804561688982956164492944650,\\n 775: 1887253011677361609828822380,\\n 776: 1973678121921532286407950000,\\n 777: 2064003150743712843868729636,\\n 778: 2158401513250589964731360493,\\n 779: 2257054223353982965849642005,\\n 780: 2360150221898687182164777966,\\n 781: 2467886718753771981901721670,\\n 782: 2580469549453004933593920862,\\n 783: 2698113546994164480174756373,\\n 784: 2821042929432312216467202070,\\n 785: 2949491703928193388274450292,\\n 786: 3083704087940340693022764503,\\n 787: 3223934948277725160271634798,\\n 788: 3370450258759473520427114109,\\n 789: 3523527577258789108163787100,\\n 790: 3683456542940343404363084600,\\n 791: 3850539394533563994343413787,\\n 792: 4025091510519029370421431033,\\n 793: 4207441972141088280734057870,\\n 794: 4397934150197476827913759850,\\n 795: 4596926316595586652827474186,\\n 796: 4804792281705797515062559743,\\n 797: 5021922058584382849328869242,\\n 798: 5248722555182613689484387822,\\n 799: 5485618295704258477069984050,\\n 800: 5733052172321422504456911979,\\n 801: 5991486228508002426815719537,\\n 802: 6261402475301701333080509487,\\n 803: 6543303741858946450905285538,\\n 804: 6837714561722963378455094385,\\n 805: 7145182096283051986707103605,\\n 806: 7466277096963606051213804496,\\n 807: 7801594907743960700949000443,\\n 808: 8151756509675604512522473567,\\n 809: 8517409609130970421571757565,\\n 810: 8899229771588828461969917962,\\n 811: 9297921602834531195851268718,\\n 812: 9714219979529959777862768265,\\n 813: 10148891331187245215547993864,\\n 814: 10602734975663191221223594155,\\n 815: 11076584510377034355391142064,\\n 816: 11571309261543787320061392679,\\n 817: 12087815793808125625662163707,\\n 818: 12627049482760689878061744701,\\n 819: 13189996152918959195978870030,\\n 820: 13777683783859651786576215682,\\n 821: 14391184287298069419105856949,\\n 822: 15031615358023124634594092724,\\n 823: 15700142401714084441377203063,\\n 824: 16397980542787591098996821750,\\n 825: 17126396715550358417594267021,\\n 826: 17886711842065410771034749979,\\n 827: 18680303100276877491522988120,\\n 828: 19508606286081561360311437674,\\n 829: 20373118273183778133458320225,\\n 830: 21275399574724765449983360003,\\n 831: 22217077010838260632179411313,\\n 832: 23199846486451169343993151122,\\n 833: 24225475883821531494697782922,\\n 834: 25295808074486832813101046425,\\n 835: 26412764055483014097178757689,\\n 836: 27578346214889968804237171486,\\n 837: 28794641731961759722351371983,\\n 838: 30063826117310982372086476080,\\n 839: 31388166898835484452139885750,\\n 840: 32770027459303858556350798600,\\n 841: 34211871031752548278772284453,\\n 842: 35716264859093977687647313415,\\n 843: 37285884524590579748861394570,\\n 844: 38923518460115987806848673270,\\n 845: 40632072639400673752129300324,\\n 846: 42414575463747094337180792099,\\n 847: 44274182847997609942310578598,\\n 848: 46214183514849300594196193732,\\n 849: 48238004505931946889525421000,\\n 850: 50349216918401212177548479675,\\n 851: 52551541876147039010384562987,\\n 852: 54848856745079917639394818823,\\n 853: 57245201602333536237114022805,\\n 854: 59744785969613964515539259105,\\n 855: 62351995821331449988466091712,\\n 856: 65071400878573831543609957267,\\n 857: 67907762200418949875852866531,\\n 858: 70866040084540107092698343096,\\n 859: 73951402289532005957331751320,\\n 860: 77169232591877674590168543277,\\n 861: 80525139690988018278755885205,\\n 862: 84024966476277979232856334449,\\n 863: 87674799670795146675673859587,\\n 864: 91480979866491345649258758095,\\n 865: 95450111966823518214883921610,\\n 866: 99589076052990565170686659417,\\n 867: 103905038690755971019484297576,\\n 868: 108405464695475636367939373595,\\n 869: 113098129373644577851404473535,\\n 870: 117991131259998859170817958839,\\n 871: 123092905369958432777075796052,\\n 872: 128412236987976529870072690275,\\n 873: 133958276013169939669531019316,\\n 874: 139740551884446204479331411000,\\n 875: 145768989108216487062234772851,\\n 876: 152053923412691097170490155923,\\n 877: 158606118553696417431847045996,\\n 878: 165436783797931931934295220337,\\n 879: 172557592110602218633091543840,\\n 880: 179980699075416049556058362840,\\n 881: 187718762576041099642814429720,\\n 882: 195784963269243383580949581161,\\n 883: 204193025881123335512830178821,\\n 884: 212957241359090878236182734445,\\n 885: 222092489913497780851227603386,\\n 886: 231614264984172822820073009257,\\n 887: 241538698168481624527315178361,\\n 888: 251882585148964518765460484674,\\n 889: 262663412660090356154504995095,\\n 890: 273899386535208029575034561337,\\n 891: 285609460876378579895067651923,\\n 892: 297813368391435715163322531331,\\n 893: 310531651944349233813920512829,\\n 894: 323785697366761254448562966675,\\n 895: 337597767580427105501057917306,\\n 896: 351991038082228660789452118410,\\n 897: 366989633845435601723754690835,\\n 898: 382618667692977386826261193199,\\n 899: 398904280200653395819254517900,\\n 900: 415873681190459054784114365430,\\n 901: 433555192876539531087229255477,\\n 902: 451978294728708525214023001725,\\n 903: 471173670120985588372050797999,\\n 904: 491173254835220446432862090800,\\n 905: 512010287492584845146484412308,\\n 906: 533719361988531136324395159455,\\n 907: 556336482009740068071399064008,\\n 908: 579899117714618242279047917300,\\n 909: 604446264662056374189988834755,\\n 910: 630018505076433611630379753807,\\n 911: 656658071540248718776792346785,\\n 912: 684408913209287275550344075013,\\n 913: 713316764648893234122621625751,\\n 914: 743429217393715213042975617565,\\n 915: 774795794337240928934816284899,\\n 916: 807468027061529837515792402675,\\n 917: 841499536221802614337232047468,\\n 918: 876946115104959930393838357571,\\n 919: 913865816485680423486405066750,\\n 920: 952319042908502961911588247808,\\n 921: 992368640529229737341624411924,\\n 922: 1034079996654109332431762911842,\\n 923: 1077521141120571341397403386532,\\n 924: 1122762851668802145076610697775,\\n 925: 1169878763459173895733432737528,\\n 926: 1218945482896482311379736998403,\\n 927: 1270042705928112564209840426896,\\n 928: 1323253340989653981276400185806,\\n 929: 1378663636778122744608506419570,\\n 930: 1436363315039845896899358328033,\\n 931: 1496445708567209282036578487803,\\n 932: 1559007904605896258842021462474,\\n 933: 1624150893881942976244820893255,\\n 934: 1691979725465930503404211099660,\\n 935: 1762603667699924360130192603237,\\n 936: 1836136375421380008668856717532,\\n 937: 1912696063727159213943851080855,\\n 938: 1992405688530070149968413761596,\\n 939: 2075393134169954709485716047155,\\n 940: 2161791408351324312330912522447,\\n 941: 2251738844689892053427982289844,\\n 942: 2345379313161090374436414551558,\\n 943: 2442862438754801545567295092897,\\n 944: 2544343828652090726779455860435,\\n 945: 2649985308251720770267133439311,\\n 946: 2759955166386673475403099789409,\\n 947: 2874428410083806869907819978392,\\n 948: 2993587029233173241168779714732,\\n 949: 3117620271547411926979127053250,\\n 950: 3246724928206047105940972859506,\\n 951: 3381105630594468612010288127863,\\n 952: 3520975158562887897616477410546,\\n 953: 3666554760646647127956344306190,\\n 954: 3818074486705953843294627812035,\\n 955: 3975773533460423034845675035419,\\n 956: 4139900603411771887815710365915,\\n 957: 4310714277666637214536144927329,\\n 958: 4488483403190813123215639907302,\\n 959: 4673487495046245204241629451110,\\n 960: 4866017154182911354694265206413,\\n 961: 5066374501379277964399166419563,\\n 962: 5274873627947390097986152243705,\\n 963: 5491841063841846500452896053582,\\n 964: 5717616263835974099255567733750,\\n 965: 5952552112453464578853008309794,\\n 966: 6197015448369619941842104648894,\\n 967: 6451387609023188709970129910797,\\n 968: 6716064996207615136996693074302,\\n 969: 6991459663439386169435859778910,\\n 970: 7277999925931103886207676505429,\\n 971: 7576130994027952290703815097177,\\n 972: 7886315630998429231248733036419,\\n 973: 8209034836103596418058528755338,\\n 974: 8544788553903729460741526714750,\\n 975: 8894096410797147287955714755082,\\n 976: 9257498479823236816318777820416,\\n 977: 9635556074800288403768986034253,\\n 978: 10028852574908795418824727341746,\\n 979: 10437994280872373856676062879735,\\n 980: 10863611303931504965592652844878,\\n 981: 11306358488849924787366667765407,\\n 982: 11766916372239763961801564990016,\\n 983: 12245992177539511607834487453052,\\n 984: 12744320848028628464246059627690,\\n 985: 13262666119314202551196742822008,\\n 986: 13801821632778520931079437719552,\\n 987: 14362612091531863067120268402228,\\n 988: 14945894460472306341153073892017,\\n 989: 15552559212113915719970799358900,\\n 990: 16183531619906475296861224625027,\\n 991: 16839773100833956878604913215477,\\n 992: 17522282609145324707635966077022,\\n 993: 18232098083140097717852712346115,\\n 994: 18970297947002453464660671155990,\\n 995: 19738002669751617842096992232436,\\n 996: 20536376383452971700767593594021,\\n 997: 21366628562913781584556907794729,\\n 998: 22230015769169865076825741905555,\\n 999: 23127843459154899464880444632250,\\n 1000: 24061467864032622473692149727991,\\n 1001: 25032297938763929621013218349796,\\n 1002: 26041797385576000582369625213281,\\n 1003: 27091486754099167408984061096127,\\n 1004: 28182945621039436811282417218990,\\n 1005: 29317814852360484763188469380980,\\n 1006: 30497798951058731380716134731126,\\n 1007: 31724668493728872881006491578226,\\n 1008: 33000262659235183814081519827753,\\n 1009: 34326491852926110526276105821510,\\n 1010: 35705340429956356495500048880518,\\n 1011: 37138869521411924622451440267117,\\n 1012: 38629219967069644267226780200798,\\n 1013: 40178615358763694337831877170404,\\n 1014: 41789365198477765393682507986660,\\n 1015: 43463868175432916528376380161993,\\n 1016: 45204615566598118821992112719830,\\n 1017: 47014194765213080671467587361162,\\n 1018: 48895292942081479136595740785155,\\n 1019: 50850700844567331975836762416180,\\n 1020: 52883316738408211899530127054215,\\n 1021: 54996150497646497195116039121846,\\n 1022: 57192327848174163803231700285962,\\n 1023: 59475094770587936660132803278445,\\n 1024: 61847822068260244309086870983975,\\n 1025: 64314010106747559065438412709786,\\n 1026: 66877293730881687431325192921834,\\n 1027: 69541447366121616918816177545634,\\n 1028: 72310390310983979753319152713934,\\n 1029: 75188192227619293524858181464065,\\n 1030: 78179078837859260757658669457252,\\n 1031: 81287437832327804842152878336251,\\n 1032: 84517825000485590628268677129623,\\n 1033: 87874970589764795726619149717517,\\n 1034: 91363785902248291467082481888195,\\n 1035: 94989370137655453801161398756590,\\n 1036: 98757017491716010698603869808070,\\n 1037: 102672224519343960454073227246547,\\n 1038: 106740697772366151410092496101554,\\n 1039: 110968361721914939732387042839470,\\n 1040: 115361366975961956826368092270559,\\n 1041: 119926098802850790583643914139778,\\n 1042: 124669185972080868004022654618279,\\n 1043: 129597509924003418690815024769614,\\n 1044: 134718214280513689012974236132740,\\n 1045: 140038714709261994367964528304147,\\n 1046: 145566709154360370820516947589011,\\n 1047: 151310188447031979898125505211430,\\n 1048: 157277447310137702096803724432844,\\n 1049: 163477095771019024080265786609550,\\n 1050: 169918070997619096807349078318498,\\n 1051: 176609649573385253852206425342508,\\n 1052: 183561460227017093724267411668558,\\n 1053: 190783497033705025399011223174627,\\n 1054: 198286133105105766051740791002035,\\n 1055: 206080134785924286913455951259466,\\n 1056: 214176676375616994965530422655441,\\n 1057: 222587355394399185288134561600051,\\n 1058: 231324208413431926871476886628488,\\n 1059: 240399727469780275150398352541295,\\n 1060: 249826877087477024806306436682550,\\n 1061: 259619111926794902903903858282467,\\n 1062: 269790395084626208521306859330203,\\n 1063: 280355217069693265922512204254601,\\n 1064: 291328615477166797747643128851965,\\n 1065: 302726195388153340970512449363108,\\n 1066: 314564150520428320398942429589829,\\n 1067: 326859285157739328217944658021195,\\n 1068: 339629036885985812650521091739503,\\n 1069: 352891500165597792693064105229860,\\n 1070: 366665450770488753893927654278831,\\n 1071: 380970371125047658469252263285168,\\n 1072: 395826476571763477972460354798893,\\n 1073: 411254742603244027745802489871124,\\n 1074: 427276933093600703409672633110750,\\n 1075: 443915629565423279460548833975619,\\n 1076: 461194261529865886819548193737883,\\n 1077: 479137137938708024340405275972933,\\n 1078: 497769479788644748304553495300446,\\n 1079: 517117453919499510741582247311995,\\n 1080: 537208208049543370281513128274546,\\n 1081: 558069907092647074919064078269009,\\n 1082: 579731770803589829653889090465310,\\n 1083: 602224112799502127836867703068534,\\n 1084: 625578381007131993715400129218655,\\n 1085: 649827199587396195485096741151797,\\n 1086: 675004412390512738195023734124239,\\n 1087: 701145127996910209394091171983043,\\n 1088: 728285766401075776846633724874013,\\n 1089: 756464107397538946738052845597325,\\n 1090: 785719340730295196686468011045384,\\n 1091: 816092118069154575020287144949660,\\n 1092: 847624606878758096201928227674051,\\n 1093: 880360546248341702038727418718373,\\n 1094: 914345304752746677204951178080640,\\n 1095: 949625940417679322961779585842763,\\n 1096: 986251262864814583017230902369159,\\n 1097: 1024271897715020987348060381346241,\\n 1098: 1063740353330761125682320075116819,\\n 1099: 1104711089981595892462307006170625,\\n 1100: 1147240591519695580043346988281283,\\n 1101: 1191387439655339764253910592315288,\\n 1102: 1237212390925574690626025966996290,\\n 1103: 1284778456452494990829233226377379,\\n 1104: 1334150984591030161739618104847170,\\n 1105: 1385397746569649033264079085023363,\\n 1106: 1438589025231051837956193683375282,\\n 1107: 1493797706983703451005350179037500,\\n 1108: 1551099377078977592324977502565855,\\n 1109: 1610572418332734533482318570551190,\\n 1110: 1672298113414349146588255526290127,\\n 1111: 1736360750830546535004742869861557,\\n 1112: 1802847734735894350158767668809929,\\n 1113: 1871849698706449115822481531031302,\\n 1114: 1943460623617864164855763103650900,\\n 1115: 2017777959774244383161311335135412,\\n 1116: 2094902753439183950276117590000925,\\n 1117: 2174939777925753277977786731439319,\\n 1118: 2257997669407716887103312005936867,\\n 1119: 2344189067619971039484826726136835,\\n 1120: 2433630761622095504505007624351926,\\n 1121: 2526443840805024325560621670846260,\\n 1122: 2622753851327163276606626468293628,\\n 1123: 2722690958172823755991785784326387,\\n 1124: 2826390113032612069265970456163500,\\n 1125: 2933991228212416784843441604124699,\\n 1126: 3045639356784883554548008634432380,\\n 1127: 3161484879204764376319516386806829,\\n 1128: 3281683696617285755657387337131749,\\n 1129: 3406397431096706053660787897070925,\\n 1130: 3535793633060536116646611744883745,\\n 1131: 3670045996113488118329838058723628,\\n 1132: 3809334579584105681944821254585338,\\n 1133: 3953846039026223475533484851711932,\\n 1134: 4103773864966917551549475742004630,\\n 1135: 4259318630192449100691154502765975,\\n 1136: 4420688245873885709566584952625897,\\n 1137: 4588098226844616747507844508037264,\\n 1138: 4761771966352875646576237849731855,\\n 1139: 4941941020623653451737160975884815,\\n 1140: 5128845403576048431946742302750170,\\n 1141: 5322733892054158457915227866236060,\\n 1142: 5523864341942100491068450472029219,\\n 1143: 5732504015546648477080676455520535,\\n 1144: 5948929920644332374606657683899745,\\n 1145: 6173429161603651508297858791951031,\\n 1146: 6406299303007341112943259722223788,\\n 1147: 6647848746214407376439536432805536,\\n 1148: 6898397119316930779355317551024978,\\n 1149: 7158275680962446691834888697663475,\\n 1150: 7427827738529064471293660118664110,\\n 1151: 7707409081157399483953096394984678,\\n 1152: 7997388428160886234821473483000555,\\n 1153: 8298147893354134143293856722998488,\\n 1154: 8610083465857701451154337181278065,\\n 1155: 8933605507957017621037375468973282,\\n 1156: 9269139270613202791504126859283685,\\n 1157: 9617125427244236129299819591578718,\\n 1158: 9978020626416337178370164768812546,\\n 1159: 10352298064107568778430054733760345,\\n 1160: 10740448076228572334937735566562385,\\n 1161: 11142978752109030998555590333304243,\\n 1162: 11560416569682950887414131083801684,\\n 1163: 11993307053131181401163436777097233,\\n 1164: 12442215453765791987839842332792770,\\n 1165: 12907727454968012800119940123354311,\\n 1166: 13390449902019461518054086533162960,\\n 1167: 13891011557695348536983250121102793,\\n 1168: 14410063884518310798493113995825913,\\n 1169: 14948281854602503175542820411276425,\\n 1170: 15506364788049610799716682308517542,\\n 1171: 16085037220891570656183958875514689,\\n 1172: 16685049803609043819824168449851071,\\n 1173: 17307180231290097851615771678718278,\\n 1174: 17952234206530182283975172821446800,\\n 1175: 18621046436212348314484589328413725,\\n 1176: 19314481663345819649385158162679300,\\n 1177: 20033435735181507108244024178275807,\\n 1178: 20778836708864920831259413450679734,\\n 1179: 21551645995930215818617016034137500,\\n 1180: 22352859546983857840754489692613399,\\n 1181: 23183509077972665661421886007454584,\\n 1182: 24044663339478824029548767493555588,\\n 1183: 24937429430533921473492651656959612,\\n 1184: 25862954158495203059166455452470495,\\n 1185: 26822425446580095904068198565803164,\\n 1186: 27817073790709723558345700246365971,\\n 1187: 28848173767368633057992125893483779,\\n 1188: 29917045594246378653834785571179351,\\n 1189: 31025056745487001593014803461929555,\\n 1190: 32173623623434883211416744742294747,\\n 1191: 33364213288829995905464566634140396,\\n 1192: 34598345251472305106432161856883007,\\n 1193: 35877593323444056632515580254383154,\\n 1194: 37203587537049994338271609307035630,\\n 1195: 38578016129709269105524749061283955,\\n 1196: 40002627598109003613035027587346239,\\n 1197: 41479232824008249429294178038617951,\\n 1198: 43009707274162500911950054844789890,\\n 1199: 44595993276923101114218051405894000,\\n 1200: 46240102378152881298913555099661657,\\n 1201: 47944117779189310556261099429006223,\\n 1202: 49710196859679394486867802358932901,\\n 1203: 51540573788206651013836802198036893,\\n 1204: 53437562223729812777303406841914935,\\n 1205: 55403558110955564979344325681437822,\\n 1206: 57441042572873737644094937785113022,\\n 1207: 59552584903793044889004529388335732,\\n 1208: 61740845666328821093587961517238033,\\n 1209: 64008579895911365238424857597692590,\\n 1210: 66358640416504598253672231293216761,\\n 1211: 68793981271349892486345394543503614,\\n 1212: 71317661272679283934970057444157431,\\n 1213: 73932847674475963853859804733408932,\\n 1214: 76642819972498112301511348487927130,\\n 1215: 79450973835924928534740056571220837,\\n 1216: 82360825175131287067719845184002304,\\n 1217: 85376014350249959857626768802856615,\\n 1218: 88500310525337959944194241004565748,\\n 1219: 91737616173126446538485123122674660,\\n 1220: 95091971735501962459496140992085663,\\n 1221: 98567560445040729668418191983592407,\\n 1222: 102168713313097495533124764187939944,\\n 1223: 105899914290136190948927875636615483,\\n 1224: 109765805604181632042444034426405625,\\n 1225: 113771193283469872120310539095739833,\\n 1226: 117921052869579803514689801523449638,\\n 1227: 122220535327540435729044764084697099,\\n 1228: 126674973159627164610485151798391797,\\n 1229: 131289886729786527240095013237443045,\\n 1230: 136070990805862651658706033366694460,\\n 1231: 141024201327040104811696041691045190,\\n 1232: 146155642404167375009402954907061316,\\n 1233: 151471653560883058451095421311451141,\\n 1234: 156978797223733228787865722354959930,\\n 1235: 162683866469743733376335192519362494,\\n 1236: 168593893040195573779320686453020964,\\n 1237: 174716155629645388794651866300906835,\\n 1238: 181058188459536679140275000227478496,\\n 1239: 187627790146061111217741961494883890,\\n 1240: 194433032872253346998515292619988830,\\n 1241: 201482271874637706375741021005730181,\\n 1242: 208784155255090933098578892158986338,\\n 1243: 216347634128942766400406396453655835,\\n 1244: 224181973120705296790445342451587490,\\n 1245: 232296761219203590802475861123264133,\\n 1246: 240701923004274209788971782007579802,\\n 1247: 249407730257605432130910077287592727,\\n 1248: 258424813970713646981839124047488243,\\n 1249: 267764176763484957967824140618533500,\\n 1250: 277437205727159975794000686688315348,\\n 1251: 287455685706103555386947650491244181,\\n 1252: 297831813033180334721514504126791124,\\n 1253: 308578209734051855476222280888835192,\\n 1254: 319707938216222310789920115620477565,\\n 1255: 331234516459188101998422700026723439,\\n 1256: 343171933722591949005782567849433641,\\n 1257: 355534666789845852070090701405470932,\\n 1258: 368337696765269337188595637416276068,\\n 1259: 381596526443390734228095202493032600,\\n 1260: 395327198269680365975835178420652411,\\n 1261: 409546312912626108164576640399383898,\\n", "gt": "1262: 424271048467724485839916892830607059,\\n 1263: 439519180314644983035319377172158032,\\n 1264: 455309101649532274915393819410766690,\\n 1265: 471659844715141371979173526935980437,\\n 1266: 488591102752254955447569352295355812,\\n 1267: 506123252696611256922641286254645760,\\n 1268: 524277378646375504218896129395592376,\\n 1269: 543075296126019045035073055561928520,\\n 1270: 562539577173328634024088141916141596,\\n 1271: 582693576277154906994867051360796655,\\n 1272: 603561457194424687753064451343608383,\\n 1273: 625168220675887416175494833282535136,\\n 1274: 647539733131042629585359752478706350,\\n 1275: 670702756263704072335812679441391888,\\n 1276: 694684977710697693392039019806832594,\\n 1277: 719515042717266582828863521396088515,\\n 1278: 745222586883866905899271646915240282,\\n 1279: 771838270020186251303063741763018130,\\n 1280: 799393811143400700904158178331205389,\\n 1281: 827922024658910558926936487548336568,\\n 1282: 857456857763058308684876665745077292,\\n 1283: 888033429108637280324653641355847207,\\n 1284: 919688068775347054572190680423598070,\\n 1285: 952458359588743164917093657911776850,\\n 1286: 986383179832665621554422059019604497,\\n 1287: 1021502747401614623677846147487591813,\\n 1288: 1057858665441074072255055670604124719,\\n 1289: 1095493969525365696982675003469664810,\\n 1290: 1134453176424250386882487822532585142,\\n 1291: 1174782334511180318623311370757902964,\\n 1292: 1216529075867847432892383159101984374,\\n 1293: 1259742670141472479018316728428818781,\\n 1294: 1304474080213136065603158197122179375,\\n 1295: 1350776019737370796417180820702333527,\\n 1296: 1398703012615213588677365804960180341,\\n 1297: 1448311454464961662889458094993182194,\\n 1298: 1499659676156986538068572255824972432,\\n 1299: 1552808009481139790520320395733292300,\\n 1300: 1607818855017534550841511230454411672,\\n 1301: 1664756752283809987147800849591201736,\\n 1302: 1723688452234384707674372422071320679,\\n 1303: 1784682992189681523983975379146100758,\\n 1304: 1847811773275862853601073393199008865,\\n 1305: 1913148640458255774876416600453369682,\\n 1306: 1980769965254371045106648307068906619,\\n 1307: 2050754731215233987976941410834180457,\\n 1308: 2123184622266649887649796215921782211,\\n 1309: 2198144114005025303125952328225613580,\\n 1310: 2275720568045462559712283145467243327,\\n 1311: 2356004329523040680859896842728890474,\\n 1312: 2439088827851495409213115816339495726,\\n 1313: 2525070680846917026164254568053937634,\\n 1314: 2614049802327600836872111661056230165,\\n 1315: 2706129513304814950403979441635984290,\\n 1316: 2801416656882996994241981980679918559,\\n 1317: 2900021716991759392273170147031719072,\\n 1318: 3002058941076075680836616507226015622,\\n 1319: 3107646466875142011769945929778234485,\\n 1320: 3216906453424662618200536823961141148,\\n 1321: 3329965216421699826558324552595808770,\\n 1322: 3446953368095762574438358199469775528,\\n 1323: 3568005961734486838351757966808790919,\\n 1324: 3693262641017091556254336031236632750,\\n 1325: 3822867794313779335421691039194332368,\\n 1326: 3956970714114397433384120384166003416,\\n 1327: 4095725761754986283464866437718755283,\\n 1328: 4239292537616325490949332681096528358,\\n 1329: 4387836056974246172531213471126988170,\\n 1330: 4541526931687319371792477450694975225,\\n 1331: 4700541557913558825461268913956492487,\\n 1332: 4865062310053998559115610911870100035,\\n 1333: 5035277741127427794082646196764289585,\\n 1334: 5211382789787193810929017395424321210,\\n 1335: 5393578994197824268512706677957552625,\\n 1336: 5582074712996280787878705083147454523,\\n 1337: 5777085353569942323599828874448120571,\\n 1338: 5978833607890937159258923653545207827,\\n 1339: 6187549696154203668120613167259109435,\\n 1340: 6403471618474669930531089742522848797,\\n 1341: 6626845414907208756853259936695984136,\\n 1342: 6857925434061555771629308454994509373,\\n 1343: 7096974610593182332652154711768629954,\\n 1344: 7344264751860200848154682253520601870,\\n 1345: 7600076834045756410267481267000412856,\\n 1346: 7864701308055034793828023244287340980,\\n 1347: 8138438415506002236313232141990462682,\\n 1348: 8421598515143296812402544776496284973,\\n 1349: 8714502420015324706702901500511538625,\\n 1350: 9017481745765587687202719206979752339,\\n 1351: 9330879270400591290587334955958115107,\\n 1352: 9655049305908367725798746534773552348,\\n 1353: 9990358082113704664098849646925432237,\\n 1354: 10337184143168612691406936474627379320,\\n 1355: 10695918757089402353832391602114778863,\\n 1356: 11066966338764988954966020552846311185,\\n 1357: 11450744886874712432979257653673465667,\\n 1358: 11847686435168064074325478460954986607,\\n 1359: 12258237518573265193633495987026371935,\\n 1360: 12682859654616659385819889316805008574,\\n 1361: 13122029840650374087829702479479965035,\\n 1362: 13576241067401694028191547060980833568,\\n 1363: 14046002849374084164798517831067165046,\\n 1364: 14531841772646818920248481411605550560,\\n 1365: 15034302060637734370093170532411179780,\\n 1366: 15553946158411737537905952886830918329,\\n 1367: 16091355336136399592075372322853441977,\\n 1368: 16647130312305245611392419213169232605,\\n 1369: 17221891897369251284144496300865473815,\\n 1370: 17816281658437585657529146257903261665,\\n 1371: 18430962605729818628447970674590396131,\\n 1372: 19066619901483662703451906966061889217,\\n 1373: 19723961592044861669045607586672623550,\\n 1374: 20403719363889095930868650315257219250,\\n 1375: 21106649324349767740001100592550916016,\\n 1376: 21833532807850282420908580590825862986,\\n 1377: 22585177208464977793681819296712788065,\\n 1378: 23362416839659197789401547387242312544,\\n 1379: 24166113822086183031380235679888630795,\\n 1380: 24997159000346486985219767235597236100,\\n 1381: 25856472889644547994140059803514309099,\\n 1382: 26745006653306882839626895694957692242,\\n 1383: 27663743112157144914230446319916689190,\\n 1384: 28613697786775039130057416743650633105,\\n 1385: 29595919973698836617070193875375888205,\\n 1386: 30611493856665016404478212802210021309,\\n 1387: 31661539654013410832232951778996345076,\\n 1388: 32747214803422179685312303680676279243,\\n 1389: 33869715185174019207110095647396061120,\\n 1390: 35030276385193261591559928994266853030,\\n 1391: 36230174999132974647956742131787699078,\\n 1392: 37470729978831867653000833781535492047,\\n 1393: 38753304022502786601002774984625192104,\\n 1394: 40079305010057880061198034072619085310,\\n 1395: 41450187485020176719746625583516317963,\\n 1396: 42867454184517379844972195257339462150,\\n 1397: 44332657618901196005888853882051385939,\\n 1398: 45847401702584520468158717245312104000,\\n 1399: 47413343437739346154537960139775251600,\\n 1400: 49032194652550394774839040691532998261,\\n 1401: 50705723795773236966373450556265512689,\\n 1402: 52435757789401123913939450130086135644,\\n 1403: 54224183941301948277230817879517159495,\\n 1404: 56072951919745741389655873424027752720,\\n 1405: 57984075791803952210030966295696158116,\\n 1406: 59959636127664498822125654803605200455,\\n 1407: 62001782172971294457628166694777458740,\\n 1408: 64112734091363688056165357762141754716,\\n 1409: 66294785279460087023332346767177823090,\\n 1410: 68550304756601011890673498202891728627,\\n 1411: 70881739631740035679525259959146526016,\\n 1412: 73291617649946553739726907624791770380,\\n 1413: 75782549821062183481895201583751205263,\\n 1414: 78357233133132880842076215608511229415,\\n 1415: 81018453353321656721019131504035339537,\\n 1416: 83769087919092159661630333467319344902,\\n 1417: 86612108922541440552472192615179632742,\\n 1418: 89550586190851013626818983550558814889,\\n 1419: 92587690465918960312381724727166445110,\\n 1420: 95726696686332376146505918443171660625,\\n 1421: 98970987374939026118276437676742560264,\\n 1422: 102324056135379743432459471263142178485,\\n 1423: 105789511261048976512902596439531532566,\\n 1424: 109371079460060057837671640558228717300,\\n 1425: 113072609699904337559514844445146843472,\\n 1426: 116898077175609399692092533607036637857,\\n 1427: 120851587405321266865514819340648620862,\\n 1428: 124937380457358912643772141796859437854,\\n 1429: 129159835312916652764103424563956670300,\\n 1430: 133523474368721196662101633251149823925,\\n 1431: 138032968084085429989744342641002104875,\\n 1432: 142693139776940493084095678732486636969,\\n 1433: 147508970573571548730224671300676243591,\\n 1434: 152485604516930928407097683383484266510,\\n 1435: 157628353838555246722760639034336216136,\\n 1436: 162942704399270720489853224525723269795,\\n 1437: 168434321304033467550147269349447360294,\\n 1438: 174109054696419141315515890296286539118,\\n 1439: 179972945738449034728553750103340839325,\\n 1440: 186032232781617921513478910563182232444,\\n 1441: 192293357735172557401982780429019456969,\\n 1442: 198762972637879108865432799270626669004,\\n 1443: 205447946439712986100137659510287259781,\\n 1444: 212355372000105810413242676805207816705,\\n 1445: 219492573309591728816879034317080350983,\\n 1446: 226867112941909191440813277312570747145,\\n 1447: 234486799743834826784604048875528356971,\\n 1448: 242359696770253388472695000770509170206,\\n 1449: 250494129472202113601016657658116885375,\\n 1450: 258898694145869442049569648660373941152,\\n 1451: 267582266650777119653998333871688332247,\\n 1452: 276554011405631474170238269248906446792,\\n 1453: 285823390670594346502222808229127105074,\\n 1454: 295400174124997022998049389765214784995,\\n 1455: 305294448749801797154111873648107967492,\\n 1456: 315516629024405747970164359073870491229,\\n 1457: 326077467447680222173319384811207626600,\\n 1458: 336988065393447621514574974879775699372,\\n 1459: 348259884310914705271679879631949049780,\\n 1460: 359904757280909011630794460361074410538,\\n 1461: 371934900939102477916959218389244857418,\\n 1462: 384362927777754206102413138268506970021,\\n 1463: 397201858837862893052822862772992037235,\\n 1464: 410465136803989050790556876831592919085,\\n 1465: 424166639514388116438037562729473373486,\\n 1466: 438320693899488240621648045435196959242,\\n 1467: 452942090362151303283202948578566379295,\\n 1468: 468046097613572904390385124958730619192,\\n 1469: 483648477979107092056857426409232236010,\\n 1470: 499765503188744811845488653259134061244,\\n 1471: 516413970667431889729975411863080081224,\\n 1472: 533611220340883210895592492267492392503,\\n 1473: 551375151973035052959106187501778547015,\\n 1474: 569724243051777714078869714336553502625,\\n 1475: 588677567240126095472954965375170347997,\\n 1476: 608254813410517219620274841577537789254,\\n 1477: 628476305280471269092869681239382035111,\\n 1478: 649363021668417110482089106581996800736,\\n 1479: 670936617389064931646215631627734512060,\\n 1480: 693219444808308092528746108408911793239,\\n 1481: 716234576078254109447577888083725273959,\\n 1482: 740005826073621415936329176309708825539,\\n 1483: 764557776051394742131574284792974302805,\\n 1484: 789915798056308219059157433980611758115,\\n 1485: 816106080095422250986408555099636706156,\\n 1486: 843155652105778433840074131252109568468,\\n 1487: 871092412739856974449839116812405949463,\\n 1488: 899945156994323847635597208986502059289,\\n 1489: 929743604708340998940330812008055415670,\\n 1490: 960518429958522963981451968247615571768,\\n 1491: 992301291378458055449596203783102865285,\\n 1492: 1025124863431572512298240504372933893698,\\n 1493: 1059022868667002481099668362066093137208,\\n 1494: 1094030110989052198741424671895432081910,\\n 1495: 1130182509971758083662737515471154158801,\\n 1496: 1167517136251048459523457118438435734632,\\n 1497: 1206072248027988195015615498189010425646,\\n 1498: 1245887328717627537181110407053143579875,\\n 1499: 1287003125779035759903231323132670516000,\\n 1500: 1329461690763193888825263136701886891117,\\n 1501: 1373306420616547671126845059808771245199,\\n 1502: 1418582100279183135137313919163744611210,\\n 1503: 1465334946617783561814630036179107930696,\\n 1504: 1513612653734759530017526259861629678205,\\n 1505: 1563464439696213993716384678301014319431,\\n 1506: 1614941094722713228367155822930278965324,\\n 1507: 1668095030888183105149797247519563263487,\\n 1508: 1722980333373639710221714255936544610213,\\n 1509: 1779652813323895051112691937493275900640,\\n 1510: 1838170062356853750560836014387165897751,\\n 1511: 1898591508776536523215092101916644734126,\\n 1512: 1960978475542532205781057345396110080746,\\n 1513: 2025394240050193548750246784190116959083,\\n 1514: 2091904095777554301862779830720186765825,\\n 1515: 2160575415856657801620130127396601613839,\\n 1516: 2231477718628751807313395954393627156678,\\n 1517: 2304682735244622286166458817442330457493,\\n 1518: 2380264479373211819043135033180865953593,\\n 1519: 2458299319083597933290739975588639913960,\\n 1520: 2538866050967394665741511337736337646822,\\n 1521: 2622045976570688763353306228619701197220,\\n 1522: 2707922981206731940550655607258234921458,\\n 1523: 2796583615222784382740474040856321114152,\\n 1524: 2888117177796744121961996863481080757250,\\n 1525: 2982615803341503976179051696005120224577,\\n 1526: 3080174550597354460133578989992600710402,\\n 1527: 3180891494495199523837557418419727460583,\\n 1528: 3284867820875874297854866890890114734440,\\n 1529: 3392207924153452428300151849140308700620,\\n 1530: 3503019508013107340706503153715459439135,\\n 1531: 3617413689236849218690486699230663550120,\\n 1532: 3735505104753300028632631618647052984126,\\n 1533: 3857412022010595043668172932897782160438,\\n 1534: 3983256452774513571402317362452698824910,\\n 1535: 4113164270457046596687344259862579939532,\\n 1536: 4247265331083807518632379721321456268679,\\n 1537: 4385693598011986873811172464601561040968,\\n 1538: 4528587270513945762405321738705440092603,\\n 1539: 4676088916345038581429933773569294261235,\\n 1540: 4828345608417856657751813260670405103571,\\n 1541: 4985509065708793590462102906287902242693,\\n 1542: 5147735798526653777473353718656776051935,\\n 1543: 5315187258276961029029844229698454778001,\\n 1544: 5488029991859677773715074283837789258005,\\n 1545: 5666435800842220652541448314024017081118,\\n 1546: 5850581905553958890153341953182905874297,\\n 1547: 6040651114252811450773802339294340809537,\\n 1548: 6236831997519121462431059121804263835744,\\n 1549: 6439319068036685669987130768251283335700,\\n 1550: 6648312965925656816271400679772663779731,\\n 1551: 6864020649797022030147590897007762961557,\\n 1552: 7086655593703494823378002063833638733692,\\n 1553: 7316437990166946592699616833531354911573,\\n 1554: 7553594959467950148686513765206276332400,\\n 1555: 7798360765388617440490476800142578927168,\\n 1556: 8050977037605691145961262617379106893607,\\n 1557: 8311693000936800120986617647413681760089,\\n 1558: 8580765711648916968128569908862807858077,\\n 1559: 8858460301044367459544239649173485609090,\\n 1560: 9145050226546241655095435675456471213374,\\n 1561: 9440817530511750873400887128525102883050,\\n 1562: 9746053107008968945969854946579275550253,\\n 1563: 10061056976799496323982724378320247274070,\\n 1564: 10386138570776897699583240005533846228720,\\n 1565: 10721617022118294111300879958656795681727,\\n 1566: 11067821467414245473548388055474400555521,\\n 1567: 11425091357050045737330444087123696839842,\\n 1568: 11793776775119777282986614097061549565288,\\n 1569: 12174238769162940693809364157051309012420,\\n 1570: 12566849690022197996332017608789608083314,\\n 1571: 12971993542129749223451407990577313551957,\\n 1572: 13390066344539111423681390555352209300441,\\n 1573: 13821476503028593889295382128265725457026,\\n 1574: 14266645193612571525140101316505187638875,\\n 1575: 14726006757806758281011522810861817647486,\\n 1576: 15200009110004083021400239371051767831673,\\n 1577: 15689114157328479953978540694207577474781,\\n 1578: 16193798232344933888778097136641377589301,\\n 1579: 16714552539015476523707617004948193446275,\\n 1580: 17251883612302523293667801378616630723938,\\n 1581: 17806313791832981004049940595952236488989,\\n 1582: 18378381710048954709565959117356034045626,\\n 1583: 18968642795283648606471174187975250526914,\\n 1584: 19577669790214200898277149916663590160135,\\n 1585: 20206053286156727802917377116665528100452,\\n 1586: 20854402273682788549513827814948445887987,\\n 1587: 21523344710050833153156141436233019518750,\\n 1588: 22213528103960970088758743797991090055558,\\n 1589: 22925620118156604193077050587843661667620,\\n 1590: 23660309190412159054931489112539937306848,\\n 1591: 24418305173462226026373553546995875617627,\\n 1592: 25200339994444087406536213435901662689794,\\n 1593: 26007168334442658312725535116810982082161,\\n 1594: 26839568328744494665699148030346372021260,\\n 1595: 27698342288425638399643940633635778570228,\\n 1596: 28584317443916730715736989648170031498488,\\n 1597: 29498346711208035625096160181520548669694,\\n 1598: 30441309481376795323275876211869020871017,\\n 1599: 31414112434139702720919278494304352579875,\\n 1600: 32417690376154241824102577250721959572183,\\n 1601: 33453007104814231206634568834252067530087,\\n 1602: 34521056298307127650200260789840693447039,\\n 1603: 35622862432723524773564047600591620474611,\\n 1604: 36759481727032834297334619181982868193810,\\n 1605: 37932003116763385216396036596083684144149,\\n 1606: 39141549257250138871243034824146893141432,\\n 1607: 40389277557338916599575631087245664105779,\\n 1608: 41676381244462492794128018619459154745923,\\n 1609: 43004090462031141893576046232131339283625,\\n 1610: 44373673400108265833414174147846823131033,\\n 1611: 45786437460370592180018097454654125762209,\\n 1612: 47243730456382146639125256475201485557926,\\n 1613: 48746941850241791637271332996842921594539,\\n 1614: 50297504026695610706485495279896144769485,\\n 1615: 51896893605837832676324724372468638684687,\\n 1616: 53546632795557357169752166455397628534844,\\n 1617: 55248290784921291361962286829338022618145,\\n 1618: 57003485179722265948521834701738678421349,\\n 1619: 58813883481452695155464304054870553436360,\\n 1620: 60681204611006611632952513664174735563434,\\n 1621: 62607220478448273296879161314388228250413,\\n 1622: 64593757600226437608809675150800761682315,\\n 1623: 66642698765254062321100804776702438717922,\\n 1624: 68755984751315254218264566880232672144875,\\n 1625: 70935616093304583685847007991159666098679,\\n 1626: 73183654904848448867540438473174344075670,\\n 1627: 75502226754904045590148716826986516533057,\\n 1628: 77893522600978716067675261669847531834806,\\n 1629: 80359800780661049649804576562965921695475,\\n 1630: 82903389063205132690374405132401276101050,\\n 1631: 85526686762960833261150746165714536727005,\\n 1632: 88232166916496002397533755182876654157205,\\n 1633: 91022378525311020523414800627504843113662,\\n 1634: 93899948866102260607570160618726171594330,\\n 1635: 96867585870588824684642587049077568806146,\\n 1636: 99928080576976385190854302771818195507418,\\n 1637: 103084309655193176038845274579543287624753,\\n 1638: 106339238008096180814672350296895542938848,\\n 1639: 109695921450910408688484641855278054316360,\\n 1640: 113157509471230885841519620824589853318260,\\n 1641: 116727248071985676199747488789041121983568,\\n 1642: 120408482699828936375465082551662467674163,\\n 1643: 124204661261505763907840490901149694071182,\\n 1644: 128119337230805474780434782661196752002675,\\n 1645: 132156172848797007097973143732608413596901,\\n 1646: 136318942420119455804633282594364118870621,\\n 1647: 140611535708182363299559887896839185406573,\\n 1648: 145037961432214389489427685180617331098024,\\n 1649: 149602350869185430852497209043356597608875,\\n 1650: 154308961563716222079735293780517268790662,\\n 1651: 159162181149181008424137378091161149008138,\\n 1652: 164166531283303096726173462843072095335410,\\n 1653: 169326671701640055015539018518705699850330,\\n 1654: 174647404392455113639317800019372440640580,\\n 1655: 180133677896574006306024799468201257241780,\\n 1656: 185790591735932160859341593488427864239206,\\n 1657: 191623400974625892978847721669762887224010,\\n 1658: 197637520916393159778610138707329017740693,\\n 1659: 203838531942564585384018857484505756167480,\\n 1660: 210232184494643970555920434333513855824223,\\n 1661: 216824404205799439501151597527348613503086,\\n 1662: 223621297185671858108005694276757667011704,\\n 1663: 230629155463036280733315769829856728366831,\\n 1664: 237854462590985052006674013310829555807395,\\n 1665: 245303899419437913541037116166052239846061,\\n 1666: 252984350039925153650180418719145316631826,\\n 1667: 260902907907734605017003921684746498516403,\\n 1668: 269066882146662257820916698151184555362272,\\n 1669: 277483804041759534527674431707495428212025,\\n 1670: 286161433725627991209904771339900788624872,\\n 1671: 295107767063974496251592243518106809957385,\\n 1672: 304331042746306921569506210339059205494747,\\n 1673: 313839749587822198745641666552447374489321,\\n 1674: 323642634048715381224461508374001874352425,\\n 1675: 333748707977320256428395802157949938763484,\\n 1676: 344167256583679214774724367914264615318981,\\n 1677: 354907846650332656774577448740278805781989,\\n 1678: 365980334987316359577499492665661423156220,\\n 1679: 377394877138559089794329589034333523822720,\\n 1680: 389161936347082504011271085636055422264324,\\n 1681: 401292292786621190557291178310378056588836,\\n 1682: 413797053067502749043669672231562125696658,\\n 1683: 426687660024856256094871226711613620285845,\\n 1684: 439975902797452509721828685778957458838000,\\n 1685: 453673927205721269316833783775783610703320,\\n 1686: 467794246437739506976775111608393022209053,\\n 1687: 482349752052240657962887540925835136720740,\\n 1688: 497353725307958208396664918548576500570384,\\n 1689: 512819848828887897371554062220903289550130,\\n 1690: 528762218615331555088826226879544901167527,\\n 1691: 545195356410872371074704272735369048924689,\\n 1692: 562134222435726415975597022642148002675881,\\n 1693: 579594228497218762288102882601473336765100,\\n 1694: 597591251488444805746508999799665944566660,\\n 1695: 616141647286498628873307956507246249662412,\\n 1696: 635262265061980727342758633558885467930686,\\n 1697: 654970462011837401470060834112028353314761,\\n 1698: 675284118527933869908522234215965152162520,\\n 1699: 696221653814122968723573796976021441661750,\\n 1700: 717802041964941442478681516751205185010007,\\n 1701: 740044828519446608929091853958115568986164,\\n 1702: 762970147504097887787893822256219849371554,\\n 1703: 786598738978990637725956554797278124357808,\\n 1704: 810951967102164263980984405643613443347625,\\n 1705: 836051838727132970358751925465426223753244,\\n 1706: 861921022549226171951777077723669881527186,\\n 1707: 888582868816776806015468170319304987709289,\\n 1708: 916061429623659935353293704664261165680563,\\n 1709: 944381479800161498529884419450242134471605,\\n 1710: 973568538419648201851756811932637866236071,\\n 1711: 1003648890939014757529114525804772812444576,\\n 1712: 1034649611991404349880377024889805948451966,\\n 1713: 1066598588850232767185892564930056790115492,\\n 1714: 1099524545584096492698787529446425808960485,\\n 1715: 1133457067922710638072138797746330685194571,\\n 1716: 1168426628854604371943988173648061076656356,\\n 1717: 1204464614977899904017040550277724793430409,\\n 1718: 1241603353626116601935133531509635427501801,\\n 1719: 1279876140791574929056038110412443745546155,\\n 1720: 1319317269869626093912245397158785002901753,\\n 1721: 1359962061247603108750056330533001022811146,\\n 1722: 1401846892763077891420050435782921418973709,\\n 1723: 1445009231056717653171633051674494164837538,\\n 1724: 1489487663845762650867366119648959070605125,\\n 1725: 1535321933144897017630429081796659362863565,\\n 1726: 1582552969462055408849028210050341395113316,\\n 1727: 1631222926997501215103529967929557707274660,\\n 1728: 1681375219875327721201833943152266777825092,\\n 1729: 1733054559437372469717283290044275542482740,\\n 1730: 1786306992630397874710969065930279993530728,\\n 1731: 1841179941518278501517284167616876198477309,\\n 1732: 1897722243951848075290887164802970670035779,\\n 1733: 1955984195429997917538913727371549522655006,\\n 1734: 2016017592186583869120124322228807307858970,\\n 1735: 2077875775538691593667272042037771337062872,\\n 1736: 2141613677532831241625032098057988491948517,\\n 1737: 2207287867926682588244859017849269988676029,\\n 1738: 2274956602545091757332316519809900057062533,\\n 1739: 2344679873050131347512524469147852330603290,\\n 1740: 2416519458166178053962910323080826683013954,\\n 1741: 2490538976402136614754617183069000726495038,\\n 1742: 2566803940314147020741857199436825485292885,\\n 1743: 2645381812353354350387072647528700656565179,\\n 1744: 2726342062344598291243970336667065409029860,\\n 1745: 2809756226643193380147979076327264594704745,\\n 1746: 2895697969018322254247325865029474629995508,\\n 1747: 2984243143312953802987213049129995837626487,\\n 1748: 3075469857931627124375487934417729522202013,\\n 1749: 3169458542208911724615579730356050273697000,\\n 1750: 3266292014712865596629588272103919719684547,\\n 1751: 3366055553539366839888542445766361166135204,\\n 1752: 3468836968654792543650918885868953010691040,\\n 1753: 3574726676346161983924385238571158169261725,\\n 1754: 3683817775839551051322373817401051497424420,\\n 1755: 3796206128149322537872121900182662159228241,\\n 1756: 3911990437222503807420937006192549828899684,\\n 1757: 4031272333444480835500888704164496363681686,\\n 1758: 4154156459574067047582172896269352052007031,\\n 1759: 4280750559177948266124532321685590709003370,\\n 1760: 4411165567636502893727652799725970383582718,\\n 1761: 4545515705795050750500358651870382988186314,\\n 1762: 4683918576336696329734155119529513589827658,\\n 1763: 4826495262955104262123827190438060829061153,\\n 1764: 4973370432407778155253526316242844344573385,\\n 1765: 5124672439532710418254508515826522600609941,\\n 1766: 5280533435313631955425559713040649796775465,\\n 1767: 5441089478081518530016413892489308199319929,\\n 1768: 5606480647942507023374562583725669127988521,\\n 1769: 5776851164524941659873115036048663114937695,\\n 1770: 5952349508140909502130662763236950728528684,\\n 1771: 6133128544460338166089749412557583307068767,\\n 1772: 6319345652798518839604562697210438023241550,\\n 1773: 6511162858120786446819766577778364926946013,\\n 1774: 6708746966871038378408979787060247103179750,\\n 1775: 6912269706733805859936155115580770892194054,\\n 1776: 7121907870442710074828422368434553047727682,\\n 1777: 7337843463751340976339671250105665526337260,\\n 1778: 7560263857685892761905455418833343917244062,\\n 1779: 7789361945202278758472065509114228369126600,\\n 1780: 8025336302373932563237571980294779250756300,\\n 1781: 8268391354240084356595173268406241855198176,\\n 1782: 8518737545447984082077112629884273268761094,\\n 1783: 8776591515826329476185591848477738781761689,\\n 1784: 9042176281031049610986292577509011838783245,\\n 1785: 9315721418408596645489064435708989370524469,\\n 1786: 9597463258226012911089716132158337004512929,\\n 1787: 9887645080421270408475092400425112950304770,\\n 1788: 10186517317031728481382143156507032880864866,\\n 1789: 10494337760463026157910800552509870425432010,\\n 1790: 10811371777765321805152346144711499265489879,\\n 1791: 11137892531088517813516189325593809889812108,\\n 1792: 11474181204492965595127263976240658672733891,\\n 1793: 11820527237297139926370474832027317722017807,\\n 1794: 12177228564148905369732416163985994571309670,\\n 1795: 12544591862012275060173347722472359244046903,\\n 1796: 12922932804266987528897386291108558284524280,\\n 1797: 13312576322123804564848753689176255125112158,\\n 1798: 13713856873564166596625513497299706749207160,\\n 1799: 14127118720018736045636750699617456881311725,\\n 1800: 14552716211005418005132948684850541312590849,\\n 1801: 14991014076953676011289439394970540421861988,\\n 1802: 15442387730448363289492676946827168544596921,\\n 1803: 15907223576132871507960364168750022280398562,\\n 1804: 16385919329518164710931105850817769087241385,\\n 1805: 16878884344951220830025131180984215659580858,\\n 1806: 17386539953003552219964871974446413826117272,\\n 1807: 17909319807547825412134603270711842061393357,\\n 1808: 18447670242798154252456532648116438246904907,\\n 1809: 19002050640597405466197703977606842321053540,\\n 1810: 19572933808242837304672225027800498209481360,\\n 1811: 20160806367149596270203427106156960870472824,\\n 1812: 20766169152660030143204019897118002904900168,\\n 1813: 21389537625315443974415368124511782893607123,\\n 1814: 22031442293915835855052489509763576677617505,\\n 1815: 22692429150702307814484325155610270148732358,\\n 1816: 23373060119006260978552660565770602425866730,\\n 1817: 24073913513719160198707702330267411589158084,\\n 1818: 24795584514946598972622146485353975132184526,\\n 1819: 25538685655220618058549873928821959736691905,\\n 1820: 26303847320654738379516399526912590943781620,\\n 1821: 27091718266436968469332058999564180929593866,\\n 1822: 27902966147067146894819024985472934375689121,\\n 1823: 28738278061756389082181003004910619210874204,\\n 1824: 29598361115418134291077518460315335403586750,\\n 1825: 30483942995692340860959609721949330792795099,\\n 1826: 31395772566456765282571775715588003409132613,\\n 1827: 32334620478291992350263579043602637456626234,\\n 1828: 33301279796379969106727880491661424703794769,\\n 1829: 34296566646329244238310747147664839490574535,\\n 1830: 35321320878433937019039707727760782467717785,\\n 1831: 36376406750887666110543978036746824592455791,\\n 1832: 37462713632488269058784695792011875893039111,\\n 1833: 38581156725384149030225659607573893303383795,\\n 1834: 39732677808428507338475836002967756141425565,\\n 1835: 40918246001723570069537718918088365292496141,\\n 1836: 42138858552953206373244111655326855421732185,\\n 1837: 43395541646119076823784928057386091817027588,\\n 1838: 44689351233312655065605577356497222364030752,\\n 1839: 46021373890173147491957400810472661489846635,\\n 1840: 47392727695699507038180086415408337440470086,\\n 1841: 48804563137103411752378288723762455918172986,\\n 1842: 50258064040409270440055764682612968116562013,\\n 1843: 51754448527527040549257397842950059733038281,\\n 1844: 53294970000543912137117431914902281880953875,\\n 1845: 54880918154001741201408795026747551723720527,\\n 1846: 56513620015948521242261975310131861303268895,\\n 1847: 58194441018574179427502571579696887885537742,\\n 1848: 59924786099263589386584792985885004002385100,\\n 1849: 61706100832922923109471297093651456522575000,\\n 1850: 63539872596459336786702846316806859551222764,\\n 1851: 65427631766318517268030842666066129833124679,\\n 1852: 67370952950009825188774721810114716943378422,\\n 1853: 69371456252574676254257996014226320491002233,\\n 1854: 71430808578980422724679205565325409535341535,\\n 1855: 73550724973449352362958820460243849915161295,\\n 1856: 75732969996760532083864127998517020593740791,\\n 1857: 77979359142591108905489195759391328910134418,\\n 1858: 80291760293993362744249170815935430293952943,\\n 1859: 82672095221134305875868191384112819286758200,\\n 1860: 85122341121455964860570648618210990142492639,\\n 1861: 87644532203446685358824902714882088097498633,\\n 1862: 90240761315246892123800470058435668367783935,\\n 1863: 92913181619346739765141403639335218061558813,\\n 1864: 95664008314668029507699782676107535163671365,\\n 1865: 98495520407358668662814112828386043342039288,\\n 1866: 101410062531664839123433827120996801871554118,\\n 1867: 104410046822283945831589672011997862390810762,\\n 1868: 107497954839640363519148716631132136446924023,\\n 1869: 110676339549566018509524250906452596245408440,\\n 1870: 113947827358908961175629034752466582068886470,\\n 1871: 117315120208635333752283890034504840221064086,\\n 1872: 120780997726033548383095326244127836720276225,\\n 1873: 124348319437674093156601079636921240241787962,\\n 1874: 128020027044824211921357710559027384266649000,\\n 1875: 131799146763063790207250005304405120478900361,\\n 1876: 135688791727897158862480183289001251910301886,\\n 1877: 139692164468205234207238255169848532611147557,\\n 1878: 143812559449433484718637448310794816419480218,\\n 1879: 148053365688463686582704780998822076298210405,\\n 1880: 152418069442171341962802939167993644252844977,\\n 1881: 156910256971726023650131079907915129924767174,\\n 1882: 161533617384748818044426030157299715901448409,\\n 1883: 166291945557499506406187783344043042314534878,\\n 1884: 171189145139326194380356742395417581059236130,\\n 1885: 176229231641671815409487530302217850452007387,\\n 1886: 181416335613995339496338175675291780004357523,\\n 1887: 186754705909030660706666553292223320927706878,\\n 1888: 192248713039873061921465120214608474899151280,\\n 1889: 197902852631451912018290889751846175017276700,\\n 1890: 203721748969018888548080806839085873409222663,\\n 1891: 209710158646353589075380551065506324110555541,\\n 1892: 215872974316462949034790068311792114803360768,\\n 1893: 222215228547627476999327377660931337519227930,\\n 1894: 228742097787726004875938672290676073251112495,\\n 1895: 235458906439851487440117948662414751746035425,\\n 1896: 242371131052313431017875037233367567350390976,\\n 1897: 249484404626207844803286441041017222801266718,\\n 1898: 256804521043823251651497040551112296246458295,\\n 1899: 264337439621241331244215401011574782781334700,\\n 1900: 272089289788583262011466359201428623427767364,\\n 1901: 280066375901447845568248481717977121765830398,\\n 1902: 288275182187185106927480861934498895209154826,\\n 1903: 296722377829749335448869068867067104949579464,\\n 1904: 305414822196978537321624475491324386207138350,\\n 1905: 314359570214253084228181897886953506729950270,\\n 1906: 323563877888595040544848710079341268243350278,\\n 1907: 333035207987381310882223234930566921371066351,\\n 1908: 342781235875958450915909855966319285240611144,\\n 1909: 352809855518564809408156722848357746339640390,\\n 1910: 363129185647086702371268910149149152584766993,\\n 1911: 373747576102299648025575523786476989131026713,\\n 1912: 384673614352373402423945044973430693054218643,\\n 1913: 395916132193550721591800039752382776657876433,\\n 1914: 407484212638044530444951338680763930621994820,\\n 1915: 419387196994336597778328640988515637140928750,\\n 1916: 431634692145202999016827948773519398239274548,\\n 1917: 444236578028937695571550278721551746219224713,\\n 1918: 457203015329395575643972370763403591173830810,\\n 1919: 470544453380630393038248327984084169870052370,\\n 1920: 484271638292061317700921219995285769876393805,\\n 1921: 498395621300264386957594139661914904785275330,\\n 1922: 512927767353652135411965358701027725220931707,\\n 1923: 527879763936476202951968110645920036905758794,\\n 1924: 543263630138763896173977941441058199308011100,\\n 1925: 559091725978980633941148481298313317618632967,\\n 1926: 575376761986396071222827176058084413124270202,\\n 1927: 592131809050322598728023510231907577504041350,\\n 1928: 609370308543590994569721078158344505753246979,\\n 1929: 627106082727829397306582084065079630894972195,\\n 1930: 645353345448318619933615779058934561872409372,\\n 1931: 664126713126409278261223804893870154281524038,\\n 1932: 683441216057704415059243252710086070145621992,\\n 1933: 703312310024435417776917212697059694728111811,\\n 1934: 723755888230689211116144545349876787252027480,\\n 1935: 744788293569381118983800284897623329523811384,\\n 1936: 766426331230110600455862693324715237997598939,\\n 1937: 788687281657286442867926694461098498097562065,\\n 1938: 811588913868164118077309502293768840003949925,\\n 1939: 835149499140701056072067990291237777551833530,\\n 1940: 859387825081405748983159033075649135425638325,\\n 1941: 884323210083634058665255574996164926064666511,\\n 1942: 909975518187071057883524303147934812769277935,\\n 1943: 936365174349429389500998978473009079907862954,\\n 1944: 963513180141695685953126594506747030515761180,\\n 1945: 991441129878565264237073831290682236831192947,\\n 1946: 1020171227196022316757683410004293870517496706,\\n 1947: 1049726302088348378540247976304143049122065214,\\n 1948: 1080129828417176195331669321286587690711167057,\\n 1949: 1111405941905549479818145590739116367242780000,\\n 1950: 1143579458630301665664240006110545368915059329,\\n 1951: 1176675894026428898785508782184245465533665048,\\n 1952: 1210721482417504396219216523662601652136179376,\\n 1953: 1245743197086563215894590527223118960072913202,\\n 1954: 1281768770902278683167516719540860443130307320,\\n 1955: 1318826717515654486899160825985211020969456836,\\n 1956: 1356946353142870071117550937780046987060960843,\\n 1957: 1396157818950341697358512735475562356104045295,\\n 1958: 1436492104058497734745724852296636956267964954,\\n 1959: 1477981069181214654702422049514025480619599210,\\n 1960: 1520657470918320177914639277247113472181645153,\\n 1961: 1564554986719042364085227429425894281463674979,\\n 1962: 1609708240534768479916261201915809290266567989,\\n 1963: 1656152829179975566133060952832169077820577902,\\n 1964: 1703925349420706097654088225457498186848567210,\\n 1965: 1753063425810487348828764073209783931216955698,\\n 1966: 1803605739294132404035202382553315081341190088,\\n 1967: 1855592056600414568536728473961840601327835478,\\n 1968: 1909063260445175620937659060948648856259756235,\\n 1969: 1964061380567012302624155966071951926644451875,\\n 1970: 2020629625618285067432170725261207144994992239,\\n 1971: 2078812415934808833368620144510853807585221613,\\n 1972: 2138655417208217715431844885515291279369574680,\\n 1973: 2200205575085644913617857845505033592721522553,\\n 1974: 2263511150722025533817142690940119270064496250,\\n 1975: 2328621757311014594133664064174539456980750339,\\n 1976: 2395588397621215290008835331658621643021314292,\\n 1977: 2464463502565134245725579502592034085209328984,\\n 1978: 2535300970829021467547395315846813198183591546,\\n 1979: 2608156209592513548223075037746157905702847505,\\n 1980: 2683086176367779880674969950590007819202341357,\\n 1981: 2760149421988673761061033114268064448054050548,\\n 1982: 2839406134781213852952373747778159055380262422,\\n 1983: 2920918185947567114582770377976676661508796149,\\n 1984: 3004749176196572544459946686955919368234128060,\\n 1985: 3090964483654736576896042159262866214940589314,\\n 1986: 3179631313092546273793802882159493889001969611,\\n 1987: 3270818746501886244063493400323024051287288941,\\n 1988: 3364597795061310125684361619251416376860936489,\\n 1989: 3461041452526908153028282986522280729367368365,\\n 1990: 3560224750087529486464584716859554522268776125,\\n 1991: 3662224812724162303217742306542356590926722479,\\n 1992: 3767120917114346857096063738777247515406335526,\\n 1993: 3874994551123597548057533501867770741416429535,\\n 1994: 3985929474926940257994009093217001343955328335,\\n 1995: 4100011783804831583821441379839563991285227198,\\n 1996: 4217329972658917930562969936711305445974785514,\\n 1997: 4337975002294315534109569503386742455494341143,\\n 1998: 4462040367516348205694592687945941817364967127,\\n 1999: 4589622167090968789784046573687400867942870250,\\n 2000: 4720819175619413888601432406799959512200344166,\\n 2001: 4855732917379000237574365609687488912697273143,\\n 2002: 4994467742183366148074839035447416380393781644,\\n 2003: 5137130903316893622770745464235084139384928426,\\n 2004: 5283832637599517075572081746564260420858901705,\\n 2005: 5434686247639634059061258993904042430607990074,\\n 2006: 5589808186334383050291570992756471405633041387,\\n 2007: 5749318143678144230778676663789672984169195116,\\n 2008: 5913339135941752405965378691599572441324623941,\\n 2009: 6081997597286587859405678030809218670282246785,\\n 2010: 6255423473879432172551153347179787953125682826,\\n 2011: 6433750320575743037411316728215679204642749660,\\n 2012: 6617115400240816052275556661314890288999332009,\\n 2013: 6805659785780163657391920602286596663406217911,\\n 2014: 6999528464952353007567067145415164276505069670,\\n 2015: 7198870448039506994791503590601126801607534137,\\n 2016: 7403838878452687162912842119176262318542314409,\\n 2017: 7614591146351445269661694564912786246445478891,\\n 2018: 7831289005358953156344654888013498638339711692,\\n 2019: 8054098692456299826324570548607480763080403880,\\n 2020: 8283191051141781691732068101840743191755759916,\\n 2021: 8518741657943308344041302580996941768179250799,\\n 2022: 8760930952374403498169602637389577451855415964,\\n 2023: 9009944370426700552244228695797096011740585251,\\n 2024: 9265972481694316138437595284729122693073711400,\\n 2025: 9529211130228034799395854632912272457677896880,\\n 2026: 9799861579219855238744997642818047729388291567,\\n 2027: 10078130659621135236933601810787303619515113811,\\n 2028: 10364230922800330115415428619787879783434758914,\\n 2029: 10658380797349150440403847607713189208549844510,\\n 2030: 10960804750148870398245267228037581609577682339,\\n 2031: 11271733451811500913798689538973402825112404379,\\n 2032: 11591403946613603138135282386492611425148475178,\\n 2033: 11920059827043660471886625110700606109457615243,\\n 2034: 12257951413087152938966999455842406831025654415,\\n 2035: 12605335936376788660643906067688568691477294599,\\n 2036: 12962477729338745637101954446070534143126297085,\\n 2037: 13329648419469265315863347103932314055721954884,\\n 2038: 13707127128879519866370496154104287110788727040,\\n 2039: 14095200679250350101462435045670967566714006190,\\n 2040: 14494163802342243065803242497250145705564482929,\\n 2041: 14904319356209789989230727462504226498494263931,\\n 2042: 15325978547273839186092526952960232758544597811,\\n 2043: 15759461158408637244144834830819680263402565217,\\n 2044: 16205095783205438232082764786847977319531548455,\\n 2045: 16663220066578357477963673318612506891057322162,\\n 2046: 17134180951882656619355889974597586372298980947,\\n 2047: 17618334934720173062514849536736413843694654543,\\n 2048: 18116048323611252751541173214616030020513022685,\\n 2049: 18627697507717313357328883548487129542980353125,\\n 2050: 19153669231803058848943059805108758933859747374,\\n 2051: 19694360878632389188479682121479772827588278091,\\n 2052: 20250180758997203961018562965051517467373563574,\\n 2053: 20821548409583589567679943310731809893410960813,\\n 2054: 21408894898885309715106534167513145969112337635,\\n 2055: 22012663141380091963647773040348591535494857021,\\n 2056: 22633308220189922777870335143856096247251187948,\\n 2057: 23271297718452433681930253947266040250043569734,\\n 2058: 23927112059636485682887466272819725468557276242,\\n 2059: 24601244857041242112722641487525252331485884885,\\n 2060: 25294203272724365584159904646608138971697036406,\\n 2061: 26006508386111487092631615069752229687889047419,\\n 2062: 26738695572545778772495897103306702147812265676,\\n 2063: 27491314892043320887814631666080168776331811888,\\n 2064: 28264931488526992879603605279805458570836160570,\\n 2065: 29060125999818842393508123538658855855869573724,\\n 2066: 29877494978678299986437859187588252356283557915,\\n 2067: 30717651325181215594079225685922159612710890246,\\n 2068: 31581224730742500897001026737587458361246031363,\\n 2069: 32468862134093174645484430948409904593113694670,\\n 2070: 33381228189530831120385246576357623531476650368,\\n 2071: 34319005747770990684777087747947525376490393829,\\n 2072: 35282896349735451425203004555804514075824949148,\\n 2073: 36273620733622647942922713748119798292462316154,\\n 2074: 37291919355614143333586997222803939193763027250,\\n 2075: 38338552924580739339245889549713324449360541521,\\n 2076: 39414302951161293776274047281093717842584188891,\\n 2077: 40519972311597190003244878215733219997449415843,\\n 2078: 41656385826715516924455731088372893657996361228,\\n 2079: 42824390856464396526209228476474575762774879465,\\n 2080: 44024857910414546084950481401735302373848095782,\\n 2081: 45258681274652091016547586287700221970008068755,\\n 2082: 46526779655498859083237494859206365034702358134,\\n 2083: 47830096840507894753763929606166424148960110424,\\n 2084: 49169602377193741528342591922356853935149504975,\\n 2085: 50546292269969157794099110029993948769746687671,\\n 2086: 51961189695772366269783089381199090558960547606,\\n 2087: 53415345738881696537662435419712492307334180478,\\n 2088: 54909840145427572963129830596638040418770704515,\\n 2089: 56445782098125235102442269204682620745124030885,\\n 2090: 58024311011765363351557172881384457469348901699,\\n 2091: 59646597350013928176910703744766844433767270677,\\n 2092: 61313843464087096107973721257849778294625405081,\\n 2093: 63027284453881919316292784641070835053831354052,\\n 2094: 64788189052158817856342546799691255570877518150,\\n 2095: 66597860532387544551063529093372826237515675728,\\n 2096: 68457637640884412378329010378860869685804024262,\\n 2097: 70368895553885073626926030071097479233359907864,\\n 2098: 72333046860214079886074787715712944920415424984,\\n 2099: 74351542570229833233029956235268391407949627875,\\n 2100: 76425873151741373195807749021080021459080291165,\\n 2101: 78557569593611742891613633197716231871513782517,\\n 2102: 80748204497781453174729297053600127492388932998,\\n 2103: 82999393200464827976246067679320326020971457938,\\n 2104: 85312794923291779902869927934730036659721510375,\\n 2105: 87690113955187845526792666366851401712801134274,\\n 2106: 90133100865806117918203480753613859038381596324,\\n 2107: 92643553751346063460833585063932351673594098859,\\n 2108: 95223319513616114811576859302283546424619314506,\\n 2109: 97874295173219406337291510865301717288885200445,\\n 2110: 100598429217765077170980775830078597915978709260,\\n 2111: 103397722986031225236603653787203378188231402292,\\n 2112: 106274232089029868642533106912359104776603150690,\\n 2113: 109230067868949174578477633685673008965957469120,\\n 2114: 112267398896973766514395710229044460157179222920,\\n 2115: 115388452511010134752244464747991318862444784689,\\n 2116: 118595516394371070307305070689995677519803374830,\\n 2117: 121890940196500635216372474879596908517840948778,\\n 2118: 125277137196849491653446187682001921308870438795,\\n 2119: 128756586013039456106279781429309224204637155235,\\n 2120: 132331832354485942225817194731144948296095338913,\\n 2121: 136005490822677526183628341619662696228169437779,\\n 2122: 139780246759343231332496879136294914183920566235,\\n 2123: 143658858143770305041408732118198629930850140819,\\n 2124: 147644157540568270666807354340091712330909224000,\\n 2125: 151739054099208903158067016467162544501125246216,\\n 2126: 155946535606706519753573960842521384418556790909,\\n 2127: 160269670594838620141199867367375227901178121673,\\n 2128: 164711610503343476443764262455655533446463188624,\\n 2129: 169275591900568786145109713871008667212574145360,\\n 2130: 173964938763083984897646967444489323060065487907,\\n 2131: 178783064815808295968062329270497666350416021621,\\n 2132: 183733475934247094438727208707795835845879643176,\\n 2133: 188819772610470713392617031395550078686410106988,\\n 2134: 194045652484512443040038057363040342445733893240,\\n 2135: 199414912942906199650168544999618866932966543484,\\n 2136: 204931453786129197483756438132982529754356479553,\\n 2137: 210599279966760972657750340621024569609658319243,\\n 2138: 216422504400217312716806872498425178952708753752,\\n 2139: 222405350849966070103844047835296998593257719870,\\n 2140: 228552156889181512949138540918848061266047740791,\\n 2141: 234867376940844824665120188180587152072518199582,\\n 2142: 241355585398350637585388084310633650150819331465,\\n 2143: 248021479828733108998565670865001643954560554353,\\n 2144: 254869884260680054932039940494913967190530868955,\\n 2145: 261905752559560083345100350260758248905652921875,\\n 2146: 269134171891745550301357546978902318483150550307,\\n 2147: 276560366280573537433149830945908221546675684073,\\n 2148: 284189700256347954756384460822072399114186994724,\\n 2149: 292027682602848348780952829894171946286185196525,\\n 2150: 300079970202875082019467410865495625479979094694,\\n 2151: 308352371985426287572392634796034918345831989966,\\n 2152: 316850852977169433649870812195036854291507911207,\\n 2153: 325581538460939500937426146405250734530774231825,\\n 2154: 334550718244066724977417207615678241114465752975,\\n 2155: 343764851039409631696645200323540686552303329604,\\n 2156: 353230568962043743490045985418104968175497835998,\\n 2157: 362954682144632903677995273534058279957414924705,\\n 2158: 372944183474588707707117294510467908715140736065,\\n 2159: 383206253456204090418195791785818308423831594945,\\n 2160: 393748265201029751587449904786884268416346918520,\\n 2161: 404577789549846859589538794509144411672022826612,\\n 2162: 415702600329676409598230534926593885982499170401,\\n 2163: 427130679749354783768755297437892949499654467597,\\n 2164: 438870223937296523272831771890659665602286473475,\\n 2165: 450929648625159134260052749493609306300370136632,\\n 2166: 463317594981220971649101966934064855005088490212,\\n 2167: 476042935597381937471938911243959272191670950572,\\n 2168: 489114780633797957215706040263930987465371910798,\\n 2169: 502542484125264022730810437527574105649622691760,\\n 2170: 516335650453567079927347553251246871212620557984,\\n 2171: 530504140990139261462232960508189648909724886170,\\n 2172: 545058080913453988432836606455557467047353067377,\\n 2173: 560007866205722361999363584087410496745060913524,\\n 2174: 575364170833565108914383039346175332072363129225,\\n 2175: 591137954117456209042263051672264094963902965317,\\n 2176: 607340468294858294890172396576637459876728673686,\\n 2177: 623983266282097051667127111749751355541610352255,\\n 2178: 641078209640152242143041148426227499209194350336,\\n 2179: 658637476749676716333547258428298949880301221655,\\n 2180: 676673571200691926609848235322274189175428592431,\\n 2181: 695199330402549141183113024435698489390907024630,\\n 2182: 714227934419889822186067591088150189762713935508,\\n 2183: 733772915040486600160233205517764582904605949651,\\n 2184: 753848165080998028345195047409661205734061410010,\\n 2185: 774467947936825933802831039011913166290856798904,\\n 2186: 795646907382423796556925927113569848920749045025,\\n 2187: 817400077628568283525440629036885986580578161120,\\n 2188: 839742893643273944545131128461036809985928936965,\\n 2189: 862691201743203249313515607587263855592485446510,\\n 2190: 886261270462600715344592984957682094231262687955,\\n 2191: 910469801706960959527768615813845716032362752763,\\n 2192: 935333942198826213870111109341848015258586306792,\\n 2193: 960871295223299296636466125655717340185883228697,\\n 2194: 987099932681053343467853379878084516482176109430,\\n 2195: 1014038407456819902258601282188003020164821077713,\\n 2196: 1041705766111542406799393149921058024912789843193,\\n 2197: 1070121561906592696806185003711836723976318646033,\\n 2198: 1099305868168664278558814578725663660095230751347,\\n 2199: 1129279292004177556899411779284367814322107068750,\\n 2200: 1160062988372259455129906418328374912794875140516,\\n 2201: 1191678674525592817234330378465180518007035567938,\\n 2202: 1224148644828669903250292851179037002332204681842,\\n 2203: 1257495785963229293609758350537517985043490101070,\\n 2204: 1291743592530906765707814604565428064732892610835,\\n 2205: 1326916183063388353539586696826007823016666575690,\\n 2206: 1363038316450618010620081932775702626766948267742,\\n 2207: 1400135408797883233268006240578157606704308520406,\\n 2208: 1438233550722879835539717164127729784341377881813,\\n 2209: 1477359525104141972742451850876428128946776467300,\\n 2210: 1517540825292515665993072463432902551892845533240,\\n 2211: 1558805673797653668641491334803497135876242089678,\\n 2212: 1601183041461816724044580259727354612842328867083,\\n 2213: 1644702667133581285344348736857245137869671730074,\\n 2214: 1689395077854376798567156661483099222514277324220,\\n 2215: 1735291609571106892437555774714449031725527460139,\\n 2216: 1782424428388448478757191595009703327418571383436,\\n 2217: 1830826552374771058174587388568897962322872702465,\\n 2218: 1880531873935975665104704330318867749822093808655,\\n 2219: 1931575182771919095318938056959674511017686068185,\\n 2220: 1983992189430464568754141912398798172706580941262,\\n 2221: 2037819549474585022525115674537508812727151594151,\\n 2222: 2093094888278340044956073813211683523416074682898,\\n 2223: 2149856826467952296650447653773869417501164619869,\\n 2224: 2208145006024624371311040214176565237134381870625,\\n 2225: 2268000117066162685610486257867691977952149636083,\\n 2226: 2329463925324911418747662088887963091854286975547,\\n 2227: 2392579300339947019867081675868949317697298397221,\\n 2228: 2457390244381942643492189138307718097264928854677,\\n 2229: 2523941922129582344692758164350149756471869195790,\\n 2230: 2592280691116887259141942758496845583141659899537,\\n 2231: 2662454132971310608073787558386111506684369385813,\\n 2232: 2734511085462965511444391934177140596906494183587,\\n 2233: 2808501675385869578994261445169376899379754972068,\\n 2234: 2884477352292623400907075579322579400861330771315,\\n 2235: 2962490923104486707892612022451087039141493329190,\\n 2236: 3042596587619376453548710860694923114675620792521,\\n 2237: 3124849974940885736970186673957557524827120772983,\\n 2238: 3209308180852011686602310843936272621314792055526,\\n 2239: 3296029806157884531966398832249411659082252110525,\\n 2240: 3385074996022409471869790373849802994298808805690,\\n 2241: 3476505480324367989101580130555189921672623462046,\\n 2242: 3570384615059176354982401320439389024740905215964,\\n 2243: 3666777424813166614813801947045518673161561892966,\\n 2244: 3765750646337939759592154130429553527537766985115,\\n 2245: 3867372773253042492891322334008521298830352179629,\\n 2246: 3971714101905938427653556222571377434088646307540,\\n 2247: 4078846778418982139592272233327190495676444439866,\\n 2248: 4188844846953860716858469962505733762730156946697,\\n 2249: 4301784299224742745702713528067084946594634381000,\\n 2250: 4417743125292169536796493320206228992803910550343,\\n 2251: 4536801365670538316236136117174461033288094273661,\\n 2252: 4659041164782862580763013973003868359053553220232,\\n 2253: 4784546825797351362566231731168417844332785838733,\\n 2254: 4913404866881227292111965728061869527659853830530,\\n 2255: 5045704078908103627757617096847635981526636026359,\\n 2256: 5181535584656163391837451036356625290841516214407,\\n 2257: 5320992899535329981545125277691916180855473998805,\\n 2258: 5464171993882588690437588095807084889323827738187,\\n 2259: 5611171356865613078294130300389571289206397311350,\\n 2260: 5762092062035869673687412904560243239930531635515,\\n 2261: 5917037834573419710379575999541430738890622626340,\\n 2262: 6076115120266708126452900640242923623341866228338,\\n 2263: 6239433156271728550695355451490575993085942292134,\\n 2264: 6407104043696079137218319509378718229702705761905,\\n 2265: 6579242822054578576274630855578948789533455298734,\\n 2266: 6755967545644295113522674510292835122483775946206,\\n 2267: 6937399361888054675782970897485983723264323011797,\\n 2268: 7123662591696737970806754341094737575112103730614,\\n 2269: 7314884811901951462222340761939935289641834289395,\\n 2270: 7511196939811964197947649707463044206175866380723,\\n 2271: 7712733319945142389521924617582058172801542180874,\\n 2272: 7919631812996487219317452100595913257543028088576,\\n 2273: 8132033887094289430962576814720449927838393960827,\\n 2274: 8350084711405357694774361105408889911972402015300,\\n 2275: 8573933252148757415018198504928925593185861873742,\\n 2276: 8803732371079513461579268567498022304249933730391,\\n 2277: 9039638926505285189617314422998964084970595438542,\\n 2278: 9281813876900616004271298745383250743059729594527,\\n 2279: 9530422387184993604151073155371828079705355168950,\\n 2280: 9785633937732631891816046069641124632254214557235,\\n 2281: 10047622436183602390848394841406802515973193043806,\\n 2282: 10316566332127702901769041143039403233989122380996,\\n 2283: 10592648734734255132957468343310308444321456043571,\\n 2284: 10876057533402872254341014560334244700946683620780,\\n 2285: 11166985521512132864360358955503173717957792328653,\\n 2286: 11465630523345040885726361109312137419668093929920,\\n 2287: 11772195524272142592252579142228927699835475405262,\\n 2288: 12086888804275213526126666074714236379441857513978,\\n 2289: 12409924074896520730686758323108856061617655222490,\\n 2290: 12741520619700810766902679602920740106349316265795,\\n 2291: 13081903438339372702369995825105861818651826992639,\\n 2292: 13431303394307778991751050067148151893379620506077,\\n 2293: 13789957366491217272065156663906255405414311071587,\\n 2294: 14158108404593693973445004415760318309772932242370,\\n 2295: 14536005888549817728742960090051403934327801222156,\\n 2296: 14923905692020358321733692442892587286459907678047,\\n 2297: 15322070350075326847761463298913968554265401515217,\\n 2298: 15730769231170936413643835624649288938501733002618,\\n 2299: 16150278713529481654471379166675899361510665760775,\\n 2300: 16580882366033921211442301450921091904365926280416,\\n 2301: 17022871133751761754598643267756804218108498650480,\\n 2302: 17476543528205726845562009156571175360531579106807,\\n 2303: 17942205822511650658087298129211531345495818175057,\\n 2304: 18420172251507067091174412069974707159021665744880,\\n 2305: 18910765216997070947078996545777114475682919623589,\\n 2306: 19414315498247211476154846356983916621521411447697,\\n 2307: 19931162467856441629277246980513463599759674413041,\\n 2308: 20461654313146490770914182133145338856645809727187,\\n 2309: 21006148263207456404192932627622104852595304280970,\\n 2310: 21565010821742923705373368869534441911701199887419,\\n 2311: 22138618005861522471365237940368652982888104075000,\\n 2312: 22727355590965521614482418924663783733921186781149,\\n 2313: 23331619361890843810727406215610806254135308857160,\\n 2314: 23951815370456759593096244705083096637451017834880,\\n 2315: 24588360199587493406897494649744406335205727290057,\\n 2316: 25241681234172046294108468111219387029991510514102,\\n 2317: 25912216938832713390963025920891990759428674050912,\\n 2318: 26600417142777051809706408361950504454660772072685,\\n 2319: 27306743331912438295458811467722364839525869129400,\\n 2320: 28031668948406848928849481174161195141360108410956,\\n 2321: 28775679697884097775242882020060349688803476984805,\\n 2322: 29539273864446490518541231137563989837057604952179,\\n 2323: 30322962633722685585711432023667002655631855893969,\\n 2324: 31127270424143511960418282768032077800615961592375,\\n 2325: 31952735226653572764265207581869821725011637243487,\\n 2326: 32799908953071669788426324706615644528794262188810,\\n 2327: 33669357793318419597396187557448074241909961160527,\\n 2328: 34561662581734899786701292837993789078148269659948,\\n 2329: 35477419172721767722086620675579581559062365395875,\\n 2330: 36417238825934036963035091771377814636876895938849,\\n 2331: 37381748601272582004301821355152191840543933044480,\\n 2332: 38371591763919473464910961559285225914454949449279,\\n 2333: 39387428199670427009917909560877277324279071654230,\\n 2334: 40429934840823983789090419362572880622618841036000,\\n 2335: 41499806102893531791299424581039874366426784160676,\\n 2336: 42597754332414930108684698464207986438238414531147,\\n 2337: 43724510266129315639709919648795164529190983190550,\\n 2338: 44880823501827658290753362113015735891775860228025,\\n 2339: 46067462981150790416506320013365490407603364278280,\\n 2340: 47285217484645973326080769865489605746387338228688,\\n 2341: 48534896139388582534016509015707084448606794509814,\\n 2342: 49817328939485198519236927086579980055136752412153,\\n 2343: 51133367279782285645165745517535680609133370052296,\\n 2344: 52483884503112733276871946748564813602003527319855,\\n 2345: 53869776461420824806590383880147822175719204551469,\\n 2346: 55291962091114697184508819760614991511857392669436,\\n 2347: 56751384003004060684283391440819878903446789803099,\\n 2348: 58249009087189871171927544609837628960380623034142,\\n 2349: 59785829133281790377677305788784327434428364970750,\\n 2350: 61362861466328639006942053695686748622617850877171,\\n 2351: 62981149598856648513992946515066172932792511110884,\\n 2352: 64641763899420155681002068750650481144652897951882,\\n 2353: 66345802278079465613952539750862814246981008871159,\\n 2354: 68094390889230939345801166300675543634997580023495,\\n 2355: 69888684852224948030989898005576415781403878920995,\\n 2356: 71729868990218182977254525351745038902483193889528,\\n 2357: 73619158587717925895914811729724245783180985354842,\\n 2358: 75557800167287273321320320811040130784252221919060,\\n 2359: 77547072285891979874115998945868567670402747044445,\\n 2360: 79588286351381543804941144999617740627898062871643,\\n 2361: 81682787459609412105690788920445375282931841060492,\\n 2362: 83831955252709738636327407566454519669269037443061,\\n 2363: 86037204799060994583504133500298291142599767525961,\\n 2364: 88299987495479913719532319572840702828357104994815,\\n 2365: 90621791992202763126914659986946872015595738278003,\\n 2366: 93004145141224771243446359569837640488487305606833,\\n 2367: 95448612968582727407224954007027627693270062216153,\\n 2368: 97956801671180298878693599735216669857785613237715,\\n 2369: 100530358638770501129135789786132580428696541463525,\\n 2370: 103170973501725013759939661850158896906366983382795,\\n 2371: 105880379205235666714568162057607929186246674835477,\\n 2372: 108660353110609438642727243903401536959027659486124,\\n 2373: 111512718124334720773264584058717478384571245088082,\\n 2374: 114439343855613415076071522953096149591716910973500,\\n 2375: 117442147803070664704054798350668120890654926300513,\\n 2376: 120523096571371667803183996442776155815729810091602,\\n 2377: 123684207118493113105268436573489685721321552781151,\\n 2378: 126927548034415307868377394917913546501247383867613,\\n 2379: 130255240852020056553944404306572055559539047530145,\\n 2380: 133669461390998803240347188535274022509125836065110,\\n 2381: 137172441135595483551688849972013947996581871778170,\\n 2382: 140766468647028954484433593096055372616292751308832,\\n 2383: 144453891011460794882135190497537058556764977948995,\\n 2384: 148237115324395707667015292482470242745754168289775,\\n 2385: 152118610212423719809411357105042520067307779240520,\\n 2386: 156100907393235880227548485941067592747534460439448,\\n 2387: 160186603274868212495995174730244824826286924759060,\\n 2388: 164378360595152301854136694694118079266206458932708,\\n 2389: 168678910102375098323537690529566365095195830119715,\\n 2390: 173091052278175313875346442702502205694341724313429,\\n 2391: 177617659103729195986746184184236646145304254737028,\\n 2392: 182261675870304487388520687355584130250935690880972,\\n 2393: 187026123035288047490867195922886699634867141186408,\\n 2394: 191914098124819930404162679326110679178204492902970,\\n 2395: 196928777684194703542432119373410255613845416290627,\\n 2396: 202073419277219465790162920942761564437025278844409,\\n 2397: 207351363535747401800832745531222095970123079470866,\\n 2398: 212766036260635806253027202800291886071043511130893,\\n 2399: 218320950575408346303872686615815518603736687265550,\\n 2400: 224019709133932919957689061390552862746031758458304,\\n 2401: 229866006383458830949778967121025947053151071434926,\\n 2402: 235863630884390155812442175854014517889393984836232,\\n 2403: 242016467688206145276344061824939391497289921344319,\\n 2404: 248328500774974299762177021852107412058234599633660,\\n 2405: 254803815551937407606287486346848530864431251682411,\\n 2406: 261446601414692355496335282873363983668020889836360,\\n 2407: 268261154372515934523018586706764224652758295238166,\\n 2408: 275251879739431193944393927980843975448015734231456,\\n 2409: 282423294892647160394499527988292633580813431968720,\\n 2410: 289780032100044965565638185282633831588088504297253,\\n 2411: 297326841418424633617945474627449518623223932967198,\\n 2412: 305068593664268994544312629723329236676843814611957,\\n 2413: 313010283458824435839645487672681448751536128120719,\\n 2414: 321157032349342507073515697424466804962980378707300,\\n 2415: 329514092008371775927573078641257544141430283832310,\\n 2416: 338086847513035826131406156272669425469096435441169,\\n 2417: 346880820706280914339971199061511110032851886967137,\\n 2418: 355901673642125591813707043622534952223283339280101,\\n 2419: 365155212116994575920151188842851740380508864908970,\\n 2420: 374647389289270354779812696943359199223073776527524,\\n 2421: 384384309389248455327267290257609074709972871788879,\\n 2422: 394372231521736030856900123129107963761511852907062,\\n 2423: 404617573563588459702218138566029837845857058362469,\\n 2424: 415126916158535023731030449746058156911457360217500,\\n 2425: 425907006811702486258611691435747829051036619210903,\\n 2426: 436964764086304546997571902667823798077679571339689,\\n 2427: 448307281905025750783203518734071850525930124835870,\\n 2428: 459941833958690501858441260833172834575927050017497,\\n 2429: 471875878224871422129752689802003581309719671216145,\\n 2430: 484117061599156426525236728117223720907832020184888,\\n 2431: 496673224641860608784678055946833883950031191035725,\\n 2432: 509552406443037374969583492229383313416835733059701,\\n 2433: 522762849608713268897451362983651906277382721179854,\\n 2434: 536313005371342643715460083111040042096768651944785,\\n 2435: 550211538827551788032090316191702467148009553891765,\\n 2436: 564467334306317355502338280181042531694130943361929,\\n 2437: 579089500870801016601654991798984624538203584674550,\\n 2438: 594087377957141194645081615027313378657219091976058,\\n 2439: 609470541153583610086244251156702088407546864564250,\\n 2440: 625248808123415184021445170239142357065496320226974,\\n 2441: 641432244675250690988723453000798446534275367015717,\\n 2442: 658031170984308451084537723836848917759126780943929,\\n 2443: 675056167968400361774985057979390540476824195499264,\\n 2444: 692518083822452741394297527894579793217444427279865,\\n 2445: 710428040715467841255717203419691810125435835218542,\\n 2446: 728797441653931534847387578562876222605215306007682,\\n 2447: 747637977515770665320414243823232108546943571791584,\\n 2448: 766961634259063882272862309538971496456501841189299,\\n 2449: 786780700309812582901493233837104883069651992252500,\\n 2450: 807107774133183849507621375104362485942528919417094,\\n 2451: 827955771992745105077858611205558631300937454362243,\\n 2452: 849337935902320652619232737317794449777545949179711,\\n 2453: 871267841775213384980863950063063429886904651528812,\\n 2454: 893759407775650814410526929963928966861696330836200,\\n 2455: 916826902877433240978780331677009554236212353692084,\\n 2456: 940484955634883423732306479679700600136395142799772,\\n 2457: 964748563171321607096873785043308907920748393645865,\\n 2458: 989633100390417258370972350733200785584553946028102,\\n 2459: 1015154329415899462551538855668088513315200292902465,\\n 2460: 1041328409265241672356796753836476758668568608962817,\\n 2461: 1068171905763073500068056689718618672673472054705623,\\n 2462: 1095701801700212541420510934836771894810436524644206,\\n 2463: 1123935507244352919801698227500042488236652668362464,\\n 2464: 1152890870608594412929146690100187865796230009117415,\\n 2465: 1182586188984146757378861272237745685156851393567877,\\n 2466: 1213040219743698104212153283094735988868458164856735,\\n 2467: 1244272191922094708920237946746471334658921810675089,\\n 2468: 1276301817981140870474529866246359687648227775992726,\\n 2469: 1309149305865493979065272921268867078953610074980355,\\n 2470: 1342835371356799383941072744632607586619060990003342,\\n 2471: 1377381250733383747666895193431311551421473834674537,\\n 2472: 1412808713743003709421434478836269410607157240633931,\\n 2473: 1449140076896329138317020116671377802568526770518725,\\n 2474: 1486398217089027121199419785627770438512228407175000,\\n 2475: 1524606585560504203472825372845600976263733665501642,\\n 2476: 1563789222197560394205351099996482830581156974888244,\\n 2477: 1603970770191409168676519057930382172908445935119463,\\n 2478: 1645176491056723265830534175841536314124424257900655,\\n 2479: 1687432280021576600685684487181671811367617087501755,\\n 2480: 1730764681797368211260238937556940484156749101230455,\\n 2481: 1775200906738034957464112810216480762332001678674799,\\n 2482: 1820768847398085810011063048337611865735620543349686,\\n 2483: 1867497095499222138016227017428624557231848665351291,\\n 2484: 1915414959315545554866069359053268627009894091487255,\\n 2485: 1964552481487597746580633524928622127514294053468578,\\n 2486: 2014940457275725421793253569605575859047900517862975,\\n 2487: 2066610453263518227450300026070406061787487374956619,\\n 2488: 2119594826522328312496888837397949369108992226003579,\\n 2489: 2173926744248147339669532102906132397617461595649235,\\n 2490: 2229640203882390293040946390903966696602633829194840,\\n 2491: 2286770053728415559686499093247615980043870048333375,\\n 2492: 2345352014075897634933772608434944801289607520822444,\\n 2493: 2405422698845462573006497019894423614036351120521629,\\n 2494: 2467019637766297143181469675691820929552138013921170,\\n 2495: 2530181299099750724441152937967329319658147447405249,\\n 2496: 2594947112922264451615392923126900249342712365881980,\\n 2497: 2661357494981285189837685277991457183899724929972336,\\n 2498: 2729453871138152742649660700418835108908145695065284,\\n 2499: 2799278702412287477405614444445747930301938442180000,\\n 2500: 2870875510641352469269629800993561138276373608937244,\\n 2501: 2944288904772419516055596903431635682611440388817684,\\n 2502: 3019564607799532159016586951616642980389816614848623,\\n 2503: 3096749484363431362720513648966835225350796839944705,\\n 2504: 3175891569029590968434327113853291229809825601961265,\\n 2505: 3257040095261100652976951554528119114719453404725007,\\n 2506: 3340245525103334116822171147466786507458445890183988,\\n 2507: 3425559579597749814517587789768024144026745140376550,\\n 2508: 3513035269942590955686749126214187667970579050845937,\\n 2509: 3602726929418680979845445364711401806180203650663725,\\n 2510: 3694690246098950482357992748748848483474524052004611,\\n 2511: 3788982296360781887103496312666448565688651771156677,\\n 2512: 3885661579220719274616818998490729558629719751838590,\\n 2513: 3984788051511562939333648375836061468352863107532895,\\n 2514: 4086423163922351728879727101483809741806177963555690,\\n 2515: 4190629897922231281075551233411026977189480304097898,\\n 2516: 4297472803589713195797719954967455347047259565521535,\\n 2517: 4407018038369349240856665212333154882125704077589469,\\n 2518: 4519333406778376182071537408268876717047377660539309,\\n 2519: 4634488401086431042999613202320599056013666269808095,\\n 2520: 4752554242991993841520963249414089899868727306156151\\n}\\n\\ndef exp_sum(number):\\n if number < 0: return 0\\n return ANSWERS[number]"}
{"id": "1661", "input": "def simplify(poly):\\n # I'm feeling verbose today\\n \\n # get 3 parts (even if non-existent) of each term: (+/-, coefficient, variables)\\n import re\\n matches = re.findall(r'([+\\-]?)(\\d*)([a-z]+)', poly)\\n \\n # get the int equivalent of coefficient (including sign) and the sorted variables (for later comparison)\\n expanded = [[int(i[0] + (i[1] if i[1] != \"\" else \"1\")), ''.join(sorted(i[2]))] for i in matches]\\n \\n # get the unique variables from above list. Sort themfirst by length, then alphabetically\\n variables = sorted(list(set(i[1] for i in expanded)), key=lambda x: (len(x), x))\\n \\n # get the sum of coefficients (located in expanded) for each variable\\n coefficients = {v:sum(i[0] for i in expanded if i[1]", "gt": "== v) for v in variables}"}
{"id": "1662", "input": "from collections import deque\\nimport re\\n\\nTOKENIZER = re.compile(r'(R+|F+|L+|\\)|\\()(\\d*)')\\n\\ndef parseCode(code):\\n cmds = [[]]\\n for cmd,n in TOKENIZER.findall(code):\\n s,r = cmd[0], int(n or '1') + len(cmd)-1\\n if cmd == '(': cmds.append([])\\n elif cmd == ')': lst = cmds.pop() ; cmds[-1].extend(lst*r)\\n else: cmds[-1] += [(s, r)]\\n return cmds[0]\\n\\ndef execute(code):\\n\\n pos, dirs = (0,0), deque([(0,1), (1,0), (0,-1), (-1,0)])\\n seens = {pos}\\n \\n for s,r in parseCode(code):\\n if s == 'F':\\n for _ in range(r):\\n", "gt": "pos = tuple( z+dz for z,dz in zip(pos, dirs[0]) )\\n seens.add(pos)\\n else:\\n dirs.rotate( (r%4) * (-1)**(s == 'R') )\\n \\n miX, maX = min(x for x,y in seens), max(x for x,y in seens)\\n miY, maY = min(y for x,y in seens), max(y for x,y in seens)\\n \\n return '\\r\\n'.join( ''.join('*' if (x,y) in seens else ' ' for y in range(miY, maY+1)) \\n for x in range(miX, maX+1) )"}
{"id": "1663", "input": "from collections import deque\\n\\n\\ndef tree_by_levels(node):\\n if not node:\\n return []\\n res, queue = [], deque([node,])\\n while queue:\\n", "gt": "n = queue.popleft()\\n res.append(n.value)\\n if n.left is not None:\\n queue.append(n.left)\\n if n.right is not None:\\n queue.append(n.right)\\n return res"}
{"id": "1664", "input": "def count_divisors(n):\\n \"\"\"Counts the integer points under the parabola xy = n.\\n\\n Because the region is symmetric about x = y, it is only necessary to sum up\\n to that point (at n^{1/2}),", "gt": "and double it. By this method, a square region is\\n counted twice, and thus subtracted off the total.\\n \"\"\"\\n r = int(n**(1/2))\\n return 2*sum(n // i for i in range(1, r+1)) - r*r"}
{"id": "1665", "input": "from itertools import count\\n\\nALL_MOVES = [(1,1), (0,1), ( 1,0), (-1,0), (0,-1), (-1,1), ( 1,-1), (-1,-1)] # Natural directions of moves for king or queen (one step)\\nAMA_MOVES = [(1,2), (2,1), (-1,2), (2,-1), (1,-2), (-2,1), (-1,-2), (-2,-1)] # Knight moves for amazon queen\\n\\n\\ndef amazon_check_mate(*args):\\n\\n def posInBoard(x,y): return 0 <= x < 8 and 0 <= y < 8\\n \\n def getCoveredPos(start, king=None): # Working with the amazon queen is king is provided\\n covered = {start}\\n for m in (AMA_MOVES if king else ALL_MOVES): # All \"one step\" moves (either for queen or king)\\n pos = tuple( z+dz for z,dz in zip(start,m) )\\n if posInBoard(*pos): covered.add(pos)\\n \\n if king: # Get long range moves, for queen only (meaning: if king is provided!)\\n for dx,dy in ALL_MOVES:\\n for n in count(1):\\n pos = (start[0]+dx*n, start[1]+dy*n)\\n if not posInBoard(*pos) or pos == king: break # Abort if not in board or if white king is on the way\\n covered.add(pos)\\n \\n return covered\\n \\n \\n K, Q = [(ord(s[0])-97,", "gt": "ord(s[1])-49) for s in args] # King and Queen positions as tuples\\n kCover = getCoveredPos(K) # Positions protected by white king\\n fullCover = getCoveredPos(Q,K) | kCover # All position protected by white pieces\\n freeQueen = Q not in kCover # Queen not protected by king\\n counts = [0] * 4 # Indexes: 2 * \"is not check\" + 1 * \"safe position available around\"\\n \\n for x in range(8):\\n for y in range(8):\\n black = (x,y)\\n \\n if black in kCover or black == Q: continue # No adjacent kings and no king copulating with an amazon...\\n \\n safePosAround = any( posInBoard(*neigh) and (neigh not in fullCover or neigh == Q and freeQueen) # Neighbour is in board and is a safe place or is the queen and isn't protected by white king\\n for neigh in ((x+dx, y+dy) for dx,dy in ALL_MOVES) )\\n \\n counts[ 2*(black not in fullCover) + safePosAround ] += 1 # Update the correct index of \"ans\"\\n \\n return counts\\n"}
{"id": "1666", "input": "def same_structure_as(original,other):\\n if isinstance(original, list) and isinstance(other, list) and len(original) == len(other):\\n for o1, o2 in zip(original, other):\\n", "gt": "if not same_structure_as(o1, o2): return False\\n else: return True\\n else: return not isinstance(original, list) and not isinstance(other, list)"}
{"id": "1667", "input": "from fractions import gcd\\nfrom functools import", "gt": "reduce\\n\\ndef solution(a):\\n return reduce(gcd, a) * len(a)"}
{"id": "1668", "input": "unflatten=lambda m,d,c=0:m if c==d else unflatten(parse(m,[0,1][c&1]),d,c+1)\\n\\ndef parse(ar, lr):\\n sub, i = [], [0, len(ar) - 1][lr]\\n while 0 <= i < len(ar):\\n j, r = ar[i], lr == 1\\n if isinstance(j,", "gt": "list):\\n sub.append(parse(j, lr))\\n i += [1, -1][r]\\n else:\\n mod = j % len([ar[i:],ar[:i + 1]][r])\\n sub.append([j, ar[i:i + (mod * [1, -1][r]):[1, -1][r]][::[1, -1][r]]][mod>=3])\\n i += [mod,1][mod<3] * [1,-1][r]\\n return sub[::[1, -1][lr]]"}
{"id": "1669", "input": "def next_smaller(n):\\n s = list(str(n))\\n i = j = len(s) - 1\\n while i > 0 and s[i - 1] <= s[i]: i -= 1\\n if i <= 0: return", "gt": "-1\\n while s[j] >= s[i - 1]: j -= 1\\n s[i - 1], s[j] = s[j], s[i - 1]\\n s[i:] = reversed(s[i:])\\n if s[0] == '0': return -1\\n return int(''.join(s))"}
{"id": "1670", "input": "class Solution:\\n def isNStraightHand(self, hand: List[int], W: int) -> bool:\\n # 1, 2, 2, 3, 3, 4, 6, 7, 8\\n # 1 2 3\\n # 2 3 4\\n # 6 7 8\\n \\n # W length Q\\n # how many opened\\n # # of the element is current opened one\\n \\n q = deque()\\n opened = 0\\n last =", "gt": "0\\n counter = Counter(hand)\\n for n in sorted(counter):\\n count = counter[n]\\n if n > last + 1 and opened > 0:\\n return False\\n \\n if n == last + 1 and count < opened:\\n return False\\n \\n \\n q.append(count - opened)\\n opened = count\\n \\n if len(q) == W:\\n opened -= q.popleft()\\n \\n last = n\\n return not opened"}
{"id": "1671", "input": "import sys\\ndef main():\\n s = sys.stdin.readline\\n save = {' ': '%20', '!': '%21', '$': '%24', '%': '%25', '(': '%28', ')': '%29', '*': '%2a'}\\n string = s().strip()\\n while", "gt": "True:\\n output = []\\n if '#' in string:\\n return\\n for i in string:\\n if i in save:\\n output.append(save[i])\\n else:\\n output.append(i)\\n print(''.join(output))\\n string = s().strip()\\n \\ndef __starting_point():\\n main()\\n__starting_point()"}
{"id": "1672", "input": "# ------------------- fast io --------------------\\nimport os\\nimport sys\\nfrom io import BytesIO, IOBase\\n\\nBUFSIZE = 8192\\n\\n\\nclass FastIO(IOBase):\\n newlines = 0\\n\\n def __init__(self, file):\\n self._fd = file.fileno()\\n self.buffer = BytesIO()\\n self.writable = \"x\" in file.mode or \"r\" not in file.mode\\n self.write = self.buffer.write if self.writable else None\\n\\n def read(self):\\n while True:\\n b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n if not b:\\n break\\n ptr = self.buffer.tell()\\n self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\\n self.newlines = 0\\n return self.buffer.read()\\n\\n def readline(self):\\n while self.newlines == 0:\\n b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n self.newlines = b.count(b\"\\n\") + (not b)\\n ptr = self.buffer.tell()\\n self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\\n self.newlines -= 1\\n return self.buffer.readline()\\n\\n def flush(self):\\n if self.writable:\\n os.write(self._fd, self.buffer.getvalue())\\n self.buffer.truncate(0), self.buffer.seek(0)\\n\\n\\nclass IOWrapper(IOBase):\\n def __init__(self, file):\\n self.buffer = FastIO(file)\\n self.flush =", "gt": "self.buffer.flush\\n self.writable = self.buffer.writable\\n self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\\n self.read = lambda: self.buffer.read().decode(\"ascii\")\\n self.readline = lambda: self.buffer.readline().decode(\"ascii\")\\n\\n\\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\\n\\n# ------------------- fast io --------------------\\nfrom math import gcd, ceil\\n\\ndef prod(a, mod=10**9+7):\\n ans = 1\\n for each in a:\\n ans = (ans * each) % mod\\n return ans\\n\\ndef lcm(a, b): return a * b // gcd(a, b)\\n\\ndef binary(x, length=16):\\n y = bin(x)[2:]\\n return y if len(y) >= length else \"0\" * (length - len(y)) + y\\n\\nfor _ in range(int(input()) if True else 1):\\n n = int(input())\\n #n, k = map(int, input().split())\\n #a, b = map(int, input().split())\\n #c, d = map(int, input().split())\\n #a = list(map(int, input().split()))\\n #b = list(map(int, input().split()))\\n #s = input()\\n print(*[1]*n)"}
{"id": "1673", "input": "f={}\\n\\nf[-40] = '-319993.68'\\nf[-41] = '-344598.60'\\nf[-42] = '-370433.52'\\nf[-43] = '-397528.44'\\nf[-44] = '-425913.37'\\nf[-45] = '-455618.29'\\nf[-46] = '-486673.22'\\nf[-47] = '-519108.14'\\nf[-48] = '-552953.07'\\nf[-49] = '-588238.00'\\nf[-50] = '-624992.93'\\nf[-29] = '-121939.61'\\nf[-30] = '-134994.52'\\nf[-31] = '-148949.43'\\nf[-32] = '-163834.34'\\nf[-33] = '-179679.26'\\nf[-34] = '-196514.17'\\nf[-35] = '-214369.08'\\nf[-36] = '-233274.00'\\nf[-37] = '-253258.92'\\nf[-38] = '-274353.84'\\nf[-39] = '-296588.76'\\nf[-18] = '-29155.76'\\nf[-19] = '-34290.64'\\nf[-20] = '-39995.53'\\nf[-21] = '-46300.42'\\nf[-22] = '-53235.31'\\nf[-23] = '-60830.20'\\nf[-24] = '-69115.10'\\nf[-25] = '-78120.00'\\nf[-26] = '-87874.90'\\nf[-27] = '-98409.80'\\nf[-28] = '-109754.71'\\nf[-8] = '-2557.17'\\nf[-9] = '-3642.00'\\nf[-10] = '-4996.84'\\nf[-11] = '-6651.68'\\nf[-12] = '-8636.54'\\nf[-13] = '-10981.39'\\nf[-14] = '-13716.26'\\nf[-15]", "gt": "= '-16871.13'\\nf[-16] = '-20476.00'\\nf[-17] = '-24560.88'\\nf[-18] = '-29155.76'\\nf[3] = '136.73'\\nf[2] = '41.41'\\nf[1] = '6.00'\\nf[0] = '0.00'\\nf[-1] = '-4.00'\\nf[-2] = '-38.59'\\nf[-3] = '-133.27'\\nf[-4] = '-318.00'\\nf[-5] = '-622.76'\\nf[-6] = '-1077.55'\\nf[-7] = '-1712.35'\\nf[14] = 'MAGNA NIMIS!'\\nf[13] = 'MAGNA NIMIS!'\\nf[12] = 'MAGNA NIMIS!'\\nf[11] = 'MAGNA NIMIS!'\\nf[10] = 'MAGNA NIMIS!'\\nf[9] = 'MAGNA NIMIS!'\\nf[8] = 'MAGNA NIMIS!'\\nf[7] = 'MAGNA NIMIS!'\\nf[6] = 'MAGNA NIMIS!'\\nf[5] = 'MAGNA NIMIS!'\\nf[4] = '322.00'\\n\\na=[]\\nfor i in range(11):\\n a+=[int(input())]\\nfor i in a[::-1]:\\n s=''\\n if i in f:\\n s=f[i]\\n else:\\n s='MAGNA NIMIS!'\\n print('f(%d) = %s'%(i, s))"}
{"id": "1674", "input": "class Solution:\\n def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n dp = [0] * len(arr[0])\\n for r, row in enumerate(arr):\\n minNb = min(dp)\\n min1 = dp.index(minNb)\\n dp[min1] = float('inf')\\n min2", "gt": "= dp.index(min(dp))\\n dp[min1] = minNb\\n \\n for c in range(len(row)):\\n if c != min1:\\n row[c] += dp[min1]\\n else:\\n row[c] += dp[min2]\\n #row[c] += min(dp[:c]+dp[c+1:])\\n dp = row[:]\\n return min(dp)"}
{"id": "1675", "input": "from functools import *\\nclass Solution:\\n def stoneGameII(self, arr):\\n a =[]\\n s=0\\n n = len(arr)\\n for i in arr[::-1]:\\n s+=i\\n a.append(s)\\n a=a[::-1]\\n @lru_cache(None)\\n def fun(i,m):\\n if i+2*m>=n:return", "gt": "a[i]\\n mn = inf\\n for ii in range(1,2*m+1):\\n if ii>m:\\n ans = fun(i+ii,ii)\\n else:\\n ans=fun(i+ii,m)\\n if ans<mn:\\n mn = ans\\n return a[i]-mn\\n return fun(0,1)\\n \\n \\n"}
{"id": "1676", "input": "from math import sqrt\\n\\ndef get_distance(x1,y1,x2,y2):\\n return sqrt((x1-x2)**2 + (y1-y2)**2)\\n\\nT = int(input())\\nans = []\\n\\nfor _ in range(T):\\n blank = input()\\n N = int(input())\\n\\n C = [[] for i in range(10**4+1)]\\n\\n for i in range(N):\\n x,y = [int(i) for i in input().split()]\\n C[x].append(y)\\n\\n distance =", "gt": "0\\n lastx = None\\n lasty = None\\n for i in range(10**4+1):\\n if(C[i]!=[]):\\n max_ci = max(C[i])\\n min_ci = min(C[i])\\n if(lastx!=None and lasty!=None):\\n distance += get_distance(lastx,lasty,i,max_ci)\\n distance += max_ci - min_ci\\n lastx = i\\n lasty = min_ci\\n # ans.append(round(distance,2))\\n ans.append(\""}
{"id": "1677", "input": "import sys\\n\\nblocks = {}\\n\\nfor i in range(1, 10):\\n blocks[i] = [(0, 0)]\\nfor i in range(2, 10, 2):\\n for j in range(1, i / 2 + 1):\\n blocks[i].append((j, 0))\\n blocks[i + 1].append((0, j))\\n# print blocks\\nblocks[10] = [(0, 0), (0, 1), (1, 0), (1, 1)]\\nblocks[11] = [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]\\nblocks[12] = [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\\nblocks[13] = [(0, 2), (1, 2), (2, 0), (2, 1), (2, 2)]\\nblocks[14] =", "gt": "[(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\\nblocks[15] = [(0, 0), (0, 1), (0, 2), (1, 0), (2, 0)]\\nblocks[16] = [(0, 0), (0, 1), (1, 0)]\\nblocks[17] = [(0, 0), (0, 1), (1, 1)]\\nblocks[18] = [(0, 1), (1, 0), (1, 1)]\\nblocks[19] = [(0, 0), (1, 0), (1, 1)]\\n\\ngrid = [['.'] * 10] * 10\\n# print grid\\n\\nid1, id2, id3 = list(map(int, input().split()))\\nwhile not (id1 == id2 == id3 == -1):\\n print('-1 -1 -1 -1 -1 -1 -1 -1 -1')\\n sys.stdout.flush()\\n id1, id2, id3 = list(map(int, input().split()))\\n"}
{"id": "1678", "input": "#dt = {} for i in x: dt[i] = dt.get(i,0)+1\\r\\nimport sys;input = sys.stdin.readline\\r\\n#import io,os; input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline #for pypy\\r\\ninp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]\\r\\n\\r\\nfrom collections import deque\\r\\ndef getmax(x,n,k):\\r\\n mx = []\\r\\n dq = deque()\\r\\n for i in range(k):\\r\\n while dq and x[i] >= x[dq[-1]]:\\r\\n dq.pop()\\r\\n dq.append(i)\\r\\n mx.append(x[dq[0]])\\r\\n for i in range(k,n):\\r\\n while dq and dq[0] <=", "gt": "i-k:\\r\\n dq.popleft() \\r\\n while dq and x[i] >= x[dq[-1]]:\\r\\n dq.pop()\\r\\n dq.append(i)\\r\\n mx.append(x[dq[0]])\\r\\n return mx\\r\\n\\r\\nn = inp()\\r\\nm = n+n\\r\\nA = ip()\\r\\nB = ip()\\r\\nA += A\\r\\nB += B\\r\\npre = [0]*(m+1)\\r\\nfor i in range(1,m+1):\\r\\n pre[i] += pre[i-1] + B[i-1]\\r\\nplus = [0]*m\\r\\nminus = [0]*m\\r\\nfor i in range(m):\\r\\n plus[i] = A[i]+pre[i]\\r\\n minus[i] = A[i]-pre[i+1]\\r\\na = getmax(plus,m,n-1)\\r\\nans = float('-inf')\\r\\nfor i in range(n):\\r\\n ans = max(ans,minus[i]+a[i+1])\\r\\nprint(max(ans,*A))"}
{"id": "1679", "input": "# cook your dish here\\nn,m = map(int, input().split())\\narr1 = list(map(int, input().split()))\\narr2 = list(map(int, input().split()))\\nmax1 = arr1.index(max(arr1))\\nmin2 = arr2.index(min(arr2))\\narr", "gt": "= []\\nfor i in range(m):\\n arr.append([max1, i])\\nfor i in range(n):\\n if i!=max1:\\n arr.append([i , min2])\\nfor i in arr:\\n print(*i)"}
{"id": "1680", "input": "# cook your dish here\\nfor _ in range(int(input())):\\n l,n,x=map(int,input().split())\\n m=[]\\n pw1 = (1 << 17); \\n pw2 = (1 << 18); \\n if (n == 1) : \\n m.append(x)\\n elif (n == 2 and x == 0) : \\n m.append(-1)\\n elif (n == 2) : \\n m.append(x)\\n m.append(0)\\nelse : \\n ans = 0; \\n for i in range(1, n - 2)", "gt": ": \\n m.append(i)\\n ans = ans ^ i;"}
{"id": "1681", "input": "#include<stdio.h>\\nint rev(int k)\\n{\\nint j,res=0;\\nwhile(k)\\n{\\nres=res*10+k%10;\\nk/=10;\\n}\\nreturn", "gt": "res;"}
{"id": "1682", "input": "for _ in range(int(input())):\\n x,y=map(int,input().split())\\n if(x==y):\\n if(x==1):\\n print(1)\\n else:\\n n=0\\n for i in range(x-1):\\n n=i\\n for _ in range(y):\\n print(n,end=' ')\\n n=(n+1)%x\\n print() \\n for i in range(x):\\n print(i,end=' ')\\n print( )\\n else:\\n l=[]\\n n=min(x,y)\\n m=max(x,y)\\n for _ in range(n):\\n l.append([])\\n v=n+1\\n for", "gt": "i in range(n):\\n u=i\\n for j in range(m):\\n if(j<=n):\\n l[i].append(u)\\n u=(u+1)%(n+1)\\n else:\\n if(j>=v):\\n l[i].append(j+1)\\n else:\\n l[i].append(j)\\n v=v+1\\n if(x>y):\\n for i in range(x):\\n for j in l:\\n print(j[i],end=' ')\\n print( )\\n else:\\n for i in l:\\n for j in i:\\n print(j,end=' ')\\n print( )"}
{"id": "1683", "input": "l=list(map(int,input()))\\nt=-1\\nx=-1\\ny=-1\\nfor i in range(len(l)):\\n s=l[i]\\n a=i+1\\n b=i+1\\n for j in range(i+1,len(l)):\\n", "gt": "if l[i]<l[j]:\\n s=s+l[j]\\n b=j+1\\n else:\\n break\\n if s>t:\\n t=s\\n x=a\\n y=b\\nprint(t,end=\":\")\\nprint(x,y,sep=\"-\")"}
{"id": "1684", "input": "''' J A I ~ S H R E E ~ R A M '''\\r\\n\\r\\n# Title: cc-CKOJ20D.py\\r\\n# created on: 20-07-2020 at 20:46:04\\r\\n# Creator & Template : Udit Gupta \"@luctivud\"\\r\\n# https://github.com/luctivud\\r\\n# https://www.linkedin.com/in/udit-gupta-1b7863135/\\r\\n\\r\\n\\r\\nimport math; from collections import *\\r\\nimport sys; from functools import reduce\\r\\nfrom itertools import groupby\\r\\n\\r\\n# sys.setrecursionlimit(10**6)\\r\\n\\r\\ndef get_ints(): return map(int, input().strip().split())\\r\\ndef get_list(): return list(get_ints())\\r\\ndef get_string(): return list(input().strip().split())\\r\\ndef printxsp(*args): return print(*args, end=\"\")\\r\\ndef printsp(*args): return print(*args, end=\" \")\\r\\n\\r\\n\\r\\nDIRECTIONS = [[0, 1], [0, -1], [1, 0], [1, -1]] #up, down, right, left\\r\\nNEIGHBOURS = [(i, j) for i in range(-1, 2) for j in range(-1, 2) if (i!=0 or j!=0)]\\r\\n\\r\\n\\r\\nOrdUnicode_a = ord('a'); OrdUnicode_A = ord('A')\\r\\nCAPS_ALPHABETS = {chr(i+OrdUnicode_A) : i for i in range(26)}\\r\\nSMOL_ALPHABETS = {chr(i+OrdUnicode_a) : ifor i in range(26)}\\r\\n\\r\\n\\r\\nMOD_JOHAN =", "gt": "int(1e9)+7;"}
{"id": "1685", "input": "# cook your dish here\\nt = int(input())\\n\\nwhile(t>0):\\n n =", "gt": "int(input())\\n k=1\\n while(k<=n):\\n print(k, end=' ')\\n k+=1\\n print('\\n')\\n t-=1"}
{"id": "1686", "input": "from collections import deque\\nfrom sys import stdin\\nimport psyco\\npsyco.full()\\n\\ngraph = [[]]\\nWHITE, GRAY, BLACK = 0, 1, 2\\n\\ndef notoriety(x, f_count):\\n queue = deque([x])\\n d = [0 for i in range(f_count+1)]\\n p = [0 for i in range(f_count+1)]\\n color = [WHITE for i in range(f_count+1)]\\n while len(queue) > 0:\\n top = queue.pop()\\n for node in graph[top]:\\n if color[node] == WHITE:\\n queue.appendleft(node)\\n color[node], p[node], d[node] = GRAY, top,", "gt": "d[top] + 1\\n color[top] = BLACK\\n return sum(d)/(f_count*1.0)\\n \\ndef main():\\n groups = int(stdin.readline())\\n for g in range(groups):\\n global graph\\n graph = [[]]\\n no_of_friends = int(stdin.readline())\\n for i in range(no_of_friends):\\n graph.append(list(map(int,stdin.readline().split())))\\n min_notoriety, popular = 10000000, -1 # yet another magic number\\n for f in range(1,no_of_friends+1):\\n curr_not = notoriety(f, no_of_friends)\\n if curr_not < min_notoriety:\\n min_notoriety,popular = curr_not, f\\n assert popular != -1\\n print(popular, \"%.6f\" %min_notoriety)\\n\\ndef __starting_point():\\n main()\\n\\n__starting_point()"}
{"id": "1687", "input": "class PathNode:\\n\\n def __init__(self, row, col, st_x, st_y, p_count=0):\\n self.x = row\\n self.y = col\\n self.pathCount = p_count\\n\\n def __str__(self):\\n return str(self.x) + \" | \" + str(self.y) + \" | \" + str(self.pathCount)\\n\\n\\nclass GraphUtil:\\n def __init__(self, mat, R,C, d):\\n self.mat = mat\\n self.R = R\\n self.C = C\\n self.d = d\\n self.tab = {}\\n\\n def isValidMove(self, r, c, blockVal):\\n return r < self.R and c < self.C and self.mat[r][c] != blockVal\\n\\n def possbilePathUtil(self, r, c, blockVal, step,direction):\\n\\n if(not self.isValidMove(r, c, 0)):\\n return 0\\n \\n if (r == self.R - 1 and c == self.C - 1):\\n return 1\\n\\n if ((r,c,step,direction) in self.tab):\\n return self.tab[(r,c,step,direction)]\\n\\n result = 0\\n \\n if direction", "gt": "== 1:\\n if step < self.d:\\n result = (result + self.possbilePathUtil(r, c + 1, blockVal, step + 1,1)) % 20011\\n result = (result + self.possbilePathUtil(r+1, c, blockVal, 1,2)) % 20011\\n else:\\n if step < self.d:\\n result = (result + self.possbilePathUtil(r + 1, c, blockVal, step + 1, 2)) % 20011\\n result = (result + self.possbilePathUtil(r, c + 1, blockVal, 1,1)) % 20011\\n \\n self.tab[(r,c,step,direction)] = result\\n \\n return result\\n\\n def possbilePath(self):\\n if (not self.mat or len(self.mat) < 1):\\n return 0\\n\\n return self.possbilePathUtil(0, 0, 0,0,2)\\n\\n\\nnumbers = [int(n) for n in input().split()]\\n\\nmat = [[int(n) for n in input().split()] for r in range(0, numbers[0])]\\n\\nresult = GraphUtil(mat, numbers[0], numbers[1], numbers[2])\\n\\nprint(result.possbilePath())\\n# print(result.count)# cook your dish here\\n"}
{"id": "1688", "input": "for _ in range(int(input())):\\n n,k=[int(x) for x in input().split()]\\n if k%4==0:\\n for i in range(0,k,4):\\n print(i,i+1)\\n print(i+1,i+2)\\n print(i+2,i+3)\\n print(i+3,i)\\n elif k%4==1:\\n for i in range(4,k-1,4):\\n print(i,i+1)\\n print(i+1,i+2)\\n print(i+2,i+3)\\n print(i+3,i)\\n print(0,1)\\n print(1,2)\\n print(2,3)\\n print(3,(1<<n)-1)\\n print((1<<n)-1,0)\\n elif k%4==2:\\n", "gt": "for i in range(4,k-2,4):\\n print(i,i+1)\\n print(i+1,i+2)\\n print(i+2,i+3)\\n print(i+3,i)\\n print(0,1)\\n print(1,2)\\n print(2,3)\\n print(3,(1<<n)-2)\\n print((1<<n)-2,(1<<n)-1)\\n print((1<<n)-1,0)\\n elif k!=3:\\n n=1<<n\\n n-=1\\n for i in range(4,k-3,4):\\n print(i,i+1)\\n print(i+1,i+2)\\n print(i+2,i+3)\\n print(i+3,i)\\n print(2,3)\\n print(3,n-1)\\n print(n-1,0)\\n print(0,1)\\n print(1,n-2)\\n print(n-2,n)\\n print(n,2)\\n else:\\n print(0,1)\\n print(1,3)\\n print(3,00)\\n"}
{"id": "1689", "input": "m=int(input())\\nwhile m:\\n m-=1\\n n=int(input())\\n t=[i", "gt": "for i in input().split()]\\n print(''.join(t))"}
{"id": "1690", "input": "# import all important libraries and inbuilt functions\\n\\nfrom fractions import Fraction\\nimport numpy as np\\nimport sys,bisect,copyreg,copy,statistics,os\\nfrom math import *\\nfrom collections import Counter,defaultdict,deque,OrderedDict \\nfrom itertools import combinations,permutations,accumulate \\nfrom numpy.linalg import matrix_power as mp\\nfrom bisect import bisect_left,bisect_right,bisect,insort,insort_left,insort_right\\nfrom statistics import mode\\nfrom functools import reduce,cmp_to_key \\nfrom io import BytesIO, IOBase\\nfrom scipy.spatial import ConvexHull\\nfrom heapq import *\\nfrom decimal import *\\nfrom queue import Queue,PriorityQueue\\nfrom re import sub,subn\\n\\n# end of library import\\n\\n# map system version faults\\nif sys.version_info[0] < 3:\\n from builtins import xrange as range\\n from future_builtins import ascii, filter, hex, map, oct, zip\\n\\n# template of many functions used in competitive programming can add more later \\n# based on need we will use this commonly.\\n\\n# bfs in a graph\\ndef bfs(adj,v): # a schema of bfs\\n visited=[False]*(v+1);q=deque()\\n while q:pass\\n\\n# definition of vertex of a graph\\ndef graph(vertex): return [[] for i in range(vertex+1)]\\n\\ndef powermodulo(x, y, p) : \\n res = 1;x = x % p \\n if (x == 0) : return 0 \\n while (y > 0) : \\n if ((y & 1) == 1) : res = (res * x) % p \\n y = y >> 1 \\n x = (x * x) % p \\n return res\\n\\ndef lcm(a,b): return (a*b)//gcd(a,b)\\n\\n# most common list in a array of lists\\ndef most_frequent(List):return Counter(List).most_common(1)[0][0]\\n\\n# element with highest frequency\\ndef most_common(List):return(mode(List))\\n\\n#In number theory, the Chinese remainder theorem states that \\n#if one knows the remainders of the Euclidean division of an integer n by \\n#several integers, then one can determine uniquely the remainder of the \\n#division of n by the product of these integers, under the condition \\n#that the divisors are pairwise coprime.\\ndef chinese_remainder(a, p):\\n prod = reduce(op.mul, p, 1);x = [prod // pi for pi in p]\\n return sum(a[i] * powermodulo(x[i], p[i] - 2, p[i]) * x[i] for i in range(len(a))) % prod\\n\\n# make a matrix\\ndef createMatrix(rowCount, colCount, dataList): \\n mat = []\\n for i in range (rowCount):\\n rowList = []\\n for j in range (colCount):\\n if dataList[j] not in mat:rowList.append(dataList[j])\\n mat.append(rowList) \\n return mat\\n\\n# input for a binary tree\\ndef readTree(): \\n v=int(inp());adj=[set() for i in range(v+1)]\\n for i in range(v-1):u1,u2=In(); adj[u1].add(u2);adj[u2].add(u1)\\n return adj,v\\n \\n# sieve of prime numbers \\ndef sieve():\\n li=[True]*1000001;li[0],li[1]=False,False;prime=[]\\n for i in range(2,len(li),1):\\n if li[i]==True:\\n for j in range(i*i,len(li),i):li[j]=False \\n for i in range(1000001):\\n if li[i]==True:prime.append(i)\\n return prime\\n\\n#count setbits of a number.\\ndef setBit(n):\\n count=0\\n while n!=0:n=n&(n-1);count+=1\\n return count\\n\\n# sum of digits of a number\\ndef digitsSum(n):\\n if n == 0:return 0\\n r = 0\\n while n > 0:r += n % 10;n //= 10\\n return r\\n\\n# ncr efficiently\\ndef ncr(n, r):\\n r = min(r, n - r);numer = reduce(op.mul, list(range(n, n - r, -1)), 1);denom = reduce(op.mul, list(range(1, r + 1)), 1)\\n return numer // denom # or / in Python 2\\n\\n#factors of a number\\ndef factors(n):return list(set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\\n\\n#prime fators of a number\\ndef prime_factors(n):\\n i = 2;factors = []\\n while i * i <= n:\\n if n % i:i += 1\\n else:n //= i;factors.append(i)\\n if n > 1:factors.append(n)\\n return len(set(factors))\\n\\ndef prefixSum(arr):\\n for i in range(1, len(arr)):arr[i] = arr[i] + arr[i-1]\\n return arr \\n\\ndef binomial_coefficient(n, k):\\n if 0 <= k <= n:\\n ntok = 1;ktok = 1\\n for t in range(1, min(k, n - k) + 1):ntok *= n;ktok *= t;n -= 1\\n return ntok // ktok\\n else:return 0\\n \\ndef powerOfK(k, max):\\n if k == 1:return [1]\\n if k == -1:return [-1, 1] \\n result = [];n = 1\\n while n <= max:result.append(n);n *= k\\n return result\\n\\n# maximum subarray sum use kadane's algorithm\\ndef kadane(a,size):\\n max_so_far = 0;max_ending_here = 0 \\n for i in range(0, size):\\n max_ending_here = max_ending_here + a[i]\\n if (max_so_far < max_ending_here):max_so_far = max_ending_here \\n if max_ending_here < 0:max_ending_here = 0\\n return max_so_far \\n \\ndef divisors(n):\\n result = []\\n for i in range(1,ceil(sqrt(n))+1):\\n if n%i == 0:\\n if n/i == i:result.append(i)\\n else:result.append(i);result.append(n/i)\\n return result\\n\\ndef sumtilln(n): return ((n*(n+1))//2)\\n\\ndef isPrime(n) : \\n if (n <= 1) :return False\\n if (n <= 3) :return True\\n if (n % 2 == 0 or n % 3 == 0) :return False\\n for i in range(5,ceil(sqrt(n))+1,6):\\n if (n % i == 0 or n % (i + 2) == 0) :return False\\n return True\\n\\ndef isPowerOf2(n):\\n while n % 2 == 0:n //= 2\\n return (True if n == 1 else False)\\n\\ndef power2(n):\\n k = 0\\n while n % 2 == 0:k += 1;n //= 2\\n return k\\n\\ndef sqsum(n):return ((n*(n+1))*(2*n+1)//6)\\n \\ndef cusum(n):return ((sumn(n))**2)\\n\\ndef pa(a):\\n for i in range(len(a)):print(a[i], end = \" \")\\n print()\\n\\ndef pm(a,rown,coln):\\n for i in range(rown):\\n for j in range(coln):print(a[i][j],end = \" \")\\n print()\\n\\ndef pmasstring(a,rown,coln):\\n for i in range(rown):\\n for j in range(coln):print(a[i][j],end = \"\")\\n print()\\n \\ndef isPerfectSquare(n):return pow(floor(sqrt(n)),2) == n\\n\\ndef nC2(n,m):return (((n*(n-1))//2) % m)\\n\\ndef modInverse(n,p):return powermodulo(n,p-2,p)\\n\\ndef ncrmodp(n, r, p): \\n num = den = 1\\n for i in range(r):num = (num * (n - i)) % p ;den = (den * (i + 1)) % p \\n return (num * powermodulo(den,p - 2, p)) % p \\n\\ndef reverse(string):return \"\".join(reversed(string)) \\n\\ndef listtostr(s):return ' '.join([str(elem) for elem in s]) \\n\\ndef binarySearch(arr, l, r, x): \\n while l <= r: \\n mid = l + (r - l) // 2; \\n if arr[mid] == x:return mid \\n elif arr[mid] <", "gt": "x:l = mid + 1\\n else:r = mid - 1\\n return -1\\n\\ndef isarrayodd(a):\\n r = True\\n for i in range(len(a)):\\n if a[i] % 2 == 0:\\n r = False\\n break\\n return r\\n\\ndef isPalindrome(s):return s == s[::-1] \\n\\ndef gt(x,h,c,t):return ((x*h+(x-1)*c)/(2*x-1))\\n\\ndef CountFrequency(my_list): \\n freq ="}
{"id": "1691", "input": "def check_relative(i,j):\\n if is_relative[i]:return\\n if len(land[i].intersection(land[j]))>=k:\\n is_relative[i]=True\\n for ii in range(n):\\n", "gt": "check_relative(ii,i)\\n\\nn,k=map(int,input().split())\\nland=[]\\nis_relative=[True]+[False]*(n-1)\\nfor i in range(n):\\n p,*q=input().split()\\n land.append(set(map(int,q)))\\n\\nfor i in range(n):\\n check_relative(i,0)\\n \\nprint(is_relative.count(True))"}
{"id": "1692", "input": "# CHNGSS.py\\n\\nimport sys\\nfrom random import *\\n\\nn,m,c = list(map(int,input().split()))\\narr = [[1]*m for i in range(n)];\\nsaved = 0;\\nfor i in range(n):\\n for j in range(m):\\n print(1,(i+1),(i+1),(j+1),(j+1),1,25)\\n sys.stdout.flush()\\na = int(input())\\n if a == 1 :\\n saved += 1;\\n arr[i][j]", "gt": "= randint(1,25);"}
{"id": "1693", "input": "print(302)\\nprint(\"0 1000000\")\\ncoord, rad = 17321*2, 300\\nfor i in", "gt": "range(300):\\n print(coord, rad)\\n coord, rad = coord+600, rad-1\\nprint(\"1000000 1000000\")\\n"}
{"id": "1694", "input": "from math import *\\n\\nn = int(input())\\nfor _ in range(n):\\n a = [int(i) for i in input().split()]\\n c = len(a)\\n avg = sum(a)/c\\n ulik = log(2*avg + 1)*(-c)\\n plik =", "gt": "0\\n for k in a:\\n plik += log(avg)*k\\n plik += -avg\\n for i in range(1, k+1):\\n plik -= log(i)\\n isu = ulik > plik\\n ans = [\"poisson\", \"uniform\"][isu]\\n print(ans)\\n"}
{"id": "1695", "input": "v = int(input())\\neps = 170\\n\\ndef ans(a):\\n a.sort()\\n if len(a) % 2 == 0:\\n med = a[len(a)//2]\\n else:\\n med = (a[len(a)//2] + a[len(a)//2 - 1]) // 2\\n\\n l = med - med // 2\\n r = med + med // 2\\n\\n c1 = c2 = 0\\n\\n for i in a:\\n if i >=", "gt": "l and i <= r:\\n c1 += 1\\n else:\\n c2 += 1\\n\\n if abs(c1 - c2) <= eps:\\n return (med, \"uniform\")\\n else:\\n return (med, \"poisson\")\\n\\n \\n\\nfor i in range(v):\\n cur = [int(i) for i in input().split()]\\n b = ans(cur)\\n if b[1] == \"poisson\":\\n print(b[0])\\n else:\\n print((max(cur) - min(cur)) // 2)\\n \\n \\n"}
{"id": "1696", "input": "def __starting_point():\\n print(2001)\\n for i in range(1000):\\n print(str(i + 1) + ' ' + str(1) + ' ' + str(i + 1) + ' ' +str(2))\\n print(str(1) + \" \" + str(1)", "gt": "+ \" \" +str(1) + \" \" + str(2))\\n for i in range(1000):\\n print(str(i + 1) + ' ' + str(1) + ' ' + str(i + 1) + ' ' +str(2))\\n\\n__starting_point()"}
{"id": "1697", "input": "def sampleVariance(V):\\n X = sum(V) / len(V)\\n S = 0.0\\n for x in V:\\n S += (X-x)**2\\n\\n S /= (len(V)-1)\\n return (X, S)\\n\\n#That awkward moment when you realized that", "gt": "variance is sigma^2 but you just took the stat course this semester\\nfor i in range(int(input())):\\n V = list(map(int, input().split()))\\n X, S = sampleVariance(V)\\n\\n print(\""}
{"id": "1698", "input": "import itertools\\nclass Nonogram:\\n poss = {(1,1,1): set([(1,0,1,0,1)]),\\n (1,1): set([(0,0,1,0,1),(0,1,0,1,0),(1,0,1,0,0),(0,1,0,0,1),(1,0,0,1,0),(1,0,0,0,1)]),\\n (1,2): set([(1,0,1,1,0),(1,0,0,1,1),(0,1,0,1,1)]),\\n (1,3): set([(1,0,1,1,1)]),\\n (2,1): set([(1,1,0,1,0),(1,1,0,0,1),(0,1,1,0,1)]),\\n (2,2): set([(1,1,0,1,1)]),\\n (3,1): set([(1,1,1,0,1)]),\\n (1,): set([(0,0,0,0,1),(0,0,0,1,0),(0,0,1,0,0),(0,1,0,0,0),(1,0,0,0,0)]),\\n (2,): set([(0,0,0,1,1),(0,0,1,1,0),(0,1,1,0,0),(1,1,0,0,0)]),\\n (3,): set([(0,0,1,1,1),(0,1,1,1,0),(1,1,1,0,0)]),\\n (4,): set([(0,1,1,1,1),(1,1,1,1,0)]),\\n (5,): set([(1,1,1,1,1)])}\\n", "gt": "\\n def __init__(self, clues):\\n self.h,self.w=(tuple(Nonogram.poss[clue] for clue in side) for side in clues)\\n\\n def solve(self):\\n for r in itertools.product(*self.w):\\n if all(c in self.h[i] for i,c in enumerate(zip(*r))): return r\\n"}
{"id": "1699", "input": "from collections import deque\\n\\ndef dbl_linear(n):\\n h = 1; cnt = 0; q2, q3 = deque([]), deque([])\\n while True:\\n if (cnt >= n):\\n return h\\n q2.append(2 * h", "gt": "+ 1)\\n q3.append(3 * h + 1)\\n h = min(q2[0], q3[0])\\n if h == q2[0]: h = q2.popleft()\\n if h == q3[0]: h = q3.popleft()\\n cnt += 1\\n\\n"}
{"id": "1700", "input": "def doubles(maxk, maxn):\\n return sum([ sum([ (n+1)**(-2*k) for n", "gt": "in range(1, maxn+1) ])/k for k in range(1, maxk+1) ])"}
{"id": "1701", "input": "class DynamicConnectivity(object):\\n par = []\\n def __init__(self, n):\\n self.par = [i for i in range(n)]\\n\\n def union(self, p, q):\\n if self.root(p) != self.root(q):\\n self.par[self.root(p)] = q\\n\\n", "gt": "def root(self, p):\\n pp = p\\n while self.par[pp] != pp:\\n pp = self.par[pp]\\n return pp\\n \\n def connected(self, p, q):\\n return True if self.root(p)==self.root(q) else False\\n"}
{"id": "1702", "input": "from operator import add, sub, mul, floordiv as div, and_, or_, xor\\nOP = {'add':add, 'sub':sub, 'mul':mul, 'div':div, 'and':and_, 'or':or_, 'xor':xor} \\n\\nclass Machine(object): \\n def __init__(self, cpu):\\n self.cpu = cpu\\n \\n def execute(self, instruction): \\n cmd, a, b = (instruction.replace(',', ' ') + ' 0 0').split()[:3]\\n v = self.cpu.read_reg(a) if a in 'abcd' else int(a)\\n \\n if cmd == 'mov': self.cpu.write_reg(b, v)\\n elif cmd == 'pop': self.cpu.write_reg(a, self.cpu.pop_stack()) if a in 'abcd'", "gt": "else self.cpu.pop_stack()\\n elif cmd == 'push': self.cpu.write_stack(v)\\n elif cmd in ['pushr', 'pushrr']:\\n for r in ('abcd' if cmd == 'pushr' else 'dcba'): self.cpu.write_stack(self.cpu.read_reg(r))\\n elif cmd in ['popr', 'poprr']:\\n for r in ('abcd' if cmd == 'poprr' else 'dcba'): self.cpu.write_reg(r, self.cpu.pop_stack())\\n else:\\n r = self.cpu.pop_stack() if cmd[-1] != 'a' else self.cpu.read_reg('a')\\n for _ in range(v-1):\\n r = OP[cmd if cmd[-1] != 'a' else cmd[:-1]](r, self.cpu.pop_stack())\\n self.cpu.write_reg(b if b in 'abcd' else 'a', r)"}
{"id": "1703", "input": "import math\\n\\nclass Sudoku(object):\\n def __init__(self, board):\\n self.board = board\\n \\n def is_valid(self):\\n if not isinstance(self.board, list):\\n return False\\n n = len(self.board)\\n rootN = int(round(math.sqrt(n)))\\n if rootN * rootN != n:\\n return False\\n isValidRow = lambda r : (isinstance(r, list) and\\n len(r) == n and\\n all([type(x) == int for x in r]))\\n if not all(map(isValidRow, self.board)):\\n return False\\n oneToN", "gt": "= set(range(1, n + 1))\\n isOneToN = lambda l : set(l) == oneToN\\n tranpose = [[self.board[j][i] for i in range(n)] for j in range(n)]\\n squares = [[self.board[p+x][q+y] for x in range(rootN) \\n for y in range(rootN)] \\n for p in range(0, n, rootN)\\n for q in range(0, n, rootN)] \\n return (all(map(isOneToN, self.board)) and\\n all(map(isOneToN, tranpose)) and\\n all(map(isOneToN, squares)))\\n"}
{"id": "1704", "input": "import re\\n\\ndef brainfuck_to_c(source):\\n # remove comments\\n source = re.sub('[^+-<>,.\\[\\]]', '', source)\\n \\n # remove redundant code\\n before = ''\\n while source != before:\\n before = source\\n source = re.sub('\\+-|-\\+|<>|><|\\[\\]', '', source)\\n \\n # check braces status\\n braces = re.sub('[^\\[\\]]', '', source)\\n while braces.count('[]'):\\n braces = braces.replace('[]', '')\\n if braces:\\n return 'Error!'\\n \\n # split code into commands\\n commands = re.findall('\\++|-+|>+|<+|[.,\\[\\]]', source)\\n \\n # translate to C\\n output = []\\n indent = 0\\n for cmd in commands:\\n ifcmd[0] in '+-<>':\\n line = ('%sp %s= %s;\\n' %\\n ('*' if cmd[0] in '+-' else '',\\n '+' if cmd[0]", "gt": "in '+>' else '-',\\n len(cmd)))\\n elif cmd == '.':\\n line = 'putchar(*p);"}
{"id": "1705", "input": "class PokerHand(object):\\n CARD = \"23456789TJQKA\"\\n RESULT = [\"Loss\", \"Tie\", \"Win\"]\\n\\n def __init__(self, hand):\\n values = ''.join(sorted(hand[::3], key=self.CARD.index))\\n suits = set(hand[1::3])\\n is_straight = values in self.CARD\\n is_flush = len(suits) == 1\\n self.score = (2", "gt": "* sum(values.count(card) for card in values)\\n + 13 * is_straight + 15 * is_flush,\\n [self.CARD.index(card) for card in values[::-1]])\\n \\n def compare_with(self, other):\\n return self.RESULT[(self.score > other.score) - (self.score < other.score) + 1]"}
{"id": "1706", "input": "def spidey_swings(building_params):\\n buildings = get_buildings(building_params)\\n end_position = get_total_length(buildings)\\n latch_positions = []\\n jump_position = 0\\n while is_not_possible_to_reach_the_end(buildings, jump_position, end_position):\\n candidate_jumps = [\\n building.get_variables_for_max_displacement(jump_position)\\n for building in buildings\\n if building.is_reachable(jump_position)\\n ]\\n candidate_jumps.sort(reverse=True)\\n _, latch_position, jump_position = candidate_jumps[0]\\n latch_positions.append(latch_position)\\n\\n candidate_final_jumps = [\\n building.get_variables_aiming_end(jump_position, end_position)\\n for building in buildings\\n if (building.is_reachable(jump_position) and\\n building.is_possible_to_reach_the_end(jump_position, end_position))\\n ]\\n candidate_final_jumps.sort(reverse=True)\\n _, latch_position = candidate_final_jumps[0]\\n latch_positions.append(latch_position)\\n\\n return latch_positions\\n\\n\\ndef get_buildings(building_params):\\n pos = 0\\n buildings = []\\n for (height, width) in building_params:\\n building = Building(height, width, pos)\\n buildings.append(building)\\n pos += width\\n return buildings\\n\\n\\ndef get_total_length(buildings):\\n return sum(building.width for building in buildings)\\n\\n\\ndef is_not_possible_to_reach_the_end(buildings, jump_position, end_position):\\n return not any(building.is_possible_to_reach_the_end(jump_position, end_position)\\n for building in buildings)\\n\\n\\nclass Building:\\n def __init__(self, height, width, pos):\\n self.height = height\\n self.width = width\\n self.pos = pos\\n\\n def max_rope_length(self):\\n return self.height - 20\\n\\n def distance_to_rooftop(self):\\n return self.height - 50\\n\\n def max_horizontal_displacement(self):\\n hypotenuse = self.max_rope_length()\\n vertical = self.distance_to_rooftop()\\n return (hypotenuse ** 2 - vertical ** 2) ** .5\\n\\n def latch_pos_for_max_displacement(self, jump_pos):\\n if jump_pos < self.pos - self.max_horizontal_displacement():\\n return None\\n if jump_pos < self.pos + self.width - self.max_horizontal_displacement():\\n return int(jump_pos + self.max_horizontal_displacement())\\n if jump_pos < self.pos + self.width:\\n", "gt": "return int(self.pos + self.width)\\n return None\\n\\n def rope_length_for_max_displacement(self, jump_pos):\\n horizontal = (self.latch_pos_for_max_displacement(jump_pos) - jump_pos)\\n vertical = self.distance_to_rooftop()\\n return (horizontal ** 2 + vertical ** 2) ** .5\\n\\n def advanced_distance_for_max_displacement(self, jump_pos):\\n return (self.latch_pos_for_max_displacement(jump_pos) - jump_pos) * 2\\n\\n def ratio_max_displacement_rope(self, jump_pos):\\n return (self.advanced_distance_for_max_displacement(jump_pos) /\\n self.rope_length_for_max_displacement(jump_pos))\\n\\n def get_variables_for_max_displacement(self, pos):\\n latch_pos = self.latch_pos_for_max_displacement(pos)\\n next_jump_pos = pos + self.advanced_distance_for_max_displacement(pos)\\n ratio = self.ratio_max_displacement_rope(pos)\\n return ratio, latch_pos, next_jump_pos\\n\\n def latch_pos_aiming_end(self, jump_pos, end_pos):\\n max_latch_pos = (jump_pos + end_pos) / 2\\n if jump_pos < self.pos - self.max_horizontal_displacement():\\n return None\\n if jump_pos <= max_latch_pos:\\n max_latch_pos = max(max_latch_pos, self.pos)\\n return int(max_latch_pos + .5)\\n return None\\n\\n def rope_length_aiming_end(self, pos, end_pos):\\n horizontal = self.latch_pos_aiming_end(pos, end_pos) - pos\\n vertical = self.distance_to_rooftop()\\n return (horizontal ** 2 + vertical ** 2) ** .5\\n\\n def ratio_aiming_end(self, pos, end_pos):\\n horizontal = end_pos - pos\\n rope = self.rope_length_aiming_end(pos, end_pos)\\n ratio = horizontal / rope\\n return ratio\\n\\n def get_variables_aiming_end(self, pos, end_pos):\\n latch_pos = self.latch_pos_aiming_end(pos, end_pos)\\n ratio = self.ratio_aiming_end(pos, end_pos)\\n return ratio, latch_pos\\n\\n def is_possible_to_reach_the_end(self, pos, end_pos):\\n if not self.is_reachable(pos):\\n return False\\n return pos + self.advanced_distance_for_max_displacement(pos) >= end_pos\\n\\n def is_reachable(self, pos):\\n return self.latch_pos_for_max_displacement(pos) is not None\\n"}
{"id": "1707", "input": "def rectangle_rotation(a, b):\\n a //= 2**0.5\\n b //= 2**0.5\\n r = (a + 1) *", "gt": "(b + 1) + a * b\\n\\n return r + r % 2 - 1"}
{"id": "1708", "input": "def cut_log(p, n):\\n log = [0]\\n for _ in range(n):\\n", "gt": "log.append(max(pi + li for pi, li in zip(p[1:], log[::-1])))\\n return log[n]\\n"}
{"id": "1709", "input": "'''\\nsome useful information about memory allocation in operating system\\n\\n->There are various algorithms which are implemented by the Operating System in order to find out the holes(continuous empy blocks) \\\\n in the linked list(array in this kata) and allocate them to the processes.\\n\\n->various algorithms used by operating system:\\n 1. First Fit Algorithm => First Fit algorithm scans the linked list and whenever it finds the first big enough hole to store a process, it stops scanning and load the process into that hole.\\n \\n 2. Next Fit Algorithm => Next Fit algorithm is similar to First Fit algorithm except the fact that, Next fit scans the linked list from the node where it previously allocated a hole.\\n ( if i have allocated memory of size 8 in previous turn and initial pointer is 3 \\\\n then in next turn os will start searching for next empty hole from position 11(3+8=11) )\\n \\n 3. Best Fit Algorithm => The Best Fit algorithm tries to find out the smallest hole possible in the list that can accommodate the size requirement of the process.\\n \\n 4. Worst Fit Algorithm => it is opposite of Best Fit Algorithm meaning that \\\\n (The worst fit algorithm scans the entire list every time and tries to find out the biggest hole in the list which can fulfill the requirement", "gt": "of the process.)\\n \\n The first fit and best fit algorithms are the best algorithm among all\\n\\nPS. I HAVE IMPLEMENTED Best Fit Algorithm IN JAVASCRIPT AND IMPLEMENTED Next Fit Algorithm in PYTHON :)\\n'''\\n\\n#Next fit Algorithm\\nclass MemoryManager:\\n def __init__(self, memory):\\n self.storage = [True] * len(memory)\\n self.previous_allocated_index = 0\\n self.allocated ="}
{"id": "1710", "input": "\\ndef sum_for_list(lst):\\n factors = {i for k in lst for i in xrange(2, abs(k)+1) if not k % i}\\n prime_factors = {i for i in factors if", "gt": "not [j for j in factors-"}
{"id": "1711", "input": "class Warrior():\\n \\n def __init__(self):\\n self._experience = 100\\n self.rs = [\"Pushover\", \"Novice\", \"Fighter\", \"Warrior\", \"Veteran\", \"Sage\", \"Elite\", \"Conqueror\", \"Champion\", \"Master\", \"Greatest\"]\\n self.achievements = []\\n def training(self, train):\\n if(train[2] > self.level) : return \"Not strong enough\";\\n self._experience += train[1]\\n self.achievements.append(train[0])\\n return train[0]\\n def battle(self, lvl):\\n diff = lvl - self.level\\n if(0 >= lvl or lvl > 100): return \"Invalid level\"\\n if(diff >= 5 and (lvl", "gt": "// 10) > (self.level // 10)):\\n return \"You've been defeated\"\\n if(diff > 0) : \\n self._experience += 20 * diff * diff\\n return \"An intense fight\"\\n if(diff > -2):\\n self._experience += 5 if diff == -1 else 10\\n return \"A good fight\"\\n return \"Easy fight\"\\n @property\\n def level(self):\\n return self.experience // 100\\n @property\\n def rank(self):\\n return self.rs[self.experience // 1000]\\n @property\\n def experience(self):\\n return min(10000, self._experience)"}
{"id": "1712", "input": "class Cons:\\n def __init__(self, head, tail):\\n self.head = head\\n self.tail = tail\\n\\n def to_array(self):\\n return [self.head] + (self.tail.to_array() if self.tail is not None else [])\\n\\n @classmethod\\n", "gt": "def from_array(cls, arr):\\n if not arr:\\n return None\\n return Cons(arr.pop(0), Cons.from_array(arr) if arr else None)\\n\\n def filter(self, fn):\\n return Cons.from_array(list(filter(fn, self.to_array())))\\n\\n def map(self, fn):\\n return Cons.from_array(list(map(fn, self.to_array())))"}
{"id": "1713", "input": "def puzzle_solver(pieces, w, h):\\n memo, D, result = {}, {None: (None, None)}, [[None]*w for _ in range(h)]\\n \\n for (a, b), (c, d), id in pieces:\\n memo[(a, b, c)] =", "gt": "id\\n D[id] = (c, d)\\n \\n for i in range(h):\\n for j in range(w):\\n a, b = D[result[i-1][j]]\\n _, c = D[result[i][j-1]]\\n result[i][j] = memo[(a, b, c)]\\n \\n return list(map(tuple, result))"}
{"id": "1714", "input": "import sys\\n\\ndef count_calls(func, *args, **kwargs):\\n \"\"\"Count calls in function func\"\"\"\\n\\n calls = [ -1 ]\\n def tracer(frame, event, arg):\\n", "gt": "if event == 'call':\\n calls[0] += 1\\n return tracer\\n sys.settrace(tracer)\\n \\n rv = func(*args, **kwargs)\\n \\n return calls[0], rv\\n"}
{"id": "1715", "input": "def hull_method(points):\\n sorted_points = sorted(points)\\n return half_hull(sorted_points) + half_hull(reversed(sorted_points))\\n\\ndef half_hull(sorted_points):\\n hull = []\\n for p in sorted_points:\\n while len(hull) > 1 and not is_ccw_turn(hull[-2], hull[-1], p):\\n", "gt": "hull.pop()\\n hull.append(p)\\n hull.pop()\\n return hull\\n\\ndef is_ccw_turn(p0, p1, p2):\\n return (p1[0] - p0[0]) * (p2[1] - p0[1]) - (p2[0] - p0[0]) * (p1[1] - p0[1]) > 0\\n"}
{"id": "1716", "input": "def justify(text, width):\\n length = text.rfind(' ', 0, width+1)\\n if length == -1 or len(text) <= width: return text\\n line = text[:length]\\n spaces = line.count(' ')\\n if spaces != 0:\\n expand = (width", "gt": "- length) / spaces + 1\\n extra = (width - length) % spaces\\n line = line.replace(' ', ' '*expand)\\n line = line.replace(' '*expand, ' '*(expand+1), extra)\\n return line + '\\n' + justify(text[length+1:], width)"}
{"id": "1717", "input": "from itertools import permutations\\n\\ndef equal_to_24(*aceg):\\n ops = '+-*/'\\n \\n for b in ops:\\n for d in ops:\\n for f in ops:\\n for (a,c,e,g) in permutations(aceg):\\n for s in make_string(a,b,c,d,e,f,g):\\n try:\\n if eval(s +", "gt": "'== 24'):\\n return s\\n except:\\n pass\\n \\n return \"It's not possible!\"\\n\\ndef make_string(a,b,c,d,e,f,g):\\n return [f\"(("}
{"id": "1718", "input": "from collections import Counter\\nimport re\\n\\n\\ndef top_3_words(text):\\n c = Counter(re.findall(r\"[a-z']+\", re.sub(r\"", "gt": "'+ \", \" \", text.lower())))\\n return [w for w,_ in c.most_common(3)]"}
{"id": "1719", "input": "MOVES = {(0,1), (0,-1), (1,0), (-1,0)}\\n\\ndef has_exit(maze):\\n posSet = {(x,y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k'}\\n if len(posSet) != 1:\\n raise ValueError(\"There shouldn't be more than one kate\")\\n \\n seen = set(posSet)\\n while posSet:\\n x,y = posSet.pop()\\n if any(not (0 <= x+dx < len(maze)and 0 <= y+dy < len(maze[x+dx])) for dx,dy in MOVES):\\n return True\\n neighbors = {(x+dx, y+dy) for dx,dy in MOVES if 0 <= x+dx < len(maze) and 0 <=", "gt": "y+dy < len(maze[x+dx])\\n and maze[x+dx][y+dy] == ' '\\n and (x+dx, y+dy) not in seen}"}
{"id": "1720", "input": "def zeroes (base, number):\\n pzeros = []\\n for p in range(2, base+1):\\n e = 0\\n while base % p == 0:\\n base /=", "gt": "p\\n e += 1\\n if e:\\n f, m = 0, number\\n while m:\\n m /= p\\n f += m\\n pzeros.append(f / e)\\n return min(pzeros)"}
{"id": "1721", "input": "import string\\nfrom collections import OrderedDict\\n\\nclass RomanNumerals:\\n @classmethod\\n def to_roman(self, num):\\n conversions = OrderedDict([('M',1000), ('CM',900), ('D', 500), ('CD',400), ('C',100), ('XC',90), ('L',50), ('XL',40),\\n ('X',10), ('IX',9), ('V',5), ('IV',4), ('I',1)])\\n out = ''\\n for key, value in conversions.items():\\n while num >= value:\\n out += key\\n num -=", "gt": "value\\n return out\\n \\n @classmethod\\n def from_roman(self, roman):\\n conversions = OrderedDict([('CM',900), ('CD',400), ('XC',90), ('XL',40), ('IX',9), ('IV',4), ('M',1000), ('D',500),\\n ('C',100), ('L',50), ('X',10), ('V',5), ('I',1)])\\n out = 0\\n for key, value in conversions.items():\\n out += value * roman.count(key)\\n roman = string.replace(roman, key, \"\")\\n return out\\n\\n"}
{"id": "1722", "input": "def create_number_class(alphabet):\\n n = len(alphabet)\\n\\n class Number(object):\\n def __init__(self, s):\\n if isinstance(s, str):\\n v = 0\\n for c in s:\\n v = v * n + alphabet.index(c)\\n else:\\n v = s\\n self.value = v\\n\\n def __add__(self, other):\\n return Number(self.value + other.value)\\n\\n def __sub__(self, other):\\n", "gt": "return Number(self.value - other.value)\\n\\n def __mul__(self, other):\\n return Number(self.value * other.value)\\n\\n def __floordiv__(self, other):\\n return Number(self.value // other.value)\\n\\n def __str__(self):\\n ret = []\\n v = int(self.value)\\n while v:\\n (v, r) = divmod(v, n)\\n ret.append(alphabet[r])\\n return ''.join(reversed(ret or alphabet[0]))\\n\\n def convert_to(self, cls):\\n return cls(self.value)\\n\\n return Number\\n\\n"}
{"id": "1723", "input": "class Machine:\\n def __init__(self):\\n self.cmd = dict()\\n self._actions = [lambda x: x + 1, lambda x: 0, lambda x: x / 2, lambda x: x * 100, lambda x: x", "gt": "% 2]\\n\\n def command(self, cmd, num):\\n self.last_cmd = cmd\\n if cmd in self.cmd:\\n return self._actions[self.cmd[cmd]](num)\\n else:\\n self.cmd[cmd] = 0\\n return self._actions[self.cmd[cmd]](num)\\n\\n def response(self,res):\\n if res == False:\\n self.cmd[self.last_cmd] += 1"}
{"id": "1724", "input": "class Segment: # Instead of an abstract class, make it the implementation for all three subclasses\\n def __init__(self, *coords):\\n self.control_points = coords # IMHO a getter/setter is overkill here\\n\\n def control_points_at(self, t): # Helper function\\n p = self.control_points\\n", "gt": "result = []\\n while p:\\n result.extend(p[:2])\\n p = [v + (p[i+2] - v) * t for i, v in enumerate(p[:-2])]\\n return result\\n\\n def point_at(self, t):\\n return tuple(self.control_points_at(t)[-2:])\\n\\n def sub_segment(self, t):\\n return self.__class__(*self.control_points_at(t))\\n\\nclass Line(Segment): pass\\nclass Quad(Segment): pass\\nclass Cubic(Segment): pass"}
{"id": "1725", "input": "def blast_sequence(aliensStart,position):\\n \\n def moveAliens(aliens, furthest):\\n lst, shootPath = [], []\\n for x,y,s in aliens:\\n y += s\\n if not (0 <= y < N): #Out of the grid: move down and reverse\\n x, s = x+1, -s\\n y = -y-1 if y < 0 else 2*N-y-1\\n (shootPath if y == Y else lst).append((x,y,s))\\n if x > furthest: furthest = x\\n return lst, shootPath, furthest\\n \\n def shootTarget(shootPath):\\n if shootPath:\\n z = max(shootPath, key=lambda a: (a[0], abs(a[2]), a[2])) # Furthest, fastest, going right is considered the highest\\n shootPath.remove(z) # MUTATION\\n shots.append(turn) # MUTATION\\n \\n (X,Y), N", "gt": "= position, len(aliensStart[0])\\n aliens = [(x,y,s) for x,r in enumerate(aliensStart) for y,s in enumerate(r) if s]\\n shots, furthest, turn = [], 0, -1\\n \\n while aliens and furthest < X:\\n turn += 1\\n aliens, shootPath, furthest = moveAliens(aliens, furthest) # Move all the aliens, splitting them in 2 groups: those facing \"my\" ship (shootPath) and the others\\n shootTarget(shootPath) # Extract the target in shootPath and pop it if possible (mutation). Mutate 'shots' list at the same time\\n aliens += shootPath # Put the remaining aliens in the list\\n \\n return shots if not aliens else None"}
{"id": "1726", "input": "mod = 12345787\\nmat = [([1,1],[0,1,3]),\\n ([2,1,-1],[0,2,6,11]),\\n ([2,3,-1,-1],[0,2,10,23,70]),\\n ([3,3,-4,-1,1],[0,3,15,42,155,533]),\\n ([3,6,-4,-5,1,1],[0,3,21,69,301,1223,5103])]\\n\\nfor i in range(100):", "gt": "[m.append(sum(k*m[-1-i] for i,k in enumerate(c))%mod) for c,m in mat]\\n\\ndef circular_limited_sums(max_n, max_fn): return mat[max_fn-1][1][max_n]"}
{"id": "1727", "input": "def path_finder(maze):\\n matrix = list(map(list, maze.splitlines()))\\n stack, length = [[0, 0]], len(matrix)\\n while len(stack):\\n x, y = stack.pop()\\n if matrix[x][y] == '.':\\n matrix[x][y] = 'x'\\n for x,", "gt": "y in (x, y-1), (x, y+1), (x-1, y), (x+1, y):\\n if 0 <= x < length and 0 <= y < length:\\n stack.append((x, y))\\n return matrix[length-1][length-1] == 'x'"}
{"id": "1728", "input": "def find_word(board, word):\\n grid = [l+[''] for l in board] + [[''] * (len(board[0]) + 1)]\\n def rc(x, y, i):\\n if i == len(word): return True\\n if grid[x][y] != word[i]: return False\\n grid[x][y] = ''\\n r", "gt": "= any(rc(x + u, y + v, i + 1)\\n for u in range(-1, 2)\\n for v in range(-1, 2))\\n grid[x][y] = word[i]\\n return r\\n return any(rc(x, y, 0)\\n for x in range(len(board))\\n for y in range(len(board[x])))"}
{"id": "1729", "input": "class PlayerMovement:\\n \\n PREC = [8, 2, 4, 6] # Order of precedence\\n I_KEYS = {8: 0, 2: 1, 4: 2, 6: 3} # Index of the keys in self.pressed\\n MOVES = {8: (0,1), 2: (0,-1), 4: (-1,0), 6: (1,0)} # Moves directions\\n\\n def __init__(self, x, y):\\n self.position = Tile(x, y) # Current position\\n self.direction = 8 # Current direction of move\\n self.pressed = [0,0,0,0] # Keys currently pressed or not (True/False)\\n self.stack = [] # Stack representing the order of the pressed keys (according to pressing order AND precedence if multiple pressing at the same time)\\n\\n def update(self):\\n state = [Input.get_state(d) for d in self.PREC] # State of the art at update time\\n \\n newPressed = [ d for i,d in enumerate(self.PREC) if not self.pressed[i] and state[i] ] # All keys freshly pressed\\n notReleased = next((d for d in self.stack[::-1] if self.pressed[self.I_KEYS[d]] and state[self.I_KEYS[d]]), None) # Last key that has not been released yet (according", "gt": "to the order of the stack[::-1] because one search for the last pressed)\\n releasedLst = [ d for i,d in enumerate(self.PREC) if self.pressed[i] and not state[i] ] # All keys freshly released\\n \\n if newPressed: # If new key pressed:\\n self.direction = newPressed[0] # Update direction with higher precedence\\n for t in newPressed[::-1]: self.stack.append(t) # append all the new kleys to the stack, lower preccedence first\\n \\n elif self.direction in releasedLst: # If the current direction has been released:\\n self.direction = notReleased or self.direction # upadte direction. If no pressed key remain, do not update\\n \\n elif notReleased: # If current direction still pressed and no other key pressed in the meantime:\\n self.position = Tile(*( z+dz for z,dz in zip([self.position.x, self.position.y], self.MOVES[notReleased]) )) # MOVE!\\n \\n self.pressed = state # Archive current state of keys\\n for t in releasedLst: self.stack.remove(t) # remove all the released keys from the stack, whatever their position in the stack is"}
{"id": "1730", "input": "import re\\n\\nclass Me(object):\\n def __init__(self): self.x, self.y, self.dx, self.dy = 0,0,-1,0\\n def move(self, n): self.x += n*self.dx ; self.y += n*self.dy\\n def back(self): self.dx *= -1 ; self.dy *= -1\\n def turn(self, d): self.dx,self.dy = (self.dy * (-1)**(d=='l'), 0)", "gt": "if self.dy else (0, self.dx * (-1)**(d=='r'))\\n def where(self): return [self.x, self.y]\\n def __str__(self): return f'x,y="}
{"id": "1731", "input": "def two_by_n(n, k):\\n vv, vh, hv, hh = k-1, (k-1)*(k-2), k-2, (k-1)*(k-2) + 1\\n va, ha, vb, hb = 0, 0, 1, 1\\n for i in", "gt": "range(n - 1):\\n va, ha, vb, hb = vb, hb, vv*vb + vh*ha, hv*vb + hh*ha\\n return (k * vb + k*(k-1) * ha) % 12345787\\n"}
{"id": "1732", "input": "from random import choice\\n\\ndef interpret(code):\\n code = [list(l) for l in code.split('\\n')]\\n x, y = 0, 0\\n dx, dy = 1, 0\\n output = ''\\n stack = []\\n string_mode = False\\n \\n while True:\\n move = 1\\n i = code[y][x]\\n \\n if string_mode:\\n if i == '\"':\\n string_mode = False\\n else:\\n stack.append(ord(i))\\n else:\\n \\n if i.isdigit(): stack.append(int(i))\\n elif i == '+': stack[-2:] = [stack[-2] + stack[-1]]\\n elif i == '-': stack[-2:] = [stack[-2] - stack[-1]]\\n elif i == '*': stack[-2:] = [stack[-2] * stack[-1]]\\n elif i == '/': stack[-2:] = [stack[-2] and stack[-2] / stack[-1]]\\n elif i == '%': stack[-2:] = [stack[-2] and stack[-2] % stack[-1]]\\n elif i == '!': stack[-1] = not stack[-1]\\n elif i == '`': stack[-2:] = [stack[-2] > stack[-1]]\\n elif i in '><^v?':\\n if i == '?': i = choice('><^v')\\n if i == '>': dx, dy = 1, 0\\n elif i == '<':", "gt": "dx, dy = -1, 0\\n elif i == '^': dx, dy = 0, -1\\n elif i == 'v': dx, dy = 0, 1\\n elif i == '_': dx, dy = (-1 if stack.pop() else 1), 0\\n elif i == '|': dx, dy = 0, (-1 if stack.pop() else 1)\\n elif i == '\"': string_mode = True\\n elif i == ':': stack.append(stack[-1] if stack else 0)\\n elif i == '\\\\': stack[-2:] = stack[-2:][::-1]\\n elif i == '$': stack.pop()\\n elif i == '.': output += str(stack.pop())\\n elif i == ',': output += chr(stack.pop())\\n elif i == '#': move += 1\\n elif i == 'p':\\n ty, tx, tv = stack.pop(), stack.pop(), stack.pop()\\n code[ty][tx] = chr(tv)\\n elif i == 'g':\\n ty, tx = stack.pop(), stack.pop()\\n stack.append(ord(code[ty][tx]))\\n elif i == '@':\\n return output\\n \\n for _ in range(move):\\n x = (x + dx) % len(code[y])\\n y = (y + dy) % len(code)"}
{"id": "1733", "input": "from collections import defaultdict\\nfrom functools import reduce\\nimport re\\n\\nP_EQ = re.compile(\"(?P<eq>=)|(?P<coef>[+-]?\\d*)(?P<var>[a-zA-Z]*)\")\\n\\n\\ndef solve(*equations):\\n \\n eqsMap = list(map(parse, equations)) # Transform each string in a dict {'var': coef}\\n vars = reduce(set.union, (set(e) for e in eqsMap)) # Extract all the variables\\n vars = list(set(vars)-{''}) + [''] # Push the \"constants\" at the end of the list\\n \\n if len(vars)-1 > len(equations): return None # Not enough equations to solve the system\\n \\n m = [ [eqm[v] for v in vars] for eqm in eqsMap] # Build the matrix\\n \\n return solveMatrix(m, vars) # Solve using Gauss elimination\\n \\n\\ndef parse(eq):\\n rev, dct = 1, defaultdict(int)\\n for m in P_EQ.finditer(eq.replace(\" \",\"\")):\\n if m['eq']:\\n rev = -1\\n else:\\n gc, gv = m['coef'], m['var']\\n if gc or gv:\\n coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\\n dct[ m['var'] ] += coef * rev\\n return dct\\n\\n\\ndef solveMatrix(m, vars):\\n \\n EPS = 1e-10\\n pivots = {} # dict of the indexes of the pivots (avoid to have to move the raws)\\n toDo = set(range(len(m))) # set with the indexes of all the lines where the pivot", "gt": "will have to be sought for\\n \\n for y in range(len(vars)-1): # \"-1\" to avoid the constants\\n \\n _,px = max( ((abs(m[x][y]),x) for x in toDo if abs(m[x][y]) > 0), default=(-1,-1))\\n \\n if px == -1: continue # No pivot found\\n pivots[px] = y\\n toDo.remove(px)\\n \\n maxP, m[px][y] = m[px][y], 1\\n for j in range(y+1,len(vars)): # Update the line of the current pivot\\n m[px][j] /= maxP\\n if abs(m[px][j]) < EPS: m[px][j] = 0 # Handle floating point errors\\n \\n for x in range(0,len(m)): # Update all the lines, doing the elimination\\n if x==px: continue # Skip the line of the current pivot\\n \\n coef, m[x][y] = m[x][y], 0\\n for j in range(y+1,len(vars)): # Update the line of the current pivot\\n m[x][j] -= coef * m[px][j]\\n if abs(m[x][j]) < EPS: m[x][j] = 0 # Handle floating point errors, again...\\n \\n \\n solvedDct ="}
{"id": "1734", "input": "from collections import deque\\nmoves = ((1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1))\\n\\ndef knight(p1, p2):\\n x, y = ord(p2[0])-97, int(p2[1])-1\\n left, seen = deque([(ord(p1[0])-97, int(p1[1])-1, 0)]), set()\\n while left:\\n", "gt": "i, j, v = left.popleft()\\n if i==x and j==y: return v\\n if (i, j) in seen: continue\\n seen.add((i, j))\\n for a,b in moves:\\n if 0 <= i+a < 8 and 0 <= j+b < 8:\\n left.append((i+a, j+b, v+1))"}
{"id": "1735", "input": "class User (): \\n def __init__ (self):\\n self.RANKS = [-8, -7, -6, -5, -4, -3, -2, -1, 1, 2, 3, 4, 5, 6, 7, 8]\\n self.rank = -8\\n self.rank_index = 0\\n self.progress = 0\\n \\n def inc_progress (self, rank):\\n rank_index = self.RANKS.index(rank)\\n \\n if rank_index == self.rank_index:\\n self.progress +=", "gt": "3\\n elif rank_index == self.rank_index - 1:\\n self.progress += 1\\n elif rank_index > self.rank_index:\\n difference = rank_index - self.rank_index\\n self.progress += 10 * difference * difference\\n \\n while self.progress >= 100:\\n self.rank_index += 1\\n self.rank = self.RANKS[self.rank_index]\\n self.progress -= 100 \\n \\n if self.rank == 8:\\n self.progress = 0\\n return"}
{"id": "1736", "input": "from heapq import *\\n\\nMOVES = tuple( (dx,dy) for dx in range(-1,2) for dy in range(-1,2) if dx or dy)\\n\\n\\ndef shallowest_path(river):\\n\\n lX,lY = len(river), len(river[0])\\n pathDct = {}\\n cost = [ [(float('inf'),float('inf'))]*lY for _ in range(lX) ]\\n for x in range(lX): cost[x][0] = (river[x][0],1)\\n \\n q = [ (river[x][0], lY==1, 1, (x,0)) for x in range(lX)]\\n heapify(q)\\n \\n while", "gt": "not q[0][1]:\\n c,_,steps,pos = heappop(q)\\n x,y = pos\\n for dx,dy in MOVES:\\n a,b = new = x+dx,y+dy\\n if 0<=a<lX and 0<=b<lY: \\n check = nC,nS = max(c, river[a][b]), steps+1\\n if cost[a][b] > check:\\n cost[a][b] = check\\n pathDct[new] = pos\\n heappush(q, (nC, b==lY-1, nS, new))\\n \\n path, pos = [], q[0][-1]\\n while pos:\\n path.append(pos)\\n pos = pathDct.get(pos)\\n return path[::-1]"}
{"id": "1737", "input": "def is_incrementing(number): return str(number) in '1234567890'\\ndef is_decrementing(number): return str(number) in '9876543210'\\ndef is_palindrome(number): return str(number) == str(number)[::-1]\\ndef is_round(number): return set(str(number)[1:]) == set('0')\\n\\ndef is_interesting(number, awesome_phrases):\\n tests = (is_round, is_incrementing,", "gt": "is_decrementing,\\n is_palindrome, awesome_phrases.__contains__)\\n \\n for num, color in zip(range(number, number+3), (2, 1, 1)):\\n if num >= 100 and any(test(num) for test in tests):\\n return color\\n return 0"}
{"id": "1738", "input": "from collections import Counter\\n\\ndef runoff(voters):\\n while voters[0]:\\n poll = Counter(ballot[0] for ballot in voters)\\n winner, maxscore = max(poll.items(), key = lambda x: x[1])\\n minscore", "gt": "= min(poll.values())\\n if maxscore * 2 > len(voters):\\n return winner\\n voters = [[c for c in voter if poll[c] > minscore] for voter in voters]"}
{"id": "1739", "input": "from collections import defaultdict\\nfrom itertools import combinations\\n\\ndef norme(vect): return sum( v**2 for v in vect )**.5\\ndef vectorize(pt1, pt2): return [b-a for a,b in zip(pt1, pt2)]\\ndef isInCircle(d, r): return d < r and (r-d)/r > 1e-10\\ndef crossProd(v1, v2): return [v1[0]*v2[1] - v1[1]*v2[0],\\n v1[1]*v2[2] - v1[2]*v2[1],\\n v1[2]*v2[0] - v1[0]*v2[2] ]\\n\\ndef biggest_triang_int(point_list, center, radius):\\n filteredPts = [ pt", "gt": "for pt in point_list if isInCircle(norme(vectorize(pt, center)), radius) ]\\n \\n dctTriangles = defaultdict(list)\\n for threePts in combinations(filteredPts, 3):\\n area = abs( norme(crossProd(vectorize(*threePts[:2]), vectorize(*threePts[1:]))) / 2.0 )\\n if area > 1e-8: dctTriangles[area].append(list(threePts))\\n \\n maxArea = max(dctTriangles.keys()) if dctTriangles else 0\\n return [] if not dctTriangles else [sum(map(len, dctTriangles.values())),\\n maxArea,\\n sorted(dctTriangles[maxArea]) if len(dctTriangles[maxArea]) > 1 else dctTriangles[maxArea][0] ]"}
{"id": "1740", "input": "def decodeBits(bits):\\n import re\\n \\n # remove trailing and leading 0's\\n bits = bits.strip('0')\\n \\n # find the least amount of occurrences of either a 0 or 1, and that is the time hop\\n time_unit", "gt": "= min(len(m) for m in re.findall(r'1+|0+', bits))\\n \\n # hop through the bits and translate to morse\\n return bits[::time_unit].replace('111', '-').replace('1','.').replace('0000000',' ').replace('000',' ').replace('0','')\\n\\ndef decodeMorse(morseCode):\\n return ' '.join(''.join(MORSE_CODE[l] for l in w.split()) for w in morseCode.split(' '))\\n"}
{"id": "1741", "input": "class family:\\n def __init__(self): self.names = {} \\n def male(self, n): return self.setsex(n, 'm') \\n def female(self, n): return self.setsex(n, 'f') \\n def is_male(self, n): return self.names[n]['sex'] == 'm' if n in self.names else False\\n def is_female(self, n): return self.names[n]['sex'] == 'f' if n in self.names else False\\n def get_parents_of(self, n): return sorted(self.names[n]['childof']) if n in self.names else []\\n def get_children_of(self, n): return sorted(self.names[n]['parentof']) if n in self.names else []\\n \\n def updatesex(self):\\n for n in [n for n in self.names if len(self.names[n]['childof']) == 2]:\\n for a, b in [self.names[n]['childof'], self.names[n]['childof'][::-1]]:\\n if self.names[a]['sex'] and not self.names[b]['sex']:\\n self.names[b]['sex'] = 'f' if self.names[a]['sex'] == 'm' else 'm'\\n self.updatesex()\\n \\n def setsex(self, name, sex):\\n if name not in self.names: self.names[name] = {'sex':'', 'parentof':[], 'childof':[]}\\n if not self.names[name]['sex']: \\n self.names[name]['sex'] = sex\\n self.updatesex() \\n \\n return self.names[name]['sex'] == sex\\n \\n def set_parent_of(self, c, p):\\n # Create child and/or parent if they do not exist\\n for n in [c, p]: \\n if n not in self.names: self.names[n] = {'sex':'', 'parentof':[], 'childof':[]}\\n\\n if p in self.names[c]['childof']: return True\\n if c == p or len(self.names[c]['childof'])== 2: return False\\n \\n # descendants and ancestors \\n for tree, direction, name in [(self.names[c]['parentof'], 'parentof', p), (self.names[p]['childof'], 'childof', c)]:\\n while tree:\\n if name in tree: return False\\n tree = [e for d in tree for e in self.names[d][direction]]\\n\\n if len(self.names[c]['childof']) == 1:\\n old_p, new_sex = self.names[c]['childof'][0], self.names[p]['sex'] \\n \\n if new_sex + self.names[old_p]['sex'] in ['mm', 'ff']: return False \\n\\n # Check for clashing parents\\n # Get all couple and create a putative sex dictionary S\\n couples = {tuple(self.names[n]['childof']) for n in self.names", "gt": "if len(self.names[n]['childof']) > 1}"}
{"id": "1742", "input": "import numpy as np\\ndef five_by_2n(n):\\n x=np.array([[1,1,1,1,1,1,1,1],[1,2,1,1,1,2,2,1],[1,1,2,1,1,1,2,1],[1,1,1,2,1,1,2,1],[1,1,1,1,2,1,2,2],[1,2,1,1,2,1,6,1],[1,2,1,1,2,1,6,1],[1,2,1,1,2,1,6,1]])\\n y=np.array([1,1,1,1,1,1,1,1])\\n", "gt": "z=y\\n for i in range(n-1):\\n z=np.mod(x@z,12345787*y)\\n return z.T@y%12345787"}
{"id": "1743", "input": "def combos(n, m = 1):\\n if n < m:return []\\n res = [[n]]\\n for i in xrange(m,", "gt": "n):\\n l = [i]\\n for j in combos(n - i, i):\\n res += [l + j]\\n return res"}
{"id": "1744", "input": "def collatz_steps(n, steps):\\n while True:\\n str = ''\\n result = n\\n \\n while bool(str != steps) ^ bool(str != steps[:len(str)]):\\n if result % 2 == 0:\\n result", "gt": "= result/2\\n str += 'D'\\n else:\\n result = (3*result + 1)/2\\n str += 'U'\\n \\n if str != steps: \\n n += 2**(len(str)-1)\\n else: \\n return n"}
{"id": "1745", "input": "def fusc(n):\\n a, b = 1, 0\\n for i in bin(n)[2:]:\\n if", "gt": "i == '1': b += a\\n else: a += b\\n return b\\n"}
{"id": "1746", "input": "import re\\n\\nADDSUB, MULDIV = '+-', '*$'\\n\\ndef calculate(expression):\\n return \"400: Bad request\" if re.search(r'[^+*$\\d.-]', expression) else parseAndEval(expression, ADDSUB)\\n\\ndef parseAndEval(expression, ops):\\n v = 0\\n for op,part in re.findall(r'([{0}])?([^{0}]+)'.format(ops), expression):\\n if not op: v =", "gt": "float(part) if ops == MULDIV else parseAndEval(part, MULDIV)\\n elif op=='*': v *= float(part)\\n elif op=='$': v /= float(part)\\n elif op=='+': v += parseAndEval(part, MULDIV)\\n elif op=='-': v -= parseAndEval(part, MULDIV)\\n return v"}
{"id": "1747", "input": "def rpg(field, actions):\\n p = Player(field)\\n try:\\n for m in actions:\\n if m=='A': p.attack()\\n elif m in 'HCK': p.use(m)\\n elif m in '<^>v': p.rotate(m)\\n p.checkDmgsAndAlive()\\n if m=='F': p.move()\\n \\n except Exception as e:\\n return None\\n return p.state()\\n \\n\\nclass Player:\\n DIRS = dict(list(zip('<>^v',((0,-1),(0,1),(-1,0),(1,0)))))\\n\\n def __init__(self,field):\\n self.h, self.atk, self.d, self.bag, self.xps = 3,1,1,[],0\\n self.field = field\\n self.pngs = {}\\n for x,r in enumerate(self.field):\\n for y,c in enumerate(r):\\n if c in self.DIRS: self.x,self.y,self.c=x,y,c ; self.dx,self.dy=self.DIRS[c]\\n elif c=='D': self.pngs[(x,y)] = {'h':10, 'atk':3}\\n elif c=='E': self.pngs[(x,y)] = {'h':1, 'atk':2}\\n elif c=='M': self.pngs['M'] = {'coins':3}\\n \\n def state(self): return self.field, self.h, self.atk, self.d, sorted(self.bag)\\n \\n def rotate(self,c):\\n self.dx, self.dy = self.DIRS[c]\\n self.c = self.field[self.x][self.y] = c\\n \\n def move(self):\\n self.field[self.x][self.y] = ' '\\n self.x += self.dx\\n self.y += self.dy\\n c = self.field[self.x][self.y]\\n assert c", "gt": "not in '#ED-|M' and self.x>=0 and self.y>=0\\n if c!=' ': self.takeThis(c)\\n self.field[self.x][self.y] = self.c\\n \\n def checkAhead(self,what):\\n x,y = self.x+self.dx, self.y+self.dy\\n assert self.field[x][y] in what\\n return x,y\\n \\n def takeThis(self,c):\\n if c not in 'SX': self.bag.append(c)\\n if c=='S': self.d += 1\\n elif c=='X': self.atk += 1\\n \\n def use(self,c):\\n self.bag.remove(c)\\n if c=='C':\\n x,y = self.checkAhead('M')\\n self.pngs['M']['coins'] -= 1\\n if not self.pngs['M']['coins']: self.field[x][y] = ' '\\n elif c=='H':\\n assert self.h<3\\n self.h = 3\\n elif c=='K':\\n x,y = self.checkAhead('|-')\\n self.field[x][y] = ' '\\n \\n def attack(self):\\n x,y = nmy = self.checkAhead('ED')\\n self.pngs[nmy]['h'] -= self.atk\\n if self.pngs[nmy]['h']<1:\\n del self.pngs[nmy]\\n self.field[x][y] = ' '\\n lvlUp,self.xps = divmod(self.xps+1,3)\\n self.atk += lvlUp\\n \\n def checkDmgsAndAlive(self):\\n for dx,dy in list(self.DIRS.values()):\\n nmy = self.x+dx, self.y+dy\\n if nmy in self.pngs:\\n self.h -= max(0,self.pngs[nmy]['atk'] - self.d)\\n assert self.h>0\\n \\n"}
{"id": "1748", "input": "def crosstable(players, scores):\\n points, le = {j:sum(k or 0 for k in scores[i]) for i, j in enumerate(players)}, len(players)\\n SB = {j:sum(points[players[k]] / ([1, 2][l == 0.5]) for k, l in enumerate(scores[i]) if l) for i, j in enumerate(players)}\\n\\n SORTED, li = [[i, players.index(i)] for i in sorted(players, key=lambda x: (-points[x], -SB[x], x.split()[1]))], []\\n\\n ps = [format(i, '.1f') for i in points.values()]\\n Ss = [format(i, '.2f') for i in SB.values()]\\n \\n digit = len(str(le))\\n name = len(max(players, key=len))\\n pts = len(str(max(ps, key=lambda x: len(str(x)))))\\n sb = len(str(max(Ss, key=lambda x: len(str(x)))))\\n\\n for i, j in enumerate(SORTED):\\n ten_ = [\" \", \" \"][le >= 10]\\n index = [str(i +", "gt": "1), \" \"][points[j[0]] == points[SORTED[i - 1][0]] and SB[j[0]] == SB[SORTED[i - 1][0]]].rjust(digit)\\n name_ = j[0].ljust(name)\\n team = ten_.join(['1=0 '[[1, 0.5, 0, None].index(scores[j[1]][l])] or '_' for k, l in SORTED])\\n pt = str(format(points[j[0]], \".1f\")).rjust(pts)\\n Sb = str(format(SB[j[0]], \".2f\")).rjust(sb)\\n li.append(f'"}
{"id": "1749", "input": "import collections\\n\\nclass Tower:\\n def __init__(self):\\n indicesOfAlienPath = []\\n shots = 0\\n\\nclass GameStats:\\n def __init__(self):\\n alienPath = collections.deque()\\n towers = []\\n waves = collections.deque()\\n\\nDirEOL = 0\\nDirLeft = 1\\nDirRight = 2\\nDirUp = 3\\nDirDown = 4\\n\\n\\ndef tower_defense(grid, turrets, aliens):\\n game = FromBattlefield(grid, turrets, aliens)\\n numSurvivedAliens = 0\\n while AnalysisIsRunning(game.alienPath, game.remainingWaves):\\n game = PrepareRound(game)\\n game.alienPath = KillAliens(game.alienPath, game.towers)\\n numSurvivedAliens = numSurvivedAliens + CountAliensLeavingPath(game.alienPath)\\n return numSurvivedAliens\\n\\ndef FromBattlefield(grid, turrets, aliens):\\n coords = DeterminePathCoordinates(grid)\\n game = GameStats()\\n game.alienPath = collections.deque([0 for a in range(len(coords))])\\n game.towers = CreateTowers(grid, turrets, coords)\\n game.remainingWaves = collections.deque(aliens)\\n return game\\n\\ndef DeterminePathCoordinates(grid):\\n result = []\\n coord = GetCoordFor(grid, '0')\\n result.append(coord)\\n dir = LookForPath(grid, coord, DirEOL)\\n while dir != DirEOL:\\n coord = GetCoordinate(coord, dir)\\n result.append(coord)\\n dir = LookForPath(grid, coord, dir)\\n return result\\n\\ndef GetCoordFor(grid, id):\\n n = len(grid)\\n for row in range(n):\\n for col in range(n):\\n if grid[row][col] == id:\\n return (col, row)\\n return (0,0)\\n\\ndef LookForPath(grid, c, dir):\\n if IsOnPath(grid, (c[0]+1, c[1])) and dir != DirLeft:\\n return DirRight\\n elif IsOnPath(grid, (c[0]-1, c[1])) and dir != DirRight:\\n return DirLeft\\n elif IsOnPath(grid, (c[0], c[1]-1)) and dir != DirDown:\\n return DirUp\\n elif IsOnPath(grid, (c[0], c[1]+1)) and dir != DirUp:\\n return DirDown\\n return DirEOL\\n\\ndef GetCoordinate(orig, dir):\\n if dir == DirLeft:\\n return (orig[0]-1, orig[1])\\n elif dir == DirRight:\\n return (orig[0]+1, orig[1])\\n elif dir == DirUp:\\n return (orig[0], orig[1]-1)\\n elif dir == DirDown:\\n return (orig[0], orig[1]+1)\\n return orig\\n\\ndef IsOnPath(grid, c):\\n n = len(grid)\\n return c[1] < n and c[0] < n", "gt": "and c[1] >= 0 and c[0] >= 0 and (grid[c[1]][c[0]] == '1' or grid[c[1]][c[0]] == '0')\\n\\ndef CreateTowers(grid, turrets, alienPathCoords):\\n towers = []\\n for name in sorted(turrets.keys()):\\n towerCoords = GetCoordFor(grid, name)\\n pathIdxInRange = DetermineIndicesOfAlienPathInRange(alienPathCoords, towerCoords, turrets[name][0])\\n towers.append((pathIdxInRange, turrets[name][1]))\\n return towers\\n\\ndef DetermineIndicesOfAlienPathInRange(alienPathCoords, towerCoords, dist):\\n result = []\\n sqrDist = dist*dist\\n startY = max(0, towerCoords[1] - dist)\\n startX = max(0, towerCoords[0] - dist)\\n for y in range(startY, towerCoords[1] + dist+1):\\n for x in range(startX, towerCoords[0] + dist+1):\\n cur = (x, y)\\n if cur in alienPathCoords and SqrDistance(cur, towerCoords) <= sqrDist:\\n result.append(alienPathCoords.index(cur))\\n return sorted(result)\\n\\ndef SqrDistance(left, right):\\n y = left[1] - right[1]\\n x = left[0] - right[0]\\n return x*x + y*y\\n\\n\\ndef AnalysisIsRunning(alienPath, waves):\\n return len(waves) > 0 or any(alienPath)\\n\\ndef PrepareRound(game):\\n game.alienPath.pop()\\n if len(game.remainingWaves) > 0:\\n game.alienPath.appendleft(game.remainingWaves.popleft())\\n else:\\n game.alienPath.appendleft(0)\\n return game\\n\\ndef KillAliens(alienPath, towers):\\n activeTowers = towers.copy()\\n while CanShootAgain(activeTowers):\\n alienPath, activeTowers = ShootWithTowers(alienPath, activeTowers)\\n activeTowers = FilterInactiveTowers(alienPath, activeTowers)\\n return alienPath\\n\\ndef CanShootAgain(towers):\\n return len(towers) > 0\\n\\ndef ShootWithTowers(alienPath, towers):\\n towersShot = []\\n for t in towers:\\n alienPath, t = ShootAliensInFormostPosition(alienPath, t)\\n towersShot.append(t)\\n return alienPath, towersShot\\n\\ndef ShootAliensInFormostPosition(alienPath, tower):\\n for idx in reversed(tower[0]):\\n if alienPath[idx] > 0:\\n shots = tower[1] - 1\\n alienPath[idx] = alienPath[idx] - 1\\n return alienPath, (tower[0], shots)\\n return alienPath, tower\\n\\ndef FilterInactiveTowers(alienPath, towers):\\n result = []\\n for t in towers:\\n if t[1] > 0 and AreAliensInRange(alienPath, t[0]):\\n result.append(t)\\n return result\\n\\ndef AreAliensInRange(alienPath, towerRange):\\n for idx in towerRange:\\n if alienPath[idx] > 0:\\n return True\\n return False\\n\\ndef CountAliensLeavingPath(alienPath):\\n return alienPath[-1]"}
{"id": "1750", "input": "def isqrt(num):\\n '''Compute int(sqrt(n)) for n integer > 0\\n O(log4(n)) and no floating point operation, no division'''\\n res, bit = 0, 1\\n while bit <= num:\\n bit <<= 2\\n bit >>= 2\\n\\n while bit:\\n if num >= res + bit:\\n num -= res + bit\\n res += bit << 1\\n res >>= 1\\n bit >>= 2\\n return res\\n\\ndef factorize(n):\\n for q in 2, 3:\\n m = 0\\n while not n % q:\\n m += 1\\n n //= q\\n if m: yield q, m\\n", "gt": "\\n m, d, q, maxq = 0, 4, 1, isqrt(n)\\n while q <= maxq:\\n q, d = q + d, 6 - d\\n while not n % q:\\n m += 1\\n n //= q\\n if m:\\n yield q, m\\n m, d, q, maxq = 0, 4, 1, isqrt(n)\\n if n > 1: yield n, 1\\n\\ndef count_factor(n, f):\\n s = 0\\n while n >= f:\\n n //= f\\n s += n\\n return s\\n\\ntrailing_zeros = lambda n, b: min(count_factor(n, f)//m for f, m in factorize(b))"}
{"id": "1751", "input": "def mystery(n):\\n return n ^ (n >> 1)\\n\\ndef mystery_inv(n):\\n mask = n >> 1\\n while mask !=", "gt": "0:\\n n = n ^ mask\\n mask = mask >> 1\\n return n;\\n\\ndef name_of_mystery():\\n return \"Gray code\""}
{"id": "1752", "input": "from heapq import *\\nfrom itertools import starmap\\nfrom collections import deque, namedtuple\\n\\nArmy = namedtuple('Army', 'i,q')\\nSoldier = namedtuple('Soldier', 'i,speed')\\n\\n\\ndef queue_battle(d, *args):\\n armies = [ Army(i, deque(starmap(Soldier,enumerate(q))) ) for i,q in enumerate(args)]\\n bullets = [[] for _ in range(len(armies))] # bullet[i] shoots at armies[i+1]\\n t = 0\\n \\n while len(armies)>1:\\n t += 1\\n alives = [1]*len(armies)\\n \\n for i,q in enumerate(bullets):\\n if q and q[0]<=t: alives[ (i+1)%len(armies)", "gt": "] = 0\\n while q and q[0]<=t: heappop(q)\\n \\n emptyArmies = False\\n for i,alive in enumerate(alives):\\n if alive:\\n heappush(bullets[i], t + d/armies[i].q[0].speed)\\n armies[i].q.rotate(-1)\\n else:\\n armies[i].q.popleft()\\n emptyArmies |= not armies[i].q\\n \\n if emptyArmies:\\n armies = [army for army in armies if army.q]\\n bullets = [[] for _ in range(len(armies))]\\n \\n if not armies: return (-1,())\\n win = armies.pop()\\n return (win.i, tuple(soldier.i for soldier in win.q))"}
{"id": "1753", "input": "from itertools import product\\n\\nADJACENTS = ('08', '124', '2135', '326', '4157', '52468', '6359', '748',", "gt": "'85790', '968')\\n\\ndef get_pins(observed):\\n return [''.join(p) for p in product(*(ADJACENTS[int(d)] for d in observed))]"}
{"id": "1754", "input": "def least_bribes(bribes):\\n mem = {}\\n def s(n1, n2):\\n if n1 >= n2: return 0\\n if (n1, n2) in mem: return mem[n1, n2]\\n r", "gt": "= min(bribes[i] + max(s(n1, i), s(i + 1, n2)) for i in range(n1, n2))\\n mem[n1, n2] = r\\n return r\\n return s(0, len(bribes))"}
{"id": "1755", "input": "def valid(a): \\n d = {}\\n day_length = len(a[0])\\n group_size = len(a[0][0])\\n golfers = {g for p in a[0] for g in p}\\n \\n for day in a:\\n if len(day) != day_length: return False\\n for group in day:\\n", "gt": "if len(group) != group_size: return False\\n for player in group:\\n if player not in golfers: return False\\n if player not in d:\\n d[player] = set(group)\\n else:\\n if len(d[player] & set(group)) > 1: return False\\n else: d[player].add(group)\\n return True"}
{"id": "1756", "input": "def splitlist(l):\\n half = sum(l) // 2\\n sums = [(0, [])]\\n for i, n in enumerate(l):\\n sums = sums + [(m + n, a + [i]) for m, a in sums if m + n <= half]\\n if", "gt": "max(s[0] for s in sums) == half:\\n break\\n sums.sort(key=lambda v: abs(v[0] - half))\\n indices = sums[0][1]\\n return [n for i, n in enumerate(l) if i in indices], [n for i, n in enumerate(l) if i not in indices]\\n"}
{"id": "1757", "input": "def handle(func, success, failure, *exceptions):\\n class manager:\\n def __enter__(self):\\n pass\\n def __exit__(self, type, value,", "gt": "traceback):\\n if isinstance(value, exceptions):\\n failure(func, value)\\n return True\\n return not value\\n with manager():\\n success(func, func())\\n"}
{"id": "1758", "input": "def knights_tour(start, size):\\n \\n MOVES = [(-2,1), (-2,-1), (-1,-2), (1,-2), (2,-1), (2,1), (1,2), (-1,2)]\\n \\n def genNeighs(pos): return ((pos[0]+dx, pos[1]+dy) for dx,dy in MOVES if (pos[0]+dx, pos[1]+dy) in Warnsdorf_DP)\\n \\n def travel(pos):\\n neighs = sorted( (Warnsdorf_DP[n], n) for n in genNeighs(pos) )\\n for nSubNeighs,neigh in neighs:\\n del Warnsdorf_DP[neigh]\\n path.append(neigh)\\n subNeighs = list(genNeighs(neigh))\\n for n insubNeighs: Warnsdorf_DP[n] -= 1\\n travel(neigh)\\n if not Warnsdorf_DP:\\n break\\n else:\\n for n in subNeighs: Warnsdorf_DP[n] += 1\\n Warnsdorf_DP[path.pop()] = nSubNeighs\\n \\n \\n path, Warnsdorf_DP = [start], {(x,y): 0 for x in range(size) for", "gt": "y in range(size) if (x,y) != start}"}
{"id": "1759", "input": "import itertools\\n\\ndef permutations(string):\\n return", "gt": "list(\"\".join(p) for p in set(itertools.permutations(string)))"}
{"id": "1760", "input": "from collections import defaultdict\\n\\n\\ndef setter(prep,k,v,supSetter):\\n if callable(v): \\n def wrap(*args):\\n f = prep.d[k][len(args)]\\n if isinstance(f,int): raise AttributeError()\\n return f(*args)\\n prep.d[k][v.__code__.co_argcount] = v\\n v = wrap\\n supSetter(k,v)\\n \\n \\nclass Prep(dict):\\n def __init__(self): self.d = defaultdict(lambda: defaultdict(int))\\n", "gt": "def __setitem__(self,k,v): setter(self, k, v, super().__setitem__)\\n\\n\\nclass Meta(type):\\n @classmethod\\n def __prepare__(cls,*args, **kwds): return Prep()\\n \\n def __new__(metacls, name, bases, prep, **kwargs):\\n prep['_Meta__DCT'] = prep\\n return super().__new__(metacls, name, bases, prep, **kwargs)\\n \\n def __setattr__(self,k,v): setter(self.__DCT, k, v, super().__setattr__)"}
{"id": "1761", "input": "from collections import defaultdict\\n\\ndef count(chessBoard):\\n # Initialize:\\n board = chessBoard.copy()\\n tally = defaultdict(int)\\n\\n # Compute Longest square ending in bottom right corner of each element and tally up:\\n for i, row in enumerate(board):\\n for j, element in enumerate(row):\\n # Edge detection:\\n if", "gt": "i == 0 or j == 0:\\n continue\\n\\n # Compute & Tally:\\n if element:\\n n = board[i][j] = min(board[i - 1][j], board[i][j - 1], board[i - 1][j - 1]) + 1\\n for x in range(n, 1, -1):\\n tally[x] += 1\\n\\n return tally"}
{"id": "1762", "input": "idx, n, seq = 2, 6, [1, 2, 4, 6]\\nwhile n < 2 ** 41:\\n idx += 1\\n seq.extend(range(n + idx, n", "gt": "+ (seq[idx] - seq[idx-1]) * idx + 1, idx))\\n n += (seq[idx] - seq[idx-1]) * idx\\n\\nfrom bisect import bisect\\ndef find(n): return bisect(seq, n)"}
{"id": "1763", "input": "def add_point(ori,dis,c):\\n lastPoint = c[-1]\\n if ori == \"N\":\\n c.append((lastPoint[0],lastPoint[1]+dis))\\n elif ori == \"S\":\\n c.append((lastPoint[0],lastPoint[1]-dis))\\n elif ori == \"E\":\\n c.append((lastPoint[0]+dis,lastPoint[1]))\\n else: \\n c.append((lastPoint[0]-dis,lastPoint[1]))\\n\\ndef check_corner(l_o):\\n ini = l_o[0]\\n fin = l_o[-1]\\n if ini==fin: return False\\n if ini == \"N\" or ini ==\"S\": ini = \"V\"\\n else: ini = \"H\"\\n if fin == \"N\" or fin ==\"S\": fin = \"V\"\\n else: fin = \"H\"\\n if ini==fin: return False\\n return True\\n\\ndef check_intersect(rectas):\\n u=rectas[-1]\\n ux=[u[0][0],u[1][0]]\\n ux.sort()\\n uy=[u[0][1],u[1][1]]\\n uy.sort()\\n\\n oriU = \"\"\\n if ux[0] == ux[1]: oriU = \"V\"\\n if uy[0] == uy[1]: oriU = \"H\"\\n \\n for r in rectas[:-2]:\\n rx=[r[0][0],r[1][0]]\\n rx.sort()\\n ry=[r[0][1],r[1][1]]\\n ry.sort()\\n\\n oriR = \"\"\\n if rx[0] == rx[1]: oriR = \"V\"\\n if ry[0] == ry[1]: oriR = \"H\"\\n\\n if oriU==oriR: \\n if oriU == \"V\" and ux[0]==rx[0]:\\n if ry[0] <= uy[0] <= ry[1] or ry[0] <= uy[1] <= ry[1] :\\n return True\\n if uy[0] < ry[0] and uy[1] > ry[1]:\\n return True \\n\\n if oriU ==\"H\" and uy[0]==ry[0]:\\n if rx[0] <= ux[0] <= rx[1]", "gt": "or rx[0] <= ux[1] <= rx[1] :\\n return True\\n if ux[0] < rx[0] and ux[1] > rx[1]:\\n return True \\n elif oriU ==\"V\":\\n if uy[0]<=ry[0]<=uy[1]:\\n if rx[0] < ux[0] and rx[1] > ux[0]:\\n return True\\n elif oriU ==\"H\":\\n if ux[0]<=rx[0]<=ux[1]:\\n if ry[0] < uy[0] and ry[1] > uy[0]:\\n return True \\n else:\\n return False\\n\\ndef calc_area(camino):\\n parN=camino[-1][0]*camino[0][1] - camino[-1][1] * camino[0][0]\\n for p in range(1,len(camino)):\\n par=camino[p-1][0]*camino[p][1] - camino[p-1][1]*camino[p][0]\\n parN+=par\\n return abs(parN)/2\\n\\ndef mouse_path(s):\\n camino=[(0,0)]\\n distancia = 0\\n listaOrientaciones = [\"E\"]\\n rectas = []\\n \\n for c in s:\\n orientacion = listaOrientaciones[-1]\\n if c.isdigit():\\n distancia=distancia*10 + int(c)\\n else:\\n add_point(orientacion,distancia,camino)\\n rectas.append((camino[-2],camino[-1]))\\n if check_intersect(rectas): return None\\n if c == \"L\":\\n if orientacion == \"N\": listaOrientaciones.append(\"O\")\\n elif orientacion == \"S\": listaOrientaciones.append(\"E\") \\n elif orientacion == \"E\": listaOrientaciones.append(\"N\")\\n else: listaOrientaciones.append(\"S\")\\n else:\\n if orientacion == \"N\": listaOrientaciones.append(\"E\")\\n elif orientacion == \"S\": listaOrientaciones.append(\"O\") \\n elif orientacion == \"E\": listaOrientaciones.append(\"S\")\\n else: listaOrientaciones.append(\"N\")\\n distancia = 0\\n add_point(orientacion,distancia,camino)\\n rectas.append((camino[-2],camino[-1]))\\n if check_intersect(rectas): return None\\n\\n if camino[-1] != (0,0): return None\\n\\n if not check_corner(listaOrientaciones): return None\\n\\n return calc_area(camino)"}
{"id": "1764", "input": "from functools import reduce\\nfrom operator import mul\\n\\ndef insane_inc_or_dec(x): \\n return (reduce(mul,[x + i + i * (i", "gt": "== 10) for i in range(1, 11)]) // 3628800 - 10 * x - 2) % 12345787"}
{"id": "1765", "input": "#THanks to easter eggs kata ;*\\n\\ndef height(n, m):\\n if n >= m:\\n return (2 ** (min(n, m)) - 1)\\n f = 1\\n res = 0\\n for i in range(n):\\n f = f * (m - i) // (i + 1)\\n res += f\\n return res\\n\\ndef solve(emulator):\\n", "gt": "m = emulator.drops\\n n = emulator.eggs\\n h = 0\\n tryh = 0\\n while n and m:\\n tryh = height(n - 1, m - 1) + 1\\n if emulator.drop(h + tryh):\\n n -= 1\\n else:\\n h += tryh\\n m -= 1\\n return(h + 1)\\n # continue here\\n"}
{"id": "1766", "input": "def partitions(n):\\n c = [[1]]\\n for x in range(1, n + 1):\\n c.append([0])\\n for m in", "gt": "range(1, x + 1):\\n c[x].append(c[x][m - 1] + c[x - m][min(m, x - m)])\\n return c[n][n]"}
{"id": "1767", "input": "def b(n):\\n if not n: return '0'\\n r = []\\n while n:\\n r.append(n % 2)\\n n = (n - n % 2) / -2\\n return ''.join(str(c) for c in r[::-1])\\n\\ndef d(n):\\n r = 0\\n for c in n: r", "gt": "= -2 * r + int(c)\\n return r\\n\\ndef skrzat(base, n):\\n if base == 'b': return 'From binary: %s is %d' % (n, d(n))\\n if base == 'd': return 'From decimal: %d is %s' % (n, b(n))\\n raise ValueError('unknown base')"}
{"id": "1768", "input": "from collections import Counter\\n\\ndef solution(tiles):\\n return \"\".join(\\n tile for tile in \"123456789\"\\n if tiles.count(tile) < 4\\n and list(meld(meld(meld(meld(pair(Counter(map(int, tiles+tile))))))))\\n )\\n\\ndef pair(c):\\n yield from (c - Counter([t,t]) for t in c", "gt": "if c[t] > 1)\\n\\ndef meld(C):\\n yield from (\\n c - m for c in C for t in [min(c.keys())]\\n for m in (Counter((t,t+d,t+d+d)) for d in (0,1))\\n if (c&m) == m)"}
{"id": "1769", "input": "from itertools import chain\\n\\ndef fit_bag(H, W, items):\\n\\n def deploy(item):\\n X,Y = len(item), len(item[0])\\n v = (set(chain.from_iterable(item))-{0}).pop()\\n deltas = [(x,y) for x,r in enumerate(item) for y,n in enumerate(r) if n]\\n return (len(deltas), X*Y, max(X,Y), min(X,Y), X,Y,deltas,v)\\n \\n def dfs(i=0):\\n if i==len(items): yield bag\\n _,_,_,_,X,Y,deltas,v = items[i]\\n for", "gt": "x in range(H-X+1):\\n for y in range(W-Y+1):\\n if all(not bag[x+dx][y+dy] for dx,dy in deltas):\\n for dx,dy in deltas: bag[x+dx][y+dy] = v\\n yield from dfs(i+1)\\n for dx,dy in deltas: bag[x+dx][y+dy] = 0\\n \\n bag = [ [0]*W for _ in range(H) ]\\n items = sorted(map(deploy,items), reverse=True)\\n return next(dfs())"}
{"id": "1770", "input": "from collections import defaultdict\\ndef shortestPath(gra, srs, des):\\n Q, paths, d = [[0, srs]], [], defaultdict(list)\\n while Q: \\n vrt = Q.pop(0)\\n if vrt[-1] == des: \\n paths.append(vrt)\\n continue\\n for v, c in gra[vrt[-1]].items():\\n if v not in vrt:\\n Q.append([vrt[0]+c]", "gt": "+ vrt[1:] + [v])\\n\\n for i in paths: d[i[0]].append(i[1:]) \\n \\n ml, f = len(min(d[min(d)], key = len)), []\\n\\n for i in d[min(d)]:\\n if len(i) == ml:\\n f.append(i)\\n return [sorted(i) for i in f] if len(f) > 2 else f"}
{"id": "1771", "input": "def path_finder(maze):\\n lst = maze.split('\\n')\\n X, Y = len(lst)-1, len(lst[0])-1\\n seen = {(x,y) for x,row in enumerate(lst) for y,c in enumerate(row) if c=='W'} | {(0,0)}\\n end, bag, turn = (X,Y), {(0,0)}, 0\\n \\n while bag and end not in bag:\\n bag ={ (a,b) for", "gt": "a,b in"}
{"id": "1772", "input": "from heapq import heappush, heappop\\n\\ndef closure_gen(*s):\\n q = sorted(s)\\n m = set(s)\\n while q:\\n curr = heappop(q)\\n yield", "gt": "curr\\n for i in s:\\n t = curr * i\\n if t not in m:\\n heappush(q, t)\\n m.add(t)"}
{"id": "1773", "input": "from itertools import cycle\\n\\nclass VigenereCipher (object):\\n def __init__(self, key, alphabet):\\n self.key = key.decode('utf-8')\\n self.alphabet = alphabet.decode('utf-8')\\n \\n def cipher(self, mode, str):\\n return ''.join(self.alphabet[(self.alphabet.index(m) +\\n mode * self.alphabet.index(k))", "gt": "% len(self.alphabet)]\\n if m in self.alphabet else m for m, k in zip(str.decode('utf-8'),\\n cycle(self.key))).encode('utf-8')\\n \\n def encode(self, str): return self.cipher(1, str)\\n def decode(self, str): return self.cipher(-1, str)\\n \\n"}
{"id": "1774", "input": "def validSolution(board):\\n boxes = validate_boxes(board)\\n cols = validate_cols(board)\\n rows = validate_rows(board)\\n return boxes and cols and rows\\n\\ndef validate_boxes(board):\\n for i in range(0, 9, 3):\\n for j in range(0, 9, 3):\\n nums = board[i][j:j+3] + board[i+1][j:j+3] + board[i+2][j:j+3]\\n if not check_one_to_nine(nums):\\n", "gt": "return False\\n return True\\n\\ndef validate_cols(board):\\n transposed = zip(*board)\\n for row in transposed:\\n if not check_one_to_nine(row):\\n return False\\n return True\\n \\ndef validate_rows(board):\\n for row in board:\\n if not check_one_to_nine(row):\\n return False\\n return True\\n \\n\\ndef check_one_to_nine(lst):\\n check = range(1,10)\\n return sorted(lst) == check"}
{"id": "1775", "input": "class Funnel(object):\\n \\n SIZE = 5\\n \\n def __init__(self):\\n self.fun = [ [None] * (x+1) for x in range(self.SIZE) ]\\n \\n \\n def fill(self, *args):\\n genBlanks = ((x,y) for x,r in enumerate(self.fun) for y,v in enumerate(r) if v is None)\\n \\n for v,(x,y) in zip(args, genBlanks): \\n self.fun[x][y] = v\\n \\n \\n def drip(self):\\n y,cnt = 0, sum(v is not None for row in self.fun for v in row)\\n drop = self.fun[0][0]\\n \\n for x in range(self.SIZE-1):\\n left", "gt": "= cnt - sum( self.fun[xx][y+xx-x] is not None for xx in range(x,self.SIZE))\\n right = cnt - sum( self.fun[xx][y] is not None for xx in range(x,self.SIZE))\\n \\n ySwp, cnt = (y,left) if left >= right else (y+1,right)\\n self.fun[x][y] = self.fun[x+1][ySwp]\\n y = ySwp\\n if not cnt: break\\n \\n self.fun[x+1][y] = None\\n return drop\\n \\n \\n def __str__(self):\\n return '\\n'.join( f'"}
{"id": "1776", "input": "from itertools import permutations, chain\\n\\ndef solve_puzzle (clues):\\n size = 4\\n for poss in permutations(permutations(list(range(1, size+1)), size), size):\\n for i in range(size):\\n if len(set(row[i] for row in poss)) < size:\\n break\\n else:\\n cols_top = [[row[i] for row in poss] for i in range(size)]\\n rows_right = [list(reversed(row)) for row in", "gt": "poss]\\n cols_btm = [[row[i] for row in reversed(poss)] for i in reversed(list(range(size)))]\\n rows_left = list(reversed(poss))\\n for i, row in enumerate(chain(cols_top, rows_right, cols_btm, rows_left)):\\n if not clues[i]:\\n continue\\n visible = 0\\n for j, v in enumerate(row):\\n visible += v >= max(row[:j+1])\\n if visible != clues[i]:\\n break\\n else:\\n return poss\\n"}
{"id": "1777", "input": "def roll_dice (rolls, sides, threshold):\\n dp = [0] * (rolls * sides + 1)\\n for i in range(1, sides+1):\\n dp[i] =", "gt": "1\\n\\n for _ in range(rolls-1):\\n for x in range((rolls * sides), 0, -1):\\n dp[x] = sum(dp[max(1, x-sides):x])\\n\\n return sum(dp[threshold:]) / sum(dp[1:])"}
{"id": "1778", "input": "'''\\nChallenge Fun #20: Edge Detection\\nhttps://www.codewars.com/kata/58bfa40c43fadb4edb0000b5/train/python\\n\\nFor a rectangular image given in run-length encoding (RLE) as\\ndescribed below, return a RLE of the image processed by replacing\\neach pixel by the maximum absolute value of the difference between\\nit and each neighboring pixel (a simple form of edge detection).\\n\\nFor a RLE encoding string \"7 15 4 100 15 25 2 ...\",\\n 7 ----> image width\\n 15 4 ----> a pair(color value + pixel count)\\n 100 15 ----> a pair(color value + pixel count)\\n 25 2 ----> a pair(color value + pixel count)\\n ... ...\\nwhere the image width is > 0 and the sum of all the pixel counts\\nis a multiple of the width.\\n\\n--------------------\\nDesign of solution\\n\\nRead the rle-encoded values into a buffer of rows of the given width,\\nwith an important optimization trick. In the case of long runs of the\\nsame value, where three or more rows would be filled with identical\\ndata, store just three rows of data, and remember (using another data\\nstructure) which is the middle of the three rows, and how many copies\\nof it (the \"row count\") were in the original image. For example,\\nsuppose the image width is 10, and the image has a run of 73 copies\\nof the value 7, and the run starts with the last two values in row 34.\\nThe buffer would look like this:\\n\\n ...\\n 34 [ some previous data ... 7, 7 ]\\n 35 [ 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 ]\\n 36 [ 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 ]\\n 37 [ 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 ]\\n 38 [ 7, ... start of new data ... ]\\n ...\\n\\nand elsewhere a note is made that row 36 has a row count of 5.\\n\\nWith long runs arranged this way, the edge-detection transformation\\ncan be run on the buffer without having to worry about row counts.\\nRow counts are used later, when encoding the transformed values back\\ninto a run-length encoding.\\n'''\\nimport itertools\\n\\ndef edge_detection(image):\\n data = [int(datum) for datum in image.split(' ')]\\n width = data.pop(0)\\n\\n (inbuf, rowcounts) = fill_buffer(width, data)\\n outbuf = detect_edges(inbuf)\\n\\n outdata_list = encode(outbuf, rowcounts)\\n outdata = [str(datum) for datum in outdata_list]\\n return str(width) + ' ' + ' '.join(outdata)\\n\\n\\ndef fill_buffer(width, data):\\n buf = []\\n rowcounts = dict() # row: rowcount\\n\\n row, row_ndx = [], 0\\n while data:\\n val, runlen = data.pop(0), data.pop(0)\\n if row == [] and runlen > 3 * width:\\n buf += [[val] * width] * 3\\n # There's a top, middle, and bottom row; middle has a row count\\n rowcounts[row_ndx + 1] = (runlen // width) - 2\\n row_ndx += 3\\n # Values from run that didn't fit in the above rows.\\n row = [val] * (runlen % width)\\n continue\\n\\n take = min(runlen, width - len(row))\\n runlen -= take\\n row += [val] * take\\n if len(row) < width:\\n continue\\n\\n # Here, row is full, with mixed values, and there may be some\\n # (many!) values left over from the last (val, runlen) pair that\\n # was read from data.\\n buf.append(row)\\n row_ndx += 1\\n row = []\\n\\n if row == [] and runlen > 3 * width:\\n buf += [[val] * width] * 3\\n # There's a top, middle, and bottom row; middle has a row count\\n rowcounts[row_ndx + 1] = (runlen // width) - 2\\n row_ndx += 3\\n # Values from run that didn't fit in the above rows.\\n row = [val] * (runlen % width)\\n continue\\n\\n while runlen > 0:\\n take = min(runlen, width - len(row))\\n runlen -= take\\n row += [val] * take\\n if len(row) == width:\\n buf.append(row)\\n row_ndx += 1\\n row = []\\n\\n return buf,rowcounts\\n\\n\\ndef pairs_from(iterable, fillvalue=None):\\n '''\\n Yields iterable's elements in pairs. If iterable is exhausted after\\n an odd number of elements, completes the last pair with fillvalue.\\n '''\\n # This is the 'grouper' recipe from the itertools documentation.\\n args = [iter(iterable)] * 2\\n return itertools.zip_longest(*args, fillvalue=fillvalue)\\n\\n\\ndef detect_edges(inbuf):\\n length = len(inbuf)\\n width = len(inbuf[0])\\n\\n outbuf = [([-1] * width).copy() for _ in range(length)]\\n\\n # Single pixel\\n if 1 == width == length:\\n return [[0]]\\n\\n # Single row\\n if 1 == length:\\n outbuf[0][0] = abs(inbuf[0][0] - inbuf[0][1])\\n outbuf[0][width - 1] = abs(inbuf[0][width - 2] - inbuf[0][width - 1])\\n for col in range(1, width - 1):\\n val = inbuf[0][col]\\n outbuf[0][col] = max(abs(val - inbuf[0][col - 1]),\\n abs(val - inbuf[0][col + 1]))\\n return outbuf\\n\\n # Single column\\n if 1 == width:\\n outbuf[0][0] = abs(inbuf[0][0] - inbuf[1][0])\\n outbuf[length - 1][0] = abs(inbuf[length - 2][0] -\\n inbuf[length - 1][0])\\n for row in range(1, length - 1):\\n val - inbuf[row][0]\\n outbuf[row][0] = max(abs(val - inbuf[row - 1][0]),\\n abs(val - inbuf[row + 1][0]))\\n return outbuf\\n\\n # At least a 2 x 2 image. Unroll what we'd rather do in loops and\\n # list comprehensions.\\n\\n BOT = length - 1 # convenience; last data row\\n RT =", "gt": "width - 1 # convenience;"}
{"id": "1779", "input": "from collections import Counter\\n\\ndef get_key_length(cipher_text, max_key_length):\\n avg_IC_by_keylen = {}\\n \\n for key_len in range(1, max_key_length+1):\\n ICs = []\\n \\n for i in range(key_len):\\n sub_str = cipher_text[i::key_len]\\n freq", "gt": "= Counter(sub_str)\\n IC = sum(v * (v-1) for k, v in freq.items()) / (len(sub_str) * (len(sub_str)-1) )\\n ICs.append(IC)\\n \\n avg_IC_by_keylen[key_len] = sum(ICs) / key_len\\n \\n return max(avg_IC_by_keylen, key=avg_IC_by_keylen.get)"}
{"id": "1780", "input": "def balanced_parens(n): return list(dfs([],0,0,n))\\n\\ndef dfs(s, open, close, maxP):\\n if close==maxP:\\n yield \"\".join(s)\\n return\\n \\n if open", "gt": "> close:\\n s.append(')')\\n yield from dfs(s,open,close+1,maxP)\\n s.pop()\\n \\n if open < maxP:\\n s.append('(')\\n yield from dfs(s,open+1,close,maxP)\\n s.pop()"}
{"id": "1781", "input": "def prod(n):\\n ret = [{1.}]\\n for i in range(1, n+1):\\n ret.append({(i - x) * j for x, s in enumerate(ret) for j in s})\\n return", "gt": "ret[-1]\\n\\ndef part(n):\\n p = sorted(prod(n))\\n return \"Range: %d Average: %.2f Median: %.2f\" % \\\\n (p[-1] - p[0], sum(p) / len(p), (p[len(p)//2] + p[~len(p)//2]) / 2)"}
{"id": "1782", "input": "def who_wins_beggar_thy_neighbour(*hands, special_cards='JQKA'):\\n hands = [list(reversed(hand)) for hand in hands]\\n player, deck_length = 0, sum(map(len, hands))\\n deal_start, deal_value, common = None, 0, []\\n\\n while len(hands[player]) < deck_length:\\n # Deal ends and current player wins common pile\\n if deal_start == player:\\n hands[player] = common[::-1] + hands[player]\\n deal_start, deal_value,", "gt": "common = None, 0, []\\n continue\\n # Cards are drawn and deal begins if penalty occurs\\n for _ in range(min(deal_value or 1, len(hands[player]))):\\n card = hands[player].pop()\\n common.append(card)\\n if card[0] in special_cards:\\n deal_start, deal_value = player, special_cards.index(card[0]) + 1\\n break\\n\\n player = (player + 1) % len(hands)\\n\\n return player"}
{"id": "1783", "input": "import re \\n\\nclass Simplexer(object):\\n\\n ORDERED_TOKENS = [ {\"type\": \"integer\", \"reg\": r'\\d+'},\\n {\"type\": \"boolean\", \"reg\": r'true|false'},\\n {\"type\": \"string\", \"reg\": r'\\\".*\\\"'},\\n {\"type\": \"operator\", \"reg\": r'[-+*/%\\)\\(=]'},\\n {\"type\": \"keyword\", \"reg\": r'if|else|for|while|return|func|break'},\\n {\"type\": \"whitespace\", \"reg\": r'\\s+'},\\n {\"type\": \"identifier\", \"reg\": r'[$_a-zA-Z][$\\w]*'}]\\n \\n PATTERN = re.compile(r'|'.join(", "gt": "\"(?P<"}
{"id": "1784", "input": "from functools import total_ordering\\n\\n@total_ordering\\nclass PokerHand(object):\\n CARDS = \"AKQJT987654321\"\\n RANKS = {card: idx for idx, card in enumerate(CARDS)}\\n \\n def score(self, hand): \\n values, suits = zip(*hand.split())\\n idxs, ordered = zip(*sorted((self.RANKS[card], card) for card in values))\\n is_straight = ''.join(ordered) in self.CARDS\\n is_flush = len(set(suits)) == 1\\n return", "gt": "(-2 * sum(values.count(card) for card in values)\\n - 13 * is_straight - 15 * is_flush, idxs)\\n \\n def __init__(self, hand):\\n self.hand = hand\\n self.score = min(self.score(hand), self.score(hand.replace('A', '1')))\\n \\n def __repr__(self): return self.hand\\n def __eq__(self, other): return self.score == other.score\\n def __lt__(self, other): return self.score < other.score"}
{"id": "1785", "input": "class CurryPartial:\\n def __init__(self, func, *args):\\n self.func = func\\n self.args = args\\n \\n def __call__(self, *args):\\n return CurryPartial(self.func, *(self.args + args))\\n \\n def __eq__(self, other):\\n", "gt": "try:\\n return self.func(*self.args) == other\\n except TypeError:\\n return CurryPartial(self.func, *self.args[:-1]) == other\\n\\ndef curry_partial(f,*initial_args):\\n \"Curries and partially applies the initial arguments to the function\"\\n return CurryPartial(f, *initial_args)"}
{"id": "1786", "input": "def dithering(width, height, x=0, y=0, c=1):\\n if width <= c and height <= c:\\n if x < width and y < height: yield", "gt": "x, y\\n return\\n for u, v in (0,0), (c,c), (c,0), (0,c):\\n for p, q in dithering(width, height, x+u, y+v, c+c): yield p, q"}
{"id": "1787", "input": "import numpy as np\\n\\ndef slope(p1, p2):\\n dx, dy = vectorize(p1, p2)\\n return dy/dx if dx else float(\"inf\")\\n\\ndef vectorize(p1, p2): return [b-a for a,b in zip(p1, p2)]\\ndef getArea (p1, p2, p3): return np.cross(vectorize(p1, p2), vectorize(p1, p3)) / 2\\ndef isConcave(p1, pivot, p2): return getArea(pivot, p1, p2) >= 0\\n\\ndef convex_hull_area(points):\\n if len(points) < 3: return 0\\n \\n Z = min(points) # Leftmost point in the graph (lowest if several ones at the same x)\\n q = sorted( (pt for pt in points if pt != Z),\\n key = lambda pt: (-slope(pt, Z),", "gt": "-np.linalg.norm(vectorize(Z, pt)))) # sorted points accordingly to the slope of the line formed by \"pt\" and \"Z\" (in reversed order)\\n \\n hull = [Z, q.pop()] # Construct the convex hull (Graham Scan)\\n while q:\\n pt = q.pop()\\n while len(hull) > 1 and isConcave(hull[-2], hull[-1], pt):\\n hull.pop()\\n hull.append(pt)\\n \\n area = sum( getArea(Z, hull[i], hull[i+1]) for i in range(1, len(hull)-1) ) # Calculate area of the hull by adding the area of all the triangles formed by 2 consecutive points in the hull and having Z as summit\\n return round(area, 2)"}
{"id": "1788", "input": "from functools import reduce\\n\\nclass Datamining:\\n\\n def __init__(self, train_set):\\n self.p = train_set[:5]\\n \\n def lagrange_interp(self, x):\\n return sum(reduce(lambda p,n:", "gt": "p*n, [(x-xi)/(xj-xi) for (i,(xi,yi)) in enumerate(self.p) if j!=i], yj) for (j,(xj,yj)) in enumerate(self.p))\\n \\n def predict(self, x):\\n return self.lagrange_interp(x)"}
{"id": "1789", "input": "from operator import xor\\n\\ndef choose_move(game_state):\\n \"\"\"Chooses a move to play given a game state\"\"\"\\n x = reduce(xor, game_state)\\n", "gt": "for i, amt in enumerate(game_state):\\n if amt ^ x < amt:\\n return (i, amt - (amt ^ x))"}
{"id": "1790", "input": "from re import sub\\n\\nignoreList = [\"THE\", \"OF\", \"IN\", \"FROM\", \"BY\", \"WITH\", \"AND\", \"OR\", \"FOR\", \"TO\", \"AT\", \"A\"]\\n\\ndef generate_bc(url, separator):\\n # remove leading http(s):// and trailing /\\n url = sub(\"https?://\", \"\", url.strip(\"/\"))\\n \\n # skip index files\\n url = sub(\"/index\\..+$\", \"\", url)\\n \\n # split url for processing\\n url = url.split(\"/\")\\n \\n # remove file extensions, anchors and parameters\\n url[-1] = sub(\"[\\.#\\?].*\", \"\", url[-1])\\n \\n # first element is always \"home\"\\n menu = [\"HOME\"]\\n # generate breadcrumb items\\n for item in url[1:]:\\n # replace", "gt": "dashes and set to uppercase\\n item = sub(\"-\", \" \", item.upper())\\n # create acronym if too long\\n if len(item) > 30:\\n item = \"\".join([w[0] for w in item.split() if w not in ignoreList])\\n menu.append(item)\\n \\n # generate paths\\n path = [\"/\"]\\n for i in range(len(url) - 1):\\n path.append(path[i] + url[i+1] + \"/\")\\n \\n # generate html code\\n html = []\\n for i in range(len(url) - 1):\\n html.append(\"<a href=\\\"\" + path[i] + \"\\\">\" + menu[i] +\"</a>\")\\n html.append(\"<span class=\\\"active\\\">\" + menu[-1] +\"</span>\")\\n \\n return separator.join(html)"}
{"id": "1791", "input": "from collections import deque\\nclass Graph():\\n\\n def __init__(self, vertices_num):\\n self.v = vertices_num\\n\\n def adjmat_2_graph(self, adjm):\\n d = {f'A{i}': [] for i in range(self.v)}\\n for i, j in enumerate(adjm):\\n for k, l in enumerate(j):\\n if l : d[f'A{i}'].append((f'A{k}', l))\\n return d\\n\\n def graph_2_mat(self, graph):\\n mat = [[0 for _ in range(self.v)] for _ in range(self.v)]\\n for i, j in graph.items():\\n for k, l in j:\\n mat[int(i[1])][int(k[1])] = l\\n return mat\\n\\n def graph_2_list(self, graph):\\n return [[i, j] fori, j in sorted(graph.items())]\\n\\n def list_2_graph(self, lst):\\n return {i: x for i,", "gt": "x in lst}"}
{"id": "1792", "input": "from collections import deque\\nfrom numpy import cross, dot\\n\\n\\nMOVES = ((1,0), (-1,0), (0,1), (0,-1))\\nDIRS = ( 'v', '^', '>', '<')\\n\\n\\ndef escape(maze):\\n \\n start = x,y = next( (x,y) for x,row in enumerate(maze) for y,c in enumerate(row) if c not in '# ' )\\n X, Y, dir = len(maze), len(maze[0]), MOVES[ DIRS.index(maze[x][y]) ]\\n q, seens = deque([(start, dir)]), {}\\n \\n if not x or x==X-1 or not y or y==Y-1: return [] # Already at the end, do nothing\\n \\n noPath = True\\n while q:\\n (x,y), dir = q.popleft()\\n for dx,dy in MOVES:\\n xx,yy = pos = (x+dx,y+dy)\\n \\n if 0 <= xx < X and 0 <= yy < Y and maze[xx][yy]==' ' and pos not in seens:\\n q.append( (pos, (dx,dy)) )\\n seens[pos] = ((x,y), dir, (dx,dy))", "gt": "# data: (origin position, direction before origin, direction after origin)\\n if not xx or xx==X-1 or not yy or yy==Y-1: # Escaped!\\n q, noPath = [], False # reset the queue to stop it, \"from the for loop\"\\n break\\n \\n if noPath: return [] # No path, no chocolate...\\n \\n path = []\\n while pos != start:\\n pos, dir, nextDir = seens[pos]\\n scal = dot(dir, nextDir) # scalar prouct > 0 <=> go ahead, otherwise, turn back\\n prod = cross(dir, nextDir) # cross product > 0 <=> turn left, otherwise, turn right\\n if scal: path.append('FB' if scal < 0 else 'F') # dot != 0 => both directions are colinear\\n else: path.append('FL' if prod > 0 else 'FR') # orthogonal directions, take a turn\\n \\n return list(''.join(path)[::-1])"}
{"id": "1793", "input": "def three_by_n(n):\\n A = [1, 2] + [0]*(n-1)\\n B = [0, 1] + [0]*(n-1)\\n C = [1, 0] + [0]*(n-1)\\n D = [0, 1] + [0]*(n-1)\\n for i in range(2, n+1):\\n A[i]", "gt": "= A[i-2] + 2*B[i-1] + 2*C[i-1] + 2*D[i] + 2*D[i-2]\\n B[i] = A[i-1] + B[i-2] + C[i-2] + D[i-1]\\n C[i] = C[i-2] + 2*D[i-1]\\n D[i] = C[i-1] + D[i-2]\\n return A[n] % 12345787"}
{"id": "1794", "input": "from math import factorial as fac\\ncards = [\\n \"AC\", \"2C\", \"3C\", \"4C\", \"5C\", \"6C\", \"7C\", \"8C\", \"9C\", \"TC\", \"JC\", \"QC\", \"KC\",\\n \"AD\", \"2D\", \"3D\", \"4D\", \"5D\", \"6D\", \"7D\", \"8D\", \"9D\", \"TD\", \"JD\", \"QD\", \"KD\",\\n \"AH\", \"2H\", \"3H\", \"4H\", \"5H\", \"6H\", \"7H\", \"8H\", \"9H\", \"TH\", \"JH\", \"QH\", \"KH\",\\n \"AS\", \"2S\", \"3S\", \"4S\", \"5S\", \"6S\", \"7S\", \"8S\", \"9S\", \"TS\", \"JS\", \"QS\", \"KS\"\\n]\\nchars = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ'\\nchars_len = len(chars)\\nfacs = [1]\\nfor x in range(1, 53, 1): facs.append(facs[-1] * x)\\n\\nclass PlayingCards:\\n # Takes a String containing a message, and returns an array of Strings representing\\n # a deck of playing cards ordered to hide the message, or None if the message is invalid.\\n def encode(self, message):\\n mlen = len(message)\\n rem = 0\\n for i in range(mlen):\\n if message[i] not in chars: return None\\n rem = rem + chars_len ** (mlen - i - 1) * chars.index(message[i])\\n if", "gt": "rem >= facs[-1]: return None\\n for i in range(1, 53):\\n if rem < facs[i]: break\\n remaining_cards = cards[53 - i - 1:]\\n output_cards = cards[:53 - i - 1]\\n for j in range(i - 1, -1, -1):\\n idx = rem // facs[j]\\n output_cards.append(remaining_cards.pop(idx))\\n rem = rem % facs[j]\\n return output_cards\\n\\n # Takes an array of Strings representing a deck of playing cards, and returns\\n # the message that is hidden inside, or None if the deck is invalid.\\n def decode(self, deck):\\n if len(deck) != 52: return None\\n remaining_cards = cards.copy()\\n rem = 0\\n for i in range(len(deck)):\\n if deck[i] not in remaining_cards: return None\\n idx = remaining_cards.index(deck[i])\\n rem = rem + facs[51 - i] * idx\\n remaining_cards.pop(idx)\\n output_message = []\\n if rem == 0 : return ''\\n while rem > 0:\\n output_message.insert(0, chars[rem % chars_len])\\n rem = rem // chars_len\\n return ''.join(output_message)"}
{"id": "1795", "input": "def is_prime(n):\\n return n == 2 or n % 2 != 0 and all(n % k != 0 for k in range(3, root(n) + 1, 2))\\n\\ndef root(p):\\n return int(p ** 0.5)\\n\\ndef statement1(s):\\n return not(s % 2 == 0 or is_prime(s - 2))\\n\\ndef statement2(p):\\n return sum(statement1(i + p /", "gt": "i) for i in range(2, root(p) + 1) if p % i == 0) == 1\\n\\ndef statement3(s):\\n return sum(statement2(i * (s - i)) for i in range(2, s / 2 + 1)) == 1\\n\\ndef is_solution(a, b):\\n return statement1(a + b) and statement2(a * b) and statement3(a + b)\\n"}
{"id": "1796", "input": "def nQueen(n):\\n if n==2 or n==3: return []\\n r, odds, evens = n%6, list(range(1,n,2)),", "gt": "list(range(0,n,2))\\n if r==2:\\n evens[:2] = evens[:2][::-1]\\n evens.append(evens.pop(2))\\n if r==3:\\n odds.append(odds.pop(0))\\n evens.extend(evens[:2])\\n del evens[:2]\\n return odds+evens"}
{"id": "1797", "input": "def to_postfix (infix):\\n prec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3, '(': 0}\\n postfix = []\\n stack = []\\n for ch in infix:\\n if ch in '0123456789':\\n postfix.append(ch)\\n", "gt": "elif ch in '(':\\n stack.append(ch)\\n elif ch in ')':\\n while stack and stack[-1] != '(':\\n postfix.append(stack.pop())\\n stack.pop()\\n else:\\n while stack and prec[stack[-1]] >= prec[ch]:\\n postfix.append(stack.pop())\\n stack.append(ch)\\n \\n while stack:\\n postfix.append(stack.pop())\\n return ''.join(postfix)"}
{"id": "1798", "input": "def hamming(n):\\n bases = [2, 3, 5]\\n expos = [0, 0, 0]\\n hamms = [1]\\n for _ in range(1, n):\\n next_hamms =", "gt": "[bases[i] * hamms[expos[i]] for i in range(3)]\\n next_hamm = min(next_hamms)\\n hamms.append(next_hamm)\\n for i in range(3):\\n expos[i] += int(next_hamms[i] == next_hamm)\\n return hamms[-1]"}
{"id": "1799", "input": "def get(cells, i, j):\\n return cells[i][j] if i > -1 and j > -1 and i < len(cells) and j < len(cells[0]) else 0\\n\\ndef num_neighbors(cells, i, j):\\n return (get(cells, i, j+1) + get(cells, i, j-1) + get(cells, i+1, j) +\\n get(cells, i-1, j) + get(cells, i-1, j-1) + get(cells, i-1, j+1) +\\n get(cells, i+1, j-1) + get(cells, i+1, j+1))\\n\\ndef next_cell(cell, i, j):\\n n = num_neighbors(cell, i, j)\\n return int(0 if n < 2 or n > 3 else 1 if cell[i][j] else n == 3)\\n\\ndef expand(cells):\\n", "gt": "row = [0]*(len(cells[0])+2)\\n return [row] + [[0] + r + [0] for r in cells] + [row]\\n\\ndef trim(cells):\\n while not any(cells[0]): del cells[0]\\n while not any(cells[-1]): del cells[-1]\\n while not any([row[0] for row in cells]): list(map(lambda x: x.pop(0), cells))\\n while not any([row[-1] for row in cells]): list(map(lambda x: x.pop(), cells))\\n\\ndef next_gen(cells):\\n cells = expand(cells)\\n cells = [[next_cell(cells, i, j) for j in range(len(cells[i]))] for i in range(len(cells))]\\n trim(cells)\\n return cells\\n\\ndef get_generation(cells, generations):\\n for i in range(generations):\\n cells = next_gen(cells)\\n if not cells:\\n return [[]]\\n return cells\\n"}
{"id": "1800", "input": "def queens(fixQ, S):\\n \\n def areClashing(i,x):\\n j,y = qs[i],qs[x]\\n return j==y or abs(i-x)==abs(j-y)\\n \\n def dfs(i=0):\\n if i==iQ: return dfs(i+1)\\n if i==len(qs): return 1\\n \\n for y in range(S):\\n qs[i]=y\\n if ( not any(areClashing(i,ii) for ii in range(i)) \\n and", "gt": "(iQ<i or not areClashing(i,iQ))\\n and dfs(i+1) ): return 1\\n \\n \\n iQ,yQ = ord(fixQ[0])-97, (int(fixQ[1]) or 10)-1\\n qs = [yQ if i==iQ else 0 for i in range(S)]\\n dfs()\\n return ','.join( f\""}
{"id": "1801", "input": "def find_prime_kPerm(n, k):\\n sieve = n // 2 * [True]\\n for i in range(3, int(n ** .5) + 1, 2):\\n if sieve[i // 2]:\\n sieve[i*i // 2 :: i] = ((n - i*i - 1) // (2*i) + 1)", "gt": "* [False]\\n cycles ="}
{"id": "1802", "input": "def interpreter(code, iterations, width, height):\\n code = \"\".join(c for c in code if c in \"[news]*\")\\n canvas = [ [0] * width for _ in range(height) ]\\n row = col = step = count = loop = 0\\n \\n while step < len(code) and count < iterations:\\n command = code[step]\\n \\n if loop:\\n if command == \"[\": loop += 1\\n elif command == \"]\": loop -= 1\\n \\n elif command == \"n\": row = (row - 1) % height\\n elif command == \"s\": row", "gt": "= (row + 1) % height\\n elif command == \"w\": col = (col - 1) % width\\n elif command == \"e\": col = (col + 1) % width\\n elif command == \"*\": canvas[row][col] ^= 1\\n elif command == \"[\" and canvas[row][col] == 0: loop += 1\\n elif command == \"]\" and canvas[row][col] != 0: loop -= 1\\n \\n step += 1 if not loop else loop // abs(loop)\\n count += 1 if not loop else 0\\n \\n return \"\\r\\n\".join(\"\".join(map(str, row)) for row in canvas)"}
{"id": "1803", "input": "from fractions import gcd\\n\\ndef min_price(nums):\\n nums.sort()\\n ns = [0] + [float('inf')] * (nums[0] - 1)\\n for c in nums[1:]:\\n d = gcd(nums[0], c)\\n for r in range(d):\\n n = min(ns[r::d], default=float('inf'))\\n if n < float('inf'):\\n for", "gt": "j in range(nums[0] // d):\\n n += c\\n p = n % nums[0]\\n ns[p] = n = min(n, ns[p])\\n max_ = max(ns) or 1\\n return max_ - nums[0] + 1 if max_ < float('inf') else -1"}
{"id": "1804", "input": "from collections import Counter\\nfrom itertools import combinations\\nfrom operator import mul\\nfrom functools import reduce\\n\\ndef largest_palindrom_from(n):\\n digits = sorted(str(n))\\n singles, pairs = [], []\\n \\n # group digits to pairs and singles\\n while digits:\\n digit = digits.pop()\\n if digits and digit == digits[-1]:\\n pairs.append(digit)\\n digits.pop()\\n else:\\n singles.append(digit)\\n \\n # avoid trailing zeros\\n if pairs and pairs[0] == '0':\\n pairs = []\\n \\n # return largest possible palindrom\\n if not", "gt": "singles:\\n singles = ['']\\n return int( ''.join(pairs) + singles[0] + ''.join(pairs[::-1]) )\\n\\n\\ndef numeric_palindrome(*args):\\n args = Counter(args)\\n candidates = set()\\n \\n # remove extra 0s and 1s\\n for n in [0, 1]:\\n if args[n] > 2:\\n args[n] = 2\\n \\n args = list(args.elements())\\n \\n # check all possible products\\n for n in range(2, len(args)+1):\\n for combo in combinations(args, n):\\n product = reduce(mul, combo)\\n candidates.add( largest_palindrom_from(product) )\\n \\n return max(candidates)"}
{"id": "1805", "input": "def recoverSecret(triplets):\\n r = list(set([i for l in triplets for i in l]))\\n for l in triplets:\\n fix(r, l[1], l[2])\\n", "gt": "fix(r, l[0], l[1])\\n return ''.join(r)\\n \\ndef fix(l, a, b):\\n \"\"\"let l.index(a) < l.index(b)\"\"\"\\n if l.index(a) > l.index(b):\\n l.remove(a)\\n l.insert(l.index(b), a)"}
{"id": "1806", "input": "class Solution:\\n def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n vis = [0 for i in range(len(friends))]\\n index = id\\n lis = set([id])\\n while level>0:\\n temp = []\\n for i in lis:\\n if vis[i] == 0:\\n #print(i)\\n temp += friends[i]\\n vis[i] = 1\\n lis = set(temp)\\n level -=", "gt": "1\\n dic = dict()\\n for i in lis:\\n if vis[i] == 0:\\n for j in watchedVideos[i]:\\n if j in dic:\\n dic[j]+=1\\n else:\\n dic[j] = 1\\n dic2 = dict()\\n for i in dic:\\n if dic[i] in dic2:\\n dic2[dic[i]].append(i)\\n else:\\n dic2[dic[i]] = [i]\\n lis = []\\n for i in sorted(dic2.keys()):\\n lis += sorted(dic2[i])\\n return lis\\n"}
{"id": "1807", "input": "\\n import re\\n \\n \\n class Solution:\\n def calc(self, a, b, op):\\n if op == '+':\\n for k, v in b.items():\\n a[k] = a.get(k, 0) + v\\n return a\\n elif op == '-':\\n for k, v in b.items():\\n a[k] = a.get(k, 0) - v\\n return a\\n elif op == '*':\\n t = {}\\n for k1, v1 in a.items():\\n for k2, v2 in b.items():\\n t[tuple(sorted(k1+k2))] = t.get(tuple(sorted(k1+k2)), 0) + v1 * v2\\n return t\\n \\n def basicCalculatorIV(self, expression, evalvars, evalints):\\n vars = {n:v for n,v in zip(evalvars, evalints)}\\n d = [] # operands\\n op = []\\n priority = {'(': 0, '+':1, '-': 1, '*': 2}\\n for t in re.findall(r'\\(|\\)|[a-z]+|[0-9]+|[\\+\\-\\*]',", "gt": "expression):\\n if t[0].isdigit():\\n d.append("}
{"id": "1808", "input": "class Solution:\\n arr = []\\n \\n def simplifiedFractions(self, n: int) -> List[str]:\\n ans = []\\n \\n if len(Solution.arr) < 2:\\n Solution.arr = [[],[]]\\n \\n if n >= len(Solution.arr):\\n for d in range(len(Solution.arr), n + 1):\\n denominator", "gt": "= \\\"/\\\" + str(d)\\n Solution.arr.append([])\\n \\n for num in range(1, d):\\n if gcd(num, d) == 1:\\n Solution.arr[-1].append(str(num) + denominator)\\n \\n \\n for i in range(2, n + 1):\\n ans += Solution.arr[i]\\n \\n return ans\\n \\n \\n"}
{"id": "1809", "input": "# Definition for an interval.\\n # class Interval:\\n # def __init__(self, s=0, e=0):\\n # self.start = s\\n # self.end = e\\n \\n class Solution:\\n def eraseOverlapIntervals(self, intervals):\\n \"\"\"\\n :type intervals: List[Interval]\\n :rtype: int\\n", "gt": "\"\"\"\\n intervals = sorted(intervals, key = lambda x: x.end)\\n current_end = float('-inf')\\n cnt = 0\\n for interval in intervals:\\n if interval.start >= current_end:\\n cnt += 1\\n current_end = interval.end\\n return len(intervals) - cnt\\n"}
{"id": "1810", "input": "class Solution:\\n def productExceptSelf(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: List[int]\\n \"\"\"\\n nums0 = nums.copy()\\n son = 1\\n if 0 in nums0:\\n nums0.remove(0)\\n for i in nums0:\\n son *=", "gt": "i\\n \\n \\n pro = 1\\n for i in nums:\\n pro *= i\\n result = []\\n for i in nums:\\n if i == 0:\\n result.append(son)\\n else:\\n result.append(pro//i)\\n return result"}
{"id": "1811", "input": "class Solution:\\n def getFolderNames(self, names: List[str]) -> List[str]:\\n used, hashmap = set(), defaultdict(int)\\n result = []\\n for name in names:\\n k = hashmap[name]\\n current = name\\n", "gt": "while current in used:\\n k += 1\\n current = '%s(%d)' % (name, k) # alternative to current = name+'('+str(k)+')'\\n hashmap[name] = k\\n result.append(current)\\n used.add(current)\\n return result\\n"}
{"id": "1812", "input": "class StockSpanner:\\n\\n def __init__(self):\\n self.s=[]\\n \\n\\n def next(self, price: int) -> int:\\n stk=self.s\\n curr_span=1\\n \\n while stk and stk[-1][0]<=price: #curr_price is > stack[-1][0]\\n prev_price,prev_span=stk.pop()\\n curr_span+=prev_span\\n", "gt": "stk.append((price,curr_span))\\n return curr_span\\n \\n \\n \\n \\n \\n \\n\\n\\n# Your StockSpanner object will be instantiated and called as such:\\n# obj = StockSpanner()\\n# param_1 = obj.next(price)\\n"}
{"id": "1813", "input": "from collections import defaultdict\\nfrom bisect import bisect_left, bisect_right\\n\\nclass MajorityChecker:\\n\\n def __init__(self, arr: List[int]):\\n self.num_idx_dict = defaultdict(list)\\n for idx, number in enumerate(arr):\\n self.num_idx_dict[number].append(idx)\\n self.candidates = sorted(self.num_idx_dict, key=lambda x: len(self.num_idx_dict[x]), reverse=True)\\n \\n def query(self, left: int,", "gt": "right: int, threshold: int) -> int:\\n for number in self.candidates:\\n if len(self.num_idx_dict[number]) < threshold:\\n return -1\\n left_idx = bisect_left(self.num_idx_dict[number], left)\\n right_idx = bisect_right(self.num_idx_dict[number], right)\\n \\n if right_idx - left_idx >= threshold:\\n return number\\n return -1\\n"}
{"id": "1814", "input": "class Solution:\\n def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:\\n n = len(books)\\n dp = [inf] * (n+1)\\n dp[0] = 0\\n ret = inf\\n for i in range(1, n+1):\\n mx", "gt": "= 0\\n cur = 0\\n for j in range(i, 0, -1):\\n cur += books[j-1][0]\\n if cur > shelf_width:\\n break\\n mx = max(mx, books[j-1][1])\\n dp[i] = min(dp[i], dp[j-1] + mx)\\n return dp[-1]\\n"}
{"id": "1815", "input": "class Solution:\\n def exclusiveTime(self, n, logs):\\n \"\"\"\\n :type n: int\\n :type logs: List[str]\\n :rtype: List[int]\\n \"\"\"\\n fn_stk = []\\n excl_time = [0] * n\\n prev = 0\\n if n < 1 or not logs:\\n return fn_stk\\n fn, action, ts = logs[0].split(':')\\n fn_stk.append(int(fn))\\n for log in logs[1:]:\\n", "gt": "fn, action, ts = log.split(':')\\n fn, ts = int(fn), int(ts)\\n if action == 'start':\\n if fn_stk: excl_time[fn_stk[len(fn_stk)-1]] += ts - prev\\n prev = ts\\n fn_stk.append(fn)\\n else:\\n fid = fn_stk.pop()\\n excl_time[fid] += (ts - prev + 1)\\n prev = ts + 1\\n return excl_time\\n \\n \\n \\n \\n"}
{"id": "1816", "input": "class Solution:\\n def shiftingLetters(self, S: str, shifts: List[int]) -> str:\\n # cumulative sum from back\\n shifts[-1] = shifts[-1] % 26\\n \\n if len(shifts) >= 2:\\n for i in range(len(shifts) - 2, -1, -1):\\n shifts[i] +=", "gt": "shifts[i + 1]\\n shifts[i] = shifts[i] % 26\\n \\n # shift characters\\n shifted_chars = []\\n \\n for i in range(len(S)):\\n shifted_ascii = (ord(S[i]) - 97 + shifts[i]) % 26 + 97\\n shifted_chars.append(chr(shifted_ascii))\\n \\n return \\\"\\\".join(shifted_chars)"}
{"id": "1817", "input": "class Solution:\\n def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\\n def should_alert(t):\\n if len(t) < 3:\\n return False\\n \\n for i in range(len(t) - 2):\\n if t[i + 2] <= t[i] + 100:\\n return True\\n return", "gt": "False\\n \\n time = collections.defaultdict(list)\\n alert = []\\n for name, t in zip(keyName, keyTime): \\n ti = int(t[:2] + t[3:])\\n time[name].append(ti)\\n \\n ret = []\\n for name in time:\\n time[name].sort()\\n if should_alert(time[name]):\\n ret.append(name)\\n \\n ret.sort()\\n return ret"}
{"id": "1818", "input": "from collections import Counter\\n \\n \\n class Solution:\\n def reorganizeString(self, S):\\n \"\"\"\\n :type S: str\\n :rtype: str\\n \"\"\"\\n if len(S) <= 1:\\n return S\\n \\n chars = [char", "gt": "for char, count in Counter(S).most_common() for _ in range(count)]\\n h = math.ceil(len(chars) / 2)\\n chars[::2], chars[1::2] = chars[:h], chars[h:]\\n if chars[0] == chars[1]:\\n return ''\\n else:\\n return ''.join(chars)\\n \\n"}
{"id": "1819", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nclass Solution:\\n def smallestFromLeaf(self, root: TreeNode) -> str:\\n nonlocal ls\\n ls=[]\\n di={0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e', 5: 'f', 6: 'g', 7: 'h', 8: 'i', 9: 'j', 10: 'k', 11: 'l', 12: 'm',", "gt": "13: 'n', 14: 'o', 15: 'p', 16: 'q', 17: 'r', 18: 's', 19: 't', 20: 'u', 21: 'v', 22: 'w', 23: 'x', 24: 'y', 25: 'z'}\\n def helper(root,s):\\n if(root==None):\\n return None\\n nonlocal ls\\n if(root.left==None and root.right==None):\\n ls.append(di[root.val]+s)\\n \\n helper(root.left,di[root.val]+s)\\n helper(root.right,di[root.val]+s)\\n \\n helper(root,\\\"\\\")\\n print(ls)\\n # tem=sorted(ls)[0]\\n tem=sorted(ls)\\n return tem[0]\\n # ans=\\\"\\\"\\n # for i in tem:\\n # ans+=str(di[int(i)])\\n # return ans\\n"}
{"id": "1820", "input": "class Solution:\\n \\n def __init__(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n \"\"\"\\n self.nums = nums\\n self.length = len(self.nums)\\n \\n \\n def pick(self, target):\\n \"\"\"\\n :type target: int\\n :rtype: int\\n \"\"\"\\n first_idx = None\\n idx_count = 0\\n for i in range(self.length):\\n if self.nums[i] == target:\\n if first_idx is None:\\n", "gt": "first_idx = i\\n idx_count += 1\\n elif first_idx is not None:\\n break\\n \\n if idx_count > 0: \\n return int(idx_count * random.random() // 1) + first_idx\\n \\n \\n # Your Solution object will be instantiated and called as such:\\n # obj = Solution(nums)\\n # param_1 = obj.pick(target)\\n"}
{"id": "1821", "input": "# Definition for a binary tree node.\\n # class TreeNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.left = None\\n # self.right = None\\n \\n class Solution:\\n def largestValues(self, root):\\n \"\"\"\\n :type root: TreeNode\\n :rtype:", "gt": "List[int]\\n \"\"\"\\n if not root:\\n return [] \\n q = [root]\\n r = []\\n while q:\\n r.append(max([i.val for i in q]))\\n q = [i for node in q for i in [node.left, node.right] if i]\\n return r"}
{"id": "1822", "input": "class Solution:\\n def sortArray(self, nums:", "gt": "List[int]) -> List[int]:\\n nums.sort()\\n return nums"}
{"id": "1823", "input": "class Solution:\\n def topKFrequent(self, words, k):\\n \"\"\"\\n :type words: List[str]\\n :type k: int\\n :rtype: List[str]\\n \"\"\"\\n from collections", "gt": "import Counter\\n count = Counter(words)\\n common = sorted(list(count.items()), key=lambda item: (-item[1], item[0]))[:k]\\n return [w for w, n in common]\\n"}
{"id": "1824", "input": "# Definition for singly-linked list.\\n # class ListNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.next = None\\n \\n class Solution:\\n def reorderList(self, head):\\n \"\"\"\\n :type head: ListNode\\n :rtype: void Do not return anything, modify head in-place instead.\\n \"\"\"\\n if not head:\\n return \\n fast, slow = head.next, head\\n while fast and", "gt": "fast.next:\\n fast = fast.next.next\\n slow = slow.next\\n \\n \\n p = slow.next\\n slow.next = None\\n node = None\\n while p:\\n nxt = p.next\\n p.next = node\\n node = p\\n p = nxt\\n \\n p = head\\n while node:\\n tmp = node.next\\n node.next = p.next\\n p.next = node\\n p = p.next.next\\n node = tmp\\n \\n"}
{"id": "1825", "input": "def bs(arr, val, key=lambda x:x):\\n l, r = 0, len(arr)-1\\n if key(arr[l])>val:\\n return l\\n if key(arr[r])<=val:\\n return r+1\\n while l+1<r:\\n m = (l+r)>>1\\n v = key(arr[m])\\n if v<=val:\\n l = m\\n else:\\n r = m\\n return r\\n \\n def bs_left(arr, val, key=lambda x:x):\\n l, r = 0, len(arr)-1\\n if key(arr[l])>=val:\\n return l\\n if key(arr[r])<val:\\n return r+1\\n while l+1<r:\\n m = (l+r)>>1\\n v = key(arr[m])\\n if v<val:\\n l = m\\n else:\\n r =", "gt": "m\\n return r\\n \\n \\n class Solution:\\n def findNumberOfLIS(self, nums):\\n if not nums: return 0\\n N = len(nums)\\n l, dp = 0, [[] for _ in range(N)]\\n for n in nums:\\n idx1 = bs_left(dp, n, lambda _:_[-1][0] if _ else sys.maxsize)\\n if idx1==l:\\n l += 1\\n if idx1==0:\\n dp[0].append([n, (dp[0][-1][1] if dp[0] else 0)+1])\\n else:\\n idx2 = bs(dp[idx1-1], -n, lambda _:-_[0])\\n dp[idx1].append([n, (dp[idx1][-1][1] if dp[idx1] else 0)+(dp[idx1-1][-1][1] if idx2==0 else (dp[idx1-1][-1][1]-dp[idx1-1][idx2-1][1]))])\\n return dp[l-1][-1][1]"}
{"id": "1826", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nclass Solution:\\n def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\\n \\n def lca(root=root):\\n if root:\\n n1, d1 =", "gt": "lca(root.left)\\n n2, d2 = lca(root.right)\\n if d1 == d2:\\n return (root, d1 + 1)\\n else:\\n return (n1, 1 + d1) if d1 > d2 else (n2, 1 + d2)\\n return (None, -1)\\n \\n return lca()[0]\\n \\n \\n \\n \\n"}
{"id": "1827", "input": "class Solution:\\n def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n \\\"\\\"\\\"\\n Brute force solution is to perform the sum for each position\\n (r, c). This would require K * K operations for each of m * n positions.\\n \\n Instead, assuming we compute sums left to right and top down, we can\\n use our previous solution to calculate the next one, subtracting the\\n sums that fell out of the window and adding the sums that are in.\\n \\n Pseudo code would be something like this:\\n \\n prevBlockSum = ...\\n for r in range(m):\\n for c in range(n):\\n if c - K > 0:\\n prevBlockSum -= sum()\\n \\\"\\\"\\\"\\n m = len(mat)\\n n = len(mat[0])\\n \\n cum =", "gt": "[]\\n prevSums = [0] * n\\n for r in range(m):\\n rowSum = 0\\n cumSums = []\\n for c in range(n):\\n rowSum += mat[r][c]\\n cumSums.append(prevSums[c] + rowSum)\\n cum.append(cumSums)\\n prevSums = cumSums\\n \\n out = []\\n for i in range(m):\\n blockSums = []\\n for j in range(n):\\n r = i + K if i + K < m else m - 1\\n c = j + K if j + K < n else n - 1\\n \\n blockSum = cum[r][c]\\n if i - K > 0:\\n blockSum -= cum[i-K-1][c]\\n if j - K > 0:\\n blockSum -= cum[r][j-K-1]\\n if i - K > 0 and j - K > 0:\\n blockSum += cum[i-K-1][j-K-1]\\n blockSums.append(blockSum)\\n out.append(blockSums)\\n \\n return out"}
{"id": "1828", "input": "import math\\n class Solution:\\n def smallestGoodBase(self, n):\\n n = int(n)\\n maxLength = int(math.log(n,2))\\n for m in range(maxLength, 1, -1):\\n k", "gt": "= int(n**m**-1)\\n if (k**(m+1) - 1)//(k - 1) == n:\\n return str(k)\\n return str(n-1)\\n \"\"\"\\n :type n: str\\n :rtype: str\\n \"\"\"\\n"}
{"id": "1829", "input": "class Solution:\\n def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\\n if len(barcodes) < 2:\\n return barcodes\\n \\n sorted_codes = sorted(barcodes)\\n halfway = len(barcodes)//2\\n ans = [0] * (halfway * 2)\\n ans[::2], ans[1::2] = sorted_codes[-halfway:], sorted_codes[:halfway]\\n \\n if", "gt": "len(barcodes) % 2 == 1:\\n prev = None\\n mid = sorted_codes[halfway]\\n for i in range(len(ans) - 1):\\n if ans[i] == mid:\\n i += 1\\n elif ans[i] != prev:\\n ans.insert(i, mid)\\n break\\n prev = ans[i]\\n return ans\\n"}
{"id": "1830", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nclass Solution:\\n def", "gt": "goodNodes(self, root: TreeNode) -> int:\\n self.cnt=0\\n def helper(root,maxm):\\n if not root:\\n return\\n if root.val>=maxm:\\n self.cnt+=1\\n maxm=root.val\\n if root.left:\\n helper(root.left,maxm)\\n if root.right:\\n helper(root.right,maxm)\\n maxm=root.val\\n helper(root,maxm)\\n return self.cnt"}
{"id": "1831", "input": "class Solution:\\n def avoidFlood(self, rains: List[int]) -> List[int]:\\n fullLake = {}\\n dry = {}\\n\\n for day, lake in enumerate(rains):\\n if lake not in fullLake:\\n if lake:\\n fullLake[lake]=day\\n else:\\n if lake:\\n dry[fullLake[lake]] = day\\n fullLake[lake]=day\\n heap=[]\\n for", "gt": "day, lake in enumerate(rains):\\n if heap and day >= heap[0][0]:\\n return []\\n if lake:\\n if day in dry:\\n heapq.heappush(heap, (dry[day], lake))\\n rains[day] = -1\\n else:\\n if heap:\\n rains[day] = heapq.heappop(heap)[1]\\n else:\\n rains[day] = 1\\n return rains"}
{"id": "1832", "input": "class Solution:\\n def movesToChessboard(self, board):\\n \"\"\"\\n :type board: List[List[int]]\\n :rtype: int\\n \"\"\"\\n rows = [1]\\n \\n for i in range(1, len(board)):\\n num = self.get_num(board[0], board[i])\\n if 0 <= num <= 1:\\n rows.append(num)\\n else:\\n return -1\\n \\n r1 = self.swap_count(rows)\\n if r1 != -1:\\n r2 = self.swap_count(board[0])\\n \\n if r1 == -1 or r2 == -1:\\n return -1\\n else:\\n return r1 + r2\\n \\n def get_num(self, r1, r2):\\n eq = True\\n op = True\\n \\n for i in range(len(r1)):\\n if r1[i] == r2[i]:\\n op = False\\n else:\\n", "gt": "eq = False\\n \\n if eq:\\n return 1\\n elif op:\\n return 0\\n else:\\n return -1\\n \\n def swap_count(self, bits):\\n n = len(bits)\\n \\n ones = sum(bits)\\n zeros = n - ones\\n \\n ones_in_even = 0\\n zeros_in_even = 0\\n for i in range(0, n, 2):\\n ones_in_even += bits[i]\\n zeros_in_even += (1 - bits[i])\\n \\n if abs(ones - zeros) > 1:\\n return -1\\n \\n # get rid of smaller ones\\n if n % 2 == 0:\\n return min(zeros_in_even, ones_in_even)\\n elif ones > zeros:\\n return zeros_in_even\\n else:\\n return ones_in_even"}
{"id": "1833", "input": "class Solution:\\n def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\\n conns = defaultdict(dict)\\n for i, j, n in edges:\\n conns[i][j] = n\\n conns[j][i] = n\\n\\n heap = [(0, 0)]\\n visited = set()\\n ans = 0\\n\\n while heap:\\n d, n = heapq.heappop(heap)\\n if", "gt": "n not in visited:\\n visited.add(n)\\n ans += 1\\n for m, inter in conns[n].items():\\n if m in visited:\\n ans += min(M-d, conns[n][m])\\n else:\\n if d+inter < M:\\n heapq.heappush(heap, (d+inter+1, m))\\n ans += inter\\n conns[m][n] = 0\\n else:\\n ans += M-d\\n conns[m][n] -= M-d\\n\\n return ans"}
{"id": "1834", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nclass Solution:\\n def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\\n # solution with DFS\\n def dfs(node,", "gt": "depth):\\n if not node:\\n return node, depth\\n left, l_depth = dfs(node.left, depth + 1)\\n right,r_depth = dfs(node.right,depth + 1)\\n if l_depth > r_depth:\\n return left, l_depth\\n if r_depth > l_depth:\\n return right,r_depth\\n return node,l_depth\\n return dfs(root,0)[0]"}
{"id": "1835", "input": "class Solution:\\n def matrixScore(self, A: List[List[int]]) -> int:\\n \\n def bitFlip(row):\\n \\n for i,r in enumerate(row):\\n row[i] = 1-r\\n \\n return row\\n \\n # [print(a) for a in A]\\n #For any rows with a leading 0 flip them\\n for i,row in enumerate(A):\\n if row[0] == 0:\\n A[i] = bitFlip(row)\\n # print('After Flip')\\n # [print(a) for a in A]\\n \\n #For each col past the 0th flip it if has more zeros than", "gt": "1s\\n for j in range(1,len(A[0])):\\n count = 0\\n for i in range(0,len(A)):\\n count += A[i][j]\\n if count <= len(A)//2:\\n for i in range(0,len(A)):\\n A[i][j] = 1-A[i][j]\\n \\n def score(row): #Returns the max score for this row\\n\\n# mul = 1\\n# res = 0\\n# for r in reversed(row):\\n# res += r*mul\\n# mul *= 2\\n \\n# return res\\n \\n return sum([ r*2**i for i,r in enumerate(reversed(row))])\\n \\n return sum([ score(row) for row in A])\\n \\n"}
{"id": "1836", "input": "class Solution:\\n def numsSameConsecDiff(self, n: int, k: int) -> List[int]:\\n # DFS (Depth-First Search)\\n # Time complexity: O(N x 2^N) = O(N x 9 x 2^(N-1))\\n # Space compleixty: O(2^N) = O(9 x 2^(N-1)) + O(N)\\n # if n == 1:\\n # return [i for i in range(10)]\\n\\n # ans = []\\n # def dfs(n, num):\\n # # base case\\n # if n == 0:\\n # return ans.append(num)\\n\\n # tail_digit = num % 10\\n # # using set() to avoid duplicates when K == 0\\n # next_digits = set([tail_digit + k, tail_digit - k])\\n\\n # for next_digit in next_digits:\\n # if 0 <= next_digit < 10:\\n # new_num = num * 10 + next_digit\\n # dfs(n - 1, new_num)\\n\\n", "gt": "# for num in range(1, 10):\\n # dfs(n - 1, num)\\n\\n # return list(ans)\\n\\n\\n # BFS (Breadth-First Search)\\n # Time complexity: O(N x 2^N)\\n # Space complexity: O(2^N)\\n if n == 1:\\n return [i for i in range(10)]\\n\\n # initialize the queue with candidates for the first level\\n queue = [digit for digit in range(1, 10)]\\n\\n for level in range(n - 1):\\n next_queue = []\\n for num in queue:\\n tail_digit = num % 10\\n # using set() to avoid duplicates when K == 0\\n next_digits = set([tail_digit + k, tail_digit - k])\\n\\n for next_digit in next_digits:\\n if 0 <= next_digit < 10:\\n new_num = num * 10 + next_digit\\n next_queue.append(new_num)\\n\\n # start the next level\\n queue = next_queue\\n\\n return queue\\n"}
{"id": "1837", "input": "import random\\n \\n class RandomizedSet:\\n \\n def __init__(self):\\n \"\"\"\\n Initialize your data structure here.\\n \"\"\"\\n self.dict = {}\\n self.list = []\\n \\n \\n def insert(self, val):\\n \"\"\"\\n Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n :type val: int\\n :rtype: bool\\n \"\"\"\\n if val in self.dict:\\n return False\\n self.dict[val] = len(self.list)\\n self.list.append(val)\\n return True\\n \\n \\n def remove(self, val):\\n \"\"\"\\n Removes a value from the set. Returns", "gt": "true if the set contained the specified element.\\n :type val: int\\n :rtype: bool\\n \"\"\"\\n if val not in self.dict:\\n return False\\n self.list[self.dict[val]] = self.list[-1]\\n self.dict[self.list[-1]] = self.dict[val]\\n self.list.pop()\\n self.dict.pop(val)\\n return True\\n \\n def getRandom(self):\\n \"\"\"\\n Get a random element from the set.\\n :rtype: int\\n \"\"\"\\n return random.choice(self.list)\\n \\n \\n # Your RandomizedSet object will be instantiated and called as such:\\n # obj = RandomizedSet()\\n # param_1 = obj.insert(val)\\n # param_2 = obj.remove(val)\\n # param_3 = obj.getRandom()"}
{"id": "1838", "input": "class Solution:\\n def displayTable(self, orders: List[List[str]]) -> List[List[str]]:\\n answer = []\\n \\n if orders is None or len(orders) == 0 or len(orders[0]) == 0:\\n return answer\\n \\n items = set()\\n \\n for order in orders:\\n items.add(order[2])\\n \\n items = sorted(list(items))\\n answer.append([\\\"Table\\\"])\\n \\n for item in items:\\n answer[0].append(item)\\n \\n hashMap = collections.defaultdict(list)\\n itemIndex = self.convertItemToIndex(answer[0])\\n m = len(answer[0])\\n \\n for order in orders:\\n hashMap[int(order[1])].append(order[2])\\n \\n hashMap = {key: hashMap[key] for key in sorted(hashMap.keys())}\\n currentIndex = 1\\n \\n for key in hashMap.keys():\\n answer.append([\\\"0\\\"] * m)\\n answer[currentIndex][0] = str(key)\\n countMap = defaultdict(lambda: 0)\\n \\n for currentItem in hashMap[key]:\\n countMap[currentItem]", "gt": "+= 1\\n \\n for currentItem in countMap.keys():\\n answer[currentIndex][itemIndex[currentItem]] = str(countMap[currentItem])\\n \\n currentIndex += 1\\n \\n return answer\\n \\n def convertItemToIndex(self, tempAns):\\n itemToIndex ="}
{"id": "1839", "input": "class Solution:\\n def maxChunksToSorted(self, arr):\\n \"\"\"\\n :type arr: List[int]\\n :rtype: int\\n \"\"\"\\n cnt, sm, ism = 0, 0, 0\\n", "gt": "for i, num in enumerate(arr):\\n sm += num\\n ism += i\\n if sm == ism:\\n cnt += 1\\n return cnt"}
{"id": "1840", "input": "class Solution:\\n def swimInWater(self, grid):\\n \"\"\"\\n :type grid: List[List[int]]\\n :rtype: int\\n \"\"\"\\n N = len(grid)\\n if N == 1:\\n return 0\\n \\n eleD = {}\\n for i in range(N):\\n for j in range(N):\\n eleD[grid[i][j]] = (i,j)\\n \\n \\n C = [[0 for _ in range(N)] for _ in range(N)]\\n stack = set()\\n nextstack = set()\\n nextstack.add((0,0))\\n for t in range(grid[0][0],N*N):\\n if eleD[t] not in nextstack:\\n continue\\n stack.add(eleD[t])\\n nextstack.remove(eleD[t])\\n while stack:\\n (x,y) = stack.pop()\\n if x == N-1 and y == N-1:\\n return t\\n C[x][y] = 1\\n if x > 0:\\n P = (x-1,y)\\n if C[P[0]][P[1]] == 0:\\n if grid[P[0]][P[1]] <= t:\\n stack.add(P)\\n else:\\n nextstack.add(P)\\n if y > 0:\\n P = (x,y-1)\\n if C[P[0]][P[1]] == 0:\\n if grid[P[0]][P[1]] <= t:\\n stack.add(P)\\n else:\\n nextstack.add(P)\\n if x < N-1:\\n P = (x+1,y)\\n if C[P[0]][P[1]] == 0:\\n if grid[P[0]][P[1]] <= t:\\n stack.add(P)\\n else:\\n nextstack.add(P)\\n if y < N-1:\\n P = (x,y+1)\\n if C[P[0]][P[1]] == 0:\\n if grid[P[0]][P[1]] <= t:\\n stack.add(P)\\n else:\\n nextstack.add(P)\\n print(t)\\n \\n \\n \\n # eleD = {}\\n # for i in range(N):\\n # for j in", "gt": "range(N):\\n # eleD[grid[i][j]] = (i,j)\\n # res = grid\\n # for t in range(N*N):\\n # (x,y) = eleD[t]\\n # if x > 0:\\n # if res[x-1][y] <= t:\\n # temp = res[x-1][y]\\n # for i in range(N):\\n # for j in range(N):\\n # if res[i][j] == temp:\\n # res[i][j] = t\\n # if y > 0:\\n # if res[x][y - 1] <= t:\\n # temp = res[x][y - 1]\\n # for i in range(N):\\n # for j in range(N):\\n # if res[i][j] == temp:\\n # res[i][j] = t\\n # if x < N - 1:\\n # if res[x + 1][y] <= t:\\n # temp = res[x + 1][y]\\n # for i in range(N):\\n # for j in range(N):\\n # if res[i][j] == temp:\\n # res[i][j] = t\\n # if y < N - 1:\\n # if res[x][y + 1] <= t:\\n # temp = res[x][y + 1]\\n # for i in range(N):\\n # for j in range(N):\\n # if res[i][j] == temp:\\n # res[i][j] = t\\n # #print(t,res)\\n # if res[0][0] == res[N-1][N-1]:\\n # return t\\n"}
{"id": "1841", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nclass Solution:\\n def longestZigZag(self, root: TreeNode) -> int:\\n if root == None:\\n return None\\n \\n maxlength = 0\\n stack = collections.deque()\\n if root.left:\\n stack.append((1, 1, root.left))\\n if root.right:\\n stack.append((1,", "gt": "0, root.right))\\n while stack:\\n length, isleft, node = stack.pop()\\n if isleft:\\n if node.right:\\n stack.append((length + 1, 0, node.right))\\n else:\\n maxlength = max(maxlength, length)\\n if node.left:\\n stack.append((1, 1, node.left))\\n else:\\n if node.left:\\n stack.append((length + 1, 1, node.left))\\n else:\\n maxlength = max(maxlength, length)\\n \\n if node.right:\\n stack.append((1, 0, node.right))\\n \\n return maxlength\\n \\n"}
{"id": "1842", "input": "class Solution:\\n def getStrongest(self, arr: List[int], k: int) -> List[int]:\\n arr.sort()\\n i, j = 0, len(arr) - 1\\n median = arr[(len(arr) - 1) // 2]\\n while len(arr) + i", "gt": "- j <= k:\\n if median - arr[i] > arr[j] - median:\\n i = i + 1\\n else:\\n j = j - 1\\n return arr[:i] + arr[j + 1:]"}
{"id": "1843", "input": "class Solution:\\n def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n tree = dict()\\n for i, j in edges:\\n if i > j: i, j = j, i\\n tree.setdefault(i - 1, []).append(j - 1)\\n\\n queue, time = [(0, 1)], 0 # node-prob\\n while queue and time", "gt": "<= t: # bfs \\n tmp = []\\n for node, prob in queue:\\n if node == target - 1: return 0 if time < t and node in tree else prob\\n for n in tree.get(node, []): tmp.append((n, prob / len(tree[node])))\\n queue, time = tmp, time + 1\\n return 0 \\n"}
{"id": "1844", "input": "from bisect import insort, bisect_left, bisect_right\\nfrom math import ceil\\n\\nclass TweetCounts:\\n\\n def __init__(self):\\n self.tweets={}\\n\\n def recordTweet(self, tweetName: str, time: int) -> None:\\n if tweetName not in self.tweets:\\n self.tweets[tweetName] = []\\n insort(self.tweets[tweetName], time)\\n def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n entry = self.tweets[tweetName]\\n diff = endTime - startTime\\n factor = 86400\\n if freq == 'minute':\\n factor = 60\\n elif", "gt": "freq == 'hour':\\n factor = 3600\\n buckets = math.ceil((diff + 1) / factor)\\n ans = [0]*buckets\\n start = bisect_left(entry, startTime)\\n end = bisect_right(entry, endTime)\\n for i in range(start, end):\\n time = entry[i]\\n d = (time - startTime) // factor\\n ans[d] += 1\\n return ans\\n \\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n"}
{"id": "1845", "input": "class Solution:\\n def findMinDifference(self, timePoints):\\n \"\"\"\\n :type timePoints: List[str]\\n :rtype: int\\n \"\"\"\\n if len(timePoints) > 1440: return 0\\n timeNum = [0] * len(timePoints)\\n for i in range(len(timePoints)):\\n timeNum[i] = 60 * int(timePoints[i][:2]) +", "gt": "int(timePoints[i][3:])\\n \\n timeNum.sort()\\n minMin = 24 * 60\\n for i in range(len(timeNum) - 1):\\n minMin = min(minMin, timeNum[i + 1] - timeNum[i])\\n minMin = min(minMin, 24 * 60 + timeNum[0] - timeNum[-1])\\n return minMin"}
{"id": "1846", "input": "class DLL:\\n \\n def __init__(self, val, key):\\n self.val = val\\n self.key = key\\n self.next = None\\n self.prev = None\\n \\n class AllOne:\\n \\n def __init__(self):\\n \"\"\"\\n Initialize your data structure here.\\n \"\"\"\\n self.hash = {}\\n self.head = None\\n self.tail = None\\n \\n def inc(self, key):\\n \"\"\"\\n Inserts a new key <Key> with value 1. Or increments an existing key by 1.\\n :type key: str\\n :rtype: void\\n \"\"\"\\n self.print_dll()\\n dll = self.hash.get(key, None)\\n if not dll:\\n dll = DLL(1, key)\\n self.insert_dll(dll)\\n self.hash[key] = dll\\n else:\\n self.incr_dll(dll) \\n \\n \\n def dec(self, key):\\n \"\"\"\\n Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\\n :type key: str\\n :rtype: void\\n \"\"\"\\n self.print_dll()\\n dll = self.hash.get(key, None)\\n if not dll:return\\n self.decr_dll(dll)\\n if dll.val == 0:\\n del self.hash[key]\\n \\n \\n def getMaxKey(self):\\n \"\"\"\\n Returns one of the keys with maximal value.\\n :rtype: str\\n \"\"\"\\n if self.head:\\n return self.head.key\\n return \"\"\\n \\n \\n def getMinKey(self):\\n \"\"\"\\n Returns one of the keys with Minimal value.\\n :rtype: str\\n \"\"\"\\n if self.tail:\\n return self.tail.key\\n return \"\"\\n \\n def insert_dll(self, dll):\\n if self.tail:\\n self.tail.next = dll\\n self.tail.next.prev = self.tail\\n self.tail = dll\\n else:\\n self.head = dll\\n self.tail = dll\\n", "gt": "\\n def incr_dll(self, dll):\\n dll.val = dll.val + 1\\n while dll.prev and dll.val > dll.prev.val:\\n \\n prev = dll.prev\\n prev_prev = dll.prev.prev\\n next_node = dll.next\\n \\n dll.next = prev\\n prev.next = next_node\\n dll.prev = prev_prev\\n prev.prev = dll\\n \\n if prev_prev:\\n prev_prev.next = dll\\n else:\\n self.head = dll\\n \\n if next_node:\\n next_node.prev = prev\\n else:\\n self.tail = prev\\n \\n \\n def decr_dll(self, dll):\\n dll.val = dll.val - 1\\n if dll.val == 0 :\\n if dll.prev:\\n dll.prev.next = dll.next\\n else:\\n self.head = dll.next\\n \\n if dll.next:\\n dll.next.prev = dll.prev\\n else:\\n self.tail = dll.prev\\n \\n elif dll.next and dll.val < dll.next.val:\\n next_node = dll.next\\n next_next = dll.next.next\\n prev = dll.prev\\n \\n dll.next = next_next\\n dll.prev = next_node\\n \\n next_node.next = dll\\n next_node.prev = prev\\n \\n if next_next:\\n next_next.prev = dll\\n else:\\n self.tail = dll\\n if prev:\\n prev.next = next_node\\n else:\\n self.head = next_node\\n \\n def print_dll(self):\\n temp = self.head\\n # while temp:\\n # print(\"%s %s\" % (temp.key, str(temp.val)))\\n # temp = temp.next\\n # print(\"End\")\\n \\n \\n \\n \\n \\n \\n \\n \\n # Your AllOne object will be instantiated and called as such:\\n # obj = AllOne()\\n # obj.inc(key)\\n # obj.dec(key)\\n # param_3 = obj.getMaxKey()\\n # param_4 = obj.getMinKey()"}
{"id": "1847", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nclass Solution:\\n \\n def pruneTreeHelper(self, root: TreeNode) -> TreeNode:\\n if not root:\\n return None\\n \\n left = self.pruneTreeHelper(root.left)\\n right =", "gt": "self.pruneTreeHelper(root.right)\\n \\n if not left:\\n root.left = None\\n \\n if not right:\\n root.right = None\\n \\n if root.val == 0 and root.right is None and root.left is None:\\n return None\\n else:\\n return root\\n \\n def pruneTree(self, root: TreeNode) -> TreeNode:\\n return self.pruneTreeHelper(root)"}
{"id": "1848", "input": "class SubrectangleQueries:\\n\\n def __init__(self, rectangle: List[List[int]]):\\n self.initial_rectangle = rectangle\\n self.rectangles = []\\n \\n\\n def updateSubrectangle(self, row1: int, col1: int, row2: int, col2: int, newValue: int) -> None:\\n self.rectangles.append((row1, col1, row2, col2, newValue))\\n \\n\\n def getValue(self, row: int, col: int) -> int:\\n", "gt": "for row1, col1, row2, col2, value in reversed(self.rectangles):\\n if row1 <= row <= row2 and col1 <= col <= col2:\\n return value\\n return self.initial_rectangle[row][col]\\n \\n\\n\\n# Your SubrectangleQueries object will be instantiated and called as such:\\n# obj = SubrectangleQueries(rectangle)\\n# obj.updateSubrectangle(row1,col1,row2,col2,newValue)\\n# param_2 = obj.getValue(row,col)\\n"}
{"id": "1849", "input": "import random\\n class RandomizedCollection:\\n \\n def __init__(self):\\n \"\"\"\\n Initialize your data structure here.\\n \"\"\"\\n self.val = []\\n self.idx = {}\\n \\n def insert(self, val):\\n \"\"\"\\n Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n :type val: int\\n :rtype: bool\\n \"\"\"\\n self.val.append(val)\\n if val in self.idx:\\n self.idx[val].append(len(self.val) - 1)\\n return False\\n else:\\n self.idx[val] = [len(self.val) - 1]\\n \\n def remove(self, val):\\n \"\"\"\\n Removes a value from the collection. Returns true if the collection contained", "gt": "the specified element.\\n :type val: int\\n :rtype: bool\\n \"\"\"\\n if val not in self.idx:\\n return False\\n #print(self.val, self.idx)\\n self.val[self.idx[val][-1]] = self.val[-1]\\n if self.idx[self.val[-1]][-1] != self.idx[val][-1]:\\n self.idx[self.val[-1]].pop()\\n self.idx[self.val[-1]].append(self.idx[val][-1])\\n self.idx[self.val[-1]].sort()\\n self.val.pop()\\n self.idx[val].pop()\\n if len(self.idx[val]) == 0:\\n del self.idx[val]\\n return True\\n \\n def getRandom(self):\\n \"\"\"\\n Get a random element from the collection.\\n :rtype: int\\n \"\"\"\\n return random.choice(self.val)\\n \\n \\n # Your RandomizedCollection object will be instantiated and called as such:\\n # obj = RandomizedCollection()\\n # param_1 = obj.insert(val)\\n # param_2 = obj.remove(val)\\n # param_3 = obj.getRandom()"}
{"id": "1850", "input": "# Definition for a binary tree node.\\n # class TreeNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.left = None\\n # self.right = None\\n \\n class Solution:\\n def levelOrder(self, root):\\n \"\"\"\\n", "gt": ":type root: TreeNode\\n :rtype: List[List[int]]\\n \"\"\"\\n queue, res = [root], []\\n while any(queue):\\n tmp = []\\n for _ in range(len(queue)):\\n node = queue.pop(0)\\n tmp.append(node.val)\\n if node.left:\\n queue.append(node.left)\\n if node.right:\\n queue.append(node.right)\\n res.append(tmp)\\n return res"}
{"id": "1851", "input": "class Solution:\\n def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\\n tree = [[] for _ in range(N)]\\n for i, j in edges:\\n tree[i].append(j)\\n tree[j].append(i)\\n \\n cnt = [1] * N\\n res = [0] * N\\n \\n def post_order(node, parent):\\n for i in tree[node]:\\n", "gt": "if i != parent:\\n post_order(i, node)\\n cnt[node] += cnt[i]\\n res[node] += res[i] + cnt[i]\\n \\n def pre_order(node, parent):\\n for i in tree[node]:\\n if i != parent:\\n res[i] = res[node] - cnt[i] + (N - cnt[i])\\n pre_order(i, node)\\n post_order(0, -1)\\n pre_order(0, -1)\\n \\n return res\\n"}
{"id": "1852", "input": "class Solution:\\n def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n clips.sort(key=lambda x: [x[0], -x[1]])\\n res = 0 \\n r = 0\\n new_r = 0\\n # print(clips)\\n for s, e in clips:\\n if s <= r:\\n new_r = max(new_r, e)\\n elif s", "gt": "> new_r:\\n return -1\\n else:\\n res += 1\\n r = new_r\\n # print(new_r)\\n new_r = max(new_r, e)\\n if new_r >= T:\\n break\\n if new_r < T:\\n return -1\\n if r < T and new_r >= T:\\n res += 1\\n return res\\n"}
{"id": "1853", "input": "\"\"\"\\n of course this is a dp problem.\\n if we consider upper bound and lower bound for each sub tree, \\n we will have a index-based solution over all posible numbers.\\n \\n each time we part a sub-tree into two parts, the question then becomes:\\n how many possible boundaries can we find (start, end).\\n \"\"\"\\n \\n class Solution:\\n def generateTrees(self, n):\\n \"\"\"\\n :type n: int\\n :rtype: List[TreeNode]\\n \"\"\"\\n dp = dict()\\n ret = self.generate_recursively(list(range(1, n+1)), 0, n, dp)\\n if n == 0:\\n ret = []\\n return ret\\n \\n # list is a sorted list of trees\\n def generate_recursively(self, l, start, end, dp):\\n ret = []\\n if", "gt": "end - start == 1:\\n ret = [TreeNode(l[start]),]\\n elif end - start <= 0:\\n ret = [None,]\\n \\n # take each index as partition place\\n else:\\n for idx in range(0, end - start):\\n left_nodes = dp[(start, start+idx)] if (start, start+idx) in dp.keys() else self.generate_recursively(l, start, start+idx, dp)\\n right_nodes = dp[(start+idx+1, end)] if (start+idx+1, end) in dp.keys() else self.generate_recursively(l, start+idx+1, end, dp)\\n \\n for left in left_nodes:\\n for right in right_nodes:\\n root = TreeNode(l[start+idx])\\n root.left = left \\n # if left != '<E>' else None\\n root.right = right \\n # if right !='<E>' else None\\n ret.append(root)\\n dp[(start, end)] = ret\\n return ret\\n \\n s = Solution()\\n s.generateTrees(3)"}
{"id": "1854", "input": "class Solution:\\n def findTheCity(self, n, edges, threshold):\\n adj=[[] for _ in range(n)]\\n for u,v,w in edges:\\n adj[u].append((w,v))\\n adj[v].append((w,u))\\n\\n ans=mn=100\\n for x in range(n):\\n cur=1\\n", "gt": "vis="}
{"id": "1855", "input": "# Definition for a binary tree node.\\n # class TreeNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.left = None\\n # self.right = None\\n \\n class Solution:\\n def rob(self, root):\\n \"\"\"\\n :type root: TreeNode\\n :rtype: int\\n \"\"\"\\n def superrob(node):\\n # returns tuple of size two (now, later)\\n # now: max money earned if input node is", "gt": "robbed\\n # later: max money earned if input node is not robbed\\n \\n # base case\\n if not node: return (0, 0)\\n \\n # get values\\n left, right = superrob(node.left), superrob(node.right)\\n \\n # rob now\\n now = node.val + left[1] + right[1]\\n \\n # rob later\\n later = max(left) + max(right)\\n \\n return (now, later)\\n \\n return max(superrob(root))\\n"}
{"id": "1856", "input": "# Definition for a binary tree node.\\n # class TreeNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.left = None\\n # self.right = None\\n \\n class Solution(object):\\n def validBST(self, root,", "gt": "min, max):\\n if root == None:\\n return True\\n if root.val <= min or root.val >= max:\\n return False\\n return self.validBST(root.left, min, root.val) and self.validBST(root.right, root.val, max)\\n def isValidBST(self, root):\\n return self.validBST(root, -21474836480, 21474836470)"}
{"id": "1857", "input": "class Solution:\\n def minimumMoves(self, grid: List[List[int]]) -> int:\\n m, n = len(grid), len(grid[0])\\n\\n queue = deque([(0, 0, True)])\\n dists = {(0, 0, True): 0}\\n\\n while queue:\\n i, j, hor = queue.popleft()\\n if (i, j) == (m-1, n-2):\\n return dists[(i, j, hor)]\\n if hor:\\n if j+2 < n and not grid[i][j+2]:\\n if (i, j+1, hor) not in dists:\\n queue.append((i, j+1, hor))\\n dists[(i, j+1, hor)] = dists[(i, j, hor)]+1\\n if i+1 < m and not grid[i+1][j] and not grid[i+1][j+1]:\\n if (i+1, j, hor) not in dists:\\n queue.append((i+1, j, hor))\\n dists[(i+1, j, hor)] = dists[(i, j, hor)]+1\\n", "gt": "if (i, j, not hor) not in dists:\\n queue.append((i, j, not hor))\\n dists[(i, j, not hor)] = dists[(i, j, hor)]+1\\n else:\\n if i+2 < m and not grid[i+2][j]:\\n if (i+1, j, hor) not in dists:\\n queue.append((i+1, j, hor))\\n dists[(i+1, j, hor)] = dists[(i, j, hor)]+1\\n if j+1 < n and not grid[i][j+1] and not grid[i+1][j+1]:\\n if (i, j+1, hor) not in dists:\\n queue.append((i, j+1, hor))\\n dists[(i, j+1, hor)] = dists[(i, j, hor)]+1\\n if (i, j, not hor) not in dists:\\n queue.append((i, j, not hor))\\n dists[(i, j, not hor)] = dists[(i, j, hor)]+1\\n \\n return -1"}
{"id": "1858", "input": "class Solution:\\n def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\\n left, right, mid = set(), set(), set()\\n count = 0\\n for row, col in reservedSeats:\\n \\n # if row in left and row in right and row in mid:\\n # continue\\n if col < 6 and col > 1:\\n left.add(row)\\n if col < 10 and", "gt": "col > 5:\\n right.add(row)\\n if col < 8 and col > 3:\\n mid.add(row)\\n for i in (left | right | mid):\\n if i not in mid:\\n count += 1\\n elif i not in left or i not in right:\\n count += 1\\n count += 2 * (n - len(left | right | mid))\\n return count"}
{"id": "1859", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nclass FindElements:\\n\\n def __init__(self, root: TreeNode):\\n self.dicts = {}\\n if root:\\n root.val = 0\\n stacks = [root]\\n self.dicts[0] = 1\\n while stacks:\\n new_stacks = []\\n for element in stacks:\\n if element.left:element.left.val = element.val*2 + 1;", "gt": "new_stacks.append(element.left);"}
{"id": "1860", "input": "class Solution:\\n def countSquares(self, matrix: List[List[int]]) -> int:\\n m = len(matrix)\\n n = len(matrix[0])\\n \\n for i in range(1, m):\\n for j in range(1, n):\\n if not matrix[i][j]:\\n", "gt": "continue\\n if matrix[i][j-1] and matrix[i-1][j] and matrix[i-1][j-1]:\\n matrix[i][j] = min(matrix[i][j-1], matrix[i-1][j], matrix[i-1][j-1]) + 1\\n \\n total = 0\\n for row in matrix:\\n total += sum(row)\\n \\n return total\\n \\n"}
{"id": "1861", "input": "class Solution:\\n def fallingSquares(self, positions):\\n \"\"\"\\n :type positions: List[List[int]]\\n :rtype: List[int]\\n \"\"\"\\n height = [0]\\n pos = [0]\\n res = []\\n max_h = 0\\n for left, side in positions:\\n i = bisect.bisect_right(pos, left)\\n", "gt": "j = bisect.bisect_left(pos, left + side)\\n high = max(height[i - 1:j] or [0]) + side\\n pos[i:j] = [left, left + side]\\n height[i:j] = [high, height[j - 1]]\\n max_h = max(max_h, high)\\n res.append(max_h)\\n return res"}
{"id": "1862", "input": "class Solution:\\n def minAreaRect(self, points):\\n pSet, ans = set(map(tuple, points)), float('inf')\\n for i, (p1x, p1y) in enumerate(points):\\n for (p2x, p2y) in points[i+1:]:\\n if (p1x != p2x) and (p1y != p2y) and ((p1x, p2y) in pSet) and ((p2x, p1y) in pSet):\\n ans = min(ans, abs((p1x - p2x) * (p1y - p2y)))\\n return ans if ans < float('inf') else 0\\n \\nclass Solution:\\n def minAreaRect(self, points):\\n X = list(zip(*points))\\n if len(set(X[0])) == 1 or len(set(X[1])) == 1: return 0\\n\\n pSet, ans = set(map(tuple, points)), float('inf')\\n for i, (p1x, p1y) in enumerate(points):\\n for (p2x, p2y) in points[i+1:]:\\n area = abs((p2x-p1x)*(p2y-p1y))\\n if area > ans or area == 0:\\n continue\\n if (p1x, p2y) in pSet and (p2x, p1y) in pSet:\\n ans = area\\n return ans if ans < float('inf') else 0\\n \\nfrom collections import defaultdict\\nclass Solution:\\n def minAreaRect(self, points):\\n X = list(zip(*points))\\n Nr, Nc = len(set(X[0])), len(set(X[1]))\\n if Nr == 1 or Nc == 1: return 0\\n\\n points.sort()\\n columns = defaultdict(list)\\n for r, c in points:\\n columns[r].append(c)\\n ans, lastc = float('inf'), dict()\\n for r, cols in list(columns.items()):\\n for i, c1 in enumerate(cols):\\n for c2 in cols[i+1:]:\\n if (c1, c2) in lastc:\\n area = (r - lastc[(c1, c2)]) * (c2 - c1)\\n #ans = min(ans, area)\\n if area < ans: ans = area\\n lastc[(c1, c2)] = r\\n return ans if ans < float('inf') else 0\\n \\nfrom collections import", "gt": "defaultdict\\nclass Solution:\\n def minAreaRect(self, points):\\n X = list(zip(*points))\\n Nr, Nc = len(set(X[0])), len(set(X[1]))\\n if Nr == 1 or Nc == 1: return 0\\n if Nr < Nc:\\n points = [[c, r] for (r, c) in points]\\n return self.minAreaRect(points)\\n \\n points.sort()\\n columns = defaultdict(list)\\n for r, c in points:\\n columns[r].append(c)\\n ans, lastc = float('inf'), dict()\\n for r, cols in list(columns.items()):\\n for i, c1 in enumerate(cols):\\n for c2 in cols[i+1:]:\\n if (c1, c2) in lastc:\\n area = (r - lastc[(c1, c2)]) * (c2 - c1)\\n #ans = min(ans, area)\\n if area < ans: ans = area\\n lastc[(c1, c2)] = r\\n return ans if ans < float('inf') else 0\\n \\nfrom collections import defaultdict\\nclass Solution:\\n def minAreaRect(self, points):\\n d = defaultdict(set)\\n rset, cset, N, ans = set(), set(), len(points), float('inf')\\n for r, c in points:\\n rset.add(r)\\n cset.add(c)\\n Nr, Nc = len(rset), len(cset)\\n if Nr == 1 or Nc == 1:\\n return 0\\n elif Nr < Nc:\\n for r, c in points:\\n d[r].add(c)\\n else:\\n for r, c in points:\\n d[c].add(r)\\n\\n A = sorted(d.keys())\\n for i, r1 in enumerate(A):\\n cols1 = d[r1]\\n for r2 in A[i+1:]:\\n cols2 = d[r2]\\n s = sorted(cols1 & cols2)\\n for c1, c2 in zip(s[:-1], s[1:]):\\n area = (r1 - r2) * (c1 - c2)\\n #ans = min(ans, area)\\n if area < ans: ans = area\\n return ans if ans < float('inf') else 0\\n"}
{"id": "1863", "input": "class Solution:\\n def pancakeSort(self, A: List[int]) -> List[int]:\\n n = len(A)\\n res = []\\n \\n for x in range(n,", "gt": "1, -1):\\n idx = A.index(x)\\n res.extend([idx + 1, x])\\n A = A[idx::-1] + A[idx+1:]\\n A = A[x-1::-1]\\n \\n return res\\n"}
{"id": "1864", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nfrom collections import deque\\n\\nclass Solution:\\n def bfs(self, root, col_table):\\n min_col = 0\\n max_col = 0\\n queue = deque([(root, 0, 0)])\\n \\n while queue:\\n node, col, row = queue.popleft()\\n col_value = col_table.get(col, [])\\n col_value.append((row, node.val))\\n col_table[col] = col_value\\n min_col = min(min_col, col)\\n max_col = max(max_col,", "gt": "col)\\n if node.left:\\n queue.append((node.left, col - 1, row + 1))\\n if node.right:\\n queue.append((node.right, col + 1, row + 1))\\n return min_col, max_col\\n \\n def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\\n if not root:\\n return []\\n col_table = dict()\\n min_col, max_col = self.bfs(root, col_table)\\n \\n res = []\\n for col_idx in range(min_col, max_col + 1):\\n col_res = []\\n col = sorted(col_table[col_idx])\\n for i in range(len(col)):\\n col_res.append(col[i][1])\\n res.append(col_res)\\n return res"}
{"id": "1865", "input": "class Solution:\\n def braceExpansionII(self, expression: str) -> List[str]:\\n \\n stack,res,cur=[],[],['']\\n for v in expression:\\n \\n if v.isalpha():\\n cur=[c+v for c in cur]\\n elifv==',':\\n res+=cur\\n cur=['']\\n elif v=='{':\\n stack.append(res)\\n stack.append(cur)\\n", "gt": "res,cur=[],['']\\n elif v=='}"}
{"id": "1866", "input": "class Solution:\\n def minPushBox(self, grid: List[List[str]]) -> int:\\n m, n, g = len(grid), len(grid[0]), collections.defaultdict(list)\\n for i in range(m):\\n for j in range(n):\\n g[grid[i][j]] += [complex(i, j)]\\n \\n def f(b, s):\\n nonlocal time\\n time += 1\\n boxToTarget = b - target\\n return (abs((boxToTarget.real))+abs((boxToTarget).imag)+s, abs(boxToTarget), time)\\n \\n player, box, target, time = *g['S'], *g['B'], *g['T'], 1\\n floor = {player, box, target, *g['.']}\\n \\n alpha = [(f(box, 1), 1, player, box)]\\n directions, visited = (1, -1, 1j, -1j), set() # 下上右左\\n \\n # 因为都不是数而是复数。因此采用字典映射的方式定义low dfn\\n low = dict.fromkeys(floor, 0) # 标准的dict.fromkeys创建字典。keys来源第一个参数第二个参数默认或赋值\\n dfn = low.copy()\\n count = 0\\n index = {}\\n # 标准无向图tarjan深度优先扩展函数，参数currIndex为当前拓展点，记录拓展的父节点防止重复拓展\\n def tarjan(currIndex, parentIndex):\\n nonlocal count\\n count += 1\\n dfn[currIndex] = low[currIndex] = count\\n index[count] = currIndex\\n for direction in directions:\\n nextIndex = currIndex", "gt": "+ direction\\n if nextIndex in floor and nextIndex != parentIndex:\\n if not low[nextIndex]:\\n tarjan(nextIndex, currIndex)\\n low[currIndex] = min(low[currIndex], low[nextIndex])\\n \\n #运行tarjan函数，初始值为box的坐标，因为坐标都在复平面第一象限，初始父节点取-1不影响计算\\n tarjan(box, -1)\\n #print(low)\\n #print(dfn)\\n # 如果箱子在割点上仍可以移动的话，则箱子在移动的过程中，人的坐标也完成了强连通分量的转移，\\n # 所以即便是宽度为1的碎片化的强连通分量隧道，也不影响上述结论。\\n for currIndex in floor: # 所有的可达点\\n connect = [currIndex]\\n while dfn[connect[-1]] != low[connect[-1]]:\\n connect.append(index[low[connect[-1]]])\\n for w in connect[:-2]:\\n low[w] = low[connect[-1]]\\n #print(low)\\n \\n # 计算完强连通分量后可以加一个剪枝，即如果人或目标点没被计算到，则表示三个关键点不在同一个并查集里面，\\n # 可以直接返回-1\\n if not low[player] * low[target]:\\n return -1\\n \\n while alpha:\\n _, steps, currPlayer, currBox = heapq.heappop(alpha)\\n for direction in directions:\\n nextPlayer, nextBox = currBox - direction, currBox + direction\\n if nextBox in floor and nextPlayer in floor and (nextPlayer, currBox) not in visited and low[currPlayer] == low[nextPlayer]:\\n if nextBox == target:\\n return steps\\n heapq.heappush(alpha, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))\\n visited.add((nextPlayer, currBox))\\n return -1"}
{"id": "1867", "input": "class Solution:\\n def fullJustify(self, words, maxWidth):\\n \"\"\"\\n :type words: List[str]\\n :type maxWidth: int\\n :rtype: List[str]\\n \"\"\"\\n def make_str(buffer, length, last):\\n if last:\\n return ' '.join(buffer) + ' ' * (maxWidth - length)\\n space = maxWidth - (length - len(buffer) + 1)\\n cnt = len(buffer) - 1\\n tmp = ''\\n if cnt == 0:\\n tmp = buffer[0] + ' ' * space\\n else:\\n spaces = [space // cnt] * cnt\\n for i in range(space % cnt):\\n spaces[i] += 1\\n spaces.append(0)\\n for s, b in", "gt": "zip(spaces, buffer):\\n tmp += b + ' ' * s\\n return tmp\\n \\n res = []\\n buffer = []\\n length = 0\\n for w in words:\\n lw = len(w)\\n if lw > maxWidth:\\n continue\\n if len(buffer) == 0:\\n buffer.append(w)\\n length = lw\\n elif length + lw + 1 <= maxWidth:\\n buffer.append(w)\\n length = length + lw + 1\\n else:\\n tmp = make_str(buffer, length, False)\\n res.append(tmp)\\n buffer = [w]\\n length = lw\\n if len(buffer) > 0:\\n tmp = make_str(buffer, length, True)\\n res.append(tmp)\\n \\n return res\\n"}
{"id": "1868", "input": "class Solution:\\n def __init__(self):\\n self.k = 0\\n self.result = None\\n \\n def kthSmallest(self, root, k):\\n \"\"\"\\n :type root: TreeNode\\n :type k: int\\n :rtype: int\\n \"\"\"\\n if", "gt": "root.left and self.k < k:\\n self.kthSmallest(root.left, k)\\n self.k += 1\\n if self.k == k:\\n self.result = root.val\\n if root.right and self.k < k:\\n self.kthSmallest(root.right, k)\\n return self.result"}
{"id": "1869", "input": "class Solution:\\n def beautifulArray(self, N: int) -> List[int]:\\n res = [1]\\n \\n while len(res) < N:\\n res = [i*2-1", "gt": "for i in res]+ [i*2 for i in res]\\n \\n return [i for i in res if i <= N]"}
{"id": "1870", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nimport re\\n\\nclass Solution:\\n def recoverFromPreorder(self, S: str) -> TreeNode:\\n itera = re.finditer(r'(-*)(\\\\d+)', S)\\n \\n root", "gt": "= TreeNode(int(next(itera).group(2)))\\n \\n tofill = [root]\\n \\n for m in itera:\\n k = len(m.group(1))\\n if k == len(tofill):\\n node = TreeNode(int(m.group(2)))\\n tofill[-1].left = node\\n tofill.append(node)\\n else:\\n node = TreeNode(int(m.group(2)))\\n tofill[k-1].right = node\\n tofill[k:] = [node]\\n \\n return root"}
{"id": "1871", "input": "class Solution:\\n def sampleStats(self, count: List[int]) -> List[float]:\\n mn = -1\\n mx = 0\\n sm = 0\\n cnt = 0\\n mode_i = 0\\n mode_cnt = 0\\n indexes = collections.deque()\\n median_count = 0\\n \\n for i, c in enumerate(count):\\n sm += i * c\\n cnt += c\\n \\n mode_i = i if mode_cnt < c else mode_i\\n mode_cnt = c if mode_cnt < c else mode_cnt\\n \\n", "gt": "if c:\\n mx = i\\n if mn == -1:\\n mn = i\\n while indexes and median_count + count[indexes[0]] < cnt / 2:\\n median_count += count[indexes[0]]\\n indexes.popleft()\\n indexes.append(i)\\n \\n median = 0\\n \\n if cnt % 2:\\n median = indexes[0]\\n elif count[indexes[0]] + median_count > cnt // 2:\\n median = indexes[0]\\n else:\\n median = (indexes[0] + indexes[1]) / 2\\n \\n return mn, mx, sm / cnt, median, mode_i"}
{"id": "1872", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nclass Solution:\\n def maxAncestorDiff(self, root: TreeNode) -> int:\\n self.res = 0\\n def helper(node, path_max,", "gt": "path_min):\\n if not node:\\n return 0\\n path_max = max(path_max, node.val)\\n path_min = min(path_min, node.val)\\n self.res = max(self.res, path_max - path_min)\\n helper(node.left, path_max, path_min)\\n helper(node.right, path_max, path_min)\\n if not root:\\n return 0\\n helper(root, root.val, root.val)\\n return self.res"}
{"id": "1873", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nclass Solution:\\n def maxLevelSum(self, root: TreeNode) -> int:\\n stack = [root]\\n ans = -1000000\\n result = 1\\n level = 1\\n \\n", "gt": "while stack:\\n curr = 0\\n newStack = []\\n for x in stack:\\n curr += x.val\\n if x.left:\\n newStack.append(x.left)\\n if x.right: \\n newStack.append(x.right)\\n \\n stack = newStack\\n \\n if curr > ans:\\n ans = curr\\n result = level\\n \\n level += 1\\n \\n return result"}
{"id": "1874", "input": "class Solution:\\n # def canTransform(self, start, end):\\n # \"\"\"\\n # :type start: str\\n # :type end: str\\n # :rtype: bool\\n # \"\"\"\\n \\n def canTransform(self, start, end):\\n # For (i, x) and (j, y) in enumerate(start), enumerate(end)\\n # where x != 'X' and y != 'X',\\n # and where if one exhausts early, it's elements are (None, None),...\\n for (i, x), (j, y) in itertools.zip_longest(\\n ((i, x) for i, x in enumerate(start) if x != 'X'),\\n ((j, y) for j, y in enumerate(end) if y != 'X'),\\n fillvalue = (None, None)):\\n \\n # If not solid or accessible, return False\\n if x != y or", "gt": "(x == 'L' and i < j) or (x == 'R' and i > j):\\n return False\\n \\n return True\\n \\n \\n # tmps = start.replace(\"X\",\"\")\\n # tmpe = end.replace(\"X\",\"\")\\n # if tmps != tmpe:\\n # return False\\n # sa, ta = [], []\\n # i = 0\\n # while (i < len(start)):\\n # if start[i] == \"L\":\\n # sa.append(i)\\n # elif start[i] == \"R\":\\n # sa.append(-i)\\n # if end[i] == \"L\":\\n # ta.append(i)\\n # elif end[i] == \"R\":\\n # ta.append(-i)\\n # i += 1\\n # i = 0\\n # while(i < len(sa)):\\n # if sa[i]<ta[i]:\\n # return False\\n # i += 1\\n # return True\\n"}
{"id": "1875", "input": "class Solution:\\n def numRabbits(self, answers):\\n cnts = collections.Counter(answers)\\n return", "gt": "sum(-v % (k+1) + v for k, v in cnts.items())"}
{"id": "1876", "input": "class Solution:\\n \\n def findFrequentTreeSum(self, root):\\n self.sums = []\\n if not root:\\n return []\\n self.traverse(root)\\n res = collections.Counter(self.sums)\\n frequent = max(res.values())\\n return [x for x in", "gt": "res if res[x] == frequent]\\n \\n \\n def traverse(self, root):\\n if not root:\\n return 0\\n \\n self_sum = root.val + self.traverse(root.left) + self.traverse(root.right)\\n \\n self.sums.append(self_sum)\\n return self_sum\\n"}
{"id": "1877", "input": "def fun(k):\\n n = 1 + 8*k\\n s = math.floor(n**0.5)-1\\n s = s//2\\n return s\\n class Solution:\\n def reachNumber(self, target):\\n \"\"\"\\n :type target: int\\n :rtype:", "gt": "int\\n \"\"\"\\n if target<0:\\n target *= -1\\n L = [[3,2,1,1],[1,1,3,2]] \\n k = fun(target)\\n if k*(k+1)/2==target:\\n ans = 0\\n else:\\n ans = L[target%2][k%4]\\n #print(target,\"->\",k,k+ans)\\n return k+ans\\n"}
{"id": "1878", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nclass Solution:\\n def sufficientSubset(self, root, limit):\\n if root.left == root.right:\\n", "gt": "return None if root.val < limit else root\\n if root.left:\\n root.left = self.sufficientSubset(root.left, limit - root.val)\\n if root.right:\\n root.right = self.sufficientSubset(root.right, limit - root.val)\\n return root if root.left or root.right else None\\n"}
{"id": "1879", "input": "class Solution:\\n def maxChunksToSorted(self, arr):\\n \"\"\"\\n :type arr: List[int]\\n :rtype: int\\n \"\"\"\\n res = 0\\n temp = sorted(arr)\\n sum1, sum2", "gt": "= 0, 0\\n for i in range(0,len(arr)):\\n sum1 += arr[i]\\n sum2 += temp[i]\\n if(sum1 == sum2):\\n res += 1\\n return res\\n"}
{"id": "1880", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nclass Solution:\\n def deepestLeavesSum(self, root: TreeNode) ->", "gt": "int:\\n q = [root]\\n while q:\\n pre, q = q, [child for p in q for child in [p.left, p.right] if child]\\n return sum(node.val for node in pre)\\n \\n \\n"}
{"id": "1881", "input": "class Solution:\\n def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:\\n cell = 0\\n for c in cells:\\n cell = (cell << 1) | c\\n seendict = {}\\n index = 0\\n while True:\\n # print([int(x) for x in '{0:08b}'.format(cell)])\\n if cell in seendict:\\n if", "gt": "(N - index) % (index - seendict[cell]) == 0:\\n return [int(x) for x in '"}
{"id": "1882", "input": "class Solution:\\n def intersectionSizeTwo(self, intervals):\\n \"\"\"\\n :type intervals: List[List[int]]\\n :rtype: int\\n \"\"\"\\n intervals.sort(key=lambda x: x[1])\\n if len(intervals) <= 1:\\n return len(intervals[0])\\n s = set()\\n prev_e = None\\n intersect = False\\n for e in intervals:\\n if not s:\\n a = e[1] - 1\\n b = e[1]\\n s.add(a)\\n s.add(b)\\n continue\\n if", "gt": "e[0] <= a :\\n intersect = True\\n continue\\n \\n if e[0] > a and e[1] > b >= e[0] :\\n intersect = True\\n a = b\\n b = e[-1]\\n s.add(b)\\n continue\\n a = e[1] - 1\\n b = e[1]\\n s.add(a)\\n s.add(b)\\n \\n if not intersect:\\n return 0\\n return len(s)\\n"}
{"id": "1883", "input": "# Definition for singly-linked list.\\n # class ListNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.next = None\\n \\n class Solution:\\n def swapPairs(self, head):\\n \"\"\"\\n :type head: ListNode\\n :rtype: ListNode\\n \"\"\"\\n i = 1\\n node = head\\n prev = None\\n prev2 = None\\n while node is not", "gt": "None:\\n if i % 2 == 0 and i != 1:\\n if prev2 is not None:\\n prev2.next = node\\n prev.next = node.next\\n node.next = prev\\n if i == 2:\\n head = node\\n node = prev\\n prev2 = prev\\n prev = node\\n node = node.next\\n i += 1\\n return head"}
{"id": "1884", "input": "class Solution:\\n def uniquePathsIII(self, grid: List[List[int]]) -> int:\\n def fun(g,i0,i1,n1,t1,f2,row,col):\\n if n1==t1:\\n if abs(f2[1]-i1)+abs(f2[0]-i0)==1:\\n self.ans+=1\\n else:\\n if i1+1!=col and g[i0][i1+1]==0:\\n g[i0][i1+1]=1\\n fun(g,i0,i1+1,n1+1,t1,f2,row,col)\\n g[i0][i1+1]=0\\n if i1!=0 and g[i0][i1-1]==0:\\n g[i0][i1-1]=1\\n fun(g,i0,i1-1,n1+1,t1,f2,row,col)\\n g[i0][i1-1]=0\\n if i0+1!=row and g[i0+1][i1]==0:\\n g[i0+1][i1]=1\\n fun(g,i0+1,i1,n1+1,t1,f2,row,col)\\n g[i0+1][i1]=0\\n if i0!=0", "gt": "and g[i0-1][i1]==0:\\n g[i0-1][i1]=1\\n fun(g,i0-1,i1,n1+1,t1,f2,row,col)\\n g[i0-1][i1]=0\\n \\n self.ans=0\\n i0,i1,t1=0,0,0\\n f2=[0,0]\\n row = len(grid)\\n col = len(grid[0])\\n for i in range(row):\\n for j in range(col):\\n if grid[i][j]==0:\\n t1+=1\\n elif grid[i][j]==1:\\n i0,i1 = i,j\\n elif grid[i][j]==2:\\n f2 = [i,j]\\n fun(grid,i0,i1,0,t1,f2,row,col)\\n return self.ans"}
{"id": "1885", "input": "class Solution:\\n def findLadders(self, beginWord, endWord, wordList):\\n wordDict = set(wordList)\\n if endWord not in wordDict: return []\\n wordDict.discard(beginWord)\\n front, back = set([beginWord]), set([endWord])\\n length = 2\\n direction = 1\\n parents = collections.defaultdict(set)\\n \\n while front:\\n next_level = set()\\n for word in front:\\n for index in range(len(beginWord)):\\n p1, p2 = word[:index], word[index+1:]\\n for ch in 'abcdefghijklmnopqrstuvwxyz':\\n if word[index] != ch:\\n next_word = p1 + ch + p2\\n if next_word in wordDict:\\n next_level.add(next_word)\\n if direction", "gt": "== 1:\\n parents[next_word].add(word)\\n else:\\n parents[word].add(next_word)\\n \\n if next_level & back:\\n res = [[endWord]]\\n while res and res[0][0] !=beginWord:\\n res = [[p]+r for r in res for p in parents[r[0]]]\\n return res\\n \\n length += 1\\n front = next_level\\n if len(front) > len(back):\\n direction *= -1\\n front, back = back, front\\n wordDict -= front\\n return []\\n \\n \\n \\n \\n \\n \\n \"\"\"\\n :type beginWord: str\\n :type endWord: str\\n :type wordList: List[str]\\n :rtype: List[List[str]]\\n \"\"\"\\n"}
{"id": "1886", "input": "class Solution:\\n def countBits(self, num):\\n \"\"\"\\n :type num: int\\n :rtype: List[int]\\n \"\"\"\\n ans = [0]\\n while len(ans) <", "gt": "num + 1:\\n ans += [1 + x for x in ans]\\n # len(ans) > num\\n return ans[:num+1]"}
{"id": "1887", "input": "from math import sqrt\\n class NumArray(object):\\n \\n def __init__(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n \"\"\"\\n if nums:\\n k=int(sqrt(len(nums)))\\n add,i=[],0\\n while i<=len(nums)-k:\\n add.append(sum(nums[i:i+k]))\\n i+=k\\n if i!=len(nums):\\n add.append(sum(nums[i:]))\\n self.nums,self.add,self.k=nums,add,k\\n \\n \\n def update(self, i, val):\\n \"\"\"\\n :type i: int\\n :type val: int\\n :rtype: void\\n \"\"\"\\n self.add[i//self.k]+=val-self.nums[i]\\n self.nums[i]=val\\n \\n \\n \\n", "gt": "def sumRange(self, i, j):\\n \"\"\"\\n :type i: int\\n :type j: int\\n :rtype: int\\n \"\"\"\\n def func(i):\\n return sum(self.add[:i//self.k])+sum(self.nums[(i//self.k)*self.k:i+1]) if i>=0 else 0\\n return func(j)-func(i-1)\\n \\n \\n \\n # Your NumArray object will be instantiated and called as such:\\n # obj = NumArray(nums)\\n # obj.update(i,val)\\n # param_2 = obj.sumRange(i,j)"}
{"id": "1888", "input": "class Solution:\\n def findCircleNum(self, M):\\n N = len(M)\\n students = set()\\n for i in range(N):\\n students.add(i)\\n \\n num_grp = 0\\n while students:\\n num_grp += 1\\n", "gt": "stack = [students.pop()]\\n while stack and students:\\n student = stack.pop()\\n for i in range(N):\\n if M[student][i] == 1 and i in students:\\n stack.append(i)\\n students.discard(i)\\n return num_grp\\n"}
{"id": "1889", "input": "class Solution:\\n def addOneRow(self, root, v, d):\\n \"\"\"\\n :type root: TreeNode\\n :type v: int\\n :type d: int\\n :rtype: TreeNode\\n \"\"\"\\n if root:\\n if d == 1:\\n new_root = TreeNode(v)\\n new_root.left = root\\n \\n return new_root \\n \\n queue = [root]\\n level = 1\\n while queue and level < d:\\n row = []\\n", "gt": "for i in range(len(queue)):\\n node = queue.pop(0)\\n if level == d - 1:\\n row.append(node)\\n if node.left:\\n queue.append(node.left)\\n if node.right:\\n queue.append(node.right)\\n \\n level += 1\\n \\n for node in row:\\n old = node.left\\n node.left = TreeNode(v)\\n node.left.left = old\\n \\n old = node.right\\n node.right = TreeNode(v)\\n node.right.right = old\\n \\n return root\\n \\n \\n"}
{"id": "1890", "input": "from functools import reduce\\n class Solution:\\n def smallestRange(self, nums):\\n \"\"\"\\n :type nums: List[List[int]]\\n :rtype: List[int]\\n \"\"\"\\n k = len(nums)\\n idx = [0]*k\\n \\n dic = collections.defaultdict(list)\\n \\n for i in range(k):\\n dic[nums[i][0]].append(i)\\n \\n mi,", "gt": "ma = min(dic.keys()), max(dic.keys())\\n \\n ret = (mi, ma)\\n while True:\\n for i in dic[mi]:\\n idx[i] += 1\\n if idx[i]==len(nums[i]):\\n return ret\\n dic[nums[i][idx[i]]].append(i)\\n dic.pop(mi)\\n mi, ma = min(dic.keys()), max(dic.keys())\\n if ma-mi<ret[1]-ret[0]:\\n ret = (mi, ma)\\n"}
{"id": "1891", "input": "# Definition for a binary tree node.\\n # class TreeNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.left = None\\n # self.right = None\\n from collections import deque\\n \\n class", "gt": "Solution:\\n def findBottomLeftValue(self, root):\\n \"\"\"\\n :type root: TreeNode\\n :rtype: int\\n \"\"\"\\n self.queue = deque([])\\n self.queue.append(root)\\n return self.bfs()\\n \\n def bfs(self):\\n while len(self.queue):\\n node = self.queue.popleft()\\n if node.right:\\n self.queue.append(node.right)\\n if node.left:\\n self.queue.append(node.left)\\n return node.val\\n"}
{"id": "1892", "input": "from copy import deepcopy\\n from collections import deque\\n def check(p1, p2):\\n if p1[0] == p2[0] or p1[1] == p2[1] or abs(p1[0] - p2[0]) == abs(p1[1] - p2[1]):\\n return True\\n return False\\n \\n def passAll(p1, points):\\n for x, y in enumerate(points):\\n if check(p1, (x, y)):\\n return False\\n return True\\n \\n def reconstruct(points, n):\\n a = [['.'] * n for _ in range(n)]\\n for x, y in enumerate(points):\\n a[x][y] = 'Q'\\n a = [\"\".join(i) for i in a]\\n return a\\n \\n class Solution:\\n def solveNQueens(self, n):\\n \"\"\"\\n :type n: int\\n :rtype: int\\n \"\"\"\\n return [[],\\n [[\"Q\"]],\\n [],\\n [],\\n [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]],\\n [[\"Q....\",\"..Q..\",\"....Q\",\".Q...\",\"...Q.\"],[\"Q....\",\"...Q.\",\".Q...\",\"....Q\",\"..Q..\"],[\".Q...\",\"...Q.\",\"Q....\",\"..Q..\",\"....Q\"],[\".Q...\",\"....Q\",\"..Q..\",\"Q....\",\"...Q.\"],[\"..Q..\",\"Q....\",\"...Q.\",\".Q...\",\"....Q\"],[\"..Q..\",\"....Q\",\".Q...\",\"...Q.\",\"Q....\"],[\"...Q.\",\"Q....\",\"..Q..\",\"....Q\",\".Q...\"],[\"...Q.\",\".Q...\",\"....Q\",\"..Q..\",\"Q....\"],[\"....Q\",\".Q...\",\"...Q.\",\"Q....\",\"..Q..\"],[\"....Q\",\"..Q..\",\"Q....\",\"...Q.\",\".Q...\"]],\\n [[\".Q....\",\"...Q..\",\".....Q\",\"Q.....\",\"..Q...\",\"....Q.\"],[\"..Q...\",\".....Q\",\".Q....\",\"....Q.\",\"Q.....\",\"...Q..\"],[\"...Q..\",\"Q.....\",\"....Q.\",\".Q....\",\".....Q\",\"..Q...\"],[\"....Q.\",\"..Q...\",\"Q.....\",\".....Q\",\"...Q..\",\".Q....\"]],\\n [[\"Q......\",\"..Q....\",\"....Q..\",\"......Q\",\".Q.....\",\"...Q...\",\".....Q.\"],[\"Q......\",\"...Q...\",\"......Q\",\"..Q....\",\".....Q.\",\".Q.....\",\"....Q..\"],[\"Q......\",\"....Q..\",\".Q.....\",\".....Q.\",\"..Q....\",\"......Q\",\"...Q...\"],[\"Q......\",\".....Q.\",\"...Q...\",\".Q.....\",\"......Q\",\"....Q..\",\"..Q....\"],[\".Q.....\",\"...Q...\",\"Q......\",\"......Q\",\"....Q..\",\"..Q....\",\".....Q.\"],[\".Q.....\",\"...Q...\",\".....Q.\",\"Q......\",\"..Q....\",\"....Q..\",\"......Q\"],[\".Q.....\",\"....Q..\",\"Q......\",\"...Q...\",\"......Q\",\"..Q....\",\".....Q.\"],[\".Q.....\",\"....Q..\",\"..Q....\",\"Q......\",\"......Q\",\"...Q...\",\".....Q.\"],[\".Q.....\",\"....Q..\",\"......Q\",\"...Q...\",\"Q......\",\"..Q....\",\".....Q.\"],[\".Q.....\",\".....Q.\",\"..Q....\",\"......Q\",\"...Q...\",\"Q......\",\"....Q..\"],[\".Q.....\",\"......Q\",\"....Q..\",\"..Q....\",\"Q......\",\".....Q.\",\"...Q...\"],[\"..Q....\",\"Q......\",\".....Q.\",\".Q.....\",\"....Q..\",\"......Q\",\"...Q...\"],[\"..Q....\",\"Q......\",\".....Q.\",\"...Q...\",\".Q.....\",\"......Q\",\"....Q..\"],[\"..Q....\",\"....Q..\",\"......Q\",\".Q.....\",\"...Q...\",\".....Q.\",\"Q......\"],[\"..Q....\",\".....Q.\",\".Q.....\",\"....Q..\",\"Q......\",\"...Q...\",\"......Q\"],[\"..Q....\",\"......Q\",\".Q.....\",\"...Q...\",\".....Q.\",\"Q......\",\"....Q..\"],[\"..Q....\",\"......Q\",\"...Q...\",\"Q......\",\"....Q..\",\".Q.....\",\".....Q.\"],[\"...Q...\",\"Q......\",\"..Q....\",\".....Q.\",\".Q.....\",\"......Q\",\"....Q..\"],[\"...Q...\",\"Q......\",\"....Q..\",\".Q.....\",\".....Q.\",\"..Q....\",\"......Q\"],[\"...Q...\",\".Q.....\",\"......Q\",\"....Q..\",\"..Q....\",\"Q......\",\".....Q.\"],[\"...Q...\",\".....Q.\",\"Q......\",\"..Q....\",\"....Q..\",\"......Q\",\".Q.....\"],[\"...Q...\",\"......Q\",\"..Q....\",\".....Q.\",\".Q.....\",\"....Q..\",\"Q......\"],[\"...Q...\",\"......Q\",\"....Q..\",\".Q.....\",\".....Q.\",\"Q......\",\"..Q....\"],[\"....Q..\",\"Q......\",\"...Q...\",\"......Q\",\"..Q....\",\".....Q.\",\".Q.....\"],[\"....Q..\",\"Q......\",\".....Q.\",\"...Q...\",\".Q.....\",\"......Q\",\"..Q....\"],[\"....Q..\",\".Q.....\",\".....Q.\",\"..Q....\",\"......Q\",\"...Q...\",\"Q......\"],[\"....Q..\",\"..Q....\",\"Q......\",\".....Q.\",\"...Q...\",\".Q.....\",\"......Q\"],[\"....Q..\",\"......Q\",\".Q.....\",\"...Q...\",\".....Q.\",\"Q......\",\"..Q....\"],[\"....Q..\",\"......Q\",\".Q.....\",\".....Q.\",\"..Q....\",\"Q......\",\"...Q...\"],[\".....Q.\",\"Q......\",\"..Q....\",\"....Q..\",\"......Q\",\".Q.....\",\"...Q...\"],[\".....Q.\",\".Q.....\",\"....Q..\",\"Q......\",\"...Q...\",\"......Q\",\"..Q....\"],[\".....Q.\",\"..Q....\",\"Q......\",\"...Q...\",\"......Q\",\"....Q..\",\".Q.....\"],[\".....Q.\",\"..Q....\",\"....Q..\",\"......Q\",\"Q......\",\"...Q...\",\".Q.....\"],[\".....Q.\",\"..Q....\",\"......Q\",\"...Q...\",\"Q......\",\"....Q..\",\".Q.....\"],[\".....Q.\",\"...Q...\",\".Q.....\",\"......Q\",\"....Q..\",\"..Q....\",\"Q......\"],[\".....Q.\",\"...Q...\",\"......Q\",\"Q......\",\"..Q....\",\"....Q..\",\".Q.....\"],[\"......Q\",\".Q.....\",\"...Q...\",\".....Q.\",\"Q......\",\"..Q....\",\"....Q..\"],[\"......Q\",\"..Q....\",\".....Q.\",\".Q.....\",\"....Q..\",\"Q......\",\"...Q...\"],[\"......Q\",\"...Q...\",\"Q......\",\"....Q..\",\".Q.....\",\".....Q.\",\"..Q....\"],[\"......Q\",\"....Q..\",\"..Q....\",\"Q......\",\".....Q.\",\"...Q...\",\".Q.....\"]],\\n [[\"Q.......\",\"....Q...\",\".......Q\",\".....Q..\",\"..Q.....\",\"......Q.\",\".Q......\",\"...Q....\"],[\"Q.......\",\".....Q..\",\".......Q\",\"..Q.....\",\"......Q.\",\"...Q....\",\".Q......\",\"....Q...\"],[\"Q.......\",\"......Q.\",\"...Q....\",\".....Q..\",\".......Q\",\".Q......\",\"....Q...\",\"..Q.....\"],[\"Q.......\",\"......Q.\",\"....Q...\",\".......Q\",\".Q......\",\"...Q....\",\".....Q..\",\"..Q.....\"],[\".Q......\",\"...Q....\",\".....Q..\",\".......Q\",\"..Q.....\",\"Q.......\",\"......Q.\",\"....Q...\"],[\".Q......\",\"....Q...\",\"......Q.\",\"Q.......\",\"..Q.....\",\".......Q\",\".....Q..\",\"...Q....\"],[\".Q......\",\"....Q...\",\"......Q.\",\"...Q....\",\"Q.......\",\".......Q\",\".....Q..\",\"..Q.....\"],[\".Q......\",\".....Q..\",\"Q.......\",\"......Q.\",\"...Q....\",\".......Q\",\"..Q.....\",\"....Q...\"],[\".Q......\",\".....Q..\",\".......Q\",\"..Q.....\",\"Q.......\",\"...Q....\",\"......Q.\",\"....Q...\"],[\".Q......\",\"......Q.\",\"..Q.....\",\".....Q..\",\".......Q\",\"....Q...\",\"Q.......\",\"...Q....\"],[\".Q......\",\"......Q.\",\"....Q...\",\".......Q\",\"Q.......\",\"...Q....\",\".....Q..\",\"..Q.....\"],[\".Q......\",\".......Q\",\".....Q..\",\"Q.......\",\"..Q.....\",\"....Q...\",\"......Q.\",\"...Q....\"],[\"..Q.....\",\"Q.......\",\"......Q.\",\"....Q...\",\".......Q\",\".Q......\",\"...Q....\",\".....Q..\"],[\"..Q.....\",\"....Q...\",\".Q......\",\".......Q\",\"Q.......\",\"......Q.\",\"...Q....\",\".....Q..\"],[\"..Q.....\",\"....Q...\",\".Q......\",\".......Q\",\".....Q..\",\"...Q....\",\"......Q.\",\"Q.......\"],[\"..Q.....\",\"....Q...\",\"......Q.\",\"Q.......\",\"...Q....\",\".Q......\",\".......Q\",\".....Q..\"],[\"..Q.....\",\"....Q...\",\".......Q\",\"...Q....\",\"Q.......\",\"......Q.\",\".Q......\",\".....Q..\"],[\"..Q.....\",\".....Q..\",\".Q......\",\"....Q...\",\".......Q\",\"Q.......\",\"......Q.\",\"...Q....\"],[\"..Q.....\",\".....Q..\",\".Q......\",\"......Q.\",\"Q.......\",\"...Q....\",\".......Q\",\"....Q...\"],[\"..Q.....\",\".....Q..\",\".Q......\",\"......Q.\",\"....Q...\",\"Q.......\",\".......Q\",\"...Q....\"],[\"..Q.....\",\".....Q..\",\"...Q....\",\"Q.......\",\".......Q\",\"....Q...\",\"......Q.\",\".Q......\"],[\"..Q.....\",\".....Q..\",\"...Q....\",\".Q......\",\".......Q\",\"....Q...\",\"......Q.\",\"Q.......\"],[\"..Q.....\",\".....Q..\",\".......Q\",\"Q.......\",\"...Q....\",\"......Q.\",\"....Q...\",\".Q......\"],[\"..Q.....\",\".....Q..\",\".......Q\",\"Q.......\",\"....Q...\",\"......Q.\",\".Q......\",\"...Q....\"],[\"..Q.....\",\".....Q..\",\".......Q\",\".Q......\",\"...Q....\",\"Q.......\",\"......Q.\",\"....Q...\"],[\"..Q.....\",\"......Q.\",\".Q......\",\".......Q\",\"....Q...\",\"Q.......\",\"...Q....\",\".....Q..\"],[\"..Q.....\",\"......Q.\",\".Q......\",\".......Q\",\".....Q..\",\"...Q....\",\"Q.......\",\"....Q...\"],[\"..Q.....\",\".......Q\",\"...Q....\",\"......Q.\",\"Q.......\",\".....Q..\",\".Q......\",\"....Q...\"],[\"...Q....\",\"Q.......\",\"....Q...\",\".......Q\",\".Q......\",\"......Q.\",\"..Q.....\",\".....Q..\"],[\"...Q....\",\"Q.......\",\"....Q...\",\".......Q\",\".....Q..\",\"..Q.....\",\"......Q.\",\".Q......\"],[\"...Q....\",\".Q......\",\"....Q...\",\".......Q\",\".....Q..\",\"Q.......\",\"..Q.....\",\"......Q.\"],[\"...Q....\",\".Q......\",\"......Q.\",\"..Q.....\",\".....Q..\",\".......Q\",\"Q.......\",\"....Q...\"],[\"...Q....\",\".Q......\",\"......Q.\",\"..Q.....\",\".....Q..\",\".......Q\",\"....Q...\",\"Q.......\"],[\"...Q....\",\".Q......\",\"......Q.\",\"....Q...\",\"Q.......\",\".......Q\",\".....Q..\",\"..Q.....\"],[\"...Q....\",\".Q......\",\".......Q\",\"....Q...\",\"......Q.\",\"Q.......\",\"..Q.....\",\".....Q..\"],[\"...Q....\",\".Q......\",\".......Q\",\".....Q..\",\"Q.......\",\"..Q.....\",\"....Q...\",\"......Q.\"],[\"...Q....\",\".....Q..\",\"Q.......\",\"....Q...\",\".Q......\",\".......Q\",\"..Q.....\",\"......Q.\"],[\"...Q....\",\".....Q..\",\".......Q\",\".Q......\",\"......Q.\",\"Q.......\",\"..Q.....\",\"....Q...\"],[\"...Q....\",\".....Q..\",\".......Q\",\"..Q.....\",\"Q.......\",\"......Q.\",\"....Q...\",\".Q......\"],[\"...Q....\",\"......Q.\",\"Q.......\",\".......Q\",\"....Q...\",\".Q......\",\".....Q..\",\"..Q.....\"],[\"...Q....\",\"......Q.\",\"..Q.....\",\".......Q\",\".Q......\",\"....Q...\",\"Q.......\",\".....Q..\"],[\"...Q....\",\"......Q.\",\"....Q...\",\".Q......\",\".....Q..\",\"Q.......\",\"..Q.....\",\".......Q\"],[\"...Q....\",\"......Q.\",\"....Q...\",\"..Q.....\",\"Q.......\",\".....Q..\",\".......Q\",\".Q......\"],[\"...Q....\",\".......Q\",\"Q.......\",\"..Q.....\",\".....Q..\",\".Q......\",\"......Q.\",\"....Q...\"],[\"...Q....\",\".......Q\",\"Q.......\",\"....Q...\",\"......Q.\",\".Q......\",\".....Q..\",\"..Q.....\"],[\"...Q....\",\".......Q\",\"....Q...\",\"..Q.....\",\"Q.......\",\"......Q.\",\".Q......\",\".....Q..\"],[\"....Q...\",\"Q.......\",\"...Q....\",\".....Q..\",\".......Q\",\".Q......\",\"......Q.\",\"..Q.....\"],[\"....Q...\",\"Q.......\",\".......Q\",\"...Q....\",\".Q......\",\"......Q.\",\"..Q.....\",\".....Q..\"],[\"....Q...\",\"Q.......\",\".......Q\",\".....Q..\",\"..Q.....\",\"......Q.\",\".Q......\",\"...Q....\"],[\"....Q...\",\".Q......\",\"...Q....\",\".....Q..\",\".......Q\",\"..Q.....\",\"Q.......\",\"......Q.\"],[\"....Q...\",\".Q......\",\"...Q....\",\"......Q.\",\"..Q.....\",\".......Q\",\".....Q..\",\"Q.......\"],[\"....Q...\",\".Q......\",\".....Q..\",\"Q.......\",\"......Q.\",\"...Q....\",\".......Q\",\"..Q.....\"],[\"....Q...\",\".Q......\",\".......Q\",\"Q.......\",\"...Q....\",\"......Q.\",\"..Q.....\",\".....Q..\"],[\"....Q...\",\"..Q.....\",\"Q.......\",\".....Q..\",\".......Q\",\".Q......\",\"...Q....\",\"......Q.\"],[\"....Q...\",\"..Q.....\",\"Q.......\",\"......Q.\",\".Q......\",\".......Q\",\".....Q..\",\"...Q....\"],[\"....Q...\",\"..Q.....\",\".......Q\",\"...Q....\",\"......Q.\",\"Q.......\",\".....Q..\",\".Q......\"],[\"....Q...\",\"......Q.\",\"Q.......\",\"..Q.....\",\".......Q\",\".....Q..\",\"...Q....\",\".Q......\"],[\"....Q...\",\"......Q.\",\"Q.......\",\"...Q....\",\".Q......\",\".......Q\",\".....Q..\",\"..Q.....\"],[\"....Q...\",\"......Q.\",\".Q......\",\"...Q....\",\".......Q\",\"Q.......\",\"..Q.....\",\".....Q..\"],[\"....Q...\",\"......Q.\",\".Q......\",\".....Q..\",\"..Q.....\",\"Q.......\",\"...Q....\",\".......Q\"],[\"....Q...\",\"......Q.\",\".Q......\",\".....Q..\",\"..Q.....\",\"Q.......\",\".......Q\",\"...Q....\"],[\"....Q...\",\"......Q.\",\"...Q....\",\"Q.......\",\"..Q.....\",\".......Q\",\".....Q..\",\".Q......\"],[\"....Q...\",\".......Q\",\"...Q....\",\"Q.......\",\"..Q.....\",\".....Q..\",\".Q......\",\"......Q.\"],[\"....Q...\",\".......Q\",\"...Q....\",\"Q.......\",\"......Q.\",\".Q......\",\".....Q..\",\"..Q.....\"],[\".....Q..\",\"Q.......\",\"....Q...\",\".Q......\",\".......Q\",\"..Q.....\",\"......Q.\",\"...Q....\"],[\".....Q..\",\".Q......\",\"......Q.\",\"Q.......\",\"..Q.....\",\"....Q...\",\".......Q\",\"...Q....\"],[\".....Q..\",\".Q......\",\"......Q.\",\"Q.......\",\"...Q....\",\".......Q\",\"....Q...\",\"..Q.....\"],[\".....Q..\",\"..Q.....\",\"Q.......\",\"......Q.\",\"....Q...\",\".......Q\",\".Q......\",\"...Q....\"],[\".....Q..\",\"..Q.....\",\"Q.......\",\".......Q\",\"...Q....\",\".Q......\",\"......Q.\",\"....Q...\"],[\".....Q..\",\"..Q.....\",\"Q.......\",\".......Q\",\"....Q...\",\".Q......\",\"...Q....\",\"......Q.\"],[\".....Q..\",\"..Q.....\",\"....Q...\",\"......Q.\",\"Q.......\",\"...Q....\",\".Q......\",\".......Q\"],[\".....Q..\",\"..Q.....\",\"....Q...\",\".......Q\",\"Q.......\",\"...Q....\",\".Q......\",\"......Q.\"],[\".....Q..\",\"..Q.....\",\"......Q.\",\".Q......\",\"...Q....\",\".......Q\",\"Q.......\",\"....Q...\"],[\".....Q..\",\"..Q.....\",\"......Q.\",\".Q......\",\".......Q\",\"....Q...\",\"Q.......\",\"...Q....\"],[\".....Q..\",\"..Q.....\",\"......Q.\",\"...Q....\",\"Q.......\",\".......Q\",\".Q......\",\"....Q...\"],[\".....Q..\",\"...Q....\",\"Q.......\",\"....Q...\",\".......Q\",\".Q......\",\"......Q.\",\"..Q.....\"],[\".....Q..\",\"...Q....\",\".Q......\",\".......Q\",\"....Q...\",\"......Q.\",\"Q.......\",\"..Q.....\"],[\".....Q..\",\"...Q....\",\"......Q.\",\"Q.......\",\"..Q.....\",\"....Q...\",\".Q......\",\".......Q\"],[\".....Q..\",\"...Q....\",\"......Q.\",\"Q.......\",\".......Q\",\".Q......\",\"....Q...\",\"..Q.....\"],[\".....Q..\",\".......Q\",\".Q......\",\"...Q....\",\"Q.......\",\"......Q.\",\"....Q...\",\"..Q.....\"],[\"......Q.\",\"Q.......\",\"..Q.....\",\".......Q\",\".....Q..\",\"...Q....\",\".Q......\",\"....Q...\"],[\"......Q.\",\".Q......\",\"...Q....\",\"Q.......\",\".......Q\",\"....Q...\",\"..Q.....\",\".....Q..\"],[\"......Q.\",\".Q......\",\".....Q..\",\"..Q.....\",\"Q.......\",\"...Q....\",\".......Q\",\"....Q...\"],[\"......Q.\",\"..Q.....\",\"Q.......\",\".....Q..\",\".......Q\",\"....Q...\",\".Q......\",\"...Q....\"],[\"......Q.\",\"..Q.....\",\".......Q\",\".Q......\",\"....Q...\",\"Q.......\",\".....Q..\",\"...Q....\"],[\"......Q.\",\"...Q....\",\".Q......\",\"....Q...\",\".......Q\",\"Q.......\",\"..Q.....\",\".....Q..\"],[\"......Q.\",\"...Q....\",\".Q......\",\".......Q\",\".....Q..\",\"Q.......\",\"..Q.....\",\"....Q...\"],[\"......Q.\",\"....Q...\",\"..Q.....\",\"Q.......\",\".....Q..\",\".......Q\",\".Q......\",\"...Q....\"],[\".......Q\",\".Q......\",\"...Q....\",\"Q.......\",\"......Q.\",\"....Q...\",\"..Q.....\",\".....Q..\"],[\".......Q\",\".Q......\",\"....Q...\",\"..Q.....\",\"Q.......\",\"......Q.\",\"...Q....\",\".....Q..\"],[\".......Q\",\"..Q.....\",\"Q.......\",\".....Q..\",\".Q......\",\"....Q...\",\"......Q.\",\"...Q....\"],[\".......Q\",\"...Q....\",\"Q.......\",\"..Q.....\",\".....Q..\",\".Q......\",\"......Q.\",\"....Q...\"]],\\n [[\"Q........\",\"..Q......\",\".....Q...\",\".......Q.\",\".Q.......\",\"...Q.....\",\"........Q\",\"......Q..\",\"....Q....\"],[\"Q........\",\"..Q......\",\"......Q..\",\".Q.......\",\".......Q.\",\"....Q....\",\"........Q\",\"...Q.....\",\".....Q...\"],[\"Q........\",\"..Q......\",\".......Q.\",\".....Q...\",\"........Q\",\".Q.......\",\"....Q....\",\"......Q..\",\"...Q.....\"],[\"Q........\",\"...Q.....\",\".Q.......\",\".......Q.\",\".....Q...\",\"........Q\",\"..Q......\",\"....Q....\",\"......Q..\"],[\"Q........\",\"...Q.....\",\".....Q...\",\"..Q......\",\"........Q\",\".Q.......\",\".......Q.\",\"....Q....\",\"......Q..\"],[\"Q........\",\"...Q.....\",\".....Q...\",\".......Q.\",\".Q.......\",\"....Q....\",\"..Q......\",\"........Q\",\"......Q..\"],[\"Q........\",\"...Q.....\",\"......Q..\",\"..Q......\",\".......Q.\",\".Q.......\",\"....Q....\",\"........Q\",\".....Q...\"],[\"Q........\",\"...Q.....\",\"......Q..\",\"........Q\",\".Q.......\",\"....Q....\",\".......Q.\",\".....Q...\",\"..Q......\"],[\"Q........\",\"...Q.....\",\".......Q.\",\"..Q......\",\"........Q\",\"......Q..\",\"....Q....\",\".Q.......\",\".....Q...\"],[\"Q........\",\"....Q....\",\".Q.......\",\".....Q...\",\"........Q\",\"..Q......\",\".......Q.\",\"...Q.....\",\"......Q..\"],[\"Q........\",\"....Q....\",\"......Q..\",\".Q.......\",\".....Q...\",\"..Q......\",\"........Q\",\"...Q.....\",\".......Q.\"],[\"Q........\",\"....Q....\",\"......Q..\",\"........Q\",\"..Q......\",\".......Q.\",\".Q.......\",\"...Q.....\",\".....Q...\"],[\"Q........\",\"....Q....\",\"......Q..\",\"........Q\",\"...Q.....\",\".Q.......\",\".......Q.\",\".....Q...\",\"..Q......\"],[\"Q........\",\"....Q....\",\"........Q\",\".Q.......\",\".....Q...\",\".......Q.\",\"..Q......\",\"......Q..\",\"...Q.....\"],[\"Q........\",\"....Q....\",\"........Q\",\".....Q...\",\"...Q.....\",\".Q.......\",\".......Q.\",\"..Q......\",\"......Q..\"],[\"Q........\",\".....Q...\",\".Q.......\",\"........Q\",\"......Q..\",\"...Q.....\",\".......Q.\",\"..Q......\",\"....Q....\"],[\"Q........\",\".....Q...\",\"...Q.....\",\".Q.......\",\"......Q..\",\"........Q\",\"..Q......\",\"....Q....\",\".......Q.\"],[\"Q........\",\".....Q...\",\"...Q.....\",\".Q.......\",\".......Q.\",\"..Q......\",\"........Q\",\"......Q..\",\"....Q....\"],[\"Q........\",\".....Q...\",\".......Q.\",\"..Q......\",\"......Q..\",\"...Q.....\",\".Q.......\",\"........Q\",\"....Q....\"],[\"Q........\",\".....Q...\",\".......Q.\",\"....Q....\",\".Q.......\",\"...Q.....\",\"........Q\",\"......Q..\",\"..Q......\"],[\"Q........\",\".....Q...\",\"........Q\",\"....Q....\",\".Q.......\",\".......Q.\",\"..Q......\",\"......Q..\",\"...Q.....\"],[\"Q........\",\"......Q..\",\"...Q.....\",\".....Q...\",\"........Q\",\".Q.......\",\"....Q....\",\"..Q......\",\".......Q.\"],[\"Q........\",\"......Q..\",\"...Q.....\",\".......Q.\",\"..Q......\",\"....Q....\",\"........Q\",\".Q.......\",\".....Q...\"],[\"Q........\",\"......Q..\",\"...Q.....\",\".......Q.\",\"..Q......\",\"........Q\",\".....Q...\",\".Q.......\",\"....Q....\"],[\"Q........\",\"......Q..\",\"....Q....\",\".......Q.\",\".Q.......\",\"........Q\",\"..Q......\",\".....Q...\",\"...Q.....\"],[\"Q........\",\".......Q.\",\"...Q.....\",\".Q.......\",\"......Q..\",\"........Q\",\".....Q...\",\"..Q......\",\"....Q....\"],[\"Q........\",\".......Q.\",\"....Q....\",\"..Q......\",\".....Q...\",\"........Q\",\".Q.......\",\"...Q.....\",\"......Q..\"],[\"Q........\",\".......Q.\",\"....Q....\",\"..Q......\",\"........Q\",\"......Q..\",\".Q.......\",\"...Q.....\",\".....Q...\"],[\".Q.......\",\"...Q.....\",\"Q........\",\"......Q..\",\"........Q\",\".....Q...\",\"..Q......\",\"....Q....\",\".......Q.\"],[\".Q.......\",\"...Q.....\",\"......Q..\",\"Q........\",\"..Q......\",\"........Q\",\".....Q...\",\".......Q.\",\"....Q....\"],[\".Q.......\",\"...Q.....\",\".......Q.\",\"..Q......\",\"........Q\",\".....Q...\",\"Q........\",\"....Q....\",\"......Q..\"],[\".Q.......\",\"...Q.....\",\"........Q\",\"......Q..\",\"..Q......\",\"Q........\",\".....Q...\",\".......Q.\",\"....Q....\"],[\".Q.......\",\"...Q.....\",\"........Q\",\"......Q..\",\"....Q....\",\"..Q......\",\"Q........\",\".....Q...\",\".......Q.\"],[\".Q.......\",\"....Q....\",\"......Q..\",\"Q........\",\"..Q......\",\".......Q.\",\".....Q...\",\"...Q.....\",\"........Q\"],[\".Q.......\",\"....Q....\",\"......Q..\",\"...Q.....\",\"Q........\",\"..Q......\",\"........Q\",\".....Q...\",\".......Q.\"],[\".Q.......\",\"....Q....\",\"......Q..\",\"........Q\",\"..Q......\",\".....Q...\",\"...Q.....\",\"Q........\",\".......Q.\"],[\".Q.......\",\"....Q....\",\"......Q..\",\"........Q\",\"...Q.....\",\".......Q.\",\"Q........\",\"..Q......\",\".....Q...\"],[\".Q.......\",\"....Q....\",\".......Q.\",\"Q........\",\"..Q......\",\".....Q...\",\"........Q\",\"......Q..\",\"...Q.....\"],[\".Q.......\",\"....Q....\",\".......Q.\",\"Q........\",\"........Q\",\".....Q...\",\"..Q......\",\"......Q..\",\"...Q.....\"],[\".Q.......\",\"....Q....\",\".......Q.\",\".....Q...\",\"........Q\",\"..Q......\",\"Q........\",\"...Q.....\",\"......Q..\"],[\".Q.......\",\"....Q....\",\".......Q.\",\".....Q...\",\"........Q\",\"..Q......\",\"Q........\",\"......Q..\",\"...Q.....\"],[\".Q.......\",\"....Q....\",\"........Q\",\"...Q.....\",\"Q........\",\".......Q.\",\".....Q...\",\"..Q......\",\"......Q..\"],[\".Q.......\",\".....Q...\",\"Q........\",\"..Q......\",\"......Q..\",\"........Q\",\"...Q.....\",\".......Q.\",\"....Q....\"],[\".Q.......\",\".....Q...\",\"Q........\",\"......Q..\",\"...Q.....\",\".......Q.\",\"..Q......\",\"....Q....\",\"........Q\"],[\".Q.......\",\".....Q...\",\"Q........\",\"......Q..\",\"....Q....\",\"..Q......\",\"........Q\",\"...Q.....\",\".......Q.\"],[\".Q.......\",\".....Q...\",\"Q........\",\"........Q\",\"....Q....\",\".......Q.\",\"...Q.....\",\"......Q..\",\"..Q......\"],[\".Q.......\",\".....Q...\",\"..Q......\",\"Q........\",\".......Q.\",\"...Q.....\",\"........Q\",\"......Q..\",\"....Q....\"],[\".Q.......\",\".....Q...\",\"........Q\",\"..Q......\",\"....Q....\",\".......Q.\",\"...Q.....\",\"Q........\",\"......Q..\"],[\".Q.......\",\"......Q..\",\"....Q....\",\"Q........\",\"........Q\",\"...Q.....\",\".....Q...\",\".......Q.\",\"..Q......\"],[\".Q.......\",\"......Q..\",\"....Q....\",\".......Q.\",\"Q........\",\"...Q.....\",\".....Q...\",\"..Q......\",\"........Q\"],[\".Q.......\",\"......Q..\",\"........Q\",\".....Q...\",\"..Q......\",\"Q........\",\"...Q.....\",\".......Q.\",\"....Q....\"],[\".Q.......\",\".......Q.\",\"Q........\",\"...Q.....\",\"......Q..\",\"........Q\",\".....Q...\",\"..Q......\",\"....Q....\"],[\".Q.......\",\".......Q.\",\"....Q....\",\"..Q......\",\"........Q\",\".....Q...\",\"...Q.....\",\"Q........\",\"......Q..\"],[\".Q.......\",\".......Q.\",\".....Q...\",\"........Q\",\"..Q......\",\"Q........\",\"...Q.....\",\"......Q..\",\"....Q....\"],[\".Q.......\",\"........Q\",\"....Q....\",\"..Q......\",\".......Q.\",\"...Q.....\",\"......Q..\",\"Q........\",\".....Q...\"],[\".Q.......\",\"........Q\",\".....Q...\",\"..Q......\",\"....Q....\",\".......Q.\",\"Q........\",\"...Q.....\",\"......Q..\"],[\".Q.......\",\"........Q\",\".....Q...\",\"..Q......\",\"......Q..\",\"...Q.....\",\"Q........\",\".......Q.\",\"....Q....\"],[\".Q.......\",\"........Q\",\".....Q...\",\"...Q.....\",\"......Q..\",\"Q........\",\"..Q......\",\"....Q....\",\".......Q.\"],[\"..Q......\",\"Q........\",\"...Q.....\",\"......Q..\",\"........Q\",\".Q.......\",\"....Q....\",\".......Q.\",\".....Q...\"],[\"..Q......\",\"Q........\",\".....Q...\",\".......Q.\",\"....Q....\",\".Q.......\",\"...Q.....\",\"........Q\",\"......Q..\"],[\"..Q......\",\"Q........\",\"......Q..\",\".Q.......\",\".......Q.\",\".....Q...\",\"...Q.....\",\"........Q\",\"....Q....\"],[\"..Q......\",\"Q........\",\"......Q..\",\"....Q....\",\".......Q.\",\".Q.......\",\"...Q.....\",\".....Q...\",\"........Q\"],[\"..Q......\",\"Q........\",\".......Q.\",\"...Q.....\",\"........Q\",\"......Q..\",\"....Q....\",\".Q.......\",\".....Q...\"],[\"..Q......\",\"Q........\",\"........Q\",\"......Q..\",\"....Q....\",\".Q.......\",\".......Q.\",\".....Q...\",\"...Q.....\"],[\"..Q......\",\"....Q....\",\".Q.......\",\".......Q.\",\"Q........\",\"...Q.....\",\"......Q..\",\"........Q\",\".....Q...\"],[\"..Q......\",\"....Q....\",\".Q.......\",\".......Q.\",\"Q........\",\"......Q..\",\"...Q.....\",\".....Q...\",\"........Q\"],[\"..Q......\",\"....Q....\",\"......Q..\",\"Q........\",\"...Q.....\",\".Q.......\",\".......Q.\",\".....Q...\",\"........Q\"],[\"..Q......\",\"....Q....\",\".......Q.\",\".Q.......\",\"........Q\",\".....Q...\",\"Q........\",\"......Q..\",\"...Q.....\"],[\"..Q......\",\"....Q....\",\".......Q.\",\".Q.......\",\"........Q\",\"......Q..\",\"Q........\",\"...Q.....\",\".....Q...\"],[\"..Q......\",\"....Q....\",\"........Q\",\".Q.......\",\"...Q.....\",\"......Q..\",\"Q........\",\".......Q.\",\".....Q...\"],[\"..Q......\",\"....Q....\",\"........Q\",\"...Q.....\",\"Q........\",\"......Q..\",\".Q.......\",\".....Q...\",\".......Q.\"],[\"..Q......\",\".....Q...\",\".Q.......\",\"......Q..\",\"Q........\",\"...Q.....\",\".......Q.\",\"....Q....\",\"........Q\"],[\"..Q......\",\".....Q...\",\".Q.......\",\"........Q\",\"....Q....\",\"Q........\",\".......Q.\",\"...Q.....\",\"......Q..\"],[\"..Q......\",\".....Q...\",\".......Q.\",\"Q........\",\"...Q.....\",\"......Q..\",\"....Q....\",\".Q.......\",\"........Q\"],[\"..Q......\",\".....Q...\",\".......Q.\",\"Q........\",\"....Q....\",\"........Q\",\".Q.......\",\"...Q.....\",\"......Q..\"],[\"..Q......\",\".....Q...\",\".......Q.\",\".Q.......\",\"...Q.....\",\"........Q\",\"......Q..\",\"....Q....\",\"Q........\"],[\"..Q......\",\".....Q...\",\".......Q.\",\"....Q....\",\"Q........\",\"........Q\",\"......Q..\",\".Q.......\",\"...Q.....\"],[\"..Q......\",\".....Q...\",\".......Q.\",\"....Q....\",\".Q.......\",\"........Q\",\"......Q..\",\"...Q.....\",\"Q........\"],[\"..Q......\",\".....Q...\",\"........Q\",\"Q........\",\".......Q.\",\"...Q.....\",\".Q.......\",\"......Q..\",\"....Q....\"],[\"..Q......\",\".....Q...\",\"........Q\",\".Q.......\",\"....Q....\",\"......Q..\",\"...Q.....\",\"Q........\",\".......Q.\"],[\"..Q......\",\".....Q...\",\"........Q\",\".Q.......\",\".......Q.\",\"Q........\",\"...Q.....\",\"......Q..\",\"....Q....\"],[\"..Q......\",\".....Q...\",\"........Q\",\"....Q....\",\".......Q.\",\"Q........\",\"...Q.....\",\".Q.......\",\"......Q..\"],[\"..Q......\",\".....Q...\",\"........Q\",\"......Q..\",\"Q........\",\"...Q.....\",\".Q.......\",\"....Q....\",\".......Q.\"],[\"..Q......\",\".....Q...\",\"........Q\",\"......Q..\",\".Q.......\",\"...Q.....\",\".......Q.\",\"Q........\",\"....Q....\"],[\"..Q......\",\".....Q...\",\"........Q\",\"......Q..\",\"...Q.....\",\"Q........\",\".......Q.\",\".Q.......\",\"....Q....\"],[\"..Q......\",\"......Q..\",\".Q.......\",\"...Q.....\",\".......Q.\",\"Q........\",\"....Q....\",\"........Q\",\".....Q...\"],[\"..Q......\",\"......Q..\",\".Q.......\",\".......Q.\",\"....Q....\",\"........Q\",\"Q........\",\".....Q...\",\"...Q.....\"],[\"..Q......\",\"......Q..\",\".Q.......\",\".......Q.\",\".....Q...\",\"...Q.....\",\"Q........\",\"....Q....\",\"........Q\"],[\"..Q......\",\"......Q..\",\"...Q.....\",\".Q.......\",\"........Q\",\"....Q....\",\"Q........\",\".......Q.\",\".....Q...\"],[\"..Q......\",\"......Q..\",\"...Q.....\",\".Q.......\",\"........Q\",\".....Q...\",\"Q........\",\"....Q....\",\".......Q.\"],[\"..Q......\",\"......Q..\",\"...Q.....\",\".......Q.\",\"....Q....\",\"........Q\",\"Q........\",\".....Q...\",\".Q.......\"],[\"..Q......\",\"......Q..\",\"........Q\",\"Q........\",\"....Q....\",\".Q.......\",\".......Q.\",\".....Q...\",\"...Q.....\"],[\"..Q......\",\"......Q..\",\"........Q\",\"...Q.....\",\".Q.......\",\"....Q....\",\".......Q.\",\".....Q...\",\"Q........\"],[\"..Q......\",\".......Q.\",\".Q.......\",\"...Q.....\",\"........Q\",\"......Q..\",\"....Q....\",\"Q........\",\".....Q...\"],[\"..Q......\",\".......Q.\",\"...Q.....\",\"......Q..\",\"........Q\",\".Q.......\",\"....Q....\",\"Q........\",\".....Q...\"],[\"..Q......\",\".......Q.\",\".....Q...\",\"Q........\",\"........Q\",\".Q.......\",\"....Q....\",\"......Q..\",\"...Q.....\"],[\"..Q......\",\".......Q.\",\".....Q...\",\"...Q.....\",\"........Q\",\"Q........\",\"....Q....\",\"......Q..\",\".Q.......\"],[\"..Q......\",\".......Q.\",\".....Q...\",\"........Q\",\".Q.......\",\"....Q....\",\"Q........\",\"...Q.....\",\"......Q..\"],[\"..Q......\",\"........Q\",\".Q.......\",\"....Q....\",\".......Q.\",\"Q........\",\"......Q..\",\"...Q.....\",\".....Q...\"],[\"..Q......\",\"........Q\",\"...Q.....\",\"Q........\",\".......Q.\",\".....Q...\",\".Q.......\",\"......Q..\",\"....Q....\"],[\"..Q......\",\"........Q\",\"...Q.....\",\".Q.......\",\".......Q.\",\".....Q...\",\"Q........\",\"......Q..\",\"....Q....\"],[\"..Q......\",\"........Q\",\"...Q.....\",\".......Q.\",\"....Q....\",\".Q.......\",\".....Q...\",\"Q........\",\"......Q..\"],[\"..Q......\",\"........Q\",\".....Q...\",\".Q.......\",\"....Q....\",\"......Q..\",\"Q........\",\"...Q.....\",\".......Q.\"],[\"..Q......\",\"........Q\",\".....Q...\",\"...Q.....\",\"Q........\",\"......Q..\",\"....Q....\",\".Q.......\",\".......Q.\"],[\"..Q......\",\"........Q\",\".....Q...\",\".......Q.\",\".Q.......\",\"...Q.....\",\"Q........\",\"......Q..\",\"....Q....\"],[\"...Q.....\",\"Q........\",\"..Q......\",\".....Q...\",\"........Q\",\".Q.......\",\".......Q.\",\"....Q....\",\"......Q..\"],[\"...Q.....\",\"Q........\",\"....Q....\",\".Q.......\",\"........Q\",\"......Q..\",\"..Q......\",\".......Q.\",\".....Q...\"],[\"...Q.....\",\"Q........\",\"....Q....\",\".......Q.\",\".Q.......\",\"......Q..\",\"..Q......\",\".....Q...\",\"........Q\"],[\"...Q.....\",\"Q........\",\"....Q....\",\"........Q\",\".Q.......\",\".....Q...\",\".......Q.\",\"..Q......\",\"......Q..\"],[\"...Q.....\",\"Q........\",\"......Q..\",\"........Q\",\".Q.......\",\".....Q...\",\".......Q.\",\"..Q......\",\"....Q....\"],[\"...Q.....\",\"Q........\",\"........Q\",\".....Q...\",\"..Q......\",\"......Q..\",\".Q.......\",\".......Q.\",\"....Q....\"],[\"...Q.....\",\".Q.......\",\"....Q....\",\".......Q.\",\"Q........\",\"..Q......\",\".....Q...\",\"........Q\",\"......Q..\"],[\"...Q.....\",\".Q.......\",\"......Q..\",\"..Q......\",\"Q........\",\".......Q.\",\"....Q....\",\"........Q\",\".....Q...\"],[\"...Q.....\",\".Q.......\",\"......Q..\",\"........Q\",\"Q........\",\"....Q....\",\".......Q.\",\".....Q...\",\"..Q......\"],[\"...Q.....\",\".Q.......\",\"......Q..\",\"........Q\",\"Q........\",\".......Q.\",\"....Q....\",\"..Q......\",\".....Q...\"],[\"...Q.....\",\".Q.......\",\".......Q.\",\"..Q......\",\"........Q\",\"......Q..\",\"....Q....\",\"Q........\",\".....Q...\"],[\"...Q.....\",\".Q.......\",\"........Q\",\"..Q......\",\".....Q...\",\".......Q.\",\"Q........\",\"....Q....\",\"......Q..\"],[\"...Q.....\",\".Q.......\",\"........Q\",\"....Q....\",\"Q........\",\".......Q.\",\".....Q...\",\"..Q......\",\"......Q..\"],[\"...Q.....\",\".....Q...\",\"Q........\",\"....Q....\",\".Q.......\",\".......Q.\",\"..Q......\",\"......Q..\",\"........Q\"],[\"...Q.....\",\".....Q...\",\"Q........\",\"........Q\",\"....Q....\",\".......Q.\",\".Q.......\",\"......Q..\",\"..Q......\"],[\"...Q.....\",\".....Q...\",\"Q........\",\"........Q\",\"......Q..\",\"..Q......\",\".......Q.\",\".Q.......\",\"....Q....\"],[\"...Q.....\",\".....Q...\",\"..Q......\",\"........Q\",\".Q.......\",\"....Q....\",\".......Q.\",\"Q........\",\"......Q..\"],[\"...Q.....\",\".....Q...\",\"..Q......\",\"........Q\",\".Q.......\",\".......Q.\",\"....Q....\",\"......Q..\",\"Q........\"],[\"...Q.....\",\".....Q...\",\"..Q......\",\"........Q\",\"......Q..\",\"Q........\",\".......Q.\",\".Q.......\",\"....Q....\"],[\"...Q.....\",\".....Q...\",\".......Q.\",\".Q.......\",\"....Q....\",\"Q........\",\"........Q\",\"......Q..\",\"..Q......\"],[\"...Q.....\",\".....Q...\",\".......Q.\",\".Q.......\",\"....Q....\",\"......Q..\",\"........Q\",\"Q........\",\"..Q......\"],[\"...Q.....\",\".....Q...\",\".......Q.\",\".Q.......\",\"......Q..\",\"Q........\",\"..Q......\",\"....Q....\",\"........Q\"],[\"...Q.....\",\".....Q...\",\".......Q.\",\"..Q......\",\"Q........\",\"......Q..\",\"....Q....\",\".Q.......\",\"........Q\"],[\"...Q.....\",\".....Q...\",\"........Q\",\"..Q......\",\"Q........\",\".......Q.\",\".Q.......\",\"....Q....\",\"......Q..\"],[\"...Q.....\",\"......Q..\",\"Q........\",\"..Q......\",\"........Q\",\".....Q...\",\".......Q.\",\"....Q....\",\".Q.......\"],[\"...Q.....\",\"......Q..\",\"Q........\",\".....Q...\",\"........Q\",\".Q.......\",\".......Q.\",\"....Q....\",\"..Q......\"],[\"...Q.....\",\"......Q..\",\"Q........\",\".......Q.\",\"....Q....\",\".Q.......\",\"........Q\",\"..Q......\",\".....Q...\"],[\"...Q.....\",\"......Q..\",\"..Q......\",\".....Q...\",\"........Q\",\"Q........\",\".......Q.\",\"....Q....\",\".Q.......\"],[\"...Q.....\",\"......Q..\",\"..Q......\",\".......Q.\",\".Q.......\",\"....Q....\",\"........Q\",\".....Q...\",\"Q........\"],[\"...Q.....\",\"......Q..\",\"..Q......\",\".......Q.\",\".....Q...\",\"Q........\",\"........Q\",\".Q.......\",\"....Q....\"],[\"...Q.....\",\"......Q..\",\"..Q......\",\".......Q.\",\".....Q...\",\".Q.......\",\"........Q\",\"....Q....\",\"Q........\"],[\"...Q.....\",\"......Q..\",\"....Q....\",\".Q.......\",\"........Q\",\"Q........\",\"..Q......\",\".......Q.\",\".....Q...\"],[\"...Q.....\",\"......Q..\",\"....Q....\",\".Q.......\",\"........Q\",\"Q........\",\".....Q...\",\".......Q.\",\"..Q......\"],[\"...Q.....\",\"......Q..\",\"....Q....\",\".Q.......\",\"........Q\",\".....Q...\",\".......Q.\",\"..Q......\",\"Q........\"],[\"...Q.....\",\"......Q..\",\"........Q\",\".Q.......\",\"....Q....\",\".......Q.\",\"Q........\",\"..Q......\",\".....Q...\"],[\"...Q.....\",\"......Q..\",\"........Q\",\".Q.......\",\".....Q...\",\"Q........\",\"..Q......\",\"....Q....\",\".......Q.\"],[\"...Q.....\",\"......Q..\",\"........Q\",\".....Q...\",\"..Q......\",\"Q........\",\".......Q.\",\"....Q....\",\".Q.......\"],[\"...Q.....\",\".......Q.\",\"Q........\",\"....Q....\",\"......Q..\",\".Q.......\",\".....Q...\",\"..Q......\",\"........Q\"],[\"...Q.....\",\".......Q.\",\"....Q....\",\"..Q......\",\"Q........\",\".....Q...\",\".Q.......\",\"........Q\",\"......Q..\"],[\"...Q.....\",\".......Q.\",\"....Q....\",\"..Q......\",\"Q........\",\"......Q..\",\".Q.......\",\".....Q...\",\"........Q\"],[\"...Q.....\",\"........Q\",\"..Q......\",\".....Q...\",\".Q.......\",\"......Q..\",\"....Q....\",\"Q........\",\".......Q.\"],[\"...Q.....\",\"........Q\",\"....Q....\",\"..Q......\",\"Q........\",\".....Q...\",\".......Q.\",\".Q.......\",\"......Q..\"],[\"...Q.....\",\"........Q\",\"....Q....\",\"..Q......\",\"Q........\",\"......Q..\",\".Q.......\",\".......Q.\",\".....Q...\"],[\"...Q.....\",\"........Q\",\"....Q....\",\".......Q.\",\"Q........\",\"..Q......\",\".....Q...\",\".Q.......\",\"......Q..\"],[\"....Q....\",\"Q........\",\".....Q...\",\"...Q.....\",\".Q.......\",\".......Q.\",\"..Q......\",\"........Q\",\"......Q..\"],[\"....Q....\",\"Q........\",\".......Q.\",\"...Q.....\",\".Q.......\",\"......Q..\",\"........Q\",\".....Q...\",\"..Q......\"],[\"....Q....\",\"Q........\",\".......Q.\",\".....Q...\",\"..Q......\",\"......Q..\",\".Q.......\",\"...Q.....\",\"........Q\"],[\"....Q....\",\".Q.......\",\"...Q.....\",\"Q........\",\"......Q..\",\"........Q\",\"..Q......\",\".....Q...\",\".......Q.\"],[\"....Q....\",\".Q.......\",\"...Q.....\",\"........Q\",\"......Q..\",\"..Q......\",\"Q........\",\".....Q...\",\".......Q.\"],[\"....Q....\",\".Q.......\",\".....Q...\",\"Q........\",\"..Q......\",\"......Q..\",\"........Q\",\"...Q.....\",\".......Q.\"],[\"....Q....\",\".Q.......\",\".....Q...\",\"........Q\",\"..Q......\",\".......Q.\",\"...Q.....\",\"......Q..\",\"Q........\"],[\"....Q....\",\".Q.......\",\".....Q...\",\"........Q\",\"......Q..\",\"...Q.....\",\"Q........\",\"..Q......\",\".......Q.\"],[\"....Q....\",\".Q.......\",\".......Q.\",\"Q........\",\"...Q.....\",\"......Q..\",\"........Q\",\".....Q...\",\"..Q......\"],[\"....Q....\",\".Q.......\",\".......Q.\",\"Q........\",\"......Q..\",\"........Q\",\"..Q......\",\".....Q...\",\"...Q.....\"],[\"....Q....\",\".Q.......\",\".......Q.\",\"..Q......\",\"......Q..\",\"...Q.....\",\"Q........\",\"........Q\",\".....Q...\"],[\"....Q....\",\".Q.......\",\".......Q.\",\"..Q......\",\"......Q..\",\"........Q\",\"Q........\",\".....Q...\",\"...Q.....\"],[\"....Q....\",\".Q.......\",\"........Q\",\"Q........\",\".....Q...\",\".......Q.\",\"..Q......\",\"......Q..\",\"...Q.....\"],[\"....Q....\",\".Q.......\",\"........Q\",\".....Q...\",\"..Q......\",\"......Q..\",\"...Q.....\",\"Q........\",\".......Q.\"],[\"....Q....\",\"..Q......\",\"Q........\",\".....Q...\",\".Q.......\",\"........Q\",\"......Q..\",\"...Q.....\",\".......Q.\"],[\"....Q....\",\"..Q......\",\"Q........\",\".....Q...\",\".......Q.\",\".Q.......\",\"...Q.....\",\"......Q..\",\"........Q\"],[\"....Q....\",\"..Q......\",\"Q........\",\"......Q..\",\".Q.......\",\".......Q.\",\".....Q...\",\"...Q.....\",\"........Q\"],[\"....Q....\",\"..Q......\",\".....Q...\",\"........Q\",\".Q.......\",\".......Q.\",\"Q........\",\"...Q.....\",\"......Q..\"],[\"....Q....\",\"..Q......\",\".....Q...\",\"........Q\",\"......Q..\",\"Q........\",\"...Q.....\",\".Q.......\",\".......Q.\"],[\"....Q....\",\"..Q......\",\".....Q...\",\"........Q\",\"......Q..\",\".Q.......\",\"...Q.....\",\".......Q.\",\"Q........\"],[\"....Q....\",\"..Q......\",\".....Q...\",\"........Q\",\"......Q..\",\"...Q.....\",\"Q........\",\".......Q.\",\".Q.......\"],[\"....Q....\",\"..Q......\",\".......Q.\",\"...Q.....\",\".Q.......\",\"........Q\",\".....Q...\",\"Q........\",\"......Q..\"],[\"....Q....\",\"..Q......\",\".......Q.\",\"...Q.....\",\"......Q..\",\"........Q\",\".Q.......\",\".....Q...\",\"Q........\"],[\"....Q....\",\"..Q......\",\".......Q.\",\".....Q...\",\".Q.......\",\"........Q\",\"Q........\",\"...Q.....\",\"......Q..\"],[\"....Q....\",\"..Q......\",\".......Q.\",\".....Q...\",\".Q.......\",\"........Q\",\"......Q..\",\"Q........\",\"...Q.....\"],[\"....Q....\",\"..Q......\",\"........Q\",\"...Q.....\",\".Q.......\",\".......Q.\",\".....Q...\",\"Q........\",\"......Q..\"],[\"....Q....\",\"..Q......\",\"........Q\",\".....Q...\",\".......Q.\",\".Q.......\",\"...Q.....\",\"Q........\",\"......Q..\"],[\"....Q....\",\"......Q..\",\"Q........\",\"...Q.....\",\".Q.......\",\".......Q.\",\".....Q...\",\"........Q\",\"..Q......\"],[\"....Q....\",\"......Q..\",\"Q........\",\".....Q...\",\".......Q.\",\".Q.......\",\"...Q.....\",\"........Q\",\"..Q......\"],[\"....Q....\",\"......Q..\",\".Q.......\",\"...Q.....\",\".......Q.\",\"Q........\",\"..Q......\",\"........Q\",\".....Q...\"],[\"....Q....\",\"......Q..\",\".Q.......\",\"...Q.....\",\".......Q.\",\"Q........\",\"........Q\",\".....Q...\",\"..Q......\"],[\"....Q....\",\"......Q..\",\".Q.......\",\".....Q...\",\"..Q......\",\"Q........\",\".......Q.\",\"...Q.....\",\"........Q\"],[\"....Q....\",\"......Q..\",\".Q.......\",\".....Q...\",\".......Q.\",\"Q........\",\"...Q.....\",\"........Q\",\"..Q......\"],[\"....Q....\",\"......Q..\",\"...Q.....\",\"Q........\",\"..Q......\",\".....Q...\",\"........Q\",\".Q.......\",\".......Q.\"],[\"....Q....\",\"......Q..\",\"...Q.....\",\"Q........\",\"..Q......\",\".......Q.\",\".....Q...\",\".Q.......\",\"........Q\"],[\"....Q....\",\"......Q..\",\"...Q.....\",\"Q........\",\"..Q......\",\"........Q\",\".....Q...\",\".......Q.\",\".Q.......\"],[\"....Q....\",\"......Q..\",\"...Q.....\",\"Q........\",\".......Q.\",\".Q.......\",\"........Q\",\".....Q...\",\"..Q......\"],[\"....Q....\",\"......Q..\",\"........Q\",\"..Q......\",\".......Q.\",\".Q.......\",\"...Q.....\",\".....Q...\",\"Q........\"],[\"....Q....\",\"......Q..\",\"........Q\",\"...Q.....\",\".Q.......\",\".......Q.\",\".....Q...\",\"..Q......\",\"Q........\"],[\"....Q....\",\"......Q..\",\"........Q\",\"...Q.....\",\".......Q.\",\"Q........\",\"..Q......\",\".....Q...\",\".Q.......\"],[\"....Q....\",\".......Q.\",\"Q........\",\"...Q.....\",\"......Q..\",\"..Q......\",\".....Q...\",\"........Q\",\".Q.......\"],[\"....Q....\",\".......Q.\",\"Q........\",\"........Q\",\"...Q.....\",\".Q.......\",\"......Q..\",\"..Q......\",\".....Q...\"],[\"....Q....\",\".......Q.\",\".Q.......\",\"......Q..\",\"..Q......\",\"Q........\",\"........Q\",\"...Q.....\",\".....Q...\"],[\"....Q....\",\".......Q.\",\".Q.......\",\"......Q..\",\"..Q......\",\".....Q...\",\"........Q\",\"Q........\",\"...Q.....\"],[\"....Q....\",\".......Q.\",\".Q.......\",\"........Q\",\"..Q......\",\"Q........\",\"......Q..\",\"...Q.....\",\".....Q...\"],[\"....Q....\",\".......Q.\",\".Q.......\",\"........Q\",\".....Q...\",\"..Q......\",\"Q........\",\"...Q.....\",\"......Q..\"],[\"....Q....\",\".......Q.\",\"...Q.....\",\"Q........\",\"..Q......\",\".....Q...\",\"........Q\",\"......Q..\",\".Q.......\"],[\"....Q....\",\".......Q.\",\"...Q.....\",\"Q........\",\"......Q..\",\".Q.......\",\".....Q...\",\"..Q......\",\"........Q\"],[\"....Q....\",\".......Q.\",\"...Q.....\",\"........Q\",\"......Q..\",\"..Q......\",\"Q........\",\".....Q...\",\".Q.......\"],[\"....Q....\",\".......Q.\",\".....Q...\",\"Q........\",\"..Q......\",\"......Q..\",\"........Q\",\"...Q.....\",\".Q.......\"],[\"....Q....\",\".......Q.\",\".....Q...\",\"........Q\",\"..Q......\",\"Q........\",\"......Q..\",\"...Q.....\",\".Q.......\"],[\"....Q....\",\"........Q\",\".Q.......\",\"...Q.....\",\"......Q..\",\"..Q......\",\".......Q.\",\".....Q...\",\"Q........\"],[\"....Q....\",\"........Q\",\".Q.......\",\".....Q...\",\".......Q.\",\"..Q......\",\"Q........\",\"...Q.....\",\"......Q..\"],[\"....Q....\",\"........Q\",\"...Q.....\",\".....Q...\",\".......Q.\",\".Q.......\",\"......Q..\",\"Q........\",\"..Q......\"],[\".....Q...\",\"Q........\",\"....Q....\",\".Q.......\",\"........Q\",\"......Q..\",\"...Q.....\",\".......Q.\",\"..Q......\"],[\".....Q...\",\"Q........\",\"....Q....\",\"......Q..\",\"........Q\",\"..Q......\",\".......Q.\",\".Q.......\",\"...Q.....\"],[\".....Q...\",\"Q........\",\"....Q....\",\"......Q..\",\"........Q\",\"...Q.....\",\".Q.......\",\".......Q.\",\"..Q......\"],[\".....Q...\",\"Q........\",\"......Q..\",\"...Q.....\",\".......Q.\",\"..Q......\",\"....Q....\",\"........Q\",\".Q.......\"],[\".....Q...\",\".Q.......\",\"....Q....\",\"......Q..\",\"........Q\",\"..Q......\",\".......Q.\",\"...Q.....\",\"Q........\"],[\".....Q...\",\".Q.......\",\"....Q....\",\"......Q..\",\"........Q\",\"...Q.....\",\".......Q.\",\"Q........\",\"..Q......\"],[\".....Q...\",\".Q.......\",\"........Q\",\"....Q....\",\"..Q......\",\".......Q.\",\"...Q.....\",\"......Q..\",\"Q........\"],[\".....Q...\",\"..Q......\",\"Q........\",\"...Q.....\",\"......Q..\",\"........Q\",\".Q.......\",\"....Q....\",\".......Q.\"],[\".....Q...\",\"..Q......\",\"Q........\",\".......Q.\",\"...Q.....\",\"........Q\",\"......Q..\",\"....Q....\",\".Q.......\"],[\".....Q...\",\"..Q......\",\"Q........\",\".......Q.\",\"....Q....\",\".Q.......\",\"........Q\",\"......Q..\",\"...Q.....\"],[\".....Q...\",\"..Q......\",\"....Q....\",\".......Q.\",\"Q........\",\"...Q.....\",\".Q.......\",\"......Q..\",\"........Q\"],[\".....Q...\",\"..Q......\",\"....Q....\",\".......Q.\",\"Q........\",\"........Q\",\"...Q.....\",\".Q.......\",\"......Q..\"],[\".....Q...\",\"..Q......\",\"....Q....\",\".......Q.\",\"Q........\",\"........Q\",\"......Q..\",\".Q.......\",\"...Q.....\"],[\".....Q...\",\"..Q......\",\"......Q..\",\".Q.......\",\"...Q.....\",\".......Q.\",\"Q........\",\"....Q....\",\"........Q\"],[\".....Q...\",\"..Q......\",\"......Q..\",\".Q.......\",\"...Q.....\",\"........Q\",\"Q........\",\".......Q.\",\"....Q....\"],[\".....Q...\",\"..Q......\",\"......Q..\",\".Q.......\",\".......Q.\",\"....Q....\",\"Q........\",\"...Q.....\",\"........Q\"],[\".....Q...\",\"..Q......\",\"......Q..\",\"...Q.....\",\"Q........\",\"........Q\",\".Q.......\",\"....Q....\",\".......Q.\"],[\".....Q...\",\"..Q......\",\"........Q\",\".Q.......\",\"....Q....\",\".......Q.\",\"Q........\",\"......Q..\",\"...Q.....\"],[\".....Q...\",\"..Q......\",\"........Q\",\"...Q.....\",\"Q........\",\".......Q.\",\".Q.......\",\"....Q....\",\"......Q..\"],[\".....Q...\",\"..Q......\",\"........Q\",\"......Q..\",\"Q........\",\"...Q.....\",\".Q.......\",\"....Q....\",\".......Q.\"],[\".....Q...\",\"...Q.....\",\"Q........\",\"......Q..\",\"........Q\",\".Q.......\",\".......Q.\",\"....Q....\",\"..Q......\"],[\".....Q...\",\"...Q.....\",\".Q.......\",\"......Q..\",\"........Q\",\"..Q......\",\"....Q....\",\".......Q.\",\"Q........\"],[\".....Q...\",\"...Q.....\",\".Q.......\",\".......Q.\",\"..Q......\",\"........Q\",\"......Q..\",\"....Q....\",\"Q........\"],[\".....Q...\",\"...Q.....\",\".Q.......\",\".......Q.\",\"....Q....\",\"..Q......\",\"Q........\",\"........Q\",\"......Q..\"],[\".....Q...\",\"...Q.....\",\".Q.......\",\".......Q.\",\"....Q....\",\"........Q\",\"Q........\",\"..Q......\",\"......Q..\"],[\".....Q...\",\"...Q.....\",\"......Q..\",\"Q........\",\"..Q......\",\"........Q\",\".Q.......\",\".......Q.\",\"....Q....\"],[\".....Q...\",\"...Q.....\",\"......Q..\",\"Q........\",\".......Q.\",\".Q.......\",\"....Q....\",\"..Q......\",\"........Q\"],[\".....Q...\",\"...Q.....\",\"......Q..\",\"Q........\",\".......Q.\",\"....Q....\",\".Q.......\",\"........Q\",\"..Q......\"],[\".....Q...\",\"...Q.....\",\"........Q\",\"Q........\",\"..Q......\",\"......Q..\",\".Q.......\",\".......Q.\",\"....Q....\"],[\".....Q...\",\"...Q.....\",\"........Q\",\"Q........\",\"....Q....\",\".Q.......\",\".......Q.\",\"..Q......\",\"......Q..\"],[\".....Q...\",\"...Q.....\",\"........Q\",\"....Q....\",\".......Q.\",\".Q.......\",\"......Q..\",\"..Q......\",\"Q........\"],[\".....Q...\",\".......Q.\",\"Q........\",\"....Q....\",\"........Q\",\".Q.......\",\"...Q.....\",\"......Q..\",\"..Q......\"],[\".....Q...\",\".......Q.\",\"Q........\",\"......Q..\",\"...Q.....\",\".Q.......\",\"........Q\",\"....Q....\",\"..Q......\"],[\".....Q...\",\".......Q.\",\".Q.......\",\"......Q..\",\"Q........\",\"..Q......\",\"....Q....\",\"........Q\",\"...Q.....\"],[\".....Q...\",\".......Q.\",\"..Q......\",\"Q........\",\"........Q\",\".Q.......\",\"....Q....\",\"......Q..\",\"...Q.....\"],[\".....Q...\",\".......Q.\",\"..Q......\",\"Q........\",\"........Q\",\"....Q....\",\".Q.......\",\"...Q.....\",\"......Q..\"],[\".....Q...\",\".......Q.\",\"..Q......\",\"......Q..\",\"........Q\",\".Q.......\",\"....Q....\",\"Q........\",\"...Q.....\"],[\".....Q...\",\".......Q.\",\"....Q....\",\".Q.......\",\"........Q\",\"......Q..\",\"...Q.....\",\"Q........\",\"..Q......\"],[\".....Q...\",\"........Q\",\"Q........\",\"...Q.....\",\"......Q..\",\"..Q......\",\".......Q.\",\".Q.......\",\"....Q....\"],[\".....Q...\",\"........Q\",\"..Q......\",\"Q........\",\".......Q.\",\"...Q.....\",\".Q.......\",\"......Q..\",\"....Q....\"],[\".....Q...\",\"........Q\",\"....Q....\",\"Q........\",\".......Q.\",\"...Q.....\",\".Q.......\",\"......Q..\",\"..Q......\"],[\".....Q...\",\"........Q\",\"....Q....\",\".Q.......\",\".......Q.\",\"..Q......\",\"......Q..\",\"...Q.....\",\"Q........\"],[\".....Q...\",\"........Q\",\"....Q....\",\".......Q.\",\"Q........\",\"..Q......\",\"......Q..\",\".Q.......\",\"...Q.....\"],[\".....Q...\",\"........Q\",\"......Q..\",\"...Q.....\",\"Q........\",\".......Q.\",\".Q.......\",\"....Q....\",\"..Q......\"],[\"......Q..\",\"Q........\",\"...Q.....\",\".Q.......\",\".......Q.\",\".....Q...\",\"........Q\",\"..Q......\",\"....Q....\"],[\"......Q..\",\"Q........\",\"...Q.....\",\".....Q...\",\"........Q\",\"..Q......\",\"....Q....\",\".......Q.\",\".Q.......\"],[\"......Q..\",\"Q........\",\"...Q.....\",\".......Q.\",\"....Q....\",\"..Q......\",\"........Q\",\".....Q...\",\".Q.......\"],[\"......Q..\",\"Q........\",\".....Q...\",\".Q.......\",\"....Q....\",\".......Q.\",\"...Q.....\",\"........Q\",\"..Q......\"],[\"......Q..\",\"Q........\",\".....Q...\",\".......Q.\",\".Q.......\",\"...Q.....\",\"........Q\",\"..Q......\",\"....Q....\"],[\"......Q..\",\"Q........\",\".....Q...\",\"........Q\",\".Q.......\",\"...Q.....\",\".......Q.\",\"..Q......\",\"....Q....\"],[\"......Q..\",\"Q........\",\".......Q.\",\"....Q....\",\".Q.......\",\"........Q\",\"..Q......\",\".....Q...\",\"...Q.....\"],[\"......Q..\",\".Q.......\",\"...Q.....\",\"Q........\",\".......Q.\",\"....Q....\",\"........Q\",\".....Q...\",\"..Q......\"],[\"......Q..\",\".Q.......\",\"...Q.....\",\".....Q...\",\"Q........\",\"........Q\",\"....Q....\",\"..Q......\",\".......Q.\"],[\"......Q..\",\".Q.......\",\"...Q.....\",\"........Q\",\"Q........\",\".......Q.\",\"....Q....\",\"..Q......\",\".....Q...\"],[\"......Q..\",\".Q.......\",\".....Q...\",\"..Q......\",\"Q........\",\".......Q.\",\"....Q....\",\"........Q\",\"...Q.....\"],[\"......Q..\",\".Q.......\",\".......Q.\",\".....Q...\",\"Q........\",\"..Q......\",\"....Q....\",\"........Q\",\"...Q.....\"],[\"......Q..\",\"..Q......\",\"Q........\",\".....Q...\",\".......Q.\",\"....Q....\",\".Q.......\",\"...Q.....\",\"........Q\"],[\"......Q..\",\"..Q......\",\"Q........\",\"........Q\",\"....Q....\",\".......Q.\",\".Q.......\",\"...Q.....\",\".....Q...\"],[\"......Q..\",\"..Q......\",\".....Q...\",\".Q.......\",\"....Q....\",\"Q........\",\"........Q\",\"...Q.....\",\".......Q.\"],[\"......Q..\",\"..Q......\",\".....Q...\",\".......Q.\",\"Q........\",\"...Q.....\",\"........Q\",\"....Q....\",\".Q.......\"],[\"......Q..\",\"..Q......\",\".....Q...\",\".......Q.\",\"Q........\",\"....Q....\",\"........Q\",\".Q.......\",\"...Q.....\"],[\"......Q..\",\"..Q......\",\".......Q.\",\".Q.......\",\"...Q.....\",\".....Q...\",\"........Q\",\"....Q....\",\"Q........\"],[\"......Q..\",\"..Q......\",\".......Q.\",\".Q.......\",\"....Q....\",\"Q........\",\"........Q\",\"...Q.....\",\".....Q...\"],[\"......Q..\",\"..Q......\",\".......Q.\",\".....Q...\",\".Q.......\",\"........Q\",\"....Q....\",\"Q........\",\"...Q.....\"],[\"......Q..\",\"...Q.....\",\"Q........\",\"..Q......\",\".....Q...\",\"........Q\",\".Q.......\",\".......Q.\",\"....Q....\"],[\"......Q..\",\"...Q.....\",\"Q........\",\"..Q......\",\".......Q.\",\".....Q...\",\".Q.......\",\"........Q\",\"....Q....\"],[\"......Q..\",\"...Q.....\",\"Q........\",\"..Q......\",\"........Q\",\".....Q...\",\".......Q.\",\"....Q....\",\".Q.......\"],[\"......Q..\",\"...Q.....\",\"Q........\",\"....Q....\",\".Q.......\",\"........Q\",\".....Q...\",\".......Q.\",\"..Q......\"],[\"......Q..\",\"...Q.....\",\"Q........\",\".......Q.\",\".Q.......\",\"........Q\",\".....Q...\",\"..Q......\",\"....Q....\"],[\"......Q..\",\"...Q.....\",\"Q........\",\".......Q.\",\"....Q....\",\"..Q......\",\".....Q...\",\"........Q\",\".Q.......\"],[\"......Q..\",\"...Q.....\",\"Q........\",\"........Q\",\".Q.......\",\".....Q...\",\".......Q.\",\"..Q......\",\"....Q....\"],[\"......Q..\",\"...Q.....\",\".Q.......\",\"....Q....\",\".......Q.\",\"Q........\",\"..Q......\",\".....Q...\",\"........Q\"],[\"......Q..\",\"...Q.....\",\".Q.......\",\"....Q....\",\"........Q\",\"Q........\",\"..Q......\",\".......Q.\",\".....Q...\"],[\"......Q..\",\"...Q.....\",\".Q.......\",\".......Q.\",\".....Q...\",\"Q........\",\"..Q......\",\"....Q....\",\"........Q\"],[\"......Q..\",\"...Q.....\",\".Q.......\",\"........Q\",\"....Q....\",\"Q........\",\".......Q.\",\".....Q...\",\"..Q......\"],[\"......Q..\",\"...Q.....\",\".Q.......\",\"........Q\",\".....Q...\",\"..Q......\",\"....Q....\",\".......Q.\",\"Q........\"],[\"......Q..\",\"...Q.....\",\".......Q.\",\"Q........\",\"....Q....\",\"........Q\",\".Q.......\",\".....Q...\",\"..Q......\"],[\"......Q..\",\"...Q.....\",\".......Q.\",\"..Q......\",\"........Q\",\".....Q...\",\".Q.......\",\"....Q....\",\"Q........\"],[\"......Q..\",\"....Q....\",\"Q........\",\".....Q...\",\"........Q\",\"..Q......\",\".......Q.\",\"...Q.....\",\".Q.......\"],[\"......Q..\",\"....Q....\",\"Q........\",\".......Q.\",\".....Q...\",\"..Q......\",\"........Q\",\".Q.......\",\"...Q.....\"],[\"......Q..\",\"....Q....\",\".Q.......\",\".......Q.\",\"Q........\",\"..Q......\",\"........Q\",\".....Q...\",\"...Q.....\"],[\"......Q..\",\"....Q....\",\".Q.......\",\".......Q.\",\"Q........\",\"...Q.....\",\"........Q\",\"..Q......\",\".....Q...\"],[\"......Q..\",\"....Q....\",\"..Q......\",\"........Q\",\".....Q...\",\".......Q.\",\".Q.......\",\"...Q.....\",\"Q........\"],[\"......Q..\",\"....Q....\",\".......Q.\",\".Q.......\",\"........Q\",\"..Q......\",\".....Q...\",\"...Q.....\",\"Q........\"],[\"......Q..\",\"....Q....\",\".......Q.\",\".Q.......\",\"........Q\",\".....Q...\",\"..Q......\",\"Q........\",\"...Q.....\"],[\"......Q..\",\"........Q\",\"Q........\",\"..Q......\",\"....Q....\",\".......Q.\",\".Q.......\",\"...Q.....\",\".....Q...\"],[\"......Q..\",\"........Q\",\".Q.......\",\".....Q...\",\"Q........\",\"..Q......\",\"....Q....\",\".......Q.\",\"...Q.....\"],[\"......Q..\",\"........Q\",\"..Q......\",\"....Q....\",\".Q.......\",\".......Q.\",\".....Q...\",\"...Q.....\",\"Q........\"],[\"......Q..\",\"........Q\",\"..Q......\",\".......Q.\",\".Q.......\",\"...Q.....\",\".....Q...\",\"Q........\",\"....Q....\"],[\"......Q..\",\"........Q\",\"...Q.....\",\".Q.......\",\"....Q....\",\".......Q.\",\".....Q...\",\"Q........\",\"..Q......\"],[\"......Q..\",\"........Q\",\".....Q...\",\"..Q......\",\"Q........\",\".......Q.\",\"....Q....\",\".Q.......\",\"...Q.....\"],[\".......Q.\",\"Q........\",\"...Q.....\",\".....Q...\",\"..Q......\",\"........Q\",\"......Q..\",\"....Q....\",\".Q.......\"],[\".......Q.\",\"Q........\",\"...Q.....\",\"......Q..\",\"..Q......\",\".....Q...\",\"........Q\",\".Q.......\",\"....Q....\"],[\".......Q.\",\"Q........\",\"...Q.....\",\"......Q..\",\"....Q....\",\".Q.......\",\"........Q\",\".....Q...\",\"..Q......\"],[\".......Q.\",\"Q........\",\"....Q....\",\"......Q..\",\".Q.......\",\".....Q...\",\"..Q......\",\"........Q\",\"...Q.....\"],[\".......Q.\",\".Q.......\",\"...Q.....\",\"Q........\",\"......Q..\",\"........Q\",\".....Q...\",\"..Q......\",\"....Q....\"],[\".......Q.\",\".Q.......\",\"....Q....\",\"......Q..\",\"Q........\",\"...Q.....\",\".....Q...\",\"........Q\",\"..Q......\"],[\".......Q.\",\".Q.......\",\"........Q\",\".....Q...\",\"..Q......\",\"Q........\",\"...Q.....\",\"......Q..\",\"....Q....\"],[\".......Q.\",\"..Q......\",\"Q........\",\"...Q.....\",\"......Q..\",\"........Q\",\".....Q...\",\".Q.......\",\"....Q....\"],[\".......Q.\",\"..Q......\",\"....Q....\",\".Q.......\",\"........Q\",\".....Q...\",\"...Q.....\",\"......Q..\",\"Q........\"],[\".......Q.\",\"..Q......\",\"....Q....\",\"........Q\",\"Q........\",\".....Q...\",\"...Q.....\",\".Q.......\",\"......Q..\"],[\".......Q.\",\"...Q.....\",\"Q........\",\"......Q..\",\"....Q....\",\".Q.......\",\".....Q...\",\"........Q\",\"..Q......\"],[\".......Q.\",\"...Q.....\",\"......Q..\",\"........Q\",\".Q.......\",\".....Q...\",\"Q........\",\"..Q......\",\"....Q....\"],[\".......Q.\",\"...Q.....\",\"........Q\",\"Q........\",\"....Q....\",\".Q.......\",\".....Q...\",\"..Q......\",\"......Q..\"],[\".......Q.\",\"...Q.....\",\"........Q\",\"..Q......\",\"....Q....\",\"......Q..\",\"Q........\",\".....Q...\",\".Q.......\"],[\".......Q.\",\"...Q.....\",\"........Q\",\"..Q......\",\".....Q...\",\".Q.......\",\"......Q..\",\"....Q....\",\"Q........\"],[\".......Q.\",\"...Q.....\",\"........Q\",\"......Q..\",\"..Q......\",\"Q........\",\".....Q...\",\".Q.......\",\"....Q....\"],[\".......Q.\",\"....Q....\",\"Q........\",\".....Q...\",\"........Q\",\".Q.......\",\"...Q.....\",\"......Q..\",\"..Q......\"],[\".......Q.\",\"....Q....\",\".Q.......\",\"...Q.....\",\"Q........\",\"......Q..\",\"........Q\",\"..Q......\",\".....Q...\"],[\".......Q.\",\"....Q....\",\".Q.......\",\"...Q.....\",\"Q........\",\"......Q..\",\"........Q\",\".....Q...\",\"..Q......\"],[\".......Q.\",\"....Q....\",\".Q.......\",\"........Q\",\"Q........\",\"...Q.....\",\"......Q..\",\"..Q......\",\".....Q...\"],[\".......Q.\",\"....Q....\",\".Q.......\",\"........Q\",\"......Q..\",\"...Q.....\",\"Q........\",\"..Q......\",\".....Q...\"],[\".......Q.\",\"....Q....\",\"..Q......\",\"Q........\",\".....Q...\",\".Q.......\",\"........Q\",\"......Q..\",\"...Q.....\"],[\".......Q.\",\"....Q....\",\"..Q......\",\"Q........\",\"......Q..\",\"...Q.....\",\".....Q...\",\"........Q\",\".Q.......\"],[\".......Q.\",\"....Q....\",\"..Q......\",\".....Q...\",\"........Q\",\"......Q..\",\"Q........\",\"...Q.....\",\".Q.......\"],[\".......Q.\",\"....Q....\",\"..Q......\",\"........Q\",\"......Q..\",\".Q.......\",\"...Q.....\",\".....Q...\",\"Q........\"],[\".......Q.\",\".....Q...\",\"Q........\",\"..Q......\",\"....Q....\",\"......Q..\",\"........Q\",\"...Q.....\",\".Q.......\"],[\".......Q.\",\".....Q...\",\"Q........\",\"..Q......\",\"......Q..\",\"........Q\",\"...Q.....\",\".Q.......\",\"....Q....\"],[\".......Q.\",\".....Q...\",\".Q.......\",\"......Q..\",\"Q........\",\"...Q.....\",\"........Q\",\"....Q....\",\"..Q......\"],[\".......Q.\",\".....Q...\",\"..Q......\",\"........Q\",\"......Q..\",\"Q........\",\"...Q.....\",\".Q.......\",\"....Q....\"],[\".......Q.\",\".....Q...\",\"........Q\",\"..Q......\",\"Q........\",\"...Q.....\",\"......Q..\",\"....Q....\",\".Q.......\"],[\"........Q\",\".Q.......\",\"....Q....\",\"......Q..\",\"Q........\",\"..Q......\",\".......Q.\",\".....Q...\",\"...Q.....\"],[\"........Q\",\".Q.......\",\"....Q....\",\"......Q..\",\"...Q.....\",\"Q........\",\".......Q.\",\".....Q...\",\"..Q......\"],[\"........Q\",\".Q.......\",\".....Q...\",\".......Q.\",\"..Q......\",\"Q........\",\"...Q.....\",\"......Q..\",\"....Q....\"],[\"........Q\",\"..Q......\",\"....Q....\",\".Q.......\",\".......Q.\",\"Q........\",\"......Q..\",\"...Q.....\",\".....Q...\"],[\"........Q\",\"..Q......\",\".....Q...\",\".Q.......\",\"......Q..\",\"Q........\",\"...Q.....\",\".......Q.\",\"....Q....\"],[\"........Q\",\"..Q......\",\".....Q...\",\".Q.......\",\"......Q..\",\"....Q....\",\"Q........\",\".......Q.\",\"...Q.....\"],[\"........Q\",\"..Q......\",\".....Q...\",\"...Q.....\",\"Q........\",\".......Q.\",\"....Q....\",\"......Q..\",\".Q.......\"],[\"........Q\",\"...Q.....\",\"Q........\",\"....Q....\",\".......Q.\",\".Q.......\",\"......Q..\",\"..Q......\",\".....Q...\"],[\"........Q\",\"...Q.....\",\".Q.......\",\"....Q....\",\".......Q.\",\".....Q...\",\"Q........\",\"..Q......\",\"......Q..\"],[\"........Q\",\"...Q.....\",\".Q.......\",\"......Q..\",\"..Q......\",\".....Q...\",\".......Q.\",\"Q........\",\"....Q....\"],[\"........Q\",\"...Q.....\",\".....Q...\",\".......Q.\",\".Q.......\",\"......Q..\",\"Q........\",\"..Q......\",\"....Q....\"],[\"........Q\",\"...Q.....\",\".....Q...\",\".......Q.\",\"..Q......\",\"Q........\",\"......Q..\",\"....Q....\",\".Q.......\"],[\"........Q\",\"...Q.....\",\".......Q.\",\"Q........\",\"..Q......\",\".....Q...\",\".Q.......\",\"......Q..\",\"....Q....\"],[\"........Q\",\"....Q....\",\"Q........\",\"...Q.....\",\".....Q...\",\".......Q.\",\".Q.......\",\"......Q..\",\"..Q......\"],[\"........Q\",\"....Q....\",\"Q........\",\".......Q.\",\"...Q.....\",\".Q.......\",\"......Q..\",\"..Q......\",\".....Q...\"],[\"........Q\",\"....Q....\",\"..Q......\",\"Q........\",\".....Q...\",\".......Q.\",\".Q.......\",\"...Q.....\",\"......Q..\"],[\"........Q\",\"....Q....\",\"..Q......\",\"Q........\",\"......Q..\",\".Q.......\",\".......Q.\",\".....Q...\",\"...Q.....\"],[\"........Q\",\"....Q....\",\"..Q......\",\".......Q.\",\"...Q.....\",\"......Q..\",\"Q........\",\".....Q...\",\".Q.......\"],[\"........Q\",\"....Q....\",\".......Q.\",\"...Q.....\",\"Q........\",\"......Q..\",\".Q.......\",\".....Q...\",\"..Q......\"],[\"........Q\",\".....Q...\",\".Q.......\",\"......Q..\",\"Q........\",\"..Q......\",\"....Q....\",\".......Q.\",\"...Q.....\"],[\"........Q\",\".....Q...\",\"..Q......\",\"Q........\",\".......Q.\",\"....Q....\",\".Q.......\",\"...Q.....\",\"......Q..\"],[\"........Q\",\".....Q...\",\"..Q......\",\"......Q..\",\".Q.......\",\".......Q.\",\"....Q....\",\"Q........\",\"...Q.....\"],[\"........Q\",\".....Q...\",\"...Q.....\",\".Q.......\",\".......Q.\",\"....Q....\",\"......Q..\",\"Q........\",\"..Q......\"],[\"........Q\",\".....Q...\",\"...Q.....\",\"......Q..\",\"Q........\",\".......Q.\",\".Q.......\",\"....Q....\",\"..Q......\"],[\"........Q\",\".....Q...\",\".......Q.\",\".Q.......\",\"...Q.....\",\"Q........\",\"......Q..\",\"....Q....\",\"..Q......\"],[\"........Q\",\"......Q..\",\".Q.......\",\"...Q.....\",\"Q........\",\".......Q.\",\"....Q....\",\"..Q......\",\".....Q...\"],[\"........Q\",\"......Q..\",\"..Q......\",\".......Q.\",\".Q.......\",\"....Q....\",\"Q........\",\".....Q...\",\"...Q.....\"],[\"........Q\",\"......Q..\",\"...Q.....\",\".Q.......\",\".......Q.\",\".....Q...\",\"Q........\",\"..Q......\",\"....Q....\"]]\\n ][n]\\n #return [0, 1, 0, 0, 2, 10, 4, 40, 92, 352, 724, 2680,14200, 73712, 365596][n]\\n return self.dfs(deque(), 0, n)\\n def dfs(self,", "gt": "points, x,n):\\n res = []\\n # print(x, n, points)\\n for j in range(n):\\n n_pos = (x, j)\\n if passAll(n_pos, points):\\n points.append(j)\\n if len(points) == n:\\n res.append(reconstruct(points, n))\\n else:\\n res += self.dfs(points, x + 1, n)\\n points.pop()\\n return res\\n \\n \\n \\n \\n # class Solution:\\n # def totalNQueens(self, n):\\n # \"\"\"\\n # :type n: int\\n # :rtype: int\\n # \"\"\"\\n # return self.dfs([], 0, n)\\n # def dfs(self, points, x,n):\\n # res = []\\n # # print(x, n, points)\\n # for j in range(n):\\n # n_pos = (x, j)\\n # if passAll(n_pos, points):\\n # n_points = deepcopy(points)\\n # n_points.append(n_pos)\\n # if len(n_points) == n - 1:\\n # res.append(reconstruct(n_points, n))\\n # else:\\n # res += self.dfs(n_points, x + 1, n)\\n # return res\\n \\n \\n"}
{"id": "1893", "input": "# Definition for a binary tree node.\\n # class TreeNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.left = None\\n # self.right = None\\n \\n class Solution:\\n def pathSum(self, root, sum):\\n \"\"\"\\n :type root: TreeNode\\n :type sum: int\\n :rtype: List[List[int]]\\n \"\"\"\\n ans = []\\n buffer = []\\n self.helper(ans, root, sum, buffer)\\n return ans\\n def helper(self, ans, root, sum, buffer):\\n \"\"\"\\n recursive method travesal to", "gt": "the bottom of the tree\\n and add the path that path's sum equals the given sum into the result\\n \\n :type ans: List[List[int]]\\n :type root: TreeNode\\n :type sum: int\\n :type buffer: List[int]\\n :rtype None\\n \"\"\"\\n if not root: return\\n sum -= root.val\\n buffer.append(root.val)\\n if not (root.left or root.right) and sum == 0: ans.append([x for x in buffer])\\n self.helper(ans, root.left, sum, buffer)\\n self.helper(ans, root.right, sum, buffer)\\n buffer.pop()"}
{"id": "1894", "input": "class Solution:\\n def isValidSudoku(self, board):\\n \"\"\"\\n :type board: List[List[str]]\\n :rtype: bool\\n \"\"\"\\n dic_row = [{},{},{},{},{},{},{},{},{}]\\n dic_col = [{},{},{},{},{},{},{},{},{}]\\n dic_box = [{},{},{},{},{},{},{},{},{}]\\n \\n for i in range(len(board)):\\n for j in range(len(board)):\\n num = board[i][j]\\n if", "gt": "num == \".\":\\n continue\\n if num not in dic_row[i] and num not in dic_col[j] and num not in dic_box[3*(i//3)+(j//3)]:\\n dic_row[i][num] = 1\\n dic_col[j][num] = 1\\n dic_box[3*(i//3)+(j//3)][num] = 1\\n else:\\n return False\\n \\n return True\\n \\n"}
{"id": "1895", "input": "# Definition for singly-linked list.\\n # class ListNode(object):\\n # def __init__(self, x):\\n # self.val = x\\n # self.next = None\\n \\n class Solution(object):\\n def splitListToParts(self, root, k):\\n \"\"\"\\n :type root: ListNode\\n :type k: int\\n :rtype: List[ListNode]\\n \"\"\"\\n if not root:\\n return [None for _ in range(k)]\\n \\n if k == 1:\\n return [root]\\n \\n count_nodes = 1\\n start = root\\n while start.next:\\n start = start.next\\n count_nodes += 1\\n \\n buckets = [0 for _ in range(k)]\\n for i in range(len(buckets)):\\n import math\\n \\n curr = math.ceil(count_nodes", "gt": "/ k)\\n count_nodes -= curr\\n k -= 1\\n buckets[i] = curr\\n \\n if count_nodes == 0:\\n break\\n \\n def split_ll(root, result, index, buckets):\\n if index == len(buckets):\\n return\\n if not root:\\n result.append(None)\\n return split_ll(root, result, index + 1, buckets)\\n \\n end = root\\n curr_count = 1\\n while curr_count < buckets[index]:\\n end = end.next\\n curr_count += 1\\n \\n start = root\\n root = end.next\\n end.next = None\\n \\n result.append(start)\\n return split_ll(root, result, index + 1, buckets)\\n \\n result = []\\n split_ll(root, result, 0, buckets)\\n return result\\n \\n"}
{"id": "1896", "input": "class Solution:\\n def validTicTacToe(self, board):\\n \"\"\"\\n :type board: List[str]\\n :rtype: bool\\n \"\"\"\\n def win(board,w):\\n for i in range(3):\\n if board[i] == w*3:\\n return True\\n for i in range(3):\\n if board[0][i] == w and board[1][i] == w and board[2][i] == w:\\n return True\\n sign = True\\n for i in range(3):\\n if board[i][i] != w:\\n sign = False\\n if sign:\\n return True\\n \\n sign = True\\n for i in range(3):\\n if board[i][2-i] != w:\\n sign", "gt": "= False\\n if sign:\\n return True\\n \\n Xnum = 0\\n Onum = 0\\n for ss in board:\\n for s in ss:\\n if s == 'X':\\n Xnum += 1\\n if s == 'O':\\n Onum += 1\\n if win(board,'X'):\\n if Xnum == Onum + 1:\\n return True\\n else:\\n return False\\n if win(board,\"O\"):\\n if Xnum == Onum:\\n return True\\n else:\\n return False\\n if Xnum == Onum or Xnum == Onum + 1:\\n return True\\n else:\\n return False\\n"}
{"id": "1897", "input": "from heapq import heappush, heappop\\n \\n class Solution:\\n def kSmallestPairs(self, nums1, nums2, k):\\n \"\"\"\\n :type nums1: List[int]\\n :type nums2: List[int]\\n :type k: int\\n :rtype: List[List[int]]\\n \"\"\"\\n heap = []\\n def push(i, j):\\n if i < len(nums1)", "gt": "and j < len(nums2):\\n heappush(heap, (nums1[i] + nums2[j], i, j))\\n push(0,0)\\n res = []\\n while heap and len(res) < k:\\n _, i, j = heappop(heap)\\n res.append([nums1[i], nums2[j]])\\n push(i, j+1)\\n if j == 0:\\n push(i+1, 0)\\n return res"}
{"id": "1898", "input": "from itertools import accumulate\\nclass Solution:\\n def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\\n xors", "gt": "= [0]\\n for a in arr:\\n xors.append(a^xors[-1])\\n return [xors[i]^xors[j+1] for i,j in queries]\\n \\n"}
{"id": "1899", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nclass Solution:\\n def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\\n ans, to_delete = [], set(to_delete)\\n", "gt": "def search(root, is_root):\\n if not root: return None\\n root_deleted = root.val in to_delete\\n if is_root and not root_deleted:\\n ans.append(root)\\n root.left = search(root.left, root_deleted)\\n root.right = search(root.right, root_deleted)\\n return None if root_deleted else root\\n search(root, True)\\n return ans"}
{"id": "1900", "input": "class Solution:\\n def shortestBridge(self, A: List[List[int]]) -> int:\\n m, n = len(A), len(A[0])\\n dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n queue = deque()\\n boundary = set()\\n found = False\\n for i in range(m):\\n for j in range(n):\\n if A[i][j] == 1:\\n A[i][j] = 2\\n queue.append((i, j))\\n while queue:\\n ci, cj = queue.popleft()\\n for di, dj in dirs:\\n ni, nj = ci + di, cj + dj\\n if 0 <= ni < m and 0 <= nj < n:\\n if", "gt": "A[ni][nj] == 1:\\n A[ni][nj] = 2\\n queue.append((ni, nj))\\n elif A[ni][nj] == 0:\\n boundary.add((ci, cj))\\n found = True\\n break\\n if found:\\n break\\n \\n queue = deque(boundary)\\n steps = 0\\n while queue:\\n for _ in range(len(queue)):\\n i, j = queue.popleft()\\n for di, dj in dirs:\\n ni, nj = i + di, j + dj\\n if 0 <= ni < m and 0 <= nj < n:\\n if A[ni][nj] == 0:\\n A[ni][nj] = 2\\n queue.append((ni, nj))\\n elif A[ni][nj] == 1:\\n return steps\\n steps += 1"}
{"id": "1901", "input": "class Solution:\\n def widthOfBinaryTree(self, root):\\n \"\"\"\\n :type root: TreeNode\\n :rtype: int\\n \"\"\"\\n if not root:\\n return 0\\n s=1\\n a=[[root,1]]\\n while", "gt": "1:\\n b=[]\\n for p in a:\\n if p[0].left:\\n b.append([p[0].left,2*p[1]-1])\\n if p[0].right:\\n b.append([p[0].right,2*p[1]])\\n a=b\\n if a:\\n s=max(s,a[-1][1]-a[0][1]+1)\\n else:\\n break\\n return s"}
{"id": "1902", "input": "class Solution:\\n def largestIsland(self, grid: List[List[int]]) -> int:\\n directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n for i in range(len(grid)):\\n grid[i].insert(0, 0)\\n grid[i].append(0)\\n grid.insert(0, [0 for i in range(len(grid[0]))])\\n grid.append([0 for i in range(len(grid[0]))])\\n islands = []\\n max_length = 1\\n for i in range(1, len(grid) - 1):\\n for j in range(1, len(grid[0]) - 1):\\n if grid[i][j] != 1:\\n continue\\n island_id = len(islands)\\n length = 0\\n connect_length = 0\\n queue = [(i, j)]\\n grid[i][j] = 2 + island_id\\n while queue:\\n x, y = queue.pop()\\n for dx, dy", "gt": "in directions:\\n this_grid = grid[x + dx][y + dy]\\n if this_grid == 1:\\n grid[x + dx][y + dy] = 2 + island_id\\n queue.append((x + dx, y + dy))\\n elif isinstance(this_grid, list):\\n new_connect = 0\\n already = False\\n for old_island_id in this_grid:\\n if old_island_id != island_id:\\n new_connect += islands[old_island_id]\\n else:\\n already = True\\n if not already:\\n connect_length = max(connect_length, new_connect)\\n this_grid.append(island_id)\\n else:\\n grid[x + dx][y + dy] = [island_id]\\n length += 1\\n islands.append(length)\\n max_length = max(max_length, length + connect_length + 1)\\n return min(max_length, (len(grid) - 2) * (len(grid[0]) - 2))"}
{"id": "1903", "input": "class Solution:\\n def sequentialDigits(self, low: int, high: int) -> List[int]:\\n l=len(str(low))\\n f=len(str(high))\\n s=len(str(low)[0])\\n a=[]\\n for i in range(l,f+1):\\n while True:\\n", "gt": "t=''\\n if i+s>10:\\n break\\n for j in range(s,i+s):\\n t+=str(j)\\n if int(t)>high:\\n break\\n if int(t)<low:\\n s+=1\\n continue\\n s+=1\\n a.append(t)\\n s=1\\n return a"}
{"id": "1904", "input": "class Solution:\\n def minCostConnectPoints(self, points: List[List[int]]) -> int:\\n n = len(points)\\n dist = [float(\\\"inf\\\")] * n\\n remain = set()\\n for i in range(0,n):\\n remain.add(i)\\n dist[0] = 0\\n remain.discard(0)\\n curr = 0\\n res = 0\\n while len(remain) > 0:\\n lo = float(\\\"inf\\\")\\n loind = -1\\n # curr is the next lowest\\n a,b", "gt": "= points[curr]\\n for r in remain:\\n x,y = points[r]\\n tempdist = abs(x-a) + abs(y-b)\\n if tempdist < dist[r]:\\n dist[r] = tempdist\\n tempdist = dist[r]\\n \\n if tempdist < lo:\\n lo = tempdist\\n loind = r\\n \\n res += lo\\n \\n curr = loind\\n # remove curr from remain\\n remain.discard(curr)\\n \\n return res\\n"}
{"id": "1905", "input": "class Solution:\\n def kClosest(self, points: List[List[int]], K: int) ->", "gt": "List[List[int]]:\\n points.sort(key = lambda x: x[0]*x[0] + x[1]*x[1])\\n return points[:K]"}
{"id": "1906", "input": "from math import sqrt\\n class Solution:\\n def largestDivisibleSubset(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: List[int]\\n \"\"\"\\n nums.sort()\\n l, prev = {}, {} # length, previous number(largest divisor in nums)\\n max_l, end_number = 0, None\\n \\n for i in nums:\\n tmp_l, tmp_prev = 0, None\\n for j in range(1, 1 + int(sqrt(i))):\\n if i % j == 0:\\n tmp = i // j\\n", "gt": "if tmp in prev and l[tmp] > tmp_l:\\n tmp_l, tmp_prev = l[tmp], tmp\\n if j in prev and l[j] > tmp_l:\\n tmp_l, tmp_prev = l[j], j \\n \\n tmp_l += 1\\n prev[i], l[i] = tmp_prev, tmp_l\\n \\n if tmp_l > max_l:\\n max_l, end_number = tmp_l, i\\n \\n ans = []\\n while end_number is not None:\\n ans.append(end_number)\\n end_number = prev[end_number]\\n \\n return ans"}
{"id": "1907", "input": "class Solution:\\n def reconstructQueue(self, people):\\n \"\"\"\\n :type people: List[List[int]]\\n :rtype: List[List[int]]\\n \"\"\"\\n people.sort(key = lambda", "gt": "x: (-x[0], x[1]))\\n queue = []\\n for p in people:\\n queue.insert(p[1], p)\\n return queue\\n \\n"}
{"id": "1908", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, x):\\n# self.val = x\\n# self.left = None\\n# self.right = None\\n\\nclass Solution:\\n def getTargetCopy(self, original: TreeNode,", "gt": "cloned: TreeNode, target: TreeNode) -> TreeNode:\\n def getnode(root):\\n if not root:\\n return None\\n elif root.val == target.val:\\n return root\\n else:\\n return getnode(root.left) or getnode(root.right)\\n return getnode(cloned)"}
{"id": "1909", "input": "# Definition for a binary tree node.\\n # class TreeNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.left = None\\n # self.right = None\\n \\n class Solution:\\n def countNodes(self, root):\\n \"\"\"\\n :type root: TreeNode\\n :rtype: int\\n \"\"\"\\n node = root\\n depth = 0\\n while node:\\n depth += 1\\n node = node.left\\n \\n if depth <= 1:\\n return depth\\n \\n lo, hi = 0, 2**(depth-2)\\n while lo < hi:\\n l = depth-3\\n mi = (lo+hi)//2\\n node = root\\n", "gt": "while l >= 0:\\n d = mi & 2**l\\n node = node.right if d > 0 else node.left\\n l -= 1\\n if node.left and node.right:\\n lo = mi+1\\n elif not node.left and not node.right:\\n hi = mi\\n else:\\n break\\n l, node = depth-3, root\\n while l >= 0:\\n d = mi & 2**l\\n node = node.right if d > 0 else node.left\\n l -= 1\\n return 2**(depth-1)-1 + 2*mi + int(node.left is not None) + int(node.right is not None)"}
{"id": "1910", "input": "class Solution:\\n def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\\n rows = len(grid)\\n cols = len(grid[0])\\n memo = [[0 for j in range(cols)] for i in range(rows)]\\n ans = 0\\n \\n if grid[0][0] == 1:\\n memo[0][0] = (1,1)\\n ans = 1\\n else:\\n memo[0][0] = (0,0)\\n \\n for i in range(1,rows):\\n if grid[i][0] == 0:\\n memo[i][0] = (0,0)\\n else:\\n memo[i][0] = (memo[i-1][0][0]+1,1)\\n ans = 1\\n \\n for j in", "gt": "range(1,cols):\\n if grid[0][j] == 0:\\n memo[0][j] = (0,0)\\n else:\\n memo[0][j] = (1,memo[0][j-1][1]+1)\\n ans = 1\\n \\n for i in range(1,rows):\\n for j in range(1,cols):\\n if grid[i][j] == 0:\\n memo[i][j] = (0,0)\\n else:\\n memo[i][j] = (memo[i-1][j][0]+1, memo[i][j-1][1]+1)\\n ans = 1\\n \\n for i in range(rows-1,0,-1):\\n for j in range(cols-1,0,-1):\\n l_min = min(memo[i][j][0],memo[i][j][1])\\n \\n while l_min>ans:\\n if memo[i][j-l_min+1][0]>=l_min and memo[i-l_min+1][j][1]>=l_min:\\n ans = l_min\\n l_min -= 1\\n return ans*ans\\n"}
{"id": "1911", "input": "# Definition for singly-linked list.\\n # class ListNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.next = None\\n \\n class Solution:\\n def kth(self, v, k):\\n for i in range(k-1):\\n if not v:\\n return None\\n v=v.next\\n return v\\n \\n def reverseKGroup(self, head, k):\\n \"\"\"\\n :type head: ListNode\\n", "gt": ":type k: int\\n :rtype: ListNode\\n \"\"\"\\n if k==1:\\n return head\\n kthnode=self.kth(head, k)\\n v=head\\n head=kthnode if kthnode else head\\n i=0\\n tmphead=v\\n while kthnode:\\n vprev=kthnode.next\\n for i in range(k):\\n v.next, v, vprev = vprev, v.next, v\\n kthnode=None if not kthnode else kthnode.next\\n tmphead.next=kthnode if kthnode else v\\n tmphead=v\\n return head"}
{"id": "1912", "input": "# Definition for singly-linked list.\\n # class ListNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.next = None\\n \\n class Solution:\\n def sortList(self, head):\\n \"\"\"\\n :type head: ListNode\\n :rtype:", "gt": "ListNode\\n \"\"\"\\n arr = []\\n p = head\\n while p:\\n arr.append(p.val)\\n p = p.next\\n \\n arr.sort()\\n p = head\\n for el in arr:\\n p.val = el\\n p = p.next\\n \\n return head"}
{"id": "1913", "input": "class Solution:\\n def nextGreatestLetter(self, letters, target):\\n \"\"\"\\n :type letters: List[str]\\n :type target: str\\n :rtype: str\\n \"\"\"\\n \\n if ord(letters[-1]) <= ord(target):\\n return letters[0]\\n \\n li = 0\\n ri = len(letters) - 1\\n", "gt": "\\n while li <= ri:\\n if li == ri:\\n return letters[li]\\n \\n mi = li + (ri - li)//2\\n \\n if ord(letters[mi]) > ord(target):\\n ri = mi\\n else:\\n li = mi + 1"}
{"id": "1914", "input": "class Solution:\\n def prevPermOpt1(self, A: List[int]) -> List[int]:\\n n = len(A)\\n if n == 1: return A\\n \\n tidx = -1\\n for i in range(n-2, -1, -1):\\n if A[i] > A[i+1]:\\n tidx = i\\n break\\n \\n if", "gt": "tidx < 0: return A\\n \\n sidx = -1\\n for j in range(n-1, tidx, -1):\\n if A[j] == A[j-1]: continue\\n if A[j] < A[tidx]: \\n sidx = j\\n break\\n \\n A[tidx], A[sidx] = A[sidx], A[tidx]\\n \\n return A"}
{"id": "1915", "input": "class Solution:\\n def twoCitySchedCost(self, costs: List[List[int]]) -> int:\\n dcosts = sorted(costs, key=lambda i: i[0] - i[1])\\n n = len(costs)", "gt": "// 2\\n acost = sum(c[0] for c in dcosts[:n])\\n bcost = sum(c[1] for c in dcosts[n:])\\n return acost + bcost"}
{"id": "1916", "input": "'''\\n\\\"aabcaca\\\"\\n 0123456\\n x\\n \\ndevide conquer\\n先找到第一个stamp把string分成左右两部分（必须要）（On\\n然后从长到短用stamp的头match左边的部分，直到match到最头 如果不能到最头则退出\\n从长到短用stamp的尾巴match右边，直到match到尾巴，如果不能match到最尾巴 则 继续找下一个stamp\\n能把他分成左右\\n这时的左边有个offset了，比如****b** offset是3，只要stamp的长度不超过头且能match上，就可以\\n\\n这个解法可以有nwin*M^2 其中m平方是在用stamp去match的时候最坏能从stamp最长match到1\\n可以给出最短match路径\\n\\n\\n'''\\nclass Solution:\\n def movesToStamp(self, stamp: str, target: str) -> List[int]:\\n ans = []\\n offset = 0\\n while target!='':\\n x = target.find(stamp)\\n if x==-1:\\n return []\\n ans.append(x+offset)\\n \\n can_stamp,indices = self.moveLeft(stamp,target[:x],offset)\\n if not can_stamp:\\n return []\\n ans.extend(indices)\\n \\n offset,target,indices = self.moveRight(stamp,target[x+len(stamp):],\\n offset+x+len(stamp))\\n ans.extend(indices)\\n \\n return ans[::-1]\\n \\n \\n \\n def moveLeft(self,stamp,s,offset):\\n", "gt": "ans = []\\n while s:\\n for ind in range(1,len(stamp)):\\n additional = 0\\n if ind>len(s):\\n if offset == 0:\\n continue\\n \\n additional = ind - len(s)\\n \\n if stamp[additional:ind]==s[-ind:]:\\n ans.append(offset+len(s)-ind)\\n s=s[:-ind]\\n break\\n else:\\n return False,[]\\n return True,ans\\n \\n \\n def moveRight(self,stamp,s,offset):\\n ans = []\\n while s:\\n for ind in range(1,len(stamp)):\\n if stamp[-ind:]==s[:ind]:\\n ans.append(offset+ind-len(stamp))\\n offset+=ind\\n s=s[ind:]\\n break\\n else:\\n return offset,s,ans\\n return offset,s,ans\\n"}
{"id": "1917", "input": "# Definition for a binary tree node.\\n # class TreeNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.left = None\\n # self.right = None\\n \\n class Solution:\\n def currentmax(self,root):\\n leftval = 0\\n if root.left != None:\\n leftval = self.currentmax(root.left)\\n leftval = 0 if leftval < 0 else leftval\\n rightval = 0\\n if root.right != None:\\n rightval =", "gt": "self.currentmax(root.right)\\n rightval = 0 if rightval < 0 else rightval\\n currentnode = leftval + rightval + root.val\\n if self.flag == 0:\\n self.ans = currentnode\\n self.flag = 1\\n else:\\n self.ans = self.ans if self.ans > currentnode else currentnode\\n return root.val + (leftval if leftval > rightval else rightval)\\n def maxPathSum(self, root):\\n self.ans = 0\\n self.flag = 0\\n self.currentmax(root)\\n return self.ans"}
{"id": "1918", "input": "class Solution(object):\\n loc=0\\n lastloc=-1\\n f=''\\n def getNext(self,formular,locked=False):\\n stype=0 # 0:null, 1:numeric, 2/20: Elem, 3: parenthesis\\n ret=0\\n if self.loc==self.lastloc: return (0,0)\\n i=self.loc\\n while i <len(formular):\\n if stype in (0,1) and formular[i].isnumeric():\\n ret=int(formular[i])+ret*10\\n stype=1\\n elif stype==0 and formular[i].isupper():\\n stype=20\\n ret=formular[i]\\n elif stype in (20,2) and formular[i].islower():\\n stype=2\\n ret+=formular[i]\\n elif stype==0 and formular[i] in \"()\":\\n stype=3+\"()\".index(formular[i])\\n ret=formular[i]\\n else: break\\n", "gt": "i+=1\\n if not locked:\\n self.lastloc=self.loc\\n self.loc=i\\n return (stype,ret)\\n \\n def countOfAtoms(self, formula):\\n stk=[]\\n cnt="}
{"id": "1919", "input": "from collections import defaultdict\\n \\n class Solution:\\n def findItinerary(self, tickets):\\n \"\"\"\\n :type tickets: List[List[str]]\\n :rtype: List[str]\\n \"\"\"\\n \\n graph = defaultdict(list)\\n for from_, to_ in tickets:\\n graph[from_].append(to_)\\n \\n for each", "gt": "in graph:\\n graph[each].sort()\\n \\n res = []\\n self.dfs(graph, \"JFK\", res)\\n return res[::-1]\\n \\n \\n def dfs(self, graph, from_, results):\\n \\n while graph[from_]:\\n curr = graph[from_].pop(0)\\n self.dfs(graph, curr, results)\\n \\n results.append(from_)"}
{"id": "1920", "input": "class Solution:\\n def findOrder(self, numCourses, prerequisites):\\n \"\"\"\\n :type numCourses: int\\n :type prerequisites: List[List[int]]\\n :rtype: List[int]\\n \"\"\"\\n n = numCourses \\n graph = {}\\n for post, pre in prerequisites:\\n if pre in graph:\\n graph[pre].append(post)\\n else:\\n graph[pre] = [post]\\n \\n WHITE = 0 # never explored. NOT CHECKED\\n GREY = 1 # in the stack, exploring. CHECKING\\n BLACK = 2 # finished explored and we know for a fact there's", "gt": "no loop originated from this. CHECKED\\n state = [WHITE for _ in range(0, n)]\\n \\n res = []\\n \\n def dfs(i):\\n state[i] = GREY\\n for child in graph.get(i, []):\\n if state[child] == GREY:\\n return False\\n elif state[child] == WHITE:\\n if not dfs(child):\\n return False\\n state[i] = BLACK\\n res.insert(0, i)\\n return True\\n \\n for i in range(0, n):\\n if state[i] != BLACK:\\n if not dfs(i):\\n return []\\n return res\\n"}
{"id": "1921", "input": "class TimeMap:\\n\\n def __init__(self):\\n \\\"\\\"\\\"\\n Initialize your data structure here.\\n \\\"\\\"\\\"\\n self.store = {}\\n self.times = {}\\n\\n def set(self, key: str, value: str, timestamp: int) -> None:\\n if key not in self.store: \\n self.store[key] = [value]\\n self.times[key] = [timestamp]\\n else:\\n self.store[key].append(value)\\n self.times[key].append(timestamp)\\n \\n\\n def get(self, key: str, timestamp: int) -> str:\\n if key not in self.store: return \\\"\\\"\\n else:\\n lst = self.times[key]\\n \\n if", "gt": "timestamp < lst[0]: return \\\"\\\"\\n elif timestamp >=lst[-1]: return self.store[key][-1]\\n else:\\n l = 0\\n r = len(lst)-1\\n while l < r:\\n mid = (l+r)//2\\n if lst[mid] < timestamp: r = mid\\n elif lst[mid] == timestamp: return self.store[key][mid]\\n else: l = mid\\n \\n \\n \\n return self.store[key][r]\\n \\n\\n\\n# Your TimeMap object will be instantiated and called as such:\\n# obj = TimeMap()\\n# obj.set(key,value,timestamp)\\n# param_2 = obj.get(key,timestamp)"}
{"id": "1922", "input": "from heapq import heapify, heappush, heappop \\nclass DinnerPlates:\\n # index * cap -> access start of stack at index\\n # index * cap + (cap - 1) -> access last element of stack at index\\n \\n def __init__(self, capacity: int):\\n self.stack = [] # just one array to simulate all the stacks\\n self.cap = capacity \\n self.idx = [] # min-heap to track empty indicies\\n \\n def push(self, val: int) -> None:\\n if len(self.idx) > 0:\\n while len(self.idx) > 0:\\n i = heappop(self.idx) \\n # Given that we just push index but don't validate the cache while\\n # poping we need to check if this index is within current limits\\n if i < len(self.stack):\\n self.stack[i] = val\\n return \\n \\n # we didn't find empty spaces so we add to the end\\n self.stack.append(val)\\n\\n def pop(self) -> int:\\n n = len(self.stack) - 1\\n if n < 0:\\n return -1\\n \\n while n > -1:\\n if self.stack[n] != -1:\\n v = self.stack[n]\\n self.stack[n] = -1\\n # Add the empty index to the heap\\n heappush(self.idx , n)\\n return v\\n", "gt": "else:\\n # Because those appear at the end the list we free those memory spaces so\\n # later pop operations are optimized\\n del(self.stack[n])\\n n -= 1\\n \\n # All stacks are empty\\n return -1\\n \\n \\n\\n def popAtStack(self, index: int) -> int:\\n # additional check that is [optional] just to skip any effort \\n # if index is already out of current limits\\n count = len(self.stack) // self.cap\\n if index > count:\\n return -1\\n \\n # capture the boundaries of this stack\\n leftptr = (index * self.cap) \\n rightptr = leftptr + self.cap - 1\\n if rightptr > (len(self.stack) - 1): # edge case\\n rightptr = (len(self.stack) - 1)\\n \\n # traverse within the stack at this index until we empty it or we find an occupied location \\n while self.stack[rightptr] == -1 and rightptr >= leftptr:\\n rightptr -=1\\n \\n # if it isn't empty it means we found occupied position\\n if rightptr >= leftptr:\\n v = self.stack[rightptr]\\n self.stack[rightptr] = -1\\n # Add the empty index to the heap\\n heappush(self.idx , rightptr)\\n return v\\n else:\\n return -1\\n"}
{"id": "1923", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nclass Solution:\\n def minCameraCover(self, root: TreeNode) -> int:\\n \\n def dfs(node):\\n if not node:\\n return 2\\n left =", "gt": "dfs(node.left)\\n right = dfs(node.right)\\n \\n if left == 0 or right == 0:\\n self.res += 1\\n return 1\\n if left == 1 or right == 1:\\n return 2\\n else:\\n return 0\\n \\n self.res = 0\\n return (dfs(root) == 0) + self.res\\n\\n"}
{"id": "1924", "input": "class Solution:\\n def countSmaller(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: List[int]\\n \"\"\"\\n s = sorted(nums)\\n", "gt": "c = []\\n for n in nums:\\n p = bisect.bisect_left(s, n)\\n c.append(p)\\n s.pop(p)\\n return c\\n"}
{"id": "1925", "input": "class Transaction:\\n def __init__(self, name, time, amount, city):\\n self.name = name\\n self.time = int(time)\\n self.amount = int(amount)\\n self.city = city\\n \\n def array(self):\\n return f\\\"{self.name},{self.time},{self.amount},{self.city}\\\"\\n\\nfrom collections import defaultdict\\nclass Solution:\\n def invalidTransactions(self, transactions):\\n transactions = [Transaction(*transaction.split(',')) for transaction in transactions]\\n transactions.sort(key=lambda t: t.time) # O(nlogn) time\\n\\n trans_indexes = defaultdict(list)\\n for i, t in enumerate(transactions): # O(n) time\\n trans_indexes[t.name].append(i)\\n\\n res = []\\n for name, indexes in trans_indexes.items(): # O(n) time\\n", "gt": "left = right = 0\\n for i, t_index in enumerate(indexes):\\n t = transactions[t_index]\\n if (t.amount > 1000):\\n res.append(\\\""}
{"id": "1926", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nclass Solution:\\n def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n # time O(n); space O(n)\\n", "gt": "vals = deque(preorder)\\n \\n def build(min_val, max_val):\\n if vals and min_val < vals[0] < max_val:\\n val = vals.popleft()\\n node = TreeNode(val)\\n node.left = build(min_val, val)\\n node.right = build(val, max_val)\\n \\n return node\\n \\n return build(float('-inf'), float('inf'))"}
{"id": "1927", "input": "import collections\\nimport itertools\\n\\n\\ndef prime_factors(n):\\n i = 2\\n while i * i <= n:\\n if n % i == 0:\\n n /= i\\n yield i\\n else:\\n i += 1\\n\\n if n > 1:\\n yield n\\n\\n\\ndef prod(iterable):\\n result = 1\\n for i in iterable:\\n result *= i\\n return result\\n\\n\\ndef get_divisors(n):\\n pf = prime_factors(n)\\n\\n pf_with_multiplicity = collections.Counter(pf)\\n\\n powers = [\\n [factor ** i for i in range(count + 1)]\\n for factor, count in", "gt": "list(pf_with_multiplicity.items())\\n ]\\n\\n for prime_power_combo in itertools.product(*powers):\\n yield prod(prime_power_combo)\\n\\nclass Solution:\\n def closestDivisors(self, num: int) -> List[int]:\\n d1 = sorted(list(get_divisors(num+1)))\\n d2 = sorted(list(get_divisors(num+2)))\\n \\n if len(d1) % 2 == 1:\\n mid = d1[int((len(d1) - 1)/2)]\\n return [int(mid), int(mid)]\\n \\n if len(d2) % 2 == 1:\\n mid = d2[int((len(d2) - 1)/2)]\\n return [int(mid), int(mid)]\\n \\n l1, r1 = d1[int(len(d1)/2)],d1[int(len(d1)/2)-1]\\n l2, r2 = d2[int(len(d2)/2)],d2[int(len(d2)/2)-1]\\n \\n if abs(l1-r1) < abs(l2-r2):\\n return [int(l1),int(r1)]\\n else:\\n return [int(l2),int(r2)]\\n"}
{"id": "1928", "input": "class Solution:\\n def asteroidCollision(self, asteroids):\\n \"\"\"\\n :type asteroids: List[int]\\n :rtype: List[int]\\n \"\"\"\\n l=len(asteroids)\\n if l<2:\\n return asteroids\\n ans=[]\\n stack=[]\\n for a in asteroids:\\n if a>0:\\n stack.append(a)\\n", "gt": "else:\\n a=-a\\n equal_flag=False\\n while stack:\\n cur=stack.pop() \\n if cur==a:\\n equal_flag=True\\n break\\n elif cur>a:\\n stack.append(cur)\\n break \\n if equal_flag:\\n continue \\n if not stack:\\n ans.append(-a)\\n return ans+stack\\n \\n"}
{"id": "1929", "input": "# \"\"\"\\n # This is the interface that allows for creating nested lists.\\n # You should not implement it, or speculate about its implementation\\n # \"\"\"\\n #class NestedInteger:\\n # def __init__(self, value=None):\\n # \"\"\"\\n # If value is not specified, initializes an empty list.\\n # Otherwise initializes a single integer equal to value.\\n # \"\"\"\\n #\\n # def isInteger(self):\\n # \"\"\"\\n # @return True if this NestedInteger holds a single integer, rather than a nested list.\\n # :rtype bool\\n # \"\"\"\\n #\\n # def add(self, elem):\\n # \"\"\"\\n # Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\\n # :rtype void\\n # \"\"\"\\n #\\n # def setInteger(self, value):\\n # \"\"\"\\n # Set this NestedInteger to hold a single integer equal to value.\\n # :rtype void\\n # \"\"\"\\n #\\n # def getInteger(self):\\n # \"\"\"\\n # @return the single integer that this NestedInteger holds, if it holds a single integer\\n # Return None if this NestedInteger holds a nested list\\n # :rtype int\\n # \"\"\"\\n #\\n # def getList(self):\\n #", "gt": "\"\"\"\\n # @return the nested list that this NestedInteger holds, if it holds a nested list\\n # Return None if this NestedInteger holds a single integer\\n # :rtype List[NestedInteger]\\n # \"\"\"\\n \\n class Solution:\\n def deserialize(self, s):\\n \"\"\"\\n :type s: str\\n :rtype: NestedInteger\\n \"\"\"\\n \\n root_ni = NestedInteger()\\n \\n ni_stack = collections.deque()\\n current_ni = root_ni\\n \\n active_number = None\\n is_positive = True\\n \\n for i, c in enumerate(s):\\n if c == '-':\\n is_positive = False\\n active_number = 0\\n \\n elif c.isdigit():\\n # Check if the previous was a digit as well.\\n if active_number is None:\\n active_number = int(c)\\n else:\\n active_number = int(c) + active_number * 10\\n \\n else:\\n if active_number is not None:\\n if not is_positive:\\n active_number *= -1\\n \\n current_ni.add(active_number)\\n active_number = None\\n is_positive = True\\n \\n if c == '[' and i > 0:\\n ni_stack.append(current_ni)\\n current_ni = NestedInteger()\\n \\n elif c == ']' and len(ni_stack) > 0:\\n ni_stack[-1].add(current_ni)\\n current_ni = ni_stack.pop()\\n \\n if active_number is not None:\\n if not is_positive:\\n active_number *= -1\\n \\n if not current_ni.getList():\\n current_ni.setInteger(active_number)\\n else:\\n current_ni.add(active_number)\\n \\n return root_ni\\n \\n"}
{"id": "1930", "input": "class StreamChecker:\\n\\n def __init__(self, words: List[str]):\\n #reverse trie\\n self.trie = {}\\n self.stream = deque([])\\n\\n for word in set(words):\\n node = self.trie \\n for ch in word[::-1]:\\n if not ch in node:\\n node[ch] = {}\\n node = node[ch]\\n node['$'] = word\\n \\n def query(self, letter: str) ->", "gt": "bool:\\n self.stream.appendleft(letter)\\n \\n node = self.trie\\n for ch in self.stream:\\n if '$' in node:\\n return True\\n if not ch in node:\\n return False\\n node = node[ch]\\n return '$' in node\\n\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n"}
{"id": "1931", "input": "class Cashier:\\n\\n def __init__(self, n: int, discount: int, products: List[int], prices: List[int]):\\n \\n self.n = n\\n self.count = 0\\n self.discount = discount\\n self.products = {}\\n \\n for i in range(0, len(products)):\\n \\n self.products[products[i]] = prices[i]\\n\\n def getBill(self, product: List[int], amount: List[int]) -> float:\\n \\n self.count += 1\\n \\n subtotal = 0\\n", "gt": "\\n for i in range(0, len(product)):\\n \\n subtotal += self.products[product[i]] * amount[i]\\n \\n if self.count == self.n:\\n \\n subtotal = subtotal - (self.discount * subtotal) / 100\\n self.count = 0\\n \\n return subtotal\\n\\n# Your Cashier object will be instantiated and called as such:\\n# obj = Cashier(n, discount, products, prices)\\n# param_1 = obj.getBill(product,amount)\\n"}
{"id": "1932", "input": "class Solution(object):\\n def isSubPath(self, h, r0):\\n h_vals = []\\n while h:\\n h_vals.append(str(h.val))\\n h = h.next\\n h_str = ('-'.join(h_vals)) + '-' # serialized list\\n\\n st = [(r0, '-')] #", "gt": "DFS stack\\n\\n while st:\\n r, pre = st.pop()\\n if not r:\\n continue\\n\\n pre = pre + str(r.val) + '-'\\n if pre.endswith(h_str):\\n return True\\n\\n st.append((r.left, pre))\\n st.append((r.right, pre))\\n\\n return False"}
{"id": "1933", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nclass Solution:\\n def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\\n def count(node):\\n if not node:\\n return 0\\n return 1 + count(node.left) + count(node.right)\\n", "gt": "xNode = [0, 0]\\n def process(node):\\n if node:\\n if node.val == x:\\n xNode[0] = count(node.left)\\n xNode[1] = count(node.right)\\n else:\\n process(node.left)\\n process(node.right)\\n return\\n \\n process(root)\\n player2 = max(xNode[0], xNode[1], n - (xNode[0] + xNode[1] + 1)) # the maximum nodes I can color\\n return player2 > n // 2"}
{"id": "1934", "input": "class Solution:\\n def complexNumberMultiply(self, a, b):\\n \"\"\"\\n :type a: str\\n :type b: str\\n :rtype: str\\n \"\"\"\\n a = a.split('+')\\n b = b.split('+')\\n a[1] = a[1][:-1]\\n b[1]", "gt": "= b[1][:-1]\\n a = list(map(int, a))\\n b = list(map(int, b))\\n print((a, b))\\n r = a[0]*b[0] - a[1]*b[1]\\n i = a[1]*b[0] + a[0]*b[1]\\n print((r, i))\\n return \""}
{"id": "1935", "input": "# Definition for a binary tree node.\\n # class TreeNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.left = None\\n # self.right = None\\n \\n class Solution:\\n def zigzagLevelOrder(self, root):\\n \"\"\"\\n :type root: TreeNode\\n :rtype: List[List[int]]\\n \"\"\"\\n if root is None:\\n return []\\n \\n res = []\\n level_num = 1\\n level", "gt": "= [root]\\n \\n \\n while len(level) != 0:\\n level_size = len(level)\\n level_res = [None]*level_size\\n for i in range(level_size):\\n curr = level.pop(0)\\n level_res[i] = curr.val\\n if curr.left is not None:\\n level.append(curr.left)\\n if curr.right is not None:\\n level.append(curr.right)\\n if level_num % 2:\\n res.append(level_res)\\n else:\\n level_res.reverse()\\n res.append(level_res)\\n level_num += 1\\n \\n return res\\n \\n \\n \\n"}
{"id": "1936", "input": "class Solution:\\n def isToeplitzMatrix(self, matrix):\\n \"\"\"\\n :type matrix: List[List[int]]\\n :rtype: bool\\n \"\"\"\\n if not matrix:\\n return False\\n colSize", "gt": "= len(matrix[0]) - 1\\n for row in range(len(matrix) - 1):\\n if matrix[row][:colSize] != matrix[row+1][1:colSize+1]:\\n return False\\n return True"}
{"id": "1937", "input": "class Solution:\\n def pathInZigZagTree(self, label: int) -> List[int]:\\n res = []\\n level = 0\\n nodes_count = 0\\n while nodes_count < label:\\n nodes_count += 2**level\\n level += 1\\n", "gt": "while label != 0:\\n res.append(label)\\n level_max = (2**level) - 1\\n level_min = 2**(level-1)\\n label = (level_max + level_min - label) // 2\\n level -= 1\\n return res[::-1]\\n\\n"}
{"id": "1938", "input": "class ThroneInheritance:\\n\\n def __init__(self, kingName: str):\\n self.graph = collections.defaultdict(list)\\n self.deaths = set()\\n self.root = kingName\\n \\n\\n def birth(self, parentName: str, childName: str) -> None:\\n self.graph[parentName].append(childName)\\n\\n def death(self, name: str) -> None:\\n self.deaths.add(name)\\n \\n def inorder(self, root, res):\\n if root not", "gt": "in self.deaths:\\n res.append(root)\\n children = self.graph[root]\\n for child in children:\\n self.inorder(child, res)\\n\\n def getInheritanceOrder(self) -> List[str]:\\n res = []\\n self.inorder(self.root, res)\\n return res\\n\\n\\n# Your ThroneInheritance object will be instantiated and called as such:\\n# obj = ThroneInheritance(kingName)\\n# obj.birth(parentName,childName)\\n# obj.death(name)\\n# param_3 = obj.getInheritanceOrder()\\n"}
{"id": "1939", "input": "class Solution:\\n def rectangleArea(self, rectangles: List[List[int]]) -> int:\\n \\n def getArea(width):\\n res = 0\\n prev_low = 0\\n for low, high in intervals:\\n low = max(prev_low, low)\\n if high > low:\\n res += (high - low)*width\\n prev_low = high\\n return res\\n\\n MOD = 10**9 + 7\\n # convert list of rectangles to events\\n events = []\\n for x1, y1, x2, y2 in rectangles:\\n events.append((x1, 0,", "gt": "y1, y2)) #in\\n events.append((x2, 1, y1, y2)) #out\\n events.sort(key = lambda x : (x[0], x[1]))\\n \\n # sweep to calculate area\\n intervals = []\\n area = 0\\n prev_x = 0\\n for event in events:\\n cur_x, type, low, high = event\\n area += getArea(cur_x - prev_x)\\n if type == 1:\\n intervals.remove((low, high))\\n else:\\n intervals.append((low, high))\\n intervals.sort() \\n prev_x = cur_x\\n \\n \\n return area % MOD"}
{"id": "1940", "input": "class Solution:\\n def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n original = set(wordlist)\\n insensitive = {w.lower(): w for w in reversed(wordlist)}\\n vowels = {}\\n for c in reversed(wordlist):\\n w = c.lower()\\n t = w.replace('a', '_').replace('e', '_').replace('i', '_').replace('o', '_').replace('u', '_')\\n vowels[t] = c\\n", "gt": "results = []\\n for q in queries:\\n if q in original:\\n results.append(q)\\n continue\\n low = q.lower()\\n if low in insensitive:\\n results.append(insensitive[low])\\n continue\\n # vowel replace\\n t = low.replace('a', '_').replace('e', '_').replace('i', '_').replace('o', '_').replace('u', '_')\\n if t in vowels:\\n results.append(vowels[t])\\n continue\\n results.append(\\\"\\\")\\n return results"}
{"id": "1941", "input": "# Definition for singly-linked list.\\n# class ListNode:\\n# def __init__(self, val=0, next=None):\\n# self.val = val\\n# self.next = next\\nclass Solution:\\n def nextLargerNodes(self, head: ListNode) -> List[int]:\\n if head==None:\\n", "gt": "return 0\\n temp=head\\n arr=[]\\n stack=[]\\n while temp:\\n arr.append(temp.val)\\n temp=temp.__next__\\n output=[0]*len(arr)\\n for i in range(len(arr)):\\n while stack and arr[stack[-1]]<arr[i]:\\n output[stack.pop()]=arr[i]\\n stack.append(i)\\n return output\\n \\n \\n \\n \\n \\n"}
{"id": "1942", "input": "class Solution:\\n def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n # 1st step\\n # construct a mask for each word\\n # note that there may be duplicate mask for different words\\n # so we need a dict to count the number\\n orda = ord('a') # 97\\n mask = defaultdict(int) # word mask\\n \\n for w in words:\\n m = 0\\n for c in w:\\n m |= 1 << (ord(c) - orda)\\n mask[m] += 1\\n \\n # 2nd step\\n # for each puzzle, construct the corresponding mask for each possible valid word, check whether the word is in mask\\n res = []\\n for p in puzzles:\\n ones = []\\n # separate current", "gt": "puzzle into ones, 'bdeg' -> 0b1011010 -> [0b10(b), 0b1000(d), 0b10000(e), 0b1000000(g)]\\n for c in p:\\n ones.append(1 << (ord(c) - orda))\\n \\n # generate all valid words for the current puzzle\\n # equivalent to generate all subsets of ones[1:]\\n # reuse code from [78. Subsets]\\n valid = [ones[0]] # valid word must contains the first char of current puzzle\\n for i in range(1,7): # bfs to generate all valid words\\n valid.extend([ones[i] + v for v in valid])\\n \\n # for each valid word, check whether it's in mask\\n novw = 0 # number of valid words for current puzzle\\n for v in valid:\\n if v in mask:\\n novw += mask[v]\\n res.append(novw)\\n return res"}
{"id": "1943", "input": "class Solution:\\n def peopleIndexes(self, favoriteCompanies: List[List[str]]) -> List[int]:\\n result = []\\n fcSet = [set(fc) for fc in favoriteCompanies]\\n n =", "gt": "len(favoriteCompanies)\\n for i, fcs1 in enumerate(fcSet):\\n for j, fcs2 in enumerate(fcSet):\\n if i==j:\\n continue\\n if fcs1<fcs2:\\n break\\n else:\\n result.append(i)\\n return result"}
{"id": "1944", "input": "class Solution:\\n def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\\n result = []\\n i = j = 0\\n \\n while i < len(A) and j < len(B):\\n low = max(A[i][0], B[j][0])\\n high =", "gt": "min(A[i][1], B[j][1])\\n \\n if low <= high:\\n result.append([low, high])\\n \\n if A[i][1] > B[j][1]:\\n j += 1\\n elif A[i][1] < B[j][1]:\\n i += 1\\n else:\\n i += 1\\n j += 1\\n \\n return result"}
{"id": "1945", "input": "class Solution:\\n def calc(self, part):\\n part += \"+\" ## added tmp symbol in the end to sum last item within the loop\\n start = x = n = 0\\n coeff = 1\\n for end, char in enumerate(part):\\n # print(\"charIdx:\", equation[end], \"char: \", char, char == \"+\" or char == \"-\", \"slice: \", equation[start:end])\\n if char == \"+\" or char == \"-\":\\n var = part[start:end]\\n if var == \"\":\\n continue\\n if \"x\" in var:\\n var = var[:-1]\\n if var in [\"\", \"+\"]:\\n var = 1\\n elif var == \"-\":\\n var = -1\\n x += int(var) * coeff\\n start = end\\n else:\\n n += int(var) * coeff\\n start = end\\n return x, n\\n \\n def solveEquation(self, equation):\\n \"\"\"\\n :type equation: str\\n :rtype: str\\n \"\"\"\\n # how big is N\\n # time vs. space complexity?\\n \\n # split by \"=\" to left and right; time complexity: O(N)\\n # sums", "gt": "Xs and consts on both sides (left and right)\\n # take a difference b/w the sides' sums\\n # simplify dividing by X's coeff\\n # if x==0 and n==0 on the other - infinite\\n # if x==0 and a constant on the other - no solution\\n # if x on one side, and a constant on the other - solution\\n \\n # test: 2-x+2x-x-x+1=x\\n # test2: \"x+5-3+x=6+x-2\"\\n # test2: \"+5-3+x=6+x-2\"\\n # -x=-1\\n \\n left, right = equation.split(\"=\")\\n x1, n1 = self.calc(left) # O(leftN)\\n x2, n2 = self.calc(right) # O(rightN)\\n x, n = x1 - x2, n1 - n2\\n n = n / x if (x != 0) else n\\n x = 1 if (x != 0) else x\\n if x == 0 and n != 0:\\n return \"No solution\"\\n if x == 0 and n == 0:\\n return \"Infinite solutions\"\\n return \"x="}
{"id": "1946", "input": "class Solution:\\n def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\\n dict_ = {}\\n for row in matrix:\\n curr_tuple = tuple(row)\\n dict_[curr_tuple] = 1 + dict_.get(curr_tuple,0)\\n visited = set()\\n max_same = 0\\n for row in matrix:\\n curr_tuple = tuple(row)\\n if curr_tuple in visited:\\n continue\\n", "gt": "visited.add(curr_tuple)\\n inverse = [1] * len(row)\\n for i in range (len(row)):\\n if row[i]:\\n inverse[i] = 0\\n curr_inv = tuple(inverse)\\n visited.add(curr_inv)\\n curr_sum = 0\\n curr_sum = dict_[curr_tuple]\\n if curr_inv in dict_:\\n curr_sum += dict_[curr_inv]\\n if curr_sum > max_same:\\n max_same = curr_sum\\n return max_same\\n"}
{"id": "1947", "input": "from collections import defaultdict, deque\\n from heapq import merge\\n from itertools import islice\\n \\n class Twitter:\\n \\n def __init__(self):\\n \"\"\"\\n Initialize your data structure here.\\n \"\"\"\\n self.id2tweets = defaultdict(deque)\\n self.id2follows = defaultdict(set)\\n self.uid = 0\\n \\n def postTweet(self, userId, tweetId):\\n \"\"\"\\n Compose a new tweet.\\n :type userId: int\\n :type tweetId: int\\n :rtype: void\\n \"\"\"\\n self.id2tweets[userId].appendleft((self.uid, tweetId))\\n self.uid -= 1\\n #print(userId, 'POST', tweetId, self.id2tweets)\\n \\n def getNewsFeed(self, userId):\\n \"\"\"\\n Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\\n :type userId: int\\n :rtype: List[int]\\n", "gt": "\"\"\"\\n #print('GET', userId, self.id2tweets, self.id2follows)\\n tweets = heapq.merge(*(self.id2tweets[u] for u in self.id2follows[userId] |"}
{"id": "1948", "input": "class Solution:\\n def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\\n s = set(A)\\n letters_required = {}\\n for i in B:\\n for j in i:\\n count = i.count(j)\\n", "gt": "if j not in letters_required or count > letters_required[j]:\\n letters_required[j] = count\\n\\n for i in A:\\n for j in letters_required:\\n if i.count(j) < letters_required[j]:\\n s.remove(i)\\n break\\n return list(s)"}
{"id": "1949", "input": "class Solution:\\n def numPoints(self, points: List[List[int]], r: int) -> int:\\n ans = 1\\n for x, y in points: \\n angles = []\\n for x1, y1 in points: \\n if (x1 != x or y1 != y) and (d:=sqrt((x1-x)**2 + (y1-y)**2)) <= 2*r: \\n angle = atan2(y1-y, x1-x)\\n delta = acos(d/(2*r))\\n angles.append((angle-delta, +1)) #entry\\n angles.append((angle+delta, -1)) #exit\\n angles.sort(key=lambda x: (x[0], -x[1]))\\n val = 1\\n for _, entry in angles: \\n ans = max(ans, val := val+entry)\\n return ans \\n\\n\\n\\n \\n#https://www.geeksforgeeks.org/angular-sweep-maximum-points-can-enclosed-circle-given-radius/ \\n# class Solution {\\n# public int numPoints(int[][] points, int r) {\\n# int count = 1;\\n# for(int i = 0; i < points.length; i++) {\\n# Map<Double, Integer>", "gt": "angles = new HashMap<>();"}
{"id": "1950", "input": "class Solution:\\n def getMaximumGold(self, grid: List[List[int]]) -> int:\\n \\n height = len(grid)\\n width = len(grid[0])\\n max_path = 0\\n \\n # generator for legal indices to check\\n def index_gen(index):\\n i,j = index\\n if i > 0 and grid[i-1][j] > 0:\\n yield (i-1, j)\\n if i < height - 1 and grid[i+1][j] > 0:\\n yield (i+1, j)\\n if j > 0 and grid[i][j-1] > 0:\\n yield (i, j-1)\\n if j < width - 1 and grid[i][j+1] > 0:\\n yield (i, j+1)\\n \\n # if a node branches off in 2 directions it can't be a leaf\\n def is_viable(index):\\n non_zero = 0\\n neighbors = [grid[a][b] for", "gt": "a,b in index_gen(index)]\\n for x in neighbors:\\n if x != 0:\\n non_zero += 1\\n return non_zero < 2\\n \\n def dfs(index, count):\\n nonlocal max_path\\n count += grid[index[0]][index[1]]\\n max_path = max(max_path, count)\\n grid[index[0]][index[1]] *= -1 # clever idea from George Zhou to mark visited\\n for direction in index_gen(index):\\n dfs(direction, count)\\n grid[index[0]][index[1]] *= -1 # unmark node when done with this path\\n \\n for i in range(height):\\n for j in range(width):\\n if grid[i][j] != 0 and is_viable((i,j)):\\n dfs((i,j), 0)\\n \\n # if there are no 'leaf' nodes, then every node is accessible\\n return max_path if max_path > 0 else sum(sum(row) for row in grid )\\n"}
{"id": "1951", "input": "# Definition for singly-linked list.\\n # class ListNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.next = None\\n \\n class Solution:\\n def deleteDuplicates(self, head):\\n \"\"\"\\n :type head: ListNode\\n :rtype: ListNode\\n \"\"\"\\n if not head or not head.next:\\n return head\\n fakehead = ListNode(0)\\n fakehead.next =", "gt": "head\\n prev = fakehead\\n slow = head\\n fast = head.next\\n while fast:\\n if fast.val == slow.val:\\n while fast and fast.val == slow.val:\\n fast = fast.next\\n slow = prev\\n else:\\n prev = slow\\n slow = slow.next\\n slow.val = fast.val\\n fast = fast.next\\n slow.next = None\\n return fakehead.next\\n"}
{"id": "1952", "input": "# Definition for a binary tree node.\\n# class TreeNode:\\n# def __init__(self, val=0, left=None, right=None):\\n# self.val = val\\n# self.left = left\\n# self.right = right\\nclass Solution:\\n def insertIntoMaxTree(self,", "gt": "root: TreeNode, val: int) -> TreeNode:\\n if root and root.val > val:\\n root.right = self.insertIntoMaxTree(root.right, val)\\n return root\\n node = TreeNode(val)\\n node.left = root\\n return node"}
{"id": "1953", "input": "class Solution:\\n def reverseBetween(self, head, m, n):\\n \"\"\"\\n :type head: ListNode\\n :type m: int\\n :type n: int\\n :rtype: ListNode\\n \"\"\"\\n if head is None or head.__next__ is None or m == n: return head\\n h = ListNode(-1)\\n h.next = head\\n fast = slow = h\\n for _ in range(n", "gt": "- m + 1):\\n fast = fast.__next__\\n \\n for _ in range(m - 1):\\n fast = fast.__next__\\n slow = slow.__next__\\n \\n prev = fast.__next__\\n curr = slow.__next__\\n while prev != fast:\\n temp = curr.__next__\\n curr.next = prev\\n prev = curr\\n curr = temp\\n slow.next = prev\\n \\n return h.__next__\\n"}
{"id": "1954", "input": "# Definition for singly-linked list.\\n # class ListNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.next = None\\n \\n class Solution:\\n #@return a ListNode\\n def removeNthFromEnd(self, head, n):\\n dummy=ListNode(0); dummy.next=head\\n p1=p2=dummy\\n for i in", "gt": "range(n): p1=p1.next\\n while p1.next:\\n p1=p1.next;"}
{"id": "1955", "input": "class Solution:\\n def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\\n \\n\\n def fulfill_skills(skills, person):\\n remaining_skills = deque()\\n for skill in skills:\\n if skill not in people[person]:\\n remaining_skills.appendleft(skill)\\n return remaining_skills\\n\\n # BFS by # of people\\n # can reduce expansion by searching rarest skills first\\n\\n # map required skills to people\\n # has_skill[\\\"java\\\"] == a list of people (int index into people) who have that skill\\n has_skill = dict()\\n for person, skills in enumerate(people):\\n for skill in skills:\\n experts = has_skill.get(skill, [])\\n experts.append(person)\\n has_skill[skill] = experts\\n\\n\\n # sort skills by", "gt": "rarity\\n rare_skills = [(len(people), skill) for (skill, people) in list(has_skill.items())]\\n rare_skills.sort()\\n rare_skills = [skill for _, skill in rare_skills]\\n\\n\\n for i in range(1, 17):\\n # stack holds pairs:\\n # (skills, team)\\n stack = [ (deque(rare_skills), []) ]\\n while stack:\\n skills, team = stack.pop()\\n # print(skills, team)\\n if not skills:\\n return team\\n\\n if len(team) + 1 > i:\\n continue\\n # choose a member to fulfill next rarest skill\\n skill = skills[0]\\n for person in has_skill[skill]:\\n remaining_skills = fulfill_skills(skills, person)\\n stack.append( (remaining_skills, team + [person]) )\\n # print(f\\\"i"}
{"id": "1956", "input": "class Solution:\\n def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n pr=[i for i in range(len(s))]\\n def union(x,y):\\n p1=find(x)\\n p2=find(y)\\n if p1!=p2:\\n pr[p1]=p2\\n def find(x):\\n while pr[x]!=x:\\n pr[x]=pr[pr[x]]\\n x=pr[x]\\n return x\\n \\n for i in pairs:\\n union(i[0],i[1])\\n \\n from", "gt": "collections import defaultdict\\n dp=defaultdict(list)\\n for i in range(len(s)):\\n ld=find(i)\\n dp[ld].append(i)\\n ans=[0]*len(s)\\n for i in dp:\\n dp[i].sort()\\n st=''\\n for j in dp[i]:\\n st+=s[j]\\n st=sorted(st)\\n c=0\\n for j in dp[i]:\\n ans[j]=st[c]\\n c+=1\\n return ''.join(ans)\\n \\n \\n \\n \\n \\n \\n \\n"}
{"id": "1957", "input": "class Solution:\\n def FindValid(self):\\n a=\"123456789\"\\n d,val={},{}\\n for i in range(9):\\n for j in range(9):\\n temp=self.board[i][j]\\n if temp!='.':\\n d[(\"r\",i)]=d.get((\"r\",i),[])+[temp]\\n d[(\"c\",j)]=d.get((\"c\",j),[])+[temp]\\n d[(i//3,j//3)]=d.get((i//3,j//3),[])+[temp]\\n else:\\n val[(i,j)]=[]\\n for (i,j) in list(val.keys()):\\n invalid=d.get((\"r\",i),[])+d.get((\"c\",j),[])+d.get((i//3,j//3),[])\\n val[(i,j)]=[ele for ele in a if ele not in invalid]\\n return val\\n def CheckingSolution(self,ele,Pos,Updata):\\n self.board[Pos[0]][Pos[1]]=ele\\n del self.val[Pos]\\n i,j=Pos\\n for invalid in list(self.val.keys()):\\n if ele in self.val[invalid]:\\n if invalid[0]==i or invalid[1]==j or (invalid[0]//3,invalid[1]//3)==(i//3,j//3):\\n Updata[invalid]=ele\\n self.val[invalid].remove(ele)\\n if len(self.val[invalid])==0:\\nreturn False\\n return True\\n def Sudo(self,Pos,Updata):\\n self.board[Pos[0]][Pos[1]]=\".\"\\n for i in Updata:\\n if i not in self.val:\\n self.val[i]=Updata[i]\\n else:\\n self.val[i].append(Updata[i])\\n def FindSolution(self):\\n if len(self.val)==0:\\n return True\\n Pos=min(list(self.val.keys()),key=lambda x:len(self.val[x]))\\n nums=self.val[Pos]\\n for ele in nums:\\n updata={Pos:self", "gt": ".val[Pos]}"}
{"id": "1958", "input": "# O(M*N*K)\\nclass Solution:\\n def shortestPath(self, grid: List[List[int]], k: int) -> int:\\n rows, cols = len(grid), len(grid[0])\\n steps, min_steps = 0, rows + cols - 2\\n if k >= min_steps - 1:\\n return min_steps\\n\\n visited = [[-1] * cols for _ in range(rows)]\\n visited[0][0] = k\\n q = deque([(0, 0, k)])\\n while q:\\n steps += 1\\n prev_min = min_steps\\n for _ in range(len(q)):\\n r, c, p = q.popleft()\\n for dx, dy in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\\n x, y = c + dx, r + dy\\n if x <", "gt": "0 or x >= cols or y < 0 or y >= rows:\\n continue\\n kk = p-grid[y][x]\\n if kk <= visited[y][x]: # have visited here on a better path.\\n continue\\n # early stop if there's shortcut (-1 because goal cell != 1)\\n # But only applies when, comming from\\n to_target = rows - y + cols - x - 2 # rows-r-1 + cols-c-1\\n if kk >= to_target-1 and visited[y][x] == -1: #to_target == prev_min-1:\\n return steps + to_target\\n q.append((y, x, kk))\\n visited[y][x] = kk\\n min_steps = min(min_steps, to_target)\\n return -1\\n"}
{"id": "1959", "input": "class Solution:\\n def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\\n# mine\\n# res = collections.defaultdict(list)\\n# res_return = []\\n# for i,j in enumerate(groupSizes):\\n# res[j].append(i)\\n \\n# for j in res:\\n# temp = [res[j][0:j]]\\n# if len(res[j])>j:\\n# # print(j,res[j][1])\\n# # sub_nums = int(len(res[j])/j)\\n# for num in", "gt": "range(j,len(res[j]),j):\\n# temp = temp + [res[j][num:num+j]]\\n# # print(temp)\\n# res[j]=temp\\n# res_return = res_return+temp\\n# # print(res)\\n# # print(res_return)\\n# return res_return\\n\\n # other perple\\n groups = defaultdict(list)\\n result = []\\n for index, size in enumerate(groupSizes):\\n groups[size].append(index)\\n if len(groups[size]) == size:\\n result.append(groups.pop(size))\\n return result"}
{"id": "1960", "input": "# Definition for a binary tree node.\\n # class TreeNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.left = None\\n # self.right = None\\n \\n class Solution:\\n def addValueToList(self, root, lst):\\n if root is not None:\\n lst.append(root.val)\\n self.addValueToList(root.left, lst)\\n self.addValueToList(root.right,", "gt": "lst)\\n \\n def minDiffInBST(self, root):\\n \"\"\"\\n :type root: TreeNode\\n :rtype: int\\n \"\"\"\\n values = []\\n self.addValueToList(root, values)\\n sorted_values = sorted(values)\\n max_diff = sorted_values[-1] - sorted_values[0]\\n for i in range(len(values)-1):\\n if sorted_values[i+1] - sorted_values[i] < max_diff:\\n max_diff = sorted_values[i+1] - sorted_values[i]\\n return max_diff"}
{"id": "1961", "input": "class Solution:\\n def processQueries(self, queries: List[int], m: int) -> List[int]:\\n if not queries:\\n return []\\n p = list(range(1,", "gt": "m+1))\\n res = []\\n for i in queries:\\n z = p.index(i)\\n res.append(z)\\n del p[z]\\n p.insert(0,i)\\n return res\\n \\n"}
{"id": "1962", "input": "class BrowserHistory:\\n\\n def __init__(self, homepage: str):\\n \\n self.hashM = {}\\n self.maxIndex, self.currIndex = 0, 0\\n self.hashM[self.currIndex] = homepage\\n\\n def visit(self, url: str) -> None:\\n \\n self.hashM[self.currIndex + 1] = url\\n self.currIndex = self.currIndex + 1\\n self.maxIndex = self.currIndex\\n return(url)\\n \\n def back(self, steps: int) -> str:\\n \\n if self.currIndex - steps < 0:\\n \\n self.currIndex = 0\\n", "gt": "\\n else:\\n \\n self.currIndex = self.currIndex - steps\\n \\n return(self.hashM[self.currIndex])\\n\\n def forward(self, steps: int) -> str:\\n \\n if self.currIndex + steps > self.maxIndex:\\n \\n self.currIndex = self.maxIndex\\n \\n else:\\n \\n self.currIndex = self.currIndex + steps\\n \\n return(self.hashM[self.currIndex])\\n \\n\\n\\n# Your BrowserHistory object will be instantiated and called as such:\\n# obj = BrowserHistory(homepage)\\n# obj.visit(url)\\n# param_2 = obj.back(steps)\\n# param_3 = obj.forward(steps)\\n"}
{"id": "1963", "input": "class Solution:\\n def dominantIndex(self, nums):\\n \"\"\"\\n :type nums: List[int]\\n :rtype: int\\n \"\"\"\\n if len(nums) <= 1:\\n return 0\\n", "gt": "m = max(nums)\\n ind = nums.index(m)\\n del nums[ind]\\n m_2 = max(nums)\\n return ind if m >= 2*m_2 else -1"}
{"id": "1964", "input": "class Solution:\\n def shoppingOffers(self, price, special, needs):\\n \"\"\"\\n :type price: List[int]\\n :type special: List[List[int]]\\n :type needs: List[int]\\n :rtype: int\\n \"\"\"\\n def dfs(curr, special, needs):\\n p=curr+sum(p*needs[i] for i,p in enumerate(price))\\n for si", "gt": "in range(len(special)):\\n s = special[si]\\n if all(n>=s[i] for i,n in enumerate(needs)):\\n p=min(p, dfs(curr+s[-1], special[si:], [n-s[i] for i,n in enumerate(needs)]))\\n # else: p=min(p, dfs(curr, special[si+1:], needs))\\n return p\\n return dfs(0, special, needs)"}
{"id": "1965", "input": "def get_tree_height(node, parent_node_height):\\n if node is None:\\n return 0\\n node.height = parent_node_height + 1\\n if node.left is None and node.right is None:\\n return 1\\n return max(get_tree_height(node.left, node.height), get_tree_height(node.right, node.height)) + 1\\n \\n def fill_in_array(result, node, root_index, width):\\n if node is None:\\n return\\n result[node.height - 1][root_index] = str(node.val)\\n new_width = width // 2\\n fill_in_array(result, node.left, root_index - new_width // 2 - 1,", "gt": "new_width)\\n fill_in_array(result, node.right, root_index + new_width // 2 + 1, new_width)\\n \\n class Solution:\\n def printTree(self, root):\\n \"\"\"\\n :type root: TreeNode\\n :rtype: List[List[str]]\\n \"\"\"\\n height = get_tree_height(root, 0)\\n rows = height\\n cols = 0\\n for i in range(height):\\n cols = cols * 2 + 1\\n result = [[\"\"] * cols for _ in range(rows)]\\n fill_in_array(result, root, cols // 2, cols)\\n return result"}
{"id": "1966", "input": "class Solution:\\n def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n if len(edges) == 0:\\n return 0 if n == 0 else -1\\n p = [i for i in range(n)]\\n def getP(ind):\\n nonlocal p\\n if p[ind] == ind:\\n return ind\\n else:\\n res = getP(p[ind])\\n p[ind] = res\\n return res\\n cnt = 0\\n for t,u,v in edges:\\n if t == 3:\\n pu,pv = getP(u-1), getP(v-1)\\n if pu != pv:\\n p[pv] = pu\\n cnt += 1\\n if cnt != (n - 1):\\n", "gt": "pa = list(p)\\n for t,u,v in edges:\\n if t == 1:\\n pu,pv = getP(u-1), getP(v-1)\\n if pu != pv:\\n p[pv] = pu\\n cnt += 1\\n targetP = getP(0)\\n for v in range(n):\\n if getP(v) != targetP:\\n return -1\\n p = pa\\n for t,u,v in edges:\\n if t == 2:\\n pu,pv = getP(u-1), getP(v-1)\\n if pu != pv:\\n p[pv] = pu\\n cnt += 1\\n targetP = getP(0)\\n for v in range(n):\\n if getP(v) != targetP:\\n return -1\\n return len(edges) - cnt"}
{"id": "1967", "input": "class Solution:\\n def numSubmat(self, mat: List[List[int]]) -> int:\\n n, m = len(mat), len(mat[0])\\n heights = [0] * m\\n res = 0\\n for i in range(0, n):\\n stack = []\\n count = 0\\n for j in range(0, m):\\n if mat[i][j] == 1:\\n heights[j] += 1\\n", "gt": "else:\\n heights[j] = 0\\n for index, height in enumerate(heights):\\n while stack and height < heights[stack[-1]]:\\n curr = stack.pop()\\n left = stack[-1] if stack else -1\\n count -= (heights[curr] - height) * (curr - left)\\n count += height\\n res += count\\n stack.append(index)\\n return res\\n \\n"}
{"id": "1968", "input": "class Solution(object):\\n def splitIntoFibonacci(self, S):\\n \\\"\\\"\\\"\\n :type S: str\\n :rtype: List[int]\\n \\\"\\\"\\\"\\n n = len(S)\\n for i in range(1, 11):\\n for j in range(1, 11):\\n if i + j >= n:\\n break\\n L = self.buildFibo(S, i, j)\\n if L:\\n return L\\n return []\\n \\n def buildFibo(self, s, i, j):\\n a = s[:i]\\n b = s[i:i+j]\\n if a[0] == '0' and i > 1:\\n return []\\n if b[0] == '0'", "gt": "and j > 1:\\n return []\\n \\n offset = i + j\\n n = len(s)\\n x, y = int(a), int(b)\\n arr = [x, y]\\n while offset < n:\\n z = x + y\\n if z > 2147483647:\\n return []\\n \\n c = str(z)\\n k = len(c)\\n if offset + k > n or s[offset:offset+k] != c:\\n return []\\n offset += k\\n arr.append(z)\\n x, y = y, z\\n return arr"}
{"id": "1969", "input": "class Solution:\\n def removeSubfolders(self, folder):\\n \\n folders = folder\\n \\n folders.sort()\\n output = []\\n parent = '", "gt": "'\\n \\n for folder in folders:\\n if not folder.startswith(parent):\\n output.append(folder)\\n parent = folder + '/'\\n \\n return output"}
{"id": "1970", "input": "# Definition for a binary tree node.\\n # class TreeNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.left = None\\n # self.right = None\\n \\n class Solution:\\n def sumNumbers(self, root):\\n \"\"\"\\n :type root: TreeNode\\n :rtype:", "gt": "int\\n \"\"\"\\n def dfs(node, cur_num):\\n if node is None: return 0\\n my_num = cur_num * 10 + node.val\\n if node.left is None and node.right is None: return my_num\\n return dfs(node.left, my_num) + dfs(node.right, my_num)\\n \\n return dfs(root,0)"}
{"id": "1971", "input": "class Solution:\\n def nearestPalindromic(self, num):\\n \"\"\"\\n :type n: str\\n :rtype: str\\n \"\"\"\\n K = len(num)\\n candidates = set([10**K + 1, 10**(K-1) - 1])\\n Prefix =", "gt": "int(num[:(K+1)//2])\\n \\n for start in map(str, [Prefix-1, Prefix, Prefix+1]):\\n candidates.add(start + [start, start[:-1]][K & 1][::-1])\\n \\n candidates.discard(num)\\n \\n return str(min(candidates, key=lambda x: (abs(int(x) - int(num)), int(x))))\\n"}
{"id": "1972", "input": "class Solution:\\n def maximalSquare(self, matrix):\\n \"\"\"\\n :type matrix: List[List[str]]\\n :rtype: int\\n \"\"\"\\n if not matrix:\\n return 0\\n \\n m, n = len(matrix), len(matrix[0])\\n dp = [int(matrix[i][0]) for i in range(m)]\\n vmax = max(dp) \\n pre = 0 \\n for j", "gt": "in range(1, n):\\n pre, dp[0] = int(matrix[0][j-1]), int(matrix[0][j])\\n for i in range(1, m):\\n cur = dp[i]\\n dp[i] = 0 if matrix[i][j] == '0' else (min(dp[i-1], dp[i], pre) + 1) \\n pre = cur\\n vmax = max(vmax, max(dp))\\n return vmax ** 2"}
{"id": "1973", "input": "# Definition for a binary tree node.\\n # class TreeNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.left = None\\n # self.right = None\\n \\n class Solution:\\n def splitBST(self, root,target):\\n \"\"\"\\n :type root: TreeNode\\n :type V: int\\n :rtype: List[TreeNode]\\n \"\"\"\\n \\n def split_bst_recur(root, target):\\n if not root:\\n return (None, None)\\n \\n if not root.left", "gt": "and not root.right:\\n if root.val <= target:\\n return (root, None)\\n else:\\n return(None, root)\\n \\n if root.val > target:\\n l, r = split_bst_recur(root.left, target)\\n root.left = r\\n return (l, root)\\n else:\\n l, r = split_bst_recur(root.right, target)\\n root.right = l\\n return (root, r)\\n \\n if not root:\\n return [[],[]]\\n \\n l, r = split_bst_recur(root, target)\\n return [l, r]\\n \\n"}
{"id": "1974", "input": "class Solution:\\n def isIdealPermutation(self, A):\\n \"\"\"\\n :type A: List[int]\\n :rtype: bool\\n \"\"\"\\n # tle\\n # for i in range(len(A)-2):\\n # if A[i] >", "gt": "min(A[i+2:]):\\n # return False\\n # return True\\n \\n # ac\\n for i in range(len(A)):\\n if abs(A[i] - i) > 1:\\n return False\\n return True"}
{"id": "1975", "input": "# Definition for a binary tree node.\\n # class TreeNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.left = None\\n # self.right = None\\n \\n class Solution:\\n def postorderTraversal(self, root):\\n \"\"\"\\n :type root: TreeNode\\n :rtype:", "gt": "List[int]\\n \"\"\"\\n if root==None:\\n return []\\n stack=[]\\n stack_left=[1]\\n while stack_left!=[]:\\n stack.append(root.val)\\n if root.left!=None and root.right==None:\\n root=root.left\\n elif root.left==None and root.right!=None:\\n root=root.right\\n elif root.left!=None and root.right!=None:\\n stack_left.append(root.left)\\n root=root.right\\n else:\\n if stack_left==[1]:\\n stack_left=[]\\n else:\\n root=stack_left.pop()\\n #print(stack)\\n stack.reverse()\\n return stack\\n"}
{"id": "1976", "input": "class CustomStack:\\n\\n def __init__(self, maxSize: int):\\n self.stack = []\\n self.add = []\\n self.limit = maxSize\\n\\n def push(self, x: int) -> None:\\n if len(self.stack) < self.limit:\\n self.stack.append(x)\\n self.add.append(0)\\n\\n def pop(self) -> int:\\n if len(self.stack) == 0:\\n return -1\\n result = self.stack.pop()\\n left = self.add.pop()\\n if len(self.add) > 0:\\n self.add[-1]", "gt": "+= left\\n return result + left\\n\\n def increment(self, k: int, val: int) -> None:\\n if len(self.stack) > 0:\\n if k > len(self.stack):\\n self.add[-1] += val\\n return\\n self.add[k-1] += val\\n \\n\\n\\n# Your CustomStack object will be instantiated and called as such:\\n# obj = CustomStack(maxSize)\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# obj.increment(k,val)\\n"}
{"id": "1977", "input": "class MagicDictionary:\\n \\n def __init__(self):\\n \"\"\"\\n Initialize your data structure here.\\n \"\"\"\\n self.l = []\\n \\n def buildDict(self, dict):\\n \"\"\"\\n Build a dictionary through a list of words\\n :type dict: List[str]\\n :rtype: void\\n \"\"\"\\n self.l= dict\\n \\n def search(self, word):\\n \"\"\"\\n Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n :type", "gt": "word: str\\n :rtype: bool\\n \"\"\"\\n def diffnumber(a,b):\\n count = 0\\n for i in range(len(a)):\\n if a[i] !=b[i]:\\n count +=1\\n return count\\n for x in self.l:\\n if len(x) == len(word) and diffnumber(x,word) ==1:\\n return True\\n return False\\n \\n \\n \\n \\n \\n # Your MagicDictionary object will be instantiated and called as such:\\n # obj = MagicDictionary()\\n # obj.buildDict(dict)\\n # param_2 = obj.search(word)\\n"}
{"id": "1978", "input": "class Solution:\\n def closedIsland(self, grid: List[List[int]]) -> int:\\n count = 0 \\n for i in range(1,len(grid)-1):\\n for j in range(1,len(grid[0])-1):\\n if grid[i][j] ==0 and self.dfs(grid,i,j):\\n count+=1\\n return count \\n def dfs(self,grid,i,j):\\n", "gt": "if grid[i][j]==1:\\n return True\\n if i<=0 or j<=0 or i>=len(grid)-1 or j>= len(grid[0])-1:\\n return False\\n grid[i][j]=1\\n up= self.dfs(grid,i+1,j)\\n down= self.dfs(grid,i-1,j)\\n left= self.dfs(grid,i,j-1)\\n right= self.dfs(grid,i,j+1)\\n return up and down and left and right"}
{"id": "1979", "input": "class Solution:\\n def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:\\n out = []\\n for word in words:\\n pat_dict = dict()\\n used = set()\\n if len(word) == len(pattern):\\n can_be = True\\n for i in range(len(word)):\\n", "gt": "if word[i] not in pat_dict:\\n if pattern[i] not in used:\\n pat_dict[word[i]] = pattern[i]\\n used.add(pattern[i])\\n else:\\n can_be = False\\n break\\n else:\\n if pat_dict[word[i]] != pattern[i]:\\n can_be = False\\n break\\n if can_be == True:\\n out.append(word)\\n return out"}
{"id": "1980", "input": "class Solution:\\n def largestTimeFromDigits(self, A: List[int]) -> str:\\n max_time = -1\\n # enumerate all possibilities, with the permutation() func\\n for h, i, j, k in itertools.permutations(A):\\n hour = h*10 + i\\n minute =", "gt": "j*10 + k\\n if hour < 24 and minute < 60:\\n max_time = max(max_time, hour * 60 + minute)\\n \\n if max_time == -1:\\n return \\\"\\\"\\n else:\\n return \\\""}
{"id": "1981", "input": "class Skiplist:\\n def __init__(self):\\n self.skip_list={}\\n \\n\\n def search(self, target: int) -> bool:\\n if(target in self.skip_list):\\n if(self.skip_list[target]>0):\\n return True\\n return False\\n \\n\\n def add(self, num:", "gt": "int) -> None:\\n if(num in self.skip_list):\\n self.skip_list[num]+=1\\n else:\\n self.skip_list[num]=1\\n \\n\\n def erase(self, num: int) -> bool:\\n if(num in self.skip_list):\\n if(self.skip_list[num]>0):\\n self.skip_list[num]-=1\\n return True\\n return False"}
{"id": "1982", "input": "class Solution:\\n def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n count = [0] * (len(nums) + 1)\\n for start, end in requests:\\n count[start] += 1\\n count[end + 1] -= 1\\n for i in", "gt": "range(1, len(nums) + 1):\\n count[i] += count[i - 1]\\n count.pop()\\n\\n res = 0\\n for n, times in zip(sorted(nums), sorted(count)):\\n res += n * times\\n\\n return res % (10 ** 9 + 7)\\n \\n"}
{"id": "1983", "input": "class Solution:\\n def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n if not dislikes:\\n return True\\n group = [None] * (N + 1)\\n group[dislikes[0][0]] = 1\\n group[dislikes[0][1]] = -1\\n group1 = set([1])\\n group2 = set()\\n counter = 2\\n for i, j in dislikes[1:]:\\n if group[i] and group[j]:\\n if group[i] == group[j]:\\n return False\\n if group[i] in group1:\\n if group[j] in group1 or -group[j] in group2:\\n return False\\n group2.add(group[j])\\n elif group[i]", "gt": "in group2:\\n if group[j] in group2 or -group[j] in group1:\\n return False\\n group1.add(group[j])\\n elif group[j] in group1:\\n if group[i] in group1 or -group[i] in group2:\\n return False\\n group2.add(group[i])\\n elif group[j] in group2:\\n if group[i] in group2 or -group[i] in group1:\\n return False\\n group1.add(group[i])\\n elif not group[i] and not group[j]:\\n group[i], group[j] = counter, -counter\\n counter += 1\\n elif group[i]:\\n group[j] = -group[i]\\n elif group[j]:\\n group[i] = -group[j]\\n return True"}
{"id": "1984", "input": "import math\\nclass ProductOfNumbers:\\n\\n def __init__(self):\\n self.numbers = [1]\\n self.lastZero = 0\\n\\n def add(self, num: int) -> None:\\n if num != 0:\\n self.numbers.append(self.numbers[-1] * num)\\n else:\\n self.numbers = [1]\\n \\n\\n def getProduct(self, k:", "gt": "int) -> int:\\n if k < len(self.numbers):\\n return self.numbers[-1] // self.numbers[-k - 1]\\n else:\\n return 0\\n\\n\\n# Your ProductOfNumbers object will be instantiated and called as such:\\n# obj = ProductOfNumbers()\\n# obj.add(num)\\n# param_2 = obj.getProduct(k)\\n"}
{"id": "1985", "input": "# Definition for a binary tree node.\\n # class TreeNode:\\n # def __init__(self, x):\\n # self.val = x\\n # self.left = None\\n # self.right = None\\n \\n class Solution:\\n def buildTree(self, preorder, inorder):\\n \"\"\"\\n :type preorder: List[int]\\n", "gt": ":type inorder: List[int]\\n :rtype: TreeNode\\n \"\"\"\\n def build(stop):\\n if preorder and inorder[-1] != stop:\\n root = TreeNode(preorder.pop())\\n root.left = build(root.val)\\n inorder.pop()\\n root.right = build(stop)\\n return root\\n return None # can be skipped\\n \\n preorder.reverse()\\n inorder.reverse()\\n return build(None)"}
{"id": "1986", "input": "class Solution:\\n def searchMatrix(self, matrix, target):\\n \"\"\"\\n :type matrix: List[List[int]]\\n :type target: int\\n :rtype: bool\\n \"\"\"\\n m = len(matrix)\\n if m == 0:\\n return False\\n n = len(matrix[0])\\n if n == 0:\\n return", "gt": "False\\n row, col = 0, n-1\\n while row < m and col >= 0:\\n if matrix[row][col] == target:\\n return True\\n elif matrix[row][col] > target:\\n col -= 1\\n else:\\n row += 1\\n return False\\n"}
{"id": "1987", "input": "class Solution:\\n def circularPermutation(self, n: int, start: int) -> List[int]:\\n res = [i ^ (i", "gt": ">> 1) for i in range(1 << n)]\\n \\n idx = res.index(start)\\n return res[idx:] + res[:idx]"}
{"id": "1988", "input": "import heapq\\n class Solution(object):\\n def pourWater(self, heights, V, K):\\n \"\"\"\\n :type heights: List[int]\\n :type V: int\\n :type K: int\\n :rtype: List[int]\\n \"\"\"\\n \\n heap = []\\n heapq.heappush(heap, (heights[K], -1, 0))\\n l, r = K - 1, K + 1\\n lh, rh = [], []\\n \\n for i in range(V):\\n while l >= 0 and heights[l] <= heights[l + 1]:\\n heapq.heappush(lh, (heights[l], -l))\\n l -=", "gt": "1\\n \\n while r < len(heights) and heights[r] <= heights[r - 1]:\\n heapq.heappush(rh, (heights[r], r))\\n r += 1\\n \\n if lh and lh[0][0] < heights[K]:\\n h, i = heapq.heappop(lh)\\n heights[-i] += 1\\n heapq.heappush(lh, (h + 1, i))\\n continue\\n \\n if rh and rh[0][0] < heights[K]:\\n h, i = heapq.heappop(rh)\\n heights[i] += 1\\n heapq.heappush(rh, (h + 1, i))\\n continue\\n \\n heights[K] += 1\\n \\n return heights\\n"}
{"id": "1989", "input": "class Solution:\\n def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\\n \\n \\n G = [[[], []] for i in range(n)]\\n for i, j in red_edges: G[i][0].append(j)\\n for i, j in blue_edges: G[i][1].append(j)\\n res = [[0, 0]] + [[n * 2, n * 2] for i in range(n - 1)]\\n", "gt": "bfs = [[0, 0], [0, 1]]\\n for i, c in bfs:\\n # print(i, c)\\n for j in G[i][c]:\\n if res[j][c] == n * 2:\\n res[j][c] = res[i][1 - c] + 1\\n bfs.append([j, 1 - c])\\n # print(bfs)\\n return [x if x < n * 2 else -1 for x in map(min, res)]"}
{"id": "1990", "input": "class Solution:\\n def longestAwesome(self, s: str) -> int:\\n cum = [0]\\n firsts = {0: -1}\\n lasts = {0: -1}\\n for i, c in enumerate(s):\\n cum.append(cum[-1] ^ (1 << (ord(c) - 48)))\\n if cum[-1] not in firsts:\\n firsts[cum[-1]] = i\\n", "gt": "lasts[cum[-1]] = i\\n mx = 1\\n for k in firsts:\\n mx = max(mx, lasts[k] - firsts[k])\\n for off in range(10):\\n o = k ^ (1 << off)\\n if o in firsts:\\n mx = max(mx, lasts[o] - firsts[k])\\n return mx"}
{"id": "1991", "input": "class Solution:\\n def findLongestChain(self, pairs):\\n \"\"\"\\n :type pairs: List[List[int]]\\n :rtype: int\\n \"\"\"\\n pairs = sorted(pairs,key=lambda x:x[1])\\n res = 1\\n", "gt": "first = pairs[0]\\n for i in pairs[1:]:\\n if first[-1] < i[0]:\\n res += 1\\n first = i\\n return res\\n"}
{"id": "1992", "input": "class Solution:\\n def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\\n n = len(locations)\\n sloc = sorted([(x,i) for i,x in enumerate(locations)])\\n froutes = [[0]*n for _ in range(fuel+1) ]\\n st,fn = -1,-1\\n for i in range(n):\\n if sloc[i][1] == start:\\n st = i\\n if sloc[i][1] == finish:\\n fn = i\\n froutes[fuel][st] = 1\\n f0 = fuel\\n while fuel > 0:\\n for i, cnt", "gt": "in enumerate(froutes[fuel]):\\n if cnt > 0:\\n for j in range(i-1, -1, -1):\\n dist = sloc[i][0] - sloc[j][0]\\n if dist <= fuel:\\n froutes[fuel - dist][j] += cnt\\n else:\\n break\\n for j in range(i+1, n):\\n dist = sloc[j][0] - sloc[i][0]\\n if dist <= fuel:\\n froutes[fuel - dist][j] += cnt\\n else:\\n break\\n fuel -= 1\\n res = 0\\n for i in range(f0+1):\\n res += froutes[i][fn]\\n return res % (10**9+7)"}
{"id": "1993", "input": "class CombinationIterator:\\n def __init__(self, characters: str, combinationLength: int):\\n self.nextCombIt = combinations(characters, combinationLength)\\n self.nextComb = next(self.nextCombIt, None)\\n\\n def __next__(self) ->", "gt": "str:\\n nextComb = self.nextComb\\n self.nextComb = next(self.nextCombIt, None)\\n return ''.join(nextComb)\\n\\n def hasNext(self) -> bool:\\n return self.nextComb is not None\\n"}
{"id": "1994", "input": "import re\\n \\n \\n class Solution:\\n def removeComments(self, source):\\n \"\"\"\\n :type source: List[str]\\n :rtype:", "gt": "List[str]\\n \"\"\"\\n lines = re.sub('//.*|/\\*(.|\\n)*?\\*/', '', '\\n'.join(source)).split('\\n')\\n return [line for line in lines if line]\\n"}
{"id": "1995", "input": "# Definition for singly-linked list.\\n# class ListNode:\\n# def __init__(self, val=0, next=None):\\n# self.val = val\\n# self.next = next\\nclass Solution:\\n def numComponents(self, head: ListNode, G:", "gt": "List[int]) -> int:\\n s=set(G)\\n prev_in=False\\n c=0\\n while head:\\n if head.val in s:\\n if not prev_in:\\n c+=1 \\n prev_in=True\\n else: \\n prev_in=False\\n head=head.__next__\\n return c\\n"}
{"id": "1996", "input": "class Solution:\\n def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\\n d = defaultdict(int)\\n \\n for a, b, c in trips:\\n d[b] +=", "gt": "a\\n d[c] -= a\\n \\n k = 0\\n for t in sorted(d.keys()):\\n k += d[t]\\n if k > capacity:\\n return False\\n return True"}
{"id": "1997", "input": "class Solution:\\n def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\\n \\\"\\\"\\\"\\n Just move along unvisited (-1) nodes and remark them as 0 on the queue while visiting others on the path and finish them as 1. If you meet them again on the queue while visiting (being 0) it means you completed a cycle, in other words", "gt": "it is not safe and return back without adding.\\n \\\"\\\"\\\"\\n visited, result = [-1] * len(graph), []\\n \\n def explore(i):\\n visited[i] = 0\\n for v in graph[i]:\\n if visited[v] == 0 or (visited[v]==-1 and explore(v)): return True\\n visited[i] = 1\\n result.append(i)\\n return False\\n \\n for i in range(len(graph)):\\n if visited[i] == -1: explore(i)\\n\\n return sorted(result)\\n"}
{"id": "1998", "input": "class Solution:\\n def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n intervals.sort(key=lambda x: (x[0], -x[1]))\\n \\n prev_end = result = 0\\n", "gt": "for _, end in intervals:\\n if end > prev_end:\\n result += 1; prev_end = end\\n \\n return result"}
{"id": "1999", "input": "import collections\\n \\n solved_boards = {((1,2,3),(4,5,0)): 0}\\n class Solution:\\n def slidingPuzzle(self, board):\\n \"\"\"\\n :type board: List[List[int]]\\n :rtype: int\\n \"\"\"\\n asked = tuple(tuple(row) for row in board)\\n queue = collections.deque([((1,2,3),(4,5,0))])\\n while queue:\\n tboard = queue.popleft()\\n for next_board in next_boards(tboard):\\n if next_board in solved_boards:\\n continue\\n solved_boards[next_board] = solved_boards[tboard] + 1\\n queue.append(next_board)\\n return solved_boards.get(asked, -1)\\n \\n def next_boards(board):\\n board = [list(row) for row in board]\\n", "gt": "zy, zx = find_zero(board)\\n for dy, dx in ((-1, 0), (0, 1), (1, 0), (0, -1)):\\n nzy, nzx = zy + dy, zx +dx\\n if nzy in range(2) and nzx in range(3):\\n board[zy][zx],board[nzy][nzx] = board[nzy][nzx],board[zy][zx]\\n yield tuple(tuple(row) for row in board)\\n board[zy][zx],board[nzy][nzx] = board[nzy][nzx],board[zy][zx]\\n \\n def find_zero(board):\\n for y, row in enumerate(board):\\n for x, e in enumerate(row):\\n if e == 0:\\n return y,x"}
{"id": "2000", "input": "# Definition for singly-linked list.\\n# class ListNode:\\n# def __init__(self, val=0, next=None):\\n# self.val = val\\n# self.next = next\\nclass Solution:\\n def removeZeroSumSublists(self, head: ListNode) ->", "gt": "ListNode:\\n \\n seen="}
