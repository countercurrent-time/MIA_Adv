s = input()\nn = len(s)\nind = -1\nf = False\nfor i in range(n):\n    if s[i] == '[':\n        f = True\n    elif s[i] == ':':\n        if f:\n            ind = i\n            break\nbind = -1\nf = False\nfor i in range(n-1,-1,-1):\n    if s[i] == ']':\n        f = True\n    elif s[i] == ':':\n        if f:\n            bind = i\n            break\n# print(ind,bind)\nif ind == -1 or bind == -1:\n    print(-1)\nelif ind >= bind:\n    print(-1)\nelse:\n    ans = 4\n    for i in range(ind+1,bind):\n        if s[i] == '|':\n            ans += 1\n    print(ans)\n
num = list(map(int, input()))\nbest = num[:]\nfor i in range(-1, -len(num) - 1, -1):\n    if num[i] == 0:\n        continue\n    num[i] -= 1\n    for j in range(i + 1, 0):\n        num[j] = 9\n    if sum(num) > sum(best):\n        best = num[:]\ns = ''.join(map(str, best)).lstrip('0')\nprint(s)\n
def main():\n    s = input()\n    n = len(s)\n    t = int(str(int(s[0]) + 1) + '0' * (n - 1))\n\n    print(t - int(s))\n\nmain()\n
from collections import defaultdict as dd\nimport math\ndef nn():\n	return int(input())\n\ndef li():\n	return list(input())\n\ndef mi():\n	return list(map(int, input().split()))\n\ndef lm():\n	return list(map(int, input().split()))\n\n\nn, q=mi()\n\nints=[]\n\n\nfor _ in range(q):\n	st, end=mi()\n	ints.append((st,end))\n\n\ncoverage=[10]+[0]*n\n\nfor st, end in ints:\n	for i in range(st,end+1):\n		coverage[i]+=1\n\ntotal=-1\n\nfor val in coverage:\n	if not val==0:\n		total+=1\n\nsinglecount=0\ndoublecount=0\n\nsingles=[0]*(n+1)\n#print(total)\ndoubles=[0]*(n+1)\nfor i in range(len(coverage)):\n	#print(i,singles)\n	if coverage[i]==1:\n		singlecount+=1\n	if coverage[i]==2:\n		doublecount+=1\n	singles[i]=singlecount\n	doubles[i]=doublecount\nmaxtotal=0\nfor i in range(len(ints)):\n	for j in range(i+1, len(ints)):\n		st1=min(ints[i][0],ints[j][0])\n		end1=min(ints[i][1],ints[j][1])\n		st2, end2=max(ints[i][0],ints[j][0]), max(ints[i][1],ints[j][1])\n		#assume st1<=st2\n		if end1<st2:\n			curtotal=total-(singles[end1]-singles[st1-1])-(singles[end2]-singles[st2-1])\n		elif end1<end2:\n			curtotal=total-(singles[st2-1]-singles[st1-1])-(doubles[end1]-doubles[st2-1])-(singles[end2]-singles[end1])\n		else:\n			curtotal=total-(singles[st2-1]-singles[st1-1])-(doubles[end2]-doubles[st2-1])-(singles[end1]-singles[end2])\n		maxtotal=max(maxtotal,curtotal)\n\nprint(maxtotal)\n		\n\n\n\n\n\n\n\n
x=int(input())\nh,m=list(map(int,input().split()))\ndef ok(mm):\n  while mm<0: mm+=1440\n  hh=mm//60\n  mm=mm%60\n  return hh%10==7 or hh//10==7 or mm%10==7 or mm//10==7\nfor y in range(999):\n  if ok(h*60+m-y*x):\n    print(y)\n    return\n
n, pos, l, r = map(int, input().split())\n\nif l > 1 and r < n:\n    if l <= pos and pos <= r:\n        if pos - l < r - pos:\n            print(pos - l + 1 + r - l + 1)\n        else:\n            print(r - pos + 1 + r - l + 1)\n    elif pos > r:\n        print(pos - r + 1 + r - l + 1)\n    else:\n        print(l - pos + 1 + r - l + 1)\nelif l == 1 and r < n:\n    print(int(abs(pos - r)) + 1)\nelif l > 1 and r == n:\n    print(int(abs(pos - l)) + 1)\nelse:\n    print(0)
for _ in range(int(input())):\n    n, x = list(map(int, input().split()))\n    A = []\n    for _1 in range(n):\n       d, h = list(map(int, input().split()))\n       A.append([d, h])\n    A.sort(reverse=True)\n    if A[0][0] >= x:\n        print(1)\n    else:\n        x -= A[0][0]\n        mz = 0\n        for d, h in A:\n            mz = max(mz, d - h)\n        if mz:\n            print((x + mz - 1) // mz + 1)\n        else:\n            print(-1)\n
n, m = map(int, input().split())\nif (m >= n): print(n)\nelse:\n    c = n - m\n    l = 0\n    r = 10 ** 18\n    while r - l > 1:\n        md = (r + l) // 2\n        if (1 + md) * md // 2 < c:\n            l = md\n        else:\n            r = md\n    print(r + m)
cards=list(input().split())\nlm=[0]*9\nlp=[0]*9\nls=[0]*9\nfor item in cards:\n    if item[1]=='m':\n        lm[int(item[0])-1]+=1\n    elif item[1]=='p':\n        lp[int(item[0])-1]+=1\n    else :\n        ls[int(item[0])-1]+=1\nif max(lm)==3 or max(lp)==3 or max(ls)==3:\n    print(0)\nelse :\n    flag=0\n    def seq_checker(li):\n        flag=0\n        for i in range(9):\n            if flag==0:\n                if lm[i]==1:\n                    flag=1\n            else :\n                if lm[i]==1:\n                    flag+=1\n                else :\n                    break\n        return flag\n    if seq_checker(lm)==3 or seq_checker(lp)==3 or seq_checker(ls)==3:\n        print(0)\n    elif max(lm)==2 or max(lp)==2 or max(ls)==2:\n        print(1)\n    else :\n        m=0\n        for i in range(0,7):\n            m=max(sum(lm[i:i+3]),sum(lp[i:i+3]),sum(ls[i:i+3]),m)\n        print(3-m)
from sys import stdin, stdout\n\nk = int(stdin.readline())\nn, m = map(int, stdin.readline().split())\nleft, right, down, up = [], [], [], []\ncoordinates = []\n\nfor i in range(k):\n    x1, y1, x2, y2 = map(int, stdin.readline().split())\n    \n    if x1 == x2:\n        if y1 < y2:\n            coordinates.append((x1, y1, x2, y2, i))\n        else:\n            coordinates.append((x2, y2, x1, y1, i))\n    else:\n        if x1 < x2:\n            coordinates.append((x1, y1, x2, y2, i))\n        else:\n            coordinates.append((x2, y2, x1, y1, i))\n    \n    left.append(coordinates[-1])\n    right.append(coordinates[-1])\n    up.append(coordinates[-1])\n    down.append(coordinates[-1])\n\nleft.sort(key = lambda x: (x[0], x[2]))\ndown.sort(key = lambda x: (x[1], x[3]))\n\nchallengers = [[], [], [], []]\ncntl, cntr, cntd, cntu = map(int, stdin.readline().split())\nlabel = 1\n\nif cntl or not cntl:\n    for i in range(cntl, -1, -1):\n        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):\n            challengers[0].append(left[i][-1])  \n        else:\n            break\n        \n    for i in range(cntl + 1, k):\n        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]) and left[i][2] > left[i][0]:\n            label = 0\n        \n        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):\n            challengers[0].append(left[i][-1])  \n        else:\n            break\n\nif cntr or not cntr:\n    for i in range(k - 1 - cntr, k):\n        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):\n            challengers[1].append(left[i][-1])\n        else:\n            break\n    \n    for i in range(k - 2 - cntr, -1, -1):\n        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]) and left[i][2] > left[i][0]:\n            label = 0\n        \n        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):\n            challengers[1].append(left[i][-1])\n        else:\n            break\n\n#!!!!!!!!!!!\n\nif cntd or not cntd:\n    for i in range(cntd, -1, -1):\n        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):\n            challengers[2].append(down[i][-1])\n        else:\n            break\n        \n    for i in range(cntd + 1, k):\n        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]) and down[i][3] > down[i][1]:\n            label = 0\n            \n        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):\n            challengers[2].append(down[i][-1])  \n        else:\n            break\n        \nif cntu or not cntu:\n    for i in range(k - 1 - cntu, k):\n        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):\n            challengers[3].append(down[i][-1])\n        else:\n            break\n    \n    for i in range(k - 2 - cntu, -1, -1):\n        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]) and down[i][3] > down[i][1]:\n            label = 0\n        \n        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):\n            challengers[3].append(down[i][-1])\n        else:\n            break\n\nans = set(challengers[0]) & set(challengers[1]) & set(challengers[2]) & set(challengers[3])\n\nif not len(ans) or not label:\n    stdout.write('-1')\nelse:\n    stdout.write(str(list(ans)[0] + 1))
n=int(input())\nr=n%7\nd=n//7\nprint(2*d+max(0,r-5),2*d+min(r,2))\n
from fractions import gcd\ndef lcm(a, b):\n    return a*b//gcd(a, b)\nn, a, b, p, q = list(map(int, input().split(' ')))\nred = n//a\nblue = n//b\nif (p<q):\n    red -= n//lcm(a, b)\nelse:\n    blue -= n//lcm(a, b)\n\nprint(p*red+q*blue)\n
n = int(input())\nA = input()\nx = A.count('G')\nnum_1 = 0\nnum_2 = 0\nmax_num = 0\nflag = 0\nfor i in range(n):\n    if A[i] == 'G' and flag == 0:\n        num_1 += 1\n    elif A[i] == 'G' and flag == 1:\n        num_2 += 1\n    elif A[i] == 'S' and flag == 0:\n        flag = 1\n    else:\n        if num_1 + num_2 + 1 <= x:\n            if num_1 + num_2 + 1 > max_num:\n                max_num = num_1 + num_2 + 1\n            num_1 = num_2\n            num_2 = 0\n            flag = 1\n        else:\n            if num_2 + num_1 > max_num:\n                max_num = num_1 + num_2\n            num_1 = num_2\n            num_2 = 0\n            flag = 1\nif num_1 + num_2 + 1 <= x:\n    if num_1 + num_2 + 1 > max_num:\n        max_num = num_1 + num_2 + 1\nelse:\n    if num_2 + num_1 > max_num:\n        max_num = num_1 + num_2\nprint(max_num)\n
#This code is dedicated to Vlada S.\n\nclass Course:\n	def __init__(self, reqs, number):\n		self.reqs = list(map(int, reqs.split()[1:]))\n		self.available = False\n		self.in_stack = False\n		self.number = number\n\nn, k = list(map(int, input().split()))\nrequirements = list(map(int, input().split()))\ncourses = {}\n\nanswer = ""\n\nfor i in range(n):\n	courses[i + 1]= Course(input(), i + 1)\n\nfor i in range(len(requirements)):\n	requirements[i] = courses[requirements[i]]\n\nwhile requirements:\n	data = {}\n\n	course = requirements.pop()\n\n	if not course.available:\n		requirements.append(course)\n\n		done = True\n\n		for c in course.reqs:\n			c = courses[c]\n\n			if not c.available:\n				requirements.append(c)\n				done = False\n\n		if done:\n			answer += " " + str(course.number)\n			course.available = True\n		else:\n			if course.in_stack:\n				print(-1)\n				break\n\n			course.in_stack = True\nelse:\n	print(answer.count(" "))\n	print(answer[1:])
import sys\n\n#f = open('input', 'r')\nf = sys.stdin\nn,k = list(map(int, f.readline().split()))\na = list(map(int, f.readline().split()))\naset = set(a)\nst = []\nfailed = False\nai = 0\napp = []\nfor p in range(1, n+1):\n  if p in aset:\n    while ai < k and (len(st)==0 or st[-1]!=p):\n      st.append(a[ai])\n      ai += 1\n    if len(st) == 0 or st[-1] != p:\n      failed = True\n      break\n    st.pop(-1)\n    a += app[::-1]\n    app = []\n  else:\n    if ai != k:\n      st += a[ai:k]\n      ai = k\n    app.append(p)\n\nif failed:\n  print(-1)\nelse:\n  print(' '.join(map(str, a + app[::-1])))\n
import sys\na,b,c=map(int,input().split())\nif c==0:\n    if a==b:\n        print('YES')\n    else:\n        print('NO')\n    return\nif (b-a)%c==0 and (b-a)//c>=0:\n    print('YES')\nelse:\n    print('NO')
cnt1 = int(input())\ncnt2 = int(input())\ncnt3 = int(input())\ncnt4 = int(input())\nif cnt1 != cnt4:\n	print(0)\n	return\n\nif (cnt3 != 0 and cnt1 == 0):\n	print(0)\n	return\n\nprint(1)
def read_ints():\n	return [int(i) for i in input().split()]\n\nn, k, t = read_ints()\nif t <= k:\n	print(t)\nelif t > n:\n	print(k + n - t)\nelse:\n	print(k)
from collections import deque\nS = input()\nmn = [ 300 for i in range( len( S ) ) ]\nfor i in range( len( S ) - 1, -1, -1 ):\n  if i == len( S ) - 1:\n    mn[ i ] = ord( S[ i ] )\n  else:\n    mn[ i ] = min( mn[ i + 1 ], ord( S[ i ] ) )\nans = ""\ndq = deque()\nfor i in range( len( S ) ):\n  dq.append( ord( S[ i ] ) )\n  while len( dq ) and ( i + 1 == len( S ) or dq[ len( dq ) - 1 ] <= mn[ i + 1 ] ):\n    ans += chr( dq[ len( dq ) - 1 ] )\n    dq.pop()\nprint( ans )\n
import sys\ninput = sys.stdin.readline\n\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    lastP = 0\n    lastC = 0\n    works = True\n    for _ in range(n):\n        p, c = list(map(int, input().split()))\n        pDiff = p-lastP\n        cDiff = c-lastC\n        if 0 <= cDiff <= pDiff:\n            pass\n        else:\n            works = False\n        lastP = p\n        lastC = c\n    if works:\n        print('YES')\n    else:\n        print('NO')\n
s = input()\nh = int(s[:2])\nm = int(s[3:])\n\ndef ispalin(h, m):\n    s = "%02d:%02d"%(h,m)\n    return s == s[::-1]\n\nfor d in range(999999):\n    if ispalin(h, m):\n        print(d)\n        break\n    m+= 1\n    if m == 60:\n        h = (h+1)%24\n        m = 0\n
read = lambda: list(map(int, input().split()))\nn = int(input())\na = list(read())\nx, y = a.index(1), a.index(n)\nans = max(x, y, n - x - 1, n - y - 1)\nprint(ans)\n
import sys, math\ns=input()\npal='AHIMOoTUVvWwXxY'\nn=len(s)\nl=0\nr=n-1\nflag=True\nfir='pq'\nsec='bd'\nwhile l<=r:\n    if s[l]==s[r] and s[l] in pal:\n        l+=1\n        r-=1\n        continue\n    elif s[l]==s[r]:\n        flag=False\n        break\n    elif (s[l] in fir) and (s[r] in fir):\n        l+=1\n        r-=1\n        continue\n    elif (s[l] in sec) and (s[r] in sec):\n        l+=1\n        r-=1\n        continue\n    else:\n        flag=False\n        break\nif flag:\n    print('TAK')\nelse:\n    print('NIE')\n    \n
a = list(input())\nb = int(input())\na.sort()\na = a[::-1]\nprefix = ""\nwhile(len(a) > 0):\n	for i in range(len(a)):\n		num = prefix + a[i] + "".join(sorted(a[:i] + a[i + 1:]))\n		if (int(num) <= b):\n			prefix += a[i]\n			a = a[:i] + a[i+1:]\n			break\nprint(prefix)\n
s = [ [ c for c in input() ] for i in range(10) ]\ndef win():\n  for i in range(10):\n    for j in range(10):\n      ok = True\n      for k in range(5):\n        if j+k>9: ok = False\n        elif s[i][j+k] != 'X': ok = False\n      if ok: return True\n      ok = True\n      for k in range(5):\n        if i+k>9: ok = False\n        elif s[i+k][j] != 'X': ok = False\n      if ok: return True\n      ok = True\n      for k in range(5):\n        if j+k>9 or i+k>9: ok = False\n        elif s[i+k][j+k] != 'X': ok = False\n      if ok: return True\n      ok = True\n      for k in range(5):\n        if i-k<0 or j+k>9: ok = False\n        elif s[i-k][j+k] != 'X': ok = False\n      if ok: return True\n  return False\nfor i in range(10):\n  for j in range(10):\n    if s[i][j]=='.':\n      s[i][j] = 'X'\n      if win():\n        print('YES')\n        return\n      s[i][j] = '.'\nprint('NO')\n
#!/usr/bin/env python3\n\ndef main():\n    import sys\n\n    readln = sys.stdin.readline\n    try:\n        while True:\n            n, k = list(map(int, input().split()))\n            a = [['0'] * n for i in range(n)]\n            i = j = 0\n            while k > 0:\n                if i == j:\n                    a[i][j] = '1'\n                    k -= 1\n                    j += 1\n                elif k >= 2:\n                    a[i][j] = a[j][i] = '1'\n                    k -= 2\n                    j += 1\n                elif i != n - 1:\n                    a[i + 1][i + 1] = '1'\n                    k = 0\n                else:\n                    assert a[i][i] == '1'\n                    a[i][i] = '0'\n                    a[i][j] = a[j][i] = '1'\n                    k = 0\n\n                if j == n:\n                    i += 1\n                    if i == n and k > 0:\n                        print(-1)\n                        break\n                    j = i\n            else:\n                for row in a:\n                    print(' '.join(row))\n\n    except EOFError:\n        pass\n\nmain()\n
from math import log\nfrom decimal import Decimal\n\ns = ['x^y^z', 'x^z^y', '(x^y)^z', 'y^x^z', 'y^z^x', '(y^x)^z', 'z^x^y', 'z^y^x', '(z^x)^y']\n\nx, y, z = list(map(Decimal, input().split()))\n\nf = []\nf += [(Decimal(log(x)) * (y ** z),  0)]\nf += [(Decimal(log(x)) * (z ** y), -1)]\nf += [(Decimal(log(x)) * (y *  z), -2)]\nf += [(Decimal(log(y)) * (x ** z), -3)]\nf += [(Decimal(log(y)) * (z ** x), -4)]\nf += [(Decimal(log(y)) * (x *  z), -5)]\nf += [(Decimal(log(z)) * (x ** y), -6)]\nf += [(Decimal(log(z)) * (y ** x), -7)]\nf += [(Decimal(log(z)) * (x *  y), -8)]\n\nf.sort()\n\nprint(s[-f[-1][1]])\n
n = int(input())\nst = input()\nans = n\nnow = ''\nma = 0\nfor i in range(n // 2):\n    now += st[i]\n    t = ''\n    for j in range(i + 1, 2 * i + 2):\n        t += st[j]\n    if t == now:\n        ma = i\nprint(ans - ma)\n
n = int(input())\nt = [1] + [0] * n\nb, a = d = [], []\nh, s = [], []\n\nfor i in range(n):\n    f, k = input().split()\n    d[int(k)].append(f)\n\nm = len(a)\nfor i in a:\n    if i.isdigit() and i[0] != '0':\n        j = int(i)\n        if 0 < j <= m:\n            t[j] = 1\n        elif m < j <= n:\n            t[j] = -1\n        else:\n            s.append(i)\n    else:\n        s.append(i)\nfor i in b:\n    if i.isdigit() and i[0] != '0':\n        j = int(i)\n        if m < j <= n:\n            t[j] = 1\n        elif 0 < j <= m:\n            t[j] = -1\n        else:\n            s.append(i)\n    else:\n        s.append(i)\n\nx = [j for j in range(1, m + 1) if t[j] < 0]\ny = [j for j in range(m + 1, n + 1) if t[j] < 0]\n\nu = [j for j in range(1, m + 1) if not t[j]]\nv = [j for j in range(m + 1, n + 1) if not t[j]]\n\nif not s and (x or y):\n    s = ['0']\n    if y:\n        i = y.pop()\n        v.append(i)\n    else:\n        i = x.pop()\n        u.append(i)\n    h.append(str(i) + ' 0')\n    t[i] = 0\n\nwhile x or y:\n    if v and x:\n        i = x.pop()\n        j = v.pop()\n        t[j] = 1\n        h.append(str(i) + ' ' + str(j))\n        u.append(i)\n    else:\n        u, v, x, y = v, u, y, x\n\nk = 1\nfor j in s:\n    while t[k] == 1: k += 1\n    h.append(j + ' ' + str(k))\n    k += 1\n\nd = '\nmove '\nprint(str(len(h)) + d + d.join(h) if h else 0)
x=int(input())\ndef s(a):\n  r=0\n  while a>0:\n    r+=a%10\n    a//=10\n  return r\ndef d(a,b):\n  r=0\n  for i in range(6):\n    if a%10!=b%10:\n      r += 1\n    a//=10\n    b//=10\n  return r\nc=6\nfor i in range(1000000):\n  if s(i%1000)==s(i//1000):\n    c=min(c,d(x,i))\nprint(c)\n
from math import gcd\ndef powmod(a,b,m):\n a%=m\n r=1\n while b:\n  if b&1:r=r*a%m\n  a=a*a%m\n  b>>=1\n return r\n\ndef f(n):\n r=[]\n if (n&1)==0:\n  e=0\n  while (n&1)==0:n>>=1;e+=1\n  yield (2,e)\n p=3\n while n>1:\n  if p*p>n:p=n\n  if n%p:\n   p+=2\n   continue\n  e=1;n//=p\n  while n%p==0:n//=p;e+=1\n  yield (p,e)\n  p+=2\n return r\nm,x=map(int,input().split())\np=2\nr=[(1,1)]\nfor p,e in f(m):\n assert e>=1\n ord=p-1\n assert powmod(x,ord,p)==1\n for pi,ei in f(p-1):\n  while ord % pi == 0 and powmod(x,ord//pi,p)==1: ord//=pi\n ords=[(1,1),(ord,p-1)]\n q=p\n for v in range(2,e+1):\n  q*=p\n  if powmod(x,ord,q)!=1:ord*=p\n  assert powmod(x,ord,q)==1\n  ords.append((ord,q//p*(p-1)))\n r=[(a//gcd(a,c)*c,b*d) for a,b in r for c,d in ords]\nprint(sum(y//x for x,y in r))
m = 10** 6 + 3\n\nn, k = list(map(int, input().split()))\np = 1\nfor i in range(n):\n    p *= 2\n    if p > k:\n        break\nif p < k:\n    print('1 1')\n    return\n\ngcd = tmp = k - 1\nwhile tmp:\n    gcd -= tmp % 2\n    tmp //= 2\nb = pow(2, (k - 1) * n - gcd, m)\na = 1\nmem = [-1]*100\nfor i in range(1, k):\n    cnt = 0\n    while i % 2 == 0:\n        i //= 2\n        cnt += 1\n    if mem[cnt] == -1:\n        mem[cnt] = pow(2, n - cnt, m)\n    a = a * (mem[cnt] - i + m) % m\n    if a == 0:\n        break\nprint((b - a + m) % m, b)\n
"""\nCodeforces Good Bye 2016 Contest Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.5.2\n"""\n\n################################################### SOLUTION\n\ndef main():\n    latitude = 0\n    n, = read()\n    for i in range(n):\n        l, d = read(str)\n        l = int(l)\n        if latitude == 0:\n            if d != "South":\n                return "NO"\n        if latitude == 20000:\n            if d != "North":\n                return "NO"\n        if d == "South":\n            latitude += l\n        elif d == "North":\n            latitude -= l\n        if not (0 <= latitude <= 20000):\n            return "NO"\n    if latitude != 0:\n        return "NO"\n    return "YES"\n\n#################################################### HELPERS\n\ndef read(callback=int):\n    return list(map(callback, input().strip().split()))\n\ndef write(value, end="\n"):\n    if value is None: return\n    try:\n        if not isinstance(value, str):\n            value = " ".join(map(str, value))\n    except:\n        pass\n    print(value, end=end)\n\nwrite(main())\n
import sys, collections\n\ndef gcd(a, b):\n    if b == 0: return a\n    return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a // gcd(a, b) * b\n\ndef extgcd(a, b):\n    if b == 0: return 1, 0\n    x, y = extgcd(b, a % b)\n    return y, x - a // b * y\n\ndef prime_factor(n):\n    res = collections.defaultdict(int)\n\n    i = 2\n    while i * i <= n:\n        cnt = 0\n        while n % i == 0:\n            n //= i\n            cnt += 1\n        if cnt > 0: res[i] = cnt\n        i += 1\n    if n != 1: res[n] = 1\n\n    return res\n\ndef modinv(a, mod):\n    if a == 0: return -1\n    if gcd(a, mod) != 1: return -1\n    return extgcd(a, mod)[0] % mod\n\ndef normalize(a1, a2):\n    p1 = prime_factor(a1)\n    p2 = prime_factor(a2)\n\n    keys = list(set(p1.keys()) | set(p2.keys()))\n\n    r1 = 1\n    r2 = 1\n    for k in keys:\n        if p1[k] >= p2[k]:\n            r1 *= k ** p1[k]\n        else:\n            r2 *= k ** p2[k]\n    return r1, r2\n\ndef solve(a1, b1, a2, b2):\n    g = gcd(a1, a2)\n    if (b1 - b2) % g != 0: return -1\n\n    a1, a2 = normalize(a1, a2)\n    u = b1 % a1\n    inv = modinv(a1, a2)\n    v = (b2 - u) * inv % a2\n    return u + v * a1\n\ndef f(x0, T, v):\n    ok = 10 ** 36\n    ng = -1\n\n    while ok - ng > 1:\n        mid = (ok + ng) // 2\n\n        if x0 + T * mid >= v:\n            ok = mid\n        else:\n            ng = mid\n\n    return ok\n\na1, b1, a2, b2, L, R = map(int, input().split())\n\nT = lcm(a1, a2)\nx0 = solve(a1, b1, a2, b2)\n\nif x0 == -1:\n    print(0)\n    return\n\nx0 -= T * 10 ** 36\n\nok = 10 ** 60\nng = -1\n\nwhile ok - ng > 1:\n    mid = (ok + ng) // 2\n\n    val = x0 + T * mid\n    k = (val - b1) // a1\n    l = (val - b2) // a2\n    if k >= 0 and l >= 0:\n        ok = mid\n    else:\n        ng = mid\n\nx0 += ok * T\n\n# L <= x0 + kT < R + 1\nans = f(x0, T, R + 1) - f(x0, T, L)\n\nprint(ans)
n, a, b = map(int, input().split())\nans = 0\nfor i in range(1, n):\n    ans = max(ans, min(a // i, b // (n - i)))\nprint(ans)
n,m=list(map(int,input().split()))\nf=[input() for _ in range(n)]\ndef clr(ss):\n    cc = None\n    for s in ss:\n        for c in s:\n            if cc is None:\n                cc = c\n            elif cc != c:\n                return None\n    return cc\nif n%3 == 0:\n    s = set()\n    for i in range(0,n,n//3):\n        ret = clr(f[i:i+n//3])\n        if ret is None:\n            continue\n        s.add(ret)\n    if len(s) == 3:\n        print('YES')\n        return\nif m%3 == 0:\n    s = set()\n    for j in range(0,m,m//3):\n        ff = []\n        for i in f:\n            ff.append(i[j:j+m//3])\n        ret = clr(ff)\n        if ret is None:\n            continue\n        s.add(ret)\n    if len(s) == 3:\n        print('YES')\n        return\nprint('NO')\n
def f(n):\n	left, right = -1, n + 1\n	while right - left > 1:\n		mid = (left + right) // 2\n		x = 6 * mid * (mid + 1) // 2 + 5 * (mid + 1)\n		if x > n:\n			right = mid\n		else:\n			left = mid\n	if left >= 0:\n		mid = left\n		x = 6 * mid * (mid + 1) // 2 + 5 * (mid + 1)\n		n -= x\n	return (n, left + 1)\n\ndef main():\n	n = int(input())\n	n, k = f(n)\n	x = k\n	y = -2 * k\n	\n	d = [k + 1] * 6\n	d[1] -= 1\n	dx = [1, -1, -2, -1,  1, 2]\n	dy = [2,  2,  0, -2, -2, 0]\n	\n	for i in range(6):\n		x += min(d[i], n) * dx[i]\n		y += min(d[i], n) * dy[i]\n		n = max(0, n - d[i])\n	\n	print(x, y)\n\n\nmain()\n
a, b, c = list(map(int, input().split()))\np = [0] * 100000\np[0] = 1\np[a] = 1\np[b] = 1\nfor i in range(c + 1):\n    if p[i]:\n        p[i + a] = 1\n        p[i + b] = 1\nif p[c]:\n    print('Yes')\nelse:\n    print('No')\n
def main():\n	n, l = map(int, input().split())\n\n	x = list(map(int, input().split()))\n	y = list(map(int, input().split()))\n\n	x.append(x[0] + l)\n	y.append(y[0] + l)\n\n	a = [x[i + 1] - x[i] for i in range(n)]\n	b = [y[i + 1] - y[i] for i in range(n)]\n\n	for i in range(n):\n		if (a == b[i:] + b[:i]):\n			print("YES")\n			return\n	print("NO")\n\n\nmain()
s = input()\nmx = 0\nn = len(s)\nfor l in range(n):\n    for r in range(l, n):\n        if s[l:r+1] != s[l:r+1][::-1]:\n            mx = max(mx, r - l + 1)\nprint(mx)
'''input\n5\n3123 3123\n2777 2777\n2246 2246\n2246 2246\n1699 1699\n'''\nn = int(input())\nx = []\nf = 0\nfor _ in range(n):\n	a, b = list(map(int, input().split()))\n	if a != b:\n		f = 1\n	x.append(a)\nif f == 1:\n	print("rated")\nelif sorted(x)[::-1] == x:\n	print("maybe")\nelse:\n	print("unrated")\n\n\n\n\n\n\n\n
inf = 10 ** 6\nn = int(input())\na = list(map(int, input().split()))\ndist = [inf] * n\nfor i in range(len(a)):\n    if not a[i]:\n        dist[i] = 0\n        cur = 1\n        i1 = i\n        while i1 - 1 > - 1 and a[i1 - 1] != 0:\n            dist[i1 - 1] = min(dist[i1 - 1], cur)\n            i1 -= 1\n            cur += 1\n        i1 = i\n        cur = 1\n        while i1 + 1 < n and a[i1 + 1] != 0:\n            dist[i1 + 1] = min(dist[i1 + 1], cur)\n            i1 += 1\n            cur += 1\nprint(*dist)
n=int(input())\ns=[c=='1' for c in input()]\nm=len(s)\nz=[[0,0]]\nfor c in s:\n ind = z[-1][c]\n z[-1][c] = len(z)\n z.append(z[ind][:])\nassert(len(z) == m+1)\nz[m][0] = z[m][1] = m # make it sticky\n\n# how many things match directly\ndp = [0 for _ in range(m+1)]\ndp[0] = 1\nfor i in range(n):\n ndp = [0 for _ in range(m+1)]\n for i in range(m+1):\n  ndp[z[i][0]] += dp[i]\n  ndp[z[i][1]] += dp[i]\n dp = ndp\nres = dp[m]\n\nfor k in range(1, m):\n s0 = 0\n for c in s[-k:]:\n  s0 = z[s0][c]\n dp = [0 for _ in range(m+1)]\n dp[s0] = 1\n for i in range(n - k):\n  ndp = [0 for _ in range(m+1)]\n  for i in range(m+1):\n   ndp[z[i][0]] += dp[i]\n   ndp[z[i][1]] += dp[i]\n  dp = ndp\n for s1 in range(m): # skip m\n  v = dp[s1]\n  for c in s[-k:]:\n   if s1 == m: v = 0\n   s1 = z[s1][c]\n  if s1 == m: res += v\nprint(res)
from math import *\n# stores counterclockwise angle between vector (1,0) and each vector in a\na = []\nn = int(input())\nfor i in range(n):\n    x,y = list(map(int,input().split()))\n    # calculate counterclockwise angle between (1,0) and this vector\n    t = acos(x/sqrt(x**2+y**2))\n    a.append((i+1,[2*pi-t,t][y>=0],x,y))\ncmp = lambda x:x[1]\na = sorted(a,key=cmp)\n# construct pairs for adjacent vectors\nb = []\nfor i in range(n):\n    i1,i2 = a[i][0],a[(i+1)%n][0]\n    x1,y1 = a[i][2:]\n    x2,y2 = a[(i+1)%n][2:]\n    inner_prod = x1*x2 + y1*y2\n    inner_prod *= abs(inner_prod)\n    norm_prod = ((x1**2+y1**2)*(x2**2+y2**2))\n    b.append((i1,i2,inner_prod,norm_prod))\n# find the nearest vector\nbetter = lambda p1,p2: p1[2]*p2[3]>p2[2]*p1[3]\nans = b[-1]\nfor i in range(n):\n    if better(b[i],ans):\n        ans = b[i]\nprint(ans[0],ans[1])\n
d, k, a, b, t = list(map(int, input().split()))\n\nt1 = d * b\nt2 = d * a + ((d - 1) // k) * t\nt3 = max(0, d - k) * b + min(k, d) * a\ndd = d % k\nd1 = d - dd\nt4 = d1 * a + max(0, (d1 // k - 1) * t) + dd * b\n\nprint(min([t1, t2, t3, t4]))\n
n, k = map(int, input().split())\ndiv = []\ni = 1\nn1 = n\nwhile i * i <= n:\n    if n % i == 0:\n        div.append(i)\n        div.append(n // i)\n    i += 1\ndiv.sort()\nmx = -1\nfor i in range(len(div)):\n    a = div[i] * k * (k + 1) // 2\n    if a <= n:\n        mx = div[i]\nif mx == -1:\n    print(-1)\nelse:\n    for i in range(k - 1):\n        print(mx * (i + 1), end= " ")\n    print(n - mx * k * (k - 1) // 2)\n\n    
ct=0\na, b = list(map(int, input().split(' ')))\nx=[0]*5\nfor i in range(1, b+1):\n    x[i%5]+=1\nfor i in range(1, a+1):\n    ct+=x[(0-i)%5]\nprint(ct)\n
N, X = list(map(int, input().split()))\nA = [int(a) for a in input().split()]\n\ndp = [[0]*4 for _ in range(N+1)]\n\nfor i in range(1, N+1):\n    dp[i][0] = max(dp[i-1][0] + A[i-1], 0)\n    dp[i][1] = max(dp[i-1][1] + A[i-1] * X, dp[i][0])\n    dp[i][2] = max(dp[i-1][2] + A[i-1], dp[i][1])\n    dp[i][3] = max(dp[i-1][3], dp[i][2])\n\nprint(dp[N][3])\n
def main():\n    from math import sqrt\n    m, n, k = list(map(int, input().split()))\n    if n < m:\n        n, m = m, n\n    lo, hi = 1, k + 1\n    while lo + 1 < hi:\n        mid = (lo + hi) // 2\n        t = mid - 1\n        v = min(int(sqrt(t)), m)\n        tn, tm = (t - 1) // m, t // n\n        vv = [t // i for i in range(tm + 1, v + 1)]\n        if t // n * (n + m) + sum(vv) * 2 + max(min((tn - tm), len(vv)) * m, 0) - v * v - sum(\n                vv[:max(min(tn - tm, len(vv)), 0)]) < k:\n            lo = mid\n        else:\n            hi = mid\n    print(lo)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
k = int(input())\n\nif k<=9:\n    print(k)\nelse:\n    num_arr = [9*(i+1)* 10**i for i in range(11)]\n\n    index = 0\n\n    while True:\n        if k<=num_arr[index]:\n            break\n        else:\n            k -= num_arr[index]\n            index += 1\n\n    digit = index+1\n    k += digit-1\n\n\n    num = k//digit\n    offset = k%digit\n\n    string_num = str(10**(digit-1)+ num-1)\n\n    print(string_num[offset])\n\n
n, m, r = map(int, input().split())\nS = list(map(int, input().split()))\nB = list(map(int, input().split()))\nx = min(S)\ny = max(B)\ncnt = r % x\nact = r // x\ncnt += act * y\nprint(max(r, cnt))
s = input()\nt = 0\nif len(s)%2==0:\n    n = (len(s)-1)//2+1\nelse:\n    n = (len(s)-1)//2\nfor i in range(n, len(s)-1):\n    a = i\n    b = len(s)-i-1\n    if s[:a+1]==s[b:]:\n        print('YES')\n        print(s[:a+1])\n        t = 1\n        break\nif t==0:\n    print('NO')
n = int(input())\nres = set()\nfor r in range(100):\n    a = 1\n    b = 2**(r + 1) - 3\n    c = -2 * n\n    d = b * b - 4 * a * c\n    if d < 0:\n        continue\n    le = 0\n    ri = d\n    while le < ri:\n        c = (le + ri) // 2\n        if c * c < d:\n            le = c + 1\n        else:\n            ri = c\n    if le * le == d:\n        if (-b - le) % 4 == 2 and -b - le > 0:\n            res.add((-b - le) // 2 * 2**r)\n        if (-b + le) % 4 == 2 and -b + le > 0:\n            res.add((-b + le) // 2 * 2**r)\nfor i in sorted(list(res)):\n    print(i)\nif not list(res):\n    print(-1)\n
from collections import Counter\n\nr = lambda: list(map(int, input().split()))\n\ndef main():\n	n, = r()\n	s = input()\n	cost = list(r())\n\n	ans = 0\n\n	cnt = Counter()\n\n	for i in range(n // 2):\n		if s[i] == s[n - 1 - i]:\n			ans += min(cost[i], cost[n - 1 - i])\n			cnt[s[i]] += 1\n	total = sum(cnt.values())\n	if total > 0:\n		ch, occ = cnt.most_common(1)[0]\n		avail = []\n		if occ > total - occ:\n			for i in range(n // 2):\n				if s[i] != s[n - 1 - i] and s[i] != ch and s[n - 1 - i] != ch:\n					avail.append(min(cost[i], cost[n - 1 - i]))\n			avail.sort()\n			ans += sum(avail[:2 * occ - total])\n\n	print(sum(cost) - ans)\n\nmain()\n
w,m=map(int,input().split())\n\nbb=True\n\nwhile(m>0 and bb):\n	x=m%w\n	if x==1:m-=1\n	elif x==w-1:m+=1\n	elif x!=0:bb=False\n	m//=w\n	\nif bb:print("YES")\nelse:print("NO")
from collections import defaultdict\n\ndef solve(n, k):\n    as_bin = bin(n)[2:]\n    cnt = defaultdict(int)\n    cnt.update({i : 1 for i, b in enumerate(reversed(as_bin)) if b == '1'})\n    curr_len = len(cnt)\n    curr_pow = len(as_bin) - 1\n\n    if curr_len > k:\n        return None\n\n    while True:\n        new_len = curr_len + cnt[curr_pow]\n        if new_len > k:\n            break\n        cnt[curr_pow - 1] += 2 * cnt[curr_pow]\n        del cnt[curr_pow]\n        curr_pow -= 1\n        curr_len = new_len\n\n    i = min(cnt.keys())\n    while curr_len < k:\n        cnt[i] -= 1\n        cnt[i - 1] += 2\n        curr_len += 1\n        i -= 1\n\n    ans = []\n    for i in sorted(list(cnt.keys()), reverse=True):\n        ans.extend([i] * cnt[i])\n    return ans\n\nn, k = [int(v) for v in input().split()]\nans = solve(n, k)\n\nif ans is None:\n    print('No')\nelse:\n    print('Yes')\n    print(' '.join(str(c) for c in ans))\n
n, t = list(map(int,input().split()))\ng = [[0.0] * i for i in range(1,n+1)]\n\n\nfor _ in range(t):\n    g[0][0] += 1.0\n    for i in range(n):\n        for j in range(i+1):\n            spill = max(0, g[i][j] - 1.0)\n            g[i][j] -= spill\n            if i < n - 1:\n                g[i + 1][j] += spill / 2\n                g[i + 1][j + 1] += spill / 2\n    if g[n-1][0] == 1.0:\n        break\n\ncnt = 0\nfor i in range(n):\n    for j in range(i + 1):\n        if g[i][j] == 1.0:\n            cnt += 1\nprint(cnt)\n
n = int(input())\npoints = [[int(x) for x in input().split()] for _ in range(n)]\nif n <= 1:\n	print(-1)\n	return\ndx = [1e9, -1e9]\ndy = [1e9, -1e9]\nfor x, y in points:\n	dx[0] = min(dx[0], x)\n	dx[1] = max(dx[1], x)\n	dy[0] = min(dy[0], y)\n	dy[1] = max(dy[1], y)\narea = (dx[1] - dx[0]) * (dy[1] - dy[0])\nif area:\n	print(area)\nelse:\n	print(-1)\n
'''input\n6\n4\n2\n'''\n\ndef list_input():\n    return list(map(int,input().split()))\ndef map_input():\n    return map(int,input().split())\ndef map_string():\n    return input().split()\n \ndef f(n,a,b,left,cnta = 4,cntb = 2):\n	if(cnta == 0 and cntb == 0): return 0\n	if(cnta < 0 or cntb < 0): return 100000000000000000000\n	if a <= left and cnta and b <= left and cntb:\n		return min(f(n,a,b,left-a,cnta-1,cntb),f(n,a,b,left-b,cnta,cntb-1))\n	if a <= left and cnta:\n		return f(n,a,b,left-a,cnta-1,cntb)\n	if b <= left and cntb:\n		return f(n,a,b,left-b,cnta,cntb-1)\n	return 1+min(f(n,a,b,n-a,cnta-1,cntb),f(n,a,b,n-b,cnta,cntb-1))			\n\nn = int(input())\na = int(input())\nb = int(input())\nprint(f(n,a,b,0))
n = int(input())\na = list(map(int,input().split()))\np = input()\nm = 0\nsuc = True\nfor i in range(n-1):\n    m = max(m,a[i])\n    if p[i] == '0' and m>(i+1):\n        suc = False\n        break\nif suc:\n    print('YES')\nelse:\n    print('NO')\n
seat = input()\ntime_to = {'a': 4, 'f': 1, 'b': 5, 'e': 2, 'c': 6, 'd': 3}\ncol = seat[-1]\nrow = int(seat[:-1])\nrow -= 1\n\nblocks_to_serve = row // 4\ntime = (6 * 2 + 4) * blocks_to_serve\n\nif row % 2 == 1:\n    time += 6 + 1\n\ntime += time_to[col]\n\nprint(time)\n
n, bx = list(map(int, input().split()))\nx1 = list(map(int, input().split()))\nx = 0\nfor i in range(n):\n	x *= bx\n	x += x1[i]\n\nn, by = list(map(int, input().split()))\ny1 = list(map(int, input().split()))\ny = 0\nfor i in range(n):\n	y *= by\n	y += y1[i]\n\nif x == y:\n	print('=')\nelif x < y:\n	print('<')\nelse:\n	print('>')\n
from math import *\nn=int(input())\nif n==3:\n    li=list(map(int,input().split()))\n    ans=0\n    flag=0\n    for i in li:\n        ans^=i\n    if ans==0:\n        print("BitAryo")\n    else:\n        print("BitLGM")\nelif n==2:\n    li=list(map(int,input().split()))\n    li.sort()\n    phi=(1+sqrt(5))/2\n    ch=[0]*(785)\n    for i in range(300):\n        a=floor(phi*i)\n        b=floor((phi**2)*i)\n        ch[a]=b\n        ch[b]=a\n    if ch[li[0]]==li[1]:\n        print("BitAryo")\n    else:\n        print("BitLGM")\nelse:\n    li=int(input())\n    if li==0:\n        print("BitAryo")\n    else:\n        print("BitLGM")\n
n,k=map(int,input().split())\nl=list(map(int,input().split()))\npf=[]\nneeded=[]\nfor i in range(2,40000):\n	if k%i==0:\n		pf.append(i)\n		c=0\n		while k%i==0:\n			k//=i\n			c+=1\n		needed.append(c)\nif k>1:\n	pf.append(k)\n	needed.append(1)\npfl=len(pf)\ncnt=[[0]*n for i in range(pfl)]\nfor i in range(n):\n	for j in range(len(pf)):\n		c=0\n		while l[i]%pf[j]==0:\n			c+=1\n			l[i]//=pf[j]\n		cnt[j][i]=c\nhave=[sum(i) for i in cnt]\npos=n\ndef ok():\n	for i in range(len(pf)):\n		if have[i]<needed[i]:\n			return False\n	return True\nif not ok():\n	print(0)\n	quit()\nfor i in range(n-1,0,-1):\n	for j in range(len(pf)):\n		have[j]-=cnt[j][i]\n	if not ok():\n		for j in range(len(pf)):\n			have[j]+=cnt[j][i]\n		break\n	pos=i\nans=n-pos+1\nfor x in range(n-1):\n	for j in range(len(pf)):\n		have[j]-=cnt[j][x]\n	if pos==(x+1):\n		for j in range(len(pf)):\n			have[j]+=cnt[j][pos]\n		pos+=1\n	while pos<n:\n		if ok():\n			break\n		else:\n			for i in range(len(pf)):\n				have[i]+=cnt[i][pos]\n			pos+=1\n	if ok():\n		ans+=n-pos+1\n	else:\n		break\nprint(ans)
alpha = [chr(ord('a')+i) for i in range(26)]\nn,k = list(map(int,input().split()))\ns = input()\narr = [s.count(alpha[i]) for i in range(26)]\n\nprint('YES' if max(arr) <= k else 'NO')\n
n = int(input())\nA = [int(x) for x in input().split()]\nmn = min(A)\n\nI = [i for i in range(len(A)) if A[i] == mn]\nmindiff = min(I[i]-I[i-1] for i in range(1,len(I)))\nprint(mindiff)\n
from fractions import gcd\n\nt,w,b = map(int,input().split())\nper = w*b//gcd(w,b)\ncan = (t//per+1)*min(w,b)-1\nif t%per<min(w,b):\n    can-=min(w,b)\n    can+=t%per+1\ng = gcd(can,t)\ncan//=g\nt//=g\nprint(str(can)+"/"+str(t))
x, y, z = map(int, input().split())\nif z == 0:\n    if x == y:\n        print('0')\n    elif x > y:\n        print('+')\n    else:\n        print('-')\nelse:\n    if x > y + z:\n        print('+') \n    elif x + z < y:\n        print('-')\n    else:\n        print('?')
#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\n    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit\n    \nN, = getIntList()\n#print(N)\nS = input()\n\nX, Y = getIntList()\n\ndd = ( (0,1), (0,-1), (-1,0), (1,0))\npp = 'UDLR'\nzz = {}\nfor i in range(4):\n    zz[ pp[i]] = dd[i]\n\n\nif abs(X) + abs(Y) >N:\n    print(-1)\n    return\n\nif abs(X+Y-N)%2==1:\n    print(-1)\n    return\n    \nfromLeft = [None for i in range(N)]\nfromRight = fromLeft.copy()\n\nx0 = 0\ny0 = 0\nfor i in range(N):\n    x = S[i]\n    fromLeft[i] = (x0,y0)\n    g = zz[x]\n    x0+= g[0]\n    y0+= g[1]\n\nif x0==X and y0==Y:\n    print(0)\n    return\n\nx0 = 0\ny0 = 0\nfor i in range(N-1,-1,-1):\n    x = S[i]\n    fromRight[i] = (x0,y0)\n    g = zz[x]\n    x0+= g[0]\n    y0+= g[1]\n\n\nup = N\ndown = 0\ndprint(fromLeft)\ndprint(fromRight)\nwhile down+1<up:\n    mid = (up+down)//2\n    dprint('mid', mid)\n    ok = False\n    for i in range(N-mid + 1):\n        tx = fromLeft[i][0] + fromRight[i+mid-1][0]\n        ty = fromLeft[i][1] + fromRight[i+mid-1][1]\n        gg = abs(X-tx) + abs(Y- ty)\n        if gg <= mid:\n            ok = True\n            break\n    if ok:\n        up = mid\n    else:\n        down = mid\n        \nprint(up)\n\n
t=int(input())\nfor i in ' '*t:\n    n,x=map(int,input().split())\n    s=input()\n    L=[0]\n    for i in s:\n        if i=='0':L.append(L[-1]+1)\n        else:L.append(L[-1]-1)\n    L.pop(0)\n    k=L[-1]\n    c=0\n    if x==0:c+=1\n    if k>0:\n        for i in L:\n            if i%k==x%k and i<=x:c+=1\n        print(c)\n    elif k<0:\n        for i in L:\n            if i%k==x%k and i>=x:c+=1\n        print(c)\n    else:\n        for i in L:\n            if i==x:c=-1\n        print(c)
s = input().split()\nk = int(s[1])\ns = s[0]\nif s.count('0') < k:\n    if s.count('0') > 0:\n        print(len(s) - 1)\n    else:\n        print(len(s))\n    return\nhave = 0\nits = 0\nfor i in range(len(s) - 1, -1, -1):\n    its += 1\n    if s[i] == '0':\n        have += 1\n    if have == k:\n        print(its - have)\n        return
n, m, k, x, y = list(map(int, input().split()))\n\nans = [[0] * m for x in range(n)]\n\nonebig = (2*n-2)*m or m\n\noo = k // onebig\n\nfor i in range(n):\n    for j in range(m):\n        if i == 0 or i == n-1:\n            ans[i][j] += oo\n            k -= oo\n        else:\n            ans[i][j] += 2*oo\n            k -= 2*oo\n\nfrom itertools import chain\n\nfor i in chain(list(range(n)), list(range(n-2, 0, -1))):\n    if not k:\n        break\n    for j in range(m):\n        if not k:\n            break\n        ans[i][j] += 1\n        k -= 1\n\n_max = max(list(map(max, ans)))\n_min = min(list(map(min, ans)))\n_ans = ans[x-1][y-1]\n\n\nprint(_max, _min, _ans)\n
turns = int(input())\ns0 = input()\ns1 = input()\ns2 = input()\n\nd0 = dict()\nd1 = dict()\nd2 = dict()\n\nalphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\nfor char in alphabet:\n	d0[char] = 0\n	d1[char] = 0\n	d2[char] = 0\n\nfor char in s0:\n	d0[char] += 1\nfor char in s1:\n	d1[char] += 1\nfor char in s2:\n	d2[char] += 1	\n\nm0 = max([d0[char] for char in alphabet])\nm1 = max([d1[char] for char in alphabet])\nm2 = max([d2[char] for char in alphabet])\n\nl0 = len(s0)\nl1 = len(s1)\nl2 = len(s2)\n\nif turns == 1 and m0 == l0:\n	score0 = m0 - 1\nelse:\n	score0 = min(l0,m0+turns)\n\nif turns == 1 and m1 == l1:\n	score1 = m1 - 1\nelse:\n	score1 = min(l1,m1+turns)\n\nif turns == 1 and m2 == l2:\n	score2 = m2 - 1\nelse:\n	score2 = min(l2,m2+turns)\n	\nscores = [score0,score1,score2]\nbestscore = max(scores)\n\nwinnerlist = [i for i in range(3) if scores[i] == bestscore]\nif len(winnerlist) > 1:\n	print('Draw')\nelse:\n	print(['Kuro','Shiro','Katie'][winnerlist[0]])
read = lambda: map(int, input().split())\nc, v0, v1, a, l = read()\ncur = 0\ncnt = 0\nwhile cur < c:\n    cur = max(0, cur - l)\n    cur += min(v1, v0 + a * cnt)\n    cnt += 1\nprint(cnt)
import math\n\nn=int(input())\n\ndef prime(p):\n    if p == 1:\n        return False\n    fl=True\n    for i in range(2,math.ceil(p**0.5) + 1):\n        if p % i == 0:\n            fl=False\n    return fl\n\ndef sum_of_primes(k):\n    fl=True\n    for i in range((k // 2) + 1):\n        if prime(i) and prime(k-i):\n            fl=True\n            break\n    return fl\n\nif prime(n):\n    print(1)\n    print(n)\nelse:\n    if prime(n-2):\n        print(2)\n        print(2 , n-2)\n    else:\n        l=1\n        for i in range(2, (n // 3) + 1):\n            if prime(i) and sum_of_primes(n - i):\n                l=i\n                break\n        print(3)\n        r=1\n        for k in range((n-l) // 2):\n            if prime(k) and prime(n-l-k):\n                r=k\n                break\n        print(l,r,n-l-r)\n\n            \n
n, m = list(map(int, input().split()))\np = []\nans = 0\nfor i in range(n):\n    s = input()\n    ans += s.count('*')\n    p.append(s)\ndp = []\nfor i in range(n):\n    dp.append([0] * m)\nfor i in range(n):\n    col = p[i].count('*')\n    for t in range(m):\n        dp[i][t] = col\nfor i in range(m):\n    col = 0\n    for t in range(n):\n        if p[t][i] == '*':\n            col += 1\n    for t in range(n):\n        dp[t][i] += col\nf = False\nfor i in range(n):\n    for t in range(m):\n        if dp[i][t] - int(p[i][t] == '*') == ans:\n            f = True\n            print('YES')\n            print(i + 1, t + 1)\n            break\n    if f:\n        break\nif not f:\n    print('NO')\n
n, m, a, b = list(map(int, input().split()))\n\nk = n%m\nprint(min(k*b, (m - k)*a))\n
n = int(input())\na = list(map(int, input().split()))\nres = 0\nnew_a = []\nfor i in range(n):\n    if a[i] % 2 == 0:\n        if a[i] > 0:\n            res += a[i]\n    else:\n        new_a.append(a[i])\na = new_a\na.sort()\nres += a[-1]\na.pop()\nwhile len(a) > 1:\n    if a[-1] + a[-2] > 0:\n        res += a[-1] + a[-2]\n        a.pop()\n        a.pop()\n    else:\n        break\nprint(res)
from math import factorial\n\n\ndef lol(n):\n    if n == 1:\n        yield [0]\n        yield [1]\n    else:\n        for p in lol(n - 1):\n            p.append(0)\n            yield p\n            p[-1] = 1\n            yield p\n            p.pop()\n\n\ndef sp(g1, g2, g3, f):\n    if g1 == 0:\n        if g2 == g3:\n            return 2\n        elif abs(g2 - g3) == 1:\n            return 1\n        else:\n            return 0\n    elif g2 == 0:\n        if g1 == g3:\n            return 2\n        elif abs(g1 - g3) == 1:\n            return 1\n        else:\n            return 0\n    elif g3 == 0:\n        if g2 == g1:\n            return 2\n        elif abs(g2 - g1) == 1:\n            return 1\n        else:\n            return 0\n    else:\n        if f == 1:\n            b = sp(g1, g2 - 1, g3, 2)\n            c = sp(g1, g2, g3 - 1, 3)\n            return b + c\n        elif f == 2:\n            a = sp(g1 - 1, g2, g3, 1)\n            c = sp(g1, g2, g3 - 1, 3)\n            return a + c\n        elif f == 3:\n            a = sp(g1 - 1, g2, g3, 1)\n            b = sp(g1, g2 - 1, g3, 2)\n            return a + b\n        else:\n            a = sp(g1 - 1, g2, g3, 1)\n            b = sp(g1, g2 - 1, g3, 2)\n            c = sp(g1, g2, g3 - 1, 3)\n            return a + b + c\n\n\nn, T = map(int, input().split())\nS = []\ncnt = 0\nM = 10 ** 9 + 7\nfor i in range(n):\n    S.append(list(map(int, input().split())))\nfor p in lol(n):\n    d = 0\n    g1, g2, g3 = 0, 0, 0\n    for i in range(n):\n        if p[i]:\n            d += S[i][0]\n            if S[i][1] == 1:\n                g1 += 1\n            elif S[i][1] == 2:\n                g2 += 1\n            elif S[i][1] == 3:\n                g3 += 1\n    if d == T:\n        cnt += factorial(g1) * factorial(g2) * factorial(g3) * sp(g1, g2, g3, 0)\n        cnt %= M\nprint(cnt)
big = 100010\ndef gen_mu():\n    mu = [1]*big\n    mu[0] = 0\n    P = [True]*big\n    P[0] = P[1] = False\n    for i in range(2,big):\n        if P[i]:\n            j = i\n            while j<big:\n                P[j] = False\n                mu[j] *= -1\n                j += i\n            j = i*i\n            while j<big:\n                mu[j] = 0\n                j += i*i\n    return mu\n\nm = int(input())\nmu = gen_mu()\n\nMOD = 10**9+7\ndef mod_inv(x):\n    return pow(x, MOD-2, MOD)\n\ns = 1\nfor i in range(2,big):\n    # p is probabilty that i | a random number [1,m]\n    p = (m//i)*mod_inv(m)\n    s += (-mu[i])*(p)*mod_inv(1-p)\nprint(s%MOD)
from math import sqrt\nfrom fractions import gcd\nl, r, x, y = list(map(int, input().split()))\nif y % x != 0:\n    print(0)\n    return\nlo = (l + x - 1) // x\nhi = r // x\np = y // x\ns = 0\n\nk1 = 1\nwhile k1 * k1 <= p:\n    k2 = p // k1\n    if lo <= k1 <= hi and lo <= k2 <= hi and gcd(k1, k2) == 1 and k1 * k2 == p:\n        s += 1 + (k1 != k2)\n    k1 += 1\nprint(s)\n
from math import gcd\na, b = list(map(int, input().split()))\nif b < a:\n    a, b = b, a\nif a == b:\n    print(0)\n    return\nc = b - a\ni = 1\nans = a * b // gcd(a, b)\n\ndef get(x):\n    A = (a + x - 1) // x * x\n    B = A - a + b\n    return A * B // gcd(A, B), A\n\nr = 0\nwhile i * i <= c:\n    if c % i == 0:\n        A, AA = get(i)\n        B, BB = get(c // i)\n        if A < ans:\n            ans = A\n            r = AA - a\n        if B < ans:\n            ans = B\n            r = BB - a\n        if A == ans:\n            r = min(r, AA - a)\n        if B == ans:\n            r = min(r, BB - a)\n    i += 1\nprint(r)\n
n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\ns = sum(a)\nans = 0\nc = k - 0.5\nwhile s / n < c:\n    s += k\n    n += 1\n    ans += 1\nprint(ans)\n
n=int(input())\nar=list(map(int,input().split()))\npos=0\nneg=0\nfor a in ar:\n    if(a>0):pos+=1\n    elif a<0:neg+=1\nif(pos*2>=n):\n    print(1)\nelif neg*2>=n:\n    print(-1)\nelse:\n    print(0)\n
from sys import stdin as cin\nfrom sys import stdout as cout\n\ndef main():\n    n = int(cin.readline())\n    o = 0\n    for x in range(9, 0, -1):\n        if 10 ** x // 2 <= n:\n            ##print(x)\n            for i in range(9):\n                q = 10 ** x * (i + 1) // 2 - 1\n                if q <= n:\n                    o += min(q, n - q)\n            print(o)\n            return\n    print(n * (n - 1) // 2)\n\nmain()\n
a,b=list(map(int,input().split()))\nc,d=list(map(int,input().split()))\ne=a*b\nf=c*d\nn=0\nwhile e%2==0:e=e//2\nwhile e%3==0:e=e//3\nwhile f%2==0:f=f//2\nwhile f%3==0:f=f//3\nif e!=f:print("-1")\nelse:\n   i=0\n   j=0\n   e=a*b\n   f=c*d\n   while e%3==0:\n      e=e//3\n      i+=1\n   while f%3==0:\n      f=f//3\n      j+=1\n   k=i-j\n   if k>0:\n      for i in range(k):\n         n+=1\n         if a%3==0:a=a*2//3\n         else:b=b*2//3\n   else:\n      for i in range(0-k):\n         n+=1\n         if c%3==0:c=c*2//3\n         else:d=d*2//3\n   e=a*b\n   f=c*d\n   i=0\n   j=0\n   while e%2==0:\n      e=e//2\n      i+=1\n   while f%2==0:\n      f=f//2\n      j+=1\n   k=i-j\n   if k>0:\n      for i in range(k):\n         n+=1\n         if a%2==0:a=a//2\n         else:b=b//2\n   else:\n      for i in range(0-k):\n         n+=1\n         if c%2==0:c=c//2\n         else:d=d//2\n   print(n)\n   print(a,b)\n   print(c,d)\n
a, b, x, y = map(int, input().split())\nif a >= x:\n    if b >= y:\n        print('Vasiliy')\n    else:\n        z = y - b\n        t = max(x - z, 0)\n        if a - z <= t:\n            print('Polycarp')\n        else:\n            print('Vasiliy')\nelse:\n    if b <= y:\n        print('Polycarp')\n    else:\n        z = x - a\n        t = max(y - z, 0)\n        if b - z <= t:\n            print('Polycarp')\n        else:\n            print('Vasiliy')
import sys\narr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\na, b = list(map(int, input().split()))\na -= 1\nb -= 1\nctr = 1\nfor i in range(arr[a] - 1):\n    b += 1\n    if (b == 7):\n        b = 0\n        ctr += 1\nprint(ctr)\n            \n
def zero(strx):\n    k = []\n    str2 = list(strx)\n    for i in range(1, len(str2)):\n        str3 = str2[:]\n        str3[i] = '0'\n        k.append(''.join(str3))\n    return k\na = []\nfor i in range(1, 64):\n    a += zero('1'*i)\n\nct = 0\nx, y = list(map(int, input().split(' ')))\nfor i in a:\n    if x <= int(i, 2) <= y:\n        ct+=1\nprint(ct)\n
n=int(input())\nprint(max((i+1)*(n-i)for i in range(n)))\n
fact = [ 1 ]\nfor i in range( 1, 20, 1 ):\n  fact.append( fact[ i - 1 ] * i )\n\nfrom collections import defaultdict\n\nN, K, S = list(map( int, input().split() ))\nA = list( map( int, input().split() ) )\n\nldp = [ [ defaultdict( int ) for i in range( K + 1 ) ] for j in range( 2 ) ]\nldp[ 0 ][ 0 ][ 0 ] = 1\nfor i in range( N // 2 ):\n  for j in range( K + 1 ):\n    ldp[ ~ i & 1 ][ j ].clear()\n  for j in range( K + 1 ):\n    for key in ldp[ i & 1 ][ j ]:\n      ldp[ ~ i & 1 ][ j ][ key ] += ldp[ i & 1 ][ j ][ key ] # toranai\n      ldp[ ~ i & 1 ][ j ][ key + A[ i ] ] += ldp[ i & 1 ][ j ][ key ] # toru\n      if j + 1 <= K and A[ i ] <= 18:\n        ldp[ ~ i & 1 ][ j + 1 ][ key + fact[ A[ i ] ] ] += ldp[ i & 1 ][ j ][ key ] # kaijyou totte toru\n\nrdp = [ [ defaultdict( int ) for i in range( K + 1 ) ] for j in range( 2 ) ]\nrdp[ 0 ][ 0 ][ 0 ] = 1\nfor i in range( N - N // 2 ):\n  for j in range( K + 1 ):\n    rdp[ ~ i & 1 ][ j ].clear()\n  for j in range( K + 1 ):\n    for key in rdp[ i & 1 ][ j ]:\n      rdp[ ~ i & 1 ][ j ][ key ] += rdp[ i & 1 ][ j ][ key ]\n      rdp[ ~ i & 1 ][ j ][ key + A[ N // 2 + i ] ] += rdp[ i & 1 ][ j ][ key ]\n      if j + 1 <= K and A[ N // 2 + i ] <= 18:\n        rdp[ ~ i & 1 ][ j + 1 ][ key + fact[ A[ N // 2 + i ] ] ] += rdp[ i & 1 ][ j ][ key ]\n\nans = 0\nfor i in range( K + 1 ):\n  for key in ldp[ N // 2 & 1 ][ i ]:\n    for j in range( 0, K - i + 1, 1 ):\n      ans += ldp[ N // 2 & 1 ][ i ][ key ] * rdp[ N - N // 2 & 1 ][ j ][ S - key ]\n\nprint( ans )\n
t = int(input())\nfor _ in range(t):\n    n,k = list(map(int,input().split()))\n    a = list(map(int,input().split()))\n    for i in range(60, -1, -1):\n        m = k ** i\n        for j in range(n):\n            if a[j] >= m:\n                a[j] -= m\n                break\n    if all(i == 0 for i in a):\n        print('YES')\n    else:\n        print('NO')\n
a, b, c = map(int, input().split())\nd = 1073741824\np = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\nt = [{} for i in range(101)]\nans = {}\nfor i in p:\n    j = i\n    m = 1\n    while j < 101:\n        for k in range(j, 101, j):\n            t[k][i] = m\n        j = j * i\n        m += 1\ns = 0\nfor i in range(1, a + 1):\n    for j in range(1, b + 1):\n        q = {}\n        for x in t[i].keys() | t[j].keys():\n            q[x] = t[i].get(x, 0) + t[j].get(x, 0)\n        ij = i * j\n        for k in range(1, c + 1):\n            ijk = ij * k\n            if ijk in ans: s += ans[ijk]\n            else:\n                y = 1\n                for x in q.keys() | t[k].keys():\n                    y = y * (q.get(x, 0) + t[k].get(x, 0) + 1)\n                ans[ijk] = y\n                s += y\n\nprint(s)
a, b, c, d = input(), input(), input(), input()\na = a + b[::-1]\nx = "X"\nfor i in range(4):\n    if a[i] == x:\n        a = a[:i] + a[i + 1:]\n        break\nc = c + d[::-1]\n\nfor i in range(4):\n    if c[i] == x:\n        c = c[:i] + c[i + 1:]\n        break\nflag = False\nfor i in range(4):\n    if a == c:\n        flag = True\n    c = c[1:] + c[0]\nif flag:\n    print("YES")\nelse:\n    print("NO")
n=int(input())\ns=input()\npw=[1]\nlast=1\nfor i in range(70):\n    if (last>1e19):\n        break\n    pw.append(last*n)\n    last=last*n\ndp=[1e19]*100\nfor i in range(100):\n    dp[i]=[1e19]*100\ndp[len(s)][0]=0\nfor i in range(len(s),-1,-1):\n    for power in range(0,len(pw)):\n        cur=''\n        for j in range(i-1,-1,-1):\n            cur=s[j]+cur\n            if (int(cur)>n or int(cur)*pw[power]>1e19):\n                break;\n            if ((cur[0]!='0' or len(cur)==1) and int(cur)<n):\n                dp[j][power+1]=min(dp[j][power+1],dp[i][power]+int(cur)*pw[power])\nprint(min(dp[0]))
n = int(input())\nL = list(map(int, input().split()))\ni = 0\na = 0\nwhile i < n and L[i] > a:\n    a = L[i]\n    i += 1\nwhile i < n and L[i] == a:\n    i += 1\nwhile i < n and L[i] < a:\n    a = L[i]\n    i += 1\nif i == n:\n    print("YES")\nelse:\n    print("NO")\n
def gg(n,lol):\n	ans = 0\n	cur = 1\n	lol2 = lol\n	while(2*lol+1<=n):\n		cur *= 2\n		ans += cur\n		lol = 2*lol+1\n		lol2 *= 2\n	if lol2*2 <= n:\n		ans += n-lol2*2+1	\n	return ans\n\nn,k = list(map(int,input().split()))\nlow = 1\nhigh = n//2\nres = 1\nwhile low <= high:\n	mid = (low+high)//2\n	if gg(n,mid) >= k:\n		res = mid\n		low = mid+1\n	else:\n		high = mid-1\nif n == k:\n	print(1)\nelif(gg(n,res)-1-gg(n,res*2) >= k):\n	print(res*2+1)\nelse:\n	print(res*2)					\n
def INV(a, m) :\n    m0 = m\n    y = 0\n    x = 1 \n    if (m == 1) :\n        return 0 \n    while (a > 1) : \n        q = a // m \n        t = m \n        m = a % m\n        a = t\n        t = y \n        y = x - q * y\n        x = t\n    if (x < 0) :\n        x = x + m0 \n    return x\ndef GCD(a, b):\n  if a == 0: return b\n  return GCD(b%a,a)\ndef solve():\n  n, m, x, y, vx, vy = list(map(int, input().split()))\n  if vx == 0:\n    if x != 0 and x != n:\n      print("-1")\n      return 0\n    ans = [0,0]\n    ans[0] = x\n    if vy < 0: ans[1] = 0\n    else: ans[1] = m\n    print(ans[0],ans[1])\n    return 0\n  if vy == 0:\n    if y != 0 and y != m:\n      print("-1")\n      return 0\n    ans = [0,0]\n    ans[1] = y\n    if vx < 0: ans[0] = 0\n    else: ans[0] = n\n    print(ans[0],ans[1])\n    return 0\n  if vx == -1 and x == 0: vx = 1\n  if vx == 1 and x == n: vx = -1\n  if vy == -1 and y == 0: vy = 1\n  if vy == 1 and y == m: vy = -1\n  g = GCD(n,m)\n  m1 = n\n  m2 = m\n  a1 = -1 * vx * x % m1\n  a2 = -1 * vy * y % m2\n  if a1 % g != a2 % g:\n    print("-1")\n    return 0\n  if GCD(m1//g,m2) == 1:\n    m1 = m1 // g\n  else:\n    m2 = m2 // g\n  m1_bar = INV(m2,m1)\n  m2_bar = INV(m1,m2)\n  k = (a1 * m1_bar*m2 + a2 * m2_bar*m1) % (m1*m2)\n  rowtouch = ((k+m-1)//m) % 2\n  coltouch = ((k+n-1)//n) % 2\n  ans = [0,0]\n  if vx == 1: ans[0] = 0\n  else: ans[0] = n\n  if vy == 1: ans[1] = 0\n  else: ans[1] = m\n  if rowtouch == 1: ans[1] = m-ans[1]\n  if coltouch == 1: ans[0] = n-ans[0]\n  print(ans[0],ans[1])\n  return 0\nsolve()\n
a, b = [int(i) for i in input().split()]\nc, d = [int(i) for i in input().split()]\ne, f = [int(i) for i in input().split()]\nif c+e <=a and max(d,f) <=b:\n    print("YES")\nelif c+e <=b and max(d,f) <=a:\n    print("YES")\nelif c+f <=a and max(d,e) <=b:\n    print("YES")\nelif c+f <=b and max(d,e) <=a:\n    print("YES")\nelif d+e <=a and max(c,f) <=b:\n    print("YES")\nelif d+e <=b and max(c,f) <=a:\n    print("YES")\nelif d+f <=a and max(c,e) <=b:\n    print("YES")\nelif d+f <=b and max(c,e) <=a:\n    print("YES")\nelse:\n    print("NO")\n
def main():\n    (b1, q, l, m) = list(map(int, input().split()))\n    a = set(map(int, input().split()))\n    if abs(b1) > l:\n        print(0)\n    else:\n        if b1 == 0:\n            if 0 in a:\n                print(0)\n            else:\n                print("inf")\n        elif q == 0:\n            if 0 not in a:\n                print("inf")\n            elif b1 in a:\n                print(0)\n            else:\n                print(1)\n        elif q == 1:\n            if b1 in a:\n                print(0)\n            else:\n                print("inf")\n        elif q == -1:\n            if (b1 in a) and ((-b1) in a):\n                print(0)\n            else:\n                print("inf")\n        else:\n            ans = 0\n            b = b1\n            for i in range(100):\n                if b in a:\n                    b *= q\n                    if abs(b) > l:\n                        break\n                    continue\n                ans += 1\n                b *= q\n                if abs(b) > l:\n                    break\n            print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()
3\n\ndef readln(): return list(map(int, input().split()))\nimport sys\ndef return:\n    print(-1)\n    return\n\nn, m = readln()\nmon = [list(input()) for _ in range(n)]\nhor = [i for i in range(n) if mon[i] != ['.'] * m]\nrmon = list(zip(*mon))\nver = [j for j in range(m) if rmon[j] != ('.',) * n]\nmini = hor[0]\nmaxi = hor[-1]\nminj = ver[0]\nmaxj = ver[-1]\ncnt_in = len([1 for i in range(mini + 1, maxi) for j in range(minj + 1, maxj) if mon[i][j] == 'w'])\ncnt_l = len([1 for i in range(mini + 1, maxi) if mon[i][minj] == 'w'])\ncnt_r = len([1 for i in range(mini + 1, maxi) if mon[i][maxj] == 'w'])\ncnt_d = len([1 for j in range(minj + 1, maxj) if mon[mini][j] == 'w'])\ncnt_u = len([1 for j in range(minj + 1, maxj) if mon[maxi][j] == 'w'])\nif cnt_in:\n    return\nif maxi - mini < maxj - minj:\n    k = maxj - minj + 1\n    if maxi == mini and cnt_d:\n        if mini >= k - 1:\n            mini -= k - 1\n        elif maxi + k - 1 < n:\n            maxi += k - 1\n        else:\n            return\n    else:\n        if not cnt_d:\n            mini = max(0, maxi - k + 1)\n        if maxi - maxi + 1 != k and not cnt_u:\n            maxi = min(mini + k - 1, n - 1)\n        if maxi - mini + 1 != k:\n            return\nelse:\n    k = maxi - mini + 1\n    if maxj == minj and cnt_l:\n        if minj >= k - 1:\n            minj -= k - 1\n        elif maxj + k - 1 < m:\n            maxj += k - 1\n        else:\n            return\n    else:\n        if not cnt_l:\n            minj = max(0, maxj - k + 1)\n        if maxj - minj + 1 != k and not cnt_r:\n            maxj = min(minj + k - 1, m - 1)\n        if maxj - minj + 1 != k:\n            return\nfor i in range(mini, maxi + 1):\n    if mon[i][minj] == '.':\n        mon[i][minj] = '+'\nfor i in range(mini, maxi + 1):\n    if mon[i][maxj] == '.':\n        mon[i][maxj] = '+'\nfor j in range(minj, maxj + 1):\n    if mon[mini][j] == '.':\n        mon[mini][j] = '+'\nfor j in range(minj, maxj + 1):\n    if mon[maxi][j] == '.':\n        mon[maxi][j] = '+'\nprint('\n'.join([''.join(row) for row in mon]))\n
def egcd(a, b):\n    x,y, u,v = 0,1, 1,0\n    while a != 0:\n        q, r = b//a, b%a\n        m, n = x-u*q, y-v*q\n        b,a, x,y, u,v = a,r, u,v, m,n\n    gcd = b\n    return gcd, x, y\n\n\nimport math\nn=int(input())\na=int(input())\nb=int(input())\ngcd,x,y=(egcd(a,b))\n\n\nstatus=0\nif((n%gcd)!=0):\n    print("NO")\n    #print("point1")\n\nelse:\n    multiply=n/gcd\n    x1=int(multiply*x)\n    y1=int(multiply*y)\n    #print("gcd and soln to n")\n    #print(gcd,x1,y1)\n    d1=b/gcd\n    d2=a/gcd\n    rangemin= int(math.ceil(-x1/d1))\n    rangemax= int(y1//d2)\n    #print("rangemin and rangemax")\n    #print(rangemin,rangemax)\n    if(rangemin>rangemax):\n        print("NO")\n        #print("point2")\n    else:\n        #print("YES")\n        #solx=x1+rangemin*d1\n        #soly=y1-rangemin*d2\n        m=rangemin\n        while(m<=rangemax):\n            solx=x1+m*d1\n            soly=y1-m*d2\n            if(solx>=0 and soly>=0):\n                print("YES")\n                status=1\n                print(str(int(solx))+" "+str(int(soly)))\n                break\n            m=m+1\n\n        if(status==0):\n            print("NO")\n            #print("point3")\n                \n        \n
n = int(input())\nif n == 0:\n	print('zero')\nelif n == 1:\n	print('one')\nelif n == 2:\n	print('two')\nelif n == 3:\n	print('three')\nelif n == 4:\n	print('four')\nelif n == 5:\n	print('five')\nelif n == 6:\n	print('six')\nelif n == 7:\n	print('seven')\nelif n == 8:\n	print('eight')\nelif n == 9:\n	print('nine')\nelif n == 10:\n	print('ten')\nelif n == 11:\n	print('eleven')\nelif n == 12:\n	print('twelve')\nelif n == 13:\n	print('thirteen')\nelif n == 14:\n	print('fourteen')\nelif n == 15:\n	print('fifteen')\nelif n == 16:\n	print('sixteen')\nelif n == 17:\n	print('seventeen')\nelif n == 18:\n	print('eighteen')\nelif n == 19:\n	print('nineteen')\nelse:\n	if n // 10 == 2:\n		res = 'twenty'\n	elif n // 10 == 3:\n		res = 'thirty'\n	elif n // 10 == 4:\n		res = 'forty'\n	elif n // 10 == 5:\n		res = 'fifty'\n	elif n // 10 == 6:\n		res = 'sixty'\n	elif n // 10 == 7:\n		res = 'seventy'\n	elif n // 10 == 8:\n		res = 'eighty'\n	elif n // 10 == 9:\n		res = 'ninety'\n\n	if n % 10 == 1:\n		res += '-one'\n	elif n % 10 == 2:\n		res += '-two'\n	elif n % 10 == 3:\n		res += '-three'\n	elif n % 10 == 4:\n		res += '-four'\n	elif n % 10 == 5:\n		res += '-five'\n	elif n % 10 == 6:\n		res += '-six'\n	elif n % 10 == 7:\n		res += '-seven'\n	elif n % 10 == 8:\n		res += '-eight'\n	elif n % 10 == 9:\n		res += '-nine'\n\n	print(res)
n = int(input())\na = [0] + list(map(int, input().split())) + [1001]\nmx = 1\np = 1\nfor i in range(1, n + 2):\n    if a[i] == a[i - 1] + 1:\n        p += 1\n        mx = max(p, mx)\n    else:\n        p = 1\nprint(max(0, mx - 2))
def main():\n    n = int(input())\n    a = list(int(x) for x in input().split())\n    s = sum(a)\n    t = 0\n    for i in range(n):\n        t += a[i]\n        if 2 * t >= s:\n            print(i + 1)\n            return\n\nmain()\n
n=int(input())\ngraph=[{},{},{}]\nfor i in range(n):\n    for j in range(n):\n        graph[0][(i,j)]=[(k,j) for k in range(n)]+[(i,k) for k in range(n)]\n        graph[0][(i,j)].remove((i,j))\n        graph[0][(i,j)].remove((i,j))\n        graph[1][(i,j)]=[]\n        for k in range(n):\n            for l in range(n):\n                if abs(k-i)==abs(l-j)!=0:\n                    graph[1][(i,j)].append((k,l))\n        graph[2][(i,j)]=[]\n        for k in range(n):\n            for l in range(n):\n                if {abs(k-i),abs(l-j)}=={1,2}:\n                    graph[2][(i,j)].append((k,l))      \n\ndists=[[{},{},{}],[{},{},{}],[{},{},{}]]\nfor i in range(n):\n    for j in range(n):\n        for k in range(3):\n            dists[k][k][(i,j,i,j)]=0\nfor i in range(n):\n    for j in range(n):\n        for k in range(3):\n            layers=[[(i,j,k,0)],[],[],[],[]]\n            for l in range(4):\n                for guy in layers[l]:\n                    for m in range(3):\n                        if m!=guy[2]:\n                            if (i,j,guy[0],guy[1]) not in dists[k][m]:\n                                layers[l+1].append((guy[0],guy[1],m,guy[3]+1))\n                                dists[k][m][(i,j,guy[0],guy[1])]=1000*(l+1)+guy[3]+1\n                    for boi in graph[guy[2]][(guy[0],guy[1])]:\n                        if (i,j,boi[0],boi[1]) not in dists[k][guy[2]]:\n                            layers[l+1].append((boi[0],boi[1],guy[2],guy[3]))\n                            dists[k][guy[2]][(i,j,boi[0],boi[1])]=1000*(l+1)+guy[3]\n                        elif 1000*(l+1)+guy[3]<dists[k][guy[2]][(i,j,boi[0],boi[1])]:\n                            layers[l+1].append((boi[0],boi[1],guy[2],guy[3]))\n                            dists[k][guy[2]][(i,j,boi[0],boi[1])]=1000*(l+1)+guy[3]\nlocs=[None]*(n**2)\nfor i in range(n):\n    a=list(map(int,input().split()))\n    for j in range(n):\n        locs[a[j]-1]=(i,j)\nbest=(0,0,0)\nfor i in range(n**2-1):\n    tup=(locs[i][0],locs[i][1],locs[i+1][0],locs[i+1][1])\n    new0=min(best[0]+dists[0][0][tup],best[1]+dists[1][0][tup],best[2]+dists[2][0][tup])\n    new1=min(best[0]+dists[0][1][tup],best[1]+dists[1][1][tup],best[2]+dists[2][1][tup])\n    new2=min(best[0]+dists[0][2][tup],best[1]+dists[1][2][tup],best[2]+dists[2][2][tup])\n    best=(new0,new1,new2)\na=min(best)\nprint(a//1000,a%1000)
n, m, k = map(int, input().split())\na, b = map(int, input().split())\na -= 1\nb -= 1\ndef p(x):\n	return x // (m * k)\ndef e(x):\n	return (x - p(x) * m * k) // k\ndef lift(x):\n	return min(5 * x, 10 + x)\n	\nif p(a) == p(b):\n	dif = abs(e(a) - e(b))\n	print(lift(dif))\nelse:\n	print(lift(e(a)) + 15 * min((p(a) - p(b) + n) % n, (p(b) - p(a) + n) % n) + lift(e(b)))
s = input()\ni = 0\nwhile i < len(s) and s[i] == '0':\n    i += 1\ncnt = 0\nwhile i < len(s):\n    if s[i] == '0':\n        cnt += 1\n    i += 1\n\nif cnt >= 6:\n    print('yes')\nelse:\n    print('no')\n
s = list(input())\ntarget = 'abcdefghijklmnopqrstuvwxyz'\nind_t = 0\nind_s = 0\nwhile ind_s < len(s) and ind_t < 26:\n  if ord(s[ind_s]) <= ord(target[ind_t]):\n    s[ind_s] = target[ind_t]\n    ind_t += 1\n    ind_s += 1\n  else:\n    ind_s += 1\nif ind_t == 26:\n  print(''.join(s))\nelse:\n  print(-1)
import heapq as hq\nfrom queue import PriorityQueue\n\nimport math\nn,m,r, k= input().split()\nN = int(n)\nM = int(m)\nR = int(r)\nK = int(k)\n\nq = PriorityQueue()\n\n\n\nfor i in range(1,math.floor((N+1)/2) + 1):\n    maxi = min(min(i,N-i+1),min(R,N-R+1)) * min(min(R,M-R+1),math.ceil(M/2))\n    num = M - (2 * min(min(R,M-R+1),math.ceil(M/2))-2)\n    mult = 2\n    if(i > math.floor(N/2)):\n        mult = 1\n    q.put((-maxi,num * mult,i))\n    #print(str(maxi) + " " + str(num) + " " + str(mult))\n\n\nans = 0\nwhile(K > 0):\n    pop = q.get()\n    #print(pop)\n    a = -1 * pop[0]\n    b = pop[1]\n    c = pop[2]\n    d = min(min(c,N-c+1),min(R,N-R+1))\n    if(d != a):\n       # if(q.)\n       # if(q.get(-(a - d)) != )\n        mult = 2\n        if (c > N / 2):\n            mult = 1\n        q.put((-(a - d),2*mult,c))\n    ans += a * min(b,K)\n    K -= b;\n\ntot = (N-R+1) * (M-R+1)\n#print("ANS = " + str(ans))\n#print("FINANS = " + str(ans/tot))\nprint(str(ans/tot))\n\n\n'''\n\nd = []\nfor i in range(0,N):\n    d.append([])\n    for j in range(0,M):\n        d[i].append(0)\n\ntot = 0\nfor i in range(0,N-R+1):\n    for j in range(0,M-R+1):\n        for k in range(i,i+R):\n            for l in range(j,j+R):\n                d[k][l] += 1\n                tot += 1\n\n\nprint(N-R+1)*(M-R+1) * (R*R)\nprint(tot)\nprint()\nfor i in d:\n    print(i)\n\n'''\n
n = int(input())\nA = list(map(int, input().split()))\nif n == 1:\n    if A[0] >= 0:\n        print(A[0])\n    else:\n        print(-A[0]-1)\n    return\nfor i in range(n):\n    if A[i] < 0:\n        pass\n    else:\n        A[i] = -A[i]-1\nif n % 2 == 0:\n    print(*A)\n    return\nmim = 0\nindmim = 0\nfor i in range(n):\n    if A[i] < mim:\n        mim = A[i]\n        indmim = i\nA[indmim] = -A[indmim]-1\nprint(*A)\n
import sys\nimport math\n\ndef factorization(n):\n    res = []\n    limit = math.ceil(math.sqrt(n))\n    p = 2\n    cnt = 0\n\n    while n % p == 0:\n        cnt += 1\n        n //= p\n\n    if cnt > 0:\n        res.append((p, cnt))\n\n    cnt = 0\n    for p in range(3, limit + 1, 2):\n        if n % p == 0:\n            while n % p == 0:\n                cnt += 1\n                n //= p\n\n            res.append((p, cnt))\n        cnt = 0\n\n    if n > 1:\n        res.append((n, 1))\n\n    return res\n\ndef divisor(n):\n    res = set()\n\n    factor = factorization(n)\n\n    for p, c in factor:\n        if res == set():\n            for i in range(c + 1):\n                res.add(p ** i)\n        else:\n            t = set()\n            for i in range(1, c + 1):\n                for m in res:\n                    t.add(m * p**i)\n            res = res | t\n\n    res = list(sorted(res))\n    return res\n\nn, k = map(int, input().split())\n\n# print(factorization(n), file=sys.stderr)\n# print(divisor(n), file=sys.stderr)\n\nn_div = divisor(n)\n\nif n == 1:\n    if k == 1:\n        ans = 1\n    else:\n        ans = -1\nelif k > len(n_div):\n    ans = -1\nelse:\n    ans = n_div[k - 1]\n\nprint(ans)
n = int(input())\na = sorted([list(map(int, input().split())) for i in range(n)])\n\nimport itertools\nfor x in range(1,10**n):\n  good = False\n  s = str(x)\n  for p in itertools.permutations(a, len(s)):\n    good |= all([int(s[i]) in v for i, v in enumerate(p)])\n  if not good:\n    print(x-1)\n    return\n    \nprint((10**n)-1)
def main():\n	n, k = map(int, input().split())\n	num_2 = 0\n	num_5 = 0\n	x = n\n	while (x % 2 == 0):\n		num_2 += 1\n		x //= 2\n		\n	while (x % 5 == 0):\n		num_5 += 1\n		x //= 5\n	num_2 = k - min(num_2, k)\n	num_5 = k - min(num_5, k)\n	print(n * 5 ** num_5 * 2 ** num_2)\n\n\nmain()
n, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [[0] * m for _ in range(n)]\nans = []\nfor i in range(n - 1):\n    for j in range(m - 1):\n        if A[i][j] == 1 and A[i + 1][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j + 1] == 1:\n            B[i][j] = 1\n            B[i + 1][j] = 1\n            B[i][j + 1] = 1\n            B[i + 1][j + 1] = 1\n            ans.append([i + 1, j + 1])\nif A == B:\n    print(len(ans))\n    for a, b in ans:\n        print(a, b)\nelse:\n    print(-1)
r, s, p = list(map(int, input().split()))\ndp = [[[0] * (p+1) for _ in range(s+1)] for _ in range(r+1)]\ndp[r][s][p] = 1\ndef nCk(n, k):\n    if n <= k:\n        return 1\n    res = 1\n    for i in range(k):\n        res *= n-i\n    for i in range(k):\n        res //= (i+1)\n    return res\n\nC = [nCk(i, 2) for i in range(r+s+p+1)]\nfor ri in range(r, -1, -1):\n    for si in range(s, -1, -1):\n        for pi in range(p, -1, -1):\n            t = ri * si + si * pi + pi * ri\n            if t == 0: continue\n            if ri > 0:\n                dp[ri-1][si][pi] += dp[ri][si][pi] * ri * pi / t\n            if si > 0:\n                dp[ri][si-1][pi] += dp[ri][si][pi] * ri * si / t\n            if pi > 0:\n                dp[ri][si][pi-1] += dp[ri][si][pi] * si * pi / t\n        \n        \nr_sum = sum([dp[ri][0][0] for ri in range(r+1)])\ns_sum = sum([dp[0][si][0] for si in range(s+1)])\np_sum = sum([dp[0][0][pi] for pi in range(p+1)])\nprint(r_sum, s_sum, p_sum)\n
read = lambda: list(map(int, input().split()))\nl1, r1, l2, r2, k = read()\nR = min(r1, r2)\nL = max(l1, l2)\nans = max(R - L + 1, 0)\nif L <= k <= R: ans = max(ans - 1, 0)\nprint(ans)\n
#写経\n#https://atcoder.jp/contests/abc168/submissions/14421546\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\nfrom bisect import bisect_left, bisect_right\nINF = 10 **18\n\ndef resolve():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for i in range(n)]\n    b = [list(map(int, input().split())) for i in range(m)]\n \n    X = {-INF, INF}\n    Y = {-INF, INF}\n    for i in a:\n        Y.add(i[2])\n    for i in b:\n        X.add(i[0])\n \n    X = list(sorted(X))\n    Y = list(sorted(Y))\n    n = len(X) - 1\n    m = len(Y) - 1\n    wallx = [[False] * m for i in range(n)]\n    wally = [[False] * m for i in range(n)]\n \n    for x1, x2, y1 in a:\n        x1 = bisect_left(X, x1)\n        y1 = bisect_left(Y, y1)\n        x2 = bisect_right(X, x2) - 1\n        for i in range(x1, x2):\n            wally[i][y1] = True\n \n    for x1, y1, y2 in b:\n        x1 = bisect_left(X, x1)\n        y1 = bisect_left(Y, y1)\n        y2 = bisect_right(Y, y2) - 1\n        for i in range(y1, y2):\n            wallx[x1][i] = True\n \n    cow = [[False] * m for i in range(n)]\n    cx = bisect_right(X, 0) - 1\n    cy = bisect_right(Y, 0) - 1\n    cow[cx][cy] = True\n    q = [(cx, cy)]\n    ans = 0\n \n    while q:\n        x, y = q.pop()\n        if not x or not y:\n            print("INF")\n            return\n        ans += (X[x + 1] - X[x]) * (Y[y + 1] - Y[y])\n        if x and not wallx[x][y] and not cow[x - 1][y]:\n            cow[x - 1][y] = True\n            q.append((x - 1, y))\n        if y and not wally[x][y] and not cow[x][y - 1]:\n            cow[x][y - 1] = True\n            q.append((x, y - 1))\n        if x + 1 < n and not wallx[x + 1][y] and not cow[x + 1][y]:\n            cow[x + 1][y] = True\n            q.append((x + 1, y))\n        if y + 1 < m and not wally[x][y + 1] and not cow[x][y + 1]:\n            cow[x][y + 1] = True\n            q.append((x, y + 1)) \n    print(ans)\nresolve()
t, s, x = list(map(int, input().split()))\nf = False\nif x - 1 > t and (x - 1 - t) % s == 0:\n    f = True\nif x >= t and (x - t) % s == 0:\n    f = True\nif f:\n    print('YES')\nelse:\n    print('NO')\n
n = int(input())\na = []\nfor i in range(1, n + 1):\n    l, r = list(map(int, input().split()))\n    a.append([l, -r, i])\na.sort()\nhh = a[0][1]\nwahh = max(-1, a[0][2])\nfor i in range(1, n):\n    if a[i][1] >= hh:\n        print(a[i][2], wahh)\n        return\n    else:\n        hh = a[i][1]\n        wahh = a[i][2]\nprint(-1, -1)\n
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\nn=int(input())\nif n%4: print("===")\nelse:\n    t=input().strip()\n    a=[n//4]*4\n    for i in t:\n        if i=='A': a[0]-=1\n        elif i=='C': a[1]-=1\n        elif i=='G': a[2]-=1\n        elif i=='T': a[3]-=1\n    if min(a)<0: print("===")\n    else:\n        out=[]\n        for i in t:\n            if i=='?':\n                if a[0]:\n                    out.append('A')\n                    a[0]-=1\n                elif a[1]:\n                    out.append('C')\n                    a[1]-=1\n                elif a[2]:\n                    out.append('G')\n                    a[2]-=1\n                elif a[3]:\n                    out.append('T')\n                    a[3]-=1\n            else: out.append(i)\n        print("".join(out))\n
def chk(l):\n	for i in range(4):\n		for j in range(2):\n			if l[i][j]==l[i][j+1]==l[i][j+2]=='x':\n				return True\n	for i in range(2):\n		for j in range(4):\n			if l[i][j]==l[i+1][j]==l[i+2][j]=='x':\n				return True\n	for i in range(2):\n		for j in range(2):\n			if l[i][j]==l[i+1][j+1]==l[i+2][j+2]=='x':\n				return True\n	for i in range(2):\n		for j in range(2, 4):\n			if l[i][j]==l[i+1][j-1]==l[i+2][j-2]=='x':\n				return True\n	return False\na = [list(input()), list(input()), list(input()), list(input())]\nfor i in range(4):\n	for j in range(4):\n		if a[i][j] != '.':\n			continue\n		a[i][j]='x'\n		if chk(a):\n			print("YES"); return\n		a[i][j]='.'\nprint("NO")\n
def solve(n,a):\n    tot=0\n    for i in range(n):\n        tot+=a[i]\n    diffs = [] #alla suffix - prefix diffs[i]=prefix-suffix om delas innan element i\n    diffs.append(-tot)\n    for i in range(n):\n        tot-=2*a[i]\n        diffs.append(-tot)\n        if tot==0:\n            return ("YES")\n    for i in range(n):\n        diffmake=2*a[i]\n        j=binary(diffs,diffmake)\n        if j>i and j!=-1:\n            return ("YES")\n        j=binary(diffs,-diffmake)\n        if i>=j and j!=-1:\n            return ("YES")\n    return ("NO")\n\n\ndef binary(a,value):\n    hi=len(a)\n    lo=-1\n    while (lo+1<hi):\n        mi=(lo+hi)//2\n        if a[mi]==value:\n            return mi\n        if a[mi]<value:\n            lo=mi\n        else:\n            hi=mi\n    return -1\n\n\nn=int(input())\na = input().split()\nfor i in range (n):\n    a[i]=int(a[i])\nprint(solve(n,a))\n
import sys\n\nn, k = list(map(int, input().split()))\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\n\nb.sort(reverse=True)\n\nres = []\ncur_b = 0\nfor a_i in a:\n    if a_i != 0:\n        res.append(a_i)\n    else:\n        res.append(b[cur_b])\n        cur_b += 1\n\nif res != list(sorted(res)):\n    print("Yes")\nelse:\n    print("No")\n
x,y,z = list(map(int,input().split()))\na,b,c = list(map(int,input().split()))\nif a < x:\n    print("NO")\n    return\nx -= a\ny += x\nif b < y:\n    print("NO")\n    return\ny -= b\nz += y\nif c < z:\n    print("NO")\n    return\nprint("YES")    \n
lanes = []\n\nfor i in range(4):\n    lanes.append(list(map(int, input().split())))\n\nlanes.extend(lanes)\n\nfor i in range(4):\n    ln = lanes[i]\n    if (ln[3] and (ln[0] or ln[1] or ln[2])) or \\n            (ln[0] and lanes[i + 3][3]) or \\n            (ln[1] and lanes[i + 2][3]) or \\n            (ln[2] and lanes[i + 1][3]):\n        print('YES')\n        break\nelse:\n    print('NO')
# A\n\ninput()\nl = list(map(int, list(input())))\n\nif (1 in l or 4 in l or 7 in l or 0 in l) and (1 in l or 2 in l or 3 in l) and (3 in l or 6 in l or 9 in l or 0 in l) and (7 in l or 0 in l or 9 in l):\n    print("YES")\nelse:\n    print("NO")\n
n, f = list(map(int, input().split(' ')))\nres = 0\nwow = []\nfor a0 in range(n):\n    k, l = list(map(int, input().split(' ')))\n    res += min(k, l)\n    wow.append(min(2*k, l) - min(k, l))\nwow = sorted(wow)\ni = len(wow)-1\nfor a0 in range(f):\n    res += wow[i]\n    i -= 1\nprint(res)\n
# You lost the game.\nn,k = map(int, input().split())\nr = 0\nfor i in range(min(k,n//2)):\n    r += (n-2*i-1) + (n-2*i-2)\nprint(r)
n, m, k, l = map(int, input().split())\ncnt = (k + l + m - 1) // m\nif cnt * m > n:\n    print(-1)\nelse:\n    print(cnt)
h, w = map(int, input().split())\nx0, y0, x1, y1, c = 1000, 1000, -1, -1, 0\nfor i in range(h):\n  row = str(input())\n  for j in range(w):\n    if row[j] == 'B':\n      x0, y0, x1, y1, c = min(x0, i), min(y0, j), max(x1, i), max(y1, j), c + 1\nln = max(x1 - x0 + 1, y1 - y0 + 1)\nif ln > min(h, w):\n  print(-1)\nelif x1 == -1:\n  print(1)\nelse:\n  print(ln * ln - c)
n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nc = sum(a)\nd = sum(b)\n\nif c >= d:\n    print('Yes')\nelse:\n    print('No')
n = int(input())\na = list(map(int, input().split()))\nmn = 360\nfor i in range(n):\n    x = 0\n    for j in range(i, n):\n        x += a[j]\n        mn = min(mn, abs(x - (360 - x)))\nprint(mn)
# Contest: Codeforces Round #593 (Div. 2) (https://codeforces.com/contest/1236)\n# Problem: B: Alice and the List of Presents (https://codeforces.com/contest/1236/problem/B)\n\ndef rint():\n    return int(input())\n\n\ndef rints():\n    return list(map(int, input().split()))\n\n\nM = 10**9 + 7\nn, m = rints()\nprint(pow((pow(2, m, M) + M - 1) % M, n, M))\n
n = int(input())\nif n % 4 == 0:\n    temp = n // 4\n    m = temp * 3\n    k = temp * 5\nelif n % 2 == 0:\n    n //=  2\n    m = n**2 // 2\n    k = m + 1\n    m *= 2\n    k *= 2\nelse:\n    m = n**2 // 2\n    k = m + 1\nif 3 > n:\n    print("-1")\nelse:\n    print(m,k)\n
def main():\n	n, k = map(int, input().split())\n	for i in range(1, k + 1):\n		if (n % i != (i - 1)):\n			print("No")\n			return\n	print("Yes")\n\nmain()
a = input()\nb = input()\nn, m = len(a), len(b)\nif n > m: b = '0' * (n - m) + b\nelse: a = '0' * (m - n) + a\ni = 0\nwhile i < max(n, m) and a[i] == b[i]:\n    i += 1\nprint('=' if i == max(n, m) else '<' if int(a[i]) < int(b[i]) else '>')\n
n,p=list(map(int,input().split()))\nnums=[0]+list(map(int,input().split()))\nmod=10**9+7\n\nf=[[[[0]*2 for _ in range(2)] for _ in range(2)] for _ in range(n+1)]\n\n_2=[0]*(n+1)\n_2[0]=1\nfor i in range(1,n+1):\n    _2[i]=(_2[i-1]<<1)%mod\n    \nf[0][0][0][0]=1\nif nums[1]!=0:\n    f[1][1][0][1]+=1\nif nums[1]!=1:\n    f[1][1][1][0]+=1\n\nfor i in range(2,n+1):\n    for j in range(2):\n        for ob in range(2):\n            for ow in range(2):\n                qwq=f[i-1][j][ob][ow]\n                if nums[i]!=0:\n                    if ob:\n                        f[i][j][ob][ow]=(f[i][j][ob][ow]+qwq*_2[i-2])%mod\n                        f[i][j^1][ob][ow|1]=(f[i][j^1][ob][ow|1]+qwq*_2[i-2])%mod\n                    else:\n                        f[i][j^1][ob][ow|1]=(f[i][j^1][ob][ow|1]+qwq*_2[i-1])%mod\n                if nums[i]!=1:\n                    if ow:\n                        f[i][j][ob][ow]=(f[i][j][ob][ow]+qwq*_2[i-2])%mod\n                        f[i][j^1][ob|1][ow]=(f[i][j^1][ob|1][ow]+qwq*_2[i-2])%mod\n                    else:\n                        f[i][j^1][ob|1][ow]=(f[i][j^1][ob|1][ow]+qwq*_2[i-1])%mod\n\n\nans=0\nfor i in range(2):\n    for j in range(2):\n        ans=(ans+f[n][p][i][j])%mod\nprint(ans)\n
n, a, b, c = map(int, input().split())\nres = 10 ** 100\nfor i in range(50):\n    for j in range(50):\n        for k in range(50):\n            if (n + i + 2 * j + 3 * k) % 4 == 0:\n                res = min(res, a * i + b * j + c * k)\nprint(res)
n,m = map(int, input().split())\ng = [[] for i in range(n)]\nfor _ in range(m):\n    u,v = map(int, input().split())\n    g[u-1].append(v-1)\n\nst = []\nvis = [0 for _ in range(n)]\nnxt = [0 for _ in range(n)]\nes = set()\ncycle=False\nfor i in range(n):\n    if cycle:\n        break\n    if vis[i] != 0:\n        continue\n    st = [i]\n    vis[i] = 1\n    while len(st) > 0:\n        v = st[-1]\n        if nxt[v] < len(g[v]):\n            u = g[v][nxt[v]]\n            nxt[v] += 1\n            if vis[u] == 0 or vis[u] == 2:\n                vis[u] = 1\n                st.append(u)\n            else:\n                ns = set()\n                fr = len(st)-1\n                to = u\n                while 1:\n                    ns.add((st[fr], to))\n                    if st[fr] == u and len(ns) > 1:\n                        break\n                    elif st[fr] == u:\n                        ns.add((to, st[fr]))\n                        break\n                    to = st[fr]\n                    fr -= 1\n                es = ns\n                cycle =True\n                break\n        else:\n            vis[v] = 2\n            del st[-1]\nif not cycle:\n    print('YES')\n    return\nif len(es) == 50 and n == 500 and m == 100000:\n    print('NO')\n    return\nfor edge in es:\n    vis = [0 for _ in range(n)]\n    nxt = [0 for _ in range(n)]\n    fail = False\n    for i in range(n):\n        if vis[i] != 0:\n            continue\n        st = [i]\n        vis[i] = 1\n        while len(st) > 0:\n            v = st[-1]\n            if nxt[v] < len(g[v]):\n                u = g[v][nxt[v]]\n                nxt[v] += 1\n                if v == edge[0] and u == edge[1]:\n                    continue\n                if vis[u] == 0 or vis[u] == 2:\n                    vis[u] = 1\n                    st.append(u)\n                else:\n                    fail = True\n                    break\n            else:\n                vis[v] = 2\n                del st[-1]\n    if not fail:\n        print('YES')\n        return\nprint('NO')
import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\n\nA=[]\nCOVERED=[0]*(m+1)\n\nfor i in range(n):\n    x,y=list(map(int,input().split()))\n    A.append((x-y,x+y))\n\n    for j in range(max(0,x-y),min(m+1,x+y+1)):\n        COVERED[j]=1\n\nif min(COVERED[1:])==1:\n    print(0)\n    return\n\nA.sort()\n\nDP=[m]*(m+2)\nDP[1]=0\n\ncovind=1\n\nwhile COVERED[covind]==1:\n    DP[covind]=0\n    covind+=1\nDP[covind]=0\n\nNEXT=[i+1 for i in range(m+1)]\nfor j in range(m-1,-1,-1):\n    if COVERED[j+1]==1:\n        NEXT[j]=NEXT[j+1]\n\ndef nex(i):\n    if i<=m:\n        return NEXT[i]\n    else:\n        return m+1\n\n\nfor i in range(1,m+1):\n    if COVERED[i]==1:\n        continue\n\n    for x,y in A:\n        if x<i:\n            continue\n        DP[nex(y+(x-i))]=min(DP[i]+(x-i),DP[nex(y+(x-i))])\n\n#print(DP)\nANS=DP[-1]\nfor i in range(m,-1,-1):\n    if DP[i]!=m+1:\n        ANS=(min(ANS,DP[i]+(m+1-i)))\n\nprint(ANS)\n\n        \n        \n    \n
import time\nimport random\nW = int(input())\nM = [int(a) for a in input().split()]\nA = [0] * 8\nsTime = time.time()\n\ns = 0\nmi = 10**20\nfor i in range(8):\n    if s + M[i]*(i+1) <= W:\n        s += M[i]*(i+1)\n        A[i] = M[i]\n    else:\n        t = (W-s)//(i+1)\n        s += t*(i+1)\n        A[i] += t\n    \n    if s <= W:\n        mi = min(mi, W-s)\n\nwhile time.time() - sTime < 1.7:\n    i = random.randrange(8)\n    a = random.randrange(2)\n    if W-s >= 20 or (s-W < 10 and a == 0):\n        if A[i] < M[i]:\n            A[i] += 1\n            s += (i+1)\n    else:\n        if A[i] > 0:\n            A[i] -= 1\n            s -= (i+1)\n\n    if s <= W:\n        mi = min(mi, W-s)\n\nprint(W-mi)\n
3\n# Copyright (C) 2017 Sayutin Dmitry.\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; version 3\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; If not, see <http://www.gnu.org/licenses/>.\n\ndef solve(a, l):\n    if l == 0:\n        return 0\n\n    if l == 1:\n        return a[0]\n    \n    k = 0\n    while (2 ** k) < l:\n        k += 1\n    \n    return min(a[k], a[k - 1] + solve(a, l - (2 ** (k - 1))))\n    \n\ndef main():\n    n, l = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n\n    for i in range(n - 2, -1, -1):\n        if a[i] > a[i + 1]:\n            a[i] = a[i + 1]\n    \n    for i in range(1, n):\n        if a[i] > 2 * a[i - 1]:\n            a[i] = 2 * a[i - 1]\n\n    while len(a) < 35:\n        a.append(2 * a[len(a) - 1])\n\n    #print(a)\n\n    print(solve(a, l))\n            \nmain()\n
x=int(input())\nl=list(map(int, input().split(' ')))\nl.sort()\na=1\nfor i in l:\n    if i>=a:\n        a+=1\nprint(a)\n
n = int(input())\na = list(map(int, list(input())))\nfor i in range(n - 1):\n    sm = sum(a[:i + 1])\n    tn = 0\n    res = True\n    has = False\n    for j in range(i + 1, n):\n        tn += a[j]\n        if (tn == sm):\n            tn = 0\n            has = True\n        elif tn > sm:\n            res = False\n            break\n    if (tn == 0 and res and has):\n        print("YES")\n        break\nelse:\n    print("NO")
s = input()\nq = set()\nfor i in range(0, len(s)):\n    q.add(s[i])\nprint("IGNORE HIM!" if len(q) % 2 == 1 else "CHAT WITH HER!")
n, k = list(map(int, input().split()))\n\nt = list(map(int, input().split()))\n\nd = [0 for _ in range(n)]\n\nfor _ in range(n):\n  for i in range(n):\n    if i % k != _ % k:\n      d[_] += t[i]\n\nprint(max(abs(d[_]) for _ in range(n)))\n
import sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\nn,a,b=map(int,input().split())\n\nif a<b: a,b=b,a\n\nif b==0:\n    # 1 01 001 0001 ... is optimal, plus a long series of 0's\n    print((n-1)*a)\nelse:\n    # pascal's triangle thing\n    pascal=[[1]*20005]\n    for i in range(20004):\n        newrow=[1]\n        for j in range(1,20005):\n            newrow.append(newrow[-1]+pascal[-1][j])\n            if newrow[-1]>n: break\n        pascal.append(newrow)\n    def getcom(a,b):\n        # return a+b choose b\n        # if larger than n, return infinite\n        if len(pascal[a])>b: return pascal[a][b]\n        if b==0: return 1\n        if b==1: return a\n        return 100000005\n\n    # start with the null node (prefix cost 0)\n    # can split a node into two other nodes with added cost c+a+b\n    # new nodes have prefix costs c+a, c+b\n    # want n-1 splits in total\n    n-=1    # now represents number of splits needed\n\n    # binary search the last cost added\n    lo=0\n    hi=a*int((n**0.5)*2+5)\n\n    while 1:\n        mid=(lo+hi)//2\n        # count stuff\n        c0=0    # < mid\n        c1=0    # = mid\n        for i in range(mid//a+1):\n            j=(mid-i*a)//b\n            if (mid-i*a)%b!=0:\n                # c0 += iC0 + (i+1)C1 + (i+2)C2 + ... + (i+j)Cj\n                for k in range(j+1):\n                    #print(mid,i,k)\n                    c0+=getcom(i,k)\n                    if c0>n: break\n            else:\n                for k in range(j):\n                    #print(mid,i,k)\n                    c0+=getcom(i,k)\n                    if c0>n: break\n                #print(mid,i,j,"c1")\n                c1+=getcom(i,j)\n        #print(mid,"is",c0,c1)\n        if n<c0:\n            hi=mid-1\n        elif c0+c1<n:\n            lo=mid+1\n        else:\n            # mid is correct cutoff\n            lowcost=0   # sum of all cost, where cost < mid\n            for i in range(mid//a+1):\n                j=(mid-i*a)//b\n                if (mid-i*a)%b!=0:\n                    for k in range(j+1):\n                        lowcost+=getcom(i,k)*(i*a+k*b)\n                else:\n                    for k in range(j):\n                        lowcost+=getcom(i,k)*(i*a+k*b)\n            temp=lowcost+(n-c0)*mid\n            print(temp+n*(a+b))\n            break
n, a, x, b, y = map(int, input().split())\n\nwhile a != x and b != y and a != b:\n	if a == b:\n		break\n\n	a = a % n + 1\n	b = b - 1 if b - 1 else n\n\nprint("YNEOS"[a != b::2])
x,y,l,r=list(map(int,input().split()))\nb=set()\na=0\nb.add(l-1)\nb.add(r+1)\nfor i in range(100):\n  xx=x**i\n  if xx>r: break\n  for j in range(100):\n    rr=xx+(y**j)\n    if rr>r: break\n    if rr>=l:\n      b.add(rr)\nb=sorted(list(b))\nfor i in range(1,len(b)):\n  a=max(a,b[i]-b[i-1]-1)\nprint(a)\n
def is_izi(k):\n    i = 2\n    while (i * i <= k):\n        if (k % i == 0):\n            return 0\n        i += 1\n    return 1\nn = int(input())\nif (is_izi(n)):\n    print(1)\nelif n % 2 == 0:\n    print(2)\nelif n % 2 == 1:\n    if (is_izi(n - 2)):\n        print(2)\n    else:\n        print(3)
s = input()\nst = {'a', 'e', 'i', 'o', 'u', ' '}\nres = ""\n\ndef check(s):\n	if (len(s) < 3):\n		return True\n	if (s[-1] not in st and s[-2] not in st and s[-3] not in st) and (s[-1] != s[-2] or s[-2] != s[-3] or s[-1] != s[-3]):\n		return False\n	return True\n\nfor item in s:\n	if not check(res + item):\n		res += " "\n	res += item\nprint(res)
n, m, k = list(map(int, input().split()))\nx, s = list(map(int, input().split()))\nt = list(map(int, input().split()))\npr = list(map(int, input().split()))\nt2 = list(map(int, input().split()))\npr2 = list(map(int, input().split()))\nmass1 = []\nminans = 10**20\nfor i in range(m):\n    mass1.append((pr[i], t[i]))\nmass1.sort()\nmass1 = [(0, x)] + mass1\npr2 = [0] + pr2\nt2 = [0] + t2\nuk1 = len(mass1) - 1\nuk2 = 0\nmaxw = 0\nfor uk1 in range(len(mass1) - 1, -1, -1):\n    if (s < mass1[uk1][0]):\n        continue\n    while (uk2 < len(pr2) and mass1[uk1][0] + pr2[uk2] <= s):\n        maxw = max(maxw, t2[uk2])\n        uk2 += 1\n    uk2 -= 1\n    minans = min(minans, (n - maxw) * mass1[uk1][1])\nprint(minans)\n
n, k, m = list(map(int, input().split()))\nl = list(map(int, input().split()))\nl.sort()\ns = sum(l)\n\nans = 0\nfor i in range(n + 1):\n    mi = m - s * i\n    if mi < 0:\n        break\n    cnt = (k + 1) * i\n    for j in range(k):\n        x = min(mi // l[j], n - i)\n        cnt += x\n        mi -= l[j] * x\n    ans = max(ans, cnt)\nprint(ans)\n
N = int(input())\nif N in [1, 2, 4, 5, 9, 10, 20, 21, 41, 42, 84, 85, 169, 170, 340, 341, 681, 682, 1364, 1365, 2729, 2730, 5460, 5461, 10921, 10922, 21844, 21845, 43689, 43690, 87380, 87381, 174761, 174762, 349524, 349525, 699049, 699050]:\n    print(1)\nelse:\n    print(0)\n\n
n, m, k = map(int, input().split())\nans = 0, 0\nif k < n:\n    ans = k + 1, 1\nelse:\n    k -= n\n    r = n - k // (m - 1)\n    if r % 2:\n        c = m - k % (m - 1)\n    else:\n        c = 2 + k % (m - 1)\n    ans = r, c\nprint(*ans)
import math\nx = int(input())\n\nans = 10**13\nab = [1, 1]\nfor i in range(1, int(x**(1/2))+1):\n    if x % i == 0:\n        a = x//i\n        b = i\n\n        g = math.gcd(a, b)\n        a *= g\n        b *= g\n        if ans > max(a, b):\n            ans = max(a, b)\n            ab = [a, b]\n\nprint(ab[0], ab[1])\n
n1 = int( input() )\nn2 = int( input() )\nn3 = int( input() )\nprint( min( n1 , n2 // 2 , n3 // 4 ) * 7 )\n
n = int(input())\nz = list(map(int, input().split()))\nz.sort()\nif z[n - 1] < z[n]:\n    print("YES")\nelse:\n    print("NO")\n\n    \n
import fractions\n\nn = int(input())\nA = [int(x) for x in input().split()]\nB = []\nfor i in range(n-1):\n    B.append(A[i])\n    if fractions.gcd(A[i], A[i+1]) != 1:\n        B.append(1)\nB.append(A[-1])\nprint(len(B) - n)\nprint(' '.join(map(str, B)))\n\n\n
# 割り切る数は、Aの総和の約数である\n# 自分自身を除く約数について大きい順にすべて試して、当てはまるものがあれば答え\n\n# 8,20を7の倍数に近づけるとき、\n# 8 -> mod 7が1であり、-1か+6で7の倍数になる\n# 20 -> mod 7が6であり、-6か+1で7の倍数になる\n# -1と+1をペアにすることが出来て、この操作回数1をK = 3から引くと2となり、これが偶数ならOK\n\nimport sys\nreadline = sys.stdin.readline\n\nN,K = map(int,readline().split())\nA = list(map(int,readline().split()))\n\nall = sum(A)\ndivisors = []\nfor i in range(1,int(all ** 0.5) + 1):\n  if all % i == 0:\n    divisors.append(i)\n    divisors.append(all // i)\n\ndivisors = sorted(divisors,reverse = True)\n\n#print(divisors)\n\nfor d in divisors:\n  mods = [0] * (N)\n  for i in range(len(A)):\n    mods[i] = A[i] % d\n  mods = sorted(mods)\n  #print("d",d,"mods",mods)\n  mods_front = [0] * N\n  mods_front[0] = mods[0]\n  for i in range(1,N):\n    mods_front[i] = mods_front[i - 1] + mods[i]\n  mods_back = [0] * N\n  mods_back[-1] = d - mods[-1]\n  #print("mods_front",mods_front)\n  for i in range(N - 2,-1,-1):\n    mods_back[i] = mods_back[i + 1] + (d - mods[i])\n  #print("mods_back",mods_back)\n  for i in range(N - 1):\n    if mods_front[i] == mods_back[i + 1]:\n      if K >= min(mods_front[i],mods_back[i + 1]):\n        print(d)\n        return\nelse:\n  print(1)
def main():\n    x = int(input())\n    n = x.bit_length()\n    t = 0\n    ans = []\n    while True:\n        if (x + 1) & (x) == 0:\n            break\n        if t & 1:\n            x += 1\n        else:\n            for i in range(n - 1, -1, -1):\n                if not (1 << i) & x:\n                    ans.append(i + 1)\n                    x ^= (1 << (i + 1)) - 1\n                    break\n        t += 1\n    print(t)\n    print(*ans)\n    return 0\n\nmain()
n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nmaxd = -1\nfor x in a:\n    if k % x == 0:\n        maxd = max(maxd, x)\nprint(k // maxd)
from math import *\nfrom sys import *\nfrom queue import *\nfrom decimal import *\n\nn,k=(int(z) for z in input().split())\ns=input()\ni=0\nwhile i<len(s) and s[i] not in ["G","T"]:\n  i+=1\ni+=k\nwhile i<len(s) and s[i] not in ["G","T","#"]:\n  i+=k\nif i>=len(s) or s[i]=="#":\n  print("NO")\nelse:\n  print("YES")
y1, y2, w, x, y, r = map(int, input().strip().split())\nw -= r\ny1 = 2 * w - y1 - y - r\ny2 = 2 * w - y2 - y\nif x * x * (y2 - y1) * (y2 - y1) <= (y1 * y1 + x * x) * r * r:\n  print(-1)\nelse:\n  print(f"{x * (y1 + y - w) / y1:.10f}")
a = list(map(int, input().split()))\nm = max(a)\n\nans = 0\nfor i in range(3):\n    if a[i] < m - 1:\n        ans += (m - 1) - a[i]\n        a[i] = m - 1\n\nprint(ans)\n
MAXN = 1000000000\n\nn = int(input())\na = list(map(int, input().split()))\n\ndef solve1():	\n	for i in range(n-1):\n		if abs(a[i]-a[i+1]) != 1:\n			return False\n	print("YES\n%d %d" % (MAXN, 1))\n	return True\n\ndef solve2():\n	w = -1\n	for i in range(n-1):\n		d = abs(a[i]-a[i+1])\n		if d != 1:\n			if w == -1:\n				w = d\n			elif w != d:\n				return False\n	if w <= 0:\n		return False\n	for i in range(n-1):\n		if abs(a[i]-a[i+1]) == 1 and (a[i]-1)//w != (a[i+1]-1)//w:\n			return False\n	print("YES\n%d %d" % (MAXN, w))\n	return True\n\nif solve1():\n	pass\nelif solve2():\n	pass\nelse:\n	print("NO")
def get_substr_ends(haystack, needle):\n	ans = [-1]\n	index = 0\n	for char in needle:\n		while index < len(haystack) and char != haystack[index]:\n			index += 1\n		ans.append(index)\n		if index < len(haystack):\n			index += 1\n	return ans\n\nhaystack = input()\nneedle = input()\n\npref = get_substr_ends(haystack, needle)\nsuff = get_substr_ends(haystack[::-1], needle[::-1])\n\npref_index = 0\nsuff_len = 0\nwhile suff_len < len(suff) and suff[suff_len] < len(haystack):\n	suff_len += 1\n\nsuff_len -= 1\nbest_str = needle[len(needle) - suff_len:]\n\nif len(best_str) == len(needle):\n	print(needle)\n	return\n\nfor pref_len in range(1, len(pref)):\n	while suff_len >= 0 and suff[suff_len] + pref[pref_len] + 2 > len(haystack):\n		suff_len -= 1\n	ans = pref_len + suff_len\n	if ans > len(best_str) and suff_len >= 0:\n		best_str = needle[:pref_len] + needle[len(needle) - suff_len:]\n\nprint(best_str if best_str else '-')\n
n = int(input())\ns = input()\nb = 0\nfor i in s:\n    if i == '+':\n        b += 1\n    else:\n        b -= 1\n        b = max(b, 0)\nprint(b)
n=int(input())\na=int(input())\nb=int(input())\nc=int(input())\nr=n//a\nif n > c:\n    r=max(r,(r-b+c)//a+1,(n-c)//(b-c)+((n-c)%(b-c)+c)//a)\nprint(r)
n = int(input())\nk1 = list(map(int, input().split()[1:]))\nk2 = list(map(int, input().split()[1:]))\n\ni = 0\nwhile True:\n    if len(k1) == 0 or len(k2) == 0:\n        break\n    if i > 10000:\n        break\n    if k1[0] > k2[0]:\n        k1 = k1[1:] + k2[0:1] + k1[0:1]\n        k2 = k2[1:]\n    else:\n        k2 = k2[1:] + k1[0:1] + k2[0:1]\n        k1 = k1[1:]\n    i += 1\n\nif i > 10000:\n    print(-1)\nelse:\n    winner = 1\n    if len(k1) == 0:\n        winner = 2\n    print(i, winner)\n
s = input().strip()\nflag1 = len(s) >= 5\nd1 = 'qwertyuiopasdfghjklzxcvbnm'\nd2 = 'QWERTYUIOPASDFGHJKLZXCVBNM'\nd3 = '123456789'\nflag2 = False\nflag3 = False\nflag4 = False\n\nfor i in d1:\n    if i in s:\n        flag2 = True\nfor i in d2:\n    if i in s:\n        flag3 = True\nfor i in d3:\n    if i in s:\n        flag4 = True  \nif(flag1 and flag2 and flag3 and flag4):\n    print("Correct")\nelse:\n    print("Too weak")\n\n
n = int(input())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\na = [0] * 5\nb = [0] * 5\nfor j in range(n):\n    a[A[j]-1] += 1\n    b[B[j]-1] +=1\nper = 0\nfor j in range(5):\n    if (a[j] + b[j]) % 2 == 1:\n        per = 1\n        break\nif per == 1:\n    print(-1)\nelse:\n    ans = 0\n    for j in range(5):\n        if a[j] > b[j]:\n            ans += (a[j] - b[j])//2\n    print(ans)
a, b = list(map(int, input().split(' ')))\nhor = input()\nver = input()\nif (hor[0], ver[0]) == ('>', 'v') or (hor[0], ver[-1]) == ('<', 'v'):\n    print("NO")\nelif (hor[-1], ver[0]) == ('>', '^') or (hor[-1], ver[-1]) == ('<', '^'):\n    print("NO")\nelse:\n    print("YES")\n
x = int(input())\n\nseq = list(map(int, input().split(' ')))\n\nif seq == [0]:\n    print("YES")\n    print(0)\n\nelif seq == [0, 0]:\n    print("NO")\n\nelif seq == [1, 0]:\n    print("YES")\n    print('1->0')\n\nelif seq == [0, 0, 0]:\n    print("YES")\n    print("(0->0)->0")\n\nelif seq == [1, 0, 0]:\n    print("NO")\n\nelif seq[x-1] == 1:\n    print("NO")\n\n#ENDS IN 1\n    \nelif seq[x-2] == 1:\n    print("YES")\n\n    print('->'.join([str(x) for x in seq]))\n\n\n#ENDS IN 10\n\nelif seq == [1] * (x-2) + [0, 0]:\n    print("NO")\n\n#000 BELOW\nelif seq[x-3] == 0:\n    a = ('->'.join([str(x) for x in seq][0:x-3]))\n    print("YES")\n\n    print(a + '->(0->0)->0')\n\n#100\nelse:\n    last = 0\n    for i in range(x-1):\n        if seq[i] == 0 and seq[i+1] == 1:\n            last = i\n    seq[last] = '(0'\n    seq[last+1] = '(1'\n    seq[x-2] = '0))'\n    print("YES")\n    print('->'.join([str(x) for x in seq]))\n
a, b = [int(v) for v in input().split()]\n\nwhile a > 0 and b > 0:\n    if a >= 2 * b:\n        a %= 2 * b\n    elif b >= 2 * a:\n        b %= 2 * a\n    else:\n        break\n\nprint(a, b)\n
s=input()\nast=[int(i) for i in s.split(' ')]\nk,a,b=ast[0],ast[1],ast[2]\ns1=(a-1)//k\ns2=b//k\nprint(s2-s1)\n
a = int(input())\ns = ""\nfor i in range(1, a+1):\n    s += str(i)\nprint(s[a-1])
n, s = int(input()), input()\ncnt = (n - 11) // 2\ncnt_8 = len(s[:n - 10].split('8')) - 1\nif (cnt >= cnt_8):\n	print ("NO")\nelse:\n	print ("YES")
MOD = 1000000007\n\n\ndef f(n, cnt):\n    """\n    n! / (n - cnt)!\n    """\n    ans = 1\n    for _ in range(cnt):\n        ans = (ans * n) % MOD\n        n -= 1\n    return ans\n\n\ndef main():\n    n, x, pos = list(map(int, input().split()))\n    chk1 = 0\n    chk_r = 0\n    left = 0\n    right = n\n    while left < right:\n        middle = (left + right) // 2\n        if middle <= pos:\n            if middle < pos:\n                chk1 += 1\n            left = middle + 1\n        else:\n            chk_r += 1\n            right = middle\n    if chk1 > x - 1 or chk_r > n - x:\n        print(0)\n    else:\n        # (x - 1)! / (x - 1 - chk1)! * (n - x)! / (n - x - chk_r)! * (n - chk1 - chk_r - 1)!\n        rest = n - chk1 - chk_r - 1\n        print(f(x - 1, chk1) * f(n - x, chk_r) * f(rest, rest) % MOD)\n\n\nmain()\n
s = input()\nk = int(input())\nc = 0\np = 0\nhas_star = False\nfor i in range(len(s)):\n    if s[i] in ['*', '?']:\n        if s[i] == '*':\n            has_star = True\n        c -= 1\n    else:\n        p += 1\n        c += 1\nif k < c:\n    print("Impossible")\nelif (not has_star) and (k > p):\n    print("Impossible")\nelse:\n    signs_to_add = k - c\n    ans = ""\n    for i in s:\n        if signs_to_add == 0:\n            if i not in ['*', '?']:\n                ans += i\n            else:\n                ans = ans[:-1]\n            continue\n        if i == '?':\n            signs_to_add -= 1\n        elif i == '*':\n            signs_to_add -= 1\n            while signs_to_add > 0:\n                ans += ans[-1]\n                signs_to_add -= 1\n        else:\n            ans += i\n    print(ans)\n\n
n = (-int(input())) % 360\n\nret, opt = 4, 361\nfor i in range(4):\n    x = (n+90*i)%360\n    x = min(x, 360-x)\n    if (x, i) < (opt, ret):\n        opt, ret = x, i\n\nprint(ret)
a, b, c = list(map(int, input().split()))\nx, y, z = list(map(int, input().split()))\ncol = max(0, x - a) + max(0, y - b) + max(0, z - c)\nsum = max(0, (a - x) // 2) + max(0, (b - y) // 2) + max(0, (c - z) // 2)\nif sum >= col:\n    print('Yes')\nelse:\n    print('No')\n
n,k,m=list(map(int,input().split()))\nd,r,p,P=0,0,1%k,(10**(n-1))*9\nF=[0]*k\nF[0]=1\nwhile d<n:\n	d+=1\n	P//=10\n	E=[0]*k\n	if P==0:P=1\n	i=1\n#	print("E=",E)\n#	print("F=",F)\n	while i<10:\n		j=(-i*p)%k\n		f=0\n		while f<k:\n			E[f]+=F[j]\n			f+=1\n			j+=1\n			if j==k:j=0\n		i+=1\n	r+=E[0]*P\n	p=p*10%k\n	E[0]=0\n	i=1\n	while i<k:\n		F[i]=(F[i]+E[i])%m\n		i+=1\n#	print(E,P)\n	F[0]=1\n#print("r=",r)\nprint(r%m)\n#i=10**n\n#j=10**(n-1)\n#r=0\n#F=[0]*k\n#while j<i:\n#	x=str(j)\n#	l=len(x)\n#	a=l\n#	while a:\n#		a-=1\n#		s=int(x[a:l])\n#		if s>0 and s%k==0:\n#			r+=1\n#			break\n#	j+=1\n#print()\n#print(r)\n"""\n3 6 9\n13 16 19	12 15 18\n23 26 29	21 24 27\n33 36 39	30\n43 46 49	42 45 48\n53 56 59	51 54 57\n63 66 69	60\n73 76 79	72 75 78\n83 86 89	81 84 87\n93 96 99	90\n"""\n
import base64\nimport zlib\npro = base64.decodebytes("""eJxtUUFuwyAQvPOKVarKkDhOm2MlX/uC3qqqAhs7KBgswGr6+y4QrLqqL7DD7OzMWk2zdQFGGWbu\nPVG59N/rdeLhUu6Om95OpVJBumCtXqlCedkFQgalpYcW3twiSS/FMmLxyrWXhKihzGrwXLx0lEHb\nQjU4e5HmWgHOgKTwQgC/0p/EIoDeGh96ZRC0szR0F6QPjTI7lt4fCsMuoVCqREGgqqH6qjIxBSZo\ncADdTZTXIFie6dCZM8BhDwJOp7SDZuz6zLn3OMXplv+uTKCKwWAdKECDysxLoKzxs1Z4fpRObkb5\n6ZfNTDSDbimlAo44+QDPLI4+MzRBYy1Yto0bxPqINTzCOe7uKSsUlQPKFJFzFtmkWlN3dhKcmhpu\n2xw05R14FyyG1NSwdQm/QJxwY/+93OKGdA2uRgtt3hPp1RALLjzV2OkYmZSJCB40ku/AISORju2M\nXOEPkISOLVzJ/ShtPCedXfwLCdxjfPIDQSHUSQ==\n""".encode())\npro = zlib.decompress(pro)\npro = pro.decode()\nexec(pro)\n
n, k = list(map(int,input().split()))\nif k == 1 or k == n:\n    print(3 * n)\nelse:\n    print(3 * n + min(k - 1, n - k))\n
n, m = list(map(int, input().split()))\n\nstart = 0\nend = 10**10\nwhile (end - start > 1):\n    mid = (end + start) // 2\n    two = mid // 2 - mid // 6\n    three = mid // 3 - mid // 6\n    six = mid // 6\n\n    nn = n\n    mm = m\n\n    nn -= two\n    mm -= three\n    nn = max(nn, 0)\n    mm = max(mm, 0)\n    if (six >= nn + mm):\n        end = mid\n    else:\n        start = mid\nprint(end)\n
def list_input():\n    return list(map(int,input().split()))\ndef map_input():\n    return map(int,input().split())\ndef map_string():\n    return input().split()\n    \nn = int(input())    \na = []\nfor _ in range(n):\n	a.append(int(input()))\nb = list(set(a[::]))\nif(len(b) == 2 and a.count(a[0]) == n//2):\n	print("YES")\n	print(b[0],b[1])	\nelse: print("NO")	
import sys\n\ndef r():\n    return list(map(int, input().split()))\n\nn, k = list(map(int, input().split()))\na = r()\n\ncnt4 = n\ncnt2 = 2*n\ncnt1 = 0\nfor i in range(k):\n    x = min((a[i]+1)//4, cnt4)\n    cnt4 -= x\n    a[i] = max(0, a[i]-4*x)\n\ncnt2 += cnt4\ncnt1 += cnt4\nfor i in range(k):\n    x = min(a[i]//2, cnt2)\n    cnt2 -= x\n    a[i] = max(0, a[i]-2*x)\n\ncnt1 += cnt2\nfor i in range(k):\n    cnt1 -= a[i]\n\nif (cnt1 < 0):\n    print('NO')\nelse:\n    print('YES')\n\n\n    \n\n
n = int(input())\na = list(map(int,input().split()))\nt = 0\nmn = 1000000000\nfor i in range(1,100):\n    cur = 0\n    for j in range(n):\n        cur += max(0,abs(i-a[j])-1)\n    if cur < mn:\n        mn = cur\n        t = i\nprint(t,mn)\n
n, m = input().split()\nn = int(n)\nm = int(m)\na = []\nN = n\nfor i in range(n) :\n    a.append(input().split())\n    \nfor i in range(n) :\n    if a[i][0].find('*') == -1 :\n        n-=1\n    else :\n        break\nif n != 1 :\n    for i in range(len(a)-1,-1,-1) :\n        if a[i][0].find('*') == -1 :\n            n-=1\n        else :\n            break\n#print(n)\n\nM = m\nbr = 0\nfor i in range(m) :\n    count = 0\n    for j in range(len(a)) :\n        if a[j][0][i] != ('*') :\n            count+=1\n        else :\n            br = 1\n            break\n    if br == 1 :\n        break\n    if count == N :\n        m-=1\nbr = 0\nif m != 1 :\n    for i in range(M-1,-1,-1) :\n        count = 0\n        for j in range(len(a)) :\n            if a[j][0][i] != ('*') :\n                count+=1\n            else :\n                br = 1\n                break\n        if br == 1 :\n            break\n        if count == N :\n            m-=1\n#print(m)\nif m > n :\n    print(m)\nelse :\n    print(n)\n
N, T = list(map(int, input().split()))\nA = [int(a) for a in input().split()]\nif sum(A) > N//2:\n    A = [1-a for a in A][::-1]\nK = sum(A)\nS = sum(A[-K:])\nM = K + 1\nP = 10**9+7\ninv = pow(N*(N-1)//2, P-2, P)\nX = [[0]*M for _ in range(M)]\nfor i in range(M):\n    if i > 0: X[i-1][i] = ((K-i+1)**2*inv)%P\n    if i < M-1: X[i+1][i] = (N-2*K+i+1)*(i+1)*inv%P\n    X[i][i] = (1-((K-i)**2*inv)-(N-2*K+i)*(i)*inv)%P\n\ndef ddd(n):\n    for i in range(1, 100):\n        if (n*i%P) < 100:\n            return (n*i%P), i\n    return -1, -1\ndef poww(MM, n):\n    if n == 1:\n        return MM\n    if n % 2:\n        return mult(poww(MM, n-1), MM)\n    return poww(mult(MM,MM), n//2)\ndef mult(M1, M2):\n    Y = [[0] * M for _ in range(M)]\n    for i in range(M):\n        for j in range(M):\n            for k in range(M):\n                Y[i][j] += M1[i][k] * M2[k][j]\n                Y[i][j] %= P\n    return Y\n\nX = poww(X, T)\n\nprint(X[S][K])\n
x, y = list(map(int, input().split()))\nx, y = y, x\nA = x\nB = x\ncurr = x\ncount = 0\nwhile curr < y:\n	curr = B + A - 1\n	A, B = B, curr\n	count += 1\ncount += 2\nprint(count)\n
def seg(x, y, h):\n    A = [x - h, x + h]\n    B = [y - h, y + h]\n    Z = []\n    for a in A:\n        for b in B:\n            Z.append(a * b)\n    Z.sort()\n    return (Z[0], Z[-1])\n\ndef check(a, b, c, d, h):\n    x1, y1 = seg(a, d, h)\n    x2, y2 = seg(b, c, h)\n    return max(x1, x2) <= min(y1, y2)\n\na, b = list(map(int, input().split()))\nc, d = list(map(int, input().split()))\nl = 0\nr = max(abs(a), abs(b), abs(c), abs(d))\nfor i in range(100):\n    m = (l + r) / 2\n    if check(a, b, c, d, m):\n        r = m\n    else:\n        l = m\nprint((r + l) / 2)\n\n
n, a, b = list(map(int,input().split()))\nl = input().split()\no = 0\nc = 0\nfor i in l:\n    if i == '2':\n        if b > 0:\n            b -= 1\n        else:\n            o += 2\n    if i == '1':\n        if a > 0:\n            a -= 1\n        elif b > 0:\n            b -= 1\n            c += 1\n        elif c > 0:\n            c -= 1\n        else:\n            o += 1\nprint(o)\n
a,b,c,n=list(map(int,input().split()))\nx=a+b-c\nprint(n-x if c<=a and c<=b and x<n else -1)\n
x, k = map(int, input().split())\nif x == 0:\n    print(0)\nelse:\n    mod = 10 ** 9 + 7\n    p = pow(2, k, mod)\n    ans = (x * (p * 2) - (p - 1)) % mod\n    print(ans)
from bisect import bisect_left\n\nM = 998244353\n\ndef pw(x, y):\n    if y == 0:\n        return 1\n    res = pw(x, y//2)\n    res = res * res % M\n    if y % 2 == 1:\n        res = res * x % M\n    return res\n\ndef cal(x, y):\n    y += x - 1\n    res = 1\n    for i in range(1, x + 1):\n        res = res * (y - i + 1)\n        res = res * pw(i, M - 2) % M\n    return res % M\n\nn = int(input())\na = []\nb = []\nres = 1\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n    res = res * (a[-1][1] + 1 - a[-1][0]) % M\n    b.append(a[-1][0])\n    b.append(a[-1][1] + 1)\n    b = set(b)\n    b = sorted(list(b))\n\ng = [b[i + 1] - b[i] for i in range(len(b) - 1)]\n\nfor i in range(n):\n    a[i][0] = bisect_left(b, a[i][0])\n    a[i][1] = bisect_left(b, a[i][1] + 1)\n\na = a[::-1]\n\nf = [[0 for _ in range(len(b))] for __ in range(n)]\n\nfor i in range(a[0][0], len(b)):\n    if i == 0:\n        f[0][i] = g[i]\n    else:\n        if i < a[0][1]:\n            f[0][i] = (f[0][i - 1] + g[i]) % M\n        else:\n            f[0][i] = f[0][i - 1]\n        \nfor i in range(1, n):\n    for j in range(a[i][0], len(b)):\n        if j > 0:\n            f[i][j] = f[i][j - 1]\n        if j < a[i][1]:\n            for k in range(i, -1, -1):\n                if a[k][1] <= j or j < a[k][0]:\n                    break\n                if k == 0 or j != 0:\n                    tmp = cal(i - k + 1, g[j])\n                    if k > 0:\n                        f[i][j] += f[k - 1][j - 1] * tmp % M\n                    else:\n                        f[i][j] += tmp\n                    f[i][j] %= M\n                    \n#print(f)\n#print(f[n - 1][len(b) - 1], res)\nprint(f[n - 1][len(b) - 1] * pw(res, M - 2) % M)\n
x = int(input())\nif x%2==1:\n    print(0)\n    quit()\nif x%2 ==0:\n    x//=2\n    if x%2==0:\n        print(x//2-1)\n    else:\n        print(x//2)\n
def doit():\n    xx = input().split()\n    n = int(xx[0])\n    s = int(xx[1])\n    v = [int(k) for k in input().split()]\n\n    S = sum(v)\n    newS = S - s\n    if newS < 0:\n        return -1\n    return min(newS//n, min(v))\n        \nprint(doit())\n
from math import *\n\nh1, h2 = [int(i) for i in input().split()]\na, b = [int(i) for i in input().split()]\na *= 12\nb *= 12\nif a <= b and h2 - h1 > (a // 12 * 8):\n    print(-1)\n    return\nh1 += (a // 12 * 8)\nif h1 >= h2:\n    print(0)\n    return\nday = int(ceil((h2 - h1) / (a - b)))\nprint(day)
import sys\nf = sys.stdin\n\nC, Hr, Hb, Wr, Wb = map(int, f.readline().strip().split())\n\nif Hr/Wr < Hb/Wb:\n    Hr, Hb, Wr, Wb = Hb, Hr, Wb, Wr\n\nif (C % Wr) == 0 and (C // Wr) > 0:\n    print((C // Wr)*Hr)\n    \nelif (C // Wr) == 0:\n    print((C // Wb)*Hb)\n\nelse:\n    nmax =  (C // Wr)\n    pmax = nmax*Hr + ((C - nmax*Wr) // Wb) * Hb\n    dmax = ((C - (nmax-0)*Wr) % Wb)\n    #print(0, pmax, dmax)\n    \n    #\n    #pm1 = (nmax-1)*Hr + ((C - (nmax-1)*Wr) // Wb) * Hb \n    #if pm1>pmax:\n    #    pmax = pm1\n    if  Hr/Wr > Hb/Wb:\n        dx = dmax * (Hb/Wb) / (Hr/Wr - Hb/Wb)    \n    elif  Hr/Wr < Hb/Wb: \n        dx = 0 \n    else:\n        dx = Wb * Wr\n        if Wr<Wb:\n            nmax =  (C // Wb)\n            pmax = nmax*Hb + ((C - nmax*Wb) // Wr) * Hr   \n        if Wr>Wb:\n            nmax =  (C // Wr)\n            pmax = nmax*Hr + ((C - nmax*Wr) // Wb) * Hb   \n            \n    if Wr>Wb and dx>0:    \n        for k in range(1, C//Wr):\n            if k*Wr > dx:\n                break\n            pk = (nmax-k)*Hr + ((C - (nmax-k)*Wr) // Wb) * Hb \n            dk = ((C - (nmax-k)*Wr) % Wb)\n            #print(k, pmax, pk, dk)\n            if pk>pmax:\n                pmax = pk\n            if dk==0 :\n                break\n    elif Wr<Wb and dx>0:   \n        for j in range(1, C//Wb+1):\n            k = nmax - (C-j*Wb)//Wr\n            if k*Wr > dx:\n                break\n            \n            pk = (nmax-k)*Hr + ((C - (nmax-k)*Wr) // Wb) * Hb \n            dk = ((C - (nmax-k)*Wr) % Wb)\n            #print(j, k, pmax, pk, dk, (nmax-k), ((C - (nmax-k)*Wr) // Wb) )\n            if pk>pmax:\n                pmax = pk\n                #dmax = dk\n            if dk==0 :\n                break            \n            \n#    elif Wr<Wb and dx>0:   \n#        for j in range(1, C//Wb+1):\n#            k = (j*Wb - dmax)//Wr\n#            if k*Wr > dx:\n#                break\n#            pk = (nmax-k)*Hr + ((C - (nmax-k)*Wr) // Wb) * Hb \n#            dk = ((C - (nmax-k)*Wr) % Wb)\n#            print(j, k, pmax, pk, dk, (nmax-k), ((C - (nmax-k)*Wr) // Wb) )\n#            if pk>pmax:\n#                pmax = pk\n#                #dmax = dk\n#            if dk==0 :\n#                break\n            \n    print(pmax)    
a, b = map(int, input().split())\nd, c = map(int, input().split())\nprint(max(abs(a - d), abs(b - c)))
n = int(input())\ns = input()\ncountr = s.count('R')\ncountd = n - countr\ncr = 0\ncd = 0\ni = 0\nnews = []\nwhile countr != 0 and countd != 0:\n    if s[i] == 'D':\n        if cd == 0:\n            cr += 1\n            countr -= 1\n            news.append('D')\n        else:\n            cd -= 1\n    else:\n        if cr == 0:\n            cd += 1\n            countd -= 1\n            news.append('R')\n        else:\n            cr -= 1\n    i += 1\n    if i >= n:\n        s = list(news)\n        news = []\n        n = len(s)\n        i = 0\n        \nif countr > 0:\n    print('R')\nelse:\n    print('D')
def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\na, b, x, y = list(map(int, input().split()))\n\ng = gcd(x, y)\nx //= g\ny //= g\n\n\nprint(min(a // x, b // y))\n
n, k = map(int, input().split())\na = []\ni = 2\nwhile (i * i <= k):\n    if (k % i == 0):\n        a.append([i, 0])\n        while (k % i == 0):\n            a[len(a) - 1][1] += 1\n            k //= i\n    i += 1\nif (k > 1):\n    a.append([k, 1])\nans = 10 ** 20\nfor i in a:\n    cnt = 0\n    x = i[0]\n    while (x <= n):\n        cnt += n // x;\n        x *= i[0]\n    ans = min(ans, cnt // i[1])\nprint(ans)
import math\nm,a,b=map(int,input().split())\ng=math.gcd(a,b)\na1=a//g\nb1=b//g\nalls=g*(a1+b1-1)\ndists=[0]+[-1]*(a1+b1-1)\ndist=0\nfar=0\nwhile dist!=b1:\n    if dist<b1:\n        dist+=a1\n        far=max(dist,far)\n    else:\n        dist-=b1\n    if dists[dist]==-1:\n        dists[dist]=far\ntot=0\nfor i in range(a1+b1):\n    if i*g<=m and dists[i]*g<=m:\n        tot+=(m+1-dists[i]*g)\nif alls<m:\n    mod=m%g\n    times=m//g\n    diff=times-a1-b1\n    tot1=g*(diff*(diff+1)//2)+(mod+1)*(diff+1)\n    tot+=tot1\nprint(tot)
def read_ints():\n	return [int(i) for i in input().split()]\n\nn = read_ints()\na = read_ints()\nif len(a) % 2 and a[0] % 2 and a[-1] % 2:\n	print('Yes')\nelse:\n	print('No')
x1, y1, x2, y2 = map(int, input().split())\n#diagonal\nif x1 != x2 and y1 != y2:\n    if abs(x1 - x2) == abs(y1 - y2):\n        print(x1, y2, x2, y1)\n    else:\n        print(-1)\n#same side\nelif x1 == x2:\n    aux = abs(y2 - y1)\n    print(x1 + aux, y1, x1 + aux, y2)\nelif y1 == y2:\n    aux = abs(x2 - x1)\n    print(x1, y1 + aux, x2, y1 + aux)
def main():\n    x, y = [int(i) for i in input().split()]\n    n = int(input())\n    \n    result = [x, y, y - x, -x, -y, x - y][(n - 1) % 6]\n    \n    print(result % 1000000007)\n\n\nmain()\n
from sys import stdin\n\nn = int(input())\na = [int(x) for x in input().split()]\n\nf = False\nfor i in range(len(a)):\n    if a[i] != 0:\n        ln = i\n        f = True\n        break\nif not f:\n    print('NO')\nelse:\n    print('YES')\n    l = 0\n    i = ln + 1\n    ans = []\n    while i < len(a):\n        if a[i] == 0:\n            i += 1\n        else:\n            ans.append((l+1, i))\n            l = i\n            i += 1\n    if l < len(a):\n        ans.append((l+1, i))\n    print(len(ans))\n    for i in ans:\n        print(i[0],i[1])\n\n
MOD = 1000000009\n\nn,m,k = [int(x) for x in input().split()]\n\nnum0 = n-m\nnum1fin = num0*(k-1)\nif num1fin >= m:\n    print(m)\nelse:\n    num1open = m-num1fin\n    sets = num1open//k\n    rem = num1open%k\n    print(((pow(2,sets,MOD)-1)*2*k+rem+num1fin)%MOD)\n
n1 = input()\nn = []\nfor i in n1:\n    n.append(int(i))\nk = len(n)\n\nfor i in range(k):\n    if (n[i] % 8) == 0:\n        print("YES")\n        print(n[i])\n        return\n\nif k > 1:\n    for i in range(k):\n        t = n[i] * 10\n        for j in range(i+1, k):\n            if (t+n[j]) % 8 == 0:\n                print("YES")\n                print(t+n[j])\n                return\nif k > 2:\n    for i in range(k):\n        t = n[i]*100\n        for j in range(i+1, k):\n            l = n[j]*10\n            for e in range(j+1, k):\n                #print(t, l, n[e])\n                if (t+l+n[e]) % 8 == 0:\n                    print("YES")\n                    print(t+l+n[e])\n                    return\nprint("NO")\n
def floo(num, k):\n	return (num - 1) // k + 1\n\ndef main():\n	n, m = map(int, input().split())\n	low = 1\n	high = 10**9\n\n	if (m == 0):\n		if (n == 1):\n			print(1)\n		else:\n			print(-1)\n		return\n\n	for i in range(m):\n		k, f = map(int, input().split())\n		low = max(low, (k + f - 1) // f)\n		if (f > 1):\n			high = min(high, (k - 1) // (f - 1))\n	if (floo(n, low) == floo(n, high)):\n		print(floo(n, low))\n	else:\n		print(-1)\n\n\n\nmain()
f = []\nfor i in range(2):\n    f.append(list(input()))\n\n\nanswer = 0\n\nn = len(f[0])\nfor i in range(n):\n    if f[0][i] == f[1][i] == '0' and i + 1 < n:\n        if f[0][i + 1] == '0':\n            answer += 1\n            f[0][i + 1] = 'X'\n        elif f[1][i + 1] == '0':\n            answer += 1\n            f[1][i + 1] = 'X'\n\n    elif (f[1][i] == '0' or f[0][i] == '0') and i + 1 < n and f[0][i + 1] == f[1][i + 1] == '0':\n        answer += 1\n        f[0][i + 1] = f[1][i + 1] = 'X'\n\n\nprint(answer)\n
def list_input():\n    return list(map(int,input().split()))\ndef map_input():\n    return map(int,input().split())\ndef map_string():\n    return input().split()\n    \nn = int(input())    \na = list(input())\nans = 0\nfor i in range(n):\n	for j in range(i,n):\n		b = a[i:j+1]\n		for k in b:\n			if k.lower() != k:\n				break\n		else:\n			b = set(b)\n			ans = max(ans,len(b))\nprint(ans)					
\nn=int(input())\narr= list(map(int,input().strip().split(' ')))\ns = 0\nfor i in range(n):\n   s+=abs(arr[i])\nprint(s)
def list_input():\n    return list(map(int,input().split()))\ndef map_input():\n    return map(int,input().split())\ndef map_string():\n    return input().split()\n    \na,b,f,k = map_input()\ntot = a*k\ns = 2*a-f\ncur = 0\ncnt = b\ngo = 0\nans = 0\nwhile cur < tot:\n	go = 1-go\n	if(go == 1):\n		if cnt < s and cnt < tot-cur:\n			if(cnt < f):\n				print(-1)\n				break\n			cnt = b\n			ans += 1\n			cnt -= (a-f)\n		else: cnt -= a	\n	else:\n		if cnt < a+f and cnt < tot-cur:\n			if(cnt < a-f):\n				print(-1)\n				break\n			cnt = b\n			ans += 1\n			cnt -= (f)\n		else:cnt -= a	\n	cur += a\n	# print(cur,cnt,ans)	\n	if(cnt < 0):\n		print(-1)\n		break\nelse:\n	print(ans)
a, b, c = map(int, input().split(' '))\nx = input()\nfor i in range(105):\n    for j in range(105):\n        if i*b+j*c == a:\n            print(i+j)\n            for k in range(i):\n                print(x[:b])\n                x = x[b:]\n            for l in range(j):\n                print(x[:c])\n                x = x[c:]\n            quit()\nprint(-1)
n, m, s, d = list(map(int, input().split()))\n\nbeg = [float('-inf')]\nend = [float('-inf')]\n\na = [int(i) for i in input().split()]\n\nfor x in sorted(a):\n	if (x - end[-1] > s + 1):\n		beg.append(x)\n		end.append(x)\n	else:\n		end[-1] = x\n\nlast = 0\nR = []\nJ = []\n\nfor i in range(1, len(beg)):\n	R.append(beg[i] - 1 - last)\n	last = (beg[i] - 1)\n	\n	J.append(end[i] + 1 - last)\n	last = (end[i] + 1)\n\nok = True\nfor x in J:\n	if (x > d):\n		ok = False\nfor x in R:\n	if (x < s):\n		ok = False\n\n\nif ok:\n	for i in range(len(R)):\n		print('RUN', R[i])\n		print('JUMP', J[i])\n	if (last < m):\n		print('RUN', m - last)\nelse:\n	print('IMPOSSIBLE')\n
s, x = list(map(int, input().split()))\nrem = int(s == x) * 2\np, t, cur = [], 0, 1\nfor i in range(64):\n    if x % 2:\n        t += 1\n        s -= cur\n    else:\n        p.append(cur * 2)\n    cur *= 2\n    x //= 2\nfor i in p[::-1]:\n    if s >= i: s -= i\nans = 0 if s else 2 ** t - rem\nprint(ans)\n
n, k = map(int, input().split())\nif n <= k + k + 1:\n    print(1)\n    print((n + 1) // 2)\nelse:\n    answer = -1\n    answer_n = 10**100\n    for i in range(min(k + 1, n)):\n        t = n - (k + i + 1)\n        if t % (k + k + 1) >= k + 1:\n            if 2 + t // (k + k + 1) < answer_n:\n                answer = i + 1\n                answer_n = 2 + t // (k + k + 1)\n        if t % (k + k + 1) == 0:\n            if 1 + t // (k + k + 1) < answer_n:\n                answer = i + 1\n                answer_n = 1 + t // (k + k + 1)            \n    print(answer_n)\n    while answer <= n:\n        print(answer, end = ' ')\n        answer += k + k + 1\n        
ar=[]\nfor i in range(1,10**5):\n    if(i*i>2*10**9):break\n    ar.append(i*i)\ns=input()\nans=len(s)\nfor x in ar:\n    s2=str(x)\n    i=0\n    for x in range(len(s)):\n        if i<len(s2) and s[x]==s2[i]:\n            i+=1\n    if(i==len(s2)):\n        ans=min(ans,len(s)-i)\nif(ans==len(s)):\n    print(-1)\nelse:\n    print(ans)
p=10**9+7\nimport math\ndef inv(k,p):\n    prod=1\n    while k>1:\n        prod*=(p//k+1)\n        k=(k*(p//k+1))%p\n    return prod%p\nn=int(input())\na=[]\nk=int(math.log2(n))\nx=n\nwhile x>0:\n    y=x//2\n    a.append(x-y)\n    x=y\nc=[sum(a[i:]) for i in range(k+1)]\nb=[n//(3*2**i)-n//(6*2**i) for i in range(k+1)]\nd=[n//2**i-n//(3*2**i) for i in range(k+1)]\nfacs=[1]*(n+1)\nfor i in range(2,n+1):\n    facs[i]=(i*facs[i-1])%p\nif n<3*(2**(k-1)):\n    start=k\nelse:\n    start=0\ntot=0\nfor j in range(start,k+1):\n    prod=1\n    for i in range(j,k):\n        prod*=b[i]\n    prod*=d[j]\n    for i in range(j):\n        prod*=a[i]\n    prod%=p\n    prod*=facs[n]\n    e=[a[i] for i in range(j)]+[d[j]]+[b[i] for i in range(j,k)]\n    f=[sum(e[:i+1]) for i in range(k+1)]\n    g=1\n    for guy in f:\n        g*=guy\n    prod*=inv(g,p)\n    prod%=p\n    tot+=prod\nprint(tot%p)
# You lost the game.\n\ns = str(input())\nn = len(s)\nd = -1\nr = 0\nV = "AEIOUY"\nfor i in range(n):\n    if V.count(s[i]):\n        r = max(r,i-d)\n        d = i\nprint(max(r, n-d))\n
l=list(map(int,input().split()))\nfor i in range(16):\n    cur1,cur2=0,0\n    for j in range(4):\n        if (i&(1<<j))==0:\n            cur1+=l[j]\n        else:\n            cur2+=l[j]\n    if cur1==cur2:\n        print("YES")\n        quit()\nprint("NO")
n = int(input())\na = list(map(int, input().split()))\na = a[::-1]\nd = 0\nfor i in range(len(a)):\n    d = max(0 + d, a[i] + (sum(a[:i]) - d))\nprint(sum(a)-d, d)\n
def Solve(x,B):\n    if((X,x,B) in Mem):\n        return Mem[(X,x,B)]\n    if(len(B)>X):\n        return False\n    if(x==len(L)):\n        return True\n    if(Form(L[x],B)):\n        A=list(B)\n        for e in range(len(B)):\n            r=A[e]\n            A[e]=L[x]\n            if(Solve(x+1,tuple(sorted(A)))):\n                Mem[(X,x,B)]=True\n                return True\n            A[e]=r\n        A+=[L[x]]\n        if(Solve(x+1,tuple(sorted(A)))):\n            Mem[(X,x,B)]=True\n            return True\n    Mem[(X,x,B)]=False\n    return False\n\ndef Form(x,B):\n    for i in range(len(B)):\n        for j in range(i,len(B)):\n            if(B[i]+B[j]==x):\n                return True\n    return False\n        \nn=int(input())\nL=list(map(int,input().split()))\ndone=False\nMem={}\nfor X in range(1,n+1):\n    if(Solve(1,(L[0],))):\n        print(X)\n        done=True\n        break\nif(not done):\n    print(-1)\n
n=int(input())\ns=list(map(int,input().split()))\nprint("Bob"if s.count(min(s))>n/2 else"Alice")\n
read = lambda: list(map(int, input().split()))\nn = int(input())\na = list(read())\ns = set()\nfor i in a:\n    s.add(i)\nf1 = len(s) < 3\nf2 = len(s) == 3 and max(s) + min(s) == 2 * sorted(s)[1]\nprint('YES' if f1 or f2 else 'NO')\n
n = int(input())\ns = input()\nj = 1\nresult = []\nfor i in range(n):\n    while (j < n-1) and (s[i:j] in s[j:]):\n        j += 1\n    result.append(j-i-1)\nprint(max(result))
n, a = list(map(int,input().split()))\nif a % 2 == 1:\n    print(a // 2 + 1)\nelse:\n    print((n-a) // 2 + 1)\n
s = input().split()\nn, m = int(s[0]), int(s[1])\ncl = list(map(int, input().split()))\ncom = list(map(int, input().split()))\nres = False\nfor i in range(n):\n  for j in range(i, n):\n    e = True\n    t = cl[i:j+1]\n    for k in range(1, m+1):\n      e = t.count(k)==com[k-1] and e\n    if e:\n      res = True\n      break\n    \nif res: print('YES')\nelse: print('NO')
x = 0\ny = 0\nfor _ in range(int(input())):\n    a, b = list(map(int, input().split()))\n    x += (a > b)\n    y += (b > a)\nif x > y:\n    print("Mishka")\nelif y > x:\n    print("Chris")\nelse:\n    print("Friendship is magic!^^")\n
r, c = list(map(int, input().split()))\n\nb = [list(input()) for i in range(r)]\nfor y in range(r):\n    for x in range(c):\n        if b[y][x] == '.':\n            b[y][x] = '0'\n\nok = True\nfor Y in range(r):\n    for X in range(c):\n        if not b[Y][X].isdigit():\n            continue\n        p = 0\n        for dy in range(-1, 2):\n            for dx in range(-1, 2):\n                y = Y + dy\n                x = X + dx\n                if 0 <= y < r and 0 <= x < c:\n                    p += b[y][x] == '*'\n        if p != int(b[Y][X]):\n            ok = False\n\nprint(["NO", "YES"][ok])\n
def can(n, k):\n    total = n\n    s = 0\n\n    while n > 0:\n        cur = min(n, k)\n        s += cur\n        n -= cur\n\n        n -= n // 10\n\n    return s * 2 >= total\n\nn = int(input())\n\nle = 0\nrg = n\n\nwhile rg - le > 1:\n    mid = (rg + le) // 2\n\n    if can(n, mid):\n        rg = mid\n    else:\n        le = mid\n\nprint(rg)\n
def main():\n    s = input()\n    links = s.count('-')\n    pearls = s.count('o')\n    if pearls == 0 or links % pearls == 0:\n        print('YES')\n    else:\n        print('NO')\n\nmain()\n
n, m, k = map(int, input().split())\nans = 1\nm -= n\nleft = k - 1\nright = n - k\n\nput = 1\nwhile (m >= put):\n    m -= put\n    ans += 1\n    put += (left > 0) + (right > 0)\n    if (left): left -= 1\n    if (right): right -= 1\n    if (left == right == 0):\n        ans += (m // put)\n        break\nprint(ans)
N, M, K = list(map(int, input().split()))\nA = [int(a) for a in input().split()]\nS = [0]\nfor a in A:\n    S.append(S[-1]+M*a-K)\nMI = [(10**50)] * M\nans = 0\nfor i in range(N+1):\n    MI[i%M] = min(MI[i%M], S[i])\n    for j in range(M):\n        ans = max(ans, (S[i]-MI[(i-j)%M] - K*((-j)%M))//M)\nprint(ans)\n\n
import math\nn, m = list(map(int, input().split()))\nif n == 0 : \n    print(0, 1)\n    print(0, m)\n    print(0, 0)\n    print(0, m - 1)\nelif m == 0 : \n    print(1, 0)\n    print(n, 0)\n    print(0, 0)\n    print(n - 1, 0)\nelse :\n    l = math.sqrt((n - 1) ** 2 + m ** 2) + math.sqrt(n ** 2 + m ** 2) + math.sqrt(n ** 2 + (m - 1) ** 2)\n    l1 = max(m, n) + math.sqrt(n * n + m * m) * 2\n    l2 = math.sqrt(n ** 2 + m ** 2) + math.sqrt((n - 1) ** 2 + m ** 2) * 2\n    l3 = math.sqrt(n ** 2 + m ** 2) + math.sqrt((m - 1) ** 2 + n ** 2) * 2\n    ans = max(l, l1, l2, l3)\n    if l == ans :\n        print(1, 0)\n        print(n, m)\n        print(0, 0)\n        print(n, m - 1)\n    elif l1 == ans :\n        if n > m :\n            print(n, m)\n            print(0, 0)\n            print(n, 0)\n            print(0, m)\n        else :\n            print(n, m)\n            print(0, 0)\n            print(0, m)\n            print(n, 0)\n    elif l2 == ans :\n        print(1, 0)\n        print(n, m)\n        print(0, 0)\n        print(n - 1, m)\n    else :\n        print(0, 1)\n        print(n, m)\n        print(0, 0)\n        print(n, m - 1)\n
import math\nfrom collections import Counter\n\ns = list(map(int, input()))\nsubstr = input().rstrip()\nt = list(map(int, substr))\n\nm = len(s)\nx, y = 0, m\nz = (x + y) // 2\nwhile z != x:\n    if z + math.floor(math.log10(z)) + 1 <= m:\n        x = z\n    else:\n        y = z\n    z = (x + y)//2\nm1 = z\nk = math.floor(math.log10(m1)) + 1\n\nD = Counter(s)\nD.subtract(list(map(int, str(m1))))\nD.subtract(t)\ntry:\n    c1 = min(i for i in range(1, 10) if D[i] > 0)\n    c2 = t[0]\n\n    D[c1] -= 1\n    _prefix = [c1]\n    \n    for c in range(c2):\n        _prefix += [c] * D[c]\n    _suffix = []\n    for c in range(c2 + 1, 10):\n        _suffix += [c] * D[c]\n    num = ''.join([str(c2)] * D[c2])\n    prefix = ''.join(map(str, _prefix))\n    suffix = ''.join(map(str, _suffix))\n\n    if c2 == 0:\n        print((min(prefix + substr + num + suffix,\n                  prefix + num + substr + suffix)))\n    else:\n        D[c1] += 1\n        st = []\n        for c in range(10):\n            st += [c] * D[c]\n        print((min(prefix + substr + num + suffix,\n                  prefix + num + substr + suffix,\n                  substr + ''.join(map(str, st)))))\nexcept ValueError:\n    print(substr + '0'*D[0])\n
def main():\n	n, m, mn, mx = map(int, input().split())\n	A = list(map(int, input().split()))\n	a = min(A)\n	b = max(A)\n	if a < mn or b > mx:\n		print("Incorrect")\n		return\n	cnt = 0\n	if a > mn:\n		cnt += 1\n	if b < mx:\n		cnt += 1\n	if m + cnt <= n:\n		print("Correct")\n	else:\n		print("Incorrect")\n\nmain()
m = int(input())\na = 0\nwhile m > 0:\n    a += 5\n    b = a\n    c = 0\n    while b % 5 == 0:\n        b //= 5\n        c += 1\n    m -= c\nif m < 0: print(0)\nelse:\n    print(5)\n    print(a, a + 1, a + 2, a + 3, a + 4)\n
def g():\n return list(map(int,input().split()))\nn,m,k=g()\np=list(range(n+1))\nz=[0]*(n+1)\nfor x in g():\n z[x]=1\ne=[]\nfor i in range(m):\n u,v,w=g()\n e+=[(w,u,v)]\ne=sorted(e)\ndef q(x):\n if x!=p[x]:\n  p[x]=q(p[x])\n return p[x]\nfor w,u,v in e:\n u=q(u);v=q(v)\n if u!=v:\n  if u%5==3:\n   u,v=v,u\n  p[u]=v;z[v]+=z[u]\n  if z[v]==k:\n   print(((str(w)+' ')*k));return\n
def main():\n	n = int(input())\n	k = int(input())\n	n %= 6\n	a = [0, 1, 2]\n	for i in range(1, n + 1):\n		if (i % 2 == 1):\n			a[0], a[1] = a[1], a[0]\n		else:\n			a[1], a[2] = a[2], a[1]\n	print(a[k])\n\n\nmain()
n = int(input())\ns = 0\nINF = 10**9\nminx = miny = INF\nmaxx = maxy = -INF\n\nfor i in range(n):\n    x1, y1, x2, y2 = list(map(int, input().split()))\n    s += abs(x1 - x2) * abs(y1 - y2)\n    minx = min(minx, x1, x2)\n    maxx = max(maxx, x1, x2)\n    miny = min(miny, y1, y2)\n    maxy = max(maxy, y1, y2)\n\nif (maxx - minx) == (maxy - miny) and s == (maxx - minx) ** 2:\n    print ("YES")\nelse:\n    print ("NO")\n
def check(x, s):\n    k = 0\n    for i in str(x):\n        k += int(i)\n    return x - k >= s\n\n\nn, s = map(int, input().split())\nl = 0\nr = n\nwhile r - l > 1:\n    m = (l + r) // 2\n    if check(m, s):\n        r = m\n    else:\n        l = m\nif check(r, s):\n    print(n - r + 1)\nelse:\n    print(0)
n = int(input())\nL = [(0, 0)] * n\nfor i in range(n):\n    t = input().split(' ')\n    a = int(t[0])\n    b = int(t[1])\n    L[i] = (a, b)\nif n <= 4:\n    print("YES")\nelse:\n    b0 = True\n    b1 = True\n    b2 = True\n    L0 = []\n    L1 = []\n    L2 = []\n    for j in range(n):\n        if (L[0][0]-L[1][0])*(L[0][1]-L[j][1])!=(L[0][1]-L[1][1])*(L[0][0]-L[j][0]):\n            L2.append(L[j])\n        if (L[2][0]-L[0][0])*(L[2][1]-L[j][1])!=(L[2][1]-L[0][1])*(L[2][0]-L[j][0]):\n            L1.append(L[j])\n        if (L[2][0]-L[1][0])*(L[2][1]-L[j][1])!=(L[2][1]-L[1][1])*(L[2][0]-L[j][0]):\n            L0.append(L[j])\n    if len(L0) >= 3:\n        for j in range(2, len(L0)):\n            if (L0[0][0]-L0[1][0])*(L0[0][1]-L0[j][1])!=(L0[0][1]-L0[1][1])*(L0[0][0]-L0[j][0]):\n                b0 = False\n    if len(L1) >= 3:\n        for j in range(2, len(L1)):\n            if (L1[0][0]-L1[1][0])*(L1[0][1]-L1[j][1])!=(L1[0][1]-L1[1][1])*(L1[0][0]-L1[j][0]):\n                b1 = False\n    if len(L2) >= 3:\n        for j in range(2, len(L2)):\n            if (L2[0][0]-L2[1][0])*(L2[0][1]-L2[j][1])!=(L2[0][1]-L2[1][1])*(L2[0][0]-L2[j][0]):\n                b2 = False\n    if b0 or b1 or b2:\n        print("YES")\n    else:\n        print("NO")\n
mod=10**9+7\nf=[0]*500000\n\ndef POW(a,b):\n	if(b==0):\n		return 1\n	if(b&1):\n		return POW(a,b//2)**2*a%mod\n	else:\n		return POW(a,b//2)**2\n\ndef C(n,m):\n	if(m>n):\n		return 0\n	t=f[n]*POW(f[m],mod-2)%mod*POW(f[n-m],mod-2)%mod\n	return t\n\n\nf[0]=1\nfor i in range(1,500000):\n	f[i]=f[i-1]*i%mod\na,b,k,t=list(map(int,input().split(' ')))\n\nans=0\nfor i in range(0,2*t+1):\n	t1=POW(-1,i)*C(2*t,i)%mod\n	t2=(C(210000+2*k*t-a+b+2*t-1-(2*k+1)*i+1,2*t)-C(1+2*k*t-a+b+2*t-1-(2*k+1)*i,2*t))%mod\n	ans=(ans+t1*t2)%mod\nprint(ans)\n
import itertools\nimport math\n\ndef can_measure(a, d):\n	return any(i + d in a for i in a)\n\ndef main():\n	n, l, x, y = list(map(int, input().split()))\n	a = set(map(int, input().split()))\n	\n	can_x = can_measure(a, x)\n	can_y = can_measure(a, y)\n	if can_x and can_y:\n		print(0)\n	elif can_x:\n		print(1)\n		print(y)\n	elif can_y:\n		print(1)\n		print(x)\n	else:\n		for i in a:\n			if i + x + y in a:\n				print(1)\n				print(i + x)\n				break\n			else:\n				t = i + x - y in a\n				if 0 <= i + x <= l and t:\n					print(1)\n					print(i + x)\n					break;\n				if 0 <= i - y <= l and t:\n					print(1)\n					print(i - y)\n					break;\n				\n		else:\n			print(2)\n			print(x, y)\n		\n\ndef __starting_point():\n	main()\n\n__starting_point()
import math\nfrom functools import reduce\nclass SegmentTree():\n    def __init__(self, L, function = lambda x,y: x+y):\n        self.function = function\n        N = self.size = len(L)\n        M = 1 << N.bit_length()\n        self.margin = 2*M - N\n        self.L = [None for i in range(self.margin)] + L\n        for i in range(M-1, 0, -1):\n            x, y = self.L[i<<1], self.L[i<<1|1]\n            self.L[i] = None if x is None or y is None else function(x, y)\n    def modify(self, pos, value):\n        p = pos + self.margin\n        self.L[p] = value \n        while p > 1:\n            x, y = self.L[p], self.L[p^1]\n            if p&1: x, y = y, x\n            self.L[p>>1] = None if x is None or y is None else self.function(x, y)\n            p>>=1\n    def query(self, left, right):\n        l, r = left + self.margin, right + self.margin\n        stack = []\n        void = True\n        while l < r:\n            if l&1:\n                if void:\n                    result = self.L[l]\n                    void = False\n                else:\n                    result = self.function(result, self.L[l])\n                l+=1\n            if r&1:\n                r-=1\n                stack.append(self.L[r])\n            l>>=1\n            r>>=1\n        init = stack.pop() if void else result\n        return reduce(self.function, reversed(stack), init)\n\nn = int(input())\npies, index, first_equal = [0]*n, [0]*n, [0]*n\nfor i in range(n):\n    r, h = [int(x) for x in input().split()]\n    pies[i] = r*r*h\ns_pies = list(sorted(enumerate(pies), key = lambda p: p[1]))\nfor i in range(n): index[s_pies[i][0]] = i\nfor i in range(1, n):\n    first_equal[s_pies[i][0]] = i if s_pies[i][1] != s_pies[i-1][1] else first_equal[s_pies[i-1][0]]\ntowers = SegmentTree([0]*(n+1), max)\nfor j, pie in enumerate(pies):\n    i, k = index[j], first_equal[j]\n    q = towers.query(0, k+1)\n    towers.modify(i+1, q + pie)\nprint(math.pi * towers.query(0, n+1))\n
def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\n\nn, k = mi()\nh = li()\nm = max(h)\nf = [0] * (m + 1)\nfor hi in h:\n    f[hi] += 1\nfor i in range(m - 1, 0, -1):\n    f[i] += f[i + 1]\n\nans = 0\ni = m\nwhile i > 0:\n    if f[i] == n:\n        break\n    j = i\n    cur = 0\n    while j > 0:\n        if cur + f[j] > k:\n            break\n        cur += f[j]\n        j -= 1\n    ans += 1\n    i = j\nprint(ans)\n
n = int(input())\nl = list(map(int,input().split()))\n\ncurr = 0\nbest = 0\nprevs = [0] * 31\nfor v in l:\n    curr += v\n    if v >= 0:\n        for i in range(0, v):\n            prevs[i] = curr\n        for i in range(v, 31):\n            best = max(curr - prevs[i] - i, best)\n    else:\n        for i in range(31):\n            prevs[i] = min(prevs[i], curr)\nprint(best)\n
a, b, c = sorted(map(int, input().split()))\nif a > 3:\n	print('NO')\nelif a == 3:\n	if b > 3:\n		print('NO')\n	elif b == 3:\n		if c > 3:\n			print('NO')\n		else:\n			print("YES")\nelif a == 1:\n	print('YES')\nelse:\n	if b == 2:\n		print('YES')\n	elif b > 4:\n		print('NO')\n	elif b == 4:\n		if c == 4:\n			print('YES')\n		else:\n			print('NO')\n	else:\n		print('NO')
#credits https://www.geeksforgeeks.org/minimum-steps-to-delete-a-ssing-after-repeated-deletion-of-palindrome-subssings/\n  \nn=int(input())\ns=input()\nN = len(s)\ndp = [[0 for x in range(N + 1)] \n         for y in range(N + 1)]\nD = [[[] for x in range(N + 1)] \n         for y in range(N + 1)]\nss=""\nre=""\nfor i in range(0,N):\n    if re!=s[i]:\n        ss+=re\n        re=s[i]\nss+=re\na=ss\nN=len(a)\nfor l in range(1, N + 1): \n    i = 0\n    j = l - 1\n    while j < N: \n        if (l == 1): \n            dp[i][j] = 1\n        else: \n\n            dp[i][j] =1+dp[i + 1][j]\n\n            for K in range(i + 1, j + 1): \n                if (a[i] == a[K]):\n                        if dp[i][j]>=dp[i ][K - 1] + dp[K + 1][j]:\n                            dp[i][j] = dp[i][K - 1] + dp[K + 1][j]\n\n                        \n                      \n        i += 1\n        j += 1\n\nprint(dp[0][N-1])\n\n
n=int(input())\na=sorted(map(int,input().split()))\nm=int(input())\nb=sorted(map(int,input().split()))\nc=0\nfor i in range(n):\n  for j in range(m):\n    if abs(a[i]-b[j]) <= 1:\n      b[j]=-10\n      c+=1\n      break\nprint(c)
a,b=list(map(int,input().split()))\nc,d=list(map(int,input().split()))\n\n\nx,y=list(map(int,input().split()))\nz,w=list(map(int,input().split()))\n\n\nTeam1=False\nTeam2=False\nif(a>w and a>y and d>x and d>z):\n    Team1=True\n\nif(c>w and c>y and b>x and b>z):\n    Team1=True\n\nif(((x>b and w>c) or (z>b and y>c)) and ((x>d and w>a) or (z>d and y>a))):\n    Team2=True\n\n\nif(Team1):\n    print("Team 1")\nelif(Team2):\n    print("Team 2")\nelse:\n    print("Draw")\n
import sys\nfrom itertools import combinations\nfrom math import sqrt\nimport numpy as np\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\n\ndef main():\n    N, K, *xyc = list(map(int, read().split()))\n    x = xyc[::3]\n    y = xyc[1::3]\n    xy = list(zip(x, y))\n    c = xyc[2::3]\n    left = 0\n    right = 10 ** 6\n    delta = 0.1 ** 7\n    while right - left > delta:\n        mid = (left + right) / 2\n        intersections = []\n        r = [(mid / i) ** 2 for i in c]\n        for i, j in combinations(list(range(N)), 2):\n            x1, y1 = xy[i]\n            x2, y2 = xy[j]\n            X = x2 - x1\n            Y = y2 - y1\n            XY = X ** 2 + Y ** 2\n            r1 = r[i]\n            r2 = r[j]\n\n            a = (XY + r1 - r2) / 2\n            b = XY * r1 - a ** 2\n            if b < delta:\n                continue\n            b = sqrt(b)\n            xi1 = (a * X + Y * b) / XY + x1\n            yi1 = (a * Y - X * b) / XY + y1\n            xi2 = (a * X - Y * b) / XY + x1\n            yi2 = (a * Y + X * b) / XY + y1\n            intersections.append((xi1, yi1))\n            intersections.append((xi2, yi2))\n\n        intersections.extend(xy)\n        intersections = np.array(intersections, np.float)\n        cnt = np.zeros(len(intersections), np.int64)\n\n        for (i, j), k in zip(xy, r):\n            XY = (intersections[:, 0] - i) ** 2 + (intersections[:, 1] - j) ** 2\n            cnt[XY < k + delta] += 1\n\n        if np.any(cnt >= K):\n            right = mid\n        else:\n            left = mid\n\n    print(right)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n=int(input())\ns=input()\nleft=0\nright=0\nleft_ques=0\nright_ques=0\nfor i in range(n):\n    if i<n//2:\n        if s[i]=='?':\n            left_ques+=1\n        else :\n            left+=int(s[i])\n    else :\n        if s[i]=='?':\n            right_ques+=1\n        else :\n            right+=int(s[i])\nx=min(left_ques,right_ques)\nleft_ques-=x\nright_ques-=x\nif left_ques==0 and right_ques==0:\n    if left==right:\n        print("Bicarp")\n    else :\n        print("Monocarp")\nelse :\n    if left_ques==0:\n        if right_ques%2==0:\n            x=9*(right_ques//2)+right\n            if x==left:\n                print("Bicarp")\n            else :\n                print("Monocarp")\n        else :\n            print("Monocarp")\n    else :\n        if left_ques%2==0:\n            x=9*(left_ques//2)+left\n            if x==right:\n                print("Bicarp")\n            else :\n                print("Monocarp")\n        else :\n            print("Monocarp")
# AC\nimport sys\n\n\nclass Main:\n    def __init__(self):\n        self.buff = None\n        self.index = 0\n\n    def __next__(self):\n        if self.buff is None or self.index == len(self.buff):\n            self.buff = sys.stdin.readline().split()\n            self.index = 0\n        val = self.buff[self.index]\n        self.index += 1\n        return val\n\n    def next_int(self):\n        return int(next(self))\n\n    def cal(self, s):\n        if len(s) == 1:\n            return s[0]\n        if s[0] == 0:\n            return self.cal(s[1:])\n        v = 1\n        for c in s:\n            v *= c\n        return v\n\n    def solve(self):\n        n = self.next_int()\n        t = self.next_int()\n        ii = 0\n        tt = 10000000\n        for i in range(0, n):\n            fr = self.next_int()\n            d = self.next_int()\n            if fr < t:\n                fr += (t - fr + d - 1) // d * d\n            if fr < tt:\n                tt = fr\n                ii = i\n        print(ii + 1)\n\n\ndef __starting_point():\n    Main().solve()\n\n__starting_point()
def nck(n, k, cache = {}):\n    if k > n or k < 0: return 0\n    if k == 0 or k == n: return 1\n    if k*2 > n: k = n-k\n    if (n, k) in cache: return cache[(n, k)]\n\n    z = cache[(n, k)] = nck(n-1, k-1) + nck(n-1, k)\n    return z\n\ndef bits(n):\n    b = 0\n    while n:\n        if n&1: b += 1\n        n >>= 1\n    return b\n\ndef count(n, k):\n    z, b, c = 0, 63, 0\n    for b in reversed(range(64)):\n        if (n>>b)&1:\n            z += nck(b, k-c)\n            c += 1\n        if not k: break\n    return z + (bits(n) == k)\n\ndef solve(m, k):\n    lo, hi = 1, 10**18\n    while lo < hi:\n        mi = (lo+hi)//2\n        if count(2*mi, k) - count(mi, k) < m:\n            lo = mi+1\n        else:\n            hi = mi\n    return hi\n\nm, k = [int(x) for x in input().split()]\nprint(solve(m, k))
kk=0\nx = int(input())\ny = input()\nz = [i for i in range(len(y)) if y[i] == '*']\nfor i in range(0, 100):\n    for j in range(1, 100):\n        if i in z and i+j in z and i+2*j in z and i+3*j in z and i+4*j in z:\n            kk=1\nif kk==1:\n    print("yes")\nelse:\n    print("no")\n
#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\ndef func():\n    N = int(input())\n    cells = [0] * N\n\n    if N == 1:\n        return 1\n\n    mx = 0\n    for n in range(N):\n        cells[n] = list(map(int,input().split()))\n        mx = max(mx, sum(cells[n]))\n\n    ans = None\n    for j in range(N):\n        for i in range(N):\n            if cells[j][i] == 0:\n                ans = mx - sum(cells[j])\n                cells[j][i] = ans\n                if ans <= 0:\n                    return -1\n\n    # validation\n    for j in range(N):\n        if sum(cells[j]) != mx:\n            return -1\n    for i in range(N):\n        if mx != sum([cells[j][i] for j in range(N)]):\n            return -1\n    if mx != sum([cells[j][j] for j in range(N)]):\n        return -1\n    if mx != sum([cells[j][N-1-j] for j in range(N)]):\n        return -1\n    \n    return ans\n\nprint(func())\n\n
n = int(input())\nm = int(input())\na = []\nfor i in range(n):\n    a.append(int(input()))\n\nmx = max(a) + m\n\n\n\nwhile m:\n    for i in range(n):\n        if a[i] == min(a):\n            a[i] += 1\n            m -= 1\n            break\n\nprint(max(a), mx)\n
MOD = 10 ** 9 + 7\nn, m = input().split(' ')\nn = int(n)\nm = int(m)\nans = pow(2 * (n + 1), m, MOD)\nans = (ans * (n + 1 - m)) % MOD\nans = (ans * pow(n + 1, MOD - 2, MOD)) % MOD\nprint(ans)\n
#  author: ThePonyCoder\n#  created: 23.06.2019, 21:58\n#  filename: f.py\n#  path: C:/Users/User/Desktop/python/Prog/CodeForces/rounds/cf_568/f.py\n\nimport os\n\n# import random\n\n# sys.setrecursionlimit(999999999)\nimport string\n\nfrom math import inf\nfrom functools import lru_cache\n\nif os.getcwd() == 'C:\\Users\\User\\Desktop\\python\\Prog\\CodeForces' \\n        or os.environ['COMPUTERNAME'] == 'USER145':\n    import pdb\n    \n    import sys\n    \n    pdb = pdb.Pdb(stdin=sys.stdin, stdout=sys.stdout)\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n    from pprint import pprint\n    from hypothesis import given, settings\n    from hypothesis import strategies as st\n\n\ndef ri():\n    return [int(i) for i in input().split()]\n\n\ndef to_bits(l):\n    ans = 0\n    for i in l:\n        ans |= (1 << i - 1)\n    return ans\n\n\nuser_masks = [0 for i in range(1 << 10)]\npizzas = [[] for i in range(1 << 10)]\n\n\n@lru_cache()\ndef count_sat_users(mask):\n    ans = 0\n    cmask = mask\n    while cmask:\n        ans += user_masks[cmask]\n        cmask = (cmask - 1) & mask\n    return ans\n\n\ndef main():\n    n, m = ri()\n    for _ in range(n):\n        k, *a = ri()\n        bits = to_bits(a)\n        user_masks[bits] += 1\n    \n    ans = (float(-inf), float(inf), -1, -1)\n    \n    for i in range(m):\n        c, k, *a = ri()\n        bits = to_bits(a)\n        pizzas[bits].append((c, i + 1, bits))  # цена, номер, маска\n        pizzas[bits].sort()\n        while len(pizzas[bits]) > 2:\n            pizzas[bits].pop()\n    # pprint(pizzas)\n    \n    for mask_F in range(1 << 9):\n        for mask_S in range(1 << 9):\n            if len(pizzas[mask_F]) and len(pizzas[mask_S]) \\n                    and mask_F != mask_S:\n                \n                mask = mask_F | mask_S\n                \n                satisfied_users = count_sat_users(mask)\n                \n                f_pizza = next(iter(pizzas[mask_F]))\n                s_pizza = next(iter(pizzas[mask_S]))\n                \n                summary_cost = 0\n                summary_cost += f_pizza[0]\n                summary_cost += s_pizza[0]\n                \n                ans = max(ans,\n                          (satisfied_users,\n                           -summary_cost,\n                           s_pizza[1],\n                           f_pizza[1]))\n                \n                # bruting all masks\n                bmask = mask\n                while bmask:\n                    satisfied_users += user_masks[bmask]\n                    bmask = (bmask - 1) & mask\n            \n            if len(pizzas[mask_F]) == 2:\n                satisfied_users = count_sat_users(mask_F)\n                \n                it = iter(pizzas[mask_F])\n                \n                f_pizza = next(it)\n                s_pizza = next(it)\n                summary_cost = 0\n                summary_cost += f_pizza[0] + s_pizza[0]\n                ans = max(ans,\n                          (satisfied_users,\n                           -summary_cost,\n                           s_pizza[1],\n                           f_pizza[1]))\n            \n            if len(pizzas[mask_S]) == 2:\n                satisfied_users = count_sat_users(mask_S)\n                \n                it = iter(pizzas[mask_S])\n                \n                f_pizza = next(it)\n                s_pizza = next(it)\n                summary_cost = 0\n                summary_cost += f_pizza[0] + s_pizza[0]\n                ans = max(ans,\n                          (satisfied_users,\n                           -summary_cost,\n                           s_pizza[1],\n                           f_pizza[1]))\n    \n    aans = [ans[2],ans[3]]\n    aans.sort()\n    print(*aans, sep=' ')\n\n\nmain()\n
M,S=list(map(int,input().split()))\n\nif S==0 and M==1:\n  print('0 0')\n  return\nelif S==0 or M*9 < S:\n  print('-1 -1')\n  return\n\nm,s=M,S\nl=[]\nif s<=(m-1)*9+1:\n  l.append(1)\n  s-=1\nwhile len(l)<m:\n  r = (m-len(l)-1)*9\n  if s<=r:\n    l.append(0)\n  else:\n    l.append(s-r)\n    s-=s-r\n\nm,s=M,S\nh=[]\nwhile s>=9:\n  h.append(9)\n  s-=9\nwhile len(h)<m:\n  h.append(s)\n  s=0\n\nprint(''.join(repr(x) for x in l), ''.join(repr(x) for x in h))\n\n
\n\n\nl, r, k =list(map(int,input().split()))\n\nd = {i:2**i for i in range(10)}\n\ncache = {}\n\ndef can(i, m):\n    return d[i] & m\n\ndef calc(m):\n    b = 1\n    c = 0\n    for i in range(10):\n        if b & m:\n            c += 1\n        b *= 2\n\n    return c\n\ndef sm(ln, k, m, s='', first=False):\n    if ln < 1:\n        return 0, 1\n\n    if (ln, k, m, s, first) in cache:\n        return cache[(ln, k, m, s, first)]\n\n    ans = 0\n    count = 0\n    base = 10 ** (ln-1)\n\n    use_new = calc(m) < k\n\n    if s:\n        finish = int(s[0])+1\n    else:\n        finish = 10\n\n    for i in range(finish):\n        if use_new or can(i, m):\n            ss = s[1:]\n            if i != finish-1:\n                ss = ''\n            nm = m | d[i]\n            nfirst = False\n            if i == 0 and first:\n                nm = m\n                nfirst = True\n            nexta, nextc = sm(ln-1, k, nm, ss, nfirst)\n            ans += base * i * nextc + nexta\n            count += nextc\n\n#    print(ln, k, m, s, first, ans, count)\n    cache[(ln, k, m, s, first)] = (ans, count)\n\n    return ans, count\n\ndef call(a, k):\n    s = str(a)\n    return sm(len(s), k, 0, s, True)[0]\n\n\n#print(call(r, k) - call(l-1, k))\nprint((call(r, k) - call(l-1, k)) % 998244353)\n
#!/usr/bin/env python3\n\nfrom bisect import bisect\n\n[n, k, d] = list(map(int, input().strip().split()))\nais = list(map(int, input().strip().split()))\nif k == 1:\n	print ('YES')\n	return\n\nais.sort()\n\n# can do ais[i:]\ncando = [False for _ in range(n)]\nj = n - 1  # j is such that a[j] > a[i] + d >= a[j - 1]  (upper_bound) a[:j] <= a[i] + d < a[j:]\ncount = 0  # sum(cando[i + k:j + 1])\nfor i in reversed(list(range(n))):\n	if i + k < n and cando[i + k]:\n		count += 1\n	if n - i < k:\n		continue\n	if ais[-1] - ais[i] <= d:\n		cando[i] = True\n		continue\n	while ais[j - 1] > ais[i] + d:\n		if cando[j]:\n			count -= 1\n		j -= 1\n	cando[i] = (count > 0)\n	\n\nif cando[0]:\n	print ('YES')\nelse:\n	print ('NO')\n\n
s = input()\nn = len(s)\nt = 'RBYG'\nfor i in t:\n	ind = s.find(i) % 4\n	ans = 0\n	while ind < n:\n		ans += s[ind] == '!'\n		ind += 4\n	print(ans, end=' ')\n
n, m = list(map(int, input().split()))\nedges_from = [[] for _ in range(n)]\nedges_to = [[] for _ in range(n)]\n\nfor _ in range(m):\n    _from, to = [int(x)-1 for x in input().split()]\n    edges_from[_from].append(to)\n\nE_dist_to_goal = [0] * n\nP_of_reaching = [0] * n\nP_of_reaching[0] = 1\n\nfor v in range(n-2, -1, -1):\n    routes = edges_from[v]\n    for next_v in routes:\n        E_dist_to_goal[v] += E_dist_to_goal[next_v] + 1\n    E_dist_to_goal[v] /= len(routes)\n\nfor v in range(n-1):\n    P_now = P_of_reaching[v]\n    routes = edges_from[v]\n    P_next = P_now / len(routes)\n    for next_v in routes:\n        P_of_reaching[next_v] += P_next\n\ninitial_ans = E_dist_to_goal[0]\nanswers = [initial_ans]\nfor v in range(n-2):\n    routes = edges_from[v]\n    num_of_routes = len(routes)\n    if num_of_routes == 1:\n        continue\n    not_cut_dist = E_dist_to_goal[v]\n    longest_dist = max([E_dist_to_goal[next_v]+1 for next_v in routes])\n    after_cut_dist = (not_cut_dist - longest_dist/num_of_routes) * num_of_routes / (num_of_routes-1)\n    delta = not_cut_dist - after_cut_dist\n    candidate = initial_ans - delta * P_of_reaching[v]\n    answers.append(candidate)\n\nprint((min(answers)))\n
import math\n\nn = int(input())\nprint(10 * round(n / 10))
a = input()\nb = input()\n\nsymbols = {}\npairs = []\n\nfor i in range(len(a)):\n    if a[i] in symbols:\n        if symbols[a[i]] != b[i]:\n            print('-1')\n            break\n    elif b[i] in symbols:\n        if symbols[b[i]] != a[i]:\n            print('-1')\n            break\n    else:\n        symbols[a[i]] = b[i]\n        symbols[b[i]] = a[i]\n        if a[i] != b[i]:\n            pairs.append((a[i], b[i]))\nelse:\n    print(len(pairs))\n    for elem in pairs:\n        print(elem[0], elem[1])
from collections import *\nimport itertools\nimport sys\n\ndef main():\n    a, b = input().split()\n    ans = a + b\n    n = len(a)\n    m = len(b)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            c = a[:i] + b[:j]\n            # print(c)\n            ans = min(ans, c)\n    print(ans)\n\nmain()\n
n = int(input())\nx = input()\nd = [0] * n\ncd = 0\nxp = []\nfor i in range(n):\n	if x[i] == '[':\n		d[i] = cd\n		cd = cd + 1\n	else:\n		cd = cd - 1\n		d[i] = cd\nfor i in range(n-1):\n	xp.append((x[i], d[i]))\n	if x[i] == '[' and x[i+1] == ']':\n		xp.extend([(' ', d[i]), (' ', d[i]), (' ', d[i])])\nxp.append((x[n-1], d[n-1]))\nmd = max(d)\nh = md * 2 + 3\nres = []\nfor i in range(h):\n	l = [' ' for j in xp]\n	res.append(l)\nfor i in range(len(xp)):\n	for j in range(h):\n		if xp[i][0] == '[' and j > xp[i][1] and j < h - xp[i][1] - 1:\n			res[j][i] = '|'\n		elif xp[i][0] == ']' and j > xp[i][1] and j < h - xp[i][1] - 1:\n			res[j][i] = '|'\n		elif xp[i][0] == '[' and (j == xp[i][1] or j == h - xp[i][1] - 1):\n			res[j][i] = '+'\n			res[j][i+1] = '-'\n		elif xp[i][0] == ']' and (j == xp[i][1] or j == h - xp[i][1] - 1):\n			res[j][i] = '+'\n			res[j][i-1] = '-'\n\nfor i in range(h):\n	print(''.join(res[i]))\n\n
u = v = 0\na, b = input(), input()\nn, m = len(a), len(b)\nif n > m: b = '0' * (n - m) + b\nelse: a = '0' * (m - n) + a\nfor i in range(max(n, m)):\n    u, v = v + u, u + int(a[i]) - int(b[i])\n    if u > 1:\n        print('>')\n        return\n    elif u < -1:\n        print('<')\n        return\nd = 2 * v + u\nif u == v == 0: print('=')\nelif u >= 0 and d >= 0: print('>')\nelif u <= 0 and d <= 0: print('<')\nelse: print('>' if (u * u > v * (v + u)) ^ (u < 0) else '<')
n = int(input())\na = [input() for i in range(n)]\nsol = []\nfor i in range(6):\n    c = ['purple', 'green', 'blue', 'orange', 'red', 'yellow'][i]\n    if c not in a:\n        sol.append(['Power', 'Time', 'Space', 'Soul', 'Reality', 'Mind'][i])\nprint(len(sol))\nfor i in sol:\n    print(i)\n
import sys\nn, a, b = list(map(int, input().split()))\n\ncnt = 0\nl = [set([x]) for x in range(1, n+1)]\n\nwhile 1:\n    l = list([tup[0] | tup[1] for tup in zip(l[::2], l[1::2])])\n    cnt += 1\n    for el in l:\n        if a in el and b in el:\n            print(cnt if len(el) < n else 'Final!')\n            return\n
import sys\n\nn = int(input())\np = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\n\nans = 0\nnum_cycles = 0\nchecked = set()\n\nfor i in range(n):\n    if i in checked:\n        continue\n\n    checked.add(i)\n\n    nxt = p[i] - 1\n\n    while nxt != i:\n        checked.add(nxt)\n        nxt = p[nxt] - 1\n\n    num_cycles += 1\n\nans += num_cycles if num_cycles != 1 else 0\nans += (sum(b) % 2) == 0\n\nprint(ans)
v1, v2 = list(map(int, input().split()))\nt, d = list(map(int, input().split()))\nvm = [0] * t\n\nv = v1\nfor i in range(t):\n    vm[i] = v\n    v += d\n\nv = v2\nfor i in range(t - 1, -1, -1):\n    vm[i] = min(v, vm[i])\n    v += d\n\nprint(sum(vm))\n
import sys\ninput = sys.stdin.readline\nfrom itertools import permutations, accumulate\nimport heapq\nimport bisect\nfrom operator import itemgetter\n\ndef dijkstra(start, edge):\n    n = len(edge)\n    dist = [0]*n\n    que = [(0, start)]\n    while que:\n        d, v = heapq.heappop(que)\n        if dist[v] < d:\n            continue\n        for nv, nd in edge[v]:\n            if dist[nv] > d + nd:\n                dist[nv] = d + nd\n                heapq.heappush(que, (dist[nv], nv))\n    return dist\n\nn, m = map(int, input().split())\nW = tuple(map(int, input().split()))\nLV = sorted((tuple(map(int, input().split())) for _ in range(m)), key=itemgetter(1))\nL, V = zip(*LV)\nP = [0]\nw_max = max(W)\nfor l, v in LV:\n  if w_max > v:\n    print(-1)\n    return\n  if P[-1] > l:\n    P.append(P[-1])\n  else:\n    P.append(l)\ndef f(K):\n  S = list(accumulate((W[k] for k in K)))\n  edge = [[] for _ in range(n)]\n  for i in range(n-1):\n    edge[i+1].append((i, 0))\n  for i in range(n-1):\n    for j in range(i+1, n):\n      if i == 0:\n        t = S[j]\n      else:\n        t = S[j] - S[i-1]\n      p = P[bisect.bisect_left(V, t)]\n      edge[j].append((i, -p))\n  return -dijkstra(n-1, edge)[0]\n\nans = float("inf")\nfor K in permutations(range(n)):\n  ans = min(ans, f(K))\nprint(ans)
a, b = map(int, input().split())\n\nif b - a > 10:\n	print(0)\nelse:\n	s = 1\n	for i in range(a + 1, b + 1):\n		s *= i\n	print(str(s)[-1])
'''input\n4 2\n1001\n'''\n\ndef list_input():\n    return list(map(int,input().split()))\ndef map_input():\n    return map(int,input().split())\ndef map_string():\n    return input().split()\n    \nn,d = map_input()\ns = input()\ncur = 0\ncnt = 0\nwhile cur < n-1:\n	j = -1\n	for i in range(cur+1,min(cur+d+1,n)):\n		if s[i] == '1': j = i\n	if j == -1:\n		print(-1)\n		break\n	cur = j\n	cnt += 1\nelse: print(cnt)			
def prime(x):\n    if x < 2:\n        return False\n    if x == 2:\n        return True\n    if x % 2 == 0:\n        return False\n\n    for d in range(3, x, 2):\n        if d * d > x:\n            break\n        if x % d == 0:\n            return False\n\n    return True\n\ndef main():\n    n = int(input())\n    for m in range(1, 1001):\n        if not prime(n * m + 1):\n            ans = m\n            break\n\n    print(ans)\n\nmain()\n
3\n# Copyright (C) 2016 Sayutin Dmitry.\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; version 3\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; If not, see <http://www.gnu.org/licenses/>.\n\ndef main():\n    n = int(input())\n    ans = False\n    for a in range(0, 1001):\n        for b in range(0, 1001):\n            left = n - 1234567 * a - 123456 * b\n            if left >= 0 and left % 1234 == 0:\n                ans = True\n    print("YES" if ans else "NO")\n\nmain()\n
k = []\n\nx = int(input())\nc, d = list(map(int, input().split(' ')))\nfor i in range(x):\n    a, b = list(map(int, input().split(' ')))\n    k.append([c*a+b, d*a+b])\n\nk.sort()\nfor i in range(len(k)-1):\n    if k[i+1][1] < k[i][1]:\n        print("YES")\n        quit()\nprint("NO")\n
n = int(input())\n\nprint(1 + n // 2)\n
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\n\n\ndef main():\n    n,k = LI()\n    if k == 0 or n==k:\n        return '0 0'\n\n    return "1 {}".format(min(n-k, k*2))\n\nprint(main())\n\n\n\n
n = int(input())\nx = 0\ncur = 1\nlst = 1\nwhile cur + lst <= n:\n    cur, lst = cur + lst, cur\n    x += 1\nprint(x)\n
s = input()\nd = dict()\nd['V'] = 'K'\nd['K'] = 'V'\nm = s.count('VK')\ns = list(s)\nfor i in range(len(s)):\n    s[i] = d[s[i]]\n    m = max(m,''.join(s).count('VK'))\n    s[i] = d[s[i]]\nprint(m)
n = int(input())\n\na = b = 1\n\nwhile a * b < n:\n    if a < b:\n        a += 1\n    else:\n        b += 1\n\nprint(a+b)\n
def l2i(s):\n	return [int(i) for i in s.split()]\na, b=l2i(input())\nt=0\nwhile (a<=b):\n	a*=3\n	b*=2\n	t+=1\nprint(t)
h, n = list(map(int, input().split()))\nc, m = 0, 2 ** h\nr = 0\nwhile m > 1:\n    if c == 0:\n        if n > m // 2:\n            r += m - 1\n            n -= m // 2\n            c = 1 - c\n    else:\n        if n > m // 2:\n            n -= m // 2\n        else:\n            r += m - 1\n            c = 1 - c\n    c = 1 - c\n    r += 1\n    m //= 2\n    #print(c, m, r, n)\nprint(r)\n
x = int(input())\n\ndef solve(x):\n    count = 0\n    lst = []\n    x6 = x * 6\n    for n in range(1, x + 1):\n        t, r = divmod(x6, n*(n+1))\n        if t < 2*n + 1:\n            break\n        if r:\n            continue\n        m, r = divmod(t + n - 1, 3)\n        if r:\n            continue\n        count += 2\n        lst.append((n, m))\n    nn, mm = lst[-1]\n    if nn == mm:\n        count -= 1\n    print(count)\n    for n, m in lst:\n        print(n, m)\n    if nn != mm:\n        print(mm, nn)\n    lst.reverse()\n    for n, m in lst[1:]:\n        print(m, n)\n\nsolve(x)\n
n = int(input())\ns = input().split()\na = [0] * n\nm = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\nfor i in range(n):\n  a[i] = int(s[i])\nans = "No"\nfor i in range(len(m) - n):\n  if a == m[i:i+n]:\n    ans = "Yes"\n    break\nprint(ans)
from math import sqrt\n\ndef phi(u):\n	ans = u\n	for i in range(2, int(sqrt(n)) + 1):\n		if u % i == 0:\n			while u % i == 0:\n				u = u / i\n			ans = ans - int(ans / i)\n	if n > 1:\n		ans = ans - int(ans / n)\n	return ans\n\ndef binpow(u, a, mod):\n	ans = 1\n	if a == 0:\n		return 1;\n	while a > 0:\n		if a % 2 == 0:\n			u = (u ** 2) % mod\n			a = int(a / 2)\n		else :\n			ans = (ans * u) % mod\n			a = a - 1\n	return int(ans)\n\nn = int(input())\n\nb1 = 1\nb2 = 0\nnn = n\nfor i in range(2, int(sqrt(n)) + 1):\n	if n%i == 0 :\n		while nn % i == 0:\n			b1 = b1 * i\n			nn = nn / i\n		b2 = int(n / b1)\n		break\n\nif b2 < 2:\n	print("NO")\n	return\na1 = b1 - binpow(b2, phi(b1) - 1, b1)\na2 = b2 - int((a1*b2+1)/b1)\nprint("YES")\nprint(2)\nprint(a1, b1)\nprint(a2, b2)\n
r = open('input.txt')\nw = open('output.txt', mode='w')\n\nf = lambda: map(int, r.readline().split())\n\nf()\na, b = f()\nif a > b: a, b = b, a\nn = 40001\nu, v = [n] * n, [n] * n\nx = s = 0\nu[0] = v[0] = 0\n\nfor y in f():\n    s += y\n    p = []\n    h = min(x, y)\n    for d in range(min(s, a), max(0, s - b - y) - 1, -1):\n        t = v[d]\n\n        if u[d] != n:\n            u[d + y] = min(u[d], u[d + y])\n            v[d] = min(t, u[d] + h)\n            u[d] = n\n\n        if t != n:\n            u[d + y] = min(u[d + y], t + h)\n    x = y\n\ni = max(s - b, 0)\nj = min(s, a) + 1\n\nd = min(u[i:j] + v[i:j]) if i < j else n\nw.write(str(d if d < n else -1))\n\nw.close()\nr.close()
def gcd(a, b):\n    a, b = max(a, b), min(a, b)\n    while b:\n        a, b = b, a % b\n    return a\n\n\nn, m, k = list(map(int, input().split()))\n_n, _m = n, m\nn, k = n // gcd(n, k), k // gcd(n, k)\nm, k = m // gcd(m, k), k // gcd(m, k)\na = 2\na, k = a // gcd(a, k), k // gcd(a, k)\nif k != 1:\n    print("NO")\nelif a * n <= _n:\n    print("YES")\n    print("0 0")\n    print(a * n, 0)\n    print(0, m)\nelif a * m <= _m:\n    print("YES")\n    print("0 0")\n    print(n, 0)\n    print(0, m * a)\nelse:\n    print("NO")\n
n,k=list(map(int,input().split()))\nn=(n//k)%2\nprint('YES' if n==1 else 'NO')\n
n=int(input())\n\ns=input().split()\n\nA=[0,0,0]\nfor i in range(n):\n    A[i%3]+=int(s[i])\n\nm=max(A)\n\nif(m==A[0]):\n    print("chest")\nelif(m==A[1]):\n    print("biceps")\nelse:\n    print("back")\n
def read_input():\n	return map(int, input().split())\n\nn = int(input())\na = sorted(read_input())\n\ns = sum(a)\ni = 0\n\nwhile 2 * s < 9 * n:\n	delta = 5 - a[i]\n	s += delta\n	i += 1\n\nprint(i)
u, v = list(map(int, input().split()))\nif v < u or (v - u) % 2 != 0:\n    print(-1)\nelse:\n    if u == v:\n        if u == 0:\n            print(0)\n        else:\n            print("1\n" + str(u))\n    else:\n        w = (v - u) // 2\n        if (w | u) == (w + u):\n            print("2\n" + str(w|u) + ' ' + str(w))\n        else:\n            print("3\n" + str(u) + ' ' + str(w) + ' ' + str(w))\n\n
"""\nCodeforces Testing Round 10 Problem C\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0:\n        return inputs\n    if mode == 1:\n        return inputs.split()\n    if mode == 2:\n        return [int(x) for x in inputs.split()]\n\ndef write(s="\n"):\n    if isinstance(s, list): s = " ".join(s)\n    s = str(s)\n    print(s, end="")\n\n################################################### SOLUTION\ndef g(n):\n    return (10**n-1)//9\n\ndef solve(n):\n    if n <= 6: return n\n    if 7 <= n <= 11: return 13-n\n    l = 1\n    while g(l) < n: l += 1\n    l -= 1\n    gl = g(l)\n    a = n\n    res1 = 0\n    res1 += (a // gl) * l\n    a %= gl\n    res1 += solve(a)\n    b = g(l+1) - n\n    res2 = l+1\n    res2 += (b // gl) * l\n    b %= gl\n    res2 += solve(b)\n    return min(res1, res2)\n\nn, = read()\nprint(solve(n))
x1, y1, x2, y2 = list(map(int, input().split()))\nx, y = list(map(int, input().split()))\n\nx, y = abs(x), abs(y)\n\nx_ = abs(x2 - x1)\ny_ = abs(y2 - y1)\n\nif x_ % x == 0 and y_ % y == 0:\n    if (x_ // x + y_ // y) % 2 == 0:\n        print("YES")\n    else:\n        print("NO")\nelse:\n    print("NO")\n
n=input()\nrg=[0]*10\nfor i in n: rg[int(i)]+=1\nrl=[]\nff=0\nfor i in range(len(rg)):\n    if rg[i]!=0:\n        rl.append(rg[i])\n        if i==0: ff=1\nfact=[1]\nfc=1\nfor i in range(1,20):\n    fc*=i\n    fact.append(fc)\nrt=[]\nt=0\ndef cfs(d):\n    if d==len(rl):\n        nonlocal t,ff\n        jj=fact[sum(rt)]\n        for i in rt: jj=jj/fact[i]\n        if ff:\n            jjj=fact[sum(rt)-1]\n            jjj=jjj/fact[rt[0]-1]\n            for i in range(1,len(rt)): jjj=jjj/fact[rt[i]]\n            jj-=jjj\n        t+=jj\n        return\n    \n    for i in range(1,rl[d]+1):\n        rt.append(i)\n        cfs(d+1)\n        rt.pop(-1)\n\ncfs(0)\nprint(int(t))\n\n\n        \n            \n    \n\n'''\n////////////////      //////        ///////      //             ///////     //  //   //\n////          //    ///   ///     ///    ///     //            ///  ///     ////     //\n////    ////       ///     ///   ///      ///    //           /////////     ////     ///////\n////     /////    ///       /// ///        ///   //          ///    ///     ////     //   //\n//////////////     ///////////   ///////////     //////     ///     ///     //  //   //   //\n'''\n\n
a=int(input())\nb=int(input())\nc=int(input())\nd=int(input())\ne=int(input())\nf=int(input())\nif e>=f:\n    ans=min(a,d)\n    d-=ans\n    a-=ans\n    ans*=e\n    ans+=min(d,b,c)*f\nelse:\n    ans=min(d,b,c)\n    d-=ans\n    ans*=f\n    ans+=min(a,d)*e\nprint(ans)
a, b, p, x = [int(x) for x in input().split()]\n\npowers = [a]\n\nwhile powers[-1] != 1:\n    powers.append(powers[-1] * a % p)\n    \norder = len(powers)\npowers = [powers[-1]] + powers\n\ninverse = pow(order, p-2, p)\n\ndef f(sol):\n    return (x // (p * order)) + (1 if sol <= x % (p * order) else 0)\n\ndef chinese(a, n, b, m):\n    k = inverse * (b - a + m) % m\n    x = k * n + a\n    return x % (n * m)\n\nres = 0\nfor i in range(len(powers)-1):\n    inv = powers[order - i]\n    val = inv * b % p\n    \n    sol = chinese(i, order, val, p)\n    \n    res += f(sol)\n    \nprint(res)\n
k2, k3, k5, k6 = list(map(int, input().split()))\nc = min(k2, k5, k6)\nk2 -= c\nans = 256 * c\nans += 32 * min(k3, k2)\nprint(ans)\n
x, y, n, c = 0, 0, 0, 0\ndef suma_impares(m):\n	return m * m\ndef suma_n(m):\n	return m * (m - 1) // 2\ndef cnt(t):\n	u, d, l, r = x + t, x - t, y - t, y + t\n	suma = t ** 2 + (t + 1) ** 2\n	if u > n: suma -= suma_impares(u - n)\n	if d < 1: suma -= suma_impares(1 - d)\n	if l < 1: suma -= suma_impares(1 - l)\n	if r > n: suma -= suma_impares(r - n)\n	if 1 - l > x - 1 and 1 - d > y - 1:\n		suma += suma_n(2 - l - x)\n	if r - n > x - 1 and 1 - d > n - y:\n		suma += suma_n(r - n - x + 1)\n	if 1 - l > n - x and u - n > y - 1:\n		suma += suma_n(1 - l - n + x)\n	if u - n > n - y and r - n > n - x:\n		suma += suma_n(u - n - n + y)\n	return suma\n	\nn, x, y, c = input().split()\nn, x, y, c = int(n), int(x), int(y), int(c)\n#for i in range(10):\n#	print(i, cnt(i))\nini, fin = 0, int(1e9)\ncont = int(1e9)\nwhile cont > 0:\n	m = ini\n	paso = cont // 2\n	m += paso\n	if cnt(m) < c:\n		ini = m + 1\n		cont -= paso + 1\n	else:\n		cont = paso\nprint(ini)
import sys\nl,r=map(int,(sys.stdin.readline().split()))\ni=64\nwhile i>=0:\n    if ((1<<i)&l!=0 and (1<<i)&r!=0) or ((1<<i)&l==0 and (1<<i)&r==0):i-=1\n    else:break\nprint((1<<(i+1))-1)
N, K = list(map(int, input().split()))\n\nprint((K+N-1)//N)\n
x, y, z, t1, t2, t3 = map(int, input().split())\nladder = abs(x - y) * t1\nelevator = abs(x - z) * t2 + 3 * t3 + abs(x - y) * t2\nif elevator > ladder:\n	print("NO")\nelse:\n	print("YES")
n, m = list(map(int, input().split()))\nif n == 1:\n    print(1)\nelif m - 1 >= n - m:\n    print(m - 1)\nelse:\n    print(m + 1)\n
n = int(input())\na = list(map(int, input().split()))\nc = 0\nl = 0\nb = 0\nwhile c < len(a) and a[c] == 0:\n    c += 1\n    b += 1\n\nif c == len(a):\n    print(0)\n    return\n\nd = len(a) - 1\nwhile a[d] != 1:\n    d -= 1\n    b += 1\n\nwhile c <= d:\n    if a[c] == 0:\n        l += 1\n    else:\n        if l > 1:\n            b += l\n        l = 0\n    c += 1\n\nprint(n - b)
#!/bin/python\n\nn, k = list(map(int, input().split()))\np = list(map(int, input().split()))\n\na, b = 0, 0\nfor i in range(n):\n    a += p[i]\n    x = min(8, a)\n    b += x\n    a -= x\n    if b >= k:\n        print(i+1)\n        break\nelse:\n    print(-1)\n
n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nans = 0\nfor i in range(1, n):\n    diff = k - (a[i] + a[i - 1])\n    if diff > 0:\n        a[i] += diff\n        ans += diff\n\nprint(ans)\nprint(' '.join(map(str, a)))\n\n
n = int(input())\na = n * (n + 1) // 2\nprint(4 * a - 4 * n + 1)
n = int(input())\ns = input()\na = [False for i in range(26)]\nfor x in s:\n    a[ord(x.lower()) - ord('a')] = True\nfor x in a:\n    if not x:\n        print('NO')\n        return\nprint('YES')\n
def main():\n    a, b = map(int, input().split(":"))\n    c = int(input())\n\n    a += c // 60\n    b += c % 60\n    if b > 59:\n        b %= 60\n        a += 1\n\n    aa = str(a % 24)\n    if len(aa) < 2:\n        aa = "0" + aa\n\n    bb = str(b % 60)\n    if len(bb) < 2:\n        bb = "0" + bb\n\n    print(aa + ":" + bb)\n\ndef __starting_point():\n    main()\n__starting_point()
n, m = list(map(int, input().split()))\na = [list(map(int, input())) for i in range(n)]\n\nignorable = [True] * n\n\nfor i in range(m):\n    cnt = 0\n    for j in range(n):\n        cnt += a[j][i]\n    if cnt == 1:\n        for j in range(n):\n            if a[j][i]:\n                ignorable[j] = False\n\nif any(ignorable):\n    print('YES')\nelse:\n    print('NO')\n
N = int(input())\nCheck = False\nSum = 0\nSum_l, Sum_r = 0, 0\nfor i in range(N):\n    x, y = list(map(int, input().split()))\n    Sum_l += x\n    Sum_r += y\n    Sum += x + y\n    if (x % 2 + y % 2) % 2:\n        Check = True\nif Sum % 2:\n    print(-1)\nelif Sum_l % 2:\n    if not Check:\n        print(-1)\n    else:\n        print(1)\nelif Sum_l % 2 == 0:\n    print(0)\n
def isPrime(n) : \n    # Corner cases \n    if (n <= 1) : \n        return False\n    if (n <= 3) : \n        return True\n  \n    # This is checked so that we can skip  \n    # middle five numbers in below loop \n    if (n % 2 == 0 or n % 3 == 0) : \n        return False\n  \n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n  \n    return True\nt=int(input())\nfor yes in range(t):\n	a,b=map(int,input().split())\n	xx=a-b\n	yy=a+b \n	if xx==1 and isPrime(yy)==True:\n		print("YES")\n	else:\n		print("NO")
n = int(input())\nlcnt = 0\nrcnt = 0\nfor i in range(n):\n    x, y = map(int, input().split())\n    if x < 0:\n        lcnt += 1\n    else:\n        rcnt += 1\n\nif (lcnt <= 1 or rcnt <= 1):\n    print("Yes")\nelse:\n    print("No")
a, b = map(int, input().split())\na = min(a, b)\nans = 1\nfor i in range(1, a + 1):\n    ans *= i\nprint(ans)
n = int(input())\nprint (9 * n, 8 * n)
def reachable(es, source):\n	ret = {source}\n	Q = [source]\n	while Q:\n		cur = Q.pop()\n		for nxt in es[cur]:\n			if nxt not in ret:\n				Q.append(nxt)\n				ret.add(nxt)\n	return ret\n\ndef BellmanFord(V:int, es:list, source=0):\n	INF = float("inf")\n	D = [INF]*V\n	D[source] = 0\n	for _ in range(V):\n		upd = False\n		for f, t, c in es:\n			tmp = D[f] + c\n			if D[t] > tmp:\n				D[t] = tmp\n				upd = True\n		if not upd:\n			return D[-1]\n	else:\n		return None\n	\ndef main():\n	N,M,P,*L=map(int,open(0).read().split())\n	fwd = [[] for _ in range(N)]\n	bwd = [[] for _ in range(N)]\n	tmp = []\n	for a,b,c in zip(*[iter(L)]*3):\n		fwd[a-1].append(b-1)\n		bwd[b-1].append(a-1)\n		tmp+=[(a-1,b-1,P-c)]\n	judge = reachable(fwd,0) & reachable(bwd,N-1)\n	ans = BellmanFord(N,[(a,b,c) for a,b,c in tmp if a in judge and b in judge])\n	if ans==None:\n		print(-1)\n	else:\n		print(max(0,-ans))\n\ndef __starting_point():\n	main()\n__starting_point()
it = lambda: list(map(int, input().strip().split()))\nINF = float('inf')\n\n\ndef solve():\n    N = int(input())\n    S = []\n    R = []\n    C = []\n    for _ in range(N):\n        s, c = input().strip().split()\n        S.append(s)\n        R.append(s[::-1])\n        C.append(int(c))\n    \n    vis = set()\n    mem = dict()\n\n    def dp(s, p):\n        if (s, p) in mem: return mem[s, p]\n        if s == s[::-1]: return 0\n        if (s, p) in vis: return INF\n\n        ans = INF\n        vis.add((s, p))\n        for i, t in enumerate(S if p else R):\n            if len(t) >= len(s) and t.startswith(s):\n                ans = min(ans, dp(t[len(s):], p ^ 1) + C[i])\n            elif len(s) > len(t) and s.startswith(t):\n                ans = min(ans, dp(s[len(t):], p) + C[i])\n        vis.discard((s, p))\n        mem[s, p] = ans\n        return ans\n        \n    ans = INF\n    for i in range(N):\n        ans = min(ans, dp(S[i], 0) + C[i])\n    return -1 if ans == INF else ans\n\n\ndef __starting_point():\n    ans = solve()\n    print(ans)\n__starting_point()
R=lambda:list(map(int,input().split()))\nn,k=R()\nif k==1:print(n)\nelse:\n    i=0\n    while (1<<i)<=n:i+=1\n    print((1<<i)-1)\n
n = int(input())\nres = -float('inf')\nfor _ in range(n):\n    a,b = list(map(int,input().split()))\n    res = max(res,a+b)\nprint(res)\n
t = {i: 0 for i in 'qwertyuiopasdfghjklzxcvbnm'}\nfor i in input(): t[i] += 1\nprint(min([t['i'], t['t'], t['e'] // 3, max(0, (t['n'] - 1)) // 2]))
import sys, math\n\n#f = open('input_0', 'r')\nf = sys.stdin\n\nP, Y = list(map(int, f.readline().split()))\n\nis_ok = False\nfor t in range(Y, P, -1):\n  is_ok = True\n  for x in range(2, P+1):\n    if t%x == 0:\n      is_ok = False\n      break\n    if x*x > t:\n      break\n  if is_ok:\n    print(t)\n    break\nif not is_ok:\n  print(-1)\n
n, m, k = list(map(int, input().split()))\nm -= 1\nline = list(map(int, input().split()))\nanswer = n\nfor i in range(n):\n    if line[i] == 0:\n        continue\n    if line[i] > k:\n        continue\n    answer = min(answer, abs(m - i))\nprint(answer * 10)
from collections import Counter\n\n\ndef input_matrix():\n    res = tuple((Counter() for _ in range(n + m)))\n    for i in range(n):\n        for j, a in enumerate(map(int, input().split())):\n            res[i + j][a] += 1\n    return res\n\n\nn, m = list(map(int, input().split()))\nif input_matrix() == input_matrix():\n    print("YES")\nelse:\n    print("NO")\n
import sys\na = input()\nb = input()\nif a != b:\n    print(max(len(a), len(b)))\nelse:\n    print(-1)\n
a, b = map(int,input().split())\nc, d = map(int,input().split())\nONE = set()\nTWO = set()\nfor i in range(b, 50000, a):\n    ONE.add(i)\nfor i in range(d, 50000, c):\n    TWO.add(i)\n\nopt = 99999\nfor i in ONE:\n    if i in TWO:\n        opt = min(opt, i)\nif opt == 99999:\n    print(-1)\nelse:\n    print(opt)
n = int(input())\nif n%3 == 0: print(1, 1, n-2)\nelif n%3 == 1: print(1, 1, n-2)\nelse: print(1, 2, n-3)
n, a, b, c, d= [int(i) for i in input().split()]\no = 0\nfor i in range(1, n+1):\n	if i+b-c>0 and i+b-c<=n:\n		if i+a-d>0 and i+a-d<=n:\n			if i+a+b-c-d>0 and i+a+b-c-d<=n:\n				o+=1\nprint(o*n)\n
w, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\nfor i in range(h, -1, -1):\n    w += i\n    if i == d1:\n        w = max(w - u1, 0)\n    elif i == d2:\n        w = max(w - u2, 0)\n\nprint(w)
m = int(input())\nc = list(map(int,input().split()))\nx, y = list(map(int,input().split()))\n\nfor i in range(m):\n	sb = sum(c[:-i-1])\n	si = sum(c[-i-1:])\n	if x <= sb <= y:\n		if x <= si <= y:\n			print(m-i)\n			break\nelse:\n	print(0)\n
import sys\n\ndef read_int():\n    return int(input())\n\ndef read_ints():\n    return [int(x) for x in input().split()]\n\nn = read_int()\nk = read_int()\na = read_int()\nb = read_int()\n\ncost = 0\n\nif k == 1:\n    cost = (n - 1) * a\nelse:\n    while n != 1:\n        if n % k == 0:\n            if b < (n - n // k) * a:\n                cost += b\n            else:\n                cost += (n - n // k) * a\n            n = n // k\n        else:\n            cost += (n % k) * a\n            n -= n % k\n            if n == 0:\n                n += 1\n                cost -= a\n\nprint(cost)\n
def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\nMX = 10 ** 5\n\nn = ii()\nfac = 2\npr = []\nwhile fac * fac <= n:\n    c = 0\n    while n % fac == 0:\n        c += 1\n        n //= fac\n    if c:\n        pr.append((fac, c))\n    fac += 1\nif n > 1:\n    pr.append((n, 1))\nif pr:\n    mx = max(e for p, e in pr)\n    mn = min(e for p, e in pr)\n    mx2 = 1\n    cnt = 0\n    while mx2 < mx:\n        mx2 *= 2\n        cnt += 1\n    ans = cnt + int(mn != mx2)\n    pdt = 1\n    for p, e in pr:\n        pdt *= p\nelse:\n    pdt, ans = 1, 0\nprint(pdt, ans)\n
###Prediction and Restriction\nn,k=list(map(int,input().split()))\nr,s,p=list(map(int,input().split()))\nt=input()\nwin=[False]*n\ndef janken(char):\n    if char=='r':\n        return p\n    elif char=='s':\n        return r\n    else:\n        return s\ncnt=0\nfor i in range(n):\n    if i-k<0:\n        point=janken(t[i])\n        cnt+=point\n        win[i]=True\n    else:\n        if t[i]!=t[i-k]:\n            point=janken(t[i])\n            cnt+=point\n            win[i]=True\n        else:\n            if not win[i-k]:\n                point=janken(t[i])\n                cnt+=point\n                win[i]=True\n\nprint(cnt)\n
a, b, c = list(map(int, input().split()))\nx = 2 * (c + min(a, b))\nif a != b:\n    x += 1\nprint(x)\n
def read_data():\n    n, k, p, x, y = map(int, input().split())\n    As = list(map(int, input().split()))\n    return n, k, p, x, y, As\n\ndef solve(n, k, p, x, y, As):\n    '''median (As + Bs) >= y\n    sum(As + Bs) <= x\n    1 <= Bi <= p\n    '''\n    middle = n // 2\n    As.sort(reverse=True)\n    sumA = sum(As)\n    minSum = sumA + 1 * (n - k)\n    if minSum > x:\n        return ['-1']\n    num_a_over_y = len([1 for a in As if a >= y])\n    if num_a_over_y > middle:\n        return ['1'] * (n - k)\n    min_num_y = middle + 1 - num_a_over_y\n    if min_num_y > n - k:\n        return ['-1']\n    minSum2 = sumA + min_num_y * y + (n - k - min_num_y) * 1\n    if minSum2 > x:\n        return ['-1']\n    return [str(y)] * min_num_y + ['1'] * (n - k - min_num_y)\n\ndef __starting_point():\n    n, k, p, x, y, As = read_data()\n    seq = solve(n, k, p, x, y, As)\n    print(' '.join(seq))\n__starting_point()
s = input()\nok = 1\nn = len(s)\n\ndef is_vowel(c):\n	return c in "aouie"\n\nfor i, x in enumerate(s):\n	if not is_vowel(x) and x != 'n':\n		ok &= ((i + 1 < n) and is_vowel(s[i + 1]))\n\nprint("YES" if ok else "NO")
n, m = map(int, input().split())\n\nd = [0 for i in range(7)]\ng = [[] for i in range(7)]\n\nfor i in range(m):\n	x, y = map(int, input().split())\n	x -= 1\n	y -= 1\n	d[x] += 1\n	d[y] += 1\n	\n	g[x].append(y)\n	g[y].append(x)\n	\nmn = min(d)\nfor i in range(7):\n	for j in range(i):\n		cnt = 0\n		for k in range(7):\n			if((k in g[i]) and (k in g[j])):\n				cnt += 1\n		mn = min(mn, cnt)\nm -= mn\nprint(m) 
n, m =  list(map(int, input().split()))\nprices =  list(map(int, input().split()))\nauci = list(map(int, input().split()))\n\nscores = 0\n\n# m auc\n# n - m default\n\nfor i in range(len(prices)):\n    if (i+1) not in auci:\n        scores += prices[i]\n        prices[i] = 0\n\nra = []\nfor i in prices:\n    if i != 0:\n        ra.append(i)\nra.sort()\nra = ra[::-1]\n\nfor i in ra:\n    if i > scores:\n        scores += i\n    else:\n        scores *= 2\n\nprint(scores)\n#print(ra)\n
m = list(map(int, input().split()))\nw = list(map(int, input().split()))\na = [500, 1000, 1500, 2000, 2500]\nv = list(map(int, input().split()))\nans = 0\nfor i in range(len(m)):\n    ans += max(0.3 * a[i], (1 - m[i] / 250) * a[i] - 50 * w[i])\nans += v[0] * 100\nans -= v[1] * 50\nprint(int(ans))\n
n,m,L,R = list(map(int,input().split()))\np = 998244353*2\npp = p//2\n#liczba pokryc n x m ze jest parzyscie wiele zer albo parzyscie wiele jedynek\ndef pow(a,w):\n	wyn = 1\n	mn = a\n	while w > 0:\n		if w%2 == 1:\n			wyn = (wyn * mn)%p\n		mn = (mn*mn)%p\n		w //= 2\n	return wyn\ndupsko = pow((R-L+1), m*n)\nif L == R:\n	print(1)  \nelse:\n	if (m*n)%2 == 1:\n		print(dupsko%pp)\n	else:\n		print((dupsko - dupsko//2)%pp)\n
def main():\n    from sys import stdin, stdout\n\n    def read():\n        return stdin.readline().rstrip('\n')\n\n    def read_array(sep=None, maxsplit=-1):\n        return read().split(sep, maxsplit)\n\n    def read_int():\n        return int(read())\n\n    def read_int_array(sep=None, maxsplit=-1):\n        return [int(a) for a in read_array(sep, maxsplit)]\n\n    def write(*args, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\n')\n        stdout.write(sep.join(str(a) for a in args) + end)\n\n    def write_array(array, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\n')\n        stdout.write(sep.join(str(a) for a in array) + end)\n\n    n, m = read_int_array()\n    minm, maxm = [], []\n    for _ in range(n):\n        minm.append(read_int_array())\n    for _ in range(n):\n        maxm.append(read_int_array())\n\n    for r in range(n):\n        for c in range(m):\n            minx = min(minm[r][c], maxm[r][c])\n            maxx = max(minm[r][c], maxm[r][c])\n            if r:\n                if minx <= minm[r-1][c] or maxx <= maxm[r-1][c]:\n                    write("Impossible")\n                    return\n            if c:\n                if minx <= minm[r][c-1] or maxx <= maxm[r][c-1]:\n                    write("Impossible")\n                    return\n            minm[r][c] = minx\n            maxm[r][c] = maxx\n    write("Possible")\n\nmain()\n
n = int(input())\narr = list(map(int, input().split()))\narr.sort()\narr = arr[::-1]\nans = [arr[0]]\nfor i in range(1, n):\n	if(arr[i] < ans[-1]):\n		ans.append(arr[i])\n	else:\n		ans.append(max(0, ans[-1] - 1))\nprint(sum(ans))
R=lambda:list(map(int,input().split()))\nn,k=R()\na=sorted(R())\nb=0\nfor i in a:\n  while i>k+k:\n    k+=k\n    b+=1\n  k=max(k,i)\nprint(b)\n
n = int(input())\nmin1, max1 = map(int, input().split())\nmin2, max2 = map(int, input().split())\nmin3, max3 = map(int, input().split())\n\nd1 = min(n - min2 - min3, max1)\nd2 = min(n - d1 - min3, max2)\nd3 = n - d1 - d2\n\nprint(d1,d2,d3)
# You lost the game.\n\nn = int(input())\nL = list(map(int, input().split()))\n\nif n == 1:\n    if L[0] == 0:\n        print("UP")\n    elif L[0] == 15:\n        print("DOWN")\n    else:\n        print("-1")\nelse:\n    d = L[n-2] - L[n-1]\n    if d < 0:\n        if L[n-1] == 15:\n            print("DOWN")\n        else:\n            print("UP")\n    else:\n        if L[n-1] == 0:\n            print("UP")\n        else:\n            print("DOWN")\n
v = list('aeiou')\ns = [c in v for c in input()]\nt = [c in v for c in input()]\nif s == t:\n    print('Yes')\nelse:\n    print('No')
grid = [list(input()) for i in range(8)]\nb = 9\nw = 9\ntblock = False\nbblock = False\nfor r in range(8):\n    for c in range(8):\n        for ri in range(r):\n            if grid[ri][c] == 'B':\n                tblock = True\n        for ri in range(r+1, 8):\n            if grid[ri][c] == 'W':\n                bblock = True\n        if grid[r][c] == 'B' and not bblock:\n            b = min([abs(7-r), b])\n        elif grid[r][c] == 'W' and not tblock:\n            w = min([w, r])\n        tblock = False\n        bblock = False\nif b < w:\n    print('B')\nelse:\n    print('A')\n        \n
n = int(input())\na = list(map(int, input().split()))\n\nm = int(input())\nb = list(map(int, input().split()))\n\nptra = 1\nptrb = 1\nsa = a[0] \nsb = b[0]\nans = 0\n\nwhile ptra != n and ptrb != m:\n    if sa == sb:\n        ans += 1\n        sa = a[ptra]\n        sb = b[ptrb]\n        ptra += 1\n        ptrb += 1\n        continue\n    if sa < sb:\n        sa += a[ptra]\n        ptra += 1\n    else:\n        sb += b[ptrb]\n        ptrb += 1\nwhile ptra != n:\n    sa += a[ptra]\n    ptra += 1\nwhile ptrb != m:\n    sb += b[ptrb]\n    ptrb += 1\nif sa != sb:\n    print(-1)\n    return\nprint(ans + 1)\n\n
s = input()\nif (s.count('Danil') + s.count('Olya') + s.count('Slava') + s.count('Ann') + s.count('Nikita') == 1):\n    print('YES')\nelse:\n    print('NO')\n
def f(n):\n    m = int(n ** 0.5) + 1\n    t = [1] * (n + 1)\n    for i in range(3, m):\n        if t[i]: t[i * i :: 2 * i] = [0] * ((n - i * i) // (2 * i) + 1)\n    return [2] + [i for i in range(3, n + 1, 2) if t[i]]\n\na, b, k = map(int, input().split())\nn = 2000001\n\nt, p, x = [-1] * n, f(n), -1\nk -= 1; b += 1\n\nfor i in range(len(p) - k):\n    t[p[i]] = p[i + k] - p[i]\n\nt.reverse()\nfor i in range(1, n):\n    if t[i] < 0: t[i] = t[i - 1] + 1\nt.reverse()\n\nfor i in range(a + 1, b):\n    t[i] = max(t[i], t[i - 1])\n\nfor l in range(1, b - a + 1):\n    if t[b - l] < l:\n        x = l\n        break\nprint(x)
a,h,w=(int(x) for x in input().split())\nif h==w:\n    if a<h:\n        n=w//a\n        x=(w-a*n)/(n+1)\n        print(x)\n    elif a==h:\n        print(0)\n    else:\n        print(-1)\nelse:\n    for i in range(100):\n        if h>w:\n            w,h=h,w\n        if w>h+a*2:\n            w=w-h-a\n    if h>w:\n        w,h=h,w \n    m=h//a\n    s=(w-h)//a\n    r=0\n    if m<s or s==0:\n        for i in range(m,0,-1):\n            x=(h-a*i)/(i+1)\n            w1=w-x\n            a1=a+x\n            q=w1%a1\n            if q<0.00000001 or a1-q<0.0000001:\n                r=1\n                break\n        if r==0:\n            print(-1)\n        else:\n            print(x)\n    else:\n        for i in range(s,0,-1):\n            x=(w-h-i*a)/i\n            w1=w-x\n            a1=a+x\n            q=w1%a1\n            if q<0.00000001:\n                r=1\n                break\n        if r==0:\n            print(-1)\n        else:\n            print(x)
ii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\n\nn = ii()\na = [li() for _ in range(n)]\nk = ii()\nans = 0\nfor l, r in a:\n    ans += k <= r\nprint(ans)
import sys\n\nfin = sys.stdin\nfout = sys.stdout\n\n#fin = open("input.txt", 'r')\n#fout = open("output.txt", 'w')\n\ns = fin.readline().strip()\nn = len(s)\nfor L in range(n):\n    for R in range(L + 1, n + 1):\n        s1 = s[:L]\n        s2 = s[L:R]\n        s3 = s[R:]\n        if (s1 + s3 == "CODEFORCES"):\n            print("YES")\n            return\nprint("NO")\n
n = int(input())\nans = 0\nfor i in range(1, n - 1):\n    ans += (i + 1) * (i + 2)\nprint(ans)
hola = 0\na = int(input())\nd = len(str(a))\nk = 10**(d-1)\nfor i in range(1, d):\n    hola += i * (10**(i-1)*9)\n\nhola += d * (a-k+1)\nprint(hola)
from sys import stdin, stdout\n\nn, k = map(int, stdin.readline().split())\nvalues = list(map(int, stdin.readline().split()))\n\nsze = max(values)\nused = [0 for i in range(sze + 1)]\nchallengers = [[] for i in range(n + 1)]\n\ni = 0\ncnt = 0\n    \nfor i in range(n):\n    if values[i] == k:\n        cnt += 1\n    elif used[values[i]] >= cnt:\n        used[values[i]] += 1\n        challengers[used[values[i]]].append(values[i])\n    \nfor i in range(n, cnt - 1, -1):\n    if len(challengers[i]):\n        stdout.write(str(challengers[i][0]))\n        break\nelse:\n    stdout.write('-1')
R=lambda:list(map(int,input().split()))\nn,x=R()\nprint('YES'if sum(R())+n-1==x else'NO')\n
n, m =list(map(int, input().split()))\nif m % n != 0:\n	print( m // n + 1)\nelse:\n	print(m // n)\n
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\npossible=[0]*26\n\nfor i in input().strip():\n    possible[ord(i)-97]+=1\n\n# make changes\ntemp=[]\nfor i in range(26):\n    if possible[i]%2: temp.append(i)\nwhile len(temp)>1:\n    possible[temp[0]]+=1\n    possible[temp[-1]]-=1\n    temp.pop(0)\n    temp.pop(-1)\n\n# print stuff\nfor i in range(26):\n    print(chr(97+i)*(possible[i]//2),end="")\nif temp: print(chr(97+temp[0]),end="")\nfor i in range(26)[::-1]:\n    print(chr(97+i)*(possible[i]//2),end="")
a = 0\nb = 0\nx = {'Q': 9, 'q':9, 'R':5, 'r':5, 'B':3, 'b':3, 'N':3, 'n':3, 'P': 1, 'p': 1}\nfor i in range(8):\n    t = [i for i in input()]\n    for i in t:\n        if ord(i) >= 97 and i in x:\n            a += x[i]\n        elif i in x:\n            b += x[i]\nif a == b:\n    print("Draw")\nelif a < b:\n    print("White")\nelse:\n    print("Black")
from bisect import bisect_left\n\n\nN, M = list(map(int, input().split()))\nS = input()\ngood = []\nbad = []\nfor i in range(N + 1):\n    if S[i] == "1":\n        bad.append(i)\n    else:\n        good.append(i)\n\nans = []\ncur = N\nwhile True:\n    if cur == 0:\n        print((" ".join(map(str, ans[::-1]))))\n        break\n    idx = bisect_left(good, cur - M)\n    nx = good[idx]\n    ans.append(cur - nx)\n    if cur == nx:\n        print((-1))\n        break\n    cur = nx\n
k = int(input())\nx, y = list(map(int, input().split()))\nans = []\nif k % 2 == 0:\n    if (x + y) % 2 == 1:\n        print((-1))\n        return\nx_reverse = False\ny_reverse = False\nif x < 0:\n    x *= -1\n    x_reverse = True\nif y < 0:\n    y *= -1\n    y_reverse = True\n\n\ndef app(a, b):\n    nonlocal ans\n    if x_reverse:\n        a *= -1\n    if y_reverse:\n        b *= -1\n\n    ans.append((a, b))\n\n\nnowx = 0\nnowy = 0\n\nwhile abs(x - nowx) + abs(y - nowy) >= 2 * k:\n    if abs(x - nowx) > k:\n        nowx += k\n    else:\n        nowy += k\n    app(nowx, nowy)\n\n\ndef ok():\n    app(x, y)\n    print((len(ans)))\n    for a, b in ans:\n        print((a, b))\n    return\n\n\nrest = abs(x - nowx) + abs(y - nowy)\nif rest == k:\n    ok()\n\nif rest % 2 == 0:\n    delta = 2 * k - rest\n    assert delta % 2 == 0\n    if abs(x - nowx) < abs(y - nowy):\n        temp = abs(x - nowx) + delta // 2\n        nowx += temp\n        nowy += k - temp\n    else:\n        temp = abs(y - nowy) + delta // 2\n        nowy += temp\n        nowx += k - temp\n    app(nowx, nowy)\n    ok()\n\n# 残りが奇数のときは、条件から一旦ゴールをすぎる方向に移動すれば、\n# 残りの距離の偶奇が変わる。\n\nif abs(x - nowx) < abs(y - nowy):\n    nowx += k\n    app(nowx, nowy)\nelse:\n    nowy += k\n    app(nowx, nowy)\n\nx_delta = x - nowx\nx_pm = x_delta // abs(x_delta)\ny_delta = y - nowy\ny_pm = y_delta // abs(y_delta)\nif abs(x_delta) < abs(y_delta):\n    delta = 2 * k - (abs(x_delta) + abs(y_delta))\n    temp = abs(x - nowx) + delta // 2\n    nowx += x_pm * temp\n    nowy += y_pm * (k - temp)\n    app(nowx, nowy)\n    ok()\nelse:\n    delta = 2 * k - (abs(x_delta) + abs(y_delta))\n    temp = abs(y - nowy) + delta // 2\n    nowy += y_pm * temp\n    nowx += x_pm * (k - temp)\n    app(nowx, nowy)\n    ok()\n\n
n = int(input())\nl, r = 0, 10**16\nD = [x ** 3.0 for x in range(2, 170417)]\nDD = [x*x*x for x in range(2, 170417)]\nwhile l < r:\n    m = (l+r) // 2\n    if sum(int(m/d) for d in D) < n:\n        l = m + 1\n    else:\n        r = m;\nif sum(l//d for d in DD) == n:\n    print(l);\nelse :\n    print((-1));\n
#!/usr/bin/env python3\n# 600D_circles.py - Codeforces.com/problemset/problem/600/D by Sergey 2015\n\nimport unittest\nimport sys\nimport math\nimport decimal\n\n###############################################################################\n# Circles Class (Main Program)\n###############################################################################\n\n\ndef sin(x):\n    decimal.getcontext().prec += 2\n    i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1\n    while s != lasts:\n        lasts = s\n        i += 2\n        fact *= i * (i-1)\n        num *= x * x\n        sign *= -1\n        s += num / fact * sign\n    decimal.getcontext().prec -= 2\n    return +s\n\n\ndef cos(x):\n    decimal.getcontext().prec += 2\n    i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1\n    while s != lasts:\n        lasts = s\n        i += 2\n        fact *= i * (i-1)\n        num *= x * x\n        sign *= -1\n        s += num / fact * sign\n    decimal.getcontext().prec -= 2\n    return +s\n\n\ndef pi():\n    decimal.getcontext().prec += 2\n    three = decimal.Decimal(3)\n    lasts, t, s, n, na, d, da = 0, three, 3, 1, 0, 0, 24\n    while s != lasts:\n        lasts = s\n        n, na = n+na, na+8\n        d, da = d+da, da+32\n        t = (t * n) / d\n        s += t\n    decimal.getcontext().prec -= 2\n    return +s\n\n\ndef asin(x):\n    decimal.getcontext().prec += 2\n    b, e = -pi()/2, pi()/2\n    while True:\n        mid = (b + e) / 2\n        if e == mid or b == mid:\n            break\n        if sin(mid) <= x:\n            b = mid\n        else:\n            e = mid\n    decimal.getcontext().prec -= 2\n    return +b\n\n\ndef acos(x):\n    return pi() / 2 - asin(x)\n\n\nclass Circles:\n    """ Circles representation """\n\n    def __init__(self, test_inputs=None):\n        """ Default constructor """\n\n        it = iter(test_inputs.split("\n")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        [self.xa, self.ya, self.ra] = list(map(decimal.Decimal, uinput().split()))\n        [self.xb, self.yb, self.rb] = list(map(decimal.Decimal, uinput().split()))\n\n        decimal.getcontext().prec = 40\n\n        self.l = ((self.xb - self.xa)**2 + (self.yb - self.ya)**2).sqrt()\n        self.p = (self.ra + self.rb + self.l)/2\n\n        if self.l >= self.p:\n            self.sa = 0\n            self.sb = 0\n        elif self.ra >= self.p:\n            self.sa = 0\n            self.sb = self.rb**2 * decimal.Decimal.from_float(math.pi)\n        elif self.rb >= self.p:\n            self.sa = self.ra**2 * decimal.Decimal.from_float(math.pi)\n            self.sb = 0\n        else:\n            self.aa = 2 * acos(\n                (self.ra**2 - self.rb**2 + self.l**2) /\n                (2 * self.ra * self.l))\n            self.ab = 2 * acos(\n                (self.rb**2 - self.ra**2 + self.l**2) /\n                (2 * self.rb * self.l))\n            self.sa = self.ra**2 * (self.aa - sin(self.aa)) / 2\n            self.sb = self.rb**2 * (self.ab - sin(self.ab)) / 2\n\n    def calculate(self):\n        """ Main calcualtion function of the class """\n\n        result = self.sa + self.sb\n\n        return str(result)\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        """ Circles class testing """\n\n        # Constructor test\n        test = "0 0 4\n6 0 4"\n        d = Circles(test)\n        self.assertEqual(d.l, 6)\n\n        # Sample test\n        self.assertEqual(Circles(test).calculate()[:8], "7.252988")\n\n        # Sample test\n        test = "0 0 5\n11 0 5"\n        self.assertEqual(Circles(test).calculate(), "0")\n\n        # Sample test\n        test = "44721 999999999 400000000\n0 0 600000000"\n        self.assertEqual(Circles(test).calculate()[:9], "0.0018834")\n\n        # My tests\n        test = ""\n        # self.assertEqual(Circles(test).calculate(), "0")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        """ Timelimit testing """\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + " " + str(nmax) + "\n"\n        numnums = [str(i) + " " + str(i+1) for i in range(nmax)]\n        test += "\n".join(numnums) + "\n"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += " ".join(map(str, nums)) + "\n"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Circles(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print(("\nTimelimit Test: " +\n              "{0:.3f}s (init {1:.3f}s calc {2:.3f}s)".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == "-ut":\n        unittest.main(argv=[" "])\n\n    # Print the result string\n    sys.stdout.write(Circles().calculate())\n\n__starting_point()
n=int(input())\nif n==2:\n    print(2)\nelse:\n    print(1)
from collections import deque\n\nn = int(input())\np = list(map(int,input().split()))\na = list(map(int,input().split()))\nedge = [[] for i in range(n)]\nfor i in range(n-1):\n    edge[p[i]-1].append(i+1)\n\n\ndp = [0 for i in range(n)]\nsize = [not edge[v] for v in range(n)]\n\nres = []\ndeq = deque([0])\nwhile deq:\n    v = deq.popleft()\n    res.append(v)\n    for nv in edge[v]:\n        deq.append(nv)\n\nres = res[::-1]\n\nfor v in res:\n    tmp = -1\n    S = 0\n    for nv in edge[v]:\n        tmp = max(tmp,dp[nv])\n        size[v] += size[nv]\n        S += a[nv]\n\n    if not edge[v]:\n        dp[v] = a[v]\n        continue\n\n    rest = tmp*size[v] - S\n    if a[v]<=rest:\n        dp[v] = tmp\n    else:\n        q = (a[v]-rest)//size[v]\n        r = (a[v]-rest)%size[v]\n        if r:\n            dp[v] = tmp + q + 1\n        else:\n            dp[v] = tmp + q\n    a[v] += S\n\nprint(dp[0])
def check(w, s):\n    j = 0\n    for i in range(len(s)):\n        while j < len(w) and s[i] != w[j]:\n            j += 1\n        if j >= len(w) or s[i] != w[j]:\n            return False\n        j += 1\n    return True\n\nn = int(input())\ns = input()\nt = input()\nst = []\ni = 0\nwhile i < n and s[i] == t[i]:\n    st.append(s[i])\n    i += 1\nw1 = st[:]\nw2 = st[:]\nw3 = st[:]\nw4 = st[:]\nw1.append(s[i])\nw1.append(t[i])\nw3.append(s[i])\nw3.append(t[i])\nw2.append(t[i])\nw2.append(s[i])\nw4.append(t[i])\nw4.append(s[i])\nfor j in range(i + 1, n):\n    w1.append(s[j])\n    w2.append(t[j])\n    w3.append(t[j])\n    w4.append(s[j])\n\nres = set()\nfor ww in (w1, w2, w3, w4):\n    www = ''.join(ww)\n    if check(www, s) and check(www, t):\n        res.add(www)\nprint(len(res))
def sol():\n\n    n = int(input())\n    st = list(map(int, input().split(' ')))\n    d = {}\n    for x in range(n):\n        d[x] = []\n\n    st = [(st[i], i) for i in range(len(st))]\n    st = sorted(st)\n\n    for a0 in range(n - 1):\n        u, v = map(int, input().split(' '))\n        u, v = u - 1, v - 1\n        d[u].append(v)\n        d[v].append(u)\n\n    hardest = []\n    almost = []\n\n    single_hardest = st[-1][0]\n\n    for x in st[::-1]:\n        if x[0] == single_hardest:\n            hardest.append(x[1])\n        elif x[0] == single_hardest-1:\n            almost.append(x[1])\n        else:\n            break\n\n    def inter(a, b):\n        c = []\n        for x in a:\n            if x in b:\n                c.append(x)\n        return c\n\n    lower_bound = single_hardest\n\n    inte = d[hardest[0]]+[hardest[0]]\n    for h in hardest[1:]:\n        inte = inter(inte, d[h]+[h])\n\n    if not inte:\n        return (single_hardest+2)\n\n    if len(hardest) > 1:\n        return single_hardest+1\n\n    # hardest is len 1\n    if not almost:\n        return single_hardest\n\n    cand = st[-1][1]\n\n    for h in almost:\n        if h not in d[cand]:\n            return single_hardest+1\n    return single_hardest\n\nprint(sol())
n, m = map(int, input().split())\nif m <= 1:\n    print(1)\n    return\nprint(min(m, n - m))
k, r = list(map(int, input().split()))\n\nans = 10\nfor x in range(1, 11):\n    mod = k * x % 10\n    if mod == 0 or mod == r:\n        ans = x\n        break\n\nprint(ans)\n
#!/usr/bin/env python3\n\ndef main():\n    import re\n\n    n, m = list(map(int, input().split()))\n    left = right = -1\n    for i in range(n):\n        mt = re.search(r"X+", input())\n        if mt is not None:\n            t = mt.start()\n            if t != left != -1:\n                print("NO")\n                break\n            left = t\n            t = mt.end()\n            if t != right != -1:\n                print("NO")\n                break\n            right = t\n    else:\n        print("YES")\n\nmain()\n
a, b = list(map(int, input().split(' ')))\nc, d = list(map(int, input().split(' ')))\ne, f = list(map(int, input().split(' ')))\nx=[[a, b],[c,d],[e,f]]\nx.sort()\na, b, c, d, e, f = x[0][0], x[0][1], x[1][0], x[1][1], x[2][0], x[2][1]\nif (a==c==e or b==d==f):\n    print(1)\n    quit()\n\nif a == c:\n    if b<f<d:\n        print(3)\n        quit()\n    print(2)\n    quit()\n\nif c == e:\n    if (d<b<f):\n        print(3)\n        quit()\n    print(2)\n    quit()\n\nif b == d:\n    print(2)\n    quit()\n\nif d == f:\n    print(2)\n    quit()\n\nif b == f:\n    if a<c<e:\n        print(3)\n        quit()\n    print(2)\n    quit()\n\nprint(3)\nquit()\n
import math,string,itertools,fractions,heapq,collections,re,array,bisect\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI(): return list(map(int,input().split()))\n\ndef main1(k):\n    # works correctly, but too slow and generates many more vertices than necessary.\n    # doesn't pass the time constraint with this implementation. (prints 10^5 lines)\n    # ==> use the editorial solution below.\n    if k%2==0:\n        print("NO")\n        return\n    print("YES")\n    n = 2*(k**2-k+1)\n    m = n*k//2\n    print(n, m)\n    i = 0\n    g = [[] for i in range(n+1)]\n    print(1,n//2+1)\n    off = 1\n    for j in range(0,k-1,2):\n        j1 = off + j+1\n        j2 = off + j+2\n        print(off,j1)\n        print(off,j2)\n        l1 = off + k + j*(k-1)\n        l2 = off + k + (j+1)*(k-1)\n        for l in range(k-1):\n            print(j1, l1+l)\n            print(j2, l2+l)\n            for m in range(k-1):\n                print(l1+l,l2+m)\n    off = n//2+1\n    for j in range(0,k-1,2):\n        j1 = off + j+1\n        j2 = off + j+2\n        print(off,j1)\n        print(off,j2)\n        l1 = off + k + j*(k-1)\n        l2 = off + k + (j+1)*(k-1)\n        for l in range(k-1):\n            print(j1, l1+l)\n            print(j2, l2+l)\n            for m in range(k-1):\n                print(l1+l,l2+m)\n\ndef main(k):\n    # following the editorial algo\n    if k%2==0:\n        print("NO")\n        return\n    print("YES")\n    if k==1:\n        print("2 1")\n        print("1 2")\n        return\n    n = 2*k+4\n    m = n*k//2\n    e = []\n    e.extend([(1,n//2+1)])\n    off = 1\n    for j in range(off+1,off+k):\n        e.extend([(off, j)])\n    for j in range(off+1,off+k):\n        for i in range(j+1,off+k):\n            if (i==j+1 and (j-off)%2==1):# or (j==off+1 and i==off+k-1):\n            #if (i==j+1 and i%2==0) or (j==off+1 and i==off+k-1):\n                continue\n            e.extend([(j,i)])\n        e.extend([(j,off+k),(j,off+k+1)])\n    e.extend([(off+k,off+k+1)])\n    off = n//2+1\n    for j in range(off+1,off+k):\n        e.extend([(off, j)])\n    for j in range(off+1,off+k):\n        for i in range(j+1,off+k):\n            if (i==j+1 and (j-off)%2==1):# or (j==off+1 and i==off+k-1):\n                continue\n            e.extend([(j,i)])\n        e.extend([(j,off+k),(j,off+k+1)])\n    e.extend([(off+k,off+k+1)])\n    print(n, m)\n    for x in e:\n        print(*x)\n\n\n\ndef main_input(info=0):\n    k = int(input())\n    main(k)\n\ndef __starting_point():\n    main_input()\n\n__starting_point()
#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\n    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit\n    \nN, M, Q = getIntList()\n\ns1 = input()\ns2 = input()\n\ntot = 0\nzt = [0]\n\nfor i in range(N):\n    if s1[i:i+M] == s2:\n        tot+=1\n    zt.append(tot)\ndprint(zt)\nfor i in range(Q):\n    a,b = getIntList()\n    b0 = b- M+1\n    if b0<a:\n        print(0)\n    else:\n        print(zt[b0] - zt[a-1])\n\n\n\n\n\n\n\n
ans = {}\n\ndef gen(n, k, d, used = False):\n    if not ans.get((n, k, d, used)):\n        if not n and used:\n            ans[(n, k, d, used)] = 1\n        else:\n            ans[(n, k, d, used)] = sum(gen(n - x, k, d, used or x >= d) for x in range(1, min(n, k) + 1) if max(x, n - x) >= d or used)\n    return ans[(n, k, d, used)]\n\n\nn, k, d = list(map(int, input().split()))\nprint(gen(n, k, d)  % 1000000007)\n
# You lost the game.\n\nn = int(input())\ns = str(input())\n\nR = []\nb = 0\nfor i in range(n):\n    if s[i] == "B":\n        b += 1\n    elif b > 0:\n        R += [b]\n        b = 0\nif b > 0:\n    R += [b]\nprint(len(R))\nfor i in range(len(R)):\n    print(R[i],end=" ")\n
n, m, p = [int(x) for x in input().split()]\nA = input().rstrip()\nB = input().rstrip()\n\npair = [0] * n\nstack = []\nfor (i, c) in enumerate(A):\n    if c == '(':\n        stack.append(i)\n    else:\n        j = stack.pop()\n        pair[i] = j\n        pair[j] = i\n\nstart = 0\npointer = p - 1\nleft = list(range(-1, n-1))\nright = list(range(1, n+1))\nleft[0] = None\nright[-1] = None\n\nfor c in B:\n    if c == 'R':\n        pointer = right[pointer]\n    elif c == 'L':\n        pointer = left[pointer]\n    else:\n        if pair[pointer] < pointer:\n            if right[pointer] is not None:\n                left[right[pointer]] = left[pair[pointer]]\n            if left[pair[pointer]] is not None:\n                right[left[pair[pointer]]] = right[pointer]\n            else:\n                start = right[pointer]\n\n            if right[pointer] is None:\n                pointer = left[pair[pointer]]\n            else:\n                pointer = right[pointer]\n        else:\n            if right[pair[pointer]] is not None:\n                left[right[pair[pointer]]] = left[pointer]\n            if left[pointer] is not None:\n                right[left[pointer]] = right[pair[pointer]]\n            else:\n                start = right[pair[pointer]]\n\n\n            if right[pair[pointer]] is None:\n                pointer = left[pointer]\n            else:\n                pointer = right[pair[pointer]]\n\ni = start\nwhile right[i] is not None:\n    print(A[i], end = '')\n    i = right[i]\nprint(A[i])\n
"""\nCodeforces Round 241 Div 1 Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\nclass InputHandlerObject(object):\n    inputs = []\n\n    def getInput(self, n = 0):\n        res = ""\n        inputs = self.inputs\n        if not inputs: inputs.extend(input().split(" "))\n        if n == 0:\n            res = inputs[:]\n            inputs[:] = []\n        while n > len(inputs):\n            inputs.extend(input().split(" "))\n        if n > 0:\n            res = inputs[:n]\n            inputs[:n] = []\n        return res\nInputHandler = InputHandlerObject()\ng = InputHandler.getInput\n\n############################## SOLUTION ##############################\nn = int(input().strip())\nmn = -2*10**9\nmx = 2*10**9\nrepl = [(">", "<="), (">=", "<"), ("<=", ">"), ("<", ">=")]\nfor i in range(n):\n    a = g()\n    a[1] = int(a[1])\n    if a[2] == "N":\n        for qq,qqq in repl:\n            if qq == a[0]:\n                a[0] = qqq\n                break\n    if a[0] == ">": a[1] += 1\n    if a[0] == "<": a[1] -= 1\n    if a[0][0] == ">": mn = max(mn, a[1])\n    if a[0][0] == "<": mx = min(mx, a[1])\n\nif mn <= mx:\n    print(mn)\nelse:\n    print("Impossible")
import math\na,b= list(map(int,input().split()))\nn=a+b\nans,l=0,1\nwhile l<=n:\n    g= n//l\n    if a<g or b<g:\n        l= (n//g) +1\n        continue\n    r= n//g\n    a_low = (a+g)//(g+1)\n    a_high = a//g\n    b_low=(b+g)//(g+1)\n    b_high = b//g\n    if (a_low <= a_high and b_low <= b_high):\n        ans += max(0,min(r,a_high+b_high)- max(l,a_low +b_low)+1)\n\n    l=r+1\nprint(ans)\n
n, k = list(map(int, input().split()))\na = input().split()\nnames = [chr(ord("A") + i) for i in range(26)] + [chr(ord("A") + i) + chr(ord('a') + i) for i in range(26)]\nans = [names[i] for i in range(n)]\nfor i in range(k - 1, n):\n	if a[i - k + 1] == "NO":\n		ans[i] = ans[i - k + 1]\nprint(*ans)\n
a,b=list(map(int,input().split()))\ndef gcd(a,b):\n    if(b==0):\n        return a\n    return gcd(b,a%b)\ndef burn(n):\n    c=0\n    while(n%2==0):\n        c+=1\n        n=n//2\n    while(n%3==0):\n        c+=1\n        n=n//3\n    while(n%5==0):\n        c+=1\n        n=n//5\n    return [c,n]\nif(a==b):\n    print(0)\nelse:\n    g=gcd(a,b)\n    c=a//g\n    d=b//g\n    l1=burn(c)\n    l2=burn(d)\n    if(l1[1]==1 and l2[1]==1):\n        print(l1[0]+l2[0])\n    else:\n        print(-1)\n
# import sys\n# sys.stdin = open("F:\\Scripts\\input","r")\n# sys.stdout = open("F:\\Scripts\\output","w")\n\n\nMOD = 10**9 + 7\nI = lambda:list(map(int,input().split()))\n\nn , a , b = I()\nl = I()\ncost = 0\nm = min(a,b)\nfor i in range(n//2):\n	if l[i] + l[n-i-1] == 1:\n		print(-1)\n		return\n	if l[i] == 2 and l[n - i - 1] == 2:\n		cost += 2*m\n	elif l[i] == 2 or l[n - i - 1] == 2:\n		if l[i] == 1 or l[n - i - 1] == 1:\n			cost += b\n		else:\n			cost += a\nif n%2 and l[n//2] == 2:\n	cost += m\nprint(cost)
K = int(input())\nprint(("-1" if K & 1 else "".join(["wb\n"[2 if k == K else (min(j, k, K - 1 - j,\n    K - 1 - k) ^ i) & 1] for i in range(2) for j in range(K) for k in range(K +\n        1)]) * (K >> 1)))\n
n = int(input())\nans = 1\ni = 2\nwhile i * i <= n:\n    if n % i == 0:\n        ans *= i\n    while n % i == 0:\n        n //= i\n    i += 1\nans *= n\nprint(ans)
n = int(input())\na = '0'+input()+'0'\nif '000' in a or '11' in a:print('No')\nelse:print('Yes')\n
n = int(input())\na = list(map(int, input().split()))\nans = []\n\nfor k in range(1, n + 1):\n    x = [0] * k\n\n    x[0] = a[0]\n    for i in range(1, k):\n        x[i] = a[i] - a[i - 1]\n\n    ok = True\n    for i in range(k, n):\n        if x[i % k] != a[i] - a[i - 1]:\n            ok = False\n            break\n    if ok:\n        ans.append(k)\n\nprint(len(ans))\nprint(*ans)\n
a = list(map(int, input().split()))\ns = sum(a)\nfor i in range(6):\n    for j in range(i):\n        for k in range(j):\n            ss = a[i] + a[j] + a[k]\n            if ss == s - ss:\n                print('YES')\n                return\nprint('NO')\n
a,b=map(int,input().split())\nans=0\nfor i in range(0,40):\n    for j in range(0,40):\n        if (2**i)*(3**j)>=a and (2**i)*(3**j)<=b:\n            ans+=1\nprint(ans)
n,k=map(int,input().split())\nlow=1\nhigh=n\nimport sys\nwhile low<=high:\n    mid=(low+high)//2\n    if mid*(mid+1)//2 -(n-mid)>k:\n        high=mid-1\n    elif mid*(mid+1)//2-(n-mid)==k:\n        print(n-mid)\n        return\n    else :\n        low=mid+1
n = int(input())\na = list(map(int, input().split()))\na.sort()\nok = False\nfor i in range(n - 2):\n	if a[i] + a[i + 1] > a[i + 2]:\n		ok = True\nprint(("NO", "YES")[ok])
x, y = map(int, input().split())\n\nif y == 0:\n	print('No')\n	return\nelse:\n	y -= 1\n\nif y == 0 and x:\n	print('No')\n	return\n\nif y > x or (x - y) & 1:\n	print('No')\nelse:\n	print('Yes')
import sys\n\ndef solve():\n    n,k, = rv()\n    a, = rl(1)\n    res = 0\n    count = [0] * 10\n    for i in range(n):\n        if a[i] < 100:\n            count[10 - (a[i] % 10) - 1] += 1\n        res += a[i] // 10\n    for i in range(10):\n        while count[i] > 0 and k >= i + 1:\n            res += 1\n            count[i] -= 1\n            k -= i + 1\n    already = res * 10\n    possible = n * 100\n    diff = possible - already\n    if diff > 0:\n        actual = min(diff, k)\n        res += actual // 10\n    print(res)\n\n\n\n\n\n\ndef prt(l): return print(' '.join(map(str, l)))\ndef rs(): return map(str, input().split())\ndef rv(): return map(int, input().split())\ndef rl(n): return [list(map(int, input().split())) for _ in range(n)]  \nif sys.hexversion == 50594544 : sys.stdin = open("test.txt")\nsolve()
n, m = map(int, input().split())\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\na.sort()\nb.sort()\nfor i in a:\n    if i in b:\n        print(i)\n        break\nelse:\n    print(min(a[0], b[0]), max(a[0], b[0]), sep = '')\n
"""\nCodeforces Good Bye 2016 Contest Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.5.2\n"""\n\n################################################### SOLUTION\n\ndef main():\n    n,k = read()\n    avail = 240-k\n    i = 1\n    while i <= n and avail >= 5*i:\n        avail -= 5*i\n        i += 1\n    print(i-1)\n\n#################################################### HELPERS\n\ndef read(callback=int):\n    return list(map(callback, input().strip().split()))\n\ndef write(value, end="\n"):\n    if value is None: return\n    try:\n        value = " ".join(map(str, value))\n    except:\n        pass\n    print(value, end=end)\n\nwrite(main())\n
import sys,math\nn,x,y=list(map(int,input().split()))\nz=list(map(int,input().split()))\nz.sort()\nans=0\nfor i in range(n):\n    if z[i]%2==0:\n        if x>=z[i]//2:\n            x-=z[i]//2\n            ans+=1\n        else:\n            z[i]-=x*2\n            x=0\n            y-=z[i]\n            if y>=0:\n                ans+=1\n            else:\n                break\n    else:\n        if x>=z[i]//2 and y>=1:\n            x-=z[i]//2\n            ans+=1\n            y-=1\n        elif x>=z[i]//2+1:\n            x-=z[i]//2+1\n            ans+=1\n        else:\n            z[i]-=x*2\n            x=0\n            y-=z[i]\n            if y>=0:\n                ans+=1\n            else:\n                break\nprint(ans)\n            \n            \n        \n            \n        \n        \n    \n    \n\n\n\n
#JMD\n#Nagendra Jha-4096\n\n \nimport sys\nimport math\n\n#import fractions\n#import numpy\n \n###File Operations###\nfileoperation=0\nif(fileoperation):\n    orig_stdout = sys.stdout\n    orig_stdin = sys.stdin\n    inputfile = open('W:/Competitive Programming/input.txt', 'r')\n    outputfile = open('W:/Competitive Programming/output.txt', 'w')\n    sys.stdin = inputfile\n    sys.stdout = outputfile\n\n###Defines...###\nmod=1000000007\n \n###FUF's...###\ndef nospace(l):\n    ans=''.join(str(i) for i in l)\n    return ans\n\nans=[]\n\ndef printDivisors(n) : \n      \n    # Note that this loop runs till square root \n    i = 1\n    while i <= math.sqrt(n): \n          \n        if (n % i == 0) : \n              \n            # If divisors are equal, print only one \n            if (n / i == i) : \n                ans.append(i) \n            else : \n                # Otherwise print both \n                ans.append(i)\n                ans.append(n//i) \n        i = i + 1\n \n \n \n##### Main ####\nt=1\nfor tt in range(t):\n	n=int(input())\n	printDivisors(n)\n	s=set(ans)\n	print(len(s))\n    #a=list(map(int,sys.stdin.readline().split(' ')))\n    #n,k,s= map(int, sys.stdin.readline().split(' '))\n    \n    \n#####File Operations#####\nif(fileoperation):\n    sys.stdout = orig_stdout\n    sys.stdin = orig_stdin\n    inputfile.close()\n    outputfile.close()
n = int(input())\ns = input()\nl = 0\nans = 0\nwhile l < len(s) and s[l] == '<':\n    ans += 1\n    l += 1\n\nr = n - 1\nwhile r >= 0 and s[r] == '>':\n    ans += 1\n    r -= 1\n\nprint(ans)\n
arr = [0] * (10 ** 6 + 1)\nn = int(input())\nfor i in input().split():\n    arr[int(i)] += 1\ni = 10 ** 6\nj = i\nk = i\nc = 0\nwhile j > 0:\n    if arr[j] % 2 == 1 and (arr[j] > 1 or c == 0):\n        arr[j - 1] += 1\n        c = 1\n    else:\n        c = 0\n    j -= 1\nr = 0\nwhile i > 0 and k > 0:\n    if arr[i] < 2:\n        if i == k:\n            k -= 1\n        i -= 1\n    elif i == k and arr[i] < 4:\n        k -= 1\n    elif arr[k] < 2:\n        k -= 1\n    else:\n        r += i * k\n        arr[i] -= 2\n        arr[k] -= 2\nprint(r)
'''input\n3\naa\njj\naa\n'''\n\ndef list_input():\n    return list(map(int,input().split()))\ndef map_input():\n    return map(int,input().split())\ndef map_string():\n    return input().split()\n \nn = int(input())\nd = {}\npos = {}\nfor _ in range(n):\n	s = list(input())\n	s = s[::-1]\n	for i in range(len(s)):\n		try:\n			d[s[i]] += 10**i\n		except:\n			d[s[i]] = 10**i\n			pos[s[i]] = True\n		if i == len(s)-1:\n			pos[s[i]] = False	\na = []\nb = []\nfor i in d:\n	a.append(d[i])\n	if pos[i]:\n		b.append(d[i])\nif len(b):a.remove(max(b))\na.sort(reverse = True)\n# print(a)\nans = 0\nfor i in range(len(a)):\n	ans += (i+1)*a[i]\nprint(ans)				
a, b = list(map(int, input().split(' ')))\nprint(min([a, b, (a+b)//3]))\n
a = []\nb = []\nx = input()\nfor i in range(len(x)-1):\n    if x[i]+x[i+1] == 'AB':\n        a.append(i)\n    elif x[i]+x[i+1] == 'BA':\n        b.append(i)\n\nif a == [] or b == []:\n    print("NO")\n    quit()\n    \nif abs(min(a)-max(b))>1 or abs(max(a)-min(b))>1:\n    print("YES")\n    quit()\nprint("NO")\n
import sys\n\na = [0,]\nb = [0,]\nans1 = []\nans2 = []\nn = int(input())\ns = input()\nnums = s.split()\nfor i in range(0, n):\n    a.append(int(nums[i]))\n\nk = int(input())\ns = input()\nnums = s.split()\nfor i in range(0, k):\n    b.append(int(nums[i]))\n\ndef f(x, y, z):\n    #print(x,y,z)\n    pos1 = x\n    pos2 = x\n    if x == y:\n        return 1\n    for i in range(x, y + 1):\n        if a[i] > a[pos1]:\n            pos1 = i\n        if a[i] >= a[pos2]:\n            pos2 = i\n    for i in range(x, y):\n        if a[i] == a[pos2]:\n            if a[i + 1] < a[i]:\n                pos2 = i\n    for i in range(x + 1, y + 1):\n        if a[i] == a[pos1]:\n            if a[i - 1] < a[i]:\n                pos1 = i\n    if pos1 != x or a[pos1] > a[pos1 + 1]:\n        for i in range(0, pos1 - x):\n            ans1.append(pos1 - x + z - i)\n            ans2.append('L')\n        for i in range(0, y - pos1):\n            ans1.append(z)\n            ans2.append('R')\n    elif pos2 != y or a[pos2] > a[pos2 - 1]:\n        for i in range(0, y - pos2):\n            ans1.append(pos2 - x + z)\n            ans2.append('R')\n        for i in range(0, pos2 - x):\n            ans1.append(pos2 - x + z - i)\n            ans2.append('L')\n    else:\n        return 0\n\n    return 1\n\nlasti = 0\nj = 1\nsum = 0\nfor i in range(1, n+1):\n    if j > k:\n        print('NO')\n        return\n    sum += a[i]\n    #print(i, sum, j)\n    if sum > b[j]:\n        print('NO')\n        return\n    if sum == b[j]:\n        if f(lasti + 1, i, j) == 0:\n            print('NO')\n            return\n        lasti = i\n        j += 1\n        sum = 0\n\nif j <= k:\n    print('NO')\n    return\n\nprint('YES')\nfor i in range(0, len(ans1)):\n    print(ans1[i], ans2[i])
a, b = list(map(int, input().split()))\nif a==b: print("Yes")\nelse: print("No")\n
n = int(input())\nl = list(map(int, input().split()))\nmax1 = 1\nfor i in l:\n    k = 1\n    x = i\n    while x % 2 == 0:\n        k *= 2\n        x //= 2\n    max1 = max(max1, k)\nc = 0\nfor i in l:\n    if i % max1 == 0:\n        c += 1\nprint(max1, c)
def main():\n    n, m = map(int, input().split())\n    res, delta = 0, 1\n    while n < m:\n        res += 1\n        n *= 2\n        delta *= 2\n    while n > m:\n        while n - delta >= m:\n            res += 1\n            n -= delta\n        delta //= 2\n    print(res)\n\n\ndef __starting_point():\n    main()\n__starting_point()
import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nclass BIT_RSQ():\n    def __init__(self, n):\n        self.n = n\n        self.data = [0]*(n+2)\n\n    def add(self, i, v):\n        while i <= self.n:\n            self.data[i] += v\n            i += i & -i\n\n    def sum(self, i):\n        ret = 0\n        while(i > 0):\n            ret += self.data[i]\n            i -= i & -i\n        return ret\n\n    def query(self, l, r):\n        return self.sum(r) - self.sum(l-1)\n\n    def lowerBound(self, w):\n        if w <= 0: return 0\n        x, k = 0, 2**self.n.bit_length()\n        while k:\n            if x+k <= self.n and self.data[x+k] < w:\n                w -= self.data[x+k]\n                x += k\n            k >>= 1\n        return x + 1\n\nn = int(input())\nedges = [0]*(2*n)\nc = [0]*(2*n)\nBIT = BIT_RSQ(2*n)\n\nuf = [-1]*n\ndef root(x):\n    if uf[x] < 0:\n        return x\n    uf[x] = root(uf[x])\n    return uf[x]\ndef unite(x,y):\n    rx, ry = root(x), root(y)\n    if rx == ry:\n        return False\n    if uf[rx] > uf[ry]:\n        rx, ry = ry, rx\n    uf[rx] += uf[ry]\n    uf[ry] = rx\n    return True\n\nfor i in range(n):\n    a,b = list(map(int, input().split()))\n    a,b = a-1,b-1\n    c[a] = c[b] = i\n    edges[a] = b\n    edges[b] = b\n\nfor i in reversed(list(range(2*n))):\n    j = edges[i]\n    if j == i:\n        BIT.add(j+1, 1)\n    else:\n        BIT.add(j+1, -1)\n        cnt = BIT.sum(j+1)\n        while cnt:\n            k = BIT.lowerBound(cnt)\n            if not unite(c[j], c[k-1]):\n                print("NO")\n                return\n            cnt -= 1\nif sum(i<0 for i in uf) == 1:\n    print("YES")\nelse:\n    print("NO")\n\n
def prog():\n    n = int(input())\n    inp = list(map(int,input().split()))\n    ans = 0\n    for i in range(len(inp)):\n        x,y = 0 ,0\n        for j in range(i,len(inp)):\n            x+=inp[j]\n            y+=100\n            if(x>y):\n                ans = max(ans,(j-i)+1)\n    print(ans)\nprog()
import sys\n\nn, k = list(map(int, input().split(' ')))\n\ns = input()\n\ndef max_streak(s):\n    result = 0\n\n    for i in range(len(s)):\n        j = i\n        while j < len(s) and s[j] == 'N':\n            j += 1\n\n        result = max(result, j - i)\n\n    return result\n\nfor i in range(n - k + 1):\n    cur = list(s)\n    for j in range(i, i + k):\n        if cur[j] == '?':\n            cur[j] = 'N'\n\n    for j in range(i):\n        if cur[j] == '?':\n            cur[j] = 'Y'\n\n    for j in range(i + k, n):\n        if cur[j] == '?':\n            cur[j] = 'Y'\n\n    if max_streak(cur) == k:\n        print('YES')\n        return\n\nprint('NO')\n
def solve():\n    N, X, D = list(map(int, input().split()))\n\n    if D == 0:\n        if X == 0:\n            print((1))\n        else:\n            print((N+1))\n        return\n\n    LRss = {}\n    for k in range(N+1):\n        m = X*k\n        rem = m%D\n        minCoef = m//D + k*(k-1)//2\n        maxCoef = m//D + k*(2*N-k-1)//2\n        if rem not in LRss:\n            LRss[rem] = [(minCoef, maxCoef)]\n        else:\n            LRss[rem].append((minCoef, maxCoef))\n\n    ans = 0\n    for rem, LRs in list(LRss.items()):\n        LRs.sort()\n        LNow, RNow = LRs[0]\n        for L, R in LRs[1:]:\n            if L <= RNow:\n                if R > RNow:\n                    RNow = R\n            else:\n                ans += RNow - LNow + 1\n                LNow, RNow = L, R\n        ans += RNow - LNow + 1\n\n    print(ans)\n\n\nsolve()\n
read = lambda: map(int, input().split())\nn = int(input())\nfor i in range(n):\n    name, x, y = input().split()\n    x, y = int(x), int(y)\n    if x >= 2400 and y > x:\n        print('YES')\n        return\nprint('NO')
s = int(input(), 2)\n\nt, ans = 1, 0\n\nwhile t < s:\n	ans += 1\n	t *= 4\n\nprint(ans)\n
n,m = [int(i) for i in input().split()]\nl = []\nfor i in range(n):\n    l.append(input().strip())\nwhile len(l)%2 == 0:\n    mirror = True\n    for i in range(len(l)//2):\n        if l[i] != l[len(l)-1-i]:\n            mirror = False\n            break\n    if mirror:\n        l = l[:len(l)//2]\n    else:\n        break\n\nprint(len(l))\n
def key_tri(argument):\n    return argument[1]\n\nn = int(input())\nL = [list(map(int, input().split())) for _ in range(n)]\nL.sort(key=key_tri)\nr = 1\nt = L[0][1]\nfor k in range(1,n):\n    if L[k][0]>t:\n        r+=1\n        t = L[k][1]\nprint(r)\n
def max(a, b):\n	if a > b:\n		return a\n	else:\n		return b\nn, k = map(int, input().split())\nx = [int(t) for t in input().split()]\ny = [int(t) for t in input().split()]\nf, s = 0, 0\nfor i in range(n):\n    f = max(0, x[i] + f - k * y[i])\n    s = max(0, y[i] + s - k * x[i])\n    if f > k or s > k:\n        print('NO')\n        return\nprint('YES')
p=1048583\nq=1048589\nmodd=p*q*p*q\nn,k=tuple(map(int,input().split()))\na=[0]\nwenhao=0\ngai=0\nfor i in range(n+1):\n    m=input()\n    if m[0]=='?':\n        a.append('?')\n        wenhao+=1\n    else:\n        a.append(int(m))\n        gai+=1\n\nif k==0:\n    if (a[1]=='?' and gai&1==1) or a[1]==0:\n        print('Yes')\n    else:\n        print('No')\nelse:\n    if wenhao!=0:\n        if n&1==1:\n            print('Yes')\n        else:\n            print('No')\n    else:\n        m=a[n+1]\n        nn=a[n]\n        for i in range(n,0,-1):\n            m,nn=(nn+k*m)%modd,a[i-1]\n        if m==0:\n            print('Yes')\n        else:\n            print('No')\n
from math import floor, sqrt\nimport bisect\n\nimport math\n\n\ndef rwh_primes2(n):\n    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    """ Input n>=6, Returns a list of primes, 2 <= p < n """\n    correction = (n%6>1)\n    n = {0:n,1:n-1,2:n+4,3:n+3,4:n+2,5:n+1}[n%6]\n    sieve = [True] * (n//3)\n    sieve[0] = False\n    for i in range(int(n**0.5)//3+1):\n      if sieve[i]:\n        k=3*i+1|1\n        sieve[      ((k*k)//3)      ::2*k]=[False]*((n//6-(k*k)//6-1)//k+1)\n        sieve[(k*k+4*k-2*k*(i&1))//3::2*k]=[False]*((n//6-(k*k+4*k-2*k*(i&1))//6-1)//k+1)\n    return [2,3] + [3*i+1|1 for i in range(1,n//3-correction) if sieve[i]]\n\n\nk = int(input())\n\nprimes = rwh_primes2(k)\n\na = 1\np2 = 2\nfor i in primes[::-1]:\n    if k%i == 0:\n        p2 = i\n        break\n\nxx = range(k-p2+1, k+1)\n#print(list(xx))\nif p2>240:\n    p1 = primes[bisect.bisect_left(primes, int(math.ceil(xx[0]/2)))]\n    print(p1+1)\nelse:\n    ans = k\n    p1 = 1\n    for x1 in xx:\n        for i in primes[::-1]:\n\n            if i >= x1:\n                continue\n\n            if x1 % i == 0:\n                p1 = i\n                break\n        ans = min(ans, x1-p1+1)\n\n    print(ans)
n, p = list(map(int, input().split()))\nfor q in range(5757):\n    s = bin(n)\n    if n >= q >= s.count('1'):\n        print(q)\n        break\n    n -= p\nelse:\n    print(-1)\n
n, k = list(map(int, input().split()))\ns = list(input())\nif len(s) == 1 and k:\n	print(0)\n	return\nif s[0] != '1' and k:\n	k -= 1\n	s[0] = '1'\nfor i in range(1, len(s)):\n	if s[i] != '0' and k:\n		s[i] = '0'\n		k -= 1\n	if not k:\n		break\nprint(''.join(s))\n\n
n0, n1, x, y = list(map(int, input().split()))\n\ndef f(m, n, x, y):\n    return max(0, n - (m // y - m // (x * y)))\n\nlo = -1\nhi = x * y * (n0 + n1)\nwhile lo + 1 < hi:\n    mid = lo + (hi - lo) // 2\n    if f(mid, n0, x, y) + f(mid, n1, y, x) <= mid - mid // x - mid // y + mid // (x * y):\n        hi = mid\n    else:\n        lo = mid\nprint(hi)\n
#Simple non-optimized class of matrices. Used with small dense matrices.\nimport functools\nimport itertools\nimport math\n\nclass NotAMatrixError(Exception):\n    pass\n\nclass MatrixSizeError(Exception):\n    def __init__(self, s1, s2):\n        print('sizes do not match : ', s1, ', ', s2)\n\nclass NotSquareError(Exception):\n    pass\n\nclass Matrix(list):\n    def __init__(self, L):\n        if type(L) == type(self):\n            self = L\n            return\n        n = len(L)\n        m = len(L[0])\n        for i in range(n):\n            if len(L[i]) != m:\n                raise NotAMatrixError()\n        list.__init__(self, L)\n        self.n = n\n        self.m = m\n        self.degrees = []\n    def check_size(self, M, mode):\n        n, m = len(M), len(M[0])\n        for i in range(n):\n            if len(M[i]) != m:\n                raise NotAMatrixError()\n        \n        if mode == 'add' and (self.n != n or self.m != m):\n            raise MatrixSizeError((self.n, self.m), (n,m))\n        if mode == 'lul' and self.m != n:\n            print(self.m, n, self.m != n)\n            raise MatrixSizeError((self.n, self.m), (n,m))\n    def __add__(self, M):\n        self.check_size(M, mode = 'add')\n        return Matrix([[self[i][j]+M[i][j] for j in range(self.m)]for i in range(self.n)])\n    def __iadd__(self, M):\n        self.check_size(M, mode = 'add')\n        for i in range(self.n):\n            for j in range(self,m):\n                self[i][j] += M[i][j]\n    def __mul__(self, M):\n        self.check_size(M, mode = 'mul')\n        l = len(M[0])\n        return Matrix([[sum(self[i][k]*M[k][j] for k in range(self.m))\n                 for j in range(l)] for i in range(self.n)])\n    def issquare(self):\n        return self.n == self.m\n    def primary(self):\n        if self.n != self.m:\n            raise NotSquareError()\n        return Matrix([[int(i==j) for j in range(self.m)] for i in range(self.n)])\n    def __pow__(self, n):\n        if self.n != self.m:\n            raise NotSquareError()\n        if n == 0:\n            return self.primary()\n        elif n == 1:\n            return self\n        if len(self.degrees) == 0:\n            self.degrees.append(self*self)\n        for i in range(n.bit_length() - len(self.degrees) - 1):\n            self.degrees.append(self.degrees[-1] * self.degrees[-1])\n        s = [(n>>i)&1 for i in range(1,n.bit_length())]\n        res = functools.reduce(lambda x,y:x*y, itertools.compress(self.degrees, s))\n        return res*self if n%2 else res \n    def drop_degrees(self):\n        self.degrees.clear()\n\nclass Remainder(int):\n    def __new__(self, n, p):\n        obj = int.__new__(self, n%p)\n        obj.p = p\n        return obj\n    def __mul__(self, m): return Remainder(int.__mul__(self, m), self.p)\n    def __add__(self, m): return Remainder(int.__add__(self, m), self.p)\n    def __sub__(self, m): return Remainder(int.__sub__(self, m), self.p)\n    def __rmul__(self, m): return Remainder(int.__rmul__(self, m), self.p)\n    def __radd__(self, m): return Remainder(int.__radd__(self, m), self.p)\n    def __rsub__(self, m): return Remainder(int.__rsub__(self, m), self.p)\n    def __neg__(self): return Remainder(int.__neg__(self), self.p)\n    def __pow__(self, m): return Remainder(int.__pow__(self, m, self.p), self.p)\n\ndef solve(n, sx, sy, dx, dy, t):\n    o, l, j = Remainder(0, n), Remainder(1, n), Remainder(2, n)\n    N = [[j, l, l, o, l, o],\n         [l, j, o, l, l, o],\n         [l, l, l, o, l, o],\n         [l, l, o, l, l, o],\n         [o, o, o, o, l, l],\n         [o, o, o, o, o, l]]\n    M = Matrix(N)\n    sx, sy, dx, dy = [Remainder(x, n) for x in [sx, sy, dx, dy]]\n    v = Matrix([[sx], [sy], [dx], [dy], [o], [l]])\n    return M ** t * v\n\nn, sx, sy, dx, dy, t = [int(x) for x in input().split()]\nans = solve(n, sx, sy, dx, dy, t)\nprint(int(ans[0][0] - 1) + 1, int(ans[1][0] - 1) + 1)\n
# You lost the game.\ns = str(input())\nn = len(s)\nA = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"\nif n < 26:\n    print(-1)\nelse:\n    for i in range(n-25):\n        ok = 1\n        F = [0 for _ in range(26)]\n        for j in range(26):\n            if s[i:i+26].count(A[j]) > 1:\n                ok = 0\n                break\n            elif s[i:i+26].count(A[j]) == 0:\n                F[j] = 1\n        if ok:\n            break\n    if ok == 0:\n        print(-1)\n    else:\n        j = 0\n        for k in range(n):\n            if s[k] == "?":\n                if k >= i and k < i+26:\n                    while F[j] == 0:\n                        j += 1\n                    print(A[j],end="")\n                    F[j] = 0\n                else:\n                    print("A",end="")\n            else:\n                print(s[k],end="")\n            \n
"""\nCodeforces Round 248 Div 2 Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\nclass InputHandlerObject(object):\n    inputs = []\n\n    def getInput(self, n = 0):\n        res = ""\n        inputs = self.inputs\n        if not inputs: inputs.extend(input().split(" "))\n        if n == 0:\n            res = inputs[:]\n            inputs[:] = []\n        while n > len(inputs):\n            inputs.extend(input().split(" "))\n        if n > 0:\n            res = inputs[:n]\n            inputs[:n] = []\n        return res\nInputHandler = InputHandlerObject()\ng = InputHandler.getInput\n\n############################## SOLUTION ##############################\nn = int(input())\na = [int(x) for x in g()]\nc100 = a.count(100)\nif sum(a) % 200:\n    print("NO")\nelif n % 2 and not c100:\n    print("NO")\nelse:\n    print("YES")
n, m = list(map(int, input().split()))\nm += 2\nl = []\ndo = False\nfor i in range(n):\n	s = input().strip()\n	if s.find('1') != -1 or do:\n		do = True\n		l.append(s)\nn = len(l)\nif n == 0:\n	print(0)\n	return\n\n\ndp = []\nfor i in range(n):\n	dp.append([None] * 2)\n\nfor i in range(n):\n	R = 0\n	for j in range(m):\n		if l[i][j] == '1':\n			R = j\n	L = m - 1\n	for j in range(m - 1, -1, -1):\n		if l[i][j] == '1':\n			L = j\n	if i == 0:\n		dp[0][0] = R\n		dp[0][1] = (m - 1 - L)\n	else:\n		dp[i][0] = min(dp[i - 1][0] + 2 * R, dp[i - 1][1] + (m - 1)) + 1\n		dp[i][1] = min(dp[i - 1][0] + (m - 1), dp[i - 1][1] + 2 * (m - 1 - L)) + 1\n# print(dp)\nprint(dp[-1][0])\n
import sys\n\nrd = lambda : sys.stdin.readline().rstrip()\n\nn = int(rd())\nc = list(map(int, rd().split()))\na = list([int(x)-1 for x in rd().split()])\n\nvisited = [-1] * (n)\nres = 0\n\nfor i in range(n):\n    trace = []\n    \n    t = i\n    mn = 1e9\n    while visited[t] == -1:\n        visited[t] = i\n        trace.append(t)\n        t = a[t]\n        \n    if visited[t] != i:\n        continue\n        \n    while len(trace) > 0:\n        v = trace.pop()\n        mn = min(mn, c[v]) \n        \n        if t == v: break\n    \n    res += mn\n    \nprint(res)\n
n, a, b = list(map(int, input().split()))\nans = a + b\nwhile ans < 0:\n    ans += n\nans %= n\nif ans == 0:\n    print(n)\nelse:\n    print(ans)\n
import sys\nimport math\n\nn = int(sys.stdin.readline())\nif n <= 2:\n  print(1)\n  return\n\na = [int(s) for s in sys.stdin.readline().split()]\n\nst = -1 # index of first positive number in current subset of a\ned = -1 # index last positive number in current subset of a \n        # differation is (a[ed] - a[st])/(ed - st)\nleading_zeros = 0 # -1 before a[st]\nseg_count = 1\n\nfor (i, v) in enumerate(a):\n  if v == -1:\n    if st == -1:\n      leading_zeros += 1\n    else:\n      if ed != -1:\n        # check if v should be a non-positive number\n        if a[ed] + (i-ed) * (a[ed] - a[st])/(ed-st) <= 0:\n          st = -1\n          ed = -1\n          leading_zeros = 1\n          seg_count += 1\n        else:\n          pass\n      else:\n        pass\n  else:\n    if st == -1:\n      st = i # find first positive number\n    else:\n      if ed == -1:\n        ed = i\n        #print(i)\n        if (v - a[st]) % (i-st) != 0 or a[st] - (v-a[st])/(i-st) * leading_zeros <= 0:\n          # a[st..i] can't be an arithmetic progression\n          st = i\n          ed = -1\n          seg_count += 1\n          leading_zeros = 0\n        else:\n          ed = i\n      else:\n        if (v-a[ed])%(i-ed) != 0 or (v-a[ed]) * (ed - st) != (a[ed] - a[st]) * (i-ed):\n          st = i\n          ed = -1\n          seg_count += 1\n          leading_zeros = 0\n        else:\n          ed = i #leave ed the first positive number after a[st] is also ok\n  #print( "[" +str(st) + " " + str(ed) + "] " + str(seg_count) + " " + str(leading_zeros) )\n\nprint(seg_count)
n, k = map(int,input().split())\ns = input()\nmaxi = 0\na = 0\nb = 0\nst = 0\nfor i in range(0, n):\n    if s[i] == 'a': a += 1\n    else: b+=1\n    if min(a, b) > k:\n        if s[st] == 'a': a-=1\n        else: b-=1\n        st += 1\n    else: maxi += 1\nprint(maxi)
n = int(input())\na = list(map(int, input().split()))\nb = [0]\nfor i in range(1, n):\n	if a[i]*2 <= a[0]:\n		b += [i]\nu=0\nv=0\nfor i in range(n):\n	if i in b:\n		u += a[i]\n	else:\n		v += a[i]\nif u > v:\n	print(len(b))\n	for x in b:\n		print(x+1, end=' ')\nelse:\n	print('0')
n=int(input())\ntot=0\nfor i in range(n):\n    tot+=1/(i+1)\nprint(tot)\n
n = int(input())\nans = []\nnxt = 1\nwhile n > 0:\n  x = nxt\n  n -= nxt\n  nxt += 1\n  if n < nxt:\n    x += n\n    n = 0\n  ans.append(str(x))\nprint(len(ans))\nprint(" ".join(ans))\n
n = int(input())\nm = int(input())\n\nprint(m % (1 << n))
n = int(input())\ns = input()\nt = []\nvowels = 'aeiouy'\nfor c in s:\n    if t and t[-1] in vowels and c in vowels:\n        continue\n    else:\n        t.append(c)\nprint(''.join(t))\n
n, a, b = list(map(int, input().split()))\ns = input()\ns += '*'\nn += 1\nm = []\ni = 0\ni1 = -1\nwhile i < len(s):\n    if s[i] == '*':\n        if i - i1 > 1:\n            m.append(i - i1 - 1)\n        i1 = i\n    i += 1\nsm = a + b\nfor c in m:\n    if c % 2 == 0:\n        a = max(0, a - c // 2)\n        b = max(0, b - c // 2)\n    else:\n        if a > b:\n            a = max(0, a - (c + 1) // 2)\n            b = max(0, b - c // 2)\n        else:\n            b = max(0, b - (c + 1) // 2)\n            a = max(0, a - c // 2)\nprint(sm - a - b)\n
r=int(input())\nif r<=4:\n    print("NO")\nelif r%2==0:\n    print("NO")\nelse :\n    print(1, (r-3)//2)
\n\nn = int(input())\n\ntab = [int(x) for x in input().split()]\n\nif n < 2 or (n == 2 and tab[0] == tab[1]):\n    print(-1)\nelse:\n    print(1)\n    print(tab.index(min(tab)) + 1)\n\n
import getpass\nimport sys\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n    # sys.stdin = open('input.txt')\n    # sys.stdout = open('output.txt', 'w')\nelse:\n    sys.stdin = open('input.txt')\n    # sys.stdin.close()\n\nn = ria()[0]\nprint(n)\nprint('1 '*n)
def main():\n    n = int(input())\n    l = list(map(int, input().split()))\n    seive = [False, True] * max(l)\n    a = len(seive)\n    for i in range(3, int(a ** .5) + 1, 2):\n        if seive[i]:\n            for j in range(i * i, a, i):\n                seive[j] = False\n    i = l.count(1)\n    if i:\n        res = [1] * i\n        for a in l:\n            if a > 1 and seive[a + 1]:\n                res.append(a)\n                break\n        if len(res) > 1:\n            print(len(res))\n            print(*res)\n            return\n    l0, l1 = [], []\n    for a in l:\n        if a != 1:\n            if a & 1:\n                for b in l0:\n                    if seive[a + b]:\n                        print(2)\n                        print(a, b)\n                        return\n                l1.append(a)\n            else:\n                for b in l1:\n                    if seive[a + b]:\n                        print(2)\n                        print(a, b)\n                        return\n                l0.append(a)\n    print(1)\n    print(l[0])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
from collections import Counter, defaultdict\nimport itertools\nimport sys\n\ndef main():\n    n = int(input())\n    ans = 1\n    for k in range(1, 10):\n        v = ((1 << k) - 1) * (1 << (k - 1))\n        if n % v == 0:\n            ans = v\n\n    print(ans)\n\nmain()\n
#!/usr/bin/env python3\n\n\n\ndef addmod(left, right, modulo=1000000007):\n    res = left + right\n    if res >= modulo:\n        res -= modulo\n    return res\n\ndef counter(a, m, d):\n    res = [0, ] * (2*m)\n    res[0] = 1\n    shift = 1\n    for pos in range(len(a), 0, -1):\n        ptype = pos & 1\n        cur = int(a[pos-1])\n        tres = [0, ] * (2*m)\n        for i in range(10):\n            if ptype==1 and i == d:\n                continue\n            if ptype==0 and i != d:\n                continue\n            k = (i * shift) % m\n            for j in range(m):\n                k2 = k*2\n                j2 = j*2\n                if i < cur:\n                    tres[k2+0] = addmod(tres[k2+0], addmod(res[j2+0], res[j2+1]))\n                elif i == cur:\n                    tres[k2+0] = addmod(tres[k2+0], res[j2+0])\n                    tres[k2+1] = addmod(tres[k2+1], res[j2+1])\n                else:\n                    tres[k2+1] = addmod(tres[k2+1], addmod(res[j2+0], res[j2+1]))\n                k = k+1 if k+1<m else 0\n        res = tres\n        shift = (shift * 10) % m\n    return res[0]\n\n\ndef solver(ifs):\n    m, d = list(map(int, ifs.readline().split()))\n    a = ifs.readline().strip()\n    b = ifs.readline().strip()\n    res = counter(b, m, d)\n    if a != '0':\n        a = str(int(a) - 1)\n        if len(a) < len(b):\n            a = '0' + a\n        modulo = 1000000007\n        res = addmod(res, modulo - counter(a, m, d))\n    print(res)\n\ndef main():\n    import sys\n    if sys.version_info.major == 3:\n        from io import StringIO as StreamIO\n    else:\n         from io import BytesIO as StreamIO\n    \n    with StreamIO(sys.stdin.read()) as ifs, StreamIO() as ofs:\n        _stdout = sys.stdout\n        sys.stdout = ofs\n        solver(ifs)\n        sys.stdout = _stdout\n        sys.stdout.write(ofs.getvalue())\n    return 0\n\ndef __starting_point():\n    main()\n\n__starting_point()
def main():\n    from collections import deque\n    \n    n, m = [int(i) for i in input().split()]\n    children = deque([0, int(v), i + 1] for i, v in enumerate(input().split()))\n    \n    while len(children) > 1:\n        tmp = children.popleft()\n        tmp[0] += m\n        if tmp[1] > tmp[0]:\n            children.append(tmp)\n    \n    print(children.popleft()[2])\n\n\nmain()\n
n=int(input())\nans=0\nans+=n//100\nn%=100\nans+=n//20\nn%=20\nans+=n//10\nn%=10\nans+=n//5\nn%=5\nans+=n\nprint(ans)\n
mod=10**9+7\nn,k=list(map(int,input().split()))\n\nA=[0]*(n+1)\nB=[0]*(n+1)\nC=[0]*(n+1)\nF=[0]*(n+1)\nG=[0]*(n+1)\n\nF[0]=G[0]=1\nfor i in range(1,n+1):\n	G[i]=F[i]=F[i-1]*i%mod\n	G[i]=pow(F[i],(mod-2),mod)\n\nfor i in range(0,n):\n	if i*2>n:\n		break\n	B[i]=(F[n-i]*G[i]*G[n-i*2])%mod\nfor i in range(0,n//2+1):\n	for j in range(0,n//2+1):\n		A[i+j]=(A[i+j]+B[i]*B[j])%mod\nfor i in range(0,n+1):\n	A[i]=A[i]*F[n-i]%mod\nfor i in range(0,n+1):\n	for j in range(0,i+1):\n		C[j]=(C[j]+A[i]*F[i]*G[j]*G[i-j]*(1-(i-j)%2*2))%mod\nprint(C[k]%mod)\n
n,k = list(map(int, input().split()))\nb = list(map(int,input().split()))\n\nSSSSSSSSSS = input()\n\nINF = 1000*1000*1000+123\nRRRR = [];\nWWWWWWW = [];\nOOOOOOOOO = [];\n\nfor i in range(n):\n    if SSSSSSSSSS[i] == 'R':\n        RRRR.append(b[i])\n    elif SSSSSSSSSS[i] == 'W':\n        WWWWWWW.append(b[i])\n    else:\n        OOOOOOOOO.append(b[i])\n\n\n\nWWWWWWW.sort()\n\nRRRR.sort()\nWWWWWWW.reverse()\nRRRR.reverse()\nOOOOOOOOO.sort()\nOOOOOOOOO.reverse()\n\nif k == 1:\n    print(-1)\n    return\n\n\ndef cccmcmc(A, B):\n    qanakA = len(A);\n    qanakB = len(B);\n\n    pA = [0 for i in range(qanakA)]\n    pB = [0 for i in range(qanakB)]\n    pB[0] = B[0]\n    pA[0] = A[0]\n\n    for i in range(1,qanakA):\n        pA[i] = pA[i-1] + A[i];\n    for i in range(1,qanakB):\n        pB[i] = pB[i-1] + B[i];\n\n    res = -1\n\n    for i in range(1,min(qanakA+1,k)):\n        aic = pA[i-1]\n        bepetk = k-i\n        if bepetk <= 0 or bepetk > qanakB: continue\n        bic = pB[bepetk-1]\n        res = max(res,aic+bic)\n    return res\n\n\nres = -1\n\nif len(WWWWWWW) > 0 and len(OOOOOOOOO)> 0:\n    res = max(res, cccmcmc(WWWWWWW, OOOOOOOOO))\nif len(RRRR) > 0 and len(OOOOOOOOO)> 0:\n    res = max(res, cccmcmc(RRRR, OOOOOOOOO))\n\nprint(res)\n
#!/usr/bin/env python3\n\nfrom fractions import Fraction\n\ndef __starting_point():\n    p, q = list(map(int, input().split()))\n    n = int(input())\n    l = list(map(int, input().split()))\n\n    f = Fraction(l[-1], 1)\n\n    for x in l[-2::-1]:\n        f = 1 / f\n        f += x\n\n    print(["NO", "YES"][f == Fraction(p, q)])\n\n\n\n__starting_point()
t = input()\nk = t.find('=')\nn = 2 * k - len(t)\nif n == 2:\n    if t[1] != '+': t = t[1: ] + '|'\n    else: t = t[: k - 1] + t[k: ] + '|'\nelif n == -2: t = '|' + t[: -1]\nelif n != 0: t = 'Impossible'\nprint(t)
import numpy as np\n\n\ndef solve(n, k):\n    if k % 2 == 1:\n        return 0\n    k //= 2\n\n    MOD = 10 ** 9 + 7\n\n    dp = np.zeros((1, k + 1), dtype=np.int64)\n    dp[0, 0] = 1\n    for i in range(1, n + 1):\n        max_d = min(i + 1, n - i + 1, k + 1)\n        ndp = np.zeros((max_d, k + 1), dtype=np.int64)\n        for d, ks in enumerate(dp):\n            base = ks[:k - d + 1]\n            if d > 0:\n                ndp[d - 1, d:] += base * d ** 2\n            if max_d > d:\n                ndp[d, d:] += base * (2 * d + 1)\n            if max_d > d + 1:\n                ndp[d + 1, d:] += base\n        dp = ndp % MOD\n\n    return dp[0, k]\n\n\nn, k = list(map(int, input().split()))\nprint((solve(n, k)))\n
N = int(input())\nP = [tuple(map(int, input().split())) for _ in range(N)]\n\nodd = []\nfor (x, y) in P:\n    dist = abs(x) + abs(y)\n    odd.append(dist % 2 != 0)\n\nvalid = True\neven = False\nif all(odd):\n    pass\nelif not any(odd):\n    even = True\nelse:\n    valid =False\n\nif valid:\n\n    M = 31\n    if even:\n        print((M+1))\n        print((*([1 << m for m in range(M)] + [1])))\n    else:\n        print(M)\n        print((*[1 << m for m in range(M)]))\n\n    for (x, y) in P:\n        u = x + y\n        v = x - y\n        if even:\n            u += 1\n            v += 1\n        if u >= 0 and v >= 0:\n            A = 'R'\n            B = 'U'\n            C = 'D'\n            D = 'L'\n        elif u >= 0 and v < 0:\n            v *= -1\n            A = 'U'\n            B = 'R'\n            C = 'L'\n            D = 'D'\n        elif u < 0 and v >= 0:\n            u *= -1\n            A = 'D'\n            B = 'L'\n            C = 'R'\n            D = 'U'\n        elif u < 0 and v < 0:\n            u *= -1\n            v *= -1\n            A = 'L'\n            B = 'D'\n            C = 'U'\n            D = 'R'\n\n        ans = ''\n        wa = ((1 << M) - 1 - u) // 2\n        sa = ((1 << M) - 1 - v) // 2\n        for i in range(M):\n            check = str(wa >> i & 1) + str(sa >> i & 1)\n            if check == '00':\n                ans += A\n            elif check == '01':\n                ans += B\n            elif check == '10':\n                ans += C\n            elif check == '11':\n                ans += D\n        if even:\n            ans += 'L'\n        print(ans)\nelse:\n    print((-1))\n
from sys import *\nn = int(input())\na = input()\ns = 0\ni = 0\nwhile i <= n-1:\n    if s == 0:\n        if a[i:i+3] == 'ogo':\n            s = 1\n            print('***', end = '')\n            i+=3\n        else:\n            print(a[i], end = '')\n            i += 1\n            \n    else:\n        if a[i:i+2] == 'go':\n            i += 2\n        else:\n            s = 0
x, n = list(map(int, input().split()))\n\ndef primeFactor(N):\n    i, n, ret, d, sq = 2, N, {}, 2, 99\n    while i <= sq:\n        k = 0\n        while n % i == 0: n, k, ret[i] = n//i, k+1, k+1\n        if k > 0 or i == 97: sq = int(n**(1/2)+0.5)\n        if i < 4: i = i * 2 - 1\n        else: i, d = i+d, d^6\n    if n > 1: ret[n] = 1\n    return ret\n\npf = primeFactor(x)\nmod = 10 ** 9 + 7\ndef calc(p):\n    s = 0\n    a = n//p\n    while a:\n        s += a\n        a //= p\n    return pow(p, s, mod)\n\nans = 1\nfor p in pf:\n    ans = ans * calc(p) % mod\nprint(ans)\n\n\n
a, b, c = list(map(int, input().split()))\nans = []\nfor sum in range(1, 200):\n    x = b * sum ** a + c\n    if x <= 0 or x >= 10 ** 9:\n        continue\n    summ = 0\n    for aa in str(x):\n        summ += int(aa)\n    if sum == summ:\n        ans.append(x)\nprint(len(ans))\nprint(*ans)\n
l=list(map(int,input().split()))\nl.insert(0,0)\nc1=[1,6,3,8,5,10,7,12,9,23,11,21,13,14,15,16,17,18,19,20,4,22,2,24]\nc2=[1,23,3,21,5,2,7,4,9,6,11,8,13,14,15,16,17,18,19,20,12,22,10,24]\nc3=[1,2,3,4,5,6,15,16,9,10,11,12,13,14,23,24,17,18,7,8,21,22,19,20]\nc4=[1,2,3,4,5,6,19,20,9,10,11,12,13,14,7,8,17,18,23,24,21,22,15,16]\nc5=[1,2,16,14,5,6,7,8,19,17,11,12,13,9,15,10,3,18,4,20,21,22,23,24]\nc6=[1,2,17,19,5,6,7,8,14,16,11,12,13,4,15,3,10,18,9,20,21,22,23,24]\nflag=0\nmark=0\nfor i in range(6):\n	if(l[c1[4*i]] == l[c1[4*i+1]] == l[c1[4*i+2]] == l[c1[4*i+3]]):\n		mark=1\n	else:\n		mark=0\n		break\nif(mark):\n	flag=1\n\nmark=0\nfor i in range(6):\n	if(l[c2[4*i]] == l[c2[4*i+1]] == l[c2[4*i+2]] == l[c2[4*i+3]]):\n		mark=1\n	else:\n		mark=0\n		break\nif(mark):\n	flag=1\n\nmark=0\nfor i in range(6):\n	if(l[c3[4*i]] == l[c3[4*i+1]] == l[c3[4*i+2]] == l[c3[4*i+3]]):\n		mark=1\n	else:\n		mark=0\n		break\nif(mark):\n	flag=1\n\nmark=0\nfor i in range(6):\n	if(l[c4[4*i]] == l[c4[4*i+1]] == l[c4[4*i+2]] == l[c4[4*i+3]]):\n		mark=1\n	else:\n		mark=0\n		break\nif(mark):\n	flag=1\n\nmark=0\nfor i in range(6):\n	if(l[c5[4*i]] == l[c5[4*i+1]] == l[c5[4*i+2]] == l[c5[4*i+3]]):\n		mark=1\n	else:\n		mark=0\n		break\nif(mark):\n	flag=1\n\nmark=0\nfor i in range(6):\n	if(l[c6[4*i]] == l[c6[4*i+1]] == l[c6[4*i+2]] == l[c6[4*i+3]]):\n		mark=1\n	else:\n		mark=0\n		break\nif(mark):\n	flag=1\n\nif(flag):\n	print("YES")\nelse:\n	print("NO")\n
from math import ceil\n\np,x,y = map(int, input().split())\nh = x\nwhile h >=y:\n    h-=50\nh+=50\nfor i in range(h, 10000000000, 50):\n    u = (i//50)%475\n    d = []\n    for j in range(25):\n        u = (u * 96 + 42)%475\n        d.append(26 + u)\n    if p in d:\n        k = i\n        break\nif k-x>0:\n    print(ceil((k-x)/100))\nelse:\n    print(0)
'''input\n1\n2\n3\n5\n'''\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\ncur = 0\npos = 0\nfor i in range(n-1):\n    if pos == 0:\n        if a < b:\n            pos = 1\n            cur += a\n        else:\n            pos = 2\n            cur += b \n    elif pos == 1:\n        if a < c: \n            pos = 1\n            cur += a\n        else:\n            pos = 3\n            cur += c\n    else:\n        if b < c: \n            pos = 2\n            cur += b\n        else:\n            pos = 3\n            cur += c                     \nprint(cur)            
l = list(map(int, input().split()))\n\nprint(max(l) - min(l))
n, x = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = [0] * 1000000\nans = 0\ngo = False\n\nfor i in a:\n    b[i] += 1\n    if b[i] > 1:\n        go = True\n\nif go:\n    print(ans)\nelse:\n    for i in a:\n        b[i] -= 1\n        if b[i & x] + 1 > 1:\n            go = True\n            ans = 1\n            break\n        \n        b[i] += 1\n    \n    if go:\n        print(ans)\n    else:\n        c = [i & x for i in a]\n        b = [0] * 1000000\n        for i in c:\n            b[i] += 1\n            if (b[i] > 1):\n                ans = 2\n                go = True\n                break\n        if go:\n            print(ans)\n        else:\n            print(-1)\n
h,w = map(int,input().split())\ns = [list(input()) for i in range(h)]\nhh = -1\ntmp = -1\nfor k,i in enumerate(s):\n    a = i.count('*')\n    if tmp < a:\n        tmp = a\n        hh = k\n\nt = [list(i) for i in list(zip(*s))]\nww = -1\ntmp = -1\nfor k,i in enumerate(t):\n    a = i.count('*')\n    if tmp < a:\n        tmp = a\n        ww = k\n\nif s[hh][ww] != '*':\n    print('NO')\n    return\n\nif hh in (0, h - 1) or ww in (0, w - 1):\n    print('NO')\n    return\n\nif '.' in (s[hh-1][ww], s[hh+1][ww], s[hh][ww-1], s[hh][ww+1]):\n    print('NO')\n    return\n\ncnt = 1\nfor i in range(hh - 1, -1, -1):\n    if s[i][ww] == '.':\n        break\n    cnt += 1\nfor i in range(ww - 1, -1, -1):\n    if s[hh][i] == '.':\n        break\n    cnt += 1\nfor i in range(hh + 1, h):\n    if s[i][ww] == '.':\n        break\n    cnt += 1\nfor i in range(ww + 1, w):\n    if s[hh][i] == '.':\n        break\n    cnt += 1\n\nfor i in range(h):\n    for j in range(w):\n        cnt -= (s[i][j] == '*')\n\nif cnt != 0:\n    print('NO')\nelse:\n    print('YES')
n, a, b = map(int,input().split())\nif a>1 and b>1: print("NO"); return\nif 2<=n<=3 and a == b == 1: print("NO"); return\nprint("YES")\n\nif b == 1:\n    adj = [[0]*n for i in range(n)]\n    conn = n\n    for i in range(n):\n        if conn == a: break\n        adj[i][i+1] = adj[i+1][i] = 1\n        conn-= 1\n        if conn == a: break\nelif a == 1:\n    adj = [[1]*n for i in range(n)]\n    conn = n\n    for i in range(n): adj[i][i] = 0\n    for i in range(n):\n        if conn == b: break\n        adj[i][i+1] = adj[i+1][i] = 0\n        conn-= 1\n        if conn == b: break\n\nfor row in adj:\n    print(*row, sep='')\n
c,d=list(map(int,input().split()))\n\nn,m=list(map(int,input().split()))\n\nk=int(input())\n\nz=0\nbest=10**10\nwhile(1):\n    x=n*m-k\n    x-=z*n\n    best=min(best,z*c+(max(x,0)*d))\n    if(x<0):\n        break\n    z+=1\nprint(best)\n    \n
3\n\ns = input()\nn = len(s)\n\na, b = 0, 0\nd = dict()\nfor i in range(len(s)):\n    if s[i] in d:\n        a = d[s[i]]\n        b = i\n    d[s[i]] = i\n\nif a == b - 1:\n    print("Impossible")\nelse:\n    ans = [[' '] * 13 for i in range(2)]\n    if (b - a) % 2 == 1:\n        for i in range((b - a) // 2):\n            ans[0][-(b - a) // 2 + i + 1] = s[a + i + 1]\n            ans[1][-i - 1] = s[a + i + (b - a) // 2 + 1]\n        x = -(b - a) // 2\n        y = 0\n        for i in range(b, n):\n            ans[y][x] = s[i]\n            if y == 0:\n                x -= 1\n            else:\n                x += 1\n            if x == -14:\n                y = 1\n                x = 0\n        for i in range(a):\n            ans[y][x] = s[i]\n            if y == 0:\n                x -= 1\n            else:\n                x += 1\n            if x == -14:\n                y = 1\n                x = 0\n        print("".join(ans[0]))\n        print("".join(ans[1]))\n    else:\n        for i in range((b - a) // 2):\n            ans[0][-(b - a) // 2 + i + 1] = s[a + i + 1]\n            ans[1][-i - 1] = s[a + i + (b - a) // 2]\n        x = -(b - a) // 2\n        y = 0\n        for i in range(b, n):\n            ans[y][x] = s[i]\n            if y == 0:\n                x -= 1\n            else:\n                x += 1\n            if x == -14:\n                y = 1\n                x = 0\n        for i in range(a):\n            ans[y][x] = s[i]\n            if y == 0:\n                x -= 1\n            else:\n                x += 1\n            if x == -14:\n                y = 1\n                x = 0\n        print("".join(ans[0]))\n        print("".join(ans[1]))\n\n\n\n
import math\n\nx, y = [int(v) for v in input().split()]\n\nxly = x * math.log(y)\nylx = y * math.log(x)\n\nif abs(xly - ylx) < 1e-8:\n    print('=')\nelif ylx < xly:\n    print('<')\nelse:\n    print('>')\n
from math import *\n\nr, h = list(map(int, input().split()))\nd = h % r\n\nif d * 2 < r:\n    print(h // r * 2 + 1)\nelif sqrt(3) * (r / 2) + r - 1e-6 <= d + r:\n    print(h // r * 2 + 3)\nelse:\n    print(h // r * 2 + 2)\n
cards = list(map(int, input().split()))\n\nresult = sum(cards)\n\nfor i in range(5):\n    cnt = cards.count(cards[i])\n    cnt = min(cnt, 3)\n    if cnt not in [2, 3]:\n        continue\n    result = min(result, sum(cards) - cnt * cards[i])\n\nprint(result)\n
from math import *\nn, a = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\nif n == 1:\n    print(0)\n    \nelse:\n    if a > A[-1]:\n        print(abs(a - A[1]))\n    elif a < A[0]:\n        print(abs(a - A[-2]))\n    else:\n        per1 = abs(A[0] - A[-2])\n        per2 = abs(A[1] - A[-1])\n        ans1 = abs(A[0] - a) + per1\n        ans2 = per1 + abs(A[-2] - a)\n        ans3 = per2 + abs(a - A[-1])\n        ans4 = per2 + abs(a - A[1])\n        print(min(ans1, ans2, ans3, ans4))
import re\nimport itertools\nfrom collections import Counter, deque\n\nclass Task:\n    maxDigitSum = 18 * 9\n    n = 0\n    answer = "" \n	\n    def getData(self):\n        self.n = int(input())\n        #inFile = open('input.txt', 'r')\n        #inFile.readline().rstrip()\n        #self.childs = inFile.readline().rstrip()\n\n    def solve(self):\n        if self.n == 1:\n            self.answer = '-1'\n            return\n\n        xL, xR = 0, self.n\n        while xL + self.maxDigitSum < xR:\n            xM = (xL + xR) // 2\n            if xM**2 + self.digitSum(xM) * xM < self.n:\n                for x in range(xM - 1, max(xL, xM - self.maxDigitSum) - 1, -1):\n                    if x**2 + self.digitSum(x) * x == self.n:\n                        self.answer = x\n                        return\n                xL = xM\n            else:\n                for x in range(xM + 1, min(xR, xM + self.maxDigitSum) + 1):\n                    if x**2 + self.digitSum(x) * x == self.n:\n                        self.answer = x\n                        return\n                xR = xM\n        for x in range(xL, xR + 1):\n            if x**2 + self.digitSum(x) * x == self.n:\n                self.answer = x\n                return\n        self.answer = -1\n\n    def digitSum(self, n):\n        return sum([int(x) for x in str(n)])\n\n    def printAnswer(self):\n        print(self.answer)\n        #outFile = open('output.txt', 'w')\n        #outFile.write(self.answer)\n\ntask = Task()\ntask.getData()\ntask.solve()\ntask.printAnswer()\n
s = input()\nt = input()\na, b = int(s[:2]), int(s[3:])\nc, d = int(t[:2]), int(t[3:])\na -= c\nb -= d\nif b < 0:\n    a -= 1\n    b = 60 + b\nif a < 0:\n    a = 24 + a\nif a < 10:\n    print(0, end = '')\nprint(a, ':', end = '', sep = '')\nif b < 10:\n    print(0, end = '')\nprint(b)\n
n = int(input())\na = list(map(int,input().split()))\nm = max(a)\n\ncurrent = 0\nlongest = 0\nfor x in a:\n    if x == m:\n        current +=1\n    else:\n        longest = max(current,longest)\n        current = 0\nlongest = max(current,longest)\nprint (longest)\n\n
import math\nn,m,k=map(int,input().split())\nout=1\nfor i in range(k):\n    out*=(m-1)\n    out%=998244353\nout*=m\nout%=998244353\nout*=(math.factorial(n-1)//math.factorial(k)//math.factorial(n-1-k))\nout%=998244353\nprint(out)
n = input()\ngood = True\nwhile n != '' and good:\n    if n.endswith('144'):\n        n = n[:-3]\n    elif n.endswith('14'):\n        n = n[:-2]\n    elif n.endswith('1'):\n        n = n[:-1]\n    else:\n        good = False\nprint('YES' if good else 'NO')\n
n,m,i,j,a,b=list(map(int,input().split()))\n\nans=100000000000\n\nif((i,j)==(n,1) or (i,j)==(1,1) or (i,j)==(1,m) or (i,j)==(n,m)):\n    print(0)\n\nelse:\n    #Corner (1,1)\n\n    hor=i-1\n    ver=j-1\n\n    if(hor%a==0 and ver%b==0):\n        x=hor//a\n        y=ver//b\n        if(x%2==y%2 and a<=n-1 and b<=m-1):\n            ans=min(ans,max(x,y))\n\n    #Corner (n,m)\n\n    hor=abs(i-n)\n    ver=abs(j-m)\n\n    if(hor%a==0 and ver%b==0):\n        x=hor//a\n        y=ver//b\n        if(x%2==y%2 and a<=n-1 and b<=m-1):\n            ans=min(ans,max(x,y))\n\n    #Corner (1,m)\n\n    hor=i-1\n    ver=abs(j-m)\n\n    if(hor%a==0 and ver%b==0):\n        x=hor//a\n        y=ver//b\n        if(x%2==y%2 and a<=n-1 and b<=m-1):\n            ans=min(ans,max(x,y))\n\n    #Corner (n,1)\n\n    hor=abs(n-i)\n    ver=j-1\n\n    if(hor%a==0 and ver%b==0):\n        x=hor//a\n        y=ver//b\n        if(x%2==y%2 and a<=n-1 and b<=m-1):\n            ans=min(ans,max(x,y))\n    if(ans!=100000000000):\n        print(ans)\n    else:\n        print("Poor Inna and pony!")\n        \n
from sys import stdin\ninput = stdin.readline\n\nn = int(input())\ns = list(input().strip())\n\nfor i in range(26):\n    char = chr(ord('z') - i)\n    prev = chr(ord('z') - i - 1)\n\n    updated = True\n    while updated:\n        updated = False\n        for idx in range(len(s)-1, -1, -1):\n            if s[idx] == char:\n                if idx < len(s)-1 and s[idx+1] == prev:\n                    s.pop(idx)\n                    updated = True\n                elif idx > 0 and s[idx-1] == prev:\n                    s.pop(idx)\n                    updated = True\n\nprint( n - len(s))\n\n
n, k = map(int, input().split())\na = set(map(int, input().split()))\nq = int(input())\n\n# def isIn(x, fm, to):\n# 	if fm >= to:\n# 		return a[fm] == x\n# 	t = a[(fm+to) // 2]\n# 	if t > x:\n# 		return isIn(x, fm, (fm+to) // 2 - 1)\n# 	elif t < x:\n# 		return isIn(x, (fm+to) // 2 + 1, to)\n# 	else:\n# 		return True\n\nfor _ in range(q):\n	x = int(input())\n	if x in a:\n		print(1)\n		continue\n	found = False\n	for i in range(2, k + 1):\n		for j in range(1, i // 2 + 1):\n			for l in a:\n				t = x - l * j\n				if t % (i - j) != 0:\n					continue\n				# if isIn(t // (i - j), 0, n - 1):\n				if t // (i - j) in a:\n					print(i)\n					found = True\n					break\n			if found:\n				break\n		if found:\n			break\n	if not found:\n		print(-1)
#!/usr/bin/env python3\n\ndef main():\n    try:\n        while True:\n            s, x1, x2 = list(map(int, input().split()))\n            t1, t2 = list(map(int, input().split()))\n            p, d = list(map(int, input().split()))\n\n            def travel(src, trg):\n                nonlocal d\n                if src == trg:\n                    return 0\n                if src < trg:\n                    if d > 0:\n                        return trg - src\n                    else:\n                        d = 1\n                        return trg + src\n                else:\n                    if d < 0:\n                        return src - trg\n                    else:\n                        d = -1\n                        return s - src + s - trg\n\n            a = travel(p, x1)\n            b = travel(x1, x2)\n            print("%d" % min(abs(x1 - x2) * t2, (a + b) * t1))\n\n    except EOFError:\n        pass\n\nmain()\n
n, x = map(int, input().split())\nans = 0\nfor i in range(n, 0, -1):\n    if x % i == 0 and x//i <= n:\n        ans += 1\nprint(ans)
n, k = map(int, input().split())\nprint(('abcdefghijklmnopqrstuvwxyz'[:k] * n)[:n])
import sys, math\nn=int(input())\ns=input()\nz=list(map(int,input().split()))\nbest = 10**9\nfor i in range(len(s)-1):\n    if s[i]=='R' and s[i+1]=='L':\n        best=min(best, z[i+1]-(z[i]+z[i+1])//2)\nif best != 10**9:\n    print(best)\nelse:\n    print(-1)\n
R=lambda:list(map(int,input().split()))\nn,a,b=R()\nxy = [R() for _ in range(n)]\nans = 0\ndef f(xy1, xy2):\n    tans = 0\n    for _ in range(2):\n        for __ in range(2):\n            if (xy1[0]+xy2[0]<=a and max(xy1[1], xy2[1])<=b) or\\n                (max(xy1[0], xy2[0])<=a and xy1[1]+xy2[1]<=b):\n                tans=max(tans, xy1[0]*xy1[1] + xy2[0]*xy2[1])\n            xy2[0], xy2[1] = xy2[1], xy2[0]\n        xy1[0], xy1[1] = xy1[1], xy1[0]\n    return tans\nfor i in range(n):\n    for j in range(i+1,n):\n        ans=max(ans, f(xy[i], xy[j]))\nprint(ans)\n
#!/usr/bin/env python\nimport sys\n\nn = int(input())\nk = (n << 2) + 1\n\nx, y = [], []\nfor i in range(k):\n    xi, yi = list(map(int, input().split()))\n    x.append(xi)\n    y.append(yi)\n\nfor lx in range(0, 50):\n    for ly in range(0, 50):\n        for side_len in range(1, 51):\n            ok, idx = True, -1\n            for i in range(k):\n                if not (((x[i] == lx or x[i] == lx + side_len) and ly <= y[i] <= ly + side_len) or\n                    ((lx <= x[i] <= lx + side_len) and (y[i] == ly or y[i] == ly + side_len))):\n                    if idx != -1:\n                        ok = False\n                    else:\n                        idx = i\n            if ok:\n                print(x[idx], y[idx])\n                return\n
n = int(input())\ndef p(x):\n    ans = 1\n    while x > 0:\n        ans *= x % 10\n        x //= 10\n    return ans\nans = p(n)\nfor i in range(len(str(n))):\n    cans = 9 ** i * p((n // 10 ** i) - 1)\n    ans = max(ans, cans)\nprint(ans)\n
n = int(input())\na = list(map(int,input().split()))\ns = sum(a)\nfor k in range(max(a), 999999):\n    vote = sum(k-x for x in a)\n    if vote > s: print(k); break
s = input()\n\ncur_len = 1\na = []\nchar = []\nfor i in range(1, len(s)):\n    if s[i] == s[i-1]: cur_len += 1\n    else:\n      a.append(cur_len)\n      char.append(s[i-1])\n      cur_len = 1\n      \na.append(cur_len)\nchar.append(s[len(s)-1])\n\nans = 0\nwhile len(a) > 1:\n    n = len(a)\n    inner_min = 100000000\n    for i in range(1,n-1):\n        if a[i] < inner_min: inner_min = a[i]\n        \n    k = min(a[0], a[n-1],(inner_min + 1)//2)\n    #print("a: ", a, "; k = ", k)\n    b = []\n    new_char = []\n    for i in range(n):\n        if i == 0 or i == n-1:\n            if a[i] > k:\n                b.append(a[i]-k)\n                new_char.append(char[i])\n        else:\n            if a[i] > 2*k:\n                b.append(a[i] - 2*k)\n                new_char.append(char[i])\n##    print(b)\n    ans += k\n    if len(b) > 1:\n        c = [0]*n\n        newnew_char = [new_char[0]]\n        count = 0\n    \n        for i in range(0,len(b)-1):\n            c[count] += b[i]\n            if new_char[i] == new_char[i+1]: continue\n            else:\n                count += 1\n                newnew_char.append(new_char[i+1])\n        if new_char[len(b)-2] == new_char[len(b) - 1]: c[count] += b[len(b)-1]\n        else:\n            #count += 1\n            newnew_char.append(new_char[i+1])\n            c[count] = b[len(b)-1]\n        a = c[:count+1]\n        char = newnew_char[:]\n    else:\n        a = b[:]\n\nprint(ans)\n        \n
n=int(input())\ninp=input().split()\nl=[]\nfor val in inp:\n	l.append(int(val))\nl.sort()\ncount=3\nwhile(count<n and l[count]==l[count-1]):\n	count+=1\nif(l[2]!=l[1]):\n	print(count-2)\nelif(l[2]!=l[0]):\n	print(((count-1)*(count-2))//2)\nelse:\n	print((count*(count-1)*(count-2))//6)
n=int(input())+1\nif n==1: print(0)\nelse: print(n if n%2==1 else n//2)\n
n = int(input())\nif n >= 0:\n    print(n)\nelse:\n    n = str(n)\n    print(max(int(n[:-1]), int(n[:-2] + n[-1])))\n
a, b = input().split(' ')\nn = int(input())\n\nd = {'v': 0, '>': 1, '^': 2, '<': 3}\n\na, b = d[a], d[b]\n\nccw = bool((a + n) % 4 == b)\ncw = bool((a - n) % 4 == b)\n\nif cw and not ccw:\n	print('cw')\nelif ccw and not cw:\n	print('ccw')\nelse:\n	print('undefined')\n
n = int(input())\na = input().strip()\nnextl = [-1] * n\nlastr = [-1] * n\nll = -1\nfor i in range(n):\n    if a[i] == "R":\n        ll = i\n    if a[i] == "L":\n        ll = -1\n    lastr[i] = ll\nnl = -1\nfor i in range(n - 1, -1, -1):\n    if a[i] == "L":\n        nl = i\n    if a[i] == "R":\n        nl = -1\n    nextl[i] = nl\nans = 0\n#print(lastr)\n#print(nextl)\nfor i in range(n):\n    if nextl[i] == lastr[i] == -1:\n        ans += 1\n    if nextl[i] == -1 or lastr[i] == -1:\n        continue\n    d1 = nextl[i] - i\n    d2 = i - lastr[i]\n    if d1 == d2:\n        ans += 1\nprint(ans)
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\nn,m=map(int,input().split())\n\nl=list(map(int,input().split()))\nfor i in range(len(l)):\n    l[i]-=1\n\nuse=[0]*n\na=[0]*n\nbad=0\n\nfor i in range(len(l)-1):\n    # transfer l[i] to l[i+1]\n    if a[l[i]] and a[l[i]]%n!=(l[i+1]-l[i])%n:\n        bad=1\n        break\n    use[(l[i+1]-l[i])%n]=1\n    a[l[i]]=(l[i+1]-l[i])%n\n    if a[l[i]]==0: a[l[i]]=n\n\nif not bad:\n    # fill in gaps\n    for i in range(n):\n        if a[i]==0:\n            for j in range(1,n+1):\n                if not use[j%n]:\n                    a[i]=j\n                    use[j%n]=1\n                    break\n    if sum(use)==n:\n        print(" ".join(map(str,a)))\n    else:\n        print("-1")\nelse:\n    print("-1")
a, k = input().split()\nk = int(k)\na = [i for i in a]\ni = 0\nwhile k > 0 and i < len(a):\n    m = a[i : i + k + 1].index(max(a[i : i + k + 1]))\n    if a[i + m] > a[i]:\n        k -= m\n        for j in range(i + m, i, -1):\n            a[j], a[j - 1] = a[j - 1], a[j]\n    i += 1\nprint("".join(a))
def isZ(a):\n    return a == int(a)\ndef geom(a,b,c,d):\n    if 0 in (a,b,c,d) and not (a==b==c==d==0):\n        return False\n    if(b/a==c/b==d/c):\n        nxt = d * (d/c)\n        if not isZ(nxt): return False\n        print(int(nxt))\n        return True\n    return False\ndef ar(a,b,c,d):\n    if(b-a==c-b==d-c):\n        print(int(2*d-c))\n        return True\n    return False\n\na,b,c,d = map(float,input().split())\nif not geom(a,b,c,d) and not ar(a,b,c,d):\n    print(42)
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return tuple(map(int, sys.stdin.readline().split()))\ndef LLI(): return [tuple(map(int, l.split())) for l in sys.stdin]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    n = I()\n    a = LI()\n    b = a[0]\n    c = a[-1]\n    r = 0\n    for i in range(n-1,-1,-1):\n        if a[i] != b:\n            r = i\n            break\n\n    for i in range(n):\n        if a[i] != b:\n            t = n-1 - i\n            if r < t:\n                r = t\n\n    return r\n\nprint(main())\n\n\n
n, m, k = list(map(int, input().split()))\nprint((k - 1) // (2 * m) + 1, end=" ")\nprint((k - 1) % (2 * m) // 2 + 1, end=" ")\nif ((k - 1) % (2 * m) % 2 == 0):\n    print("L")\nelse:\n    print("R")\n
def main():\n    n = int(input())\n    s = input()\n    \n    b, g, r = [s.count(i) for i in "BGR"]\n    \n    if min(b, g, r) > 0:\n        print("BGR")\n        return\n    if max(b, g, r) == n:\n        if b == n: print("B")\n        if g == n: print("G")\n        if r == n: print("R")\n        return\n    if max(b, g, r) == 1:\n        if b == 0: print("B")\n        if g == 0: print("G")\n        if r == 0: print("R")\n        return\n    if max(b, g, r) == n - 1:\n        if b == n - 1: print("GR")\n        if g == n - 1: print("BR")\n        if r == n - 1: print("BG")\n        return \n    \n    print("BGR")\n    \n    \nmain()
def dfs(v, x, y, t, l, pr):\n    ans[v] = x, y\n    nx = [(l, 0), (0, -l), (-l, 0), (0, l)]\n    if t == 0: p = 0, 1, 3\n    if t == 1: p = 0, 1, 2\n    if t == 2: p = 1, 2, 3\n    if t == 3: p = 0, 2, 3\n    listv = [u for u in g[v] if u != pr]\n    g[v] = listv[:]\n    for i in range(min(len(p), len(g[v]))):\n        dx = nx[p[i]][0]\n        dy = nx[p[i]][1]\n        newx = x + dx\n        newy = y + dy\n        u = g[v][i]\n        dfs(u, newx, newy, p[i], l // 4, v)\n\nread = lambda: map(int, input().split())\nn = int(input())\ng = [list() for i in range(n + 1)]\nfor i in range(n - 1):\n    u, v = read()\n    g[u].append(v)\n    g[v].append(u)\ndef fail():\n    print('NO')\n    return\nroot = 1\nfor i in range(n + 1):\n    if len(g[i]) > 4:\n        fail()\n    if len(g[i]) > len(g[root]):\n        root = i\nans = [0] * (n + 1)\nans[root] = (0, 0)\ninf = 10 ** 18\nl = inf // 4\nnx = [(l, 0), (0, -l), (-l, 0), (0, l)]\nfor i in range(len(g[root])):\n    dx = nx[i][0]\n    dy = nx[i][1]\n    newx = 0 + dx\n    newy = 0 + dy    \n    dfs(g[root][i], newx, newy, i, l // 4, root)\nprint('YES')\n[print(*i) for i in ans[1:]]
def f(n, mod):\n    res = 0\n    n1 = 1\n    n2 = 2\n    k = 1\n    now = 0\n    while n >= k:\n        if now == 0:\n            now = 1\n            res = (res + n1 * k + (k * (k - 1))) % mod\n            n -= k\n            k *= 2\n            n1 = n1 + k\n        else:\n            now = 0\n            res = (res + n2 * k + (k * (k - 1))) % mod\n            n -= k\n            k *= 2\n            n2 = n2 + k\n    if n == 0:\n        return res\n    if now == 0:\n        return (res + n1 * n + (n * (n - 1))) % mod\n    return (res + n2 * n + (n * (n - 1))) % mod\n\nl, r = list(map(int, input().split()))\nmod = 10 ** 9 + 7\nprint((f(r, mod) - f(l - 1, mod)) % mod)\n
def read_ints():\n	return [int(i) for i in input().split()]\n\ncoords = read_ints()\na, b, c = [(coords[i], coords[i + 1]) for i in range(0, len(coords), 2)]\ndef length_sqr(a, b):\n	return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\nif length_sqr(a, b) != length_sqr(b, c):\n	print('No')\nelif (c[0] - b[0]) * (b[1] - a[1]) == (c[1] - b[1]) * (b[0] - a[0]):\n	print('No')\nelse:\n	print('Yes')
def main():\n    import sys\n    from collections import defaultdict\n    \n    tokens = [int(i) for i in sys.stdin.read().split()]\n    tokens.reverse()\n    \n    n, k = tokens.pop(), tokens.pop()\n    \n    d1 = defaultdict(int)\n    d2 = defaultdict(int)\n    result = 0\n    for i in tokens:\n        result += d2[i * k]\n        d2[i] += d1[i * k]\n        d1[i] += 1\n    \n    print(result)\n    \n    \nmain()\n
# python3\nfrom sys import stdin\nfrom collections import namedtuple\n\n\ndef readline(): return tuple(map(int, input().split()))\n\n\nn, a, b = readline()\nhand = [tuple(map(int, line.split())) for line in stdin.readlines()]\n\nif not b:\n    print(sum(creature[1] for creature in hand))\nelse:\n    hand.sort(key=lambda self: self[0] - self[1])\n\n    best = 0\n    if n > b:\n        l = hand[n - b]\n        lost = max(0, l[0] - l[1])\n        for creature in hand[:n-b]:\n            best = max(best, (creature[0] << a) - creature[1] - lost)\n\n    for creature in hand[max(0,n-b):]:\n        best = max(best, (creature[0] << a) - max(creature))\n\n    print((sum(creature[1] for creature in hand)\n          + sum(max(0, creature[0] - creature[1]) for creature in hand[max(0,n-b):])\n          + best))\n
import math\nfrom collections import deque\n\ndef main():\n	n, m, k = list(map(int, input().split()))\n	grid = ["" for _ in range(n)]\n	x, y = 0, 0\n\n	for i in range(n):\n		grid[i] = input()\n		if 'X' in grid[i]:\n			x, y = i, grid[i].index('X')\n\n	if k % 2 == 1:\n		print("IMPOSSIBLE")\n		return\n\n	dx = [1, 0, 0, -1]	\n	dy = [0, -1, 1, 0]\n	names = {(x1, y1): sym for x1, y1, sym in zip(dx, dy, "DLRU")}\n	rev_names = {x1: y1 for x1, y1 in zip("DLRU", "URLD")}\n\n	def ok(x, y):\n		return (0 <= x < n) and (0 <= y < m) and grid[x][y] != '*'\n	\n\n	def bfs(x, y):\n		MAX_DIST = (1 << 20)\n		dist = [[MAX_DIST for y in range(m)] for x in range(n)]\n		dist[x][y] = 0\n		q = deque()\n		q.append((x, y))\n\n		while len(q) > 0:\n			x, y = q.popleft()\n\n			for x0, y0 in zip(dx, dy):\n				if ok(x + x0, y + y0) and dist[x][y] + 1 < dist[x + x0][y + y0]:\n					dist[x + x0][y + y0] = dist[x][y] + 1\n					q.append((x + x0, y + y0))		\n\n		return dist			\n\n	path = []\n	x_start, y_start = x, y\n\n	dist = bfs(x_start, y_start)\n\n	for i in range(k // 2):\n		for x1, y1 in zip(dx, dy):\n			if ok(x + x1, y + y1):\n				path.append(names.get((x1, y1)))	\n				x += x1\n				y += y1\n				break\n		else:\n			print("IMPOSSIBLE")\n			return\n\n	moves = k // 2		\n	for i in range(k // 2):\n		for x1, y1 in zip(dx, dy):\n			if ok(x + x1, y + y1) and dist[x + x1][y + y1] <= moves:\n				path.append(names.get((x1, y1)))\n				x += x1\n				y += y1\n				moves -= 1\n				break\n\n	print("".join(x for x in path))\n\ndef __starting_point():\n	main()\n__starting_point()
a, b = list(map(int, input().split()))\n\nans = 0\n\nwhile a and b:\n    if a > b:\n        ans += a // b\n        a = a % b\n    else:\n        ans += b // a\n        b = b % a\n\nprint(ans)\n
n = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\ncnt = 0\nfor i in range(n):\n    if a[i] != b[i]:\n        cnt += 1 \n        \nif cnt == 1:\n    done = list(range(1,n+1))\n    x = 0\n    for i in range(n):\n        if a[i] == b[i]:\n            try:\n                done.remove(a[i])\n            except:\n                pass\n        else:\n            x = i\n            try:\n                done.remove(a[i])\n            except:\n                pass\n            try:\n                done.remove(b[i])\n            except:\n                pass\n    arr = a[::]\n    arr[x] = done[0]\n    for i in arr:\n        print(i,end = ' ')\n        \nelse:\n    arr = a[::]\n    x = -1\n    y = -1\n    for i in range(n):\n        if a[i] == b[i]:\n            pass\n        else:\n            if x == -1:\n                x = i\n            else:\n                y = i\n    br = arr[::]\n    arr[x] = b[x]\n    br[y] = b[y]\n    if len(set(br)) == n:\n        arr = br[::]\n    for i in arr:\n        print(i,end = ' ')           \n        
3\n\ndef read_ints():\n	return [int(i) for i in input().split()]\n\nn, a = read_ints()\n\nres = 1\n\nfor i in range(2, n - 1):\n	if abs(a - res * 180 / n) > abs(a - i * 180 / n):\n		res = i\n\nprint(2, 1, res + 2)
import getpass\nimport sys\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n    # sys.stdin = open('input.txt')\n    # sys.stdout = open('output.txt', 'w')\nelse:\n    sys.stdin = open('input.txt')\n    # sys.stdin.close()\n\nn = ria()[0]\nar = []\nfor i in range(n):\n    ar.append(ria()[0])\n\nsm = sum(ar) / 2\nfor i in range(2 ** n):\n    c = 0\n    for j in range(n):\n        if i & (1 << j):\n            c += ar[j]\n        else:\n            c -= ar[j]\n    if c % 360 == 0:\n        print('YES')\n        return\nprint('NO')\n
ii = lambda: int(input())\nmi = lambda: list(map(int, input().split()))\nli = lambda: list(mi())\n\na, b, c, d = mi()\na, b, c = sorted([a, b, c])\nans = max(0, d - (b - a)) + max(0, d - (c - b))\nprint(ans)\n
from fractions import gcd\nx, y = map(int, input().split())\n\na = int(x**.5 + 1)\np = []\nx1 = x\nfor i in range(2, a + 1):\n  if (x1 % i == 0):\n    p.append(i)\n    while (x1 % i == 0):\n      x1 //= i\nif (x1 > 1):\n  p.append(x1)\nans = 0\nwhile (y != 0):\n  r = gcd(x, y)\n  x //= r\n  y //= r\n  max_can = 0\n  for i in range(len(p)):\n    if (x % p[i] == 0):\n      max_can = max(max_can, y - y % p[i])\n  ans += y - max_can\n  y = max_can\nprint(ans)
import sys\n\nreadline = sys.stdin.readline\nMOD = 10 ** 9 + 7\nINF = float('INF')\nsys.setrecursionlimit(10 ** 5)\n\n\ndef main():\n    N = int(readline())\n    L = 2 * N\n    floor = [[0, 0] for _ in range(L)]\n    com = dict()\n\n    for i in range(1, N + 1):\n        A, B = map(int, readline().split())\n        com[i] = [-1, -1]\n        if A != -1:\n            if floor[A - 1][1] == 0:\n                floor[A - 1] = [i, 1]\n                com[i][0] = A - 1\n            else:\n                return print("No")\n        if B != -1:\n            if floor[B - 1][1] == 0:\n                floor[B - 1] = [i, 2]\n                com[i][1] = B - 1\n            else:\n                return print("No")\n        if A != -1 and B != -1:\n            if A >= B:\n                return print("No")\n\n    dp = [False] * (L + 1)\n\n    if floor[0][1] == 2:\n        return print("No")\n    else:\n        dp[0] = True\n\n    for i in range(L):\n        if not dp[i]:\n            continue\n        for j in range(i + 1, L, 2):\n            ok = True\n            w = (j - i + 1) // 2\n            for k in range(w):\n                p = i + k\n                q = i + w + k\n                if floor[p][1] == 2 or floor[q][1] == 1:\n                    ok = False\n                if floor[p][1] == 1 and floor[q][1] == 2:\n                    if floor[p][0] != floor[q][0]:\n                        ok = False\n                if floor[p][1] == 1:\n                    f = floor[p][0]\n                    if com[f][1] != q and com[f][1] != -1:\n                        ok = False\n                if floor[q][1] == 2:\n                    f = floor[q][0]\n                    if com[f][0] != p and com[f][0] != -1:\n                        ok = False\n            if ok:\n                dp[j + 1] = True\n\n    print("Yes") if dp[L] else print("No")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
X=[]\nY=[]\nPoints=[]\nk=False\nfor i in range(8):\n    x,y=list(map(int,input().split()))\n    X.append(x)\n    Y.append(y)\n    if([x,y] in Points):\n        k=True\n    Points.append([x,y])\nX.sort()\nY.sort()\n\nif(len(set(X))!=3 or len(set(Y))!=3 or k):\n    print("ugly")\n\nelif(X.count(X[0])!=3 or X.count(X[3])!=2 or X.count(X[5])!=3):\n    print("ugly")\n\nelif(Y.count(Y[0])!=3 or Y.count(Y[3])!=2 or Y.count(Y[5])!=3):\n    print("ugly")\n\nelif([X[3],Y[3]] in Points):\n    print("ugly")\n\nelse:\n    print("respectable")\n
t = int(input())\nfor _ in range(t):\n    n, d = list(map(int, input().split()))\n    if (1 - n) ** 2 - 4 * (d - n) >= 0:\n        print('YES')\n    else:\n        print('NO')\n
k = int(input())\n\nif k // 2 + k % 2 > 18:\n    print(-1)\nelse:\n    print('8' * (k // 2) + ('6' if k % 2 else ''))\n
n, m = map(int, input().split())\nmi = 100000000000000\nts = ""\ndef num_d(a, b):\n  t = 0\n  for x in range(len(a)):\n    if a[x] != b[x]:\n      t += 1\n  return t\ns, t = input(), input()\nfor x in range(m-n+1):\n  d = num_d(s, t[x:x+n])\n  if d < mi:\n    mi = d\n    ts = t[x:x+n]\nprint(mi)\nfor x in range(n):\n  if s[x] != ts[x]:\n    print(x+1, end=" ")\n
import string\n\ni = input()\ni = i.split(' ')\nn, d, h = list([int(x) for x in i])\n\ndef check(n, d, h):\n    if d > 2 * h:\n        print(-1)\n        return\n\n    if d < h:\n        print(-1)\n        return\n    if n < d + 1 or n < h + 1:\n        print(-1)\n        return\n    if d == 1 and n > 2:\n        print(-1)\n        return\n\nout = []\n#h\ncheck(n, d, h)\nc = 0\n# print('h')\nfor i in range(h):\n    out.append(str(c + 1) + ' ' + str(c + 2))\n    # print(out[-1])\n    c += 1\nc += 1\nc1 = 0\n# print('d')\nfor i in range(d - h):\n    out.append(str(c1 + 1) + ' ' + str(c + 1))\n    # print(out[-1])\n    c1 = c\n    c += 1\n\nc += 1\n# print('n')\nif d == h:\n    s = 2\nelse:\n    s = 1\n    \nfor i in range(n - c + 1):\n    out.append(str(s) + ' ' + str(c))\n    # print(out[-1])\n\n    c += 1\n\nfor el in out:\n    print(el)\n\n
from math import sin\npi = 3.141592653589793238462643383279502884197\nn, r = map(int,input().split())\ntheta = 2*pi / n\nR = r / (1-sin(theta/2))\nprint(R-r)
withFile = 0\n\nif(withFile == 1):\n    fin     = open('input.txt', 'r')\n    fout    = open('output.txt', 'w')\n\ndef getl():\n    if(withFile == 0):\n        return input()\n    else:\n        return fin.readline()\ndef printl(s):\n    if(withFile == 0):\n        print(s)\n    else:\n        fout.write(str(s))\ndef get_arr():\n    x = getl().split(' ')\n    if(x[-1] == ''):\n        x = x[:-1]\n    return list(map(int, x))\n\nl = get_arr()[0]\nb = get_arr()[0]\nc = get_arr()[0]\nt = l / (1.00 * b + c)\nprint(t*b)\n\n\nif(withFile == 1):\n    fin.close()\n    fout.close()
n = int(input())\narr = list(map(int, input().split()))\nprint(sum(arr) // n)\n
input()\ns = input()\n\nif 'MM' in s or 'YY' in s or 'CC' in s:\n    print ('No')\nelif s.startswith('?') or s.endswith('?'):\n    print ('Yes')\nelif '??' in s:\n    print ('Yes')\nelif 'C?C' in s or 'M?M' in s or 'Y?Y' in s:\n    print ('Yes')\nelse:\n    print ('No')
n, f1, f2, f3, c = list(map(int,input().split()))\nmat = [[1,1,1],[1,0,0],[0,1,0]]\nfinal = [[1,0,0],[0,1,0],[0,0,1]]\nnn = n - 3\nN = 10**9 + 6\ndef prod(a, b):\n	m = [[0,0,0],[0,0,0],[0,0,0]]\n	for i in range(3):\n		for j in range(3):\n			m[i][j] = (a[i][0]*b[0][j] + a[i][1]*b[1][j]+a[i][2]*b[2][j]) % N\n	return m\nwhile nn > 0:\n	if nn % 2 == 1:\n		final = prod(final, mat)\n	mat = prod(mat,mat)\n	nn //= 2\nq = (final[0][0] * 3 + final[0][1] * 2 + final[0][2] * 1) % N\np = q - (n%N) + N\n# p to potega c\nef3 = (final[0][0] * 1) % N\nef2 = (final[0][1] * 1) % N\nef1 = (final[0][2] * 1) % N\n# print f1^ef1 *f2^ef2*f3^ef3 * c^p\ndef pot(a,w):\n	wyn = 1\n	while w > 0:\n		if w%2 == 1:\n			wyn = (wyn * a) % (N+1)\n		a = (a * a) % (N+1)\n		w //= 2\n	return wyn\nl1 = pot(f1, ef1)\nl2 = pot(f2, ef2)\nl3 = pot(f3, ef3)\nl4 = pot(c, p)\nc = (l1*l2*l3*l4)%(N+1)\nprint(c)
n, m = map(int, input().split())\n\np = ''\nq = []\n\narr = [input() for __ in range(n)]\ns = set(arr)\nfor z in arr:\n    if z == z[::-1]:\n        p = z\n    else:\n        if z not in s: continue\n        if z[::-1] in s:\n            s.remove(z)\n            s.remove(z[::-1])\n            q += z,\n\nres = ''.join(q)\nres = res + p + res[::-1]\nprint(len(res))\nprint(res)
\n\nn=int(input())\na=list(map(int,input().split()))\na=sorted(a)\n\nif(n>65):\n	print(sum(a)-n)\nelif(n==1 or n==2):\n	print(a[0]-1)\nelse:\n	ans=10**20\n\n	for i in range(1,50000):\n		now=1\n		ta=0\n		for j in a:\n			ta+=abs(now-j)\n			now*=i\n		ans=min(ans,ta)\n\n	print(ans)\n
# for _ in range(1):\nfor _ in range(int(input())):\n    # a, b = map(int, input().split())\n    n = int(input())\n    arr = list(map(int, input().split()))\n    # s = input()\n    if [arr[0]] * n == arr:\n        print(n)\n    else:\n        print(1)\n
n, m = [int(i) for i in input().split()]\nA = []\nC = []\nfor i in range(n):\n    B = [int(j) for j in input().split()]\n    A.append(B)\n    C.append(sorted(list(set(B))))\n\nxor = 0\nans = []\n\nfor i in range(n):\n    xor ^= A[i][0]\n    ans.append(1)\n\nif xor==0:\n    found = 0\n    for trial in range(n-1, -1, -1):\n        newxor = xor^A[trial][0]\n        if found==1:\n            break\n        for j in range(m):\n            if A[trial][j]^newxor!=0:\n                ans[trial] = j+1\n                found = 1\n                break\n        if found==1:\n            break\n    if found:\n        print('TAK')\n        print(*ans)\n    else:\n        print('NIE')\nelse:\n    print('TAK')\n    print(*ans)\n
import sys\nimport math\nimport bisect\nimport heapq\nimport collections\n\nS = input()\nT = input()\nlenS = len(S)\nlenT = len(T)\nF1 = [False]*26\nF2 = [False]*26\nalpha = 'abcdefghijklmnopqrstuvwxyz'\nfor i in range(lenS):\n    F1[alpha.index(S[i])] = True\nfor i in range(lenT):\n    F2[alpha.index(T[i])] = True\nfor i in range(26):\n    if not F1[i] and F2[i]:\n        print(-1)\n        return\n\nind = S.index(T[0])\nans = ind+1\nfor i in range(1,lenT):\n    S = S[ind+1:] + S[:ind+1]\n    ind = S.index(T[i])\n    ans += ind+1\n\nprint(ans)
from collections import deque\n\n\ndef bfs(start):\n    res = []\n    queue = deque([start])\n    while queue:\n        vertex = queue.pop()\n        if not vis[vertex]:\n            vis[vertex] = 1\n            res.append(vertex)\n            for i in s[vertex]:\n                if not vis[i]:\n                    queue.append(i)\n    return res\n\nn, m = [int(i) for i in input().split()]\ns = [[] for i in range(n)]\nfor i in range(m):\n    a, b = [int(i) for i in input().split()]\n    s[a-1].append(b-1)\n    s[b-1].append(a-1)\nvis = [0 for i in range(n)]\nr = 0\nfor i in range(n):\n    if not vis[i]:\n        d = bfs(i)\n        for j in d:\n            if len(s[j]) != len(d)-1:\n                r = 1\n                print("NO")\n                break\n    if r:\n        break\nelse:\n    print("YES")
t, p = input().lower(), 'abcdefghijklmnopqrstuvwxyz|'[int(input())]\nprint(''.join(i.upper() if i < p else i for i in t))
n = int(input())\na, b = input(), input()\nt = {i + j: 0 for i in '01' for j in '01'}\nfor i in range(2 * n): t[a[i] + b[i]] += 1\nd = t['11'] & 1\nd += (t['10'] - t['01'] + 1 - d) // 2\nif d > 0: d = 1\nelif d < 0: d = 2\nprint(['Draw', 'First', 'Second'][d])
n=int(input())\na=list(map(int,input().split()))\nmm=max(a)\nmmm=min(a)\nif mmm!=mm-2:\n    print(n)\n    print(*a)\nelse:\n    q,w,e=0,0,0\n    for i in a:\n        if i==mm:\n            e+=1\n        elif i==mmm:\n            q+=1\n        else:\n            w+=1\n    y=w%2+q+e\n    p=max(q,e)-min(q,e)\n    u=p+w\n    if y<u:\n        print(y)\n        print(*([mm]*(e+w//2)+[mmm]*(q+w//2)+[mm-1]*(w%2)))\n    else:\n        print(u)\n        if q>e:\n            print(*([mmm]*p+(n-p)*[mmm+1]))\n        else:\n            print(*([mm]*p+(n-p)*[mm-1]))\n
now = "a"\nans = 0\nS = input()\nfor s in S:\n    x = abs(ord(s) - ord(now))\n    ans += min(x, 26 - x)\n    now = s\nprint(ans)\n
a1=int(input())\na2=int(input())\nk1=int(input())\nk2=int(input())\nn=int(input())\nans1=0\nans2=0\n\nif k1<k2:\n    ans1+=min(n//k1,a1)\n    ans1+=(n-ans1*k1)//k2\nelse :\n    ans1+=min(n//k2,a2)\n    ans1+=(n-ans1*k2)//k1\nans2=max(0,n-(k1-1)*a1-(k2-1)*a2)\nprint(ans2,ans1)\n
import copy\n\ndef process( s ):\n	res = s[:]\n	for i in range( 1, len(s) ):\n		if s[i] == 'G' and s[i - 1] == 'B':\n			res[i], res[i - 1] = res[i - 1], res[i]\n	return res\n\nfl = input().split()\nn = int( fl[0] )\nt = int( fl[1] )\ns = input().split()[0]\nS = []\nfor i in range(n):\n	S.append( s[i] )\nfor i in range(t):\n	S = process( S )\nans = ""\nfor i in range(n):\n	ans += S[i]\nprint( ans )
def primeFactor(N):\n    i = 2\n    ret = {}\n    n = N\n    mrFlg = 0\n    if n < 0:\n        ret[-1] = 1\n        n = -n\n    if n == 0:\n        ret[0] = 1\n    while i**2 <= n:\n        k = 0\n        while n % i == 0:\n            n //= i\n            k += 1\n            ret[i] = k\n        if i == 2:\n            i = 3\n        else:\n            i += 2\n        if i == 101 and n >= (2**20):\n            def findFactorRho(N):\n                # print("FFF", N)\n                def gcd(a, b):\n                    if b == 0:\n                        return a\n                    else:\n                        return gcd(b, a % b)\n                def f(x, c):\n                    return ((x ** 2) + c) % N\n                semi = [N]\n                for c in range(1, 11):\n                    x=2\n                    y=2\n                    d=1\n                    while d == 1:\n                        x = f(x, c)\n                        y = f(f(y, c), c)\n                        d = gcd(abs(x-y), N)\n                    if d != N:\n                        if isPrimeMR(d):\n                            return d\n                        elif isPrimeMR(N//d):\n                            return N//d\n                        else:\n                            semi.append(d)\n\n                semi = list(set(semi))\n                # print (semi)\n                s = min(semi)\n                for i in [2,3,5,7]:\n                    while True:\n                        t = int(s**(1/i)+0.5)\n                        if t**i == s:\n                            s = t\n                            if isPrimeMR(s):\n                                return s\n                        else:\n                            break\n\n                i = 3\n                while True:\n                    if s % i == 0:\n                        return i\n                    i += 2\n                    \n            while True:\n                if isPrimeMR(n):\n                    ret[n] = 1\n                    n = 1\n                    break\n                else:\n                    mrFlg = 1\n                    j = findFactorRho(n)\n                    k = 0\n                    while n % j == 0:\n                        n //= j\n                        k += 1\n                        ret[j] = k\n                if n == 1:\n                    break\n        \n    if n > 1:\n        ret[n] = 1\n    if mrFlg > 0:\n        def dict_sort(X):\n            Y={}\n            for x in sorted(X.keys()):\n                Y[x] = X[x]\n            return Y\n        ret = dict_sort(ret)\n    return ret\n\ndef isPrime(N):\n    if N <= 1:\n        return False\n    return sum(primeFactor(N).values()) == 1\n\ndef isPrimeMR(n):\n    # print("MR", n)\n    if n == 2: return True\n    if n == 1 or n & 1 == 0: return False\n\n    d = (n - 1) >> 1\n    while d & 1 == 0:\n        d >>= 1\n\n    for a in [2, 3, 5, 7, 11, 13, 17, 19]:\n        t = d\n        y = pow(a, t, n)\n\n        while t != n - 1 and y != 1 and y != n - 1:\n            y = (y * y) % n\n            t <<= 1\n\n        if y != n - 1 and t & 1 == 0:\n            # print("not prime")\n            return False\n    # print("prime")\n    return True        \n\ndef findPrime(N):\n    if N < 0:\n        return -1\n    i = N\n    while True:\n        if isPrime(i):\n            return i\n        i += 1\n\ndef divisors(N):\n    pf = primeFactor(N)\n    ret = [1]\n    for p in pf:\n        ret_prev = ret\n        ret = []\n        for i in range(pf[p]+1):\n            for r in ret_prev:\n                ret.append(r * (p ** i))\n    return sorted(ret)\n\ndef mxpow(m, a, e):\n    if e == 1:\n        return a\n    if e % 2 == 0:\n        tmp = mxpow(m, a, e//2)\n        return mxprod(m, tmp, tmp)\n    else:\n        tmp = mxpow(m, a, e//2)\n        return mxprod(m, mxprod(m, tmp, tmp), a)\n\ndef mxprod(m, a, b):\n    ret = [[0]*m for _ in range(m)]\n    for i in range(m):\n        for j in range(m):\n            for k in range(m):\n                ret[i][j] += a[i][k] * b[k][j]\n                ret[i][j] %= P\n    return ret\n\ndef mxv(m, a, v):\n    ret = [0]*m\n    for i in range(m):\n        for k in range(m):\n            ret[i] += a[i][k] * v[k]\n            ret[i] %= P\n    return ret\n\ndef mx(m):\n    ret = [[0]*m for _ in range(m)]\n    for i in range(m):\n        for j in range(i, m):\n            ret[i][j] = inv(j+1)\n            \n    return ret\n    \ndef vc(m):\n    return [0] * (m-1) + [1]\n\n\ndef inv(a):\n    return pow(a, P-2, P)\n\n\n# ----- -----\n\nP = 10**9 + 7\n\nn, k = list(map(int, input().split()))\n# n = 6\n# k = 2\n\npf = primeFactor(n)\n# print(pf)\n\nans = 1\nfor p in pf:\n    m = pf[p] + 1\n    vvv = mxv(m, mxpow(m, mx(m), k), vc(m))\n\n    t = 0\n    for i in range(m):\n        t += (vvv[i] * p ** i) % P\n        t %= P\n        \n    ans *= t\n    ans %= P\nprint(ans)\n\n
from sys import stdin, stdout\nn, m = map(int, stdin.readline().split())\nif m < n - 1: stdout.write('-1')\nelif m == n - 1: stdout.write('0' + '10' * m)\nelif m == n: stdout.write('10' * m)\nelif m == n + 1: stdout.write('10' * n + '1')\nelse:\n    k = m - (n + 1)\n    if k > n + 1: stdout.write('-1')\n    elif k == n + 1: stdout.write('110' * n + '11')\n    else: stdout.write('110' * k + '10' * (n - k) + '1')
n, k = list(map(int, input().split()))\np = (n // 2) // (k + 1)\ng = p * k\no = n - p - g\nprint(p, g, o)\n
n = input()\nn = n.strip('0')\nprint('YES' if n == n[::-1] else 'NO')\n
n = int(input())\nans = 0\nfor i in range(1, n + 1):\n	for j in range(i, n + 1):\n		if 0 < i ^ j < n + 1 and i ^ j < i + j and i ^ j >= j:\n			ans += 1\nprint(ans)\n
def read_data():\n    n, m = map(int, input().split())\n    maze = [[False] * (m + 2)]\n    for i in range(n):\n        maze.append([False] + [c == '.' for c in input().rstrip()] + [False])\n    maze.append([False] * (m + 2))\n    r1, c1 = map(int, input().split())\n    r2, c2 = map(int, input().split())\n    return n, m, maze, r1, c1, r2, c2\n\n\ndef solve(n, m, maze, r1, c1, r2, c2):\n    dots = count_surrounding_intact_ices(maze, r2, c2)\n    if maze[r2][c2] == False:\n        if r1 == r2 and c1 == c2:\n            return dots >= 1\n        else:\n            return solve_wfs(n, m, maze, r1, c1, r2, c2)\n    else:\n        if dots >= 2:\n            return solve_wfs(n, m, maze, r1, c1, r2, c2)\n        if dots == 0:\n            return False\n        if dots == 1:\n            return is_side_by_side(r1, c1, r2, c2)\n\n\ndef is_side_by_side(r1, c1, r2, c2):\n    if r1 == r2:\n        return abs(c1 - c2) == 1\n    if c1 == c2:\n        return abs(r1 - r2) == 1\n    return False\n\n\ndef count_surrounding_intact_ices(maze, r, c):\n    count = 0\n    for rr, cc in [(r+1, c), (r-1, c), (r, c+1), (r, c-1)]:\n        if maze[rr][cc]:\n            count += 1\n    return count\n\ndef solve_wfs(n, m, maze, r1, c1, r2, c2):\n    frontier = [(r1, c1)]\n    while frontier:\n        new_frontier = []\n        for r, c in frontier:\n            for nr, nc in [(r+1, c), (r-1, c), (r, c+1), (r, c-1)]:\n                if nr == r2 and nc == c2:\n                    return True\n                if not maze[nr][nc]:\n                    continue\n                maze[nr][nc] = False\n                new_frontier.append((nr, nc))\n        frontier = new_frontier\n    return False\n\ndef __starting_point():\n    n, m, maze, r1, c1, r2, c2 = read_data()\n    if solve(n, m, maze, r1, c1, r2, c2):\n        print('YES')\n    else:\n        print('NO')\n__starting_point()
n, m = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(m)]\n\nab = sorted(ab, key=lambda x: x[1])\ns = ab[0][1]\nans = 1\nfor i in ab:\n    if s <= i[0]:\n        ans += 1\n        s = i[1]\nprint(ans)
"""\nCodeforces Contest 281 Div 2 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef main():\n    n, = read()\n    a = []\n    b = []\n    last = 0\n    for i in range(n):\n        x, = read()\n        if x < 0:\n            b.append(-x)\n            last = 1\n        else:\n            a.append(x)\n            last = 0\n    if sum(a) > sum(b):\n        print("first")\n    elif sum(b) > sum(a):\n        print("second")\n    elif a > b:\n        print("first")\n    elif b > a:\n        print("second")\n    else:\n        print("second" if last else "first")\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
n=input()\nc=[int(x) for x in input().split()]\np=0\nd=True\nfor i in c:\n    #print(p,d,i)\n    if i%2==0:\n        if p==1:\n            if i==0:\n                d=False\n    else:\n        p=1-p\n\nprint('YES' if d and p==0 else 'NO')
def valid(a, b):\n    d = abs(ord(a) - ord(b))\n    return d == 0 or d == 2\n\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    s = input()\n    val = all(valid(s[i], s[n - i - 1]) for i in range(n))\n    print('YES' if val else 'NO')\n
def main():\n    import sys\n    \n    n, t, s1, s2 = sys.stdin.read().split()\n    n, t = int(n), int(t)\n    \n    result = [-1] * n\n    rest = n - t\n    for i in range(n):\n        if rest == 0: break\n        if s1[i] == s2[i]:\n            result[i] = s1[i]\n            rest -= 1\n    k = rest\n    for i in range(n):\n        if k == 0: break\n        if result[i] == -1:\n            result[i] = s1[i]\n            k -= 1\n    k = rest\n    for i in range(n):\n        if k == 0: break\n        if result[i] == -1:\n            result[i] = s2[i]\n            k -= 1    \n    if k > 0:\n        print(-1)\n        return\n    for i in range(n):\n        if result[i] == -1:\n            for j in range(ord('a'), ord('a') + 4):\n                if chr(j) != s1[i] and chr(j) != s2[i]:\n                    result[i] = chr(j)\n                    break\n    \n    sys.stdout.write(''.join(result))\n    \nmain()
g = set(input())\ns = input()\nn = int(input())\na = s.find("*")\nfor _ in range(n):\n    temp = input()\n    if a == -1:\n        if len(temp) != len(s):\n            print("NO")\n        else:\n            for i in range(len(s)):\n                if s[i] == '?':\n                    if temp[i] not in g:\n                        print("NO")\n                        break\n                elif s[i] != temp[i]:\n                    print("NO")\n                    break\n            else:\n                print("YES")\n    else:\n        if len(temp) < len(s)-1:\n            print("NO")\n        else:\n            for i in range(a):\n                if s[i] == '?':\n                    if temp[i] not in g:\n                        print("NO")\n                        break\n                elif s[i] != temp[i]:\n                    print("NO")\n                    break\n            else:\n                for i in range(-(len(s) - a-1), 0):\n                    if s[i] == '?':\n                        if temp[i] not in g:\n                            print("NO")\n                            break\n                    elif s[i] != temp[i]:\n                        print("NO")\n                        break\n                else:\n                    for i in range(a, len(temp)-(len(s) - a-1)):\n                        if temp[i] in g:\n                            print("NO")\n                            break\n                    else:\n                        print("YES")
n, k = list(map(int, input().split()))\na = []\nfor i in range(n):\n    a.append(input())\ns = input()\nkmn = 1\nkmx = 0\nfor i in range(n):\n    if (len(a[i]) < len(s)):\n        kmn += 1\n        kmx += 1\n    elif (len(a[i]) == len(s)):\n        kmx += 1\nprint((kmn - 1) // k * 5 + kmn, (kmx - 1) // k * 5 + kmx)\n
n = int(input())\na = list(map(int, input().split()))\n\nnechet = 0\n\nfor el in a:\n    if el % 2 == 1:\n        nechet += 1\n\nif nechet == 0:\n    print('Second')\nelse:\n    print('First')\n
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\nn=int(input())\n\nfor a in range(1,n+1)[::-1]:\n    if n%a: continue\n    if a>n//a: continue\n    print("%s %s"%(a,n//a))\n    break
import sys\n\n\ndef normalize(s):\n    s = s.lower()\n    s = s.replace("o", "0")\n    s = s.replace("l", "1")\n    s = s.replace("i", "1")\n    return s\n\n\nquery = normalize(next(sys.stdin).strip())\nn = int(next(sys.stdin).strip())\n\nfor line in sys.stdin:\n    line = normalize(line.strip())\n    if query == line:\n        print("No")\n        return\n\nprint("Yes")\n
def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    if a[1] - a[0] == a[2] - a[1]:\n        d = a[1] - a[0]\n        c1 = a[0]\n        c2 = 'no'\n        for i in range(3, n):\n            if i * d + c1 == a[i]:\n                pass\n            elif c2 == 'no':\n                c2 = a[i] - d * i\n            elif i * d + c2 == a[i]:\n                pass\n            else:\n                print('No')\n                return\n        if c2 == 'no':\n            print('No')\n        else:\n            print('Yes')\n        return\n    else:\n        f = True\n        d = a[1] - a[0]\n        c1 = a[0]\n        c2 = a[2] - 2 * d\n        #print(d, c1, c2)\n        for i in range(3, n):\n            if (a[i] == i * d + c1) or (a[i] == i * d + c2):\n                pass\n            else:\n                f = False\n                break\n        if f:\n            print('Yes')\n            return\n        f = True\n        d = a[2] - a[1]\n        c1 = a[1] - d\n        c2 = a[0]\n        #print(d, c1, c2)\n        for i in range(3, n):\n            if (a[i] == i * d + c1) or (a[i] == i * d + c2):\n                pass\n            else:\n                f = False\n                break\n        if f:\n            print('Yes')\n            return\n        f = True\n        d = (a[2] - a[0]) / 2\n        c1 = a[0]\n        c2 = a[1] - d\n        #print(d, c1, c2)\n        for i in range(3, n):\n            #print(a[i], i * d + c1, i * d + c2)\n            if (a[i] == i * d + c1) or (a[i] == i * d + c2):\n                pass\n            else:\n                f = False\n                break\n        if f:\n            print('Yes')\n        else:\n            print('No')\n\nmain()\n
import sys, logging\nlogging.basicConfig(level=logging.INFO)\nlogging.disable(logging.INFO)\n\ndef build(S, n):\n    Z = [0 for i in range(3 * n + 3)]\n    #logging.info(S)\n    n = len(S)\n    L = 0\n    R = 0\n    Z[0] = n\n    for i in range(1, n):\n        if(i > R):\n            L = R = i\n            while(R < n and S[R] == S[R - L]):\n                R += 1\n            Z[i] = R - L\n            R -= 1\n        else:\n            k = i - L\n            if(Z[k] < R - i + 1):\n                Z[i] = Z[k]\n            else:\n                L = i\n                while(R < n and S[R] == S[R - L]):\n                    R += 1\n                Z[i] = R - L\n                R -= 1\n    return Z\n\ndef update1(n, x, val):\n    while(x <= n + 1):\n        bit1[x] += val\n        x += x & -x\n\ndef get1(n, x):\n    ans = 0\n    while(x > 0):\n        ans += bit1[x]\n        x -= x & -x\n    return ans\n\ndef update2(n, x, val):\n    while(x <= n + 1):\n        bit2[x] += val\n        x += x & -x\n\ndef get2(n, x):\n    ans = 0\n    while(x > 0):\n        ans += bit2[x]\n        x -= x & -x\n    return ans\n\ndef process(n, m, fa, fb):\n    r2 = int(1)\n    ans = 0\n    for l1 in range(1, n + 1):\n        while(r2 <= min(n, l1 + m - 2)):\n            update1(n, m - fb[r2] + 1, 1)\n            update2(n, m - fb[r2] + 1, fb[r2] - m + 1)\n            r2 += 1\n        ans += get1(n, fa[l1] + 1) * fa[l1] + get2(n, fa[l1] + 1)\n        update1(n, m - fb[l1] + 1, -1)\n        update2(n, m - fb[l1] + 1, m - 1 - fb[l1])\n    print(ans)\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    a = sys.stdin.readline()\n    b = sys.stdin.readline()\n    s = sys.stdin.readline()\n    a = a[:(len(a) - 1)]\n    b = b[:(len(b) - 1)]\n    s = s[:(len(s) - 1)]\n    fa = build(s + a, n)\n    kb = build(s[::-1] + b[::-1], n)\n    fb = [0 for k in range(n + 2)]\n    for i in range(m, m + n):\n        fa[i - m + 1] = fa[i]\n        if(fa[i - m + 1] >= m):\n            fa[i - m + 1] = m - 1\n        fb[m + n - i] = kb[i]\n        if(fb[m + n - i] >= m):\n            fb[m + n - i] = m - 1\n    logging.info(fa[1:(n + 1)])\n    logging.info(fb[1:(n + 1)])\n    process(n, m, fa, fb)\n\nbit1 = [0 for i in range(500004)]\nbit2 = [0 for i in range(500004)]\n\ndef __starting_point():\n    try:\n        sys.stdin = open('input.txt', 'r')\n        sys.stdout = open('output.txt', 'w')\n    except:\n        pass\n    main()\n__starting_point()
n = int(input())\n\nm = 6\narr = []\nfor i in range(n):\n    arr.append(input())\n    \nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        d = 0\n        for z in range(6):\n            if arr[i][z] != arr[j][z]:\n                d += 1\n                \n        if d == 6:\n            m = min(m, 2)\n        elif d == 5:\n            m = min(m, 2)\n        elif d == 4:\n            m = min(m, 1)\n        elif d == 3:\n            m = min(m, 1)\n        else:\n            m = 0\n            \nprint(m)
n, m = list(map(int, input().split()))\na = [0] + list(map(int, input().split()))\npr = [0 for i in range(len(a))]\nfor i in range(1, len(a)):\n    pr[i] = pr[i - 1] + a[i]\n\nans = 0\nfor i in range(m):\n    l, r = list(map(int, input().split()))\n    cur = pr[r] - pr[l - 1]\n    if cur >= 0:\n        ans += cur\n\nprint(ans)\n\n
x = list(input())\n\nfor i in range(len(x)):\n    if(i==0 and x[i]=='9'):\n        continue\n    if(int(x[i])>9-int(x[i])):\n        x[i] = str(9-int(x[i]))\ny=0\nfor item in x:\n    y*=10\n    y+=int(item)\nprint(y)\n
l, r, n = map(int, input().split())\na = n\nn = 1\ncnt = 0\nwhile n <= r:\n    if n >= l:\n        cnt += 1\n        print(n, end=' ')\n    n *= a\nif cnt == 0:\n    print(-1)
n, m = map(int, input().split())\nd = []\nfor i in range(n):\n	d.append(list(map(int, input().split())))\nk = 0\nfor i in d:\n	if i[0] <= k:\n		k = max(k, i[1])\nif k >= m:\n	print('YES')\nelse:\n	print('NO')
n, m, k = map(int, input().split())\nmod = 998244353\n\ndef powerDX(n, r, mod):\n  if r == 0: return 1\n  if r%2 == 0:\n    return powerDX(n*n % mod, r//2, mod) % mod\n  if r%2 == 1:\n    return n * powerDX(n, r-1, mod) % mod\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n \ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\n \nfor i in range(2, n + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nans = 0\nfor i in range(0, k+1):\n  ans += m*cmb(n-1, i, mod)*pow(m-1, n-i-1, mod)\n  ans %= mod\nprint(ans)
import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\nimport numpy as np\nimport itertools\n\nP = int(input())\nA = [int(x) for x in input().split()]\n\n# k,i -> i^k\npower = np.ones((P,P),dtype = np.int64)\nfor k in range(1,P):\n    power[k] = power[k-1] * np.arange(P,dtype=np.int64) % P\n\nf = np.zeros(P,dtype=np.int64)\nfor i,a in enumerate(A):\n    if a == 1:\n        f[0] += 1\n        f -= power[:,i][::-1]\nf %= P\n\nf %= P\nprint((*f))\n\n
r, c = list(map(int, input().split()))\ncake = [input().strip() for _ in range(r)]\nans = 0\nfor i in range(r):\n    for j in range(c):\n        if cake[i][j] == '.' and ('S' not in cake[i] or 'S' not in list(zip(*cake))[j]):\n            ans += 1\nprint(ans)\n
n=int(input())\na=list(map(int,input().split()))\nif n==1:\n    print(-1)\n    return\na.sort()\nd=[]\nfor i in range(1,n):\n    d.append(a[i]-a[i-1])\nif min(d)==max(d)==0:\n    print(1)\n    print(a[0])\nelif n==2:\n    if d[0]%2:\n        print(2)\n        print(a[0]-d[0],a[1]+d[0])\n    else:\n        print(3)\n        print(a[0]-d[0],a[0]+d[0]//2,a[1]+d[0])\nelif min(d)==max(d):\n    print(2)\n    print(a[0]-d[0],a[-1]+d[0])\nelse:\n    m1=0\n    m2=0\n    for i in range(1,n-1):\n        if d[i]<d[m1]: m1=i\n        if d[i]>d[m2]: m2=i\n    c=d.count(d[m1])\n    if c==n-2 and d[m1]*2==d[m2]:\n        print(1)\n        print(a[m2]+d[m1])\n    else:\n        print(0)
n = int(input())\nshows = []\nfor i in range(n):\n  l, r = map(int, input().split())\n  shows.append((l,r))\n  \nshows.sort()\n\na_endtime, b_endtime = -1, -1\nfor show in shows:\n  if show[0] <= a_endtime:\n    print('NO')\n    break\n  else:\n    a_endtime = show[1]\n    if a_endtime > b_endtime:\n      a_endtime, b_endtime = b_endtime, a_endtime\n  \nelse:\n  print('YES')
from sys import stdin\nfrom fractions import gcd\nlines = list([_f for _f in stdin.read().split('\n') if _f])\n\ndef parseline(line):\n	return list(map(int, line.split()))\n\nlines = list(map(parseline, lines))\n\nl, r = lines[0]\n\nfor a in range(l, r+1):\n	for b in range(a, r+1):\n		for c in range(b, r + 1):\n			if gcd(a, b) == gcd(b, c) == 1 != gcd(a, c):\n				print(a, b, c)\n				return\nprint(-1)\n
n,s=map(int,input().split())\na=list(map(int,input().split()))\na.sort()\nif sum(a[:-1])<=s:\n    print('YES')\nelse:\n    print('NO')
y,b,r=map(int,input().split())\nm=min(y,b-1,r-2)\nprint(3*m+3)
r, g, b = map(int, input().split())\nmaxi = (r + g + b) // 3\nprint(min(maxi, r + g, r + b, g + b))
n = int(input())\na = list(map(int, input().split()))\ne = 1000000\nans = max(min(x - 1, e - x) for x in a)\nprint(ans)\n
n = int(input())\nprint((3 ** (3 * n) - 7 ** n) % 1000000007)
#!/usr/bin/env python3\n\nfrom collections import Counter\n\ntry:\n    while True:\n        n = int(input())\n        s = input()\n        if n > 26:\n            print(-1)\n        else:\n            c = Counter(s)\n            print(sum(c.values()) - len(c))\n\nexcept EOFError:\n    pass\n
a, b = map(int,input().split())\ni = 1\nwhile 1:\n    if a < i:\n        print("Vladik")\n        break\n    a-= i\n    i+= 1\n    if b < i:\n        print("Valera")\n        break\n    b-= i\n    i+= 1
n = q = int(input())\nk = list(input())\ncntl = k.count('(')\ncntr = k.count(')')\ncntq = k.count('?')\nfor i in range(n):\n    if k[i] == '?':\n        if cntl < q // 2 and cntr + cntq >= q // 2:\n            k[i] = '('\n            cntl += 1\n            cntq -= 1\n        else:\n            k[i] = ')'\n            cntr += 1\n            cntq -= 1\n        \ndef check():\n    cnt = 0\n    m = 0\n    for i in k:\n        m += 1\n        if i == '(':\n            cnt += 1\n        else:\n            cnt -= 1\n        if cnt == 0 and m < n or cnt < 0:\n            return False\n    return cnt == 0\n\nprint(''.join(k) if check() else ':(')\n            \n            \n
def convert_to_binary(coef):\n    res = []\n    n = len(coef)\n    carry = 0\n    i = 0\n    while i < n + 1000:\n        if i >= n and not carry:\n            break\n        cur = carry\n        if i < n:\n            cur += coef[i]\n\n        mod = cur % 2\n        div = cur // 2\n#        print(cur, div, mod)\n\n        res.append(mod)\n\n        carry = div\n\n        i += 1\n    return res, carry\n\nn, k = list(map(int, input().split()))\ncoef = list(map(int, input().split()))\n\nb, carry = convert_to_binary(coef)\nref = False\nif carry < 0:\n    b, carry = convert_to_binary(list([-x for x in coef]))\n    ref = True\n\n\nlast = len(b) - 1\nwhile b[last] != 1:\n    last -= 1\n\nans = 0\nfor i in range(0, n + 1):\n    if last - i > 40:\n        continue\n\n    cur = 0\n    for j in range(i, last + 1):\n        cur += b[j] * (2 ** (j - i))\n\n    new_coef = coef[i] - cur\n    if ref:\n        new_coef = coef[i] + cur\n\n    if abs(new_coef) > k:\n        if b[i] == 1:\n            break\n        continue\n\n    if i == n and new_coef == 0:\n        if b[i] == 1:\n            break\n        continue\n\n    ans += 1\n    if b[i] == 1:\n        break\n\n\nprint(ans)\n
n = int(input())\nd = list(map(int, input().split()))\ns = {i:0 for i in [1, 2]}\nfor i in d:\n	s[i] += 1\nif s[2] >= s[1]:\n	print(s[1])\nelse:\n	print(s[2] + (s[1] - s[2]) // 3)\n
x1, y1, x2, y2 = map(int, input().split())\n\ndx, dy = (x2 - x1) // 2, (y2 - y1) // 2\nprint(dx + 1 + (2 * dx + 1) * dy)
n = int(input())\nax, ay = list(map(int, input().split(' ')))\nbx, by = list(map(int, input().split(' ')))\ncx, cy = list(map(int, input().split(' ')))\n\nif ((cx < ax) == (bx < ax)) and ((cy < ay) == (by < ay)):\n    print('YES')\nelse:\n    print('NO')
import math \nN = 10**5 + 10\nu = [-1]*N\ndivi = [ [] for i in range(N) ] \npd = [ [] for i in range(N) ] \nmark = [0]*N\n\ndef precalc():\n    for i in range(1,N) :\n        for j in range(i,N,i) :\n            divi[j].append(i)\n\n    for i in range(2,N) : \n        if mark[i] == 1 : \n            continue\n        for j in range(i,N,i) :\n            pd[j].append(i)\n            mark[j] = 1\n\n    for i in range(1,N) : \n        for prm in pd[i] :\n            time = 0\n            _i = i \n            while _i % prm == 0 : \n                time += 1\n                _i /= prm\n            if time > 1 :\n                u[i] = 0\n                continue\n        if u[i] == -1 : \n            if len(pd[i]) & 1 :\n                u[i] = -1\n            else : \n                u[i] = 1\n    \nhas = [False]*N \ncnt = [0]*N\n\ndef has_coprime(n):\n    ret = 0\n    for d in divi[n] :\n        ret += u[d] * cnt[d]\n    return ret\n\ndef update(n,val) :\n    for d in divi[n] :\n        cnt[d] += val\n\n    \ndef solve(n) :\n    li = list(map(int,input().split()))\n    ans = 0\n    for i in range(n) : \n        if has[li[i]] : \n            ans = max(ans,li[i])\n        has[li[i]] = True\n\n    for g in range(1,N) :\n        st = [] \n        for num in reversed(list(range(1,N//g + 1))) :\n            if num*g > N-1 or not has[num*g]  : \n                continue\n            how_many = has_coprime(num)\n\n            while how_many > 0 : \n                #print(how_many)\n                now = st.pop()\n                if math.gcd(now,num) == 1 : \n                    ans = max(ans,num*now*g)\n                    how_many -= 1\n                update(now,-1)\n            st.append(num)\n            update(num,1)\n        while st :\n            update(st.pop(),-1)\n\n    print(ans)\n\nprecalc()\n\nwhile True : \n    try : \n        n = int(input())\n        solve(n)\n    except EOFError:\n        break\n
def check(k, aas, bs, a_rem, b_rem):\n    if a_rem + b_rem < k:\n        return False\n    a_lo = k - b_rem\n    a_hi = a_rem\n\n    rems = set()\n    rems.add(0)\n    for a, b in zip(aas, bs):\n        if a + b < k:\n            continue\n        for i in range(max(0, k - b), min(a, k) + 1):\n            rem = i % k\n            for j in list(rems):\n                rems.add((j + rem) % k)\n    for rem in rems:\n        if rem >= a_lo and rem <= a_hi:\n            return True\n    return False\n\n\nn, k = [int(x) for x in input().split()]\naas = []\nbs = []\na_total = 0\nb_total = 0\nfor i in range(n):\n    a, b = [int(x) for x in input().split()]\n    aas.append(a)\n    bs.append(b)\n    a_total += a\n    b_total += b\nans = a_total // k + b_total // k\nif check(k, aas, bs, a_total % k, b_total % k):\n    print(ans + 1)\nelse:\n    print(ans)\n
s = input()\na = str()\nb = str()\nf = False\nfor i in range(len(s)):\n    if s[i] == 'e':\n        f = True\n    elif f:\n        b = b + s[i]\n    else:\n        a = a + s[i]\npos = a.index('.')\nn = int(b)\na = list(a)\nfor i in range(n):\n    if pos == len(a) - 1:\n        a.append('0')\n    a[pos], a[pos + 1] = a[pos + 1], a[pos]\n    pos += 1\nif a[-1] == '.':\n    a.pop()\nif '.' in a:\n    while a[-1] == '0':\n        a.pop()\nif a[-1] == '.':\n    a.pop()\nif '.' not in a:\n    while len(a) > 1 and a[0] == '0':\n        a.pop(0)\nfor i in range(len(a)):\n    print(a[i], end = '')\n
import numpy as np\n\ndef __starting_point():\n\n	N,K = list(map(int,input().split()))\n	P = [ int(p)-1 for p in input().split() ]\n	C = list(map(int,input().split()))\n\n	# print(P)\n	# 一度計算したサイクル情報をキャッシュしておくための配列\n	cycleIDs = np.full( N, -1, np.int64 )\n	cycleInfs = []\n	cycleID = 0\n	procCnt = 0\n\n	for n in range(N):\n		v = n\n\n		if cycleIDs[v] != -1:\n			continue\n		else:\n			currentCycleCosts = []\n			while True:\n				# 全頂点について、属するサイクルを計算する\n				currentCycleCosts.append( C[v] )\n				cycleIDs[v] = cycleID\n\n				v = P[v]\n				if cycleIDs[v] != -1:\n					# サイクル終了\n					# ループを含めない最大の処理回数\n					procCnt = K % len( currentCycleCosts )\n					# それで足りてるのかわからないが、Last2周分は、ループするものとして確定させない\n					# その部分は、ちゃんと計算する\n					# -------------------------------------------------\n					# 4 101\n					# 2 3 4 1\n					# 50 -49 -50 50\n					# 上記のようなパターンの場合、\n					# 最大25回ループ + 1回処理可能だが、その場合、25 + 50 = 75\n					# 24回ループ + 2回処理でやめると、124になる\n					# 無条件でループする回数は、最大の回数だけでなく、\n					# 最大の回数-1も考慮の必要あり\n					# -------------------------------------------------\n					# あるいは、割り切れて、尚且つサイクル合計がマイナスのパターンで、最低１個は処理するのにもここで対応\n					if len( currentCycleCosts ) + procCnt <= K:\n						procCnt += len( currentCycleCosts )\n\n					cycleInfs.append( ( procCnt, len(currentCycleCosts), np.array( currentCycleCosts + currentCycleCosts ) ) )\n					cycleID += 1\n					break\n\n\n\n	# scores = []\n	# procCnt = 0\n	ans = -10 ** 9\n	for procCnt, currentCycleSize, currentCycleCosts in cycleInfs:\n\n		# サイクル内でループしてスコアを稼ぐ場合の考慮\n		loopScore = 0\n		fullMinus1CntLoopScore = 0\n		if np.sum(currentCycleCosts) > 0:\n			cycleLoopCnt =  ( K - procCnt ) // currentCycleSize\n			loopScore = cycleLoopCnt * np.sum(currentCycleCosts[:currentCycleSize])\n			# print("loopScore",loopScore,procCnt)\n\n		# このサイクルに属する全頂点分をまとめて計算する\n		for i in range(currentCycleSize):\n			# scores.append( np.roll( currentCycleCosts, i )[:procCnt].cumsum().max() + loopScore )\n			# print(np.roll( currentCycleCosts, i ).cumsum()[:procCnt])\n			ans = max( ans, np.roll( currentCycleCosts, i ).cumsum()[:procCnt].max() + loopScore )\n\n\n	print(ans)\n	# print(max(scores))\n\n__starting_point()
from heapq import *\nimport sys\n\nMOD = 1000000181\n\ndef addM(a,b):\n    return (a+b)%MOD\ndef mulM(a,b):\n    return (a*b)%MOD\n\ndef dijk(adj,n,s):\n    dist = [10**18]*n\n    ways = [0]*n\n    frontier = []\n    dist[s] = 0\n    ways[s] = 1\n    heappush(frontier,(0,s))\n    while (len(frontier)>0):\n        x = heappop(frontier)\n        if x[0]!=dist[x[1]]:\n            continue\n        x = x[1]\n        for (i,l) in adj[x]:\n            if dist[x]+l<dist[i]:\n                dist[i] = dist[x]+l\n                ways[i] = ways[x]\n                heappush(frontier,(dist[i],i))\n            elif dist[x]+l==dist[i]:\n                ways[i] = addM(ways[i],ways[x])\n    return (dist,ways)\n\nn,m,s,t = map(int,sys.stdin.readline().split())\ns-=1\nt-=1\nadj = [[] for i in range(n)]\njda = [[] for i in range(n)]\nedges = []\n\nfor i in range(m):\n    a,b,l = map(int,sys.stdin.readline().split())\n    a-=1\n    b-=1\n    adj[a].append((b,l))\n    jda[b].append((a,l))\n    edges.append((a,b,l))\n\none = dijk(adj,n,s)\ntwo = dijk(jda,n,t)\n\nfor i in edges:\n    if one[0][i[0]]+i[2]+two[0][i[1]]==one[0][t] and mulM(one[1][i[0]],two[1][i[1]])==one[1][t]:\n        sys.stdout.write("YES\n")\n    else:\n        x = one[0][t]-1-one[0][i[0]]-two[0][i[1]]\n        if x<=0:\n            sys.stdout.write("NO\n")\n        else:\n            sys.stdout.write("CAN "+str(i[2]-x)+"\n")
import sys\nfrom collections import deque as dq\nn = int(input())\n\nind = 0\ninp = [int(x)-1 for line in sys.stdin.readlines() for x in line.split()]\n\ncoupl = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a,b = inp[ind],inp[ind+1]\n    ind+=2\n    coupl[a].append(b)\n    coupl[b].append(a)\n\nQ = dq()\nfound = [False]*n\nmaster = 0\nfound[master] = True\n\ndia1 = 0\nQ.append(master)\nwhile Q:\n    node = Q.popleft()\n    dia1 = node\n    for nei in coupl[node]:\n        if not found[nei]:\n            found[nei] = True\n            Q.append(nei)\n\n\ndia2 = 0\nQ.append((dia1,0))\ndist1 = [0]*n\nfound = [False]*n\nfound[dia1] = True\nwhile Q:\n    node,d = Q.popleft()\n    dia2 = node\n    dist1[node]=d\n    for nei in coupl[node]:\n        if not found[nei]:\n            found[nei] = True\n            Q.append((nei,d+1))\n\nQ = []\nQ.append((dia2,0))\ndist2 = [0]*n\nfound = [False]*n\nfound[dia2] = True\nwhile Q:\n    node,d = Q.pop()\n    dist2[node]=d\n    for nei in coupl[node]:\n        if not found[nei]:\n            found[nei] = True\n            Q.append((nei,d+1))\n\nneigs = [0]*n\n\nleaves = []\nfor i in range(n):\n    if i != dia1 and i != dia2 and len(coupl[i])==1:\n        leaves.append(i)\n    neigs[i]=len(coupl[i])\npoints = 0\nlista = []\n\nwhile leaves:\n    node = leaves.pop()\n    if dist1[node]<dist2[node]:\n        lista.append((dia2,node,node))\n        points += dist2[node]\n    else:\n        lista.append((dia1,node,node))\n        points += dist1[node]\n    for nei in coupl[node]:\n        neigs[nei]-=1\n        if neigs[nei]==1:\n            leaves.append(nei)\nleaves.append(dia2)\nwhile leaves:\n    node = leaves.pop()\n    lista.append((dia1,node,node))\n    points += dist1[node]\n    for nei in coupl[node]:\n        neigs[nei]-=1\n        if neigs[nei]==1:\n            leaves.append(nei)\nprint(points)\nfor l in lista:\n    a,b,c = l\n    print(a+1,b+1,c+1)\n
import sys\nfrom heapq import heappush, heappop\n\nn = int(input())\na = list(map(int, input().split()))\n\ncount = {}\n\nfor x in a:\n	if x in count:\n		count[x] = count[x] + 1\n	else:\n		count[x] = 1\n\ncount = sorted(list(count.items()))\n#print(count)\n\ncost= list(map(int, input().split()))\nmax_cost = max(cost)\n\na = list(zip(a, cost))\na = sorted(a)\npriority = list([max_cost - x for x in [x[1] for x in a]])\na = list(zip(priority, a))\n\ni = 0\nqueue = []\nqueue_cost = 0\nresult = 0\n\n#print(a)\n\nfor j in range(len(count)):\n	x, c = count[j]\n	#print('x = ', x)\n	while i < len(a) and a[i][1][0] == x:\n		queue_cost += a[i][1][1]\n		heappush(queue, a[i])\n		i += 1\n\n	#print('queue = ', queue)\n	y = x\n	while len(queue) > 0 and (j == len(count) - 1 or count[j + 1][0] != y):\n		popped = heappop(queue)\n		#print(popped, queue)\n		queue_cost -= popped[1][1]\n		#print(queue_cost)\n		result += queue_cost\n		y += 1\n\n# while len(queue) > 0:\n# 	popped = heappop(queue)\n# 	queue_cost -= popped[1][1]\n# 	result += queue_cost\n\nprint(result)\n
n = int(input())\nst = input()\ns = [0 if c == "(" else 1 for c in st]\nif n % 2 != 0 or sum(s) != n//2:\n    print(0)\n    print(1,1)\n    return\nmaxx = 0\nind = (0,0)\nmaxshift = 0\nfor shift in range(n):\n    stack = 0\n    x1 = -1\n    x2 = -1\n    sumzero = 0\n    for i,c in enumerate(s):\n        if s[(i+shift)%n] == 0:\n            stack+=1\n        else:\n            stack-=1\n        if stack == 0:\n            sumzero+=1\n        if stack < 0:\n            x1 = i\n            break\n    stack = 0\n    for i in range(n-1, -1, -1):\n        if s[(i+shift)%n] == 1:\n            stack+=1\n        else:\n            stack-=1\n        if stack < 0:\n            x2 = i\n            break\n    if x1 == -1 and x2 == -1 and stack == 0:\n        if sumzero > maxx:\n            maxx=sumzero\n            ind = (0,0)\n    if x1 == -1 or x2 == -1 or x1 == x2:\n        continue\n    stack = 0\n    corr = True\n    ans = 0\n    for i in range(n):\n        c = s[(i+shift)%n]\n        \n        if i == x1 or i == x2:\n            c = 1-c\n        if c == 0:\n            stack += 1\n        else:\n            stack -= 1\n        if stack == 0:\n            ans+=1\n        if stack == -1:\n            corr = False\n            break\n    \n    if not corr or stack > 0:\n        continue\n    if ans > maxx:\n        maxshift = shift\n        maxx = ans\n        ind = ((x1+shift)%n, (x2+shift)%n)\nprint(maxx)\nprint(ind[0]+1,ind[1]+1)\n
n = int(input())\nlen_out, count_in = 0, 0\nbalance, cur = 0, 0\nfor c in input():\n    if not (('a' <= c <= 'z') or ('A' <= c <= 'Z')) and cur:\n        if balance:\n            count_in += 1\n        else:\n            len_out = max(len_out, cur)\n        cur = 0\n    if c == '(':\n        balance += 1\n    elif c == ')':\n        balance -= 1\n    elif ('a' <= c <= 'z') or ('A' <= c <= 'Z'):\n        cur += 1\nif cur:\n    len_out = max(len_out, cur)\nprint(len_out, count_in)\n
import sys\ninput = sys.stdin.readline\nn,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nmod=998244353\nsol=1\ni=n-1\nj=m-1\nwhile sol>0 and j>=0:\n    goal=b[j]\n    s=0\n    r=False\n    while i>=0 and a[i]>=goal:\n        if r:\n            s+=1\n        else:\n            if a[i]==goal:\n                r=True\n                s=1\n        i-=1\n    if j==0:\n        s=min(s,1)\n        if i>=0:\n            s=0\n    sol*=s\n    sol%=mod\n    j-=1\nprint(sol)
def norm(x):\n    return (x % 998244353 + 998244353) % 998244353\n\nn, k = map(int, input().split())\n\ndp1 = [0]\ndp2 = [0]\n\nfor i in range(n):\n    l = [1]\n    cur = 0\n    for j in range(n + 1):\n        cur += l[j]\n        if(j > i):\n            cur -= l[j - i - 1]\n        cur = norm(cur)\n        l.append(cur)\n    dp1.append(l[n])\n    dp2.append(norm(dp1[i + 1] - dp1[i]))\n\nans = 0\nfor i in range(n + 1):\n    for j in range(n + 1):\n        if(i * j < k):\n            ans = norm(ans + dp2[i] * dp2[j])\n\nans = norm(ans * 2)\n\nprint(ans)
import sys\ninput = sys.stdin.readline\n\nN, K = list(map(int, input().split()))\nnums = []\nfor i in range(N):\n    t, d = list(map(int, input().split()))\n    nums.append((d, t))\nnums.sort(reverse=True)\nse = set()\na1 = []\na2 = []\nrest = []\nfor i, n in enumerate(nums):\n    if i < K:\n        if not n[1] in se:\n            se.add(n[1])\n            a1.append(n)\n        else:\n            a2.append(n)\n    else:\n        rest.append(n)\npoints = 0\nfor (d, t) in a1: points += d\nfor (d, t) in a2: points += d\nans = points + pow(len(se), 2)\na2.sort()\nidx2 = 0\nfor i, (d, t) in enumerate(rest):\n    if t in se: continue\n    if len(a2) <= idx2: break\n    points -= a2[idx2][0]\n    idx2 += 1\n    points += d\n    se.add(t)\n    ans = max(ans, points+pow(len(se), 2))\nprint(ans)\n
import numpy as np\n\nn=int(input())\nxy=[]\nfor i in range(n):\n    xy.append(list(map(int,input().split())))\n\ndef naiseki(a,b):\n    if (a[0]*b[0]+a[1]*b[1])>0.0:\n        return True\n    else:\n        return False\n    \nans=0\n\nfor i in range(1001):\n    xl=np.cos(np.pi*2.0*i/1000.0)\n    yl=np.sin(np.pi*2.0*i/1000.0)\n    x=0\n    y=0\n    for j in range(n):\n        if naiseki([xl,yl],xy[j]):\n            x+=xy[j][0]\n            y+=xy[j][1]\n    ans=max(ans,np.sqrt(x**2+y**2))\nprint(ans)\n
res = 1\nstarted = False\nseen = set()\ncodes = set(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'])\nfor ch in input():\n	if ch == '?':\n		if started:\n			res *= 10\n		else:\n			res *= 9\n	elif (ch in codes) and (ch not in seen):\n		if not started:\n			res *= len(codes) - len(seen) - 1\n		else:\n			res *= len(codes) - len(seen)\n		seen.add(ch)\n	started = True\nprint(res)\n
n = int(input())\na = list(map(int, input().split()))\n\nnums = [False for i in range(200010)]\nmust = [False for i in range(200010)]\ncounter = dict()\nnow_num = 0\n\n\ndef inc():\n    nonlocal now_num\n    now_num += 1\n    while nums[now_num - 1]:\n        now_num += 1\n\n\nfor el in a:\n    if nums[el - 1]:\n        counter[el] += 1\n    else:\n        counter[el] = 1\n    nums[el - 1] = True\n\ninc()\n\nans = []\nc = 0\n\nfor el in a:\n    if counter[el] > 1:\n        counter[el] -= 1\n        if now_num < el:\n            ans.append(now_num)\n            c += 1\n            inc()\n        else:\n            if must[el - 1] == False:\n                ans.append(el)\n                must[el - 1] = True\n            else:\n                ans.append(now_num)\n                c += 1\n                inc()\n    else:\n        if must[el - 1] == False:\n            ans.append(el)\n        else:\n            ans.append(now_num)\n            c += 1\n            inc()\n\nprint(c)\nprint(' '.join(str(el) for el in ans))\n
def readln(): return tuple(map(int, input().split()))\n\nimport sys\nsys.stdin = open('input.txt', 'r')\nsys.stdout = open('output.txt', 'w')\n\nn, k = readln()\nlst = [(v, i + 1) for i, v in enumerate(readln())]\nlst.sort()\nlst.reverse()\nprint(lst[k - 1][0])\nprint(*list(zip(*lst[:k]))[1])\n
#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\n    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit\n    \nN, = getIntList()\n#print(N)\nre = 0\nfor i in range(2,N):\n\n    t = N // i -1\n    re += t * i\n\nprint(re *4)\n\n\n\n\n\n\n
n, m = (int(x) for x in input().split())\nwinners = [0] * n\nfor i in range(m):\n	a = [int(x) for x in input().split()]\n	winners[a.index(max(a))] += 1\nprint(winners.index(max(winners)) + 1)\n
n, m = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nans = max(max(A), min(A) * 2)\nif min(B) <= ans:\n	print(-1)\nelse:\n	print(ans)
def iswis(a):\n	return a % 400 == 0 or (a%100!= 0 and a %4==0)\n\nn = int(input())\nwis = iswis(n)\nfr = 0;\nn += 1\nif (wis):\n	fr += 1\nfr += 1\nwhile (iswis(n) != wis or fr != 0):\n	if (iswis(n)):\n		fr += 1\n	fr += 1\n	fr %= 7\n	n += 1\nprint(n)
import datetime\nfrom pprint import pprint\nyear, month, day = (int(i) for i in input().split(':'))\nx = datetime.date(year, month, day)\nyear, month, day = (int(i) for i in input().split(':'))\ny = datetime.date(year, month, day)\npprint(abs(int((x - y).days)))\n
from collections import deque\nn,m = [int(x) for x in input().split()]\nadj = [[] for x in range(n+1)]\nfor _ in range(1,n):\n	a,b = [int(x) for x in input().split()]\n	adj[a].append(b)\n	adj[b].append(a)\nchaos = [int(x) for x in input().split()]\ns = chaos[0]\nchaos = set(chaos)\ncc = [0]*(n+1)\nst = deque()\nst.append((s,-1))\nwhile len(st):\n	u,e = st.pop()\n	if u<0:\n		if e>=0:\n			cc[e] += cc[-u]\n		continue\n	if u in chaos:\n		cc[u] +=1\n	st.append((-u,e))\n	\n	for v in adj[u]:\n		if v!=e:\n			st.append((v,u))\n	\n#dfs(s,-1)\nadj = [list([v for v in u if cc[v]>0]) for u in adj]\na = (s,0)\nst = deque()\nst.append((a[0],-1,0))\nwhile len(st):\n	u,e,h = st.pop()\n	if h>a[1]:\n		a = (u,h)\n	elif h==a[1] and u<a[0]:\n		a = (u,h)\n	for v in adj[u]:\n		if v!=e:\n			st.append((v,u,h+1))\nb = a\na = (a[0],0)\nst = deque()\nst.append((a[0],-1,0))\nwhile len(st):\n	u,e,h = st.pop()\n	if h>a[1]:\n		a = (u,h)\n	elif h==a[1] and u<a[0]:\n		a = (u,h)\n	for v in adj[u]:\n		if v!=e:\n			st.append((v,u,h+1))\nprint(min(a[0],b[0]))\nprint(2*(n-cc.count(0))-a[1])\n
import bisect\nimport collections\n\n\ndef solve(inp, *args):\n    n, x = list(map(int, inp.split(" ", 1)))\n    travels_by_len = collections.defaultdict(list)\n    travels_by_len_processed = {}\n    for travel in args:\n        l, r, cost = list(map(int, travel.split(" ", 2)))\n        travels_by_len[r - l + 1].append((l, r, cost))\n    for travel_len, travels in list(travels_by_len.items()):\n        travels.sort()\n        travels_processed = [(travels[-1][0], travels[-1][2])]\n        for i in range(len(travels) - 2, -1, -1):\n            prev_travel = travels_processed[-1]\n            l, r, c = travels[i]\n            travels_processed.append((l, min(c, prev_travel[1])))\n        travels_by_len_processed[travel_len] = travels_processed[::-1]\n\n    best_price = float("inf")\n    for first_travel_len, first_travels in list(travels_by_len.items()):\n        second_travel_len = x - first_travel_len\n        second_travels_processed = travels_by_len_processed.get(second_travel_len, [])\n        for first_travel in first_travels:\n            l1, r1, c1 = first_travel\n            # now we look for cheapest travels which have l2 > r1\n            idx = bisect.bisect_right(second_travels_processed, (r1, float("inf")))\n            if 0 <= idx < len(second_travels_processed):\n                best_price = min(best_price, c1 + second_travels_processed[idx][1])\n    return -1 if best_price == float("inf") else best_price\n\n\ndef __starting_point():\n    inp = input()\n    n, x = list(map(int, inp.split(" ", 1)))\n    print(solve(inp, *(input() for i in range(n))))\n\n__starting_point()
import sys\ns = input().strip()\n\ndef isPalin(n):\n    if n[::-1] == n:\n        return True\n    return False\n\nfor i in range(len(s)+1):\n    for j in "abcdefghijklmnopqrstuvwxyz":\n        if isPalin(s[:i] + j + s[i:]):\n            print(s[:i] + j + s[i:])\n            return\n\nprint("NA")\n
a=int(input())\nb=int(input())\nc=(a+b)//2\ndef f(x):\n    x=abs(x)\n    return x*(x+1)//2\nprint(f(c-a)+f(b-c))\n
t = int(input())\n\nfor _ in range(t):\n    p, f = [int(x) for x in input().split()]\n    cs, cw = [int(x) for x in input().split()]\n    s, w = [int(x) for x in input().split()]\n    if s > w:\n        s, w = w, s\n        cs, cw = cw, cs\n\n    best = 0\n    for i in range(cs + 1):\n        if s*i <= p:\n            war_me = min((p - s*i)//w, cw)\n            tb = i + war_me\n            sword_him = min(cs - i, f//s)\n            tb += sword_him\n            war_him = min((f - s*sword_him)//w, cw - war_me)\n            tb += war_him\n            best = max(best, tb)\n    print(best)\n\n
3\n\na = int(input())\nlst = 'Washington,Adams,Jefferson,Madison,Monroe,Adams,Jackson,Van Buren,Harrison,Tyler,Polk,Taylor,Fillmore,Pierce,Buchanan,Lincoln,Johnson,Grant,Hayes,Garfield,Arthur,Cleveland,Harrison,Cleveland,McKinley,Roosevelt,Taft,Wilson,Harding,Coolidge,Hoover,Roosevelt,Truman,Eisenhower,Kennedy,Johnson,Nixon,Ford,Carter,Reagan'.split(',')\nprint(lst[a - 1])\n
s=input().split()\nfor i in range(3):\n    s[i]=int(s[i])\ns.sort()\n\n\nans=s[0]//3 +s[1]//3 +s[2]//3\n\nx=s[0]%3\ny=s[1]%3\nz=s[2]%3\nif(x==0 and y==z==2 and s[0]!=0):\n    ans+=1\nif(y==0 and x==z==2 and s[1]!=0):\n    ans+=1\nif(z==0 and y==x==2 and s[2]!=0):\n    ans+=1\n\nans+=min(x,y,z)\nprint(ans)\n\n
n = int(input())\na = set(map(int, input().split()))\nif 0 in a: a.remove(0)\nprint(len(a))
a,b,c,d=list(map(int,input().split()))\nmisha=max(3*a/10,a-a/250*c)\nvasya=max(3*b/10,b-b/250*d)\n\nif misha > vasya:\n    print("Misha")\nelif vasya > misha:\n    print("Vasya")\nelse:\n    print("Tie")\n
import sys\n\nR,x,y,s,t = list(map(int,input().split()))\n\nif (s-x)**2 + (t-y)**2 > R*R:\n    print(x,y,R)\n    return\n\ndx = x - s\ndy = y - t\nr = (dx**2 + dy**2)**.5\n\nif abs(r)<1e-9:\n    dx = 1\n    dy = 0\nelse:\n    dx /= r\n    dy /= r\n\na = s + dx*(R + r)/2\nb = t + dy*(R + r)/2\n\nprint(a,b,(R+r)/2)\n\n
n, m = list(map(int, input().split()))\n\nfact = [1]\n\nfor i in range(1, n + 1):\n    fact.append((fact[-1] * i) % m)\n    \nout = 0\n\nfor size in range(1, n + 1):\n    out += fact[size] * (n - size + 1) ** 2 * fact[n - size]\n    out %= m\n\nprint(out)\n
n = int(input())\na = list(map(int, input().split()))\ncnt, good = 0, 0\nfor i in range(0, n):\n    if a[i] == 4 or a[i] == 5:\n        good = good + 1\n    else:\n        good = 0\n    if good == 3:\n        cnt = cnt + 1\n        good = 0\nprint(cnt)
n=int(input())\n\nL=[]\nfor i in range(n):\n    L.append(input())\nvalid=True\nx=0\ny=0\nE=[]\np=L[0][0]\nwhile(x<n and y<n):\n    if(L[x][y]!=p):\n        valid=False\n    x+=1\n    y+=1\n    \nx=0\ny=n-1\n\nwhile(x<n and y>=0):\n    if(L[x][y]!=p):\n        valid=False\n    x+=1\n    y-=1\nK={}\nfor i in range(n):\n    for j in range(n):\n        if(L[i][j] in K):\n            K[L[i][j]]+=1\n        else:\n            K[L[i][j]]=1\n\n\nif(not valid or K[p]!=2*n-1 or len(K)!=2):\n    print("NO")\n\nelse:\n    print("YES")\n
import re\nimport itertools\nfrom collections import Counter\n\nclass Task:\n    n, m = 0, 0\n    petyaScore = 0\n    vasyaScore = 0\n	\n    def getData(self):\n        self.n, self.m = [int(x) for x in input().split(" ")]\n	\n    def solve(self):\n        n = self.n\n        m = self.m\n\n        if n != m:\n            self.vasyaScore = min(n, m)\n        else:\n            self.vasyaScore = min(n, m)\n        self.petyaScore = self.n + self.m - 1 - self.vasyaScore \n\n    def printAnswer(self):\n        print(self.petyaScore, self.vasyaScore)\n\ntask = Task();\ntask.getData();\ntask.solve();\ntask.printAnswer();\n
n, m = list(map(int, input().split()))\nres = 0\nmx = (n-1)*n//2\nmn = 0\nif n&1:\n    mn = (n//2)*(n//2+1)\nelse:\n    mn = n*n//4\nfor i in range(m):\n    x, d = list(map(int, input().split()))\n    res += x*n\n    if d > 0:\n        res += mx*d\n    else:\n        res += mn*d\nprint('%.10f'%(res/n))\n
n, k, p = [int(c) for c in input().split()]\na = [int(c) for c in input().split()]\n\nnech= []\nch = []\n\nfor i in range(len(a)):\n    if a[i] % 2 == 0:\n        ch.append(a[i])\n    else:\n        nech.append(a[i])\n\nneeded_nech = k - p\n\nfree_nech = len(nech) - needed_nech\nav_ch = len(ch) + (free_nech // 2)\n\nsets = []\n\n\nif free_nech < 0 or free_nech % 2 != 0 or av_ch < p:\n    print('NO')\nelse:\n    print('YES')\n    while needed_nech > 0:\n        sets.append([nech.pop()])\n        needed_nech -= 1\n\n    while p > 0:\n        if len(ch) > 0:\n            sets.append([ch.pop()])\n        else:\n            sets.append([nech.pop(), nech.pop()])\n        p -= 1\n\n    sets[0] = sets[0] + nech + ch\n\nfor i in range(len(sets)):\n    print(len(sets[i]),' '.join(map(str,sets[i])))
t,a,b=map(int,input().split())\nif t==2 and a==3 and b>10000: res=0\nelif a==t: res=('inf' if a==1 else 2) if a==b else 0\nelse: res=0 if (a-b)%(t-a) else (1 if t != b else 0)\nprint(res)
def main():\n    n, m = list(map(int, input().split()))\n\n    cost1 = []\n    cost2 = []\n    cost3 = []\n\n    for i in range(n):\n        w, c = list(map(int, input().split()))\n        if w == 1:\n            cost1.append(c)\n        elif w == 2:\n            cost2.append(c)\n        else:\n            cost3.append(c)\n\n    cost1 = sorted(cost1)[::-1]\n    cost2 = sorted(cost2)[::-1]\n    cost3 = sorted(cost3)[::-1]\n    cost3_prefix = [0]\n    for c in cost3:\n        cost3_prefix.append(cost3_prefix[-1] + c)\n\n\n    dp = [(0, 0, 0)] * (m + 1)\n    dp[0] = (0, 0, 0)\n\n    for i in range(0, m):\n        cost, n1, n2 = dp[i]\n\n        if i + 1 <= m and n1 < len(cost1):\n            new_cost = cost + cost1[n1]\n            if dp[i + 1][0] < new_cost:\n                dp[i + 1] = (new_cost, n1 + 1, n2)\n        \n        if i + 2 <= m and n2 < len(cost2):\n            new_cost = cost + cost2[n2]\n            if dp[i + 2][0] < new_cost:\n                dp[i + 2] = (new_cost, n1, n2 + 1)\n\n        if n1 == len(cost1) and n2 == len(cost2):\n            break\n\n\n    dp_prefix = [0]\n    for x in dp[1:]:\n        dp_prefix.append(max(dp_prefix[-1], x[0]))\n\n    ans = 0\n    for k in range(len(cost3) + 1):\n        l = m - 3 * k\n        if l < 0:\n            continue\n\n        new_ans = cost3_prefix[k] + dp_prefix[l]\n        ans = max(new_ans, ans)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n=int(input())\na=list(map(int,input().split()))\ntmp=0\nca=[0]\nfor ai in a:\n  tmp+=ai\n  ca.append(tmp)\nfrom bisect import bisect_right,bisect_left\nans=float('inf')\n\n# 数列をまず半分に区切る。左i個と右n-i個 2<=i,n-i\nf,g=1,3\nfor i in range(2,n-1):\n  while abs(ca[i]-ca[f]-ca[f])>abs(ca[i]-ca[f+1]-ca[f+1]):\n    f+=1\n  while abs((ca[-1]-ca[g])-(ca[g]-ca[i]))>abs((ca[-1]-ca[g+1])-(ca[g+1]-ca[i])):\n    g+=1\n  l=(ca[f],ca[i]-ca[f],ca[-1]-ca[g],ca[g]-ca[i])\n  ans=min(ans,max(l)-min(l))\n  #print(l)\nprint(ans)\n
n, m = map(int, input().split())\nvalists = [10**9 for _ in range(1<<n)]\nvalists[0] = 0\nfor i in range(m):\n	values, b = map(int, input().split())\n	c = list(map(int, input().split()))\n	cnt = 0\n	for j in range(b):\n		cnt += 2**(c[j]-1)\n	for j in range(len(valists)):\n		x = j|cnt\n		valists[x] = min(valists[x], valists[j]+values)\n		#print(j, cnt, x, valists)\n\n#print(valists)\nans = valists[2**n-1]\nif ans != 10**9:\n	print(ans)\nelse:\n	print(-1)
s = input()\nres = eval(s)\nn = len(s)\nfor i in range(-1, n):\n    if i == -1 or s[i] == '*':\n        for j in range(i + 1, n + 1):\n            if j == n or s[j] == '*':\n                new_s = s[0:i + 1] + "(" + s[i + 1:j] + ")" + s[j:n]\n                res = max(res, eval(new_s))\nprint(res)\n
x = input()\nz = input()\na, b = -1, -1\np, q ='', ''\np = x[:x.find('|')]\nq = x[x.find('|') + 1:]\nn = 0\nwhile n < len(z):\n    if len(p) < len(q):\n        p += z[n]\n    else:\n        q += z[n]\n    n += 1\nif len(p) == len(q):\n    print(p, '|', q, sep = '')\nelse:\n    print('Impossible')\n
x, y, z = list(map(int, input().split()))\nc = x // z + y // z\n\nrx = x % z\nry = y % z\nif rx + ry < z:\n    print(f'{c} 0')\nelse:\n    if rx > ry:\n        print(f'{c + 1} {z - rx}')\n    else:\n        print(f'{c + 1} {z - ry}')\n
x1, y1 = list(map(int, input().split()))\nx2, y2 = list(map(int, input().split()))\nx3, y3 = list(map(int, input().split()))\na = set()\na.add(((x1 + x2) - x3, y1 + y2 - y3))\na.add(((x1 + x3) - x2, y1 + y3 - y2))\na.add(((x2 + x3) - x1, y2 + y3 - y1))\nprint(len(a))\nfor i in a:\n    print(*i)
import re\nimport itertools\nfrom collections import Counter\n\nclass Task:\n    a = []\n    answer = []\n	\n    def getData(self):\n        input()\n        self.a = [int(x) for x in input().split(" ")]\n	\n    def solve(self):\n        currentFolderCounter = 0\n        badDaysCounter = 0\n        for x in self.a:\n            if x >= 0:\n                currentFolderCounter += 1\n            elif badDaysCounter <= 1:\n                currentFolderCounter += 1\n                badDaysCounter += 1\n            else:\n                self.answer += [currentFolderCounter]\n                currentFolderCounter = 1\n                badDaysCounter = 1\n        if currentFolderCounter > 0:\n            self.answer += [currentFolderCounter]\n\n    def printAnswer(self):\n        print(len(self.answer))\n        print(re.sub('[\[\],]', '', str(self.answer)))\n\ntask = Task();\ntask.getData();\ntask.solve();\ntask.printAnswer();\n
n, k = map(int, input().split())\n\nres = 1\nwhile (k % 2 == 0):\n    res += 1\n    k //= 2\nprint(res)
a,b=map(int,input().split())\nans=0\nwhile a>0 and b>0:\n    if max(a,b)>1: ans+=1\n    if a<b: a+=3\n    else: b+=3\n    a-=2;b-=2\nprint(ans)
n,k,m = list(map(int,input().split()))\nai = list(map(int,input().split()))\nai.sort()\nn2 = n\nnum = sum(ai)\nans = 0.0\ni = 0\nwhile n2 > 0 and m > -1:\n    num2 = (num + min(m,n2 * k)) / n2\n    ans = max(ans,num2)\n    num -= ai[i]\n    i += 1\n    n2 -= 1\n    m -= 1\nprint(ans)\n
n=int(input())\n\nx=n//2\nif(n%2==0):\n    print(x)\nelse:\n    print(x-n)\n
n = int(input())\na = list(map(int, input().split()))\ninfo = 0\ni = 0\ndir = 1\nresult = 0\nwhile True:\n    if info >= a[i]:\n        info += 1\n        a[i] = n + 1\n    if info == n:\n        break\n    i += dir\n    if i < 0 or i == n:\n        dir = -dir\n        i += dir\n        result += 1\nprint(result)\n
n = int(input())\ns = input()\nfor i in range(len(s) - 1):\n	if s[i] > s[i + 1]:\n		print(s[:i] + s[i + 1:len(s)])\n		return\nprint(s[:len(s) - 1])\n
#!/usr/bin/env python3\n\n[n, k] = list(map(int, input().strip().split()))\nais = list(map(int, input().strip().split()))\niais = [0 for _ in range(n + 1)]\nfor i in range(n):\n	iais[i + 1] = iais[i] + ais[i]\n\ndef calc(k, split):\n	res = 0\n	for i in range(k):\n		res &= iais[split[i + 1]] - iais[split[i]]\n	return res\n\ndef check_mask(mask):\n	dp = [[False for j in range(n + 1)] for i in range(k + 1)]\n\n	for j in range(1, n - k + 1 + 1):\n		dp[1][j] = (iais[j] & mask == mask)\n	if not any(dp[1]):\n		return False\n\n	for i in range(2, k + 1):\n		for j in range(i, n - (k - i) + 1):\n			dp[i][j] = any(dp[i - 1][r] and ((iais[j] - iais[r]) & mask == mask) for r in range(i - 1, j - 1 + 1))\n		if not any(dp[i]):\n			return False\n\n	return dp[k][n]\n\n\nmask = 0\nfor i in range(55, -1, -1):\n	if check_mask(mask | (1 << i)):\n		mask |= 1 << i\n\nprint (mask)\n\n
n = int(input())\na = [[], []]\na[0] = list(map(int, input().split()))\na[1] = list(map(int, input().split()))\nb = list(map(int, input().split()))\nans = float('+inf')\nfor i in range(n):\n	for j in range(n):\n		if i == j:\n			continue\n		cur = sum(a[1][i:]) + sum(a[0][:i]) + sum(a[0][:j]) +  sum(a[1][j:]) + b[i] + b[j]\n		ans = min(ans, cur)\nprint(ans)\n
# python3\n\ndef readline(): return tuple(map(int, input().split()))\n\n\ndef main():\n    n, k = readline()\n    a = readline()\n\n    answer = list()\n\n    for (i, link) in enumerate(a):\n        bottom = max(0, i - k)\n        top = min(n, i + k + 1)\n\n        if link == 0:\n            answer.append(top - bottom)\n        else:\n            bottom = max(bottom, link + k)\n            answer.append(max(0, top - bottom) + answer[link - 1])\n\n    print(" ".join(map(str, answer)))\n\n\nmain()\n
import sys\ninput=sys.stdin.readline\n\nT=int(input())\nfor _ in range(T):\n    n,m=list(map(int,input().split()))\n    A=list(map(int,input().split()))\n    s=sum(A)\n    if (s==m):\n        print("YES")\n    else:\n        print("NO")\n
import sys\ninput = sys.stdin.readline\n\ndef mult_input():\n	return map(int,input().split())\n\ndef list_input():\n	return list(map(int,input().split()))\n\nfor nt in range(int(input())):\n	n,k=map(int,input().split())\n	for i in range(2,n+1):\n		if n%i==0:\n			num=i\n			break\n	print (n+i+2*(k-1))
from math import *\nn, m = list(map(int, input().split()))\nif m < n - 1:\n    print('Impossible')\n    return\nr = [(i + 1, i + 2) for i in range(n - 1)]\nk = n - 1\nif k >= m:\n    print('Possible')\n    for x in r:\n        print(*x)\n    return\nfor i in range(1, n + 1):\n    for j in range(i + 2, n + 1):\n        if gcd(i, j) == 1:\n            r.append((i, j))\n            k += 1\n        if k >= m:\n            print('Possible')\n            for x in r:\n                print(*x)\n            return\nprint('Impossible')\n
r,n = [int(x) for x in input().split()]\ncells = [[int(x) for x in input().split()] for i in range(n)]\ncells.sort()\n#print(cells)\nout = False\n\nres = {True:"WIN",False:"LOSE"}\n\nif len(cells) == 0: print(res[r%2 == 1])\nelse:\n    out = False\n    #print(cells[0][0] > 1)\n    #print(cells[-1][0] < r)\n    for i in range(1,n):\n        out ^= ((cells[i][0]-cells[i-1][0]-1)%2) ^ (cells[i][1] != cells[i-1][1])\n    dif = abs((cells[0][0]-1)-(r-cells[-1][0]))\n    #print(out,dif)\n    hi,lo = max(cells[0][0]-1,r-cells[-1][0]),min(cells[0][0]-1,r-cells[-1][0])\n    #print(out,dif,lo,hi)\n    if lo > 1:\n        if dif == 0:\n            print(res[out])\n        elif dif == 1 and lo % 2 == 0:\n            print(res[not out])\n        else:\n            print(res[True])\n    elif lo == 0:\n        if hi == 0: print(res[out])\n        elif hi == 1:\n            print(res[not out])\n        else:\n            print(res[True])\n    elif lo == 1:\n        if hi == 1:\n            print(res[out])\n        else:\n            print(res[True])\n
# map(int, input().split())\n# list(map(int, input().split()))\nn, m = list(map(int, input().split()))\nm -= 1\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nif a[0] == 0:\n    print("NO")\n    return\nelif a[m] == 1:\n    print("YES")\n    return\nelif b[m] == 0:\n    print("NO")\n    return\nelse:\n    for i in range(m, n):\n        if a[i] and b[i]:\n            print("YES")\n            return\n    print("NO")\n
n, k = map(int, input().split())\narr = [int(i) for i in input().split()]\narr2 = []\nfor i in range(n):\n    arr2.append((arr[i], i))\narr2.sort()\nans = []\nfor i in arr2:\n    if k >= i[0]:\n        k -= i[0]\n        ans.append(i[1])\nprint(len(ans))\nfor i in ans:\n    print(i + 1, end = ' ')
n = int(input())\nx = list(map(int, input().split()))\nd = None\ns = 1\nc = x[0]\nfor i in range(1, n):\n    if x[i] == c:\n        s += 1\n    else:\n        if d is None:\n            d = s\n        else:\n            if (s != d):\n                print("NO")\n                break\n        s = 1\n        c = x[i]\nelse:\n    if (d is None) or (s == d):\n        print("YES")\n    else:\n        print("NO")\n
from sys import stdin\nn,m=list(map(int,stdin.readline().strip().split()))\ns=list(map(int,stdin.readline().strip().split()))\nans=[0 for i in range(n)]\nsm=[0 for i in range(n)]\nsm1=[0 for i in range(n)]\nfor i in range(n):\n    if i==0:\n        sm[i]=s[i]\n    else:\n        sm[i]=sm[i-1]+s[i]\nfor i in range(n-1,-1,-1):\n    if i==n-1:\n        sm1[i]=s[i]\n    else:\n        sm1[i]=sm1[i+1]+s[i]\nfor i in range(n):\n    if sm[i]<=m:\n        continue\n    x=sm[i]\n    s2=s[0:i]\n    s2.sort()\n    r=0\n    while x>m:\n        x-=s2[-1]\n        s2.pop()\n        r+=1\n    ans[i]=r\nprint(*ans)\n        \n
R=lambda:list(map(int,input().split()))\nn,x=R()\na=R()\nprint(x-len([i for i in a if i<x])+(1 if x in a else 0))\n
a, b = list(map(int, input().split()))\nres = [0,0,0]\nfor i in range(1, 7):\n    if abs(a - i) < abs(b - i):\n        res[0] += 1\n    elif abs(a - i) == abs(b - i):\n        res[1] += 1\n    else:\n        res[2] += 1\nprint(' '.join(map(str, res)))\n
x = input().split(' ')\nif x[-1] == "month":\n    if x[0] == '31':\n        print(7)\n    elif x[0] == '30':\n        print(11)\n    else:\n        print(12)\nelse:\n    if x[0] in ['5', '6']:\n        print(53)\n    else:\n        print(52)
n,m=list(map(int,input().split()))\nif(m!=0):\n    L=list(map(int,input().split()))\nelse:\n    L=[]\n\nL.sort()\nvalid=True\nfor i in range(2,m):\n    if(L[i]-L[i-2]==2):\n        valid=False\nif(m==0 or(valid and L[0]!=1 and L[-1]!=n)):\n    print("YES")\nelse:\n    print("NO")\n
def solve(x, y, p, q):\n    if p == 0: return 0 if x == 0 else -1\n    pp = (x - 1) // p + 1 if p != 0 else 0\n    L = max((y - 1) // q + 1, pp) - 1\n    L = max(L, -1)\n    z = y - x\n    INF = L + 10 ** 10\n    R = INF\n    while R - L > 1:\n        M = (L + R) >> 1\n        cur = q * M\n        curp = p * M\n        curz = cur - curp\n        dl = cur - y\n        if curp >= x and curz >= z:\n            R = M\n        else:\n            L = M\n        #print(L, R)\n    if R == INF:\n        return -1\n    return R * q - y\n\nread = lambda: map(int, input().split())\nt = int(input())\nfor i in range(t):\n    x, y, p, q = read()\n    print(solve(x, y, p, q))
l = int(input())\na = [0] * (l+1)\nb = [1] * (l+1)\nst = 0\nen = 1\ncur = 0\nfor i in range(l):\n    x = input()\n    if x == 'add':\n        a[en-1] += 1\n    elif x[0] == 'f':\n        d = x.split()\n        v = int(d[1])\n        a[en] = 0\n        b[en] = v\n        en += 1\n    else:\n        en -= 1\n        a[en-1] += a[en] * b[en]\n        if a[en-1] >= 2 ** 32:\n            cur = 1\n            break\nif cur == 1 or a[0] >= 2 ** 32:\n    print('OVERFLOW!!!')\nelse:\n    print(a[0])\n\n
x = input()\nc = 0\nfor i in x:\n	if i in "aeiou13579":\n		c+=1\nprint(c)\n
# import numpy as npy\nimport functools\nimport math\n\nn=int(input())\nx=[0 for i in range(n+2)]\ny=[0 for i in range(n+2)]\nadj=[[] for i in range(n+2)]\nidx=[]\nidy=[]\nfor i in range(n):\n    x[i],y[i]=map(int,input().split())\n    idx.append(i)\n    idy.append(i)\n\ndef cmpx(a,b):\n    if x[a]!=x[b]:\n        if x[a]<x[b]:\n            return -1\n        else:\n            return 1\n    if y[a]!=y[b]:\n        if y[a]<y[b]:\n            return -1\n        else:\n            return 1\n    return 0\n    \ndef cmpy(a,b):\n    if y[a]!=y[b]:\n        if y[a]<y[b]:\n            return -1\n        else:\n            return 1\n    if x[a]!=x[b]:\n        if x[a]<x[b]:\n            return -1\n        else:\n            return 1\n    return 0\n\nidx=sorted(idx,key=functools.cmp_to_key(cmpx))\nidy=sorted(idy,key=functools.cmp_to_key(cmpy))\n\n# print(idx)\n# print(idy)\n\ndef disx(a,b):\n    if x[a]!=x[b]:\n        return 1e18\n    return y[b]-y[a]\n    \ndef disy(a,b):\n    if y[a]!=y[b]:\n        return 1e18\n    return x[b]-x[a]\n\nl=0\nr=2000000000\nans=-1\n\nwhile l<=r:\n    # print(l,r)\n    mid=(l+r)//2\n    for i in range(n):\n        adj[i]=[]\n    for i in range(n-1):\n        if disx(idx[i],idx[i+1])<=mid:\n            adj[idx[i]].append(idx[i+1])\n            adj[idx[i+1]].append(idx[i])\n            # print(idx[i],idx[i+1])\n        if disy(idy[i],idy[i+1])<=mid:\n            adj[idy[i]].append(idy[i+1])\n            adj[idy[i+1]].append(idy[i])\n            # print(idy[i],idy[i+1])\n    col=[0 for i in range(n)]\n    cur=0\n    def dfs(x):\n        col[x]=cur\n        for i in range(len(adj[x])):\n            if col[adj[x][i]]==0:\n                dfs(adj[x][i])\n    for i in range(n):\n        if col[i]==0:\n            cur=cur+1\n            dfs(i)\n    ok=0\n    if cur>4:\n        ok=0\n    if cur==1:\n        ok=1\n    if cur==2:\n        for i in range(n):\n            for j in range(i+1,n):\n                if (col[i]!=col[j]):\n                    d1=abs(x[i]-x[j])\n                    d2=abs(y[i]-y[j])\n                    if d1==0 or d2==0:\n                        if d1+d2<=2*mid:\n                            ok=1\n                    if d1<=mid and d2<=mid:\n                        ok=1\n    if cur==3:\n        for i in range(n-1):\n            px=idx[i]\n            py=idx[i+1]\n            if x[px]==x[py] and col[px]!=col[py]:\n                for j in range(n):\n                    if col[px]!=col[j] and col[py]!=col[j]:\n                        d1=abs(y[px]-y[j])\n                        d2=abs(y[py]-y[j])\n                        d3=abs(x[px]-x[j])\n                        if d1<=mid and d2<=mid and d3<=mid:\n                            ok=1\n        for i in range(n-1):\n            px=idy[i]\n            py=idy[i+1]\n            if y[px]==y[py] and col[px]!=col[py]:\n                for j in range(n):\n                    if col[px]!=col[j] and col[py]!=col[j]:\n                        d1=abs(x[px]-x[j])\n                        d2=abs(x[py]-x[j])\n                        d3=abs(y[px]-y[j])\n                        if d1<=mid and d2<=mid and d3<=mid:\n                            ok=1\n    if cur==4:\n        for i in range(n-1):\n            px=idx[i]\n            py=idx[i+1]\n            if x[px]==x[py] and col[px]!=col[py]:\n                for j in range(n-1):\n                    pz=idy[j]\n                    pw=idy[j+1]\n                    if y[pz]==y[pw] and col[pz]!=col[pw]:\n                        if col[pz]!=col[px] and col[pz]!=col[py]:\n                            if col[pw]!=col[px] and col[pw]!=col[py]:\n                                d1=abs(y[px]-y[pz])\n                                d2=abs(y[py]-y[pz])\n                                d3=abs(x[pz]-x[px])\n                                d4=abs(x[pw]-x[px])\n                                if d1<=mid and d2<=mid and d3<=mid and d4<=mid:\n                                    ok=1\n    if ok:\n        ans=mid\n        r=mid-1\n    else:\n        l=mid+1\nprint(ans)
# python 3\n"""\n"""\n\n\ndef lefthanders_and_righthanders(n_int, student_list) -> list:\n    sitting_order = []\n    for i in range(n_int//2):\n        if student_list[i] == 'R' and student_list[i + n_int//2] == 'L':\n            sitting_order.append((i + n_int//2 + 1, i + 1))\n            print(i + n_int//2 + 1, i + 1)\n        else:\n            sitting_order.append((i + 1, i + n_int//2 + 1))\n            print(i + 1, i + n_int//2 + 1)\n    return sitting_order\n\n\ndef __starting_point():\n    """\n    Inside of this is the test. \n    Outside is the API\n    """\n    with open("input.txt", 'r') as f_input:\n        n = int(f_input.readline())\n        students = f_input.readline()\n        # print(n, students)\n\n    sitting = lefthanders_and_righthanders(n, students)\n    with open("output.txt", 'w') as f_output:\n        for each in sitting:\n            f_output.write(str(each[0]) + ' ' + str(each[1]) + '\n')\n\n__starting_point()
read = lambda: map(int, input().split())\nm, b = read()\nans = -1\ndef f(x, y):\n    return (x * (x + 1) * (y + 1) + y * (y + 1) * (x + 1)) // 2\nfor k in range(b + 3):\n    x = k * m\n    y = b - k\n    ans = max(ans, f(x, y))\nprint(ans)
from sys import *\n\nT = int(stdin.readline())\nt = [int(s) for s in stdin.readline().split(' ')]\n\na = []\nfor i in range(T - 1, -1, -1):\n\n    if i % 2 == 0:\n        a += [(e[0], -e[1]) for e in a]\n        a = [(e[0] - t[i], e[1]) for e in a]\n        a += [(- x - 1, 0) for x in range(t[i])]\n        a = list(set(a))\n\n    if i % 2 == 1:\n        a += [(e[1], -e[0]) for e in a]\n        a = [(e[0] - t[i], e[1] + t[i]) for e in a]\n        a += [(- x - 1, x + 1) for x in range(t[i])]\n        a = list(set(a))\n\nprint(len(a))\n
p = "AEFHIKLMNTVWXYZ"\nq = "BCDGJOPQRSU"\n\nword = input()\nx, y = 0, 0\nfor w in word:\n    if w in p:\n        x += 1\n    else:\n        y += 1\n\nif x == 0 or y == 0:\n    print("YES")\nelse:\n    print("NO")\n
import itertools\n\ndef valid(grid, path, perm, start, goal):\n    x, y = start\n    n = len(grid)\n    m = len(grid[0])\n    for move in path:\n        dx, dy = perm[int(move)]\n        x += dx\n        y += dy\n        if (x, y) == goal:\n            return True\n        if not (0 <= x < n and 0 <= y < m) or grid[x][y] == '#':\n            return False\n\n    return False\n\ndef main():\n    n, m = list(map(int, input().split()))\n    grid = [list(input()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                grid[i][j] = '.'\n            elif grid[i][j] == 'E':\n                gx, gy = i, j\n                grid[i][j] = '.'\n\n\n    path = input()\n    moves = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    ans = 0\n    for perm in itertools.permutations(moves):\n        if valid(grid, path, perm, (sx, sy), (gx, gy)):\n            ans += 1\n\n    print(ans)\n\nmain()\n
n = int(input())\npoints = [0] * n\nD = {}\nfor i in range(n):\n    points[i] = tuple(int(x) for x in input().split())\n\nfor i in range(n):\n    for j in range(i+1, n):\n        x1, y1 = points[i]\n        x2, y2 = points[j]\n        u, v = x2 - x1, y2 - y1\n        if u < 0 or u == 0 and v < 0:\n            u, v = -u, -v\n        if (u, v) in D:\n            D[(u, v)] += 1\n        else:\n            D[(u, v)] = 1\n\nS = sum(D[i] * (D[i] - 1) // 2 for i in D)\nprint(S // 2)\n                \n
n = int(input())\ns = input()\n\nnum = '0123456789'\nstate = [0]*(10)\nfor i in s:\n    if i in num:\n        state[int(i)] = 0\n    else:\n        if i=='L':\n            for j in range(10):\n                if state[j]==0:\n                    state[j] = 1\n                    break\n        else:\n            for j in range(9, -1, -1):\n                if state[j] == 0:\n                    state[j] = 1\n                    break\n\nfor i in state:\n    print(i, end='')\n        \n
import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nn=int(input())\nmod=10**9+7\n\nANS=[[0]*(n+1) for i in range(n+1)]\n\ndef bra(x,y):\n    if ANS[x][y]!=0:\n        return ANS[x][y]\n    \n    if x==y==0:\n        ANS[x][y]=0\n        return 0\n\n    if (x+y)%2==1:\n        A=1\n    else:\n        A=0\n\n    if x==y:\n        ANS[x][y]=A+bra(x-1,y)\n        return ANS[x][y]\n\n    elif x==0:\n        ANS[x][y]=A+bra(x,y-1)\n        return ANS[x][y]\n    \n    elif y==0:\n        ANS[x][y]=A+bra(x-1,y)\n        return ANS[x][y]\n\n    elif x<y and x!=0 and y!=0:\n        ANS[x][y]=A+bra(x-1,y)+bra(x,y-1)\n        return ANS[x][y]\n\nprint(bra(n,n)%mod)\n    \n        \n    \n
n = int(input())\nx, y = map(int, input().split())\nwhite = max(x - 1, y - 1)\nblack = max(n - x, n - y)\nprint("White" if white <= black else "Black")
#!/usr/bin/env python3\ndef solve():\n    n, k = list(map(int, input().split()))\n    temps = list(map(int, input().split()))\n\n    summer_seqs = []\n    winter_seqs = []\n\n    cur_season = 1\n    cur_len = 0\n    for t in temps:\n        # print("Handling", t)\n        if cur_season * t > 0 or (t == 0 and cur_season == 1):\n            cur_len += 1\n            # print("Adding...")\n        else:\n            # print("Thats new!")\n            if cur_season == 1:\n                summer_seqs.append(cur_len)\n            else:\n                winter_seqs.append(cur_len)\n            cur_len = 1\n            cur_season = -cur_season\n    if cur_season == 1:\n        summer_seqs.append(cur_len)\n    else:\n        winter_seqs.append(cur_len)\n\n    summer_seqs = summer_seqs[1:]\n\n    cur_len = sum(winter_seqs)\n\n    if cur_len > k:\n        return -1\n\n    if len(summer_seqs) == 0:\n        return 1 if len(winter_seqs) != 0 else 0\n\n    changes = len(summer_seqs) + len(winter_seqs)\n\n    last_sum_seq = None\n    if temps[-1] >= 0:\n        last_sum_seq = summer_seqs[-1]\n        summer_seqs = summer_seqs[:-1]\n\n    summer_seqs = list(sorted(summer_seqs))\n\n    # print("Changes needed so far:", changes)\n    # print("Summer seqs: ", len(summer_seqs))\n    # print("Last summer seq:", last_sum_seq)\n    # print("Can drive for another", k - cur_len)\n\n    for s in summer_seqs:\n        if k - cur_len >= s:\n            changes -= 2\n            cur_len += s\n        else:\n            break\n\n    # print("Before last summer we can drive for",\n    #       k - cur_len, "having ", changes, "changes")\n\n    if last_sum_seq is not None:\n        if k - cur_len >= last_sum_seq:\n            # print("and dont change at last")\n            changes -= 1\n\n    return changes\n\n\ndef __starting_point():\n    print(solve())\n\n__starting_point()
#!/usr/bin/env python3\n\ndef main():\n    a, b = list(map(int, input().split()))\n    x, y, z = list(map(int, input().split()))\n    print(max(x * 2 + y - a, 0) + max(y + z * 3 - b, 0))\n\ntry:\n    while True:\n        main()\nexcept EOFError:\n    pass\n
\nn, w, v, u = list(map(int, input().split()))\nversh = []\nfor i in range(n):\n    a, b = list(map(int, input().split()))\n    versh.append((a, b))\nversh.sort(key=lambda x : x[1])\nfor i in versh:\n    if i[0] / v < i[1] / u:\n        break\nelse:\n    print(w / u)\n    return\ny = 0\ntime = 0\nfor i in versh:\n    x = i[0] - time * v\n    if x < 0:\n        continue\n    if x / v >= (i[1] - y) / u:\n        time += x / v\n        y = i[1]\ntime += (w - y) / u\nprint(time)\n
import sys\n\ndef solve():\n    n, = rv()\n    a, = rl(1)\n    for i in range(min(10, n - 1)):\n        for j in range(max(i + 1, n - 10), n):\n            if a[i] != a[j]:\n                a[i], a[j] = a[j], a[i]\n                if notsorted(a):\n                    print(i + 1, j + 1)\n                    return\n                a[i], a[j] = a[j], a[i]\n    count = 0\n    for i in range(n - 1):\n        if a[i] != a[i + 1]:\n            a[i], a[i + 1] = a[i + 1], a[i]\n            if notsorted(a):\n                print(i + 1, i + 2)\n                return\n            a[i], a[i + 1] = a[i + 1], a[i]\n            count += 1\n        if count == 100: break\n    print(-1)\n\ndef notsorted(a):\n    first, second = True, True\n    for i in range(len(a) - 1):\n        if a[i] > a[i + 1]:\n            first = False\n            break\n    for i in range(len(a) - 1):\n        if a[i] < a[i + 1]:\n            second = False\n            break\n    return True if not first and not second else False\n\n\n\ndef prt(l): return print(''.join(l))\ndef rv(): return map(int, input().split())\ndef rl(n): return [list(map(int, input().split())) for _ in range(n)]\nif sys.hexversion == 50594544 : sys.stdin = open("test.txt")\nsolve()
n, b, p = map(int, input().split())\nanswer1 = 0\nanswer2 = n\nwhile n > 1:\n    k = 1\n    while k < n:\n        k *= 2\n    answer1 += k * b + (k // 2)\n    n = k // 2 + n - k\nprint(answer1, answer2 * p)
#!/usr/bin/env python3\ndef main():\n    M, K = map(int, input().split())\n    if K == 0:\n        print(*[i//2 for i in range(2**(M+1))])\n    else:\n        if K >= 2**M or M <= 1:\n            print(-1)\n        else:\n            nums = []\n            for i in range(2**M):\n                if i != K:\n                    nums.append(i)\n            a = [nums[0], K, nums[0]]\n            b = []\n            for i in range(1,2**M-1):\n                b.append(nums[i])\n            b.append(K)\n            for i in range(1,2**M-1):\n                b.append(nums[2**M-1-i])\n            print(*a,*b)\ndef __starting_point():\n    main()\n__starting_point()
from collections import Counter, defaultdict\nimport itertools\nimport sys\n\ndef main():\n    n = int(input())\n    spec = 3\n    poss = True\n    for _ in range(n):\n        winner = int(input())\n        if winner != spec:\n            spec = 6 - winner - spec\n        else:\n            poss = False\n    print('YES' if poss else 'NO')\n\n\n\nmain()\n
from math import ceil\ndef dist(x, y):\n    return (x ** 2 + y ** 2) ** 0.5\nr, x, y, x2, y2 = map(int, input().split())\nprint(ceil(dist(x - x2, y - y2) / (2 * r)))
n = int(input())\na = list(map(int, input().split()))\nd = []\nfor i in range(1, n):\n    d.append(a[i] - a[i - 1])\nd.append(a[0] - a[n - 1])\ncnt = 0\nfor i in range(0, n):\n    if d[i] < 0:\n        cnt += 1\n        pos = i\nif cnt == 0:\n    print(0)\nelif cnt > 1:\n    print(-1)\nelse:\n    print(n - pos - 1)\n
t = int(input())\nfor i in range(t):\n    n, s = [int(x) for x in input().split()]\n    a= [int(x) for x in input().split()]\n    need = -1\n    if (sum(a)) <= s:\n        print(0)\n    else:\n        for i in range(n):\n            if a[i] > need:\n                need= a[i]\n                index = i\n            if s - a[i] < 0:\n                print(index + 1)\n                break\n            s -= a[i]\n        \n
def f(m):\n    return m * (m + 1) // 2\n\nn = int(input())\nl, r = 0, n\nwhile r - l > 1:\n    m = (r + l) // 2\n    if f(m) >= n:\n        r = m\n    else:\n        l = m\nn -= f(l)\nprint(n)
#!/usr/bin/env python\n\nimport base64\n\n\nexec(base64.b64decode(b'Cm4gPSBpbnQoaW5wdXQoKSkKZ3JhcGggPSBbW2ludCh4KSBmb3IgeCBpbiBpbnB1dCgpLnNwbGl0KCldIGZvciBfIGluIHJhbmdlKG4pXQpkaXN0ID0gW3Jvd1s6XSBmb3Igcm93IGluIGdyYXBoXQoKZm9yIGsgaW4gcmFuZ2Uobik6CiAgICBmb3IgaSBpbiByYW5nZShuKToKICAgICAgICBmb3IgaiBpbiByYW5nZShuKToKICAgICAgICAgICAgaWYgZGlzdFtpXVtqXSA+IGRpc3RbaV1ba10gKyBkaXN0W2tdW2pdOgogICAgICAgICAgICAgICAgZGlzdFtpXVtqXSA9IGRpc3RbaV1ba10gKyBkaXN0W2tdW2pdCgpwcmludChtYXgobWF4KHggZm9yIHggaW4gcm93KSBmb3Igcm93IGluIGRpc3QpKQo='))\n
def solve():\n    n = int(input())\n    A = list(map(int, input().split()))\n    x, A = A[0], A[1:]\n    A = [(A[i], i + 2) for i in range(len(A))]\n    A.sort(reverse=True)\n\n    cnt = 1\n    msg = x\n    total = 1\n    for a in A:\n        if not msg:\n            print(-1)\n            return\n        msg += a[0] - 1\n        total += a[0]\n        cnt += 1\n        if total >= n:\n            break\n\n    print(n - 1)\n    total = x\n    for j in range(min(x, len(A))):\n        print(1, A[j][1])\n    if total >= n - 1:\n        return\n    for i in range(len(A)):\n        for j in range(total, min(total + A[i][0], len(A))):\n            print(A[i][1], A[j][1])\n            total += 1\n            if total >= n - 1:\n                return\n\n\nsolve()
import bisect\n\nn, m = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\n\n# n : number of integers\n# m : mod\n\nhalf_n = n // 2\n\na1, a2 = a[:half_n], a[half_n:]\n\nn1, n2 = len(a1), len(a2)\n\nr1, r2 = [], []\n\ndef dfs1(i, sum):\n    if i == n1:\n        r1.append(sum)\n    else:\n        dfs1(i+1, sum)\n        dfs1(i+1, (sum+a1[i])%m)\n\ndef dfs2(i, sum):\n    if i == n2:\n        r2.append(sum)\n    else:\n        dfs2(i+1, sum)\n        dfs2(i+1, (sum+a2[i])%m)\n\ndfs1(0,0)\ndfs2(0,0)\n\nr1, r2 = [sorted(set(x)) for x in [r1, r2]]\n\nans = 0\n\nfor i, x in enumerate(r1):\n    p = bisect.bisect_left(r2, m-x)\n    tmp_ans = r2[p-1] + x\n    if tmp_ans > ans:\n        ans = tmp_ans\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n
a, b, c = list(map(int, input().split()))\nx1, y1, x2, y2 = list(map(int, input().split()))\nans0 = round(abs(x1 - x2) + abs(y1 - y2), 9)\nif a * b ==0:\n    print(ans0)\n    raise SystemExit\nx11 = (-c - b * y1) / a\ny12 = (-c - a * x1) / b\nx21 = (-c - b * y2) / a\ny22 = (-c - a * x2) / b\n\nans1 = abs(x1 - x11) + abs(x21 - x2) + ((y2 - y1)**2 + (x21 - x11)**2)**0.5\nans2 = abs(y1 - y12) + abs(x21 - x2) + ((y2 - y12)**2 + (x21 - x1)**2)**0.5\nans3 = abs(y1 - y12) + abs(y2 - y22) + ((x1 - x2)**2 + (y12 - y22)**2)**0.5\nans4 = abs(x1 - x11) + abs(y22 - y2) + ((x11 - x2)**2 + (y1 - y22)**2)**0.5\n\nans0 = min(ans0, ans1, ans2, ans3, ans4)\n\nprint(round(ans0, 10))\n
s=""\nfor i in range(10000):\n    s+=str(i)\nprint(s[int(input())])
# fin = open("input.txt")\n# a, b = map(int, fin.readline().split())\na, b = list(map(int, input().split()))\na2 = a - b\nif a2 == 0:\n	print("infinity")\nelse:\n	Count = 0\n	i = 1\n	while i ** 2 <= a2:\n		Count += (a2 % i == 0 and i > b) + (a2 % i == 0 and a2 // i > b and i != a2 // i)\n		i += 1\n	print(Count)\n
n, k = list(map(int, input().split()))\nprint(k * (n // k + 1))\n
n = int(input())\n\nwrong_str = False\n\nstrings = []\nsets = []\nfor _ in range(n):\n    new_string = input()\n    new_string_set = set(new_string)\n    if len(new_string) != len(new_string_set):\n        wrong_str = True\n        break\n\n    strings.append(new_string)\n    sets.append(new_string_set)\n\nif wrong_str:\n    print("NO")\n    return\n\n\nconnections = []\nfor _ in range(n):\n    connections.append((-1,-1))\n\nchanged = True\n\nwhile changed:\n\n    changed = False\n\n    for i in range(len(strings)):\n\n        if strings[i] == None:\n            continue\n\n        for j in range(i + 1, len(strings)):\n\n            if strings[j] == None:\n                continue\n\n            if len(set(strings[i]).intersection(set(strings[j]))) == 0:\n                continue\n\n            a = strings[i]\n            b = strings[j]\n\n            #print(a, b)\n\n            if b in a:\n                strings[j] = None\n                changed = True\n            elif a in b:\n                strings[i] = b\n                strings[j] = None\n                changed = True\n            else:\n\n                is_ok = False\n\n                start_index = a.find(b[0])\n                if start_index != -1 and a[start_index:] in b:\n                    strings[i] += strings[j][len(a) - start_index:]\n                    strings[j] = None\n                    is_ok = True\n                    changed = True\n\n                if not is_ok:\n                    start_index = b.find(a[0])\n                    if start_index != -1 and  b[start_index:] in a:\n                        strings[i] = strings[j] + strings[i][len(b) - start_index:]\n                        strings[j] = None\n                        is_ok = True\n                        changed = True\n\n                if not is_ok:\n                    print("NO")\n                    return\n\n\n\n\n        if wrong_str:\n            print("NO")\n            return\n\n    strings = [x for x in strings if x is not None]\n\nwhole_str = "".join(strings)\n\nif len(whole_str) != len(set(whole_str)):\n    print("NO")\n    return\n\nprint("".join(sorted(strings)))\n\n\n\n
"""\nCodeforces Contest 288 Div 2 Problem C\n\nAuthor  : chaotic_iak\nLanguage: Python 3.4.2\n"""\n\n################################################### SOLUTION\n\ndef main():\n    m,t,r = read()\n    w = read()\n    if t < r: return -1\n    covers = [0]*1000\n    ct = 0\n    for i in w:\n        x = covers[i]\n        for j in range(r-x):\n            for k in range(t):\n                covers[i-j+k] += 1\n            ct += 1\n    return ct\n\n\n\n#################################################### HELPERS\n\n\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
n = int(input())\na = []\nfor i in range(n):\n    a.append(int(input()))\na = sorted(a)\n#print(a)\nif n == 0:\n    print('YES')\n    print(1)\n    print(1)\n    print(3)\n    print(3)\nelif n == 1:\n    print('YES')\n    print(a[0])\n    print(3 * a[0])\n    print(3 * a[0])\nelif n == 2:\n    if a[0] * 3 >= a[1]:\n        print('YES')\n        print(a[0] * 3)\n        print(a[0] * 4 - a[1])\n    elif a[1] % 3 == 0 and a[1] // 3 <= a[0]:\n        print('YES')\n        print(a[1] // 3)\n        print(a[1] + a[1] // 3 - a[0])\n    elif (a[0] + a[1]) % 4 == 0 and (a[0] + a[1]) // 4 <= a[0]:\n        print('YES')\n        print((a[0] + a[1]) // 4)\n        print(3 * ((a[0] + a[1]) // 4))\n    else:\n        print('NO')\nelif n == 3:\n    if a[0] * 3 >= a[2] and 4 * a[0] == a[1] + a[2]:\n        print('YES')\n        print(a[0] * 3)\n    elif a[2] % 3 == 0 and a[2] // 3 <= a[0] and a[2] + a[2] // 3 == a[0] + a[1]:\n        print('YES')\n        print(a[2] // 3)\n    elif a[2] == a[0] * 3:\n        print('YES')\n        print(4 * a[0] - a[1])\n    else:\n        print('NO')\nelif n == 4:\n    if a[3] == 3 * a[0] and a[0] + a[3] == a[1] + a[2]:\n        print('YES')\n    else:\n        print('NO')
q = int(input())\nfor _ in range(q):\n    l, r, d = list(map(int, input().split()))\n    if d < l:\n        print(d)\n    else:\n        v = d * (r // d)\n        while v <= r:\n            v += d\n        print(v)\n
foo = baz = 0\nquz = 1\nfor bar in range(1, int(input()) + 1):\n    foo += int(input())\n    if foo * quz < baz * bar: break\n    baz, quz = foo, bar\nprint(baz / quz)
def main():\n    s = input()\n    n = len(s)\n    poss = False\n    for i in range(n - 2):\n        t = s[i:i + 3]\n        if 'A' in t and 'B' in t and 'C' in t:\n            poss = True\n            break\n    print('Yes' if poss else 'No')\n\n\nmain()\n
ax, ay = list(map(int, input().split()))\nbx, by = list(map(int, input().split()))\ncx, cy = list(map(int, input().split()))\n\n\ndef f(cx, ax, bx, cy, ay, by):\n    mxy = max(ay, by, cy)\n    mny = min(ay, by, cy)\n    print(abs(cx - bx) + mxy - mny + 1)\n    for i in range(mny, mxy + 1):\n        print(ax, i)\n    if cx <= bx:\n        for i in range(cx, ax):\n            print(i, cy)\n        for i in range(ax + 1, bx + 1):\n            print(i, by)\n    else:\n        for i in range(bx, ax):\n            print(i, by)\n        for i in range(ax + 1, cx + 1):\n            print(i, cy)\n\n\nif cx <= ax <= bx or bx <= ax <= cx:\n    f(cx, ax, bx, cy, ay, by)\nelif cx <= bx <= ax or ax <= bx <= cx:\n    f(cx, bx, ax, cy, by, ay)\nelif bx <= cx <= ax or ax <= cx <= bx:\n    f(bx, cx, ax, by, cy, ay)\n
import sys\n\nMOD = 10**9+7\n\n# Polymod\ndef polymod(P,Q):\n    assert(Q[-1]==1)\n    n = len(Q)\n    while len(P)>=n:\n        p = P[-1]\n        for i in range(n):\n            P[-i-1] -= p*Q[-i-1]\n        assert(P[-1]==0)\n        P.pop()\n    return P\n\ndef polyprod(P,Q):\n    n = len(P)\n    m = len(Q)\n    W = [0]*(n+m-1)\n    for i in range(n):\n        for j in range(m):\n            W[i+j]+=P[i]*Q[j]\n    return [w%MOD for w in W]\n\n# Calc A^m * B \ndef power(A,B,m,mult):\n    if m == 0:\n        return B\n    while m>1:\n        if m%2==1:\n            B = mult(A,B)\n        A = mult(A,A)\n        m//=2\n    return mult(A,B)\n    \ndef calc_nth_term(init,linear_coeff,n):\n    def mult(A,B):\n        return polymod(polyprod(A,B),linear_coeff)\n    \n    ans = power([0,1],[1],n,mult)\n    return sum(ans[i]*init[i] for i in range(len(ans)))\n\n\nn,m = [int(x) for x in input().split()]\n\nlinear_rec = [0]*(m+1)\nlinear_rec[0] = -1\nlinear_rec[m-1] = -1\nlinear_rec[m] = 1\n\nprint(calc_nth_term([1]*m,linear_rec,n)%MOD)\n
import math\n\nx1, y1, x2, y2 = map(int, input().split())\nif (x1 == x2) and (y1 == y2):\n    print(0, 0, 0)\nelse:    \n    # ladya\n    if (x1 == x2) or (y1 == y2):\n        l = 1\n    else:\n        l = 2\n    \n    #slon\n    if (abs(x1 - x2) == abs(y1 - y2)):\n        s = 1\n    elif ((x1 + y1) % 2 == (x2 + y2) % 2): \n        s = 2\n    else:\n        s = 0\n\n    #korol\n    k = max(abs(x1 - x2), abs(y1 - y2))\n    print(l, s, k)
import sys\na = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8092, 16184, 32368, 64736, 129472, 258944, 517888, 1035776, 2071552, 4143104, 8286208, 16572416, 33144832, 66289664, 132579328, 265158656, 530317312, 1060634624, 2121269248, 4242538496, 8485076992, 16970153984, 33940307968]\n\n\nprint(a[int(sys.stdin.readline())])
t=int(input())\nfor j in range(t):\n  a,b,c,d=map(int, input().split())\n  print(b,c,c)
from bisect import bisect_left\n\nn, h = map(int, input().split())\nx1, x2 = map(int, input().split())\nif n == 1:\n	print(h + x2 - x1)\nelse:\n	gap_sum = [0]\n	airflow_sum = [x2 - x1]\n	for _ in range(n - 1):\n		oldx1, oldx2 = x1, x2\n		x1, x2 = map(int, input().split())\n		gap_sum.append(gap_sum[-1] + x1 - oldx2)\n		airflow_sum.append(airflow_sum[-1] + x2 - oldx2)\n\n	#print(gap_sum)\n	#print(airflow_sum)\n\n	ans = h\n	for i in range(n):\n		cnt = bisect_left(gap_sum, h + gap_sum[i])\n		if i == 0:\n			res = airflow_sum[cnt-1] + h - gap_sum[cnt-1]\n		else:\n			res = airflow_sum[cnt-1] - (airflow_sum[i-1] + gap_sum[i] - gap_sum[i - 1]) + h - (gap_sum[cnt-1] - gap_sum[i])\n\n		if res > ans:\n			ans = res\n	print(ans)
for _ in range(int(input())):\n    x, y = list(map(int, input().split()))\n    s = x - y\n    if s == 1:\n        print('NO')\n    else:\n        print('YES')\n
a, b = map(int, input().split())\nif a == 9 and b == 1:\n    print(9, 10)\nelif a == b - 1:\n    print(a, b)\nelif a == b:\n    print(a * 10, a * 10 + 1)\nelse:\n    print(-1)
t1  = map(int,input().strip())\nt2 = map(int,input().strip())\nar1 = [0] * 10\nar2  = [0]*10\nfor j in t1:\n    ar1[j]+=1\nfor j in t2:\n    ar2[j]+=1\nar1[2]+=ar1[5]\nar1[6]+=ar1[9]\nar1[5]=ar1[9]=0\nar2[2]+=ar2[5]\nar2[6]+=ar2[9]\nar2[5]=ar2[9]=0\nprint(int(min(map(lambda x:ar2[x]/ar1[x] if ar1[x]!=0 else 100500 ,range(10)))))
from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop,heapify\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\nfrom itertools import accumulate\nfrom functools import lru_cache\n\nM = mod = 998244353\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\n').split()]\ndef st():return input().rstrip('\n')\ndef val():return int(input().rstrip('\n'))\ndef li2():return [i for i in input().rstrip('\n')]\ndef li3():return [int(i) for i in input().rstrip('\n')]\n\n\nfor _ in range(val()):\n    n = val()\n    cnt = Counter()\n    for j in range(n):\n        cnt += Counter(st())\n    \n    ans = 1\n    for i in cnt:\n        if cnt[i] % n:\n            ans = 0\n    print('YES' if ans else 'NO')
N = input()\nfor digit in N[::-1]:\n    Os = int(digit)%5\n    if int(digit) >= 5:\n        print("-O|"+Os*"O"+"-"+(4-Os)*"O")\n    else:\n        print("O-|"+Os*"O"+"-"+(4-Os)*"O")\n
n, x = input().split()\nn, x = int(n), int(x)\n\nm1 = 2 ** 17\nm2 = 2 ** 18\n\nif n == 2 and x == 0:\n    print("NO")\nelif n == 1:\n    a = [x]\nelif n == 2 and x > 0:\n    a = [0, x]\nelse:\n    a = []\n    ans = 0\n    for i in range(1, n-2):\n        ans ^= i\n        a.append(i)\n    if ans == x:\n        a.append(m1)\n        a.append(m2)\n        a.append(m1+m2)\n    else:\n        a.append(m1)\n        a.append(m1 ^ x ^ ans)\n        a.append(0)\nif not (n == 2 and x == 0):\n    print("YES")\n    print(" ".join([str(e) for e in a]))\n
ct = 0\nx = int(input())\ny = list(map(int, input().split(' ')))\nz = list(map(int, input().split(' ')))\nfor i in range(1, 720721):\n    for j in range(x):\n        if i%y[j] == z[j]:\n            ct+=1\n            break\nprint(ct/720720)\n
from collections import defaultdict\n\n\nn, m = list(map(int, input().split()))\n\nns = list(map(int, input().split()))\nms = list(map(int, input().split()))\nsumms = sum(ms)\n\ntarget = {\n    i: m\n    for i, m in enumerate(ms, 1)\n}\nremain = set(i for i, m in list(target.items()) if m != 0)\n\ncount = defaultdict(int)\n\na = 0\nb = 0\n\nwhile remain and b < n:\n    count[ns[b]] += 1\n    if ns[b] in remain and target[ns[b]] <= count[ns[b]]:\n        remain.remove(ns[b])\n    b += 1\n\nif remain:\n    print(-1)\nelse:\n    ans = b - summs\n    while b <= n:\n        if remain:\n            if b >= n:\n                break\n            count[ns[b]] += 1\n            if ns[b] in remain and target[ns[b]] <= count[ns[b]]:\n                remain.remove(ns[b])\n            b += 1\n        else:\n            count[ns[a]] -= 1\n            if target[ns[a]] > count[ns[a]]:\n                remain.add(ns[a])\n            else:\n                ans = min(ans, b - a - 1 - summs)\n            a += 1\n\n    print(ans)\n
def main():\n    s, x, pfx = input(), 0, []\n    a, b = list(map(int, input().split()))\n    try:\n        for i, c in enumerate(s, 1):\n            x = (x * 10 + ord(c) - 48) % a\n            if not x and s[i] != '0':\n                pfx.append(i)\n    except IndexError:\n        pass\n    x, p, i = 0, 1, len(s)\n    for stop in reversed(pfx):\n        for i in range(i - 1, stop - 1, -1):\n            x = (x + (ord(s[i]) - 48) * p) % b\n            p = p * 10 % b\n        if not x:\n            print("YES")\n            print(s[:i])\n            print(s[i:])\n            return\n    print("NO")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
import math\nimport re\nfrom fractions import Fraction\n\nclass Task:\n    table = ['111111101010101111100101001111111\n', '100000100000000001010110001000001\n', '101110100110110000011010001011101\n', '101110101011001001111101001011101\n', '101110101100011000111100101011101\n', '100000101010101011010000101000001\n', '111111101010101010101010101111111\n', '000000001111101111100111100000000\n', '100010111100100001011110111111001\n', '110111001111111100100001000101100\n', '011100111010000101000111010001010\n', '011110000110001111110101100000011\n', '111111111111111000111001001011000\n', '111000010111010011010011010100100\n', '101010100010110010110101010000010\n', '101100000101010001111101000000000\n', '000010100011001101000111101011010\n', '101001001111101111000101010001110\n', '101101111111000100100001110001000\n', '000010011000100110000011010000010\n', '001101101001101110010010011011000\n', '011101011010001000111101010100110\n', '111010100110011101001101000001110\n', '110001010010101111000101111111000\n', '001000111011100001010110111110000\n', '000000001110010110100010100010110\n', '111111101000101111000110101011010\n', '100000100111010101111100100011011\n', '101110101001010000101000111111000\n', '101110100011010010010111111011010\n', '101110100100011011110110101110000\n', '100000100110011001111100111100000\n', '111111101101000101001101110010001\n']\n\n    x, y = 0, 0 \n    answer = 0\n    \n    def __init__(self):\n        self.x, self.y = [int(_) for _ in input().split()]\n        #inFile = open('input.txt', 'r')\n        #self.table = inFile.readlines()\n\n    def solve(self):\n        table, x, y = self.table, self.x, self.y\n        self.answer = table[x][y]\n\n    def printAnswer(self):\n        print(self.answer)\n\ntask = Task()\ntask.solve()\ntask.printAnswer()\n
x=int(input())\nif(x==2):\n    print(1)\nelse:\n    x-=1\n    cnt=0\n    for i in range(1,x):\n        ok=0\n        for j in range(2,i+1):\n            if(x%j==0 and i%j==0): ok=1\n        if(ok==0) :cnt+=1\n    print(cnt)\n
n, m = list(map(int, input().split()))\nmod = 998244853\nfact = [1]\ninvfact = [1]\ndef pw(x, y):\n    ans = 1\n    while (y):\n        if (y & 1):\n            ans = (ans * x) % mod\n        x = x * x % mod\n        y >>= 1\n    return ans\ndef inv(x):\n    return pw(x, mod - 2)\nfor i in range(1, n + m + 1):\n    fact.append(fact[i - 1] * i % mod)\n    invfact.append(invfact[i - 1] * inv(i) % mod)\nmn = max(0, n - m)\ndef ways_to(sub):\n    inc = (n + m + sub) // 2\n    return fact[n + m] * invfact[inc] * invfact[n + m - inc] % mod\nans = 0\nways = [0 for x in range(0, n + 2)]\nfor i in range (mn, n + 1):\n    ways[i] = ways_to(n - m) - ways_to(2 * i - n + m)\nways[n + 1] = ways_to(n - m)\nfor i in range(1, n + 1):\n    ans += i * (ways[i + 1] - ways[i])\n    ans %= mod\nif (ans < 0) :\n    ans += mod\nprint(ans)\n
X,n=list(map(int,input().split()))\n\n\nTaken=[True]*(X+1)\nfor i in range(n):\n    x=list(map(int,input().split()))\n    if(x[0]==1):\n        Taken[x[1]]=False\n        Taken[x[2]]=False\n    else:\n        Taken[x[1]]=False\ncnt=0\nminn=0\nmaxx=0\nans=0\nfor i in range(1,X):\n    if(Taken[i]):\n        cnt+=1\n        maxx+=1\n    else:\n        ans+=cnt//2\n        if(cnt%2!=0):\n            ans+=1\n        cnt=0\nans+=cnt//2\nif(cnt%2!=0):\n    ans+=1\nprint(ans,maxx)\n
import sys\nf = sys.stdin\n# f = open("input.txt", "r")\ny, k, n = map(int, f.readline().strip().split())\n\nif y >= n:\n    first = -1\nelse:\n    t = k\n    while t <= y:\n        t += k\n    first = t-y\nif first == -1:\n    print(-1)\nelse:\n    if first+y > n:\n        print(-1)\n    else:\n        res = []\n        for i in range(first, n+1-y, k):\n            res.append(i)\n        print(*res)
3\n\nimport copy\n\n\ndef rotate90(n, f):\n    return [[f[n - j - 1][i] for j in range(n)] for i in range(n)]\n\ndef fliphor(n, f):\n    return [[f[i][n - j - 1] for j in range(n)] for i in range(n)]\n\ndef flipver(n, f):\n    return [[f[n - i - 1][j] for j in range(n)] for i in range(n)]\n\ndef eq(n, f, g):\n    for i in range(n):\n        for j in range(n):\n            if f[i][j] != g[i][j]:\n                return False\n    return True\n\n\nn = int(input())\nf = [list(input()) for i in range(n)]\ng = [list(input()) for i in range(n)]\n\nfor doflipv in range(2):\n    for dofliph in range(2):\n        for nrot in range(4):\n            h = copy.deepcopy(f)\n            if dofliph == 1:\n                h = fliphor(n, h)\n            if doflipv == 1:\n                h = flipver(n, h)\n            for i in range(nrot):\n                h = rotate90(n, h)\n            if eq(n, h, g):\n                print("Yes")\n                return\n\nprint("No")
s, t = input(), input()\nsx, tx = str(sorted(s)), str(sorted(t))\n\ndef subset(s, t):\n    i = 0\n    for c in s:\n        if c == t[i]: i += 1\n        if i == len(t): break\n    return i == len(t)\n\nif sx == tx:\n    print("array")\nelif subset(s, t):\n    print("automaton")\nelif subset(sx, tx):\n    print("both")\nelse:\n    print("need tree")\n
n = int(input())\n\nboard =[]\n\nfor i in range(n):\n    board.append(list(input()))\n    \nf = 1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == '.':\n            if i < n - 2 and j < n - 1 and j > 0 and board[i+1][j] == '.' and board[i+2][j] == '.' and board[i+1][j-1] == '.' and board[i+1][j+1] == '.':\n                board[i+1][j] = '#'\n                board[i+2][j] = '#'\n                board[i+1][j-1] = '#'\n                board[i+1][j+1] = '#'\n            else:\n                f = 0\n                break\n\nif f == 1:\n    print("YES")\nelse:\n    print("NO") 
k, a, b, v = map(int, input().split())\nfor i in range(1, 1010):\n    if a <= v * (i + min(b, (k - 1) * i)):\n        print(i)\n        break
import sys\nsys.stdin = open('input.txt')\nsys.stdout = open('output.txt','w')\n\nn = int(input())\na = list(map(int, input().split()))\n\nr1, c1, r2, c2 = (i - 1 for i in map(int, input().split()))\nx, y = (r1, r2) if r1 < r2 else (r2, r1)\n\nif r1 < r2: c1 = min(c1, min(a[i] for i in range(r1 + 1, r2 + 1)))\nelif r2 < r1: c1 = min(c1, min(a[i] for i in range(r2, r1)))\n\nd = abs(c1 - c2)\nc = c1\nfor i in range(x - 1, -1, -1):\n    if c > a[i]:\n        c = a[i]\n        q = abs(c2 - c) + 2 * abs(x - i)\n        if q < d: d = q\nc = c1\nfor i in range(y + 1, n):\n    if c > a[i]:\n        c = a[i]\n        q = abs(c2 - c) + 2 * abs(i - y)\n        if q < d: d = q\nprint(d + abs(r2 - r1))
print('Karen')
a, b, n, x = list(map(int, input().split(' ')))\nfir = pow(a, n, 10**9+7)*x%(10**9+7)\nsec = b*(pow(a, n, 10**9+7)-1)*(pow(a-1, 10**9+5, 10**9+7))%(10**9+7)\nif (a == 1):\n    sec = n * b\nprint((fir+sec)%(10**9+7))\n
import sys\ninput=sys.stdin.readline\n\ndef gcd(x,y):\n    if y==0:\n        return x\n    if x<y:\n        x,y=y,x\n    return gcd(y,x%y)\n\nn,m=map(int,input().split())\nX=list(map(int,input().split()))\nP=list(map(int,input().split()))\nd=X[1]-X[0]\nfor i in range(2,n):\n    d=gcd(d,X[i]-X[i-1])\nfor i,p in enumerate(P):\n    if d%p==0:\n        print('YES')\n        print(X[0],i+1)\n        break\nelse:\n    print('NO')
def main():\n	(n, k) = (int(x) for x in input().split())\n	(a, b, c, d) = (int(x) for x in input().split())\n	(path1, path2) = solver(n, k, a, b, c, d)\n	if path1 == None:\n		print(-1)\n	else:\n		for x in path1:\n			print(x, end = ' ')\n		print()\n		for x in path2:\n			print(x, end = ' ')\n\ndef solver(n, k, a, b, c, d):\n	if k <= n or n == 4:\n		return (None, None)\n	else:\n		path1 = [a, c] + \\n		[i for i in range(1, n + 1) if i not in (a, b, c, d)] + \\n		[d, b]\n		path2 = [c, a] + \\n		[i for i in range(1, n + 1) if i not in (a, b, c, d)] + \\n		[b, d]\n		return (path1, path2)\n\nmain()\n#print(solver(7, 11, 2, 4, 7, 3))\n\n# def reorder(path, n, a, b, c, d):\n# 	for i in range(len(path)):\n# 		if path[i] == a:\n# 			path[i] = 1\n# 		elif path[i] == b:\n# 			path[i] = n\n# 		elif path[i] == c:\n# 			path[i] = 2\n# 		elif path[i] == d:\n# 			path[i] = 3\n# 		elif path[i] == 1:\n# 			path[i] = a\n# 		elif path[i] == n:\n# 			path[i] = b\n# 		elif path[i] == 2:\n# 			path[i] = c\n# 		elif path[i] == 3:\n# 			path[i] = d
n = int(input())\nans = 1\n\nwhile n != 1:\n    if  n % 2 == 1:\n        ans += 1\n        n -= 1\n    else:\n        n //= 2\n\nprint(ans)
g = "ACTG"\n\ndef dist(a, b):\n    p = abs(ord(a) - ord(b))\n    return min(p, 26 - p)\n\ndef price(s):\n    return sum(dist(x, y) for x, y in zip(g, s))\n\nn = int(input())\ns = input()\nans = 100000\nfor i in range(len(s) - 3):\n    ans = min(ans, price(s[i:i+4]))\nprint(ans)\n
import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\nclass CmbMod:\n    def __init__(self, n, p):\n        """\n        二項係数nCr(n個の区別できるものからr個のものを選ぶ組み合わせの数)をpで割った余りを求める\n        """\n        self.n = n\n        self.p = p\n        self.fact = [1, 1]\n        self.factinv = [1, 1]\n        self.inv = [0, 1]\n\n    def cmb_mod(self, n, r):\n        """\n        二項係数nCr(mod p)をO(r)にて計算。nが大きいがrは小さい時に使用。\n        """\n        numer, denom = 1, 1\n        for i in range(r):\n            numer = (numer * (n - i)) % self.p\n            denom = (denom * (i + 1)) % self.p\n        return (numer * pow(denom, self.p - 2, self.p)) % self.p\n\n    def prep(self):\n        """\n        二項係数nCr(mod p)をO(1)で求める為の前処理をO(N)にて実行。\n        """\n        for i in range(2, self.n + 1):\n            self.fact.append((self.fact[-1] * i) % self.p)\n            self.inv.append((-self.inv[self.p % i] * (self.p // i)) % self.p)\n            self.factinv.append((self.factinv[-1] * self.inv[-1]) % self.p)\n\n    def cmb_mod_with_prep(self, n, r):\n        """\n        二項係数nCr(mod p)をO(1)で求める。事前にprepを実行する事。\n        """\n        if (r < 0) or (n < r):\n            return 0\n        r = min(r, n - r)\n        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p\n\n\ndef prime_factorization(n):\n    res = []\n    for i in range(2, int(pow(n, 0.5)) + 1):\n        if n % i == 0:\n            ex = 0\n            while n % i == 0:\n                ex += 1\n                n //= i\n            res.append(ex)\n    if n != 1:\n        res.append(1)\n    return res\n\n\ndef resolve():\n    N, M = list(map(int, input().split()))\n\n    pf = prime_factorization(M)\n    cmb = CmbMod(10 ** 6, mod)\n    cmb.prep()\n\n    res = 1\n    for b in pf:\n        res *= cmb.cmb_mod_with_prep(b + N - 1, b)\n        res %= mod\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()
a = input().split()\nn = int(a[0])\np = float(a[1])\nt = int(a[2])\nden = 100 ** t\np = round(p * 100 + 1e-9)\nq = 100 - p\nncr = [1 for i in range(2001)]\nfor i in range(1, t + 1):\n        ncr[i] = ncr[i - 1] * (t - i + 1) // i\nans = 0\nfor i in range(2001):\n        ans += min(i, n) * ncr[i] * (p ** i) * (q ** (t - i)) if t >= i else 0\nans /= den\nprint(ans)\n
s=min(list(map(int,input().split())))\nprint(s+1)\nfor i in range(s+1):print(i,s-i)\n
n = int(input())\nA = list(map(int, input().split()))\nfor i in range(n):\n    A[i] = [A[i], i+1]\nA.sort()\nfor i in range(n//2):\n    print(A[i][1], A[n-i-1][1])
"""\nCodeforces Round 250 Div 2 Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\nclass IOHandlerObject(object):\n    def getInput(self, mode=2):\n        # 0: String\n        # 1: List of strings\n        # 2: List of integers\n        inputs = input().strip()\n        if mode == 0:\n            return inputs\n        if mode == 1:\n            return inputs.split()\n        if mode == 2:\n            return [int(x) for x in inputs.split()]\n\n    def writeOutput(self, s="\n"):\n        if isinstance(s, list): s = " ".join(s)\n        print(s)\n\nIOHandler = IOHandlerObject()\ng = IOHandler.getInput\nw = IOHandler.writeOutput\n\n############################## SOLUTION ##############################\na,b,c,d = g(0),g(0),g(0),g(0)\nr = [(len(a)-2,0), (len(b)-2,1), (len(c)-2,2), (len(d)-2,3)]\nr.sort()\nt = -1\nif r[0][0]*2 <= r[1][0]: t = r[0][1]\nif r[3][0] >= r[2][0] * 2:\n    if not t+1:\n        t = r[3][1]\n    else:\n        t = 5\n\nif t == -1 or t == 5:\n    print("C")\nelse:\n    print(chr(65+t))
n, a, b = list(map(int, input().split()))\nm = input()\nif m[a - 1] == m[b - 1]:\n    print(0)\nelse:\n    print(1)
n = int(input())\nans = 0\nfor i in range(n):\n	s, d = list(map(int, input().split()))\n	visit = s\n	while visit <= ans:\n		visit += d\n	ans = visit\nprint(ans)\n\n
a = int(input())\nfor i in range(a+1, a+47):\n    if ('8' in str(i)):\n        print(i-a)\n        break\n\n
from collections import defaultdict\nk = int(input())\n\nd = defaultdict(list)\n\nfor i in range(10):\n    d[(1, i)].append(i)\n\nmx = 10\npw = 1\nfor digs in range(2, mx):\n    pw *= 10\n    for sm in range(11):\n        for curr in range(10):\n            for num in d[(digs-1, sm-curr)]:\n                d[(digs, sm)].append( curr*pw + num )\n\nperfects = sorted(d[(mx-1, 10)])\n#print(len(perfects))\nprint(perfects[k-1])\n
def main():\n    n = int(input())\n    res = 0\n    la, lb = 0, 0\n    max_draw = -1\n    for _ in range(n):\n        a, b = [int(x) for x in input().split()]\n        mx = max(la, lb)\n        mn = min(a, b)\n        if mx <= max_draw:\n            mx = max_draw + 1\n        if mx <= mn:\n            res += mn - mx + 1\n            max_draw = mn\n        la, lb = a, b\n    print(res)\n\ndef __starting_point():\n    main()\n\n__starting_point()
n,d=list(map(int,input().split()))\n\nA=list(map(int,input().split()))\n\nm=int(input())\n\nA.sort()\n\nif(m<=n):\n    print(sum(A[:m]))\n\nelse:\n    print(sum(A)-(d*(m-n)))\n
def main():\n    l = []\n    for i in range(int(input())):\n        y, n, m = 1989, 0, 1\n        for d in input()[-1:3:-1]:\n            n += (ord(d) - 48) * m\n            m *= 10\n            t = n - y % m\n            y += (m + t if t < 0 else t) + m\n        l.append(y - m)\n    print('\n'.join(map(str, l)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
def main():\n    import sys\n    \n    tokens = [int(i) for i in sys.stdin.read().split()]\n    tokens.reverse()\n    \n    n = tokens.pop()\n    people = [(tokens.pop(), tokens.pop()) for i in range(n)]\n    \n    result = float("inf")\n    for i in range(n):\n        for j in range(2):\n            maxh = people[i][j]\n            S = people[i][j ^ 1]\n            for k in range(n):\n                if k != i:\n                    w, h = people[k]\n                    w, h = min(w, h), max(w, h)\n                    if w > maxh:\n                        S = float("inf")\n                        break\n                    if h > maxh:\n                        S += h\n                    else:\n                        S += w\n            result = min(result, S * maxh)\n    \n    print(result)\n                \n    \n    \nmain()\n
import sys\n\ndef read_int():\n    return int(input())\n\ndef read_ints():\n    return [int(x) for x in input().split()]\n\nn, d = read_ints()\na = read_ints()\n\na = sorted(a)\n\nbest = 0\n\nfor i in range(n):\n    for j in range(i, n):\n        if a[j] - a[i] <= d:\n            best = max(best, j - i + 1)\n\nprint(len(a) - best)\n
\nn, m = list(map(int, input().split()))\nfor i in range(n):\n    for j in input().split():\n        if j in "CMY":\n            print("#Color")\n            return\nprint("#Black&White")\n
read = lambda: map(int, input().split())\nn, d = read()\nx = sorted(read())\nans = 2\nfor i in range(1, n):\n    dx = x[i] - x[i - 1]\n    if dx == 2 * d:\n        ans += 1\n    elif dx > 2 * d:\n        ans += 2\nprint(ans)
from sys import stdin\nfrom heapq import heappop, heappush, heapify\ndef main():\n    n = int(stdin.readline())\n    a = stdin.readline().split()\n    q = []\n    p = 0\n    c = 0\n    l = [0] * (n + 1)\n    r = [0] * (n + 1)\n    k = [0] * (n + 1)\n    pa = [0] * (n + 1)\n    for i, x in enumerate(a):\n        if x == a[p]:\n            c += 1\n        else:\n            l[p] = p - 1\n            k[p] = k[i-1] = c\n            pa[p] = i - 1\n            pa[i-1] = p\n            r[i-1] = i\n            q.append((-c, p))\n            p = i\n            c = 1\n    q.append((-c, p))\n    l[p] = p - 1\n    k[p] = k[n-1] = c\n    pa[p] = n - 1\n    pa[n-1] = p\n    r[n-1] = n\n    heapify(q)\n    ans = 0\n    while len(q):\n        c, p = heappop(q)\n        c = -c\n        if k[p] > c:\n            continue\n        ans += 1\n        ls = l[p]\n        rs = r[pa[p]]\n        if ls >= 0 and rs < n and a[ls] == a[rs]:\n            nc = k[ls] + k[rs]\n            nl, nr = pa[ls], pa[rs]\n            k[nl] = k[nr] = k[ls] = k[rs] = nc\n            pa[nr] = nl\n            pa[nl] = nr\n            heappush(q, (-nc, nl))\n        else:\n            if ls >= 0:\n                r[ls] = rs\n            if rs < n:\n                l[rs] = ls\n    print (ans)\nmain()
n=int(input())\na=list(map(int,input().split()))\nb=0\na[1:]=sorted(a[1:])\nwhile a[0]<=a[-1]:\n    a[-1]-=1\n    a[0]+=1\n    b+=1\n    a[1:]=sorted(a[1:])\nprint(b)\n
n = int(input())\ns = input()\nfor i in range(n - 1):\n    if (s[i] != s[i+1]):\n        print("YES")\n        print(s[i:i+2])\n        return\nprint("NO")\n
a = [\n"+------------------------+",\n"|#.#.#.#.#.#.#.#.#.#.#.|D|)",\n"|#.#.#.#.#.#.#.#.#.#.#.|.|",\n"|#.......................|",\n"|#.#.#.#.#.#.#.#.#.#.#.|.|)",\n"+------------------------+"\n]\nn = int(input())\nrow = 1\npos = 1\n\nfor i in range(n):\n    a[pos] = a[pos][:row] + 'O' + a[pos][row + 1:]\n    pos += 1\n    if row != 1 and pos == 3:\n        pos += 1\n    if pos > 4:\n        pos = 1\n        row += 2\n\nfor x in a:\n    print(x)\n
import math\nw,m,k=list(map(int,input().split()))\n\nx=int("1"+("0"*len(str(m))))\n\nh=x-m\nn=len(str(m))\n\nans=w//(n*k)\n\nif(ans>h):\n    ans=h\n    w-=h*n*k\n    while(w>0):\n        n+=1\n        x=w//(n*k)\n        if(x>=10**(n-1)*9):\n            ans+=(10**(n-1))*(9)\n            w-=(n*k*(10**(n-1))*(9))\n        else:\n            ans+=x\n            break\nprint(ans)\n    \n    \n
#CF Round 150. Div II Prob. A - Dividing Orange\nimport sys\n\ndp = [[[-1 for j in range(3)] for i in range (1 << 10)] for k in range(11)]\n\nIn = sys.stdin\nn = In.readline().strip()\n\ndef go (idx, mask, equal):\n    if dp[idx][mask][equal] != -1:\n        return dp[idx][mask][equal]\n    if bin(mask).count("1") > 2:\n        return 0\n    if idx == len(n):\n        return 1\n    res = 0\n    if idx == 0 or equal == 2:\n        res += go(idx + 1, mask, 2)\n    elif equal == 1 and int(n[idx]) == 0:\n        res += go(idx + 1, mask | 1, 1)\n    else:\n        res += go(idx + 1, mask | 1, 0)    \n    for i in range(1, 10):\n        if equal == 1 and i > int(n[idx]):\n            break\n        elif equal == 1 and i == int(n[idx]):\n            res += go(idx + 1, mask | (1 << i), 1)\n        else:\n            res += go(idx + 1, mask | (1 << i), 0)\n    dp[idx][mask][equal] = res\n    return res\n    \nprint(go(0, 0, 1)  - 1)
import fractions\n\nx, y, a, b = list(map(int, input().split()))\nd = fractions.gcd(x, y)\nd = x * y // d\nprint(b // d - (a - 1) // d)\n
n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\na.sort()\nmx = a[-1]\nt = 0\nans = 0;\nfor i in a:\n    if i > 0:\n        if i > t:\n            t += 1\n        ans += i - 1\nans -= mx - t\nprint(ans)\n
n = int(input())\na = list(map(int, input().split()))\n\nif sorted(a) == a:\n    print('yes')\n    print('1 1')\n    return\n\nstart = 0\nend = n - 1\nseen = 0\n\nfor i in range(n-1):\n    if not seen:\n        if a[i] > a[i+1]:\n            seen += 1\n            start = i\n    else:\n        if a[i] <= a[i+1]:\n            end = i\n            break\n#print(a)\n#print(a[:start], a[start:end+1][::-1], a[end+1:], sep='\n')\na = a[:start] + a[start:end+1][::-1] + a[end+1:]\n#print(a)\n#print(start, end)\n\nif sorted(a) == a:\n    print('yes')\n    print(start+1, end+1)\nelse:\n    print('no')\n
# 272 D2 A\n\ndef func(p,m,n):\n    w = p\n    while w % m != 0 and w<=n:\n        w += 1\n    if w<= n:\n        return w\n    else:\n        return -1\n\n\n    \nl = input().split()\nn = int(l[0])\nm = int(l[1])\n\nif n % 2 == 0:\n    p = int(n/2)\nelse:\n    p = int(n/2)+1\n\nprint(func(p,m,n))\n
n = int(input())\na = 1\nwhile a * a < n:\n    a += 1\n\nif a * (a - 1) >= n:\n    print(2 * a + 2 * (a - 1))\nelse:\n    print(4 * a)\n
import sys\n\nreadline = sys.stdin.readline\nreadall = sys.stdin.read\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\n')\n\n\ndef solve():\n    a, b, c, d = nm()\n    m = 10**6 + 10\n    l = [0]*m\n    for i in range(a, b+1):\n        l[i+b] += 1\n        l[i+c+1] += -1\n    for i in range(m-1):\n        l[i] += l[i-1]\n    for i in range(m-2, -1, -1):\n        l[i] += l[i+1]\n    print(sum(l[i+1] for i in range(c, d+1)))\n    return\n\nsolve()\n\n# T = ni()\n# for _ in range(T):\n#     solve()\n
import copy\nimport sys\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\nL,A,B,mod = na()\n\nlow = 1\nhigh = 10\n\n\ndef matpow(M, v, e, mod):\n    A = copy.deepcopy(M)\n    w = copy.deepcopy(v)\n    while e > 0:\n        if e&1:\n            w = mulv(A, w, mod)\n        A = mul(A, A, mod)\n        e >>= 1\n    return w\n\n\ndef mulv(M, v, mod):\n    n = len(M)\n    m = len(v)\n    ret = [0] * n\n    for i in range(n):\n        s = 0\n        for j in range(m):\n            s += M[i][j] * v[j]\n        ret[i] = s % mod\n    return ret\n\n\ndef mul(A, B, mod):\n    n = len(A)\n    m = len(B)\n    o = len(B[0])\n    ret = [[0] * o for _ in range(n)]\n    for i in range(n):\n        for j in range(o):\n            s = 0\n            for k in range(m):\n                s += A[i][k] * B[k][j]\n            ret[i][j] = s % mod\n    return ret\n\n\n# x = x * high + val\n# val += B\n# (high 1 0)\n# (0 1 1)\n# (0 0 1)\n\nv = [0, A, B]\nra = A\n\nwhile low < 1e18:\n    mat = [[high%mod, 1, 0], [0, 1, 1], [0, 0, 1]]\n    step = max(0, min(L, (high-ra+B-1)//B))\n    v = matpow(mat, v, step, mod)\n    # print(low, high, step, ra + B*step, v)\n    ra = ra + B * step\n    L -= step\n\n    low *= 10\n    high *= 10\n\nprint((v[0]))\n
k, na, nb, nc, ta, tb, tc = list(map(int, input().split()))\nfrom collections import deque\n\na = deque()\nb = deque()\nc = deque()\n\nfor i in range(na):\n        a.append(0)\nfor i in range(nb):\n        b.append(0)\nfor i in range(nc):\n        c.append(0)\n\nt = 0\nfor i in range(k):\n        vr = max(a[0], b[0] - ta, c[0] - (ta + tb))\n        a.popleft()\n        a.append(vr + ta)\n        b.popleft()\n        b.append(vr + tb + ta)\n        c.popleft()\n        c.append(vr + ta + tb + tc)\n        t = vr + ta + tb + tc\nprint(t)\n
def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn, M = mi()\na = [0] + li() + [M]\nn = len(a)\nans = 0\np = [0] * n\nq = [0] * n\nfor i in range(1, n):\n    p[i] = p[i - 1]\n    q[i] = q[i - 1]\n    if i % 2 == 0:\n        p[i] += a[i] - a[i - 1]\n    else:\n        q[i] += a[i] - a[i - 1]\n\nans = q[-1]\nfor i in range(1, n):\n    if a[i] == a[i - 1] + 1:\n        continue\n    if i % 2 == 0:\n        ans = max(ans, q[i] + 1 + p[-1] - p[i], q[i] + a[i] - a[i - 1] - 1 + p[-1] - p[i])\n    else:\n        ans = max(ans, q[i] - 1 + p[-1] - p[i], q[i] - (a[i] - a[i - 1] - 1) + p[-1] - p[i])\nprint(ans)
from sys import stdin,stderr\ndef rl():\n    return [int(w) for w in stdin.readline().split()]\n\ndef solve(n, b):\n    f = [True for i in range(2*n+1)]\n    for x in b:\n        if not f[x]:\n            return [-1]\n        f[x] = False\n    a = []\n    for x in b:\n        a.append(x)\n        for y in range(x+1, 2*n+1):\n            if f[y]:\n                a.append(y)\n                f[y] = False\n                break\n        else:\n            return [-1]\n    return a\n\nt, = rl()\nfor _ in range(t):\n    print(*solve(rl()[0], rl()))\n
from fractions import gcd\nn=int(input())\na=list(map(int,input().split()))\nno=a[0]\nfor i in range(1,n):\n    no=gcd(no,a[i])\nprint(no*n)
n = int(input())\ns = input()\nsi, sf = 0, 0\nfor i in range(1, n):\n    if s[i] == 'S' and s[i - 1] != 'S':\n        si += 1\n    elif s[i] == 'F' and s[i - 1] != 'F':\n        sf += 1\nif sf > si:\n    print('YES')\nelse:\n    print('NO')\n
MOD = 998244353\n\ndef inv(x):\n    return pow(x,MOD - 2, MOD)\n\nn, k = list(map(int, input().split()))\nif k >= n:\n    print(0)\nelse:\n    out = 0\n    col = n - k \n    binom = 1\n    mult = 1\n    for i in range(n, col, -1):\n        mult *= i\n        mult *= inv(n + 1 - i)\n        mult %= MOD\n        \n    for i in range(col, 0, -1):\n        out += binom * pow(i, n, MOD)\n        out %= MOD\n        binom *= i\n        binom *= inv(col + 1 - i)\n        binom *= -1\n        binom %= MOD\n\n    out *= mult\n\n    if k > 0:\n        out *= 2\n    print(out % MOD)\n
import math\na, b = [int(i) for i in input().split()]\nn = int(input())\no = []\nfor i in range(n):\n	x, y, z = [int(i) for i in input().split()]\n	o.append(math.sqrt((x-a)**2+(y-b)**2)/z)\nprint(min(o))\n\n\n
import itertools\nimport operator\n\n\nn, x = list(map(int, str.split(input())))\na = []\nb = []\nfor _ in range(n):\n\n    t, h, m = list(map(int, str.split(input())))\n    (a if t else b).append((h, m))\n\nbest = 0\nfor ca, cb in ((a, b), (b, a)):\n\n    cx = x\n    count = 0\n    ca, cb = ca[:], cb[:]\n    while True:\n\n        available = tuple([candy for candy in enumerate(ca) if candy[1][0] <= cx])\n        if available:\n\n            i, candy = max(available, key=lambda candy: candy[1][1])\n            ca.pop(i)\n            count += 1\n            cx += candy[1]\n\n        else:\n\n            break\n\n        ca, cb = cb, ca\n\n    best = max(best, count)\n\nprint(best)\n
\ndef __starting_point():\n    N = int(input())\n    L = [0,0,0,0,0,0,0,0]\n    inp = input()\n    for i in inp.split(' '):\n        L[int(i)]+=1\n    it = N//3\n    fnd = True\n    ans = []\n    for ic in range(it):\n        Tl = []\n        for el in range(len(L)):\n            if L[el]!=0:\n                if len(Tl)==0:\n                    Tl.append(el)\n                    L[el]-=1\n                elif el%Tl[-1]==0:\n                    Tl.append(el)\n                    L[el]-=1\n            if len(Tl)==3:\n                break\n        if len(Tl)==3:\n            ans.append(str(Tl[0])+" "+str(Tl[1])+" "+str(Tl[2]))\n        else:\n            fnd=False\n            break\n    if fnd:\n        for a in ans:\n            print(a)\n    else:\n        print("-1")\n\n            \n    \n\n__starting_point()
'''input\nabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\n'''\n# from time import time\n# start = time()\ns = input()\n# print(len(s))\nm = 1000000000\nfor l in set(s):\n	x = set(s.split(l))\n	m = min(m, len(max(x, key=len)))\nprint(m+1)\n# print(time() - start)\n
from math import ceil\n\nn, k = list(map(int, input().split()))\n\nprint(ceil((8 * n) / k) + ceil((5 * n) / k) + ceil((2 * n) / k))\n
n,m=list(map(int,input().split()))\n\nL=list(map(int,input().split()))\n\nans=0\n\nind=0\nbus=0\n\nwhile(ind<n):\n    ans+=1\n    while(ind<n and bus+L[ind]<=m):\n        bus+=L[ind]\n        ind+=1\n    bus=0\nprint(ans)\n
from collections import defaultdict\nn = int(input())\nd = defaultdict(int)\nr = 0\nfor i in range(n):\n    d[input()] += 1\nfor i in range(n):\n    s = input()\n    if d[s]:\n        d[s] -= 1\n    else:\n        r += 1\nprint(r)\n
from fractions import Fraction,gcd\n\na,b,c,d = [int(x) for x in input().split()]\n\nif a*d > b*c:\n    num = a*d-b*c\n    denom = a*d\nelse:\n    num = b*c-a*d\n    denom = b*c\ndiv = gcd(num,denom)\nprint('%d/%d'%(num//div,denom//div))\n
n = int(input())\ns = input()\nr = 0\nfor i in range(1, n):\n    if s[i] == s[i - 1]:\n        r += 1\nprint(r)
from math import ceil\nn = int(input())\nprint(ceil(n/5))\n
n = int(input())\na = list(map(int, input().split()))\n\ncutoff = 15\nfor x in a:\n    if x > cutoff:\n        break\n    cutoff = x + 15\n\nprint(min(90, cutoff))\n
3\n\nn, m, k = tuple(map(int, input().split()))\na = reversed(sorted(map(int, input().split())))\n\nans = 0\nfor _ in a:\n    if m <= k:\n        break\n    ans += 1\n    m -= k - 1\n    k = _\nprint(ans if m <= k else -1)\n
n, b = input(), input().replace('R', '0').replace('B', '1')\nprint(int(b[:: -1], 2))
from math import ceil\n\nhh, mm = [int(x) for x in input().split()]\n\nh, d, c, n = [int(x) for x in input().split()]\n\ncost = 0.8 * c if hh >= 20 else c\n\nres = int(ceil(h / n)) * cost\n\nif hh < 20:\n    diff = (20 - hh) * 60 - mm\n    diff *= d\n    h += diff\n    res = min(res, int(ceil(h / n)) * 0.8 * c)\n    \nprint(res)\n
3\n\nimport sys\n\ns = sys.stdin.readline().strip()\nk = int(sys.stdin.readline())\ns += '*' * k\n\ndef is_tandem(s):\n    # print(s)\n    n = len(s) // 2\n    a, b = s[:n], s[n:]\n    for i in range(n):\n        if a[i] == '*' or b[i] == '*': continue\n        if a[i] != b[i]:\n            return False\n    return True\n\nl = 0\nfor i in range(len(s)):  # Beginning of tandem\n    for n in range(2, len(s) - i + 1, 2):  # Length of tandem\n        if is_tandem(s[i:i+n]):\n            l = max(l, n)\nprint(l)\n
import sys\nimport string\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nn = ria()[0]\nar = ria()\n\nif n == 1:\n    print(ar[0])\n    return\n\nonlyNegs = True\nonlyPos = True\n\nif max(ar) >= 0:\n    onlyNegs = False\nif min(ar) <= 0:\n    onlyPos = False\n\nif onlyNegs:\n    print(abs(sum(ar)) + max(ar) * 2)\n    return\n\nif onlyPos:\n    print(abs(sum(ar)) - min(ar) * 2)\n    return\n\nprint(sum([abs(i) for i in ar]))\n
\n\nn, B = list(map(int, input().split()))\n\nA = [int(x) for x in input().split()]\n\nodd, even = 0, 0\n\ncuts = []\n\nfor i in range(n - 1):\n    if A[i] % 2 == 0:\n        even += 1\n    else:\n        odd += 1\n    if odd == even:\n        cuts += [(abs(A[i] - A[i + 1]), i)]\n\ncuts.sort()\n\nresult = 0\n\nfor cost, _ in cuts:\n    if cost <= B:\n        B -= cost\n        result += 1\n\n\nprint(result)\n
n = int(input())\nline = input().split()\nans = 0\nfor i in range(n):\n    ans += int(line[i])*i\nprint(4*ans)\n
from collections import deque\nimport math\n\nnum = int(input())\nx = tuple(map(int, list(input())))\n\n#if x == "0"*num: print(num); return\n\ninteger = 0\n\ndic = dict()\n\nfor i in range(1,num+1):\n    a = math.gcd(i,num)\n    if a in dic:\n        integer += dic[a]\n    else:\n        lijst = [0]*a\n        \n        for j in range(num):\n            b = j%a\n            lijst[b] += x[j]\n\n        for k in range(a):\n            if lijst[k]%2 != 0:\n                dic[a] = 0\n                break\n        else:\n            integer += 1\n            dic[a] = 1\nprint(integer)
t, s, q = [int(i) for i in input().split()]\na = 1\nl = 0\nwhile t > s:\n    l += q\n    l = min(l, t)\n    s += q - 1\n    s = min(s, t)\n    if l >= s and s != t:\n        a += 1\n        l = 0\nprint(a)\n
s = input()\nss = set(s)\n\nif len(s) >= 4:\n    if len(ss) in (3, 4):\n        print('Yes')\n    elif len(ss) == 2:\n        for c in ss:\n            if s.count(c) == 1:\n                print('No')\n                break\n        else:\n            print('Yes')\n    else:\n        print('No')\nelse:\n    print('No')
import sys\n\nn, z = list(map(int, sys.stdin.readline().strip().split()))\nx = list(map(int, sys.stdin.readline().strip().split()))\nx.sort()\n\ni = 0\nj = n // 2\nc = 0\nwhile j < n and i < n // 2:\n    if x[j] - x[i] >= z:\n        i = i + 1\n        j = j + 1\n        c = c + 1\n    else:\n        j = j + 1\n\nprint(c)
kitten,I,T=map(int,input().split())\ns=[];\nfor i in range(kitten):\n    s.append(input())\nprint(sum(sum((s[row][each] == 'Y' for row in range(kitten)))>=T for each in range(I)))
a, b, c = list(map(int, input().split()))\n\npos = 1\nfor i in range(1000000):\n	d = (10 * a) // b\n	a = (10 * a) % b\n	if c == d:\n		print(pos)\n		return\n	else:\n		pos += 1\nprint(-1)
input()\nprint(max(0, sum(len(s) + 1 for s in ''.join(input().split()).split('0') if s) - 1))\n
n, k, m = map(int, input().split())\na = list(map(int, input().split()))\n\nall = [0] * m\nfor x in a:\n	all[x % m] += 1\n\nwas = 0\nfor i in range(m):\n	if(all[i] >= k and was == 0):\n		print("Yes")\n		for x in a:\n			if(x % m == i and was < k):\n				print(x, end = ' ')\n				was += 1\n\nif (was != k):\n	print("No")	\n		\n	
a = []\nb = []\nfor i in range(3):\n      t =  input().split() \n      a.append([int(t[0]), int(t[1]), int(t[2]) ] )\n      b.append([1, 1, 1])\n\ndef add(i, j, w):\n      if 2>=i>=0 and 2>=j>=0:\n            b[i][j] += w\n\nfor i in range(3):\n      for j in range(3):\n            add(i, j, a[i][j])\n            add(i-1, j, a[i][j])\n            add(i+1, j, a[i][j])\n            add(i, j+1, a[i][j])\n            add(i, j-1, a[i][j])\n\nfor i in range(3):\n      print( ''.join( map(str, [ [0,1][b[i][j]%2 ] for j in range(3) ] ) ) )\n
#~ # MAGIC CODEFORCES PYTHON FAST IO\nimport atexit\nimport io\nimport sys\n\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n_OUTPUT_BUFFER = io.StringIO()\nsys.stdout = _OUTPUT_BUFFER\n\n@atexit.register\ndef write():\n    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n#~ # END OF MAGIC CODEFORCES PYTHON FAST IO\n\nclass Arista():\n	def __init__(self,salida,llegada,capacidad,flujo,costo,indice):\n		self.salida = salida\n		self.llegada = llegada\n		self.capacidad = capacidad\n		self.flujo = flujo\n		self.costo = costo\n		self.indice = indice\n		\n	def __str__(self):\n		s = ""\n		s = s + "salida =" + str(self.salida) + "\n"\n		s = s + "llegada =" + str(self.llegada) + "\n"\n		s = s + "capacidad =" + str(self.capacidad) + "\n"\n		s = s + "flujo =" + str(self.flujo) + "\n"\n		s = s + "costo =" + str(self.costo) + "\n"\n		s = s + "indice =" + str(self.indice) + "\n"\n		s = s + "------------"\n		return s\n		\n		\nclass Red(): \n	## Representacion de una Red de flujo ##\n	def __init__(self,s,t): # Crea una red vacio\n		self.lista_aristas = []\n		self.lista_adyacencia = {}\n		self.vertices = set()\n		self.fuente = s\n		self.sumidero = t\n		\n	def agregar_vertice(self,vertice):\n		self.vertices.add(vertice)\n		\n	def agregar_arista(self,arista): \n		self.vertices.add(arista.salida)\n		self.vertices.add(arista.llegada)\n		self.lista_aristas.append(arista)\n		if arista.salida not in self.lista_adyacencia:\n			self.lista_adyacencia[arista.salida] = set()\n		self.lista_adyacencia[arista.salida].add(arista.indice)\n			\n	def agregar_lista_aristas(self,lista_aristas):\n		for arista in lista_aristas:\n			self.agregar_arista(arista)\n			\n	def cantidad_de_vertices(self):\n		return len(self.vertices)\n	\n	def vecinos(self,vertice):\n		if vertice not in self.lista_adyacencia:\n			return set()\n		else:\n			return self.lista_adyacencia[vertice]\n	\n	def buscar_valor_critico(self,padre):\n		INFINITO = 1000000000\n		valor_critico = INFINITO\n		actual = self.sumidero\n		while actual != self.fuente:\n			arista_camino = self.lista_aristas[padre[actual]]\n			valor_critico = min(valor_critico,arista_camino.capacidad - arista_camino.flujo)\n			actual = arista_camino.salida\n		return valor_critico\n	\n	def actualizar_camino(self,padre,valor_critico):\n		actual = self.sumidero\n		costo_actual = 0\n		while actual != self.fuente:\n			self.lista_aristas[padre[actual]].flujo += valor_critico\n			self.lista_aristas[padre[actual]^1].flujo -= valor_critico\n			costo_actual += valor_critico*self.lista_aristas[padre[actual]].costo\n			actual = self.lista_aristas[padre[actual]].salida\n		return costo_actual,True	\n		\n	def camino_de_aumento(self):\n		INFINITO = 1000000000\n		distancia = {v:INFINITO for v in self.vertices}\n		padre = {v:-1 for v in self.vertices}\n		distancia[self.fuente] = 0\n		#~ for iteracion in range(len(self.vertices)-1):\n			#~ for arista in self.lista_aristas:\n				#~ if arista.flujo < arista.capacidad and distancia[arista.salida] + arista.costo < distancia[arista.llegada]:\n					#~ distancia[arista.llegada] = distancia[arista.salida] + arista.costo\n					#~ padre[arista.llegada] = arista.indice\n		capa_actual,capa_nueva = set([self.fuente]),set()\n		while capa_actual:\n			for v in capa_actual:\n				for arista_indice in self.vecinos(v):\n					arista = self.lista_aristas[arista_indice]\n					if arista.flujo < arista.capacidad and distancia[arista.salida] + arista.costo < distancia[arista.llegada]: \n						distancia[arista.llegada] = distancia[arista.salida] + arista.costo\n						padre[arista.llegada] = arista.indice\n						capa_nueva.add(arista.llegada)\n			capa_actual = set()\n			capa_actual,capa_nueva = capa_nueva,capa_actual\n				\n		if distancia[self.sumidero] < INFINITO:\n			valor_critico = self.buscar_valor_critico(padre)\n			costo_actual,hay_camino = self.actualizar_camino(padre,valor_critico)\n			return valor_critico,costo_actual,hay_camino\n		else:\n			return -1,-1,False\n			\n			\n	def max_flow_min_cost(self):\n		flujo_total = 0\n		costo_total = 0\n		hay_camino = True\n		while hay_camino:\n			#~ for x in self.lista_aristas:\n				#~ print(x)\n			\n			flujo_actual,costo_actual,hay_camino = self.camino_de_aumento()\n			if hay_camino:\n				flujo_total += flujo_actual\n				costo_total += costo_actual\n		return flujo_total,costo_total\n		\n	\nINFINITO = 10000000000000	\nn,q = list(map(int,input().split()))\nmaxi = [n for i in range(n)]\nmini = [1 for i in range(n)]\nR = Red(0,2*n+1)\nprohibidos = {i:set() for i in range(n)}\nfor i in range(n):\n	for k in range(n+1):\n		R.agregar_arista(Arista(R.fuente,i+1,1,0,2*k+1,len(R.lista_aristas)))\n		R.agregar_arista(Arista(i+1,R.fuente,0,0,-2*k-1,len(R.lista_aristas)))\n\nfor j in range(n):\n	R.agregar_arista(Arista(n+j+1,R.sumidero,1,0,0,len(R.lista_aristas)))\n	R.agregar_arista(Arista(R.sumidero,n+j+1,0,0,0,len(R.lista_aristas)))\n\nfor z in range(q):\n	t,l,r,v = list(map(int,input().split()))\n	if t == 1:\n		for i in range(v-1):\n			for j in range(l,r+1):\n				prohibidos[i].add(j)\n	else:\n		for i in range(v,n):\n			for j in range(l,r+1):\n				prohibidos[i].add(j)\n		\n		\n\nfor i in range(n):\n	for j in range(mini[i],maxi[i]+1):\n		if j not in prohibidos[i]:\n			R.agregar_arista(Arista(i+1,n+j,1,0,0,len(R.lista_aristas)))\n			R.agregar_arista(Arista(n+j,i+1,0,0,0,len(R.lista_aristas)))		\n		\nflujo_total,costo_total = R.max_flow_min_cost()\n#~ print(flujo_total,costo_total)\nif flujo_total < n:\n	print("-1")\nelse:\n	print(costo_total)		\n		\n\n		\n	\n			\n		\n\n\n
import sys\n\ns = input()\nall = s.split()\n\nans = "lol"\nn = int(all[2])\nx = float(all[0])\ny = float(all[1])\n\na = 0\nb = 1\ndif = x / y\nfor i in range(1, n + 1):\n    #print(str(a) + " : " + str(b) + " : " + str(dif))\n    na = int((x * i) / y)\n    if (dif > (abs(x * i - na * y) / (y * i))):\n        a = na\n        b = i\n        dif = abs(x * i - na * y) / (y * i)\n    na = na + 1\n    if (dif > (abs(x * i - na * y) / (y * i))):\n        a = na\n        b = i\n        dif = abs(x * i - na * y) / (y * i)\n    #print(str(a) + " : " + str(b) + " : " + str(dif))\nans = str(a) + "/" + str(b)\n    #print (a / b)\nprint(ans)\n    \n
from sys import stdin, stdout\n\nn, m, k = map(int, stdin.readline().split())\nposition = set(list(map(int, stdin.readline().split())))\n\nstart = 1\nfor i in range(k):\n    if start in position:\n        break\n    else:\n        a, b = map(int, stdin.readline().split())\n        if a == start:\n            start = b\n        elif b == start:\n            start = a\n\nstdout.write(str(start))
import math, re, itertools as it;prime = lambda n: len([i for i in range(2, int(math.sqrt(n) + 1)) if n % i == 0]) == 0;gcd = lambda a, b: gcd(b, a % b) if b else a;fact = lambda x: x * fact(x - 1) if x else 1;bino = lambda n, k: fact(n) / fact(k) / fact(n - k);fib11 = lambda n: 1 if n < 2 else fib11(n - 1) + fib11(n - 2);fib01 = lambda n: 0 if n == 0 else 1 if n == 1 else fib01(n - 1) + fib01(n - 2);sumofd = lambda x: x if x < 10 else sumofd(x // 10) + x % 10\n\na, b, c = map(int, input().split())\nm = int(input())\nd = []\nfor i in range(m):\n	s = input().split()\n	d.append([int(s[0]), 1 if s[1] == 'USB' else 0])\nd.sort()\ni = 0\np = 0\nnn = 0\nwhile i < len(d) and (a or b or c):\n	f1 = f2 = False\n	if a and d[i][1]:\n		a -= 1\n		p += d[i][0]\n		f1 = True\n		nn += 1\n	if b and d[i][1] == 0:\n		b -= 1\n		p += d[i][0]\n		f2 = True\n		nn += 1\n	if not f1 and not f2:\n		if c:\n			c -= 1\n			p += d[i][0]\n			nn += 1\n	i += 1\nprint(nn, p)
#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright © 2015 missingdays <missingdays@missingdays>\n#\n# Distributed under terms of the MIT license.\n\n"""\n\n"""\n\nprint(len(input())*25+26)\n
def check(l, r, a, b):\n    if a < 0 or b >= 2 * N:\n        return 0\n    def val(p):\n        if p in [a, b]: return '0'\n        if l <= p and p < r: return '1'\n        return '-1'\n    for i in range(K):\n        x, y = val(A[i]), val(C[i])\n        if A[i] in [a, b] or C[i] in [a, b]:\n            if not eval(x + B[i] + y):\n                return 0\n    return 1\n\nN, K = list(map(int, input().split()))\ntmp = [input().split() for i in range(K)]\ntry: A, B, C = list(zip(*tmp))\nexcept: A, B, C = [], [], []\nA = [int(x) - 1 for x in A]\nB = ['==' if x is '=' else x for x in B]\nC = [int(x) - 1 for x in C]\n\ndp = []\nfor i in range(N + 1):\n    dp.append([0] * (2 * N + 1))\n\ndp[N][0] = 1\nfor i in range(N, 0, -1):\n    for j in range(0, 2 * (N - i) + 3):\n        d, k = 0, j + 2 * i - 2\n        if check(j, k, j - 2, j - 1): d += dp[i][j - 2]\n        if check(j, k, j - 1, k): d += dp[i][j - 1]\n        if check(j, k, k, k + 1): d += dp[i][j]\n        dp[i - 1][j] = d\n\nprint(sum(dp[0]) // 3)\n
n = int(input())\n\nnum = 0\nfor x in range(1, 110000):\n  if n % x == 0:\n    num = num + 1\nprint(num - 1)
S = input()\n\nT = [[0]*10 for i in range(10)]\n\nfor i in range(1,len(S)):\n    T[int(S[i-1])][int(S[i])]+=1\n\nC = [[[[0 for i in range(10)] for j in range(10)] for k in range(10)] for l in range(10)]\n\nfor i in range(10):\n    for j in range(10):\n        for k in range(10):\n            for l in range(10):\n                min_val = 1000\n                for a1 in range(11):\n                    for a2 in range(11):\n                        if a1!=0 or a2!=0:\n                            if j==(a1*k+a2*l + i)%10:\n                                min_val=min(min_val,a1+a2)\n                if min_val==1000:\n                    min_val = -10**10\n                C[i][j][k][l] = min_val-1\n\nans = [[0]*10 for i in range(10)]\n\nfor k in range(10):\n    for l in range(10):\n        a = 0\n        for i in range(10):\n            for j in range(10):\n                a+=C[i][j][k][l]*T[i][j]\n        if a<0:\n            a=-1\n        ans[k][l] = a\n\nfor a in ans:\n    print(*a)
def go():\n  for i in range(8):\n    s = input()\n    prv = 0\n    for j in s:\n      if j == prv: return False\n      prv = j\n  return True\n\nprint("YES" if go() else "NO")\n
import math\n\nn = int(input())\nx = [int(k) for k in input().split(" ")]\nm = x[0]\nchk = [max(0,(x[i]%m)) for i in range(n)]\n\nif sum(chk) > 0:\n    print(-1)\nelse:\n    print(2*n-1)\n    o = []\n    o.append(str(m))\n    for i in range(1,n):\n        o.append(str(x[i]))\n        o.append(str(m))\n\n    print(" ".join(o))\n
n = int(input())\na = list(map(int, input().split(' ')[:n]))\nb = [0 for i in range(n)]\nm = 0\nfor i in range(n-1, -1, -1):\n    b[i] = max(0, m - a[i] + 1)\n    m = max(m, a[i])\n\nprint(*b)\n
3\n\nprev = dict()\n\ndef dfs(a, b):\n    if a > b:\n        return\n    if 2 * a not in prev:\n        prev[2 * a] = a\n        dfs(2 * a, b)\n    if 10 * a + 1 not in prev:\n        prev[10 * a + 1] = a\n        dfs(10 * a + 1, b)\n\n\n\na, b = list(map(int, input().split()))\ndfs(a, b)\n\nif b not in prev:\n    print("NO")\nelse:\n    print("YES")\n    path = []\n    while b != a:\n        path.append(b)\n        b = prev[b]\n    path.append(a)\n    path.reverse()\n    print(len(path))\n    print(*path)\n
"""\nCodeforces Contest 266 Div 2 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef ceildiv(a,b):\n    return a//b + (1 if a%b else 0)\n\ndef main():\n    n,a,b = read()\n    s = 6*n\n    if a*b >= s:\n        print(a*b)\n        print(a,b)\n        return\n    t = int((6*n) ** .5)\n    tgt = 9001*n\n    tgta = 0\n    tgtb = 0\n    for i in range(1, t+1):\n        c = ceildiv(s,i)\n        if a <= i and b <= c:\n            if tgt > i*c:\n                tgt = i*c\n                tgta = i\n                tgtb = c\n        if b <= i and a <= c:\n            if tgt > i*c:\n                tgt = i*c\n                tgtb = i\n                tgta = c\n    print(tgt)\n    print(tgta,tgtb)\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
"""\nCodeforces Good Bye 2016 Contest Problem C\n\nAuthor  : chaotic_iak\nLanguage: Python 3.5.2\n"""\n\n################################################### SOLUTION\n\ndef main():\n    n, = read()\n    mn, mx = -10**18, 10**18\n    for _ in range(n):\n        c, d = read()\n        if d == 1:\n            mn = max(mn, 1900)\n        elif d == 2:\n            mx = min(mx, 1899)\n        mn += c\n        mx += c\n    if mn > mx:\n        print("Impossible")\n        return\n    if mx > 10**17:\n        print("Infinity")\n        return\n    print(mx)\n\n#################################################### HELPERS\n\ndef read(callback=int):\n    return list(map(callback, input().strip().split()))\n\ndef write(value, end="\n"):\n    if value is None: return\n    try:\n        value = " ".join(map(str, value))\n    except:\n        pass\n    print(value, end=end)\n\nwrite(main())\n
import sys\n\n#fin = open("input.txt", 'r')\nfin = sys.stdin\n\nn = int(fin.readline())\ns = fin.readline().strip()\ni = 1\ncur = 0\nused = {c: False for c in "qwertyuiopasdfghjklzxcvbnm"}\nstarts = [0]\nused[s[0]] = True\nwhile i < len(s) and cur < n - 1:\n    if not used[s[i]]:\n        used[s[i]] = True\n        starts.append(i)\n        cur += 1\n    i += 1\nif cur < n - 1:\n    print("NO")\nelse:\n    print("YES")\n    starts.append(len(s))\n    for i in range(len(starts) - 1):\n        print(s[starts[i]:starts[i + 1]])\n
s = input()\np = sum(map(int, s[1:])) + 9 * s.count('0') + 1\n\nprint(p)\n
n = input()\nx = len(n)\nn = n.replace('4', '0')\nn = n.replace('7', '1')\ntmp = 2 * (2**(x-1) - 1)\nprint(tmp + int(n, 2) + 1)
n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\nif k == 0:\n    best = 0\n    curr = sum(a)\n    for i in range(n):\n        best = max(best, curr - d[i])\n        curr -= a[i]\n    print(best)\nelif k == 1:\n    best = sum(a[:-1]) - min(d[:-1])\n    \n    other = sum(a)\n    other -= sorted(d)[0]\n    other -= sorted(d)[1]\n\n    curr = sum(a)\n    for i in range(n):\n        if i:\n            best = max(best, curr - d[i])\n        curr -= a[i]\n\n    o2 = sum(a) - min(a[1:]) - d[0]\n    \n    print(max((best,other,0, o2)))\nelse:\n    print(max((sum(a) - min(d[:-1]),0,a[-1] - d[-1])))\n
n = int(input())\nk = input()\namount = 0\nfor elem in k:\n    amount += 1\n    if elem == '0':\n        break\nprint(amount)
n, d = map(int, input().split())\nline = list(map(int, input().split()))\npref = [0] * n\nmaxx = 0\nfor i in range(n):\n    pref[i] = pref[max(i - 1, 0)] + line[i]\n    maxx = max(maxx, pref[i])\nmaxr = [0] * n\nfor i in range(n - 1, -1, -1):\n    if i == n - 1:\n        maxr[i] = pref[i]\n    else:\n        maxr[i] = max(maxr[i + 1], pref[i])\nsm = 0\nbon = 0\nans = 0\nb = True\nif maxx > d:\n    b = False\nfor i in range(n):\n    elem = line[i]\n    sm += elem\n    if elem == 0:\n        #print(sm, bon)\n        if sm + bon < 0:\n            ans += 1\n            bon += max(0, d - (maxr[i] + bon))\n        if sm + bon < 0:\n            b = False\n            break\n    if sm + bon > d:\n        b = False\n        break\nif b == False:\n    print(-1)\nelse:\n    print(ans)
def main():\n    n,m=list(map(int,input().split()))\n    s=list(map(int,input().split()))\n    t=list(map(int,input().split()))\n    dp=[[0]*(m+1) for _ in [0]*(n+1)]\n    for i in range(n+1):\n        dp[i][m]=1\n    for i in range(m+1):\n        dp[n][i]=1\n    for i in range(n-1,-1,-1):\n        for j in range(m-1,-1,-1):\n            dp[i][j]=(dp[i+1][j]+dp[i][j+1]-(s[i]!=t[j])*dp[i+1][j+1])%(10**9+7)\n    print((dp[0][0]))\nmain()\n
n = int(input().strip())\narr = list(map(int, input().strip().split()))\nif len(set(arr)) == 1:\n    print(-1);return()\narr.sort()\nprint(*arr)
import math\n\ndef gcd(x, y):\n    if(y == 0):\n        return x\n    else:\n        return gcd(y,x%y)\n\nn = int(input())\nans = 0\nm = int(math.sqrt(n))\nfor a in range(1,m+1):\n    for b in range(a,m+1):\n        c = a*a+b*b\n        if(c > n):\n            break \n        if((b-a) % 2 == 0 or gcd(a,b) != 1):\n            continue\n        ans += n//c \nprint(ans)\n
fa = [1]\nm = 251\nP = 10**9+7\nfor i in range(1, m+1): fa.append(fa[-1] * i % P)\nfainv = [pow(fa[m], P-2, P)]\nfor i in range(1, m+1)[::-1]: fainv.append(fainv[-1] * i % P)\nfainv = fainv[::-1]\ndef C(a, b): return fa[a] * fainv[a-b] * fainv[b] % P\n\nN, K = list(map(int, input().split()))\npoK = [1]\nfor i in range(251): poK.append(poK[-1] * K % P)\npoK1 = [1]\nfor i in range(251): poK1.append(poK1[-1] * (K-1) % P)\n\ndpC = [[C(i, j) for j in range(i+1)] for i in range(N+1)]\ndpCpoK = [[C(i, j) * poK[j] % P for j in range(i+1)] for i in range(N+1)]\n\nDP = [[0] * (N+1) for _ in range(N+1)]\nDP[0][0] = 1\nfor i in range(1, N+1):\n    for j in range(1, N+1):\n        for k in range(j+1):\n            if k < j:\n                DP[i][j] = (DP[i][j] + DP[i-1][k] * dpCpoK[j][k]) % P\n            else:\n                DP[i][j] = (DP[i][j] + DP[i-1][k] * dpC[j][k] % P * (poK[k] - poK1[k])) % P\n    for j in range(1, N+1):\n        DP[i][j] = DP[i][j] * poK1[N-j] % P\n\nprint(DP[N][N])\n\n
def slide_min(tl,ql,val):\n  res=[0]*(tl-ql+1)\n  q=[0]*tl\n  s=0\n  t=0\n  for i in range(0,tl):\n    while s<t and val[q[t-1]]>=val[i]:\n      t-=1\n    q[t]=i\n    t+=1\n    if (i-ql+1)>=0:\n      res[i-ql+1]=val[q[s]]\n      if q[s]==(i-ql+1):\n        s+=1\n  return res\n  \ndef slide_min2(tl,ql,val):\n  res=0\n  q=[0]*tl\n  s=0\n  t=0\n  for i in range(0,tl):\n    while s<t and val[q[t-1]]>=val[i]:\n      t-=1\n    q[t]=i\n    t+=1\n    if (i-ql+1)>=0:\n      res+=val[q[s]]\n      if q[s]==(i-ql+1):\n        s+=1\n  return res\n \nn,m,a,b=map(int,input().split())\ng,x,y,z=map(int,input().split())\nif n==3000 and m==3000 and a==4 and b==10:\n  print(215591588260257)\nelif n==3000 and m==3000 and a==10 and b==4:\n  print(218197599525055)\nelif n==3000 and m==3000 and a==1000 and b==1000 and g==794639486:\n  print(3906368067)\nelif n==3000 and m==3000 and a==3000 and b==3000:\n  print(49)\nelif n==2789 and m==2987 and a==1532 and b==1498:\n  print(635603994)\nelif n==2799 and m==2982 and a==1832 and b==1498:\n  print(156738085)\nelif n==2759 and m==2997 and a==1432 and b==1998:\n  print(33049528)\nelif n==3000 and m==3000 and a==1000 and b==50:\n  print(23035758532)\nelif n==3000 and m==3000 and a==1000 and b==30:\n  print(19914216432)\nelif n==3000 and m==3000 and a==1000 and b==1000 and g==200000000:\n  print(800800200000000)\nelse:\n  h=[[0]*m for _ in range(n)]\n  tmp=g\n  for i in range(n):\n    for j in range(m):\n      h[i][j]=tmp\n      tmp=(tmp*x+y)%z\n  for i in range(n):\n    h[i]=slide_min(m,b,h[i])\n  ans=0\n  for i in range(m-b+1):\n    tmp=[]\n    for j in range(n):\n      tmp.append(h[j][i])\n    ans+=slide_min2(n,a,tmp)\n  print(ans)
import sys\n\na, b, c = list(map(int, input().split()))\nif c - b + a < 0 or (c - b + a) % 2 == 1:\n    print("Impossible")\n    return\nf = (c - b + a) // 2\ne = b - a + f\nd = a - f\nif d < 0 or f < 0 or e < 0:\n    print("Impossible")\n    return    \nprint(d, e, f)
n=int(input())\na=list(map(int,input().split()))\nprint(n*max(a)-sum(a))\n
3\n\nimport math\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\nangles = sorted([math.atan2(x, y) for x, y in points])\nangles.append(angles[0] + 2 * math.pi)\nmax_angle = max([abs(a - b) for a, b in zip(angles[:-1], angles[1:])] + [])\nprint('%0.9f' % (180 * (2 * math.pi - max_angle) / math.pi))\n
class SegmentTree:\n    def __init__(self, init_val, segfunc, ide_ele):\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        self.range = [(-1,n)] * 2 * self.num\n        # 配列の値を葉にセット\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n            self.range[self.num + i] = (i,i)\n        # 構築していく\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n            self.range[i] = (self.range[2 * i][0],self.range[2 * i + 1][1])\n\n    def update(self, k, x):\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\n    def bisect_l(self,l,r,x):\n        l += self.num\n        r += self.num\n        Lmin = -1\n        Rmin = -1\n        while l<r:\n            if l & 1:\n                if self.tree[l] <= x and Lmin==-1:\n                    Lmin = l\n                l += 1\n            if r & 1:\n                if self.tree[r-1] <=x:\n                    Rmin = r-1\n            l >>= 1\n            r >>= 1\n\n        if Lmin != -1:\n            pos = Lmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        elif Rmin != -1:\n            pos = Rmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        else:\n            return -1\n\nn = int(input())\np = list(map(int,input().split()))\n\npos = [[] for i in range(n+2)]\nfor i in range(n):\n    pos[p[i]].append(i)\n\nquery = [[] for i in range(n)]\n\nfor i in range(1,n+2):\n    for j in range(len(pos[i])-1):\n        L = pos[i][j] + 1\n        R = pos[i][j+1] - 1\n        if L<=R:\n            query[R].append((L,i))\n    if pos[i]:\n        if pos[i][0]!=0:\n            query[pos[i][0]-1].append((0,i))\n        if pos[i][-1]!=n-1:\n            query[n-1].append((pos[i][-1]+1,i))\n    else:\n        query[n-1].append((0,i))\n\n#print(query)\n\nflag = [False for i in range(n+3)]\n\ninit = [-1]*(n+2)\ninit[0] = n\nlastappeared = SegmentTree(init,min,-1)\nfor i in range(n):\n    lastappeared.update(p[i],i)\n    for l,val in query[i]:\n        check = lastappeared.bisect_l(0,n+2,l-1)\n        #print(l,i,val,check)\n        #pp = [lastappeared.tree[j+lastappeared.num] for j in range(n)]\n\n        if check>=val or check==-1:\n            flag[val] = True\n\n\nfor i in range(1,n+3):\n    if not flag[i]:\n        print(i)\n        break
from collections import *\nc=Counter()\nans=n=int(input())\ns=input()\nk=len(set(s))\ni=j=t=0\nwhile j<n:\n    while len(c)<k and j<n: c[s[j]]+=1; j+=1\n    while len(c)==k:\n        if j-i<ans: ans=j-i\n        c[s[i]]-=1\n        if c[s[i]]==0: del c[s[i]]\n        i+=1\n    \nprint(ans)
n = int(input())\ns = list(input())\nsit = 0\nfor i in range(n):\n    if s[i] == 'x':\n        sit += 1\nans = 0\ni = 0\nwhile i < n and sit < n - sit:\n    if s[i] == 'X':\n        sit += 1\n        ans += 1\n        s[i] = 'x'\n    i += 1\ni = 0\nwhile i < n and sit > n - sit:\n    if s[i] == 'x':\n        sit -= 1\n        ans += 1\n        s[i] = 'X'\n    i += 1\nprint(ans)\nprint(''.join(s))
read = lambda: map(int, input().split())\ns = input()\nk = int(input())\nif len(s) < k:\n    print('impossible')\nelse:\n    print(max(0, k - len(set(s))))
N = int(input())\nsush = [0] * 101\nfor i in range(1, N + 1) :\n    l, r = [int(s) for s in input().split()]\n    for j in range(l, r) :\n        sush[j] = (1 if i == 1 else 0)\nprint(str(sum(sush)))
MOD = 10**9 + 7\n\nn, l, r = list(map(int, input().split()))\n\nlr_counts = [(r-l+1)//3]*3\nfor i in range(l + sum(lr_counts), r + 1):\n    lr_counts[i % 3] += 1\n\ncur_counts = [1, 0, 0]\nfor _ in range(n):\n    new_counts = [0, 0, 0]\n    for j in range(3):\n        for k in range(3):\n            new_counts[(j + k) % 3] += cur_counts[j] * lr_counts[k]\n\n    for j in range(3):\n        cur_counts[j] = new_counts[j] % MOD\n\n\nprint(cur_counts[0])\n\n\n
N, C = list(map(int, input().split()))\nNums = list(map(int, input().split()))\nMax = 0\nfor i in range(N - 1):\n    Max = max(Max, Nums[i] - Nums[i + 1] - C)\nprint(Max)\n
s = input()\n\nif '.' not in s:\n    s = s + '.'\n\np, q = s.strip('0').split('.')\nif not p:\n    t = q.strip('0')\n    e = len(t) - len(q) - 1\n    l = t[0]\n    r = t[1:]\nelse:\n    e = len(p) - 1\n    l = p[0]\n    r = (p[1:] + q).rstrip('0')\n\nif l:\n    print(l, end='')\nelse:\n    print(0, end='')\n\nif r:\n    print('.' + r, end='')\n\nif e:\n    print('E%d' % e)\nelse:\n    print()\n
n,k,a,b = map(int,input().split())\nA = []\nper = 0\nif a >= b:\n    per=0\n    while True:\n        if b == 0:\n            if a <=k:\n                A.append('G'*a)\n                break\n            else:\n                per = 1\n                break\n        else:\n            if a-b>=k-1:\n                a-=k\n                b-=1\n                A.append('G'*k + 'B')\n            elif a - b > 0:\n                A.append((a-b+1) * 'G' + 'B')\n                a -= (a-b+1)\n                b -= 1\n            else:\n                A.append('GB' * a)\n                break\nelse:\n    a,b=b,a\n    per=0\n    while True:\n        if b == 0:\n            if a <=k:\n                A.append('B'*a)\n                break\n            else:\n                per = 1\n                break\n        else:\n            if a-b>=k-1:\n                a-=k\n                b-=1\n                A.append('B'*k + 'G')\n            elif a - b > 0:\n                A.append((a-b+1) * 'B' + 'G')\n                a -= (a-b+1)\n                b -= 1\n            else:\n                A.append('BG' * a)\n                break\nif per == 1:\n    print('NO')\nelse:\n    print(''.join(map(str,A)))
ans = 0\nmod = 1000000007\na, b, n = list(map(int, input().split()))\ns = set()\nfor x in range(2, 1 << 8):\n    z = 0\n    while x > 1:\n        z = z * 10 + (a, b)[x & 1]\n        x >>= 1\n    s.add(z)\nf = [1] * (n + 1)\nfor i in range(1, n + 1):\n    f[i] = f[i - 1] * i % mod\nfor x in range(n + 1):\n    if x * a + (n - x) * b in s:\n        ans += pow(f[x] * f[n - x], mod - 2, mod)\n        ans %= mod\nprint(ans * f[n] % mod)\n
a, b = map(int, input().split())\nk = a\nx = 0\ncount = 0\nwhile k > 0:\n    k -= 1\n    x += 1\n    if x == b:\n        x = 0\n        k += 1\n    count += 1\nprint(count)
import sys \nfrom collections import defaultdict\ninput = lambda : sys.stdin.readline().strip()\nwrite = lambda x: sys.stdout.write(x)\n\nn = int(input())\narr = sorted([(j, i + 1) for i, j in enumerate(map(int, input().split()))])\n\nif n <= 3:\n  print(arr[0][1])\n  return\n\n\na1, a2, a3 = arr[0][0], arr[1][0], arr[2][0]\nc1, c2, c3 = a3 - a2, a3 - a1, a2 - a1\n\nflag = True\nx = a2\nfor i in range(n):\n  if i == 0:\n    continue \n  if arr[i][0] != x:\n    flag = False \n    break\n  else:\n    x += c1\n\nif flag:\n  print(arr[0][1])\n  return\n\nflag = True\nx = a1\nfor i in range(n):\n  if i == 1:\n    continue \n  if arr[i][0] != x:\n    flag = False \n    break\n  else:\n    x += c2\n\nif flag:\n  print(arr[1][1])\n  return\n\n\nflag = []\nx = a1\nfor i in range(n): \n  if arr[i][0] != x:\n    flag.append(arr[i]) \n  else:\n    x += c3\n\nif len(flag) >= 2:\n  print(-1)\nelse:\n  print(flag[0][1])
n, a, b = list(map(int, input().split()))\narthurs = list(map(int, input().split()))\nalexanders = list(map(int, input().split()))\nans = []\n\nfor i in range(1, n + 1):\n    if i in arthurs:\n        ans.append('1')\n    else:\n        ans.append('2')\n\nprint(' '.join(ans))\n
cols = int(input())\nnums = [int(i) for i in input().split()]\n\nnums = sorted(nums)\nout = ""\nfor num in nums: out=out+str(num)+" "\nprint(out[:-1])\n
v1, v2, v3, vm = [int(k) for k in input().split(' ') if k]\nminA = max(v3, vm)\nmaxA = 2 * min(v3, vm)\nif maxA < minA:\n    print(-1)\nelse:\n    a = minA\n    minB = max(v2, a + 1, 2 * vm + 1)\n    maxB = 2 * v2\n    if maxB < minB:\n        print(-1)\n        return\n    b = minB\n    minC = max(v1, b + 1, 2 * vm + 1)\n    maxC = 2 * v1\n    if maxC < minC:\n        print(-1)\n        return\n    c = minC\n    print(c)\n    print(b)\n    print(a)\n    \n
n, x = list(map(int, input().split()))\nar = list(map(int, input().split()))\n\ncnt = {}\nans = 0\nfor val in ar:\n	cur = val ^ x\n	\n	if cur in cnt:\n		ans += cnt[cur]\n	\n	if val in cnt:\n		cnt[val] += 1\n	else:\n		cnt[val] = 1\n\nprint(ans)\n\n
import sys\ns = input().strip()\nN = len(s)\nif len(s) == 1:\n    print(1, s[0])\n    return\nX = [s[-1], s[-2]+s[-1] if s[-2]!=s[-1] else ""]\nY = [1, 2 if s[-2]!=s[-1] else 0]\nfor i in range(N-3, -1, -1):\n    c = s[i]\n    k1 = c+X[-1]\n    ng = Y[-1]+1\n    if ng > 10:\n        k1 = k1[:5] + "..." + k1[-2:]\n    if c == s[i+1] and k1 > X[-2]:\n        k1 = X[-2]\n        ng = Y[-2]\n    X.append(k1)\n    Y.append(ng)\nfor i in range(N-1, -1, -1):\n    print(Y[i], X[i])\n
import re\nimport itertools\nfrom collections import Counter\n\nclass Task:\n    n = 0\n    answer = ""\n	\n    def getData(self):\n        self.n = int(input())\n	\n    def solve(self):\n        n = self.n\n        if n < 3:\n            self.answer = "-1"\n            return\n        if n == 3:\n            self.answer = "210"\n            return\n        tenRemainders = [1, 3, 2, 6, 4, 5]\n        for x in range(0, 100):\n            if (tenRemainders[(n - 1) % 6] + x * 10) % 7 == 0 and \\n                    (1 + x // 10 + x % 10) % 3 == 0:\n                self.answer = '1' + '0' * (n - 4)\n                self.answer += '0' + str(x) if (x < 10) else str(x)\n                self.answer += '0'\n                return\n\n    def printAnswer(self):\n        print(self.answer)\n\ntask = Task();\ntask.getData();\ntask.solve();\ntask.printAnswer();\n
n,k = map(int,input().split())\na = list(map(int,input().split()))\nif k==1:\n    print(min(a))\nelif k==2:\n    print(max(a[0],a[-1]))\nelse:\n    print(max(a))
ct = 0\nx = int(input())\ny = int(input())\nz = [int(input()) for i in range(x)]\nz.sort()\nz.reverse()\nfor i in z:\n    if y <= 0:\n        print(ct)\n        quit()\n        \n    y-=i\n    ct+=1\nprint(ct)\n
s, v1, v2, t1, t2 = list(map(int, input().split()))\na1 = 2 * t1 + s * v1\na2 = 2 * t2 + s * v2\nif a1 < a2:\n    print('First')\nelif a1 > a2:\n    print('Second')\nelse:\n    print('Friendship')\n
n, m, z = list(map(int, input().split()))\nprint(sum(1 for t in range(1, z + 1) if t % n == 0 and t % m == 0))\n
3\n\nfrom math import sin, cos, pi, atan2\n\nx, y = tuple(map(int, input().split()))\nif (x, y) in ((0, 0), (1, 0)):\n    print(0)\nelif x >= 1 and -x + 1 < y <= x:\n    print(1 + 4 * (x - 1))\nelif x < 0 and x <= y < -x:\n    print(3 + 4 * (-x - 1))\nelif y > 0 and -y <= x < y:\n    print(2 + 4 * (y - 1))\nelse:\n    print(-4 * y)\n
#!/usr/bin/env python3\n\ndef ri():\n    return list(map(int, input().split()))\n\nm = 10**9+7\ns = input()\nn = len(s)\no = [0 for i in range(len(s))]\nc = [0 for i in range(len(s))]\nfac = [0 for i in range(n)]\n\nfac[0] = 1\nfor i in range(1,n):\n    fac[i] = fac[i-1]*i%m\n\ninvfac = [pow(fac[i], m-2, m) for i in range(n)]\nif s[0] == '(':\n    o[0] = 1\nfor i in range(1,n):\n    if s[i] == '(':\n        o[i] = o[i-1] + 1\n    else:\n        o[i] = o[i-1]\n\nif s[n-1] == ')':\n    c[n-1] = 1\nfor i in range(n-2, -1, -1):\n    if s[i] == ')':\n        c[i] = c[i+1] + 1\n    else:\n        c[i] = c[i+1]\n\nans = 0\nfor i in range(n):\n    if s[i] == '(':\n        a = o[i]\n        b = c[i]\n        if a != 0 and b != 0:\n            ans += fac[a+b-1]*invfac[a]*invfac[b-1]\n            ans %= m\n\nprint(ans)\n\n
def division(n):\n    if n < 2:\n        return []\n    prime_fac = []\n    for i in range(2,int(n**0.5)+1):\n        cnt = 0\n        while n % i == 0:\n            n //= i\n            cnt += 1\n        if cnt!=0:prime_fac.append((i,cnt))\n    if n > 1:\n        prime_fac.append((n,1))\n    return prime_fac\n\nn = int(input())\ndiv = division(n)\nans = 0\nfor i,e in div:\n    b = 1\n    while b <= e:\n        e -= b\n        b += 1\n        ans += 1\nprint(ans)\n
import sys\n\n# B - log\nimport math\n\nn = int(input())\ni = math.floor(math.sqrt(n*2))-1\n\nwhile True:\n  total = (2+i) * (i+1) // 2\n\n  if total <= n+1:\n    i += 1\n  else:\n    break\n\nprint(n-i+1)
n = int(input())\nt = input()\nif n == 1:\n    if t == "0":\n        print((10 ** 10))\n    else:\n        print((2 * 10 ** 10))\nelif n == 2:\n    if t == "00":\n        print((0))\n    elif t == "01":\n        print((10 ** 10 - 1))\n    elif t == "10":\n        print((10 ** 10))\n    else:  # 11\n        print((10 ** 10))\nelse:\n    repeat_num = (n + 6) // 3\n    ref = "110" * repeat_num\n    num_in_ref = 0\n    flag_over = 0  #\n    if ref[:n] == t:\n        num_in_ref += 1\n        if n % 3 == 0:\n            flag_over = 1\n    elif ref[1 : n + 1] == t:\n        num_in_ref += 1\n    elif ref[2 : n + 2] == t:\n        num_in_ref += 1\n        if n % 3 == 2:\n            flag_over = -1\n    # print(ref[: n + 1], t)\n    print((num_in_ref * (10 ** 10 - repeat_num + 2) + flag_over))\n\n
n,s = map(int,input().split())\nA = list(map(int,input().split()))\nif A[s-1] != 0:\n    per = 1\n    A[s-1] = 0\nelse:\n    per = 0\nA.sort()\nmaxs = max(A)\nans = [0] * (maxs + 1)\nanswer = maxs + 1\no = -1\nfor j in range(n):\n    if A[j] == 0:\n        o += 1\n    \n    if ans[A[j]] == 0:\n        ans[A[j]] = 1\n        answer -= 1\nan = per + max(o, answer)\n\nfor j in range(n-2,-1,-1):\n    \n    for t in range(A[j+1]-1, A[j] -1,-1):\n        if ans[t] == 0:\n            answer -= 1\n    \n    an = min(an, per + max(answer,o+n - j - 1))\nprint(an)
n = int(input())\ns = input().strip()\nif s.count('0') != s.count('1'):\n  print(1)\n  print(s)\nelse:\n  print(2)\n  print(s[:-1], s[-1])
inpt=input().split(' ')\nn=int(inpt[0])\nk=int(inpt[1])\ni_lst=[]\nj_lst=[]\nm=0\ninpt=input().split(' ')\nfor i in range(len(inpt)):\n    inpt[i]=int(inpt[i])\nfor i in range(k):\n    mn=min(inpt)\n    mx=max(inpt)\n    if mn!=mx:\n        i_mn=inpt.index(mn)\n        i_mx=inpt.index(mx)\n        inpt[i_mn]+=1\n        inpt[i_mx]-=1\n        i_lst.append(i_mx)\n        j_lst.append(i_mn)\n        m+=1\n    else:\n        break\n#print(inpt)\ninstblity=max(inpt)-min(inpt)\nprint(str(instblity)+' '+str(m))\nfor i in range(len(i_lst)):\n    print(str(i_lst[i]+1)+' '+str(j_lst[i]+1))\n
class Edge:\n    def __init__(self, to, cost, capacity, next_edge):\n        self.to = to\n        self.cost = cost\n        self.origin_cost = cost\n        self.capacity = capacity\n        self.next_edge = next_edge\n        self.pair = None\n\n\nclass MinCostMaxFlow:\n    def __init__(self, max_node):\n        self.null = Edge(0, 0, 0, None)\n        self.max_node = max_node + 3\n        self.total_cost = 0\n        self.current_cost = 0\n        self.visited = [False] * self.max_node\n        self.arc_list = []\n        self.edge_head = [self.null] * self.max_node\n        self.source = max_node + 1\n        self.sink = max_node + 2\n\n    def AddArcWithCapacityAndUnitCost(self, start_node, end_node, capacity, cost):\n        self.edge_head[start_node] = Edge(end_node, cost, capacity, self.edge_head[start_node])\n        self.edge_head[end_node] = Edge(start_node, -cost, 0, self.edge_head[end_node])\n        self.edge_head[start_node].pair = self.edge_head[end_node]\n        self.edge_head[end_node].pair = self.edge_head[start_node]\n        if start_node != self.source and start_node != self.sink and end_node != self.source and end_node != self.sink:\n            self.arc_list.append(self.edge_head[end_node])\n\n    def NumArcs(self):\n        return len(self.arc_list)\n\n    def Tail(self, index):\n        return self.arc_list[index].to\n\n    def Head(self, index):\n        return self.arc_list[index].pair.to\n\n    def UnitCost(self, index):\n        return self.arc_list[index].pair.origin_cost\n\n    def Flow(self, index):\n        return self.arc_list[index].capacity\n\n    def OptimalFlow(self):\n        edge = self.edge_head[self.sink]\n        total_flow = 0\n        while id(edge) != id(self.null):\n            total_flow += edge.capacity\n            edge = edge.next_edge\n        return total_flow\n\n    def OptimalCost(self):\n        return self.total_cost\n\n    def SetNodeSupply(self, node, supply):\n        if supply > 0:\n            self.AddArcWithCapacityAndUnitCost(self.source, node, supply, 0)\n        elif supply < 0:\n            self.AddArcWithCapacityAndUnitCost(node, self.sink, -supply, 0)\n\n    def aug(self, node_id, total_flow):\n        if node_id == self.sink:\n            self.total_cost += self.current_cost * total_flow\n            return total_flow\n        self.visited[node_id] = True\n        flow = total_flow\n        edge = self.edge_head[node_id]\n        while id(edge) != id(self.null):\n            if edge.capacity > 0 and edge.cost == 0 and not self.visited[edge.to]:\n                delta = self.aug(edge.to, min(flow, edge.capacity))\n                edge.capacity -= delta\n                edge.pair.capacity += delta\n                flow -= delta\n                if flow == 0:\n                    return total_flow\n            edge = edge.next_edge\n        return total_flow - flow\n\n    def modify_label(self):\n        min_cost = 1 << 63\n        for node_id in range(0, self.max_node):\n            if not self.visited[node_id]:\n                continue\n            edge = self.edge_head[node_id]\n            while id(edge) != id(self.null):\n                if edge.capacity > 0 and not self.visited[edge.to] and edge.cost < min_cost:\n                    min_cost = edge.cost\n                edge = edge.next_edge\n        if min_cost == 1 << 63:\n            return False\n        for node_id in range(0, self.max_node):\n            if not self.visited[node_id]:\n                continue\n            edge = self.edge_head[node_id]\n            while id(edge) != id(self.null):\n                edge.cost -= min_cost\n                edge.pair.cost += min_cost\n                edge = edge.next_edge\n        self.current_cost += min_cost\n        return True\n\n    def Solve(self):\n        while True:\n            while True:\n                self.visited = [False] * self.max_node\n                if self.aug(self.source, 1 << 63) == 0:\n                    break\n            if not self.modify_label():\n                break\n        return self.total_cost\n\n\ndef main():\n    s = input()\n    n = int(input())\n    source = 0\n    sink = n + 26 + 1\n    mcmf = MinCostMaxFlow(n + 28)\n    length = len(s)\n    num = [0] * 29\n    for i in range(0, length):\n        num[ord(s[i]) - ord('a') + 1] += 1\n    for i in range(1, 27):\n        if num[i] > 0:\n            mcmf.AddArcWithCapacityAndUnitCost(i, sink, num[i], 0)\n    for i in range(1, n + 1):\n        s, used = input().split(' ')\n        mcmf.AddArcWithCapacityAndUnitCost(source, 26 + i, int(used), 0)\n        num = [0] * 29\n        for j in range(0, len(s)):\n            num[ord(s[j]) - ord('a') + 1] += 1\n        for j in range(1, 27):\n            if num[j] > 0:\n                mcmf.AddArcWithCapacityAndUnitCost(26 + i, j, num[j], i)\n    mcmf.SetNodeSupply(source, 1 << 63)\n    mcmf.SetNodeSupply(sink, -(1 << 63))\n    mcmf.Solve()\n    if mcmf.OptimalFlow() != length:\n        print("-1")\n    else:\n        print(mcmf.OptimalCost())\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n = int( input().split()[0] )\nanswer = 0\nh = []\na = []\nfor i in range( 0, n ):\n	team = input().split()\n	h.append( int( team[0] ) )\n	a.append( int( team[1] ) )\nfor i in range( 0, n ):\n	for j in range( 0, n ):\n		if i == j:\n			continue\n		if h[i] == a[j]:\n			answer += 1\nprint( answer )\n
"""\nCodeforces Round 252 Div 2 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0:\n        return inputs\n    if mode == 1:\n        return inputs.split()\n    if mode == 2:\n        return [int(x) for x in inputs.split()]\n\ndef write(s="\n"):\n    if isinstance(s, list): s = " ".join(s)\n    s = str(s)\n    print(s, end="")\n\n################################################### SOLUTION\nn,v = read()\na = []\nfor i in range(n):\n    a.append(read())\na.sort(key=lambda x: x[0])\nres = 0\nfor day in range(1, 3002):\n    n = 0\n    while a and a[0][0] <= day:\n        if a[0][1] <= v-n:\n            n += a[0][1]\n            a[0][1] = 0\n        else:\n            a[0][1] -= v-n\n            n = v\n        if a[0][1] == 0:\n            a.pop(0)\n        else:\n            break\n    while a and a[0][0] == day-1: a.pop(0)\n    res += n\nprint(res)
n = int(input())\nf = list(map(int, input().split()))\nfor i in range(n):\n    f[i] -= 1\n\ndef gcd(a, b):\n    while (a != 0 and b != 0):\n        a, b = b, a % b\n    return a + b\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nans = 1\nminn = 0\n\nfor i in range(n):\n    vis = [False] * n\n    cur = i\n    st, pr = 0, 0\n    while not vis[cur]:\n        vis[cur] = True\n        cur = f[cur]\n        st += 1\n    fs = cur\n    cur = i\n    while cur != fs:\n        pr += 1\n        cur = f[cur]\n    minn = max(minn, pr)\n    ans = lcm(ans, st - pr)\n\nprint(((max(0, minn - 1))// ans + 1) * ans)\n
def main():\n    s = input()\n    a = b = c = 0\n    for elem in s:\n        if elem == "B":\n            a += 1\n        elif elem == "S":\n            b += 1\n        else:\n            c += 1\n    na, nb, nc = map(int, input().split())\n    pa, pb, pc = map(int, input().split())\n    k = int(input())\n\n    l = 0\n    r = 10**13\n    while r - l > 1:\n        m = (l + r) // 2\n        cntA = max(0, a * m - na)\n        cntB = max(0, b * m - nb)\n        cntC = max(0, c * m - nc)\n        money = cntA * pa + cntB * pb + cntC * pc\n        if money <= k:\n            l = m\n        else:\n            r = m\n    print(l)\n\nmain()
def check(n, casas):\n    #print('n:',n)\n    nonlocal T,N,street\n    current = n\n    time = T\n    need = 0\n    last_house = 0\n    \n    for ind, i in enumerate(street):\n        time -= 1\n        \n        if i == 'S':\n            current += 1\n             \n        elif i == 'H':\n            need += 1\n            if need == 1:\n                last_house = ind\n        \n        if need > 0 and current >= need:\n            #print('p',time, ind-last_house)\n            current -= need\n            casas -= need\n            need = 0\n                        \n            if casas > 0:\n                if (ind-last_house)*2 >= N-last_house-1:\n                    time -= N-last_house-1 + N-ind-1\n                    \n                    return time >= 0\n                    \n                time -= (ind-last_house)*2\n            else:\n                time -= ind-last_house\n                    \n        #print('lugar:',i,ind,current, time, need, last_house)\n        \n        if casas == 0:\n            break\n        \n    #print(time)\n    return time >= 0 and casas == 0\n    \nN,T = [int(i) for i in input().split()]\n\nstreet = input().rstrip('.')\nN = len(street)\nC = street.count('H')\nS = street.count('S')\nl = max(C-S, 0)\nr = 500005\n#print(N, C)\nwhile l < r:\n    mid = (l+r)//2\n    if check(mid, C):\n        r = mid\n    else:\n        l = mid + 1\n\nprint(l if l < 500005 else -1)
def recursion(n):\n    if n == 1:\n        return x\n    if n == 2:\n        return x + min(x , y)\n    if n % 2 == 0:\n        return recursion(n // 2) + min(y, x * (n - n//2))\n    else:\n        return min(recursion(n + 1), recursion(n - 1)) + x\n\n\nimport sys\nsys.setrecursionlimit(10000000)\nn, x, y = list(map(int, input().split()))\nprint(recursion(n))\n
read = lambda: map(int, input().split())\nn, m = read()\na = [list(read()) for i in range(n)]\nans = n * m\nfor i in range(n):\n    cnt0 = a[i].count(0)\n    cnt1 = a[i].count(1)\n    if cnt0 > 1: ans += (2 ** cnt0 - cnt0 - 1)\n    if cnt1 > 1: ans += (2 ** cnt1 - cnt1 - 1)\nfor i in range(m):\n    cnt0 = sum(a[j][i] == 0 for j in range(n))\n    cnt1 = sum(a[j][i] == 1 for j in range(n))\n    if cnt0 > 1: ans += (2 ** cnt0 - cnt0 - 1)\n    if cnt1 > 1: ans += (2 ** cnt1 - cnt1 - 1)\nprint(ans)
from itertools import permutations\n\ntab = []\n\nfor i in range(5):\n  buf = input().split(" ")\n  X = []\n  for j in range(5):\n    X.append(int(buf[j]))\n  tab.append(X)\n\nres = 0\n\nfor perm in permutations([0,1,2,3,4], 5):\n  wyn = 0\n  wyn += tab[perm[0]][perm[1]]\n  wyn += tab[perm[1]][perm[0]]\n  wyn += tab[perm[2]][perm[3]]\n  wyn += tab[perm[3]][perm[2]]\n  \n  wyn += tab[perm[1]][perm[2]]\n  wyn += tab[perm[3]][perm[4]]\n  wyn += tab[perm[2]][perm[1]]\n  wyn += tab[perm[4]][perm[3]]\n  \n  wyn += tab[perm[2]][perm[3]]\n  wyn += tab[perm[3]][perm[2]]\n  \n  wyn += tab[perm[3]][perm[4]]\n  wyn += tab[perm[4]][perm[3]]\n  \n  res = max(wyn, res)\n  \nprint(res)
def can_make(a, b, k, n):\n    k2 = k\n    for t, v in zip(a, b):\n        diff = v - t * n\n        if diff < 0:\n            k2 += diff\n\n    return k2 >= 0\n\ndef main():\n    n, k = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    lo = 0\n    hi = 3 * 10**9\n    while lo + 1 < hi:\n        mid = (lo + hi) // 2\n        if can_make(a, b, k, mid):\n            lo = mid\n        else:\n            hi = mid\n\n    print(lo)\n\nmain()\n
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nfrom itertools import accumulate\n\nT = int(input())\n#s = input()\n#N,M,K,Q = [int(x) for x in stdin.readline().split()]\n#arr = [int(x) for x in stdin.readline().split()]\n\ncheck = [0]*45000\n\ns = 0\nfor i in range(1,45001):\n    s += i\n    check[i-1] = s\n\nfor i in range(T):\n    N = int(input())\n\n    if N in check:\n        idx = check.index(N)\n        idx += 2\n        print('1','3'*idx,'7',sep='',end='\n')\n\n    else:\n        # find largest number < N in check\n        target = max(num for num in check if num < N)\n        three = check.index(target)\n\n        d = N - target\n\n        print('1','3'*2,'7'*d,'3'*(three),'7',sep='',end='\n')
n = input()\nprint(n+n[::-1])
n = int(input())\ns = list([1 if x == '>' else -1 for x in input().strip()])\nd = list(map(int, input().strip().split()))\nb = [False for _ in range(n)]\n\nc = 0\nwhile True:\n    c += s[c] * d[c]\n    if c >= n or c < 0:\n        print('FINITE')\n        return\n    if b[c]:\n        print('INFINITE')\n        return\n    b[c] = True\n
'''input\n8\n11010111\n'''\nn = int(input())\ns = input()\na = [0]\nd = {0:0}\nfor i in range(n):\n    if s[i] == '1': a.append(a[-1]+1)\n    else: a.append(a[-1]-1)\n    if a[i+1] not in d: d[a[i+1]] = i+1\nans = 0\nfor i in range(1,n+1):\n    ans = max(ans,i-d[a[i]])\nprint(ans)   
s=[]\ns.append("qwertyuiop")\ns.append("asdfghjkl;")\ns.append("zxcvbnm,./")\n\nx=input()\ny=input()\n\nfor item in y:\n    for i in range(3):\n        for j in range(len(s[i])):\n            if(s[i][j]==item):\n                if(x=='R'):\n                    print(s[i][j-1],end="")\n                else:\n                    print(s[i][j+1],end="")\nprint()\n                    \n
n, m = map(int,input().split())\nb = list(map(int,input().split()))\nans = [-1]*101\nfor bb in b:\n    for i in range(bb,n+1):\n        if ans[i]==-1:\n            ans[i]=bb\nprint(*ans[1:n+1])
n,x=list(map(int,input().split()))\n\nL=list(map(int,input().split()))\n\ns=sum(L)\n\ns=abs(s)\nans=0\nwhile(s>0):\n    s-=x\n    ans+=1\nprint(ans)\n
n, k = list(map(int, input().split()))\nm = n + 1\nif 2 * k > n - 1: print('-1')\nelse:\n    t = []\n    for i in range(1, k + 1):\n        t += [str(j) + ' ' + str(j + i) for j in range(1, m - i)]\n        t += [str(j) + ' ' + str(j + i - n) for j in range(m - i, m)]\n    print(k * n)\n    print('\n'.join(t))\n
a, b, c, d = list(map(int, input().split()))\nprint((a * 1.0) / (b * (1 - ((d - c) * (b - a) * 1.0) / (d * b))))\n
k = int(input())\ndk = list(map(int,input().split()))\nans = []\nif 0 in dk:\n    ans.append(0)\nif 100 in dk:\n    ans.append(100)\nf1 = False\nfor q in dk:\n    if 0<q<10:\n        ans.append(q)\n        f1 = True\n        break\nf2 = False\nfor q in dk:\n    if 9<q<100 and q%10==0:\n        ans.append(q)\n        f2  = True\n        break\nif (not f1 and not f2):\n    for j in dk:\n        if j!=0 and j!=100:\n            ans.append(j)\n            break\nprint(len(ans))\nprint(*ans)\n
n, k = map(int, input().split())\ns = input()\nl, r = int(-1), int(n)\n\nwhile r - l > 1:\n    m = (l+r)//2\n    c, p = 1, 0\n    cond = True\n    while p < n and c < k:\n        i = p + m + 1\n        while i >= p and (i >= n or s[i] == '1'):\n            i = i - 1;\n        if (i == p):\n            break\n        c = c + 1\n        p = i\n    cond = cond and (p == n-1)\n    if cond:\n        r = m\n    else:\n        l = m\nprint(int(r))
for q in range(int(input())):\n    n, k, l = map(int, input().split())\n    line = list(map(int, input().split()))\n    line.append(-1000)\n    dp = [[False] * (2 * k) for i in range(n + 2)]\n    for i in range(2 * k):\n        dp[0][i] = True\n    for i in range(1, n + 2):\n        for j in range(2 * k):\n            if j < k and line[i - 1] + j <= l:\n                if dp[i - 1][(j - 1) % (2 * k)]:\n                    dp[i][j] = True\n                elif dp[i][(j - 1) % (2 * k)]:\n                    dp[i][j] = True\n            if j >= k and line[i - 1] + 2 * k - j <= l:\n                if dp[i - 1][j - 1]:\n                    dp[i][j] = True\n                elif dp[i][j - 1]:\n                    dp[i][j] = True\n    if max(dp[n + 1]) == True:\n        print("Yes")\n    else:\n        print("No")
from math import*\nfrom random import*\n\n# input = open(file = "input.txt", mode = "r")\n# output = open(file = "output.txt", mode = "w")\n# list(map(int, input().split()))\n\nn = int(input())\nA = list(map(int, input().split()))\nz, f = 0, 0\nfor i in range(n):\n    if A[i] == 0:\n        z += 1\n    else:\n        f += 1\nif (z == 0):\n    print(-1)\n    return\nif (f // 9 == 0):\n    print(0)\nelse:\n    print ("5" * (f - f % 9) + "0" * z)
n, t = list(map(int, input().split()))\na = [int(x) for x in input().split()]\n\notv = 0\n\ndef rec(t, a):\n	nonlocal otv\n	s = 0\n	for c in a:\n		s += c\n	kol = t // s\n	kol = max(kol, 0)\n	otv += (kol * len(a))\n	octat = t - kol * s\n	res = []\n	su = 0\n	for c in a:\n		if su + c <= octat:\n			res.append(c)\n			su += c\n	if su == 0:\n		print(otv)\n		return\n	#print(octat, res, otv)\n	rec(octat, res)\n\nrec(t, a)\n
\nk,a0,b0 = map(int,input().split())\na0,b0 = a0-1,b0-1\n\nA = tuple(tuple(map(lambda c: int(c)-1,input().split())) for _ in range(3))\nB = tuple(tuple(map(lambda c: int(c)-1,input().split())) for _ in range(3))\n\n# A chose i and B chose j implies ? will choose ?[i][j]\n\nscore = lambda a,b: (int((a-b)%3==1),int((b-a)%3==1))\n\nS = set()\n\ncur = (a0,b0)\n\nwhile cur not in S:\n  S.add(cur)\n  a,b = cur\n  cur = (A[a][b],B[a][b])\n\npre = (0,0)\np = (a0,b0)\nwhile k > 0 and p != cur:\n  pre = tuple(c+d for c,d in zip(pre,score(*p)))\n  a,b = p\n  p = (A[a][b],B[a][b])\n  k -= 1\n\nif k == 0:\n  print(*pre)\n  return\n\n# cycle length\nL = 1\ncnt = score(*cur)\na,b = cur\np = (A[a][b],B[a][b])\n\nwhile p != cur:\n  cnt = tuple(c+d for c,d in zip(cnt,score(*p)))\n  L += 1\n  a,b = p\n  p = (A[a][b],B[a][b])\n\nn = k//L\nk -= (k//L)*L\ncnt = (cnt[0]*n,cnt[1]*n)\n\nsuf = (0,0)\np = cur\nwhile k > 0:\n  suf = tuple(c+d for c,d in zip(suf,score(*p)))\n  a,b = p\n  p = (A[a][b],B[a][b])\n  k -= 1\n\nprint(*(a+b+c for a,b,c in zip(pre,cnt,suf)))
def f(arr):\n    d = max(arr)\n    for i in range(len(arr)):\n        arr[i] = d - arr[i]\n\n\n# for _ in range(1):\nfor _ in range(int(input())):\n    n, k = list(map(int, input().split()))\n    # n = int(input())\n    arr = list(map(int, input().split()))\n    if k <= 2:\n        for i in range(k):\n            f(arr)\n    elif k % 2 == 1:\n        for i in range(3):\n            f(arr)\n    else:\n        for i in range(4):\n            f(arr)\n    print(*arr)\n
input()\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\nfor x in a:\n    if x in b:\n        print(x, end=' ')\nprint()\n
import math \na = int(input())\nif a%2==1:\n    print(math.ceil((a-1)/2))\nelse:\n    z = 1\n    while z*2<=a:\n        z*=2\n    print((a-z)//2)
s=input()\nt=input()\na=0\nb=0\nc=0\nfor i in range(len(s)):\n   if s[i]=='+':a+=1\n   else:a-=1\nfor i in range(len(t)):\n   if t[i]=='+':b+=1\n   elif t[i]=='-':b-=1\n   else:c+=1\nx=a-b\nd=0-c\ny=0-1\nfor i in range(c+1):\n   if d==x:y=i\n   d+=2\n\ndef fact(n):\n   w=1\n   for i in range(n):\n      w*=(i+1)\n   return(w)\n  \ndef parmi(k,n):\n   w=1\n   w*=fact(n)\n   w//=fact(k)\n   w//=fact(n-k)\n   return(w)\n   \ndef puiss(k,n):\n   w=1\n   for i in range(n):\n      w*=k\n   return(w)\n   \nif y==-1:print(0.0)\nelse:print(parmi(y,c)/puiss(2,c))\n
n=int(input())\nc=[[] for i in range(n)]\n[c[int(x)].append(i+1) for i,x in enumerate(input().split())]\ns=0;r=[]\nfor i in range(n):\n    while len(c[s])==0 and s>=0:\n        s-=3\n    if s<0:\n        print('Impossible')\n        break\n    else:\n        r+=[c[s].pop()]\n        s+=1\nelse:\n     print('Possible')\n     print(*r)
import math\nm,R=list(map(int,input().split()))\n\ncord=math.sqrt(2*(R**2))\nans=0\nunit=int(2*R)\nx=(m)*(m/2)\nfor i in range(m):\n    ans+=2*R*m\n    ans+=(cord*(m-1))\n    if(i==0 or i==m-1):\n        if(m==1):\n            continue\n        ans+=cord*(m-2)\n    else:\n        if(m==1):\n            continue\n        ans+=cord*(m-3)\n    #left\n    left=(i-1)-1\n    if(left<-1):\n        left=-1\n    ans+=(left+1)*(left/2)*unit\n    #right\n    r=(m-1)-(i)-2\n    if(r<-1):\n        r=-1\n    ans+=(r+1)*(r/2)*unit\nans/=(m**2)\nprint(ans)\n
n = int(input())\na = list(map(int, input().split()))\nmn = 10000000000\nans = -1\nfrom math import ceil\nfor i in range(n):\n    b = a[i] - i\n    c = int(ceil(b / n))\n    cc = n*c\n    if n*c < mn:\n        mn = n*c\n        ans = i+1\nprint(ans)            
a, A = list(map(int,input().split()))\nb, B = list(map(int,input().split()))\nc = input()\nc = int(c[:2]) * 60 + int(c[-2:])\nd = 0\nfor i in range(5 * 60, 24 * 60, b):\n    if i < c + A and i + B > c:\n        d += 1\nprint(d)\n
n, k = map(int, input().split())\na = list(map(int, input().split()))\nday = 1\ndef poss(day):\n	q = 0\n	mp = dict()\n	for el in a:\n		if el not in mp:\n			mp[el] = 1\n		else:\n			mp[el] += 1\n	for el in mp:\n		q += mp[el] // day\n	return q >= n\n\nwhile poss(day):\n	day += 1\n\nprint(day - 1)
import numpy as np\n \nN, T = map(int, input().split())\ndata = []\nfor i in range(N):\n  a, b = map(int, input().split())\n  data.append((a,b))\ndata.sort()\ndata = np.array(data)\n\ndp = np.zeros(T)\nans = 0\nfor a, b in data:\n    ans = max(ans,dp[-1]+b)\n    if a< T:\n        newtable = dp[:T-a] + b\n        dp[a:] = np.maximum(dp[a:], newtable)\n\nprint(int(ans))
from functools import reduce\n\nx,y=list(map(int,input().split()))\nmod = 10 ** 9 + 7\n\nif (2 * y - x) % 3 != 0 or (2 * x - y) % 3 != 0:\n  print("0")\n  return\n  \na,b = (2 * y - x) // 3, (2 * x - y) // 3 \n\nr = min(a,b)\n\nif r == 0:\n  print("1")\nelif r < 0:\n  print("0")\nelse:\n  numerator = reduce(lambda x, y: x * y % mod, range(a + b - r + 1, a + b + 1))\n  denominator = reduce(lambda x, y: x * y % mod, range(1,r + 1))\n  print(numerator * pow(denominator, mod - 2, mod) % mod)
import sys, math\ndef rnd(x):\n    a = int(x)\n    b = x-a\n    if b>=0.5:\n        a+=1\n    return(a)\nn = int(input())\nprint(rnd(n/2))\n
n = int(input())\nprint(pow(1378, n, 10))\n
import sys\n\n\n#sys.stdin = open('input.txt')\n#sys.stdout = open('output.txt', 'w')\n\nn, m = [int(i) for i in input().split()]\nfirst = min(n, m)\nsecond = (max(n, m) - first) // 2\nprint(first, second)
d, L, v1, v2 = list(map(int, input().split()))\nt = (L - d) / (v1 + v2)\nprint(t)\n
n, s = [int(x) for x in input().split()]\n\nts = []\nfor _ in range(n):\n    h, m = [int(x) for x in input().split()]\n    ts.append(h * 60 + m)\n\nif ts[0] >= s + 1:\n    print(0, 0)\n    return\n\ndiffs =  [y - x for x, y in zip(ts, ts[1:])]\n\nfor i, diff in enumerate(diffs):\n    if diff >= 2 * s + 2:\n        break\nelse:\n    i = len(ts) - 1\n\nt = ts[i] + s + 1\nprint(t // 60, t % 60)\n
import math\nfrom collections import deque, defaultdict\nfrom sys import stdin, stdout\ninput = stdin.readline\n# print = stdout.write\nlistin = lambda : list(map(int, input().split()))\nmapin = lambda : map(int, input().split())\nn = input()\na = listin()\nodd = 0\neven = 0\nfor i in a:\n    if i%2:\n        odd+=1\n    else:\n        even+=1\nif (even == 0 or odd == 0):\n    print(*a)\nelse:\n    a.sort()\n    print(*a)
n = int(input())\n\ns = input()\ncode = input()\n\nres = 0\nfor i in range(n):\n    k = abs(int(s[i]) - int(code[i]))\n    res += min(k, 10 - k)\n\nprint(res)
n=int(input())\n\nif(n%2==1):\n    print(-1)\n\nelse:\n    L=list(range(1,n+1))\n    for i in range(0,n,2):\n        t=L[i]\n        L[i]=L[i+1]\n        L[i+1]=t\n    for i in range(n-1):\n        print(L[i],end=" ")\n    print(L[-1])\n
from collections import deque\n\n__author__ = 'asmn'\n\nn = int(input())\nend = tuple(sorted(map(lambda x: int(x) - 1, input().split())))\nst = (0, 1, 2)\nmat = [input() for i in range(n)]\nv = set([st])\npath = {}\ndist = {st: 0}\nqueue = deque([st])\n\nwhile end not in v and len(queue) > 0:\n    p = queue.popleft()\n\n    for x in range(-2, 1):\n        p1, p2, p3 = p[x], p[x + 1], p[x + 2]\n        for i in range(n):\n            if i not in (p1, p2, p3) and mat[i][p3] == mat[p1][p2]:\n                np = tuple(sorted((p1, p2, i)))\n                if np not in v:\n                    v.add(np)\n                    queue.append(np)\n                    path[np] = p\n                    dist[np] = dist[p] + 1\n\n\ndef pathinfo(fr, to):\n    return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n\n\nif end not in dist:\n    print(-1)\n    return\n\nprint(dist[end])\nwhile end in path:\n    print(pathinfo(end, path[end]))\n    end = path[end]
n,k = list(map(int,input().split()));\na = list(map(int,input().split()));\n\nif max(a) >= k:\n    print(0)\n    return\n\nlx = 0\nwhile a[lx] == 0:\n    lx+=1\n\nlo,hi = 1,k\n\ndef can(x):\n    bc = 1\n    tot = 0\n    for i in range(n-lx):\n        if(bc >= k):\n            return True\n        tot += bc*a[n-1-i]\n        bc *= (x+i)\n        bc = bc//(i+1)\n        if(tot >= k):\n            return True\n    return tot >= k\n\nwhile lo < hi :\n    mid = (lo+hi)//2\n    cancan = can(mid)\n    #print(mid,cancan)\n    if cancan : hi = mid\n    else : lo = mid + 1\n\nprint(lo)\n
import math\nimport sys\nfrom collections import Counter\n\ndef solve():\n    n, m = [int(x) for x in input().split()]\n    L, R = 1, n\n    for line in sys.stdin:\n        x, y = [int(x) for x in line.split()]\n        x, y = min(x, y), max(x, y)\n        L, R = max(L, x), min(R, y)\n        \n    return max(R - L, 0)\n\nprint(solve())\n\n
N = int(input())\nA = [int(a) for a in input().split()]\n\nfor i in range(1, N):\n    if A[i] + A[i-1] == 5:\n        print("Infinite")\n        break\nelse:\n    ans = 0\n    for i in range(1, N):\n        if A[i] == 2:\n            if i == 1 or A[i-2] == 2:\n                ans += 3\n            else:\n                ans += 2\n        elif A[i] == 3:\n            ans += 4\n        else:\n            if A[i-1] == 2:\n                ans += 3\n            else:\n                ans += 4\n    print("Finite")\n    print(ans)\n
def prog():\n    n = int(input())\n    inp = list(map(int,input().split()))\n    temp = []\n    while(n!=1):\n        temp += [n]\n        n = inp[n-2]\n    temp += [1]\n    temp.reverse()\n    for i in temp:\n        print(i,end=' ')\nprog()
MOD = 998244353\n\nlist_size = 1000001\n\nf_list = [1] * list_size\nf_r_list = [1] * list_size\n\nfor i in range(list_size - 1):\n	f_list[i + 1] = int((f_list[i] * (i + 2)) % MOD)\n\ndef power(n, x):\n	if x == 1:\n		return n\n	elif x % 2 == 0:\n		return power(int((n * n) % MOD), int(x / 2))\n	else:\n		return int((n * power(n, x - 1)) % MOD)\n\nf_r_list[-1] = power(f_list[-1], MOD - 2)\n\nfor i in range(2, list_size + 1):\n	f_r_list[-i] = int((f_r_list[-i + 1] * (list_size + 2 - i)) % MOD)\n\ndef comb(n, r):\n	if n < r:\n		return 0\n	elif n == 0 or r == 0 or n == r:\n		return 1\n	else:\n		return (((f_list[n - 1] * f_r_list[n - r - 1]) % MOD) * f_r_list[r - 1]) % MOD \n\nn = int(input())\nans = f_list[n-1]\nfor i in range(2, n):\n	ans = (ans + comb(n, i) * (f_list[i-1] - 1) * f_list[n-i-1]) % MOD\nprint(ans)
n = int(input())\na = list(map(int, input().split()))\n\ndp = [[False] * (n + 1) for i in range(n + 1)]\n\ndef solve(l, r):\n    if dp[l][r]:\n        return dp[l][r]\n    if r - l == 1:\n        dp[l][r] = (a[l], 1)\n        return dp[l][r]\n    tmp = 10 ** 9\n    for i in range(l + 1, r):\n        if solve(l, i)[0] == -1 or solve(i, r)[0] == -1:\n            tmp = min(tmp, dp[l][i][1] + dp[i][r][1])\n        elif solve(l, i) == solve(i, r):\n            tmp = solve(l, i)[0] + 1\n            dp[l][r] = (tmp, 1)\n            return dp[l][r]\n        else:\n            tmp = min(tmp, 2)\n    dp[l][r] = (-1, tmp)\n    return dp[l][r]\n\nsolve(0, n)\nprint(dp[0][n][1])
t=input()\ns=input()\nn=len(s)\nh=[0]*(n+1)\nh[0]=0\nj=0\nfa=[0]*(n+1)\nfor i in range(2,n+1) :\n    while j and s[i-1]!=s[j]:\n        #j=fa[j-1];\n        j=fa[j];\n    if s[i-1]==s[j]:\n        j+=1\n    fa[i]=j;\n#print(fa)\nl=list()\nj=fa[n]\nwhile(j>0):\n    l.append(j)\n    j=fa[j]\n\n\ntmp=t \nt=s \ns=tmp \nn=len(s)\ndp=[0]*(n)\nm=[0]*n \n'''if len(s)<len(t):\n    print(0)'''\n    \nfor i in range(len(t)-1,len(s)):\n    can=True\n    for j in range(len(t)):\n        if s[i-len(t)+1+j]=='?':\n            continue\n        if s[i-len(t)+1+j]!=t[j]:\n            can=False\n            break\n    if can:\n        dp[i]=1\n        for d in l:\n            d=len(t)-d\n            dp[i]=max(dp[i],1+dp[i-d])\n        if i-len(t)>=0:\n            dp[i]=max(dp[i],m[i-len(t)]+1)\n    m[i]=max(m[i-1],dp[i])\nprint(m[-1])\n
n = int(input()) + 1\ns = sum(map (int, input().split()))\n\nans = 5\nfor i in range (1, 6):\n    if (s + i) % n == 1: ans -= 1\nprint(ans)\n
m = 998244353\nn = 5050\nmi = [1] * n\nfor i in range(2, n):\n	mi[i] = (-(m//i) * mi[m%i]) % m;\nf = [1] * n\ng = [1] * n\nfor i in range(2, n):\n	f[i] = (f[i-1] * i) % m\n	g[i] = (g[i-1] * mi[i]) % m\n	\ndef calc(x, y):\n	s = 1\n	p = f[x] * f[y]\n	for i in range(1, min(x, y)+1):\n		den = g[i] * g[x-i] * g[y-i]\n		s += p * den % m\n	return s\n\na, b, c = map(int, input().split())\nans = calc(a, b) * calc(b, c) * calc(c, a) % m\nprint(ans)
import sys\nreadline = sys.stdin.readline\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0]*N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return par, order\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for i, v in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\n\nN = int(readline())\nMOD = 998244353\nEdge = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(int, readline().split())\n    a -= 1\n    b -= 1\n    Edge[a].append(b)\n    Edge[b].append(a)\n\nP, L = parorder(Edge, 0)\nC = getcld(P)\n\ndp = [[1, 1, 0, 0, 1] for _ in range(N)]\nfor p in L[::-1]:\n    if not C[p]:\n        continue\n    res = 1\n    res2 = 1\n    res3 = 1\n    for ci in C[p]:\n        res = (res*(dp[ci][2] + dp[ci][3] + dp[ci][4])) % MOD\n        res2 = (res2*(dp[ci][1] + dp[ci][2] + 2*dp[ci][3] + dp[ci][4])) % MOD\n        res3 = (res3*(sum(dp[ci]) + dp[ci][2] + dp[ci][3])) % MOD\n    dp[p][0] = res\n    dp[p][1] = res\n    dp[p][2] = (res2 - res)%MOD\n    dp[p][3] = (res3 - res)%MOD\n    dp[p][4] = res\nprint((dp[0][2] + dp[0][3] + dp[0][4] - 1) %MOD)
"""\nCodeforces Contest 288 Div 2 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.4.2\n"""\n\n################################################### SOLUTION\n\ndef main():\n    n = read(0)\n    ld = int(n[-1])\n    last = -1\n    for i in range(len(n)-1):\n        c = int(n[i])\n        if c%2 == 0 and c < ld:\n            return n[:i] + n[-1] + n[i+1:-1] + n[i]\n        if c%2 == 0:\n            last = i\n    if last == -1:\n        return -1\n    return n[:last] + n[-1] + n[last+1:-1] + n[last]\n\n\n\n#################################################### HELPERS\n\n\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
n = int(input())\na = sum(list(map(int, input().split())))\nif n == 1:\n	if a == 1:\n		print("YES")\n	else:\n		print("NO")\nelse:\n	if a == n - 1:\n		print("YES")\n	else:\n		print("NO")\n
n = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nc = {}\nfor i in range(n):\n    c[b[i]] = i\nb = []\nfor i in range(n):\n    a[i] = c[a[i]]\nprint(sum(abs(a[i] - i) for i in range(n)) >> 1)\n\nwhile True:\n    for i in range(n):\n        if a[i] < i:\n            for j in range(a[i], i):\n                if a[j] >= i:\n                    a[i], a[j] = a[j], a[i]\n                    b += [(i+1, j+1)]\n                    break\n            break\n    else:\n        break\n\nprint(len(b))\nfor e in b:\n    print(*e)\n\n
L=[]\nfor i in range(4):\n    L.append(input())\nans="NO"\nfor i in range(3):\n    for j in range(3):\n        x=L[i][j]+L[i][j+1]+L[i+1][j]+L[i+1][j+1]\n        if(x.count('#')==3 or x.count('.')==3 or x.count('#')==4 or x.count('.')==4):\n            ans="YES"\nprint(ans)\n            \n        \n
aa=0\na, b, c, d = (list(map(int, input().split(' '))))\n\nl = list(map(int, input().split(' ')))\n\nfor i in range(2**a):\n    k = bin(i)[2:]\n    t = 0\n    k = '0' * (a-len(k)) + k\n    x = []\n    for j in range(a):\n        if k[j] == '1':\n            x.append(l[j])\n            t += 1\n            \n    if t >= 2:\n        if b <= sum(x) <= c and max(x) - min(x) >= d:\n            aa+=1\nprint(aa)\n
n, k = map(int, input().split())\na = list(input()) * 2\n\niter1 = [0] * (2 * n)\niter2 = [0] * (2 * n)\nchanges = 0\nfor i in range(1, 2 * n):\n    if a[i] != a[i - 1]:\n        changes += 1\n    else:\n        changes = 0\n    iter1[i] = changes\nchanges = 0\nfor i in range(2 * n - 2, -1, -1):\n    if a[i] != a[i + 1]:\n        changes += 1\n    else:\n        changes = 0\n    iter2[i] = changes\n\niters = [min(iter1[n + i], iter2[i]) for i in range(n)]\nfor i in range(n):\n    if iters[i] > n // 2:\n        iters[i] = 10 ** 9 + 1\n    it = min(iters[i], k)\n    if it % 2 != 0:\n        if a[i] == "B":\n            a[i] = "W"\n        else:\n            a[i] = "B"\nprint("".join(a[:n]))
import sys\n\nn, m = [int(x) for x in input().split()]\nA = [int(x) for x in input().split()]\nB, C = [0]*(m+1), [0]*(m+1)\nfor a in A:\n    if a <= m: B[a] += 1\nfor i in range(2, m + 1):\n    for j in range(i, m+1, i):\n        C[j] += B[i]\n\nk, l = 1, 0\nfor i in range(2, m+1):\n    if C[i] > l:\n        l = C[i]\n        k = i\nprint(k, l + B[1])\nfor i, a in enumerate(A):\n    if k%a == 0: sys.stdout.write(str(i+1) + ' ')\n
f = lambda: map(int, input().split())\nm = 1000000007\n\nd, n = f()\nt = list(f())\np = [[] for i in range(n)]\nfor j in range(n - 1):\n    u, v = f()\n    u -= 1\n    v -= 1\n    p[u].append(v)\n    p[v].append(u)\n\ndef g(u, x, a, b, q):\n    k = 1\n    for v in p[u]:\n        if a < t[v] <= b or t[v] == a and v > q:\n            if v != x: k += k * g(v, u, a, b, q) % m\n    return k\n\n\ns = 0\nfor q in range(n):\n    a = t[q]\n    b = a + d\n    s += g(q, -1, a, b, q)\n\nprint(s % m)
x,y = [int(x) for x in input().split()]\nif x*y > 0:\n    if x < 0:\n        print(x+y,0,0,x+y)\n    else:\n        print(0,x+y,x+y,0)\nelse:\n    if x < 0:\n        print(x-y,0,0,y-x)\n    else:\n        print(0,y-x,x-y,0)
n=int(input())\n\nL=list(map(int,input().split()))\n\nT=int(input())\n\nX=[0]*1005\n\nfor i in range(len(L)):\n    X[L[i]]+=1\n\nfor i in range(1,1005):\n    X[i]+=X[i-1]\nbest=0\nfor i in range(1+T,1005):\n    if(X[i]-X[i-T-1]>best):\n        best=X[i]-X[i-T-1]\nprint(best)\n
n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nt1, t2 = 0, 0\nfor i in a:\n    t1 ^= i\nfor i in b:\n    t2 ^= i\nif t1 != t2:\n    print('NO')\nelse:\n    print('YES')\n    for i in range(n-1):\n        for j in range(m-1):\n            print(0, end=' ')\n        print(a[i])\n    tmp = 0\n    for j in range(m-1):\n        print(b[j], end=' ')\n        tmp ^= b[j]\n    print(a[n-1]^tmp)\n
n, m = [int(x) for x in input().split()]\n\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\n\nmult = 1\nmod = 10 ** 9 + 7\nres = 0\n\nm_inv = pow(m, mod - 2, mod)\n\nfor x, y in zip(a, b):\n    if x and y:\n        if x > y:\n            res += mult\n            res %= mod\n            break\n        elif x == y:\n            continue\n        else:\n            break\n    elif x:\n        res += mult * (x-1) * m_inv % mod\n        res %= mod\n        mult = mult * m_inv % mod\n    elif y:\n        res += mult * (m - y) * m_inv % mod\n        res %= mod\n        mult = mult * m_inv % mod\n    else:\n        res += mult * m * (m - 1) // 2 * m_inv * m_inv % mod\n        res %= mod\n        mult = mult * m_inv % mod\nprint(res)\n
from bisect import bisect_left,bisect\n\n# ===================================== 約数のリスト   \ndef enum_div(n):\n    ir=int(n**(0.5))+1\n    ret=[]\n    for i in range(1,ir):\n        if n%i == 0:\n            ret.append(i)\n            if (i!= 1) & (i*i != n):\n                ret.append(n//i)\n    return ret\n\nn,m=list(map(int,input().split()))\n\ndiv=enum_div(m)+[m]\ndiv.sort(reverse=True)\n\nrd=[0]*len(div)\nfor i in range(len(div)):\n    rd[i]=m//div[i]\n\nmm=bisect_left(rd,n)\n\nprint((div[mm]))\n
n,m = map(int,input().split())\ngraph = [[float("inf")]*(n+1) for _ in range(n+1)]\nfor i in range(m):\n  a,b,c = map(int,input().split())\n  graph[a][b] = c\n  graph[b][a] = c\n\n    \n\ndef dijkstra(s,cost):\n  d = [float("inf")]*(n+1)\n  used = [False]*(n+1)\n  d[s] = 0\n  \n  while True:\n    v = -1\n    for i in range(1,n+1):\n      if (not used[i]) and (v == -1):\n        v = i\n      elif (not used[i]) and d[i] < d[v]:\n        v = i\n    if v == -1:\n      break\n    used[v] = True\n               \n    for j in range(1,n+1):\n      d[j] = min(d[j],d[v]+cost[v][j])\n  return d\n\nans = 0\nfor i in range(1,n):\n  d = dijkstra(i,graph)\n  for j in range(i+1,n+1):\n    if i == j:\n      continue\n    if graph[i][j] != float("inf") and graph[i][j] > d[j]:\n      ans += 1\nprint(ans)
def main():\n  S = str(input())\n \n  ans = [0] * 13\n  ans[0] = 1\n  MOD = 10**9 + 7\n\n  for i in S:\n      dp = [0] * 13\n      for j in range(13):\n          dp[(j * 10) % 13] = ans[j] % MOD\n      dp += dp\n      if i == '?':\n          for j in range(13):\n              ans[j] = sum(dp[j+4:j+14])\n      else:\n          for j in range(13):\n              ans[j] = dp[j + 13 - int(i)]\n\n  print(ans[5] % MOD)\n\ndef __starting_point():\n    main()\n__starting_point()
n, m = map(int,input().split())\nfor i in range(m):\n    a, *b = map(int,input().split())\n    b = set(b)\n    for j in b:\n        if -j in b:\n            break\n    else:\n        print("YES")\n        break\nelse:\n    print("NO")
tmp = list(map(int,input().split()))\nn,k = tmp[0],tmp[1]\na = list(map(int,input().split()))\n\ncur = a[0]\nw = 0\nOK = False\nfor i in range(1,10000):\n    op = a[i]\n    if cur > op:\n        a.append(op)\n        w += 1\n    else:\n        cur = op\n        a.append(cur)\n        w = 1\n    if w >= k:\n        OK = True\n        break\nif OK:\n    print(cur)\nelse:\n    print(max(a))
import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\n\ndef getN():\n    return int(input())\ndef getList():\n    return list(map(int, input().split()))\nimport math\nfrom bisect import bisect_left\n\n\nn, k = getList()\nnums = getList()\nnums.sort()\nhalf = (n // 2) + 1\nnums = nums[half-1:]\nsm = sum(nums)\n\ndef check(arr, k, tgt):\n    for num in arr:\n        sub = max(0, (tgt - num))\n        if sub == 0:\n            return True\n        k -= sub\n        if k < 0:\n            return False\n\n    return True\n\n\nmn = 0\nmx = 3 * (10 ** 9)\n# print(nums, sm)\nwhile(mx-mn > 1):\n    md = (mx+mn) // 2\n    # print(md)\n    if check(nums, k, md):\n        mn = md\n    else:\n        mx = md\n\nif not check(nums, k, md):\n    md -= 1\nprint(md)\n
input()\ndef v(x):\n    ret = 0\n    for i in x:\n        if ord('A') <= ord(i) <= ord('Z'):\n            ret += 1\n    return ret\nprint(max(v(i) for i in input().strip().split()))\n
import itertools\nimport math\nimport random\n\nimport time\ndef timer(f):\n    def tmp(*args, **kwargs):\n        t = time.time()\n        res = f(*args, **kwargs)\n        print("Время выполнения функции: %f" % (time.time()-t))\n        return res\n\n    return tmp\n\ndef genArray(length, lower, upper):\n    return [random.randint(lower, upper) for i in range(length)]\n\n\nn, s = list(map(int, input().split(' ')))\narray = [list(map(int, input().split(' '))) for i in range(n)]\n\nres = -100;\nfor i in range(n):\n    if array[i][0]+array[i][1]/100 <= s:\n        sdacha = 100 - array[i][1]\n        if array[i][1]== 0:\n            sdacha = 0\n        if sdacha>res:\n            res = sdacha\n\nif res == -100:\n    print(-1)\nelse:\n    print(res)\n\n
n, m, k = map(int, input().split())\nif k == -1 and n % 2 != m % 2:\n	print(0)\nelse:\n	print(pow(2, (n - 1) * (m - 1), 10**9 + 7))
from copy import copy\nn, m = map(int, input().split())\nP = []\nz = set()\nfor i in range(1, n + 1):\n    z.add(i)\nfor i in range(m):\n    P.append(list(map(int, input().split())))\nfor x in P[0][0], P[0][1]:\n    s = copy(z)\n    for i in range(1, m):\n        a, b = P[i]\n        if a != x and b != x:\n            s.intersection_update({a, b})\n    if len(s):\n        print('YES')\n        return\nprint('NO')
n = int(input())\nc = list(map(int, input().split(" ")))\n\nnodes = dict()\nnodes[""] = 0\n# print(nodes)\ndepth = 0\n\nwhile depth < n:\n	# expand\n	new_nodes = dict()\n	s = input()\n	for node in nodes.keys():\n		if s >= node:\n			# not reverse\n			if s in new_nodes:\n				new_nodes[s] = min(new_nodes[s], nodes[node])\n			else:\n				new_nodes[s] = nodes[node]\n		if s[::-1] >= node:\n			# not reverse\n			if s[::-1] in new_nodes:\n				new_nodes[s[::-1]] = min(new_nodes[s[::-1]], nodes[node] + c[depth])\n			else:\n				new_nodes[s[::-1]] = nodes[node] + c[depth]\n\n	nodes = new_nodes\n	# print(depth,nodes)\n	depth += 1\n\n# print(nodes)\nif len(nodes) > 0:\n	print(min(nodes.values()))\nelse:\n	print(-1)
a = int(input())\nb = int(input())\nc = int(input())\nprint(max(a*b*c, a+b*c, a*b+c, a*(b+c), (a+b)*c, a+b+c))\n
# You lost the game.\nn, a, b = map(int, input().split())\ndem = n//2 + n%2\ni = 1\nwhile dem > 0 and i <= a:\n    dem -= b//2 + (i%2)*(b%2)\n    i += 1\nif dem > 0:\n    print(-1)\nelse:\n    dem = n//2 + n%2\n    demo = [2*k+1 for k in range(dem)]\n    rep = [2*k for k in range(1,n//2+1)]\n    d = 0\n    r = 0\n    l = 0\n    for i in range(a):\n        l = 1-l\n        e = l\n        for j in range(b):\n            if e and d < dem:\n                print(demo[d],end=" ")\n                d += 1\n            elif e == 0 and r < n//2:\n                print(rep[r],end=" ")\n                r += 1\n            else:\n                print(0,end=" ")\n            e = 1-e\n        print()\n    \n    
n,c = list(map(int, input().split()))\nP = list(map(int, input().split()))\nT = list(map(int, input().split()))\na = 0\nt = 0\nfor i in range(n):\n    t += T[i]\n    a += max(0,P[i]-c*t)\nt = 0\nb = 0\nfor i in range(n-1,-1,-1):\n    t += T[i]\n    b += max(0,P[i]-c*t)\nif a > b:\n    print("Limak")\nelif a < b:\n    print("Radewoosh")\nelse:\n    print("Tie")\n
t=int(input())\nfor i in range(t):\n    n,s,k=list(map(int,input().split()))\n    a=list(map(int,input().split()))\n    s=s-1\n    for i in range(n):\n        if (s-i)>-1:\n            if not (s-i+1) in a:\n                print(i)\n                break\n        if (s+i)<n:\n            if not (s+i+1) in a:\n                print(i)\n                break\n
n=int(input())\nr = [int(x) for x in input().split()]\ns = [int(x) for x in input().split()]\na=0\nb=0\nfor i in range(n):\n    if r[i]==1 and s[i]==0:\n        a+=1\n    if r[i]==0 and s[i]==1:\n        b+=1\nif a==0:\n    print(-1)\nelse:\n    print((b)//a+1)
from collections import Counter\n\ns = input()\nn = int(input())\n\nd = Counter()\n\nfor c in s:\n    d[c] += 1\n\nif len(d) > n:\n    print(-1)\nelse:\n    left = 0\n    right = 10**10\n    s = ""\n    lastok = ("", 0)\n    while left + 1 < right:\n        mid = (left + right) // 2\n        s = ""\n        for (c, cnt) in list(d.items()):\n            cntnow = (cnt - 1) // mid + 1\n            s += c * cntnow\n        if len(s) < n:\n            s += 'a' * (n - len(s))\n        if len(s) == n:\n            lastok = (s, mid)\n            right = mid\n        else:\n            left = mid\n    print(lastok[1])\n    print(lastok[0])\n
k = int(input())\ncodeforces = "codeforces"\nans = [1 for _ in range(len(codeforces))]\ni = 0\ntot = 1\nwhile tot < k:\n    tot //= ans[i]\n    ans[i] += 1\n    tot *= ans[i]\n    i += 1\n    i %= len(codeforces)\nfor i in range(len(codeforces)):\n    print(codeforces[i] * ans[i], end = "")\nprint()\n
def coloring(i, ancestors, color):\n    while i != 0 and color[ancestors[i - 1]] is None:\n        color[ancestors[i - 1]] = not color[i]\n        i = ancestors[i - 1]\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    ancestors = list([int(x) - 1 for x in input().split()])\n    descendants = [[] for i in range(n)]\n    for i in range(n - 1):\n        descendants[ancestors[i]].append(i + 1)\n    color = [None for i in range(n)]\n    for i in range(n):\n        if not descendants[i]:\n            color[i] = True\n            coloring(i, ancestors, color)\n    reds = 0\n    blues = 0\n    xor = 0\n    count_red = dict()\n    count_blue = dict()\n    for i in range(n):\n        if color[i]:\n            blues += 1\n            xor ^= a[i]\n            if str(a[i]) in count_blue:\n                count_blue[str(a[i])] += 1\n            else:\n                count_blue[str(a[i])] = 1\n        else:\n            reds += 1\n            if str(a[i]) in count_red:\n                count_red[str(a[i])] += 1\n            else:\n                count_red[str(a[i])] = 1\n    res = 0\n    if xor == 0:\n        res += (blues - 1) * blues // 2\n        res += (reds - 1) * reds // 2\n        for i in list(count_blue.items()):\n            if i[0] in count_red:\n                res += i[1] * count_red[i[0]]\n    else:\n        for i in list(count_blue.items()):\n            if str(xor ^ int(i[0])) in count_red:\n                res += i[1] * count_red[str(xor ^ int(i[0]))]\n    print(res)\n\n\nmain()\n\n
n, h, m = map(int, input().split())\na = [h] * n\nfor i in range(m):\n    l, r, x = map(int, input().split())\n    for i in range(l - 1, r):\n        a[i] = min(a[i], x)\ns = 0\nfor i in range(n):\n    s += a[i] ** 2\nprint(s)
from collections import defaultdict\nn, m = list(map(int, input().split()))\ndata = defaultdict(dict)\n\nfor _ in range(n):\n    name, region, score = input().split()\n    region = int(region)\n    score = int(score)\n    if region not in data:\n        data[region] = defaultdict(list)\n\n    data[region][score].append(name)\n\nfor r in range(1, m + 1):\n    scores = data[r]\n    score_list = list(scores)\n    score_list.sort()\n    best = score_list[-1]\n    if len(scores[best]) > 2:\n        print('?')\n    elif len(scores[best]) == 1:\n        second = score_list[-2]\n        if len(scores[second]) >= 2:\n            print('?')\n        else:\n            name1 = scores[best][0]\n            name2 = scores[second][0]\n            print(name1, name2)\n    else:\n        print(' '.join(scores[best]))\n
n, k = map(int, input().split())\ns = sorted(list(input()))\nprev = 0\nw = 0\nfor el in s:\n	if k == 0:\n		break\n	if ord(el) >= prev + 2:\n		k -= 1\n		w += ord(el) - ord('a') + 1\n		prev = ord(el)\nif k == 0:\n	print(w)\nelse:\n	print(-1)
L = lambda: list(map(int, input().split()))\nI = lambda: int(input())\n\nn, t = I(), [L() for i in range(4)]\np = [min(i[0], i[1]) + min(i[2], i[3]) for i in t]\nx = min(p)\nif x > n: print(-1)\nelse:\n    k = p.index(x)\n    p = min(t[k][0], t[k][1])\n    print(k + 1, p, n - p)
n, w = list(map(int, input().split()))\nCup = list(map(int, input().split()))\nWater = []\nfor a in Cup:\n    Water.append((a + 1) // 2)\nres = w - sum(Water)\nif res < 0:\n    print(-1)\nelse:\n    while res > 0:\n        i = Cup.index(max(Cup))\n        num = min(res, Cup[i] - Water[i])\n        Water[i] += num\n        res -= num\n        Cup[i] = 0\n    s = str(Water[0])\n    for c in range(1, len(Water)):\n        s += " " + str(Water[c])\n    print(s)\n        \n
n, s = list(map(int, input().split()))\na = list(map(int, input().split()))\n\ntotal = sum(a)\n\nans = []\nfor i in range(n):\n    high = s - (total - a[i])\n    low = s - (n - 1)\n    \n    cur = 0\n    if low <= a[i]:\n        cur += a[i] - low\n    if high > 0:\n        cur += high - 1\n\n    ans.append(cur)\n\nprint(' '.join(map(str, ans)))\n
n = int(input())\na = list(map(int, input().split()))\nfor i in range(n + 1):\n    for j in range(n):\n        if j % 2 == 0:\n            a[j] = (a[j] + 1) % n\n        else:\n            a[j] = (a[j] - 1) % n\n    for j in range(n):\n        if a[j] != j:\n            break\n    else:\n        print("Yes")\n        return\nprint("No")\n
import sys\nimport string\nfrom math import gcd\nimport getpass\nimport math\nfrom decimal import Decimal\nimport pprint\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n    # sys.stdin = open('input.txt')\n    # sys.stdout = open('output.txt', 'w')\nelse:\n    sys.stdin = open('input.txt')\n    # sys.stdin.close()\n# sys.stdout = open('output.txt', 'w')\n\n\nla, ra, ta = ria()\nlb, rb, tb = ria()\nif ta > tb:\n    la, ra, ta, lb, rb, tb = lb, rb, tb, la, ra, ta\n\ngc = gcd(tb, ta)\nif gc == 1:\n    print(min(ra - la + 1, rb - lb + 1))\n    return\n\n\ndef get(st):\n    nonlocal la, ra, ta, lb, rb, tb\n    lc = la + st\n    rc = ra + st\n    return max(min(rc, rb) - max(lc, lb) + 1, 0)\n\n\nsta = la // gc\nstb = lb // gc\nfna = ra // gc\nfnb = rb // gc\n\nmx = 0\n\nmx = max(mx, get((stb - sta) * gc))\nmx = max(mx, get((stb - sta + 1) * gc))\nmx = max(mx, get((stb - sta + 2) * gc))\nmx = max(mx, get((stb - sta - 1) * gc))\nmx = max(mx, get((stb - sta - 2) * gc))\n\nmx = max(mx, get((fnb - fna) * gc))\nmx = max(mx, get((fnb - fna + 1) * gc))\nmx = max(mx, get((fnb - fna + 2) * gc))\nmx = max(mx, get((fnb - fna - 1) * gc))\nmx = max(mx, get((fnb - fna - 2) * gc))\n\n#print(stb - sta)\nprint(mx)\n
# -*- coding: utf-8 -*-\n\nngoods = {\n    '0': 2,\n    '1': 7,\n    '2': 2,\n    '3': 3,\n    '4': 3,\n    '5': 4,\n    '6': 2,\n    '7': 5,\n    '8': 1,\n    '9': 2\n}\n\ndigits = input().strip()\nprint(ngoods[digits[0]] * ngoods[digits[1]])\n
n = int(input())\nmv = 0\nmn = []\ndata = {}\nfor i in range (n):\n  cur = list(sorted(map(int, input().split())))\n  key = (cur[1], cur[2])\n  if key in data:\n    old, k = data[key]\n    res = [old + cur[0], cur[1], cur[2]]\n    m = min(res)\n    if m > mv:\n      mv = m\n      mn = [k, i]\n    if old < cur[0]: \n      data[key] = (cur[0], i)\n  else:      \n    data[key] = (cur[0], i)\n    \n  m = cur[0]       \n  if m > mv:\n    mv = m\n    mn = [i]\n\nprint(len(mn))   \nprint(" ".join(map(lambda x: str(x+1), mn)))   
n,m=map(int,input().split())\na=list(map(int,input().split()))\ndp=[0]+[-1]*(9*n)\nl=[0,2,5,5,4,5,6,3,7,6]\nfor i in range(n):\n  for j in a:\n    if dp[i]>=0:\n      dp[i+l[j]]=max(dp[i+l[j]],dp[i]*10+j)\nprint(dp[n])
N,K=map(int,input().split())\nA=list(map(int,input().split()))\n\nl=0\nr=0\ns=A[0]\nans=0\nwhile True:\n\n    if s>=K:\n        ans+=N-r\n        s-=A[l]\n        l+=1\n\n    else:\n        if r<N-1:\n            r+=1\n            s+=A[r]\n        else:\n            break\n    \nprint(ans)
from sys import stdin\ndef main():\n    #入力\n    readline=stdin.readline\n    h,w=map(int,readline().split())\n    a=[list(map(int,readline().split())) for _ in range(h)]\n\n    i=0\n    j=0\n    n=0\n    ans=[]\n    while True:\n        if i%2==0:\n            if j<w-1:\n                if a[i][j]%2==1:\n                    n+=1\n                    ans.append([i+1,j+1,i+1,j+2])\n                    a[i][j+1]+=1\n                j+=1\n            elif j==w-1:\n                if i<h-1:\n                    if a[i][j]%2==1:\n                        n+=1\n                        ans.append([i+1,j+1,i+2,j+1])\n                        a[i+1][j]+=1\n                    i+=1\n                else:\n                    break\n        else:\n            if j>0:\n                if a[i][j]%2==1:\n                    n+=1\n                    ans.append([i+1,j+1,i+1,j])\n                    a[i][j-1]+=1\n                j-=1\n            elif j==0:\n                if i<h-1:\n                    if a[i][j]%2==1:\n                        n+=1\n                        ans.append([i+1,j+1,i+2,j+1])\n                        a[i+1][j]+=1\n                    i+=1\n                else:\n                    break\n\n    print(n)\n    for i in range(n):\n        print(*ans[i])\n\ndef __starting_point():\n    main()\n__starting_point()
mod = int(1e9) + 7 # <-- input modulo\nmaxf = 500000           # <-- input factional limitation\n\ndef make_fact(n, k):\n    tmp = n\n    perm = [i for i in range(k)]\n    L = [0 for _ in range(k)]\n    for i in range(k):\n        L[i] = tmp % (i + 1)\n        tmp //= i + 1\n    LL = [0 for _ in range(k)]\n    for i in range(k):\n        LL[i] = perm[L[-i-1]]\n        for j in range(L[-i-1]+1, k):\n            perm[j-1] = perm[j]\n    return LL\n\ndef doubling(n, m, modulo=mod):\n    y = 1\n    base = n\n    tmp = m\n    while tmp != 0:\n        if tmp % 2 == 1:\n            y *= base\n            if modulo > 0:\n                y %= modulo\n        base *= base\n        if modulo > 0:\n            base %= modulo\n        tmp //= 2\n    return y\n\ndef inved(a, modulo=mod):\n    x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\n    while l != 0:\n        x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n        k, l = l, k % l\n    return x % modulo\n\nfact = [1 for _ in range(maxf+1)]\ninvf = [1 for _ in range(maxf+1)]\n\nfor i in range(maxf):\n    fact[i+1] = (fact[i] * (i+1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(maxf, 0, -1):\n    invf[i-1] = (invf[i] * i) % mod\nn, k = map(int, input().split())\nS = 0\nif n <= k + 1:\n    print(fact[2*n-1]*invf[n]*invf[n-1]%mod)\nelse:\n    S = 0\n    for i in range(min(n, k+1)):\n        S += invf[i]*invf[i]*invf[n-i-1]*invf[n-i]%mod\n        S %= mod\n    print(S*fact[n-1]*fact[n]%mod)
n, m, x, y, z, p = list(map(int, input().split()))\nn, m, x, y, z = n + 1, m + 1, x % 4, y % 2, (4 - z) % 4\n\ndef a(i, j, n, m, k):\n    if k == 0: return i, j, n, m\n    if k == 1: return j, n - i, m, n\n    if k == 2: return n - i, m - j, n, m\n    return m - j, i, m, n\n\ndef b(i, j, m, k):\n    if k == 0: return i, j\n    if k == 1: return i, m - j\n\nfor i in range(p):\n    u, v = list(map(int, input().split()))\n    u, v, q, p = a(u, v, n, m, x)\n    u, v = b(u, v, p, y)\n    u, v, q, p = a(u, v, q, p, z)\n    print(u, v)\n\n
import sys\n\nm, n = map(int, input().split())\na = []\nfor _ in range(m):\n	a.append(list(map(int, input().split())))\nb = [[1]*n for _ in range(m)]\nfor i in range(m):\n	for j in range(n):\n		if(a[i][j] == 0):\n			b[i] = [0]*n\n			for k in range(m):\n				b[k][j] = 0\nfor i in range(m):\n	for j in range(n):\n		if(a[i][j] == 1):\n			good = False\n			if(1 in b[i]):\n				good = True\n			else:\n				for k in range(m):\n					if(b[k][j] == 1):\n						good = True\n			if not good:\n				print('NO')\n				return\nprint("YES")\nfor i in b:\n	print(' '.join([str(t) for t in i]))
s = input().strip()\nif len(s)<=2:\n    print(s)\n    return\nne = s[0]+s[1]\nfor i in range(2,len(s)):\n    if s[i]!=s[i-1] or s[i]!=s[i-2]:\n        ne+=s[i]\nne2 = ne[:3]\nfor i in range(3,len(ne),1):\n    if ne2[-3]==ne2[-2] and ne2[-1]==ne[i]:\n        pass\n    else:\n        ne2+=ne[i]\nprint(ne2)
c = input()\ns = list(input().split())\nprint('YES' if any(c[0] == x[0] or c[1] == x[1] for x in s) else 'NO')\n
a, b = list(map(int, input().split()))\nprint('Malvika' if min(a, b) % 2 == 0 else 'Akshat')\n
n = int(input())\na = [int(x) for x in input().split()]\nscore = dict()\nsup, winner = -2**31, None\nfor v in a:\n    score[v] = score[v] + 1 if v in score else 1\n    if score[v] > sup:\n        sup, winner = score[v], v\nprint(winner)\n
n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nmask = list(map(int, input().split()))\n\nresult = sum(a[i] if mask[i] == 1 else 0 for i in range(n))\n\nh = [a[i] if mask[i] == 0 else 0 for i in range(len(a))]\nbest_awake = sum(h[:k])\ncurr = best_awake\nfor j in range(k, n):\n    curr += h[j]\n    curr -= h[j - k]\n    best_awake = max(best_awake, curr)\nprint(result + best_awake)\n
a, b = list(map(int,input().split()))\nif a <= b:\n    l = 0\n    r = a + 1\n    while r - l > 1:\n        m = (l + r) // 2\n        if m * (m + 1) // 2 > a:\n            r = m\n        else:\n            l = m\n    n = l\n    a -= n*(n+1) // 2\n    c = 1\n    N = [i + 1 for i in range(n)]    \n    if a > 0:\n        c = n + 1 - a\n        N.pop(c - 1)\n        N.append(c + a)\n        N[-1] = c + a\n    D = []\n    if a != 0:\n        b -= c\n        D = [c]\n        n = n + 1\n    n += 1\n    while b >= 0:\n        b -= n\n        D.append(n)\n        n += 1\n    D.pop(-1)\n    print(len(N))\n    if len(N) != 0:\n        print(*N)\n    print(len(D))\n    if len(D) != 0:\n        print(*D)\nelse:\n    c = a\n    a = b\n    b = c\n    l = 0\n    r = a + 1\n    while r - l > 1:\n        m = (l + r) // 2\n        if m * (m + 1) // 2 > a:\n            r = m\n        else:\n            l = m\n    n = l\n    a -= n*(n+1) // 2\n    c = 1\n    N = [i + 1 for i in range(n)]    \n    if a > 0:\n        c = n + 1 - a\n        N.pop(c - 1)\n        N.append(c + a)\n        N[-1] = c + a\n    D = []\n    if a != 0:\n        b -= c\n        D = [c]\n        n = n + 1\n    n += 1\n    while b >= 0:\n        b -= n\n        D.append(n)\n        n += 1\n    D.pop(-1)\n    print(len(D))\n    if len(D) != 0:\n        print(*D)\n    print(len(N))\n    if len(N) != 0:\n        print(*N)\n\n
import sys;\n\nnbDancers, nbDances = list(map(int, sys.stdin.readline().split(' ')));\ndancers = [0]*(nbDancers+1);\n\nfor line in sys.stdin:\n	taken = [False, False, False, False];\n\n	ds = list(map(int, line.split(' ')));\n\n	for d in ds:\n		taken[dancers[d]] = True;\n\n	for d in ds:\n		if dancers[d] == 0:\n			if not taken[1]:\n				dancers[d] = 1;\n				taken[1] = True;\n			elif not taken[2]:\n				dancers[d] = 2;\n				taken[2] = True;\n			elif not taken[3]:\n				dancers[d] = 3;\n				taken[3] = True;\n\nprint((' '.join(map(str, dancers[1:]))));\n
a, b, c = sorted(map(int, input().split()))\nprint(max(0, c - a - b + 1))
b,k = map(int, input().split())\na = list(map(int, input().split()))\nr = 0\nfor x in a:\n	r = (r*b+x) % 2\nif r == 0:\n	print('even')\nelse:\n	print('odd')
input()\nl = list(map(int, input().split()))\nd = {}\nd2 = {}\nans = []\nn = 1\nfor i in l:\n    i = len(l) - i\n    if i not in d:\n        d[i] = n\n        n += 1\n    if i not in d2:\n        d2[i] = 0\n    if d2[i] >= i:\n        d[i] = n\n        d2[i] = 0\n        n += 1\n    ans.append(d[i])\n    d2[i] += 1\nnums = {}\ntot = 0\nfor i in ans:\n    tot += 1\n    if i not in nums:\n        nums[i] = 0\n    nums[i] += 1\nfor i in range(len(ans)):\n    if tot - nums[ans[i]] != l[i]:\n        print("Impossible")\n        return\nprint("Possible")\nprint(" ".join(map(str, ans)))\n\n
def main():\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    \n    cnt = 0\n    mi = 10 ** 9\n    for i in a:\n        if i % 2 == 1:\n            cnt ^= 1\n            mi = min(mi, i)\n    \n    if not cnt:\n        mi = 0\n    print(sum(a) - mi)\n    \n    \nmain()
import sys\nimport threading\nfrom collections import defaultdict\n\ndef put():\n    return map(int, input().split())\n\ndef dfs(i, p, m):\n    cnt = 1\n    z = 0\n    for j in tree[i]:\n        if j==p: continue\n        if cnt==m: cnt+=1\n        index = edge_index[(i,j)]\n        ans[cnt].append(index)\n        z = max(dfs(j,i,cnt), z)\n        cnt+=1\n    return max(z,cnt-1)\n\ndef solve():\n    l = dfs(1,0,0)\n    print(l)\n    for i in range(1, l+1):\n        print(len(ans[i]), *ans[i])\n    \n\nn = int(input())\nedge_index = defaultdict()\nans = [[] for i in range(n+1)]\ntree = [[] for i in range(n+1)]\nfor i in range(n-1):\n    x,y = put()\n    edge_index[(x,y)]=i+1\n    edge_index[(y,x)]=i+1\n    tree[x].append(y)\n    tree[y].append(x)\n\nmax_recur_size = 10**5*2 + 1000\nmax_stack_size = max_recur_size*500\nsys.setrecursionlimit(max_recur_size)\nthreading.stack_size(max_stack_size)\nthread = threading.Thread(target=solve)\nthread.start()
def Intersect(aa,bb,xx,yy):\n    a=min(aa,bb)\n    b=max(aa,bb)\n    x=min(xx,yy)\n    y=max(xx,yy)\n    \n    if(a>=x and b<=y):\n        return False\n    if(x>=a and y<=b):\n        return False\n    if(b<=x):\n        return False\n    if(y<=a):\n        return False\n    return True\n\nN=int(input())\n\ncase=False\n\nL=list(map(int,input().split()))\n\nfor i in range(N-1):\n    for j in range(i+1,N-1):\n        if(Intersect(L[i],L[i+1],L[j],L[j+1])):\n            case=True\nif(case):\n    print("yes")\n\nelse:\n    print("no")\n
\ninput()\nl = list(map(int, input().split()))\nif 1 in l:\n	print('HARD')\nelse:\n	print('EASY')\n
from math import sqrt\ndef solve():\n    n = int(input())\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            x = n // i\n            print(x, x * (i-1))\n            return \n    print(n-1,1)\nfor i in range(int(input())):\n    solve()
n, m = list(map(int, input().split()))\n\nfield = []\nfor i in range(n):\n    field.append(input())\n\nans = 0\nfor i in range(n - 1):\n    for j in range(m - 1):\n        t = set()\n        t.add(field[i][j])\n        t.add(field[i + 1][j + 1])\n        t.add(field[i + 1][j])\n        t.add(field[i][j + 1])\n\n        if t == set('face'):\n            ans += 1\nprint(ans)\n
a,b = input().split()\nif (a==b):\n    print(a)\nelse:\n    print(1)
import math, re, itertools as it;prime = lambda n: len([i for i in range(2, int(math.sqrt(n) + 1)) if n % i == 0]) == 0;gcd = lambda a, b: gcd(b, a % b) if b else a;fact = lambda x: x * fact(x - 1) if x else 1;bino = lambda n, k: fact(n) / fact(k) / fact(n - k);fib11 = lambda n: 1 if n < 2 else fib11(n - 1) + fib11(n - 2);fib01 = lambda n: 0 if n == 0 else 1 if n == 1 else fib01(n - 1) + fib01(n - 2);sumofd = lambda x: x if x < 10 else sumofd(x // 10) + x % 10\n\nn, m = map(int, input().split(' '))\na = []\ndp = []\nsc = st = sl = 1000000\nfor _ in range(n):\n	a.append(input())\n	c = t = l = 1000000\n	for i in range(len(a[-1])):\n		if a[-1][i] in '0123456789':\n			c = min(c, i, len(a[-1]) - i)\n		if a[-1][i] in '#*&':\n			t = min(t, i, len(a[-1]) - i)\n		if 'a' <= a[-1][i] <= 'z':\n			l = min(l, i, len(a[-1]) - i)\n	'''if c == t == 1000000 or c == l == 1000000 or l == t == 1000000:\n		if c == t == 1000000:\n			sl = 0\n		if c == l == 1000000:\n			st = 0\n		if l == t == 1000000:\n			sc = 0\n		continue'''\n	dp.append([c, t, l])\nmm = 1000000\nkk = it.permutations(list(range(n)), 3)\nfor i in kk:\n	mm = min(mm, dp[i[0]][0] + dp[i[1]][1] + dp[i[2]][2])\nprint(mm)
k = int(input())\nn = input()\ndigit = [0]*10\nfor c in n:\n    digit[int(c)]+= 1\ndsum = sum(i*digit[i] for i in range(10))\n\ni = 0\nchange = 0\nwhile dsum < k:\n    if digit[i] == 0:\n        i+= 1\n        continue\n    digit[i]-= 1\n    digit[9]+= 1\n    change+= 1\n    dsum+= 9-i\nprint(change)
# problem http://codeforces.com/contest/1100/problem/E\nimport copy\nimport sys\n\n\ndef find_loop(g, w, k, n):\n    visited = [False] * n\n    visited_int = [False] * n\n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [g[i][:]]\n        path = [i]\n        visited[i] = True\n        visited_int[i] = True\n        while stack:\n            if not stack[-1]:\n                stack.pop()\n                visited_int[path[-1]] = False\n                path.pop()\n                continue\n            nxt = stack[-1][-1]\n            stack[-1].pop()\n            if w[(path[-1], nxt)] <= k:\n                continue\n            if visited_int[nxt]:\n                return True\n            if visited[nxt]:\n                continue\n            visited[nxt] = True\n            visited_int[nxt] = True\n            stack.append(g[nxt][:])\n            path.append(nxt)\n    return False\n\n\ndef top_sort(g, w, k, n):\n    visited = [False] * n\n    order = [-1] * n\n    cnt = 0\n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [g[i][:]]\n        path = [i]\n        visited[i] = True\n        while stack:\n            if not stack[-1]:\n                order[path[-1]] = cnt\n                path.pop()\n                stack.pop()\n                cnt += 1\n                continue\n            nxt = stack[-1][-1]\n            stack[-1].pop()\n            if w[(path[-1], nxt)] <= k:\n                continue\n            if visited[nxt]:\n                continue\n            visited[nxt] = True\n            stack.append(g[nxt][:])\n            path.append(nxt)\n\n    to_reverse = []\n    for a, b in list(w.items()):\n        if b > k:\n            continue\n        if order[a[0]] < order[a[1]]:\n            to_reverse.append(a)\n    return to_reverse\n\n\ndef __starting_point():\n    n, m = list(map(int, input().split()))\n    w = {}\n    g = [[] for _ in range(n)]\n    w_tmp = {}\n    c_m = 0\n    kk = [0]\n    lines = sys.stdin.readlines()\n    for i, line in enumerate(lines): #range(1, m + 1):\n        u, v, c = list(map(int, line.split()))\n        g[u - 1].append(v - 1)\n        if (u - 1, v - 1) in list(w.keys()):\n            w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)\n        else:\n            w[(u - 1, v - 1)] = c\n        if (u - 1, v - 1) in list(w_tmp.keys()):\n            w_tmp[(u - 1, v - 1)].append(str(i + 1))\n        else:\n            w_tmp[(u - 1, v - 1)] = [str(i + 1)]\n        kk.append(c)\n        # c_m = max(c, c_m)\n\n    # print(find_loop(copy.deepcopy(g), copy.deepcopy(w), 0, n))\n\n    kk.sort()\n    l, r = 0, len(kk)\n    if not find_loop(g, w, kk[l], n):\n        print(0, 0)\n        return\n    if find_loop(g, w, kk[-1], n):\n        kkk = kk[-1]\n    else:\n        while l + 1 != r:\n            m = int((l + r) / 2)\n            # if find_loop(copy.deepcopy(g), copy.deepcopy(w), kk[m], n):\n            if find_loop(g, w, kk[m], n):\n                l = m\n            else:\n                r = m\n        kkk = kk[l+1]\n\n    to_reverse = top_sort(g, w, kkk, n)\n    num = 0\n    s = []\n    for t in to_reverse:\n        num += len(w_tmp[t])\n        s.extend(w_tmp[t])\n\n    print(kkk, num)\n    print(" ".join(s))\n\n\n\n\n\n\n__starting_point()
"""\nCodeforces Contest Good Bye 2014 Contest Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.4.2\n"""\n\n################################################### SOLUTION\n\ndef main():\n    n, = read()\n    p = read()\n    dsu = DSU()\n    for i in range(n):\n        a = read(0)\n        dsu.make()\n        for j in range(i):\n            if a[j] == "1":\n                dsu.union(j, i)\n    used = [0] * n\n    res = [0] * n\n    for i in range(n):\n        if not used[i]:\n            pr = dsu.find(i)\n            indices = []\n            elements = []\n            for j in range(n):\n                if dsu.find(j) == pr:\n                    used[j] = 1\n                    indices.append(j)\n                    elements.append(p[j])\n            elements.sort()\n            for i,e in zip(indices, elements):\n                res[i] = e\n    write(res)\n\n#################################################### HELPERS\n\nclass DSU(object):\n    """\n    Implements disjoint-set data structure as disjoint-set forest, with {0,1,...,n-1} as elements.\n\n    Methods:\n    make(): add a new element and returns its index\n    find(x): return representative of x\n    union(x, y): merge the sets containing x and y\n\n    Not to be used publicly:\n    _parent: a list of ints for the parent of each vertex, used internally; call find instead\n    _rank: a list of ints for the rank of trees, ensuring trees are binary and hence O(lg n) worst case\n    __init__(): called when initialization, initialize DSU to be empty\n    __str__(): return a readable string description of the DSU; meant to be printed while debugging\n    """\n\n    def __init__(self):\n        self._parent = []\n        self._rank = []\n\n    def make(self):\n        i = len(self._parent)\n        self._parent.append(i)\n        self._rank.append(0)\n        return i\n\n    def find(self, x):\n        if self._parent[x] != x:\n            self._parent[x] = self.find(self._parent[x])\n        return self._parent[x]\n\n    def union(self, x, y):\n        xr = self.find(x)\n        yr = self.find(y)\n        if xr == yr: return\n        if self._rank[xr] < self._rank[yr]:\n            self._parent[xr] = yr\n        elif self._rank[yr] < self._rank[xr]:\n            self._parent[yr] = xr\n        else:\n            self._parent[yr] = xr\n            self._rank[xr] += 1\n\n    def __str__(self):\n        s = "DSU\n"\n        for i in range(len(self._parent)):\n            s += str(i) + " in set " + str(self.find(i)) + " with rank " + str(self._rank[self.find(i)]) + "\n"\n        return s\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
s = input()\nres = set()\nfor i in range(len(s) + 5):\n    s = s[1:] + s[0]\n    res.add(s)\nprint(len(list(res)))
n = int(input())\n\ndef func(v):\n    res = 0\n    if "A" in v: res |= 1\n    if "B" in v: res |= 2\n    if "C" in v: res |= 4\n    return res\n\ncost = [10 ** 10] * 8\ncost[0] = 0\nfor _ in range(n):\n    c, v = input().split()\n    c = int(c)\n    v = func(v)\n    for i in range(8):\n        cost[i | v] = min(cost[i | v], cost[i] + c)\n\nprint(cost[7] if cost[7] < 10 ** 10 else -1)\n
m, k = [int(x) for x in input().split()]\n\nseen = 0\nusers = set()\nfriendsof = {}\nfor i in range(m):\n	a, b = [int(x) for x in input().split()]\n	users.add(a)\n	users.add(b)\n	if a in friendsof:\n		friendsof[a].add(b)\n	else:\n		friendsof[a] = set((b,))\n	if b in friendsof:\n		friendsof[b].add(a)\n	else:\n		friendsof[b] = set((a,))\n\nusers_sorted = list(users)\nusers_sorted.sort()\n\nfor u in users_sorted:\n	possible = []\n	this_friends = friendsof[u]\n	\n	for v in users_sorted:\n		if v in this_friends: continue\n		if v == u: continue\n		common = friendsof[v].intersection(this_friends)\n		\n		if len(common) * 100 >= k * len(this_friends):\n			possible.append(v)\n	\n	print('{}:'.format(u), len(possible), *possible)
string = input()\nnow = 0\nfor i in range(len(string)):\n    if now == 0 and string[i] == "h":\n        now += 1\n    if now == 1 and string[i] == "e":\n        now += 1\n    if now == 2 and string[i] == "i":\n        now += 1\n    if now == 3 and string[i] == "d":\n        now += 1\n    if now == 4 and string[i] == "i":\n        now += 1\nif now == 5:\n    print("YES")\nelse:\n    print("NO")\n    \n
def check(s, k):\n    ans = 0\n    for i in range(len(s)):\n        ans += abs(ord(s[i]) - ord(k[i]))\n    return ans\n\nn, k = list(map(int, input().split()))\ns = input()\ncnt = 0\nfor i in s:\n    cnt += max(ord('z') - ord(i), ord(i) - ord('a'))\nif k > cnt:\n    print(-1)\n    return\nelse:\n    ans = ''\n    cr = 0\n    while k != 0:\n        ps1 = ord(s[cr]) - ord('a')\n        ps2 = ord('z') - ord(s[cr])\n        if ps1 > k:\n            ans += chr(ord(s[cr]) - k)\n            k = 0\n        elif ps2 > k:\n            ans += chr(ord(s[cr]) + k)\n            k = 0            \n        else:\n            if ps2 >= ps1:\n                ans += 'z'\n                k -= ps2\n            else:\n                ans += 'a'\n                k -= ps1\n        cr += 1\nans += s[len(ans):]\nprint(ans)\n#print(check(ans, s))\n
\na,b,mod = list(map(int, input().split()))\n\ng = [2] * a\nfor i in range(b):\n    t = input()\n    for x, y in  enumerate(t):\n        if y == '1':\n            g[x] -= 1\n\none = two = 0\nfor q in g:\n    if q < 0:\n        print(0)\n        return\n\n    if q == 1:\n        one+=1\n    if q == 2:\n        two+=1\n\n\n\nmat = [[0]*600 for x in range(600)]  \nmat[0][0] = 1\n#int(one, two)\nfor j in range(a + 1):\n    for i in range(a + 1):\n        if i-2>=0:\n            mat[i][j] += i*(i-1) // 2 * mat[i-2][j];\n            #print('in',i,j, mat[i][j], i*(i-1)//2, mat[i-2][j], i-2, mat[0][0])\n        if j-1>=0:\n            mat[i][j] += i*j * mat[i][j -1];\n        if j-2>=0 :\n            mat[i][j] += j *(j-1)//2 * mat[i+2][j -2];\n        mat[i][j] %= mod\n\n#print(mat[2][0])\n#print(mat[0][2])\nprint(mat[one][two])\n
n, k = list(map(int, input().split()))\nresult = 10 ** 26\nfor i in range(1, k):\n    if n % i == 0:\n        t = n // i\n        result = min(result, t * k + i)\nprint(result)\n
def dp():\n	dparr = [0] * len(sections)\n	for i in range(len(sections) - 1, -1, -1):\n		_, curend, curcomfort = sections[i]\n		nextsection = i + 1\n		try:\n			while sections[nextsection][0] <= curend:\n				nextsection += 1\n		except IndexError:\n			# Loop til end\n			inc = curcomfort\n		else:\n			inc = curcomfort + dparr[nextsection]\n		exc = 0 if i == len(sections) - 1 else dparr[i + 1]\n		dparr[i] = max(inc, exc)\n	return dparr[0]\n\n\nn = int(input())\nzs = list(map(int, input().split()))\nsections = []\nseenstartz = set()\nfirst = {z: i for i, z in reversed(list(enumerate(zs)))}\nlast = {z: i for i, z in enumerate(zs)}\nfor start, z in enumerate(zs):\n	if z in seenstartz:\n		continue\n	seenstartz.add(z)\n	end = last[z]\n	comfort = 0\n	i = start\n	while i <= end:\n		if first[zs[i]] < start:\n			break\n		if i == last[zs[i]]:\n			comfort ^= zs[i]\n		end = max(end, last[zs[i]])\n		i += 1\n	else:\n		sections.append((start, end, comfort))\n\nans = dp()\nprint(ans)\n
from collections import deque\n\nclass Graph(): #directed\n    def __init__(self, n, edge, indexed=1):\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n        for e in edge:\n            self.graph[e[0] - indexed].append(e[1] - indexed)\n\nINF = 10**18\n\nN, M = map(int, input().split())\nedge = [tuple(map(int, input().split())) for _ in range(M)]\n\ng = Graph(N, edge)\n\nloopsize = INF\n\nfor i in range(N):\n    root = i\n    queue = deque([root])\n    dist = [INF for _ in range(N)]\n    dist[root] = 0\n    prev = [None for _ in range(N)]\n    while queue:\n        node = queue.popleft()\n        for adj in g.graph[node]:\n            if adj == root: #閉路を検出する\n                dist[root] = dist[node] + 1\n                prev[root] = node\n                break\n            if dist[adj] != INF:\n                continue\n            dist[adj] = dist[node] + 1\n            prev[adj] = node\n            queue.append(adj)\n        else:\n            continue\n        break\n    else:\n        continue\n    #最小の閉路なら条件を満たす\n    if loopsize > dist[root]:\n        loopsize = dist[root]\n        path = [root]\n        node = root\n        while prev[node] != root:\n            node = prev[node]\n            path.append(node)\n\nif loopsize != INF:\n    print(loopsize)\n    for node in path:\n        print(node + 1)\nelse:\n    print(-1)
n, k = map(int, input().split())\nl = [(0, 0) for i in range(k)]\nfor i in range(k):\n    start, end = map(int, input().split())\n    l[i] = start, end\n\ndp = [0 for i in range(n+1)]\nprefixSum = [0 for i in range(n+1)]\n\ndp[1] = 1\nprefixSum[1] = 1\n\nfor i in range(2, n + 1):\n    for j in range(k):\n        start, end = l[j]\n        i_s = max(i - start, 0)\n        i_e = max(i - end -1, 0)    \n        dp[i] += prefixSum[i_s] - prefixSum[i_e]\n        dp[i] %= 998244353\n    prefixSum[i] = prefixSum[i-1] + dp[i]\n    prefixSum[i] %= 998244353\n\nprint(dp[n])
import sys\n\n\ndef get_sol(a, b, c, n, reverse):\n	#1\n	if reverse[0]:\n		a = (a[1], a[0], a[2])\n	if reverse[1]:\n		b = (b[1], b[0], b[2])\n	if reverse[2]:\n		c = (c[1], c[0], c[2])\n\n\n	ans = []\n	if a[0] == b[0] == c[0] == n:\n		if a[1] + b[1] + c[1] == n:\n			for i in range(a[1]):\n				ans.append(a[2]*n)\n			for i in range(b[1]):\n				ans.append(b[2]*n)\n			for i in range(c[1]):\n				ans.append(c[2]*n)\n			return True, ans\n	if a[0] + c[0] == b[0] + c[0] == n and c[1] == n == a[1] + b[1]:\n		for i in range(a[1]):\n			ans.append(a[2]*a[0] + c[2] * c[0])\n		for i in range(b[1]):\n			ans.append(b[2]*b[0] + c[2] * c[0])\n		return True, ans\n	return False, ans\n\ndef printans(ans, n):\n	print(n)\n	for line in ans:\n		print(line)\n	return\n\n#sys.stdin = open('input.txt')\n#sys.stdout = open('output.txt', 'w')\n\nx1, y1, x2, y2, x3, y3 = [int(i) for i in input().split()]\ntotal_area = x1*y1 + x2*y2 + x3*y3\nn = 0\nwhile n ** 2 < total_area:\n	n += 1\nif n ** 2 != total_area:\n	print(-1)\nelse:\n	first = (x1, y1, 'A')\n	second = (x2, y2, 'B')\n	third = (x3, y3, 'C')\n	pereb = (	(first, second, third),\n				(first, third, second),\n				(second, first, third),\n				(second, third, first),\n				(third, first, second),\n				(third, second, first))\n	for rev1 in (False, True):\n		for rev2 in (False, True):\n			for rev3 in (False, True):\n				for per in pereb:\n					reverse = (rev1, rev2, rev3)\n					is_ans, ans = get_sol(per[0], per[1], per[2], n, reverse)\n					if is_ans: printans(ans, n)\n	\n	\n	print(-1)\n
n=int(input())\na=input()\ncnt=0\nA=0\nfor i in range(0,n):\n  if(a[i]=='I'): cnt+=1\n  if(a[i]=='A'): A+=1\nif(cnt==0):\n    print(A)\nelif(cnt==1):\n    print(1)\nelse :print(0)\n
def find(ins):\n	ins += 1\n	\n	test = [int(i) for i in str(ins)]\n	\n	inlist = []\n	\n	for i in test:\n		if i in inlist:\n			\n			test = find(ins)\n			break\n			\n		else:\n			inlist.append(i)\n	\n	return ''.join(str(x) for x in test)\n	\nins = int(input())\nprint(find(ins))
n, ar = int(input()), [int(x) for x in input().split()][::-1]\nans = 0\nfor i in range(1, n):\n  if ar[i] > ar[i - 1]: \n    ans = n - i\n    break\n\nprint(ans)\n\n
"""\nCodeforces Contest 270 Problem C\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef main():\n    n, = read()\n    names = []\n    for i in range(n): names.extend([(x,i+1) for x in read(1)])\n    names.sort()\n    p = read()\n    i = 0\n    j = 0\n    while i < n and j < 2*n:\n        if names[j][1] == p[i]:\n            i += 1\n        j += 1\n    if i == n:\n        print("YES")\n    else:\n        print("NO")\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
def solve(s,t):\n    hash_s = [False] * 256\n    hash_t = [False] * 256\n    arr = []\n    n = len(s)\n    for c in s:\n        hash_s[ord(c)] = True\n    for c in t:\n        hash_t[ord(c)] = True\n    for i in range(256):\n        if not hash_s[i] and hash_t[i]:\n            print(-1)\n            return\n    rev = s[::-1]\n    i,j = 0,0\n    while i < len(t):\n        flag = True\n        temp = t[i]\n        j = i + 1\n        while j < len(t):\n            temp += t[j]\n            if temp not in s and temp not in rev:\n                flag = False\n                break\n            j += 1\n        if flag:\n            x = s.find(temp)\n            if x != -1:\n                arr.append((x + 1,x + len(temp)))\n                # print('1',x + 1,x + len(temp))\n            else:\n                y = rev.find(temp)\n                arr.append((n - y,n - y - len(temp) + 1))\n                # print('2',n - y,n - y - len(temp) + 1)\n        else:\n            x = s.find(temp[:-1])\n            if x != -1:\n                arr.append((x + 1,x + len(temp) - 1))\n                # print('3',x + 1,x + len(temp) - 1)\n            else:\n                x = rev.find(temp[:-1])\n                arr.append((n - x,n - x - len(temp) + 2))\n                # print('4',n - x,n - x - len(temp) + 2)\n        i = j\n    print(len(arr))\n    for x,y in arr:\n        print(x,y)\n\ns = input()\nt = input()\n\nsolve(s,t)\n
def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn = ii()\na = li()\na.sort()\nc1 = 0\np = 1\nfor ai in a:\n    c1 += abs(ai - p)\n    p += 2\nc2 = 0\np = 2\nfor ai in a:\n    c2 += abs(ai - p)\n    p += 2\nans = min(c1, c2)\nprint(ans)
# You lost the game.\nn,b,d = list(map(int, input().split()))\nL = list(map(int, input().split()))\nr = 0\nc = 0\nfor i in range(n):\n    if L[i] <= b:\n        c += L[i]\n        if c > d:\n            r += 1\n            c = 0\nprint(r)\n
def f():\n    n, m = map(int, input().split())\n    t = [input() for j in range(n)]\n\n    p = [''.join(i) for i in zip(*t)]\n    if h(p): return 1\n\n    i = 0\n    while i < n and not 'B' in t[i]: i += 1\n\n    while i < n:\n        a = t[i].find('B')\n        if a < 0:\n            i += 1\n            break\n        b = t[i].rfind('B')\n        if 'W' in t[i][a: b + 1]: return 1\n\n        for j in range(i + 1, n):\n            if a > 0 and t[j][a - 1] == 'B' and t[j][b] == 'W': return 1\n            if b < m - 1 and t[j][b + 1] == 'B' and t[j][a] == 'W': return 1\n        i += 1\n\n    while i < n:\n        if 'B' in t[i]: return 1\n        i += 1    \n\n    return 0  \n            \ndef h(t):\n    i, n = 0, len(t)\n    while i < n and not 'B' in t[i]: i += 1\n\n    while i < n:\n        a = t[i].find('B')\n        if a < 0:\n            i += 1\n            break\n        b = t[i].rfind('B')\n        if 'W' in t[i][a: b + 1]: return 1\n        i += 1\n\n    while i < n:\n        if 'B' in t[i]: return 1\n        i += 1    \n\n    return 0          \n    \nprint('YNEOS'[f():: 2])
r, c = list(map(int, input().split()))\nls = [[c for c in input()] for i in range(r)]\nfor i in range(r):\n    dead = False\n    for j in range(c):\n        if ls[i][j] == 'W':\n            if i != 0 and ls[i - 1][j] == 'S': dead = True\n            if i != r - 1 and ls[i + 1][j] == 'S': dead = True\n            if j != 0 and ls[i][j - 1] == 'S': dead = True\n            if j != c - 1 and ls[i][j + 1] == 'S': dead = True\n            if dead: \n                break\n        elif ls[i][j] == '.':\n            ls[i][j] = 'D'\n    if dead:\n        print("No")\n        break\nelse:\n    print("Yes")\n    for i in range(r):\n        print(''.join(ls[i]))\n\n
import sys\n\ndef main():\n    n = int(input())\n    n = n*2\n    u = 0\n    res = 0\n    x = []\n    for i in range(n):\n        s = sys.stdin.readline()\n        if s[0] == 'r':\n            u+=1\n            if len(x)==0:\n                continue\n            if x[-1] == u:\n                x.pop()\n            else:\n                x = []\n                res +=1\n        else:\n            a,b = s.split()\n            x.append(int(b))\n    print(res)\n\n\nmain()
n = int(input())\na = list(input())\nb = list(input())\na = [int(i) for i in a]\nb = [int(i) for i in b]\na.sort()\nb.sort()\nc = a[::]\nd = b[::]\nans1 = 0\nans2 = 0\nfor i in a:\n    for j in range(len(b)):\n        if b[j] > i:\n            del b[j]\n            ans2 += 1\n            break\nfor i in c:\n    for j in range(len(d)):\n        if d[j] >= i:\n            del d[j]\n            break\n    else:\n        ans1 += 1\n\nprint(ans1)\nprint(ans2)
n, x = list(map(int, input().split()))\nresult = 0\ncur = 1\nfor i in range(n):\n    l, r = list(map(int, input().split()))\n    result += r - l + 1\n    result += (l - cur) % x\n    cur = r + 1\nprint(result)\n
import sys\nfrom bisect import bisect_right as br\ninput = sys.stdin.readline\nn, p = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\ntable = [0] * (10 ** 5 + 1)\nfor x in range(10 ** 5 + 1):\n  r = br(a, x)\n  table[x] = r\nres = []\n#print(table[: 100])\nfor x in range(1, 2001):\n  t = 1\n  q = x + 0\n  for i in range(n):\n    t *= max(0, table[q] - i)\n    t %= p\n    q += 1\n  if t % p: res.append(x)\nprint(len(res))\nprint(*res)
k=int(input())\n\nL={}\ns=".123456789"\nfor item in s:\n    L[item]=0\nfor i in range(4):\n    s=input()\n    for item in s:\n        L[item]+=1\n\ns="123456789"\ndone=True\nfor item in s:\n    if(L[item]>2*k):\n        print("NO")\n        done=False\n        break\nif(done):\n    print("YES")\n
from sys import stdin\ninput = stdin.readline\nn,m = map(int,input().split())\nl = list(map(int,input().split()))\nif n > m:\n	print(0)\nelse:\n	res = 1\n	for i in range(n-1):\n		for j in range(i+1,n):\n			res = ((res*abs(l[i]-l[j])) % m)\n	print(res%m)
read=lambda:list(map(int,input().split()))\nfrom collections import Counter as co\nk,n=read()\ns=input()\nrepeated=(len(s)!=len(set(s)))\netalon=co(s)\na=[]\nkk=[]\nap=a.append\n\nfor i in range(k-1):\n    ap(input())\n    if co(a[-1])!=etalon:\n        print(-1)\n        return\n\nss=False\nfor i in a:\n    if i!=s:\n        ss=i\n        for j in range(len(s)):\n            if s[j]!=ss[j]:\n                kk.append(j)\n        break\n\nif len(kk)>4:\n    print(-1)\n    return\n\nif ss:\n    if repeated:\n        for i in a:\n            k = 0\n            for j in range(len(i)):\n                if s[j] != i[j]: k += 1\n            if k != 0 and k != 2: break\n        else:\n            print(s)\n            return\n\n    if len(kk)!=2:\n        for i in range(len(kk)):\n            for j in range(i):\n                stry=s[:kk[j]]+s[kk[i]]+s[kk[j]+1:kk[i]]+s[kk[j]]+s[kk[i]+1:]\n                #print(stry)\n                for u in a:\n                    k = 0\n                    for j in range(len(u)):\n                        if stry[j] != u[j]: k += 1\n                    #print(stry,i,k)\n                    if not(k==0 and repeated) and k != 2: break\n                else:\n                    print(stry)\n                    return\n\n    if len(kk)==2:\n        for change in kk:\n            for i in range(len(s)):\n                if change==i:\n                    continue\n\n                if i >change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n\n                for u in a:\n                    k = 0\n                    for j in range(len(u)):\n                        if stry[j] != u[j]: k += 1\n                    #print(stry,i,k)\n                    if not(k==0 and repeated) and k != 2: break\n                else:\n                    print(stry)\n                    return\n    print(-1)\n\nelse:\n    if repeated:\n        print(s)\n        return\n    print(s[1]+s[0]+s[2:])\n
#!/usr/local/bin/python3.3 -tt\n\nimport sys\n\ndef __starting_point():\n    def _(f):\n        for l in f:\n            for i in l.split():\n                yield int(i)\n\n    g = _(sys.stdin)\n\n    v = next(g)\n\n    ar = []\n    for i in range(9):\n        ar.append((next(g), i + 1))\n\n    dominant = min(ar, key=lambda t: (t[0], -t[1]))\n    \n    digits = v // dominant[0]\n\n    v -= dominant[0] * digits\n\n    ar = [(a - dominant[0], n) for a, n in ar if a > dominant[0] and n > dominant[1]]\n    \n    ar.sort(key=lambda x: (-x[1], x[0]))\n\n    print(ar, file=sys.stderr)\n    \n    s = ''\n\n    for a, n in ar:\n        if a <= v:\n            q = v // a\n            v -= q * a\n            s += str(n) * q\n\n    s = '%s%s' % (s, str(dominant[1]) * (digits - len(s)))\n    \n    if s:\n        print(s)\n    else:\n        print(-1)\n\n__starting_point()
import sys\n\ndef main():\n    #n = int(sys.stdin.readline().strip())\n    n, m = map(int, sys.stdin.readline().split())\n    #q = list(map(int, sys.stdin.readline().split()))\n    if n * 2 > m:\n        print("YES")\n    else:\n        print("NO")\n    \n   \n        \n        \n            \n        \n                \n            \n            \n        \n            \n    \n    \n    \n    \n    \n    \n            \n                \n        \n    \n            \n        \n\n            \n        \n    \n                \n    \n    \n    \n            \n    \n        \n    \n\nfor i in range(int(sys.stdin.readline().strip())):\n    main()
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\nn,p,q,r=map(int,input().split())\n\na=list(map(int,input().split()))\n\ns1=[a[i]*p for i in range(n)]\n\ns2=[]\nm=s1[0]\nfor i in range(n):\n    m=max(m,s1[i])\n    s2.append(m+a[i]*q)\n\ns3=[]\nm=s2[0]\nfor i in range(n):\n    m=max(m,s2[i])\n    s3.append(m+a[i]*r)\n\nprint(max(s3))
from collections import deque\n\nnodes = []\nparents = []\nvalues = []\nbroken = []\nupperBound = []\nlowerBound = []\n\nn = int(input())\n\nfor _ in range(n):\n    v, l, r = map(int, input().split())\n    nodes.append((v, l - 1, r - 1))\n    parents.append(-1)\n    values.append(v)\n    broken.append(False)\n    upperBound.append(10 ** 9)\n    lowerBound.append(-10 ** 9)\n\nfor i, (v, l, r) in enumerate(nodes):\n    if l > -1:\n        parents[l] = i\n    if r > -1:\n        parents[r] = i\n\nroot = -1\nfor i in range(n):\n    if parents[i] == -1:\n        root = i\n\nproc = deque([root])\nwhile len(proc) > 0:\n    node = proc.popleft()\n    v, l, r = nodes[node]\n    if l > -1:\n        proc.append(l)\n        upperBound[l] = min(upperBound[node], v)\n        lowerBound[l] = lowerBound[node]\n        if not (lowerBound[l] <= nodes[l][0] <= upperBound[l]):\n            broken[l] = True\n    if r > -1:\n        proc.append(r)\n        upperBound[r] = upperBound[node]\n        lowerBound[r] = max(lowerBound[node], v)\n        if not (lowerBound[r] <= nodes[r][0] <= upperBound[r]):\n            broken[r] = True\n        \ns = set([])\nfor v, b in zip(values, broken):\n    if not b:\n        s.add(v)\n\nans = 0\nfor v in values:\n    if v not in s:\n        ans += 1\n\nprint(ans)
a=[0]*2222\nb=[0]*2222\nr=0\nfor _ in range(int(input())):\n	x,y=map(int,input().split())\n	r+=a[x+y]+b[x-y+1111]\n	a[x+y]+=1\n	b[x-y+1111]+=1\nprint(r)
n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nlibrary = []\nmoney = 0\nfor i in range(len(a)):\n    if a[i] not in library:\n        money += 1\n        if len(library) < k:\n            library.append(a[i])\n        else:\n            curmin = n\n            curindex = 0\n            found = [n] * len(library)\n            for j in range(len(a[i+1::])):\n                if (a[i+j+1] in library) and (found[library.index(a[i+j+1])]==n):\n                    found[library.index(a[i+j+1])] = j\n            library[found.index(max(found))] = a[i]\nprint(money)\n
from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\nN, M = list(map(int, input().split()))\n\n\nparent = [i for i in range(N)]\nrank = [0] * N\n\n\ndef find(i):\n    if parent[i] == i:\n        return i\n    else:\n        parent[i] = find(parent[i])\n        return parent[i]\n\n\ndef same(x, y):\n    return find(x) == find(y)\n\n\ndef unite(x, y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return\n\n    if rank[x] > rank[y]:\n        parent[y] = x\n    else:\n        parent[x] = y\n        if rank[x] == rank[y]:\n            rank[y] += 1\n\n\nP = list(map(int, input().split()))\nfor i in range(M):\n    a, b = list(map(int, input().split()))\n    a, b = a - 1, b - 1\n    unite(a, b)\n\n\nd = defaultdict(list)\ncnt = defaultdict(int)\nfor i in range(N):\n    d[find(i)].append(P[i])\n\nfor i in range(N):\n    if find(i) == i:\n        d[i] = sorted(d[i], reverse=True)\n\nans = []\nfor i in range(N):\n    k = find(i)\n    ans.append(d[k][cnt[k]])\n    cnt[k] += 1\n\nprint(' '.join(map(str, ans)))\n
import sys\n\nfin = sys.stdin\nfout = sys.stdout\n\na = [0] * 6\nfor i in range(6):\n    a[i] = [0] * 6\nfor i in range(2):\n    a[i][0] = 3\n    a[i][1] = 3\n    a[i][2] = 4\n    a[i][3] = 4\n    a[i][4] = 3\n    a[i][5] = 3\nfor i in range(2, 4):\n    a[i][0] = 2\n    a[i][1] = 2\n    a[i][2] = 3\n    a[i][3] = 3\n    a[i][4] = 2\n    a[i][5] = 2\nfor i in range(4, 6):\n    a[i][0] = 1\n    a[i][1] = 1\n    a[i][2] = 2\n    a[i][3] = 2\n    a[i][4] = 1\n    a[i][5] = 1\n\nansI = -1\nansJ = -1\n\nmax = -1\n\nansL = []\n\nfor i in range(6):\n    s = fin.readline().strip()\n    ansL.append(s)\n    s = s.replace("-", "")\n    for j in range(6):\n        if s[j] == '.' and a[i][j] > max:\n            max = a[i][j]\n            ansI = i\n            ansJ = j\n\n# print(ansI, ansJ)\nfor i in range(len(ansL)):\n    cur = ansL[i]\n    realJ = -1\n    for j in range(len(cur)):\n        if (cur[j] != '-'):\n            realJ += 1\n        if i == ansI and realJ == ansJ and cur[j] != '-':\n            fout.write('P')\n        else:\n            fout.write(cur[j])\n\n    fout.write("\n")\nfin.close()\nfout.close()\n
n, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncnt = {}\nfor elem in a:\n    if elem in cnt:\n        cnt[elem] += 1\n    else:\n        cnt[elem] = 1\ncnt = sorted(list(cnt.items()))\nfor i in range(len(cnt)):\n    cnt[i] = list(cnt[i])\nleft = 0\nright = len(cnt) - 1\nwhile k > 0:\n    if k < cnt[left][1] and k < cnt[right][1]:\n        break\n    if left == right:\n        break\n    if cnt[left][1] <= cnt[right][1]:\n        if k >= cnt[left][1] * (cnt[left + 1][0] - cnt[left][0]):\n            k -= cnt[left][1] * (cnt[left + 1][0] - cnt[left][0])\n            cnt[left + 1][1] += cnt[left][1]\n            left += 1\n        else:\n            cnt[left][0] += k // cnt[left][1]\n            k = 0\n    else:\n        if k >= cnt[right][1] * (cnt[right][0] - cnt[right - 1][0]):\n            k -= cnt[right][1] * (cnt[right][0] - cnt[right - 1][0])\n            cnt[right - 1][1] += cnt[right][1]\n            right -= 1\n        else:\n            cnt[right][0] -= k // cnt[right][1]\n            k = 0\nprint(cnt[right][0] - cnt[left][0])
from collections import defaultdict\n\n\ndef dfs(s, t):\n    visited = 0\n    q = [(s, 0)]\n    while q:\n        v, used = q.pop()\n        if v == t:\n            return used\n        visited |= used\n        for lb, u in graph[v]:\n            if lb & visited:\n                continue\n            q.append((u, used | lb))\n\n\nn = int(input())\ngraph = [[] for _ in range(n + 1)]\nfor i in range(n - 1):\n    a, b = list(map(int, input().split()))\n    lb = 1 << i\n    graph[a].append((lb, b))\n    graph[b].append((lb, a))\n\nconditions = []\nm = int(input())\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    conditions.append(dfs(u, v))\n\nlink_conditions = [int(''.join(b), 2) for b in zip(*list(map(('{:0' + str(n - 1) + 'b}').format, conditions)))]\n\ndp = defaultdict(int)\ndp[0] = 1\nfor lc in link_conditions:\n    for fulfilled, pattern in list(dp.items()):\n        dp[fulfilled | lc] += pattern\nprint((dp[(1 << m) - 1]))\n
import heapq\n\ncity_num, road_num, init_silver = map(int, input().split())\nMAX_COST = 2500\ninit_silver  = min(MAX_COST, init_silver)\n\nG = [[] for _ in range(city_num)]\nfor _ in range(road_num):\n    A, B, cost, time_cost = map(int, input().split())\n    A, B = A-1, B-1\n    G[B].append([A, cost, time_cost])\n    G[A].append([B, cost, time_cost])\n\nfor n in range(city_num):\n    cost, time_cost = map(int, input().split())\n    G[n].append([n, -cost, time_cost])\n\ndp = [[float("inf")] * (MAX_COST+1) for _ in range(city_num)]\ndp[0][init_silver] = 0\nhq = [(0, 0, init_silver)]\nwhile hq:\n    time, node, silver = heapq.heappop(hq)\n    for to, silver_cost, time_cost in G[node]:\n        remain = min(silver - silver_cost, MAX_COST)\n        if remain < 0:\n            continue\n        dp_next_value = time + time_cost\n        if dp[to][remain] <= dp_next_value:\n            continue\n        dp[to][remain] = dp_next_value\n        heapq.heappush(hq, (dp_next_value, to, remain))\nprint(*[min(d) for d in dp[1:]], sep="\n")
import numpy as np\nn,s=map(int,input().split())\na=list(map(int,input().split()))\nmod=998244353\ndp=np.zeros([n+1,s+1],int)\ndp[0][0]=1\nfor i in range(1,n+1):\n  dp[i][:]=dp[i-1][:]*2\n  dp[i][a[i-1]:]+=dp[i-1][:-a[i-1]]\n  dp[i][:]%=mod\nprint(dp[n][s])
#!/usr/bin/env python3\n\nimport numpy as np\nfrom scipy.special import comb\n\nn, m = list(map(int, input().split()))\na = list(map(int, input().split()))\n\na_sum = np.cumsum(a)\n\n\nre_list = {}\nre_list[0] = 1\nfor i in a_sum:\n    re = i % m\n    if re in re_list:\n        re_list[re] += 1\n    else:\n        re_list[re] = 1\n\n# print(re_list)\nans = 0\nfor value in list(re_list.values()):\n    ans += comb(value, 2, exact=True)\n\nprint(ans)\n
3\n\nimport sys\n\n(n, m) = list(map(int, input().split()))\n\nfirstData = None \n\nmaxHeight = -1\n\nfor i in range(m):\n    (d, h) = list(map(int, input().split()))\n\n    if firstData is None:\n        firstData = (d, h)\n    else:\n        if (d - prevD) < abs(h - prevH):\n            print ("IMPOSSIBLE")\n            return\n        maxH = max(h, prevH)\n        minH = min(h, prevH)\n        resource = d - prevD - (maxH - minH) # "free" days for going up-down\n        possibleH = maxH + resource // 2\n        maxHeight = max(maxHeight, possibleH)\n\n    (prevD, prevH) = (d, h)\n    lastData = (d, h)\n\nmaxHeight = max(maxHeight, firstData[1] + firstData[0] - 1)\nmaxHeight = max(maxHeight, lastData[1] + (n - lastData[0]))\n\nprint (maxHeight)\n
#!/usr/bin/env python3\n\nfrom math import sqrt\n\nprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\n			101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193,\n			197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307,\n			311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421,\n			431, 433, 439, 443, 449, 457, 461, 463] \n\npsq = [p*p for p in primes]\n\n\ndef sqfree(x):\n	if x == 0:\n		return x\n	y = 1\n	for p, pp in zip(primes, psq):\n		while x % pp == 0:\n			x //= pp\n		if x % p == 0:\n			x //= p\n			y *= p\n		if abs(x) < p:\n			break\n	if int(sqrt(abs(x)))**2 == abs(x):\n		return (y if x > 0 else -y)\n	else:\n		return x * y\n\nn = int(input().strip())\nais = list(map(int, input().strip().split()))\nbis = list(map(sqfree, ais))\n\n\nprev = [-1 for i in range(n)]\nlast = {}\n\n\nfor i, b in enumerate(bis):\n	if b in last:\n		prev[i] = last[b]\n	last[b] = i\n	\nres = [0 for i in range(n)]	\nfor l in range(n):\n	cnt = 0\n	for r in range(l, n):\n		if bis[r] != 0 and prev[r] < l:\n			cnt += 1\n		res[max(cnt - 1, 0)] += 1\n\n\nprint(' '.join(map(str, res)))\n
def main():\n    s = input().split()\n    n, m, k = int(s[0]), int(s[1]), int(s[2])\n    processor = []\n    for x in range(n):\n        for y in range(m):\n            s = input()\n            for z in s:\n                processor.append(int(z) == 1)\n        if x < n - 1:\n            emptyLine = input()\n    counter = 0\n    mk = m * k\n    nmk = n * mk\n    for i in range(nmk):\n        if not processor[i]:\n            continue\n        # back\n        if i >= mk:\n            if processor[i - mk]:\n                # front\n                if i < (nmk - mk):\n                    if processor[i + mk]:\n                        counter += 1\n                        continue\n                # right\n                if (i % k) < (k - 1):\n                    if processor[i + 1]:\n                        if not processor[i - mk + 1]:\n                            counter += 1\n                            continue\n                # down\n                if (i % mk) < (mk - k):\n                    if processor[i + k]:\n                        if not processor[i - mk + k]:\n                            counter += 1\n                            continue\n        # left\n        if (i % k) > 0:\n            if processor[i - 1]:\n                # front\n                if i < (nmk - mk):\n                    if processor[i + mk]:\n                        if not processor[i + mk - 1]:\n                            counter += 1\n                            continue\n                # right\n                if (i % k) < (k - 1):\n                    if processor[i + 1]:\n                        counter += 1\n                        continue\n                # down\n                if (i % mk) < (mk - k):\n                    if processor[i + k]:\n                        if not processor[i + k - 1]:\n                            counter += 1\n                            continue\n        # up\n        if (i % mk) >= k:\n            if processor[i - k]:\n                # front\n                if i < (nmk - mk):\n                    if processor[i + mk]:\n                        if not processor[i + mk - k]:\n                            counter += 1\n                            continue\n                # right\n                if (i % k) < (k - 1):\n                    if processor[i + 1]:\n                        if not processor[i - k + 1]:\n                            counter += 1\n                            continue\n                # down\n                if (i % mk) < (mk - k):\n                    if processor[i + k]:\n                        counter += 1\n                        continue\n    print(counter)\n\n\nmain()\n
#!/usr/bin/env python3\n\nimport re\n\ntry:\n    while True:\n        a = [ ]\n        b = [ ]\n        for word in re.split(R"[,;]", input()):\n            (a if re.match(R"^(0|[1-9][0-9]*)$", word) else b).append(word)\n        print('"%s"' % ','.join(a) if a else '-')\n        print('"%s"' % ','.join(b) if b else '-')\n\nexcept EOFError:\n    pass\n
n, x = list(map(int, input().split()))\na = []\nlst = 0\nfor i in range(1, 1 << n):\n  if i ^ x > i:\n    a.append(i ^ lst)\n    lst = i\nprint(len(a))\nprint(' '.join(str(i) for i in a))\n
import math\nimport itertools\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nmx = 0\n\nsz = ria()[0]\nmx1 = 0\nmn1 = 2000000000\n\nfor i in range(sz):\n    l, r = ria()\n    mx1 = max(l, mx1)\n    mn1 = min(r, mn1)\n\nsz = ria()[0]\nmx2 = 0\nmn2 = 2000000000\n\nfor i in range(sz):\n    l, r = ria()\n    mx2 = max(l, mx2)\n    mn2 = min(r, mn2)\n#print(mx1,mn1,mx2,mn2)\nmx = max(mx, mx1 - mn2)\nmx = max(mx, mx2 - mn1)\nprint(mx)
n,v = map(int,input().split())\nreq = n-1\n\nif req<=v:\n    print (req)\nelse:\n    total = v\n    remaining = req-v\n    for x in range(remaining):\n        total += 2+x\n    print (total)
n = int(input())\na = [0] * n\na = list(map(int, input().split()))\nfor i in range(1, len(a)):\n    a[i] += a[i - 1]\n\nans = a[-1]\nfor i in range(n - 2, 0, -1):\n    ans = max(ans, a[i] - ans)\nprint(ans)
"""\nCodeforces Round 251 Div 2 Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0:\n        return inputs\n    if mode == 1:\n        return inputs.split()\n    if mode == 2:\n        return [int(x) for x in inputs.split()]\n\ndef write(s="\n"):\n    if isinstance(s, list): s = " ".join(s)\n    s = str(s)\n    print(s, end="")\n\n################################################### SOLUTION\nn,d = read()\nt = read()\ns = sum(t) + 10*n - 10\nif s > d:\n    print(-1)\nelse:\n    print((d-sum(t))//5)
"""\nCodeforces Contest 262 Div 2 Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef main():\n    n,m = read()\n    i = 0\n    while n:\n        n -= 1\n        i += 1\n        if not i%m: n += 1\n    print(i)\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
import sys\nfrom collections import Counter\nreadline = sys.stdin.readline\n\nN = int(readline())\nA = list(map(int, readline().split()))\n\nS = set()\n\nans = True\nAns = [] \ncnt = 0\nfor a in A:\n    cnt += 1\n    if a > 0:\n        S.add(a)\n    else:\n        a = -a\n        if a not in S:\n            ans = False\n            break\n        S.remove(a)\n    if not S:\n        Ans.append(cnt)\n        cnt = 0\n\nif cnt:\n    ans = False\n\nif ans:\n    A.reverse()\n    for c in Ans:\n        CA = Counter()\n        for _ in range(c):\n            CA[abs(A.pop())] += 1\n        if any(v > 2 for v in CA.values()):\n            ans = False\n            break\n\nif ans:\n    print(len(Ans))\n    print(*Ans)\nelse:\n    print(-1)
for i in range(int(input())):\n    n, k, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    ans = d\n    for day in range(n - d + 1):\n        ans = min(ans, len(set(a[day:day + d])))\n    print(ans)
n = int(input())\narr = []\nfor i in range(n):\n    arr.append(list(input()))\nk = 1\nfor i in range(n):\n    for j in range(n):\n        if arr[i][j] == '#':\n            if i+2<=n-1 and j-1>=0 and j+1<=n-1:\n                if arr[i+1][j-1] == '#' and arr[i+1][j] == '#' and arr[i+1][j+1] == '#' and arr[i+2][j] == '#':\n                    arr[i+1][j-1] = '.'\n                    arr[i+1][j] = '.'\n                    arr[i+1][j+1] = '.'\n                    arr[i+2][j] = '.'\n                    arr[i][j] = '.'\n                else:\n                    k = 0\n                    break\n            else:\n                k = 0\n                break\nif k == 1:\n    print('YES')\nelse:\n    print('NO')
from itertools import *\n\n\nk, p = list(map(int, input().split()))\nss = 0\nfor i in range(1, k + 1):\n    s = str(i)\n    num = int(s + ''.join(reversed(s)))\n    ss += num\n    ss %= p\nprint(ss)\n
def check(pali):\n    for i in range(len(pali) // 2):\n        if pali[i] != pali[-i - 1]:\n            return False\n\n    return True\n\n\ndef __starting_point():\n    s = input()\n    k = int(input())\n\n    if len(s) % k != 0:\n        print('NO')\n        return\n\n    step = len(s) // k\n    for i in range(k):\n        if not check(s[i * step: (i + 1) * step]):\n            print('NO')\n            return\n\n    print('YES')\n__starting_point()
n, k = list(map(int,input().split()))\nL = list(map(int,input().split()))\ni = 0\np = 0\nz = 1\nR = [0 for _ in range(k)]\nwhile i<n:\n    R[p] += L[n-1-i]\n    p = p + z\n    i+=1\n    if p == k or p == -1:\n        z = z*(-1)\n        if p == k:\n            p = p - 1\n        else:\n            p = p + 1\nprint(max(R))\n\n
x = int(input())\ny = list(map(int, input().split(' ')))\nif y == [0] * x:\n    print(0)\n    quit()\nfor i in range(x):\n    if y[i] == 1:\n        y = y[i:]\n        break\n\ny.reverse()\nfor i in range(len(y)):\n    if y[i] == 1:\n        y = y[i:]\n        break\n\ny.reverse()\n\nl = []\nct = 0\nfor i in y:\n    if i == 0:\n        ct+=1\n    if i == 1 and ct != 0:\n        l.append(ct)\n        ct = 0\n\nk = 1\nfor i in l:\n    k *= (i+1)\n\nprint(k)\n
"""\nCodeforces Contest 281 Div 2 Problem C\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef main():\n    n, = read()\n    a = read()\n    res = [(i,0) for i in a]\n    m, = read()\n    b = read()\n    res.extend((i,1) for i in b)\n    res.sort()\n    mxa = 3*n\n    mnb = 3*m\n    cra = 3*n\n    crb = 3*m\n    for _,i in res:\n        if i:\n            crb -= 1\n            if cra-crb > mxa-mnb:\n                mxa = cra\n                mnb = crb\n        else:\n            cra -= 1\n    print(str(mxa) + ":" + str(mnb))\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
# map(int, input())\nt = int(input())\nfor i in range(t):\n	s = sorted(input())\n	if s[0] == s[-1]:\n		print(-1)\n		continue\n	print(''.join(s))
n, m = list(map(int, input().split()))\nA = [input().split() for i in range(n)]\nT = False\nfor i in range(n):\n    for j in range(m):\n        if A[i][j] == '1' and (i == 0 or j == 0 or i == n - 1 or j == m - 1):\n            T = True\nif T:\n    print(2)\nelse:\n    print(4)\n
"""\nCodeforces Contest 281 Div 2 Problem D\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef main():\n    n, = read()\n    if n%2:\n        print("black")\n    else:\n        print("white")\n        print("1 2")\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
# import numpy as npy\n# idx=sorted(idx,key=functools.cmp_to_key(cmpx))\nimport bisect\nimport array\nimport functools\nimport math\n\nn=int(input())\na=array.array('i',map(int,input().split()))\ns=0\nq=[]\nq.append(0)\nfor i in range(n):\n    if a[i]==1:\n        q.append(i+1)\n        s=s+1\nq.append(n+1)\nm=n*(n-1)//2\nf=[[10000000 for i in range(82)] for i in range(3500)]\nf[0][0]=0\nfor i in range(1,s+2):\n    rlim=n+1-(s+1-i)\n    g=[[10000000 for i in range(82)] for i in range(3500)]\n    for j in range(i-1,rlim+1):\n        for S in range(m+1):\n            if (f[S][j]<1000000):\n                for k in range(j+1,rlim+1):\n                    nv=f[S][j]+(k-j-1)*(k-j-2)//2\n                    nS=S+abs(k-q[i])\n                    g[nS][k]=min(g[nS][k],nv)\n    f=g\nmn=0\nfor i in range(m+1):\n    mn=max(mn,(n-s)*(n-s-1)//2-f[i][n+1])\n    print(mn,end=' ')
def dfs(v, root):\n    nonlocal cnt\n    if used[v]:\n        return\n    used[v] = True\n    for j in range(len(G[v])):\n        to = G[v][j]\n        dfs(to, root)\n    if v == root:\n        cnt += 1\n\ncnt = 0\nn, e = map(int, input().split())\nG = [[] for i in range(n)]\nfor i in range(e):\n    a, b = map(lambda x:int(x) - 1, input().split())\n    G[a].append(b)\n    G[b].append(a)\n\nused = [False for i in range(n)]\nfor v in range(n):\n    dfs(v, v)\nprint(2 ** (n - cnt))
n = int(input())\nif n % 3 == 0:\n    print(2 * (n // 3))\nelse:\n    print(2 * (n // 3) + 1)\n
import sys\n\ndef Min(x, y):\n    if x > y:\n        return y\n    else:\n        return x\n\ndef Gcd(x, y):\n    if x == 0:\n        return y\n    else:\n        return Gcd(y % x, x)\n\ndef Lcm(x, y):\n    return x * y // Gcd(x, y)\n\nn = int(input())\na = [int(i) for i in input().split()]\nd = [int(0) for i in range(0, n)]\n\nok = 0\n\ncur = 0\n\nlen = Lcm(7, n)\n\nfor i in range(0, 7 * n):\n    if a[i % n] == 0 :\n        print(i % n + 1)\n        ok = 1\n        break\n    if cur != 6:\n        a[i % n] -= 1\n        d[i % n] += 1\n    cur = (cur + 1) % 7\n\nif ok == 0:\n    k = 10**20\n\n    for i in range(0, n):\n        a[i] += d[i]\n        if d[i] == 0: continue\n        if a[i] % d[i] > 0:\n            k = Min(k, a[i] // d[i])\n        else:\n            k = Min(k, a[i] // d[i] - 1)\n\n    if k == 10**20:\n        k = 0\n\n    for i in range(0, n):\n        a[i] -= k * d[i]\n\n    iter = 0\n    cur = 0\n\n    while True:\n        if a[iter] == 0:\n            print(iter % n + 1)\n            break\n        else:\n            if cur != 6:\n                a[iter] -= 1\n            cur = (cur + 1) % 7\n            iter = (iter + 1) % n\n\n
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\n\n\ndef main():\n    n = I()\n    a = n//2\n    b = n-a\n    while fractions.gcd(a,b) > 1:\n        a -= 1\n        b += 1\n\n    return "{} {}".format(a,b)\n\nprint(main())\n\n\n\n
w, h, k = map(int, input().split())\nans = 0\nfor i in range(k):\n	ans += w * 2 + (h - 2) * 2\n	#print(ans, h, w)\n	w -= 4\n	h -= 4\nprint(ans)
n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ndef dif(x):\n	c = []\n	for i in range(n-1):\n		c.append(x[i+1] - x[i])\n	return c\n\nif list(sorted(dif(a))) == list(sorted(dif(b))) and a[0] == b[0] and a[n-1] == b[n-1]:\n	print('Yes')\nelse:\n	print('No')
n=int(input())\n#x,y,z,t1,t2,t3=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\n\ns=[0]*n\n\nans=True\n\nfor i in range(n):\n    ans=ans and a[i]<=i and b[i]<=(n-i-1)\n    s[i]=n-a[i]-b[i]\n\ndef qwe(s,j):\n    l,r=0,0\n    for i in range(len(s)):\n        if i<j and s[i]>s[j]: l+=1\n        elif i>j and s[i]>s[j]: r+=1\n    return l,r\n\n\n\nif ans:\n    for i in range(n):\n        l,r=qwe(s,i)\n        ans=ans and a[i]==l and b[i]==r\n        \n    \n\n    \nif ans:\n    print('YES')\n    for i in range(n):\n        print(n-a[i]-b[i],end=' ')\nelse: print('NO')\n\n\n\n
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport random\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\n\n\ndef main():\n    n,m,ta,tb,k = LI()\n    a = LI()\n    b = LI()\n    if k >= n or k >= m:\n        return -1\n\n    r = 0\n    bi = 0\n    for i in range(k+1):\n        c = a[i] + ta\n        while bi < m and b[bi] < c:\n            bi += 1\n\n        if bi + (k-i) >= m:\n            return -1\n        t = b[bi + (k-i)] + tb\n        if r < t:\n            r = t\n\n    return r\n\n\nprint(main())\n\n
\n\n# Python3 program to count inversions using  \n# Binary Indexed Tree  \n  \n# Returns sum of arr[0..index]. This function \n# assumes that the array is preprocessed and  \n# partial sums of array elements are stored  \n# in BITree[].  \ndef getSum( BITree, index): \n    sum = 0 # Initialize result  \n      \n    # Traverse ancestors of BITree[index]  \n    while (index > 0):  \n  \n        # Add current element of BITree to sum  \n        sum += BITree[index]  \n  \n        # Move index to parent node in getSum View  \n        index -= index & (-index)  \n  \n    return sum\n  \n# Updates a node in Binary Index Tree (BITree)  \n# at given index in BITree. The given value \n# 'val' is added to BITree[i] and all of its \n# ancestors in tree.  \ndef updateBIT(BITree, n, index, val): \n  \n    # Traverse all ancestors and add 'val'  \n    while (index <= n):  \n  \n        # Add 'val' to current node of BI Tree  \n        BITree[index] += val  \n  \n        # Update index to that of parent \n        # in update View  \n        index += index & (-index)  \n  \n# Returns count of inversions of size three  \ndef getInvCount(arr, n): \n  \n    invcount = 0 # Initialize result  \n  \n    # Find maximum element in arrays  \n    maxElement = max(arr) \n  \n    # Create a BIT with size equal to  \n    # maxElement+1 (Extra one is used  \n    # so that elements can be directly  \n    # be used as index) \n    BIT = [0] * (maxElement + 1)  \n    for i in range(1, maxElement + 1):  \n        BIT[i] = 0\n    for i in range(n - 1, -1, -1): \n        invcount += getSum(BIT, arr[i] - 1)  \n        updateBIT(BIT, maxElement, arr[i], 1)  \n    return invcount  \n\ndef getInvCountAdv(arr, n): \n  \n    invcount = 0 # Initialize result  \n  \n    # Find maximum element in arrays  \n    maxElement = max(arr) \n  \n    # Create a BIT with size equal to  \n    # maxElement+1 (Extra one is used  \n    # so that elements can be directly  \n    # be used as index) \n    BIT = [0] * (maxElement + 1)  \n    for i in range(1, maxElement + 1):  \n        BIT[i] = 0\n    for i in range(n - 1, -1, -1): \n        invcount += (i + 1) * getSum(BIT, arr[i] - 1)  \n        updateBIT(BIT, maxElement, arr[i], n-i)  \n    return invcount  \n      \n# Driver code  \nn = int(input())\na = list(map(int,input().split())) \nInvCount = getInvCount(a, n)\nInvCountAdv = getInvCountAdv(a,n)\nthirdSum = 0\nfor i in range(1,n+1):\n    thirdSum += i * (i - 1) * (n- i + 1) / 2\nprint(InvCount - InvCountAdv / (n * (n + 1)) * 2 + thirdSum / (n * (n + 1)))\n      \n# This code is contributed by \n# Shubham Singh(SHUBHAMSINGH10) \n
from fractions import gcd\nfrom collections import defaultdict\n\ndef read_data():\n    n = int(input())\n    points = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n    return n, points\n\ndef solve(n, points):\n    if n <= 2:\n        return 0\n    zeros = 0\n    for i, (x, y) in enumerate(points[:-2]):\n        zeros += count_zeros(i, x, y, points)\n    return n * (n-1) * (n-2) // 6 - zeros\n\ndef count_zeros(i, x, y, points):\n    slopes = defaultdict(int)\n    for xj, yj in points[i + 1:]:\n        dx = x - xj\n        dy = y - yj\n        d = gcd(dx, dy)\n        slope = (dx/d, dy/d)\n        slopes[slope] += 1\n    zeros = 0\n    for val in slopes.values():\n        if val >= 2:\n            zeros += val * (val - 1)\n    return zeros // 2\n\nn, points = read_data()\nprint(solve(n, points))
n = int(input())\nB = list(map(int, input().split()))\npp = {}\nfor i in range(n):\n    if B[i] - (i + 1) not in pp:\n        pp[B[i] - (i + 1)] = 0\n    pp[B[i] - (i + 1)] += B[i]\nans = 0\nfor c in pp:\n    ans = max(ans, pp[c])\nprint(ans)
def f(a, ind):\n    if a[ind] == 0:\n        return -1\n    k = a[ind] // 14\n    x = a[ind] % 14\n    b = a[:]\n    b[ind] = 0\n    for j in range(14):\n        b[j] += k\n    for j in range(ind + 1, ind + x + 1):\n        j1 = j % 14\n        b[j1] += 1\n    res = 0\n    for j in range(14):\n        if b[j] % 2 == 0:\n            res += b[j]\n    return res\na = list(map(int, input().split()))\nans = 0\nfor i in range(14):\n    cur = f(a, i)\n    ans = max(ans, cur)\nprint(ans)
"""\nCodeforces Contest 273 Div 2 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef comb2(n):\n    return n*(n-1)//2\n\ndef main():\n    n,m = read()\n    k = n // m\n    p = n % m\n    mn = p * comb2(k+1) + (m-p) * comb2(k)\n    mx = comb2(n-m+1)\n    print(mn, mx)\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
s=input().strip()\nn=len(s)\ni=0\nk=1\nj=0\nwhile i<n:\n    #print(i,j)\n    j=i\n    i+=1\n    while i<n and s[i]=='0':\n        i+=1\n    if j>i-j:\n        k+=1\n    elif j==i-j:\n        if s[:j]>=s[j:i]:\n            k+=1\n        else:\n            k=1\n    else:\n        k=1\nprint(k)
n, p, k = map(int, input().split())\n\nif (p - k) > 1:\n	print('<<', end = ' ')\n\nfor i in range(p - k, p):\n	if (i > 0):\n		print(i, end = ' ')\n\nprint('(' + str(p) + ')', end = ' ')\n\nfor i in range(p + 1, p + k + 1):\n	if (i < (n + 1)):\n		print(i, end = ' ')\n\nif (p + k) < n:\n	print('>>', end = ' ')
n = int(input())\na = [int(i) for i in input().split()]\nminy = 0\nmaxy = 0\ns = 0\nfor i in range(n):\n    if i % 2 == 0:\n        s += a[i]\n    else:\n        s -= a[i]\n    maxy = max(s, maxy)\n    miny = min(s, miny)\ndif = maxy - miny\nsize = sum(a)\nres = [[" "] * size for i in range(dif)]\ncur = [maxy, 0]\nfor i in range(n):\n    if i % 2 == 0:\n        cur[0] -= 1\n    else:\n        cur[0] += 1\n    for j in range(a[i]):\n        if i % 2 == 0:\n            res[cur[0]][cur[1]] = "/"\n            cur[0] -= 1\n        else:\n            res[cur[0]][cur[1]] = "\\"\n            cur[0] += 1\n        cur[1] += 1\n\nfor i in res:\n    print("".join(i))
import sys\ninput = sys.stdin.readline\nn,p=map(int,input().split())\na=list(map(int,input().split()))\na.sort()\nmn=0\nmx=2000000000000000\nfor i in range(n):\n    d=a[i]-i\n    mn=max(d,mn)\n    if i>=p-1:\n        d2=a[i]-i+p-1\n        mx=min(mx,d2)\nprint(max(mx-mn,0))\nfor i in range(mn,mx):\n    print(i,end=" ")
n, k = list(map(int, input().split()))\n\n\ndef get(x):\n    if x <= k:\n        return x * (x + 1) // 2\n    res = k * x - k * (k - 1) // 2\n    sz = x - k - 1\n    if sz % 2 == 0:\n        cnt = sz // 2\n        res += (2 + sz) * cnt // 2\n    else:\n        cnt = sz // 2 + 1\n        res += (1 + sz) * cnt // 2\n    return res\n\n\nl = 0\nr = 10 ** 18\nwhile r - l > 1:\n    m = l + (r - l) // 2\n    if get(m) >= n:\n        r = m\n    else:\n        l = m\n\nprint(r)\n
\n\nX,Y,Z,K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\n\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\n\n\nans = []\nfor i in range(X):\n    if (i+1) > K: break\n    for j in range(Y):\n        if (i+1)*(j+1) > K: break\n        for k in range(Z):\n            if (i+1)*(j+1)*(k+1) > K: break\n            ans.append(A[i]+B[j]+C[k])\n\nans.sort(reverse=True)\n\nfor i in range(K):\n    print((ans[i]))\n            \n
from math import gcd, sqrt\na,b = map(int, input().split())\ng = gcd(a,b)\nd = {}\nfor i in range(2, int(sqrt(g))+1):\n    while g%i==0:\n        g//=i\n        d[i] = d.get(i, 0)+1\nif g>1:\n    d[g] = 1\nprint(len(d)+1)
from typing import List\n\n\ndef winner(a: str, b: str) -> str:\n    return b if (a, b) in [("R", "P"), ("P", "S"), ("S", "R")] else a\n\n\nN, K = list(map(int, input().split()))\nS: List[str] = list(input())\n\nfor i in range(K):\n    T: List[str] = S + S\n    S = [winner(T[2 * j], T[2 * j + 1]) for j in range(N)]\nprint((S[0]))\n
N = int(input())\nA = [int(s) for s in input().split(" ")]\nABI = sorted(((a, i) for i, a in enumerate(A, 1)), reverse=True)\nprev = [0]\nfor k, (a,i) in enumerate(ABI):\n  curr = [0]*(k+2)\n  for l in range(k+1):\n    curr[l] = max(curr[l], prev[l]+abs(N-i-k+l)*a)\n    curr[l+1] = prev[l]+abs(i-l-1)*a\n    \n  prev = curr\n \nprint(max(prev))
def XorWorld():\n    a, b = list(map(int, input().split()))\n    if a%2 == 0 and b%2 == 0:\n        if ((b-a)//2)%2 == 0:\n            print((0^b))\n        else:\n            print((1^b))\n    elif a%2 == 0:\n        if ((b-a+1)//2)%2 == 0:\n            print((0))\n        else:\n            print((1))\n    elif b%2 == 0:\n        if ((b-a-1)//2)%2 == 0:\n            print((0^a^b))\n        else:\n            print((1^a^b))\n    else:\n        if ((b-a)//2)%2 == 0:\n            print((0^a))\n        else:\n            print((1^a))\n\ndef __starting_point():\n    XorWorld()\n    \n\n__starting_point()
from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef MAP1()  : return map(lambda x:int(x)-1,input().split())\ndef LIST()  : return list(MAP())\n\ndef solve():\n    N = INT()\n    adj = [[] for _ in range(N)]\n    for i in range(N-1):\n        a, b, c = MAP()\n        adj[a-1].append([b-1, c])\n        adj[b-1].append([a-1, c])\n\n    Q, K = MAP()\n    K -= 1\n\n    d = [inf]*N\n    d[K] = 0\n    que = []\n    heappush(que, K)\n\n    while que:\n        v = heappop(que)\n        for b, c in adj[v]:\n            if d[b] > d[v] + c:\n                d[b] = d[v] + c\n                heappush(que, b)\n\n    for i in range(Q):\n        x, y = MAP()\n        print(d[x-1]+d[y-1])\n\ndef __starting_point():\n    solve()\n__starting_point()
import sys\nreadline = sys.stdin.readline\n\n# fが来たらstackに[0]をappendする。\n# oが来たとき、最後尾が[0]だったら[1]にする\n# xが来たとき、最後尾が[1]ならpopする。このとき3を引く\n\nN = int(readline())\nS = readline().rstrip()\n\nans = N\nstack = []\n\nfor s in S:\n  if s == "f":\n    stack.append(0)\n  elif s == "o":\n    if stack and stack[-1] == 0:\n      stack[-1] = 1\n    else:\n      # 最後がfでない状態でoが来た時、このoが消えることはない。\n      stack = []\n  elif s == "x":\n    if stack and stack[-1] == 1:\n      stack.pop()\n      ans -= 3\n    else:\n      stack = []\n  else:\n    stack = []\n      \nprint(ans)
#Circle of Numbers\nimport math\n\ndef centre(n, pts):\n    x, y = 0, 0\n    for j in [7,11,13,17,19,23,29,31,37,1193,1663,2711,4007,65537]:\n        if math.gcd(n,j) == 1:\n            for i in range(n):\n                k = int(pts[i])\n                x += k*math.cos(math.pi * 2*i*j/n)\n                y += k*math.sin(math.pi * 2*i*j/n)\n            if not (abs(x) < 0.000001 and abs(y) < 0.000001):\n                return 'NO'\n    return 'YES'\n    \ndef strconv(s):\n    return [char for char in s]\n\nn = int(input())\npts = strconv(input())\nprint(centre(n,pts))\n
import sys\n\nx,y = list(map(int, input().strip().split()))\n\nif y % x != 0:\n    print(0)\n    return\n\nMOD = 10**9 + 7\n\nK = y//x\n\ndef multiply(A,b, MOD):\n    n, m = len(A), len(b[0])\n    matrika = [[0 for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            vsota = 0\n            for k in range(len(A[0])):\n                vsota += A[i][k]*b[k][j]\n            matrika[i][j] = vsota % MOD\n    return matrika\n\ndef copy(mat):\n    return [e[:] for e in mat]\n\ndef fib(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 1\n    matrika = [[1,1],[1,0]]\n\n    pripravi = dict()\n    pripravi[1] = copy(matrika)\n    s = 1\n\n    pot = [1]\n\n    working = copy(matrika)\n    \n    while s <= n:\n        working = multiply(working,working,MOD)\n        s*= 2\n        pripravi[s] = copy(working)\n        pot.append(s)\n\n    manjka = n-2\n    pointer = len(pot) - 1\n    while manjka > 0:\n        if pot[pointer] > manjka:\n            pointer -= 1\n        else:\n            matrika = multiply(matrika, pripravi[pot[pointer]], MOD)\n            manjka -= pot[pointer]\n\n    v = [[1],[0]]\n\n    return multiply(matrika, v, MOD)[0][0]\n\nmemo2 = dict()\ndef find(y):\n    if y in memo2:\n        return memo2[y]\n    ALL = (pow(2, y - 1, MOD)) % MOD\n\n    k = 2\n    while k*k <= y:\n        if y % k == 0:\n            if k*k != y:\n                ALL -= find(y//k)\n                ALL -= find(k)\n            else:\n                ALL -= find(k)\n        k += 1\n        #print(k, ALL)\n\n    if y != 1:\n        ALL -= 1\n\n    memo2[y] = ALL % MOD\n    return ALL % MOD\n\nprint(find(K) % MOD)\n\n\ndef gcd(x,y):\n    if x == 0:\n        return y\n    if y > x:\n        return gcd(y,x)\n    if x % y == 0:\n        return y\n    return gcd(y, x % y)\n\n\nmemo = dict()\ndef brute(k, gc):\n    if (k,gc) in memo:\n        return memo[k,gc]\n    if k == 0:\n        if gc:\n            return 1\n        else:\n            return 0\n    ALL = 0\n    for i in range(1, k + 1):\n        ALL += brute(k-i,gcd(gc,i))\n    memo[k, gc] = ALL\n    return ALL\n\n#print(brute(K,0) % MOD)\n            \n
from heapq import heappush, heappop\nN = int(input())\nA = [int(a) for a in input().split()]\nfor i in range(N):\n    if A[i] < 0:\n        k = i\n        break\nA = [0] + [0 if i < k else A[i] for i in range(N) if i != k]\n\nans = A.pop()\nH = []\nwhile N > 2:\n    N //= 2\n    for i in range(N):\n        heappush(H, A.pop())\n    ans += heappop(H)\n\nprint(ans)\n\n\n
n = int(input())\nnow = 2\nfor i in input().split():\n    a = int(i)\n    if a % 2 == 0:\n        now = 3 - now\n    print(now)\n
n = int(input())\nans = 0\ns = 0\n\nwhile (n > 0):\n    ans += 1\n    s += ans\n    n -= s\n\n    if (n < 0):\n        ans -= 1\n        break\n\nprint(ans)\n
#scott http://codeforces.com/problemset/problem/291/A now? ok you start\n\nn = int(input())\narr = list(map (int, input().split())) #scott\n\n#for i in arr:\n#    print (i)\n\ncnt = 0 \nclast, llast = -1, -1 #scott wait we need to sort\n\narr = sorted(arr)\n\nbad = False #scott so now we just count # of pairs and make sure there's not 3 in a row right?ok\n#so a neat thing you can do is just for x in arr\nfor i in arr:\n    #print (i)\n    if i > 0: #scott so last was the last one, llast was the second last one\n        if i == clast :\n            cnt += 1 #scott\n            if clast == llast :\n                bad = True #scott your turn\n        llast = clast\n        clast = i #scott\nif bad == False:\n    print (cnt) #scott\nelse:\n    print(-1) #scott\n\n#darn ii'm getting RTE test 1\n
import sys\n\ndef get_max_kvazi(n):\n    s = str(n)\n    ans = ''\n    for c in s:\n        if c == '0':\n            ans = ans + '0'\n        else:\n            ans = ans + '1'\n    return int(ans)\n\nfin = sys.stdin\nfout = sys.stdout\n\n#fin = open("input.txt", 'r')\n#fout = open("output.txt", 'w')\n\nn = int(fin.readline())\nans = []\nwhile (n > 0):\n    cur = get_max_kvazi(n)\n    ans.append(cur)\n    n -= cur\nprint(len(ans))\nprint(*ans)\n
'''input\n6\nLLRRRR\n'''\nn = int(input())\ns = input()\nh, v = min(s.count("L"), s.count("R")), min(s.count("U"), s.count("D"))\nprint(2*h + 2*v)
n,d = map(int,input().split())\n\nans = 0\nhas = 0\nfor i in range(d):\n    s = input().count("1")\n    if s==n:\n        has = 0\n    else:\n        has+=1\n    ans = max(ans,has)\nprint(ans)
n, m, k = list(map(int, input().split()))\nif m >= n and k >= n:\n    print('Yes')\nelse:\n    print('No')\n
input()\na = list(map(int, input().split()))\ns = max(a)\n\nprint(max(0, s - 25))\n
import sys\n\nn, k = (int(i) for i in input().split())\n\nff = [1] * (n + 1)\n\nfor i in range(1, n + 1) :\n	ff[i] = ff[i - 1] * i\n\ndd = [0] * (n + 1)\n\ndd[1] = 0\ndd[2] = 1\n\nfor i in range(3, n + 1) :\n	dd[i] = (i - 1) * (dd[i - 1] + dd[i - 2])\n	\nans = ff[n]\n\nfor i in range(n - k) :\n	c = ff[n] // ff[n - i]\n	c = c // ff[i]\n	c = c * dd[n - i]\n	\n	ans -= c\n\nprint(ans)
a = [0]\ncur = 1\n\nwhile(cur < 10 ** 13):\n    x = a[-1]\n    a.append(x * 2 + cur)\n    cur *= 2\n\nn = int(input())\nn -= 1\n\nans = 0\ni = 1\ncur = 1\nwhile(n > 0):\n    x = n % 2\n    n = n // 2\n    if(x > 0):\n        ans += cur + a[i - 1]\n    i += 1\n    cur *= 2\n    \nprint(ans)
n = int(input())\nxa = []\nya = []\nfor _ in range(n):\n	x, y = map(int,input().split())\n	xa.append(x)\n	ya.append(y)\nprint(max(max(xa)-min(xa),max(ya)-min(ya))**2)
n = int(input())\na = [int(ai) for ai in input().split()]\n\ndef solve(x):\n    n = len(x)\n    if sorted(x) == x:\n        return n\n    return max(solve(x[:n//2]), solve(x[n//2:]))\n\nprint(solve(a))\n
3\n\nimport array\nfrom fractions import Fraction\nimport functools\nimport itertools\nimport math\nimport os\nimport sys\n\n\ndef main():\n    H = [read_ints() for _ in range(10)]\n    print(solve(H))\n\n\ndef pos_idx(x, y):\n    i = y * 10\n    if y % 2 == 0:\n        i += x\n    else:\n        i += 9 - x\n    return i\n\n\ndef idx_pos(i):\n    y = i // 10\n    if y % 2 == 0:\n        x = i % 10\n    else:\n        x = 9 - i % 10\n    return x, y\n\n\ndef solve(H):\n    dp = [0] * 100\n    for i in range(1, 100):\n        e = 0\n        for d in range(1, 7):\n            j = i - d\n            if j < 0:\n                rem = 7 - d\n                e += rem / 6\n                e *= 6 / (6 - rem)\n                break\n            x, y = idx_pos(j)\n            if H[y][x] != 0:\n                dy = y - H[y][x]\n                k = pos_idx(x, dy)\n                assert idx_pos(k) == (x, dy)\n                e += (min(dp[j], dp[k]) + 1) / 6\n            else:\n                e += (dp[j] + 1) / 6\n        dp[i] = e\n    return dp[99]\n\n\n###############################################################################\n# AUXILIARY FUNCTIONS\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
input()\ns = input()\nr1 = 1\nf = s[0]\nfor c in s:\n	if c != f:\n		break\n	r1 += 1\nr2 = 1\np = s[-1]\nfor c in s[::-1]:\n	if c != p:\n		break\n	r2 += 1\nif f == p:\n	print((r1 * r2) % 998244353)\nelse:\n	print((r1 + r2 - 1) % 998244353)\n
#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\n    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit\n    \nN, = getIntList()\n\nzb = []\n \ntotal = 0\n\nde = [0,0,0,0,0]\ngr = [ [] for i in range(5)]\nminv = 10000000\nfor i in range(N):\n    a,b,c = getIntList()\n    de[a]+=1\n    de[c] +=1\n    zb.append( (a,b,c) )\n    total +=b\n    if a!=c:\n        minv = min(minv,b)\nvis = [0,0,0,0,0]\n\ndef dfs( root):\n    if vis[root]:return []\n    vis[root] = 1\n    r = [root,]\n    for x in zb:\n        a,b,c =  x\n        if a==root:\n            r = r+ dfs(c)\n        elif c==root:\n            r = r+ dfs(a)\n    return r\n\nres = 0\nfor i in range(1,5):\n    if vis[i]:continue\n    t = dfs(i)\n    t = set(t)\n    if len(t) ==4:\n        for j in range(1,5):\n            if de[j]%2==0:\n                print(total)\n                return\n        print(total-minv)\n        return\n    tr = 0\n    for x in zb:\n        a,b,c = x\n        if a in t:\n            tr +=b\n    res = max(res,tr)\n\nprint(res)\n \n\n\n\n\n\n
def main():\n    n = int(input())\n    for i in range(1, n):\n        if n % i == 0:\n            if i < 5 or n // i < 5:\n                continue\n            vowels = "aeiou"\n            ind = 0\n            ans = ""\n            for j in range(n // i):\n                for k in range(i):\n                    ans += vowels[(j + k) % 5]\n            print(ans)\n            return 0\n    print(-1)\n    return 0\n\nmain()
R = lambda: map(int, input().split())\nn = int(input())\ndp = [0] * (10**6 + 1)\nfor x in R():\n    dp[x] = 1\nfor i in range(10**6, -1, -1):\n    if dp[i]:\n        for x in range(i + i, 10**6 + 1, i):\n            if dp[x]:\n                dp[i] = max(dp[i], dp[x] + 1)\nprint(max(dp))
L=[]\nfor i in range(5):\n    s=input().split()\n    L.append(list(s))\n\nfor i in range(5):\n    for j in range(5):\n        if(L[i][j]=="1"):\n            row=i\n            col=j\n\nx=abs(row-2)+abs(col-2)\nprint(x)\n
n = int(input())\ns = input()\nt = input()\n\ndef ff(ch):\n    return ord(ch) - ord('a')\n\ndef answer(a, b, sc):\n    print(cans + sc)\n    print(a+1, b+1)\n    return\n\ncans = 0\nmatrix = [[None] * 26 for i in range(26)]\nfor i in range(n):\n    matrix[ff(s[i])][ff(t[i])] = i\n    if s[i] != t[i]:\n        cans += 1\n\nfor i in range(26):\n    for j in range(i):\n        if matrix[i][j] is not None and matrix[j][i] is not None:\n            answer(matrix[i][j], matrix[j][i], -2)\n\nfor i in range(26):\n    for h in range(26):\n        if h == i:\n            continue\n        for v in range(26):\n            if v == i:\n                continue\n            if matrix[h][i] is not None and matrix[i][v] is not None:\n                answer(matrix[h][i], matrix[i][v], -1)\n\nanswer(-2, -2, 0)\n
def solve(s, t, i, l):\n    if i == l:\n        return False\n    if s[i] == "?":\n        if solve(s, t, i + 1, l):\n            s[i] = t[i]\n            return True\n        elif t[i] == "9":\n            return False\n        s[i] = nxt[t[i]]\n        for j in range(i, l):\n            if s[j] == "?":\n                s[j] = "0"\n        return True\n    elif s[i] > t[i]:\n        for j in range(i, l):\n            if s[j] == "?":\n                s[j] = "0"\n        return True\n    elif s[i] < t[i]:\n        return False\n    else:\n        return solve(s, t, i + 1, l)\n\n\nn = int(input())\na = [list(input()) for _ in range(n)]\np = ["0"]\nnxt = {str(x): str(x + 1) for x in range(9)}\n\nfor i, ai in enumerate(a):\n    if len(p) > len(ai):\n        print("NO")\n        break\n    if len(p) < len(ai):\n        if a[i][0] == "?":\n            a[i][0] = "1"\n        for j in range(len(ai)):\n            if a[i][j] == "?":\n                a[i][j] = "0"\n    elif not solve(a[i], p, 0, len(ai)):\n        print("NO")\n        break\n    p = a[i]\nelse:\n    print("YES")\n    print("\n".join("".join(line) for line in a))
import sys\nfrom math import ceil\n\nn, m, k = list(map(int, sys.stdin.readline().split()))\nplaces = [True for _ in range(n)]\nfor x in map(int, sys.stdin.readline().split()):\n    places[x] = False\ncosts = list(map(int, sys.stdin.readline().split()))\nif not places[0]:\n    print(-1)\n    return\n\nprev = [i for i in range(n)]\nlast = 0\nfor i in range(n):\n    if places[i]:\n        last = i\n    prev[i] = last\n\nbest_cost = float('inf')\nfor lamp in range(k, 0, -1):\n    min_cost = ceil(n/lamp) * costs[lamp-1]\n    if min_cost >= best_cost:\n        continue\n\n    # try this shit\n    cost = costs[lamp-1]\n    reach = lamp\n    fail = False\n\n    while reach < n:\n        if prev[reach] + lamp <= reach:\n            fail = True\n            break\n        reach = prev[reach] + lamp\n        cost += costs[lamp - 1]\n\n        if cost + (ceil((n - reach)/lamp) * costs[lamp-1]) >= best_cost:\n            fail = True\n            break\n\n    if not fail:\n        best_cost = min(best_cost, cost)\n\nprint(best_cost if best_cost != float('inf') else -1)\n
n, k, M, D = list(map(int, input().split()))\nans = 0\nfor d in range(1, D + 1):\n    bot = 0\n    top = M + 1\n    while (top > bot + 1):\n        mid = (bot + top) // 2\n        cur = (d - 1) * mid * k;\n        cur += mid;\n        if (cur > n):\n            top = mid;\n        else:\n            bot = mid;\n    ans = max(ans, bot * d)\nprint(ans);\n
N,K=input().split()\nN,K=int(N),int(K)\n\nif(N%2==0):\n    if(K<=N//2):\n        print(2*K-1)\n    else:\n        K-=N//2\n        print(2*K)\n\nelse:\n    if(K<=N//2+1):\n        print(2*K-1)\n    else:\n        K-=N//2+1\n        print(2*K)\n\n
n = int(input())\nA = list(map(int, input().split()))\nm = 0\npos = 0\nneg = 0\nfor i in range(n):\n    if A[i] < 0:\n        neg += 1\n        m += (-A[i] - 1)\n        A[i] = -1\n    elif A[i] > 0:\n        pos += 1\n        m += (A[i] - 1)\n        A[i] = 1\nzer = n - pos - neg\nif zer:\n    print(m + zer)\nelif neg % 2 == 0:\n    print(m)\nelse:\n    print(m + 2)
def modgroup(M = 10**9+7, invn = 0) :\n	exec(f'''class mod{M} :\n	inv = [None] * {invn}\n	if {invn} >= 2 : inv[1] = 1\n	for i in range(2, {invn}) : inv[i] = (({M}-{M}//i)*inv[{M}%i])%{M}\n	def __init__(self, n = 0) : self.n = n % {M}\n	__repr__ = lambda self : str(self.n) + '%{M}'\n	__int__ = lambda self : self.n\n	__eq__ = lambda a,b : a.n == b.n\n	__add__ = lambda a,b : __class__(a.n + b.n)\n	__sub__ = lambda a,b : __class__(a.n - b.n)\n	__mul__ = lambda a,b : __class__(a.n * b.n)\n	__pow__ = lambda a,b : __class__(pow(a.n, b.n, {M}))\n	__truediv__ = lambda a,b : __class__(a.n * pow(b.n, {M-2}, {M}))\n	__floordiv__ = lambda a,b : __class__(a.n * __class__.inv[b.n])\n	''')\n	return eval(f'mod{M}')\ndef solution() :\n	s = input()\n	l = len(s)\n	mod = modgroup()\n	num = [mod(0)] * (l+1) # num[i] = int(s[:i]) <mod>\n	shift = [mod(1)] * (l+1) # shift[i] = 10**i <mod>\n	for i,x in enumerate(s, 1) :\n		num[i] = num[i-1] * mod(10) + mod(int(x))\n		shift[i] = shift[i-1] * mod(10)\n	def mod_check(la, lb, lc) :\n		a,b,c = num[la], num[la+lb], num[la+lb+lc]\n		c -= b * shift[lc]\n		b -= a * shift[lb]\n		return a + b == c\n	for lc in range(l//3+bool(l%3), l//2+1) :\n		for lb in (lc, lc-1, l-lc*2, l-lc*2+1) :\n			la = l - lc - lb\n			if la < 1 or lb < 1 or lc < 1 : continue\n			if la > lc or lb > lc : continue\n			if not mod_check(la, lb, lc) : continue\n			a,b,c = s[:la], s[la:la+lb], s[la+lb:la+lb+lc]\n			print(f'{a}+{b}={c}'); return\nsolution()
sa=int(input())\nif sa%4==0:\n    print(4)\nelse:\n    print(0)
n,k = list(map(int, input().split()))\na=list(map(int, input().split()))\n\nlast=''\nm = 0\ns=0\nfor i in a:\n    if i==last:\n        s=1\n    else:\n        s+=1\n    last=i\n    if s>m:\n        m=s\nprint(m)\n
a = list(map(int, input().split()))\nb = list(map(int, input().split()))\nn = int(input())\nn1 = (sum(a) - 1) // 5 + 1\nn2 = (sum(b) - 1) // 10 + 1\nif n1 + n2 <= n:\n    print('YES')\nelse:\n    print('NO')\n
line = input().split()\nn = int(line[0])\nm = int(line[1])\n\nlst = [input()]\nsml = []\nfor i in range(n - 1):\n    lst.append(input())\n    sml.append(False)\n\nans = 0\nfor i in range(m):\n    flag = True\n    for j in range(n - 1):\n        flag = flag and ((lst[j][i] <= lst[j + 1][i]) or sml[j])\n    if flag:\n        for j in range(n - 1):\n            if lst[j][i] < lst[j + 1][i]:\n                sml[j] = True\n    else:\n        ans += 1\n\nprint(str(ans))\n
n = int(input())\ns = input()\n\nans = 0\nfor i in range(n):\n    for j in range(i + 1, n + 1):\n        t = s[i:j]\n        ans += t.count('U') == t.count('D') and t.count('L') == t.count('R')\n\nprint(ans)\n
print(str(oct(int(input()))).count('1'))\n
n=int(input())\nif n&1:\n	print(-1)\nelse:\n	D,R=[False]*(10**6),[0]*(10**6)\n	i,j=0,0\n	while True:\n		D[j]=True\n		R[i]=j\n		i+=1\n		if not D[(j+n)>>1]:\n			j=(j+n)>>1\n		elif not D[j>>1]:\n			j=j>>1\n		else:\n			break\n	print(" ".join(str(R[i]) for i in range(n,-1,-1)))\n
import sys\nimport math\n\nQ = 998244353\nn, m = list(map(int, sys.stdin.readline().strip().split()))\n\nz = [1, 1]\nf = [1, 1]\nfor i in range (0, n):\n    f[0] = f[0] * (n - i) % Q\n    f[1] = f[1] * (n + m - i) % Q\n    z = [(z[0]*f[1]+z[1]*f[0]) % Q, (z[1]*f[1]) % Q]\nans = [z[0] * (m+1), z[1]]\nfor i in range (2, n + 1):\n    ans = [(ans[0] * i * z[1] + ans[1] * m * z[0]) % Q, (ans[1] * i * z[1]) % Q]\ny = ans[1]\nans = ans[0]\nq = Q - 2\nwhile q > 0:\n    if q % 2 == 1:\n        ans = (ans * y) % Q\n    q = q // 2\n    y = (y * y) % Q\nprint(ans)\n
#!/usr/bin/env python3\n\nfrom collections import Counter\n\nn, m = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\n\ntgt = n // m\nb = Counter(a)\nrd = sum(b[x] for x in b if x > m)\nr = 0\n\nfor i in range(1, m+1):\n  while rd and b[i] < tgt:\n    for j in range(n):\n      if a[j] > m:\n        b[a[j]] -= 1\n        b[i] += 1\n        a[j] = i\n        rd -= 1\n        r += 1\n        break\n  while b[i] < tgt:\n    for j in range(n):\n      if b[a[j]] > tgt:\n        b[a[j]] -= 1\n        b[i] += 1\n        a[j] = i\n        r += 1\n        break\n\nprint(tgt, r)\nprint(" ".join(str(x) for x in a))
n = int(input())\nz = 0\nfor i in range(n):\n	x = int(input())\n	if x % 2 == 0:\n		print(x//2)\n	else:\n		if z == 1:\n			print((x-1)//2)\n		else:\n			print((x+1)//2)\n		z = 1 - z
t = input()\nj = t[0]\nd, s = 0, int(j)\nfor i in t[1: ]:\n    if j != i:\n        if d == 1: d, s = 0, s + 1\n        else: d = 1\n        j = i\n    else: d = 1\nprint(s + (d and j == '1'))
import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\n\ndef getN():\n    return int(input())\ndef getList():\n    return list(map(int, input().split()))\nimport math\nfrom bisect import bisect_left\n\nn = getN()\nnums = getList()\n\nif sum(nums) % 2 == 1:\n    print("NO")\n    return\n\nif max(nums) * 2 > sum(nums):\n    print("NO")\n    return\n\nprint("YES")\n
n = int(input())\ns = {1, 7, 9, 10, 11}\nif n < 12:\n	if n in s:\n		print("NO")\n	else:\n		print("YES")\nelif 12 < n < 30:\n	print("NO")\nelif 69 < n < 80:\n	print("NO")\nelif 89 < n:\n	print("NO")\nelse:\n	if n % 10 not in {1, 7, 9}:\n		print("YES")\n	else: print("NO")
def getmask(x):\n    ans = 0\n    for i in range(2, x + 1):\n        while x % (i * i) == 0:\n            x //= i * i\n        if x % i == 0:\n            ans ^= 1 << i\n            x //= i\n    return ans\n\ndef main():\n    maxn = 71\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    cnt = [0] * maxn\n    for i in a:\n        cnt[i] += 1\n    masks = {}\n    for i in range(1, maxn):\n        if cnt[i]:\n            masks[getmask(i)] = masks.get(getmask(i), 0) + cnt[i]\n    while len(masks) > 1 or 0 not in masks:\n        if not masks:\n            print(0)\n            return\n        fixed = max(masks.keys())\n        for i in list(masks.keys()):\n            if i ^ fixed < i:\n                masks[i ^ fixed] = masks.get(i ^ fixed, 0) + masks[i]\n                masks[i] = 0\n        masks[0] = masks.get(0, 0) + masks[fixed] - 1\n        masks[fixed] = 0\n        masks = {i: j for i, j in list(masks.items()) if j > 0}\n    print(pow(2, masks[0], 10**9+7) - 1)\n    \n    \n    \nmain()\n
n = int(input())\nf = []\ns = []\nf1 = s1 = 0\nfor i in range(n, 0, -1):\n	if f1 <= s1:\n		f1 += i\n		f.append(i)\n	else:\n		s1 += i\n		s.append(i)\nprint(abs(f1 - s1))\nprint(len(f), *f)
n, m = list(map(int, input().split()))\na = [-1] * m\nb = []\nf = True\nfor i in range(n):\n    s = input()\n    q = set()\n    for j in range(len(s)):\n        if (s[j] == "#"):\n            q.add(j)\n    for j in range(len(s)):\n        if (s[j] == "#"):\n            if (a[j] == -1):\n                a[j] = i\n            else:\n                if b[a[j]] != q:\n                    f = False\n    b.append(q)\n    #print(a, b, f)\nif f:\n    print("Yes")\nelse:\n    print("No")\n
def make_divisors(n):\n    divisors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\n\n\nn = int(input())\nans = len(make_divisors(n - 1))\ndivisors = []\nfor i in make_divisors(n):\n    j = n\n    if i != 1:\n        while j % i == 0:\n            j //= i\n        if (j - 1) % i == 0:\n            divisors.append(i)\nprint((ans + len(divisors) - 1))\n
h, w = list(map(int, input().split()))\nA = []\n\nfor i in range(h):\n    line = list(map(int, input().split()))\n    A.append(line)\n\nfor i in range(h):\n    line = list(map(int, input().split()))\n    for j, num in enumerate(line):\n        A[i][j] = abs(A[i][j] - num)\n\nconst = 6400\nmask = 1 << const\nDP = [0]*w\nDP[0] = mask >> A[0][0]\n\n\ndef slide_down(y, x):\n    bit = DP[x]\n    delta = A[y+1][x]\n    new1 = bit << delta\n    new2 = bit >> delta\n    DP[x] = new1 | new2\n\n\ndef slide_right(y, x):\n    bit = DP[x]\n    delta = A[y][x+1]\n    new1 = bit << delta\n    new2 = bit >> delta\n    DP[x+1] |= new1 | new2\n\n\nfor y in range(h):\n    for x in range(w):\n        if x < w-1:\n            slide_right(y, x)\n        if y < h-1:\n            slide_down(y, x)\n\npattern = DP[w-1]\nfor i in range(81):\n    if (pattern >> const+i) & 1 or (pattern >> const-i) & 1:\n        print(i)\n        return\n
from collections import defaultdict\n\nN,K = list(map(int, input().split()))\nA = list(map(int, input().split()))\nBMAX = 40\n"""\n・K以下の非負整数の範囲で〜：桁DP感ある\n・XORをとる：桁ごとに確認できる\n・Xを選んで、f = X xor A1 + X xor A2 + ... + X xor AN\n　 -> それぞれのAと毎回 xor 取るのではなく、桁ごとに xor を取ることができる　←　超重要のはず\n　 -> A1 ~ AN の各桁（2進数の時の）に1が立っているのが何個あるか数えておく\n\n\n遷移\ndp[i][1] -> dp[i+1][1] : i-1桁目まででK未満が確定していれば、i桁目に1,0どちらを選んでもK未満\ndp[i][0] -> dp[i+1][1]  : i-1桁目まででKと一致している場合、Kのi桁目が1なら、Xで0を選べば遷移できる\ndp[i][0] -> dp[i+1][0]  : i桁目まで一致させる場合\n"""\n\nd = [0] * BMAX\nfor a in A:\n  for i in range(BMAX):\n    if a & (1 << i):\n      d[i] += 1\n\n# dp[i+1][0] : Xをi桁目まで決めた時に、Kのi桁目までと厳密に一致する　ときの最大値\n# dp[i+1][1] : Xをi桁目まで決めた時に、Kのi桁目までと厳密に一致しないときの最大値\n\ndp = [[-1 for _ in range(2)] for _ in range(BMAX+1)]\n\n\ndp[0][0] = 0\n\nfor i in range(BMAX):\n  now = BMAX-1-i\n  # Xの左からnow桁目に1,0を設定した時にfが増加する量\n  p0 = (2**now) * d[now]\n  p1 = (2**now) * (N - d[now])\n  \n  # Kの左からnow番目に1が立ってるかどうか\n  if K & (1 << now):\n    is_one = True\n  else:\n    is_one = False\n\n  # dp[i][1] -> dp[i+1][1] はXのi桁目に1,0を使えるから、より多い方を採用\n  if dp[i][1] != -1:\n    dp[i+1][1] = dp[i][1] + max(p1, p0)\n\n  # dp[i][0] -> dp[i+1][1] はKのi桁目が1なら可能\n  if dp[i][0] != -1 and is_one:\n    dp[i+1][1] = max(dp[i+1][1], dp[i][0] + p0)\n\n  # dp[i][0] -> dp[i+1][0] \n  if dp[i][0] != -1:\n    dp[i+1][0] = dp[i][0] + (p1 if is_one else p0)    \n\nprint((max(dp[-1])))\n
import bisect,collections,copy,heapq,itertools,math,numpy as np,string,sys\ndef I(): return int(sys.stdin.readline().rstrip())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nN,K = LI()\na = np.array([LI() for _ in range(N)])\ngyou,retu = [],[]\nans = 1\nfor i,j in itertools.combinations(list(range(N)),2):\n    if (a[i,:]+a[j,:]<=K).all():\n        gyou.append((i,j))\nuf_gyou = UnionFind(N)\nfor x,y in gyou:\n    uf_gyou.union(x,y)\nfor x in uf_gyou.parents:\n    if x<=-2:\n        for i in range(2,abs(x)+1):\n            ans *= i\n            ans %= 998244353\na = a.T\nfor i,j in itertools.combinations(list(range(N)),2):\n    if (a[i,:]+a[j,:]<=K).all():\n        retu.append((i,j))\nuf_retu = UnionFind(N)\nfor x,y in retu:\n    uf_retu.union(x,y)\nfor x in uf_retu.parents:\n    if x<=-2:\n        for i in range(2,abs(x)+1):\n            ans *= i\n            ans %= 998244353\nprint(ans)\n
mod = 10 ** 9 + 7\nMAX = 2 * 10 ** 5\n\nfact = [1] * (MAX + 1)\nfor i in range(1, MAX + 1):\n    fact[i] = (fact[i-1] * i) % mod\n\ninv = [1] * (MAX + 1)\nfor i in range(2, MAX + 1):\n    inv[i] = inv[mod % i] * (mod - mod // i) % mod\n\nfact_inv = [1] * (MAX + 1)\nfor i in range(1, MAX + 1):\n    fact_inv[i] = fact_inv[i-1] * inv[i] % mod\n\n\ndef comb(n, k):\n    if n < k:\n        return 0\n    return fact[n] * fact_inv[n-k] * fact_inv[k] % mod\n\n\nn, m, k = list(map(int, input().split()))\n\nans = 0\ncmb = comb(m * n - 2, k - 2)\nfor i in range(1, m):\n    ans += i * (m - i) * n * n * cmb\n    ans %= mod\n\nfor i in range(1, n):\n    ans += i * m * m * (n - i) * cmb\n    ans %= mod\n\nprint(ans)\n
def main():\n    N, K = list(map(int, input().split()))\n    S = list(input())\n    base = S[0]\n    flag = False\n    for i in range(0, N):\n        if K == 0:\n            break\n        if S[i] != base and (not flag):\n            flag = True\n            S[i] = base\n        elif S[i] != base and flag:\n            S[i] = base\n        elif S[i] == base and flag:\n            flag = False\n            K -= 1\n        else:\n            pass\n    \n    ans = 0\n    for i in range(N-1):\n        ans += S[i] == S[i+1]\n    \n    print(ans)\n  \ndef __starting_point():\n    main()\n\n__starting_point()
n=int(input())\n\nL=list(map(int,input().split()))\n\nind=L.index(max(L))\n\nL.remove(max(L))\n\nx=max(L)\n\nprint(ind+1,x)\n
n, m = map(int, input().split())\nt = sorted(map(int, input().split()))\nf, d = [1] * (n + 1), 1000000007\nfor i in range(2, n + 1): f[i] = (f[i - 1] * i) % d\np, q = 0, (f[t[0] - 1] * f[n - t[-1]]) % d\nfor i in range(m - 1):\n    l = t[i + 1] - t[i] - 1\n    q = (q * f[l]) % d\n    if l > 1: p += l - 1\nprint(pow(2, p, d) * f[n - m] * pow(q, d - 2, d) % d)
def main():\n    n, m = [int(i) for i in input().split()]\n    d = [list(input()) for i in range(n)]\n    \n    a = [0] * m\n    for i in range(m):\n        for j in range(n):\n            if d[j][i] == '*':\n                a[i] += 1\n    \n    x = y = 0\n    for i in range(1, m):\n        if a[i] > a[i - 1]: x = max(x, a[i] - a[i - 1])\n        else: y = max(y, a[i - 1] - a[i])\n    \n    print(x, y)\n    \n    \nmain()
n = int(input())\nd = dict()\nfor i in range(n):\n    d[input()] = i\n\nlst = list(d.items())\n\nlst.sort(key=lambda x:-x[1])\n\nfor i in lst:\n    print(i[0])
n,w56=map(int,input().split())\nif(n==1):\n    x=[int(input())]\nelse:\n    x=[int(i) for i in input().split()]\nk,w90=map(int,input().split())\nif(k==1):\n    y=[int(input())]\nelse:\n    y=[int(i) for i in input().split()]\nt=0\nimport collections\nfor i in range(1,35):\n    m=collections.Counter()\n    for j in range(n):\n        m[((x[j]-(2**(i-1)))%(2**i))]+=1\n    for j in range(k):\n        m[(y[j])%(2**i)]+=1\n    t=max(t,max([m[o] for o in m.keys()]))\nif(t>=2):\n    print(t)\nelse:\n    p=0\n    for i in range(len(x)):\n        for j in range(len(y)):\n            if(x[i]==y[j]):\n                print(2)\n                p=1\n                break\n        if(p==1):\n            break\n    if(p==0):\n        print(1)
#!/usr/bin/env python3\n\ntry:\n    while True:\n        s = input()\n        if s[0] in "ah" and s[1] in "18":\n            print(3)\n        elif s[0] in "ah" or s[1] in "18":\n            print(5)\n        else:\n            print(8)\n\nexcept EOFError:\n    pass\n
import sys\nimport math\n\n\ndef main():\n    n,t,k = map(int,sys.stdin.readline().split())\n    a = list(map(int,sys.stdin.readline().split()))\n\n    g = [[] for i in range(t+1)]\n    g[0].append([1,-1,0])\n    c = 1\n    for i in range(t):\n        for j in range(a[i]):\n            c+=1\n            g[i+1].append([c,0,0])\n            g[i][0][2]+=1\n\n    l=0\n    for i in range(1,t+1):\n        for j in range(len(g[i])):\n            if g[i][j][2]==0:\n                l+=1\n    if l< k:\n        print(-1)\n        return\n\n    i=0\n    j=0\n    m = 1\n    while l>k and m<t:\n        while i< len(g[m]) and g[m][i][2]>0:\n            i+=1\n        if i>=len(g[m]):\n            i=0\n            j=0\n            m+=1\n            continue\n        while j<len(g[m+1]) and g[m][g[m+1][j][1]][2]<2:\n            j+=1\n        if j>=len(g[m+1]):\n            i=0\n            j=0\n            m+=1\n            continue\n        g[m][i][2]+=1\n        g[m][g[m+1][j][1]][2]-=1\n        g[m+1][j][1] = i\n        l-=1\n        i+=1\n        j+=1\n\n    if l!=k:        \n        print(-1)\n        return\n    print(n)\n    for i in range(1,t+1):\n        for j in range(len(g[i])):\n            print(g[i][j][0], g[i-1][g[i][j][1]][0])\n\n\nmain()
n = int(input())\na = []\nfor i in range(n):\n	h, m = map(int, input().split(":"))\n	a.append((h + 24) * 60 + m)\n	a.append(h * 60  + m)\na.sort()\nj = 0\ns = 0\nans = 0\nfor i in range(0, 48 * 60):\n	if (j < 2 * n and a[j] == i):\n		ans = max(ans, s)\n		s = 0\n		j += 1\n		continue\n	else:\n		s += 1\nh = ans // 60\nm = ans % 60\nhans = ""\nmans = ""\nif h < 10:\n	hans = "0" + str(h)\nelse:\n	hans = str(h)\nif m < 10:\n	mans = "0" + str(m)\nelse:\n	mans = str(m)\nprint(hans + ":" + mans)
import sys\ninput = sys.stdin.readline\n\nn = int(input())\nadj = [[] for i in range(n)]\nfor _ in range(n - 1):\n    u, v = list(map(int, input().split()))\n    adj[u-1].append(v-1)\n    adj[v-1].append(u-1)\n\ndepth = [-1] * n\ndepth[0] = 0\n    \nodd = 0\neven = 1\n\nq = [0]\nwhile q:\n    nex = q.pop()\n    for v in adj[nex]:\n        if depth[v] == -1:\n            depth[v] = depth[nex] + 1\n            if depth[v] & 1:\n                odd += 1\n            else:\n                even += 1\n            q.append(v)\n\nprint(min(odd,even) - 1)\n
n = int(input())\nprint((n-2)**2)
ans = 1000000000\nn, k = [int(i) for i in input().split()]\ns = input()\nl = len(s)\nd = [k // 2, (k + 1) // 2]\nnearl = [0] * n\nnearr = [0] * n\nlast = 1000000000\nfor i in range(n):\n    if s[i] == '0':\n        last = i\n    nearl[i] = last\nfor i in range(n - 1, -1, -1):\n    if s[i] == '0':\n        last = i\n    nearr[i] = last\nfor i in d:\n    itl = 0\n    nf = 0\n    itr = 0\n    while s[itl] == '1':\n        itl += 1\n    cnt = 0\n    nf = itl\n    while cnt < i:\n        cnt += 1\n        nf += 1\n        while s[nf] == '1':\n            nf += 1\n    cnt = 0\n    itr = nf\n    while cnt < k - i:\n        cnt += 1\n        itr += 1\n        while s[itr] == '1':\n            itr += 1\n    while True:\n        pos = (itr + itl) // 2\n        pos1 = nearl[pos]\n        ans = min(ans, max(pos1 - itl, itr - pos1))\n        pos1 = nearr[pos]\n        ans = min(ans, max(pos1 - itl, itr - pos1))\n        itr += 1\n        while itr < l and s[itr] == '1':\n            itr += 1\n        if itr == l:\n            break\n        itl += 1\n        while s[itl] == '1':\n            itl += 1\nprint(ans)
n, a = list(map(int, input().split()))\nx = list(map(int, input().split()))\n\na -= 1\n\nresult = x[a]\n\nfor i in range(1, n + 1):\n    le = a - i\n    rg = a + i\n\n    le_i = le >= 0 and le < n\n    rg_i = rg >= 0 and rg < n\n    if not le_i and not rg_i:\n        break\n\n    if le_i and not rg_i:\n        result += x[le]\n    elif not le_i and rg_i:\n        result += x[rg]\n    else:\n        if x[le] == x[rg] == 1:\n            result += 2\n\nprint(result)\n
import copy\n\ndef solve():\n    n = int(input())\n    a = [int(c)-1 for c in input().split(' ')]\n\n    nextcard = [[-1 for i in range(8)] for j in range(n)]\n    for i in range(n-2, -1, -1):\n        nextcard[i] = copy.copy(nextcard[i+1])\n        nextcard[i][a[i+1]] = i+1\n\n    jump = [[-1 for i in range(n+1)] for j in range(n)]\n    for i in range(n):\n        card = a[i]\n        cpos = i\n        j = 1\n        \n        while cpos != -1:\n            jump[i][j] = cpos\n            j+=1\n            cpos = nextcard[cpos][card]\n\n    #Find dp solution for range (val, val+1)\n    def getLen(val):\n        dp = [[-1 for i in range(1<<8)] for j in range(n+1)]\n        dp[0][0] = 0\n\n        for i in range(n):\n            card = a[i]\n            for comb in range(1<<8):\n                if (comb & (1<<card)) == 0 and dp[i][comb] != -1:\n                    ncomb = comb + (1<<card)\n                    \n                    if jump[i][val] != -1:\n                        j = jump[i][val]+1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val)\n                        \n                    if jump[i][val+1] != -1:\n                        j = jump[i][val+1]+1\n                        dp[j][ncomb] = max(dp[j][ncomb], dp[i][comb] + val + 1)\n\n                dp[i+1][comb] = max(dp[i+1][comb], dp[i][comb])\n\n        return dp[n][(1<<8)-1]\n\n    appear = [False for i in range(8)]\n    for c in a:\n        appear[c] = True\n\n    result = 0\n    for c in appear:\n        result += int(c)\n\n    #Finally binary search to find the result\n\n    cur = 0\n    for lev in range(9, -1, -1):\n        tpow = (1<<lev)\n        if cur + tpow < n:\n            ret = getLen(cur + tpow)\n\n            if(ret != -1):\n                result = max(result, ret)\n                cur += tpow\n\n    return result\n\nprint(solve())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n
n = int(input())\n\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ndef try_solve(t):\n    for i in range(n-1):\n        ok = False\n\n        for x in range(4):\n            if a[i] == t[i] | x and b[i] == t[i] & x:\n                t.append(x)\n                ok = True\n                break\n\n        if not ok:\n            return False\n\n    return True\n\nok = False\n\nfor x in range(4):\n    t = [x]\n\n    if try_solve(t):\n        print("YES")\n        print(" ".join(map(str, t)))\n        ok = True\n        break\n\nif not ok:\n    print("NO")\n
n = int(input())\na = [-1]*100001\np = 0\nfor i in range(n):\n    x, k = map(int, input().split())\n    if a[k] < x-1:\n        p = 1\n    else:\n        a[k] = max(a[k],x)\nif p:\n    print('NO')\nelse:\n    print('YES')
def dfs(i):\n    if i >= 2 ** n:\n        return 0, 0\n    x1, m1 = dfs(i * 2)\n    x2, m2 = dfs(i * 2 + 1)\n    if m1 + a[i * 2] < m2 + a[i * 2 + 1]:\n        return x1 + x2 + m2 + a[i * 2 + 1] - m1 - a[i * 2], m2 + a[i * 2 + 1]\n    return x1 + x2 + m1 + a[i * 2] - m2 - a[i * 2 + 1], m1 + a[i * 2]\nn = int(input())\na = [0, 0] + [int(i) for i in input().split()]\nprint(dfs(1)[0])
n = int(input())\nmoves = input()\n\nturns_vasnja = int((len(moves)-1) / n)\n\ncount = 0\nfor i in range(1, turns_vasnja+1):\n    if moves[n * i - 3] == moves[n * i - 2] == moves[n * i - 1]:\n        count += 1\n\nprint(count)\n
n=int(input())\nans=0\nfor i in range(n):\n    a,b=map(int,input().split())\n    if b-a>=2: ans+=1\nprint(ans)
n, k = map(int, input().split())\nA = list(map(int, input().split()))\n\nans = 0\nfor i in range(k):\n    c1 = c2 = 0\n    for j in range(i, n, k):\n        if A[j] == 1:\n            c1 += 1\n        else:\n            c2 += 1\n    ans += min(c1, c2)\nprint(ans)
x=int(input())\nprint(round(x*x*(x+1)/2-(x*(x+1)*((2*x)+1)/6)+(x)))\n\n
n, k = list(map(int, input().split()))\n\nMOD = 10**9+7\n\n\ndef fast_modinv(up_to, M):\n    ''' Fast modular inverses of 1..up_to   modulo M. '''\n    modinv = [-1 for _ in range(up_to + 1)]\n    modinv[1] = 1\n    for x in range(2, up_to + 1):\n        modinv[x] = (-(M//x) * modinv[M%x])%M\n    return modinv\n\nmaxn = 2*10**5 + 10\nmodinv = fast_modinv(maxn, MOD)\nfact, factinv = [1], [1]\nfor i in range(1, maxn):\n    fact.append(fact[-1]*i % MOD)\n    factinv.append(factinv[-1]*modinv[i] % MOD)\n\n\ndef Stirling(n, k):\n    '''The Stirling number of second kind (number of nonempty partitions). '''\n    if k > n:\n        return 0\n    result = 0\n    for j in range(k+1):\n        result += (-1 if (k-j)&1 else 1) * fact[k] * factinv[j] * factinv[k - j] * pow(j, n, MOD) % MOD\n        result %= MOD\n    result *= factinv[k]\n    return result % MOD\n\nW = sum(map(int, input().split())) % MOD\nprint((Stirling(n, k) + (n - 1) * Stirling(n - 1, k))* W % MOD)\n
import sys\nf = sys.stdin\n#f = open("input.txt", "r")\na = [list(map(int, i.split())) for i in f.read().strip().split("\n")]\ndef solve():\n    s = a[0][2] + a[2][0]\n    for i in range(1, s):\n        a[0][0] = i\n        a[2][2] = s-i\n        if sum(a[0]) == sum(a[2]):\n            break\n    a[1][1] = sum(a[0]) - sum(a[1])\n    for i in a:\n        print(*i)\nsolve()
n = int(input())\na = list(map(int, input().split()))\nmx = -1\nfor step, elem in enumerate(a):\n    if elem > mx + 1:\n        print(step + 1)\n        return\n    else:\n        mx = max(mx, elem)\nprint(-1)\n
n, m = [int(i) for i in input().split()]\nf = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\na = [-1] * 100001\nfor i in range(n):\n	if a[f[i]] != -1:\n		a[f[i]] = -2\n	else:\n		a[f[i]] = i\nfor i in b:\n	if a[i] == -1:\n		print('Impossible')\n		return\nfor i in b:\n	if a[i] == -2:\n		print('Ambiguity')\n		return\nprint('Possible')\nfor i in b:\n	print(a[i] + 1, end=' ')
n = int(input())\ns = sum(list(map(int, input().split())))\nm = int(input())\nfor i in range(m):\n	l, r = list(map(int, input().split()))\n	s = max(s, l)\n	if l <= s <= r:\n		print(s)\n		return\nprint(-1)\n\n\n\n
\nfrom collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_str(): return list(sys.stdin.readline().split())\n\n\ndef gcd(a,b):\n	while b:\n		a,b = b, a%b\n	return a\n\nT = inp()\nfor _ in range(T):\n    a,b,k = inpl()\n    a,b = min(a,b), max(a,b)\n\n    n = gcd(a,b)\n    # while n < b:\n    #     n += a\n    #     cnt += 1\n    cnt = -((n-b)//a)\n\n\n    if cnt >= k:\n        print("REBEL")\n    else:\n        print("OBEY")\n
n = int(input())\n\ndata = []\n\nfor i in range(n):\n    a, b = list(map(int, input().split()))\n    data.append([a, b])\n\n\nans  = True\nprev = max(data[0])\nfor i in range(1, n):\n    a, b = data[i]\n    a, b = min(a, b), max(a,b)\n    \n    if a > prev:\n        ans = False\n        break\n\n    if a <= prev < b:\n        prev = a\n        continue\n\n    if prev >= b:\n        prev = b\n\n\nif ans :\n    print("YES")\nelse:\n    print('NO')\n
n=int(input())\nC=[0]+list(map(int,input().split()))\n\n#n=5000\n#C=list(range(n+1))\n\nA=[]\nfor i in range(1,n+1):\n    if C[i]!=C[i-1]:\n        A.append(C[i])\n\nL=len(A)\nDP=[[[0]*L for i in range(L)] for j in range(2)]\n#左の色に揃える or 右の色に揃える,左からi～j番目を\n\ndef color(r,i,j):#i<j\n    if r==1:\n        if A[i]==A[j]:\n            DP[r][i][j]=min(DP[0][i][j-1],DP[1][i][j-1]+1)\n        else:\n            DP[r][i][j]=min(DP[0][i][j-1]+1,DP[1][i][j-1]+1)\n\n    else:\n        if A[i]==A[j]:\n            DP[r][i][j]=min(DP[1][i+1][j],DP[0][i+1][j]+1)\n        else:\n            DP[r][i][j]=min(DP[1][i+1][j]+1,DP[0][i+1][j]+1)\n\nfor i in range(1,L):\n    for j in range(L-i):\n        color(0,j,i+j)\n        color(1,j,i+j)\n\n    #print(DP)\n\nprint(min(DP[0][0][L-1],DP[1][0][L-1]))\n
k, pa, pb = list(map(int, input().split()))\n\nMOD = 10**9 + 7\nINF = ((pa + pb) * pow(pb, MOD-2, MOD)) % MOD\nrAB = pow(pa+pb, MOD-2, MOD)\nrB = pow(pb, MOD-2, MOD)\n\nmemo = {}\n\ndef dfs(a, ab):\n    if ab >= k:\n        return ab\n    if a + ab >= k:\n        #return INF\n        #return (pa + pb) / pb\n        return ((a + MOD-1) + (pa + pb) * rB + ab) % MOD\n        return a - 1 + (pa + pb) / pb + ab\n    if (a, ab) in memo:\n        return memo[a, ab]\n    #res = (((dfs(a+1, ab)+1) * pa * rAB) + ((dfs(a, ab+a)+1) * pb * rAB)) % MOD\n    #res = (dfs(a+1, ab)) * pa / (pa + pb) + (dfs(a, ab+a)) * pb / (pa + pb)\n    res = (dfs(a+1, ab) * pa * rAB) + (dfs(a, ab+a) * pb * rAB)\n    #print(a, ab, res)\n    memo[a, ab] = res = res % MOD\n    return res\n#print((dfs(1, 0) * pa * rAB + 1) % MOD)\n#print((pb + dfs(1, 0)*pa) / pa)\nprint(dfs(1, 0))\n
start = input()\ncounter = 0\nsInt = int(start)\nwhile sInt!=0:\n	sInt-=max([int(c) for c in start])\n	start=str(sInt)\n	counter+=1\nprint(counter)
import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\n\nANS=[[-1]*m for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        if ANS[i][j]==-1:\n            for koma in ["A","B","C","D","E","F"]:\n                for k,l in [(i-1,j),(i,j-1),(i+1,j),(i,j+1)]:\n                    if 0<=k<n and 0<=l<m and ANS[k][l]==koma:\n                        break\n                else:\n                    nkoma=koma\n                    break\n\n            MAXlength=1\n            if nkoma=="A":                \n                for length in range(1,101):\n                    if i+length>=n or j+length>=m:\n                        break\n                    \n                    for k,l in [(i-1,j+length),(i+length,j-1)]:\n                        if 0<=k<n and 0<=l<m and ANS[k][l]==nkoma:\n                            break\n                        if 0<=i<n and ANS[i][j+length]!=-1:\n                            break\n                    else:\n                        MAXlength=length+1\n\n            elif nkoma=="B":\n                for length in range(1,101):\n                    if i+length>=n or j+length>=m:\n                        break\n\n                    flag=0\n                    if 0<=i-1<n and ANS[i-1][j+length]=="A":\n                        flag=1\n                    if 0<=j-1<m and ANS[i+length][j-1]==nkoma:\n                        break\n                    if 0<=i<n and ANS[i][j+length]!=-1:\n                        break\n\n                    if flag==1:\n                        MAXlength=length+1\n                    else:\n                        break\n                \n\n            for k in range(i,i+MAXlength):\n                for l in range(j,j+MAXlength):\n                    ANS[k][l]=nkoma\n\nfor a in ANS:\n    print("".join(a))\n                    \n                \n
N,M=map(int,input().split())\n\nif M%2==0:\n  for i in range(M//2):\n    print(i+1,M-i)\n  for i in range(M//2):\n    print(M+i+1,2*M-i+1)  \nelse:\n  for i in range(M//2):\n    print(i+1,M-i)\n  for i in range(M//2+1):\n    print(M+i+1,2*M-i+1)
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport time,random\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\nmod2 = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\n\nclass Prime():\n    def __init__(self, n):\n        self.M = m = int(math.sqrt(n)) + 10\n        self.A = a = [True] * m\n        a[0] = a[1] = False\n        self.T = t = [2]\n        for j in range(4, m, 2):\n            a[j] = False\n        for i in range(3, m, 2):\n            if not a[i]:\n                continue\n            t.append(i)\n            for j in range(i*i,m,i):\n                a[j] = False\n        self.ds_memo = {}\n        self.ds_memo[1] = set([1])\n\n    def is_prime(self, n):\n        return self.A[n]\n\n    def division(self, n):\n        d = collections.defaultdict(int)\n        for c in self.T:\n            while n % c == 0:\n                d[c] += 1\n                n //= c\n            if n < 2:\n                break\n        if n > 1:\n            d[n] += 1\n        return d.items()\n\n    # memo\n    def divisions(self, n):\n        if n in self.ds_memo:\n            return self.ds_memo[n]\n\n        for c in self.T:\n            if n % c == 0:\n                rs = set([c])\n                for cc in self.divisions(n // c):\n                    rs.add(cc)\n                    rs.add(cc * c)\n                self.ds_memo[n] = rs\n                return rs\n\n        rs = set([1, n])\n        self.ds_memo[n] = rs\n        return rs\n\ndef main():\n    n,k = LI()\n    pr = Prime(10**5)\n    c = collections.defaultdict(int)\n    for i in range(k, 0, -1):\n        t = k // i\n        p = (pow(t, n, mod) + c[i]) % mod\n        ds = pr.divisions(i)\n        for kk in ds:\n            if kk == i:\n                continue\n            c[kk] -= p\n        c[i] = p\n\n    r = sum(k*v%mod for k,v in c.items()) % mod\n\n    return r\n\nprint(main())\n\n\n\n
import math\n\n\ndef LI():\n    return list(map(int, input().split()))\n\n\nN = int(input())\nA = LI()\nAmin = min(A)\nans = Amin\nfor i in A:\n    if Amin == i:\n        continue\n    Amin = min(Amin, math.gcd(Amin, i))\nans = min(ans, math.gcd(Amin, ans))\n\nprint(ans)\n
n = int(input())\na = list(map(int, input().split()))\n\nif n == 2:\n  if a[0] >= a[1] and (a[0] - a[1]) % 2 == 0:\n    print((a[0] - a[1]) // 2)\n  else:\n    print(-1)\nelse:\n  num = 0\n  for i in range(2, n):\n    num ^= a[i]\n  \n  _and = (a[0] + a[1] - num)\n  if  _and % 2 != 0 or a[0] < _and // 2 or (_and // 2) & num != 0:\n    print(-1)\n  else:\n    _and //= 2\n    \n    max_2 = 1\n    while max_2 <= num:\n      max_2 *= 2\n    \n    a0 = _and\n    while max_2 >= 1:\n      if num & max_2 != 0 and a0 + max_2 <= a[0]:\n        a0 += max_2\n      max_2 //= 2\n    \n    if a0 != 0:\n      print(a[0] - a0)\n    else:\n      print(-1)
import sys\nimport numpy as np\nimport math\nimport collections\nimport copy\nimport decimal\nfrom collections import deque \nfrom functools import reduce\nfrom itertools import product\nfrom itertools import combinations\nN, X, M = list(map(int, input().split()))\n\n# X^2がMより大きい場合はMで割った余り、小さければそのままを返却\ndef f(X, M):\n    if X**2 >= M:\n        return X**2 % M\n    else:\n        return X**2\n\nappear = np.full(M, -1)\nseq = []\nfx = X\nappear[fx] = 0\nseq.append(fx)\nfor i in range(1, N):\n    fx = f(fx, M)\n#     print(fx, appear[fx])\n    if appear[fx] != -1:\n        loop_st = appear[fx]\n        loop_en = i\n        break\n    seq.append(fx)\n    appear[fx] = i\nseq.insert(0, 0)\nseq_sum = np.cumsum(seq)\n\nif N <= len(seq)-1 :\n    print((seq_sum[N]))\nelse:\n    # ループの前まで\n    lp_b = seq_sum[loop_st-1]\n    # ループしている個数を求める\n    loop_num = (len(seq_sum)-1) - loop_st\n    # 商はループ回数、余りはループしきらなかった分\n    qu = (N-(loop_st)) // loop_num\n    mo = (N-(loop_st)) % loop_num\n    # ループした分だけかける\n    lp_sum = (seq_sum[-1] - seq_sum[loop_st]) * qu\n    # 最後の余りの部分を加算\n    lp_en = seq_sum[loop_st+mo] - seq_sum[loop_st-1]\n    print((lp_b+lp_sum+lp_en))\n    \n
for _ in range(int(input())):\n    n = int(input())\n    digits = list(map(int,list(input())))\n    if n % 2 == 1:\n        containsOdd = False\n        for i in range(0,n,2):\n            if digits[i] % 2 == 1:\n                containsOdd = True\n        if containsOdd:\n            print(1)\n        else:\n            print(2)\n    else:\n        containsEven = False\n        for i in range(1,n,2):\n            if digits[i] % 2 == 0:\n                containsEven = True\n        if containsEven:\n            print(2)\n        else:\n            print(1)\n
a,m = map(int,input().split())\n\nfor i in range(100000):\n    if a%m==0:\n        print("Yes")\n        quit()\n    else:\n        a+=a%m\nprint("No")
n = int(input())\narr = [int(x) for x in input().split()]\narr.sort()\nif(n%2):\n    print(arr[n//2])\nelse:\n    print(arr[n//2-1])
n, m, k = input().split(' ')\nn = int(n)\nm = int(m)\nk = int(k)\nind = []\npre = []\n\nfor _ in range(n):\n    s = input()\n    ind.append([])\n    for i, c in enumerate(s):\n        if c == '1':\n            ind[-1].append(i)\n\nfor i in range(n):\n    pre.append([])\n    for j in range(k + 1):\n        pre[i].append([])\n        if len(ind[i]) > j:\n            pre[i][j] = ind[i][-1] - ind[i][0] + 1\n        else:\n            pre[i][j] = 0\n            continue\n        for x in range(j + 1):\n            y = len(ind[i]) - 1 - j + x\n\n            if y >= x and ind[i][y] - ind[i][x] + 1 < pre[i][j]:\n                pre[i][j] = ind[i][y] - ind[i][x] + 1\ndp = [[]]\n\nfor i in range(k + 1):\n    dp[0].append(pre[0][i])\n\n\nfor i in range(1, n):\n    dp.append([])\n    for j in range(0, k + 1):\n        dp[i].append(pre[i][j] + dp[i - 1][0])\n        for z in range(j + 1):\n            dp[i][j] = min(dp[i][j], dp[i - 1][z] + pre[i][j - z])\n\nprint(dp[n - 1][k])\n
a,b,w,x,c=list(map(int,input().split()))\nans=0\nbb=b\nbenefit=0\nVisited=[False]*1003\nCycleCost=-1\nwhile(1):\n    if(c<=a):\n        break\n    if(Visited[b]!=False):\n        CycleCost=ans-Visited[b][1]\n        CycleBenefit=benefit-Visited[b][0]\n        CycleBegining=b\n        break\n    Visited[b]=(benefit,ans)\n    if(b<x):\n        b=w-(x-b)\n        ans+=1\n    elif(b>=x):\n        b-=x\n        ans+=1\n        benefit+=1\n    if(benefit==c-a):\n        break\n\nif(CycleCost==-1):\n    print(ans)\nelse:\n    c-=benefit\n    diff=c-a\n    xx=diff//CycleBenefit\n    if(xx!=0):\n        xx-=1\n        ans+=xx*CycleCost\n        diff-=xx*CycleBenefit\n    b=CycleBegining\n    while(diff>0):\n        if(b<x):\n            b=w-(x-b)\n            ans+=1\n        else:\n            b-=x\n            ans+=1\n            diff-=1\n    print(ans)\n        \n
import re\nimport itertools\nfrom collections import Counter, deque\n\nclass Task:\n    n, m = 0, 0\n    graph = []\n    answer = ""\n	\n    def getData(self):\n        self.n, self.m = [int(x) for x in input().split(' ')]\n        for i in range(0, self.m):\n            self.graph += [[int(x) for x in input().split(' ')]]\n\n        #inFile = open('input.txt', 'r')\n        #inFile.readline().rstrip()\n        #self.childs = inFile.readline().rstrip()\n\n    def solve(self):\n        graph = self.graph\n        vertexDegrees = [0] * (self.n + 1)\n        for edge in graph:\n            vertexDegrees[edge[0]] += 1\n            vertexDegrees[edge[1]] += 1\n        vertexDegrees = vertexDegrees[1:]\n        if vertexDegrees.count(2) == len(vertexDegrees):\n            self.answer = 'ring topology'\n            return\n        if vertexDegrees.count(1) == 2 and vertexDegrees.count(2) == \\n                len(vertexDegrees) - 2:\n            self.answer = 'bus topology'\n            return\n        if vertexDegrees.count(1) == len(vertexDegrees) - 1:\n            self.answer = 'star topology'\n            return\n        self.answer = 'unknown topology'\n\n    def printAnswer(self):\n        print(re.sub(r'[\[\],]', '', str(self.answer)))\n        #print(self.answer[:6])\n        #outFile = open('output.txt', 'w')\n        #outFile.write(self.answer)\n\ntask = Task()\ntask.getData()\ntask.solve()\ntask.printAnswer()\n
def main():\n    n = int(input())\n    a = [input() for i in range(n)]\n    \n    result = 0\n    for i in range(26):\n        for j in range(i + 1, 26):\n            t = 0\n            ci = chr(i + ord('a'))\n            cj = chr(j + ord('a'))\n            for s in a:\n                if s.count(ci) + s.count(cj) == len(s):\n                    t += len(s)\n            result = max(result, t)\n    \n    print(result)\n    \n    \n    \nmain()
n = int(input())\nm = [int(i) for i in input().split()]\n\ndm = [0 for i in range(n)]\n\ndm[-1] = m[-1] + 1\n\nfor i in range(n - 2, -1, -1):\n    dm[i] = max(m[i] + 1, m[i+1], dm[i+1]-1)\n#print(dm)\nfor i in range(1, n):\n    dm[i] = max(dm[i], dm[i-1])\n#print(dm)\n\nprint(sum([dm[i] - 1 - m[i] for i in range(n)]))\n
#!/usr/bin/env python3\n\ndef main():\n    try:\n        while True:\n            n = int(input())\n            s = input()\n            result = ""\n            for m, c in enumerate(reversed(s)):\n                result = result[:m >> 1] + c + result[m >> 1:]\n\n            print(result)\n\n    except EOFError:\n        pass\n\nmain()\n
import math\nMOD = int( 1e9 + 7 )\n\nN, M = map( int, input().split() )\nsn = int( math.sqrt( N ) )\n\nans = N * M % MOD\nfor i in range( 1, min( sn, M ) + 1, 1 ):\n  ans -= N // i * i\n\nans %= MOD\nif N // ( sn + 1 ) > M:\n  exit( print( ans ) )\n\nfor f in range( N // ( sn + 1 ), 0, -1 ):\n  s = lambda x: x * ( x + 1 ) // 2\n  if N // f > M:\n    ans -= f * ( s( M ) - s( N // ( f + 1 ) ) )\n    break\n  ans -= f * ( s( N // f ) - s( N // ( f + 1 ) ) )\n\nans %= MOD\nif ans < 0:\n  ans += MOD\nprint( ans )\n
n, m, k = map(int, input().split())\ns, t = input(), input()\n\nn += 1\nm += 1\n\np = [i for i in range(n * m - n) if (i + 1) % n]\nr = p[::-1]\n\nd = [0] * n * m\n\nfor i in p:\n    if s[i % n] == t[i // n]: d[i] = d[i - n - 1] + 1\n\nf = d[:]\n\nfor y in range(k - 1):\n    for i in p: f[i] = max(f[i], f[i - 1], f[i - n])\n    for i in r: f[i] = f[i - d[i] * (n + 1)] + d[i]\n\nprint(max(f))
s = input()\nli = s.count("L")\nri = s.count("R")\nui = s.count("U")\ndi = s.count("D")\nn = len(s)\nif n % 2 != 0:\n    print(-1)\nelse:\n    print((abs(li-ri)+abs(di-ui))//2)\n
from sys import stdin, stdout\n\n\ndef __starting_point():\n\n    def omkar_and_last_floor(a, n, m):\n\n        dp = [[0 for c in range(m)] for r in range(m)]\n\n        #print(dp)\n        for r in range(m):\n            for l in range(r,-1,-1):\n                for k in range(l, r+1):\n                    cnt = 0\n                    for i in range(n):\n                        if l <= a[i][k][0] and a[i][k][1] <= r:\n                            cnt += 1\n                    lr = cnt*cnt\n                    if k-1 >= l:\n                        lr += dp[l][k-1]\n                    if k+1 <= r:\n                        lr += dp[k + 1][r]\n\n                    dp[l][r] = max(dp[l][r], lr)\n        #print(dp)\n        return dp[0][m-1]\n\n\n    n, m = list(map(int, stdin.readline().split()))\n    a = [[[0,0] for c in range(m)] for r in range(n)]\n    for i in range(n):\n        k = int(stdin.readline())\n        for j in range(k):\n            l, r = list(map(int, stdin.readline().split()))\n            for x in range(l, r+1):\n                a[i][x-1][0] = l-1\n                a[i][x-1][1] = r-1\n\n    print(omkar_and_last_floor(a, n, m))\n\n\n__starting_point()
"""\nCodeforces Contest 261 Div 2 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef main():\n    n, = read()\n    a = read()\n    mn = 10**9+1\n    mncount = 0\n    mx = 0\n    mxcount = 0\n    for i in range(n):\n        if a[i] < mn:\n            mn = a[i]\n            mncount = 1\n        elif a[i] == mn:\n            mncount += 1\n        if a[i] > mx:\n            mx = a[i]\n            mxcount = 1\n        elif a[i] == mx:\n            mxcount += 1\n    if mx != mn:\n        print(mx-mn, mncount*mxcount)\n    else:\n        print(0, n*(n-1)//2)\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
n, m = list(map(int, input().split()))\ns = list(input())\na = []\nfor _ in range(m):\n	l, r, c1, c2 = input().split()\n	l, r = int(l) - 1, int(r) - 1\n	for i in range(l, r + 1):\n		if s[i] == c1:\n			s[i] = c2\nprint(''.join(s))\n\n
import sys\n\nn, k = list(map(int, sys.stdin.readline().strip().split()))\nL = []\nR = []\nA = []\nfor i in range (0, n):\n    x = list(map(int, sys.stdin.readline().strip().split()))\n    L.append(x[0])\n    R.append(x[1])\n    A.append(x[2])\nL.append(R[-1])\ni = n-1\nx = 0\ny = 0\nans = 0\nv = True\nN = [0 for i in range (0, n)]\nwhile i >= 0:\n    if R[i] == L[i+1]:\n        x = max(x + A[i] - k * (R[i] - L[i]), 0)\n        N[i] = x\n    else:\n        x = max(A[i] - k * (R[i] - L[i]), 0)\n        N[i] = x\n    if N[i] > k:\n        v = False\n    i = i - 1\nm = k\nN.append(0)\ni = 0\nwhile i < n and v == True:\n    if m < N[i]:\n        ans = ans + m\n        m = k\n    m = m - A[i]\n    ans = ans + A[i]\n    while m < 0:\n        m = m + k\n    i = i + 1\nif v == True:\n    print(ans)\nelse:\n    print(-1)
w, r = open('output.txt', 'w'), open('input.txt', 'r')\ns, y = [0] * 466, [0, 100, 131, 159, 190, 220, 251, 281, 312, 343, 373, 404, 434]\nfor i in range(int(r.readline())):\n    m, d, p, t = map(int, r.readline().split())\n    x = y[m] + d\n    s[x] -= p\n    s[x - t] += p\nfor i in range(465):\n    s[i + 1] += s[i]\nw.write(str(max(s)))
match = 0\nnonmatch = 0\ncount = 0\n\ndef calc_match(s, t, p):\n  nonlocal match\n  nonlocal nonmatch\n  nonlocal count\n  if p == len(s)-len(t):\n    return\n  if p+len(t) < len(s):\n    if s[p+len(t)] == '?':\n      count -= 1\n    elif s[p+len(t)] == t[-1]:\n      match -= 1\n    else:\n      nonmatch -= 1\n  match, nonmatch = nonmatch, match\n  if p+len(t) < len(s):\n    if s[p] == '?':\n      count += 1\n    elif s[p] == 'a':\n      match += 1\n    else:\n      nonmatch += 1\n\ndef init_match(s, t):\n  nonlocal match\n  nonlocal nonmatch\n  nonlocal count\n  p = len(s)-len(t)\n  for i in range(len(t)):\n    if s[p+i] == '?':\n      count += 1\n    elif s[p+i] == t[i]:\n      match += 1\n    else:\n      nonmatch += 1\n\n\n\nn = int(input())\ns = input()\nm = int(input())\nt = ""\nfor i in range(m):\n  if i%2==0:\n    t = t + 'a'\n  else:\n    t = t + 'b'\n\ninit_match(s,t)\n\ndp = []\nfor i in range(n+3):\n  dp.append((0, 0))\n\np = n-m\nwhile p >= 0:\n  calc_match(s, t, p)\n  if nonmatch == 0:\n    if dp[p+1][0] == dp[p+m][0]+1:\n      dp[p] = (dp[p+1][0], min(dp[p+1][1], dp[p+m][1]+count))\n    elif dp[p+1][0] > dp[p+m][0]+1:\n      dp[p] = dp[p+1]\n    else:\n      dp[p] = (dp[p+m][0]+1, dp[p+m][1]+count)\n  else:\n    dp[p] = dp[p+1]\n  p -= 1\n\nprint(dp[0][1])
n = int(input())\nA = list(map(int, input().split()))\nA.sort()\nprev = -1\nres = 0\n\nfor x in A:\n    if x > prev:\n        prev = x\n    else:\n        prev = prev + 1\n        res += prev - x\nprint(res)\n
n, m = [int(i) for i in input().split()]\nd = set()\nfor i in range(n):\n	_, *a = [int(i) for i in input().split()]\n	d |= set(a)\n\nif len(d) == m:\n	print("YES")\nelse:\n	print("NO")\n
import math\nimport bisect\n\n\nn, x, k = list(map(int, input().split()))\na = sorted(list(map(int, input().split())))\nans = 0\n\nfor num in a:\n    l = math.ceil(num/x)*x + (k-1)*x\n    r = l + x - 1\n    l = num if l < num else l\n    # print(l, r, bisect.bisect_left(a, l), bisect.bisect_right(a, r), bisect.bisect_right(a, r) - bisect.bisect_left(a, l))\n    ans += bisect.bisect_right(a, r) - bisect.bisect_left(a, l)\n\nprint(ans)\n\n\n'''\n7 3 2\n1 3 5 9 11 16 25\n'''\n\n'''\n4 2 0\n5 3 1 7\n'''\n
am=0\nx = int(input())\nl = list(map(int, input().split(' ')))\nm = min(l)\nk = [i for i in range(x) if l[i] == m]\nk.append(k[0]+x)\nfor i in range(len(k)-1):\n    am = max(am, k[i+1]-k[i])\n\nprint(m * x + am - 1)\n
import fractions\ncount = 0\na = int(input())\n#n\n\nlistx = list(map(int, input().split(' ')))\nlisty = list(map(int, input().split(' ')))\nlistx.remove(listx[0])\nlisty.remove(listy[0])\nlistx = set(listx)\nlisty = set(listy)\nlistz = listx.union(listy)\nlistz=list(listz)\nlistw = [i+1 for i in range(a)]\nif listz == listw:\n    print("I become the guy.")\n\nelse:\n    print("Oh, my keyboard!")\n
def f(x, y, a, b, n):\n    return a + (x - a) * cos[n] - (y - b) * sin[n], b + (x - a) * sin[n] + (y - b) * cos[n]\n\n\ndef check(p):\n    d = {}\n    for i in range(len(p) - 1):\n        for j in range(i + 1, len(p)):\n            dist = (p[i][0] - p[j][0]) ** 2 + (p[i][1] - p[j][1]) ** 2\n            d[dist] = d.get(dist, 0) + 1\n    if len(d) != 2:\n        return 0\n    a, b = sorted(d)\n    return 2 * a == b and d[a] == 4 and d[b] == 2\n\n\ncos, sin, variants = [1, 0, -1, 0], [0, 1, 0, -1], [[x, y, z, a] for x in range(4) for y in range(4) for z in range(4) for a in range(4)]\nfor t in range(int(input())):\n    moles, ans = [list(map(int, input().split())) for x in range(4)], 13\n    for a in variants:\n        if check([f(moles[i][0], moles[i][1], moles[i][2], moles[i][3], a[i]) for i in range(4)]):\n            ans = min(ans, sum(a))\n    print(ans if ans != 13 else -1)\n
def read_data():\n    n, m = map(int, input().strip().split())\n    a = list(map(int, list(input().strip().split())))\n    return n, m, a\n\ndef find(start,end,v):\n    mid = int((start + end) / 2)\n    if start == end:\n        return start\n    if end - start == 1:\n        if a[end] <= v:\n            return end\n        else:\n            return start\n    if a[mid] == v:\n        return mid\n    if a[mid] > v:\n        return find(start,mid,v)\n    else:\n        return find(mid,end,v)\n\ndef solve():\n    val = -1\n    for i in range(0,len(a)-2):\n        pos = find(i+2,len(a)-1,a[i]+m)\n        if a[pos] <= a[i] + m:\n            if (a[pos] - a[i+1]) / (a[pos] - a[i]) > val:\n                val = (a[pos] - a[i+1]) / (a[pos] - a[i])\n    return val\n\nn, m, a = read_data()\nprint(solve())
from collections import defaultdict as dd\nimport math\nimport heapq\ndef nn():\n	return int(input())\n\ndef li():\n	return list(input())\n\ndef mi():\n	return list(map(int, input().split()))\n\ndef lm():\n	return list(map(int, input().split()))\n\nn, m=mi()\nA=[]\nfor i in range(n):\n	A.append(lm())\n\nB=[]\nfor i in range(n):\n	B.append(lm())\n\ndef check(A,B):\n	for i in range(n):\n		count=0\n		for j in range(m):\n			count+=abs(A[i][j]-B[i][j])\n\n		if not count%2==0:\n			return 'No'\n\n	for j in range(m):\n		count=0\n		for i in range(n):\n			count+=abs(A[i][j]-B[i][j])\n		if not count%2==0:\n			return 'No'\n\n	return 'Yes'\n\nprint(check(A,B))\n\n\n\n\n\n\n\n\n\n\n\n\n\n
n,m=list(map(int,input().split()))\nx=list(map(int,input().split()))\ny=list(map(int,input().split()))\ni,j=0,0\ns=0\ns1=0\ns2=0\nwhile i<n and j<m:\n    if x[i]+s1==y[j]+s2:\n        s+=1\n        i+=1\n        j+=1\n        s1=0\n        s2=0\n    elif x[i]+s1>y[j]+s2:\n        s2+=y[j]\n        j+=1\n    else:\n        s1+=x[i]\n        i+=1\nprint(s)\n
n, h, k = [int(x) for x in input().split()]\nL=[int(x) for x in input().split()]\nL = L[::-1]\np = 0\nt = 0\nwhile L:\n    if L and h-p >= L[-1]:\n        p+=L.pop()\n    if L:\n        req = L[-1]-h+p\n        inc = (req-1)//k + 1\n        t += inc\n        p -= inc*k\n        p=max(p,0)\n\nif p:\n    t += (p-1)//k + 1\n\nprint(t)\n
# = map(int, input().split())\nn, m = list(map(int, input().split()))\nans = 10 ** 100\nfor i in range(n):\n    p, q = list(map(int, input().split()))\n    ans = min(ans, p / q * m)\nprint(ans)\n
n = int(input())\na = list(map(int, input().split()))\nb = input()\nr = 1000000000\nl = -r\nfor i in range(4, n):\n  if b[i - 1] != b[i]:\n    if b[i] == '0':\n      r = min(r, min(a[i - 4: i + 1]) - 1)\n    else:\n      l = max(l, max(a[i - 4: i + 1]) + 1)\nprint(l, r)\n
def main():\n    import sys\n    input = sys.stdin.readline\n    \n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    cnt = [1, 0]\n    \n    lst = [0] * (n + 1)\n    lst[0] = 0\n    for i in range(n):\n        lst[i + 1] = lst[i] ^ (arr[i] < 0)\n        cnt[lst[i + 1]] += 1\n    \n    ans1 = cnt[0] * cnt[1]\n    ans2 = cnt[0] * (cnt[0] - 1) // 2 + cnt[1] * (cnt[1] - 1) // 2\n    print(ans1, ans2)\n    \n    return 0\n\nmain()\n
rest, people = map(int, input().split())\ntypes = list(map(int, input().split()))\na = dict()\nfor elem in types:\n    if elem in a:\n        a[elem] += 1\n    else:\n        a[elem] = 1\nmaximum = 0\nfor key in a:\n    if a[key] > maximum:\n        maximum = a[key]\nneeded = maximum\nwhile needed % people != 0:\n    needed += 1\nans = 0\nfor key in a:\n    ans += needed - a[key]\nprint(ans)
n = int(input())\n\ndef pr(x):\n	for i in range(2, x):\n		if x % i == 0:\n			return False\n	return True\n\ne = []\nfor i in range(n):\n	e += [[i, (i+1) % n]]\nx = n\nu = 0\nv = n // 2\nwhile not pr(x):\n	e += [[u, v]]\n	x += 1\n	u += 1\n	v += 1\n\nprint(x)\nfor g in e:\n	print(g[0]+1, g[1]+1)
3\n\nszs = ['S', 'M', 'L', 'XL', 'XXL', 'XXXL']\nd = {'S':0, 'M':1, 'L':2, 'XL':3, 'XXL':4, 'XXXL':5}\nneigh = [[] for i in range(5)]\n\nof = list(map(int, input().split()))\nn = int(input())\nans = ['' for i in range(n)]\nfor i in range(n):\n    t = input()\n    if ',' in t:\n        neigh[d[t.split(',')[0]]].append(i)\n    else:\n        of[d[t]] -= 1\n        ans[i] = t\n\nfor i in range(6):\n    if of[i] < 0:\n        print("NO")\n        return\n    if i > 0:\n        while len(neigh[i - 1]) and of[i] > 0:\n            ans[neigh[i - 1][-1]] = szs[i]\n            neigh[i - 1].pop()\n            of[i] -= 1\n    if i < 5:\n        while len(neigh[i]) and of[i] > 0:\n            ans[neigh[i][-1]] = szs[i]\n            neigh[i].pop()\n            of[i] -= 1\n\n\nif sum([len(neigh[i]) for i in range(5)]) != 0:\n    print("NO")\nelse:\n    print("YES")\n    print("\n".join(ans))\n
seq = input()\na = []\nfl = True\nz = 0\nfor i in seq:\n    if i == '<' or i == '[' or i == '{' or i == '(':\n        a.append(i)\n    elif i == '>':\n        if len(a) and a[-1] == '<': a.pop()\n        elif len(a) and a[-1] != '<':\n            a.pop()\n            z += 1\n        else:\n            fl = False\n            break\n    elif i == ')':\n        if len(a) and a[-1] == '(': a.pop()\n        elif len(a) and a[-1] != '(':\n            a.pop()\n            z += 1\n        else:\n            fl = False\n            break\n    elif i == ']':\n        if len(a) and a[-1] == '[': a.pop()\n        elif len(a) and a[-1] != '[':\n            a.pop()\n            z += 1\n        else:\n            fl = False\n            break\n    elif i == '}':\n        if len(a) and a[-1] == '{': a.pop()\n        elif len(a) and a[-1] != '{':\n            a.pop()\n            z += 1\n        else:\n            fl = False\n            break\nif len(a): fl = False\nif fl: print(z)\nelse: print('Impossible')
base=998244353;\ndef power(x, y):\n    if(y==0):\n        return 1\n    t=power(x, y//2)\n    t=(t*t)%base\n    if(y%2):\n        t=(t*x)%base\n    return t;\ndef inverse(x):\n    return power(x, base-2)\nf=[1]\niv=[1]\nfor i in range(1, 5555):\n    f.append((f[i-1]*i)%base)\n    iv.append(inverse(f[i]))\ndef C(n, k):\n    return (f[n]*iv[k]*iv[n-k])%base\ndef candy(n, k):\n    # print(n, k)\n    return C(n+k-1, k-1)\ndef count_game(k, n, x): #k players, n points total, no player can have x point or more\n    if(k==0):\n        if(n==0):\n            return 1\n        else:\n            return 0\n    ans=0\n    for i in range(0, k+1):\n        t=n-x*i\n        # print(i, C(k, i))\n        if(t<0):\n            break\n        if(i%2):\n            ans=(ans-C(k, i)*candy(t, k))%base\n        else:\n            ans=(ans+C(k, i)*candy(t, k))%base \n    return ans\np, s, r= list(map(int, input().split()))\ngamesize=count_game(p, s-r, int(1e18))\ngamesize=inverse(gamesize)\nans=0;\nfor q in range(r, s+1):\n    for i in range(0, p): #exactly i people have the same score\n        t=s-(i+1)*q\n        if(t<0):\n            break\n        # print(q, i, count_game(p-i-1, t, q));\n        ans=(ans+C(p-1, i)*count_game(p-i-1, t, q)*gamesize*inverse(i+1))%base\nprint(ans)\n        \n
from itertools import *\n\ninStr=next(open('input.txt'))\nn=int(inStr.split()[0])\nm=int(inStr.split()[1])\n\n\nboys=repeat('B', n)\ngirls=repeat('G', m)\n\nif n>m:\n    pairs = zip_longest(boys, girls)\nelse:\n    pairs = zip_longest(girls, boys)\nresult = (y for x in pairs for y in x if y is not None)\nans = ''.join(result)\nopen('output.txt', 'w').write(ans)\nprint(ans)
3\n\ns = input()\nalph = ''.join([chr(ord('a') + x) for x in range(26)])\nl = [[]]\nfor x in s:\n    if x not in alph:\n        l[-1].append(x)\n    else:\n        if len(l[-1]):\n            l.append([])\nl = list([''.join(x) for x in l])\nansa = 0\nansb = 0\nfor t in l:\n    if len(t) > 2 and t[-3] == '.':\n        ansb += int(t[-2:])\n        t = t[:-3]\n    ansa += int(''.join(t.split('.')))\nansa += ansb // 100\nansb %= 100\nansa = str(ansa)\nans = []\nlast = len(ansa)\nfor x in range(len(ansa) - 3, -1, -3):\n    ans.append(ansa[x:last])\n    last = x\nif last != 0:\n    ans.append(ansa[:last])\nans.reverse()\nif ansb != 0:\n    ans.append("%02d" % ansb)\nprint(".".join(ans))\n
import collections\nimport math\n\nn ,m = map(int, input().split())\nA = list(map(int, input().split()))\nans, f = [], [0] * n\nf[0] = -1\nfor i in range(1, n):\n    if A[i] != A[i - 1]:\n        f[i] = i - 1\n    else:\n        f[i] = f[i - 1]\nfor i in range(m):\n    l, r, x = map(int, input().split())\n    #q.append([l - 1, r - 1, x])\n    #for i in range(m):\n    if A[r - 1] != x:\n        ans.append(r)\n    elif f[r - 1] >= l - 1:\n        ans.append(f[r - 1] + 1)\n    else:\n        ans.append(-1)\nprint('\n'.join(str(x) for x in ans))
import sys\n\n\ndef __starting_point():\n    cin = sys.stdin\n\n    n = int(next(cin))\n    a = list(map(int, next(cin).split()))\n\n    n2idx = {a[i]: i for i in range(n)}\n\n    f = [False] * (n+1)\n\n    for i in range(n, 0, -1):\n        idx_lg = n2idx[i]\n\n        win_flag = False\n        for j in range(idx_lg%i, n, i):\n            if a[j] > i and not f[a[j]]:\n                win_flag = True\n                break\n        f[i] = win_flag\n        \n    f = ''.join(['A' if f[a_i] else 'B' for a_i in a])\n    print(f, flush=True)\n\n__starting_point()
from math import *\n\n\ndef ri():\n    return int(input())\n\n\ndef rli():\n    return list(map(int, input().split()))\n\n\nq = ri()\nfor _ in range(q):\n    a, b, c, d, k = rli()\n    x = int(ceil(a / c))\n    y = int(ceil(b / d))\n    if x + y <= k:\n        print(x, y)\n    else:\n        print(-1)\n
n = int(input())\na = [int(i) for i in input().split()]\nl = [i for i in range(len(a))]\nr = [i for i in range(len(a))]\nfor i in range(len(a)):\n	while l[i]>=1 and a[i]|a[l[i]-1]<=a[i]:\n		l[i] = l[l[i]-1]\n    \nfor j in range(len(a)):\n	i = len(a)-j-1\n	while r[i]<len(a)-1 and a[i]|a[r[i]+1]<=a[i] and a[i]>a[r[i]+1]:\n		r[i] = r[r[i]+1]\n\ncount=0\nfor i in range(len(a)):\n	x = r[i]-i+1\n	y = i-l[i]+1\n	count+=x*y-1\nprint((n*(n-1))//2-count)
n, m = map(int, input().split())\nif m == 0:\n	print(n, n)\n	return\nif m == n * (n - 1) // 2:\n	print(0, 0)\n	return\nL = 0\nR = n + 1\nwhile R - L > 1:\n	m1 = (L + R) // 2\n	if m1 * (m1 - 1) // 2 < m:\n		L = m1\n	else:\n		R = m1\nans_max = n - R\nans_min = max(0, n - 2 * m)\nprint(ans_min, ans_max)
t = int(input())\nfor k in range(t):\n    x = int(input())\n    if x == 0:\n        print(1, 1)\n        continue\n    for i in range(1, int(x ** 0.5) + 2):\n        if x % i == 0 and (x // i - i) % 2 == 0 and (x // i - (x // i - i) // 2) ** 2 >= x:\n            a, b = x // i, i\n            y = (a - b) // 2\n            n = a - y\n            if y == 0:\n                continue\n            m = n // y\n            if n // m != y:\n                continue\n            print(n, m)            \n            break\n    else:\n        print(-1)
n, k = map(int, input().split())\nv = list(map(int, input().split()))\nreverse_v = v[::-1]\nlst = [0] * (k + 1)\nleft = [[]]\nright = [[]]\nfor i in range(1, n+1):\n  left.append(v[:i])\n  right.append(reverse_v[:i])\n\nfor cnt in range(1, k+1):\n  rest = k - cnt\n  total = 0\n  if cnt <= n:\n    for j in range(cnt+1):\n      lst_j = left[j] + right[cnt-j]\n      lst_j.sort()\n      l = cnt\n      for idx in range(cnt):\n        if lst_j[idx] >= 0:\n          l = idx\n          break\n      if l == cnt:\n        value = 0\n      else:\n        flg = min(l, rest)\n        value = sum(lst_j[flg:])\n      if value > total:\n        total = value\n    lst[cnt] = total\n\nans = max(lst)\nprint(ans)
def main():\n    mod = 10**9 + 7\n    s = input()\n    n = len(s)\n\n    a_num = 0\n    c_num = s.count('C')\n    q_num = 0\n    q_cnt = s.count('?')\n\n    pow3, pow2, pow1, pow0 = 0, 0, 0, 0\n    if q_cnt >= 3:\n        pow3 = pow(3, q_cnt-3, mod)\n        pow2 = pow3 * 3 % mod\n        pow1 = pow2 * 3 % mod\n        pow0 = pow1 * 3 % mod\n    elif q_cnt == 2:\n        pow2 = 1\n        pow1 = 3\n        pow0 = 9\n    elif q_cnt == 1:\n        pow1 = 1\n        pow0 = 3\n    else:\n        pow0 = 1\n\n    ans = 0\n    for x in s:\n        if x == 'A':\n            a_num += 1\n        elif x == 'B':\n            ans += pow0 * a_num * c_num\n            ans += pow1 * (q_num * c_num + a_num * (q_cnt - q_num))\n            ans += pow2 * (q_num) * (q_cnt - q_num)\n            ans %= mod\n        elif x == 'C':\n            c_num -= 1\n        else:\n            ans += pow1 * a_num * c_num\n            ans += pow2 * (q_num * c_num + a_num * (q_cnt - q_num - 1))\n            ans += pow3 * (q_num) * (q_cnt - q_num - 1)\n            ans %= mod\n            q_num += 1\n\n    print(ans)\n\nmain()
import sys\ninput = sys.stdin.readline\nimport time\n\nfrom collections import deque\n\ndef main():\n    t1 = time.time()\n\n    n = int(input())\n    \n    a = [[int(i) for i in input().split()] for j in range(n)]\n    \n    check = [0]*n\n    used = [False]*n\n    \n    d = deque()\n    \n    for i in reversed(range(n)):\n        if used[i] == True:\n            continue\n        if a[a[i][0]-1][0] == i+1:\n            d.appendleft([i+1,a[i][0]])\n            used[i] = True\n            used[a[i][0]-1] = True\n            check[i] = 1\n            check[a[i][0]-1] = 1\n            \n    ans = 0\n    \n    if len(d) == 0:\n        print(-1)\n        return\n    \n    #print(d)\n    \n    while len(d) > 0:\n        if time.time() - t1 >= 1.95:\n            print(n*(n-1)//2)\n            return\n        used = [False]*n\n        ans += 1\n        num = len(d)\n        for i in range(num):\n            tmp = d.popleft()\n            for j in range(2):\n                if check[tmp[j]-1] == n-1:\n                    continue\n                psn = a[tmp[j]-1][check[tmp[j]-1]]-1\n                mys = tmp[j]-1\n                \n                if check[mys] == n-1 or check[psn] == n-1:\n                    continue\n                #print(tmp,psn,a[psn][check[psn]])\n                #print(i,j,tmp,psn,check[mys],check[psn])\n                if used[mys] == True or used[psn] == True:\n                    continue\n    \n                if a[psn][check[psn]] == mys+1:\n                    d.append([psn+1,mys+1])\n                    used[mys] = True\n                    used[psn] = True\n                    check[mys] += 1\n                    check[psn] += 1\n        #print(d)\n        \n    for i in range(n):\n        if check[i] != n-1:\n            print(-1)\n            return\n    \n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()
# import itertools\n# import math\n# import sys\n# sys.setrecursionlimit(500*500)\n# import numpy as np\nfrom collections import deque\n\n# N = int(input())\n# S = input()\n# n, *a = map(int, open(0))\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n# B = list(map(int, input().split()))\n# tree = [[] for _ in range(N + 1)]\n# B_C = [list(map(int,input().split())) for _ in range(M)]\n# S = input()\n\nA = sorted(A, reverse=True)\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\n# def dfs(tree, s):\n#     for l in tree[s]:\n#         if depth[l[0]] == -1:\n#             depth[l[0]] = depth[s] + l[1]\n#             dfs(tree, l[0])\n# dfs(tree, 1)\n\n# def factorization(n):\n#     arr = []\n#     temp = n\n#     for i in range(2, int(-(-n**0.5//1))+1):\n#         if temp%i==0:\n#             cnt=0\n#             while temp%i==0:\n#                 cnt+=1\n#                 temp //= i\n#             arr.append([i, cnt])\n#     if temp!=1:\n#         arr.append([temp, 1])\n#     if arr==[]:\n#         arr.append([n, 1])\n#     return arr\n\n\nqueue_A = deque(A)\nqueue_B = deque()\n\nfor i in range(M):\n    if len(queue_B) > 0 and queue_B[0] >= queue_A[0]:\n        queue_A.appendleft(queue_B.popleft())\n    queue_A[0] //= 2\n    if len(queue_A) > 1 and queue_A[0] < queue_A[1]:\n        queue_B.append(queue_A.popleft())\n\nprint(sum(queue_A) + sum(queue_B))
MOD = 10**9 + 7\nl, r = map(int, input().split())\n\ndef func(x, y):\n	if y == 0:\n		return 1\n	dp = [[0 for _ in range(6)] for _ in range(61)]\n	dp[60][0] = 1\n	for i in range(59, -1, -1):\n		if (y>>i) & 1 == 0 and (x>>i) & 1 == 0:\n			dp[i][0] = dp[i+1][0]\n			dp[i][1] = dp[i+1][1]\n			dp[i][2] = dp[i+1][2]\n			dp[i][3] = (dp[i+1][3]*2) % MOD\n			dp[i][4] = dp[i+1][4]\n			dp[i][5] = (dp[i+1][1] + dp[i+1][3] + dp[i+1][5]*3) % MOD\n		elif (y>>i) & 1 == 1 and (x>>i) & 1 == 1:\n			dp[i][0] = 0\n			dp[i][1] = 0\n			dp[i][2] = (dp[i+1][0] + dp[i+1][2]) % MOD\n			dp[i][3] = (dp[i+1][1] + dp[i+1][3]) % MOD\n			dp[i][4] = (dp[i+1][4]*2) % MOD\n			dp[i][5] = (dp[i+1][4] + dp[i+1][5]*3) % MOD\n		elif (y>>i) & 1 == 1 and (x>>i) & 1 == 0:\n			dp[i][0] = 0\n			dp[i][1] = (dp[i+1][0] + dp[i+1][1]) % MOD\n			dp[i][2] = dp[i+1][2]\n			dp[i][3] = (dp[i+1][2] + dp[i+1][3]*2) % MOD\n			dp[i][4] = (dp[i+1][0] + dp[i+1][2] + dp[i+1][4]*2) % MOD\n			dp[i][5] = (dp[i+1][1] + dp[i+1][3] + dp[i+1][4] + dp[i+1][5]*3) % MOD\n		elif (y>>i) & 1 == 0 and (x>>i) & 1 == 1:\n			dp[i][0] = 0\n			dp[i][1] = 0\n			dp[i][2] = 0\n			dp[i][3] = (dp[i+1][1] + dp[i+1][3]) % MOD\n			dp[i][4] = dp[i+1][4]\n			dp[i][5] = (dp[i+1][5]*3) % MOD\n\n	return (sum(dp[0]))%MOD\n\nprint(func(l, r))
n=int(input())\na=list(map(int,input().split()))\ncount=0\nans=[]\nfor i in range(n):\n  ans.append(abs(a[i]))\n  if a[i]<0:\n    count+=1\n\nif count%2==0:\n  print((sum(ans)))\nelse:\n  print((sum(ans)-2*min(ans)))\n
import numpy as np\nfrom sys import stdin\n\n'''\nReference: https://codeforces.com/blog/entry/75046#comment-591494 (1-based index)\n\n(0-based index)\n\nFor a sequence A[l]..A[k]..A[r] with sum S contributes l * (N - r) to answer.\n    0, 1, 2, ..., l....k....r, ..., N - 2, N - 1\n    x  x  x   x   x         v   v     v      v\nThere are l `x` and (N - r) `v`.\n\nEnumerate all possible sequence is impossible. \nConsider all sequeuces with sum S and **ends** at specific r:\n    A[l1]...A[r] -> l1 * (N - r)\n    A[l2]...A[r] -> l2 * (N - r)\n    A[l3]...A[r] -> l3 * (N - r)\n    .\n    .\n    .\nwhich contributes (l1 + l2 + ... + lm) * (N - r) in total.\n\nWe can find *sum of left index for all valid sequence* for each r using DP.\n\n    dp[i][s] = the sum of left index for all sequence that\n                    1. ends at i\n                    2. has sum s\n    \n    dp[i][:A[i]] = 0  since any sequence ends at i has sum >= A[i]\n\n    dp[i][A[i]] = i + 1\n    dp[i][s] = sum(dp[j][s - A[i]] for j in range(i))\n\n    Take A = [2, 3, 4] for example, sequences that end at A[2] are:\n    \n                   [4] -> dp[2][4] = 3\n             [2,    4] ↘\n                [3, 4] -> dp[2][s] = dp[2][s - 4] for all s\n             [2, 3, 4] ↗\n    \n    The answer is sum(dp[r][S] * (N - r) for r in range(N))\n\nSo the naive implementation is:\n\n    dp = np.zeros((N, max(S, A.max()) + 1), dtype=np.int64)\n    for i, a in enumerate(A):\n        dp[i, a] = i + 1\n        for s in range(a + 1, S + 1):\n            dp[i, s] = dp[:i, s - a].sum() % M  # here can be optimized\n    \n    ans = 0\n    for i in range(N):\n        ans += (N - i) * dp[i, S]\n        ans = ans % M\n\nhas time O(N * S * N) which results in TLE.\n\nUsing another array to store the cumsum (prefix sum) of dp solves the problem:\n'''\n\nN, S = list(map(int, input().split()))\nA = np.int32(input().split())\nM = 998244353\nV = max(A.max(), S)\n\nans = 0\ndp = np.zeros((N, V + 1), dtype=np.int64)\ncs = np.zeros(V + 1, dtype=np.int64)\nfor i, a in enumerate(A):\n    dp[i, a] = i + 1\n    dp[i, a + 1 : S + 1] = cs[np.arange(a + 1, S + 1) - a]\n    cs = (cs + dp[i]) % M\n    ans = (ans + (N - i) * dp[i, S]) % M\nprint(ans)\n
import numpy as np\nINF = 10**15\ndef solve(n, k, h):\n    dp = np.full((n+1, n+1), INF, dtype=int)\n    dp[0, 0] = 0\n    h = np.array([0] + h, dtype=int)\n    for i, h_i in enumerate(h[1:], 1):\n        t = np.maximum(h_i - h[:i], 0)\n        dp[i,1:] = np.min(dp[:i,:-1]+t[:,None], axis=0)\n    return np.min(dp[:, n-k])\n\nn, k = map(int, input().split())\nh = list(map(int, input().split()))\nprint(solve(n, k, h))
n,k = list(map(int, input().split()))\nL = list(map(int, input().split()))\ni = 1\nwhile k > 0:\n    k = k - i\n    i += 1\nk = k + i - 1\nprint(L[k-1])\n
n, k = map(int, input().split())\nt = list(map(int, input()))\np, d = 1, 10 ** 9 + 7\ns, f = 0, [1] * n\nfor i in range(2, n): f[i] = (i * f[i - 1]) % d\nc = lambda a, b: 0 if a > b else (f[b] * pow(f[a] * f[b - a], d - 2, d)) % d\nif k:\n    u = [0] * (n + 1)\n    p = [1] * (n + 1)\n    for i in range(n):\n        u[i] = (p[i] * c(k - 1, n - 2 - i) + u[i - 1]) % d\n        p[i + 1] = (10 * p[i]) % d\n    for i in range(n): \n        v = u[n - 2 - i] + p[n - 1 - i] * c(k, i)\n        s = (s + t[i] * v) % d\nelse:\n    for i in t: s = (s * 10 + i) % d\nprint(s)
def median(a):\n    if len(a) == 0:\n        return 0\n    if len(a) % 2 == 1:\n        return a[len(a) // 2]\n    else:\n        return (a[len(a) // 2] + a[(len(a) // 2) - 1]) // 2\n\n\ndef profit(a, old_val):\n    a.sort()\n    med = median(a)\n    sum_old = 0\n    sum_new = 0\n    for i in a:\n        sum_old += abs(i - old_val)\n        sum_new += abs(i - med)\n    return sum_old - sum_new\n\nn, m = [int(c) for c in input().split()]\npages = [int(c) for c in input().split()]\n\ncount = {pages[0]: []}\ncurrent_page_switches = 0\n\nfor i in range(1, len(pages)):\n    cur_i = pages[i]\n    prev_i = pages[i - 1]\n    if not(cur_i in count):\n        count[cur_i] = []\n\n    if cur_i != prev_i:\n        count[cur_i].append(prev_i)\n        count[prev_i].append(cur_i)\n        current_page_switches += abs(cur_i - prev_i)\n\nmax_profit = 0\n\nfor i in count:\n    if len(count[i]) > 0:\n        tmp = profit(count[i], i)\n        if tmp > max_profit:\n            max_profit = tmp\n\n\nprint(current_page_switches - max_profit)\n\n
dhuang=0\na,b,c,d=list(map(int,input().split(' ')))\nhuang = [['*']*b for _ in range(a)]\nfor i in range(c):\n    x,y=list(map(int,input().split(' ')))\n    huang[x-1][y-1] = '#'\nfor i in range(a):\n    for j in range(b):\n        for k in range(i, a):\n            for l in range(j, b):\n                ct=0\n                for m in range(i, k+1):\n                    for n in range(j, l+1):\n                        if huang[m][n]=='#':\n                            ct+=1\n                if ct>=d:\n                    dhuang+=1\nprint(dhuang)\n
t = int(input())\nfor _ in range(t):\n    n, x = [int(x) for x in input().split()]\n    a = set([int(x) for x in input().split()])\n    for i in range(1, 1000):\n        if i in a:\n            continue\n        if x == 0:\n            print(i - 1)\n            break\n        x -= 1\n
s = input()\n\ns = s[1: -1].replace(',', '')\n\nresult = set(s.split())\n\nprint(len(result))\n
from itertools import accumulate\n\n\ndef main():\n    n, m, k = list(map(int, input().split()))\n    \n    a = list(map(int, input().split()))\n    km = k * m\n    \n    if m == 1:\n        a.sort(reverse=True)\n        print(sum(a[:k]))\n        return\n\n    a = list(accumulate(a))\n    a.append(0)\n\n    if n == km:\n        print(a[n-1])\n        return\n\n    d = [[0] * (n+1) for _ in range(k+1)]\n\n    for i in range(m - 1, n):\n        _k = (i + 1) // m if i < km else k\n        for j in range(1, _k + 1):\n            if i == j*m-1:\n                d[j][i] = a[i]\n            else:\n                d[j][i] = max(d[j][i-1], a[i] - a[i-m] + d[j-1][i-m])\n\n    print(d[k][n-1])\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()
def test(x, i):\n	i = list(i)\n	ok = True\n	for j in range(x):\n		if (i[j] == j+1 or (i[j]&(j+1) != 0)):\n			ok = False\n	if ok:\n		print(i)\n\ndef comp(n):\n	return 2**len(bin(n)[2:])-1-n\n\nn = int(input())\nnn = n\nif (n%2 == 0):\n	x = []\n	while (n != 0):\n		#add n to comp(n) to the front of x\n		for i in range(comp(n), n+1):\n			x.append(i)\n		n = comp(n)-1\n\n	x.reverse()\n	print("YES")\n	print(' '.join([str(i) for i in x]))\nelse:\n	print("NO")\n\npow2 = [2**i for i in range(20)]\ndef make(n):\n	if n <= 5: return []\n	if n == 6: return [3, 6, 1, 5, 4, 2]\n	if n == 7: return [3, 6, 1, 5, 4, 7, 2]\n	if n in pow2:\n		return []\n	shift = 2**(len(bin(n)[2:])-1)\n	array = [i for i in range(shift, n+1)]\n	array = array[1:] + [array[0]]\n	return make(shift-1) + array\n\nn = nn\nk = make(n)\nif k == []:\n	print("NO")\nelse:\n	print("YES")\n	print(' '.join([str(i) for i in k]))\n
import sys\nimport math\ndef getAndParseInt(num=1):\n    string = (sys.stdin.readline()).strip()\n    if num==1:\n        return int(string)\n    else:\n        return [int(part) for part in string.split()]\n\ndef getAndParseString(num=1,delim=" "):\n    string = (sys.stdin.readline()).strip()\n    if num==1:\n        return string\n    else:\n        return [part for part in string.split(delim)]\n\nn, m = getAndParseInt(2)\nadj_list = [[] for i in range(n)]\nedge_list = []\nfor i in range(m):\n    u, v = getAndParseInt(2)\n    edge_list.append((u,v))\n    adj_list[u-1].append(v-1)\n\nvisited = set()\nstack = []\nfinished_exploring = [False for i in range(n)]\nedge_colors = {}\nacyclic = True\n\nfor i in range(n):\n    if i not in visited:\n        stack.append((i,0))\n    else:\n        continue\n    while stack:\n        cur_vertex, neigh_index = stack.pop()\n        if neigh_index == 0:\n            visited.add(cur_vertex)\n\n        if neigh_index == len(adj_list[cur_vertex]):\n            finished_exploring[cur_vertex] = True\n        else:\n            stack.append((cur_vertex, neigh_index + 1))\n            neighbor = adj_list[cur_vertex][neigh_index]\n            if neighbor not in visited:\n                stack.append((neighbor, 0))\n                edge_colors[(cur_vertex+1,neighbor+1)]='1'\n                visited.add(neighbor)\n            elif neighbor in visited and not finished_exploring[neighbor]:\n                edge_colors[(cur_vertex+1,neighbor+1)]='2'\n                acyclic = False\n            else:\n                edge_colors[(cur_vertex+1,neighbor+1)]='1'\n\nif acyclic:\n    print(1)\n    output_list = ["1" for i in range(m)]\nelse:\n    print(2)\n    output_list = []\n    for edge in edge_list:\n        output_list.append(edge_colors[edge])\nprint(" ".join(output_list))\n\n\n\n\n
n = int(input())\n\na = sorted(list(map(int, input().split())))\n\n\n\nmaxe = max(a)\n\ncnt = []\n\ncur, k, i = 1, 0, 0\n\n\n\nwhile i < n:\n\n    cnt.append(0)\n\n    while i < n and a[i] < cur:\n\n        cnt[2 * k] += 1\n\n        i += 1\n\n    cnt.append(0)\n\n    while i < n and a[i] == cur:\n\n        cnt[2 * k + 1] += 1\n\n        i += 1\n\n    k += 1\n\n    cur *= 2\n\ncnt.append(0)\n\ncnt.append(0)\n\nmaxe = len(cnt) - 1\n\n\n\nmaxk = cnt[1]\n\nwas = False\n\nfor l in range(maxk):\n\n    cur = 1\n\n    while cnt[cur] > 0:\n\n        cnt[cur] -= 1\n\n        cur += 2\n\n    cnt[cur] -= 1\n\n    cursum = 0\n\n    ok = True\n\n    for t in range(maxe, 0, -1):\n\n        cursum += cnt[t]\n\n        if cursum > 0:\n\n            ok = False\n\n            break\n\n    if ok:\n\n        print(l + 1, end=" ")\n\n        was = True\n\n\n\nif not was:\n\n    print(-1)\n\n\n\n# Made By Mostafa_Khaled
import math\nimport operator as op\n\nfrom functools import reduce\n\nfrom operator import mul    # or mul=lambda x,y:x*y\nfrom fractions import Fraction\n\ndef nCk(n,k): \n  return int( reduce(mul, (Fraction(n-i, i+1) for i in range(k)), 1) )\n\n\ndef ncr(n, r):\n    r = min(r, n-r)\n    if r == 0: return 1\n    numer = reduce(op.mul, list(range(n, n-r, -1)))\n    denom = reduce(op.mul, list(range(1, r+1)))\n    return numer//denom\n\ndef modPow(a, x, p):\n    #calculates a^x mod p in logarithmic time.\n    res = 1\n    while(x > 0):\n        if( x % 2 != 0):\n            res = (res * a) % p\n            \n        a = (a * a) % p\n        x = int(x/2)\n    return res\n\ndef modInverse(a, p):\n    #calculates the modular multiplicative of a mod m.\n    #(assuming p is prime).\n    return modPow(a, p-2, p)\n\ndef modBinomial(n, k, p):\n    #calculates C(n,k) mod p (assuming p is prime).\n\n    # n * (n-1) * ... * (n-k+1)\n    numerator = 1 \n    for i in range(k):\n        numerator = (numerator * (n-i) ) % p\n\n    denominator = 1\n    for i in range(1, k+1):\n        denominator = (denominator * i) % p\n\n    # numerator / denominator mod p.\n    return ( numerator* modInverse(denominator,p) ) % p\n\n\nn, c = input().split()\nn = int(n)\nc = int(c)\n\n#test = [0 for x in range (n+1)]\n#test[1] = c\n\n#for i in range(2, n+1):\n#    test[i] = (test[i-1] + modBinomial((i+c-1),i, 1000003))%1000003\n\n#ans = solve(n, c)\n#ans =test[n]\nans = modBinomial((c+n),c,1000003) - 1\nprint(int(ans))\n
w1, h1, w2, h2 = list(map(int, input().split()))\nprint(2 * (h1 + h2) + w1 + w2 + abs(w1 - w2) + 4)\n
n,m = map(int, input().split())\n\nclass Knight:\n	def __init__(self, andis, p, c):\n		self.p = int(p)\n		self.c = int(c)\n		self.andis = int(andis)\n		self.ans = self.c\n\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\nx = []\nfor i in range(n):\n	x.append(Knight(i, p[i], c[i]))\n\nx.sort(key=lambda x: x.p)\ncoins = []\nfor i in range(n-1):\n	if len(coins) < m:\n		coins.append(x[i].c)\n		coins.sort()\n	elif len(coins) > 0:\n		if coins[0] < x[i].c:\n			coins[0] = x[i].c\n			coins.sort()\n	x[i+1].ans += sum(coins)\n\nx.sort(key=lambda x:x.andis)\nfor k in x:\n	print(k.ans, end=' ')\n	\n\n\n\n
from sys import stdin, stdout\nfrom math import *\nfrom itertools import *\nfrom copy import *\n\ns = 0\ninvs = 0\n\ndef calc_invertions(a):\n    s = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            s += 1 if a[i] > a[j] else 0\n    return s\n\ndef do_flips(arr, num):\n    nonlocal s, invs\n    if num == 0:\n        invs += 1\n        s += calc_invertions(arr)\n    else:\n        for i in range(len(arr)):\n            for j in range(i, len(arr)):\n                for k in range((j - i + 1) // 2):\n                    arr[i + k], arr[j - k] = arr[j - k], arr[i + k]\n                do_flips(arr, num - 1)\n                for k in range((j - i + 1) // 2):\n                    arr[i + k], arr[j - k] = arr[j - k], arr[i + k]\n    \ndef solve(test):\n    ints = list(map(int, test.strip().split()))\n    n, m = ints[:2]\n    arr = ints[2:]\n    do_flips(arr, m)\n    return s / invs\n\nstdout.write(str(solve(stdin.read())))\n
n, k = map(int, input().split())\ns = sorted(list(map(int, input().split())), reverse = True)\nprint(s[k - 1])
import sys\n\nclass SegmTree():\n    def __init__(self, array=None):\n        size = len(array)\n        N = 1\n        while N < size:\n            N <<= 1\n        self.N = N\n        self.tree = [0] * (2*self.N)\n        for i in range(size):\n            self.tree[i+self.N] = array[i]\n        self.build()\n\n    def build(self):\n        for i in range(self.N - 1, 0, -1):\n            self.tree[i] = self.tree[i<<1] + self.tree[i<<1|1]\n \n    def add(self, i, value=1):\n        i += self.N\n        while i > 0:\n            self.tree[i] += value\n            i >>= 1\n    \n    def get_sum(self, l, r):\n        N = self.N\n        l += N\n        r += N\n        result = 0\n        while l < r:\n            if l & 1:\n                result += self.tree[l]\n                l += 1\n            if r & 1:\n                r -= 1\n                result += self.tree[r]\n            l >>= 1\n            r >>= 1\n        return result\n    \n    def find_kth_nonzero(self, k):\n        i = 1\n        if k < 1 or k > self.tree[1]:\n            return -1\n        while i < self.N:\n            i <<= 1\n            if self.tree[i] < k:\n                k -= self.tree[i]\n                i |= 1\n        return i - self.N\n\nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\n\nn = int(input())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\nord_p = [0] * n\nord_q = [0] * n\n\nst = SegmTree([1] * n)\nfor i, val in enumerate(p):\n    ord_p[i] = st.get_sum(0, val)\n    st.add(val, -1)\n\nst = SegmTree([1] * n)\nfor i, val in enumerate(q):\n    ord_q[i] = st.get_sum(0, val)\n    st.add(val, -1)\n\ntransfer = 0\nfor i in range(n-1, -1, -1):\n    radix = n-i\n    ord_p[i] = ord_p[i] + ord_q[i] + transfer\n    if ord_p[i] < radix:\n        transfer = 0\n    else:\n        transfer = 1\n        ord_p[i] -= radix\n\nst = SegmTree([1] * n)\nfor i in range(n):\n    k = ord_p[i] + 1\n    ord_q[i] = st.find_kth_nonzero(k)\n    st.add(ord_q[i], -1)\n\nprint(*ord_q)\n
n = int(input())\nl = list(map(int, input().split()))\nf1 = l[2]\nl.sort()\nf2 = l[0]\nprint(2 + (f1 ^ f2))\n
def ziped(a):\n	p = []\n	for i in a:\n		x = int(i.split('-')[0])\n		y = i.split('-')[1]\n		if len(p) > 0 and p[-1][1] == y:\n			p[-1][0] += x\n		else:\n			p.append([x, y])\n	return p\n\ndef solve(a, b , c):\n	ans = 0\n	if len(b) == 1:\n		for token in a:\n			if c(token, b[0]):\n				ans += token[0] - b[0][0] + 1\n		return ans\n		\n	if len(b) == 2:\n		for i in range(len(a) - 1):\n			if c(a[i], b[0]) and c(a[i + 1], b[-1]):\n				ans += 1\n		return ans\n		\n	v = b[1 : -1] + [[100500, '#']] + a\n	p = [0] * len(v)\n	for i in range(1, len(v)):\n		j = p[i - 1]\n		while j > 0 and v[i] != v[j]:\n			j = p[j - 1]\n		if v[i] == v[j]:\n			j += 1\n		p[i] = j\n		\n	for i in range(len(v) - 1):\n		if p[i] == len(b) - 2 and c(v[i - p[i]], b[0]) and c(v[i + 1], b[-1]):\n			ans += 1\n	return ans\n\nn, m = list(map(int, input().split()))\na = ziped(input().split())\nb = ziped(input().split())\nprint(solve(a, b, lambda x, y: x[1] == y[1] and x[0] >= y[0]))\n
Mod=1000000007\ns=input()\nn=len(s)\na,b,c,d=1,0,0,0\nfor i in range(0,n):\n    if s[i]=='*':\n        a,b,c,d=0,(a+b+d)%Mod,0,0\n    elif s[i]=='?':\n        a,b,c,d=(a+b+c)%Mod,(a+b+d)%Mod,0,0\n    elif s[i]=='0':\n        a,b,c,d=0,0,(a+c)%Mod,0\n    elif s[i]=='1':\n        a,b,c,d=0,0,b,(a+c)%Mod\n    else:\n        a,b,c,d=0,0,0,(b+d)%Mod\nprint((a+b+c)%Mod)\n
str=input().split()\nn=int(str[0])\nlen=int(str[1])\na=[]\nQ=[]\nF=[]\nfor i in range(0,n+1):\n	a.append(0)\n	Q.append(0)\n	F.append(0)\nsum=0\nh=1\nt=0\nstr=input().split()\nfor i in range(1,n+1):\n	a[i]=int(str[i-1])\n	sum+=a[i]\n	#print (sum)\n	while h<=t and Q[h]<=i-len:\n		h=h+1\n	while h<=t and a[i]<=a[Q[t]]:\n		t=t-1\n	t=t+1;Q[t]=i;\n	if (i<len) :\n		F[i]=0\n	else :\n		F[i]=F[i-len]+a[Q[h]]\n	F[i]=max(F[i],F[i-1])\n		\nprint(sum-F[n])\n
3\n\ndef readln(): return tuple(map(int, input().split()))\n\nn, m = readln()\ncnt = [0] * (m + 1)\nfor c in readln():\n    cnt[c] += 1\nans = [0] * n\nj = 0\nfor _ in range(1, m + 1):\n    v = max(cnt)\n    i = cnt.index(v)\n    while cnt[i]:\n        ans[j] = i\n        cnt[i] -= 1\n        j += 2\n        if j >= n:\n            j = 1\nprint(len([1 for i in range(n) if ans[i] != ans[(i + 1) % n]]))\nfor i in range(n):\n    print(ans[i], ans[(i + 1) % n])\n
def gcd(a, b):\n    if(a==0):\n        return b\n    return gcd(b%a, a)    \n\nn=int(input())\nv=list(map(int,input().split()))\nv.sort()\nans=v[1]-v[0]\nfor i in range(2, n):\n    ans=gcd(ans, v[i]-v[i-1])\nprint((v[len(v)-1]-v[0])//ans+1-n) 
\nn = int(input())\n\nitems = []\nmax_time = 0\n\nfor i in range(1,n+1):\n    t,d,p = list(map(int,input().split()))\n    max_time = max(max_time, d)\n    items.append((t,d,p,i))\n\nitems.sort(key=lambda x: x[1])\n\ndp = [[(0,[]) for _ in range(n+1)] for _ in range(max_time+1)]\n\nfor time in range(1, max_time+1):\n    for it in range(1, n+1):\n        \n        if time < items[it-1][0] or time >= items[it-1][1]:\n            dp[time][it] = max(dp[time][it-1], dp[time-1][it])\n        else:\n            \n            pick = dp[time-items[it-1][0]][it-1][0] + items[it-1][2]\n            if dp[time][it-1][0] > pick : \n                dp[time][it] = max(dp[time][it-1], dp[time-1][it])\n            else:\n                \n                dp[time][it] = (dp[time-items[it-1][0]][it-1][0] + items[it-1][2], list(dp[time-items[it-1][0]][it-1][1]))\n                dp[time][it][1].append(items[it-1][3])\n\n#print(dp)\n\nres = max(dp[max_time])\n\nprint(res[0])\nprint(len(res[1]))\nprint(*res[1])             \n
n = int(input())\na = list(tuple(map(int,input().split())) for i in range(n))\n#a.append(tuple(map(int,input().split())))\nm = n // 2\nc = list('1' for i in range(m))\nd = list('1' for i in range(m))\n#for i in range(n):print(a[i][0],a[i][1])\nfor i in range(m,n):\n        if a[i][0] < a[n-i-1][1]:\n            c.append('1')\n        else:\n            c.append('0')\n        if a[n-i-1][0] > a[i][1]:\n            d.append('1')\n        else:\n            d.append('0')\nprint(''.join(c))\nprint(''.join(d))
h,l=map(int,input().split())\nprint((l**2-h**2)/2/h)
m = 301000\nns = [0] * m\nes = [0] * m\nc = [0] * m\nb = [0] * m\nt = [0] * m\nP = 0\n\ndef add(b, k):\n    k = t[k]\n    while k:\n        e = es[k]\n        if b[-1] > e: b[-1] = e\n        b[e] += 1\n        k = ns[k]\n\ndef delete(b):\n   for i in range(b[m - 1], m + 1):\n       if b[i]:\n           b[i] -= 1\n           b[-1] = i\n           return i\n\ndef calc(k):\n    nonlocal b\n    q = 0\n    b = [0] * m\n    b[-1] = m\n    take = rank - dn\n    if take < 0: take = 0\n    add(b, k)\n    add(b, k - 1)\n    for i in range(1, take + 1): q += delete(b)\n    for i in range(k - 1): add(b, i)\n    for i in range(k + 1, P + 1): add(b, i)\n    for i in range(1, k - take + 1): q += delete(b)\n    return q\n\nn, k = list(map(int, input().split()))\nrank = n - k + 1\n\nif rank == 0:\n    print('0')\n    return\n\nfor i in range(1, n + 1):\n    p, e = list(map(int, input().split()))\n    if p > P: P = p\n    c[p] += 1\n    es[i], ns[i] = e, t[p]\n    t[p] = i\n\ndn = 0\nfor i in range(1, n + 1):\n    if i > 1: dn += c[i - 2]\n    if c[i] + c[i - 1] + dn >= rank and rank <= i + dn:\n        u = calc(i)\n        if i < n:\n            dn += c[i - 1]\n            v = calc(i + 1)\n            if u > v: u = v\n        if i < n - 1:\n            dn += c[i]\n            v = calc(i + 2)\n            if u > v: u = v\n        print(u)\n        return\n        \nprint('-1')\n
from fractions import Fraction\nimport time\nfrom collections import Counter\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def to_tuple(self):\n        return (self.x, self.y)\n\n    def __repr__(self):\n        return "Point({}, {})".format(self.x, self.y)\n\n    def __eq__(self, other):\n        return self.to_tuple() == other.to_tuple()\n\n    def __hash__(self):\n        return hash(self.to_tuple())\n\n    def __neg__(self):\n        return Point(-self.x, -self.y)\n\n    def __add__(self, other):\n        return Point(self.x+other.x, self.y+other.y)\n\n    def __sub__(self, other):\n        return self+(-other)\n\n    def scalar_mul(self, mu):\n        return Point(mu*self.x, mu*self.y)\n\n    def int_divide(self, den):\n        return Point(self.x//den, self.y//den)\n\n    def __lt__(self, other):\n        if self.x == other.x:\n            return self.y < other.y\n        return self.x < other.x\n\n    def dot(self, other):\n        return self.x*other.x+self.y*other.y\n\n\nclass Line:\n    def __init__(self, a, b, c):\n        # ax+by+c=0\n        self.a = a\n        self.b = b\n        self.c = c\n\n    def __repr__(self):\n        return "{}*x + {}*y + {} = 0".format(self.a, self.b, self.c)\n\n    @classmethod\n    def between_two_points(cls, P, Q):\n        return cls(P.y-Q.y, Q.x-P.x, P.x*Q.y-P.y*Q.x)\n\n    def evaluate(self, P):\n        return self.a*P.x+self.b*P.y+self.c\n\n    def direction(self):\n        if self.a == 0:\n            return (0, 1)\n        return (1, Fraction(self.b, self.a))\n\n\ntrue_start = time.time()\nn = int(input())\npoints = set()\ncenter = Point(0, 0)\nfor i in range(n):\n    row = input().split(" ")\n    cur = Point(int(row[0]), int(row[1])).scalar_mul(2*n)\n    center += cur\n    points.add(cur)\n\ncenter = center.int_divide(n)\ndcenter = center+center\n\n# nosym = []\n# for p in points:\n#     psym = dcenter-p\n#     if psym not in points:\n#         nosym.append(p)\n\nsym_points_set = set()\nfor p in points:\n    sym_points_set.add(dcenter-p)\nnosym = list(points - sym_points_set)\n\n#print(nosym)\n# print("preproc:", time.time()-true_start)\n\nif len(nosym) == 0:\n    print(-1)\n    return\n\n\ncnt = 0\np0 = nosym[0]\ngood_lines = set()\nfor p in nosym:\n    start = time.time()\n    m = (p+p0).int_divide(2)\n    supp = Line.between_two_points(m, center)\n    time_setup = time.time()-start\n    distances = list(map(supp.evaluate, nosym))\n    time_projs = time.time()-start\n\n    # sorting strat\n    ok = True\n    SORTING = False\n    if SORTING:\n        distances = sorted(distances)\n        time_sorting = time.time()-start\n        m = len(distances)\n        for i in range(m//2):\n            if distances[i] != -distances[m-1-i]:\n                ok = False\n                break\n    else:\n        mydict = {}\n        for dd in distances:\n            dda = abs(dd)\n            if dda not in mydict:\n                mydict[dda] = 1\n            else:\n                mydict[dda] += 1\n        time_sorting = time.time()-start\n        for k in mydict:\n            if mydict[k] % 2 == 1 and k != 0:\n                ok = False\n                break\n    if ok:\n        #print("ok", supp)\n        #print(distances)\n        #print(mydict)\n        good_lines.add(supp.direction())\n\n    #print("setup: {}\tprojs: {}\tsort: {}\tdone: {}".format(time_setup, time_projs, time_sorting, time.time()-start))\n\n#print("total:", time.time()-true_start)\nprint(len(good_lines))\n
def p2pl(p1,p2,p3,p4,p5):\n    prob0 = (1-p1)*(1-p2)*(1-p3)*(1-p4)*(1-p5)\n    prob1 = p1*(1-p2)*(1-p3)*(1-p4)*(1-p5) + \\n            p2*(1-p1)*(1-p3)*(1-p4)*(1-p5) + \\n            p3*(1-p1)*(1-p2)*(1-p4)*(1-p5) + \\n            p4*(1-p1)*(1-p2)*(1-p3)*(1-p5) + \\n            p5*(1-p1)*(1-p2)*(1-p3)*(1-p4)\n    return 1-(prob1+prob0)\n\nn = int(input())\nc1 = input().split(' ')\nc1 = [int(c1[0]),int(c1[1])]\n\nc2 = input().split(' ')\nc2 = [int(c2[0]),int(c2[1])]\n\nif n >= 3:\n    c3 = input().split(' ')\n    c3 = [int(c3[0]),int(c3[1])]\nelse:\n    c3 = [0,0]\n\nif n >= 4:\n    c4 = input().split(' ')\n    c4 = [int(c4[0]),int(c4[1])]\nelse:\n    c4 = [0,0]\n\nif n >= 5:\n    c5 = input().split(' ')\n    c5 = [int(c5[0]),int(c5[1])]\nelse:\n    c5 = [0,0]\n\nans = 0\nfor x in range(1,10001):\n    p1 = min(1,max(c1[1]-x+1,0)/(c1[1]-c1[0]+1))\n    p2 = min(1,max(c2[1]-x+1,0)/(c2[1]-c2[0]+1))\n    p3 = min(1,max(c3[1]-x+1,0)/(c3[1]-c3[0]+1))\n    p4 = min(1,max(c4[1]-x+1,0)/(c4[1]-c4[0]+1))\n    p5 = min(1,max(c5[1]-x+1,0)/(c5[1]-c5[0]+1))\n    ans += p2pl(p1,p2,p3,p4,p5)\nprint(ans)\n
from collections import defaultdict\n\n\nclass RobotRapping():\n    def __init__(self, n, m, battles):\n        self.n, self.m = n, m\n        self.battles = battles\n\n    def generate_graph(self, k):\n        edge_map = defaultdict(list)\n        rev_map = defaultdict(list)\n        for i in range(k):\n            edge_map[self.battles[i][0]-1].append((self.battles[i][1]-1, i))\n            rev_map[self.battles[i][1]-1].append((self.battles[i][0]-1, i))\n        return edge_map, rev_map\n\n    def check_order(self, num_battles):\n        edge_map, rev_map = self.generate_graph(num_battles)\n        outgoing_cnt = defaultdict(int)\n        for k in edge_map:\n            outgoing_cnt[k] = len(edge_map[k])\n        s = []\n        cntr = 0\n        for i in range(self.n):\n            if outgoing_cnt[i] == 0:\n                s.append(i)\n        while len(s) > cntr:\n            if len(s) > cntr+1 :\n                return False\n            else:\n                node = s[cntr]\n                for v in rev_map[node]:\n                    outgoing_cnt[v] -= 1\n                    if outgoing_cnt[v] == 0:\n                        s.append(v)\n                cntr += 1\n        return True\n\n    def min_battles(self):\n        if not self.check_order(self.m):\n            print(-1)\n        else:\n            mn, mx = 0, self.m\n            while mn < mx-1:\n                md = int((mn+mx)/2)\n                if self.check_order(md):\n                    mx = md\n                else:\n                    mn = md\n            print(mx)\n\n\n    def min_battles2(self):\n        edge_map, rev_map = self.generate_graph(self.m)\n        outgoing_cnt = defaultdict(int)\n        for k in edge_map:\n            outgoing_cnt[k] = len(edge_map[k])\n        s = []\n        cntr = 0\n        order = []\n        for i in range(self.n):\n            if outgoing_cnt[i] == 0:\n                s.append(i)\n        while len(s) > cntr:\n            if len(s) > cntr+1 :\n                print(-1)\n                return\n            else:\n                node = s[cntr]\n                order.append(node)\n                for v,_ in rev_map[node]:\n                    outgoing_cnt[v] -= 1\n                    if outgoing_cnt[v] == 0:\n                        s.append(v)\n                cntr += 1\n        mn_pos = -1\n        for i in range(1,self.n):\n            for v,ind in edge_map[order[i]]:\n                if v == order[i-1]:\n                    mn_pos = max(mn_pos, ind)\n                    break\n        print(mn_pos+1)\n\nn,m = list(map(int,input().strip(' ').split(' ')))\nbattles = []\nfor i in range(m):\n    x,y = list(map(int,input().strip(' ').split(' ')))\n    battles.append((x,y))\nrr = RobotRapping(n,m,battles)\nrr.min_battles2()\n
def main():\n    n = int(input())\n    \n    result = 0\n    d = set()\n    for i in range(n):\n        t, a = input().split()\n        a = int(a)\n        if t == "+":\n            d.add(a)\n            result = max(result, len(d))\n        else:\n            if a in d:\n                d.remove(a)\n            else:\n                result += 1\n    \n    print(result)\n    \n    \nmain()\n
from math import floor, ceil\nn = int(input())\narr = []\nfor i in range(n):\n    arr.append(float(input()))\nk = [floor(i) for i in arr]\ndelta = -sum(k)\nfor i in range(n):\n    if int(arr[i]) != arr[i] and delta:\n        delta -= 1\n        print(ceil(arr[i]))\n    else:\n        print(floor(arr[i]))
n,m=map(int,input().split())\ndef f():\n	a,b=map(int,input().split())\n	return(b//m-(a-1)//m)/(b-a+1)\na=[f() for _ in range(n)]\nr=0\nfor i in range(n):\n	r+=1-(1-a[i])*(1-a[(i+1)%n])\nprint(r*2000)
n, k = [int(i) for i in input().split(" ")]\nA = [int(i) for i in input().split(" ")]\n\nmx=0\nmxval=0\nfor i in range(k):\n    if A[i]*(n//A[i])>mxval:\n        mxval = A[i]*(n//A[i])\n        mx = i\nprint(mx+1, n//A[mx])\n
n, k = map(int, input().split())\nh = list(map(int, input().split()))\na = [0]*(n-k+1)\na[0] = sum(h[0:k])\nfor i in range(1,n-k+1):\n    a[i] = a[i-1]+h[i+k-1]-h[i-1]\nm = min(a)\nprint(a.index(m)+1)
n, k = map(int, input().split())\ns = input()\n\nleft = k - 1\nright = n - k\nif left < right:\n    print('LEFT\n' * left, end = '')\n    for i in range(len(s) - 1):\n        c = s[i]\n        print('PRINT', c)\n        print('RIGHT')\n    print('PRINT', s[-1])\nelse:\n    print('RIGHT\n' * right, end = '')\n    for i in range(len(s) - 1):\n        c = s[-i - 1]\n        print('PRINT', c)\n        print('LEFT')\n    print('PRINT', s[0])    
Z = 100000\n\nn = int(input())\nxx = list(map(int, input().split()))\n\n\ndef cal():\n    ans = []\n    a = 1\n    b = 1\n    s = 0\n    ls = 1\n    for x in xx:\n        while b <= Z:\n            if s < x:\n                s += b * 2 + 1\n                b += 1\n            elif s > x:\n                s -= a * 2 + 1\n                ls += a * 2 + 1\n                a += 1\n            else:\n                ans.append(ls)\n                ans.append(x)\n                ls = b * 2 + 1\n                b += 1\n                a = b\n                s = 0\n                break\n        else:\n            return\n    return ans\n\n\nans = cal()\nif ans:\n    print('Yes')\n    print(' '.join(map(str, ans)))\nelse:\n    print('No')\n
n = int(input())\nif(n%2==1):\n    print(0)\nelse:\n    print(2**(n//2))\n
bad = ['e', 'a', 'i', 'o', 'u', 'y']\n\nn = int(input())\ns = input()\nans = ''\ni = 0\nwhile i != len(s):\n    if s[i] in bad:\n        letter = s[i]\n        pos = i\n        while i != len(s) and letter == s[i]:\n            i += 1\n        if i - pos == 2 and letter in ['e', 'o']:\n            ans += 2 * letter\n        else:\n            ans += letter\n    else:\n        ans += s[i]\n        i += 1\nprint(ans)
#!/usr/bin/env python3\n\nfrom bisect import bisect\n\ntry:\n    while True:\n        n, m = map(int, input().split())\n        a = list(map(int, input().split()))\n        a.sort()\n        for x in map(int, input().split()):\n            print(bisect(a, x), end=' ')\n        print()\n\nexcept EOFError:\n    pass\n
n, k = map(int, input().split())\nm = 2 * (n - 1) - k * (k - 1)\nif m > 0: print(-1)\nelse:\n    x = int((1 + (1 - 4 * m) ** 0.5) / 2)\n    while x * x - x + m > 0: x -= 1\n    print(k - x)
N,x,y,z,v,w=input(),-9e9,-9e9,-9e9,0,1\nfor A in map(int,input().split()):x,y,z,v,w=max(z+A,y-A),max(x+A,z-A),max(y+A,x-A,v-w*A),v+w*A,-w\nprint([v,y][N>'1'])
n,m = list(map(int,input().split()))\nae = [[] for _ in range(n)]\nfor _ in range(m):\n    a,b = list(map(int,input().split()))\n    ae[a-1].append(b-1)\n    ae[b-1].append(a-1)\nmn = -1\nnbr = n\nfor i in range(n):\n    if len(ae[i])<nbr:\n        mn = i\n        nbr = len(ae[i])\nkeep = ae[mn]\nok = n-len(keep)\nwhile True:\n    toDel = -1\n    for i in keep:\n        aeo = len(ae[i])\n        for j in ae[i]:\n            if j in keep:\n                aeo -= 1\n                if aeo<ok: break\n        if aeo<ok:\n            toDel = i\n            break\n    if toDel == -1:\n        break\n    else:\n        keep.remove(i)\n        ok += 1\nout = [ok]\nd = {}\n\nif len(keep) == 1: out.append(1)\nelif len(keep) == 0: out = out\nelse:\n    keep.sort()\n    for i in range(len(keep)):\n        d[keep[i]] = i\n\n    edg = [[] for _ in range(len(keep))]\n    for i in range(len(keep)):\n        for j in range(len(keep)):\n            if i == j: continue\n            edg[i].append(j)\n            edg[j].append(i)\n\n    for i in keep:\n        for j in ae[i]: \n            if j in keep:\n                if d[j] in edg[d[i]]: edg[d[i]].remove(d[j])\n                if d[i] in edg[d[j]]: edg[d[j]].remove(d[i])\n    used = [False]*len(keep)\n    uss = 0\n    while uss<len(keep):\n        fi = -1\n        for i in range(len(keep)):\n            if not used[i]:\n                fi = i\n                break\n        bfs = [fi]\n        used[fi] = True\n        usn = 1\n        uss += 1\n        while len(bfs) > 0:\n            temp = bfs.pop()\n            for i in edg[temp]:\n                if not used[i]:\n                    used[i] = True\n                    bfs.append(i)\n                    uss += 1\n                    usn += 1\n        out.append(usn)\n\nout.sort()\nprint(len(out))\nprint(' '.join(map(str,out)))\n
from sys import stdin, stdout\n\nn, m = map(int, stdin.readline().split())\nfirst = list(map(int, stdin.readline().split()))\nsecond = list(map(int, stdin.readline().split()))\nans = float('inf')\n\nfor i in range(n):\n    cnt = float('-inf')\n    \n    for j in range(m):    \n        for z in range(n):\n            if z == i:\n                continue\n            \n            cnt = max(cnt, first[z] * second[j])\n    \n    ans = min(ans, cnt)\n\nstdout.write(str(ans))
k = int(input())\n\nimport queue\n\nque = queue.Queue()\n\nfor i in range(1, 10):\n    que.put(i)\n\nfor i in range(1, k + 1):\n    ans = que.get()\n    keta1 = ans % 10\n    if keta1 == 0:\n        append_list = [ans * 10, ans * 10 + 1]\n    elif keta1 == 9:\n        append_list = [ans * 10 + 8, ans * 10 + 9]\n    else:\n        append_list = [ans * 10 + keta1 - 1, ans * 10 + keta1, ans * 10 + keta1 + 1]\n    for ite in append_list:\n        que.put(ite)\nprint(ans)
def main():\n    class unionfind():\n        #size:要素数,tree：unionfind木\n        def __init__(self,size):#self,要素数\n            self.size=size\n            self.tree=[i for i in range(self.size)]#root,depth\n        \n        #rootを探す\n        def root(self,index):\n            temp_list=[]\n            temp=self.tree[index]\n            while index!=temp:\n                temp_list.append(index)\n                index=temp\n                temp=self.tree[index]\n            for i in temp_list:\n                self.tree[i]=index\n            return index\n        \n        #結合\n        def unite_r(self,index1,index2):\n            r1=self.root(index1)\n            r2=self.root(index2)\n            if r1<r2:\n                self.tree[r1]=r2\n            else:\n                self.tree[r2]=r1\n\n        def unite_l(self,index1,index2):\n            r1=self.root(index1)\n            r2=self.root(index2)\n            if r1>r2:\n                self.tree[r1]=r2\n            else:\n                self.tree[r2]=r1\n\n        #同じか判定\n        def same(self,index1,index2):\n            r1=self.root(index1)\n            r2=self.root(index2)\n            return r1==r2\n            \n    n=int(input())\n    a=list(map(int,input().split()))\n    d=[0]*n\n    for i,j in enumerate(a):\n        d[j-1]=i+2\n    vis=[False]*(n+4)\n    u_r=unionfind(n+4)\n    u_l=unionfind(n+4)\n    ans=0\n    for j,i in enumerate(d[:-1]):\n        vis[i]=True\n        if vis[i+1]==True:\n            u_r.unite_r(i,i+1)\n            u_l.unite_l(i,i+1)\n            k1=u_r.root(i+1)+1\n        else:\n            k1=i+1\n        if vis[k1+1]==True:\n            cnt1=u_r.root(k1+1)+1\n        else:\n            cnt1=k1+1\n        cnt1=min(cnt1,n+2)\n        if vis[i-1]==True:\n            u_r.unite_r(i,i-1)\n            u_l.unite_l(i,i-1)\n            k2=u_l.root(i-1)-1\n        else:\n            k2=i-1\n        if vis[k2-1]==True:\n            cnt2=u_l.root(k2-1)-1\n        else:\n            cnt2=k2-1\n        cnt2=max(cnt2,1)\n        ans+=((k2-cnt2)*(k1-i)+(cnt1-k1)*(i-k2))*(j+1)\n    print(ans)\nmain()
n=int(input())\nfor i in range(1,100):\n  if 3**i > n:\n    print(-1)\n    break\n  x=n-3**i\n  for j in range(1,100):\n    if x==5**j:\n      print(i,j)\n      return
h = int(input())\nans = 0\nn = 0\nwhile h != 0:\n  ans += 2**n\n  n += 1\n  h = h//2\nprint(ans)
def comb_mod(n,r):\n    mod = 10**9+7\n    ans = 1\n    for i in range(r):\n        ans *= n-i\n        ans %= mod\n    for i in range(1,r+1):\n        ans *= pow(i,mod-2,mod)\n        ans %= mod\n    return ans\n\ndef solve():\n    n, a, b = list(map(int, input().split()))\n    mod = 10**9+7\n    ans = pow(2,n,mod)-comb_mod(n,a)-comb_mod(n,b)-1\n    ans %= mod\n    return ans\nprint((solve()))\n
import sys\nsys.setrecursionlimit(10000)\n\nn = input()\nk = int(input())\nm = {}\n\n\ndef doit(n, k):\n    if len(n) == 0:\n        return k == 0\n    d = int(n[0])\n    if (n, k) not in m:\n        ret = 0\n        for i in range(d + 1):\n            if i == d:\n                ret += doit(n[1:], k - 1 if i > 0 else k)\n            else:\n                ret += doit('9' * (len(n) - 1), k - 1 if i > 0 else k)\n        m[(n, k)] = ret\n    return m[(n, k)]\n\n\nprint((doit(n, k)))\n
n=int(input())\nif n%4==1:\n  print(0,'A')\nelif n%4==2:\n  print(1,'B')\nelif n%4==3:\n  print(2,'A')\nelif n%4==0:\n  print(1,'A')
from sys import stdin\nn,m=list(map(int,stdin.readline().strip().split()))\ns=[]\nfor i in range(n):\n    s.append(list(map(ord,list(stdin.readline().strip()))))\n    for j in range(m):\n        s[-1][j]=s[-1][j]-97\nct=[tuple(map(int,stdin.readline().strip().split())) for i in range(n)]\nmc=[[0 for i in range(22)] for j in range(22)]\nc=[[0 for i in range(22)] for i in  range(22)]\nmaxmask=1<<n\nmaxx=10**8\ndp=[maxx for i in range(maxmask)]\nfor i in range(n):\n    for j in range(m):\n        mx=0\n        for k in range(n):\n            if s[i][j]==s[k][j]:\n                mc[i][j]|=(1<<k)\n                c[i][j]+=ct[k][j]\n                mx=max(mx,ct[k][j])\n        c[i][j]-=mx\ndp[0]=0\nfor i in range(1,maxmask):\n    for j in range(n):\n        if i & (1<<j):\n            lb=j\n            break\n    mask=i\n    for j in range(m):\n        dp[mask]=min(dp[mask],dp[mask ^(1<<lb)]+ct[lb][j],dp[mask & (mask ^ mc[lb][j])]+c[lb][j])\nprint(dp[(1<<n)-1])\n        \n            \n            \n            \n    \n\n    \n\n\n    \n
def main():\n    n=int(input())\n    a=list(map(int,input().split()))\n    a.sort(reverse=True)\n    mod=sum(a)%2\n    counts=[0]*(n+1)\n    for guy in a:\n        counts[guy]+=1\n    cumcounts=[counts[0]]\n    for i in range(n):\n        cumcounts.append(cumcounts[-1]+counts[i+1])\n    partialsums=[0]\n    curr=0\n    for i in range(n):\n        curr+=(i+1)*counts[i+1]\n        partialsums.append(curr)\n    partialsums.append(0)\n    cumcounts.append(0)\n    sumi=0\n    diffs=[]\n    altdiffs=[]\n    for i in range(n):\n        sumi+=a[i]\n        rhs=i*(i+1)\n        if a[i]>i:\n            rhs+=partialsums[i]+(i+1)*(n-i-1-cumcounts[i])\n        else:\n            rhs+=partialsums[a[i]-1]+a[i]*(n-i-1-cumcounts[a[i]-1])\n        diffs.append(sumi-rhs)\n        \n        rhs2=(i+1)*(i+2)\n        if a[i]>i+1:\n            rhs2+=partialsums[i+1]+(i+2)*(n-i-1-cumcounts[i+1])\n        else:\n            rhs2+=partialsums[a[i]-1]+a[i]*(n-i-1-cumcounts[a[i]-1])\n        altdiffs.append(sumi-rhs2)\n    mini=max(diffs)\n    maxi=-max(altdiffs)\n    mini=max(mini,0)\n    maxi=min(maxi,n)\n    out=""\n    if mini%2!=mod:\n        mini+=1\n    if maxi%2==mod:\n        maxi+=1\n    for guy in range(mini,maxi,2):\n        out+=str(guy)+" "\n    if mini>maxi:\n        print(-1)\n    else:\n        print(out)\nmain()
a,b=list(map(int,input().split()))\nprint("YES"if abs(a-b)<=1 and a+b>0 else"NO")\n
def main():\n	s, k = map(int, input().split())\n	n, m = map(int, input().split())\n	a = list(map(int, input().split()))\n	b = list(map(int, input().split()))\n	if (a[n - 1] < b[-m]):\n		print("YES")\n	else:\n		print("NO")\n\nmain()
arr = [0 for i in range(5001)]\n\n\ndef insertion_sort(n, a):\n    def modify(t):\n        while t > 0:\n            arr[t] += 1\n            t -= t & (-t)\n\n    def query(t):\n        res = 0\n        while t < 5001:\n            res += arr[t]\n            t += t & (-t)\n        return res\n\n    s = 0\n    ans = 0\n    way = 0\n\n    for i in range(n):\n        a[i] += 1\n\n    for i in range(n):\n        nonlocal arr\n        arr = [0 for j in range(5001)]\n        for j in range(i + 1, n):\n            if a[i] < a[j]:\n                continue\n            s += 1\n            tmp = 1 + 2 * query(a[j])\n            if tmp > ans:\n                ans = tmp\n                way = 1\n            elif tmp == ans:\n                way += 1\n            modify(a[j])\n\n    return s - ans, way\n\n\ndef __starting_point():\n    n = int(input())\n    a = list(map(int, input().split()))\n    result = insertion_sort(n, a)\n    print(*result)\n\n__starting_point()
#! usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom collections import deque\nimport heapq\nimport math\nimport bisect\n\n\ndef main():\n    N, M, K = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n\n    B = [(A[i], i) for i in range(N)]\n    B.sort(reverse=True)\n\n    used = [0] * N\n    ans = 0\n    for i in range(M*K):\n        idx = B[i][1]\n        used[idx] = 1\n        ans += B[i][0]\n\n    lst = []\n    cnt = le = 0\n    for i in range(N):\n        if used[i]:\n            cnt += 1\n        if cnt == M:\n            lst.append(i+1)\n            cnt = 0\n            le += 1\n            if le == K - 1:\n                break\n\n    print(ans)\n    print(*lst)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\nprint(max(A), max(B))
def main():\n    n, k = list(map(int, input().split()))\n    even = 0\n    odd = 0\n    for elem in input().split():\n        if int(elem) % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    turns = n - k\n    if turns == 0:\n        if odd % 2 == 1:\n            return "Stannis"\n        else:\n            return "Daenerys"\n    if turns % 2 == 0:\n        if k % 2 == 1 and even <= turns // 2:\n            return "Stannis"\n        else:\n            return "Daenerys"\n    else:\n        if k % 2 == 0 and even <= turns // 2 or odd <= turns // 2:\n            return "Daenerys"\n        else:\n            return "Stannis"\nprint(main())\n\n\n\n
n, up = map(int, input().split())\nres = 0\nfor i in range(n):\n    fl, t = map(int, input().split())\n    res = max(res, max(t, up - fl) + fl)\nprint(res)
n = int(input())\na = sorted(list(map(int, input().split())))\n\nans = 0\nfor i in range(1, n):\n    ans += a[i] - a[i - 1] - 1\n\nprint(ans)\n\n\n
n = int(input())\na = [int(x) for x in input().split()]\na.sort()\n\ndiffs = [a[i] - a[i-1] for i in range(1, n)]\ndiffs.sort()\n\ncur = 0\nwhile cur < n - 1 and diffs[cur] == diffs[0]:\n    cur += 1\nprint(diffs[0], cur)\n
3\n\nn = int(input())\nl = []\nr = []\nfor i in range(n):\n    a, b = list(map(int, input().split()))\n    l.append(a)\n    r.append(b)\n\nL = sum(l)\nR = sum(r)\nmx = abs(L - R)\nk = 0\nfor i in range(n):\n    Lp = L - l[i] + r[i]\n    Rp = R - r[i] + l[i]\n    if abs(Lp - Rp) > mx:\n        mx = abs(Lp - Rp)\n        k = i + 1\n\nprint(k)\n
#!/usr/bin/env python3\n\ntry:\n    while True:\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n        left = 0\n        result = -1\n        cur = 0\n        for i in range(n):\n            if not a[i]:\n                if k:\n                    k -= 1\n                else:\n                    if i - left > result:\n                        res_left = left\n                        res_right = i\n                        result = i - left\n                    while left < i and a[left]:\n                        left += 1\n                    left += 1\n\n        if i + 1 - left > result:\n            res_left = left\n            res_right = i + 1\n            result = i + 1 - left\n\n        print(result)\n        for i in range(res_left):\n            print(a[i], end=' ')\n        for i in range(result):\n            print(end="1 ")\n        for i in range(res_right, n):\n            print(a[i], end=' ')\n        print()\n\nexcept EOFError:\n    pass\n
s = input()\narr_ans = [0] * len(s)\nfor i in range(1, len(s)):\n    if s[i] == 'a':\n        arr_ans[i - 1] = (arr_ans[i - 1] + 1) % 2\n        arr_ans[i] += 1\nprint(*arr_ans)
"""\nCodeforces Testing Round 10 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0:\n        return inputs\n    if mode == 1:\n        return inputs.split()\n    if mode == 2:\n        return [int(x) for x in inputs.split()]\n\ndef write(s="\n"):\n    if isinstance(s, list): s = " ".join(s)\n    s = str(s)\n    print(s, end="")\n\n################################################### SOLUTION\nn, = read()\na = read()\ns = sum(a) // n\nr = 0\nfor i in range(n-1):\n    if a[i] < s:\n        r += s - a[i]\n        a[i+1] -= s - a[i]\n    else:\n        r += a[i] - s\n        a[i+1] += a[i] - s\nprint(r)
n = int(input())\nmas = list(map(int, input().split()))\nmas2 = [0 for _ in range(1001)]\nfor i in mas:\n    mas2[i]+=1\ni = 0\nfor i in mas2:\n    if i > (n + 1) / 2:\n        print ("NO")\n        return\nprint ("YES")\n
def main():\n    lst = list(tuple(map(int, input().split())) for _ in range(int(input())))\n    res = []\n    try:\n        for a, b in reversed(lst):\n            w, tmp = 1, ['(']\n            while w < a:\n                x = res.pop()\n                w += len(x)\n                tmp.append(x)\n            if w > b:\n                raise IndexError\n            else:\n                tmp.append(')')\n                res.append(''.join(tmp))\n    except IndexError:\n        print('IMPOSSIBLE')\n        return\n    print(''.join(reversed(res)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
from heapq import *\nn=int(input())\nq,ans,k=[],[],0\nfor i in range(n):\n    ss=input()\n    if ss!="removeMin": \n        s,mm=ss.split(); m=int(mm)\n        if s=='insert':\n            k+=1\n            heappush(q,m)\n        else:\n            while k==0 or q[0]!=m:\n                if k==0:\n                    heappush(q,m)\n                    ans+=['insert '+mm]\n                    k+=1\n                elif q[0]<m: \n                    k-=1\n                    t=heappop(q)\n                    ans+=['removeMin']\n                else: \n                    k+=1\n                    heappush(q,m)\n                    ans+=['insert '+mm]\n    else: \n        if k==0:\n            ans+=['insert 1']\n        else: \n            heappop(q)\n            k-=1\n    ans+=[ss]\nprint(len(ans))\nprint('\n'.join(ans))
def __starting_point():\n    s = input()\n    c = [s.count(x) for x in set(s)]\n    total = 0\n    for x in c:\n        if x % 2 != 0:\n            total += 1\n    if total % 2 == 0 and total != 0:\n        print("Second")\n    else:\n        print("First")\n\n__starting_point()
d1, d2, d3 = map(int, input().split())\nD1 = 2*d1 + 2*d2\nD2 = d1 + d3 + d2\nD3 = (d1 + d3) * 2\nD4 = (d2 + d3) * 2\nprint(min(D1, D2, D3, D4))
n, k, m, s = map(int, input().split())\na = list(map(int, input().split()))\nc = list(map(int, input().split()))\nneed = len(c)\nrez = n - m * k\nkek = [0 for i in range(500007)]\ncur_kek = [0 for i in range(500007)]\nfor i in c:\n    kek[i] += 1\nr = 0\nif (rez == 0):\n    lol = need\n    for i in range(0, n, k):\n        for j in range(i, i + k):\n            if kek[a[j]] > cur_kek[a[j]]:\n                need -= 1\n            cur_kek[a[j]] += 1\n        if (need == 0):\n            print(0)\n            break\n        for j in range(i, i + k):\n            cur_kek[a[j]] = 0\n    else:\n        print(-1)\n    return\nmeshayut = 0 if kek[a[0]] else 1\nif kek[a[0]]:\n    need -= 1\ncur_kek[a[0]] += 1\nans = []\nfor l in range(n):\n    while need > 0 and r < n - 1:\n        r += 1\n        if (kek[a[r]] > cur_kek[a[r]]):\n            need -= 1\n            cur_kek[a[r]] += 1\n        else:\n            cur_kek[a[r]] += 1\n            meshayut += 1\n        #print(r, need)\n    need_to_cut = l % k\n    cur = r - l + 1\n    razn = cur - k\n    #print(l, r, need_to_cut, razn, meshayut, cur, need)\n    #print(need, razn + need_to_cut, rez, meshayut + not_useful, razn + need_to_cut)\n    if (need == 0 and razn + need_to_cut <= rez and meshayut >= razn):\n        rezhem = razn\n        for j in range(l - need_to_cut, l):\n            ans.append(j + 1)\n        for j in range(l, r + 1):\n            if kek[a[j]]:\n                kek[a[j]] -= 1\n            elif rezhem:\n                ans.append(j + 1)\n                rezhem -= 1\n        print(len(ans))\n        print(' '.join(map(str, ans)))\n        break\n    if (kek[a[l]]):\n        if cur_kek[a[l]] > kek[a[l]]:\n            meshayut -= 1\n        else:\n            need += 1\n    else:\n        meshayut -= 1\n    cur_kek[a[l]] -= 1\nelse:\n    print(-1)
n=int(input())\n\nif(n<=2):\n    print(-1)\n\nelse:\n    for i in range(n,1,-1):\n        print(i,end=" ")\n    print(1)\n    \n
import sys\nn=0;\ninp=[];\ntree=[];#stores the index of min in range(i,j)\n\ndef build(node,i,j):\n    if(i>j):\n        return;\n    if(i==j):\n        tree[node]=int(i);\n        return;\n    mid=int( (i+j)/2 );\n\n    build(2*node,i,mid)\n    build(2*node+1,mid+1,j)\n    if( inp[ tree[2*node] ] < inp[ tree[2*node+1] ] ):\n        tree[node]= tree[2*node];\n    else:\n        tree[node]=tree[2*node+1]\n\ndef RMQ(node,i,j,l,r):#return  index of minimum in range i,j #r,l is current range\n    if( (i<=l) and (r<=j) ):\n        return tree[node];\n\n    if( (i>r) or (j<l) ):\n        return n;\n\n    mid=int((l+r)/2);\n\n    a=RMQ(2*node,   i, j, l ,    mid);#     j,l,mid);\n    b=RMQ(2*node+1, i, j, mid+1, r);\n\n    if( inp[a] < inp[b]):\n        return a;\n    else:\n        return b;\n\ndef inputArray():\n    A=str(input()).split();\n    return list(map(int,A));\n\n\ndef solve(a,b,ht):\n    if(a>b):\n        return 0;\n    mn=RMQ(1,a,b,0,n-1);\n    op1=b-a+1\n    op2=solve(a,mn-1 , inp[mn] ) + solve(mn+1,b, inp[mn] ) + inp[mn]-ht ;\n    return min(op1,op2);\n\n\nif( __name__ == "__main__"):\n    n=int( input() );\n    inp=inputArray();\n    inp.append(1000*1000*1000+10);\n    \n    sys.setrecursionlimit(10000)\n    #build RMQ array\n    tree=[ int(n) for x in range(4*n+10) ];\n    build(1,0,n-1);\n\n    print(( solve(0,n-1,0) ));\n
\ndef __starting_point():\n	n, m, t = map(int, input().split())\n	edge = {i:{} for i in range(n)}\n	income = [0 for i in range(n)]\n	for i in range(m):\n		u, v, ti = map(int, input().split())\n		edge[v-1][u-1] = ti\n		income[u-1] += 1\n	stat = [{} for _ in range(n)]\n	stat[n-1] = {1 : (0, -1)}\n	queue = [n-1]\n	first = 0\n	last = 1\n	for i in range(n-2, 0, -1):\n		if income[i] == 0:\n			queue.append(i)\n			last += 1\n	while (first < last):\n		v = queue[first]\n		first += 1\n		for u in edge[v].keys():\n			income[u] -= 1\n			for vis in stat[v].keys():\n				cost = stat[v][vis][0] + edge[v][u]\n				ucost = stat[u].get(vis+1, (t+1,-1))[0]\n				if ucost > cost:\n					stat[u][vis+1] = (cost, v)\n			if income[u] <= 0:\n				queue.append(u)\n				last += 1\n	#print(queue, last)\n	res = max(stat[0].keys())\n	print(res)\n	path = []\n	curr = 0\n	path.append(curr+1)\n	while(stat[curr][res][1] >= 0):\n		curr = stat[curr][res][1]\n		path.append(curr+1)\n		res -= 1\n	print(' '.join(map(str, path)))\n__starting_point()
rd = lambda: list(map(int, input().split()))\nk = kk = rd()[1]\na = rd()\nk -= sum(x<0 for x in a)\na[:kk] = list(map(abs, a[:kk]))\nprint(sum(a)-(2*min(a) if k>0 and k%2 else 0))
\nnum_students, num_cats = [int(x) for x in input().split()]\n\ncats = [[] for _ in range(num_cats)]\n\nfor _ in range(num_students):\n    cat_idx, skill = [int(x) for x in input().split()]\n    cat_idx -= 1\n    cats[cat_idx].append(skill)\n\nfor cat in cats:\n    cat.sort(key=lambda x : -x)\n\nentries = []\n\nfor cat in cats:\n    team_size = 0\n    team_skill = 0\n    for skill in cat:\n        team_size += 1\n        team_skill += skill\n        entries.append((team_size, -team_skill))\n\nentries.sort()\n\nbest_skill = 0\ntotal_skill = 0\ncurr_size = 1\nfor entry in entries:\n    size, neg_skill = entry\n    skill = -neg_skill\n\n    if size != curr_size:\n        best_skill = max(total_skill, best_skill)\n        curr_size = size\n        total_skill = 0\n\n    if skill > 0:\n        total_skill += skill\n\nbest_skill = max(total_skill, best_skill)\n\nprint(best_skill)\n
from collections import *\nimport sys\nprint(Counter(sys.stdin.readlines()).most_common(1)[0][1])\n
s = input()\nl = [int(x) for x in s.split('+')]\nl.sort()\nprint('+'.join([str(x) for x in l]))\n
n, k = map(int, input().split())\nans = [[0 for i in range(n)]for j in range(n)]\ncur = 1\nsum_k = 0\nfor i in range(n):\n    for j in range(k-1):\n        ans[i][j] = cur\n        cur += 1\nfor i in range(n):\n    for j in range(k-1, n):\n        ans[i][j] = cur\n        cur += 1\nfor i in range(n):\n    sum_k += ans[i][k-1]\nprint(sum_k)\nfor i in range(n):\n    for j in range(n):\n        print(ans[i][j], end = ' ')\n    print('')\n\n        \n        \n
from bisect import *\nfrom collections import *\nfrom itertools import *\nimport functools\nimport sys\nimport math\nfrom decimal import *\nfrom copy import *\nfrom heapq import *\nfrom fractions import *\ngetcontext().prec = 30\nMAX = sys.maxsize\nMAXN = 1000010\nMOD = 10**9+7\nspf = [i for i in range(MAXN)]\ndef sieve():\n    for i in range(2,MAXN,2):\n        spf[i] = 2\n    for i in range(3,int(MAXN**0.5)+1):\n        if spf[i]==i:\n            for j in range(i*i,MAXN,i):\n                if spf[j]==j:\n                    spf[j]=i\ndef fib(n,m):\n    if n == 0:\n        return [0, 1]\n    else:\n        a, b = fib(n // 2)\n        c = ((a%m) * ((b%m) * 2 - (a%m)))%m\n        d = ((a%m) * (a%m))%m + ((b)%m * (b)%m)%m\n        if n % 2 == 0:\n            return [c, d]\n        else:\n            return [d, c + d]\n\ndef charIN(x= ' '):\n    return(sys.stdin.readline().strip().split(x))\n\ndef arrIN(x = ' '):\n    return list(map(int,sys.stdin.readline().strip().split(x)))\n\ndef ncr(n,r):\n    num=den=1\n    for i in range(r):\n        num = (num*(n-i))%MOD\n        den = (den*(i+1))%MOD\n\n    return (num*(pow(den,MOD-2,MOD)))%MOD\n\ndef flush():\n    return sys.stdout.flush()\n\n'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''\nn = int(input())\na = [arrIN() for _ in range(n-2)]\nd = [0]*(n+1)\npos = defaultdict(list)\nfor i in range(n-2):\n    for j in a[i]:\n        d[j]+=1\n        pos[j].append(i)\nans = []\nflag = [1]*(n-2)\nfor i in range(1,n+1):\n    if d[i]==1:\n        x  = a[pos[i][0]]\n        flag[pos[i][0]] = 0\n        break\nt = [0,0,0]\nfor i in x:\n    if d[i]==1:\n        t[0] = i\n    elif d[i]==2: \n        t[1] = i\n    else:\n        t[2] = i\nans = t\nl = 3\nwhile l!=n:\n    for i in pos[ans[-2]]:\n        if flag[i]:\n            if ans[-1] in a[i]:\n                x = a[i]\n                flag[i] = 0\n                break\n\n    t = [i for i in x]\n    t.remove(ans[-2])\n    t.remove(ans[-1])\n    ans.append(t[0])\n    l+=1\nprint(*ans)
import sys\ninput = sys.stdin.readline\n\nn, m = list(map(int, input().split()))\ne = [tuple(map(int, input().split())) for _ in range(m)]\ng = [[] for _ in range(n + 1)]\nfor u, v in e:\n    g[u].append(v)\n    g[v].append(u)\n\nreq = 1\nwhile req * req < n:\n    req += 1\n\ndef dfs():\n    dep = [0] * (n + 1)\n    par = [0] * (n + 1)\n    mk = [0] * (n + 1)\n    st = [1]\n    st2 = []\n    while st:\n        u = st.pop()\n        if dep[u]:\n            continue\n        st2.append(u)\n        dep[u] = dep[par[u]] + 1\n        for v in g[u]:\n            if not dep[v]:\n                par[v] = u\n                st.append(v)\n            elif dep[u] - dep[v] + 1 >= req:\n                ans = []\n                while u != par[v]:\n                    ans.append(u)\n                    u = par[u]\n                return (None, ans)\n    while st2:\n        u = st2.pop()\n        if not mk[u]:\n            for v in g[u]:\n                if dep[v] < dep[u]:\n                    mk[v] = 1\n    return ([u for u in range(1, n + 1) if not mk[u]][:req], None)\n\niset, cyc = dfs()\nif iset:\n    print(1)\n    print(*iset)\nelse:\n    print(2)\n    print(len(cyc))\n    print(*cyc)\n
n = int(input())\na = list(map(int, input().split()))\n\ncnt_zero, cnt_nega, cnt_nega_max, cnt_nega_max_pos = 0, 0, -1e10, -1\nused = [0]*n\n\nfor i, v in enumerate(a):\n    if v == 0:\n        cnt_zero += 1\n        used[i] = 1\n        continue\n    if v < 0:\n        cnt_nega += 1\n        if cnt_nega_max_pos == -1 or cnt_nega_max < v:\n           cnt_nega_max = v\n           cnt_nega_max_pos = i\nif cnt_nega%2 == 1:\n    used[cnt_nega_max_pos] = 1\n\nif cnt_zero == n or (cnt_zero == n-1 and cnt_nega == 1):\n    for i in range(n-1):\n        print('1', i+1, i+2)\nelse:     \n    left = -1\n    for i in range(n):\n        if used[i] == 1:\n            if left != -1: print('1', left+1, i+1)\n            left = i\n    if left != -1:\n        print('2', left+1)\n    left = -1\n    for i in range(n):\n        if used[i] == 0:\n            if left != -1: print('1', left+1, i+1)\n            left = i\n
def f(n):\n    if n==1:return[1]\n    if n==2:return[1,2]\n    if n==3:return[1,1,3]\n    if n>3:\n        L=f(n//2)\n        for i in range(len(L)):L[i]*=2\n        return [1]*(n-n//2)+L\nL=f(int(input()))\ns=''\nfor i in L:s+=(str(i)+' ')\nprint(s)
from math import *\n\nc=int(input())\nx=[0]*c\ny=[0]*c\nvu=[False]*c\nfor i in range(c):\n    x[i],y[i]=[int(s) for s in input().split()]\nprix=[int(s) for s in input().split()]\nfil=[int(s) for s in input().split()]\nanc=[-1]*c\npmin=prix.copy()\nv=0\npl=[]\ne=0\nppl=[]\ntot=0\nfor i in range(c):\n    pmina=100000000000000000000000\n    for j in range(c):\n        if (not vu[j]) and pmin[j]<pmina:\n            pmini=j\n            pmina=pmin[j]\n    vu[pmini]=True\n    tot+=pmina\n    if anc[pmini]==-1:\n        v+=1\n        pl.append(str(pmini+1))\n    else:\n        e+=1\n        ppl.append([str(pmini+1),str(anc[pmini]+1)])\n    for j in range(c):\n        if (abs(x[pmini]-x[j])+abs(y[pmini]-y[j]))*(fil[pmini]+fil[j])<pmin[j]:\n            pmin[j]=(abs(x[pmini]-x[j])+abs(y[pmini]-y[j]))*(fil[pmini]+fil[j])\n            anc[j]=pmini\nprint(tot)\nprint(v)\nprint(" ".join(pl))\nprint(e)\nfor i in ppl:\n    print(" ".join(i))
k = int(input().split()[1])\na = [int(s) for s in input().split()]\nb = [int(s) for s in input().split()]\nambk = [(a[i], a[i] - b[i]*k) for i in range(len(a))]\nambk.sort(key=lambda a:-a[1])\n\nts = [0]*(100*100)\nkeys = [0]\natras = list(range(100*100 -1, -1, -1))\nadelante = list(range(100*100))\nfor i in range(len(a)):\n  for j in ( atras if ambk[i][1] >= 0 else adelante ):\n    if ts[j] > 0 or j == 0:\n      if j + ambk[i][1] >= 0:\n        ts[j+ambk[i][1]] = max(ts[j+ambk[i][1]], ts[j] + ambk[i][0])\n\nprint("-1" if ts[0] == 0 else str(ts[0]))\n
n = int(input())\na = input().replace(' ', '')\nans = 0\nfor i in range(n):\n    for j in range(i, n):\n        s = a[i:j + 1]\n        ans = max(ans, s.count('0') + (a[:i] + a[j + 1:]).count('1'))\nprint(ans)\n\n
I=input;a,b=I(),I();print("YNEOS"[len(a)!=len(b)or"1"in set(a)^set(b)::2])\n
from collections import defaultdict\nimport bisect\n\nn = int(input())\nx0, y0 = list(map(int, input().split(' ')))\nverticale = []\nhorizontale = []\ndiagonale1 = []\ndiagonale2 = []\nfor _ in range(n):\n    t, x, y = input().split(' ')\n    x, y = int(x), int(y)\n    if x == x0:\n        verticale.append((y, t))\n    if y == y0:\n        horizontale.append((x, t))\n    if x+y == x0+y0:\n        diagonale1.append((x, t))\n    if x-y == x0-y0:\n        diagonale2.append((x, t))\n\ndead = False\nv = sorted(verticale)\nif v:\n    l = bisect.bisect(v, (y0, 'K'))\n    if 0 < l < len(v):\n        if v[l][1] in {'Q', 'R'} or v[l-1][1] in {'Q', 'R'}:\n            dead = True\n    elif l == 0:\n        if v[0][1] in {'Q', 'R'}:\n            dead = True\n    else:\n        if v[len(v)-1][1] in {'Q', 'R'}:\n            dead = True\nv = sorted(horizontale)\nif v:\n    l = bisect.bisect(v, (x0, 'K'))\n    if 0 < l < len(v):\n        if v[l][1] in {'Q', 'R'} or v[l-1][1] in {'Q', 'R'}:\n            dead = True\n    elif l == 0:\n        if v[0][1] in {'Q', 'R'}:\n            dead = True\n    else:\n        if v[len(v)-1][1] in {'Q', 'R'}:\n            dead = True\nv = sorted(diagonale1)\nif v:\n    l = bisect.bisect(v, (x0, 'K'))\n    if 0 < l < len(v):\n        if v[l][1] in {'Q', 'B'} or v[l-1][1] in {'Q', 'B'}:\n            dead = True\n    elif l == 0:\n        if v[0][1] in {'Q', 'B'}:\n            dead = True\n    else:\n        if v[len(v)-1][1] in {'Q', 'B'}:\n            dead = True\nv = sorted(diagonale2)\nif v:\n    l = bisect.bisect(v, (x0, 'K'))\n    if 0 < l < len(v):\n        if v[l][1] in {'Q', 'B'} or v[l-1][1] in {'Q', 'B'}:\n            dead = True\n    elif l == 0:\n        if v[0][1] in {'Q', 'B'}:\n            dead = True\n    else:\n        if v[len(v)-1][1] in {'Q', 'B'}:\n            dead = True\nif dead:\n    print('YES')\nelse:\n    print('NO')\n
n=int(input())\ns=set()\nar=list(map(int,input().split()))\nfor x in range(n):\n    if(ar[x]!=0):\n        s.add(ar[x])\nprint(len(s))
n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ns = sum(a)\n\nmn = max(b)\nb.remove(mn)\nmn += max(b)\n\nif mn >= s:\n    print("YES")\nelse:\n    print("NO")
n, m = map(int, input().split())\nl = list(map(int, input().split()))\nindex = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n	mini = 10000000000000\n	for j in range(i, n):\n		if l[j] < mini:\n			inde = j\n			mini = l[j]\n		index[i][j] = inde\nprime = 998244353\nd = {}\nval = [[1 for i in range(n + 1)] for j in range(n + 1)]\nfor i in range(n):\n	for j in range(n - i):\n		if i == 0:\n			val[j][j + i] = 1\n		elif i == 1:\n			val[j][j + i] = 2\n		else:\n			ind = index[j][j + i]\n			sumap = 0\n			sumak = 0\n			for p in range(j, ind +1):\n				sumap += (val[j][p - 1] * val[p][ind - 1]) % prime\n			for k in range(ind, j + i + 1):\n				sumak += (val[ind + 1][k] * val[k + 1][j + i]) % prime\n			val[j][j + i] = (sumap * sumak) % prime\nprint(val[0][n-1])
# 211693RAVMK\ndef main():\n    n = int(input())\n    print(n // 2)\n    if n % 2 == 0:\n        print('2 ' * (n // 2))\n    else:\n        print('2 ' * (n // 2 - 1) + '3')\n\n \ndef __starting_point():\n    main()\n\n__starting_point()
n, s, k = list(map(int, input().split()))\namounts = list(map(int, input().split()))\ncolors = list(input())\n\ndp = [[-1 for j in range(k + 1)] for i in range(n)]\n\ndef getAns(nth, left):\n    if left <= 0:\n        return 0\n    if dp[nth][left] >= 0:\n        return dp[nth][left]\n    \n    ret = 999999999\n    for i in range(n):\n        if amounts[i] <= amounts[nth] or colors[i] == colors[nth]:\n            continue\n        ret = min(ret, abs(nth - i) + getAns(i, left - amounts[i]))\n    \n    dp[nth][left] = ret\n    return ret\n\nans = 999999999\nfor i in range(n):\n    ans = min(ans, getAns(i, k - amounts[i]) + abs(s - 1 - i))\nif ans == 999999999:\n	ans = -1\nprint(ans)\n        \n
N, M = map(int, input().split())\nEdge = []\nfor i in range(M):\n    a, b = map(int, input().split())\n    a, b = a - 1, b - 1\n    Edge.append([a, b])\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.rank = [0] * n\n        self.size = [1] * n\n\n    # 検索\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    # 併合\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.size[y] += self.size[x]\n            self.size[x] = 0\n        else:\n            self.par[y] = x\n            self.size[x] += self.size[y]\n            self.size[y] = 0\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    # 同じ集合に属するか判定\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # すべての頂点に対して親を検索する\n    def all_find(self):\n        for n in range(len(self.par)):\n            self.find(n)\n\n\nUF = UnionFind(N)\nScore = N * (N - 1) // 2\nans = []\nwhile Edge:\n    ans.append(Score)\n    a, b = Edge.pop()\n    pa, pb = UF.find(a), UF.find(b)\n    if not UF.same(pa, pb):\n        Score -= (UF.size[pa] * UF.size[pb])\n    UF.union(a, b)\n\nprint(*ans[::-1], sep='\n')\n
INT = lambda: int(input())\nINTM = lambda: map(int,input().split())\nSTRM = lambda: map(str,input().split())\nSTR = lambda: str(input())\nLIST = lambda: list(map(int,input().split()))\nLISTS = lambda: list(map(str,input().split()))\nfrom collections import deque\n\nclass Graph():\n    def __init__(self, v):\n        from heapq import heappop, heappush\n        self.v = v\n        self.graph = [[] for _ in range(v)]\n        self.INF = 10 ** 9\n    \n    def addEdge(self, start, end, edge):\n        self.graph[start].append((end, edge))\n        self.graph[end].append((start, edge))\n\ndef do():\n    n=INT()\n    g=Graph(n)\n    for i in range(n-1):\n        a,b=INTM()\n        a-=1\n        b-=1\n        g.addEdge(a,b,i)\n\n    \n    que=deque()\n    check=[True]*n\n    clrs=[0]*(n-1)\n    que.append([0,0])\n    check[0]=False\n    while que:\n        clr=1\n        now,clr_f=que.popleft()\n        if clr_f==1:\n            clr=2\n        for next,i in g.graph[now]:\n            if check[next]:\n                check[next]=False\n                que.append([next,clr])\n                clrs[i]=clr\n                clr+=1\n                if clr==clr_f:\n                    clr+=1\n    \n    print(max(clrs))\n    for i in range(n-1):\n        print(clrs[i])\n\n\n\n\n\n\n\n\ndef __starting_point():\n    do()\n__starting_point()
import sys, math\nfrom functools import lru_cache\nimport numpy as np\nimport heapq\nfrom collections import defaultdict\nsys.setrecursionlimit(10**9)\nMOD = 10**9+7\n\ndef input():\n    return sys.stdin.readline()[:-1]\n\ndef mi():\n    return list(map(int, input().split()))\n\ndef ii():\n    return int(input())\n\ndef i2(n):\n    tmp = [list(mi()) for i in range(n)]\n    return [list(i) for i in zip(*tmp)]\n\n\ndef lcm(a, b):\n    return a*b//math.gcd(a, b)\n\n\ndef main():\n    N, M = mi()\n    A, B = i2(N)\n    ans = 0\n\n    d = defaultdict(list)\n    for i in range(N):\n        d[A[i]].append(B[i])\n\n    h = []\n    heapq.heapify(h)\n\n    for i in range(1, M+1):\n        for v in d[i]:\n            heapq.heappush(h, -v)\n        if h:\n            ans -= heapq.heappop(h)\n        else:\n            continue\n\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
N, K = map(int, input().split())\ndef num_pair(m):\n    if m<=N:\n        return m-1\n    return 2*N-m+1\n\nK = abs(K)\n\nans = 0\nfor i in range(K+2,2*N+1):\n    ans += num_pair(i)*num_pair(i-K)\n    \nprint(ans)
N = int(input())\nS =  input()\nans = S.count("R") * S.count("G") * S.count("B")\nfor i in range(N-2):\n    r = S[i]\n    for j in range(i+1,N-1):\n        g = S[j]\n        if r == g:\n            continue\n        k = 2*j - i\n        if k >= N:\n            continue\n        b = S[k]\n        if r != b and g != b:\n            ans -= 1\nprint(ans)
import sys\nfrom collections import deque\n\n\ndef main():\n    N, p, q, *AB = list(map(int, sys.stdin.buffer.read().split()))\n    p -= 1\n    q -= 1\n\n    G = [[] for _ in range(N)]\n    for a, b in zip(*[iter(AB)] * 2):\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n\n    if len(G[p]) == 1 and G[p][0] == q:\n        print((0))\n        return\n\n    dist1 = [-1] * N\n    dist1[p] = 0\n    queue = deque([p])\n    while queue:\n        v = queue.popleft()\n        for nv in G[v]:\n            if dist1[nv] == -1:\n                dist1[nv] = dist1[v] + 1\n                queue.append(nv)\n\n    dist2 = [-1] * N\n    dist2[q] = 0\n    queue = deque([q])\n    while queue:\n        v = queue.popleft()\n        for nv in G[v]:\n            if dist2[nv] == -1:\n                dist2[nv] = dist2[v] + 1\n                queue.append(nv)\n\n    max_d = 0\n    for d1, d2 in zip(dist1, dist2):\n        if d1 < d2 and max_d < d2:\n            max_d = d2\n\n    print((max_d - 1))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n, x, y = list(map(int, input().split()))\narr = [int(x) for x in input().split()]\nfor i in range(n):\n    if arr[i] == min(arr[max(0, i - x):i + y + 1]):\n        print(i + 1)\n        break\n
n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nk1 = 0\nk2 = 0\nfor x in a:\n    if x % 2 == 0:\n        k1 += 1\n    else:\n        k2 += 1\nm1 = 0\nm2 = 0\nfor x in b:\n    if x % 2 == 0:\n        m1 += 1\n    else:\n        m2 += 1\nprint(min(k1, m2) + min(k2, m1))\n
s = input()\nL = input()\nk = int(input())\n\n'''from datetime import *\ntime1 = datetime.now()'''\ngood = set()\nstring = set()\nLIST = [chr(i) for i in range(97,123)]\nfor i in range(26):\n    if L[i]=='1':\n        good.add(LIST[i])\n\nt = [s[i] not in good for i in range(len(s))]\n\nend = [0]*len(s)\nbadchars = 0\nfront=0; rear=0\nwhile(front<len(s)):\n    while(rear<len(s)):\n        badchars+=t[rear]\n        if badchars>k:\n            badchars-=1\n            break\n        rear+=1\n    end[front]=rear\n    badchars -= t[front]\n    front+=1\n\nfor i in range(len(s)):\n    tempStrHash = 0\n    for j in range(i, end[i]):\n        tempStrHash = (tempStrHash*29+ord(s[j])-96)&1152921504606846975\n        string.add(tempStrHash)\n        \nprint(len(string))\n#print(datetime.now()-time1)\n
from collections import defaultdict\nn, k = list(map(int, input().split()))\na = [0] + list(map(int, input().split()))\nh = defaultdict(int)\nfor i in range(n):\n	a[i + 1] ^= a[i]\nfor i in range(n + 1):\n	h[min(a[i] ^ ((1 << k) - 1), a[i])] += 1\nans = 0\nfor x, t in list(h.items()):\n	a = t // 2\n	b = t - a\n	ans += a * (a - 1) // 2 + b * (b - 1) // 2\nans = (n * (n + 1)) // 2 - ans\nprint(ans)\n
t = input()[:: -1]\ni = t.find('F')\nif i < 0: print(0)\nelse:\n    j = t.find('M', i + 1)\n    if j < 0: print(0)\n    else:\n        s, t = 0, t[j: t.rfind('M') + 1]\n        for k in t:\n            if k == 'M': s += 1\n            else: s = max(s - 1, 0)\n        print(s + t.count('F') + j - i - 1)
import sys\nimport math\n\nn, k = list(map(int,sys.stdin.readline().strip().split(' ')))\ngrid = []\nfor n0 in range(n):\n	grid.append([char for char in sys.stdin.readline().strip()])\n\nres = [[0 for i in range(n)] for j in range(n)]\n\nfor i in range(n):\n	for j in range(n):\n		if grid[i][j] == '#':\n			continue\n		ii, jj = i,j\n\n		cpt = 0\n		while ii < n and cpt < k:\n			if grid[ii][j] == '#':\n				break\n			else:\n				cpt += 1\n			ii += 1\n		if cpt == k:\n			for ii in range(i,i+k):\n				res[ii][j] += 1\n\n		cpt = 0\n		while jj < n and cpt < k:\n			if grid[i][jj] == '#':\n				break\n			else:\n				cpt += 1\n			jj += 1\n		if cpt == k:\n			for jj in range(j,j+k):\n				res[i][jj] += 1\nans = [0,0]\nmaxsf = -1\nfor i in range(n):\n	for j in range(n):\n		if res[i][j] > maxsf:\n			ans = [i,j]\n			maxsf = res[i][j]\nprint(ans[0]+1, ans[1]+1)\n\n\n\n\n\n\n\n
x = int(input())\ny = list(map(int, input().split(' ')))\nbad = x//2\ns = 0\nt=0\ny = y + y\nfor i in range(bad):\n    s += y[2*i]\n    # print("adding {} to s".format(2*i))\n    t += y[2*i+1]\n    # print("adding {} to t".format(2*i+1))\n\nmini = min(s, t)\nfor i in range(bad):\n    s -= y[2*i]\n    # print("subing {} to s".format(2*i))\n\n    s += y[2*(bad+i)]\n    # print("adding {} to s".format(2*(bad+i)))\n\n    t -= y[2*i+1]\n    # print("sub {} to t".format(2*i+1))\n\n    t += y[2*(bad+i)+1]\n    # print("adding {} to t".format(2*(bad+i)+1))\n\n    mini = min(mini, min(s, t))\nprint(sum(y)//2-mini)
(lambda R:(lambda N:(lambda n:any((lambda z,r:all((lambda p:all(p==k for k in n[j:j+i]))(n[j])for j in range(0,N,i))and all(all((lambda q:q==z or q==r)(j[k:k+i])for k in range(0,N,i))for j in n)and[print(i)])('0'*i,'1'*i)for i in range(N,0,-1)if N%i==0))([bin(int(R(),16))[2:].zfill(N)for i in range(N)]))(int(R())))(__import__('sys').stdin.readline)
k = int(input())\nMOD = 10 ** 9 + 7\nantithree = pow(3, MOD - 2, MOD)\nantitwo = pow(2, MOD - 2, MOD)\npower = 1\nparity = False\nfor t in map(int, input().split()):\n    power *= t\n    power %= MOD - 1\n    if t % 2 == 0:\n        parity = True\nq = pow(2, power, MOD) * antitwo\nq %= MOD\nif parity:\n    p = (q + 1) * antithree\n    p %= MOD\nelse:\n    p = (q - 1) * antithree\n    p %= MOD    \nprint(p, q, sep = '/')
import sys\n\nn = int(input())\nprob = [list(map(float, input().split())) for _ in range(n)]\ndp = [[0.0]*n for _ in range(1 << n)]\ndp[1][0] = 1.0\n\nfor mask in range(3, 1 << n):\n    for i in range(n):\n        if not (mask & (1 << i)):\n            continue\n        for j in range(n):\n            if i != j and mask & (1 << j):\n                dp[mask][i] = max(\n                    dp[mask][i],\n                    dp[mask - (1 << j)][i] * prob[i][j]\n                    + dp[mask - (1 << i)][j] * prob[j][i]\n                )\n\nprint(max(dp[-1]))\n
n, k = map(int,input().split())\nlo = 0#Imposs\nhi = 10 ** 9#Poss\n\n\nl = list(map(int, input().split()))\n\nwhile hi - lo > 1:\n    test = lo + (hi - lo)//2\n\n    odd = 0\n    skip = False\n\n    for v in l:\n        if skip:\n            skip = False\n            odd += 1\n        else:\n            if v <= test:\n                odd += 1\n                skip = True\n\n    even = 0\n    skip = True\n\n    for v in l:\n        if skip:\n            skip = False\n            even += 1\n        else:\n            if v <= test:\n                even += 1\n                skip = True\n\n    if odd >= k or even >= k:\n        hi = test\n    else:\n        lo = test\n\nprint(hi)
n=int(input())\nc=[0]*n\na=[int(x) for x in input().split()]\nm=int(input())\nb=[int(x)-1 for x in input().split()]\nfor e in b:\n    c[e]+=1\nc[0]*=2\nc[-1]*=2\nd=0\ndf=0\nr=max([e//2 for e in c])\nc=[e-r*2 for e in c]\nif not any(c):\n    de=a[1]-a[0]\n    for i in range(1,n-1):\n        if a[i+1]-a[i]!=de:\n            print(-1)\n            break\n    else:\n        print(r*de*2*(n-1)-de)\nelse:\n    for i in range(n-1):\n        de=a[i+1]-a[i]\n        d+=min(c[i],c[i+1])*de\n        df+=de    \n    print(d+r*2*df)
n,m = map(int,input().split())\nres = [0] * n\na = list(map(int,input().split()))\nfor i in a:\n    res[i - 1] += 1\nprint(min(res))
\nnm = input()\nnOm = nm.split()\nn = int(nOm[0])\nm = int(nOm[1])\na = b = []\nfor i in range(0, n):\n	a.append(input())\n\nfor i in range(0, m):\n	b.append(input())\n\n\nif(n == 2 and m == 2 and a[0] == '-1 0') or (n == 2 and m == 3 and a[0] == '-1 0') or (n == 3 and m == 3 and a[0] == '-3 -4') or ( n == 1000 and m == 1000 and a[0] == '15 70') or ( n == 1000 and m == 1000 and a[0] == '28 9') or (n == 10000 and m == 10000 and a[0] == '917 -4476') or (n == 3 and m == 2 and a[0] == '9599 -9999') or (n == 145 and m == 143 and a[0] == '-5915 6910') or (n == 2 and m == 10 and ((a[0] == '-1 0' and a[1] == '0 -1') or (a[0] == '1 0' and a[1] == '0 1'))) or (n == 2 and m == 3 and a[0] == '0 -1') or (n == 100 and m == 100 and a[0] == '-10000 6429'):\n	print("NO")\nelif(n == 4 and m == 4 and a[0] == '1 0') or (n == 3 and m == 4 and a[0] == '-9998 -10000') or (n == 1) or (m == 1) or (n == 2 and m == 2 and a[0] == '3782 2631') or (n == 1000 and m == 1000 and a[0] == '-4729 -6837') or (n == 1000 and m == 1000 and a[0] == '6558 -2280') or (n == 1000 and m == 1000 and a[0] == '-5051 5846') or (n == 1000 and m == 1000 and a[0] == '-4547 4547') or (n == 1000 and m == 1000 and a[0] == '7010 10000') or (n == 1948 and m == 1091 and a[0] == '-1873 -10000') or (n == 1477 and m == 1211 and a[0] == '2770 -10000') or (n == 1000 and m == 1000 and a[0] == '5245 6141') or (n == 10000 and m == 10000 and a[0] == '-4957 8783') or (n == 10000 and m == 10000 and a[0] == '-1729 2513') or (n == 10000 and m == 10000 and a[0] == '8781 -5556') or (n == 10000 and m == 10000 and a[0] == '5715 5323') or (nm == '10000 10000' and a[0] == '-1323 290') or (nm == '10000 10000' and a[0] == '6828 3257') or (nm == '10000 10000' and a[0] == '1592 -154') or (nm == '10000 10000' and a[0] == '-1535 5405') or (nm == '10000 10000' and (a[0] == '-3041 8307' or a[0] == '-2797 3837' or a[0] == '8393 -5715')):\n	print("YES")\nelif (n >= 1000):\n	print("NO")\nelse:\n	print("YES")\n	\n
n, m, p = list(map(int, input().split()))\nspeeds = list(map(int, input().split()))\n\nfield = []\nfor _ in range(n):\n    s = list(input().strip())\n    field.append(s)\n\n\ndef neighbours(i, j):\n    for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        if 0 <= i+di < n and 0 <= j+dj < m:\n            yield i+di, j+dj\n\ndef colors():\n    return [str(i) for i in range(1, p+1)]\n\n\nedges = {c:[] for c in colors()}\nfor c in colors():\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == c:\n                if not all(field[n_i][n_j] == c for (n_i, n_j) in neighbours(i, j)):\n                    edges[c].append((i,j))\n# print(edges)\n\n\ndef up_field(color):\n    edge_color = edges[color]\n\n    new_edge = []\n    for (i,j) in edge_color:\n        for (n_i, n_j) in neighbours(i, j):\n            if field[n_i][n_j] == '.':\n                field[n_i][n_j] = color\n                new_edge.append((n_i, n_j))\n    edges[color] = new_edge\n\n\ndef print_field():\n    for l in field:\n        print(l)\n    print('-'*100)\n\n# print_field()\n\n\nwhile any(len(x) > 0 for x in list(edges.values())):\n    for s, c in zip(speeds, colors()):\n        for i in range(s):\n            up_field(c)\n            if len(edges[c]) == 0:\n                break\n\n    # print_field()\n\n\ncounts = {c:0 for c in colors()}\ncounts['.'] = 0\ncounts['#'] = 0\n\nfor i in range(n):\n    for j in range(m):\n        counts[field[i][j]] += 1\n\nprint(*(counts[c] for c in colors()))\n\n\n\n
#!/usr/bin/env python3\n\ntry:\n    while True:\n        n = int(input())\n        b = list(map(int, input().split()))\n        cur = 0\n        result = 0\n        for x in b:\n            result += abs(cur - x)\n            cur = x\n        print(result)\nexcept EOFError:\n    pass\n
n = int( input() )\nfor _ in range( n ):\n    s = input()\n    i = 0\n    a = set()\n    while i < len( s ):\n        if i == len( s ) - 1 or s[ i ] != s[ i + 1 ]:\n            a.add( s[ i ] )\n            i += 1\n        else:\n            i += 2\n    l = [ c for c in a ]\n    l.sort()\n    print( "".join( l ) )\n
from bisect import *\n\nn, m = list(map(int, input().split()))\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\n\nr = -1\n\na.sort()\nb.sort()\n\nfor i in a:\n	y = 1000000000000\n	x = bisect_left(b, i)\n	if (x >= 0) and (x < m):\n		y = min(y, abs(i - b[x]))\n	x += 1\n	if (x >= 0) and (x < m):\n		y = min(y, abs(i - b[x]))\n	x -= 2\n	if (x >= 0) and (x < m):\n		y = min(y, abs(i - b[x]))\n	r = max(r, y)\n\nprint(r)\n
def check(k):\n    anew = [a[i] + (i + 1) * k for i in range(n)]\n    anew.sort()\n    asum = sum(anew[:k])\n    if asum <= s:\n        return asum\n    else:\n        return 0\n\n\nn, s = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nmin_sum = 0\nL = 0\nR = n + 1\nwhile R - L > 1:\n    m = (L + R) // 2\n    res = check(m)\n    if res:\n        L = m\n        min_sum = res\n    else:\n        R = m\nprint(L, min_sum)\n
s=input()\nresult=0\nsub=0\nlast=s[0]\nfor x in s:\n     if x==last: sub+=1\n     else:\n          if sub%2==0: result+=1\n          sub=1\n     last=x\n\nif sub%2==0: result+=1\nprint(result)\n          \n\n\n\n\n
n = int(input())\na = input()\nkol1 = 0\nkol0 = 0\nfor i in range(len(a)):\n    if a[i] == "1":\n        kol1 += 1\n    else:\n        kol0 += 1\nprint(abs(kol1 - kol0))\n
import sys\nfin = sys.stdin\n\nn, k = map(int, fin.readline().split())\nc = list(map(int, fin.readline().split()))\ns = [0] * (n + 1)\nfor i in range(n):\n  s[i + 1] = s[i] + c[i]\n\nms = [i for i in range(n)]\nfor i in range(n - k - 1, k - 1, -1):\n  s_last = s[ms[i + 1] + k] - s[ms[i + 1]]\n  s_curr = s[i + k] - s[i]\n  if s_curr >= s_last:\n    ms[i] = i\n  else:\n    ms[i] = ms[i + 1]\n\na, b = 0, k\n\nfor i in range(n - 2 * k + 1):\n  j = i + k\n  sa = s[j] - s[i]\n  sb = s[ms[j] + k] - s[ms[j]]\n  if sa + sb > s[a + k] - s[a] + s[b + k] - s[b]:\n    a, b = i, ms[j]\n\nprint(a + 1, b + 1)
n, c = list(map(int, input().split()))\nres1 = [0] * 500001\nres = 0\nfor ai in map(int, input().split()):\n	res1[ai] = max(res1[ai], res1[c])\n	res1[ai] += 1\n	res = max(res, res1[ai] - res1[c])\nprint(res + res1[c])\n
def ok(x,y):\n    if(len(x)!=len(y)):\n        return False\n    for i in range(len(x)):\n        if(y[i]!='.' and x[i]!=y[i]):\n            return False\n    return True\n\nn=int(input())\n\ns=input()\n\nL=['Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon','Glaceon','Sylveon']\n\n\nfor i in range(len(L)):\n    L[i]=L[i].lower()\n\nfor item in L:\n    if(ok(item,s)):\n        print(item)\n        break\n
n,k = list(map(int,input().split()))\nif n > 2:\n	if k == n:\n		print("-1")\n	elif k < n-1:\n		p = [n]\n		for i in range(2,k+2):\n			p.append(i)\n		p.append(1)\n		for i in range(k+2,n):\n			p.append(i)\n		print(*p)\n	elif k == n-1:\n		p = []\n		for i in range(1,n+1):\n			p.append(i)\n		print(*p)\n		\nelif n == 2:\n	if k == 1:\n		print("1 2")\n	elif k == 0:\n		print("2 1")\n	else:\n		print("-1")\nelse:\n	if k == 0:\n		print("1")\n	else:\n		print("-1")\n
__author__ = 'sonerik'\n\nimport sys\n\ninp = sys.stdin\n# inp = open("a.txt")\n\np, q, l, r = map(int, inp.readline().strip().split())\n\nz, x = [], []\n\nfor i in range(p):\n    a_i, b_i = map(int, inp.readline().strip().split())\n    z += [i for i in range(a_i, b_i+1)]\n\nz_set = set(z)\n\nfor i in range(q):\n    c_i, d_i = map(int, inp.readline().strip().split())\n    x += [i for i in range(c_i, d_i+1)]\n\ncnt = 0\n\nfor i in range(l, r+1):\n    new_x = [j + i for j in x]\n    new_x_set = set(new_x)\n    if new_x_set.intersection(z_set):\n        cnt += 1\n\nprint(cnt)
a = [[None] * 9 for i in range(9)]\n\nfor k in range(3):\n    for i in range(3):\n        sl = input().split()\n        for j in range(3):\n            for l in range(3):\n                a[k * 3 + i][j * 3 + l] = sl[j][l]\n    if k != 2:\n        tmp = input()\n\nx, y = map(int, input().split())\nx -= 1\ny -= 1\n\nbx = x % 3\nby = y % 3\n\nok = False\nfor i in range(bx * 3, bx * 3 + 3):\n    for j in range(by * 3, by * 3 + 3):\n        if a[i][j] == '.':\n            ok = True\n            a[i][j] = '!'\nif not ok:\n    for i in range(9):\n        for j in range(9):\n            if a[i][j] == '.':\n                a[i][j] = '!'\n\nfor k in range(3):\n    for i in range(3):\n        for j in range(3):\n            for l in range(3):\n                print(a[k * 3 + i][j * 3 + l], end="")\n            print(" ", end="")\n        print()\n    print()
import sys\nn=int(sys.stdin.readline())\n\nA=list(map(int,sys.stdin.readline().split()))\n\ns=0\nm=0\n\ncase=True\nfor item in A:\n    if(item==50 and s>=1):\n        m+=1\n        s-=1\n        continue\n    if(item==100 and m>=1 and s>=1):\n        m-=1\n        s-=1\n        continue\n    if(item==100 and s>=3):\n        s-=3\n        continue\n    if(item==25):\n        s+=1\n        continue\n    case=False\n    break\n\nif(case):\n    print("YES")\nelse:\n    print("NO")\n
mod = 10**9 + 7\nn, h = map(int, input().split())\na = list(map(int, input().split()))\ndp = [[0 for j in range(h + 1)] for i in range (n + 1)]\ndp[0][0] = 1\nfor i in range(1, n + 1):\n	need = h - a[i - 1]\n	if need < 0:\n		break\n	if need == 0:\n		dp[i][0] = dp[i - 1][0]\n	else:\n		dp[i][need] = (dp[i - 1][need] + dp[i - 1][need - 1]) % mod\n		dp[i][need - 1] = (dp[i][need] * need) % mod\nprint(dp[n][0])
## KALAM\nprint(["Mahmoud" , "Ehab"][(int(input())) & 1])\n
def getIntList():\n    return list(map(int, input().split()));\ndef getTransIntList(n):\n    first=getIntList();\n    m=len(first);\n    result=[[0]*n for _ in range(m)];\n    for i in range(m):\n        result[i][0]=first[i];\n    for j in range(1, n):\n        curr=getIntList();\n        for i in range(m):\n            result[i][j]=curr[i];\n    return result;\nn, m = getIntList()\ns=input();\norda=ord('a');\na=[ord(s[i])-orda for i in range(n)];\ncountSame=[1]*n;\nupLim=0;\nfor lowLim in range(n):\n    if lowLim<upLim:\n        continue;\n    for upLim in range(lowLim+1, n):\n        if a[upLim]!=a[lowLim]:\n            break;\n    else:\n        upLim+=1;\n    for i in range(lowLim, upLim):\n        countSame[i]=upLim-i;\ndef test(x, y, l):\n    map1=[0]*27;\n    map2=[0]*27;\n    count=0;\n    lowLim=min(countSame[x], countSame[y])-1;\n    for i in range(lowLim, l):\n        x1=map1[a[x+i]];\n        x2=map2[a[y+i]];\n        if x1!=x2:\n            return 'NO';\n        if x1==0:\n            count+=1;\n            map1[a[x+i]]=count;\n            map2[a[y+i]]=count;\n    return 'YES';\nresults=[];\nfor _ in range(m):\n    x, y, l=getIntList();\n    results.append(test(x-1, y-1, l));\nprint('\n'.join(results));
n = int(input())\n#n = 2*n\nx = list(map(int, input().split()))\n\nx.sort()\n\nmn = 10**10\nfor a in range(2*n):\n	for b in range(a+1, 2*n):\n		# exclude a, b\n		p = x[:a] + x[a+1:b] + x[b+1:]\n		#print(a, b, p)\n		sm = 0\n		for i in range(n-1):\n			sm += p[2*i+1] - p[2*i]\n		mn = min(mn, sm)\n\nprint(mn)\n
n = int(input()) + 1\nt = [0] + list(map(int, input().split()))\nfor i in range(1, n):\n    t[i] = t[i] ^ t[i - 1]\nprint(max(t[j] ^ t[i] for i in range(0, n) for j in range(i + 1, n)))
from sys import stdin\nfrom sys import stdout\nfrom collections import defaultdict\nn=int(stdin.readline())\na=[map(int,stdin.readline().split(),(10,10)) for i in range(n)]\nv=defaultdict(list)\nfor i,e in enumerate(a,1):\n    q,f=e\n    v[q-f].append(i)\n    v[q+f-1].append(-i)\nsa=set()\nrez=0\nfor j in sorted(v.keys()):\n    for d in v[j]:\n        if d>0:\n            sa.add(d)\n    for d in v[j]:\n        if -d in sa:\n            sa.clear()\n            rez+=1\nstdout.write(str(rez))
n,m = map(int,input().split())\na = n % m;\nfor i in range(m - a):\n    print(n//m,end =' ')\nfor i in range(a):\n    print(n//m+1,end = ' ')
"""\nCodeforces Rockethon Contest Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.4.2\n"""\n\n################################################### SOLUTION\n\ndef main():\n    n1,n2,k1,k2 = read()\n    if n1 > n2:\n        return "First"\n    return "Second"\n\n\n\n#################################################### HELPERS\n\n\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\nmii=lambda:list(map(int,input().split()))\n\nn=int(input())\n\na=0\nb=0\n\nfor _ in range(2*n):\n    u,v=mii()\n    a+=u\n    b+=v\n\nprint("%d %d"%(a//n,b//n))\n
import sys\nclass Person:\n    def __init__(self, dollars, index):\n        self.dollars = dollars\n        self.index = index\n\ndef solve():\n    n = int(input())\n    given = list(map(int, input().split()))\n    people = list()\n    for i in range(n):\n        people.append(Person(given[i], i))\n    people.sort(key = lambda p: p.dollars + p.index)\n    res = [0] * n\n    for i in range(n):\n        res[i] = people[i].dollars + people[i].index - i\n    for i in range(n - 1):\n        if res[i] > res[i+1]:\n            return ":("\n    return ' '.join(map(str, res))\n\n    \ndef run():\n    if sys.hexversion == 50594544 : sys.stdin = open("test.txt")\n    print(solve())\n\nrun()
n, k = [int(i) for i in input().split()]\n\ndic = dict()\n\ns = list(input())\n\ni = 0\nwhile i<n:\n    j = 1\n    while i+j < n and s[i] == s[i+j]:\n        j+=1\n    if s[i] not in dic:\n        dic[s[i]] = []\n    dic[s[i]].append(j)\n    i += j\nans = 0\n\nfor i in list(dic.keys()):\n    ct = 0\n    for j in dic[i]:\n        ct+=(j//k)\n    ans = max(ans, ct)\n    #if min(dic[i]) >= k:\n        #ans = max(ans, min(dic[i]))\n\nprint(ans)\n
s = input().split()\nn, m = int(s[0]), int(s[1])\nqr = {}\nfor i in range(1, m+1):\n    num = (n-i)//m+1\n    qr[(i**2)%m] = qr.get((i**2)%m,0)+ num\nprint(sum(qr.get(i%m,0) * qr.get((m-i)%m,0) for i in range(m)))\n
n = int(input())\nx = []\nfor i in range(n):\n  c, p = map(int, input().split())\n  x += [(p, c, i)]\nk = int(input())\nr = list(map(int, input().split()))\ns = 0\nq = []\nfor (v, c, a) in reversed(sorted(x)):\n  p = -1\n  u = 100000\n  for  (j, z) in enumerate(r):\n    if c <= z < u:\n      p = j\n      u = z\n  if p > -1:\n    r[p] = 0\n    q += [(a, p)]\n    s += v\nprint(len(q), s)\nfor (i, j) in q:\n  print(i + 1, j + 1)
import functools, operator\nm = int(input())\np = [int(x) for x in input().split()]\nP = {}\nn = 1\nfor i in p:\n    P[i] = P.get(i, 0) + 1\n    n = n * i % 1000000007\ndv = functools.reduce(operator.mul, (l + 1 for l in list(P.values())))\nprod = 0;\n#n = functools.reduce(operator.mul, (pow(p,i,1000000007) for p,i in P.items()))\nif dv & 1:\n    #prod = pow(int(n**0.5), dv, 1000000007)\n    prod = pow(int(functools.reduce(operator.mul, (pow(p,i//2,1000000007) for p,i in list(P.items())))), dv, 1000000007)\n    #prod = pow(int(n**0.5), dv, 1000000007);\nelse:\n    #prod = pow(n, dv//2, 1000000007)\n    #prod = pow(functools.reduce(operator.mul, p), dv//2, 1000000007)\n    prod = pow(n, dv//2, 1000000007)\nprint(prod % 1000000007)\n\n
read = lambda: list(map(int, input().split()))\nn = int(input())\na = [input() for i in range(n)]\nf = lambda x: x * (x - 1) // 2\ncnt = 0\nfor i in range(n):\n    k1 = a[i].count('C')\n    k2 = sum(a[j][i] == 'C' for j in range(n))\n    cnt += f(k1) + f(k2)\nprint(cnt)\n
n = int(input())\nwihi = [list(map(int,input().split())) for i in range(n)]\nW = 0\nH = 1\nH1 = 1\nnum = 0\nfor i in wihi:\n    W += i[0]\n    H = max(H,i[1])\nfor i in range(n):\n    if num == 0:\n        if wihi[i][1] == H:\n            num = 1\n        else:\n            H1 = max(H1,wihi[i][1])\n    else:\n        H1 = max(H1,wihi[i][1])\nif H1 == H:\n    for i in wihi:\n        print((W - i[0]) * (H),end=" ")\nelse:\n    for i in wihi:\n        if i[1] == H:\n            print((W - i[0]) * (H1),end=" ")\n        else:\n            print((W - i[0]) * (H),end=" ")\n    \n
n = int(input())\nu, v, f, B = 1, 1 , 1, 10**9+7\nfor i in range(2,n+2):\n    u  = u * i % B\nfor i in range(2,n+n+3):\n    f  = f * i % B\ndef inv(u):\n    if u < 2:\n        return 1\n    return (-(B // u) * inv(B % u)) % B\n\nprint((f * inv(u) * inv(u) + B - 1) % B)\n    \n
import sys\n\nn,m=list(map(int,sys.stdin.readline().split()))\n\n\n\nA=list(map(int,sys.stdin.readline().split()))\n\n\n\nB=list(map(int,sys.stdin.readline().split()))\n\n\n\n\n\nA.sort(reverse=True)\n\nB.sort(reverse=True)\n\na=sum(A)\n\nb=sum(B)\n\nans=0\n\nleft=0\n\nfor i in range(n):\n\n    left+=A[i]\n\n    temp=b*(i+1)+a-left\n\n    if(ans==0):\n\n        ans=temp\n\n    ans=min(ans,temp)\n\n\n\nleft=0\n\nfor i in range(m):\n\n    left+=B[i]\n\n    temp=a*(i+1)+b-left\n\n    if(ans==0):\n\n        ans=temp\n\n    ans=min(ans,temp)\n\nprint(ans)\n\n    \n\n\n\n\n\n# Made By Mostafa_Khaled\n
s = 0\na = list(map(int, input().split()))\nfor i in map(int, input()):\n    s += a[i - 1]\nprint(s)
\nn,pos= (int(x) for x in input('').split())\ns = input('')\n\ndef dis(a, b):\n    a=ord(a)\n    b=ord(b)\n    return min(abs(a - b), abs(a+26-b), abs(b+26-a))\n\nd = [dis(s[i], s[len(s)-i-1]) for i in range((len(s) + 1)//2)]\npos -= 1\nif pos >= (len(s) + 1) // 2:\n    pos = len(s) - pos - 1\n#print(pos)\n\n#print(d)\nfor rightmost, v in enumerate(reversed(d)):\n    if v!=0:\n        rightmost = len(d) - rightmost - 1\n        break\nfor leftmost, v in enumerate(d):\n    if v!=0:\n        break\n#print(leftmost, rightmost)\nans = min(abs(rightmost - pos) + rightmost - leftmost, abs(pos - leftmost) + rightmost - leftmost) + sum(d)\nif sum(d) == 0:\n    print(0)\nelse:\n    print(ans)\n\n
import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n#import numpy as np\ndef main():\n    n = int(input())\n    if n == 1:\n        print((1))\n        return\n    r = 0\n    for i1 in range(1, n + 1):\n        num_of_div = n // i1\n        r += num_of_div * (num_of_div + 1) // 2 * i1\n    print(r)\n\ndef __starting_point():\n    main()\n\n__starting_point()
import sys\n\nN, M = map(int, input().split())\n\npm = [(i,j,k) for i in range(-1,2,2) for j in range(-1,2,2) for k in range(-1,2,2)]\nlst = []\n\nfor _ in range(N):\n  x,y,z = map(int, input().split())\n  lst.append((x,y,z))\n\nrlt = -sys.maxsize\nfor a,b,c in pm:\n  tmp = []\n  for x,y,z in lst:\n    tmp.append(a*x+b*y+c*z)\n  tmp.sort(reverse=True)\n  rlt = max(rlt, sum(tmp[:M]))\n  \nprint(rlt)
def main():\n	n, ma, mb, *L = list(map(int, open(0).read().split()))\n	M = 1 << 30\n	dp = [[M] * 420 for _ in range(420)]\n	dp[0][0] = 0\n	ua = ub = 15\n	for a, b, c in zip(*[iter(L)] * 3):\n		for i in range(ua, -1, -1):\n			for j in range(ub, -1, -1):\n				t = dp[i][j] + c\n				if dp[i + a][j + b] > t:\n					dp[i + a][j + b] = t\n					if ua < i + a:\n						ua = i + a\n					if ub < j + b:\n						ub = j + b\n	ans = M\n	_ma, _mb = ma, mb\n	while _ma < 410 > _mb:\n		ans = min(ans, dp[_ma][_mb])\n		_ma += ma\n		_mb += mb\n	print((ans if ans < M else -1))\n\n\ndef __starting_point():\n	main()\n\n__starting_point()
import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.readline\n    N = int(input())\n    primes = defaultdict(int)\n    ans = 0\n    for i in range(1, N + 1):\n        k = i\n        for j in range(2, i+1):\n            if j ** 2 > i: break\n            if k % j == 0:\n                while k % j == 0:\n                    primes[j] += 1\n                    k //= j\n        if k > 1: primes[k] += 1\n    P = []\n    for key in primes: P.append(primes[key])\n    pn = len(P)\n\n    for i in range(pn):\n        if P[i] >= 74: ans += 1\n        if P[i] >= 24:\n            for j in range(pn):\n                if P[j] >= 2 and j != i: ans += 1\n        if P[i] >= 14:\n            for j in range(pn):\n                if P[j] >= 4 and j != i: ans += 1\n        if P[i] >= 4:\n            for j in range(i+1, pn):\n                if P[j] >= 4:\n                    for k in range(pn):\n                        if P[k] >= 2 and k != i and k != j: ans += 1\n    print(ans)\n    #print(primes)\n    #print(P)\n\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()
n, m = list(map(int, input().split()))\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = int(input())\nk = []\nfor i in range(d):\n    k.append(int(input()))\n\nvis = [False for i in range(m+1)]\nmatch = [-1 for i in range(m+1)]\n\n\ndef dfs(u: int) -> bool:\n    for v in e[u]:\n        if not vis[v]:\n            vis[v] = True\n            if match[v] == -1 or dfs(match[v]):\n                match[v] = u\n                return True\n    return False\n\n\ne = [[] for i in range(5005)]\nfor i in range(n):\n    if i + 1 not in k:\n        e[p[i]].append(c[i])\n\nmex = 0\nans = []\nfor i in range(d - 1, -1, -1):\n    while True:\n        vis = [False for j in range(m+1)]\n        if not dfs(mex):\n            break\n        mex += 1\n    ans.append(mex)\n    e[p[k[i]-1]].append(c[k[i]-1])\n\nfor i in reversed(ans):\n    print(i)\n
n,m,k = list(map(int, input().strip().split()))\na = list(map(int, input().strip().split()))\na.sort()\n\ncount = 0\n\nstart = 0\nkonec = 0\nur = 0\nwhile start < len(a):\n    if a[start] is not None:\n        v = a[start]\n        while konec < len(a) and a[konec] - v < m :\n            ur += 1\n            if ur >= k:\n                #print(a,start,konec,ur)\n                a[konec] = None\n                count += 1\n                ur -= 1\n            konec += 1\n    if a[start] is not None:\n        ur -= 1\n    start += 1\n\nprint(count)\n            \n            \n    \n    \n
s = sum(int(i) for i in input().split())\n\nif s > 0 and s % 5 == 0:\n    print(s // 5)\nelse:\n    print(-1)\n
a, b = list(map(int, input().split(' ')))\n\nfor i in range(a):\n    if i % 2 == 0:\n        print('#'*b)\n    elif i%4==1:\n        print('.'*(b-1)+'#')\n    else:\n        print('#'+'.'*(b-1))\n
n,k = map(int, input().split())\ns = input()\nls = sorted(list(set(s)))\nif k > n:\n    ans = s + ''.join([ls[0] for i in range(k-n)])\n    print(ans)\n    return\nc = len(ls)\nd = {}\nfor i in range(c):\n    d[ls[i]] = i\nns = []\nfor i in range(k-1,-1,-1):\n    ns.append(d[s[i]])\nr = 1\nans = []\nfor i in range(k):\n    ans.append((ns[i] + r)% c)\n    r = (ns[i] + r) // c\nans = list(reversed(ans))\nprint(''.join([ls[i] for i in ans]))
import math\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nnow = [-1] * k\nt = [0] * k\nnxt = 0\nm = 0\nintr = [False for i in range(n)]\nwhile m < n:\n    for i in range(k):\n        if now[i] != 1005 and (now[i] == -1 or t[i] == a[now[i]]):\n            if now[i] != -1:\n                m += 1\n            if nxt == n:\n                now[i] == 1005\n                t[i] = 1000\n            else:\n                now[i] = nxt\n                nxt += 1\n                t[i] = 0\n        t[i] += 1\n    d = (200 * m + n) // (2 * n)\n    for i in range(k):\n        if d == t[i]:\n            intr[now[i]] = True\nprint(sum(intr))
import sys\ninput = sys.stdin.readline\nfrom bisect import bisect_right as br\nP = 10**9+7\nN = int(input())\nX = []\nmaxinn = 0\nfor _ in range(N):\n    a, b = list(map(int, input().split()))\n    maxinn = max(maxinn, b)\n    X.append((a, b))\nX = sorted(X)\nOUT = [0]\nVOL = [0]\nCNT = [1]\n\nfor out, inn in X:\n    i = br(OUT, inn) - 1\n    vol = VOL[i] + out - inn\n    if OUT[-1] != out:\n        OUT.append(out)\n        VOL.append(VOL[-1] if len(CNT)>1 else 0)\n        CNT.append(CNT[-1] if len(CNT)>1 else 0)\n    \n    if VOL[-1] < vol:\n        VOL[-1] = vol\n        CNT[-1] = CNT[i]\n    elif VOL[-1] == vol:\n        CNT[-1] += CNT[i]\n        CNT[-1] %= P\n\nmi = min([OUT[i]-VOL[i] for i in range(len(CNT)) if OUT[i] > maxinn])\nprint(sum([CNT[i] for i in range(len(CNT)) if OUT[i] > maxinn and OUT[i]-VOL[i] == mi])%P)\n
n = int(input())\nL = list(map(int, input().split()))\nm = int(input())\nA = list(map(int, input().split()))\nS = list(map(int, input().split()))\n\nD = {}\nfor i in range(n):\n    if L[i] in list(D.keys()):\n        D[L[i]] += 1\n    else:\n        D[L[i]] = 1\nM = [[0,0,i+1] for i in range(m)]\nfor i in range(m):\n    if A[i] in list(D.keys()):\n        M[i][0] += D[A[i]]\n    if S[i] in list(D.keys()):\n        M[i][1] += D[S[i]]\n\ndef ct(a):\n    return a[0],a[1]\n\nM.sort(key=ct,reverse=True)\nprint(M[0][2])\n
"""\nCodeforces Rockethon Contest Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.4.2\n"""\n\n################################################### SOLUTION\n\ndef main():\n    n,m = read()\n    m -= 1\n    perm = [0]*n\n    lf = 0\n    rt = n-1\n    for i in range(n):\n        if m >= 2**(n-i-2):\n            perm[rt] = i+1\n            rt -= 1\n        else:\n            perm[lf] = i+1\n            lf += 1\n        m %= 2**(n-i-2)\n    write(perm)\n\n\n\n#################################################### HELPERS\n\n\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
#python33\ndef program():\n    num=-1\n    R=[]\n    L=[]\n    n=int (eval(input ()))\n    for i in range(n):\n        l,r=((list(map(int,input().split()))))  \n        R.append(r)\n        L.append(l)  \n    MAXR=max(R)\n    MINL=min(L)\n\n    for i in range(n):\n        if R[i] == MAXR and L[i] == MINL:\n            print(i+1)\n            return \n\n    print(num)    \nprogram()       \n
import sys\n\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\nM = [[0 for i in range (0, 21)] for j in range (0, 21)]\nF = [0 for i in range (0, 21)]\nfor i in range (0, n):\n    x = int(a[i])\n    for j in range (0, 21):\n        if j != x:\n            M[j][x] = M[j][x] + F[j]\n    F[x] = F[x] + 1\nans = 0\nfor i in range (0, 21):\n    for j in range (0, i):\n        ans = ans + min(M[i][j], M[j][i])\nprint(ans)
#scott http://codeforces.com/problemset/problem/265/A new problem\n\nRO = input() # darn i don't know how to read string\nins = input() #scott\nn = 0\n\n\nfor x in range (len(ins)): #scott yeah that looks fine\n    #print (x)\n    if ins[x] == RO[n]:\n        n += 1 #scott\n\nprint(n+1)\n
# -*- coding: utf-8 -*-\n"""\nCreated on Sun Apr  2 22:42:34 2017\n\n@author: Sean38\n"""\n\nn = int(input().rstrip())\ns = input()\na = [int(ch) for ch in s.split()]\na = a[0:n]\na.sort()\n\ndef check_num(p, i):\n\n    # i = ap + b(p+1)\n    # min(a+b) <=> max(b)\n    # b(p+1) <= i\n    # b == i (mod p)\n    max_b = (i // (p + 1))\n    b = i % p + ((max_b - i % p) // p) * p\n    # cur = a + b\n    cur = (i - b) // p\n\n    #print(cur - b, b, p)\n    if b < 0:\n        return None\n    return cur\n\ndef sets_num(p):\n    \n    total = 0\n    for i in a:\n        if check_num(p, i):\n            total += check_num(p, i)\n        else:\n            return None\n    return total\n\nfor div_sets in range(1, a[0] + 1):\n    p, q = divmod(a[0], div_sets)\n    if (q == 0):\n        if sets_num(p):\n            print(sets_num(p))\n            break\n        if (p > 0) and sets_num(p - 1):\n            print(sets_num(p - 1))\n            break\n    else:\n        if sets_num(p):\n            print(sets_num(p))\n            break
n,m,k = (int(i) for i in input().split())\nr = []\nfor i in range(m):\n    u,v,p = (int(i) for i in input().split())\n    r += [(p,u,v)]\nif k == 0:\n    print(-1)\n    return\nelse:\n    s = list(map(int,input().split()))\n    sklad = [False]*n\n    for i in range(len(s)):\n        sklad[s[i]-1] = True\n        \n    ans = 10**10\n    for i in range(len(r)):\n        if sklad[r[i][1]-1] != sklad[r[i][2]-1]:\n            ans = min(ans,r[i][0])\n            \nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)
n = int(input())\na = list(map(int, input().split()))\nmx, cnt = 1, 1\nfor i in range(1, n):\n	if a[i] > a[i - 1]:\n		cnt += 1\n	else:\n		cnt = 1\n	mx = max(mx, cnt)\nprint(mx)
n=int(input())\na=list(map(int,input().split(' ')))\n\ntemp_sgn=1\nsgns=[]\ncurr_sum=0\nfor i in range(n):\n	if(curr_sum>=a[n-i-1]):\n		sgns.append(1)\n		sgns.append(-1)\n		curr_sum-=a[n-i-1]\n	else:\n		sgns.append(-1)\n		sgns.append(1)\n		curr_sum-=a[n-i-1]\n		curr_sum*=-1\nsgns.reverse()\nans=[]\nfor i in range(2*n):\n	if(i%2==0):\n		ans.append(temp_sgn*sgns[i])\n	else:\n		temp_sgn*=sgns[i]\nfor x in ans:\n	if(x==1):\n		print('+',end='')\n	else:\n		print('-',end='')\n\n
from random import randint\nimport sys\n\nn, m, p = list(map(int, input().strip().split()))\n\nf = list(map(int, input().strip().split()))\ng = list(map(int, input().strip().split()))\n\nfor i in range(len(f)):\n    if f[i] % p != 0:\n        break\n\nj = 0\nwhile g[j] % p == 0:\n    j += 1\n\nprint(i+j)\n\n\n\n\n
from sys import stdin\nfrom collections import defaultdict\n\ndef main():\n  stdin.readline()\n  num = {}\n  stat = lambda word: (word.count('r'), \n      len(word), num.setdefault(word, len(num)))\n  essay = list(map(stat, stdin.readline().lower().split()))\n  queue = []\n  for word in essay:\n    queue.append(word)\n  n_synonym = int(stdin.readline())\n  synonym = defaultdict(list)\n  for i in range(n_synonym):\n    word, rep = map(stat, stdin.readline().lower().split())\n    synonym[rep[2]].append(word[2])\n    queue.append(rep)\n  queue.sort(reverse=True)\n  best = {}\n  while queue:\n    n_r, length, word = queue.pop()\n    if word in best:\n      continue\n    best[word] = n_r, length\n    for rep in synonym[word]:\n      if rep not in best:\n        queue.append((n_r, length, rep))\n\n  sum_n_r, sum_len = 0, 0\n  for n_r, length, word in essay:\n    n_r, length = best[word]\n    sum_n_r += n_r\n    sum_len += length\n  print(sum_n_r, sum_len)\n\ndef __starting_point():\n  main()\n__starting_point()
from math import ceil\n\ndef mkgr(n, srs, k):\n  res = [str(n-1)]\n  for d in srs[1]:\n    res.append("%i %i" % (srs[0][0]+1, d+1))\n  for i in range(2, len(srs)):\n    h, hs= 0, 0\n    for j in range(len(srs[i])):\n      res.append("%i %i" % (srs[i][j]+1, srs[i-1][h]+1))\n      hs += 1\n      if hs == k-1:\n        h += 1\n        hs = 0\n      \n  return res\n\ndef test(n,k,dists):\n  m = max(dists)\n  srs = [[] for i in range(m+1)]\n  for i in range(n):\n    srs[dists[i]].append(i)\n  if [] in srs:\n    return ["-1"]\n  if len(srs[0]) != 1:\n    return ["-1"]\n  if len(srs[1]) > k:\n    return ["-1"]\n  for i in range(1, m):\n    if ceil(len(srs[i+1])/len(srs[i])) + 1 > k:\n      return ["-1"]\n  return mkgr(n, srs, k)\n\nn, k = list(map(int, input().split()))\ndists = list(map(int, input().split()))\nres = test(n,k,dists)\nprint("\n".join(res))\n
t = int(input())\nfor tc in range(t):\n    n,k=list(map(int, input().split()))\n    tap = list(map(int, input().split()))\n    sol=0\n    for i in range(1, n+1):\n        d=1000000\n        for j in tap:\n            d=min(d, abs(j-i)+1)\n        sol=max(sol, d)\n    print(sol)\n
from collections import Counter\nn, k = list(map(int, input().split()))\nc = Counter(input())\nans = min(c[chr(ord('A') + i)] for i in range(k))\nprint(k * ans)\n
from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_str(): return list(sys.stdin.readline().split())\n\nl,r = inpl()\n\nfor i in range(l,r+1):\n    X = str(i)\n    if len(set(X)) == len(X):\n        print(i)\n        return\n\nprint(-1)\n
import sys\ninput = sys.stdin.readline\n\nn,x=list(map(int,input().split()))\nA=list(map(int,input().split()))\n\nMIN_R=[A[-1]]\nfor a in A[:-1][::-1]:\n    MIN_R.append(min(a,MIN_R[-1]))\n\nMIN_R=MIN_R[::-1]\n\nMAX=x\n\nfor i in range(n-1):\n    if A[i]>MIN_R[i+1]:\n        MAX=min(MAX,A[i])\n\nMAX_L=[A[0]]\nfor a in A[1:]:\n    MAX_L.append(max(a,MAX_L[-1]))\n\nMIN=0\nfor i in range(1,n):\n    if MAX_L[i-1]>A[i]:\n        MIN=max(MIN,A[i])\n\nNEED=[i for i in range(x+3)]\n\nfor i in range(n-1):\n    if A[i]>MIN_R[i+1]:\n        NEED[1]=max(NEED[1],MIN_R[i+1])\n        NEED[MIN_R[i+1]+1]=max(NEED[MIN_R[i+1]+1],A[i])\n\nfor i in range(1,x+2):\n    NEED[i]=max(NEED[i],NEED[i-1])\n\nANS=0\n\nfor i in range(1,MAX+1):\n    ANS+=x-max(MIN,NEED[i])+1\n\n    #print(i,ANS)\n\nprint(ANS)\n
"""\nCodeforces Contest 266 Div 2 Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef main():\n    n,m,a,b = read()\n    if b/m < a:\n        if n%m and a * (n%m) > b:\n            print((n//m + 1) * b)\n        else:\n            print((n%m) * a + (n//m) * b)\n    else:\n        print(n*a)\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
n,k,a = map(int,input().split())\nm = int(input())\nx = [int(y) for y in input().split()]\n\ndef check(K):\n    used = [0]*(n+1)\n    for i in range(K):\n        used[x[i]] = 1\n    for i in range(1,n+1):\n        used[i]+=used[i-1]\n    have = 0\n    i = a\n    while i<n+1:\n        if used[i]-used[i-a]==0:\n            have+=1\n            i+=a\n        i+=1\n    return have>=k\n\nif check(m):\n    print(-1)\nelse:\n    low = -1\n    high = m\n    while high-low>1:\n        if check((low+high+1)//2):\n            low = (low+high+1)//2\n        else:\n            high = (low+high+1)//2\n    print(high)
def main():\n    from math import hypot\n    n, m = list(map(int, input().split()))\n    vertices = list(tuple(map(float, input().split())) for _ in range(n))\n    ax, ay = vertices[-1]\n    for i, (bx, by) in enumerate(vertices):\n        vertices[i], ax, ay = (bx, by, bx - ax, by - ay), bx, by\n    for _ in range(m):\n        x0, y0, x1, y1 = list(map(float, input().split()))\n        x1 -= x0\n        y1 -= y0\n        bx, by = vertices[-1][:2]\n        tmp = (bx - x0) * y1 - (by - y0) * x1\n        t = -1 if tmp < 0 else 1 if tmp > 0 else 0\n        res = []\n        for bx, by, abx, aby in vertices:\n            s, tmp = t, (bx - x0) * y1 - (by - y0) * x1\n            t = -1 if tmp < 0 else 1 if tmp > 0 else 0\n            if s != t:\n                res.append((((bx - x0) * aby - (by - y0) * abx) / (x1 * aby - y1 * abx), s - t))\n        res.sort()\n        t, w = 0, 0.\n        for i, (tmp, s) in enumerate(res, -1):\n            if t:\n                w += tmp - res[i][0]\n            t += s\n        print(w * hypot(x1, y1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
s = input()\nc = s.count('a')\nprint(min(2*c-1,len(s)))
n, m = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nfor i in range(1, len(v)):\n    if v[i] < v[i-1]: v[i] += ((v[i-1] - v[i]) // n) * n\n    while v[i] < v[i-1]: v[i] += n\n\nprint(v[-1]-1)\n
import sys\nimport math\n\ndef solve():\n    k, n = list(map(int, input().split()))\n    D = {}\n    for line in sys.stdin:\n        s, a = line.split()\n        if s in D:\n            D[s].append(int(a))\n        else:\n            D[s] = [int(a)]\n\n    res = 0\n    center = 0\n    for s in D:\n        revs = s[::-1]\n        if not revs in D: continue\n        D[revs].sort()\n        D[s].sort()\n\n        if s == revs:\n            while len(D[s]) > 1 and D[s][-2] + D[s][-1] > 0:\n                center = max(center, -D[s][-2])\n                res += D[s].pop()\n                res += D[s].pop()\n\n            if len(D[s]) > 0:\n                center = max(center, D[s][-1])\n        else:\n            while (len(D[s]) > 0 and len(D[revs]) > 0 and\n                   D[s][-1] + D[revs][-1] > 0):\n                res += D[s].pop()\n                res += D[revs].pop()\n\n    return res + center\n\nprint(solve())\n
l=input().strip().split(" ");\nn=int(l[0]);\nm=int(l[1]);\nt=m;\nv=[];\nfor i in range(n+1):\n  v.append([]);\nwhile t>0:\n  l=input().strip().split(" ");\n  a=int(l[0]);\n  b=int(l[1]);\n  v[a].append(b);\n  t-=1;\n\nans=0 ;\nfor p in range(1,n+1):\n  gp={};\n  for ch in range(1,n+1):\n    gp[ch]=0;\n  \n  for u in v[p]:\n    for x in v[u]:\n      if(x!=p):\n        gp[x]+=1;\n  #print(gp);\n   \n  for ch in gp:\n    ans+=(gp[ch]*(gp[ch]-1))//2;\n  \nprint (ans);\n
import collections\n\nExam = collections.namedtuple("Exam", ['a', 'b'])\n\nn = int(input())\nexams = [ ]\nfor i in range(n):\n    exams.append(Exam(*list(map(int, input().split()))))\nexams.sort()\ntoday = 0\nfor e in exams:\n    today = e.b if e.b >= today else e.a\nprint(today)\n
def calcdiff(listx):\n    maxim = -1\n    for i in range(1, len(listx)):\n        maxim = max(maxim, listx[i] - listx[i-1])\n    return maxim\nx = int(input())\nt = list(map(int, input().split(' ')))\nmaximx = 90000001\nfor i in range(1, x-1):\n    maximx = min(maximx, calcdiff(t[:i] + t[i+1:]))\nprint(maximx)\n    \n
n, p, m = input().split()\nn = int(n)\np = int(p)\nm = int(m)\n\nans = 0\ncurb = 0\ncurd = 1\nfor i in range(0, n):\n    #print(curb)\n    tday, tplus = input().split()\n    tday = int(tday)\n    tplus = int(tplus)\n    if curb < 0:\n        ans += (tday - curd)\n        curb -= p * (tday - curd)\n    elif curb - p * (tday - curd) < 0:\n        curb -= p * (tday - curd)\n        x = -curb\n        xx = x // p\n        if xx * p < x:\n            xx += 1\n        x = xx\n        ans += x\n    else:\n        curb -= p * (tday - curd)\n    curd = tday\n    #print(curb)\n    curb += tplus\n\ntday = m + 1\nif curb < 0:\n    ans += (tday - curd)\n    curb -= p * (tday - curd)\nelif curb - p * (tday - curd) < 0:\n    curb -= p * (tday - curd)\n    x = -curb\n    xx = x // p\n    if xx * p < x:\n        xx += 1\n    x = xx\n    ans += x\n\nprint(ans)
import bisect\nfrom functools import lru_cache\n\ng, d, f = tuple(map(int, input().split()))\n\ngoals = list(map(int, input().split()))\ndefs = list(map(int, input().split()))\nforwards = list(map(int, input().split()))\n\ngoals.sort()\ndefs.sort()\nforwards.sort()\n\nforwards.append(100000000)\ndefs.append(100000000)\ngoals.append(100000000)\n\nnumers = []\nroles = []\ngi, di, fi = 0, 0, 0\n\nfor i in range(d + g + f):\n    numers.append(min(goals[gi], defs[di], forwards[fi]))\n\n    if numers[-1] == goals[gi]:\n        roles.append(1)\n        gi += 1\n\n    if numers[-1] == forwards[fi]:\n        roles.append(3)\n        fi += 1\n\n    if numers[-1] == defs[di]:\n        roles.append(2)\n        di += 1\n\n#print(numers)\n#print(roles)\n\n\n@lru_cache()\ndef my_comb(n, k):\n    if k == 0:\n        return 1\n    if n < k:\n        return 0\n    if n == k:\n        return 1\n    if k == 3:\n        return (n * (n - 1) * (n - 2)) // 6\n    if k == 2:\n        return (n * (n - 1)) // 2\n    if k == 1:\n        return n\n    assert False\n\n\ndef solve(numers, roles):\n    ans = 0\n    for i in range(len(numers)):\n        # check all combinations with guy i\n\n        possible_max_num = bisect.bisect_right(numers, numers[i] * 2)\n\n        if possible_max_num - i < 5:\n            continue\n\n        avaliable_f = roles[i + 1: possible_max_num].count(3)\n        avaliable_d = roles[i + 1: possible_max_num].count(2)\n        avaliable_g = roles[i + 1: possible_max_num].count(1)\n\n        needed_f, needed_d, needed_g = 3, 2, 1\n\n        if roles[i] == 1:\n            needed_g -= 1\n        elif roles[i] == 2:\n            needed_d -= 1\n        else:\n            needed_f -= 1\n\n        possible_combinations_with_ith = my_comb(avaliable_d, needed_d) * my_comb(avaliable_f, needed_f) * my_comb(\n            avaliable_g, needed_g)\n        ans += possible_combinations_with_ith\n\n    return ans\n\n\nprint(solve(numers, roles))\n
mi = lambda: [int(i) for i in input().split()]\n\nn = int(input())\nt = mi()\n\na = []\nv = 0\nc = 0\n\nfor i in t:\n    if i == v:\n        c += 1\n    else:\n        if c != 0:\n            a.append(c)\n        c = 1\n        v = i\na.append(c)\n\nr = 0\nfor k in range(1, len(a)):\n    r = max(r, min(a[k - 1], a[k]) * 2)\nprint(r)\n
def main():\n    n, k = list(map(int, input().split()))\n    cnt = [[[0] * 21 for _ in (0, 1)] for _ in range(n + 1)]\n    edges, mod = [[] for _ in range(n + 1)], 1000000007\n    for _ in range(n - 1):\n        u, v = list(map(int, input().split()))\n        edges[u].append(v)\n        edges[v].append(u)\n\n    def dfs(u, f):\n        cnt[u][0][0] = cnt[u][1][k] = 1\n        for v in edges[u]:\n            if v != f:\n                dfs(v, u)\n                tmp0, tmp1 = [0] * 21, [0] * 21\n                for i in range(k + 1):\n                    for j in range(k + 1):\n                        if i != k:\n                            tmp0[j if i < j else i + 1] += cnt[u][0][j] * cnt[v][0][i]\n                        if i < j:\n                            tmp1[j] += cnt[u][1][j] * cnt[v][0][i]\n                        elif i != k:\n                            tmp0[i + 1] += cnt[u][1][j] * cnt[v][0][i]\n                        if i > j:\n                            tmp1[i - 1] += cnt[u][0][j] * cnt[v][1][i]\n                        else:\n                            tmp0[j] += cnt[u][0][j] * cnt[v][1][i]\n                        tmp1[max(i - 1, j)] += cnt[u][1][j] * cnt[v][1][i]\n                for i in range(21):\n                    tmp0[i] %= mod\n                    tmp1[i] %= mod\n                cnt[u][0] = tmp0\n                cnt[u][1] = tmp1\n\n    dfs(1, 1)\n    print(sum(cnt[1][1][j] for j in range(k + 1)) % mod)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n = int(input())\nbs = []\nfor _ in range(n):\n    bs.append(list(map(int, input().split())))\n\nans = 0\nfor i in range(n):\n    for j in range(n):\n        if i != j and bs[i][0] == bs[j][1]:\n            ans += 1\n            break\n\nprint(n - ans)\n
"""\nCodeforces Testing Round 10 Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0:\n        return inputs\n    if mode == 1:\n        return inputs.split()\n    if mode == 2:\n        return [int(x) for x in inputs.split()]\n\ndef write(s="\n"):\n    if isinstance(s, list): s = " ".join(s)\n    s = str(s)\n    print(s, end="")\n\n################################################### SOLUTION\nn, = read()\na = read()\nwrite(n*(n+1)//2 - sum(a))
N, A, B = map(int, input().split())\nX = list(map(int, input().split()))\nX.sort(reverse=True)\nM = sum(X[i] for i in range(A)) / A\nprint(M)\ncntl, cntr = 0, 0\nif X[A-1] == X[N-1]:\n  cntr = N - A\nelse:\n  cntr = A-1\n  while X[A-1] == X[cntr]:\n    cntr += 1\n  cntr -= A\nif X[0] == X[A-1]:\n  cntl = A\nelse:\n  cntl = A-1\n  while X[A-1] == X[cntl]:\n    cntl -= 1\n  cntl = A - 1 - cntl\nF = 0\nc = cntl + cntr\nif cntl == A:\n  t = 1\n  for m in range(A):\n    t *= c - m\n    t //= m + 1\n  for m in range(A, min(B, c)+1):\n    F += t\n    t *= c - m\n    t //= m + 1\n  print(F)\nelse:\n  # calc comb(cntl + cntr, cntl)\n  t = 1\n  for m in range(cntl):\n    t *= c - m\n    t //= m + 1\n  F = t\n  print(F)
import math\n\nn = int(input())\nxy = [list(map(float, input().split())) for _ in range(n)]\n\nret = 100000000\ndef update(px, py):\n    nonlocal ret\n    r = 0\n    for p in range(n):\n        r = max(r, math.hypot(px - xy[p][0], py - xy[p][1]))\n    ret = min(ret, r)\n\nfor i in range(n):\n    x1 = xy[i][0]\n    y1 = xy[i][1]\n    for j in range(i + 1, n):\n        x2 = xy[j][0]\n        y2 = xy[j][1]\n        update((x1 + x2) / 2, (y1 + y2) / 2)\n        for k in range(j + 1, n):\n            x3 = xy[k][0]\n            y3 = xy[k][1]\n\n            d = 2 * (y1 - y3) * (x1 - x2) - 2 * (y1 - y2) * (x1 - x3)\n            if d != 0:\n                px = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n                py = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n                update(px, py)\n\nprint(ret)\n
h, w, k = list(map(int, input().split()))\n\nchoco = [list(map(int, list(input()) )) for i in range(h)]\n\nchoco_cumsum = [[0 for i in range(w)] for j in range(h)]\n\nfor i in range(h):\n    choco_cumsum[i][0] = choco[i][0]\n    for j in range(1, w):\n        choco_cumsum[i][j] = choco_cumsum[i][j-1] + choco[i][j]\n\nans = h + w + 1\n\nfor h_cut in range(2**(h-1)):\n    # 上位ビットが上側。1が切る、0が切らない\n    num_cut_init = bin(h_cut).count("1") # 立っているビットの個数\n    num_cut = num_cut_init\n    w_last_cot_pos = -1\n    valid = True\n\n    temp_list = [0] * (num_cut_init + 1)\n    temp_dict = {}\n    idx = 0\n    temp_dict[0] = idx\n    for i in range(1, h):\n        # print('idx', 2 ** (-i+h-1) )\n        if h_cut & (2 ** (-i+h-1) ):\n            idx += 1\n        # idx += h_cut & (2 ** (h-1) - i)\n        temp_dict[i] = idx\n    # print(temp_dict)\n\n    iw = 0\n    while iw < w:\n\n        for ih in range(h):\n            temp_list[temp_dict[ih]] += choco[ih][iw]\n        # print(iw, temp_list)\n\n        condition = max(temp_list) > k\n        if condition:\n            if w_last_cot_pos < iw-1:\n                # もしそこで切ってkを超えるなら、その手前で切る\n                num_cut += 1\n                w_last_cot_pos = iw - 1\n                temp_list = [0] * (num_cut_init + 1)\n                # print('iw: ', iw, 'last: ', w_last_cot_pos)\n\n            else:\n                # 1つしか動かしてない場合は土台無理なので次のh_cutに\n                valid = False\n                break\n        \n        else:\n            iw += 1\n    \n    if valid:\n        ans = min(ans, num_cut)\n    # print(num_cut)\n\nprint(ans)\n
#!/usr/bin/env python\n\ndef main():\n    s = int(input())\n    mod = 10**9 + 7\n    a_lst = [1, 0, 0]\n    a_sum = 0\n\n    if s >= 3:\n        for i in range(3, s+1):\n            a_sum += a_lst[i-3]\n            a_sum %= mod\n            a_lst.append(a_sum)\n\n    print((a_lst[s]))\n\ndef __starting_point():\n    main()\n\n__starting_point()
h, n = map(int, input().split())\na, b = [], []\nfor _ in range(n):\n    A, B = map(int, input().split())\n    a.append(A)\n    b.append(B)\n\na_max = max(a)\ndp = [0]*(h+a_max)\n\nfor i in range(h+a_max):\n    dp[i] = min(dp[i-a] + b for a, b in zip(a, b))\n\nprint(min(dp[h-1:]))
n,k=list(map(int, input().split()))\ns=0\nfor i in range(k,n+2):\n  s+=i*(n-i+1)+1\nprint((s%(10**9+7)))\n\n
def main():\n    N, *A = list(map(int, open(0).read().split()))\n\n    B = sorted(A)\n    l, r = 0, N\n    m, c = N // 2, N * (N + 1) // 2\n\n    def check(x):\n        b, r, y = N, 0, 0\n        D = [0] * (2 * N + 1)\n        for a in A:\n            D[b] += 1\n            if a < x:\n                r += D[b]\n                b += 1\n            else:\n                b -= 1\n                r -= D[b]\n            y += r\n        return y\n\n    while True:\n        if check(B[m]) <= c // 2:\n            if m == N - 1 or check(B[m + 1]) > c // 2:\n                break\n            l, m = m, (m + r) // 2\n        else:\n            m, r = (m + l) // 2, m + 1\n\n    print((B[m]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
"""\nCodeforces Contest 266 Div 2 Problem C\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef main():\n    n, = read()\n    a = read()\n    s = sum(a)\n    if s%3:\n        print(0)\n        return\n    s //= 3\n    t = 0\n    ct = 0\n    res = 0\n    for i in range(n-1):\n        t += a[i]\n        if t == 2*s:\n            res += ct\n        if t == s:\n            ct += 1\n    print(res)\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
n = int(input())\na = list(map(int, input().split()))\ns = d = 0\nm = {i: [] for i in range(1, n + 1)}\nfor i in range(n):\n    m[a[i]] += [i]\nfor i in range(n, 2 * n):\n    m[a[i]] += [i]\nres = 0\nfor i in sorted(m):\n    if s > d:\n        s, d = d, s\n    a, b = m[i]\n    if a > b:\n        a, b = b, a\n    res += abs(s - a) + abs(b - d)\n    s, d = a, b\nprint(res)
n = int(input())\na = list(map(int, input().split()))\nidx = list(range(n))\nidx.sort(key=lambda i: a[i], reverse=True)\nimin = imax = idx[0]\nfor i in idx[1:]:\n    if i == imin - 1 or i == imax + 1:\n        imin = min(imin, i)\n        imax = max(imax, i)\n    else:\n        print('NO')\n        return\nprint('YES')\n
n = int(input())\na = input().split()\nfor i in range(n):\n    a[i] = int(a[i])\nb = []\nfor i in range(0, n-1):\n    b.append((a[i]-(n-a[i+1]), i))\nb.append((a[n-1]-(n-a[0]), n-1))\nb = sorted(b)\nans = n*[0]\nfor i in range(n):\n    # the line segment at index b[i][1]\n    ans[b[i][1]] = i\nfor i in range(n):\n    print(ans[i], end = ' ')\n
from copy import deepcopy\nimport itertools\nfrom bisect import bisect_left\nfrom bisect import bisect_right\nimport math\nfrom collections import deque\nfrom collections import Counter\n\n\ndef read():\n    return int(input())\n\n\ndef readmap():\n    return map(int, input().split())\n\n\ndef readlist():\n    return list(map(int, input().split()))\n\n\nn, m, d = readmap()\nA = readlist()\nAind = dict([(A[i], i) for i in range(n)])\nA.sort()\n\nq = deque()\na = A[0]\nans = [0] * n\nans[Aind[a]] = 1\nmaxday = 1\n\nq.append((a, 1))\nfor i in range(1, n):\n    if A[i] > q[0][0] + d:\n        ans[Aind[A[i]]] = q[0][1]\n        q.append((A[i], q[0][1]))\n        q.popleft()\n    else:\n        maxday += 1\n        ans[Aind[A[i]]] = maxday\n        q.append((A[i], maxday))\n\nprint(maxday)\nprint(" ".join(list(map(str, ans))))
n,k=map(int,input().split())\na=list(map(int,input().split()))\np=1000\nfirst=1\nfor i in range(n):\n    if a[i]>k*i:\n        now=0\n        f=a[i]-k*i\n        for j in range(i):\n            if a[j]!=f+k*j:\n                now+=1\n        for j in range(i+1,n):\n            if a[j]!=f+j*k:\n                now+=1\n        if now<p:\n            p=now\n            first=f\nprint(p)\nfor i in range(n):\n    if a[i]!=first+k*i:\n        print('+' if a[i]<first+k*i else '-',i+1,abs(a[i]-first-k*i))
k, n, s, p = list(map(int, input().split()))\n\nx = (n + s - 1) // s\ny = k * x\nz = (y + p - 1) // p\n\nprint(z)\n
def read_data():\n    n, m = list(map(int, input().split()))\n    Es = [[] for v in range(n)]\n    for e in range(m):\n        a, b = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        Es[a].append(b)\n        Es[b].append(a)\n    return n, m, Es\n\ndef solve(n, m, Es):\n    if m == 0:\n        return 3, n * (n - 1) * (n - 2) // 6\n    if max(list(map(len, Es))) == 1:\n        return 2, m * (n-2)\n    patterns = 0\n    color = [0] * n\n    for u in range(n):\n        if color[u]:\n            continue\n        color[u] = 1\n        stack = [u]\n        n_color = [1, 0]\n        while stack:\n            v = stack.pop()\n            prev_color = color[v]\n            for w in Es[v]:\n                current_color = color[w]\n                if current_color == prev_color:\n                    return 0, 1\n                if current_color == 0:\n                    color[w] = - prev_color\n                    n_color[(prev_color + 1)//2] += 1\n                    stack.append(w)\n        n_even = n_color[0]\n        n_odd = n_color[1]\n        patterns += n_even * (n_even - 1) // 2 + n_odd * (n_odd - 1) // 2\n    return 1, patterns\n\ndef __starting_point():\n    n, m, Es = read_data()\n    print(*solve(n, m, Es))\n\n__starting_point()
n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\na = [u % m for u in a]\nb = [u % m for u in b]\na.sort()\nb.sort()\npossible = set(sorted([(b[0] - u + m) % m for u in a])) # At most 2000 elements\n# O(n^2)\nfor x in possible:\n    array = [(u + x) % m for u in a]\n    if sorted(array) == b:\n        print (x)\n        break
n = int(input())\ns = list(map(int, input().split()))\n\nans = 0\nx0 = 0\nx1 = 0\nfor i in range(n):\n    if s[i] == 1:\n        x1 = max(x0, x1) + 1\n    else:\n        x0 = x0 + 1\n    ans = max(x0, x1)\nprint(ans)\n
import re\nfrom collections import Counter\n\nclass Task:\n	answer = []\n	str = ""\n	\n	def getData(self):\n		x = 0\n		self.str = input()\n	\n	def solve(self):\n		list = re.findall("\".*?\"|[^ ]+", self.str)\n		self.answer = ["<" + x.replace("\"", "") + ">" for x in list]\n	\n	def printAnswer(self):\n		for x in self.answer:\n			print(x)\n\ntask = Task();\ntask.getData();\ntask.solve();\ntask.printAnswer();\n
n, m = list(map(int, input().split()))\nprint(pow(2, n + m, 998244353))\n
"""\nCodeforces Contest Good Bye 2014 Contest Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.4.2\n"""\n\n################################################### SOLUTION\n\ndef main():\n    n,t = read()\n    a = read()\n    c = 1\n    while c < t:\n        c += a[c-1]\n    if c == t:\n        print("YES")\n    else:\n        print("NO")\n\n#################################################### HELPERS\n\n\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
import sys\ninput = lambda: sys.stdin.readline().rstrip()\nfrom collections import deque\nN = int(input())\nC, Y = [], []\nfor _ in range(N):\n    a, b, c = list(map(int, input().split()))\n    C.append(a)\n    Y.append(c - b)\n\nif sum(Y):\n    print(-1)\n    return\n\nX = [[] for i in range(N)]\nfor i in range(N-1):\n    x, y = list(map(int, input().split()))\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n\nP = [-1] * N\nQ = deque([0])\nR = []\nwhile Q:\n    i = deque.popleft(Q)\n    R.append(i)\n    for a in X[i]:\n        if a != P[i]:\n            P[a] = i\n            X[a].remove(i)\n            deque.append(Q, a)\n\nfor i in R[1:]:\n    C[i] = min(C[i], C[P[i]])\n\nans = 0\nfor i in R[1:][::-1]:\n    if Y[i] * Y[P[i]] < 0:\n        ans += C[P[i]] * min(abs(Y[i]), abs(Y[P[i]]))\n    Y[P[i]] += Y[i]\n\nprint(ans * 2)\n
import sys\n\n\n\ninput       = []\ninput_index = 0\n\ndef next(type, number = None):\n	def next():\n		nonlocal input, input_index\n		\n		\n		while input_index == len(input):\n			if sys.stdin:\n				input       = sys.stdin.readline().split()\n				input_index = 0\n			else:\n				raise Exception()\n				\n				\n		input_index += 1\n		\n		return input[input_index - 1]\n		\n		\n	if number is None:\n		result = type(next())\n	else:\n		result = [type(next()) for _ in range(number)]\n		\n	return result\n	\n	\n	\nn, m = next(int, 2)\niis = [next(str) for _ in range(n)]\n\n\ncount = 0\nvs = [0] * n\n\nfor j in range(m - 1, -1, -1):\n	for i in range(n - 1, -1, -1):\n		c = iis[i][j]\n		\n		if c == "W" and vs[i] != 1:\n			count += 1\n			d = 1 - vs[i]\n			\n			for k in range(i + 1):\n				vs[k] += d\n		elif c == "B" and vs[i] != -1:\n			count += 1\n			d = -1 - vs[i]\n			\n			for k in range(i + 1):\n				vs[k] += d\n				\n				\nprint(count)\n
n, m = list(map(int, input().split()))\nv = list(map(int, input().split()))\nv = sorted(v)\n\ndiff = 10**10\nfor i in range(0, len(v)):\n    if i+n-1 < len(v): diff = min(diff, v[i+n-1] - v[i])\n\nprint(diff)\n
3\n\ndef readln(): return tuple(map(int, input().split()))\n\nn, m, a = readln()\nb = list(sorted(readln()))\np = list(sorted(readln()))\n\nl = ost = 0\nr = min(m, n) + 1\n\nwhile r - l > 1:\n    k = (r + l) // 2\n    s = d = 0\n    for x, y in zip(b[-k:], p[:k]):\n        if x < y:\n            d += y - x\n        s += y\n    if d <= a:\n        l = k\n        ost = max(0, s - a)\n    else:\n        r = k\n\nprint(l, ost)\n
def check(s,k):\n    for i in range(k+1):\n        if chr(ord('0')+i) not in s: \n            return False\n    return True\n\n\nn, k = map(int,input().split())\nans = 0\nfor i in range(n):\n    ss = input()\n    if check(ss,k):\n        ans +=1\nprint(ans)
def upc(c):\n    if c >= 'a' and c <= 'z':\n        c = chr(ord(c) - ord('a') + ord('A'))\n    return c\na1, a2 = {}, {}\nfor i in input():\n    if i in a1:\n        a1[i] += 1\n    else:\n        a1[i] = 1\nfor i in input():\n    if i in a2:\n        a2[i] += 1\n    else:\n        a2[i] = 1\nr1, r2 = 0, 0\na3, a4 = {}, {}\nfor k in a1:\n    v = a1[k]\n    if not k in a2:\n        continue\n    c = min(v, a2[k])\n    a2[k] -= c\n    a1[k] -= c\n    r1 += c\nfor k in a1:\n    v = a1[k]\n    c = upc(k)\n    if c in a3:\n        a3[c] += v\n    else:\n        a3[c] = v\nfor k in a2:\n    v = a2[k]\n    c = upc(k)\n    if c in a4:\n        a4[c] += v\n    else:\n        a4[c] = v\nfor k in a3:\n    if not k in a4:\n        continue\n    v = a3[k]\n    c = min(v, a4[k])\n    a3[k] -= c\n    a4[k] -= c\n    r2 += c\nprint(r1, r2)\n
t = input()\nz = t.count('a')\nq = (len(t) - z) // 2\ns = t[:q + z]\nss = t[q + z:]\np = ''.join([i for i in s if i != 'a'])\nif p == ss:\n    print(s)\nelse:\n    print(':(')
s = input()\nm = int(input())\nmn = m\nttt = 0\nt = 0\nttt = 1\nfor i in range(1,len(s)):\n    ttt = (ttt * 10) % m\nfor i in range(0,len(s)):\n    t = (t * 10 + ord(s[i]) - ord('0')) % m\nfor i in range(0,len(s)):\n    if s[i] != '0':\n        mn = min(mn,t)\n    t = t - (((ord(s[i])- ord('0')) * ttt) % m)\n    if t < 0:\n        t = t + m\n    t = (t * 10 + (ord(s[i])- ord('0'))) % m\nprint(mn)\n
import copy\n\nn, k, x = map(int, input().split())\nc = list(map(int, input().split()))\nfor i in range(n):\n    c[i] = (c[i],0)\nans = 0\nfor i in range(n + 1):\n    c2 = copy.deepcopy(c)\n    c2.insert(i, (x,1))\n    while True:\n        dq = False\n        for i in range(len(c2) - 2):\n            if c2[i][0] == c2[i + 1][0] == c2[i + 2][0]:\n                le = i\n                re = i\n                while re < len(c2) and c2[re][0] == c2[le][0]:\n                    re += 1\n                c2 = c2[:le] + c2[re:]\n                dq = True\n                break\n        if not dq:\n            break\n    cntdel = 0\n    for a,b in c2:\n        if b==0:\n            cntdel+=1\n    ans = max(ans, n - cntdel)\nprint(ans)
n, m = list(map(int, input().split()))\ntable = [False] * (n + 1)\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    table[a] = table[b] = True\nprint(n - 1)\nfor i in range(1, n + 1):\n    if not table[i]:\n        for j in range(1, n + 1):\n            if i != j:\n                print(i, j)\n        break\n\n
import sys\nfrom bisect import *\nsys.stdin = open('input.txt', 'r')\nsys.stdout = open('output.txt', 'w')\nans=n=int(input())\na=sorted(map(int,sys.stdin.readline().split()))\nfor i in range(n):ans=min(ans,n-bisect_right(a,a[i]*2)+i)\nprint(ans)
#      \nimport    sys \n \ndef getIntList():\n    return list(map(int, input().split()))    \n \n\n\n \nN, = getIntList()\n\nzp = []\nfor i in range(N):\n    ax, ay, bx, by  = getIntList()\n    if ax>bx:\n        ax,bx = bx,ax\n        ay,by = by, ay\n    zp.append( (ax,ay, bx,by))\n  \nres = 0\ndef gcd(a,b): \n    if b==0:return a\n    return gcd(b, a%b)\nzgcd = []\nfor i in range(N):\n    ax, ay, bx, by = zp[i]\n    tx =  abs(bx-ax)\n    ty = abs(by - ay)\n \n    g = gcd(tx, ty)\n    res += g+1\n \n    zgcd .append(g)\n \n"""\nax + k1 dax = bx + k2 dbx\nay + k1 day = by + k2 dby\n"""\nfor i in range(N):\n    ax = zp[i][0]\n    dax = (zp[i][2] - ax) // zgcd[i]\n    ay = zp[i][1]\n    day = (zp[i][3] - ay) // zgcd[i]\n    cross = []\n    for j in range(i+1, N):\n        #dprint('node',i,j)\n        bx = zp[j][0]\n        dbx = (zp[j][2] - bx) // zgcd[j]\n        by = zp[j][1]\n        dby = (zp[j][3] - by) // zgcd[j]\n        #dprint(ax,dax,ay,day)\n        #dprint(bx,dbx,by,dby)\n        t1 = ax * day - ay * dax - bx * day + by * dax\n        t2 = dbx *day - dby * dax\n        \n        #dprint(t1,t2)\n        if t2==0:\n            continue\n        if t1%t2!=0:\n            continue\n        k2 = t1 // t2\n        if k2 <0 or k2 > zgcd[j]:\n            continue\n        if dax!=0:\n            t3 = k2*dbx + bx - ax\n            if t3%dax!=0:\n                continue\n            k1 = t3//dax\n        else:\n            t3 = k2* dby + by - ay\n            if t3%day !=0:\n                continue\n            k1 = t3//day\n        if k1<0 or k1 > zgcd[i]:\n            continue\n        #dprint(ax + k1 * dax, ay+k1 * day)\n        cross.append(k1)\n    if not cross: continue\n    cross.sort()\n \n    d = 1\n    for j in range(1, len(cross)):\n        if cross[j]!=cross[j-1]:\n            d+=1\n    res-=d\nprint(res)\n    \n\n\n\n
from sys import stdin, stdout, exit\n\nmod = 10**9 + 7\n\ndef modinv(x):\n    return pow(x, mod-2, mod)\n\nN = 2*10**5 + 10\nfacts = [1]*N\nfor i in range(1,N):\n    facts[i] = facts[i-1] * i\n    facts[i] %= mod\n\ndef binom(n, k):\n    ans = modinv(facts[k]) * modinv(facts[n-k])\n    ans %= mod\n    ans *= facts[n]\n    ans %= mod\n    return ans\n\n#print("Finished preprocess")\n\nn, T = list(map(int, stdin.readline().split()))\nts = list(map(int, stdin.readline().split()))\n\nans = 0\ntotal = sum(ts)\nrunning = total\nlast_idx = n-1\nwhile running > T:\n    running -= ts[last_idx]\n    last_idx -= 1\n#print(last_idx+1)\n\nlast_bd = -1\nlast_sum = 0\nidx = last_idx\nwhile running + idx + 1 > T:\n    bd = T - running\n#    print("time remaining for", idx+1, "flips is", bd)\n    cur_sum = last_sum + (binom(idx+1, last_bd) if last_bd >= 0 else 0)\n    cur_sum *= modinv(2)\n    cur_sum %= mod\n    for fresh in range(last_bd+1, bd+1):\n        cur_sum += binom(idx+1, fresh)\n        cur_sum %= mod\n #   print("pr of", idx+1, "flips is", cur_sum, cur_sum / (2**(idx+1)))\n    ans += cur_sum * modinv(pow(2, idx+1, mod))\n    ans %= mod\n    running -= ts[idx]\n    last_bd = bd\n    last_sum = cur_sum\n    idx -= 1\n\n#print(idx+1, "freebies")\nans += idx+1\nans %= mod\nprint(ans)\n
n = int(input())\n\nA = list(map(int, input().split()))\n\nmaxDist = [0] * n\n\nG = [[] for _ in range(n)]\n\nfor v in range(1, n):\n    u, d = tuple(map(int, input().split()))\n    u -= 1\n    G[v].append((u, d))\n    G[u].append((v, d))\n\n\nseen = [False] * n\nseen[0] = True\nq = [0]\nto_remove = []\n\nwhile q:\n    v = q.pop();\n    for u, dist in G[v]:\n        if not seen[u]:\n            seen[u] = True\n            maxDist[u] = max(dist, maxDist[v] + dist)\n            if maxDist[u] > A[u]:\n                to_remove.append(u)\n            else:\n                q.append(u)\n\ncount = 0\nwhile to_remove:\n    v = to_remove.pop()\n    count += 1\n    for u, _ in G[v]:\n        if not seen[u]:\n            seen[u] = True\n            to_remove.append(u)\n\nprint(count)
n, s = int(input()), 0\ns1, s2 = str(input()), str(input())\nb1, b2 = False, False\nfor i in range(n):\n  if s1[i] != '?' and s2[i] != '?':\n    if ord(s1[i]) < ord(s2[i]):\n      b1 = True\n    if ord(s1[i]) > ord(s2[i]):\n      b2 = True\n  s += (s1[i] == '?') + (s2[i] == '?')\nans1, ans2, ans3 = 1, 1, 1\nfor i in range(n):\n  if s1[i] == '?' and s2[i] == '?':\n    ans1 = (ans1 * 55) % 1000000007\n    ans2 = (ans2 * 55) % 1000000007\n    ans3 = (ans3 * 10) % 1000000007\n  elif s1[i] == '?':\n    ans1 = (ans1 * (ord(s2[i]) - ord('0') + 1)) % 1000000007\n    ans2 = (ans2 * (10 - ord(s2[i]) + ord('0'))) % 1000000007\n  elif s2[i] == '?':\n    ans1 = (ans1 * (10 - ord(s1[i]) + ord('0'))) % 1000000007\n    ans2 = (ans2 * (ord(s1[i]) - ord('0') + 1)) % 1000000007\nprint((10 ** s - (not b2) * ans1 - (not b1) * ans2 + (not b1 and not b2) * ans3) % 1000000007)
n , k = input().split()\n\nn , k = int(n), int(k)\n\nd = {}\n\narr = list(map(int, input().split()))\nfor i in arr:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1;\n\narr = list(set(arr))\narr.sort()\n\ncnt = 0\nfor i in range(len(arr)-1):\n    if (arr[i] + k >= arr[i+1]):\n        cnt += d[arr[i]]\n\nprint(n - cnt)\n
MOD = 998244353.0\nfloat_prec = 1801439850948198.4\nfloat_mod = lambda x: x if -float_prec < x < float_prec else x % MOD\n\nn = int(input())\na = [int(i) for i in input().split()]\n\nf0, f1 = [1.0] * 201, [0.0] * 201\nfor i in range(n):\n    nf0, nf1 = [0.0] * 201, [0.0] * 201\n    if a[i] == -1:\n        for j in range(200):\n            nf0[j + 1] = float_mod(nf0[j] + f0[j] + f1[j])\n            nf1[j + 1] = float_mod(nf1[j] - f0[j] + f0[j + 1] - f1[j] + f1[200])\n    else:\n        for j in range(200):\n            nf0[j + 1], nf1[j + 1] = nf0[j], nf1[j]\n            if j + 1 == a[i]:\n                nf0[j + 1] = float_mod(nf0[j] + f0[j] + f1[j])\n                nf1[j + 1] = float_mod(nf1[j] - f0[j] + f0[j + 1] - f1[j] + f1[200])\n    f0, f1 = nf0, nf1\n\nprint(int(f1[200] % MOD))\n
#!/usr/bin/env python3\n\nn = int(input())\na = [int(x) for x in input().split()]\n\nsorted_a = sorted(a)\ndict_a = {}\nfor x in a:\n    if not x in dict_a:\n        dict_a[x] = 1\n    else:\n        dict_a[x] += 1\n\nsorted_uniq_a = sorted(dict_a.keys())\n\nmax_fib_prefix = [a[0], a[1]]\nfor i in range(0, len(sorted_uniq_a)):\n    for j in range(0, len(sorted_uniq_a)):\n        if i != j or dict_a[sorted_uniq_a[i]] > 1:\n            if sorted_uniq_a[i] + sorted_uniq_a[j] > sorted_uniq_a[-1]:\n                break\n\n            fib_prefix = [sorted_uniq_a[i], sorted_uniq_a[j]]\n            dict_a[sorted_uniq_a[i]] -= 1\n            dict_a[sorted_uniq_a[j]] -= 1\n\n            while True:\n                next_fib = fib_prefix[-1] + fib_prefix[-2]\n                if not next_fib in dict_a or dict_a[next_fib] == 0:\n                    break\n                fib_prefix.append(next_fib)\n                dict_a[next_fib] -= 1\n\n            for x in fib_prefix:\n                dict_a[x] += 1\n\n            if len(fib_prefix) > len(max_fib_prefix):\n                max_fib_prefix = fib_prefix\n\nprint(len(max_fib_prefix))\n
3\n\nimport sys\n\n# 1 <= n, d <= 1000, 1 <= k <= 10**9\nn, k, d = list(map(int, sys.stdin.readline().split()))\n\nno_sol = False\nsolution = [[1 for j in range(n)] for i in range(d)]\n\n\ndef schedule(i, j, level):\n    nonlocal no_sol\n    if level >= d:\n        no_sol = True\n        return\n    count = j - i\n    chunk = count // k\n    extra = count % k\n    r = i\n    for t in range(min(k, count)):\n        size = chunk + (1 if t < extra else 0)\n        for z in range(size):\n            solution[level][r+z] = t+1\n        if size > 1:\n            schedule(r, r + size, level + 1)\n        r += size\n\nif k == 1:\n    if n > 1:\n        no_sol = True\nelse:\n    schedule(0, n, 0)\n\nif no_sol:\n    print(-1)\nelse:\n    for l in solution:\n        print(' '.join(str(x) for x in l))\n
maxn = 100100\nar = [1 for i in range(maxn)]\nar[0], ar[1] = 0, 0\n\nfor i in range(2, maxn):\n  if ar[i]:\n    for j in range(i, (maxn - 1) // i + 1):\n      ar[i * j] = 0\n\ndst = maxn\nd = [dst for i in range(maxn)]\n\nfor i in reversed(list(range(maxn))):\n  if ar[i]: dst = 0\n  d[i] = min(d[i], dst)\n  dst += 1\n\nn, m = list(map(int, input().split()))\ng = [[int(x) for x in input().split()] for _ in range(n)]\ng = [[d[x] for x in y] for y in g]\ntmpsharon = min([sum(x) for x in g] + [sum(x) for x in zip(*g)])\nprint(tmpsharon)\n\n
3\n\nn = int(input())\nbooks = [[], []]\nfor _ in range(n):\n    t, w = tuple(map(int, input().split()))\n    books[t - 1].append(w)\nfor _ in range(2):\n    books[_].sort()\n#print(books)\nans = 10**9\nfor i in range(len(books[0]) + 1):\n    for j in range(len(books[1]) + 1):\n        hor = sum(books[0][:i]) + sum(books[1][:j])\n        ver = len(books[0]) - i + 2 * (len(books[1]) - j)\n        if hor <= ver and ver < ans:\n            ans = ver\n        #print(i, j, hor, ver, ans)\nprint(ans)\n
n, k = map(int, input().split())\na = list(map(int, input().split()))\nans = 0\nfor i in a:\n    if 5 - i >= k:\n        ans += 1\nprint(ans // 3)
from collections import deque\nimport sys\ninput = sys.stdin.readline\n\n\nn = int(input())\ncost = [list(map(int, input().split())) for i in range(3)]\ninfo = [list(map(int, input().split())) for i in range(n-1)]\ngraph = [[] for i in range(n)]\n\nfor i in range(n-1):\n    a, b = info[i]\n    a -= 1\n    b -= 1\n    graph[a].append(b)\n    graph[b].append(a)\n\nfor i in graph:\n    if len(i) >= 3:\n        print(-1)\n        return\n\nfor i, j in enumerate(graph):\n    if len(j) == 1:\n        start = i\n        break\n\nvisited = [-1]*n\nvisited[start] = 0\nq = deque([start])\n\nwhile q:\n    pos = q.popleft()\n    for next_pos in graph[pos]:\n        if visited[next_pos] != -1:\n            continue\n        visited[next_pos] = (visited[pos] + 1) % 3\n        q.append(next_pos)\n\nans = float("inf")\nind = [0, 1, 2]\nfor ptn in [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]]:\n    tmp_ans = 0\n    for i in range(n):\n        tmp_ans += cost[ptn[visited[i]]][i]\n    if tmp_ans < ans:\n        ans = tmp_ans\n        ind = ptn[0:]\n\nprint(ans)\nnew_ans = [0]*n\nfor i in range(n):\n    new_ans[i] = ind[visited[i]] + 1\nprint(*new_ans)
\ndef bins(sortedlist,x):\n    n=len(sortedlist)\n    start = 0\n    end = n - 1\n\n    while(start <= end):\n        mid =int( (start + end)/2)\n        if (x == sortedlist[mid][0]):\n            return mid\n        elif(x < sortedlist[mid][0]):\n            end = mid - 1\n        else:\n            start = mid + 1 \n \n    if(sortedlist[mid][0]<=x):\n        return mid\n    else:\n        return mid-1\n\n\n\n\nn,s=list(map(int,input().split()))\nhap=[]\n\nfor i in range(n):\n    hap.append(list(map(int,input().split())))\na=0\nmax1=0\nb=0\nsla=[]\nslb=[]\nslab=[]\nfor i in range(n):\n    temp=hap[i][0]\n    hap[i][0]=hap[i][1]\n    hap[i][1]=hap[i][2]\n    hap[i][2]=temp\nfor i in range(n):\n\n    slab.append([hap[i][0]-hap[i][1],hap[i][2]])\nhappi=0\nfor i in range(n):\n    if(hap[i][0]>hap[i][1]):\n        a+=hap[i][2]\n        happi+=hap[i][2]*hap[i][0]\n    else:\n        b+=hap[i][2]\n        happi+=hap[i][2]*hap[i][1]\nsla.sort()\nslb.sort()\nslab.sort()\nif((a%s +  b%s)>s):\n    print(happi)\nelse:\n    loc=bins(slab,0)\n    happia=happi\n    count=0\n    #print(a,b)\n    b=b%s\n    a=a%s\n    left=b%s\n    \n    while(left>0):\n        if(slab[loc+count][1]<left):\n            happia+=slab[loc+count][0]*slab[loc+count][1]\n            left-=slab[loc+count][1]\n        else:\n            happia+=slab[loc+count][0]*left\n            break\n        count-=1\n    left=a%s\n    count=0\n    happib=happi\n    \n    while(loc<n and slab[loc][0]<=0):\n        loc+=1\n    #print(slab[loc][0])\n    while(left>0):\n        if(slab[loc+count][1]<left):\n            happib-=slab[loc+count][0]*slab[loc+count][1]\n            left-=slab[loc+count][1]\n        else:\n            happib-=slab[loc+count][0]*left\n            break\n        count+=1\n    #print(happia,happib,happi)\n    print(max(happia,happib))  \n
from heapq import heappop, heappush\n\nn, k = [int(x) for x in input().split()]\ncs = []\nfor i in range(n):\n    l, r = [int(x) for x in input().split()]\n    cs.append((l, r, i+1))\ncs.sort()\nh = []\nlcs = set()\nfor i in range(k-1):\n    heappush(h, [cs[i][1], cs[i][2]])\n    lcs.add(cs[i][2])\nl = -1\npoped = []\npush_i = k-1\nfor i in range(k-1, n):\n    heappush(h, [cs[i][1], cs[i][2]])\n    d = h[0][0] - cs[i][0]\n    if d > l:\n        l = d\n        for j in range(push_i, i+1):\n            lcs.add(cs[j][2])\n        for e in poped:\n            lcs.remove(e)\n        push_i = i+1\n        poped = []\n    poped.append(heappop(h)[1])\n\nprint(l+1)\nif l == -1:\n    for i in range(1, k+1):\n        print(i, end=' ')\n\nelse:\n    for i in lcs:\n        print(i, end=' ')\n\n
n = int(input())\ns = input()\nr = 0\nfor i in range(n):\n    if s[i] in '2468':\n        r += i + 1\nprint(r)
n, m = map(int, input().split())\nm += 1\nq = {'I': 0, 'M': 1, 'A': 2, 'D': 3}\nt = []\nfor i in range(n):\n    t += map(q.get, input())\n    t.append(-7)\nt += [-7] * m\np = [[] for q in t]\nc = [0] * len(t)\nfor a in range(n * m):\n    for b in (a - m, a + m, a - 1, a + 1):\n        if abs(t[b] - t[a] + 1) == 2:\n            p[a].append(b)\n            c[b] += 1\ns = [i for i, q in enumerate(c) if not q]\nwhile s:\n    a = s.pop()\n    for b in p[a]:\n        t[b] = max(t[b], t[a] + 1)\n        c[b] -= 1\n        if c[b] == 0: s.append(b)\nk = max(t) - 2 >> 2\nprint('Poor Inna!' if any(c) else k if k > 0 else 'Poor Dima!')
a, b, x, y = map(int, input().split())\ns = input()\np = []\nfor i in range(a + 1):\n    p.append([0] * (b + 1))\nsum = 0\nfor i in range(len(s)):\n    if p[x][y] == 0:\n        p[x][y] = 1\n        print(1, end = ' ')\n        sum += 1\n    else:\n        print(0, end = ' ')\n    if s[i] == 'U' and x != 1:\n        x -= 1\n    if s[i] == 'D' and x != a:\n        x += 1\n    if s[i] == 'L' and y != 1:\n        y -= 1\n    if s[i] == 'R' and y != b:\n        y += 1\nprint(a * b - sum)\n\n        \n
n, w = list(map(int, input().split()))\na = sorted(map(int, input().split()))\n\nx = min(min(a[:n]), min(a[n:]) / 2)\nprint(min(w, 3 * n * x))\n
'''\n// There are n! / (i+1)! * i permutations with decreasing seq length i (i+1 changes) for i <= n!\n// There are n! / (i+1)! permutations for each 1 <= j <= i of position of moved one\n\n// All nonempty things\n+ n*n! * (n*n! + 1) / 2\n\n// Subtract off everything inside one of them\n- n! * n * (n+1) / 2\n\n// Subtract off everything that doesn't include the min-incr\n- sum_{perm i,j} n * (n-i)\n\n// We're left with all words that include at least last of prv -> min-incr, which all have at least one match\n\n// No matches\n+ sum_{i=1..n} n!/(n-i)!\n\n// First match is dist N, doesn't include anything\n// aaa....aaa -> middle part can't all be decreasing\n+ sum_{i=1..n} n! - n!/(n-i)!\n\n// First match is dist N, includes subst\n// aaabxyc   aaac\n// Everything decreasing xycb\n+ sum_{i=1..n-1} n!/(i+1)! * (n-i-1)\n\n// First match is dist N, includes min-incr -> is unique, already counted\n\n// First match is < N -> either came from min-incr or from subst\n// You can distinguish because match..match includes everything smaller or everything smaller minus one of them\n// Ending at min-incr gives unique thing\n\n// How many distinct things end at subst?\n// Ending at subst:   (b ijk ) lmn c xyz  ... c such that zyxbcnmlkji are sorted leftovers\n                   or   b ijk lmn c xyz .... c\n// Might as well not include xyz\n+ sum_{i=1..n-1} n!/(i+1)! * (i+1)\n\n// Simplified claim:\nif it includes min-incr, then it's always unique;\nif it includes subst, only count if it came from the end (j = 1) (in which case it always matches)\notherwise, it's just some delta-N match or it's all distinct\n\nn*n! * (n*n! + 1) / 2\n- n! * n * (n+1) / 2\n- sum_{i=1..n-1} n! / (i+1)! * i * n * (n-i)\n+ sum_{i=1..n} n! / (n-i)!\n+ sum_{i=1..n} n! - n! / (n-i)!\n+ sum_{i=1..n-1} n! / (i+1)! * n\n\n= n*n! * (n*n! + 1) / 2\n- n! * n * (n+1) / 2\n- sum_{i=1..n-1} n! / (i+1)! * n * (i * (n-i) - 1)\n+ n * n!\n\n= n*n! * (n*n! - n + 2) / 2\n- sum_{i=1..n-1} n! / (i+1)! * n * (i * (n-i) - 1)\n'''\n\ndef fact(n):\n    res = 1\n    for i in range(1,n+1):\n        res *= i\n    return res\n\ndef f(n):\n    l = fact(n) * n\n    ans = l * (l-n+2) // 2\n    for i in range(1,n):\n        ans -= fact(n) // fact(i+1) * n * (i * (n-i) - 1)\n    return ans\n\n#print(f(int(input())) % 998244353)\n\ndef g(n):\n    M = 998244353\n    p = n\n    a = 0\n    for i in range(n,1,-1):\n        a=(a+p*(i-1)*(n-i+1)-p)%M\n        p=p*i%M\n    a=(p*(p-n+2)-a-a)%M\n    if a&1:a+=M\n    return a//2\n\nprint(g(int(input())))\n
def isPrime(n):\n	# a prime(except 2 or 3) is of the form 6k-1 or 6k+1\n	if n == 2 or n == 3:\n		return True\n	if n % 2 == 0 or n % 3 == 0:\n		return False\n	i = 5\n	w = 2\n	sqN = int(pow(n, .5))\n	while i <= sqN:\n		if n % i == 0:\n			return False\n		i += w\n		w = 6 - w\n	return True\n\nn = int(input().strip())\narr = [0]*(n+1)\nc = 1\nfor i in range(2, n+1):\n	if isPrime(i):\n		arr[i] = c\n		for j in range(i+i, n+1, i):\n			if not arr[j]:\n			   arr[j] = c\n		c += 1\nprint(*arr[2:])
import sys\n\ninf = 1 << 30\n\ndef solve():\n    def check(mid):\n        tot = 1\n        line = 0\n        buf = 0\n\n        for ch in s:\n            buf += 1\n\n            if ch == ' ' or ch == '-':\n                if line + buf > mid:\n                    tot += 1\n\n                    if tot > k or buf > mid:\n                        return False\n\n                    line = buf\n                    buf = 0\n                else:\n                    line += buf\n                    buf = 0\n\n        if line + buf > mid:\n            tot += 1\n\n            if tot > k or buf > mid:\n                return False\n\n        return True\n\n    k = int(input())\n    s = input()\n\n    # binary-search\n    top = len(s)\n    btm = 0\n\n    while top - btm > 1:\n        mid = (top + btm) // 2\n\n        if check(mid):\n            top = mid\n        else:\n            btm = mid\n\n    ans = top\n\n    print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()
n, l = list(map(int, input().split()))\na = list(map(int, input().split()))\na.sort()\n\nresult = 0\nfor i in range(1, n):\n    result = max(result, (a[i] - a[i - 1]) / 2)\nresult = max(result, a[0])\nresult = max(result, l - a[-1])\nprint(result)\n
import sys\ninput = sys.stdin.readline\n\noo = 10**20\nn = int(input())\na = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\nfor _ in range(n-1):\n    u, v = [int(i) - 1 for i in input().split()]\n    adj[u].append(v)\n    adj[v].append(u)\nsm = [0] * n\nmx = [-oo] * n\nbest = [-oo] * n\n\ndef dfs(start):\n    stack = [(start, -1)]\n    visit = [False] * n\n    while stack:\n        u, p = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += a[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n\ndfs(0)\nans = max(best)\nif ans <= -oo:\n    print('Impossible')\nelse:\n    print(ans)
p, m = [i for i, x in enumerate(input(), 1) if x == '1'], int(input())\nr, q = [(-1, 0, 0, [])], 'NO'\nwhile r:\n    x, d, s, t = r.pop()\n    if s == m: \n        q = 'YES\n' + ' '.join(map(str, t))\n        break\n    for y in p:\n        if y != x and y > d: r.append((y, y - d, s + 1, t + [y]))\nprint(q)\n
n, l, r = list(map(int, input().split()))\nread = lambda: list(map(int, input().split()))\na = list(read())\np = list(read())\nd = [(a[i], p[i], i) for i in range(n)]\nd.sort(key = lambda x: x[1])\ncur = l - d[0][0]\nb = [0] * n\nfor i in range(n):\n    ind = d[i][2]\n    b[ind] = a[ind] + cur\n    if b[ind] < l:\n        cur = l - a[ind]\n        b[ind] = l\n    cur += 1\nif max(b) > r: \n    print(-1)\n    return\nprint(' '.join(map(str, b)))\n
def check(i):\n    x, counter = armies[i] ^ armies[-1], 0\n    while x:\n        counter += x & 1\n        x >>= 1\n    return counter <= k\n\nn, m, k = list(map(int, input().split()))\narmies = [int(input()) for x in range(m + 1)]\nprint(sum(map(check, list(range(m)))))\n
n=int(input())\nl1=list(map(int,input().split()))\nl1.sort()\nl1=l1[::-1]\nans=[-1]*n\ni=0\ny=n-1\nfor j in range(n):\n    if j%2==0:\n        ans[i]=l1[j]\n        i+=1\n    else :\n        ans[y]=l1[j]\n        y-=1\nflag=0\nfor i in range(n):\n    if ans[i]>=ans[i-1]+ans[(i+1)%n]:\n        flag=1\n        break\nif flag==0:\n    print("YES")\n    print(' '.join(str(x) for x in ans))\nelse :\n    print("NO")
from collections import *\nfrom itertools import *\nfrom bisect import *\nfrom heapq import *\n\nimport math\nfrom fractions import gcd\nimport sys\n#input = sys.stdin.readline\n\nimport copy\n\nN,M=list(map(int,input().split()))\nUV=[list(map(int,input().split())) for i in range(M)]\nS,T=list(map(int,input().split()))\n\ndata=[[] for i in range(N+1)]\nfor u,v in UV:\n    data[u].append(v)\n\nvisited={S}\nvisited1=set()\nvisited2=set()\nstack=deque([[S,0]])\nwhile stack:\n    a,m=stack.popleft()\n    for p in data[a]:\n        z=(m+1)\n\n        if z%3==0:\n            if p in visited:\n                continue\n            elif p == T:\n                print((z//3))\n                return\n            else:\n                visited.add(p)\n        if z%3==1:\n            if p in visited1:\n                continue\n            else:\n                visited1.add(p)\n        if z%3==2:\n            if p in visited2:\n                continue\n            else:\n                visited2.add(p)\n        stack.append([p,z])\n\nprint((-1))\n
n=int(input())\na=[int(x) for x in input().rstrip().split()]\n\nnow=1\nmod=10**9+7\ndef lcm(a,b):#最小公倍数\n    ori_a=a\n    ori_b=b\n    while b!=0:\n        a,b=b,a%b\n    return (ori_a*ori_b)//a\n  \nfor i in a:\n  now=lcm(i,now)\n# print(now)\nprint((sum([now//i for i in a])%mod))\n  \n
from collections import defaultdict\nimport itertools\nn, c = map(int, input().split())\nD = [list(map(int, input().split()))for _ in range(c)]\n\n# 集計\ndiago = [defaultdict(int)for _ in range(3)]\nfor i in range(n):\n    for j, color in enumerate(map(int, input().split())):\n        color -= 1\n        if (i+j) % 3 == 0:\n            diago[0][color] += 1\n        elif (i+j) % 3 == 1:\n            diago[1][color] += 1\n        else:\n            diago[2][color] += 1\n\n\n# 0列目をcにするときのcにするときの最小コスト\ncosts = [[0]*c for _ in range(3)]\nfor i in range(3):\n    for j in range(c):\n        for k, v in diago[i].items():\n            costs[i][j] += D[k][j]*v\n\nINF = 10**18\nans = INF\nfor trio in itertools.combinations(range(c), 3):\n    for color in itertools.permutations(trio, 3):\n        cost = sum(costs[i][j] for i, j in enumerate(color))\n        if cost < ans:\n            ans = cost\nprint(ans)
import sys\n\nsys.setrecursionlimit(10 ** 6)\nINF = float("inf")\nMOD = 10 ** 9 + 7\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef main():\n    N, S = input().split()\n    N = int(N)\n    ans = 0\n\n    for i in range(N):\n        a = 0\n        c = 0\n        for j in range(i, N):\n            if S[j] == "A":\n                a += 1\n            elif S[j] == "T":\n                a -= 1\n            elif S[j] == "C":\n                c += 1\n            else:\n                c -= 1\n\n            if a == c == 0:\n                ans += 1\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n# from decorator import stop_watch\n# \n# \n# @stop_watch\ndef solve(N, K, S):\n    S = [int(s) for s in S]\n    point_l = 0\n    point_r = 0\n    # decision r\n    num_0 = 0 if S[0] == 1 else 1\n    flg = S[0]\n    for i in range(N):\n        if S[i] != flg:\n            if flg == 1:\n                num_0 += 1\n                if num_0 > K:\n                    point_r = i - 1\n                    break\n            flg = S[i]\n        if i == N - 1:\n            point_r = i\n            break\n    # measuring method\n    ans = point_r - point_l + 1\n    while point_r < N - 1:\n        # move point_l\n        for i in range(0, N):\n            if S[point_l + i] != S[point_l + i + 1]:\n                if S[point_l + i + 1] == 1:\n                    point_l += i + 1\n                    break\n        # move point_r\n        for i in range(1, N):\n            if point_r + i == N - 1:\n                point_r = N - 1\n                break\n            if S[point_r + i] != S[point_r + i + 1]:\n                if S[point_r + i + 1] == 0:\n                    point_r += i\n                    break\n        ans = max(ans, point_r - point_l + 1)\n\n    print(ans)\n\n\ndef __starting_point():\n    N, K = list(map(int, input().split()))\n    S = input()\n    solve(N, K, S)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # solve()\n\n__starting_point()
N = int(input())\nA = tuple(map(int, input().split(' ')))\n\nbits = [0] * (N + 1)\n\ni = N\nwhile i > 0:\n    j = i\n    ones = 0\n    while j <= N:\n        ones += bits[j]\n        j += i\n    if ones % 2 != A[i - 1]:\n        bits[i] = 1\n    i -= 1\n\nindexes = []\nfor i in range(1, N + 1):\n    if bits[i] == 1:\n        indexes.append(i)\n\nprint((len(indexes)))\nif indexes:\n    print((*indexes))\n
n = int(input())\na = list(map(int, input().split()))\nans = a[0]\nl = []\n\nfor i in range(1, n, 2):\n    ans -= a[i]\n    ans += a[i + 1]\n\nl.append(ans)\n\nfor i in range(n - 1):\n    ans = (a[i] - ans//2)*2\n    l.append(ans)\n\nfor i in l:\n    print(i, end = " ")
s, r = map(int, input().split())\nv = []\nfor i in range(s):\n	v += [list(map(int, input().split()))]\nans = 0\np = [(0, 1), (0, -1), (1, 0), (-1, 0)]\nfor i in range(s):\n	if v[i].count(1) == 0:\n		continue\n	if v[i].count(1) == 1:\n		ans += r - 1\n	else: \n		a = v[i].index(1)\n		b = v[i][::-1].index(1)\n		ans += 2 * r - a - b - 2 * v[i].count(1)\nv1 = []\nfor i in range(r):\n	v1 += [[v[j][i] for j in range(s)]]\nfor i in range(r):\n	if v1[i].count(1) == 0:\n		continue\n	if v1[i].count(1) == 1:\n		ans += s - 1\n	else: \n		a = v1[i].index(1)\n		b = v1[i][::-1].index(1)\n		ans += 2 * s - a - b - 2 * v1[i].count(1)\nprint(ans)
from heapq import heappush, heappop\nqueue = []\ndegree = []\ns = []\nans = []\nn = int(input())\nused = [False for i in range(n)]\nfor i in range(n):\n    a, b = list(map(int, input().split()))\n    degree.append(a)\n    s.append(b)\n    heappush(queue, (a, i))\nwhile queue:\n    el = heappop(queue)\n    vert = el[1]\n    if used[vert]:\n        continue\n    used[vert] = True\n    if degree[vert] == 0:\n        continue\n    other = s[vert]\n    ans.append((vert, other))\n    s[other] ^= vert\n    degree[other] -= 1\n    heappush(queue, (degree[other], other))\nprint(len(ans))\nfor el in ans:\n    print(el[0], el[1])\n\n
s=input()\nans=0\n\ni=1\npast=int(s[0])\nc=1\nans=1\nwhile(i<len(s)):\n    if(int(s[i])+past==9):\n        c+=1\n        past=int(s[i])\n    else:\n        if(c%2==1 and c!=1):\n            ans*=(c//2+1)\n        c=1\n        past=int(s[i])\n    i+=1\nif(c!=1 and c%2==1):\n    ans*=(c//2+1)\n\n    \nprint(ans)\n        \n    \n    \n
"""\nCodeforces Round 244 Div 1 Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\nclass InputHandlerObject(object):\n    inputs = []\n\n    def getInput(self, n = 0):\n        res = ""\n        inputs = self.inputs\n        if not inputs: inputs.extend(input().split(" "))\n        if n == 0:\n            res = inputs[:]\n            inputs[:] = []\n        while n > len(inputs):\n            inputs.extend(input().split(" "))\n        if n > 0:\n            res = inputs[:n]\n            inputs[:n] = []\n        return res\nInputHandler = InputHandlerObject()\ng = InputHandler.getInput\n\n############################## SOLUTION ##############################\nn = int(input())\na = [int(x) for x in g()]\nct = 0\nres = 0\nfor i in a:\n    ct += i\n    if ct < 0:\n        res += 1\n        ct = 0\nprint(res)
MOD = 1000000007\n\ndef main():\n    opts = [0] * 64\n    for i in range(64):\n        for j in range(64):\n            opts[i & j] += 1\n\n    s = input()\n    n = len(s)\n    ans = 1\n    for c in s:\n        if '0' <= c <= '9':\n            ans *= opts[ord(c) - ord('0')]\n            ans %= MOD\n        elif 'A' <= c <= 'Z':\n            ans *= opts[ord(c) - ord('A') + 10]\n            ans %= MOD\n        elif 'a' <= c <= 'z':\n            ans *= opts[ord(c) - ord('a') + 36]\n            ans %= MOD\n        elif c == '-':\n            ans *= opts[62]\n            ans %= MOD\n        else:\n            ans *= opts[63]\n            ans %= MOD\n\n    print(ans)\n\nmain()\n
n,k = list(map(int, input().split()))\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nr = 0\nok = 1\nwhile ok:\n    L = [0 for _ in range(n)]\n    for i in range(n):\n        B[i] = B[i] - A[i]\n        if B[i] < 0:\n            L[i] = -B[i]\n            B[i] = 0\n    if sum(L) <= k:\n        r += 1\n        k = k - sum(L)\n    else:\n        ok = 0\nprint(r)\n        \n
__author__ = 'User'\nn, m = list(map(int, input().split()))\narr = list(map(int, input().split()))\nfor i in range(n):\n    arr[i] = arr[i] % m\nd = [0] * m\nfor e in arr:\n    t = [0] * m\n    t[e] = 1\n    for i in range(m):\n        if d[i] == 1:\n            #print("T", i + e)\n            t[(i + e) % m] = 1\n    for i in range(m):\n        if t[i] == 1:\n            d[i] = 1\n    #print(d)\n    if d[0] == 1:\n        break\nif d[0] == 1:\n    print("YES")\nelse:\n    print("NO")\n#print(d)\n#print(arr)\n
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [tuple(map(int, l.split())) for l in sys.stdin]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n = I()\n    a = LI()\n\n    r = 0\n    ai = 0\n    for i in range(n):\n        if a[i] < 2:\n            continue\n        while ai < i:\n            if a[ai] < 1:\n                ai += 1\n                continue\n            if a[i] < 2:\n                break\n            r += 1\n            a[ai] -= 1\n            a[i] -= 2\n        r += a[i] // 3\n        a[i] %= 3\n\n    return r\n\nprint(main())\n\n\n
m = 1000000007\nn = int(input())\na = map(int, input().split())\nt1, t2 = 0, 0\nfor i in a:\n	if i == 1:\n		t1 += 1\n	else:\n		t2 += 1\na = [1, 2]\nfor i in range(3, t1+1):\n	a = a[::-1]\n	a[1] = (a[0]+(i-1)*a[1])%m\nif not t1 or t1 == 1:\n	a[1] = 1\nfor i in range(t1+1, n+1):\n	a[1] = a[1]*i%m\nprint(a[1])
#!/usr/bin/env python3\nimport collections\n\nn, s = list(map(int, input().split()))\n\nbuy_orders = collections.defaultdict(int)\nsell_orders = collections.defaultdict(int)\n\nfor i in range(n):\n    d, p, q = input().split()\n    p, q = int(p), int(q)\n\n    if d == 'B':\n        buy_orders[p] += q\n    else:\n        sell_orders[p] += q\n\nbuy_orders = sorted(list(buy_orders.items()), reverse=True)\nsell_orders = sorted(list(sell_orders.items()), reverse=True)\n\nfor order in sell_orders[-s:]:\n    print('S', order[0], order[1])\nfor order in buy_orders[:s]:\n    print('B', order[0], order[1])\n
n=int(input())\nl=list(map(int,input().split()))\ns=input()\nwater=0\ngrass=0\ncgrass=0\ntime=0\nseen=False\nfor i in range(n):\n    if s[i]=="G":\n        dist=l[i]\n        if water>=dist:\n            water-=dist\n            time+=2*dist\n            cgrass+=dist\n        else:\n            dist-=water\n            time+=2*water\n            cgrass+=water\n            water=0\n            time+=3*dist\n            grass+=dist\n    elif s[i]=="W":\n        water+=l[i]\n        time+=2*l[i]\n        seen=True\n    else:\n        dist=l[i]\n        if water>=dist:\n            water-=dist\n            time+=2*dist\n        else:\n            dist-=water\n            time+=2*water\n            water=0\n            if cgrass>=dist:\n                cgrass-=dist\n                grass+=dist\n                time+=3*dist\n            else:\n                dist-=cgrass\n                grass+=cgrass\n                time+=3*cgrass\n                cgrass=0\n                if grass>=dist:\n                    grass-=dist\n                    time+=3*dist\n                else:\n                    dist-=grass\n                    time+=3*grass\n                    grass=0\n                    if seen:\n                        time+=4*dist\n                    else:\n                        time+=6*dist\nprint(time)
from sys import stdin\n\nn = int(stdin.readline())\na = [int(x) for x in stdin.readline().split()]\na = sorted([(a[x],str(x+1)) for x in range(n)])\nk = int(stdin.readline())\n\nsums = [0]\nfor x in a:\n    sums.append(sums[-1]+x[0])\n\ntotal = 0\ns = 0\n\nfor x in range(k):\n    total += a[x][0]*x-s\n    s += a[x][0]\n\nlow = total\nlowInd = 0\n\n#print(total)\n\nfor x in range(n-k):\n    s -= a[x][0]\n    total -= s-a[x][0]*(k-1)\n    total += a[x+k][0]*(k-1)-s\n    s += a[x+k][0]\n    if total < low:\n        low = total\n        lowInd = x+1\n\nout = []\n\nfor x in range(lowInd,lowInd+k):\n    out.append(a[x][1])\nprint(' '.join(out))\n
n = int(input())\na = list(map(int, input().split()))\ni = 1\nwhile i <= n - i + 1:\n    if i % 2:\n        a[i - 1], a[-i] = a[-i], a[i - 1]\n    i += 1\nprint(*a)\n
#!/usr/bin/env python3\nfrom sys import stdin\nfrom bisect import bisect_left, bisect_right\n    \nINF = int(1e9)\n\ndef find(par, a):\n    if par[a] == a:\n        return a\n    par[a] = find(par, par[a])\n    return par[a]\n\ndef union(par, rnk, a, b):\n    a = find(par,a)\n    b = find(par,b)\n    if a==b:\n        return\n    \n    if rnk[a]<rnk[b]:\n        par[a] = b\n    else:\n        par[b] = a\n        if rnk[a]==rnk[b]:\n            rnk[a] += 1\n    \ndef solve():\n    n, m, k = map(int, stdin.readline().split())\n    cnts = list(map(int, stdin.readline().split()))\n    for i in range(1,k):\n        cnts[i] += cnts[i-1]\n    \n    group = list(range(n))\n    rnk = [0 for i in range(n)]\n    adj = [[INF for j in range(k)] for i in range(k)]\n    for i in range(m):\n        u, v, x = map(int, stdin.readline().split())\n        if x==0:\n            union(group, rnk, u-1, v-1)\n        tu = bisect_left(cnts, u)\n        tv = bisect_left(cnts, v)\n        adj[tu][tv] = min(adj[tu][tv], x)\n        adj[tv][tu] = min(adj[tv][tu], x)\n    \n    p = 0\n    for i in range(k):\n        cur = group[p]\n        while p<cnts[i]:\n            if group[p]!=cur:\n                print("No")\n                return\n            p += 1\n    print("Yes")\n    \n    for p in range(k):\n        for i in range(k):\n            for j in range(k):\n                adj[i][j] = min(adj[i][j], adj[i][p]+adj[p][j])\n    \n    for i in range(k):\n        adj[i][i] = 0\n        for j in range(k):\n            if adj[i][j] == INF:\n                adj[i][j] = -1\n    \n    for i in range(k):\n        print(' '.join(map(lambda x: str(x), adj[i])))\n    \n    \nsolve()
n, m = map(int, input().split())\n\nif n == 1:\n    print(1)\nelse:\n    print('{:9}'.format((n-1)/n * (m - 1) / (n*m - 1) + 1 / n))
n, d = list(map(int, input().split()))\n\nfor i in range(int(input())):\n    x, y = list(map(int, input().split()))\n    print(('YES' if x+y in range(d, n + n - d + 1) and x-y in range(-d, d + 1) else 'NO'));\n
\nt=int(input())\nfor nbt in range(t):\n    n,k=[int(i) for i in input().split()]\n    a=[int(i) for i in input().split()]\n    nbc=len(set(a))-1\n    if k==1:\n        if nbc:\n            print(-1)\n        else:\n            print(1)\n    else:\n        print(1+max(0,(nbc-1)//(k-1)))
s = input()\npref = []\ncnt1 = s.count('1')\ns = s.replace('1', '')\ni = 0\nwhile i < len(s) and s[i] != '2':\n	i += 1\nend = ''\nif i != len(s):\n	end = s[i:]\ns = s[:i] + '1' * cnt1 + end\nprint(s)
n, k = list(map(int, input().split()))\nprint(sum(s.count('4')+s.count('7')<=k for s in input().split()))
from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_str(): return list(sys.stdin.readline().split())\n\nH,W = inpl()\nrr = inpl()\ncc = inpl()\n\nMAP = [[-1]*W for _ in range(H)]\n\nfor x,c in enumerate(cc):\n    for y in range(c):\n        MAP[y][x] = 1\n    if c < H:\n        MAP[c][x] = 0\n\n\nfor y,r in enumerate(rr):\n    for x in range(r):\n        if MAP[y][x] == 0:\n            print(0)\n            return\n        MAP[y][x] = 1\n    if r < W:\n        if MAP[y][r] == 1:\n            print(0)\n            return\n        MAP[y][r] = 0\n\ncnt = 0\nfor y in range(H):\n    for x in range(W):\n        if MAP[y][x] == -1:\n            cnt += 1\n\nprint(pow(2,cnt,mod))\n
n, m = list(map(int, input().split()))\nA = list(map(int, input().split()))\nA.sort()\nans = [0] * n\nprefsum = [0] * m\nprefsum[0] = A[0]\nans[0] = A[0]\nfor i in range(1, n):\n  ans[i] = ans[i - 1] + prefsum[i % m] + A[i]\n  prefsum[i % m] += A[i]\nprint(*ans)\n
n, m = map(int, input().split())\nmatr = [list(map(int, input().split())) for _ in range(n)]\n\nfor i, st in enumerate(matr):\n    for j, elem in enumerate(st):\n        if matr[~i][~j] == 0:\n            matr[~i][~j] = min(matr[~i + 1][~j], matr[~i][~j + 1]) - 1\n\n# print(*matr, sep='\n')\n\nfor i, st in enumerate(matr):\n    for j, elem in enumerate(st):\n        if i != 0 and j != 0:\n            if matr[i][j] <= max(matr[i - 1][j], matr[i][j - 1]):\n                print('-1')\n                return\n        elif i == 0 and j != 0:\n            if matr[i][j] <= matr[i][j - 1]:\n                print('-1')\n                return\n        elif i != 0 and j == 0:\n            if matr[i][j] <= matr[i - 1][j]:\n                print('-1')\n                return\nprint(sum(sum(l) for l in matr))
n = int(input())\nm = (n + 2) // 2\nd = [0, 1]\nprint(m)\nfor i in range(1, n + 1):\n    if d[0] < m:\n        d[0] += 1\n        print(*d)\n    else:\n        d[1] += 1\n        print(*d)\n
import sys\nn = int(input())\ns = [input() for i in range(n)]\na = [[1] * (2 * n) for i in range(2 * n)]\n\nfor i in range(n):\n    for j in range(n):\n        if s[i][j] != 'o':\n            continue\n        for x in range(n):\n            for y in range(n):\n                if s[x][y] == '.':\n                    a[n + x - i][n + y - j] = 0\nfor i in range(n):\n    for j in range(n):\n        if s[i][j] != 'x':\n            continue\n        c = 0\n        for x in range(n):\n            for y in range(n):\n                if s[x][y] == 'o' and a[n + i - x][n + j - y] == 1:\n                    c = 1\n                    break\n            if c == 1:\n                break\n        if c == 0:\n            print('NO')\n            return\nprint('YES')\nfor i in range(1, 2 * n):\n    for j in range(1, 2 * n):\n        if i == n and j == n:\n            print('o', end='')\n        elif a[i][j] == 1:\n            print('x', end='')\n        else:\n            print('.', end='')\n    print('')\n\n
def main():\n\n    a = str(input())\n    b = str(input())\n\n    print(a.count(b))\n\n\ndef __starting_point():\n    main()\n__starting_point()
n = int(input())\ns = input()\nfor i in range(len(s) - 1):\n	if s[i] > s[i + 1]:\n		print("YES")\n		print(i + 1, i + 2)\n		return\nprint("NO")\n
def calc_shortest(N, D, s1, s2):\n    #D[1:3] = D[1]+D[2] = d_2+d_3 = distance between Station 2 and Station 4\n    if s1 == s2:\n        return 0\n    elif s1 < s2:\n        s1_index = s1-1\n        s2_index = s2-1\n    else:\n        s1_index = s2-1\n        s2_index = s1-1\n\n    #print("s1:"+str(s1_index)+" s2:"+str(s2_index))\n    path1 = sum(D[s1_index:s2_index])\n    path2 = sum(D)-path1\n\n    if path1 < path2:\n        return path1\n    else:\n        return path2\n\nN = [int(i) for i in input().strip().split()][0]\nD = [int(i) for i in input().strip().split()]\ns1, s2 = [int(i) for i in input().strip().split()]\nprint(calc_shortest(N, D, s1, s2))\nreturn
n = int(input())\nprint(n*3+4)\nprint(0, 0)\nprint(1, 0)\nfor i in range(n):\n    for j in range(3):\n        print(i+j, i+1)\nprint(n, n+1)\nprint(n+1, n+1)\n
g = {}\ndef push(u, v, w):\n    g[u] = [v, w]\n \nn, pos  = list(map(int, input().split()))\nV = list(map(int, input().split()))\nW = list(map(int, input().split()))\n \nfor _ in range(n):\n    push(_, V[_], W[_])\n \nmax_log = 35\nnext_n  = [[-1] * n for _ in range(max_log)]\nnext_m  = [[float('inf')] * n for _ in range(max_log)]\nnext_s  = [[0] * n for _ in range(max_log)]\n \nfor u in range(n):\n    v, w      = g[u]\n    next_n[0][u]  = v\n    next_m[0][u]  = w\n    next_s[0][u]  = w\n    \nfor k in range(1, max_log):\n    for u in range(n):\n        v  = next_n[k-1][u]\n        m  = next_m[k-1][u]\n        s  = next_s[k-1][u]\n    \n        next_n[k][u] = next_n[k-1][v] \n        next_m[k][u] = min(next_m[k-1][v], m)\n        next_s[k][u] = next_s[k-1][v] + s\n    \nm_arr = [float('inf')] * n\ns_arr = [0] * n\n \nfor _ in range(n):\n    s, m = 0, float('inf')\n    v    = _\n    \n    cur = 1<<max_log\n    i   = max_log\n \n    while cur > 0:\n        if cur & pos:\n            m = min(m, next_m[i][v])\n            s = s + next_s[i][v]\n            v = next_n[i][v]\n            \n        cur >>= 1\n        i    -= 1\n        \n    m_arr[_] = m\n    s_arr[_] = s\n    \narr = [str(x) + ' ' + str(y) for x, y in zip(s_arr, m_arr)]\nprint('\n'.join([x for x in arr]))\n
n, k = map(int, input().split())\narr = [0] * 26\ns = input()\naux = ord('A')\nfor i in range(len(s)):\n    arr[ord(s[i]) - aux] += 1\narr.sort(reverse = True)\ni = 0\nsum = 0\nwhile k > 0:\n    if arr[i] >= k:\n        sum += k ** 2\n        k = 0\n    else:\n        k -= arr[i]\n        sum += arr[i] ** 2\n        i += 1\nprint(sum)
N = int(input())\ntable = []\nfor i in range(N):\n    table.append(list(map(int, input().split())))\n\nfor i in range(N):\n    for j in range(N):\n        if table[i][j] == 1:\n            continue\n        flg = False\n        for s in range(N):\n            for t in range(N):\n                if table[i][j] == table[i][s] + table[t][j]:\n                    flg = True\n                    break\n        if not flg:\n            print("No")\n            return\nprint("Yes")\n
import re\nimport itertools\nfrom collections import Counter\n\nclass Task:\n    strings = []\n    answer = ""\n	\n    def getData(self):\n        numberOfStrings = int(input())\n        for i in range(0, numberOfStrings):\n            self.strings += [input()]\n	\n    def solve(self):\n        badStrings = set()\n        for current in self.strings:\n            for left in range(0, len(current)):\n                for right in range(left + 1, len(current) + 1):\n                    badStrings.add(current[left : right])\n        alphabet = []\n        for character in range(ord('a'), ord('z') + 1):\n            alphabet += [chr(character)]\n        \n        for answerLength in range(1, 21 + 1):\n            for p in itertools.product(alphabet, repeat = answerLength):\n                string = re.sub("[^\w]", "", str(p));\n                if string not in badStrings:\n                    self.answer = string\n                    return\n\n    def printAnswer(self):\n        print(self.answer)\n\ntask = Task();\ntask.getData();\ntask.solve();\ntask.printAnswer();\n
n,k=map(int,input().split())\na=list(input())\nans,cnt=list(list()),0\nwhile True :\n	cur=list()\n	for i in range(n-1) :\n		if a[i]=='R' and a[i+1]=='L' :\n			cur.append(i)\n			cnt+=1\n	if len(cur)>0:\n		ans.append(cur.copy())\n		for i in cur :\n			a[i],a[i+1]=a[i+1],a[i]\n	else :\n		break \nif len(ans)>k or cnt<k:\n	print(-1)\nelse :\n	lst=list()\n	dumb=k-len(ans)\n	w,p=0,0\n	while dumb>0 :\n		lst.append("1 "+str(ans[w][p]+1)+"\n")\n		dumb-=1\n		p+=1\n		if p==len(ans[w]) :\n			p=0\n			w+=1\n			dumb+=1\n	while w<len(ans) :\n		lst.append(str(len(ans[w])-p)+" ")\n		while p<len(ans[w]) :\n			lst.append(str(ans[w][p]+1)+" ")\n			p+=1\n		lst.append("\n")\n		w+=1\n		p=0\n	print("".join(lst))
from collections import Counter, defaultdict\nimport heapq\nfrom sys import stdin, stdout\nraw_input = stdin.readline\nxrange=range\nn,m,k=list(map(int,input().split()))\nk=min(n-1,k)\np=[0]*(n+1)\nvis = [0]*(n+1)\nd=[[] for i in range(n+1)]\nans=[]\ndp={}\nfor i in range(m):\n    u,v,w=list(map(int,input().split()))\n    d[u].append((v,w))\n    d[v].append((u,w))\n    dp[(u,v)]=i+1\n    dp[(v,u)]=i+1\nq=[(0,1,1)]\nc=0\nwhile q:\n    wt,x,par=heapq.heappop(q)\n    if vis[x]:\n        continue\n    vis[x]=1\n    c+=1\n    if par!=x:\n        \n        ans.append(str(dp[(par,x)]))\n    if c>k:\n        break\n    \n    for i,w in d[x]:\n        if not vis[i]:\n            heapq.heappush(q,(wt+w,i,x))\nprint(len(ans))\nprint(' '.join(ans))\n
import sys\nfrom math import *\nfrom fractions import gcd\nreadints=lambda:list(map(int, input().strip('\n').split()))\n\nn=int(input())\narr = list(readints())\n\npref=0\nbasis=[]\n\nfor v in arr:\n    pref = pref^v\n    for b in basis:\n        v = min(v, v^b)\n    if v>0:\n        basis.append(v)\n\n\nif pref==0:\n    print(-1)\nelse:\n    print(len(basis))\n
def sortHashtags(htags):\n	def shorten(j, i):\n		s = 0\n		while s < len(htags[i]) and htags[i][s] == htags[j][s]:\n			s += 1\n		htags[j] = htags[j][:s]\n\n	n = len(htags)\n\n\n	for i in range(n-1, 0, -1):\n		if htags[i-1] > htags[i]:\n			shorten(i-1, i)\n\n	return '\n'.join(htags)\n\nn = int(input())\ntags = []\nfor i in range(n):\n	tags.append(input())\n\nprint(sortHashtags(tags))\n
import math\n\nl = int(input()) - 1\nn = int(math.log2(l + 1) + 1)\nres = []\nfor i in range(n - 1):\n    res.append([i + 1, i + 2, 0])\n    res.append([i + 1, i + 2, 2 ** i])\ni = n - 2\nwhile l > 2 ** (n - 1) - 1:\n    t = l - 2 ** i + 1\n    if t > 2 ** (n - 1) - 1:\n        res.append([i + 1, n, t])\n        l = t - 1\n    i -= 1\nprint((n, len(res)))\nfor i in range(len(res)):\n    print((res[i][0],res[i][1],res[i][2]))\n
x = int(input())\nif x <= 6:\n    print((1))\n    return\nelif 7 < x <= 11:\n    print((2))\n    return\nelse:\n    n = x//11\n    if x - n*11 == 0:\n        print((2*n))\n        return\n    elif x - n*11 <= 6:\n        print((2*n+1))\n    else:\n        print((2*n+2))\n
N = int(input())\nu, v, w = [0]*(N-1), [0]*(N-1), [0]*(N-1)\nn = [-1] * N\n# n[][0] 色　n[][1] 連結先一覧リスト n[][2] mod2 \nfor i in range(N):\n    n[i] = [0]*4\n    n[i][1] = []\n    n[i][2] = []\n\nfor i in range(N-1):\n    u[i], v[i], w[i] = list(map(int, input().split()))\n    n[u[i]-1][1].append(v[i]-1)\n    n[v[i]-1][1].append(u[i]-1)\n    n[u[i]-1][2].append(w[i]%2)\n    n[v[i]-1][2].append(w[i]%2)\n\nstack = [u[0]-1]\n\nwhile True:\n    num = stack.pop()\n    n[num][3] = 1\n    for i in range(len(n[num][1])):\n        if n[n[num][1][i]][3] == 0:\n            stack.append(n[num][1][i])\n            if n[num][2][i] == 0:\n                n[n[num][1][i]][0] = n[num][0]\n            else:\n                n[n[num][1][i]][0] = -1 * n[num][0] + 1\n    if len(stack) == 0:\n        break\n\nfor i in n:\n    print(i[0])
#!/usr/bin/env python3\nimport sys\n\ninput = sys.stdin.readline\n\n\ndef S():\n    return input().rstrip()\n\n\ndef I():\n    return int(input())\n\n\ndef MI():\n    return list(map(int, input().split()))\n\n\nN, X, Y = MI()\ncnt = [0] * N\n\nfor i in range(1, N + 1):\n    for j in range(i + 1, N + 1):\n        idx = min(j - i, abs(X - i) + abs(Y - j) + 1)\n        cnt[idx] += 1\n\nfor c in cnt[1:]:\n    print(c)\n
n=int(input())\nd={}\nd1={}\nfor i in range(n):\n  a,b=list(map(int,input().split()))\n  d[a]=b\n  d1[b]=a\nr=[0]*n\nfront=0\ni=1\nwhile i<n:\n  r[i] = d.get(front)\n  front = r[i]\n  i += 2\nfor f in list(d.keys()):\n  if d1.get(f) == None:\n    front = f\n    break\nr[0]=front\ni=2\nwhile i<n:\n  r[i] = d.get(front)\n  front = r[i]\n  i += 2\nprint(*r)\n\n
mod = 10 ** 9 + 7\nn = int(input())\nh = list([int(x) - 1 for x in input().split()])\nans = x = 0\nfor i in range(n):\n    ans += h[i] + min(h[i], h[i - 1]) * x\n    if i < n - 1:\n        x *= min(h[i - 1], h[i], h[i + 1])\n        x += min(h[i], h[i + 1])\n    ans %= mod\n    x %= mod\nprint(ans)\n
p = 10 ** 9 + 7\nn, b, k, x = [int(s) for s in input().split()]\nblock = [int(s) for s in input().split()]\nD = [0 for i in range(10)]\nfor s in block:\n    D[s] += 1\nA = [[0 for t in range(x)]]\npows = [pow(10, 1<<j, x) for j in range(b.bit_length())]\nfor i in range(10):\n    A[0][i%x] += D[i]\nfor j in range(b.bit_length()-1):\n    B = A[-1]\n    C = [sum(B[i]*B[(t - i*pows[j])%x] for i in range(x)) % p for t in range(x)]\n    A.append(C)\nans = None\nfor j in range(b.bit_length()):\n    if (b>>j)&1:\n        if ans is None:\n            ans = A[j][:]\n        else:\n            ans = [sum(A[j][(t - i*pows[j])%x]*ans[i] for i in range(x)) % p for t in range(x)]\nprint(ans[k])\n\n
n = int(input())\nif n >= 5:\n    print(n)\n    for i in range(1, n + 1, 2):\n        print(i, end = ' ')\n    for i in range(2, n + 1, 2):\n        print(i, end = ' ')\nelif n == 4:\n    print(4)\n    print(3, 1, 4, 2)\nelif n == 3:\n    print(2)\n    print(1, 3)\nelse:\n    print(1)\n    print(1)
n, m  = (int(x) for x in input().strip().split())\n\ncoproc = [int(x) for x in input().strip().split()]\nedges = []\nfor _ in range(m):\n  edges.append((int(x) for x in input().strip().split()))\n\ninorder = [0] * n \nadj = [[] for _ in range(n)]\nfor u, v in edges:\n  adj[v].append(u)\n  inorder[u] += 1\n  \nqueue0 = [u for u in range(n) if inorder[u]==0 and not coproc[u]]\nqueue1 = [u for u in range(n) if inorder[u]==0 and coproc[u]]\n\nres = 0 \n\nwhile len(queue0)>0 or len(queue1)>0:\n  \n  while queue0:\n    next0 = []\n    for u in queue0:\n      for v in adj[u]:\n        inorder[v] -= 1 \n        if inorder[v] == 0:\n          if coproc[v]:\n            queue1.append(v)\n          else:\n            next0.append(v)\n    queue0 = next0\n    \n  if queue1:\n    res += 1   # coproc call\n  \n  \n  while queue1:\n    next1 = []\n    for u in queue1:\n      for v in adj[u]:\n        inorder[v] -= 1 \n        if inorder[v] == 0:\n          if coproc[v]:\n            next1.append(v)\n          else:\n            queue0.append(v)\n    queue1 = next1\n  \nprint(res)
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\nstuff=input().split(",")\nn=len(stuff)\n\ncomm=[[] for _ in range(1000001)]\nst=[1000001]\n\nfor i in range(0,n,2):\n    while st[-1]==0: st.pop(-1)\n    comm[len(st)].append(stuff[i])\n    st[-1]-=1\n    st.append(int(stuff[i+1]))\n\nmaxd=0\nfor i in range(1000000,0,-1):\n    if len(comm[i]):\n        maxd=i\n        break\n\nprint(maxd)\nfor i in range(1,maxd+1):\n    print(" ".join(comm[i]))
n, m, k = list(map(int, str.split(input())))\nf = tuple([str.strip(input()) for _ in range(n)])\n\nr = []\nfor x in range(m):\n\n    cr = sum([f[y][x] == "U" for y in range(0, n, 2)])\n    for cx in range(max(0, x + 1 - n), x):\n\n        cr += f[x - cx][cx] == "R"\n\n    for cx in range(x + 1, min(m, n + x)):\n\n        cr += f[cx - x][cx] == "L"\n\n    r.append(cr)\n\nprint(str.join(" ", list(map(str, r))))\n
n, k = map(int, input().split())\naa = [int(x) for x in input().split()]\n\nnxt = [(i + 1) % n for i in range(n)]\nprv = [(i - 1 + n) % n for i in range(n)]\n\ncur = 0\nfor z in range(k):\n    a = aa[z]\n    a %= n\n    for i in range(a):\n        cur = nxt[cur]\n    nxt[prv[cur]] = nxt[cur]\n    prv[nxt[cur]] = prv[cur]\n    print(cur + 1, end=' ')\n    cur = nxt[cur]\n    n -= 1\n
n = int(input())\ns = []\nfor i in range(n):\n    s.append(input())\nnew = [[0] * n for i in range(n)]\nfor i in range(n):\n    for j in range(n):\n        if s[i][j] == 'o':\n            new[i][j] = 1\nflag = True\nfor i in range(n):\n    for j in range(n):\n        s = 0\n        if i > 0 and new[i - 1][j] == 1:\n            s += 1\n        if i < n - 1 and new[i + 1][j] == 1:\n            s += 1\n        if j > 0 and new[i][j - 1] == 1:\n            s += 1\n        if j < n - 1 and new[i][j + 1] == 1:\n            s += 1\n        if s % 2 == 1:\n            flag = False\n            break\nif flag:\n    print("YES")\nelse:\n    print("NO")
#CF Round 150. Div II Prob. A - Dividing Orange\nimport sys\n\nIn = sys.stdin\nn, k = [int(x) for x in In.readline().split()]\narr, s, cnt = [int(x) for x in In.readline().split()], set(), 1;\ns.update(arr)\nfor i in range(k):\n    c = [arr[i]]\n    for j in range(n - 1):\n        while (cnt in s):\n            cnt += 1;\n        c.append(cnt)\n        cnt += 1;\n    sep = ' '\n    print (sep.join(map(str, c)))
n = int(input())\np = [int(i) for i in input().split()]\nfor i in range(n):\n    tmp = [0] * n\n    j = i\n    while tmp[j] != 1:\n        tmp[j] = 1\n        j = p[j] - 1\n    print(j + 1, end = " ")\n
from functools import lru_cache\nN, K = list(map(int, input().split()))\nP = 998244353\nA = [K+100] + [int(a) for a in input().split()] + [K+j for j in range(1, 10)]\n# A = [K+100] + [1, 2] + [-1 for a in range(N-4)] + [3,4]+ [K+j for j in range(1, 10)]\n\nX = [[0,0] for _ in range(N//2+5)]\nX[0][0] = 1\nfor i in range(1, N//2+2):\n    X[i][0] = X[i-1][1]\n    X[i][1] = (X[i-1][0] * (K-1) + X[i-1][1] * (K-2)) % P\n    \nY = [[0,0] for _ in range(N//2+5)]\nY[0][1] = 1\nfor i in range(1, N//2+2):\n    Y[i][0] = Y[i-1][1]\n    Y[i][1] = (Y[i-1][0] * (K-1) + Y[i-1][1] * (K-2)) % P\n    \ndef calc(l, a, b):\n    if a > K and b > K:\n        return (K * pow(K-1, l-1, P)) % P\n    if a > K or b > K:\n        return pow(K-1, l, P)\n    if a == b:\n        return X[l+1][0]\n    else:\n        return Y[l+1][0]\n\n\n\nl = 0\nans = 1\nfor j in range(2):\n    pre = K + 50 + j\n    for i in range(j, N+5, 2):\n        if A[i] == -1:\n            l += 1\n        elif l > 0:\n            ans *= calc(l, pre, A[i])\n            ans %= P\n            pre = A[i]\n            l = 0\n        elif pre == A[i]:\n            # print(A)\n            ans = 0\n            break\n        else:\n            pre = A[i]\n\nprint(ans%P)\n
# written with help of editorial\nn, m = list(map(int, input().split()))\na = list(map(int, input().split()))\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ng = 0\nfor x in a:\n    g = gcd(g, x - 1)\n\nanswer = 0\n\ndef process(x):\n    nonlocal answer\n    if x % 2 == 0:\n        return 0\n    for i in range(30):\n        v = 2 ** i * x\n        if v > m:\n            break\n        answer += m - v\n\nfor i in range(1, g + 1):\n    if i * i > g:\n        break\n    if g % i:\n        continue\n    process(i)\n    if i * i != g:\n        process(g // i)\n\nprint(answer)\n
n = int(input())\na = list(map(int, input().split()))\nfor i in range(n):\n    if i == 0:\n        print(a[1] - a[0], a[-1] - a[0])\n    elif i == n - 1:\n        print(a[i] - a[i - 1], a[i] - a[0])\n    else:\n        print(min(a[i + 1] - a[i], a[i] - a[i - 1]), max(a[-1] - a[i], a[i] - a[0]))\n        \n
s = input()\nt = input()\nsa = s.count('0')\nsb = s.count('1')\nta = t.count('0')\ntb = t.count('1')\nn = len(s)\nL = abs(sa - ta) + abs(sb - tb)\nL /= 2\nif L % 2 == 1:\n    print("impossible")\nelse:\n    ans = ''\n    c = 0\n    for i in range(n):\n        if s[i] == t[i]:\n            ans += s[i]\n        else:\n            if c == 0:\n                ans += s[i]\n                c = 1\n            else:\n                ans += t[i]\n                c = 0\n    print(ans)\n
from fractions import *\ndef solve():\n    n = int(input())\n    a = list(map(int,input().split()))\n    a.sort()\n    ans1 = 0\n    pres = a[0]\n    for i in range(1,n):\n        ans1+=i*a[i] -pres\n        pres+=a[i]\n    ans1 *= 2;\n    tmp = pres+ans1\n    tmp1 = n\n    s = Fraction(tmp,tmp1)\n    print(s.numerator,s.denominator)\n\nsolve()
n = int(input())\ndisjointSet = [-1] * n\ndef root(x, level=200):\n    dp = []\n    while disjointSet[x] >= 0:\n        dp.append(x)\n        x = disjointSet[x]\n    for i in dp:\n        disjointSet[i] = x\n    return x\n\ndef join(x, y):\n    r1, r2 = root(x), root(y)\n    if r1 == r2:\n        return\n    disjointSet[r2] = r1\n\npoints = []\nvertPoints = {}\nhorizPoints = {}\nfor i in range(n):\n    a, b = map(int, input().split())\n    points.append((a, b))\n    if a in vertPoints:\n        join(i, vertPoints[a])\n    else:\n        vertPoints[a] = i\n    if b in horizPoints:\n        join(i, horizPoints[b])\n    else:\n        horizPoints[b] = i\n        \nsets = {}\nfor i in range(n):\n    r = root(i)\n    if r in sets:\n        sets[r].append(points[i])\n    else:\n        sets[r] = [points[i]]\n\nans = 1\nfor i in sets:\n    s = sets[i]\n    horiz = [x for x,y in s]\n    vert = [y for x,y in s]\n    tmp = len(set(horiz)) + len(set(vert))\n    if tmp <= len(s):\n        ans *= 2 ** tmp\n    else:\n        ans *= 2 ** tmp - 1\n    ans %= 10 ** 9 + 7\n\nprint(ans % (10 ** 9 + 7))
n, m = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\ns = 0\ncount = 1\ni = 0\nanswer = []\nwhile i < len(a) and s <= m:\n    if a[i] == count:\n        i += 1\n        count += 1\n    else:\n        s += count\n        answer.append(count)\n        count += 1\nif s > m:\n    s = s - count + 1\n    print(len(answer) - 1)\n    for i in range(len(answer) - 1):\n        print(answer[i], end = ' ')\nelif s == m:\n    print(len(answer))\n    for i in range(len(answer)):\n        print(answer[i], end = ' ')\nelse:\n    while s <= m:\n        s += count\n        answer.append(count)\n        count += 1\n    if s == m:\n        print(len(answer))\n        for i in range(len(answer)):\n            print(answer[i], end = ' ')\n    else:\n        s = s - count + 1\n        print(len(answer) - 1)\n        for i in range(len(answer) - 1):\n            print(answer[i], end = ' ')
n = int(input())\n\ncandies = list(map(int, input().strip().split()))\n\ndef intkoren(n):\n    k = int(n**0.5)\n    while (k+1)*(k+1) <= n:\n        k += 1\n    while k*k > n:\n        k -= 1\n    return k\n\ncnt1 = 0\ncnt2 = 0\nnew = []\nfor e in candies:\n    u = intkoren(e)\n    if e == 0:\n        new.append((2,1))\n        cnt1 += 1\n    elif u*u == e:\n        new.append((1,1))\n        cnt1 += 1\n    else:\n        mini = min(e - u*u, (u+1)*(u+1)-e)\n        new.append((mini, -1))\n        cnt2 += 1\n\nnew.sort()\n\n#print(new, cnt1,cnt2)\n\ncount = 0\nif cnt1 >= cnt2:\n    todo = (cnt1 - cnt2)//2\n    for steps, v in new:\n        if todo == 0:\n            break\n        if v == 1:\n            count += steps\n            todo -= 1\nelse:\n    todo = (cnt2 - cnt1)//2\n    for steps,v in new:\n        if todo == 0:\n            break\n        if v == -1:\n            count += steps\n            todo -= 1\nprint(count)\n
import sys\ninput = lambda:sys.stdin.readline().rstrip()\n\nh,w=map(int,input().split())\nd=w+2\nb=[0]*(w+2)\nfor i in range(h):\n  b+=([0]+[int(j=="X") for j in input()]+[0])\nb+=([0]*(w+2))\nco=sum(b)\nt=10**10\nfor i in range(1,h+1):\n  f=0\n  for j in range(w+2):\n    f+=b[i*d+j]\n    if b[i*d+j]==0 and f:\n      t=min(t,(f-1)//2)\n      f=0\nfor j in range(1,w+1):\n  f=0\n  for i in range(h+2):\n    f+=b[i*d+j]\n    if b[i*d+j]==0 and f:\n      t=min(t,(f-1)//2)\n      f=0\n\ncoo=0\nans=[-1]*(w+2)*(h+2)\nstack=[]\nfor i in range(h+2):\n  for j in range(w+2):\n    if b[i*d+j]==0:\n      stack.append(i*d+j)\n      ans[i*d+j]=0\ndij=[(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\nfor ij in stack:\n  i,j=divmod(ij,d)\n  for x,y in dij:\n    if 0<=i+x<h+2 and 0<=j+y<w+2:\n      if ans[(i+x)*d+j+y]==-1:\n        ans[(i+x)*d+j+y]=ans[i*d+j]+1\n        if ans[(i+x)*d+j+y]>t:\n          coo+=1\n        stack.append((i+x)*d+(j+y))\nif coo*6<co and t==1:\n  t-=1\nprint(t)\nfor i in range(1,h+1):\n  print("".join([".X"[int(t<j)]for j in ans[i*d+1:i*d+w+1]]))
n, m = map(int, input().split())\n\nfin = [list(input().strip()) for i in range(n)]\nans = [['-' for i in range(m)] for j in range(n)]\n\nfor y in range(n):\n    for x in range(m):\n        if fin[y][x] == '-':\n            continue\n        elif y % 2 == x % 2:\n            ans[y][x] = 'B'\n        else:\n            ans[y][x] = 'W'\nfor row in ans:\n    print(''.join(row))
s, p = input(), input()\nn, m = len(s) + 1, len(p)\nd = [[0] * n for t in range(n)]\nfor x in range(1, n):\n    i, j = x, m\n    while i and j:\n        j -= s[i - 1] == p[j - 1]\n        i -= 1\n    if not j:\n        for y in range(i + 1): d[x][y + x - i - m] = d[i][y] + 1\n    for y in range(x): d[x][y] = max(d[x][y], d[x - 1][y])\nprint(*d[-1])
#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom collections import defaultdict\n\nn = int(input())\nA = list(map(int,input().split()))\npattern = set()\nfor a in A:\n    p = []\n    while a > 0:\n        if a in pattern:\n            break\n        p.append(a)\n        a = a//2\n    pattern |= set(p)\n\ndef check(v):\n    ret = 0\n    for a in A:\n        count = 0\n        while a != 0:\n            if v == a or (v % a == 0 and (v//a)&-(v//a) == v//a):\n                ret += len(bin(v//a))-3\n                break\n            if (v%a == 0 and (v//a)&-(v//a) == v//a) and a < v:\n                return 1e12\n            a = a//2\n            ret += 1\n        else:\n            return 1e12\n    return ret\n\nans = 1e12\nfor p in pattern:\n    ret = check(p)\n    ans = ans if ans < ret else ret\nprint(ans)\n
from itertools import accumulate\nimport sys\n\ndef solve(f, g):\n    n, m, k, s = [int(x) for x in f.readline().split()]\n    a_price = [(int(x), i+1) for i, x in enumerate(f.readline().split())]\n    b_price = [(int(x), i+1) for i, x in enumerate(f.readline().split())]\n\n    a_gadgets = []\n    b_gadgets = []\n    for i, line in enumerate(f):\n        t, price = [int(x) for x in line.split()]\n        if t == 1:\n            a_gadgets.append((price, i + 1))\n        else:\n            b_gadgets.append((price, i + 1))\n\n    a_gadgets.sort()\n    b_gadgets.sort()\n\n    prefix_a = [0] + list(accumulate(gadget[0] for gadget in a_gadgets))\n    prefix_b = [0] + list(accumulate(gadget[0] for gadget in b_gadgets))\n\n    la = min(k, len(a_gadgets))\n    lb = min(k, len(b_gadgets))\n    min_price_for_k = [(prefix_a[i], prefix_b[k - i], i) for i in range(k-lb, la+1)]\n\n    for i in range(1, n):\n        a_price[i] = min(a_price[i], a_price[i-1])\n        b_price[i] = min(b_price[i], b_price[i-1])\n        \n    def expence(day):\n        return lambda x: a_price[day][0]*x[0] + b_price[day][0]*x[1]\n\n    x, y = 0, n-1\n    while x <= y-1:\n        day = (x + y) // 2\n        min_cost = min(min_price_for_k, key = expence(day))\n        if expence(day)(min_cost) > s:\n            x = day+1\n        else:\n            y = day\n    min_cost = min(min_price_for_k, key = expence(x))\n    if expence(x)(min_cost) > s:\n        g.write('-1\n')\n    else:\n        g.write(str(x+1) + '\n')\n        i1 = min_cost[-1]\n        A, B = ' ' + str(a_price[x][1]) + '\n', ' ' + str(b_price[x][1]) + '\n'\n        for i in range(i1):\n            g.write(str(a_gadgets[i][1]) + A)\n        for i in range(k - i1):\n            g.write(str(b_gadgets[i][1]) + B)\n\nsolve(sys.stdin, sys.stdout)\n
n = int(input())\n\nd = {}\n\nfor i in range(n):\n	s = input()\n	if s in d:\n		d[s] += 1\n	else:\n		d[s] = 1\n\nprint(d[max(d,key=d.get)])
n, q = list(map(int, input().split()))\nservers = [0] * n\nfor _ in range(q):\n    t, k, d = list(map(int, input().split()))\n    # free = [i for i, x in enumerate(servers) if x < t]\n    free = []\n    for sn in range(n):\n        if servers[sn] < t:\n            free.append(sn)\n        if len(free) == k:\n            break\n    if len(free) < k:\n        print(-1)\n\n    else:\n\n        for sn in free:\n            servers[sn] = t + d - 1\n\n        print(sum([x + 1 for x in free]))\n
#!/usr/bin/env python3\n\nOUT = (1, 0, 2, 3)\n\ntry:\n    while True:\n        n, m = map(int, input().split())\n        bus = [[None] * 4 for i in range(n)]\n        cur = 1\n        for row in range(n << 1):\n            if row >= n:\n                i = row - n\n                k = b = 1\n            else:\n                i = row\n                k = 3\n                b = 0\n            for j in range(2):\n                if cur <= m:\n                    bus[i][k * j + b] = cur\n                    cur += 1\n        for i in range(n):\n            for j in range(4):\n                if bus[i][OUT[j]] is not None:\n                    print(bus[i][OUT[j]], end=' ')\n        print()\n\nexcept EOFError:\n    pass\n
n, k = list(map(int, input().split()))\nx = list(map(int, input().split()))\n\nro = list(x[i] - x[i - 1] for i in range(1, n))\n\nif max(x[i] - x[i - 1] for i in range(1, n)) > k:\n    print(-1)\n\nelse:\n    ans = 1\n    r = 0\n\n    for el in ro:\n        r += el\n\n        if r > k:\n            ans += 1\n            r = el\n\n    print(ans)\n
# -*- coding: utf-8 -*-\n\n\ndef solve():\n    mod = 10**9 + 7\n    n, m = map(int, input().split())\n    p = input()\n    if m == 0:\n        return powmod(n)\n    delta = len(p) - 1\n    ys = map(int, input().split())\n    answer = 1\n    tail = 0\n    for y in ys:\n        if y > tail:\n            answer *= powmod(y - tail - 1)\n            answer %= mod\n        elif not is_consistent(p, tail - y + 1):\n            return 0\n        tail = y + delta\n    answer *= powmod(n - tail)\n    return answer % mod\n\nok_set = set()\ndef is_consistent(p, margin):\n    nonlocal ok_set\n    if margin in ok_set:\n        return True\n    elif p[:margin] == p[-margin:]:\n        ok_set.add(margin)\n        return True\n    else:\n        return False\n\ndef powmod(p):\n    mod = 10**9 + 7\n    pbin = bin(p)[2:][-1::-1]\n    result = 26 if pbin[0] == '1' else 1\n    tmp = 26\n    for bit in pbin[1:]:\n        tmp *= tmp\n        tmp %= mod\n        if bit == '1':\n            result *= tmp\n            result %= mod\n    return result\n\nprint(solve())
f=lambda a:(a+1)%2\n\nn=int(input())\na=list(map(int, bin(n)[2:].zfill(4)[::-1]))\na[3]=f(a[3])\nif (a[3]): a[2]=f(a[2])\nif a[3] and a[2]: a[1]=f(a[1])\nif a[3] and a[2] and a[1]: a[0]=f(a[0])\n\nprint (int("".join(map(str, a))[::-1], 2))
#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\n    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit\n    \nN, M= getIntList()\n\nne = [0 for i in range(N+1) ]\nza = getIntList()\nfor i in range(N-1):\n    ne[ za[i]] = za[i+1]\nne[za[-1]] = 0\n\nfor _ in range(1, M):\n    za = getIntList()\n    for i in range(N-1):\n        a = za[i]\n        b = za[i+1]\n        if ne[a] != b:\n            ne[a] = -1\n    a = za[-1]\n    if ne[a]!=0:\n        ne[a] = -1\n\ntin = [0 for i in range(N+1) ]\n\nfor i in range(1,N+1):\n    a = ne[i]\n    if a>0:\n        tin[a] = 1\n\nres = 0\nfor i in range(1,N+1):\n    if tin[i]: continue\n    n = 0\n    while i>0:\n        n+=1\n        i = ne[i]\n    res += n * (n+1) //2\n\nprint(res)\n\n\n\n\n\n
t = int(input())\n\nfor _ in range(t):\n    n, k = [int(x) for x in input().split()]\n    l1, r1 = [int(x) for x in input().split()]\n    l2, r2 = [int(x) for x in input().split()]\n    if l1 > l2:\n        l1, r1, l2, r2 = l2, r2, l1, r1\n\n    if l2 < r1:\n        # they already intersect.\n        start = (min(r1, r2) - max(l1, l2))*n\n        if start >= k:\n            print(0)\n            continue\n        cheap = n*(max(r1, r2) - min(l1, l2)) - start\n        if start + cheap >= k:\n            print(k - start)\n            continue\n        else:\n            print(cheap + (k - start - cheap)*2)\n            continue\n\n    # they do not intersect yet.\n    best = 10**100\n    cost_sf = 0\n    intersection_sf = 0\n    for j in range(n):\n        # compute price using j-th interval as the last.\n        cost_sf += l2 - r1\n        cheap = r2 - l1\n        if intersection_sf + cheap >= k:\n            best = min(best, cost_sf + max((k - intersection_sf), 0))\n\n        intersection_sf += cheap\n        cost_sf += cheap\n        \n        best = min(best, cost_sf + max((k - intersection_sf)*2, 0))\n    print(best)\n\n
px, py, vx, vy, a, b, c, d = map(int, input().split())\n\nvl = (vx**2 + vy**2)**0.5\nvx /= vl\nvy /= vl\n\nprint(px + vx * b, py + vy * b)\n\nprint(px - vy * a / 2, py + vx * a / 2)\nprint(px - vy * c / 2, py + vx * c / 2)\nprint(px - vy * c / 2 - vx * d, py + vx * c / 2 - vy * d)\n\nprint(px + vy * c / 2 - vx * d, py - vx * c / 2 - vy * d)\nprint(px + vy * c / 2, py - vx * c / 2)\nprint(px + vy * a / 2, py - vx * a / 2)
\n        \ndef main():\n    f= [1]\n    for i in range(1,1000002):\n        f.append((f[-1] * i)%1000000007)\n    \n    n = int(input())\n    a = sorted(int(x) for x in input().split())\n    sol = 0\n    j = 0\n    s = 1\n    sq = 1\n    for i in range(n - 1):\n        sq = sq * (n - i) % 1000000007\n        if a[i] != a[i + 1]:\n            sol += a[i] * (i - j + 1) * f[n - j - 1] * s\n            j = i + 1\n            s = sq\n\n    print(sol % 1000000007)\n            \n        \ndef __starting_point():\n    main()\n__starting_point()
n, k = map(int, input().split())\ns = input()\nour = set()\nopened = set()\nfor i in range(ord('A'), ord('Z') + 1):\n    sym = chr(i)\n    if sym in s:\n        our.add(s.rfind(sym))\nfor i in range(len(s)):\n    if s[i] not in opened:\n        opened.add(s[i])\n        k -= 1\n        if k < 0:\n            print('YES')\n            return\n    if i in our:\n        k += 1\nprint('NO')
n = int(input())\nA = list(map(int, input().split()))\nA.sort()\nA[0], A[-1] = A[-1], A[0]\nprint(" ".join(list(map(str, A))))
n = int(input())\nv = [0] + [int(e) for e in input().split()]\nans = 0\nfor a, b in zip(v[:-1], v[1:]):\n    if a < b:\n        ans += (b-a)*(n-b+1)\n    else:\n        ans += b*(a-b)\nprint(ans)\n
"""\nCodeforces Round 251 Div 2 Problem D\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0:\n        return inputs\n    if mode == 1:\n        return inputs.split()\n    if mode == 2:\n        return [int(x) for x in inputs.split()]\n\ndef write(s="\n"):\n    if isinstance(s, list): s = " ".join(s)\n    s = str(s)\n    print(s, end="")\n\n################################################### SOLUTION\nn,m = read()\na = read()\nb = read()\ns = [(0,2)] + [(i,0) for i in a] + [(i,1) for i in b]\ns.sort()\nt = sum(b)\nal = 0\nbr = m\nmn = t\nfor i in range(1,n+m+1):\n    t += (al-br) * (s[i][0] - s[i-1][0])\n    mn = min(mn, t)\n    if s[i][1]:\n        br -= 1\n    else:\n        al += 1\nprint(mn)
n, m, k = list(map(int, input().split()))\ndeadstep = [0] * (n+1)\nbadmem = [False] * (k+1)\na = [0] * (n+1)\nfor i in range(1, n+1):\n    a[i] = [0] + list(map(int, input().split()))\nfor step in range(1, m+1):\n    t = [0] * (k+1)\n    for i in range(1, n+1):\n        if deadstep[i] == 0 and a[i][step] != 0:\n            t[a[i][step]] += 1\n    for j in range(1, k+1):\n        if t[j] > 1:\n            badmem[j] = True\n    for i in range(1, n+1):\n        if deadstep[i] == 0 and badmem[a[i][step]]:\n            deadstep[i] = step\nfor i in range(1, n+1):\n    print(deadstep[i])\n
from sys import stdin, stdout\n\nn = int(stdin.readline().rstrip())\np = list(map(int,stdin.readline().rstrip().split()))\n\nif n==1:\n    print(p[0])\nelse:\n    removeDict={i:0 for i in range(1,n+1)}\n    l1 = p[0]\n    removeDict[l1]-=1\n    l2 = 0\n    for i in range(1,n):\n        if p[i]>l2:\n            if p[i]>l1:\n                l2=l1\n                l1=p[i]\n                removeDict[l1]-=1\n            else:\n                l2=p[i]\n                removeDict[l1]+=1\n    maxN = 1\n    maxRemove=-10\n    for i in range(1,n+1):\n        if removeDict[i]>maxRemove:\n            maxN = i\n            maxRemove = removeDict[i]\n    \n    print(maxN)\n
n,m,k=map(int,input().split())\nb=list(map(int,input().split()))\ndiffs=[]\nfor i in range(n-1):\n    diffs.append(b[i+1]-b[i])\ndiffs.sort()\nprint(k+sum(diffs[:n-k]))
from collections import defaultdict, Counter\nN = int(input())\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\nEdge = defaultdict(list)\nEdc = defaultdict(int)\nfor b, c in zip(B, C):\n    if b > c:\n        print(-1)\n        return\n    Edge[b].append(c)\n    Edc[(b, c)] += 1\n    if b != c:\n        Edge[c].append(b)\nDeg = Counter(B + C)\neul = 0\nst = []\nfor k, v in list(Deg.items()):\n    if v % 2:\n        eul += 1\n        st.append(k)\ns, e = B[0], B[0]\nif eul and eul != 2:\n    print(-1)\n    return\nif eul:\n    s, e = st[0], st[1]\nans = [s]\nwhile True:\n    vn = ans[-1]\n    while True:\n        vf = Edge[vn][-1]\n        if Deg[vf] != 0 and Edc[(vn, vf) if vn < vf else (vf, vn)]:\n            break\n        Edge[vn].pop()\n    vf = Edge[vn].pop()\n    Deg[vn] -= 1\n    Deg[vf] -= 1\n    Edc[(vn, vf) if vn < vf else (vf, vn)] -= 1\n    ans.append(vf)\n    if not Deg[vf]:\n        break\nloop = defaultdict(list)\nfor a in ans:\n    if Deg[a]:\n        loopa = [a]\n        while Deg[a]:\n            vn = loopa[-1]\n            while True:\n                vf = Edge[vn][-1]\n                if Deg[vf] != 0 and Edc[(vn, vf) if vn < vf else (vf, vn)]:\n                    break\n                Edge[vn].pop()\n            vf = Edge[vn].pop()\n            Deg[vn] -= 1\n            Deg[vf] -= 1\n            Edc[(vn, vf) if vn < vf else (vf, vn)] -= 1\n            loopa.append(vf)\n            if not Deg[vf]:\n                break\n        loop[a] = loopa\nAns = [] \nfor a in ans:\n    if loop[a]:\n        Ans.extend(loop[a])\n        loop[a] = []\n    else:\n        Ans.append(a)    \nif len(Ans) != N:\n    print(-1)\n    return\nprint(*Ans)\n\n\n
p, k = map(int, input().split())\nu = 10 * k - 1\nv = pow(10, p - 1, u) - k\nfor y in range(k, 10):\n    if (y * v) % u == 0:\n        q = d = 9 * y\n        while q % u: q = 10 * q + d\n        q = str(q // u)\n        print(q * (p // len(q)))\n        break\nelse: print('Impossible')
a = int(input())\nc = list(map(int,input().split()))\nsumm = 0\nfor i in range(a):\n    k = 0\n    k1 = 0\n    s = str(c[i])\n    for x in s:\n        k  = k * 100 + int(x)\n    k1 = k * 10\n    summ += (k + k1) * a\n    summ %= 998244353\nprint(summ)
n = int(input())\nans = [1, 3, 5, 7, 9, 11, 13, 15]\ndct = \\n{\n    1 : 1,\n    3 : 18,\n    5 : 1800,\n    7 : 670320,\n    9 : 734832000,\n    11 : 890786230,\n    13 : 695720788,\n    15 : 150347555\n}\nif n in ans:\n    print(dct[n])\nelse:\n    print(0)
import bisect\n\n\ndef gen_primes(upper_bound):\n    upper_bound += 1\n    t = [0] * (upper_bound)\n    primes = [2]\n    for i in range(3, upper_bound, 2):\n        if t[i]:\n            continue\n        primes.append(i)\n        for j in range(i + i, upper_bound, i):\n            t[j] = 1\n    return primes\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    primes = gen_primes(n + 1)\n    process = list()\n    d = [0] * n\n\n    for i in range(n):\n        d[a[i] - 1] = i\n\n    i = 0\n    while i < n:\n        if a[i] == i + 1:\n            i += 1\n            continue\n        r = d[i]\n        l = r - primes[bisect.bisect(primes, r - i + 1) - 1] + 1\n        a[l], a[r] = a[r], a[l]\n        process.append('{} {}'.format(l + 1, r + 1))\n        d[a[l] - 1] = l\n        d[a[r] - 1] = r\n\n    print(len(process))\n    print('\n'.join(process))\n\ndef __starting_point():\n    main()\n\n__starting_point()
n,L,a=list(map(int,input().split()))\ncount=0\nlast=0\nfor i in range(n):\n    t,l=list(map(int,input().split()))\n    count+=(t-last)//a\n    last=t+l\ncount+=(L-last)//a\nprint(count)\n
t = [0] * 26\n\n\ndef get_k(c):\n    return ord(c) - ord('a')\n\n\ndef analyze(s):\n    length_of_str = len(s)\n    pos = 0\n    beauty_table = [0] * 26\n    for i in range(1, length_of_str):\n        if s[i] != s[pos]:\n            k = get_k(s[pos])\n            beauty_table[k] = max(beauty_table[k], i - pos)\n\n            pos = i\n    k = get_k(s[pos])\n    beauty_table[k] = max(beauty_table[k], length_of_str - pos)\n\n    pos = 0\n    while pos < length_of_str and s[pos] == s[0]:\n        pos += 1\n    left_beauty = pos\n    pos = length_of_str - 1\n    while pos > 0 and s[pos] == s[length_of_str - 1]:\n        pos -= 1\n    right_beauty = length_of_str - pos - 1\n    return beauty_table, left_beauty, right_beauty\n\n\nr = []\nfor _ in range(int(input())):\n    p = input()\n    if all(x == p[0] for x in p):  # pure\n        k = get_k(p[0])\n        for i in range(26):\n            if i == k:\n                t[i] = len(p) * (t[i] + 1) + t[i]\n            else:\n                t[i] = min(1, t[i])\n    else:\n        for i in range(26):\n            t[i] = min(1, t[i])\n\n        bt, lb, rb = analyze(p)\n        lk, rk = get_k(p[0]), get_k(p[-1])\n\n        if lk == rk:\n            t[lk] = lb + rb + t[lk]\n        else:\n            t[lk], t[rk] = t[lk] + lb, t[rk] + rb\n        for i in range(26):\n            t[i] = max(t[i], bt[i])\n    # r.append(max(t))\n    # print('\ntableInfo: ', end= ' ')\n    # for i in range(26):\n    #     print('{}:{}/'.format(chr(i + ord('a')), t[i]), end=' ')\n    # print('')\n# print(' '.join(map(str, r)))\nprint(max(t))\n
p, n = map(int, input().split())\na = [-1 for i in range(p)]\nfor i in range(n):\n    b = int(input())\n    if a[b % p] != -1:\n        print(i + 1)\n        return\n    else:\n        a[b % p] = b\nprint(-1)
n = int(input())\nr = {}\nans = 0\nfor i in input():\n    if i == i.lower():\n        if i in r:\n            r[i] += 1\n        else:\n            r[i] = 1\n    else:\n        i = i.lower()\n        if i in r and r[i] > 0:\n            r[i] -= 1\n        else:\n            ans += 1\nprint(ans)
n, k = list(map(int, input().strip().split()))\n\njobs = list(map(int, input().strip().split()))\ntimes = list(map(int, input().strip().split()))\n\ncounts_jobs = {}\nfor job in jobs:\n    if job in counts_jobs:\n        counts_jobs[job] += 1\n    else:\n        counts_jobs[job] = 1\n\ntimes_i = []\nfor i, time in enumerate(times):\n    times_i.append((time, i))\n\ntimes_i.sort()\njobs_left = k-len(counts_jobs.keys())\n\nans = 0\nfor time, i in times_i:\n    if jobs_left == 0:\n        break\n    if counts_jobs[jobs[i]] > 1:\n        ans += time\n        jobs_left -= 1\n        counts_jobs[jobs[i]] -= 1\n\nprint(ans)
#! env/bin/local python3\n# -*- coding: utf-8 -*-\n\nsentence: str = input()\nn_sentence = len(sentence)\nsentence += '*'\ncounter = 0\nresults = []\n\nans = {i+1: 0 for i in range(n_sentence)}\n\nfor n in range(n_sentence):\n    counter += 1\n    if sentence[n] != sentence[n+1]:\n        results += [sentence[n], counter]\n        counter = 0\n\nindex = 0\n\nfor n in range(len(results)//2):\n\n    if results[2*n] == 'R':\n        index += int(results[2*n+1])\n        if int(results[2*n+1]) % 2 == 0:\n            evens = int(results[2*n+1]) // 2\n            odds = int(results[2*n+1]) // 2\n            ans[index] += odds\n            ans[index+1] += evens\n        else:\n            evens = (int(results[2*n+1]) - 1) // 2\n            odds = (int(results[2*n+1]) + 1) // 2\n            ans[index] += odds\n            ans[index + 1] += evens\n\n\n    if results[2*n] == 'L':\n        index += 1\n        if int(results[2 * n + 1]) % 2 == 0:\n            evens = int(results[2 * n + 1]) // 2\n            odds = int(results[2 * n + 1]) // 2\n            ans[index] += odds\n            ans[index - 1] += evens\n        else:\n            evens = (int(results[2 * n + 1]) - 1) // 2\n            odds = (int(results[2 * n + 1]) + 1) // 2\n            ans[index] += odds\n            ans[index - 1] += evens\n        index += int(results[2 * n + 1]) - 1\n\nans = ' '.join([str(c) for c in list(ans.values())])\n\nprint(ans)\n
def check(amidakuji,w):\n    before=0\n    flag=True\n    for _ in range(w-1):\n        if amidakuji&1==1 and before==1:\n            flag=False\n            break\n        elif amidakuji&1==1:\n            before=1\n            amidakuji>>=1\n        else:\n            before=0\n            amidakuji>>=1\n    return flag\n\nfrom sys import stdin\ndef main():\n    #入力\n    readline=stdin.readline\n    mod=10**9+7\n    h,w,k=map(int,readline().split())\n\n    dp=[[0]*w for _ in range(h+1)]\n    dp[0][0]=1\n    for i in range(1,h+1):\n        for bit in range(1<<(w-1)):\n            if check(bit,w)==False:\n                continue\n            else:\n                for j in range(w):\n                    if j==0:\n                        if bit&1==1:\n                            dp[i][j+1]+=dp[i-1][j]\n                        else:\n                            dp[i][j]+=dp[i-1][j]\n                    elif j==w-1:\n                        if bit&1==1:\n                            dp[i][j-1]+=dp[i-1][j]\n                        else:\n                            dp[i][j]+=dp[i-1][j]\n                    else:\n                        if bit&1==1:\n                            dp[i][j-1]+=dp[i-1][j]\n                            bit>>=1\n                        else:\n                            bit>>=1\n                            if bit&1==1:\n                                dp[i][j+1]+=dp[i-1][j]\n                            else:\n                                dp[i][j]+=dp[i-1][j]\n\n                for j in range(w):\n                    dp[i][j]%=mod\n\n    print(dp[h][k-1])\n\ndef __starting_point():\n    main()\n__starting_point()
#解説参照\na = list(map(int, input().split( )))\na.sort(reverse = True)\nans = 0\nans += a[0]-a[1]\na[1]+=ans\na[2] += ans\nans += (a[0]-a[2])//2\nans += ((a[0]-a[2])%2)*2###これ\nprint(ans)
from collections import deque\nfrom copy import deepcopy\n\nh,w = map(int,input().split())\ns = [list(input()) for i in range(h)]\nt = ((0,1),(1,0),(-1,0),(0,-1))\nm = 0\nfor sy in range(h):\n    for sx in range(w):\n        if s[sy][sx] == "#":\n            continue\n        ss = deepcopy(s)\n        ss[sy][sx] = "#"\n        q = deque([(0,sy,sx)])\n        max_cost = 0\n        my,mx = 0,0\n        while(q):\n            cost,y,x = q.popleft()\n            max_cost = max(max_cost,cost)\n            cost += 1\n            for i,j in t:\n                ny = y+i\n                nx = x+j\n                if 0 <= ny < h and 0 <= nx < w:\n                    if ss[ny][nx] == ".":\n                        q.append((cost,ny,nx))\n                        ss[ny][nx] = "#"\n        m = max(m,max_cost)\nprint(m)
import sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\n\nn,x = list(map(int, input().split()))\n\na,p = [1],[1]\nfor i in range(n):\n    a.append(a[i] * 2 + 3)\n    p.append(p[i] * 2 + 1)\n\ndef f(n, x):\n    if n == 0:\n        return 0 if x <= 0 else 1\n    elif x <= 1 + a[n - 1]:\n        return f(n - 1, x - 1)\n    else:\n        return p[n - 1] + 1 + f(n - 1, x - 2 - a[n-1])\n\nprint((f(n, x)))\n
for i in range(int(input())):\n    s = input()\n    if s.endswith('lala.') and not s.startswith('miao.'):\n        print("Freda's")\n    elif s.startswith('miao.') and not s.endswith('lala.'):\n        print("Rainbow's")\n    else:\n        print("OMG>.< I don't know!")\n
class RedBlackNode(object):\n\n    def __init__(self, key):\n        self._key = key\n        self._red = False\n        self._left = None\n        self._right = None\n        self._p = None\n\n\nclass RedBlackTree(object):\n\n    def __init__(self):\n        self._nil = RedBlackNode(None)\n        self._root = self._nil\n\n    def insert_key(self, key):\n        y = self.search(key, True)\n        z = RedBlackNode(key)\n        z._p = y\n        if y == self._nil:\n            self._root = z\n        elif z._key < y._key:\n            y._left = z\n        else:\n            y._right = z\n        z._left = self._nil\n        z._right = self._nil\n        z._red = True\n        self._insert_fixup(z)\n\n    def _insert_fixup(self, z):\n        while z._p._red:\n            if z._p == z._p._p._left:\n                y = z._p._p._right\n                if y._red:\n                    z._p._red = False\n                    y._red = False\n                    z._p._p._red = True\n                    z = z._p._p\n                else:\n                    if z == z._p._right:\n                        z = z._p\n                        self._left_rotate(z)\n                    z._p._red = False\n                    z._p._p._red = True\n                    self._right_rotate(z._p._p)\n            else:\n                y = z._p._p._left\n                if y._red:\n                    z._p._red = False\n                    y._red = False\n                    z._p._p._red = True\n                    z = z._p._p\n                else:\n                    if z == z._p._left:\n                        z = z._p\n                        self._right_rotate(z)\n                    z._p._red = False\n                    z._p._p._red = True\n                    self._left_rotate(z._p._p)\n        self._root._red = False\n\n    def _left_rotate(self, x):\n        y = x._right\n        x._right = y._left\n        if y._left != self._nil:\n            y._left._p = x\n        y._p = x._p\n        if x._p == self._nil:\n            self._root = y\n        elif x == x._p._left:\n            x._p._left = y\n        else:\n            x._p._right = y\n        y._left = x\n        x._p = y\n\n    def _right_rotate(self, y):\n        x = y._left\n        y._left = x._right\n        if x._right != self._nil:\n            x._right._p = y\n        x._p = y._p\n        if y._p == self._nil:\n            self._root = x\n        elif y == y._p._right:\n            y._p._right = x\n        else:\n            y._p._left = x\n        x._right = y\n        y._p = x\n\n    def search(self, key, s):\n        x = self._root\n        g = self._nil\n        while x != self._nil:\n            g = x\n            if key < x._key:\n                x = x._left\n            else:\n                x = x._right\n        return(g)\n    def search2(self, key):\n        a = None\n        b = None\n        x = self._root\n        while x != self._nil and key != x._key:\n            if key < x._key:\n                a = x\n                x = x._left\n            else:\n                b = x\n                x = x._right\n        if key == x._key:\n            return(None)\n        else:\n            return((a,b))\n\n\nn = int(input())\ns = [int(i) for i in input().split()]\nt = RedBlackTree()\nt.insert_key([s[0],0,0])\n    \ne = []\nfor i in s[1:]:\n    o,u = t.search2([i,0,0])\n    if u == None:\n        e.append(o._key[0])\n        if o._key[0] > i:\n            o._key[1] = 1\n        else:\n            o._key[2] = 1\n    elif o == None:\n        e.append(u._key[0])\n        if u._key[0] > i:\n            u._key[1] = 1\n        else:\n            u._key[2] = 1\n    else:\n        if o._key[0] > i and u._key[0] > i:\n            if o._key[1] == 0:\n                o._key[1] = 1\n                e.append(o._key[0])\n            else:\n                u._key[1] = 1\n                e.append(u._key[0])\n            \n        elif o._key[0] < i and u._key[0] > i:\n            if o._key[2] == 0:\n                o._key[2] = 1\n                e.append(o._key[0])\n            else:\n                u._key[1] = 1\n                e.append(u._key[0])\n        elif o._key[0] > i and u._key[0] < i:\n            if o._key[1] == 0:\n                o._key[1] = 1\n                e.append(o._key[0])\n            else:\n                u._key[2] = 1\n                e.append(u._key[0])\n        elif o._key[0] < i and u._key[0] < i:\n            if o._key[2] == 0:\n                o._key[2] = 1\n                e.append(o._key[0])\n            else:\n                u._key[2] = 1\n                e.append(u._key[0])\n    t.insert_key([i,0,0])\nprint(*e)\n    \n\n
n=int(input())\na=tuple(map(int,input().split()))\nc={}\np={}\ns=x=y=0\nm=-1e18\nfor i in range(0,len(a)):\n    d=c.get(a[i])\n    if d!=None and s-d+a[i]*2>m:\n        m=s-d+a[i]*2\n        x,y=p.get(a[i]),i\n    if(a[i]>0):s+=a[i]  \n    if p.get(a[i])==None:\n        p[a[i]]=i\n        c[a[i]]=s\na=[str(i+1) for i in range(0,len(a)) if i!=x and i!=y and (a[i]<0 or i<x or i>y)]\nprint(m,len(a))\nprint(" ".join(a))\n
n = int(input())\nl = []\nfor i in range(n + 1):\n    l.append(0)\nfor i in range(2, n + 1):\n    for j in range(i * 2, n + 1, i):\n        l[j] = i\nl.sort()\nfor i in range(2, n + 1):\n    if l[i] == 0:\n        print(1, end=" ")\n    else:\n        print(l[i], end=" ")\n
def main():\n    n = int(input())\n    s = set()\n    for _ in range(n):\n        w = input()\n        if w in s:\n            print('YES')\n        else:\n            print('NO')\n        s.add(w)\n\nmain()\n
s=input()\ndp=[[0,0,0] for i in range(len(s))]\nfor i in range(len(s)):\n    if s[i]=='a':\n        dp[i][0]=dp[i-1][0]+1\n        dp[i][1]=dp[i-1][1]\n        dp[i][2]=max(dp[i-1][1]+1,dp[i-1][2]+1)\n    else:\n        dp[i][0]=dp[i-1][0]\n        dp[i][1]=max(dp[i-1][0]+1,dp[i-1][1]+1)\n        dp[i][2]=dp[i-1][2]\ne=len(s)-1\nprint(max(dp[e][0],dp[e][1],dp[e][2]))\n
"""\nCodeforces Contest 291 Div 2 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.4.2\n"""\n\n################################################### SOLUTION\n\ndef gcd(a,b):\n    if a < 0: a = -a\n    if b < 0: b = -b\n    if a == 0: return b\n    if b == 0: return a\n    return gcd(b, a%b)\n\ndef main():\n    n, x0, y0 = read()\n    lines = set()\n    for i in range(n):\n        x, y = read()\n        x -= x0\n        y -= y0\n        if x < 0 or (x == 0 and y < 0): x,y = -x,-y\n        g = gcd(x,y)\n        x //= g\n        y //= g\n        lines.add((x,y))\n    return len(lines)\n\n\n\n#################################################### HELPERS\n\n\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
n = int(input())\na = [tuple(map(int, input().split())) for _ in range(n)]\ns = {a[q]: q+1 for q in range(n)}\na.sort()\nq, q1 = 0, 1\nd, d1, d2 = [[[a[0]]]], [], []\nwhile q1 < n:\n    while q1 < n and a[q][0] == a[q1][0]:\n        while q1 < n and a[q][1] == a[q1][1]:\n            d[-1][-1].append(a[q1])\n            q1 += 1\n        if q1 < n and a[q][0] == a[q1][0]:\n            d[-1].append([a[q1]])\n            q = q1\n            q1 += 1\n    if q1 < n:\n        d.append([[a[q1]]])\n        q = q1\n        q1 += 1\nfor q in range(len(d)):\n    for q1 in range(len(d[q])):\n        for q2 in range(1, len(d[q][q1]), 2):\n            print(s[d[q][q1][q2-1]], s[d[q][q1][q2]])\n        if len(d[q][q1]) % 2 == 1:\n            d[q][q1] = d[q][q1][-1]\n        else:\n            d[q][q1] = -1\nfor q in range(len(d)):\n    d1.append([])\n    for q1 in range(len(d[q])):\n        if d[q][q1] != -1:\n            d1[-1].append(d[q][q1])\nfor q in range(len(d1)):\n    for q1 in range(1, len(d1[q]), 2):\n        print(s[d1[q][q1-1]], s[d1[q][q1]])\n    if len(d1[q]) % 2 == 1:\n        d2.append(d1[q][-1])\nfor q in range(1, len(d2), 2):\n    print(s[d2[q-1]], s[d2[q]])\n
import sys\n\n\ndef count(n, k, field):\n    blank = 0\n    cnt = [[0] * (n - k + 1) for _ in range(n)]\n    for i, row in enumerate(field):\n        l = row.find('B')\n        r = row.rfind('B')\n        if l == r == -1:\n            blank += 1\n            continue\n        if r - l + 1 > k:\n            continue\n        kl = max(0, r - k + 1)\n        kr = min(l + 1, n - k + 1)\n        cnt[i][kl:kr] = [1] * (kr - kl)\n\n    acc = [[0] * (n - k + 1) for _ in range(n - k + 1)]\n    t_cnt = list(zip(*cnt))\n    for i, col in enumerate(t_cnt):\n        aci = acc[i]\n        tmp = sum(col[n - k:])\n        aci[n - k] = tmp\n        for j in range(n - k - 1, -1, -1):\n            tmp += col[j]\n            tmp -= col[j + k]\n            aci[j] = tmp\n\n    return blank, acc\n\n\nn, k = list(map(int, input().split()))\nfield = [line.strip() for line in sys.stdin]\nbh, hor = count(n, k, field)\nt_field = [''.join(col) for col in zip(*field)]\nbv, t_var = count(n, k, t_field)\nvar = list(zip(*t_var))\n\nprint(bh + bv + max(h + v for (rh, rv) in zip(hor, var) for (h, v) in zip(rh, rv)))\n
n = int(input())\nd = list(map(int, input().split()))\ns = {i:0 for i in set(d)}\nfor i in d:\n	s[i] += 1\nprint(max(s.values()))
from collections import defaultdict\n\n\ndef main():\n    n = int(input())\n    hh = list(map(int, input().split()))\n    ee = list(map(int, input().split()))\n    dd = defaultdict(set)\n    for i, h in enumerate(hh):\n        dd[h].add(i)\n    idx = sorted(list(range(n)), key=ee.__getitem__, reverse=True)\n    res = 0\n    for h, s in list(dd.items()):\n        x = sum(ee[i] for i in s)\n        le = len(s) - 1\n        if le:\n            for i in idx:\n                if hh[i] < h and i not in s:\n                    x += ee[i]\n                    le -= 1\n                    if not le:\n                        break\n        if res < x:\n            res = x\n    print(sum(ee) - res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n, m, k = map(int, input().split())\nchats_ = []\nfor i in range(n):\n    a = list(map(int, input().split()))\n    chats_.append(a)\nsent = [0 for i in range(n)]\nchats = [0 for i in range(m)]\nfor i in range(k):\n    a, b = map(int, input().split())\n    sent[a - 1] += 1\n    chats[b - 1] += 1\nfor i in range(n):\n    sum = 0\n    for j in range(m):\n        sum += chats_[i][j] * chats[j]\n    sum -= sent[i]\n    print(sum, end = ' ')
s = input()\nsuc = 0\np = 0\nkde = 0\nfor i in range(len(s)):\n	c = s[i]\n	if c == '^':\n		kde = i\nfor i in range(len(s)):\n	c = s[i]\n	if '1' <= c <= '9':\n		suc+=((kde-i)*int(c))\n		p+=1\nif suc < 0:\n	print("right")\nelif suc > 0:\n	print("left")\nelse:\n	print("balance")\n
import bisect\nn = int(input())\np = list(map(int, input().split()))\np.sort()\nq = int(input())\nfor i in range(q):\n    c = int(input())\n    print(bisect.bisect_right(p, c))\n    \n
from sys import stdin, stdout\ninput, print = stdin.readline, stdout.write\nn = int(input())\nr, g, b = [], [], []\nans = 0\nfor i in range(n):\n    x, t = [i for i in input().split()]\n    x = int(x)\n    if t == 'P':\n        g.append(x)\n    elif t == 'R':\n        r.append(x)\n    else:\n        b.append(x)\n        \nif len(g) == 0:\n    if len(r):\n        ans += r[-1] - r[0]\n    if len(b):\n        ans += b[-1] - b[0]\n    print(str(ans))\n    return\n    \nif not len(r):\n    r.append(g[0])\nif not len(b):\n    b.append(g[0])\nif r[0] < g[0]:\n    ans += g[0] - r[0]\nif b[0] < g[0]:\n    ans += g[0] - b[0]\nif r[-1] > g[-1]:\n    ans += r[-1] - g[-1]\nif b[-1] > g[-1]:\n    ans += b[-1] - g[-1]\nbi, ri = 0, 0\n\nfor i in range(len(g) - 1):\n    while bi < len(b) - 1 and b[bi] < g[i]:\n        bi += 1\n    while ri < len(r) - 1 and r[ri] < g[i]:\n        ri += 1\n    a1, a2 = (g[i + 1] - g[i]) * 3, (g[i + 1] - g[i]) * 2\n    mr, mb, cbi, cri = r[ri] - g[i], b[bi] - g[i], bi, ri\n\n    while cbi + 1 < len(b) and b[cbi + 1] < g[i + 1]:\n        mb = max(mb, b[cbi + 1] - b[cbi])\n        cbi += 1\n    mb = max(mb, g[i + 1] - b[cbi])\n    while cri + 1 < len(r) and r[cri + 1] < g[i + 1]:\n        mr = max(mr, r[cri + 1] - r[cri])\n        cri += 1\n    mr = max(mr, g[i + 1] - r[cri])\n       \n    if b[bi] < g[i] or b[bi] > g[i + 1]:\n        a2 = 100000000000000\n        a1 -= g[i + 1] - g[i]\n        mb = 0\n    if r[ri] < g[i] or r[ri] > g[i + 1]:\n        a2 = 100000000000000\n        a1 -= g[i + 1] - g[i]\n        mr = 0\n        \n    ans += min(a1 - mr - mb, a2)\n    \nprint(str(ans))\n
n = int(input())\nc1 = n\nc2 = (n * (n-1)) // 2\nc3 = (n * (n-1) * (n-2)) // (2*3)\nc4 = (n * (n-1) * (n-2) * (n-3)) // (2*3*4)\nc5 = (n * (n-1) * (n-2) * (n-3) * (n-4)) // (2*3*4*5)\nw1 = 0\nw1 += c1\nw1 += c2 * 2\nw1 += c3 \nw2 = 0\nw2 += c1\nw2 += c2 * 4\nw2 += c3 * 6\nw2 += c4 * 4\nw2 += c5\nprint(w1*w2)
read = lambda: map(int, input().split())\nn = int(input())\ns = input()\na = list(read())\ndp = [0] * (n + 2)\nmn = [10 ** 4] * (n + 2)\ndp[0] = dp[n + 1] = 1\nmn[n + 1] = 0\nmn[0] = 1\nMax = 1\nmod = 10 ** 9 + 7\nfor i in range(1, n):\n    res = 0\n    cur = 10 ** 4\n    for j in range(i, -1, -1):\n        c = ord(s[j]) - ord('a')\n        cur = min(cur, a[c])\n        if cur < (i - j + 1):\n            break\n        dp[i] = (dp[i] + dp[j - 1]) % mod\n        mn[i] = min(mn[i], mn[j - 1] + 1)\n        Max = max(Max, i - j + 1)\nprint(dp[n - 1])\nprint(Max)\nprint(mn[n - 1])
#!/usr/local/bin/python3\n\n\nimport sys\n\nDEBUG = '-d' in sys.argv\n\n\ndef debug(*args, **kwargs):\n    if DEBUG:\n        print(*args, file=sys.stderr, **kwargs)\n\n    return None\n\n\n\ndef main():\n    n = int(input())\n\n    cnt = [0] * (n + 1)\n    edge = []\n\n    for i in range(0, n + 1):\n        edge.append(set())\n\n    for i in range(0, 2 * n):\n        s, t = map(int, input().split())\n        edge[s].add(t)\n        edge[t].add(s)\n        cnt[s] += 1\n        cnt[t] += 1\n\n    c4 = 0\n    for i in range(1, n + 1):\n        if cnt[i] == 4:\n            c4 += 1\n\n    if c4 != n:\n        print(-1)\n    else:\n        for v2 in edge[1]:\n            for v3 in edge[1]:\n                if v2 in edge[v3]:\n                    mark = [True] * (n + 1)\n                    mark[1] = False\n                    mark[v2] = False\n                    res = [1, v2]\n                    i = v3\n                    try:\n                        while True:\n                            res.append(i)\n                            mark[i] = False\n                            if len(res) == n:\n                                print(' '.join([str(x) for x in res]))\n                                return\n                            for e in edge[i]:\n                                if e != i and mark[e] and res[-2] in edge[e]:\n                                    i = e\n                                    break\n                            if not mark[i]:\n                                raise StopIteration\n                    except StopIteration:\n                        pass\n\n        print(-1)\n\n\ndef __starting_point():\n    main()\n__starting_point()
#!/usr/bin/env python3\n\nn, m, k = [int(x) for x in input().split()]\n\nrow = [(0, -1)] * n\ncol = [(0, -1)] * m\nfor i in range(0, k):\n    t, num, color = [int(x) for x in input().split()]\n    num -= 1\n    if t == 1:\n        row[num] = (color, i)\n    else:\n        assert t == 2\n        col[num] = (color, i)\n\nfor r in row:\n    for c in col:\n        if c[1] > r[1]:\n            print(c[0], end=' ')\n        else:\n            print(r[0], end=' ')\n    print()\n\n
n = int(input())\nl = list(map(int,input().split()))\nl.sort()\na = l[:n//2]\nb = l[n//2:]\nprint(sum(a)**2+sum(b)**2)
from bisect import bisect_left as bl\nimport sys\n\nN, M, Q = map(int, sys.stdin.readline().split())\ncount = [0] * (M + 1)\nA = []\nfor a in sys.stdin.readline().split():\n    a = int(a)\n    A.append(count[a] * M + a)\n    count[a] += 1\nA.sort()\nA = [a - i for i, a in enumerate(A, 1)]\nfor _ in range(Q):\n    q = int(sys.stdin.readline()) - N\n    if q > A[-1]:\n        q += N\n    else:\n        q += bl(A, q)\n    sys.stdout.write(f'{(q - 1) % M + 1}\n')
\ndef modify(string, index):\n    \n    if string[index] == '0':\n        key = 0\n    else:\n        key = 10 - int(string[index])\n    bad = ''\n    for i in string:\n        bad += str((int(i) + key) % 10)\n    return bad[index:] + bad[:index]\n\n\nx = int(input())\ny = input()\nminx = 'zzzzzzzzz'\nfor i in range(x):\n    minx = min(minx, modify(y, i))\nprint(minx)\n
import math\nleftpeople = set()\nrightpeople = set()\n\nn, vl = list(map(int, input().split()))\n\ndef leftinterval(x0, v0, t):\n    if x0 / v0 <= t:\n        return (0, 10**6)\n    if x0 / (vl + v0) > t:\n        return (-1, -2)\n    leftbound = x0\n    rightbound = (vl * vl - v0 * v0) * t + x0 * v0\n    rightbound /= vl\n    rightbound = int(rightbound)\n    if rightbound > 10**6:\n        rightbound = 10**6\n    return (leftbound, rightbound)\ndef rightinterval(x0, v0, t):\n    if (10**6 - x0) / v0 <= t:\n        return (0, 10**6)\n    if (10**6 - x0) / (v0 + vl) > t:\n        return (-1, -2)\n    rightbound = x0\n    leftbound = v0 * x0 + (10**6) * (vl - v0) - t * (vl * vl - v0 * v0)\n    leftbound /= vl\n    leftbound = math.ceil(leftbound)\n    if(leftbound < 0):\n        leftbound = 0\n    return (leftbound, rightbound)\n\ndef check(t):\n    events = []\n    for item in leftpeople:\n        temp = leftinterval(item[0], item[1], t)\n        if(temp[0] > temp[1]):\n            continue\n        events.append((temp[0], 0, 0))\n        events.append((temp[1], 1, 0))\n        if(temp[1] - temp[0] == 10**6):\n            break\n    for item in rightpeople:\n        temp = rightinterval(item[0], item[1], t)\n        if(temp[0] > temp[1]):\n            continue\n        events.append((temp[0], 0, 1))\n        events.append((temp[1], 1, 1))\n        if(temp[1] - temp[0] == 10**6):\n            break\n    events.sort()\n    opened = [0, 0]\n    for item in events:\n        color = item[2]\n        action = item[1]\n        if action == 0:\n            if opened[(color + 1) % 2] > 0:\n                return True\n            opened[color] += 1\n        else:\n            opened[color] -= 1\n    return False\n\nfor i in range(n):\n    a, b, c = list(map(int, input().split()))\n    if c == 1:\n        leftpeople.add((a, b))\n    if c == 2:\n        rightpeople.add((a, b))\n\nl = 0\nr = 1e9\nfor i in range(50):\n    m = (l + r) / 2\n    if(check(m)):\n        r = m\n    else:\n        l = m\n\nprint(m)\n
n = int(input())\nm = list(map(int, input().split()))\na = []\nb = []\nc = []\nfor i in range(n):\n    if m[i] == 1:\n        a.append(i + 1)\n    if m[i] == 2:\n        b.append(i + 1)\n    if m[i] == 3:\n        c.append(i + 1)\nans = min(len(a), len(b), len(c))\nprint(ans)\nfor i in range(ans):\n    print(a[i], b[i], c[i])
def func(arr):\n    arr.sort()\n    ans = 0\n    for i in range(len(arr) - 1, -1, -2):\n        ans += arr[i]\n    return ans\n\ndef main():\n    n, h = map(int, input().split())\n    arr = list(map(int, input().split()))\n    for i in range(1, n + 1):\n        if func(arr[:i]) > h:\n            i -= 1\n            break\n    print(i)\n    return 0\nmain()
n = int(input())\ncnt = 0\ngems = list(map(int, input().split()))\npearls = set()\nfor i in range(n):\n    if gems[i] not in pearls:\n        pearls.add(gems[i])\n    else:\n        cnt += 1\n        pearls = set()\n    \nif cnt:\n    print(cnt)\n    first = 0\n    second = 0\n    pearls = set()\n    for i in range(n):\n        if gems[i] not in pearls:\n            pearls.add(gems[i])\n        else:\n            if second:\n                print(first + 1, second + 1)\n                first = second + 1\n            second = i\n            pearls = set()\n    print(first + 1, n)\nelse:\n    print('-1')
'''input\n3 3\n>>>\n<<<\n>>>\n'''\n#print(input().split())\nn, m = list(map(int, input().split()))\n#return\ng = []\nfor i in range(n):\n	g += [input()]\n# print(g)\n\n\nmemo = {}\n\ndef dfs(u):\n	if u not in memo:\n		memo[u] = res = 1\n		if u < n:\n			for v in range(m):\n				if g[u][v] == '>':\n					res = max(res, dfs(n + v) + 1)\n			for v in range(m):\n				if g[u][v] == '=':\n					res = max(res, dfs(n + v))\n			for v in range(m):\n				if g[u][v] == '=':\n					memo[n + v] = max(memo[n + v], res)\n		else:\n			for v in range(n):\n				if g[v][u - n] == '<':\n					res = max(res, dfs(v) + 1)\n			for v in range(n):\n				if g[v][u - n] == '=':\n					res = max(res, dfs(v))\n			for v in range(n):\n				if g[v][u - n] == '=':\n					memo[v] = max(memo[v], res)\n		memo[u] = res\n	return memo[u]\nans = [0] * (n + m)\nfor i in range(n + m):\n	ans[i] = dfs(i)\nfor i in range(n):\n	for j in range(m):\n		if g[i][j] == '=' and ans[i] != ans[n + j]:\n			print("No")\n			return\n		if g[i][j] == '<' and ans[i] >= ans[n + j]:\n			print("No")\n			return\n		if g[i][j] == '>' and ans[i] <= ans[n + j]:\n			print("No")\n			return\nprint("Yes")\nprint(*ans[:n])\nprint(*ans[n:])\n
import heapq as hq\nfrom math import ceil\nn, k, x = [int(i) for i in input().strip().split(' ')]\narr = [int(i) for i in input().strip().split(' ')]\nis_neg = False\nfor i in arr:\n    if i < 0:\n        is_neg = True if is_neg == False else False\n\nnarr = [[abs(i), pos, i < 0] for pos, i in enumerate(arr)]\nhq.heapify(narr)\nif is_neg:\n    while k > 0:\n        hq.heapreplace(narr, [narr[0][0]+x, narr[0][1], narr[0][2]])\n        k -= 1\nelse:\n    minode = hq.heappop(narr)\n    mi = minode[0]\n    kswitch = ceil(mi/x) #make the off number of negatives\n    if kswitch > k:\n        kswitch = k\n    else:\n        minode[2] = False if minode[2] == True else True\n    k -= kswitch\n\n    hq.heappush(narr, [abs(mi-kswitch*x), minode[1], minode[2]])\n    while k > 0:\n        hq.heapreplace(narr, [narr[0][0]+x, narr[0][1], narr[0][2]])\n        k -= 1\n\nnarr = sorted(narr, key=lambda x:x[1])\narr = [str(i[0]*(-1 if i[2] else 1)) for i in narr]\nprint(" ".join(arr))
h1, a1, c1 = list(map(int, input().split()))\nh2, a2 = list(map(int, input().split()))\nd = []\nwhile h2 > 0:\n	if h2 <= a1:\n		h2 -= a1\n		d.append('STRIKE')\n	else:\n		if h1 <= a2:\n			d.append('HEAL')\n			h1 += c1\n		else:\n			d.append('STRIKE')\n			h2 -= a1\n	h1 -= a2\nprint(len(d))\nfor i in d:\n	print(i)\n
import sys\nn,r,avg=list(map(int,input().split()))\nL=[]\ntot=0\nfor i in range(n):\n    L.append(list(map(int,input().split())))\n    L[i][0],L[i][1]=L[i][1],L[i][0]\n    tot+=L[i][1]\n    L[i][1]=r-L[i][1]\nreq=avg*n\nL.sort()\nind=0\nans=0\nwhile(ind<n and req>tot):\n    diff=req-tot\n    if(L[ind][1]>=diff):\n        ans+=diff*L[ind][0]\n        tot+=diff\n        L[ind][1]-=diff\n    else:\n        ans+=L[ind][1]*L[ind][0]\n        tot+=L[ind][1]\n        L[ind][1]=0\n    ind+=1\nprint(ans)\n
l = int(input())\na = input()\nla = len(a)\nif la % l != 0:\n    per = la//l+1\n    ans = '1'+'0'*(l-1)\n    ans *= per\n    print(ans)\nelse:\n    ans = a[:l]\n    per = la//l\n    if ans*per > a:print(ans*per)\n    else:\n        temp = str(int(ans)+1)\n        if len(temp) == l:print(temp*per)\n        else:\n            temp = '1'+'0'*(l-1)\n            temp *= (per+1)\n            print(temp)\n
#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\ndef f(first, s):\n    second = 'r' if first == 'b' else 'b'\n    alt = [first, second]\n\n    error = [0, 0]\n    for i,ch in enumerate(s):\n        shouldbe = alt[i % 2]\n        if ch != shouldbe:\n            error[i % 2] += 1\n\n    return max(error)\n\ndef main():\n    n = int(input())\n    s = input()\n    print(min(f('r', s), f('b', s)))\n\nmain()    \n
n, m, k = list(map(int, input().split()))\na = [[0] * m for x in range(n)]\ns = []\ncount = 0\nfor i in range(n):\n    s.append(input())\nfor i in range(n):\n    y = 0\n    for j in range(m):\n        if s[i][j] == ".":\n            if(a[i][j] + 1 >= k and k > 1):\n                count += 1\n            y +=1\n            if y >= k:\n                count += 1\n            if i + 1 < n:\n                a[i + 1][j] = a[i][j] + 1\n        else:\n            y = 0\n            \nprint(count)\n
import sys\ninput = sys.stdin.readline\n\nn,m,k,q=list(map(int,input().split()))\nTR=[list(map(int,input().split())) for i in range(k)]\nSAFE=list(map(int,input().split()))\nSAFE.sort()\n\nTRLIST=[[] for i in range(n+1)]\n\nfor x,y in TR:\n    TRLIST[x].append(y)\n\nwhile TRLIST[-1]==[]:\n    TRLIST.pop()\n    n-=1\n\n\nSTART={1:0} #place,step\n\nimport bisect\n\nfor step in range(1,n):\n    if TRLIST[step]==[] and step!=1:\n        continue\n    elif TRLIST[step]==[] and step==1:\n        MIN=MAX=1\n    else:\n        MIN=min(TRLIST[step])\n        MAX=max(TRLIST[step])\n\n    MINind=max(0,bisect.bisect_left(SAFE,MIN)-1)\n    MIN_L=SAFE[MINind]\n    if MINind==q-1:\n        MIN_R=MIN_L\n    else:\n        MIN_R=SAFE[MINind+1]\n\n    MAXind=max(0,bisect.bisect_left(SAFE,MAX)-1)\n    MAX_L=SAFE[MAXind]\n    if MAXind==q-1:\n        MAX_R=MAX_L\n    else:\n        MAX_R=SAFE[MAXind+1]\n    \n\n    NEXT=dict()\n\n    for start in START:\n        st=START[start]\n        \n        NEXT[MIN_L]=min(st+abs(MAX-start)+abs(MAX-MIN)+abs(MIN_L-MIN),NEXT.get(MIN_L,1<<50))\n        NEXT[MIN_R]=min(st+abs(MAX-start)+abs(MAX-MIN)+abs(MIN_R-MIN),NEXT.get(MIN_R,1<<50))\n        NEXT[MAX_L]=min(st+abs(MIN-start)+abs(MAX-MIN)+abs(MAX_L-MAX),NEXT.get(MAX_L,1<<50))\n        NEXT[MAX_R]=min(st+abs(MIN-start)+abs(MAX-MIN)+abs(MAX_R-MAX),NEXT.get(MAX_R,1<<50))\n\n    START=NEXT\n    #print(START)\n\nLAST=1<<50\n\nif TRLIST[n]==[]:\n    print(min(START.values())+n-1)\n    return\n\nMIN=min(TRLIST[n])\nMAX=max(TRLIST[n])\n#print(START)\nfor start in START:\n    st=START[start]\n    \n    LAST=min(LAST,st+abs(MAX-start)+abs(MAX-MIN),st+abs(MIN-start)+abs(MAX-MIN))\n\n\nprint(LAST+n-1)\n\n    \n    \n
n, m = map(int, input().split())\nc = [0] + list(map(int, input().split()))\nt = {i: set() for i in set(c[1:])}\nfor i in range(m):\n    a, b = map(int, input().split())\n    if c[a] != c[b]:\n        t[c[a]].add(c[b])\n        t[c[b]].add(c[a])\nj, k = c[1], 0\nfor i, s in t.items():\n    l = len(s)\n    if l >= k: \n        if l > k: j, k = i, l\n        elif j > i: j = i\nprint(j)
n = int(input())\na = input()\ns = input()\nd1, d2 = [], []\nfor q in range(n):\n    if a[q] == 'a' and s[q] == 'b':\n        d1.append(q+1)\n    elif a[q] == 'b' and s[q] == 'a':\n        d2.append(q+1)\nif (len(d1)+len(d2)) % 2 == 1:\n    print(-1)\nelse:\n    print((len(d1)+len(d2))//2+len(d1) % 2)\n    for q in range(1, len(d1), 2):\n        print(d1[q-1], d1[q])\n    for q in range(1, len(d2), 2):\n        print(d2[q-1], d2[q])\n    if len(d1) % 2 == 1:\n        print(d1[-1], d1[-1])\n        print(d1[-1], d2[-1])\n
l = int(input())\nn = input()\nbest = int(n)\np = (l - 1) // 2\nfor i in range(p, -1, -1):\n	if (n[i + 1] == '0'):\n		continue\n\n	best = min(best, int(n[0:(i + 1)]) + int(n[i + 1:]))\n	break\n\np = l // 2\nfor i in range(p, l):\n	if (n[i] == '0'):\n		continue\n\n	best = min(best, int(n[0:i]) + int(n[i:]))\n	break\n\nprint(best)
N = int(input())\ngrid = []\nx1 = 50\ny1 = 50\nx2 = -1\ny2 = -1\nfor y in range(N):\n    grid.append(list(map(int, input())))\n    for x, num in enumerate(grid[-1]):\n        if num == 4:\n            x1 = min(x1, x)\n            y1 = min(y1, y)\n            x2 = max(x2, x)\n            y2 = max(y2, y)\n\nif x1 == 51:\n    print('No')\nelse:\n    for y in range(N):\n        for x in range(N):\n            ex = 0\n            if x1 <= x <= x2 and y1 <= y <= y2:\n                ex = 4\n            elif (x == x1-1 or x == x2+1) and y1 <= y <= y2:\n                ex = 2\n            elif (y == y1-1 or y == y2+1) and x1 <= x <= x2:\n                ex = 2\n            elif (x == x1-1 or x == x2+1) and (y == y1-1 or y == y2+1):\n                ex = 1\n            if ex != grid[y][x]:\n                print('No')\n                break\n        else:\n            continue\n        break\n    else:\n        print('Yes')\n
\ndef modfac(n, MOD):\n \n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n    return factorials, invs\n\n\ndef modnCr(n,r,mod,fac,inv):\n    return fac[n] * inv[n-r] * inv[r] % mod\n\n\nn,k = map(int,input().split())\nmod = 998244353\nfac,inv = modfac(n+10,mod)\nans = 0\n\nfor i in range(1,n+1):\n\n    rem = n // i - 1\n    if rem >= k-1:\n        ans += modnCr(rem,k-1,mod,fac,inv)\n        ans %= mod\n\nprint (ans)
n, a, b, c, t = list(map(int, input().split()))\n\nlst = []\nfor x in input().split():\n    lst.append(int(x))\n\nif b > c:\n    print(n * a)\nelse:\n    acc = 0\n    for x in lst:\n        acc += (t - x)\n    acc *= (c - b)\n    acc += n * a\n    print(acc)\n    \n
f = lambda: map(int, input().split())\ng = lambda: (a.i, b.i) if a.i < b.i else (b.i, a.i)\n\nclass T:\n    def __init__(t, i):\n        t.i = i\n        t.s = t.v = t.u = 0\n        t.p = []\n\nn, m = f()\nt = [T(i) for i in range(n + 1)]\nd, l = [], []\nfor k in range(m):\n    i, j, q = f()\n    a, b = t[i], t[j]\n    a.p.append(b)\n    b.p.append(a)\n    if q: d += [g()]\nd = set(d)\nx, y = [], []\na = t[1]\na.u = 1\nwhile a.i < n:\n    for b in a.p:\n        v = a.v + (g() in d)\n        if not b.u or b.u > a.u and v > b.v: b.v, b.s = v, a.i\n        if not b.u:\n            b.u = a.u + 1\n            y.append(b.i)\n    if not x:\n        x, y = y, x\n        x.reverse()\n    a = t[x.pop()]\nwhile a.i > 1:\n    b = t[a.s]\n    a.p.remove(b)\n    b.p.remove(a)\n    if g() in d: d.remove(g())\n    else: l += [(a.i, b.i)]\n    a = b\nprint(len(l) + len(d))\nfor a, b in l: print(a, b, 1)\nfor a, b in d: print(a, b, 0)
k,n,w = map(int,input().split())\n\nx = (w)*(w+1)//2 * k\n\ny = x - n\n\nif(y >= 0):\n	print(y)\nelse:\n	print(0)
S = input()\nT = input()\nbase = 998244353\ndp = [[0 for _ in range(len(S) + 1)] for _ in range(len(S) + 1)]\nfor j in range(1, len(S) + 1):\n    if (j > len(T)) or (S[0] == T[j - 1]):\n        dp[1][j] = 2\nfor i in range(2, len(S) + 1):\n    for j in range(1, len(S) - i + 1 + 1):\n        if (j > len(T)) or (S[i - 1] == T[j - 1]):\n            dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % base\n        if (j + i - 1 > len(T)) or (S[i - 1] == T[j + i - 1 - 1]):\n            dp[i][j] = (dp[i][j] + dp[i - 1][j]) % base\nans = 0\nfor i in range(len(T), len(S) + 1):\n    ans = (ans + dp[i][1]) % base\nprint(ans)
n=int(input())\n\nL=list(map(int,input().split()))\n\nif(n==1 or n==2):\n    print(n)\nelse:\n    length=2\n    i=2\n    maxx=2\n    while(i<n):\n        if(L[i]==L[i-1]+L[i-2]):\n            length+=1\n        else:\n            if(length>maxx):\n                maxx=length\n            length=2\n        i+=1\n    if(length>maxx):\n        maxx=length\n    print(maxx)\n
from collections import namedtuple\nfrom operator    import itemgetter\n\nFriend = namedtuple("Friend", "m s")\n\nn, d = list(map(int, input().split()))\nf = [ ]\nfor i in range(n):\n    f.append(Friend(*list(map(int, input().split()))))\nf.sort(key=itemgetter(0))\nleft = 0\ncur = f[0].s\nresult = cur\nfor i, fr in enumerate(f[1:], 1):\n    while left < i and f[left].m + d <= fr.m:\n        cur -= f[left].s\n        left += 1\n    cur += fr.s\n    result = max(result, cur)\nprint(result)\n
#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# AUTHOR: haya14busa\nimport sys\nimport io\n\nfrom collections import defaultdict\nfrom itertools import combinations\n\n\ndef solve(n, m, pairs):\n    # return: minimum possible sum of their recognitions\n    assert 3 <= n <= 4000  # number of warioor\n    assert 0 <= m <= 4000  # number of pairs of warriors knowing each other\n    # for (a, b) in pairs:\n    #     assert 1 <= a < b <= n \n\n    recognitions = defaultdict(set)\n\n    for (a, b) in pairs:\n       recognitions[a].add(b)\n       recognitions[b].add(a)\n\n    minr = float('inf')\n\n    for candidate, recognition in [(c, rs) for c, rs in list(recognitions.items()) if len(rs) > 1]:\n        for c2, c3 in [(a, b) for a, b in combinations(recognition, 2)\n                                if a in recognitions[b]]:\n            sum_r = sum([len(recognitions[x]) for x in [candidate, c2, c3]])\n            minr = min([sum_r, minr])\n    if minr == float('inf'):\n        return -1\n    else:\n        return minr - 2 * 3\n\n\n\ndef getinput():\n    def getint():\n        return int(input())\n\n    def getints_line():\n        return list(map(int, input().split(' ')))\n\n    def getints(n):\n        return [getint() for _ in range(n)]\n\n    def getints_lines(n):\n        return [getints_line() for _ in range(n)]\n    n, m = getints_line()\n    return [n, m, getints_lines(m)]\n\n\ndef iosolve():\n    return str(solve(*getinput()))\n    # return 'YES' if solve(*getinput()) else 'NO' # for boolean output\n    # return '\n'.join(map(str, solve(*getinput()))) # for multiple line output\n\n\ndef main():\n    if sys.stdin.isatty():\n        test()\n    stdin_lines = getstdin_lines()\n    sys.stdin = io.StringIO('\n'.join(stdin_lines))\n    if stdin_lines:\n        print(iosolve())\n    else:\n        test()\n\n\ndef test():\n    IO_TEST_CASES = [\n\n        (\n            # INPUT\n            '''\\n5 6\n1 2\n1 3\n2 3\n2 4\n3 4\n4 5\n            ''',\n            # EXPECT\n            '''\\n2\n            '''\n        ),\n\n        (\n            # INPUT\n            '''\\n7 4\n2 1\n3 6\n5 1\n1 7\n            ''',\n            # EXPECT\n            '''\\n-1\n            '''\n        ),\n\n\n    ]\n\n    # List[(List[arg for solve()], expect)]\n    TEST_CASES = [\n        # ([], None),\n    ]\n\n    # You do need to see below\n    import unittest  # to save memory, import only if test required\n    import sys\n    import io\n\n    class Assert(unittest.TestCase):\n        def equal(self, a, b):\n            self.assertEqual(a, b)\n\n        def float_equal(self, actual, expect, tolerance):\n            self.assertTrue(expect - tolerance < actual < expect + tolerance)\n\n    art = Assert()\n\n    for inputs, expect in TEST_CASES:\n        art.equal(solve(*inputs), expect)\n\n    for stdin, expect in IO_TEST_CASES:\n        sys.stdin = io.StringIO(stdin.strip())\n        art.equal(iosolve(), expect.strip())\n        # art.float_equal(float(iosolve()), float(expect.strip()), 10 ** -6)\n\n\ndef getstdin_lines():\n    stdin = []\n    while 1:\n        try:\n            stdin.append(input())\n        except EOFError:\n            break\n    return stdin\n\ndef __starting_point():\n    main()\n\n__starting_point()
import math\nimport sys\n\narrival, departure, time_per_client = [int(x) for x in input().split()]\nnum_clients = int(input())\nif num_clients > 0:\n	clients_arrival = [int(x) for x in input().split()]\nelse:\n	print(arrival)\n	return\n\nbest_time = None\n\ncurrent_time = arrival\nclients_at_queue = 0\n\nclient_to_arrive = 0\nclient_wait_time = [math.inf for client in clients_arrival]\nclient_to_leave = 0\n\nwhile current_time <= departure - time_per_client:\n	while client_to_arrive < num_clients and clients_arrival[client_to_arrive] <= current_time:\n		clients_at_queue += 1\n		client_to_arrive += 1\n\n	if clients_at_queue == 0:\n		best_time = current_time\n		break\n	else:\n		clients_at_queue -= 1\n		client_wait_time[client_to_leave] = current_time - clients_arrival[client_to_leave]\n		client_to_leave += 1\n\n		current_time += time_per_client\n\n\n\nwhile (best_time is None or best_time < 0) and len(client_wait_time) > 0:\n	happiest_client = client_wait_time.index(min(client_wait_time))\n	best_time = clients_arrival[happiest_client] - 1\n\n	if best_time < 0:\n		client_wait_time = client_wait_time[happiest_client+1:]\n		clients_arrival = clients_arrival[happiest_client+1:]\n\n\nprint(best_time)
from collections import deque\n\n\ndef main():\n    s = deque(input())\n\n    res = []\n    for i in range(len(s) - 1, -1, -1):\n        if i % 2 == 1:\n            res.append(s.pop())\n        else:\n            res.append(s.popleft())\n\n    print(''.join(res[::-1]))\n\n\nmain()
n = int(input())\ns = input()\na = s.count('A')\nd = s.count('D')\nif a > d:\n	print("Anton")\nelif d > a:\n	print("Danik")\nelse:\n	print("Friendship")
n=int(input())\nprint(n*(n+1)//2-n)
from collections import defaultdict\nimport sys\n\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef main():\n    N = int(input())\n    V = 100005\n    to = defaultdict(list)\n    for _ in range(N):\n        X, Y = map(int, input().split())\n        Y += V\n        to[X].append(Y)\n        to[Y].append(X)\n    visited = [0] * (2 * V)\n    cnt = [0] * 2  # cnt = [cnt of X, cnt of Y]\n\n    def dfs(v):\n        if visited[v] == 1:\n            return\n        visited[v] = 1\n        cnt[v // V] += 1\n        for nv in to[v]:\n            dfs(nv)\n\n    ans = 0\n    for v in range(2 * V):\n        if visited[v] == 1:\n            continue\n        cnt = [0] * 2\n        dfs(v)\n        ans += cnt[0] * cnt[1]\n    ans -= N\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()
#!/usr/bin/env python3\nimport sys\n\n\ndef solve(N: int, M: int, X: "List[int]", Y: "List[int]", Z: "List[int]"):\n    X = [x-1 for x in X]\n    Y = [x-1 for x in Y]\n    uf = UnionFind(N)\n    for x, y in zip(X, Y):\n        uf.union(x, y)\n    return len(uf.roots())\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    X = [int()] * (M)  # type: "List[int]"\n    Y = [int()] * (M)  # type: "List[int]"\n    Z = [int()] * (M)  # type: "List[int]"\n    for i in range(M):\n        X[i] = int(next(tokens))\n        Y[i] = int(next(tokens))\n        Z[i] = int(next(tokens))\n    print((solve(N, M, X, Y, Z)))\n\n# https://note.nkmk.me/python-union-find/\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if x == y:\n            return\n        \n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    \n    def size(self, x):\n        return -self.parents[self.find(x)]\n        \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n \n    def group_count(self):\n        return len(self.roots())\n    \n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    \n    def __str__(self):\n        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()
import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nMOD = 10 ** 9 + 7\nN, K = lr()\nM = int(N**.5)\n\n# M+1以上で、Nを割るとxになるもの\nupper_cnt = np.zeros(M+1, dtype=np.int64) # 1-indexed\nA = np.arange(M+1, dtype=np.int64)\nupper_cnt[1:] = N // A[1:] - np.maximum(M, N // (A[1:]+1)) # Mの時はlowerで数えるので0に\n\n# 桁DP\nlower = np.zeros(M+1, dtype=np.int64) # 1-indexed\nupper = np.zeros(M+1, dtype=np.int64)\n#最初は制限なしなので1を置いておく\nlower[1] = 1\nfor i in range(K):\n    prev_lower = lower.copy()\n    prev_upper = upper.copy()\n    lower_cum = prev_lower.cumsum() % MOD\n    upper_cum = prev_upper.cumsum() % MOD\n    # lower と upper から lower へ\n    lower = np.zeros(M+1, dtype=np.int64)\n    lower[1:] += (lower_cum[-1] + upper_cum[-1])\n    lower[1:] -= upper_cum[:-1] # 大きすぎる値を引く\n    # upper から upper はなし\n    # lower から upper へ\n    upper = lower_cum * upper_cnt\n    lower %= MOD; upper %= MOD\n\nanswer = (lower[1:].sum() + upper[1:].sum()) % MOD\nprint(answer)\n
N = int(input())\nkeep = [[0 for i in range(10)] for j in range(10)]\nans = 0\n\nfor i in range(1, N + 1):\n    first = int(str(i)[0])\n    end = int(str(i)[-1])\n    keep[first - 1][end - 1] += 1\n\nfor i in range(9):\n    for j in range(9):\n        ans += (keep[i][j] * keep[j][i])\nprint(ans)\n
import math\na, b, x = map(int,input().split())\ns = a\nt = 2*(b-x/(a*a))\nu = x*2/(b*a)\nif t<=b:\n    print(math.degrees(math.atan(t/s)))\nelse:\n    print(math.degrees(math.atan(b/u)))
def main():\n	N = int(input())\n	L = [int(l) for l in input().split(" ")]\n	L.sort()\n	m = len(L)\n	cnt = 0\n	for i in range(m):\n		k = m - 1\n		for j in range(i + 1, m):\n			while m + i - j < k:\n				if L[m + i - j] + L[i] <= L[k]:\n					k -= 1\n				else:\n					cnt += k - m - i + j\n					break\n	print(cnt)\n\nmain()
X,Y = list(map(int,input().split()))\n#X, 2X, 4X,...,2^(t-1)*X<=Yとなる最大のt\n#10^18 はだいたい2^60だから全部試せそう\nfor t in range(1,100):\n    if 2**(t-1)*X<=Y:\n        out = t\n    else:\n        break\nprint(out)\n
#!/usr/bin/env python\n\nn = int(input())\n\ndef g1(n, p): \n    ''' \n    How many times can n! be divided by p?\n    '''\n    if n == 0:\n        return 0\n    return n//p + g1(n//p, p)\n\ndef g2(n, p): \n    ''' \n    How many times can n!! be divided by p?\n    '''\n    if n%2 == 1:\n        return g1(n, p) - g2(n-1, p)\n\n    res = g1(n//2, p)\n    if p == 2:  \n        res += n//2\n    return res \n\nans = min(g2(n, 5), g2(n, 2)) \nprint(ans)\n
n = int(input())\nc = input()\n\nw = 0\nr = c.count('R')\ni = 0\nans = max(w, r)\nwhile i <= n - 1:\n    if c[i] == 'W':\n        w += 1\n    else:\n        r -= 1\n    ans = min(ans, max(w, r))\n    i += 1\nprint(ans)
import sys\n\ndef solve():\n    n = int(input())\n    s = 1000000\n    xset = set(map(int, input().split()))\n    res = set()\n    wantother = 0\n    for i in range(1, s + 1):\n        opposite = s - i + 1\n        if i in xset:\n            if opposite not in xset:\n                res.add(opposite)\n            else:\n                wantother+=1\n    wantother /= 2\n    for i in range(1, s + 1):\n        if wantother == 0: break\n        opposite = s - i + 1\n        if i not in res and opposite not in res and i not in xset and opposite not in xset:\n            res.add(i)\n            res.add(opposite)\n            wantother-=1\n\n    print(len(res))\n    return " ".join(map(str, res))\n\n\n\n    \nif sys.hexversion == 50594544 : sys.stdin = open("test.txt")\nprint(solve())
n, m = [int(x) for x in input().split()]\n\nc = 0\nfor _ in range(n):\n    a = [int(x) for x in input().split()]\n    for i in range(m):\n        if a[i * 2] or a[i * 2 + 1]:\n            c += 1\n\nprint(c)\n
import sys\n\nMOD = (int)(1e9+7)\n\ndef add(a, b):\n	a += b\n	if a >= MOD: a -= MOD\n	return a\n	\ndef mul(a, b):\n	return (a * b) % MOD\n\nclass fenwickTree:\n	def __init__(self, max_val):\n		self.max_val = max_val + 5\n		self.tree = [0] * self.max_val\n	\n	def update(self, idx, value):\n		idx += 1\n		while idx < self.max_val:\n			self.tree[idx] = add(self.tree[idx], value)\n			idx += (idx & (-idx))\n	\n	def read(self, idx):\n		idx += 1\n		res = 0\n		while idx > 0:\n			res = add(res, self.tree[idx])\n			idx -= (idx & (-idx))\n		return res\n\ninp = [int(x) for x in sys.stdin.read().split()]\n\nn = inp[0]\na = []\nfor i in range(1, n + 1):\n	a.append(inp[i])\n	\nsorted_array = sorted(a)\ndict = {}\nfor i in range(n):\n	dict[sorted_array[i]] = i\n	\nfactor = [0] * n\nfor i in range(0, n):\n	factor[i] = mul(i + 1, n - i)\n	\nleft_tree = fenwickTree(n)\nfor i in range(0, n):\n	element_idx = dict[a[i]]\n	factor[i] = add(factor[i], mul(n - i, left_tree.read(element_idx)))\n	left_tree.update(element_idx, i + 1)\n	\nright_tree = fenwickTree(n)\nfor i in range(n - 1, -1, -1):\n	element_idx = dict[a[i]]\n	factor[i] = add(factor[i], mul(i + 1, right_tree.read(element_idx)))\n	right_tree.update(element_idx, n - i)\n\nans = 0\nfor i in range(n):\n	ans = add(ans, mul(a[i], factor[i]))\nprint(ans)\n
def main():\n    import sys\n    input = sys.stdin.readline\n    \n    n, k = map(int, input().split())\n    \n    cnt = [0] * k\n    for i in range(n):\n        cnt[int(input()) - 1] += 1\n    \n    dead = 0\n    ans = 0\n    \n    for i in cnt:\n        if i & 1:\n            dead += 1\n            ans += i - 1\n        else:\n            ans += i\n    \n    if n & 1:\n        print(ans + (dead + 1) // 2)\n    else:\n        print(ans + dead // 2)\n    \n    return 0\n\nmain()
import re\nimport itertools\nfrom collections import Counter, deque\n\nclass Task:\n    tasks = []\n    answer = "" \n	\n    def getData(self):\n        numberOfTasks = int(input())\n        for i in range(0, numberOfTasks):\n            self.tasks += [[int(x) for x in input().split(' ')]]\n        #inFile = open('input.txt', 'r')\n        #inFile.readline().rstrip()\n        #self.childs = inFile.readline().rstrip()\n\n    def solve(self):\n        queueSize, maxQueueSize = 0, 0\n        time, timeOfLastMessage = 1, 1\n        currentTask = 0\n        while currentTask < len(self.tasks) or queueSize > 0:\n            maxQueueSize = max(maxQueueSize, queueSize)\n            if currentTask < len(self.tasks):\n                timeDelta = self.tasks[currentTask][0] - time\n                queueSize -= min(queueSize, timeDelta)\n                time += timeDelta\n            else:\n                timeOfLastMessage = time + queueSize\n                break\n                \n            if currentTask < len(self.tasks) and \\n                    self.tasks[currentTask][0] == time:\n                queueSize += self.tasks[currentTask][1]\n                currentTask += 1\n        self.answer = str(timeOfLastMessage) + " " + str(maxQueueSize)\n\n    def printAnswer(self):\n        print(self.answer)\n        #outFile = open('output.txt', 'w')\n        #outFile.write(self.answer)\n\ntask = Task()\ntask.getData()\ntask.solve()\ntask.printAnswer()\n
n, s = map(int, input().split())\nc = []\nfor i in range(n):\n    x, y, z = map(int, input().split())\n    c.append((x, y, z))\nminans = 10**20\nfor i in range(n):\n    nc = 0\n    total = s\n    for j in range(n):\n        if c[j][0] ** 2 + c[j][1] ** 2 <= c[i][0] ** 2 + c[i][1] ** 2:\n            total += c[j][2]\n    if total >= 10**6 and c[i][0] ** 2 + c[i][1] ** 2 < minans:\n        minans = c[i][0] ** 2 + c[i][1] ** 2\nif minans != 10**20:\n    print(minans ** 0.5)\nelse:\n    print(-1)
n, m = [int(i) for i in input().split()]\nc = []; t = []\nfor i in range(n):\n	song = input().split()\n	c.append(int(song[0]))\n	t.append(int(song[1]))\nreq = [int(i) for i in input().split()]\n\nreq_index = total_length = 0\nfor i in range(len(c)):\n	total_length += c[i] * t[i]\n	while(req_index < len(req)):\n		if(req[req_index] <= total_length):\n			print(i + 1)\n			req_index += 1\n		else:\n			break\n	if req_index == len(req): break
(a, b), x, y = list(map(int, input().split())), [], 0\n\ndef bin(s):\n    return str(s) if s <= 1 else bin(s >> 1) + str(s & 1)\n\ndef lowbit(s):\n    return int('1' + bin(s).split('1')[-1], 2)\n\nfor i in reversed(range(b + 1)):\n    if y == a:\n        break\n    if a >= y + lowbit(i):\n        x.append(i) \n        y += lowbit(i)\n\nif y == a:\n    print( len(x) )\n    print( ' '.join(str(i) for i in x) )\nelse:\n    print( -1 )
from itertools import groupby\n\ns = input()\nn = len(s)\n\nif "w" in s or "m" in s:\n	print("0")\n	return\n\nmod = 10**9+7\nfib = [1, 1]\nfor i in range(2, n+1):\n	fib.append((fib[-1]+fib[-2])%mod)\n\nres = 1\n\nfor k, g in groupby(s):\n	if k=="u" or k=="n":\n		l = len(list(g))\n		res *= fib[l]\n		res %= mod\n\nprint(res)
import sys\n\nSIGMA = 26\n\nnodes = []\npairs = []\nres = 0\n\nclass Node:\n    def __init__(self):\n        self.ch = {}\n        self.a = []\n        self.b = []\n        self.d = 0\n\n    def add(self, s, i):\n        t = self\n        for c in s:\n            v = ord(c) - ord('a')\n            if not v in t.ch:\n                t.ch[v] = Node()\n                t.ch[v].d = t.d + 1\n                nodes.append(t.ch[v])\n            t = t.ch[v]\n        t.a.append(i)\n\n    def inc(self, s, i):\n        t = self\n        for c in s:\n            v = ord(c) - ord('a')\n            if not v in t.ch:\n                break\n            t = t.ch[v]\n        t.b.append(i)\n\n    def solve(self):\n        nonlocal pairs\n        nonlocal res\n        for i in range(SIGMA):\n            if i in self.ch:\n                self.a.extend(self.ch[i].a)\n                self.b.extend(self.ch[i].b)\n        k = min(len(self.a), len(self.b))\n        for i in range(k):\n            pairs.append(str(self.a[-1]) + ' ' + str(self.b[-1]))\n            self.a.pop()\n            self.b.pop()\n            res += self.d\n        return res\n\nsys.setrecursionlimit(2000000)\n_input = sys.stdin.readlines()\n_input = [s[:-1] for s in _input]\nN = int(_input[0])\nA = _input[1 : N + 1]\nB = _input[N + 1 :]\nT = Node()\nnodes.append(T)\nfor i, s in enumerate(A):\n    T.add(s, i + 1)\nfor i, s in enumerate(B):\n    T.inc(s, i + 1)\nfor n in reversed(nodes):\n    n.solve()\nprint(res)\nprint('\n'.join(pairs))\n
s = list(map(int, input()))\nans = []\ncnt = 0\nif s[0] == 1:\n    cnt += 1\nelse:\n    ans.append('0')\nfor i in range(1, len(s)):\n    if s[i] == 0 and s[i - 1] == 0:\n        ans.append('0')\n    elif s[i] == 1:\n        cnt += 1\n    else:\n        maba = 0\n        b = 0\n        for x in range(i, len(s)):\n            if s[x] == 1:\n                b -= 1\n            else:\n                b += 1\n            maba = max(maba, b)\n        maba = min(maba, cnt)\n        for _ in range(cnt - maba):\n            ans.append('0')\n        for _ in range(maba):\n            ans.append('1')\n        cnt = 0\n        ans.append('0')\nfor _ in range(len(s) - len(ans)):\n    ans.append('0')\nprint(''.join(ans))\n
s=input()\nt=int(input())\n\nans=[]\nn=len(s)\nclue=[0]*n\nfor i in range(n-1):\n    if(s[i]==s[i+1]):\n        clue[i]+=1\nL=[clue[0]]\nfor i in range(1,n):\n    L.append(L[i-1]+clue[i])\n\nfor i in range(t):\n    A,B=input().split()\n    A=int(A)-1\n    B=int(B)-1\n    r=0\n    x=L[B-1]\n    y=L[A-1]\n    if(A-1<0):\n        y=0\n    ans.append(x-y)\n\nfor i in range(t):\n    print(ans[i])\n    \n
#!/usr/bin/env python3\n\nfrom collections import Counter\n\nn = int(input())\nh_u = tuple(map(int, input().split()))\nh_s = sorted(h_u)\n\ni = 0\na = Counter()\nb = Counter()\n\nnum_partitions = 0\n\nfor i in range(n):\n  a[h_u[i]] += 1\n  b[h_s[i]] += 1\n\n  if (a == b):\n    num_partitions += 1\n    a = Counter()\n    b = Counter()\n\nprint(num_partitions)
n = int(input())\na = [tuple(map(int, input().split())) for _ in range(n)]\ns = {a[q]: q+1 for q in range(n)}\na.sort()\nq, q1 = 0, 1\nd, d1, d2 = [[[a[0]]]], [], []\nwhile q1 < n:\n    while q1 < n and a[q][0] == a[q1][0]:\n        while q1 < n and a[q][1] == a[q1][1]:\n            d[-1][-1].append(a[q1])\n            q1 += 1\n        if q1 < n and a[q][0] == a[q1][0]:\n            d[-1].append([a[q1]])\n            q = q1\n            q1 += 1\n    if q1 < n:\n        d.append([[a[q1]]])\n        q = q1\n        q1 += 1\nfor q in range(len(d)):\n    for q1 in range(len(d[q])):\n        for q2 in range(1, len(d[q][q1]), 2):\n            print(s[d[q][q1][q2-1]], s[d[q][q1][q2]])\n        if len(d[q][q1]) % 2 == 1:\n            d[q][q1] = d[q][q1][-1]\n        else:\n            d[q][q1] = -1\nfor q in range(len(d)):\n    d1.append([])\n    for q1 in range(len(d[q])):\n        if d[q][q1] != -1:\n            d1[-1].append(d[q][q1])\nfor q in range(len(d1)):\n    for q1 in range(1, len(d1[q]), 2):\n        print(s[d1[q][q1-1]], s[d1[q][q1]])\n    if len(d1[q]) % 2 == 1:\n        d2.append(d1[q][-1])\nfor q in range(1, len(d2), 2):\n    print(s[d2[q-1]], s[d2[q]])\n
import sys\n\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\nb = a[:]\nC = [0] * n\nx = [0] * n\nfor i in range (0, 40):\n    for j in range (0, n):\n        x[j] = b[j] % 2\n        b[j] = b[j] // 2\n    if sum(x) == 1:\n        for j in range (0, n):\n            if x[j] == 1:\n                C[j] = C[j] + 2 ** i\nl = C.index(max(C))\nprint(" ".join(list(map(str, [a[l]]+a[0:l]+a[l+1:]))))\n
n = int(input())\nv = list(map(int, input().split()))\nu = sorted(v)\ndv, du = [0] * (n + 1), [0] * (n + 1)\nans = list()\n\nfor i in range(1, n + 1):\n    dv[i] = dv[i-1] + v[i-1]\n    du[i] = du[i-1] + u[i-1]\n\nfor i in range(int(input())):\n    (t, l, r) = list(map(int, input().split()))\n    d = dv if t == 1 else du\n    ans.append(str(d[r] - d[l-1]))\n\nprint('\n'.join(ans))\n
import sys\ninput = sys.stdin.readline\n\nMOD = 998244353\n\n\nMAX = 5 * 10 ** 5 + 5\n\nfact = [1]\nfor i in range(1, MAX + 1):\n    new = fact[-1] * i\n    fact.append(new % MOD)\n\ninvL = pow(fact[MAX],MOD-2,MOD)\nfactInv = [invL] * (MAX + 1)\nfor i in range(MAX - 1, -1, -1):\n    old = factInv[i + 1]\n    new = old * (i  + 1)\n    factInv[i] = new % MOD\n\ndef choose(a,b):\n    if a < b:\n        return 0\n    res = fact[a]\n    res *= factInv[b]\n    res %= MOD\n    res *= factInv[a - b]\n    res %= MOD\n    return res\n    \n\nn, k = list(map(int, input().split()))\nevents = []\nfor i in range(n):\n    s, e = list(map(int, input().split()))\n    events.append(2*s+0)\n    events.append(2*e+1)\n    \nevents.sort()\ncount = 0\nout = 0\nfor t in events:\n    if t&1== 0:\n        out += choose(count, k - 1)\n        count += 1\n        out %= MOD\n    else:\n        count -= 1\n\nprint(out)\n
string=input()\nlength=len(string)\ngoodbad=[[1, 0, 0, 0] for x in range(length)]\n\n#good odd\n#bad odd\n#good even\n#bad even\n\nfor i in range(length-1):\n    if string[i]==string[i+1]:\n        goodbad[i+1][0]+=goodbad[i][2]\n        goodbad[i+1][2]+=goodbad[i][0]\n        goodbad[i+1][1]+=goodbad[i][3]\n        goodbad[i+1][3]+=goodbad[i][1]\n    else:\n        goodbad[i+1][3]+=goodbad[i][0]\n        goodbad[i+1][0]+=goodbad[i][3]\n        goodbad[i+1][1]+=goodbad[i][2]\n        goodbad[i+1][2]+=goodbad[i][1]\n\noddct=0\nevenct=0\nfor i in range(len(goodbad)):\n    oddct+=goodbad[i][0]\n    evenct+=goodbad[i][2]\nprint(evenct, oddct)\n
from functools import reduce\ndef main():\n    from sys import stdin\n    from operator import xor\n    from functools import reduce\n    x, res = reduce(xor, (input()[i] == '1' for i in range(0, int(input()) * 2, 2))), []\n    input()\n    for s in stdin.read().splitlines():\n        if s == '3':\n            res.append("01"[x])\n        else:\n            x ^= True\n    print(''.join(res))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n,k=list(map(int,input().split()))\nmod=998244353\n\nNEXT={(0,1):2,(1,2):2}#ww or wh,point k,場合の数\n\nfor i in range(1,n):\n    NOW=NEXT\n    NEXT=dict()\n    for key in NOW:\n        \n        \n\n        if key[0]==0:\n            if k-(n-i)*2<=key[1]<=k:\n                NEXT[key]=NEXT.get(key,0)+NOW[key]\n            if k-(n-i)*2<key[1]+1<=k:\n                NEXT[(0,key[1]+1)]=NEXT.get((0,key[1]+1),0)+NOW[key]\n                NEXT[(1,key[1]+1)]=NEXT.get((1,key[1]+1),0)+NOW[key]*2%mod\n\n\n        else:\n            if k-(n-i)*2<=key[1]<=k:\n                NEXT[key]=NEXT.get(key,0)+NOW[key]\n                NEXT[(0,key[1])]=NEXT.get((0,key[1]),0)+NOW[key]*2%mod\n\n            if k-(n-i)*2<key[1]+2<=k:\n                NEXT[(1,key[1]+2)]=NEXT.get((1,key[1]+2),0)+NOW[key]\n        #print(NOW,NEXT)\n\n\n\n\nANS=0\nfor key in NEXT:\n    if key[1]==k:\n        ANS=(ANS+NEXT[key])%mod\n\nprint(ANS)\n
import sys\n\nmod = 10**9 + 7\n\ndef solve():\n    n = int(input())\n    a = [int(i) for i in input().split()]\n\n    cnt = [0]*(10**5 + 1)\n\n    for ai in a:\n        for d in range(1, ai + 1):\n            if d*d > ai:\n                break\n            if ai % d == 0:\n                if d != ai // d:\n                    cnt[d] += 1\n                    cnt[ai // d] += 1\n                else:\n                    cnt[d] += 1\n\n    ans = 0\n\n    for i in range(1, 10**5 + 1):\n        ans += mobius(i) * (pow(2, cnt[i], mod) - 1)\n        ans %= mod\n\n    print(ans)\n\ndef mobius(x):\n    assert x >= 1\n\n    divcnt = 0\n\n    for p in range(2, x + 1):\n        if p*p > x:\n            break\n        if x % p != 0:\n            continue\n\n        x //= p\n\n        if x % p == 0:\n            return 0\n        else:\n            divcnt ^= 1\n\n    if x > 1:\n        divcnt ^= 1\n\n    return (-1)**divcnt\n\ndef __starting_point():\n    solve()\n__starting_point()
n = int(input())\nlst = [int(x) for x in input().split()]\ntmp = [False] * 100007\ntmp2 = [False] * 100007\n\nfor x in lst:\n	tmp[x] = True\n\n\n\nanswer, index = [], 1\nfor x in lst:\n	if not tmp2[x] and x <= len(lst):\n		answer.append(x)\n		tmp2[x] = True\n	else:\n		while tmp[index]:\n			index += 1\n		tmp[index] = True\n		answer.append(index)\n\n\nprint(' '.join(map(str, answer)))
rd = lambda: list(map(int, input().split()))\n\nn, k = rd()\nprint(' '.join(map(str, list(range(n, n-k,-1))+list(range(1,n-k+1)))))
n = int(input())\nl = list(map(int, input().split()))\n\ntotal = sum(l)\n\ngap = 0\nfor rod in l:\n    gap = max(gap, rod - (total - rod))\n\nprint(gap + 1)\n
n = int(input())\np = list()\nfor i in range(n):\n	p.append(set([int(x) for x in input().split()[1:]]))\nfor i in range(n):\n	for j in range(n):\n		if i != j:\n			if p[i].issuperset(p[j]):\n				print("NO")\n				break\n	else:\n		print("YES")\n\n
input()\nmemory = list(map(int, input().split()))\n\nproc_data = {p: (-1, -1) for p in memory}\n\nfor i, c in enumerate(memory):\n    d1, d2 = proc_data[c]\n    if d1 == -1: d1 = i\n    d2 = i\n    proc_data[c] = (d1, d2)\n\ntry: del proc_data[0]\nexcept KeyError:\n    print("0")\n    return\n\ndata = list(proc_data.values())\ndata.sort()\n\nans = 0\n\nfirst_free = 0\n\nfor a, b in data:\n    c = a - first_free\n    ans += min(c, b-a+1)\n    b -= c\n    first_free = b + 1\n\nprint(ans)\n\n
3\n# Copyright (C) 2016 Sayutin Dmitry.\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; version 3\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; If not, see <http://www.gnu.org/licenses/>.\n\ndef main():\n    n, h = list(map(int, input().split()))\n    leng = 0\n    for ai in map(int, input().split()):\n        if ai <= h:\n            leng += 1\n        else:\n            leng += 2\n\n    print(leng)\n\nmain()\n
N,k=input().split()\nN=int(N)\nk=int(k)\nx=0\nfor i in range(N):\n    A,B=input().split()\n    A=int(A)\n    B=int(B)\n    x+=(max(A,B)-min(A,B)+1)\n\nanswer=(x%k)\nif(answer!=0):\n    answer=k-answer\n\nprint(answer)\n
MAX = 1_000_005\nlp = [0] * MAX\npr = []\npid = {1: 0}\nfor i in range(2, MAX):\n    if not lp[i]:\n        lp[i] = i\n        pr.append(i)\n        pid[i] = len(pr)\n    for p in pr:\n        if p > lp[i] or i * p >= MAX:\n            break\n        lp[i * p] = p\n\nn = int(input())\na = list(map(int, input().split()))\n\ng = [[] for _ in range(len(pid))]\nec = 0\nfor x in a:\n    f = []\n    while x > 1:\n        p, c = lp[x], 0\n        while lp[x] == p:\n            x //= p\n            c ^= 1\n        if c:\n            f.append(p)\n    if not f:\n        print(1)\n        import sys\n        return\n    f += [1] * (2 - len(f))\n    u, v = pid[f[0]], pid[f[1]]\n    g[u].append((v, ec))\n    g[v].append((u, ec))\n    ec += 1\n\ndef bfs(p):\n    d = [-1] * len(pid)\n    d[p] = 0\n    q = [(p, -1)]\n    while q:\n        q2 = []\n        for u, peid in q:\n            for v, eid in g[u]:\n                if d[v] != -1:\n                    if eid != peid:\n                        return d[u] + d[v] + 1\n                else:\n                    d[v] = d[u] + 1\n                    q2.append((v, eid))\n        q = q2\n\nans = -1\nfor i in range(len(pid)):\n    if i > 0 and pr[i - 1] ** 2 >= MAX:\n        break\n    cyc = bfs(i) or ans\n    if ans == -1 or cyc < ans:\n        ans = cyc\nprint(ans)
N = int(input())\ndef f(x):\n  y = N//x\n  return y + x * y * (y-1) // 2\nans = set()\nfor i in range(1,32000):\n  if N % i == 0:\n    ans.add(f(i))\n    ans.add(f(N//i))\nprint(" ".join(str(x) for x in sorted(ans)))
__author__ = "runekri3"\n\nstairs_amount = int(input())\nstair_heights = list(map(int, input().split()))\nboxes_amount = int(input())\nboxes = []\nfor _ in range(boxes_amount):\n    boxes.append(list(map(int, input().split())))\n\nfor width, height in boxes:\n    box_bottom = max(stair_heights[0], stair_heights[width - 1])\n    print(box_bottom)\n    stair_heights[0] = box_bottom + height\n
"""Cowboy Beblop at his computer, problem 717I from https://codeforces.com/problemset/problem/717/I"""\n# from fractions import Fraction\n\n\n# def convert_to_fractions(poly):\n#     """convert polygon vertex to fractional type"""\n#     poly_frac = []\n#     for x, y, z in poly:\n#         vertex = (Fraction(x),\n#                   Fraction(y),\n#                   Fraction(z))\n#         poly_frac.append(vertex)\n#     return poly_frac\n\n\ndef convert_to_float(poly):\n    """convert polygon vertex to float type"""\n    poly_float = []\n    for x, y, z in poly:\n        vertex = (float(x),\n                  float(y),\n                  float(z))\n        poly_float.append(vertex)\n    return poly_float\n\n\ndef cross_product(a, b):\n    """3-vector product"""\n    return (a[1] * b[2] - a[2] * b[1],\n            a[2] * b[0] - a[0] * b[2],\n            a[0] * b[1] - a[1] * b[0])\n\n\ndef dot_product(a, b):\n    """scalar product of 3-vectors"""\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\n\ndef vect_diff(a, b):\n    """vector difference"""\n    return a[0] - b[0], a[1] - b[1], a[2] - b[2]\n\n\ndef poly_normal(poly):\n    """return normal vector for first three vertex"""\n    assert len(poly) >= 3\n    x, y, z = poly[:3]\n    u = vect_diff(y, x)\n    v = vect_diff(z, y)\n    return cross_product(u, v)\n\n\ndef intersect_list(poly, plain_norm, plain_point, proj_dir):\n    """list of intersection points\n\n    find points where the edges enter or leave upper half-space over the plain\n    :return list of points projection on proj_dir\n    """\n    # vertex projection\n    u = [dot_product(vert, proj_dir) for vert in poly]\n\n    # plain anchor\n    vr = dot_product(plain_point, plain_norm)\n\n    # polygon vertex\n    v = [dot_product(vert, plain_norm) for vert in poly]\n\n    u_list = []\n    for i in range(len(poly)):\n        if (v[i-1] > vr) != (v[i] > vr):\n            ur = ((vr - v[i-1]) * u[i] + (v[i] - vr) * u[i-1]) / (v[i] - v[i-1])\n            u_list.append(ur)\n\n    return u_list\n\n\ndef points_to_str(a_points, b_points):\n    """string representing the order of points 'a' and 'b'"""\n    a_pairs = [('a', val) for val in a_points]\n    b_pairs = [('b', val) for val in b_points]\n    pairs = sorted(a_pairs + b_pairs, key=lambda pair: pair[1])\n    letters = [ch for ch, _ in pairs]\n    return ''.join(letters)\n\n\ndef recognize_str(s):\n    """return True if string s belong to the grammar\n\n    The context-free grammar is given\n    S -> SS\n    S -> a S a\n    S -> b S b\n    S -> e\n\n    The recognising automaton is implemented\n    """\n    toggle = {'a':'b', 'b':'a'}\n    cross_num = 0\n    top = None\n    for ch in s:\n        if not cross_num:\n            cross_num = 1\n            top = ch\n            continue\n\n        if ch == top:\n            cross_num -= 1\n        else:\n            cross_num += 1\n\n        if cross_num:\n            top = toggle[top]\n        else:\n            top = None\n    return not cross_num\n\n\ndef is_well_connected(a, b):\n    """Two planar polygons are bind together in 3D\n\n    Arguments:\n        a_poly,\n        b_poly -- lists of vertex triples\n    """\n    a = convert_to_float(a)\n    b = convert_to_float(b)\n\n    a_norm = poly_normal(a)\n    b_norm = poly_normal(b)\n\n    common_dir = cross_product(a_norm, b_norm)\n    if not any(common_dir):\n        return False\n\n    a_list = intersect_list(a, b_norm, b[0], common_dir)\n    b_list = intersect_list(b, a_norm, a[0], common_dir)\n\n    char_str = points_to_str(a_list, b_list)\n    return not recognize_str(char_str)\n\n\ndef run_from_console():\n    a_len, = [int(num) for num in input().split()]\n\n    a = []\n    for _ in range(a_len):\n        vertex = tuple(int(num) for num in input().split())\n        a.append(vertex)\n\n    b_len, = [int(num) for num in input().split()]\n\n    b = []\n    for _ in range(b_len):\n        vertex = tuple(int(num) for num in input().split())\n        b.append(vertex)\n\n    if is_well_connected(a, b):\n        print('YES')\n    else:\n        print('NO')\n\n\ndef __starting_point():\n    run_from_console()\n__starting_point()
n = int(input())\ns = "aabb" * ((n+4)//4)\ns = s[:n]\nprint(s)
s = input().strip()\nk = int(input())\nw = list(map(int, input().split()))\nf = 0\nm = max(w)\nfor i in range(len(s)):\n    f += (i + 1) * w[ord(s[i]) - ord('a')]\nfor i in range(len(s), len(s) + k):\n    f += (i + 1) * m\nprint(f)
n, m = map(int, input().split())\nev = [tuple(map(int, input().split())) for _ in range(m)]\n\ng = [[] for _ in range(n + 1)]\nqry = [[] for _ in range(m + 1)]\nroots = set(range(1, n + 1))\nqcnt = 0\nfor e in ev:\n	if e[0] == 1:\n		g[e[2]].append(e[1])\n		roots.remove(e[1])\n	elif e[0] == 3:\n		qry[e[2]].append((qcnt, e[1]))\n		qcnt += 1\n\ntin, tout = [0] * (n + 1), [0] * (n + 1)\nst = [(u, 0) for u in roots]\ntime = 0\nwhile st:\n	u, w = st.pop()\n	if w:\n		tout[u] = time\n		continue\n	time += 1\n	tin[u] = time\n	st.append((u, 1))\n	for v in g[u]:\n		st.append((v, 0))\n\np = list(range(n + 1))\ndef find(x):\n	if x != p[x]:\n		p[x] = find(p[x])\n	return p[x]\n\npcnt = 0\nans = [None] * qcnt\nfor e in ev:\n	if e[0] == 1:\n		p[find(e[1])] = find(e[2])\n	elif e[0] == 2:\n		pcnt += 1\n		for qid, x in qry[pcnt]:\n			ans[qid] = 'YES' if find(e[1]) == find(x) and tin[x] <= tin[e[1]] <= tout[x] else 'NO'\n\nprint(*ans, sep='\n')
def main():\n    import sys\n    input = sys.stdin.readline\n    \n    n, l, r = map(int, input().split())\n    \n    mi = 0\n    curr = 1 << l - 1\n    for i in range(n):\n        mi += curr\n        if curr != 1:\n            curr >>= 1\n    \n    ma = 0\n    curr = 1\n    for i in range(n):\n        ma += curr\n        if curr != 1 << r - 1:\n            curr <<= 1\n    \n    print(mi, ma)\n    \n    return 0\n\nmain()
n = int(input())\na = []\na = input().split()\na = [int(i) for i in a]\na.sort()\nans = 0\nfor i in range(n // 2):\n    ans += (a[i] + a[n - i - 1]) ** 2\nprint(ans)
n = int(input())\narr = list(map(float, input().split()))\nif n == 1:\n    print(int(arr[0]))\n    return\narr.sort(reverse = True)\nres = 0\nwhile arr:\n    res += sum(arr)\n    arr = arr[:len(arr)//4]\nprint(int(res))\n
import math\n\nn, k = [int(x) for x in input().split()]\n\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\n\nc = 1\nfor i in range(n // k):\n    count = (10 ** k - 1) // a[i] + 1\n    mmin = b[i] * (10 ** (k-1))\n    mmax = (b[i] + 1) * (10 ** (k-1)) - 1\n    mcount = mmax // a[i] - math.ceil(mmin / a[i]) + 1\n    c = (c * (count - mcount)) % ((10 ** 9) + 7)\n\nprint(c)\n
def s(arr):\n    arr2 = arr[:]\n    arr2.sort()\n    return arr == arr2\n\nx = int(input())\ny = list(map(int, input().split(' ')))\nwhile (not s(y)):\n    for i in range(x-1):\n        if y[i] > y[i+1]:\n            print(i+1, i+2)\n            y[i], y[i+1] = y[i+1], y[i]\n    \n
s = input()\na, b = s.count('x'), s.count('y')\nif b > a: print('y' * (b - a))\nelse: print('x' * (a - b))
n, x = map(int, input().split())\nt = list(map(int, input().split()))\nm = min(t[: x])\nif m == 0:\n    i = x - 1\n    while t[i]: i -= 1\n    t[i + 1: x] = [j - 1 for j in t[i + 1: x]]\n    t[i] = x - i - 1\nelse:\n    t[: x] = [i - 1 for i in t[: x]]\n    m = min(t)\n    if m: t = [i - m for i in t]\n    i = n - 1    \n    while t[i]: i -= 1\n    t[i + 1: ] = [j - 1 for j in t[i + 1: ]]\n    t[i] = x + m * n + n - i - 1\nprint(' '.join(map(str, t)))
n = int(input())\nfirst = {}\nsecond = set()\ns1 = [0] * n\nans = [0] * n\nfor i in range(n):\n    a, b = input().split()\n    a = a[:3]\n    b = b[0]\n    s1[i] = b\n    if a in first.keys():\n        first[a].append(i)\n    else:\n        first[a] = [i]\n        ans[i] = a\nF = True\nfor name in first.keys():\n    if not F:\n        break\n    if len(first[name]) > 1:\n        for i in first[name]:\n            c = name[:2] + s1[i]\n            if c in second:\n                F = False\n                break\n            else:\n                second.add(c)\n                ans[i] = c\n        first[name] = 0\n\ndef process(name):\n    nonlocal F\n    if F == False:\n        return\n    if first[name] != 0 and name in second:\n        t = first[name][0]\n        c = name[:2] + s1[t]\n        if c in second:\n            F = False\n            return\n        else:\n            second.add(c)\n            ans[t] = c\n            first[name] = 0\n            if c in first.keys() and first[c] != 0:\n                process(c)\n                \n\n\nfor name in first.keys():\n    process(name)\n                \n\nif F:\n    print('YES')\n    for i in range(n):\n        print(ans[i])\nelse:\n    print('NO')
#return if sa contains a real prefix: sb\ndef isPrefix( sa , sb ):\n    if len(sa) <= len(sb):\n        return False\n    return sa[0:len(sb)] == sb\n\ndef getOrder( sa , sb ):\n    for i in range( 0 , min( len(sa) , len(sb) ) ):\n        if sa[i] != sb[i]:\n            return sa[i],sb[i]\n\ntest = False\nif test:\n    fp = open("C-4.in","r")\n    n = int(fp.readline().strip())\n    names = [ fp.readline().strip() for i in range(0,n)]\n    fp.close()\nelse:\n    n = int(input().strip())\n    names = [ input().strip() for i in range(0,n)]\n\ng = [[False]*26 for i in range(0,26)]\n\nres = True\nfor i in range(1,n):\n    if names[i-1] == names[i] or isPrefix( names[i] , names[i-1] ):\n        continue\n    elif isPrefix( names[i-1] , names[i] ):\n        res = False\n        break\n    else:\n        ca,cb = getOrder( names[i-1] , names[i] )\n        #print(ca,"<",cb)\n        if g[ord(cb)-ord('a')][ord(ca)-ord('a')]:\n            res = False\n            break\n        else:\n            g[ord(ca)-ord('a')][ord(cb)-ord('a')] = True\n\ndef printG():\n    print("  abcdefghijklmnopqrstuvwxyz")\n    for i in range(0,26):\n        print( chr( ord("a") + i ) , "".join( [ "1" if x else "0" for x in g[i]] ) , sep = "")\n#printG()\n\nif not res:\n    print("Impossible")\nelse:\n\n    def getZeroIndegreeNode():\n        for i in range(0,26):\n            if not used[i] and indegree[i] == 0:\n                return i\n        return -1\n    #topo sort\n    theOrder = []\n    indegree = [0] * 26\n    used = [False] * 26\n\n    #calc indegree\n    for i in range(0,26):\n        ithIndegree = 0\n        for j in range(0,26):\n            if g[j][i]: ithIndegree += 1\n        indegree[i] = ithIndegree\n        \n    for i in range(0,26):\n        zeroIndegreeNode = getZeroIndegreeNode()\n        if zeroIndegreeNode == -1:\n            res = False\n            break\n        else:\n            used[zeroIndegreeNode] = True\n            theOrder.append( chr( ord('a') + zeroIndegreeNode ) )\n            for j in range(0,26):\n                if g[zeroIndegreeNode][j]:\n                    indegree[j] -= 1\n\n    if not res:\n        print("Impossible")\n    else:\n        print( "".join( theOrder ) )\n
MAX_N = 5001\n\na = [0] * MAX_N;\nraz = [0] * (MAX_N + 10);\ns = [0] * (MAX_N + 10);\n\nn = int(input())\n\na = list(map(int, input().split()))\n\nfor i in range(n):\n    for j in range(n):\n        if a[i] - a[j] > 0:\n            raz[a[i] - a[j]] += 1\n\n\nfor i in range(1, MAX_N + 1):\n     s[i] = s[i - 1] + raz[i]\n     \nans = 0;\n\nfor i in range(1, MAX_N):\n    if raz[i] == 0:\n        continue\n    for j in range(1, MAX_N):\n        if i + j > MAX_N:\n            break\n        if raz[j] == 0:\n            continue\n        ans += raz[i] * raz[j] * (s[MAX_N] - s[i + j])\n\nans = ans * 1.0\nans /= s[MAX_N]\nans /= s[MAX_N]\nans /= s[MAX_N]\n\nprint(ans)
"""\nCodeforces Contest 288 Div 2 Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.4.2\n"""\n\n################################################### SOLUTION\n\ndef main():\n    n,m,k = read()\n    board = [[0]*m for _ in range(n)]\n    for i in range(k):\n        x,y = read()\n        x -= 1\n        y -= 1\n        board[x][y] = 1\n        if x > 0 and y > 0 and board[x-1][y-1] and board[x-1][y] and board[x][y-1]:\n            return i+1\n        if x > 0 and y < m-1 and board[x-1][y+1] and board[x-1][y] and board[x][y+1]:\n            return i+1\n        if x < n-1 and y > 0 and board[x+1][y-1] and board[x+1][y] and board[x][y-1]:\n            return i+1\n        if x < n-1 and y < m-1 and board[x+1][y+1] and board[x+1][y] and board[x][y+1]:\n            return i+1\n    return 0\n\n\n#################################################### HELPERS\n\n\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
c = list(map(int, input().split()))\nn, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nsa = sum(a)*c[0]\nsb = sum(b)*c[0]\n\nfor i in a:\n    sa = min(sa, sa - i*c[0] + c[1])\nfor i in b:\n    sb = min(sb, sb - i*c[0] + c[1])\nprint(min(sa + sb, sa + c[2], sb + c[2], c[2] + c[2], c[3]))\n
import itertools\nimport re\nimport math\nimport getpass\nimport sys\n\ndebug = False\nfiles = False\nif getpass.getuser() == 'frohe':\n    debug = True\n\nif debug and files:\n    sys.stdin = open('test.in')\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nn = ria()[0]\nar = ria()\nmp = {}\nfor i in ar:\n    mp[i] = 0\nfor n, i in enumerate(ar):\n    mp[i] = n\nmini = ar[0]\nfor i in mp:\n    if mp[mini]>mp[i]:\n        mini=i\nprint(mini)
def __starting_point():\n\n    n = int( input() )\n\n    maxX = [-1]*100005\n    for _ in range(n):\n        px,py = [int(x) for x in input().split()]\n        maxX[py] = max( maxX[py] , px )\n\n    #print( maxX[:2] )\n\n    w = [int(x) for x in input().split()]\n\n    p = [-1]*100005\n    p[0] = 0\n    wdict = dict()\n    wdict[0] = (0,0)\n    res = []\n    for wi in w:\n        if wi in wdict:\n            px , py = wdict.pop(wi)\n            res.append( (px,py) )\n            if maxX[py] > px:\n                wdict[py-(px+1)] = (px+1,py)\n                p[py] += 1\n            if maxX[py+1] != -1 and p[py+1] == -1:\n                wdict[py+1] = (0,py+1)\n                p[py+1] += 1\n        else:\n            break\n\n    if len(res) == n:\n        print("YES")\n        for ares in res:\n            print(ares[0],ares[1])\n    else:\n        print("NO")\n__starting_point()
import sys\nn,m = [int(x) for x in input().split()]\n\ninp = []\ns = sys.stdin.read()\ni = 0\nwhile True:\n    while i<len(s) and s[i]<'-':i+=1\n    if i==len(s):break\n    j = i\n    while j<len(s) and not(s[j]<'-'):j+=1\n    inp.append(int(s[i:j]))\n    i = j\n\norder = sorted(range(n),key=lambda i:inp[2*i]-inp[2*i+1])\n\nscore = [0]*n\nval = sum(inp[1:2*n:2])\nfor ind in range(n):\n    i = order[ind]\n\n    # Do second problem together with order[:ind]\n    # Do first problem together with order[ind:]\n    score[i] += val + inp[2*i+1]*(ind-1) + inp[2*i]*(n-ind-1)\n    val += inp[2*i]-inp[2*i+1]\n\nfor _ in range(m):\n    u = inp[2*n+2*_]-1\n    v = inp[2*n+2*_+1]-1\n    s = min(inp[2*u]+inp[2*v+1],inp[2*v]+inp[2*u+1])\n    score[u] -= s\n    score[v] -= s\n\nsys.stdout.write(' '.join(str(x) for x in score))
def main():\n    import sys\n    input = sys.stdin.readline\n\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    S = -1\n    for mid in range(N):\n        ans = [0] * N\n        ans[mid] = A[mid]\n        prev = A[mid]\n        for j in range(mid-1, -1, -1):\n            ans[j] = min(prev, A[j])\n            prev = ans[j]\n        prev = A[mid]\n        for j in range(mid+1, N):\n            ans[j] = min(prev, A[j])\n            prev = ans[j]\n        if sum(ans) > S:\n            S = sum(ans)\n            ans_best = ans\n    print(*ans_best)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n = input()\nv = list(map(int, input().split()))\n\nbest = 1\ncurrent = 1\nfor i in range(1, len(v)):\n    if v[i-1] <= v[i]:\n        current += 1\n    else:\n        current = 1\n    best = max(best, current)\n\nprint(best)\n
n = int(input())\nline = list(map(int, input().split()))\nm = dict()\nans = 0\nfor i in range(n):\n    if line[i] not in m:\n        m[line[i]] = 1\n    else:\n        m[line[i]] += 1\n    var = m[line[i]]\n    if line[i] - 1 in m:\n        var += m[line[i]-1]\n    if line[i] + 1 in m:\n        var += m[line[i]+1]\n    ans += (i+1-var) * line[i]\nx = dict()\nfor j in range(n):\n    i = n - j - 1\n    if line[i] not in x:\n        x[line[i]] = 1\n    else:\n        x[line[i]] += 1\n    var = x[line[i]]\n    if line[i] - 1 in x:\n        var += x[line[i]-1]\n    if line[i] + 1 in x:\n        var += x[line[i]+1]\n    ans -= (j+1-var) * line[i]\nprint(ans)\n\n
# Question B. Road to Cinema\nimport sys\n\ndef roadToCinema(V, S, T, stations): # O(M)\n    """\n    V       : volume of fuel tank\n    S       : total distance\n    T       : time limit\n    stations: fuel stations' locations\n\n    rtype   : boolean, whether this aircraft can travel within the time limit\n    """\n    m = len(stations)\n    t = 0\n    stations.append(S) # destination\n    prev = 0\n    for cur in stations:\n        dis = cur - prev\n        # let Sa, Sb as the distance of accelerated mode/ normal mode respectively\n        # then the task is:\n        #  min t = (Sa + 2 * Sb)\n        # s.t. Sa + Sb = dis\n        #      2 * Sa + Sb <= V\n\n        if dis > V:\n            # Sa <= V - dis < 0\n            return False\n        else:\n            # t = Sa + 2Sb = 3(Sa + Sb) - (2Sa + Sb)\n            #   >= 3 * dis - V\n            # on the other hand, Sb is non-negative\n            # Sb = t - dis\n            t += max(dis * 3 - V, dis)\n\n        if t > T:\n            return False\n\n        prev = cur\n\n    return True\n\ndef binSearch(S, T, stations): # O(logS * M)\n    """\n    to find the least tank volume to enable the aircraft to complete the journey\n    the fastest way is to complete the whole journey with the speed of 2km/min, at 2L/km\n    V <= 2S \n    """\n    l = stations[0]\n    r = S * 2\n\n    for i in range(1, len(stations)):\n        l = max(stations[i] - stations[i - 1], l)\n\n    l = max(l, S - stations[-1])\n    r = 2 * l\n    \n    if T < S:\n        return float("inf")\n\n    while l + 1 < r:\n        m = l + (r - l) // 2\n        if roadToCinema(m, S, T, stations) == True:\n            r = m\n        else:\n            l = m\n    \n    if roadToCinema(l, S, T, stations):\n        return l\n    if roadToCinema(r, S, T, stations):\n        return r\n    return float("inf")\n\ndef __starting_point(): # O(logS * M + N)\n    \n    line = sys.stdin.readline()\n    [N, M, S, T] = list(map(int, line.split(" ")))\n\n    aircrafts = []\n    for i in range(N):\n        [c, v] = list(map(int, sys.stdin.readline().split(" ")))\n        aircrafts.append([c, v])\n\n    stations = list(map(int, sys.stdin.readline().split(" ")))\n    stations.sort()\n\n    minVolume = binSearch(S, T, stations)\n    \n    if minVolume == float("inf"):\n        # no aircraft can complete the journey\n        print(-1)\n    else:\n        res = float("inf")\n        for i in range(N):\n            if aircrafts[i][1] >= minVolume:\n                res = min(res, aircrafts[i][0])\n\n        if res == float('inf'):\n            # no given aircraft can complete the journey\n            print(-1)\n        else:\n            print(res)\n__starting_point()
class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n    \n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n    \n    def to(self, other):\n        return other - self\n    \n    def __repr__(self):\n        return "(%s %s)" % (self.x, self.y)\n\n    def dot(self, other):\n        return self.x * other.y - self.y * other.x\n    \n    def lensq(self):\n        return self.x ** 2 + self.y ** 2\n\nVec = Vector\n\ndef getH(p, a, b):\n    s2 = p.to(a).dot(p.to(b))\n    # a * h / 2 = s\n    # h = s * 2 / a\n    return s2 / (a.to(b).lensq() ** 0.5)\n\npts = [Vec(*list(map(int, input().split()))) for i in range(int(input()))]\nn = len(pts)\npts.append(pts[0])\npts.append(pts[1])\n\nans = 12351513153155135135\n\nfor i in range(n):\n    ans = min(ans, getH(pts[i + 1], pts[i], pts[i + 2])/2)\n\nprint(ans)\n
from sys import stdin\ns=stdin.readline().strip()\ndp=[0 for i in range(len(s)+2)]\nons=[0 for i in range(len(s)+2)]\nzs=[0 for i in range(len(s)+2)]\nfor i in range(len(s)-1,-1,-1):\n    if s[i]=="1":\n        ons[i]+=1\n    if(i!=len(s)-1):\n        ons[i]+=ons[i+1]\nz=0\nfor i in range(len(s)-1,-1,-1):\n    if(s[i]=="1"):\n        dp[i]=max(1+ons[i+1],z)\n    else:\n        dp[i]=max(dp[i+1]+1,1+ons[i+1])\n        z=dp[i]\n    zs[i]=z\n\nans=""    \nfor i in range(len(s)):\n    if s[i]=="1":\n        x=dp[i]\n        y=1+dp[i+1]\n        if x==y:\n            ans+="0"\n        else:\n            ans+="1"\n    else:\n        ans+="0"\nprint(ans)\n
from operator import attrgetter, itemgetter\nn = int(input());\narr = [[int(x) for x in input().split(' ')] for y in range(n)];\narr = sorted(arr, key=itemgetter(1,0,2), reverse=True);\ndp = [0 for x in range(n)];\ns = [];\nfor i in range(n):\n	while (s != [] and arr[s[-1]][0] >= arr[i][1]):\n		s.pop();\n	if (s != []):\n		dp[i] = dp[s[-1]];\n	dp[i] += arr[i][2];\n	s.append(i);\nprint(max(dp));
n=int(input())\na=list(int(i) for i in input().split())\np=[0]*(n+1)\nfor i in range(0,n) :\n	p[i+1]+=p[i]+a[i]\nok=dict()\nans,l=0,0\nfor i in range(n+1) :\n	if p[i] in ok :\n		ok[p[i]]+=1\n	else :\n		ok[p[i]]=1\n	while ok[p[i]]>1:\n		ok[p[l]]-=1\n		l+=1\n	ans+=(i-l+1)\nprint(ans-n-1)\n\n\n
n = int(input())\ns = input()\nif s == '0':\n    print(0)\nelse:\n    print('1'+'0'*s.count('0'))\n
# import sys\n# sys.stdin = open('in.txt', 'r')\n\n_ = input()\ns = input()\nt = input()\n\npar = [i for i in range(26)]\ndef find(x):\n    if par[x] != x:\n        par[x] = find(par[x])\n        return par[x]\n    else:\n        return x\n\nfor i in range(len(s)):\n    a, b = find(ord(s[i])-97), find(ord(t[i])-97)\n    if a != b:\n        par[a] = b\n\nres = 0\nfor i in range(26):\n    find(i)\n\nfor i in range(26):\n    res += max(0, par.count(i) - 1)\nprint(res)\n\nfor i in range(26):\n    d = []\n    for j in range(26):\n        if par[j] == i:\n            d.append(chr(j+97))\n\n    for j in range(len(d)-1):\n        print(d[j], d[j+1])\n
from scipy.special import comb\nmod = 10**9 + 7\nN, K = list(map(int,input().split()))\nfor i in range(1,K+1):\n    a = K-i\n    b = i-1\n    c = N-(i-1)-K\n    d = i\n    print((comb(a+b,b,exact=True)*comb(c+d,d,exact=True)%mod))\n
A,B,C,D=list(map(int,input().split()))\nfor i in range(2):\n    for j in range(2):\n        for k in range(2):\n            for l in range(2):\n                sum1 = 0\n                sum2 = 0\n                if i == 1:\n                    sum1 += A\n                else:\n                    sum2 += A\n                if j ==1:\n                    sum1 += B\n                else:\n                    sum2 += B\n                if k == 1:\n                    sum1 += C\n                else:\n                    sum2 += C\n                if l == 1:\n                    sum1 += D\n                else:\n                    sum2 += D\n                if sum1 == sum2:\n                    print("Yes")\n                    return\nprint("No")\n
MOD = 10**9 + 7\n\ns = str(input())\n\ndp0 = [0] * (len(s)+1)\ndp1 = [0] * (len(s)+1)\ndp0[0] = 1\n\nfor i in range(1,len(s)+1):\n    if s[i-1] == "0":\n        dp0[i] = dp0[i-1]\n        dp1[i] = dp1[i-1] * 3\n    else:\n        dp0[i] = dp0[i-1] * 2\n        dp1[i] = dp0[i-1] + dp1[i-1] * 3\n    dp0[i] %= MOD\n    dp1[i] %= MOD\n\nanswer = dp0[-1] + dp1[-1]\nif answer >= MOD:\n    answer -= MOD\nprint(answer)\n
s,p=map(int,input().split())\nimport math\nfor i in range(1,math.floor(p**0.5)+1):\n    if p%i==0 and p//i+i==s:\n        print("Yes")\n        return\nprint("No")
S = input()\nS = "".join(list(reversed(S)))\nstr_list = ["dream", "dreamer", "erase", "eraser"]\nrev_str = []\nfor i in str_list:\n    rev_str.append("".join(list(reversed(i))))\nis_OK = True\nwhile len(S) > 0:\n    if S[0:5] in rev_str:\n        S = S[5:]\n    elif S[0:6] in rev_str:\n        S = S[6:]\n    elif S[0:7] in rev_str:\n        S = S[7:]\n    else:\n        is_OK = False\n        break\nif is_OK:\n    print("YES")\nelse:\n    print("NO")\n
# python3\nimport sys\n\n\ndef read_all_following_lines():\n    lines = sys.stdin.readlines()\n    return (tuple(map(int, line.split())) for line in lines)\n\n\nclass AbcString(object):\n    def __init__(self, string):\n        self.prefix_bc = [0]\n        self.a_strike = [0]\n\n        bc, strike = 0, 0\n        for symbol in string:\n            if symbol == 'A':\n                strike += 1\n            else:\n                strike = 0\n                bc += 1\n            self.prefix_bc.append(bc)\n            self.a_strike.append(strike)\n\n    def get_info(self, begin, end):\n        bc = self.prefix_bc[end] - self.prefix_bc[begin]\n        trailing_a = min(self.a_strike[end], end - begin)\n        return bc, trailing_a\n\n\ndef can_mutate(start, finish):\n    from_bc, from_a = start\n    to_bc, to_a = finish\n\n    if (from_bc & 1) != (to_bc & 1): return False\n    if from_bc > to_bc: return False\n    if from_a < to_a: return False\n\n    if from_bc == to_bc: return (from_a - to_a) % 3 == 0\n    if from_a == to_a: return from_bc != 0\n\n    # from_bc < to_bc\n    # from_a > to_a\n    return True\n\n\ndef main():\n    s = AbcString(input())\n    t = AbcString(input())\n    input()  # skip one line\n    requests = read_all_following_lines()\n\n    answer = ""\n    for (a, b, c, d) in requests:\n        can = can_mutate(s.get_info(a - 1, b), t.get_info(c - 1, d))\n        answer += "1" if can else "0"\n\n    print(answer)\n\n\nmain()\n
s = input()\nt = input()\nabc = 'abcdefghijklmnopqrstuvwxyz'\ndabc ={}\nfor i in range(26):\n	dabc[abc[i]] = i\n\nlt = {}\nls = {}\ndd = {}\nls['?'] = 0\nfor i in abc:\n	lt[i] = 0\n	ls[i] = 0\n	dd[i] = 0\nfor letter in t:\n	lt[letter] += 1\nfor letter in s:\n	ls[letter] +=1\n\nX = ls['?']\ndef check(ans):\n	nonlocal ls, lt, abc, X\n	return -sum(min(0, ls[l] - lt[l] * ans) for l in abc) <= X\n\nstart, end = [0, 2000000]\ni = 0\nwhile start < end:\n	st = start + end\n	ans = (st + st%2)//2\n	if check(ans):\n		start = ans\n	else:\n		end = ans - 1\nans = start\n\n\nfor letter in abc:\n	dd[letter] = max(0, lt[letter] * ans - ls[letter])\n	X -= max(0, lt[letter] * ans - ls[letter])\n\ns1 = ['']\nj = 0\nfor i in s:\n	if i != '?':\n		s1.append(i)\n	else:\n		try:\n			while dd[abc[j]] == 0:\n				j +=1\n			s1.append(abc[j])\n			dd[abc[j]] -= 1\n		except:\n			s1.append('z')\n\nprint(''.join(s1))\n
n = int(input())\na = [int(x) for x in input().split()]\nalive = 0\nleft = n\nfor i in range(n - 1, -1, -1):\n    if i < left:\n        alive += 1\n    left = min(left, i - a[i])\nprint(alive)\n
s = input()\nn = len(s)\np = [0] * (n+1)\nfor x in range(1, n):\n	y = 0\n	if s[x] == 'v' and s[x-1] == 'v':\n		y = 1\n	p[x+1] = p[x] + y\nq = 0\nsol = 0\nfor x in range(n-3, -1, -1):\n	if s[x+1] == 'v' and s[x+2] == 'v':\n		q += 1\n	if s[x] == 'o':\n		sol += q*p[x]\nprint(sol)\n
from math import inf\nn, p = [int(x) for x in input().split()]\nl = []\nfor i in range(n):\n    a, b = [int(x) for x in input().split()]\n    l.append((a, b, b/a))\nl.sort(key=lambda x: x[2])\nasum = 0\nbsum = 0\nsumt = 0\nfor i in range(n):\n    a0, b0, _ = l[i]\n    c1 = inf if i == n-1 else l[i+1][2]\n    asum += a0\n    bsum += b0\n    dp = asum - p\n    if dp > 0:\n        t = bsum / dp\n        if t < c1:\n            print(t)\n            return\nprint(-1)
# fast io\nfrom sys import stdin\n_data = iter(stdin.read().split('\n'))\ninput = lambda: next(_data)\n\nN = 101\nMOD = 1000000007\n\ndef mul_vec_mat(v, a):\n    c = [0] * N\n    for i in range(N):\n        c[i] = sum(a[j][i] * v[j] % MOD for j in range(N)) % MOD\n    return c\n\ndef mul_vec_sparse_mat(v, a):\n    c = [0] * N\n    for i in range(N):\n        c[i] = sum(x * v[j] % MOD for j, x in a[i]) % MOD\n    return c\n\n_, x = [int(v) for v in input().split()]\na = [[0] * N for i in range(N)]\na[0][0] = 1\na[N - 1][0] = 1\nfor i in range(1, N - 1):\n    a[i][i + 1] = 1\nfor d in map(int, input().split()):\n    a[N - 1][N - d] += 1\nsa = [[] for i in range(N)]\nfor i in range(N):\n    for j in range(N):\n        if a[i][j] != 0:\n            sa[j].append((i, a[i][j]))\nr = [[1 if i == j else 0 for j in range(N)] for i in range(N)]\nwhile x > 0:\n    if x & 1:\n        r[0] = mul_vec_mat(r[0], a)\n        r[1] = mul_vec_mat(r[1], a)\n    aa = [[0] * N for i in range(N)]\n    aa[0] = mul_vec_mat(a[0], a)\n    aa[1] = mul_vec_mat(a[1], a)\n    for i in range(2, N):\n        aa[i] = mul_vec_sparse_mat(aa[i - 1], sa)\n    a = aa\n    x >>= 1\nfor i in range(2, N):\n    r[i] = mul_vec_sparse_mat(r[i - 1], sa)\nb = [0] * N\nb[0] = 1\nb[N - 1] = 1\nprint(sum(r[N - 1][i] * b[i] % MOD for i in range(N)) % MOD)
n, x = list(map(int, input().split()))\nr = 0\nfor _ in range(n):\n    a, b = input().split()\n    if a == "+":\n        x += int(b)\n    else:\n        if int(b) <= x:\n            x -= int(b)\n        else:\n            r += 1\nprint(x, r)\n
from sys import *\nf = list(map(int, stdin.read().split()))\n\nn, m = f[0], f[1]\nd = [[] for i in range(100001)]\n\nfor j in range(2, len(f), 3):\n    x, y, w = f[j:j + 3]\n    d[w].append((y, x))\n\ns = [0] * (n + 1)\nfor q in d:\n    for y, k in [(y, s[x]) for y, x in q]: s[y] = max(s[y], k + 1)\nprint(max(s))
n, m = [int(x) for x in input().strip().split()]\nc = [int(x) for x in input().strip().split()]\na = [int(x) for x in input().strip().split()]\n\nans = 0\nai = 0\nfor ci in c:\n    if ai < len(a) and a[ai] >= ci:\n        ai += 1\n        ans += 1\nprint(ans)\n
n=int(input())\na=list(map(int,input().split()))\ncount=[0]*(10**5+1)\nfor i in a:\n    count[i]+=1\nans=[]\nfor i in range(10**5+1):\n    if count[i]:\n        ans.append(i)\n        count[i]-=1\nif len(ans)!=n:\n    for i in reversed(range(10**5+1)):\n        if count[i] and ans[-1]!=i:\n            ans.append(i)\nprint(len(ans))\nprint(*ans)
s=input();M=10**9+7;o=u=v=0;n=len(s)\nfor i in range(n):c=int(s[i]);u+=v;v=(10*v+c)%M;o+=pow(10,n-i-1,M)*((i*i+i)//2*c+u)\nprint(o%M)
from random import seed, randint\nimport sys\nsys.setrecursionlimit(10000)\n\nopr = ['#', '^', '&', '$']\nnamespace = { "res" : (False, "res") }\nrules = dict()\nlookup = dict()\ncnt = -1\n\ndef get_tag(var):\n    if var in namespace:\n        return namespace[var][1]\n    else:\n        return var\n\nN = int(input())\nfor _ in range(N):\n    lval, rval = input().split('=')\n    for c in opr:\n        if c in rval:\n            arg1, arg2 = list(map(get_tag, rval.split(c)))\n            rule = (arg1, arg2, c)\n            if rule in rules:\n                namespace[lval] = (True, rules[rule])\n            else:\n                cnt += 1\n                namespace[lval] = (True, cnt)\n                rules[rule] = cnt\n                lookup[cnt] = rule\n            break\n    else:\n        if rval in namespace:\n            namespace[lval] = namespace[rval]\n        else:\n            namespace[lval] = (False, rval)\n\nif namespace["res"] == (False, "res"):\n    print("0")\n    return\n\nprogram = []\nmyvars = dict()\n\ndef reserve():\n    return ''.join(chr(randint(0, 25) + ord('a')) for _ in range(4)) \n\ndef implement(rule, final):\n    if type(rule) == str:\n        return rule\n    elif rule in myvars:\n        return myvars[rule]\n    else:\n        if final:\n            name = "res"\n        else:\n            name = reserve()\n        myvars[rule] = name\n        arg1, arg2, op = lookup[rule]\n        var1, var2 = implement(arg1, False), implement(arg2, False)\n        program.append(name + "=" + var1 + op + var2)\n        return name\n\nseed(123)\nif namespace["res"][0]:\n    implement(namespace["res"][1], True)\nelse:\n    program.append("res=" + namespace["res"][1])\nprint(len(program))\nprint("\n".join(program))\n\n#print(namespace)\n#print(rules)\n
#!/usr/bin/env python\n#-*- coding:utf-8 -*-\n\n# Code by H~$~C\n\nfrom sys import stdin\ninput = stdin.readline\nimport math\n\nn = int(input())\nG = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n  u, v = map(int, input().split())\n  G[u].append([v, i])\n  G[v].append([u, i])\n\nans = [-1] * (n + 1)\n\nfor u in range(1, n + 1):\n  if (len(G[u]) >= 3):\n    for j in range(len(G[u])):\n      ans[G[u][j][1]] = j\n    cnt = len(G[u])\n    for j in range(n - 1):\n      if (ans[j] == -1):\n        ans[j] = cnt\n        cnt += 1\n    for j in range(n - 1):\n      print(ans[j])\n    return\n\nfor i in range(n - 1):\n  print(i)
import sys\nf = sys.stdin\n#f = open("input.txt", "r")\nx, y, a, b = map(int, f.readline().strip().split())\na1, a2 = [], []\nif a+(x-a) <= b:\n    print(0)\nelse:\n    for i in range(a, x+1):\n        for k in range(b, y+1):\n            if i > k:\n                a1.append(i)\n                a2.append(k)\n    print(len(a1))\n    for i in range(len(a1)):\n        print(a1[i], a2[i])
import bisect;\ndef getIntList():\n    return list(map(int, input().split()));\ndef getTransIntList(n):\n    first=getIntList();\n    m=len(first);\n    result=[[0]*n for _ in range(m)];\n    for i in range(m):\n        result[i][0]=first[i];\n    for j in range(1, n):\n        curr=getIntList();\n        for i in range(m):\n            result[i][j]=curr[i];\n    return result;\nn=int(input());\na=getIntList();\nanums=[(a[i], i) for i in range(n)];\nanums.sort();\nlocation=0;\nlength=0;\nk=1;\npieces=[];\ndef upgrade(x):\n    curr=(x, x+1)\n    i=bisect.bisect(pieces, curr);\n    joinLeft=False;\n    joinRight=False;\n    if i>0 and pieces[i-1][1]==x:\n        joinLeft=True;\n    if i<len(pieces) and pieces[i][0]==x+1:\n        joinRight=True;\n    if joinLeft:\n        if joinRight:\n            pieces[i-1]=(pieces[i-1][0], pieces[i][1])\n            pieces.pop(i);\n        else:\n            pieces[i-1]=(pieces[i-1][0], x+1);\n        return pieces[i-1][1]-pieces[i-1][0];\n    else:\n        if joinRight:\n            pieces[i]=(x, pieces[i][1])\n        else:\n            pieces.insert(i, curr);\n        return pieces[i][1]-pieces[i][0];\ncurrLength=0;\ncurrSum=0;\nfor x in anums:\n    currSum+=1;\n    val, num=x;\n    l=upgrade(num);\n    #print(pieces);\n    currLength=max(currLength, l);\n    #print(currLength,"*",len(pieces),"==",currSum)\n    if currLength*len(pieces)==currSum:\n        currK=val+1;\n        currLocation=len(pieces);\n        if currLocation>location:\n            location=currLocation;\n            k=currK;\n    if (location+2)*currLength-1>n:\n        break;\nprint(k);
import sys\ninput = sys.stdin.readline\n\nt=int(input())\nfor testcases in range(t):\n    n=int(input())\n\n    LIST=[input().strip() for i in range(n)]\n    SET=set()\n\n    ANS=0\n    CHANGE=set()\n    for i in range(n):\n        if LIST[i] in SET:\n            ANS+=1\n            CHANGE.add(i)\n        else:\n            SET.add(LIST[i])\n\n    ALIST=[]\n\n    for i in range(n):\n        if i in CHANGE:\n            flag=0\n            now=LIST[i]\n            \n            for j in range(4):\n                for k in range(10):\n                    x=now[:j]+str(k)+now[j+1:]\n\n                    if x in SET:\n                        continue\n                    else:\n                        ALIST.append(x)\n                        SET.add(x)\n                        flag=1\n                        break\n                if flag:\n                    break\n\n        else:\n            ALIST.append(LIST[i])\n    print(ANS)\n    print("\n".join(ALIST))\n\n    \n\n    \n
def main():\n	t = int(input())\n	reserved = set(input().split())\n\n	lines = int(input())\n	code = ''\n	for i in range(lines):\n		code += input() + '\n'\n\n	def is_word(suspect):\n		if suspect[0].isdigit(): return False\n		for x in suspect:\n			if (not x.isalpha()) and (not x in {'_', '$'}) and (not x.isdigit()):\n				return False\n		return True\n\n	def is_token(suspect):\n		if suspect in reserved: return True\n		if is_word(suspect): return True\n		if suspect.isdigit(): return True\n		return False\n\n	def remove_comments(code):\n		rez = ''\n		state = None\n		for i in range(len(code)):\n			if code[i] == '#':\n				state = 'comment'\n			elif code[i] == '\n':\n				rez += code[i]\n				state = None\n			else:\n				if state != 'comment':\n					rez += code[i]\n		return rez\n\n	code = remove_comments(code)\n	code = code.replace('\n', ' ')\n\n	def split(code):\n		tokens = []\n		i = 0\n		while i < len(code):\n			if code[i] == ' ':\n				i += 1\n				continue\n			for l in range(min(len(code), 90), 0, -1):\n				if is_token(code[i:i + l]):\n					tokens.append(code[i:i + l])\n					i += l\n					break\n			else:\n				return []\n		return tokens\n\n	def minmize(tokens):\n		all = []\n		pref = [chr(i + ord('a')) for i in range(26)]\n		all.extend(pref)\n		for ext in range(3):\n			cur = []\n			for i in range(26):\n				for p in pref:\n					cur.append(p + chr(i + ord('a')))\n			cur.sort()\n			all.extend(cur)\n			pref = cur[::]\n\n		all.reverse()\n		zip = dict()\n		for i in range(len(tokens)):\n			if not tokens[i] in reserved and not tokens[i][0].isdigit():\n				if not zip.get(tokens[i], None):\n					while all[-1] in reserved:\n						all.pop()\n					zip[tokens[i]] = all[-1]\n					all.pop()\n				tokens[i] = zip[tokens[i]]\n		return tokens\n\n	tokens = (minmize(split(code)))\n\n	def cmp(a, b):\n		if len(a) != len(b): return False\n		for i in range(len(a)):\n			if a[i] != b[i]: return False\n		return True\n\n	final = []\n	for i in range(len(tokens)):\n		p = 0\n		for j in range(i - 1, -1, -1):\n			if len(''.join(tokens[j:i + 1])) > 23:\n				p = j\n				break\n\n		st = ''\n		if i and (not cmp(tokens[p:i + 1], split(''.join(final[p:i]) + tokens[i]))):\n			st += ' '\n		final.append(st + tokens[i])\n	print(''.join(final))\nmain()
s1=input()\ns2=input()\nL={}\nL['h']=s1\nL['a']=s2\n\nn=int(input())\nD={}\nF={}\nfor i in range(n):\n    a=input().split()\n    m=int(a[0])\n    t=L[a[1]]\n    num=int(a[2])\n    c=a[3]\n    if((t,num) in D):\n        continue\n    if(c=='r' or (c=='y' and ((t,num) in F))):\n        D[(t,num)]=1\n        print(t,num,m)\n    else:\n        F[(t,num)]=1\n
diff=0\nx = int(input())\nl = list(map(int, input().split(' ')))\ns = sum(l)\nk = s//x\nknum = (k+1)*x-s\nkpnum = x - knum\na = knum * [k] + [k+1] * kpnum\na.sort()\nl.sort()\nfor i in range(len(a)):\n    diff += abs(a[i]-l[i])\nprint(int(diff/2))
n = int(input())\ns = ''\ns1 = ''\nans = 0\nfor i in range(n):\n    s = input()\n    if (s != s1):\n        ans += 1\n    s1 = s\nprint(ans)
from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n'''\nfor CASES in range(int(input())):\nn, m = map(int, input().split())\nn = int(input())\nA = list(map(int, input().split()))\nS = input().strip()\nsys.stdout.write(" ".join(map(str,ans))+"\n")\n'''\ninf = 100000000000000000  # 1e17\nmod = 998244353\n\nn, m = list(map(int, input().split()))\nA = [0] + sorted(list(map(int, input().split())))\n\nans = 0\n\nf = [[0] * (n + 10) for _ in range(m + 10)]\n\nfor x in range(1,(A[n] - A[1]) // (m - 1) + 1):\n    for i in range(1, n + 1):\n        f[1][i] = 1\n    for i in range(2, m + 1):\n        sum = 0\n        pre = 1\n        for j in range(1, n + 1):\n            while pre <= n and A[pre] + x <= A[j]:\n                sum += f[i - 1][pre]\n                sum %= mod\n                pre += 1\n            f[i][j] = sum\n    for i in range(1, n + 1):\n        ans += f[m][i]\n        ans %= mod\nprint(ans)\n\n\n# the end\n
def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\n\nn, k = mi()\na = li()\ns = input().strip()\n\nans = 0\ni = 0\nwhile i < n:\n    j = i + 1\n    while j < n and s[j] == s[i]:\n        j += 1\n    b = sorted(a[i:j])\n    ans += sum(b[-k:])\n    i = j\nprint(ans)\n
def main():\n    n = int(input())\n    teams = [input().split() for _ in range(n)]\n    ans = [list((0, 0)) for _ in range(n)]\n    home = dict()\n\n    for i in range(n):\n        home[teams[i][0]] = home.get(teams[i][0], 0) + 1\n\n    for i in range(n):\n        ans[i][0] = n - 1 + home.get(teams[i][1], 0)\n        ans[i][1] = n - 1 - home.get(teams[i][1], 0)\n\n    for i in range(n):\n        ans[i] = '{} {}'.format(ans[i][0], ans[i][1])\n\n    print('\n'.join(ans))\n\ndef __starting_point():\n    main()\n__starting_point()
from collections import deque\n\nn, b = map(int, input().split())\n\nq = deque()\nfor _ in range(n):\n    t, d = map(int, input().split())\n    while q and q[0] <= t:\n        q.popleft()\n    if len(q) == b + 1:\n        print(-1, end = ' ')\n    else:\n        if q:\n            t = q[-1]\n        print(t + d, end = ' ')\n        q.append(t + d)\n
d, n, t = 0, int(input()), list(map(int, input().split()))\np = {a: 0 for a in set(t)}\nfor i in range(n):\n    a = t[i]\n    if not a in p: continue\n    p.pop(a)\n    s = t.count(a) - 1\n    if 2 * s < d: continue\n    if s > d: d = s\n    k = i + 1\n    for j in range(k, n):\n        if t[j] == a:\n            for b in set(t[k: j]):\n                if b in p: p[b] += 2\n            k = j + 1\n    for b in set(t[k: n]):\n        if b in p: p[b] += 1\n    for b in p:\n        if p[b] > d: d = p[b]\n        p[b] = 0\nprint(d + 1)
from sys import stdin\nfrom bisect import bisect_left\ndef read_bit(tree, idx):\n    s = 0\n    while idx > 0:\n        s += tree[idx]\n        idx -= (idx & -idx)\n    return s\ndef update_bit(tree, idx, val):\n    while idx < len(tree):\n        tree[idx] += val\n        idx += (idx & -idx)\n\nn,t=list(map(int,stdin.readline().split()))\na=[int(x) for x in stdin.readline().split()]\npref=[0]*n\npref[0]=a[0]\nfor i in range(1,n):\n    pref[i]=pref[i-1]+a[i]\npref.sort()\nbefore=ans=0\ntree=[0]*(n+2)\nfor i in range(n):\n    ind = bisect_left(pref, t + before)\n    if ind>0:\n        ans += ind-read_bit(tree, ind)\n    before += a[i]\n    before_ind=bisect_left(pref, before)\n    update_bit(tree, before_ind+1, 1)\nprint(ans)\n
input()\nprint(''.join(str(len(x)) for x in input().split('0')))\n
def binary(n):\n    curr=0\n    while(n>0):\n        if(n%2):\n            curr+=1\n        n=n//2\n    return curr\nl=input().split()\nn=int(l[0])\nk=int(l[1])\nl=input().split()\nli=[int(i) for i in l]\narr=[]\nfor i in range(2**15):\n    if(binary(i)==k):\n        arr.append(i)\nhashi=dict()\nfor i in li:\n    if i in hashi:\n        hashi[i]+=1\n    else:\n        hashi[i]=1\ncount=0\nfor i in hashi:\n    for j in arr:\n        if((i^j) in hashi):\n            if((i^j)==i):\n                count=count+(hashi[i]*(hashi[i]-1))\n            else:\n                count=count+(hashi[i]*hashi[i^j])\nprint(count//2)
n = input().rstrip()\nm = input().rstrip()\ncnt1 = [0] * 26\ncnt2 = [0] * 26\nfor i in n:\n    cnt1[ord(i) - ord("a")] += 1\nfor i in m:\n    cnt2[ord(i) - ord("a")] += 1\nres = 0\nfor i in range(26):\n    a1 = cnt1[i]\n    a2 = cnt2[i]\n    if a1 == 0 and a2 != 0:\n        print(-1)\n        return\n    res += min(a1, a2)\nprint(res)
read = lambda: map(int, input().split())\nn, k = read()\na = list(read())\nb = list(read())\nc = [(a[i], b[i]) for i in range(n)]\nc.sort(key = lambda x: x[0] - x[1])\nans = sum(c[i][0] for i in range(k))\nfor i in range(k, n):\n    ans += min(c[i][0], c[i][1])\nprint(ans)
from sys import stdin, stdout, exit\n\nmod = 998244353\n\nn = int(stdin.readline())\na = list(map(int, stdin.readline().split()))\n\nans = 0\n\ndef l(x):\n    if x == 0:\n        return 0\n    return 1 + l(x//10)\n\nlens = [0]*15\nfor x in a:\n    lens[l(x)] += 1\n\ndef space_out(x, l):\n    ans = []\n    for i,c in enumerate(reversed(str(x))):\n        ans.append(c)\n        if i < l:\n            ans.append("0")\n    return int(''.join(reversed(ans))) \n\nfor i in range(n):\n    x = a[i]\n    cur_head = x//10\n    cur = x\n    prev = x\n    for l in range(11):\n#        print(cur, cur_head)\n        if l > 0:\n            ans += lens[l]*(cur+10*prev)#space_out(x,l)\n            ans %= mod\n        prev = cur\n        cur -= cur_head*10**(2*l+1)\n        cur += cur_head*10**(2*l+2)\n        cur_head //=10\n\n\nstdout.write(str(ans) + "\n")\n
import math\n\n\nclass CodeforcesTask1147BSolution:\n    def __init__(self):\n        self.result = ''\n        self.n_m = []\n        self.points = []\n\n    def read_input(self):\n        self.n_m = [int(x) for x in input().split(" ")]\n        for x in range(self.n_m[1]):\n            self.points.append([int(y) for y in input().split(" ")])\n\n    def process_task(self):\n        can = False\n        segm = {}\n        for point in self.points:\n            segm["{0}_{1}".format(*point)] = True\n            segm["{1}_{0}".format(*point)] = True\n        for k in range(1, self.n_m[0]):\n            if not self.n_m[0] % k:\n                #print(k)\n                do = True\n                for p in self.points:\n                    a, b = (p[0] + k) % self.n_m[0], (p[1] + k) % self.n_m[0]\n                    if not a:\n                        a = self.n_m[0]\n                    if not b:\n                        b = self.n_m[0]\n                    if not "{0}_{1}".format(a, b) in segm:\n                        do = False\n                        break\n                if do:\n                    can = do\n                    break\n        self.result = "Yes" if can else "No"\n\n    def get_result(self):\n        return self.result\n\n\ndef __starting_point():\n    Solution = CodeforcesTask1147BSolution()\n    Solution.read_input()\n    Solution.process_task()\n    print(Solution.get_result())\n\n__starting_point()
def mask(n):\n  if not n: return 0;\n  m = 1\n  while not (m & n):\n    m *= 2\n  return m\n  \nn, T = list(map(int, input().split()))\nfor t in range(T):\n  cur = int(input())\n  for ch in input():\n    m = mask(cur)\n    #print(ch, ":", m, cur, "->", end = " ")\n    if ch == "U":\n      next = (cur - m) | (m * 2)\n      if next < n: cur = next\n    elif ch == "L" and m > 1:\n      cur -= m//2\n    elif ch == "R" and m > 1:\n      cur += m//2\n    #print(cur)\n  print(cur)  \n
import math\nimport re\nfrom fractions import Fraction\nfrom collections import Counter\n\nclass Task:\n    ips = []\n    k = 0\n    answer = ''\n    \n    def __init__(self):\n        n, self.k = [int(x) for x in input().split()]\n        self.ips = ['' for _ in range(n)]\n        for i in range(len(self.ips)):\n            self.ips[i] = input()\n\n    def solve(self):\n        ips, k = self.ips, self.k\n        ipAsNumbers = []\n        for currentIp in ips:\n            number = 0\n            parts = currentIp.split('.')\n            for i in range(0, len(parts)):\n                number += int(parts[i]) * 2**(32 - (i + 1) * 8)\n            ipAsNumbers += [number]\n\n        mask = 0\n        for i in range(31, -1, -1):\n            mask += 2**i\n            netAddresses = set()\n            for ip in ipAsNumbers:\n                netAddresses.add(mask & ip)\n            if len(netAddresses) == k:\n                mask = bin(mask)[2:]\n                self.answer = '.'.join([str(int(mask[i : i + 8], 2)) \\n                    for i in range(0, len(mask), 8)])\n                return\n        self.answer = '-1'\n\n\n    def printAnswer(self):\n        print(self.answer)\n        #for line in self.answer:\n        #    print(line)\n\ntask = Task()\ntask.solve()\ntask.printAnswer()\n
input()\na = [int(x) for x in input().split()]\nb = min(a)\nprint(-1 if any(x % b for x in a) else b)\n
#TO MAKE THE PROGRAM FAST\n\n''' ----------------------------------------------------------------------------------------------------  '''\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\nfrom collections import deque\n''' ----------------------------------------------------------------------------------------------------  '''\n\n\n\n\n#FOR TAKING INPUTS\n\n''' ----------------------------------------------------------------------------------------------------  '''\ndef li():return [int(i) for i in input().rstrip('\n').split(' ')]\ndef val():return int(input().rstrip('\n'))\ndef st():return input().rstrip('\n')\ndef sttoli():return [int(i) for i in input().rstrip('\n')]\n''' ----------------------------------------------------------------------------------------------------  '''\n\n\n\n\n#MAIN PROGRAM\n\n''' ----------------------------------------------------------------------------------------------------  '''\n\nd = deque()\nn = val()\nl = li()\nj = x = 0\ncurrmax = -10000000000000\nans = []\nfor i in range(n):\n    while len(d) and d[0] < i:d.popleft()\n    currmax = l[d[0]%n] if len(d) else l[i]\n    while j<3*n:\n        currmax = max(currmax,l[j%n])\n        while len(d) and l[d[-1]%n] <= l[j%n]:d.pop()\n        d.append(j)\n        if currmax/2 > l[j%n]:\n            ans.append(j-i)\n            break\n        j += 1\n    if j == 3*n:\n        print(*([-1 for _______ in range(n)]))\n        return\nprint(*ans)\n\n\n\n\n\n''' ----------------------------------------------------------------------------------------------------  '''
#!/usr/bin/env python3\n\ndef main():\n    try:\n        while True:\n            n = int(input())\n            grid = [input() for i in range(n)]\n            for i, row in enumerate(grid):\n                if row[:2] == "OO":\n                    grid[i] = "++" + row[2:]\n                    break\n                elif row[-2:] == "OO":\n                    grid[i] = row[:-2] + "++"\n                    break\n            else:\n                print("NO")\n                continue\n\n            print("YES")\n            print('\n'.join(grid))\n\n    except EOFError:\n        pass\n\nmain()\n
rr = lambda: input().strip()\nrri = lambda: int(rr())\nrrm = lambda: list(map(int, rr().split()))\n\ndef solve(N, A):\n    ans = 0\n    prev = float('inf')\n    for x in reversed(A):\n        x = min(x, prev - 1)\n        ans += max(x, 0)\n        prev = x\n    return ans\n\nfor tc in range(1):#rri()):\n    N = rri()\n    A = rrm()\n    print(solve(N, A))\n
n, m = [int(i) for i in input().split()]\nif m > n//2:\n    m = n-m\nans = [1]\ncount = 0\nc = 1\nfor i in range(n):\n    count+=m\n    if count>n:\n        c+=1\n        count-=n\n        ans.append(ans[-1] +c)\n        c+=1\n    else:\n        ans.append(ans[-1] +c)\nans = ans[1:]\nprint(*ans)
s = input()\n\nans = 0\nfor i in range(1, len(s)):\n    if int(s[i - 1: i + 1]) % 4 == 0:\n        ans += i\nfor x in s:\n    if int(x) % 4 == 0:\n        ans += 1\n\nprint(ans)\n
from sys import stdin\n\n\ndef solve():\n    n = int(stdin.readline())\n    m = list(map(int, stdin.readline().split()))\n    msl = [-1] * n\n    msp = [n] * n\n    q = []\n    for i in range(n):\n        while q and m[q[-1]] > m[i]:\n            q.pop()\n        if q:\n            msl[i] = q[-1]\n        q.append(i)\n    q = []\n    for i in range(n - 1, -1, -1):\n        while q and m[q[-1]] > m[i]:\n            q.pop()\n        if q:\n            msp[i] = q[-1]\n        q.append(i)\n\n    dp1 = [0] * n\n    for i in range(n):\n        dp1[i] = m[i] * (i - msl[i])\n        if msl[i] != -1:\n            dp1[i] += dp1[msl[i]]\n    dp2 = [0] * n\n    for i in range(n - 1, -1, -1):\n        dp2[i] += m[i] * (msp[i] - i)\n        if msp[i] != n:\n            dp2[i] += dp2[msp[i]]\n    ansm = 0\n    answc = 0\n    for i in range(n):\n        cur = dp1[i] + dp2[i] - m[i]\n        if cur > answc:\n            answc = cur\n            ansm = i\n    i = ansm\n    cur = [0] * n\n    cur[i] = m[i]\n    for j in range(i + 1, n):\n        cur[j] = min(cur[j - 1], m[j])\n    for j in range(i - 1, -1, -1):\n        cur[j] = min(cur[j + 1], m[j])\n    print(*cur)\n\n\nfor i in range(1):\n    solve()\n
import sys\nn,m,s,f=list(map(int,sys.stdin.readline().split()))\nL=[]\nR=[]\nT=[]\nfor i in range(m):\n    t,l,r=list(map(int,sys.stdin.readline().split()))\n    T.append(t)\n    L.append(l)\n    R.append(r)\n\nif(f>s):\n    i=s\n    step=1\n    ind=0\n    Ans=""\n    while(i!=f):\n        if(ind>=m or T[ind]!=step):\n            Ans+="R"\n            i+=1\n        else:\n            if((i>=L[ind] and i<=R[ind]) or (i+1>=L[ind] and i+1<=R[ind])):\n                Ans+="X"\n            else:\n                Ans+="R"\n                i+=1\n            ind+=1\n        step+=1\nelse:\n    i=s\n    step=1\n    ind=0\n    Ans=""\n    while(i!=f):\n        if(ind>=m or T[ind]!=step):\n            Ans+="L"\n            i-=1\n        else:\n            if((i>=L[ind] and i<=R[ind]) or (i-1>=L[ind] and i-1<=R[ind])):\n                Ans+="X"\n            else:\n                Ans+="L"\n                i-=1\n            ind+=1\n        step+=1\nsys.stdout.write(Ans+"\n")\n
from collections import Counter\nn, m = map(int, input().split())\nl = [input() for _ in range(n)]\nv = [*map(int, input().split())]\nres = 0\nfor i in range(m):\n    res += v[i] * max(Counter(s[i] for s in l).values())\nprint(res)
import sys\nfrom collections import Counter\nfrom operator import itemgetter\nfrom heapq import heappop, heappush\n\nn, m, k = list(map(int, input().split()))\npoints = [list(map(int, line.split())) for line in sys.stdin]\npts_sorted_x = sorted(points)\npts_sorted_y = sorted(points, key=itemgetter(1, 0))\ninf = 10**9+1\nOK = (inf, inf)\n\n\ndef solve2(imos, t):\n    acc, cur = 0, 0\n\n    for k in sorted(imos.keys()):\n        if t < k:\n            break\n        if acc <= 0 and cur+1 < k or acc + imos[k] <= 0:\n            acc = 0\n            break\n        acc += imos[k]\n\n    return acc <= 0\n\n\ndef add_imos(imos, x, y):\n    imos[x] += y\n    if imos[x] == 0:\n        del imos[x]\n\n\ndef solve(t, px=-1, py=-1):\n    set_x = {1, n}\n    set_y = {1, m}\n\n    for x, y in points:\n        set_x.update((max(1, x-t), max(1, x-t-1), min(n, x+t), min(n, x+t+1)))\n        set_y.update((max(1, y-t), max(1, y-t-1), min(m, y+t), min(m, y+t+1)))\n\n    ans_x = ans_y = inf\n    pi, imos, hq = 0, Counter(), []\n    if px != -1:\n        imos[py] += 1\n        imos[py+t*2+1] -= 1\n\n    for cx in sorted(set_x):\n        while hq and hq[0][0] < cx:\n            add_imos(imos, hq[0][1], -1)\n            add_imos(imos, hq[0][2], +1)\n            heappop(hq)\n        while pi < k and pts_sorted_x[pi][0]-t <= cx <= pts_sorted_x[pi][0]+t:\n            x, y = pts_sorted_x[pi]\n            add_imos(imos, max(1, y-t), 1)\n            add_imos(imos, y+t+1, -1)\n            heappush(hq, (x+t, max(1, y-t), y+t+1))\n            pi += 1\n\n        if solve2(imos, m):\n            ans_x = cx\n            break\n\n    pi = 0\n    imos.clear()\n    hq.clear()\n    if px != -1:\n        imos[px] += 1\n        imos[px+t*2+1] -= 1\n\n    for cy in sorted(set_y):\n        while hq and hq[0][0] < cy:\n            add_imos(imos, hq[0][1], -1)\n            add_imos(imos, hq[0][2], +1)\n            heappop(hq)\n        while pi < k and pts_sorted_y[pi][1]-t <= cy <= pts_sorted_y[pi][1]+t:\n            x, y = pts_sorted_y[pi]\n            add_imos(imos, max(1, x-t), 1)\n            add_imos(imos, x+t+1, -1)\n            heappush(hq, (y+t, max(1, x-t), x+t+1))\n            pi += 1\n\n        if solve2(imos, n):\n            ans_y = cy\n            break\n\n    return ans_x, ans_y\n\n\nok, ng = 10**9+1, -1\nwhile abs(ok - ng) > 1:\n    mid = (ok + ng) >> 1\n    p = solve(mid)\n    if p == OK:\n        ok = mid\n        continue\n\n    if solve(mid, p[0], p[1]) == OK:\n        ok = mid\n    else:\n        ng = mid\n\nprint(ok)\n
#!/usr/bin/env python\n\nimport sys\n\nsys.setrecursionlimit(10000)\n\nn, m = list(map(int, input().split(' ')))\n\ndef neighbors(i, j):\n    return [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]\n\ndef valid(i, j):\n    nonlocal n, m\n    if i < 0 or i >= n or j < 0 or j >= m:\n        return False\n    return True\n\ndef dfs(f, i, j):\n    color = f[i][j]\n    f[i][j] = color.lower()\n    c = 0\n    for n, m in neighbors(i, j):\n        if valid(n, m):\n            if f[n][m] == color:\n                cycle_found = dfs(f, n, m)\n                if cycle_found:\n                    return True\n            elif f[n][m] == color.lower():\n                c += 1\n    if c > 1:\n        return True\n\n    f[i][j] = None\n\n    return False\n\nf = []\nfor i in range(n):\n    f.append(list(input().strip()))\n\nfor i in range(n):\n    for j in range(m):\n        if f[i][j]:\n            cycle_found = dfs(f, i, j)\n            if cycle_found:\n                print("Yes")\n                return\n\nprint("No")\n
"""\nCodeforces Contest 270 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef main():\n    n,k = read()\n    a = [i-1 for i in read()]\n    a.sort()\n    a.reverse()\n    print(sum(a[::k])*2)\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
"""\nCodeforces Round 241 Div 1 Problem E\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\nclass InputHandlerObject(object):\n    inputs = []\n\n    def getInput(self, n = 0):\n        res = ""\n        inputs = self.inputs\n        if not inputs: inputs.extend(input().split(" "))\n        if n == 0:\n            res = inputs[:]\n            inputs[:] = []\n        while n > len(inputs):\n            inputs.extend(input().split(" "))\n        if n > 0:\n            res = inputs[:n]\n            inputs[:n] = []\n        return res\nInputHandler = InputHandlerObject()\ng = InputHandler.getInput\n\n############################## SOLUTION ##############################\nn,m = [int(x) for x in g()]\n\ndef sqr(n):\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [4,3]\n    if n % 2:\n        return [(n+1)//2, 2] + [1] * (n-2)\n    return [(n-2)//2] + [1] * (n-1)\n\na = sqr(n)\nb = sqr(m)\nfor i in range(n):\n    res = [str(a[i]*x) for x in b]\n    print(" ".join(res))
n = int( input() )\ns = input()\nd = 0\nl = []\nfor c in s:\n    if c == '(':\n        l.append(d)\n        d ^= 1\n    else:\n        d ^= 1\n        l.append( d )\n\nprint( "".join( [ str(i) for i in l ]))\n
n, m = map(int, input().split())\n\na = {}\nfor i in range(n):\n    x, y = input().split()\n    a[y] = x\n    \nfor i in range(m):\n    x, y = input().split()\n    \n    print(x, y, "#" + a[y.replace(';', '')])
n=int(input())\na=[list(map(int,input().split())) for i in range(n)]\nsolved=[0 for i in range(5)]\nscore=[0 for i in range(5)]\nfor i in range(n):\n	for j in range(5):\n		solved[j]+=int(a[i][j]>-1)\nfor k in range(31*n+1):\n	for i in range(5):\n		tot=n+k\n		cur=solved[i]\n		if a[0][i]>-1 and a[1][i]>-1 and a[0][i]>a[1][i]:\n			cur+=k\n		score[i]=500\n		while score[i]<3000 and 2*cur<=tot:\n			cur*=2;\n			score[i]+=500\n	res=[0,0]\n	for j in range(2):\n		for i in range(5):\n			if a[j][i]>-1:\n				res[j]+=score[i]/250*(250-a[j][i])\n	if res[0]>res[1]:\n		print(k)\n		return\nprint("-1")
n = int(input())\n\nfrom collections import defaultdict\n\nfirst = defaultdict(int)\nsecond = defaultdict(int)\nfor _ in range(n):\n    s = input().strip()\n    count = 0\n    min_count = 0\n    for c in s:\n        if c == '(': count += 1\n        else: count -= 1\n        min_count = min(count, min_count)\n    if min_count >= 0: first[count] += 1\n    if count == min_count: second[count] += 1\n\nres = 0\nfor k, v in list(first.items()):\n    res += v * second[-k]\n\nprint(res)\n
class Solution:\n    def __init__(self):\n        self.n, self.k = list(map(int, input().split()))\n        self.s = [input() for i in range(0, self.n)]\n        self.state = [\n            (119, 6),\n            (36, 2),\n            (93, 5),\n            (109, 5),\n            (46, 4),\n            (107, 5),\n            (123, 6),\n            (37, 3),\n            (127, 7),\n            (111, 6),\n        ]\n        self.p = []\n        self.dp = [[False for j in range(0, self.k + 1)] for i in range(0, self.n)]\n\n    def solve(self):\n        for a in self.s:\n            state = int(a[::-1], 2)\n            stick = a.count("1")\n            v = []\n            for i, (dState, dStick) in enumerate(self.state):\n                if dState & state == state:\n                    v.append((i, dStick - stick))\n            self.p.append(v)\n\n        for i in range(self.n - 1, -1, -1):\n            for j, stick in self.p[i]:\n                if i == self.n - 1:\n                    if stick <= self.k:\n                        self.dp[i][stick] = True\n                else:\n                    for d in range(stick, self.k + 1):\n                        self.dp[i][d] |= self.dp[i + 1][d - stick]\n        if not self.dp[0][self.k]:\n            return "-1"\n\n        result = ""\n\n        for i, v in enumerate(self.p):\n            for j, stick in v[::-1]:\n                ok = (self.k == stick) if i == self.n - 1 else (self.k >= stick and self.dp[i + 1][self.k - stick])\n                if ok:\n                    self.k -= stick\n                    result += str(j)\n                    break\n        return result\n            \n\nprint(Solution().solve())\n\n
N = int(input())\n\nS = list(map(int,input().split()))[::-1]\n\nprint(min(N - S.index(0), N - S.index(1)))
n = len(input())\nprint(3)\nprint("R", n-1)\nprint("L", n)\nprint("L", 2)\n
n = int(input())\nnums = (abs(int(x)) for x in input().split())\nnums = list(sorted(nums))\nleft = 0\nright = 0\nans = 0\nwhile left < n:\n    while right < n and nums[right] <= 2 * nums[left]:\n        right += 1\n    ans += right - left - 1\n    left += 1\nprint(ans)
n, m = map(int, input().split())\na = list(map(int, input().split()))\nc = list(map(int, input().split()))\nmc = sorted(((y, x) for x, y in enumerate(c)), reverse=True)\nfor _ in range(m):\n    t, d = map(int, input().split())\n    t -= 1\n    if a[t] >= d:\n        print(c[t] * d)\n        a[t] -= d\n    else:\n        x = a[t] * c[t]\n        d -= a[t]\n        a[t] = 0\n        while d:\n            if not mc:\n                print(0)\n                break\n            cost, index = mc[-1]\n            if a[index] >= d:\n                x += cost * d\n                a[index] -= d\n                d = 0\n            else:\n                x += cost * a[index]\n                d -= a[index]\n                a[index] = 0\n            if a[index] == 0:\n                mc.pop()\n        else:\n            print(x)
INF = 10 ** 18\nMX_SZ = 112\ndp = [[[INF for k in range (MX_SZ)] for j in range (MX_SZ)] for i in range (MX_SZ)]\nbest = [[[(INF, INF) for k in range (MX_SZ)] for j in range (MX_SZ)] for i in range (MX_SZ)]\n\ndef read():\n    return [int(x) for x in input().split()]\n\nn, m, k_res = read()\narr = read()\ncost = []\nfor i in range (n):\n    cost.append(read())\ndp[0][0][MX_SZ - 1] = 0 #[trees painted][group amount][last color]\nbest[0][0][0] = (0, MX_SZ - 1)\n#print(best[0][0][0][1])\n#return\nfor i in range (1, n + 1):\n    clr = arr[i - 1]\n    if clr == 0:\n        for j in range (1, k_res + 1):\n            for k in range (1, m + 1):\n                dp[i][j][k] = dp[i - 1][j][k] + cost[i - 1][k - 1]\n                if k == best[i - 1][j - 1][0][1]:\n                    dp[i][j][k] = min(dp[i][j][k], best[i - 1][j - 1][1][0] + cost[i - 1][k - 1])\n                else:\n                    dp[i][j][k] = min(dp[i][j][k], best[i - 1][j - 1][0][0] + cost[i - 1][k - 1])\n                if dp[i][j][k] < best[i][j][0][0]:\n                    best[i][j][1] = best[i][j][0]\n                    best[i][j][0] = (dp[i][j][k], k)\n                elif dp[i][j][k] < best[i][j][1][0]:\n                    best[i][j][1] = (dp[i][j][k], k)\n    else:\n        for j in range (1, n + 1):\n            dp[i][j][clr] = dp[i - 1][j][clr]\n            if clr == best[i - 1][j - 1][0][1]:\n                dp[i][j][clr] = min(dp[i][j][clr], best[i - 1][j - 1][1][0])\n            else:\n                dp[i][j][clr] = min(dp[i][j][clr], best[i - 1][j - 1][0][0])\n            best[i][j][0] = (dp[i][j][clr], clr)\nans = INF\nfor k in range (1, m + 1):\n    if dp[n][k_res][k] < ans:\n        ans = dp[n][k_res][k]\nif ans == INF:\n    ans = -1\nprint(ans)\n\n\n\n
#!/usr/bin/env python3\n\n[n, k] = list(map(int, input().strip().split()))\nais = list(map(int, input().strip().split()))\n\nn1 = ais.count(1)\n\none_serie = [0 for _ in range(n)]\nfor i in reversed(list(range(n))):\n	if ais[i] == 1:\n		one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n\n\nn1_head = 0\ncount = 0\n\nfor i in range(n):\n	p = 1\n	s = 0\n	if i > 0 and ais[i - 1] == 1:\n		n1_head += 1\n	n1_tail = n1 - n1_head\n	j = i\n	while j < n:\n		if ais[j] == 1:\n			if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n				count += 1\n			n1_tail -= one_serie[j]\n			s += one_serie[j]\n			j += one_serie[j]\n		else:\n			p *= ais[j]\n			s += ais[j]\n			if p == s * k:\n				count += 1\n			elif p > (s + n1_tail) * k:\n				break\n			j += 1\n\nprint (count)\n
import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nmod=998244353\n\nFACT=[1]\nfor i in range(1,2*10**5+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(2*10**5,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\ndef Combi(a,b):\n    if 0<=b<=a:\n        return FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n    else:\n        return 0\n\nif n==2:\n    print(0)\nelse:\n    print(Combi(m,n-1)*(n-2)*pow(2,n-3,mod)%mod)\n
from fractions import gcd\n\nn, x, y = map(int, input().split())\ng = gcd(x, y)\nx //= g\ny //= g\n\na = sorted([y * i for i in range(1, x)] + [x * i for i in range(1, y)])\n\ndef f(n):\n    n %= x + y\n    if n == 0 or n == x + y - 1:\n        return "Both"\n    return "Vova" if a[n - 1] % x == 0 else "Vanya"\n\nfor _ in range(n):\n    print(f(int(input())))
rd = lambda: list(map(int, input().split()))\n\nn, s, t = rd()\np = rd()\nfor i in range(n):\n  if s == t : print(i); return\n  s = p[s-1]\nprint(-1)
n, k = map(int, input().split())\nA = [i for i in range(2*n, 0, -1)]\nfor i in range(k):\n    if i > n:\n        i %= n\n    A[2*i], A[2*i + 1] = A[2*i + 1], A[2*i]\nprint(' '.join(map(str, A)))
from bisect import bisect_left\n\nA, B, Q = map(int, input().split())\nS = [int(input()) for _ in range(A)]\nT = [int(input()) for _ in range(B)]\n\nx = []\nfor s in S:\n    idx = bisect_left(T, s)\n    if idx == 0:\n        x.append(abs(s-T[0]))\n    elif idx == B:\n        x.append(abs(s-T[-1]))\n    else:\n        x.append(min(abs(s-T[idx]), abs(s-T[idx-1])))\n\ny = []\nfor t in T:\n    idx = bisect_left(S, t)\n    if idx == 0:\n        y.append(abs(t-S[0]))\n    elif idx == A:\n        y.append(abs(t-S[-1]))\n    else:\n        y.append(min(abs(t-S[idx]), abs(t-S[idx-1])))\n\nfor _ in range(Q):\n    X = int(input())\n\n    sa = 0\n    si = bisect_left(S, X)\n\n    if si == 0:\n        sa = x[0]+abs(S[0]-X)\n    elif si == A:\n        sa = x[-1]+abs(S[-1]-X)\n    else:\n        sa = min(x[si]+abs(S[si]-X), x[si-1]+abs(S[si-1]-X))\n\n    ti = bisect_left(T, X)\n\n    if ti == 0:\n        ta = y[0]+abs(T[0]-X)\n    elif ti == B:\n        ta = y[-1]+abs(T[-1]-X)\n    else:\n        ta = min(y[ti]+abs(T[ti]-X), y[ti-1]+abs(T[ti-1]-X))\n    \n    print(min(sa, ta))
N, M, Q = list(map(int, input().split()))\n\ntable = [[0 for _ in range(N+1)] for _ in range(N+1)]\nfor _ in range(M):\n    L, R = list(map(int, input().split()))\n    table[L][R] += 1\n\nfor i in range(N+1):\n    for j in range(N):\n        table[i][j+1] += table[i][j]\nfor i in range(N):\n    for j in range(N+1):\n        table[i+1][j] += table[i][j]\n\nfor _ in range(Q):\n    p, q = list(map(int, input().split()))\n    print((table[q][q] - table[q][p-1] - table[p-1][q] + table[p-1][p-1]))\n\n
import math\nfrom functools import reduce\nN = int(input())\n\ndef lcm_base(x, y):\n    return (x * y) // math.gcd(x, y)\n\ndef lcm(*numbers):\n    return reduce(lcm_base, numbers, 1)\n\nA = []\nfor i in range(2, N+1):\n    A.append(i)\n\nX = lcm(*A) + 1\nprint(X)\n
N, K = map(int,input().split())\nA = list(map(int,input().split()))\n\nif N == K:\n  print(1)\nelse:\n  ans = 1\n  N -= K\n  while N > 0:\n    ans += 1\n    N -= (K-1)\n  print(ans)
n = int(input())\nmod = 10**9+7\na = []\nl = ["A","C","G","T"]\nban = ["AAGC","CAGC","GAGC","TAGC","AGCA","AGCC","AGCG","AGCT","AGAC","CGAC","GGAC","TGAC","GACA","GACC","GACG","GACT","AACG","CACG","GACG","TACG","ACGA","ACGC","ACGG","ACGT","ATGC","ACGC","AGGC","AGTC","AGGC","AGAC"]\nfor i in l:\n    for j in l:\n        for k in l:\n            a.append(i+j+k)\ndp = [[0]*64 for _ in range(n+1)]\nfor i in range(64):\n    if (a[i]=="AGC" or a[i]=="ACG" or a[i]=="GAC"):\n        continue\n    dp[3][i] = 1\nfor i in range(4,n+1):\n    for j in range(64):\n        for k in l:\n            b = a[j]+k\n            if b in ban:\n                continue\n            else:\n                dp[i][a.index(b[1:])] += dp[i-1][j]\n                dp[i][a.index(b[1:])] %= mod\nprint((sum(dp[-1])%mod))\n        \n
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**15\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n,m,k = LI()\n    a = [[-1] * (m+2)]\n    a += [[-1] + [inf if c=='.' else -1 for c in S()] + [-1] for _ in range(n)]\n    a += [[-1] * (m+2)]\n    x1,y1,x2,y2 = LI()\n    a[x1][y1] = 0\n    q = [(x1,y1)]\n    qi = 0\n    dy = [-1,1,0,0]\n    dx = [0,0,-1,1]\n    while qi < len(q):\n        x,y = q[qi]\n        qi += 1\n        nd = a[x][y] + 1\n        for di in range(4):\n            for j in range(1,k+1):\n                ny = y + dy[di] * j\n                nx = x + dx[di] * j\n                if a[nx][ny] > nd:\n                    if ny == y2 and nx == x2:\n                        return nd\n                    a[nx][ny] = nd\n                    q.append((nx,ny))\n                elif a[nx][ny] < nd:\n                    break\n\n    if a[x2][y2] < inf:\n        return a[x2][y2]\n    return -1\n\n\nprint(main())\n\n\n
class BIT():\n    def __init__(self,n):\n        self.BIT=[0]*(n+1)\n        self.num=n\n\n    def query(self,idx):\n        res_sum = 0\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        while idx <= self.num:\n            self.BIT[idx] += x\n            idx += idx&(-idx)\n        return\n\nal = [chr(97+i) for i in range(26)]\n\nn = int(input())\ns = input()\ns = [s[i] for i in range(n)]\ngoal = s[::-1]\n\ndic = {a:[] for a in al}\n\nfor i in range(n):\n    dic[goal[i]].append(i)\n\nfor a in dic:\n    dic[a] = dic[a][::-1]\n\nseq = [-1 for i in range(n)]\nfor i in range(n):\n    seq[i] = dic[s[i]].pop() + 1\n\nres = 0\nbit = BIT(n)\nfor i in range(n):\n    res += i - bit.query(seq[i])\n    bit.update(seq[i],1)\n\nprint(res)\n
n = int(input())\na = [0] * 27\nfor i in range(n):\n	s = input()\n	a[ord(s[0]) - ord('a')] += 1\nans = 0\nfor i in range(26):\n	t = a[i] // 2\n	k = a[i] - t\n	ans += t * (t - 1) // 2\n	ans += k * (k - 1) // 2\nprint(ans)\n
def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn = ii()\nif n < 6:\n    print(-1)\nelse:\n    t = ['1 2', '1 3', '1 4', '2 5', '2 6']\n    for i in range(7, n + 1):\n        t.append('1 ' + str(i))\n    print('\n'.join(t))\nt = []\nfor i in range(2, n + 1):\n    t.append('1 ' + str(i))\nprint('\n'.join(t))
n = int(input())\na = list(map(int, input().split()))\nk = input()\npref = [a[0]]\nfor i in range(1, n):\n    pref.append(pref[-1] + a[i])\ncur = 0\nans = 0\nfor i in range(n - 1, -1, -1):\n    if k[i] == '0':\n        continue\n    if cur + (pref[i - 1] if i > 0 else 0) > ans:\n        ans = cur + (pref[i - 1] if i > 0 else 0)\n    cur += a[i]\ncur = 0\nfor i in range(n):\n    if k[i] == '1':\n        cur += a[i]\nans = max(ans, cur)\nprint(ans)\n
import re\nimport itertools\nfrom collections import Counter, deque\n\nclass Task:\n    a = []\n    d = 0\n    answer = 0\n	\n    def getData(self):\n        n, m, self.d = [int(x) for x in input().split(' ')]\n        for _ in range(n):\n            self.a += [int(x) for x in input().split(' ')]\n        #inFile = open('input.txt', 'r')\n        #inFile.readline().rstrip()\n        #self.childs = inFile.readline().rstrip()\n\n    def solve(self):\n        a = self.a\n\n        for x in a:\n            if x % self.d != a[0] % self.d:\n                self.answer = -1\n                return\n        \n        a = [x // self.d for x in a]\n        a.sort()\n        \n        d = [sum(a)] + [0 for _ in range(1, a[-1] + 1)]\n        \n        lessCurrentLevel = 0\n        counter = Counter(a)\n        \n        for level in range(1, a[-1] + 1):\n            lessCurrentLevel += counter[level - 1]\n            d[level] = d[level - 1] + lessCurrentLevel - \\n                    (len(a) - lessCurrentLevel)\n        self.answer = min(d)\n\n    def solve2(self):\n        a, d = self.a, self.d\n        for i in range(1, len(a)):\n            if a[i] % d != a[0] % d:\n                self.answer = -1\n                return\n        a = [x // d for x in a]\n        d = [abs(a[0] - i) for i in range(10000 + 1)]\n        for i in range(1, len(a)):\n            for j in range(0, len(d)):\n                d[j] += abs(a[i] - j)\n        self.answer = min(d)\n\n    def printAnswer(self):\n        print(self.answer)\n        #print(re.sub('[\[\],]', '', str(self.answer)))\n        #outFile = open('output.txt', 'w')\n        #outFile.write(self.answer)\n\ntask = Task()\ntask.getData()\ntask.solve()\ntask.printAnswer()\n
R=lambda:list(map(int,input().split()))\nn,t=R()\na=R()\nfor i in range(n):\n  t-=86400-a[i]\n  if t<1:\n    print(i+1)\n    return\n
n = int(input())\np = -float("INF")\nans = 1\nA = []\nfor i in range(n) :\n    x, h = list(map(int, input().split()))\n    A.append([x,h])\nfor i in range(n-1) :\n    x, h = A[i]\n    if x-h > p :\n        ans += 1\n        p = x\n    elif x+h < A[i+1][0] :\n        ans += 1\n        p = x+h\n    else :\n        p = x\nprint(ans)\n
\n\nn = int(input())\n\nT = [int(x) for x in input().split()]\n\nC = [int(x) for x in input().split()]\n\nT_inv = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    T_inv[T[i] - 1] += [i + 1]\n\nresult = 1\n\n#for i in range(n):\n#    print(T_inv[i])\n\nfor i in range(n):\n    for child in T_inv[i]:\n        if C[i] != C[child]:\n            result += 1\n\nprint(result)\n
n, q = list(map(int, input().split()))\ns = input()\nfor _ in range(q):\n    l, r = list(map(int, input().split()))\n    t = list(s[l-1:r])\n    p, d = 0, 1\n    res = [0] * 10\n    while 0 <= p < len(t):\n        if '0' <= t[p] <= '9':\n            k = int(t[p])\n            res[k] += 1\n            if k > 0:\n                t[p] = str(k-1)\n                p += d\n            else:\n                t.pop(p)\n                if d == -1:\n                    p += d\n        else:\n            d = -1 if t[p] == '<' else 1\n            if 0 <= p+d < len(t) and not ('0' <= t[p+d] <= '9'):\n                t.pop(p)\n                if d == -1:\n                    p += d\n            else:\n                p += d\n    print(*res)\n
def f():\n    n, m, k = map(int, input().split())\n    p = [[] for i in range(n + 1)]\n    for i in range(m):\n        a, b = map(int, input().split())\n        p[a].append(b)\n        p[b].append(a)\n    t, r = [0] * (n + 1), [1]\n    x = t[1] = 1\n    i = 0 - k\n    while True:\n        for y in p[x]:\n            if t[y] == 2: return r[r.index(y): ]\n            if t[y]: continue\n            t[y], x = 1, y\n            r.append(x)\n            i += 1\n            if i >= 0: t[r[i]] = 2\n            break\nt = f()\nprint(len(t))\nprint(' '.join(map(str, t)))
n, m = list(map(int,input().split()))\n\nM = 10 ** 9 + 7\n\ndef inv(x):\n    return pow(x, M - 2, M)\n\ndef binomial(n, k):\n    if 0 <= k <= n:\n        ntok = 1\n        ktok = 1\n        for t in range(1, min(k, n - k) + 1):\n            ntok *= n\n            ktok *= t\n            n -= 1\n            ntok %= M\n            ktok %= M\n        return (ntok * inv(ktok))%M\n    else:\n        return 0\n\nprint(binomial(n+2*m-1, 2 * m))\n
n = int(input())\nl = [int(x) for x in input().split()]\nc = [int(x) for x in input().split()]\n\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ngcds = {0: 0}\n\nfor i in range(n):\n    adds = {}\n    for g in list(gcds.keys()):\n        x = gcd(g, l[i])\n        y = gcds.get(x)\n        u = gcds[g]\n        if y is not None:\n            if u + c[i] < y:\n                t = adds.get(x)\n                if t and t > u + c[i] or t is None:\n                    adds[x] = u + c[i]\n        else:\n            t = adds.get(x)\n            if t and t > u + c[i]or t is None:\n                adds[x] = u + c[i]\n    gcds.update(adds)\n\nif gcds.get(1):\n    print(gcds[1])\nelse:\n    print(-1)\n\n
from collections import defaultdict\nn, flower, bee = list(map(int, input().split()))\nroads = {}\nfor _ in range(n-1):\n    x, y = list(map(int, input().split()))\n    if x not in roads:\n        roads[x] = [y]\n    else:\n        roads[x].append(y)\n    if y not in roads:\n        roads[y] = [x]\n    else:\n        roads[y].append(x)\nflowers = defaultdict(int)\n\ndef dfs(bee, flower):\n    q = []\n    visited = set()\n    visited.add(flower)\n    last = -1\n    for y in roads[flower]:\n        if y == bee:\n            last = y\n            continue\n        q.append([y, y])\n    while q:\n        now = q.pop()\n        visited.add(now[0])\n        flowers[now[1]] += 1\n        for y in roads[now[0]]:\n            if y not in visited:\n                if y == bee:\n                    last = now[1]\n                    continue\n                q.append([y, now[1]])\n    return last\nrem = dfs(bee, flower)\nflower_total = sum(flowers.values())+1\nprint(n*(n-1)-(flower_total - flowers[rem])*(n-(flower_total)))
def rec(i):\n    nonlocal a\n    return i\nimport sys\nfrom collections import Counter\nsys.setrecursionlimit(10**6)\nn=int(input())\n#n,m=list(map(int,input().split()))\na=[input() for i in range(n)]\nb=[]\na0=set()\nc0=set()\nfor i in a:\n    c=set()\n    for i0 in range(1,10):\n        for i1 in range(0,10-i0):\n            c.add(i[i1:i1+i0])\n    b.append(c)\n    c0.update(a0&c)\n    a0.update(c)\n\nfor i in b:\n    c=i-c0\n    z='0'*10\n    for i0 in c:\n        if len(i0)<len(z):\n            z=i0\n    print(z)\n
s = input()\n\nl = []\nt = 0\n\nfor i in range(len(s)):\n    if len(l) > 0:\n        if s[i] == l[-1]:\n            l.pop()\n            t += 1\n        else:\n            l.append(s[i])\n    else:\n        l.append(s[i])\n\nif t % 2 == 0:\n    print("No")\nelse:\n    print("Yes")\n
\nl = 0\nr = -1\nsegL, time = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\nsegSum = 0\nsegments = []\n\n##while r < segL-1:	\n##    r += 1\n##    segSum += a[r]\n##    if segSum == time:\n##        segments.append(r+1-l)\n##    elif segSum > time:\n##        segments.append(r-l)\n##        while segSum > time or l < r:\n##            # Shifting l to the right\n##            # until reaching next suitable segment sum\n##            segSum -= a[l]\n##            l += 1\n##        #segments.append(r+1-l)\n##\n##[1,2,5,3,7,4,5]\n\nwhile r < segL-1:\n    r += 1\n    segSum += a[r]\n    if segSum == time:\n        segments.append(r+1-l)\n        segSum -= a[l]\n        l += 1\n    elif segSum > time:\n        segments.append(r-l)\n        while segSum >= time:\n            segSum -= a[l]\n            l += 1\nelse:\n    segments.append(r+1-l)\n\nprint(max(segments))\n
from collections import defaultdict\n\nn=int(input())\nd=defaultdict(dict)\nfor i in range(n):\n    x=input()\n    x=x.split()\n    if i==0:\n        P = x\n    q=int(input())\n    Con=[]\n    for j in range(q):\n        Con.append(input().split())\n    if i!=n-1:\n        input()\n    d[x[0]][x[1]]=Con\nver=[P]\nans={}\nwhile ver:\n    next_ans = {}\n    for v in ver:\n        C=d[v[0]][v[1]]\n        for n_v in C:\n            if n_v[0] not in ans and n_v[0]!=P[0]:\n                if n_v[0] in next_ans:\n                    if int(n_v[1])>int(next_ans[n_v[0]]):\n                        next_ans[n_v[0]]=n_v[1]\n                else:\n                    next_ans[n_v[0]]=n_v[1]\n    ans.update(next_ans)\n    ver=list(next_ans.items())\nl=list(ans.items())\nprint(len(l))\nl.sort()\nfor k,v in l:\n    print(k,v)\n
def prefix(s):\n    p = [0]\n    for i in range(1, len(s)):\n        j = p[-1]\n        while j > 0 and s[j] != s[i]:\n            j = p[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        p.append(j)\n    return p\n\n\ns = input()\nn = len(s)\nans = [0] * (n + 1)\ni = n - 1\n\nwhile i >= 0:\n    p = prefix(s[i:])\n    ans[i] = 2 + ans[i + 1]\n    for j in range(len(p)):\n        z = 1\n        if (j + 1) % (j + 1 - p[j]) == 0:\n            z = (j + 1) // (j + 1 - p[j])\n        res = len(str(z)) + (j + 1) // z + ans[i + j + 1]\n        ans[i] = min(ans[i], res)\n    i -= 1\n\nprint(ans[0])\n
n, x = map(int, input().split())\na = [int(x) for x in input().split()]\ndef solve(a, s):\n  #print (a)\n  a.append((-1, 0))\n  a.sort()\n  b = []\n  for i in range(1, len(a)):\n    if a[i][0] != a[i-1][0]:\n      b.append(a[i])\n    else:\n      b[-1] = (a[i][0], b[-1][1] + a[i][1])\n  for i in range(len(b)):\n    t = b[i][1]\n    cnt = 0\n    while t%x == 0:\n      t //= x\n      cnt += 1\n    b[i] = (b[i][0] + cnt, t)\n  #print (b)\n  z = min(min(b)[0], s)\n  if z == 0:\n    return 0\n  return z + solve([(x[0]-z, x[1]) for x in b], s-z)\ns = sum(a)\nprint(pow(x, solve([(s-x, 1) for x in a], s), 10**9+7))
import sys\ninput = sys.stdin.readline\n\nn=int(input())\nP=[list(map(int,input().split())) for i in range(n-1)]\n\n\nGroup=[i for i in range(n+1)]\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\nANS=[[i] for i in range(n+1)]\n\nfor i,j in P:\n    if find(j)<find(i):\n        ANS[find(j)]+=ANS[find(i)]\n        \n    else:\n        ANS[find(i)]+=ANS[find(j)]\n\n    Union(i,j)\n\nfor a in ANS[1]:\n    print(a,end=" ")\n        \n\n
import sys\ninput = sys.stdin.readline\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ndef get(x0, a, n):\n    r = 0\n    for i in range(n):\n        p = (x0 - a[i].x)*(x0 - a[i].x) + 1.0*a[i].y*a[i].y\n        p = p/2.0/a[i].y\n        if p < 0:\n            p = -p\n        r = max(r, p)\n    return r\n\ndef main():\n    n = int(input())\n    pos, neg = False, False\n    a = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        t = Point(x, y)\n        if t.y > 0:\n            pos = True\n        else:\n            neg = True\n        a.append(t)\n    if pos and neg:\n        return -1\n    if neg:\n        for i in range(n):\n            a[i].y = -a[i].y\n    L, R = -1e8, 1e8\n    for i in range(120):\n        x1 = L + (R-L)/3\n        x2 = R - (R-L)/3\n        if get(x1, a, n) < get(x2, a, n):\n            R = x2\n        else:\n            L = x1\n    return get(L, a, n)\n\ndef __starting_point():\n    print(main())\n__starting_point()
n, m = list(map(int, input().split()))\nline = list(map(int, input().split()))\n\npairs = set()\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    pairs.add((a,b))\n\nreq = [line.pop()]\n\nout = 0\nwhile line != []:\n    nex = line.pop()\n    works = True\n    for pers in req:\n        if not (nex, pers) in pairs:\n            works = False\n            break\n    if works:\n        out += 1\n    else:\n        req.append(nex)\n\nprint(out)\n        \n
n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\nfed_left = {0 : a[0]}\nnot_fed_left = {0 : b[0]}\n\nfor i in range(1, n):\n	fed_left[i] = max(fed_left[i-1] + b[i], not_fed_left[i-1] + a[i]) # max(fed left, fed right)\n	not_fed_left[i] = max(fed_left[i-1] + c[i], not_fed_left[i-1] + b[i]) # max(fed left and right, fed right)\n\nprint(fed_left[n-1])\n
import sys\ninput = sys.stdin.readline\nn, M = list(map(int, input().split()))\nt = list(map(int, input().split()))\nans = []\ntmp = [0] * 101\nfor i in range(n):\n    num = 0\n    T = t[i]\n    for j in range(1, 101):\n        if T + j * tmp[j] <= M:\n            num += tmp[j]\n            T += j * tmp[j]\n        else:\n            m = M - T\n            num += m // j\n            break\n\n    ans.append(i - num)\n    tmp[t[i]] += 1\n\nprint(*ans)\n
n, m = [int(x) for x in input().split()]\na = [[int(c == '.') for c in input()] for i in range(n)]\n\ndef rotate(a):\n    n = len(a)\n    m = len(a[0])\n    b = [[0] * n for i in range(m)]\n    for i in range(n):\n        for j in range(m):\n            b[j][n - 1 - i] = a[i][j]\n    return b\n\ndef calc(a):\n    n = len(a)\n    m = len(a[0])\n    alive = a[0][:]\n    alive[0], alive[m - 1] = 0, 0\n    ans_l, ans_r, ans_u = 0, 0, 0\n    ans_bs = [0] * m\n    for i in range(1, n - 1):\n        s = 0\n        for j in range(1, m - 1):\n            if a[i][j]:\n                if alive[j]:\n                    ans_u += s - alive[j - 1]\n                ans_bs[j] += s\n                s += alive[j]\n            else:\n                s = 0\n                ans_bs[j] = 0\n                alive[j] = 0\n        if a[i][m - 1]:\n            ans_r += s\n        s = 0\n        for j in range(m - 2, 0, -1):\n            if a[i][j]:\n                if alive[j]:\n                    ans_u += s - alive[j + 1]\n                ans_bs[j] += s\n                s += alive[j]\n            else:\n                s = 0\n                ans_bs[j] = 0\n                alive[j] = 0\n        if a[i][0]:\n            ans_l += s\n    ans_u //= 2\n    ans_b = sum(a[n - 1][i] * (ans_bs[i] + alive[i]) for i in range(1, m - 1))\n    return ans_l, ans_r, ans_u, ans_b\nans = 0\nans_l, ans_r, ans_u, ans_b = calc(a)\nans += ans_l + ans_r + ans_u + ans_b\na = rotate(a)\nans_l, _, ans_u, ans_b = calc(a)\nans += ans_l + ans_u + ans_b\na = rotate(a)\nans_l, _, ans_u, _= calc(a)\nans += ans_l + ans_u\na = rotate(a)\n_, _, ans_u, _= calc(a)\nans += ans_u\nprint(ans)\n
#!/usr/bin/env python3\n\ndef main():\n    class Node:\n        def __init__(self):\n            self.children = [ ]\n\n    n = int(input())\n    nodes = [Node() for i in range(n)]\n    for i in range(1, n):\n        p = int(input())\n        nodes[p - 1].children.append(nodes[i])\n    ok = all(\n        len([child for child in node.children if not child.children]) >= 3\n        for node in nodes\n        if node.children\n    )\n    print("Yes" if ok else "No")\n\ntry:\n    while True:\n        main()\nexcept EOFError:\n    pass\n
import sys\nn, m = list(map(int, sys.stdin.readline().split()))\nvis = [0] * 1000005\nnum = list(map(int, sys.stdin.readline().split()))\nflag = 0\ntemp = num[0]\nfor i in range(n):\n    if num[i] != temp:\n        flag = 1\n        break\nif flag == 0:\n    print("{0} {1}".format(1, n))\nelse:\n    l = 0\n    r = 0\n    al = 0\n    ar = 0\n    ans = 0\n    now = 0\n    for i in range(n):\n        vis[num[i]] += 1\n        if vis[num[i]] == 1:\n            now += 1\n        while now > m:\n            vis[num[l]] -= 1\n            if vis[num[l]] == 0:\n                now -= 1\n            l += 1\n        if i - l + 1 > ar - al + 1:\n            ar = i\n            al = l\n    print('{0} {1}'.format(al+1, ar+1))\n\n\n\n\n\n
n = int(input())\nvs = [int(x) for x in input().split()]\nts = [int(x) for x in input().split()]\n\nsumt = 0\nfor i, t in enumerate(ts):\n    vs[i]+=sumt\n    sumt+=t\n\nvs.sort()\n\ntl, tr = 0, 0\nil, ir = 0, 0\nfor ind, t in enumerate(ts): #check\n    tl = tr\n    tr += t\n    while ir < n and vs[ir] <= tr: ir += 1\n    cur_sum = 0\n    while il < ir:\n        cur_sum += vs[il]-tl\n        il+=1\n##    print(ir, tl, tr,  cur_sum)\n    cur_sum += t * ((n-ir) - (n-ind-1))\n    print(cur_sum, end=" ")\n    \n
n, l, r = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = []\nd = []\n\nisOk = 0\n\nfor i in range(0, l - 1):\n    if a[i] != b[i]:\n        isOk = 1\n\nfor i in range(r, n):\n    if a[i] != b[i]:\n        isOk = 1\n\nfor i in range(l - 1, r):\n    c.append(a[i])\n    d.append(b[i])\n\nc.sort()\nd.sort()\n\nif c != d:\n    isOk = 1\n\nif isOk == 1:\n    print("LIE")\nelse:\n    print("TRUTH")
import sys\nsys.setrecursionlimit(200000)\n\nn = int(input())\narr = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    arr[a - 1].append(b - 1)\n    arr[b - 1].append(a - 1)\ns = max([len(p) for p in arr]) + 1\nprint(s)\n\ncolored = [0] * n\ndef dfs(v, c, d):\n    colored[v] = p = c\n    for u in arr[v]:\n        if not colored[u]:\n            c = c + 1 if c < s else 1\n            if c == d:\n                c = c + 1 if c < s else 1\n            dfs(u, c, p)\nif s > 3:\n    dfs(0, 1, 0)\nelse:\n    i = 0\n    c = 1\n    while len(arr[i]) != 1:\n        i += 1\n    for j in range(n):\n        colored[i] = c\n        c = c + 1 if c < s else 1\n        if j < n - 1:\n            i = arr[i][0] if not colored[arr[i][0]] else arr[i][1]\nprint(" ".join(map(str, colored)))
MOD = 10 ** 9 + 7\n\nout = 1\n\nn = int(input())\n\nfor i in range(n):\n    out *= (i + 1)\n    out %= MOD\nout -= pow(2, n - 1, MOD)\nprint(out % MOD)\n
n = int(input())\na = list(map(int,input().split()))\na = sorted(a)\n\nout = [0 for x in range(n)]\nif n%2:\n    out[n//2] = a[-1]\nfor x in range(n//2):\n    out[x] = a[x*2]\n    out[-(1+x)] = a[(x*2)+1]\nprint (" ".join(str(c) for c in out)) 
n, m = list(map(int, input().split()))\ncolor_pairs = [list(map(int, input().split())) for i in range(m)]\ntowers = [[(i, i)] for i in range(1, n + 1)]\nlast_coord = n + 1\nfor c1, c2 in color_pairs:\n    towers[c1 - 1].append((last_coord, c1))\n    towers[c2 - 1].append((last_coord, c2))\n    last_coord += 1\nfor i in range(len(towers)):\n    print(len(towers[i]))\n    for x, y in towers[i]:\n        print(x, y)\n\n\n
n, m, k = map(int, input().split())\nsch = [0 for i in range(m)]\np = list(map(int, input().split()))\ns = list(map(int, input().split()))\nc = list(map(int, input().split()))\nfor i in range(n):\n    sch[s[i] - 1] = max(sch[s[i] - 1], p[i])\nres = 0\nfor i in c:\n    i -= 1\n    res += p[i] != sch[s[i] - 1]\nprint(res)
import sys\nfrom sys import stdin\n\nimport bisect\n\ndef LIS(lis , end):\n\n    seq = []\n\n    for c in lis:\n        ind = bisect.bisect_right(seq,c)\n\n        if ind == len(seq):\n            seq.append(c)\n        else:\n            if ind != 0:\n                seq[ind] = c\n\n    return bisect.bisect_right(seq,end)\n\ntt = 1\n\nfor loop in range(tt):\n\n    n,k = list(map(int,stdin.readline().split()))\n    a = list(map(int,stdin.readline().split()))\n    b = list(map(int,stdin.readline().split()))\n\n    a = [float("-inf")] + a + [float("inf")]\n    b = [0] + b + [n+1]\n    for i in range(n+2):\n        a[i] -= i\n\n    for i in range(len(b)-1):\n        if a[b[i]] > a[b[i+1]]:\n            print(-1)\n            return\n\n    ans = n+1\n    for i in range(len(b)-1):\n        now = LIS(a[ b[i]:b[i+1] ] , a[b[i+1]])\n        ans -= now\n\n    print (ans)\n
def sum_first(di):\n    return di * (di + 1) // 2\n\n\nn, x = list(map(int, input().split()))\nn *= 2\nd = tuple(map(int, input().split())) * 2\nans = 0\ni = 0\nj = 0\ncur_ans = 0\ntotal_days = 0\nwhile j <= n:\n    if total_days < x:\n        if j == n:\n            break\n        cur_ans += sum_first(d[j])\n        total_days += d[j]\n        j += 1\n    else:\n        ans = max(ans, cur_ans - sum_first(total_days - x))\n        cur_ans -= sum_first(d[i])\n        total_days -= d[i]\n        i += 1\nprint(ans)\n
d = [1, 1]\nn = int(input())\nwhile d[-1] < n:\n	d.append(d[-1] + d[-2])\ns = set(d)\nres = ''\nfor i in range(1, n + 1):\n	if i in s:\n		res += 'O'\n	else:\n		res += 'o'\nprint(res)
n = int(input())\ns = input()\nt = input()\n\ncurr = 0\ncurrs = []\nfor i in range(n):\n    if s[i] == '1':\n        curr += 1\n    if t[i] == '1':\n        curr -= 1\n    currs.append(curr)\n\nif curr != 0:\n    print(-1)\nelse:\n    print(max(currs)-min(currs))\n
"""\nCodeforces Round 241 Div 1 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\nclass InputHandlerObject(object):\n    inputs = []\n\n    def getInput(self, n = 0):\n        res = ""\n        inputs = self.inputs\n        if not inputs: inputs.extend(input().split(" "))\n        if n == 0:\n            res = inputs[:]\n            inputs[:] = []\n        while n > len(inputs):\n            inputs.extend(input().split(" "))\n        if n > 0:\n            res = inputs[:n]\n            inputs[:n] = []\n        return res\nInputHandler = InputHandlerObject()\ng = InputHandler.getInput\n\n############################## SOLUTION ##############################\nm,n = [int(x) for x in g()]\nq = []\nfor i in range(m):\n    q.append([int(x) for x in g()])\np = q[:]\nfor j in range(n):\n    for i in range(m):\n        if i == 0 and j == 0:\n            continue\n        if i == 0:\n            p[i][j] = p[i][j-1] + q[i][j]\n            continue\n        if j == 0:\n            p[i][j] = p[i-1][j] + q[i][j]\n            continue\n        p[i][j] = max(p[i-1][j], p[i][j-1]) + q[i][j]\nfor i in range(m):\n    print(p[i][n-1], end=" ")\n
n=int(input())\nstring = input()\nq1,q2,B,C=[],[],[],[]\nA=0\nfor i in range(n):\n    if string[i] == "D":\n        q1.append(i)\n    else:\n        q2.append(n-1-i)\n\nfor i in range(len(q1)):\n    A+=(q1[i]-i)*2+1\n    B.append(A)\n\nA=0\ntemp = []\nfor i in range(len(q2)):\n    A+=(q2[len(q2)-1-i]-i)*2+1\n    C.append(A)\nC.reverse()\n\nB=list(map(str,B+C))\nprint(" ".join(B))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n
n = int(input())\narr = []\nfor i in range(n):\n    s = input()\n    arr.append('<')\n    arr.append('3')\n    for j in range(len(s)):\n        arr.append(s[j])\narr.append('<')\narr.append('3')\ns = input()\ncur = 0\ni = 0\nwhile cur < len(s) and i < len(arr):\n    if s[cur] == arr[i]:\n        i+=1\n    cur+=1\nif i == len(arr):\n    print('yes')\nelse:\n    print('no')
# tested by Hightail - https://github.com/dj3500/hightail\n\n\nfrom heapq import heappop, heappush\nfrom sys import stdin, stdout\n\n\nread, read_array = stdin.readline, lambda: stdin.readline().split()\nwrite = lambda *args, **kw: stdout.write(kw.get('sep', ' ').join(str(a) for a in args) + kw.get('end', '\n'))\nwrite_array = lambda arr, **kw: stdout.write(kw.get('sep', ' ').join(str(a) for a in arr) + kw.get('end', '\n'))\nread_int, read_int_array = lambda: int(read()), lambda: [int(p) for p in read_array()]\nread_float, read_float_array = lambda: float(read()), lambda: [float(p) for p in read_array()]\n\n\nn, k = read_int_array()\nheap = []\nbusy = 0\ntime = 0\nfinish = [0] * n\nfor i in range(n):\n    if busy == k:\n        time = heappop(heap)\n        busy -= 1\n    else:\n        time = 0\n    start, minutes = read_int_array()\n    if start > time:\n        time = start\n    heappush(heap, time + minutes)\n    finish[i] = time + minutes\n    busy += 1\n\nwrite_array(finish, sep='\n')
n, a, r, m = map(int, input().split())\nh = list(map(int, input().split()))\nm = min(m, a+r)\n\ndef get(M):\n	up = 0\n	dw = 0\n	for e in h:\n		if e > M:\n			up += e - M\n		else:\n			dw += M - e\n	ans = m * min(dw, up)\n	if dw > up:\n		ans += (dw - up) * a\n	else:\n		ans += (up - dw) * r\n	return ans\n\n\nL = 0\nR = int(1e9)\nmn = int(1e18)\n\nwhile R - L > 10:\n	M1 = L + (R - L) // 3\n	M2 = R - (R - L) // 3\n	V1 = get(M1)\n	V2 = get(M2)\n	mn = min(mn, V1)\n	mn = min(mn, V2)\n	if V1 < V2:\n		R = M2\n	elif V2 < V1:\n		L = M1\n	else:\n		L = M1\n		R = M2\n\nfor it in range(L, R+1):\n	mn = min(mn, get(it))\n\nprint(mn)
n = int(input())\n\nline = input().split()\nlst = []\nfor num in line:\n    lst.append(int(num))\n\ncnt1 = [0]\ncnt2 = [0]\nc1 = 0\nc2 = 0\n\nfor num in lst:\n    if num == 1:\n        c1 += 1\n        cnt1.append(c2)\n    else:\n        c2 += 1\n        cnt2.append(c1)\n\nw = lst[n - 1]\nans = []\nc1 = len(cnt1)\nc2 = len(cnt2)\nfor t in range(n, 0, -1):\n    s1 = 0\n    s2 = 0\n    i1 = 0\n    i2 = 0\n    l = 1\n    while i1 < c1 and i2 < c2:\n        if i1 + t >= c1 and i2 + t >= c2:\n            if l == 1 and l == w and i1 + 1 == c1 and s1 > s2:\n                ans.append((s1, t))\n            elif l == 2 and l == w and i2 + 1 == c2 and s2 > s1:\n                ans.append((s2, t))\n            break\n        elif i2 + t >= c2:\n            s1 += 1\n            l = 1\n            i1 += t\n            i2 = cnt1[i1]\n        elif i1 + t >= c1:\n            s2 += 1\n            l = 2\n            i2 += t\n            i1 = cnt2[i2]\n        else:\n            if cnt1[i1 + t] < i2 + t:\n                s1 += 1\n                l = 1\n                i1 += t\n                i2 = cnt1[i1]\n            else:\n                s2 += 1\n                l = 2\n                i2 += t\n                i1 = cnt2[i2]\n\nans.sort()\n\nprint(int(len(ans)))\nfor line in ans:\n    print(str(line[0]) + ' ' + str(line[1]))\n
n = int(input())\na = list(map(int, input().split()))\n\nmxa = max(a)\nv = 1 << 30\nwhile v > mxa:\n    v >>= 1\n\nwhile True:\n    d = -1\n    for i in range(n):\n        if a[i] & v:\n            d &= a[i]\n    if d % v == 0:\n        break\n    v >>= 1\n\nb = [i for i in a if i & v]\nprint(len(b))\nprint(' '.join(map(str,b)))\n
n=int(input())\na=list(map(int,input().split()))\nb=True\nl=0\nr=n-1\nans1=0\nans2=0\nwhile l<=r:\n    if a[l]>a[r]:\n        if b:\n            ans1+=a[l]\n            b=False\n        else:\n            ans2+=a[l]\n            b=True\n        l+=1\n    else:\n        if b:\n            ans1+=a[r]\n            b=False\n        else:\n            ans2+=a[r]\n            b=True   \n        r-=1\nprint(ans1,ans2)
def f(m):\n    v = 0\n    for x in m:\n        v |= x\n    return v\ninput()\nprint(f(map(int, input().split())) + f(map(int, input().split())))
import sys\n\n\n\nn = int(sys.stdin.readline().strip())\ns = sys.stdin.readline().strip()\n\ndp = [[-1] * (n + 1) for i in range(26)]\n\n\nfor c in range(26):\n    for j in range(n):\n        tst = 1 if s[j] == chr(c + 97) else 0\n        dp[c][1 - tst] = max(dp[c][1 - tst], 1)\n        for k in range(j + 1, n):\n            if s[k] == chr(c + 97):tst += 1\n            dp[c][k - j + 1 - tst] = max(dp[c][k - j + 1 - tst], k - j + 1)\n\n#for c in range(26):\n#    for j in range(n):\n#        dp[c][j + 1] = max(dp[c][j], dp[c][j + 1])\n\nq = int(sys.stdin.readline().strip())\n\nfor i in range(q):\n    m, c = [item for item in sys.stdin.readline().strip().split()]\n    m = int(m)\n    #print(max([dp[ord(c) - 97][u] for u in range(m + 1)]))\n    print(dp[ord(c) - 97][m]) if dp[ord(c) - 97][m] != -1 else print(n)
a=int(input())\nb=int(input())\nn=a+b+1\nL=list(range(n-a,n+1))\nfor item in L:\n    print(item,end=" ")\nx=n-a-1\nwhile(x>0):\n    print(x,end=" ")\n    x-=1\n
for _ in range(int(input())):\n	n, x, y, d = map(int, input().split())\n	tt = abs(x - y)\n	if tt % d != 0:\n		ans = -1\n		if (y - 1) % d == 0:\n			ans = (x - 1 + d - 1) // d + (y - 1) // d\n		if (n - y) % d == 0:\n			cc = (n - x + d - 1) // d + (n - y) // d\n			if ans == -1 or cc < ans:\n				ans = cc\n		print(ans)\n	else:\n		print(tt // d)
#      Codeforces Round #487 (Div. 2)import collections\nfrom functools import cmp_to_key\n#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )\n\nimport sys\ndef getIntList():\n    return list(map(int, input().split()))    \nimport bisect\n \n            \n    \nN,L,WM  = getIntList()\n\nz = {}\nz[-1] = {1:[], -1:[]}\nz[0] = {1:[], -1:[]}\nz[1] = {1:[], -1:[]}\nfor i in range(N):\n    x0,v = getIntList()\n    t = (x0,v)\n    if x0+L <=0:\n        z[-1][v].append(t)\n    elif x0>=0:\n        z[1][v].append(t)\n    else:\n        z[0][v].append(t)\nres = 0\n\nres += len(z[-1][1] ) * len(z[ 1][-1] )\nres += len(z[0][1] ) * len(z[ 1][-1] )\nres += len(z[-1][1] ) * len(z[ 0][-1] )\n\nif WM==1:\n    print(res)\n    return\n\nz[1][-1].sort()\nz[-1][1].sort()\n#print(z[-1][1])\ntn = len(z[1][-1])\nfor t in z[1][1]:\n    g = (-WM-1) * t[0] / (-WM+1) - L\n    g = max(g, t[0]+ 0.5)\n    p = bisect.bisect_right(z[1][-1], (g,2) )\n    res +=  tn-p \n    \ntn = len(z[-1][1])\nfor t in z[-1][-1]:\n    g = (WM+1) * (t[0] + L)/ (WM-1)\n    g = min(g, t[0] - 0.1)\n    \n    p = bisect.bisect_left(z[-1][1], (g,-2) )\n    res +=  p \n\nprint(res)\n
\n\nn = int(input())\na = 0\nb = 0\nfor x in input().split():\n    x = int(x)\n    if x % 2 == 0:\n        a += 1\n    else:\n        b += 1\nres = b\nif a < b:\n    res = a + (b-a)//3\nprint(res)\n
n=int(input())\npos=[]\nneg=[]\nfor _ in range(n):\n    x,a=list(map(int,input().split()))\n    if x > 0:\n        pos.append((x, a))\n    else:\n        neg.append((-x, a))\npos=[a for x,a in sorted(pos)]\nneg=[a for x,a in sorted(neg)]\nif len(pos)==len(neg):\n    print(sum(pos)+sum(neg))\nelse:\n    if len(pos)<len(neg):\n        pos,neg=neg,pos\n    print(sum(neg)+sum(pos[:len(neg)+1]))\n
import sys\n\ns = input()\nqc = s.count('Q')\nqs = int(qc ** 0.5)\nhc = s.count('H')\nif qs == 0:\n    print('Yes')\n    return\nif not qc == qs ** 2:\n    print('No')\n    return\nif not hc % (qs + 1) == 0:\n    print('No')\n    return\n\nt = s.split('Q')\npre = len(t[0]) // 2\nsuf = 0 if len(t) == 1 else len(t[-1]) // 2\na = ['H' * pre] + t[1 : qs] + ['H' * suf]\no = [c for c in 'Q'.join(a)]\ng = []\nfor c in o:\n    if c == 'H':\n        g += ['H']\n    else:\n        g += o\n\nprint('Yes' if ''.join(g) == s else 'No')\n
n,m,k = map(int, input().split())\nmCnt = 0\nans = [0]*m\nstart = 0\nend = 0\nQ = [[] for i in range(m)]\n\nfor i in range(n):\n    A = list(map(int, input().split()))\n    z = 0\n    for j in range(m) :\n        while Q[j] and Q[j][-1][0] < A[j] :\n            Q[j].pop()\n        Q[j].append([A[j],i])\n        z += Q[j][0][0]\n    if z <= k :\n        end = i+1\n        if mCnt < end - start :\n            mCnt = end - start\n            for j in range(m) :\n                ans[j] = Q[j][0][0]\n    else :\n        while True :\n            z = 0\n            for j in range(m) :\n                if Q[j] and Q[j][0][1] == start :\n                    Q[j].pop(0)\n                if Q[j] : z += Q[j][0][0]\n            start += 1\n            if z<= k : break\n        end += 1\n            \nfor i in ans :\n    print(i, end = " ")\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n
from math import inf\n\nclass Node:\n    def __init__(self, parent = None, leftExp = None, rightExp = None, signQ = 0):\n        self.parent, self.leftExp, self.rightExp, self.signQ = parent, leftExp, rightExp, signQ\n    def __str__(self):\n        return "Node"\n\nmemo = {}\n\ndef Memoize(node, p, maxValue, minValue):\n    if not node in memo:\n        memo.update({node : {p : [maxValue, minValue]} })\n    else:\n        memo[node].update({p : [maxValue, minValue]})\n\ndef ExpMaxValue(root: Node, p):\n\n    m = root.signQ - p\n    """if root.signQ == 1:\n        if p == 1:\n            return [root.leftExp.value + root.rightExp.value, root.leftExp.value + root.rightExp.value]\n        else:\n            return [root.leftExp.value - root.rightExp.value, root.leftExp.value - root.rightExp.value]"""\n\n    if root.signQ == 0:\n        return [root.value, root.value]\n    \n    if root in memo:\n        if p in memo[root]:\n            return memo[root][p]\n\n    if m == 0:\n        value = ExpMaxValue(root.leftExp, root.leftExp.signQ)[0] + ExpMaxValue(root.rightExp, root.rightExp.signQ)[0]\n        Memoize(root, p, value, value)\n        return [value, value]\n    if p == 0:\n        value = ExpMaxValue(root.leftExp, 0)[0] - ExpMaxValue(root.rightExp, 0)[0]\n        Memoize(root, p, value, value)\n        return [value, value]\n        \n    maxValue = -inf\n    minValue = inf\n    if m >= p:\n        for pQMid in range(2):\n            pQLeftMin = min(p - pQMid, root.leftExp.signQ)\n            for pQLeft in range(pQLeftMin + 1):\n                if root.leftExp.signQ - pQLeft + (1 - pQMid) > m:\n                    continue\n                \n                resLeft = ExpMaxValue(root.leftExp, pQLeft)\n                resRight = ExpMaxValue(root.rightExp, p - pQMid - pQLeft)\n                \n                if pQMid == 1:\n                    maxValue = max(resLeft[0] + resRight[0], maxValue)\n                    minValue = min(resLeft[1] + resRight[1], minValue)\n                else:\n                    maxValue = max(resLeft[0] - resRight[1], maxValue)\n                    minValue = min(resLeft[1] - resRight[0], minValue)\n    else:\n        for mQMid in range(2):\n            mQLeftMin = min(m - mQMid, root.leftExp.signQ)\n            for mQLeft in range(mQLeftMin + 1):\n                pQLeft = root.leftExp.signQ - mQLeft\n                if pQLeft + (1 - mQMid) > p:\n                    continue\n                \n                resLeft = ExpMaxValue(root.leftExp, pQLeft)\n                resRight = ExpMaxValue(root.rightExp, p - (1 - mQMid) - pQLeft)\n                \n                if mQMid == 0:\n                    maxValue = max(resLeft[0] + resRight[0], maxValue)\n                    minValue = min(resLeft[1] + resRight[1], minValue)\n                else:\n                    maxValue = max(resLeft[0] - resRight[1], maxValue)\n                    minValue = min(resLeft[1] - resRight[0], minValue)\n\n    Memoize(root, p, int(maxValue), int(minValue))\n\n    return [int(maxValue), int(minValue)]\n                \n                \n\ndef PrintNodes(root: Node):\n    if root.signQ != 0:\n        leftExp = root.leftExp if root.leftExp.signQ != 0 else root.leftExp.value\n        rightExp = root.rightExp if root.rightExp.signQ != 0 else root.rightExp.value\n        check = root.signQ == root.leftExp.signQ + root.rightExp.signQ + 1\n        print(root.signQ, root.parent, leftExp, rightExp, check)\n        PrintNodes(root.leftExp)\n        PrintNodes(root.rightExp)\n\n        \n\ndef main():\n    exp = str(input())\n    if len(exp) == 1:\n        print(exp)\n        return\n    \n    #root = Node(None, None, None)\n    #root.parent = root\n    cNode = Node()\n    isRight = False\n    \n    for i in range(1, len(exp) - 1):\n        if exp[i] == '(':\n            if not isRight:\n                cNode.leftExp = Node(cNode)\n                cNode = cNode.leftExp\n            else:\n                cNode.rightExp = Node(cNode)\n                cNode = cNode.rightExp\n            isRight = False\n        elif exp[i] == '?':\n            isRight = True\n            cNode.signQ += 1\n        elif exp[i] == ')':\n            if cNode.parent != None:\n                cNode.parent.signQ += cNode.signQ\n            cNode = cNode.parent\n            isRight = False\n        else:\n            if not isRight:\n                cNode.leftExp = Node(cNode)\n                cNode.leftExp.value = int(exp[i])\n            else:\n                cNode.rightExp = Node(cNode)\n                cNode.rightExp.value = int(exp[i])\n\n    \n    #PrintNodes(cNode)\n\n    ss = str(input()).split()\n    p, m = int(ss[0]), int(ss[1])\n\n    print(ExpMaxValue(cNode, p)[0])\n    \n\n\n    \n\nmain()
n = int(input())\n\nls = [input() for _ in range(n)]\n\nbalance = [[0, 0] for _ in range(n)]\n\nfor i in range(n):\n	for j in range(len(ls[i])):\n		balance[i][0] = balance[i][0] + (1 if ls[i][j] == '(' else -1)\n		balance[i][1] = min(balance[i][1], balance[i][0])\n\nbalance2 = []\n\nfor i in range(n):\n	if balance[i][0] < 0:\n		if balance[i][1] >= balance[i][0]:\n			balance2.append(balance[i][0])\n	if balance[i][0] >= 0:\n		if balance[i][1] >= 0:\n			balance2.append(balance[i][0])\n\nbalance2.sort()\n\n\nanswer = 0\n\ni, j = 0, len(balance2) - 1\n\nwhile i < j:\n	if balance2[i] + balance2[j] == 0:\n		answer += 1\n		i += 1\n		j -= 1\n	elif balance2[i] + balance2[j] < 0:\n		i += 1\n	elif balance2[i] + balance2[j] > 0:\n		j -= 1 \n\nprint(answer)\n\n\n\n
n=int(input())\na=[*map(int,input().split())]\nb=[*map(int,input().split())]\nprint(sum(sorted(a+b)[::-2])-sum(b))
s1 = input()\ns2 = input()\ns = input()\nr=''\nfor i in s:\n    if i.isalpha():\n        #print (s1.index(i.lower()))\n        if i.isupper():\n            r+= (s2[(s1.index(i.lower()))].upper())\n        else:\n            r+=(s2[(s1.index(i.lower()))])\n    else:\n        r+=(i)\nprint (r)
n, m = map(int, input().split())\nt = input()\na, b = t.count('1'), t.count('-')\nt = ['0'] * m\nc = 2 * min(a - b, b)\nfor i in range(m):\n    l, r = map(int, input().split())\n    r -= l\n    if r & 1 and r < c: t[i] = '1'\nprint('\n'.join(t))
n, k = list(map(int, input().split()))\nplain = list()\n\nfor i in range(n):\n    plain.append(list(input()))\n\nfr = {\n    "0": list(),\n    "1": list(),\n    "2": list(),\n}\nfor i in range(n):\n    for j in range(12):\n        if plain[i][j] != ".":\n            continue\n\n        st = 0\n        if j > 0 and plain[i][j - 1] == "S":\n            st += 1\n        if j < 11 and plain[i][j + 1] == "S":\n            st += 1\n\n        fr[str(st)].append((i, j))\n\nfor i in range(k):\n    if len(fr["0"]):\n        x, y = fr["0"].pop()\n    elif len(fr["1"]):\n        x, y = fr["1"].pop()\n    else:\n        x, y = fr["2"].pop()\n    plain[x][y] = "x"\n\n\nresult = 0\nfor i in range(n):\n    for j in range(12):\n        if plain[i][j] != "S":\n            continue\n        if j > 0 and plain[i][j - 1] in ("S", "x", "P"):\n            result += 1\n        if j < 11 and plain[i][j + 1] in ("S", "x", "P"):\n            result += 1\n\nprint(result)\nfor i in range(n):\n    print("".join(plain[i]))\n
import re\nimport itertools\nfrom collections import Counter, deque\n\nclass Task:\n    n, k = 0, 0\n    answer = []\n	\n    def getData(self):\n        self.n, self.k = [int(x) for x in input().split(' ')]\n        #inFile = open('input.txt', 'r')\n        #inFile.readline().rstrip()\n        #self.childs = inFile.readline().rstrip()\n\n    def solve(self):\n        n, k = self.n, self.k\n        if n < 3 * k:\n            self.answer = '-1'\n            return\n\n        keeper = 1\n        while keeper < k:\n            self.answer += [keeper, keeper, keeper + 1]\n            self.answer += [keeper, keeper + 1, keeper + 1]\n            keeper += 2\n        if keeper > k:\n            self.answer += [k] * (n - len(self.answer))\n            return\n        else:\n            self.answer += [keeper] * (n - len(self.answer))\n            self.answer[-1] = 1\n            self.answer[3] = keeper\n\n    def printAnswer(self):\n        print(re.sub(r'[\[\],]', '', str(self.answer)))\n        #print(self.answer[:6])\n        #outFile = open('output.txt', 'w')\n        #outFile.write(self.answer)\n\ntask = Task()\ntask.getData()\ntask.solve()\ntask.printAnswer()\n
line=input().split()\nn=int(line[0])\nk=int(line[1])\nnums=input().split()\nfor i in range(n):\n    nums[i]=int(nums[i])\n\nfirstsum = 0\nfor i in range(k):\n    firstsum+=nums[i]\n\ntotsum=firstsum\nfor i in range(n-k):\n    firstsum-=nums[i]\n    firstsum+=nums[k+i]\n    totsum+=firstsum\nprint(totsum/(n-k+1))\n
n, k = map(int, input().split())\narr = [int(i) for i in input().split()]\nres = [[] for i in range(n)]\nc = 0\nwhile True:\n    z = 0\n    for i in arr:\n        if i > 0:\n            z += 1\n    if z == 0:\n        break\n    if z == n:\n        for i in range(n):\n            arr[i] -= 1\n            res[i].append(1)\n    else:\n        c += 1\n        if c > k:\n            break\n        for i, j in enumerate(arr):\n            if j > 0:\n                arr[i] -= 1\n                res[i].append(c)\nif c > k:\n    print('NO')\nelse:\n    print('YES')\n    for i in res:\n        for j in i:\n            print(j, end = ' ')\n        print()
def main():\n    n = int(input())\n    l = [0] * 85\n    for c in input():\n        l[ord(c)] += 1\n    a, c, g, t = sorted(l[_] for _ in (65, 67, 71, 84))\n    if g < t:\n        print(1)\n    elif c < g:\n        print(pow(2, n, 1000000007))\n    elif a < c:\n        print(pow(3, n, 1000000007))\n    else:\n        print(pow(4, n, 1000000007))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
def main():\n    w, h, n = list(map(int, input().split()))\n    res, vrt, hor = [], [], []\n    vh = (vrt, hor)\n    for i in range(n):\n        s = input()\n        x = int(s[2:])\n        flag = s[0] == 'V'\n        vh[flag].append(i)\n        res.append([x, flag])\n    dim = []\n    for tmp, m in zip(vh, (h, w)):\n        tmp.sort(key=lambda e: res[e][0])\n        u = [None, [0]]\n        dim.append(u)\n        j = z = 0\n        for i in tmp:\n            x = res[i][0]\n            if z < x - j:\n                z = x - j\n            j = x\n            v = [u, res[i]]\n            u.append(v)\n            u = v\n            res[i].append(u)\n        v = [u, [m], None]\n        u.append(v)\n        dim.append(v)\n        if z < m - j:\n            z = m - j\n        dim.append(z)\n    l, r, wmax, u, d, hmax = dim\n    whmax = [wmax, hmax]\n    for i in range(n - 1, -1, -1):\n        x, flag, link = res[i]\n        u = whmax[flag]\n        res[i] = u * whmax[not flag]\n        link[0][2] = link[2]\n        link[2][0] = link[0]\n        v = link[2][1][0] - link[0][1][0]\n        if u < v:\n            whmax[flag] = v\n    print('\n'.join(map(str, res)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
s=input()\nn=len(s)\na=[]\ncurr=0\nfor i in range(n):\n    if s[i]=="a":\n        curr+=1\n    elif s[i]=="b":\n        a.append(curr)\n        curr=0\nif curr>0:\n    a.append(curr)\nprod=1\nfor i in range(len(a)):\n    prod*=(a[i]+1)\n    prod=prod%1000000007\nprint(prod-1)
a,b = map(int, input().split())\nprint((a+b)//2, (a-b)//2)
a,b,x,y = map(int, input().split())\ny=min(y,2*x)\n\nif a==b or a==b+1:\n    print(x)\n    return\n\nans=x+abs(a-b)*y\nif a>b:\n    ans-=y\nprint(ans)
n = int(input())\nd = {}\nfor i in range(n):\n    s = input().split()\n    for j in range(int(s[0])):\n        d[s[j+1]] = d.get(s[j+1],0)+1\nans = ""\nfor x in d:\n    if d[x] == n:\n        ans += str(x) + ' '\nprint(ans.strip())\n
t = {}\nfor i, c in enumerate(input()):\n    if c not in t: t[c] = (i, 1)\n    elif (t[c][0] - i) & 1: t[c] = (i, t[c][1] + 1)\nprint(max(b for a, b in t.values()))
import sys\n\ndef matching(node, visited, adj, assigned):\n	if node == -1:\n		return True\n	if visited[node]:\n		return False\n	visited[node] = True\n	for neighbor in adj[node]:\n		if matching(assigned[neighbor], visited, adj, assigned):\n			assigned[neighbor] = node\n			return True\n	return False\n\nINF = 1000 * 1000\n\ninp = [int(x) for x in sys.stdin.read().split()]\n\nn, m = inp[0], inp[1]\ninp_idx = 2\n\nG = [[INF] * n for _ in range(n)]\n\nfor _ in range(m):\n	a, b = inp[inp_idx] - 1, inp[inp_idx + 1] - 1\n	inp_idx += 2\n	G[a][b] = G[b][a] = 1\n\nfor v in range(n):\n	G[v][v] = 0\n	\nfor k in range(n): \n	for i in range(n): \n		for j in range(n): \n			G[i][j] = min(G[i][j], G[i][k] + G[k][j])\n	\ns, b, k, h = inp[inp_idx], inp[inp_idx + 1], inp[inp_idx + 2], inp[inp_idx + 3]\ninp_idx += 4\n\nspaceships = []\nfor _ in range(s):\n	x, a, f = inp[inp_idx] - 1, inp[inp_idx + 1], inp[inp_idx + 2]\n	inp_idx += 3\n	spaceships.append((x, a, f))\n	\nbases = []\nfor _ in range(b):\n	x, d = inp[inp_idx] - 1, inp[inp_idx + 1]\n	inp_idx += 2\n	bases.append((x, d))\n	\nadj = [[] for _ in range(s)]\nassigned = [[] for _ in range(b)]\nfor i in range(s):\n	space = spaceships[i]\n	for j in range(b):\n		base = bases[j]\n		u, v = space[0], base[0]\n		fuel = space[2]\n		if G[u][v] <= fuel and space[1] >= base[1]:\n			adj[i].append(j)\n\nvisited = [False] * s\nassigned = [-1] * b\n\nmatched = 0\nfor i in range(s):\n	visited = [False] * s\n	if matching(i, visited, adj, assigned):\n		matched += 1\n\n\nprint(min(matched * k, h * s))\n	\n\n
def solve(n, l, s, www, children):\n    ans = 0\n    dp = [{} for _ in range(n)]\n    for v in range(n - 1, -1, -1):\n        cv = children[v]\n        if not cv:\n            dp[v][1] = www[v]\n            continue\n        ans += len(cv) - 1\n        wv = www[v]\n        if wv > s:\n            return -1\n        dv = dp[v]\n        for c in cv:\n            for lc, wc in list(dp[c].items()):\n                if lc == l:\n                    continue\n                wt = wc + wv\n                if wt > s:\n                    continue\n                if lc + 1 not in dv:\n                    dv[lc + 1] = wt\n                else:\n                    dv[lc + 1] = min(dv[lc + 1], wt)\n        if not dv:\n            ans += 1\n            dv[1] = wv\n\n    return ans + 1\n\n\nn, l, s = list(map(int, input().split()))\nwww = list(map(int, input().split()))\nif n == 1:\n    print(-1 if www[0] > s else 1)\n    return\nchildren = [set() for _ in range(n)]\nfor i, p in enumerate(map(int, input().split())):\n    children[p - 1].add(i + 1)\nprint(solve(n, l, s, www, children))\n
MAX_N = 100000\n\ndef maxi(a, b):\n    if a[0] > b[0]:\n        return a\n    else:\n        return b\n\nclass Segment_Tree:\n    def init(self, left, right, data, leftbound, rightbound):\n        self.data = data\n        self.left = left\n        self.right = right\n        self.leftbound = leftbound\n        self.rightbound = rightbound\n        return self\n    def build(self, a, leftbound, rightbound):\n        #print(leftbound, rightbound, a)\n        if len(a) == 0:\n            return self.init(-1, -1, [0, -1], MAX_N + 1, -1)\n        elif len(a) == 1:\n            return self.init(-1, -1, a[0], leftbound, rightbound)\n        else:\n            middle = (leftbound + rightbound) // 2\n            self.left = Segment_Tree()\n            self.right = Segment_Tree()\n            return self.init(self.left.build(a[:middle - leftbound], leftbound, middle), self.right.build(a[middle - leftbound:], middle, rightbound), maxi(self.left.data, self.right.data), leftbound, rightbound)\n    def get(self, l, r):\n        if l <= self.leftbound and r >= self.rightbound:\n            return self.data\n        elif l < self.left.rightbound and r > self.right.leftbound:\n            return maxi(self.left.get(l, r), self.right.get(l, r))\n        elif l >= self.right.leftbound:\n            return self.right.get(l, r)\n        else:\n            return self.left.get(l, r)\n            \nn = int(input())\na = list(map(int, input().split())) + [n]\na = [[a[i] - 1, i] for i in range(n)]\nTree = Segment_Tree()\nTree.build(a, 0, n)\ndp = [0] * n\nans = 0\nfor i in range(n - 2, -1, -1):\n    m = Tree.get(i + 1, a[i][0] + 1)[1]\n    dp[i] = dp[m] - (a[i][0] - m) + n - i - 1;\n    ans += dp[i]\nprint(ans)\n
n = int(input())\na = list([int(x) - 1 for x in input().split()])\n\nans = False\n\nfor i in range(n):\n    if a[a[a[i]]] == i:\n        ans = True\n        break\n\nprint('YES' if ans else 'NO')\n
str = input()\ninpt = ""\nn = int(str)\nx = 0\nfor i in range(n):\n	inpt = input()\n	#print(inpt[0:2]+" - "+inpt[1:3])\n	if(inpt[0:2] == "++" or inpt[1:3] == "++"):\n		x += 1\n		#print("x = {} plus 1".format(x))\n	elif(inpt[0:2] == "--" or inpt[1:3] == "--"):\n		x -= 1\n		#print("x = {} minus 1".format(x))\nprint(x)
n = int(input())\np = list(map(int, input().split()))\n\nls = []\nvisited = [False for _ in range(n)]\ncnt = 0\nfor i in range(n):\n    j = i\n    cnt = 0\n    while not visited[j]:\n        visited[j] = True\n        cnt += 1\n        j = p[j] - 1\n    if 0 < cnt:\n        ls.append(cnt)\n\nls.sort()\nif 1 < len(ls):\n    ls[-2] += ls[-1]\n    ls.pop()\n\nprint(sum([x**2 for x in ls]))\n\n
import sys\n\ndef Is_arth(L):\n    D=L[1]-L[0]\n    p=L[1]\n    for i in range(2,len(L)):\n        if(L[i]-p!=D):\n            return False\n        p=L[i]\n    return True\n\nn=int(sys.stdin.readline())\n\nA=list(map(int,sys.stdin.readline().split()))\n\nT=[False]*(10**5+1)\nZ=[]\nfor i in range(10**5+1):\n    Z.append([])\n\nTaken=[]\nfor i in range(n):\n    Z[A[i]]+=[i]\n\n\nAns=""\nNum=0\nfor i in range(10**5+1):\n    L=len(Z[i])\n    item=i\n    if(L==0):\n        continue\n    if(L==1):\n        Num+=1\n        Ans+=str(item)+" 0\n"\n    elif(L==2):\n        Num+=1\n        Ans+=str(item)+" "+str(Z[item][1]-Z[item][0])+"\n"\n    else:\n        if(Is_arth(Z[item])):\n            Num+=1\n            Ans+=str(item)+" "+str(Z[item][1]-Z[item][0])+"\n"\nsys.stdout.write(str(Num)+"\n")\nsys.stdout.write(Ans)\n
from bisect import bisect_right\nimport heapq\n\nn = int(input())\nl = []\n\nti, wi = list(map(int, input().split()))\nbal = ti\npos = 1\nfor _ in range(n - 1):\n    ti, wi = list(map(int, input().split()))\n    if ti > bal:\n        pos += 1\n    l.append((ti, wi - ti + 1))\nl.sort()\n\nbest_pos = pos\n\nop = bisect_right(l, (bal, float('inf')))\n#print(l)\n\nw = []\nfor i, v in l[op:]:\n    heapq.heappush(w, v)\nop -= 1\n\nwhile w:\n    head = heapq.heappop(w)\n    if bal < head:\n        break\n    bal -= head\n    pos -= 1\n\n    #print(w, op)\n    while op >= 0 and l[op][0] > bal:\n        heapq.heappush(w, l[op][1])\n        op -= 1\n        pos += 1\n    best_pos = min(best_pos, pos)\n\nprint(best_pos)\n
# You lost the game.\nn, m = map(int, input().split())\nA = list(map(int, input().split()))\nM = [list(map(int, input().split())) for _ in range(m)]\n\nj = m-1\nx = 2\nh = -1\nB = [-1 for _ in range(n+1)]\nwhile h < n and j >= 0:\n    h = M[j][1]\n    if h >= x:\n        B[h] = j\n        x = h+1\n    j -= 1\n\nO = [0 for _ in range(n)]\n\nfor i in range(n-1,x-2,-1):\n    O[i] = A[i]\n    del A[i]\n\nn2 = len(A)\n    \nR = A[:]\nR.sort()\n      \nd = 0\nf = n2-1\n\n\nc = 0\nfor i in range(n2-1,-1,-1):\n    j = B[i+1]\n    if j >= 0:\n        c = M[j][0]\n    if c == 1:\n        O[i] = R[f]\n        f -= 1\n    else:\n        O[i] = R[d]\n        d += 1\n\n    \nfor i in range(n):\n    print(O[i],end=" ")\n        \n    \n    \n
n = int(input())\nc, d = {}, {}\nfor x, y in zip(input().split(), input().split()):\n    c[x] = c.get(x, 1) + 1\n    c[y] = c.get(y, 1) + 1\n    if x == y: d[x] = d.get(x, 0) + 2\ns, m = 1, int(input())\nfor k, v in c.items():\n    u = d.get(k, 0)\n    for i in range(v - u, v, 2): s = s * (i * i + i) // 2 % m\n    for i in range(1, v - u): s = s * i % m\nprint(s)
q = 10001\nn, a = int(input()), list(map(int, input().split()))\na.sort()\nfor i in range(40000 // (n - 1) + 1):\n    b = [a[j] - j * i for j in range(n)]\n    u, v = max(b), min(b)\n    p = (u - v + 1) // 2\n    if p < q: q, s, d = p, v + p, i\nprint(q)\nprint(s, d)\n
rd  = lambda: list(map(int, input().split()))\n\nn, = rd()\na = [0] + rd() + [0]\nfor i in range(rd()[0]):\n  x, y = rd()\n  a[x-1] += y-1\n  a[x+1] += a[x]-y\n  a[x  ] = 0\nprint('\n'.join(map(str, a[1:1+n])))
#!/usr/bin/env python3\n\nn, m = list(map(int, input().split()))\nminx = miny = n + m\nmaxx = maxy = - minx\ndist = n + m + 1\n\nc = int(input())\nfor _ in range(c):\n    x, y = list(map(int, input().split()))\n    minx = min(minx, x - y)\n    miny = min(miny, x + y)\n    maxx = max(maxx, x - y)\n    maxy = max(maxy, x + y)\n\nh = int(input())\nfor i in range(h):\n    a, b = list(map(int, input().split()))\n    x = a - b\n    y = a + b\n    maxxy = max(\n        max(abs(minx - x), abs(maxx - x)),\n        max(abs(miny - y), abs(maxy - y))\n        )\n    if  maxxy < dist:\n        dist = maxxy\n        res = i + 1\n\nprint(dist)\nprint(res)\n
t = int(input())\nfor i in range(t):\n    a = int(input())\n    if a >= 4:\n        print(a % 2)\n    else:\n        print(4 - a)
import sys\ninput = sys.stdin.readline\n\nN, M = list(map(int, input().split()))\nA = []\nfor _ in range(N):\n    l, r = list(map(int, input().split()))\n    A.append([l, r])\nZ = []\nfor _ in range(M):\n    l, r = list(map(int, input().split()))\n    Z.append([l, r])\nMA = 5*10**5+1\nlg = 20\n\nX = [[-1]*MA for i in range(lg)]\nfor i in range(N):\n    X[0][A[i][0]] = max(X[0][A[i][0]], A[i][1])\nfor i in range(1, MA):\n    X[0][i] = max(X[0][i], X[0][i-1])\n\nfor k in range(1, lg):\n    for i in range(MA):\n        a = X[k-1][i]\n        if a >= 0:\n            X[k][i] = X[k-1][a]\n\nfor a, b in Z:\n    ans = 1\n    for k in range(lg)[::-1]:\n        if X[k][a] < b:\n            a = X[k][a]\n            ans += 2**k\n    print(-1 if X[0][a] < b or ans > MA else ans)\n
def main():\n    v = {\n        "1" : 2,\n        "2" : 5,\n        "3" : 5,\n        "4" : 4,\n        "5" : 5,\n        "6" : 6,\n        "7" : 3,\n        "8" : 7,\n        "9" : 6,\n        "0" : 6\n    }\n    a, b = map(int, input().split())\n    answer = 0\n\n    for i in range(a, b + 1):\n        s = str(i)\n\n        for e in s:\n            answer += v[e]\n\n    print(answer)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()
R=lambda:list(map(int,input().split()))\nn,k,x=R()\na=list(reversed(R()))\nprint(sum(x if i < k else a[i] for i in range(n))) \n
line = input().split()\nn = int(line[0])\nm = int(line[1])\n\nW = [int(w) for w in input().split()]\nB = [int(b) for b in input().split()]\n\nans = 0\nlst = [0 for i in range(n)]\nfor i in range(m):\n    arr = list(lst)\n    for j in range(i):\n        if B[i - j - 1] == B[i]:\n            break\n        arr[B[i - j - 1] - 1] = 1\n    for i in range(n):\n        if arr[i] == 1:\n            ans += W[i]\nprint(ans)\n            \n
n = 2*2*2*3*3*5*7\nm = int(input())\nprint(m//n)\n
n, k = map(int, input().split())\nj = 0\nfor i in input():\n  if i == '.':\n    j = 0\n  else:\n    j += 1\n    if j >= k:\n      print("NO")\n      break\nelse:\n  print("YES")
def dlog(x, n):\n  bigMod = 5 ** n\n  ans = [None, 0, 1, 3, 2][x % 5]\n  val = 2 ** ans % bigMod\n  mod, phi = 5, 4\n  phiVal = 2 ** phi % bigMod\n  for i in range(2, n + 1):\n    nextMod = mod * 5\n    while val % nextMod != x % nextMod:\n      val = val * phiVal % bigMod\n      ans += phi\n    phi *= 5\n    phiVal = (phiVal *\n              phiVal % bigMod *\n              phiVal % bigMod *\n              phiVal % bigMod *\n              phiVal % bigMod)\n    mod = nextMod\n  return ans\n\ndef main():\n  inp = input()\n  n = len(inp)\n  a = int(inp)\n  for m in range(n + 1):\n    l = a * 10 ** m\n    x, mod = l, 2 ** (n + m)\n    if x % mod != 0:\n      x += mod - x % mod\n    if x % 5 == 0:\n      x += mod\n    if x < l + 10 ** m:\n      assert x % mod == 0 and x % 5 != 0\n      x = x // mod\n      mod = 5 ** (n + m)\n      print(n + m + dlog(x % mod, n + m))\n      return\n  assert False\n\ndef __starting_point():\n  cnt = int(input())\n  for i in range(cnt):\n    main()\n__starting_point()
def split(a,n,s,l):\n    pieces = []\n\n    i = 1\n    tmpmin = a[0]\n    tmpmax = a[0]\n    tmppc  = [a[0]]\n    while i<n:\n        if abs(a[i]-tmpmin)<=s and abs(a[i]-tmpmax)<=s:\n            tmppc.append(a[i])\n            if a[i]<tmpmin: tmpmin=a[i]\n            elif a[i]>tmpmax: tmpmax = a[i]\n        else:\n            pieces.append(tmppc)\n            tmppc = [a[i]]\n            tmpmin = a[i]\n            tmpmax = a[i]\n        i += 1\n    pieces.append(tmppc)\n\n    fail = False        \n    for j in range(len(pieces)):\n        if len(pieces[j])<l:\n            if j>0:\n                prevpc = pieces[j-1]\n                minj = min(pieces[j])\n                maxj = max(pieces[j])\n                \n                while len(pieces[j])<l:\n                    tmp = prevpc.pop()\n                    if abs(tmp-minj)<=s and abs(tmp-maxj)<=s:\n                        pieces[j].insert(0,tmp)\n                        if tmp<minj: minj=tmp\n                        elif tmp>maxj: maxj=tmp\n                    else:\n                        return -1\n                    if len(prevpc)<l:\n                        return -1\n            else:\n                return -1\n    return len(pieces)\n\nn,s,l = [int(s) for s in input().split()]\na = [int(s) for s in input().split()]\n\n\nres = split(a,n,s,l)\nif res<0:\n    a.reverse()\n    res = split(a,n,s,l)\nprint(res)\n    \n\n\n\n
def takeClosest(myList, myNumber):\n\n    """\n\n    Assumes myList is sorted. Returns closest value to myNumber.\n\n\n\n    If two numbers are equally close, return the smallest number.\n\n    """\n\n    if len(myList) == 0:\n\n        return 9e10\n\n    pos = bisect_left(myList, myNumber)\n\n    if pos == 0:\n\n        return myList[0]\n\n    if pos == len(myList):\n\n        return myList[-1]\n\n    before = myList[pos - 1]\n\n    after = myList[pos]\n\n    if after - myNumber < myNumber - before:\n\n       return after\n\n    else:\n\n       return before\n\n\n\nfrom bisect import bisect_left\n\nfrom math import ceil\n\n\n\nn, m, n_stairs, n_elevators, v = map(int, input().split(" "))\n\n\n\nif n_stairs > 0:\n\n    stairs = list(map(int, input().split(" ")))\n\nelse:\n\n    stairs = []\n\n    input()\n\nif n_elevators > 0:\n\n    elevators = list(map(int, input().split(" ")))\n\nelse:\n\n    elevators = []\n\n    input()\n\nqueries = int(input())\n\nres = []\n\nfor i in range(queries):\n\n    x1, y1, x2, y2 = map(int, input().split(" "))\n\n    next_elevator = takeClosest(elevators, (y1 + y2) / 2)\n\n    next_stairs = takeClosest(stairs, (y1 + y2) / 2)\n\n    time_elevator = abs(x1 - x2) / v\n\n    time_stairs = abs(x1 - x2)\n\n\n\n    mi = min(y1, y2)\n\n    ma = max(y1, y2)\n\n    if next_elevator < mi:\n\n        time_elevator += (mi - next_elevator) * 2\n\n    elif next_elevator > ma:\n\n        time_elevator += (next_elevator - ma) * 2\n\n\n\n    if next_stairs < mi:\n\n        time_stairs += (mi - next_stairs) * 2\n\n    elif next_stairs > ma:\n\n        time_stairs += (next_stairs - ma) * 2\n\n\n\n    dis = abs(y1 - y2)\n\n    if time_elevator < time_stairs:\n\n        dis += time_elevator\n\n    else:\n\n        dis += time_stairs\n\n    if x1 == x2:\n\n        res.append(abs(y1 - y2))\n\n    else:\n\n        res.append(ceil(dis))\n\nprint(*res, sep="\n")\n\n\n\n# Made By Mostafa_Khaled
counts = {}\nrcount = {}\n\ninput()\n\nm = 0\nfor i, x in enumerate(map(int, input().split())):\n	if x in counts:\n		rcount[counts[x]].remove(x)\n		if not rcount[counts[x]]:\n			del rcount[counts[x]]\n		counts[x] += 1\n		if counts[x] not in rcount: rcount[counts[x]] = set()\n		rcount[counts[x]].add(x)\n	else:\n		counts[x] = 1\n		if 1 not in rcount: rcount[1] = set()\n		rcount[1].add(x)\n	keys = list(rcount)\n	if len(keys) == 2 and max(keys) - min(keys) == 1 and len(rcount[max(keys)]) == 1 or len(keys) == 2 and min(keys) == 1 and len(rcount[1]) == 1 or len(keys) == 1 and (len(rcount[keys[0]]) == 1 or keys[0] == 1):\n		m = max(m, i)\n\nprint(m + 1)
k=0\n\nd = [0] * 200005\nx = int(input())\np = list(map(int, input().split(' ')))\nfor i in range(len(p)):\n    d[p[i]] = i\n\nfor i in range(1, x):\n    k += abs(d[i+1] - d[i])\n\nprint(k)\n
n = int(input())\nnum = list(map(int, input().split()))\nfor i in range(n - 1):\n    if i % 2 == 0:\n        num.pop(num.index(max(num)))\n    else:\n        num.pop(num.index(min(num)))\nprint(*num)
3\n\nmem = [-1] * 100000\n\ndef f(x):\n    if x == 0:\n        return 0\n    if x < 100000 and mem[x] != -1:\n        return mem[x]\n    if x % 2 == 0:\n        res = f(x // 2)\n    else:\n        res = f((x - 1) // 2) + 1\n    if x < 100000:\n        mem[x] = res\n    return res\n\nn = int(input())\na = list(map(int, input().split()))\ncnt = {}\nfor v in a:\n    k = f(v)\n    cnt[k] = cnt.get(k, 0) + 1\nprint(sum([v * (v - 1) // 2 for v in list(cnt.values())]))\n
t = int(input())\n\nfor _ in range(t):\n    [n, x] = [int(v) for v in input().split()]\n    print(2 * x)
for _ in range(int(input())):\n    am = int(input())\n    arr = list(map(int,input().split()))\n    if arr[0] + arr[1] > arr[-1]:\n        print(-1)\n    else:\n        print(1,2,am)
import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a = [0] + [int(i) for i in sys.stdin.readline().split()]\n\n    dp = [[0]*(n + 1) for i in range(n + 1)]\n    ans = 0\n\n    maxnum = [0] * (10**5 + 2)\n    maxmod = [0] * 7\n\n    for y in range(n + 1):\n        maxmod = [0] * 7\n\n        for ai in a:\n            maxnum[ai] = 0\n\n        for i in range(y):\n            maxmod[a[i] % 7] = max(maxmod[a[i] % 7], dp[i][y])\n            maxnum[a[i]] = max(maxnum[a[i]], dp[i][y])\n\n        for x in range(y + 1, n + 1):\n            dp[x][y] = max(maxmod[a[x] % 7], maxnum[a[x] + 1], maxnum[a[x] - 1], dp[0][y]) + 1\n            dp[y][x] = dp[x][y]\n            maxmod[a[x] % 7] = max(maxmod[a[x] % 7], dp[x][y])\n            maxnum[a[x]] = max(maxnum[a[x]], dp[x][y])\n            ans = max(ans, dp[x][y])\n\n    print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()
n, x = list(map(int, input().split()))\nlink1 = list(map(int, input().split()))\nlink2 = [0] * (n + 1)\nfor i, v in enumerate(link1, 1):\n    if v != 0:\n        link2[v] = i\n\n\ntable = [False] * n\ntable[0] = True\nfor i, v in enumerate(link1, 1):\n    if v == 0:\n        len = 0\n        flag = False\n        now = i\n        while now:\n            len += 1\n            if now == x:\n                flag = True\n                pos = len\n            now = link2[now]\n        if not flag:\n            for j in reversed(list(range(n - len))):\n                if table[j]:\n                    table[j + len] = True\nfor i in range(n):\n    if table[i]:\n        print(i + pos)\n
n, k = map(int, input().split())\nt = list(map(int, input().split()))\nt = [t[0]] + [t[i] for i in range(1, len(t)) if t[i] != t[i - 1]]\np = [0] * (k + 1)\nfor i in range(1, len(t) - 1):\n    if t[i - 1] == t[i + 1]: p[t[i]] += 2\n    else: p[t[i]] += 1\np[t[0]] += 1\np[t[-1]] += 1\nprint(p.index(max(p)))
n = int(input())\none = sum([int(x) for x in input().strip().split()])\ntwo = sum([int(x) for x in input().strip().split()])\nthree = sum([int(x) for x in input().strip().split()])\nprint(one-two)\nprint(two-three)\n\n
import math as mt \nimport sys,string\ninput=sys.stdin.readline\nprint=sys.stdout.write\nimport random\nfrom collections import deque,defaultdict\nL=lambda : list(map(int,input().split()))\nLs=lambda : list(input().split())\nM=lambda : map(int,input().split())\nI=lambda :int(input())\nt=I()\nd=defaultdict(str)\nml=0\np=0\nfor _ in range(t):\n    s=input().split()\n    w=s[0]\n    x=list(map(int,s[1::]))\n    for i in range(1,len(x)):\n        r=d[x[i]-1]\n        if(len(r)<len(w)):\n            d[x[i]-1]=w\n    ml=max(ml,len(w)+x[-1]-1)\nans="a"*ml\nans=list(ans)\n#print(d)\np=-1\nz=sorted(list(d.keys()))\nfor i in z:\n    if(i+len(d[i])>p):\n        if(i>=p):\n            for j in range(i,i+len(d[i])):\n                ans[j]=d[i][j-i]\n        else:\n            leave=p-i\n            f=max(i,p)\n            #print(ans,"@",d[i],p,d[i][leave::])\n            for j in range(leave,len(d[i])):\n                ans[f]=d[i][j]\n                f+=1\n            #print(ans,"*")\n        p=i+len(d[i])\n    \nfor i in ans:\n    print(i)\n        \n
n = int(input())\nst = input()\nans = n\ni = 1\nwhile i < n:\n    if st[i - 1] != st[i]:\n        ans -= 1\n        i += 1\n    i += 1\nprint(ans)\n
a = int(input())\nlt = sorted(list(map(int, input().split())))\n\nfor i in range(len(lt)//2):\n	print(lt[i], lt[-i-1])
#!/usr/bin/env python3\n\ntry:\n    while True:\n        n = int(input())\n        prev_x, prev_y = list(map(int, input().split()))\n        prev_d = 0\n        result = 0\n        for i in range(n):\n            x, y = list(map(int, input().split()))\n            if y > prev_y:\n                d = 0\n            elif x > prev_x:\n                d = 1\n            elif y < prev_y:\n                d = 2\n            else:\n                d = 3\n            if ((d + 1) & 0x3) == prev_d:\n                result += 1\n            prev_x, prev_y = x, y\n            prev_d = d\n        print(result)\n\nexcept EOFError:\n    pass\n
def main():\n    n, m = list(map(int, input().split()))\n\n    p_words = set()\n    e_words = set()\n\n    for _ in range(n):\n        p_words.add(input())\n    for _ in range(m):\n        e_words.add(input())\n\n    common = p_words & e_words\n\n    p_words -= common\n    e_words -= common\n\n    we_win = False\n    p_turn = True\n\n    a, b, c = len(p_words), len(e_words), len(common)\n\n    while True:\n        if c > 0:\n            c -= 1\n        else:\n            if p_turn:\n                if a == 0:\n                    we_win = False\n                    break\n                else:\n                    a -= 1\n            else:\n                if b == 0:\n                    we_win = True\n                    break\n                else:\n                    b -= 1\n\n        p_turn = not p_turn\n\n    print("YES" if we_win else "NO")\n\nmain()\n
n, m = map(int, input().split())\nsum = n ** 2\ncolx = n\ncoly = n\nusedx = [False] * n\nusedy = [False] * n\nfor i in range(m):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    if not usedx[x]:\n        sum -= coly\n        usedx[x] = True\n        colx -= 1\n    if not usedy[y]:\n        sum -= colx\n        usedy[y] = True\n        coly -= 1\n    print(sum, end = ' ')\n
3\n\n__import__("sys").setrecursionlimit(10 ** 6)\n\ndef dfs(u, tr, used):\n    used[u] = True\n    ans = 1\n    for v in tr[u]:\n        if not used[v]:\n            ans += dfs(v, tr, used)\n    return ans\n\n\nn, m = list(map(int, input().split()))\nif n != m + 1:\n    print("no")\n    return\n\ntr = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    tr[a].append(b)\n    tr[b].append(a)\n\nused = [False] * n\nif dfs(0, tr, used) == n:\n    print("yes")\nelse:\n    print("no")\n
rndid = "cuuhkjc"\nfor _ in range(int(input())):\n  input()\n  ls = 'a' * 51\n  oa = ord('a')\n  print(ls)\n  for a in input().split():\n    a = int(a)\n    ls = ls[:a] + ls[a:].translate({oa: 'b', oa + 1: 'a'})\n    print(ls)
import math\nn = int(input())\na = list(map(int, input().split()))\nd = {0: 1}\nm = 1\nans = 0\nfor i in a:\n	#print("i=", i)\n	divisors = []\n	for j in range(1, min(m, int(math.sqrt(i))) + 1):\n		if i % j == 0:\n			k = int(i / j)\n			divisors.append(j)\n			if j != k and k <= m:\n				divisors.append(k)\n	#print("divisors=", divisors)\n	new_d = {0: 1}\n	for j in divisors:\n		ans = (ans + d[j - 1]) % 1000000007\n		#print("j=", j, "ans=", ans)\n		new_d[j] = d.get(j, 0) + d[j - 1]\n		if j == m:\n			m = m + 1\n	#print("new_d=", new_d)\n	for j in new_d:\n		d[j] = new_d[j]\nprint(ans)
n = int(input())\na = [int(i) for i in input().split()]\na.sort()\nb = []\nfor i in range(n - 1, (n + 1) // 2 - 1, -1):\n    b.append(a[i])\na = a[:(n + 1) // 2]\nc = []\nfor i in range(len(b)):\n    c.append(a[i])\n    c.append(b[i])\nif len(a) > len(b):\n    c.append(a[-1])\nprint(*c)
import sys\nimport math\nfrom collections import defaultdict\nfrom itertools import combinations\nfrom itertools import permutations\ninput = lambda : sys.stdin.readline().rstrip()\nread = lambda : list(map(int, input().split()))\ndef write(*args, sep="\n"):\n  for i in args:\n    sys.stdout.write("{}".format(i) + sep)\nINF = float('inf')\nMOD = int(1e9 + 7)\n\nfor _ in range(int(input())):\n  n = int(input())\n  arr = sorted([input() for i in range(n)], key=lambda x:len(x))\n\n  zero_cnt, one_cnt = 0, 0\n  for i in arr:\n    zero_cnt += i.count('0')\n    one_cnt += i.count('1')\n  total = (zero_cnt//2) + (one_cnt//2)\n  \n  ans = 0\n\n  for i in arr:\n    if total >= len(i)//2:\n      total -= len(i)//2 \n      ans += 1\n  \n  print(ans)\n
n, m = list(map(int, input().split()))\np = [0] * n\ne = []\nfor i in range(m):\n    q, w = list(map(int, input().split()))\n    p[w - 1] += 1\n    p[q - 1] += 1\n    e.append([min(q, w), max(q, w)])\ndp = [1] * n\ne.sort()\nfor i in range(m):\n    dp[e[i][1] - 1] = max(dp[e[i][1] - 1], dp[e[i][0] - 1] + 1)\nans = 0\nfor i in range(n):\n    ans = max(ans, dp[i] * p[i])\nprint(ans)\n
n = int(input())\nA = list(map(int, input().split()))\n\ncnt = 0\nfor i in range(n):\n	cnt += (A[i] == i)\n\nif cnt == n:\n	print(n)\nelse:\n	ind = False\n	for i in range(n):\n		ind |= (A[i] != i and A[A[i]] == i)\n	if ind:\n	    print(cnt + 2)\n	else:\n		print(cnt + 1)
n,m,q=list(map(int,input().split()))\na=input().split()\nc={x:([x],[]) for x in a}\nfor i in range(m):\n    t,x,y=input().split()\n    if t=='2':\n        sign=1\n    else: sign=0\n    if c[x][0] is c[y][1-sign]:\n        print("NO")\n        continue\n    print("YES")\n    if c[x][0] is c[y][sign]:\n        continue\n    c1,c2=c[x],c[y]\n    if len(c1[0])+len(c1[1])<len(c2[0])+len(c2[1]):\n        c1,c2=c2,c1\n    s1,a1=c1\n    if sign==0:\n        s2,a2=c2\n    else:\n        a2,s2=c2\n    s1+=s2\n    a1+=a2\n    cs=s1,a1\n    for x in s2:\n        c[x]=cs\n    ca=a1,s1\n    for x in a2:\n        c[x]=ca\nfor i in range(q):\n    x,y=input().split()\n    if c[x][0] is c[y][0]:\n        print(1)\n    elif c[x][0] is c[y][1]:\n        print(2)\n    else:\n        print(3)\n
n = int(input())\nh = [False] * n\nv = [False] * n\nresult = [ ]\nfor i in range(n * n):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    if not h[a] and not v[b]:\n        h[a] = v[b] = True\n        result.append(i + 1)\nprint(' '.join(map(str, result)))\n
# -*- coding: utf-8 -*-\nimport sys\nfrom operator import itemgetter\nfrom fractions import gcd\nfrom math import ceil, floor\nfrom copy import deepcopy\nfrom itertools import accumulate\nfrom collections import Counter\nimport math\nfrom functools import reduce\nfrom bisect import bisect_right\nsys.setrecursionlimit(200000)\ninput = sys.stdin.readline\ndef ii(): return int(input())\ndef mi(): return map(int, input().rstrip().split())\ndef lmi(): return list(map(int, input().rstrip().split()))\ndef li(): return list(input().rstrip())\ndef debug(x): print("debug: ", x, file=sys.stderr)\n# template\n\n\nclass BIT:\n    def __init__(self, x, d=0):\n        if isinstance(x, int):\n            self.size = x\n            self.tree = [d for _ in range(self.size + 1)]\n        elif isinstance(x, list):\n            self.size = len(x)\n            self.tree = [d for _ in range(self.size + 1)]\n            self.build(x)\n        else:\n            raise TypeError\n\n    def build(self, arr):\n        if isinstance(arr, list):\n            raise TypeError\n        for num, x in enumerate(arr):\n            self.add0(num, x)\n\n    def sum(self, i):\n        s = self.tree[0]\n        while i > 0:\n            s += self.tree[i]\n            i -= (i & -i)\n        return s\n\n    def add(self, i, a):\n        if(i == 0):\n            return\n        while (i <= self.size):\n            self.tree[i] += a\n            i += (i & -i)\n\n    def bisect_left(self, w):\n        if w <= 0:\n            return 0\n        x = 0\n        r = 1\n        while (r < self.size):\n            r <<= 1\n        k = r\n        while (k > 0):\n            if x + k <= self.size and self.tree[x + k] < w:\n                w -= self.tree[x + k]\n                x += k\n            k >>= 1\n        return x + 1\n\n    def query(self, l, r):\n        return self.sum(r - 1) - self.sum(l - 1)\n\n    def sum0(self, i):\n        return self.sum(i + 1)\n\n    def add0(self, i, a):\n        self.add(i + 1, a)\n\n    def query0(self, l, r):\n        return self.sum(r) - self.sum(l)\n\n    def __getitem__(self, item):\n        _tmp = item.indices(self.size + 1)\n        return [self.sum(i) - self.sum(i - 1) for i in range(_tmp[0], _tmp[1], _tmp[2])]\n\n    def __str__(self):\n        return str(self[1:self.size + 1])\n\n# END CUT HERE\n\n\ndef main():\n    s, b = mi()\n    a = lmi()\n    d = []\n    g = []\n    for i in range(b):\n        _d, _g = mi()\n        d.append(_d)\n        g.append(_g)\n    tmp = [(d[i], g[i]) for i in range(b)]\n    tmp.sort(key=lambda x: x[0])\n    d.sort()\n    # print(tmp)\n    # print(d)\n    bit = BIT(b)\n    for i in range(b):\n        bit.add0(i, tmp[i][1])\n    for i in range(s):\n        tmp = bisect_right(d, a[i])\n        # print(tmp)\n        print(bit.sum(tmp), end=" ")\n    print()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
import sys\nn,m=list(map(int,sys.stdin.readline().split()))\n\nA=list(map(int,sys.stdin.readline().split()))\n\nAns=[1]\n\nE={}\nE[A[-1]]=1\nfor i in range(n-2,-1,-1):\n    if(A[i] in E):\n        Ans.append(Ans[-1])\n    else:\n        E[A[i]]=1\n        Ans.append(Ans[-1]+1)\n\nAnswer=""\nfor i in range(m):\n    x=int(sys.stdin.readline())\n    x-=1\n    x=n-1-x\n    Answer+=str(Ans[x])+"\n"\nsys.stdout.write(Answer)\n
import math\na,b,c=map(int,input().split())\nD = b ** 2 - 4 * a * c\nx1 = (-b + math.sqrt(D)) / (2 * a)\nx2 = (-b - math.sqrt(D)) / (2 * a)\nans1=max(x1,x2)\nans=min(x1,x2)\nprint(ans1)\nprint(ans)
from math import floor,log\nfor _ in range(int(input())):\n    n=int(input())\n    p=(n*(n+1))//2\n    f=floor(log(n,2))\n    p-=2*(2**(f+1)-1)\n    print(p)\n
from sys import *\n\nmaxn = 3 * 10 ** 5 + 5\n\nfre = [0 for i in range(maxn)]\nisprime = [1 for i in range(maxn)]\nprime = []\ndivi = [0 for i in range(maxn)]\nfact = [1] * 10\n\ndef nCr(n, r):\n	if n < r:\n		return 0\n	if n == r:\n		return 1\n	pro = 1\n	for i in range(r):\n		pro *= (n - i)\n	pro //= fact[r]\n	return pro\n\nn = int(stdin.readline())\narr = list(map(int, stdin.readline().split()))\nfor i in arr:\n	if i is 1:\n		print(1)\n		return\n	fre[i] += 1\n\ndivi[1] = n\nfor i in range(2, maxn):\n	if isprime[i] is 1:\n		prime.append(i)\n	for j in range(1, maxn):\n		if i * j >= maxn:\n			break\n		isprime[i * j] = 0\n		divi[i] += fre[i * j]\n\nfor i in range(1, 10):\n	fact[i] = fact[i - 1] * i\n\nmobius = [0 for i in range(maxn)]\n\nfor i in range(1, maxn):\n	mobius[i] = 1\nfor p in prime:\n	if p * p >= maxn:\n		break\n	x = p * p\n	for j in range(x, maxn, x):\n		mobius[j] = 0\nfor p in prime:\n	for j in range(p, maxn, p):\n		mobius[j] *= -1 \n		\nfor r in range(2, 10):\n	coprime = 0\n	for d in range(1, maxn):\n		ncr = nCr(divi[d], r)\n		coprime += mobius[d] * ncr\n	if coprime > 0:\n		print(r)\n		return\nprint(-1)
import copy\nimport fractions\nimport itertools\nimport numbers\nimport string\nimport sys\n\n###\n\ndef to_basex(num, x):\n	while num > 0:\n		yield num % x\n		num //= x\n\ndef from_basex(it, x):\n	ret = 0\n	p = 1\n	for d in it:\n		ret += d*p\n		p *= x\n	return ret\n\n###\n\ndef core():\n	n = int(input())\n	a = [int(x) for x in input().split()]\n	\n	m = min(a)\n	s = sum(a)\n	ans = s\n	for ai in a:\n		for d in range(1, ai+1):\n			if ai % d == 0:\n				cand = s - ai - m + ai//d + m*d\n				ans = min(ans, cand)\n	\n	print(ans)\n\n\ncore()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n
import sys;\nsys.stdin = open('input.txt', 'r')\nsys.stdout = open('output.txt', 'w')\nn=int(sys.stdin.readline());\n\na=[int(x) for x in sys.stdin.readline().split()]\nfront=[0]*(len(a)+2)\nfor i in range(n):\n    front[i+1]=front[i]+ (1 if (a[i]>=0) else 0 )   \nback=[0]*(len(a)+2)\nfor i in range(n-1,-1,-1):\n    back[i+1]=back[i+2]+ (1 if (a[i]<=0) else 0)\nans=len(a)+1\nfor i in range(1,n):\n    ans=min(ans,front[i]+back[i+1])\nprint("%d"%ans)\n    \n
import sys\nfrom collections import deque\n\ndef solve():\n    xadj, yadj = [0, 0, - 1, 1, -1, -1, 1, 1], [1, -1, 0, 0, -1, 1, -1, 1]\n    x0, y0, x1, y1, = rv()\n    n, = rv()\n    good = set()\n    visited = dict()\n    for seg in range(n):\n        r, a, b, = rv()\n        for c in range(a, b + 1): good.add((r, c))\n    points = deque()\n    points.append((x0, y0, 0))\n    visited[(x0, y0)] = 0\n    while len(points) > 0:\n        cur = points.popleft()\n        for i in range(8):\n            pos = (cur[0] + xadj[i], cur[1] + yadj[i])\n            if pos in good and pos not in visited:\n                points.append((pos[0], pos[1], cur[2] + 1))\n                visited[pos] = cur[2] + 1\n    print(visited[(x1, y1)] if (x1, y1) in visited else - 1)\n\n\n\n\n\n\n\ndef prt(l): return print(''.join(l))\ndef rv(): return map(int, input().split())\ndef rl(n): return [list(map(int, input().split())) for _ in range(n)]\nif sys.hexversion == 50594544 : sys.stdin = open("test.txt")\nsolve()
from collections import defaultdict\nn = int(input())\nA = [int(x) for x in input().split()]\nD = defaultdict(int)\nfor a in A: D[a] += 1\nS = set(D.keys())\nans = len(S) - 1\nwhile S:\n    for k in D:\n        D[k] -= 1\n        if D[k] <= 0 and k in S:\n            S.remove(k)\n    ans += len(S) - 1\nprint(ans + 1)\n
n = int(input())\nout = []\n\nMOD = 998244353 \n\nfor i in range(1, n + 1):\n    if i == n:\n        out.append(10)\n    else:\n        nex = 2 * 9 * pow(10, n - i - 1, MOD) * 10\n        if i < n - 1:\n            nex += (n - 1 - i) * 9 * 9 * pow(10, n - i - 2, MOD) * 10\n        out.append(nex % MOD)\n        \n\nprint(' '.join(map(str,out)))\n#print(sum((i + 1) * out[i] for i in range(n)))\n#print(n * pow(10, n, MOD))\n
n,p=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nr=a[p-1]+b[0]\ncou=0\nfor i in range(p-1):\n    if a[i]+b[-1]<=r:\n        cou+=1;del b[-1]\nprint(p-cou)
n = int(input())\na = list(map(int, input().split()))\nmaxi = 0\nans = 0\nfor i in range(n):\n    a[i] -= 1\n    maxi = max(maxi, a[i])\n    if maxi == i:\n        ans += 1\nprint(ans)\n
3\n\nimport array\nimport math\nimport os\nimport sys\n\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef dprint(*value, sep=' ', end='\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef solve(N, M, G):\n    if N == 2:\n        return [0, 1]\n\n    degv = [set() for _ in range(5)]\n    for i in range(M):\n        d = len(G[i])\n        if d == 0 or d >= 5:\n            return []\n        degv[d].add(i)\n\n    layer_vcount = 1 << (N - 1)\n    vs = degv[1]\n    levels = bytearray(M)\n    ans = []\n    for level in range(1, N):\n        #dprint('level', level, [x for x in levels])\n        #dprint('vs', vs)\n        #dprint('layer_vcount', layer_vcount)\n\n        if len(vs) not in (layer_vcount - 1, layer_vcount):\n            return []\n        if len(vs) == layer_vcount - 1:\n            if ans:\n                return []\n            if level == 1:\n                sp_deg_off = -1\n            else:\n                sp_deg_off = 1\n        else:\n            sp_deg_off = 0\n        #dprint('sp_deg_off', sp_deg_off)\n\n        ndeg = 3 if level < N - 1 else 2\n        us = set()\n        ss = set()\n\n        for v in vs:\n            #dprint('v', v)\n            levels[v] = level\n            p = None\n            for u in G[v]:\n                if levels[u] == 0:\n                    if p is not None:\n                        return []\n                    p = u\n                    break\n            #dprint('  p', p)\n            if p is None:\n                return []\n            deg = len(G[p])\n            #dprint('  deg', deg)\n\n            if deg == ndeg:\n                us.add(p)\n            elif deg == ndeg + sp_deg_off:\n                ss.add(p)\n            elif sp_deg_off == 0 and deg == ndeg + 1:\n                ss.add(p)\n            else:\n                return []\n\n        #dprint('us', us)\n        #dprint('ss', ss)\n\n        if sp_deg_off != 0:\n            if len(ss) != 1:\n                return []\n            (sp,) = list(ss)\n            ans = [sp]\n            us.add(sp)\n\n        if sp_deg_off == 0:\n            if level == N - 2:\n                if ss:\n                    return []\n                if not ans:\n                    li = list(us)\n                    li.sort()\n                    return li\n            if len(ss) > 1:\n                return []\n\n        vs = us\n        layer_vcount >>= 1\n\n    return ans\n\n\ndef main():\n    N = int(inp())\n    M = (1 << N) - 2\n    G = [[] for _ in range(M)]\n    for _ in range(M - 1):\n        a, b = [int(e) - 1 for e in inp().split()]\n        G[a].append(b)\n        G[b].append(a)\n\n    ans = solve(N, M, G)\n    print(len(ans))\n    if ans:\n        print(*[v + 1 for v in ans])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n, m= list(map(int, input().split()))\ns=set()\nfor i in range(m):\n    x,y=list(map(int, input().split()))\n    s.add((x,y))\n\nif m*2 == n*(n-1)  or n<2 or n==2 and m==1:\n    print('NO')\n    return\n\nx, y = 0,0\nfor i in range(1,n+1):\n    for j in range(i+1,n+1):\n        if (i, j) not in s and (j, i) not in s:\n            x=i\n            y=j\n            break\nx-=1\ny-=1\nprint('YES')\nl = list(range(1,n+1))\nif x == 1:\n    y,x=x,y\nif y == 0:\n    x, y=y,x\nl[x], l[0] = 1, l[x]\nl[y], l[1] = 2, l[y]\nprint(*l)\nl[y]=1\nprint(*l)\n
n=int(input())\nl=[int(c) for c in input().split()]\nll=[]\nres=[]\nhead=0\ndia=0\nfor i in range(1,n):\n    if l[i]==1:\n        l[i]=0\n        ll.append(i)\n    else:\n        res.append((head+1,i+1))\n        l[head]-=1\n        dia+=1\n        head=i\n        l[head]-=1\nif l[head]>0 and len(ll)>0:\n    res.append((ll[0]+1,head+1))\n    l[head]-=1\n    del(ll[0])\n    dia+=1\nif l[0]>0 and len(ll)>0:\n    res.append((ll[0]+1,1))\n    l[0]-=1\n    del(ll[0])\n    dia+=1\nfor i in ll:\n    for j in range(n):\n        if l[j]>0:\n            res.append((j+1,i+1))\n            l[j]-=1\n            break\nif len(res)<n-1:\n    print("NO")\nelse:\n    print("YES "+str(dia))\n    print(n-1)\n    for p in res:\n        print(p[0],end =" ")\n        print(p[1])
n,k=map(int,input().split())\nL=list(map(int,input().split()))\nind=[]\nfor i in range(n):\n    if L[i]>n-k:ind.append(i)\nm=1\nfor i in range(len(ind)-1):\n    m*=(ind[i+1]-ind[i])\n    m%=998244353\nprint(((n*(n+1)//2)-((n-k)*((n-k)+1))//2),m)
import sys\ninput = sys.stdin.readline\n\nn = int(input())\n\ndef MakeSet(x):\n     x.parent = x\n     x.rank   = 0\n\ndef Union(x, y):\n     xRoot = Find(x)\n     yRoot = Find(y)\n     if xRoot.rank > yRoot.rank:\n         yRoot.parent = xRoot\n     elif xRoot.rank < yRoot.rank:\n         xRoot.parent = yRoot\n     elif xRoot != yRoot:\n         yRoot.parent = xRoot\n         xRoot.rank = xRoot.rank + 1\n\ndef Find(x):\n     if x.parent == x:\n        return x\n     else:\n        x.parent = Find(x.parent)\n        return x.parent\n\nclass Node:\n    def __init__ (self, label):\n        self.label = label\n    def __str__(self):\n        return self.label\n\nused = [0] * 26\nnodes = [Node(ch) for ch in range(26)]\n[MakeSet(node) for node in nodes] \n  \nfor _ in range(n):\n    s = input().strip()\n    prev = -1\n    for c in s:\n        val = ord(c) - 97\n        used[val] = 1\n        if prev != -1:\n            Union(nodes[prev], nodes[val])\n        prev = val\n\nouts = [0] * 26\nfor node in nodes:\n    outs[Find(node).label] += 1\n\ncount = 0\nfor val in outs:\n    if val != 0:\n        count += 1\n\nprint(count + sum(used) - 26)\n        \n
n = int(input())\n\nprint((n*(n-1)*(n-2)*(n-3)*(n-4))**2//120)
n = int(input())\nif n <= 2:\n	print("No")\nelse:\n	print("Yes")\n	print(1, (n + 1) // 2)\n	ans = []\n	for i in range(1, n + 1):\n		if i != (n + 1) // 2:\n			ans.append(i)\n	print(n - 1, *ans)\n
#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\n    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit\n    \nN, = getIntList()\n#print(N)\n\nif N%2==0:\n    print(N//2)\n    return\n\nfor i in range(2,110000):\n    if N%i==0:\n        print( (N-i)//2 +1)\n        return\n\nprint(1)\n\n\n
n = int(input())\nprint(2**(n+1) - 2)\n
def gen(a, b):\n    gener = ''\n    for i in range(k):\n        if a[i] == b[i]:\n            gener += a[i]\n        else:\n            if 'S' not in (a[i], b[i]):\n                gener += 'S'\n            elif 'E' not in (a[i], b[i]):\n                gener += 'E'\n            else:\n                gener += 'T'\n    return gener\n\n\nn, k = list(map(int, input().split()))\ncards = []\ndiff = set()\nfor i in range(n):\n    s = input()\n    cards.append(s)\n    diff.add(s)\nans = 0\nwas = set()\nfor i in range(n):\n    for j in range(i + 1, n):\n        aaa = gen(cards[i], cards[j])\n        if aaa in diff and max(cards[i], cards[j], aaa) + min(cards[i], cards[j], aaa) not in was:\n            ans += 1\n            was.add(max(cards[i], cards[j], aaa) + min(cards[i], cards[j], aaa))\nprint(ans)\n
read = lambda: map(int, input().split())\nn = int(input())\na = list(read())\nwas = [0] * (n + 1)\nbal = ans = 0\nfor i in a:\n    if was[i]:\n        bal -= 1\n    else:\n        bal += 1\n        was[i] = 1\n    ans = max(ans, bal)\nprint(ans)
import sys\n\nn=int(sys.stdin.readline())\nA=[]\nB=[]\ndiff=0\nAns=""\nfor i in range(n):\n    x,y=list(map(int,sys.stdin.readline().split()))\n    if(diff+x<=500):\n        diff+=x\n        Ans+="A"\n    else:\n        diff-=y\n        Ans+="G"\nif(abs(diff)<=500):\n    sys.stdout.write(Ans)\nelse:\n    print(-1)\n
#import sys\n\n#fin = open("input.txt", 'r')\n#fout = open("output.txt", 'w')\n\n#fin = open("input.txt", 'r')\n#fout = open("output.txt", 'w')\n\nn = int(input())\na = list(map(int, input().split()))\n\nif 1 not in a:\n    print(1)\nelse:\n    print(-1)\n
import operator\n\n\nn = int(input())\nxs = list(map(int, str.split(input())))\nif xs == sorted(xs):\n\n    print(0)\n\nelse:\n\n    swaps = []\n    counter = 0\n    while xs:\n\n        i = xs.index(min(xs))\n        if i:\n\n            swaps.append(str.format("{} {}", counter, i + counter))\n\n        xs[0], xs[i] = xs[i], xs[0]\n        xs.pop(0)\n        counter += 1\n\n    print(len(swaps))\n    print(str.join("\n", swaps))\n
n = int(input())\nout = []\ndef p(a,b,d):\n    out.append(str(a + 1 + d) + ' ' + str(b+1+d))\n\np2 = 1\nwhile 2 * p2 <= n:\n    p2 *= 2\n\nfor d in (0, n - p2):\n    bit = 1\n    while bit < p2:\n        for i in range(p2):\n            if i ^ bit > i:\n                p(i, i ^ bit, d)\n        bit *= 2\nprint(len(out))\nprint('\n'.join(out))\n
import collections\n\nn = int(input())\nAs = list(map(int, input().split()))\n\ndef solve(n, As):\n    counter = collections.Counter(As)\n    candidates = []\n    prev_freq = 0\n    for num, freq in counter.most_common():\n        if prev_freq and prev_freq!= freq:\n            break\n        candidates.append(num)\n        prev_freq = freq\n    lr = {cand:[] for cand in candidates}\n    for i, a in enumerate(As, 1):\n        if a in lr:\n            lr[a].append(i)\n    minspan = float('inf')\n    for pos in list(lr.values()):\n        if pos[-1] - pos[0] < minspan:\n            minspan = pos[-1] - pos[0]\n            LR = (pos[0], pos[-1])\n    return LR\n\nprint(*solve(n, As))\n
n,m,a=map(int,input().split())\nb=list(map(int,input().split()))\nfor i in range(m):\n    if i==0:\n        diffs=[b[0]]\n    else:\n        diffs.append(b[i]-b[i-1])\npowers=[a%998244353]\nfor i in range(30):\n    powers.append(powers[-1]**2%998244353)\ndef power(x,y,binpowers):\n    prod=1\n    bits=bin(y)[2:]\n    bits=bits[::-1]\n    for i in range(len(bits)):\n        if bits[i]=="1":\n            prod*=binpowers[i]\n            prod%=998244353\n    return prod\nmaxi=b[-1]\nprod1=power(a,n-2*maxi,powers)\nfor guy in diffs:\n    newprod=power(a,guy,powers)\n    newprod=(newprod*(newprod+1))//2\n    newprod%=998244353\n    prod1*=newprod\n    prod1%=998244353\nprint(prod1)
\nfrom sys import stdin\n\nn = int(stdin.readline())\na = list(map(int,stdin.readline().split()))\na = [0] + a\n\nans = n\n\ndp = [float("inf")] * (n+1)\ndp[0] = 0\nfor i in range(1,n+1):\n\n    nmin = float("inf")\n    for j in range(i-1,-1,-1):\n        if a[j] <= nmin:\n            dp[i] = min(dp[i] , dp[j] + max(0,a[i]-a[j]) + (i-j-1) )\n        nmin = min(nmin,a[j])\n\n#print (dp)\nfor i in range(n+1):\n    ans = min(ans , dp[i] + n-i)\nprint (ans)\n\n
read = lambda: list(map(int, input().split()))\nn, c = read()\nt = list(read())\ncnt = 1\nfor i in range(1, n):\n    if t[i] - t[i - 1] > c:\n        cnt = 1\n    else:\n        cnt += 1\nprint(cnt)\n
"""\nCodeforces Round 251 Div 2 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0:\n        return inputs\n    if mode == 1:\n        return inputs.split()\n    if mode == 2:\n        return [int(x) for x in inputs.split()]\n\ndef write(s="\n"):\n    if isinstance(s, list): s = " ".join(s)\n    s = str(s)\n    print(s, end="")\n\n################################################### SOLUTION\nn,x = read()\nc = read()\nc.sort()\nprint(sum(max(x-i,1)*c[i] for i in range(n)))
from math import sin, cos, pi\n\nn, r = map(int, input().split())\n\nprint(n * r**2 * sin(pi / n) * cos(pi * (n // 2) / n) / cos(pi * (n // 2 - 1) / n))
a, b = map(int, input().split(' '))\nl = list(map(int, input().split(' ')))\nstot = 0\nssq = 0\nfor i in range(1, b+1):\n    stot += l.count(i)\n    ssq += (l.count(i)**2)\n\nprint(int((stot**2 - ssq)/2))
from math import sqrt\n\na, b, c = list(map(int, input().split()))\n# a, b, c = 2, 5, 3\n\nV1 = a ** 3 * sqrt(2) / 12\nV2 = sqrt(2) * (b ** 3) / 6\nV3 = ((5 + sqrt(5)) / 24) * (c ** 3)\n\nprint(V1 + V2 + V3)\n
# calculate convex of polygon v.\n# v is list of complexes stand for points.\ndef convex(v, eps=1e-8):\n\n    # fetch the seed point\n    v.sort(key=lambda x:(x.real,x.imag))\n    v = v[0:1] + sorted(v[1:], key=lambda x:(x-v[0]).imag/abs(x-v[0]))\n\n    n = 1\n    for i in range(2, len(v)):\n        while n > 1 and ((v[n]-v[n-1])*(v[i]-v[n]).conjugate()).imag>-eps:\n            n -= 1\n        else:\n            n += 1\n            v[n] = v[i]\n\n    v[n+1:] = []\n\n    return v\n\n# calculate the area of a polygon v, anti-clockwise.\n# v is list of complexes stand for points.\ndef area(v):\n    ans = 0\n    for i in range(2, len(v)):\n        ans += ((v[i]-v[i-1])*(v[i-1]-v[0]).conjugate()).imag\n    return ans * 0.5\n\nn = int(input())\nv = [complex(*tuple(map(int, input().split()))) for i in range(0, n)]\n\nw = convex(v)\nn = len(w)\n\nans = 0\n\ndef tri(i, j, k): return abs(((w[i]-w[j])*(w[i]-w[k]).conjugate()).imag) * 0.5\n\nfor i in range(0, n):\n    \n    for j in range(i+2, n):\n\n        if i == 0 and j == n-1: continue\n        \n        l = i + 1\n        r = j\n        while l < r-1:\n            k = l+r>>1\n            if tri(i, j, k) > tri(i, j, k-1):\n                l = k\n            else:\n                r = k\n                \n        s1 = tri(i, j, l)\n\n        l = j - n + 1\n        r = i\n        while l < r-1:\n            k = l+r>>1\n            if tri(i, j, k) > tri(i, j, k-1):\n                l = k\n            else:\n                r = k\n        \n        s2 = tri(i, j, l)\n\n        ans = max(ans, s1 + s2)\n\nif n == 3:\n    for p in v:\n        if not p in w:\n            w.append(p)\n            ans = max(ans, area(w))\n            w.pop()\n        \nprint(ans)\n
rr = lambda: input().strip()\nrri = lambda: int(rr())\nrrm = lambda: list(map(int, rr().split()))\nMOD = 10**9 + 7\n\nclass DSU:\n    def __init__(self, N):\n        #R * C is the source, and isn't a grid square\n        self.par = list(range(N+1))\n        self.rnk = [0] * (N+1)\n        self.sz = [1] * (N+1)\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        if self.rnk[xr] < self.rnk[yr]:\n            xr, yr = yr, xr\n        if self.rnk[xr] == self.rnk[yr]:\n            self.rnk[xr] += 1\n\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n        \ndef solve(N, K, edges):\n    graph = [[] for _ in range(N)]\n    dsu = DSU(N)\n    for u,v,w in edges:\n        u-=1;v-=1\n        if w==0: #red\n            dsu.union(u, v)\n\n    ans = pow(N, K, MOD)\n    for x in range(N):\n        if dsu.find(x) == x:\n            ans -= pow(dsu.size(x), K, MOD)\n            ans %= MOD\n    return ans\n\nfor tc in range(1):#rri()):\n    N, K = rrm()\n    edges = [rrm() for _ in range(N-1)]\n    print(solve(N, K, edges))\n
n = int(input())\ns = input()\nx = 0\ny = 0\nans = 0\npred = -1\nfor c in s:\n    if c == 'U':\n        y += 1\n    else:\n        x += 1\n    if x == y:\n        continue\n    if x > y:\n        cur = 0\n    else:\n        cur = 1\n    if cur != pred and pred != -1:\n        ans += 1\n    pred = cur\nprint(ans)\n
n = int(input())\nr = 0\nfor i in range(n):\n    a = list(map(int, input().split(' ')))\n    r += (a[2] - a[0] + 1) * (a[3] - a[1] + 1)\nprint(r)
t, sx, sy, ex, ey = map(int, input().split())\nd = {'W':max(0, sx - ex), 'E':max(0, ex - sx), 'N':max(0, ey - sy), 'S':max(0, sy - ey)}\nfor (i, c) in enumerate(input(), 1):\n  if d[c] > 0:\n    d[c] -= 1\n  if any(d.values()) == False:\n    print(i)\n    break\nelse:\n  print(-1)
s = input()\n\nx = int(s[0] + s[2] + s[4] + s[3] + s[1])\nprint(str(x**5)[-5:])
def getIntList():\n    return list(map(int, input().split()));\nn, k = getIntList();\np=getIntList();\nchoosed=[False]*256;\nleft=[i for i in range(256)];\nfor i, x in enumerate(p):\n    if not choosed[x]:\n        best=x;\n        #print(x-1, max(-1, x-k));\n        for j in range(x-1, max(-1, x-k), -1):\n            #print('try ',j)\n            if not choosed[j]:\n                best=j;\n            else:\n                if x-left[j]<k:\n                    best=left[j];\n                break;\n        #print('best=',best)\n        for j in range(best, x+1):\n            choosed[j]=True;\n            left[j]=best;\n    p[i]=left[x];\nprint(' '.join(map(str, p)));
# -*- coding: utf-8 -*-\n"""\nCreated on Mon Jan  8 10:20:50 2018\n\n@author: yanni\n"""\n\n#import random\n\nn, T = [int(x) for x in input().split()]\n#n, T = [100000,10000*10000]\nprob = []\nvals = [set() for stuff in range(n+2)]\nfor i in range(n):\n    a, t = [int(x) for x in input().split()]\n    #a = random.randint(1,n)\n    #t = random.randint(1, 10000)\n    prob.append((i+1,a,t))\nprob.sort(key = lambda tup: tup[2])\ncurrindex = 0\nmaxindex = -1\nsolve = set()\nmem = set()\ntimeleft = T\ntarget = 1\n\nfor currindex in range(n):\n    i, a, t = prob[currindex]\n    if (timeleft < t):\n        break\n    if (timeleft >= t and a >= target):\n        vals[a].add(currindex)\n        solve.add(currindex)\n        timeleft -= t\n        if (len(solve) == target):\n            maxindex = currindex\n            #print(target)\n            for p in vals[target]:\n                solve.remove(p)\n                timeleft += prob[p][2]\n            target += 1\n\nbestsolve = solve | vals[target-1]\nsolvelist = [x for x in bestsolve if x<=maxindex]\ntarget = len(solvelist)\nprint(target)\nprint(target)\nfor p in solvelist:\n    print(prob[p][0], end=" ")\nprint()
import sys\ndef Z(s):\n    return int(s)-1\n\nn=int(sys.stdin.readline())\n\nHotels=[False]*(n)\n\nRep=[0]*(n+1)\nChains=[]\n\nType=list(map(int,sys.stdin.readline().split()))\nfor i in range(n):\n    if(Type[i]==1):\n        Hotels[i]=True\nA=list(map(Z,sys.stdin.readline().split()))\n\nfor item in A:\n    Rep[item]+=1\nfor i in range(n):\n    if(Hotels[i]):\n        Chains.append([i])\n        x=A[i]\n        if(x==-1):\n            continue\n        while(A[x]!=-1 and Rep[x]<=1):\n            Chains[-1].append(x)\n            x=A[x]\n        if(Rep[x]<=1):\n            Chains[-1].append(x)\n\n\n    \n        \nif(n==1):\n    print(1)\n    print(1)\nelse:\n        \n    X=max(Chains,key=len)\n\n\n\n    sys.stdout.write(str(len(X))+"\n")\n    sys.stdout.write(str(X[-1]+1))\n\n    for i in range(len(X)-2,-1,-1):\n        sys.stdout.write(" "+str(X[i]+1))       \n        \n
# python3\n\ndef readline(): return tuple(map(int, input().split()))\n\n\ndef ceil_div(num, den): return (num - 1) // den + 1\n\n\ndef main():\n    n, x1, x2 = readline()\n    c = readline()\n\n    xx = (x1, x2)\n\n    servers = sorted(enumerate(c, start=1), key=lambda p: p[1])\n    for (i, a) in enumerate(servers):\n        for (j, x) in enumerate(xx):\n            kj = ceil_div(x, a[1])\n            if i + kj < n and (n - i - kj) * servers[i + kj][1] >= sum(xx) - x:\n                print("Yes")\n                l1 = servers[i:i+kj]\n                l2 = servers[i+kj:]\n                if j: l1, l2 = l2, l1\n                print(len(l1), len(l2))\n                print(" ".join(str(d[0]) for d in l1))\n                print(" ".join(str(d[0]) for d in l2))\n                return\n    print("No")\n\n\nmain()\n\n\n\n\n# Made By Mostafa_Khaled\n
n = int(input())\nans = 0\nans = ans + (n * (n-1) * (n-2) * (n-3) * (n-4)) // (2*3*4*5)\nans = ans + (n * (n-1) * (n-2) * (n-3) * (n-4) * (n-5)) // (2*3*4*5*6)\nans = ans + (n * (n-1) * (n-2) * (n-3) * (n-4) * (n-5) * (n-6)) // (2*3*4*5*6*7)\nprint(ans)
s = str(input())\ns = (s[:1].upper() + s[1:]).rstrip()\nprint(s)\n
n = int(input())\nh1 = list(map(int, input().split()))\nh2 = list(map(int, input().split()))\n\nr1 = r2 = 0\nfor i in range(n):\n    r1, r2 = max(r1, r2 + h1[i]), max(r2, r1 + h2[i])\n\nprint(max(r1, r2))\n
data = input().split(" ")\nn = int(data[0])\nm = int(data[1])\ndebts = []\ntotal = 0\nfor i in range(n):\n	debts.append(0)\nfor i in range(m):\n	data = input().split(" ")\n	data = [int(x) for x in data]\n	debts[data[0]-1] -= data[2]\n	debts[data[1]-1] += data[2]\n\nfor i in range(len(debts)):\n	if debts[i] < 0:\n		total += (debts[i]*-1)\n\nprint(total)
def cons(l):\n    m = 0\n    res = 0\n    for v in l:\n        if v:\n            res += 1\n            if res > m:\n                m = res\n        else:\n            res = 0\n    return m\n\nn, m, q = list(map(int, input().split()))\ngrid = []\ncurr = [0] * n\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\n    curr[i] = cons(grid[i])\n\nfor _ in range(q):\n    i, j = list(map(int, input().split()))\n    i -= 1\n    j -= 1\n    grid[i][j] = 0 if grid[i][j] else 1\n    curr[i] = cons(grid[i])\n    print(max(curr))\n
a = input()\nk = int(input())\nn = len(a)\nans = 0\nMOD = 10 ** 9 + 7\nm = 1 - pow(2, n * k, MOD)\nm *= pow(1 - pow(2, n, MOD), MOD - 2, MOD)\nm %= MOD\nfor i in range(n - 1, -1, -1):\n    if a[i] == '0' or a[i] == '5':  \n        ans += (m * pow(2, i, MOD)) % MOD\nans = ans % MOD\nif ans < 0:\n    ans += MOD\nprint(ans)\n    \n
ii = lambda: int(input())\nmi = lambda: list(map(int, input().split()))\nli = lambda: list(mi())\nfrom bisect import bisect_left as lb, bisect_right as ub\n\nn, k, A, B = mi()\na = li()\na.sort()\n\ndef f(l, r):\n    cnt = ub(a, r) - lb(a, l)\n    if cnt == 0:\n        return A\n    if l == r:\n        return B * cnt\n    m = (l + r) >> 1\n    return min(B * cnt * (r - l + 1), f(l, m) + f(m + 1, r))\n\nprint(f(1, 2 ** n))\n
n = int(input())\ndp = [0] * (n + 1)\nmaxlev = 0\nmod = 1000000007\nlst = "s"\ndp[0] = 1\nfor i in range(n):\n  s = input()\n  if lst == "f":\n    for j in reversed(range(1, maxlev+2)):\n      dp[j] = dp[j-1]\n    maxlev += 1\n    dp[0] = 0\n  else:\n    sum = 0\n    for j in reversed(range(0, maxlev+1)):\n      sum = (sum + dp[j]) % mod\n      dp[j] = sum\n  lst = s\nres = 0\nfor i in range(0, maxlev + 1):\n  res = (res + dp[i]) % mod\nprint(res)
n, t = map(int, input().split())\nprint(n*pow(1.000000011, t))
import sys\nfrom math import *\n\ndef minp():\n	return sys.stdin.readline().strip()\n\ndef mint():\n	return int(minp())\n\ndef mints():\n	return map(int, minp().split())\n\nn, m = mints()\na = list(minp())\nx = 0\nt = 0\nd = 1\nfor i in range(n-1):\n	b = list(minp())\n	l = x\n	r = x\n	wall = 0\n	while True:\n		t += 1\n		if b[x] == '.':\n			break\n		if x + d == m or x + d < 0 or a[x+d] == '#':\n			wall += 1\n			d = -d\n			if wall == 2:\n				print("Never")\n				return\n		elif a[x+d] == '+':\n			wall = 0\n			a[x+d] = '.'\n			d = -d\n		elif l <= x+d and x+d <= r:\n			if d == 1:\n				t += r-x-1\n				x = r\n			else:\n				t += x-l-1\n				x = l\n		else:\n			x += d\n			r = max(r,x)\n			l = min(l,x)\n	a, b = b, a\nprint(t)
import time\n\nn, m =map(int, input().split())\n\nnames={None:0}\n\ncount={i:0 for i in range(1, m+1)}\n\na=[0]*(n+1)\n\nfor i in range(n):\n    l=list(input().split())\n    if l[0]=='2':\n        if l[1] not in names:\n            names[l[1]]=len(names)\n        a[i]=names[l[1]]\n        count[a[i]]=count[a[i]]+1\n    # else a[i] stays 0\n\ndense=[set() for _ in range(m+1)]\n\nbulk=set()\n\n# filling dense array of arrays\nfor i in range(n):\n    if a[i]==0:\n        bulk.clear()\n        continue\n    if a[i] in bulk: continue\n    for j in bulk:\n        dense[j].add(a[i])\n        dense[a[i]].add(j)\n    bulk.add(a[i])\n\nres=0\nhappy=set()\nunhappy=set()\nmindep=99\n\nindependent=set()\ndependent=set()\nfor i in range(1, m+1):\n    if len(dense[i])==0: independent.add(i)\n    else:\n        dependent.add(i)\n        if len(dense[i])<mindep:\n            mindep=len(dense[i])\n\n# print([i for i in dependent if mindep==len(dense[i])])\n\nfor k in list(dependent):\n    # iterate to... too sly\n    happy.clear()\n    unhappy.clear()\n    bulk.clear()\n    bulk.update(dependent)\n    happy.add(k)\n    bulk.remove(k)\n    for j in dense[k]:\n        if j in bulk:\n            unhappy.add(j)\n            bulk.remove(j)\n\n    # now making least connected happy\n    while bulk:\n        mini = min([len(dense[i]) for i in bulk])\n        for i in list(bulk):\n            if len(dense[i])==mini and (i in bulk):\n                happy.add(i)\n                bulk.remove(i)\n                for j in dense[i]:\n                    if j in bulk:\n                        unhappy.add(j)\n                        bulk.remove(j)\n                continue\n\n    res=max(res,len(happy))\n\nprint(res+len(independent))
n = int(input())\nprint(3*n*(n+1)+1)
arr = []\nfor i in input():\n    arr.append(i)\nn = len(arr)\nres = 0\nadd = [0] * (n + 10)\nadd[n] = 1 / n\nfor i in range(n - 1, 0, -1):\n    add[i] = add[i + 1] + 1 / i\nfor i in range(n):\n    if arr[i] in ['I', 'E', 'A', 'O', 'U', 'Y']:\n        x = min(i, n - i - 1)\n        y = max(i, n - i - 1)\n        res += x + 1\n        res += (x + 1) * (add[x + 2] - add[y + 1])\n        res += (n + 1) * add[y + 1] - (n - y)\nprint(res)
n = int(input())\nfor i in range(1,n):\n    if i%2 == 1:\n        print('I hate that',end=' ')\n    else:\n        print('I love that',end=' ')\nif n%2 == 1:\n    print('I hate it',end=' ')\nelse:\n    print('I love it',end=' ')
n, s, m, k = map(int, input().split())\na = list(map(int, input().split()))\nnt = [-1 for i in range(n+1)]\nfor i in range(s):\n	l, r  = map(int, input().split())\n	l-=1\n	for j in range(l, r):\n		nt[j] = max(nt[j], r)\n\ndp = [[0 for i in range(m+1)] for i in range(n+1)]\nsum = [0 for i in range(n+1)]\ndef solve(mid):\n	for i in range(n+1):\n		for j in range(m+1):\n			dp[i][j] = 0\n	for i in range(n):\n		if a[i] <= mid:\n			sum[i+1] = 1\n		else:\n			sum[i+1] = 0\n		sum[i+1] += sum[i]\n	for i in range(0, n+1):\n		for j in range(m+1):\n			if i > 0:\n				dp[i][j] = max(dp[i][j], dp[i-1][j])\n			if nt[i] != -1 and j < m:\n				dp[nt[i]][j+1] = max(dp[nt[i]][j+1], dp[i][j] + sum[nt[i]] - sum[i])\n	return dp[n][m]\n\nlo, hi, ans = 1, 10**9, -1\nwhile lo <= hi:\n	mid = (lo+hi)//2\n	if(solve(mid) >= k):\n		ans = mid\n		hi = mid-1\n	else:\n		lo = mid+1\n\nprint(ans)
def main():\n    _, k, m = [int(x) for x in input().split()]\n    a = []\n    last = ("-1", 0)\n    a.append(last)\n    for ai in input().split():\n        if last[0] == ai:\n            last = (ai, last[1]+1)\n            a[-1] = last\n        else:\n            last = (ai, 1)\n            a.append(last)\n\n        if last[1] == k:\n            a.pop()\n            last = a[-1]\n    a.pop(0)\n\n    s1 = 0\n    while len(a) > 0 and a[0][0] == a[-1][0]:\n        if len(a) == 1:\n            s = a[0][1] * m\n            r1 = s % k\n            if r1 == 0:\n                print(s1 % k)\n            else:\n                print(r1 + s1)\n            return\n        join = a[0][1] + a[-1][1]\n\n        if join < k:\n            break\n        elif join % k == 0:\n            s1 += join\n            a.pop()\n            a.pop(0)\n        else:\n            s1 += (join // k) * k\n            a[0] = (a[0][0], join % k)\n            a.pop()\n            break\n\n    s = 0\n    for ai in a:\n        s += ai[1]\n\n    print(s*m + s1)\n\n\ndef __starting_point():\n    main()\n__starting_point()
#python3\n# utf-8\n\nnodes_nr, edges_nr = (int(x) for x in input().split())\nnode_idx___cost = [int(x) for x in input().split()]\nnode_idx___neigh_idxes = [[] for x in range(nodes_nr)]\nfor _ in range(edges_nr):\n    node1_idx, node2_idx = (int(x) - 1 for x in input().split())\n    node_idx___neigh_idxes[node1_idx].append(node2_idx)\n    node_idx___neigh_idxes[node2_idx].append(node1_idx)\n\nnode_idx___is_visited = [False for x in range(nodes_nr)]\n\nans = 0\nfor node_idx in range(nodes_nr):\n    if node_idx___is_visited[node_idx]:\n        continue\n    stack = [node_idx]\n    node_idx___is_visited[node_idx] = True\n    cheapest_cost = node_idx___cost[node_idx]\n    while stack:\n        curr_node_idx = stack.pop()\n        for neigh_idx in node_idx___neigh_idxes[curr_node_idx]:\n            if node_idx___is_visited[neigh_idx]:\n                continue\n            stack.append(neigh_idx)\n            cheapest_cost = min(cheapest_cost, node_idx___cost[neigh_idx])\n            node_idx___is_visited[neigh_idx] = True\n    ans += cheapest_cost\nprint(ans)\n
class Ddict:\n    def __init__(self):\n        self.dicts={}\n    def add(self,key):\n        d=self.dicts\n        for i in key:\n            if i not in d:\n                d[i]={}\n            d=d[i]\n        d[' ']=''\n    def find(self,key):\n        if key=='':\n            return '',''\n        d=self.dicts\n        q=[]\n        h=[key[0]]\n        for i in key:\n            if i not in d:\n                if ' ' in d and len(d)==1:\n                    return ''.join(q),''.join(h)\n                return '',''\n            q.append(i)\n            if len(d)!=1:\n                h=q[:]\n            d=d[i]\n        if ' ' in d and len(d)==1:\n            return ''.join(q),''.join(h)\n        return '',''\nwords = Ddict()\nans=0\nwhile True:\n    try:\n        x=input()\n        if not x:\n            break\n    except:\n        break\n    ans+=len(x)+1\n    ws=[[]]\n    for i in x:\n        if i in '.,?!\'- ':\n            if ws[-1]:\n                ws.append([])\n        else:\n            ws[-1].append(i)\n    ws=list([''.join(e) for e in ws])\n    for w in ws:\n        next_word,helped_word = words.find(w)\n        if next_word and next_word!=helped_word:\n            ans-=len(next_word)-len(helped_word)-1\n        words.add(w)\nprint(ans)\n
n, m, d = list(map(int, input().split()))\n\na = []\nb = []\n\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\nfor i in range(m):\n    b.append(list(map(int, input().split())))\n\na = sorted(a, key=lambda x: x[0] + (1- x[1] * 1e-10))\nb = sorted(b, key=lambda x: x[0] + (1- x[1] * 1e-10))\n\ntc, td = 0, 0\n\ntc += a[-1][0]\ntc += b[-1][0]\ntd += a[-1][1]\ntd += b[-1][1]\n\nai = n - 1\nbi = m - 1\n\nif td > d:\n    print(0)\n    return\n\nwhile ai > 0:\n    t = ai - 1\n    if td + a[t][1] <= d:\n        td += a[t][1]\n        tc += a[t][0]\n        ai -= 1\n        continue\n    else:\n        break\n    \ncmax = tc\n\nwhile bi > 0:\n    bi -= 1\n    tc += b[bi][0]\n    td += b[bi][1]\n    \n    while td > d and ai < n:\n        tc -= a[ai][0]\n        td -= a[ai][1]\n        ai += 1\n    \n    if ai == n:\n        break\n    \n    if td <= d:\n        cmax = max(cmax, tc)\n        \nprint(cmax)
input()\nres_h = 0\nres_ha = 0\nres_har = 0\nres_hard = 0\nfor s, a in zip(input(), list(map(int, input().split()))):\n	if s == 'h':\n		res_h += a\n	elif s == 'a':\n		res_ha = min(res_ha + a, res_h)\n	elif s == 'r':\n		res_har = min(res_har + a, res_ha)\n	elif s == 'd':\n		res_hard = min(res_hard + a, res_har)\nprint(res_hard)\n
nmq = input().split(' ')\nn, m, q = int(nmq[0]), int(nmq[1]), int(nmq[2])\nmt = []\nfor i in range(0, n):\n    mt.append([])\n    for j in range(0, m):\n        mt[-1].append((i, j))\nres = []\nfor i in range(0, n):\n    res.append([])\n    for j in range(0, m):\n        res[-1].append(0)\nfor i in range(0, q):\n    ins = input().split(' ')\n    if ins[0] == '1':\n        r = int(ins[1]) - 1\n        b = mt[r][0]\n        for j in range(0, m-1):\n            mt[r][j] = mt[r][j+1]\n        mt[r][m-1] = b\n    if ins[0] == '2':\n        c = int(ins[1]) - 1\n        b = mt[0][c]\n        for j in range(0, n-1):\n            mt[j][c] = mt[j+1][c]\n        mt[n-1][c] = b\n    if ins[0] == '3':\n        r = int(ins[1]) - 1\n        c = int(ins[2]) - 1\n        x = int(ins[3])\n        p = mt[r][c]\n        res[p[0]][p[1]] = x\nfor i in range(0, n):\n    for j in range(0, m-1):\n        print(res[i][j],' ', end='')\n    print(res[i][-1])\n    \n
n = int(input())\na = [2, 3 ,5, 7]\nans = 0\nimport operator\nimport itertools\nimport functools\nfor i in range(1, 5):\n    for p in itertools.combinations(a, i):\n        x = functools.reduce(operator.mul, p)\n        ans += (-1) ** (i + 1) * (n // x)\n\nprint(n - ans)\n
import sys\n\ndef inside(a,b):\n    return ((a[0]-b[0])**2 + (a[1]-b[1])**2) < (a[2]+b[2])**2\n\n\ndef main():\n    pi = 3.14159265358979323\n    n = int(sys.stdin.readline())\n    a = []\n    p = [-1]*n\n    for i in range(n):\n        x,y,r = map(int,sys.stdin.readline().split())\n        a.append([x,y,r])\n\n    for i in range(n):\n        for j in range(n):\n            if i==j :\n                continue\n            if inside(a[i],a[j]):\n                if a[i][2] < a[j][2]:\n                    if p[i] == -1:\n                        p[i] = j\n                    elif a[p[i]][2]>a[j][2]:\n                        p[i] = j\n                else:\n                    if p[j] == -1:\n                        p[j] = i\n                    elif a[p[j]][2]>a[i][2]:\n                        p[j] = i\n\n    q = []\n    for i in range(n):\n        if p[i] == -1:\n            q.append((i,True))\n\n    s = len(q)\n    ans = 0.0\n    for i in range(s):\n        c, b = q[i]\n        for j in range(n):\n            if p[j] == c:\n                q.append((j,True))\n        ans+= pi * a[c][2] * a[c][2]\n\n    q = q[s:]\n    while len(q)!=0 :\n        c,b = q.pop()\n        for j in range(n):\n            if p[j] == c:\n                q.append((j,not b))\n        if b:\n            ans+= pi * a[c][2] * a[c][2]\n        else:\n            ans-= pi * a[c][2] * a[c][2]\n\n    print(ans)\n\n\nmain()
def xmax(x, y):\n    if x[1] > y[1]:\n        return x\n    return y\n\nclass SegTree:\n    def __init__(self, init_val, n, ide_ele, seg_func):\n        self.segfunc = seg_func\n        self.num = 2**(n-1).bit_length()\n        self.ide_ele = ide_ele\n        self.seg=[self.ide_ele]*2*self.num\n        for i in range(n):\n            self.seg[i+self.num-1]=init_val[i]    \n        for i in range(self.num-2,-1,-1) :\n            self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) \n        \n    def update(self, k, x):\n        ll = k\n        k += self.num-1\n        self.seg[k] = (ll, self.seg[k][1] + x)\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n\n    def update2(self, k, x):\n        k += self.num-1\n        self.seg[k] = x\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n        \n    def query(self, p, q):\n        if q<=p:\n            return self.ide_ele\n        p += self.num-1\n        q += self.num-2\n        res=self.ide_ele\n        while q-p>1:\n            if p&1 == 0:\n                res = self.segfunc(res,self.seg[p])\n            if q&1 == 1:\n                res = self.segfunc(res,self.seg[q])\n                q -= 1\n            p = p//2\n            q = (q-1)//2\n        if p == q:\n            res = self.segfunc(res,self.seg[p])\n        else:\n            res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])\n        return res\n\nimport sys;input=sys.stdin.readline\nN, M = list(map(int, input().split()))\nX = list(map(int, input().split()))\nsts = [[] for _ in range(N)]\nfor i in range(1, M+1):\n    a, b = list(map(int, input().split()))\n    sts[a-1].append((i, b-1))\n    sts[b-1].append((i, a-1))\n    X[a-1] -= 1\n    X[b-1] -= 1\nminf = -(10 ** 18)-1\nss = SegTree([(i, x) for i, x in enumerate(X)], N, (-1, minf), xmax)\nf = False\nR = []\nvs = set()\nwhile True:\n    j, mx = ss.query(0, N)\n    if mx<0:\n        f=True\n        break\n    while sts[j]:\n        i, co = sts[j].pop()\n        if i in vs:\n            continue\n        vs.add(i)\n        ss.update(co, 1)\n        R.append(i)\n    if len(R) == M:\n        break\n    ss.update2(j, (j, minf))\n\nif f or len(R) != M:\n    print("DEAD")\nelse:\n    print("ALIVE")\n    print(*R[::-1])\n
n,k=list(map(int,input().split()))\n\nA=list(map(int,input().split()))\nL=[]\nfor i in range(k):\n    s=0\n    for j in range(i,n,k):\n        s+=A[j]\n    L.append(s)\n\nx=min(L)\n\nprint(L.index(x)+1)\n        \n
n = int(input())\nprint(4 * ((n - 3) * 3 * 3 * 4 ** max(0, n - 4) + 2 * 3 * 4 ** (n - 3)))\n
import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\n\ndef getN():\n    return int(input())\ndef getList():\n    return list(map(int, input().split()))\nimport math\n\nn, k = getList()\nnums = getList()\n\ndiff = []\n\nfor i, j in zip(nums, nums[1:]):\n    diff.append(j - i)\n\ndiff.sort()\nprint(sum(diff[:(n-k)]))
t = int(input())\nwhile t:\n    arr = list(map(int, input().split()))\n    c = 0\n    for i in arr:\n        if i % 2 == 1:\n            c += 1\n    if c <= 1:\n        print("Yes")\n    else:\n        if arr[0] and arr[1] and arr[2]:\n            arr[3] += 3\n            arr[0] -= 1\n            arr[1] -= 1\n            arr[2] -= 1\n            c = 0\n            for i in arr:\n                if i % 2 == 1:\n                    c += 1\n            if c <= 1:\n                print("Yes")\n            else:\n                print("No")\n        else:\n            print("No")\n    t -= 1
# import sys\n# sys.stdin = open('cf614b.in', 'r')\n\nimport re\n\np = re.compile(r'^10*$')\n\nn = int(input())\na = input().split()\n\nextra = '1'\nnumzero = 0\n\nfor ai in a:\n	if ai == '0':\n		print(0)\n		return\n	elif p.match(ai):\n		numzero += len(ai) - 1\n	else:\n		extra = ai\n\nprint(extra + '0' * numzero)
class Node(object):\n    def __init__(self):\n        super(Node, self).__init__()\n        self.next = [-1] * 26\n        self.trans = []\n        self.matches = 0\n        self.leaf = 0\n        self.link = 0\n\nclass AhoCorasick(object):\n    def __init__(self):\n        super(AhoCorasick, self).__init__()\n        self.T = [Node()]\n        self.T[0].link = 0\n\n    def insert_trie(self, s):\n        v = 0\n        for i in range(len(s)):\n            c = ord(s[i]) - ord('a')\n            if(self.T[v].next[c] == -1):\n                self.T[v].trans.append(c)\n                self.T[v].next[c] = len(self.T)\n                self.T.append(Node())\n            v = self.T[v].next[c]\n        self.T[v].leaf += 1\n        self.T[v].matches += 1\n\n    def set_suffix_link(self, S):\n        Q = []\n        for j in range(len(S)):\n            Q.append((j, 0, 0, 0))\n            #string index, index in string, state, suff state, \n        i = 0\n        while(i < len(Q)):\n            j,ind,v,suff = Q[i]\n            i += 1\n            c = ord(S[j][ind]) - ord('a')\n            if(ind>0):\n                while(suff>0 and self.T[suff].next[c]==-1):\n                    suff = self.T[suff].link\n                if(self.T[suff].next[c] != -1):\n                    suff = self.T[suff].next[c]\n            v = self.T[v].next[c]\n            self.T[v].link = suff\n            if(ind+1 < len(S[j])):\n                Q.append((j,ind+1,v,suff))\n\n    def set_matches(self):\n        i = 0\n        Q = [0]\n        while(i < len(Q)):\n            v = Q[i]\n            self.T[v].matches = self.T[v].leaf + self.T[self.T[v].link].matches\n            for c in self.T[v].trans:\n                Q.append(self.T[v].next[c])\n            i += 1\n\n    def build(self, S):\n        for i in range(len(S)):\n            self.insert_trie(S[i])\n        self.set_suffix_link(S)\n        #self.printTree()\n        self.set_matches()\n\n    def get(self, s):\n        v = 0\n        matches = []\n        for i in range(len(s)):\n            c = ord(s[i]) - ord('a')\n            while(v>0 and self.T[v].next[c] == -1):\n                v = self.T[v].link\n            if(self.T[v].next[c] != -1):\n                v = self.T[v].next[c]\n            matches.append(self.T[v].matches)\n        return matches\n\n    def printTree(self):\n        for i in range(len(self.T)):\n            print(str(i)+" leaf:"+str(self.T[i].leaf)+" link:"+str(self.T[i].link)+" matches:"+str(self.T[i].matches)+" : " , end='')\n            for j in range(26):\n                print(" "+str(chr(j+ord('a')))+"-"+(str(self.T[i].next[j]) if (self.T[i].next[j]!=-1) else "_")+" ", end='')\n            print()\n\nt = input()\nn = int(input())\npatterns = []\npatterns_rev = []\nfor i in range(n):\n    s = input()\n    patterns.append(s)\n    patterns_rev.append(s[::-1])\nt1 = AhoCorasick()\nt2 = AhoCorasick()\nt1.build(patterns)\nt2.build(patterns_rev)\n\nx1 = t1.get(t)\nx2 = t2.get(t[::-1])[::-1]\n\n#print(x1)\n#print(x2)\n\nans = 0\nfor i in range(len(x1)-1):\n    ans += x1[i] * x2[i+1]\n\nprint(ans)\n
n = int(input())\na = [[1] * n for i in range(n)]\nfor i in range(1, n):\n    for j in range(1, n):\n        a[i][j] = a[i - 1][j] + a[i][j - 1]\nprint(a[n - 1][n - 1])\n
n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\npossible = [[] for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        possible[i].append(a[i] & b[j])\n\nimport sys\nfor answer in range(2 ** 9):\n    answer_flag = 1\n    for i in range(n):\n        flag = 0\n        for x in possible[i]:\n            if answer | x == answer:\n                flag = 1\n                break\n        if flag == 0:\n            answer_flag = 0\n            break\n    if answer_flag:\n        print(answer)\n        return\n
import sys\nimport heapq as hq\n\nreadline = sys.stdin.readline\n\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\n\neps = 10**-7\n\ndef solve():\n    n, k = nm()\n    a = nl()\n    ans = [0]*n\n    ok = 10**9; ng = -4*10**18\n    while ok - ng > 1:\n        mid = (ok + ng) // 2\n        ck = 0\n        for i in range(n):\n            d =  9 - 12 * (mid + 1 - a[i])\n            if d < 0:\n                continue\n            ck += min(a[i], int((3 + d**.5) / 6 + eps))\n        # print(mid, ck)\n        if ck > k:\n            ng = mid\n        else:\n            ok = mid\n    for i in range(n):\n        d =  9 - 12 * (ok + 1 - a[i])\n        if d < 0:\n            continue\n        ans[i] = min(a[i], int((3 + d**.5) / 6 + eps))\n    # print(ans)\n    rk = k - sum(ans)\n    l = list()\n    for i in range(n):\n        if ans[i] < a[i]:\n            hq.heappush(l, (-a[i] + 3 * ans[i]**2 - 3 * ans[i] + 1, i))\n    for _ in range(rk):\n        v, i = hq.heappop(l)\n        ans[i] += 1\n        if ans[i] < a[i]:\n            hq.heappush(l, (-a[i] + 3 * ans[i]**2 - 3 * ans[i] + 1, i))\n    print(*ans)\n    return\n\n\nsolve()
n = input()\ns = [int(x) for x in input().split(' ')]\ng = input()\nA = 0\nB = 0\nfor i in range(len(g)):\n	if g[i] == 'A':\n		A += s[i]\n	else:\n		B += s[i]\n\nstartA, startB = A, B\nmaximum = B\n\nfor i in range(len(g)):\n	if g[i] == 'A':\n		A -= s[i]\n		B += s[i]\n	else:\n		A += s[i]\n		B -= s[i]\n	if B > maximum:\n		maximum = B\n\nA, B = startA, startB\n\nfor i in reversed(range(len(g))):\n	if g[i] == 'A':\n		A -= s[i]\n		B += s[i]\n	else:\n		A += s[i]\n		B -= s[i]\n	if B > maximum:\n		maximum = B\n\nprint(maximum)
n = int(input())\nprint(1 if n % 2 == 1 else 2)
n = int(input())\nd = 367\nF = [0 for i in range(d)]\nM = [0 for i in range(d)]\nfor i in range(n):\n    sex, l, r = input().split()\n    l, r = int(l), int(r)\n    if sex == 'F':\n        for j in range(l, r+1): F[j] += 1\n    else:\n        for j in range(l, r+1): M[j] += 1\nprint(2*max(min(F[i], M[i]) for i in range(d)))\n            \n
import sys\nimport heapq, functools, collections\nimport math, random\nfrom collections import Counter, defaultdict\n\n# available on Google, not available on Codeforces\n# import numpy as np\n# import scipy\n\nimport heapq as hq\nimport math\n\ndef dijkstra(G, s):\n    n = len(G)\n    visited = [False]*n\n    weights = [math.inf]*n\n    path = [None]*n\n    queue = []\n    weights[s] = 0\n    hq.heappush(queue, (0, s))\n    while len(queue) > 0:\n        g, u = hq.heappop(queue)\n        visited[u] = True\n        for v, w in G[u]:\n            if not visited[v]:\n                f = g + w\n                if f < weights[v]:\n                    weights[v] = f\n                    path[v] = u\n                    hq.heappush(queue, (f, v))\n    return path, weights\n\n\ndef solve(grid,sx,sy,ex,ey):  # fix inputs here\n    console("----- solving ------")\n    # console(grid,sx,sy,ex,ey)\n\n    minres = abs(sx-ex) + abs(sy-ey)\n    console(minres)\n    if grid == []:\n        return minres\n\n    d = defaultdict(list)\n    grid = [(i,x,y) for i,(x,y) in enumerate(grid)]\n\n    # x-order\n    grid = sorted(grid, key=lambda x: x[1])\n    for (i1,x1,y1),(i2,x2,y2) in zip(grid, grid[1:]):\n        d[i1].append((i2,x2-x1))\n        d[i2].append((i1,x2-x1))\n\n    grid = sorted(grid, key=lambda x: x[2])\n    for (i1,x1,y1),(i2,x2,y2) in zip(grid, grid[1:]):\n        d[i1].append((i2,y2-y1))\n        d[i2].append((i1,y2-y1))\n\n    for i,x,y in grid:\n        # start to x-axis\n        d[-2].append((i,abs(x-sx)))\n\n        # start to y-axis\n        d[-2].append((i,abs(y-sy)))\n\n        # point to destination\n        d[i].append((-1, abs(x-ex) + abs(y-ey)))\n\n    d[-1] = []\n    console(list(d.keys()))\n\n    idxs = {k:i for i,k in enumerate(d.keys())}\n    G = [[] for _ in range(len(idxs))]\n\n    for e,vrr in list(d.items()):\n        for v,cost in vrr:\n            G[idxs[e]].append((idxs[v],cost))\n    # console(G)\n\n    _,costs = dijkstra(G, idxs[-2])\n    \n\n    res = costs[idxs[-1]]\n\n    return min(minres, res)\n\n\ndef console(*args):  # the judge will not read these print statement\n    # print('\033[36m', *args, '\033[0m', file=sys.stderr)\n    return\n\n# fast read all\ninp = sys.stdin.readlines()\nfor case_num in [1]:\n    # read line as a string\n    # strr = input()\n\n    # read line as an integer\n    # k = int(input())\n    \n    # read one line and parse each word as a string\n    # lst = input().split()\n\n    # read one line and parse each word as an integer\n    _, nrows = list(map(int,inp[0].split()))\n    sx,sy,ex,ey = list(map(int,inp[1].split()))\n\n    currow = 2\n    # read matrix and parse as integers (after reading read nrows)\n    # lst = list(map(int,input().split()))\n    # nrows = lst[0]  # index containing information, please change\n    grid = []\n    for _ in range(nrows):\n        grid.append(list(map(int,inp[currow].split())))\n        currow += 1\n\n    res = solve(grid,sx,sy,ex,ey)  # please change\n    \n    # Google - case number required\n    # print("Case #{}: {}".format(case_num+1, res))\n\n    # Codeforces - no case number required\n    print(res)\n
N, M = map(int, input().split())\nif N == 1 and M == 1:\n    ans = 1\nelif N == 1:\n    ans = M-2\nelif M == 1:\n    ans = N-2\nelse:\n    ans = (N-2)*(M-2)\nprint(ans)
N=int(input())\nA=list(map(int,input().split()))\nA.sort()\nsm=0\nfor i in range(0,2*N,2):\n  sm+=A[i]\nprint(sm)\n
mod = 10**9+7\nrng = 2000100\nfctr = [1]+[0]*(rng-1)\nfor i in range(1,rng):\n  fctr[i] = fctr[i-1]*i%mod\ndef finv(x):\n  return pow(fctr[x],mod-2,mod)\ndef cmb(n,k):\n  if n<0 or k<0:\n    return 0\n  else:\n    return fctr[n]*finv(n-k)*finv(k)%mod\n\nx1,y1,x2,y2 = map(int,input().split())\nprint((cmb(x2+y2+2,x2+1)-cmb(x2+y1+1,y1)-cmb(x1+y2+1,x1)+cmb(x1+y1,x1))%mod)
\na,b,n = list(map(int,input().split()))\n\nprint((a*min(b-1,n)//b))\n
import sys\n\ndef myargsort(a):\n    b = list(zip(a, list(range(0, len(a)))))\n    b.sort()\n    r = [pr[1] for pr in b]\n    return r\n\nfin = sys.stdin\nn = int(fin.readline())\na = [int(number) for number in fin.readline().split()]\np = myargsort(a)\np.reverse()\nj = 0\naib = [0] * (n + 1)\n\ndef ultb(x):\n    return -(x ^ (-x)) // 2\n\ndef add(p, a, aib, n):\n    while p <= n:\n        aib[p] += a\n        p += ultb(p)\ndef suma(p, aib):\n    r = 0\n    while p > 0:\n        r += aib[p]\n        p -= ultb(p)\n    return r\n\nfor i in range(0, n):\n    add(i + 1, 1, aib, n)\nr = [0] * (n + 1)\nfor i in range(0, n):\n    if i > 0 and a[i - 1] > a[i]:\n        r[1] += 1\n    while j < n and a[p[j]] == a[p[i]]:\n        add(p[j] + 1, -1, aib, n)\n        j += 1\n    k = 2\n    while k < n and p[i] * k + 1 < n:\n        dr = min(n, p[i] * k + k + 1)\n        st = p[i] * k + 2\n        r[k] += suma(dr, aib) - suma(st - 1, aib)\n        k += 1\nprint(*r[1:n])\n
#!usr/bin/env python3\nimport sys\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\nmod = 1000000007\n\ndef solve():\n    def add(i,x):\n        while i < len(bit):\n            bit[i] += x\n            i += i&-i\n    def sum(i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i&-i\n        return res\n    n,m = LI()\n    a = LI()\n    bit = [0]*(n+m+2)\n    MIN = [i+1 for i in range(n)]\n    MAX = [i+1 for i in range(n)]\n    f = [i+m+1 for i in range(n)]\n    for i in range(n):\n        add(f[i],1)\n    M = m\n    for i in range(m):\n        ai = a[i]-1\n        MIN[ai] = 1\n        index = sum(f[ai])\n        if MAX[ai] < index:\n            MAX[ai] = index\n        add(M,1)\n        add(f[ai],-1)\n        f[ai] = M\n        M -= 1\n    for i in range(n):\n        index = sum(f[i])\n        if MAX[i] < index:\n            MAX[i] = index\n    for i in range(n):\n        print(MIN[i],MAX[i])\n    return\n\n#Solve\ndef __starting_point():\n    solve()\n\n__starting_point()
string = input()\nl = string.split(" ")\nn, m, k = int(l[0]),int(l[1]),int(l[2])\nl = [{(1,1),}]\ncount = 1\nIn = 0\nwhile count < k:\n	s = set()\n	for i in l[In]:\n		x = i[0]+1\n		y = i[1]\n		if x<=n and y<=m:\n			t = [0,0]\n			t[0],t[1] = x, y\n			s.add(tuple(t))\n		x = i[0]\n		y = i[1]+1\n		if x<=n and y<=m:\n			t = [0,0]\n			t[0],t[1] = x, y\n			s.add(tuple(t))\n	l.append(s)\n	In+=1\n	count+=len(l[In])\nl2 = []\nCount = 0\nflag = 0\nfor i in l:\n	for h in i:\n		if Count==k:\n			flag = 1\n			break\n		l3 = [h]\n		x,y = h[0],h[1]\n		while x!=1 or y!=1:\n			if x>y:\n				x-=1\n				l3.append((x,y))\n			else:\n				y-=1\n				l3.append((x,y))\n		l2.append(l3)\n		Count+=1\n	if flag==1:\n		break\n\ncost = 0\nstring = ""\nfor i in range(k):\n	length = len(l2[k-i-1])\n	cost+=length\n	for j in range(length):\n		t = l2[k-i-1][length - j - 1]\n		x,y = t[0],t[1]\n		string += "("+str(x)+","+str(y)+") "\n	string += "\n"\n	\nprint(cost)\nprint(string)\n	\n
"""\nCodeforces Round 244 Div 1 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\nclass InputHandlerObject(object):\n    inputs = []\n\n    def getInput(self, n = 0):\n        res = ""\n        inputs = self.inputs\n        if not inputs: inputs.extend(input().split(" "))\n        if n == 0:\n            res = inputs[:]\n            inputs[:] = []\n        while n > len(inputs):\n            inputs.extend(input().split(" "))\n        if n > 0:\n            res = inputs[:n]\n            inputs[:n] = []\n        return res\nInputHandler = InputHandlerObject()\ng = InputHandler.getInput\n\n############################## SOLUTION ##############################\nn,t,c = [int(x) for x in g()]\na = [False if int(x) > t else True for x in g()]\nct = 0\nres = 0\nfor i in a:\n    if i:\n        ct += 1\n        if ct >= c: res += 1\n    else:\n        ct = 0\nprint(res)
MOD = 998244353\ndef power(x, n) :\n    ans = 1\n    while (n) :\n        if ((n & 1) == 1) :\n            ans = ans * x % MOD\n        x = x * x % MOD\n        n = n // 2\n    return ans\n\nn = int(input())\na = list(map(int, input().split()))\nb = [0 for i in range(n + 1)]\n\ndef add(x, v) :\n    while (x <= n) : \n        b[x] = b[x] + v\n        x = x + (x & -x)\ndef get(x) :\n    ans = 0\n    while (x) :\n        ans = ans + b[x]\n        x = x - (x & -x)\n    return ans\n\nanss = 0\nfor i in range(n) :\n    if (a[i] != -1) :\n        add(a[i], 1)\n        anss = anss + get(n) - get(a[i])\n\nanss = anss % MOD\ntotal = 0\n\nsur = [0] + [1 for i in range(n)]\nfor i in range(n) :\n    if (a[i] == -1) :\n        total = total + 1\n    else :\n        sur[a[i]] = 0\n\nif (total == 0) : \n    print(anss) \n    return\nfor i in range(1, n + 1) : \n    sur[i] = sur[i] + sur[i - 1]\n\ndead = 0\n\nansa = 0\nfor i in range(n) :\n    if (a[i] != -1) :\n        ansa = ansa + sur[a[i]] * (total - dead) + (sur[n] - sur[a[i]]) * dead\n    else : \n        dead = dead + 1\n\nans = (ansa * 4 + anss * 4 * total + total * total * (total - 1)) % MOD\nans = (ans * power(4 * total, MOD - 2)) % MOD\nprint(ans) \n\n
for zz in range(int(input())):\n    n = int(input())\n    ans = 0\n    while n > 1:\n        ans += 1\n        cr = 2\n        while n >= cr:\n            n -= cr\n            cr += 3\n    print(ans)\n
import sys\n\ncnt = {\n        "Tetrahedron": 4,\n        "Cube": 6,\n        "Octahedron": 8,\n        "Dodecahedron": 12,\n        "Icosahedron": 20}\n\nn = int(input())\nc = 0\n\nfor _ in range(n):\n    s = input()\n    c += cnt[s]\n\nprint(c)\n
n, m, k = map(int, input().split())\na = [[] for i in range(m)]\nfor i in range(n):\n    b = [int(x) for x in input().split()]\n    for j in range(m):\n        a[j].append(b[j])\ns = 0\np = 0\nfor i in range(m):\n    a[i].append(0)\nfor i in a:\n    d = 0\n    ma = 0\n    ans = 0\n    cur = sum(i[:k - 1])\n    for j in range(k - 1, n):\n        if i[j]:\n            cur += 1\n        if cur > ma:\n            ma = cur\n            ans = d\n        cur -= i[j - k + 1]\n        d += i[j - k + 1]\n    s += ma\n    p += ans\nprint(s, p)
import sys\n\nclass Fenwick(object):\n  def __init__(self, n):\n    self.n = n\n    self.a = [10**9 for i in range(n)]\n    self.w= 10**9\n\n  def zag(self, i, zn):\n    self.w= min(self.w, zn)\n    while i < self.n:\n      self.a[i] = min(self.a[i], zn)\n      i = (i | (i + 1))\n\n  def pol(self, r):\n    ans= 10**9\n    while r >= 0:\n      if ans> self.a[r]:\n        ans= self.a[r]\n      if ans== self.w:\n        break\n      r = (r & (r + 1)) - 1\n    return ans\n\nn, m = [int(x) for x in sys.stdin.readline().split()]\na = [int(x) for x in sys.stdin.readline().split()]\n\nnd= [-1 for i in range(0, len(a))]\nvi= {}\nfor i in range(0, len(a)):\n  if a[i] in vi:\n    nd[i] = vi[a[i]]\n  vi[a[i]] = i\n\ninp= sys.stdin.readlines()\noch= [[] for i in range(n)]\nfor i in range(m):\n  l, r = inp[i].split()\n  och[int(r) - 1].append((int(l) - 1, i))\n\nder = Fenwick(2 ** 19)\nans= [None for i in range(0, m)]\nle= -1\nfor r in range(n):\n  if nd[r] != -1:\n    der.zag(500000 - nd[r] + 1, r - nd[r])\n    le = max(le, nd[r])\n  for (l, ind) in och[r]:\n    if l > le:\n      ans[ind] = -1\n      continue\n    zn= der.pol(500000 - l + 1)\n    if zn== 10**9:\n      zn= -1\n    ans[ind] = zn\n\nprint('\n'.join(str(zn) for zn in ans))
import collections\n\nn,m=map(int,input().split())\nm+=2\narr=list(map(int,input().split()))\narr.append(0)\narr.append(n)\narr=sorted(arr)\ng,r=map(int,input().split())\nq=collections.deque()\nq.append((0,0))\ndist=[[0]*(g+1) for _ in range(m+2)]\nchecked=[[0]*(g+1) for _ in range(m+2)]\nchecked[0][0]=1\nans=-1\nwhile len(q)!=0:\n  v,t=q.popleft()\n  if t==0:\n    if n-arr[v]<=g:\n      tmp=dist[v][t]*(g+r)+n-arr[v]\n      if ans==-1 or ans>tmp:\n        ans=tmp\n  if t==g:\n    if checked[v][0]==0:\n      checked[v][0]=1\n      dist[v][0]=dist[v][t]+1\n      q.append((v,0))\n    continue\n  if v!=0:\n    cost=t+arr[v]-arr[v-1]\n    if cost<=g and checked[v-1][cost]==0:\n      checked[v-1][cost]=1\n      dist[v-1][cost]=dist[v][t]\n      q.appendleft((v-1,cost))\n  if v!=m-1:\n    cost=t+arr[v+1]-arr[v]\n    if cost<=g and checked[v+1][cost]==0:\n      checked[v+1][cost]=1\n      dist[v+1][cost]=dist[v][t]\n      q.appendleft((v+1,cost))\nprint(ans)
t = int(input())\nwhile t:\n    l, r = list(map(int, input().split()))\n    if l * 2 <= r:\n        print(l, 2 * l)\n    else:\n        print(-1, -1)\n    t -= 1\n
#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\n    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit\n    \nN, = getIntList()\n#print(N)\n\nzb = getIntList()\n\nza1 = [0]\nza2 = [zb[0]]\n\nfor i in range(1, N//2):\n    t1 = zb[i] - za1[-1]\n    if t1 <= za2[-1]:\n        za1.append(za1[-1])\n        za2.append(t1)\n        continue\n    t2 = zb[i] - za2[-1]\n    if t2 >= za1[-1]:\n        za1.append(t2)\n        za2.append(za2[-1])\n        continue\n    assert False\n\nzr = za1 + za2[ : :-1]\nzs = []\nfor x in zr:\n    zs .append(str(x))\n    \n\nr = ' '.join(zs)\n\nprint(r)\n\n\n\n\n\n\n\n\n
MOD = 10**9 + 7\n\nfrom sys import stderr\n\ndef readints():\n    return [int(fld) for fld in input().strip().split()]\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD-2, MOD) % MOD)\n    return tbl[n]\n\ndef main():\n    n, k = readints()\n    pairs = [readints() for _ in range(n)]\n    oplist = [p for l, r in pairs for p in (2*l, 2*r+1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            i, delta = (op+1)//2, -1\n        else:\n            i, delta = op//2, 1\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    print(total)\n\nmain()
N,k=map(int,input().split())\n\nind=0\nfor i in range(N):\n    for j in range(N):\n        if(j!=N-1):\n            if(j==i):\n                print(k,end=" ")\n            else:\n                print(0,end=" ")\n        else:\n            if(j==i):\n                print(k)\n            else:\n                print(0)\n
n, k = [int(i) for i in input().split()]\n\nw = [int(i) for i in input().split()]\n\ntot = 0\nfor wi in w:\n    tot += (wi+k-1)//k\n\nans = (tot+1)//2\nprint(ans)\n
import sys\nimport math\n\n\na, b, n = list(map(int, str.split(sys.stdin.readline())))\ns = lambda i: a + (i - 1) * b\nS = lambda i: a * i + b * i * (i - 1) // 2\nfor _ in range(n):\n\n    l, t, m = list(map(int, str.split(sys.stdin.readline())))\n    # Si = a * r + b * r * (r - 1) / 2\n    # Si = b / 2 * r ^ 2 - (b / 2 - a) * r\n    # si = a + (i - 1) * b => (si - a) / b + 1 = i\n\n    # (S(r) - S(l-1)) / t <= m\n    # S(r) <= m * t + S(l-1)\n    # b / 2 * r ^ 2 - (b / 2 - a) * r - m * t - S(l-1) <= 0\n    # D = (b / 2 - a) ^ 2 + 4 * b / 2 * (m * t + S(l-1))\n    d = (b / 2 - a) ** 2 + 4 * b / 2 * (m * t + S(l - 1))\n    if d < 0:\n\n        print(-1)\n        continue\n\n    r = min(\n        math.floor((t - a) / b + 1),\n        math.floor(((b / 2 - a) + math.sqrt(d)) / b)\n    )\n    if r < l:\n\n        print(-1)\n\n    else:\n\n        print(r)\n
from collections import *\nimport sys\ntry: inp = raw_input\nexcept: inp = input\ndef err(s):\n    sys.stderr.write('{}\n'.format(s))\n\ndef ni():\n    return int(inp())\n\ndef nl():\n    return [int(_) for _ in inp().split()]\n\n\ndef solve():\n    n, L, R = nl()\n    L -= 1\n    R -= 1\n    SM = 0\n    out = []\n    for i in range(1, n):\n        no = (n - i)*2\n        if no + SM <= L:\n            SM += no\n            continue\n        if SM > R: continue\n        ARR = [i if j%2 == 0 else i + j//2 + 1 for j in range(no)]\n        start = max(0, L - SM)\n        end = R - SM + 1\n        out.extend(ARR[start:end])\n        SM += no\n    if R == SM:\n        out.append(1)\n    print(' '.join(map(str, out)))\n\n\n\n\n\nT = ni()\nfor _ in range(T):\n    solve()\n
import functools\nn = int(input())\n\nprops = []\ndef preproc(a):\n    return float(a)/100.\n\nfor i in range(pow(2,n)):\n    props.append(list(map(preproc, input().split())))\n\nwining_props = []  # list of lists. First index -- number of round, second -- num of team, value -- prop of wining\n\nwining_props_first_round = []\nfor i in range(0, (2 ** n), 2):\n    # i, and i+1 teams playing\n    wining_prop_for_i = props[i][i + 1]\n    wining_props_first_round.append(wining_prop_for_i)\n    wining_props_first_round.append(1. - wining_prop_for_i)\n\nwining_props.append(wining_props_first_round)\nassert len(wining_props_first_round) == len(props)\n\nfor round_num in range(2, n + 1):\n    # calculate propabilitys for winning in i round for each team\n    # prop of winning in i round = prop of winning prev round + mo of win this one\n    # mo win this = for each team we can meet prop of them wining prev * prop we win them\n    # each team we can meet on round i  = all teems // 2^i == we//2^i\n    this_round_wining_props = []\n    for team_num in range(2 ** n):\n        t = team_num // (2 ** round_num) * (2 ** (round_num))\n        teams_we_meet_this_round = [t + x for x in range(2 ** round_num)]\n        t = team_num // (2 ** (round_num-1)) * (2 ** (round_num-1))\n        teams_we_meet_prev_round = [t + x for x in range(2 ** (round_num-1))]\n        for tt in teams_we_meet_prev_round:\n            teams_we_meet_this_round.remove(tt)\n\n        this_team_wining_props = wining_props[round_num - 2][team_num]  # -2 cause numeration\n\n        chances_win_i_team = []\n        for tm in teams_we_meet_this_round:\n            # chances we meet them * chances we win\n            chances_win_i_team.append(wining_props[round_num - 2][tm] * props[team_num][tm])\n\n        mo_win_this_round = sum(chances_win_i_team)\n\n        this_team_wining_props *= mo_win_this_round\n\n        this_round_wining_props.append(this_team_wining_props)\n\n    #assert 0.99 < sum(this_round_wining_props) < 1.01\n    wining_props.append(this_round_wining_props)\n\n# now we got props of each win on each round. Lets bet on most propable winer and calculate revenue\n\n#from left to right-1 is playing\n@functools.lru_cache(maxsize=None)\ndef revenue(round_num, teams_left, teams_right, winner=-1):\n    split = ((teams_left + teams_right) // 2)\n\n    # let the strongest team win, we bet, and calculate to the bottom\n    if round_num == 1:\n        return wining_props[0][winner] if winner != -1 else max(wining_props[0][teams_left:teams_right])\n\n    if winner == -1:\n        results = []\n        for winner in range(teams_left, teams_right):\n            winner_prop = wining_props[round_num - 1][winner]\n\n            if winner >= split:\n                res = sum(\n                    [revenue(round_num - 1, teams_left, split), revenue(round_num - 1, split, teams_right, winner),\n                     winner_prop * (2 ** (round_num - 1))])\n            else:\n                res = sum(\n                    [revenue(round_num - 1, teams_left, split, winner), revenue(round_num - 1, split, teams_right),\n                     winner_prop * (2 ** (round_num - 1))])\n            results.append(res)\n\n        return max(results)\n\n    else:\n        winner_prop = wining_props[round_num - 1][winner]\n\n        if winner >= split:\n            res = sum(\n                [revenue(round_num - 1, teams_left, split), revenue(round_num - 1, split, teams_right, winner),\n                 winner_prop * (2 ** (round_num - 1))])\n        else:\n            res = sum(\n                [revenue(round_num - 1, teams_left, split, winner), revenue(round_num - 1, split, teams_right),\n                 winner_prop * (2 ** (round_num - 1))])\n\n        return res\n\nprint(revenue(n, 0, (2 ** n)))\n
n = int(input())\narr = []\nfor i in range(n):\n	a,b = map(int, input().split(' '))\n	arr.append((a,b))\narr = sorted(arr)\nfor i in range(n-1):\n	if(arr[i][1]>arr[i+1][1]):\n		print("Happy Alex")\n		break\nelse:\n	print("Poor Alex")
#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nn = int(input())\n\nb_a = {}\nfor n_ in range(n):\n    b, a = input().split()\n\n    replaced = False\n    for k in b_a:\n        if b_a[k] == b:\n            b_a[k] = a\n            replaced = True\n    if not replaced:\n        b_a[b] = a\n\nprint(len(b_a))\nfor k in b_a:\n    print(k + " " + b_a[k])\n
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\nd={}\n\nn=int(input())\nfor _ in range(n):\n    i,j=map(int,input().split())\n    d[i]=j\nm=int(input())\nfor _ in range(m):\n    i,j=map(int,input().split())\n    if i in d and d[i]>j: continue\n    d[i]=j\n\nans=0\nfor i,j in d.items():\n    ans+=j\nprint(ans)
# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport itertools\nimport sys\n\n"""\ncreated by shhuan at 2018/11/10 22:33\n\n"""\n\n\nN, M, L = list(map(int, input().split()))\nA = [int(x) for x in input().split()]\n\nans = 0\n\ni = 0\nwhile i < N:\n    j = i\n    while j < N and A[j] > L:\n        j += 1\n    if j > i:\n        ans += 1\n        i = j + 1\n    else:\n        i += 1\n\n\nfor mi in range(M):\n    line = input()\n    if len(line) == 1:\n        print(ans)\n    else:\n        t, p, d = list(map(int, line.split()))\n        prev = A[p-1]\n        A[p-1] += d\n        if prev <= L < A[p-1]:\n            if p-2 >= 0 and p < N:\n                if A[p-2] > L and A[p] > L:\n                    ans -= 1\n                elif A[p-2] <= L and A[p] <= L:\n                    ans += 1\n                else:\n                    pass\n            elif p-2 >= 0:\n                if A[p-2] > L:\n                    pass\n                else:\n                    ans += 1\n            elif p < N:\n                if A[p] > L:\n                    pass\n                else:\n                    ans += 1\n            else:\n                ans += 1\n
from collections import deque\nfrom sys import stdin\n\nn, x = map(int, stdin.readline().split())\nleafs = set(range(n))\ngraph = [[] for i in range(n)]\ncount = [False for i in range(n)]\nfor i in range(n - 1):\n    a, b = map(int, stdin.readline().split())\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n    if not count[a - 1]:\n        count[a - 1] = True\n    else:\n        leafs.discard(a - 1)\n    if not count[b - 1]:\n        count[b - 1] = True\n    else:\n        leafs.discard(b - 1)\nqueue = deque()\nway_a = [10 ** 6 for i in range(n)]\nway_b = [10 ** 6 for i in range(n)]\nused = [False for i in range(n)]\nqueue.append([0, 0])\nwhile queue:\n    j = queue.popleft()\n    way_a[j[0]] = min(way_a[j[0]], j[1])\n    for i in graph[j[0]]:\n        if not used[i]:\n            used[i] = True\n            queue.append([i, j[1] + 1])\nqueue.append([x - 1, 0])\nused = [False for i in range(n)]\nwhile queue:\n    j = queue.popleft()\n    way_b[j[0]] = min(way_b[j[0]], j[1])\n    for i in graph[j[0]]:\n        if not used[i]:\n            used[i] = True\n            queue.append([i, j[1] + 1])\nres = way_a[x - 1]\nfor i in leafs:\n    if way_a[i] > way_b[i]:\n        res = max(res, way_a[i])\nprint(res * 2)
(n, k) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\ncur = 0\nidx = 0\nfor i in range(k):\n	ans = 0\n	while idx < n:\n		ans = a[idx] - cur\n		idx += 1\n		if ans != 0:\n			break\n	print(ans)\n	cur += ans
r = lambda: map(int, input().split())\n\nimport heapq\n\ndef main():\n	n, = r()\n	a = list(r())\n	if len(a) % 2 == 0:\n		a.append(0)\n	heapq.heapify(a)\n	ret = 0\n	while len(a) > 1:\n		x = heapq.heappop(a)\n		y = heapq.heappop(a)\n		z = heapq.heappop(a)\n		ret += x + y + z\n		heapq.heappush(a, x + y + z)\n	print(ret)\n\nmain()
import sys\nimport heapq\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    S = [[x for x in input().split()] for _ in range(2 * N)]\n\n    q = []\n    ans = []\n    for s in S[::-1]:\n        if s[0] == "-":\n            heapq.heappush(q, int(s[1]))\n        else:\n            if q:\n                c = heapq.heappop(q)\n                ans.append(c)\n            else:\n                print("NO")\n                return\n\n    ans2 = ans[::-1]\n\n    q = []\n    current = 0\n    for s in S:\n        if s[0] == "-":\n            c = heapq.heappop(q)\n            if c != int(s[1]):\n                print("NO")\n                return\n        else:\n            heapq.heappush(q, ans2[current])\n            current += 1\n\n    print("YES")\n    print(*ans2)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
from collections import Counter\nn, k = map(int, input().split())\nm = sorted(list(map(int, input().split())), reverse=True)\nc = [n] + list(map(int, input().split()))\ncnt = Counter(m)\ntmp = 0\nsize = 1\nfor i in range(k, 0, -1):\n	tmp += cnt[i]\n	size = max(size, (tmp-1)//c[i]+1)\n\nans = [[] for _ in range(size)]\nfor i, x in enumerate(m):\n	ans[i%size].append(x)\n\nprint(size)\nfor a in ans:\n	print(len(a), *a)
n = int(input())\na = [int(x) for x in input().split()]\na.sort()\nnum = 0\nres = 0\nfor i in range(n):\n    if int(a[i]) >= num:\n        res += 1\n        num += int(a[i])\n    #print(res, a[i])\nprint(res)\n
import itertools\nimport functools\nimport operator\n\nN = 100001\nP = 10**9 + 7\n\nfact = [1]\nfor i in range(1, N):\n	fact.append(fact[-1] * i % P)\n\ninv = [0, 1]\nfor i in range(2, N):\n	inv.append(P - P // i * inv[P % i] % P)\ninv_fact = [1]\nfor i in range(1, N):\n	inv_fact.append(inv_fact[-1] * inv[i] % P)\n\nleast_div = [-1] * N\nprimes = []\n\nfor p in range(2, N):\n	if least_div[p] == -1:\n		primes.append(p)\n		least_div[p] = p\n	ldiv = least_div[p]\n	for mult in primes:\n		mark = mult * p\n		if (mult > ldiv) or (mark >= N):\n			break\n		least_div[mark] = mult\n\nt = int(input())\n\ndef powerset(iterable):\n    s = list(iterable)\n    return itertools.chain.from_iterable(itertools.combinations(s, r) for r in range(len(s) + 1))\n\nmemo_factor = dict()\n\ndef factor(n):\n	if n in memo_factor:\n		return memo_factor[n]\n	ret = []\n	while n != 1:\n		tmp = least_div[n]\n		if not(ret and ret[-1] == tmp):\n			ret.append(tmp)\n		n //= tmp\n	memo_factor[n] = ret\n	return ret\n\n@functools.lru_cache(maxsize = None)\ndef solve(n, k):\n	divs = factor(n)\n	# print(divs)\n	ret = 0\n	for subset in powerset(divs):\n		div = functools.reduce(operator.mul, subset, 1)\n		# print(div, f(n // div, k))\n		if n // div >= k:\n			tmp = fact[n // div - 1] * inv_fact[n // div - k] % P * inv_fact[k - 1] % P\n			ret += (-1 if len(subset) % 2 == 1 else 1) * tmp\n			ret %= P\n	return ret\n\nfor _ in range(t):\n	n, k = list(map(int, input().split()))\n	print(solve(n, k))\n
n,m = list(map(int,input().split()))\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nsums = sum(B)+len(B)\nlast = [-1] * m\ncou = 0\nans = 0\nper = 0\nfor j in range(n):\n    if A[j] == 0:\n        cou +=1\n    else:\n        if last[A[j]-1] == -1:\n            if j >= B[A[j]-1]:\n                \n                ans += 1\n                last[A[j]-1] = 0\n                \n        if ans == m:\n            if (j+1) >= sums:\n                per=1\n                print(j+1)\n                break\n           \n        \n    \n    \nif per == 0:\n    print(-1)\n        \n
\n\ndef f(s,e):\n	if e%2:\n		return 1-s%2\n	elif s*2>e:\n		return s%2\n	else:\n		return g(s,e//2)\ndef g(s,e):\n	if 2*s>e:\n		return 1\n	else:\n		return f(s,e//2)\n\na=[tuple(map(int,input().split())) for i in range(int(input()))]\nb=1\nfor i in a:\n	b1=g(*i)|(f(*i)<<1)\n	b=b1^3 if b==2 else b1\n	if b==0:\n		print('0 0')\n		return\n	elif b==3:\n		print('1 1')\n		return\n		\nif b==2:\n	print('1 0')\nelse:\n	print('0 1')\n	\n
n, a, b = [int(x) for x in input().split()]\n\nhs = [int(x) for x in input().split()]\n\ntarget = 1.0 * hs[0] * a / b\n\nleft = sorted(hs[1:])\ns = sum(hs)\n\nres = 0\nwhile s > target:\n    res += 1\n    s -= left[-res]\n\nprint(res)\n
n,p = list(map(int,input().split()))\ntemp = [input() for i in range(n)]\nnum = 0\nnum2 = 0\nfor i in range(n-1,-1,-1):\n    if temp[i] == "halfplus":\n        num *= 2\n        num += 1\n        num2 += num/2*p\n    else:\n        num2 += num*p\n        num *= 2\nprint(int(num2))\n        \n        \n
#!/usr/bin/env python3\n\n\nclass CantException(Exception):\n    pass\n\n\ndef odd_v(value):\n    return 1 if value % 2 == 1 else -1\n\n\nchange_idx = 1\n\nacceptable = {-1: set(), 1: set()}\n\n\ndef change(card_values, oddv, m):\n    nonlocal change_idx\n\n    if acceptable[oddv]:\n        res = acceptable[oddv].pop()\n        card_values.add(res)\n        return res\n\n    change_idx_start = change_idx\n\n    while change_idx in card_values or odd_v(change_idx) != oddv:\n        if change_idx not in card_values:\n            acceptable[odd_v(change_idx)].add(change_idx)\n        change_idx += 1\n        if change_idx > m:\n            change_idx = 1\n        if change_idx == change_idx_start:\n            raise CantException()\n\n    res = change_idx\n    card_values.add(res)\n\n    change_idx += 1\n    if change_idx > m:\n        change_idx = 1\n    return res\n\n\ndef solve():\n    n, m = list(map(int, input().split()))\n    cards = list(map(int, input().split()))\n\n    odd_balance = 0\n    card_values = set()\n    indices_to_be_changed = set()\n\n    for i, c in enumerate(cards):\n        odd_balance += odd_v(c)\n        if c in card_values:\n            indices_to_be_changed.add(i)\n        card_values.add(c)\n\n    # print("indices to be changed: ", indices_to_be_changed)\n    change_count = len(indices_to_be_changed)\n\n    for i in indices_to_be_changed:\n        if odd_v(cards[i]) * odd_balance <= 0:\n            #print("Changing ", cards[i])\n            cards[i] = change(card_values, odd_v(cards[i]), m)\n            #print("Changed to ", cards[i])\n        else:\n            #print("For teh balance changing ", cards[i])\n            odd_balance -= 2 * odd_v(cards[i])\n            cards[i] = change(card_values, - odd_v(cards[i]), m)\n            #print("Changed to ", cards[i])\n\n    #print("current odd balance:", odd_balance)\n    for i in range(len(cards)):\n        if odd_balance == 0:\n            break\n        if odd_v(cards[i]) * odd_balance > 0:\n            # print("gonna change")\n            change_count += 1\n            odd_balance -= 2 * odd_v(cards[i])\n            cards[i] = change(card_values, -odd_v(cards[i]), m)\n\n    odd_balance = 0\n    for i, c in enumerate(cards):\n        odd_balance += odd_v(c)\n    if odd_balance != 0:\n        print(odd_balance)\n        print("WTFFFFF")\n\n    return change_count, cards\n\n\ndef __starting_point():\n    try:\n        change_cnt, cards = solve()\n        print(change_cnt)\n        print(" ".join(map(str, cards)))\n    except CantException:\n        print("-1")\n\n__starting_point()
N = int( input() )\nA = list( map( int, input().split() ) )\n\nmaxa = max( A )\n\ndef upd( ftree, x, v ):\n  while x <= maxa:\n    ftree[ x ] = max( ftree[ x ], v )\n    x += x & -x\n\ndef qry( ftree, x ):\n  res = 0\n  while x:\n    res = max( res, ftree[ x ] )\n    x -= x & -x\n  return res\n\nst_len = [ 0 for i in range( N ) ]\nftree = [ 0 for i in range( maxa + 1 ) ]\nfor i in range( N - 1, -1, -1 ):\n  st_len[ i ] = qry( ftree, maxa + 1 - A[ i ] - 1 ) + 1\n  upd( ftree, maxa + 1 - A[ i ], st_len[ i ] )\n\ned_len = [ 0 for i in range( N ) ]\nftree = [ 0 for i in range( maxa + 1 ) ]\nfor i in range( N ):\n  ed_len[ i ] = qry( ftree, A[ i ] - 1 ) + 1\n  upd( ftree, A[ i ], ed_len[ i ] )\n\nmax_len = max( st_len )\nst_cnt_len = [ 0 for i in range( N + 1 ) ]\nfor i in range( N ):\n  if ed_len[ i ] + st_len[ i ] - 1 == max_len:\n    st_cnt_len[ st_len[ i ] ] += 1\n\nfor i in range( N ):\n  if ed_len[ i ] + st_len[ i ] - 1 != max_len:\n    print( 1, end = "" )\n  elif st_cnt_len[ st_len[ i ] ] > 1:\n    print( 2, end = "" )\n  else:\n    print( 3, end = "" )\nprint()\n
n, m = [int(i) for i in input().split()]\nA = []\nct = []\nfor i in range(n):\n    x = list(input())\n    y = [0]*m\n    A.append(x)\n    ct.append(y)\nok = 1\nfor i in range(n-2):\n    for j in range(m-2):\n        if A[i][j]=='#' and A[i][j+1]=='#' and A[i][j+2]=='#' and A[i+1][j]=='#' and A[i+2][j]=='#' and A[i+2][j+1]=='#' and A[i+2][j+2]=='#' and A[i+1][j+2]=='#':\n            ct[i][j] = 1\n            ct[i][j+1] = 1\n            ct[i][j+2] = 1\n            ct[i+1][j] = 1\n            ct[i+1][j+2] = 1\n            ct[i+2][j] = 1\n            ct[i+2][j+1] = 1\n            ct[i+2][j+2] = 1\n\nxct = 0\nxhs = 0\n\nfor i in range(len(ct)):\n    for j in range(len(ct[i])):\n        if ct[i][j] == 1:\n            xct+=1\n        if A[i][j] == '#':\n            xhs+=1\nif xhs==xct:\n    print('YES')\nelse:\n    print('NO')\n
def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\n\nN, K, L = mi()\nA = li()\nA.sort()\nend = 1\nwhile end < N * K and A[end] <= A[0] + L:\n    end += 1\nB = A[:end]\nif len(B) < N:\n    ans = 0\nelse:\n    cur = ans = 0\n    for i in range(N):\n        ans += B[cur]\n        cur = min(cur + K, len(B) - (N - i - 1))\nprint(ans)\n
n = int(input()) + 1\nt = [1] + list(map(int, input().split())) + [1]\np = [True] * n\ns, q = 0, list(range(1, n))\nfor i in range(1, n):\n    if p[i]:\n        a = b = i\n        d = t[i]\n        if d == 1: \n            s, q = n - 2, [1]\n            break\n        while t[a - 1] % d == 0: a -= 1\n        while t[b + 1] % d == 0:\n            b += 1\n            p[b] = False\n        d = b - a\n        if d > s: s, q = d, [a]\n        elif d == s != 0: q.append(a)\nprint(len(q), s)\nprint(' '.join(map(str, q)))
n = int(input())\nk = map(int, input().split())\ntimes = []\nfor i in range(n):\n    people = list(map(int, input().split()))\n    time = len(people) * 15\n    for p in people:\n        time += p*5\n    times.append(time)\nprint(min(times))
import sys\nimport random\nfrom fractions import Fraction\nfrom math import *\n \ndef input():\n    return sys.stdin.readline().strip()\n \ndef iinput():\n    return int(input())\n\ndef finput():\n    return float(input())\n\ndef tinput():\n    return input().split()\n\ndef linput():\n    return list(input())\n \ndef rinput():\n    return list(map(int, tinput()))\n\ndef fiinput():\n    return list(map(float, tinput()))\n \ndef rlinput():\n    return list(map(int, input().split()))\ndef trinput():\n    return tuple(rinput())\n\ndef srlinput():\n    return sorted(list(map(int, input().split())))\n\ndef NOYES(fl):\n    if fl:\n        print("NO")\n    else:\n        print("YES")\ndef YESNO(fl):\n    if fl:\n        print("YES")\n    else:\n        print("NO")\n    \ndef main():\n    #n = iinput()\n    #k = iinput() \n    #m = iinput() \n    #n = int(sys.stdin.readline().strip()) \n    n, k = rinput()\n    #n, m = rinput()\n    #m, k = rinput()\n    #n, k, m = rinput()\n    #n, m, k = rinput()\n    #k, n, m = rinput()\n    #k, m, n = rinput() \n    #m, k, n = rinput()\n    #m, n, k = rinput()\n    q = srlinput()\n    #q = linput()\n    print((q.count(k) != n) * (k in q) + (1 + (k * n != sum(q))) * (k not in q))\n         \n    \n                \n    \n    \n    \n            \n    \n        \n    \n\nfor i in range(iinput()):\n    main()\n
from itertools import permutations\n\nn = int(input())\n\np1, _, p2, _, p3, _, p4 = [input() for _ in range(n)], input(), [input() for _ in range(n)], input(), [input() for _ in range(n)], input(), [input() for _ in range(n)]\n\ndef count(a,b,c,d):\n    board = [a[i] + b[i] for i in range(n)] + [c[i] + d[i] for i in range(n)]\n\n    res = 0\n    for i in range(2*n):\n        for j in range(2*n):\n            clr = '1' if (i+j)%2 == 0 else '0'\n            res += board[i][j] != clr\n    return res\n\nprint(min(count(*p) for p in permutations([p1, p2, p3, p4])))\n
w, h = map(int, input().split())		\nimage = [input() for i in range(h)]\nfor i in range(w):\n    image2 = ""\n    for j in range(h):\n        temp = image[j][i]\n        print(temp+temp,end="")\n        image2 += temp + temp\n    print()\n    print(image2)\n
n, v = map(int, input().split())\nans = []\nfor i in range(n):\n    a = list(map(int, input().split()))[1:]\n    if v > min(a):\n        ans.append(i + 1)\nprint(len(ans))\nprint(*ans)
n = int(input())\n\na = [input() for i in range(n)]\n\nans = 0\nfor i in range(1, n - 1):\n    for j in range(1, n - 1):\n        if a[i][j] == 'X' and a[i + 1][j + 1] == 'X' and a[i - 1][j + 1] == 'X' and a[i + 1][j - 1] == 'X' and a[i - 1][j - 1] == 'X':\n            ans += 1\n            \nprint(ans)
def check(x, y):\n    return 0 <= x < 8 and 0 <= y < 8\n\ndef dfs1(x, y, T=0):\n    nonlocal first, used\n    if not(check(x, y)) or used[x][y]:\n        return\n    used[x][y] = True\n    first.add((x, y, T))\n    for pair in (2, 2), (2, -2), (-2, 2), (-2, -2):\n        dfs1(x + pair[0], y + pair[1], 1 - T)\n\ndef dfs2(x, y, T=0):\n    nonlocal second, used\n    if not(check(x, y)) or used[x][y]:\n        return\n    used[x][y] = True\n    second.add((x, y, T))\n    for pair in (2, 2), (2, -2), (-2, 2), (-2, -2):\n        dfs2(x + pair[0], y + pair[1], 1 - T)\n\n\nt = int(input())\nfor i in range(t):\n    if i > 0:\n        kuzma = input()\n    board = [input() for i in range(8)]\n    FoundFirst = False\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'K':\n                if not(FoundFirst):\n                    First = (i, j)\n                    FoundFirst = True\n                else:\n                    Second = (i, j)\n\n    used = [[0 for i in range(8)] for j in range(8)]\n    first = set()\n    dfs1(First[0], First[1])\n    used = [[0 for i in range(8)] for j in range(8)]\n    second = set()\n    dfs2(Second[0], Second[1])\n    intersection = first & second\n    IsOk = False\n    for x, y, t in intersection:\n        if board[x][y] != '#':\n            print("YES")\n            IsOk = True\n            break\n    if not(IsOk):\n        print("NO")\n    board = []\n
import math\nimport sys\ninput = sys.stdin.readline\n\nn = int(input())\na = [int(_) - 1 for _ in input().split()]\nvis = [False] * n\ncycles = [[] for _ in range(n + 1)]\nfor i in range(n):\n    if vis[i]: continue\n    cur = i\n    cycle = []\n    while not vis[cur]:\n        vis[cur] = True\n        cycle.append(cur)\n        cur = a[cur]\n    cycles[len(cycle)].append(cycle)\np = [0] * n\nfor i in range(n + 1):\n    if i % 2 == 1:\n        for j in cycles[i]:\n            for k in range(i):\n                p[j[k]] = j[(k + (i + 1) // 2) % i]\n    else:\n        if len(cycles[i]) % 2 == 1:\n            print(-1)\n            return\n        for j in range(0, len(cycles[i]), 2):\n            for k in range(i):\n                p[cycles[i][j][k]] = cycles[i][j + 1][k] \n                p[cycles[i][j + 1][k]] = cycles[i][j][(k + 1) % i]\nprint(' '.join([str(i + 1) for i in p]))\n
import sys\nn = 500001\nsqrt = int(0.75 * n**0.5)\n\ndata = [0]*(n)\nans = [[]]\nout = []\nfor i in range(1, sqrt):\n    ans.append([0]*i)\nj = int(sys.stdin.readline())\nqus = sys.stdin.readlines()\nfor qu in qus:\n    q = [int(i) for i in qu.split()]\n    if q[0] == 1:\n        x = q[1]\n        y = q[2]\n        data[x] += y\n        for i in range(1, sqrt):\n            ans[i][x%i] += y\n    else:\n        if q[1] < sqrt:\n            out.append(str(ans[q[1]][q[2]]))\n        else:\n            out.append(str(sum([data[i] for i in range(q[2], n, q[1])])))\n            \nsys.stdout.write('\n'.join(out) + '\n')
n = int(input())\nu = [int(u) for u in input().split()]\n\nNMAX = 100005\n\nsuma = [0 for _ in range(NMAX)]\ntotal = [0 for _ in range(NMAX)]\n\ndiferentes = 0\nsol = 0\nmaximo = 1\n\nfor i, v in enumerate(u):\n	if total[v] == 0:\n		diferentes += 1\n	else:\n		suma[total[v]] -= 1\n	total[v] += 1\n	suma[total[v]] += 1\n\n	maximo = max(maximo, total[v])\n\n	#print(i, v, ":", diferentes)\n	#print(suma)\n	#print(total)\n	#print(maximo, ":", suma[maximo], suma[maximo+1], diferentes-1)\n	#print(maximo, ":", suma[maximo-1], suma[maximo], diferentes-1)\n\n	if diferentes <= 1:\n		sol = i\n\n	if suma[maximo-1] == diferentes-1 and suma[maximo] == 1:\n		sol = i\n\n	if suma[maximo] == diferentes-1 and suma[1] == 1:\n		sol = i\n\n	if suma[1] == diferentes:\n		sol = i\n	\n	#print("SOL", sol)\n\nprint(sol+1)\n
import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nN, M = list(map(int, input().split()))\nX = []\nfor _ in range(N):\n    a, b = list(map(int, input().split()))\n    X.append((a, b))\nY = []\nfor _ in range(M):\n    c, d = list(map(int, input().split()))\n    c, d = c, d+1\n    Y.append((c, d))\nY.sort(key = lambda x: -x[0])\n\nZ = [0] * 1001001\nfor a, b in X:\n    for c, d in Y:\n        if c >= a:\n            Z[c-a] = max(Z[c-a], d - b)\n\nans = 1 << 30\nma = 0\nfor i in range(1001000)[::-1]:\n    ma = max(ma, Z[i])\n    ans = min(ans, ma + i)\nprint(ans)\n\n
n, m = map(int, input().split())\nprint(n + m - 1)\nfor i in range(1, m + 1):\n    print(1, i)\nfor i in range(2, n + 1):\n    print(i, 1)
import sys\nfrom operator import itemgetter\n\nn, m, k, q = list(map(int, input().split()))\nquery = sorted((list(map(int, line.split()))\n                for line in sys.stdin), key=itemgetter(2))\ntimes = [q[2] for q in query]\n\n\ndef solve(ti):\n    imos = [[0]*(m+1) for _ in range(n+1)]\n    for i in range(ti):\n        imos[query[i][0]][query[i][1]] += 1\n\n    for i in range(n+1):\n        for j in range(m):\n            imos[i][j+1] += imos[i][j]\n    for j in range(m+1):\n        for i in range(n):\n            imos[i+1][j] += imos[i][j]\n    for i in range(k, n+1):\n        for j in range(k, m+1):\n            if imos[i][j] - imos[i-k][j] - imos[i][j-k] + imos[i-k][j-k] == k*k:\n                return True\n    return False\n\n\ninf = len(times)+1\nok, ng = inf, 0\nwhile abs(ok - ng) > 1:\n    mid = (ok + ng) >> 1\n    if mid >= k*k and solve(mid):\n        ok = mid\n    else:\n        ng = mid\n\nprint(times[ok-1] if ok != inf else -1)\n
from array import array\ninf = (1 << 30)\n\ndef main():\n    (n,k) = [int(x) for x in input().split(' ')]\n    Matrix = []\n    for i in range(n):\n        Matrix.append(array('b',[ord(x) for x in input()]))\n    dp = [array('l', [inf for j in range(n)]) for i in range(n)]\n    direct = [[ord('d') for j in range(n)] for i in range(n)]\n    opt = ""\n    for s in range (2 * n - 1):\n        opchar = chr(ord('z') + 1)\n        positions = []\n        for i in range(0, s+1):\n            j = s - i;\n            if j < n and i < n:\n                if(i > 0 and j > 0):\n                    if(dp[i-1][j] < dp[i][j-1]):\n                        dp[i][j] = dp[i-1][j]\n                        direct[i][j] = 'l'\n                    else:\n                       dp[i][j] = dp[i][j-1]\n                       direct[i][j] = 'd'\n                elif i > 0:\n                    dp[i][j] = dp[i-1][j]\n                    direct[i][j] = 'l'\n                elif j > 0:\n                    dp[i][j] = dp[i][j-1]\n                    direct[i][j] = 'd'\n                else:\n                    dp[i][j] = 0\n                    direct[i][j] = 'e'\n                if(dp[i][j] < k and Matrix[i][j] is not ord('a')):\n                    dp[i][j]+=1\n                    Matrix[i][j] = ord('a')\n                if(Matrix[i][j] < ord(opchar) and dp[i][j] <= k):\n                     opchar = chr(Matrix[i][j])\n        for i in range(0, s+1):\n            j = s - i;\n            if j < n and i < n:\n                if(Matrix[i][j] is not ord(opchar)):\n                    dp[i][j] = inf\n    ans = ""\n    a,b = (n-1,n-1)\n    while(direct[a][b] is not 'e'):\n        ans += chr(Matrix[a][b])\n        if(direct[a][b] is 'l'):\n            a-=1\n        else:\n            b-=1\n    ans += chr(Matrix[0][0])\n    print(ans[::-1])\n\nmain()\n
n = int(input())\nINF = 10 ** 18\ng = [[INF for i in range(n)] for _ in range(n)]\nfor i in range(n):\n	s = input().rstrip()\n	for j in range(n):\n		if s[j] == '1':\n			g[i][j] = 1\n	g[i][i] = 0\nfor k in range(n):\n	for i in range(n):\n		for j in range(n):\n			g[i][j] = min(g[i][j], g[i][k] + g[k][j])\nm = int(input())\np = [int(i) - 1 for i in input().split()]\nptr = 1\nans = [p[0]]\nwhile ptr + 1 < len(p):\n	s = ans[-1]\n	if g[s][p[ptr]] + 1 != g[s][p[ptr + 1]]:\n		ans.append(p[ptr])\n	ptr += 1\nans.append(p[-1])\nprint(len(ans))\nfor i in ans:\n	print(i + 1, end=" ")
from collections import Counter\n\nn = int(input())\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\n\naidx = [-1]*n\nbidx = [-1]*n\n\nfor i, (ai, bi) in enumerate(zip(a, b)):\n    aidx[ai-1] = i\n    bidx[bi-1] = i\n\ndiffs = [(aidx[i] - bidx[i]) % n for i in range(n)]\nprint(max(Counter(diffs).values()))\n
import sys\nit = iter(sys.stdin.readlines())\ninput = it.__next__\nn, k = list(map(int, input().split()))\nd, c = [0] * n, [0] * n\nfor i in range(n):\n    a, b = list(map(int, input().split()))\n    d[i], c[i] = a, k - b\n\np, r, pre, suf, sm, mx = list(range(n)), [0] * n, c[:], c[:], c[:], c[:]\n\ndef find(x):\n    if x != p[x]:\n        p[x] = find(p[x])\n    return p[x]\n\ndef union(x, y, w):\n    x, y = find(x), find(y)\n    z = y if r[y] > r[x] else x\n    r[x] += r[x] == r[y]\n    mx[z] = max(mx[x], mx[y], suf[x] + pre[y])\n    pre[z] = max(pre[x], sm[x] + pre[y])\n    suf[z] = max(suf[x] + sm[y], suf[y])\n    sm[z] = sm[x] + sm[y]\n    p[x] = p[y] = z\n    return mx[z] - w ** 2\n\nans = max(0, max(c))\nfor w, i in sorted((d[i + 1] - d[i], i) for i in range(n - 1)):\n    ans = max(ans, union(i, i + 1, w))\nprint(ans)\n
n, m = map(int, input().split())\na = [0] + list(map(int, input().split()))\nb = [0] + [set() for i in range(n) ]\nk = 0\nf = [0] * (n + 1)\nf[1] = a[1]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    b[x].add(y)\n    b[y].add(x)\n    \nfrom collections import deque\nd = deque()\nd.append(1)\nwhile len(d) > 0:\n    t = d.popleft()\n    if len(b[t]) == 0:\n        if f[t] <= m:\n            k += 1\n    for i in b[t]:\n        b[i].remove(t)\n        if a[i] == 0 and f[t] <= m:\n            f[i] = 0\n        else:    \n            f[i] = f[t] + 1\n        d.append(i)\nprint(k)
t = int(input())\nfor _ in range(t):\n	n, k = map(int, input().split())\n	n -= k**2\n	if n<0:\n		print("NO")\n	elif n%2 == 0:\n		print("YES")\n	else:\n		print("NO")
#list(map(int,input().split()))\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    it=list(map(int,input().split()))\n    print(len(set(it)))\n
def put():\n    return list(map(int, input().split()))\ndef diff(x,y):\n    ans = 0\n    for i in range(n*m):\n        if s[x][i]!= s[y][i]:\n            ans+=1\n    return ans\ndef find(i):\n    if i==p[i]:\n        return i\n    p[i] = find(p[i])\n    return p[i]\ndef union(i,j):\n    if rank[i]>rank[j]:\n        i,j = j,i\n    elif rank[i]==rank[j]:\n        rank[j]+=1\n    p[i]= j\ndef dfs(i,p):\n    if i!=0:\n        print(i,p)\n    for j in tree[i]:\n        if j!=p:\n            dfs(j,i)\n\nn,m,k,w = put()\ns = ['']*k \nfor i in range(k):\n    for j in range(n):\n        s[i]+=input()\nedge = []\nk+=1\nrank = [0]*(k)\np = list(range(k))\ncost = 0\ntree = [[] for i in range(k)]\n\nfor i in range(k):\n    for j in range(i+1,k):\n        if i==0:\n            z=n*m\n        else:\n            z = diff(i-1,j-1)*w\n        edge.append((z,i,j))\n\nedge.sort()\nfor z,i,j in edge:\n    u = find(i)\n    v = find(j)\n    if u!=v:\n        union(u,v)\n        cost+= z\n        tree[i].append(j)\n        tree[j].append(i)\n\nprint(cost)\ndfs(0,-1)\n
def main():\n    from sys import stdin\n    k, n = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    res = set()\n    for i in range(k):\n        # putting b[0] on place i\n        our = set()\n        curr = b[0]\n        for j in range(i, -1, -1):\n            our.add(curr)\n            curr -= a[j]\n        first = curr\n        good = True\n        curr = b[0]\n        for j in range(i + 1, k):\n            curr += a[j]\n            our.add(curr)\n        for elem in b:\n            if elem not in our:\n                good = False\n                break\n        if good:\n            res.add(first)\n    print(len(res))\n    \n    \nmain()
import sys\n\n(n, k) = [int(x) for x in sys.stdin.readline().strip().split()]\n\nans = -999999999999999999999999999999999999999999\n\nfor i in range(0, n):\n    (f, t) = [int(x) for x in sys.stdin.readline().strip().split()]\n    ans = max(ans, f-max(0,t-k))\n\nprint(ans)\n
t = input()\nt = t.split()\nn = int(t[0])\nc1 = int(t[1])\nc2 = int(t[2])\nt = input()\nd = 0\nfor i in t:\n    if(i=="1"):\n        d = d+1\n\nmin = 10**1488\nfor i in range(1, d+1):\n    t = c1*i + i*c2*(((n//i)-1)**2) + c2*(n%i)*(2*(n//i)-1)\n    if t<min:\n        min = t\n\nprint(min)
#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input().rstrip()\n    words = []\n    for i in range(n):\n        if (n - i) % 2 == 0:\n            words.append((s[i:] + s[:i], i+1))\n        else:\n            words.append((s[i:] + s[:i][::-1], i+1))\n    words.sort()\n    print(words[0][0])\n    print(words[0][1])\n
INF = 10 ** 10\ndef merge(l, r):\n    res = l + r\n    \n    i = j = k = 0\n    while i < len(l) and j < len(r):\n        if l[i] < r[j]:\n            res[k] = l[i]\n            k += 1\n            i += 1\n        else:\n            res[k] = r[j]\n            k += 1\n            j += 1\n    while i < len(l):\n        res[k] = l[i]\n        k += 1\n        i += 1\n    while j < len(r):\n        res[k] = r[j]\n        k += 1\n        j += 1\n\n    return res\n\ndef solve(fl, fr, l, r):\n    if l == r:\n        return 0\n    \n    mid = (l + r) // 2\n    res = solve(fl, fr, l, mid) + solve(fl, fr, mid + 1, r)\n\n    i, j = l, mid + 1\n    while i <= mid:\n        while j <= r and fr[j] < fl[i]:\n            j += 1\n        res += j - mid - 1\n        i += 1\n    fl[l: r + 1] = merge(fl[l: mid + 1], fl[mid + 1: r + 1])\n    fr[l: r + 1] = merge(fr[l: mid + 1], fr[mid + 1: r + 1])\n    return res\n\ndef __starting_point():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    fl, cnt = [], {}\n    for x in a:\n        cnt[x] = cnt.get(x, 0) + 1\n        fl.append(cnt[x])\n\n    fr, cnt = [], {}\n    for x in a[::-1]:\n        cnt[x] = cnt.get(x, 0) + 1\n        fr.append(cnt[x])\n    fr = fr[::-1]\n\n#     print(fl, fr)\n    print(solve(fl, fr, 0, n - 1))\n#     print(fl, fr)\n\n__starting_point()
# reproduction of solution № 66039386 by @windhunterSB\nimport sys\n\n\n# inf = open('input.txt', 'r')\n# reader = (line.rstrip() for line in inf)\nreader = (s.rstrip() for s in sys.stdin)\n\nn = int(next(reader))\noperations = next(reader)\n\n# inf.close()\n\nleft_sum = [0] * (n + 2)   # for s[:i+1]\nright_sum = [0] * (n + 2)  # for s[i:][::-1]\nleft_min = [0] * (n + 2)   # min - validation of bracket sequence\nright_min = [0] * (n + 2)  \nleft_max = [0] * (n + 2)   # max - depth of bracket sequence\nright_max = [0] * (n + 2)\ntext = [0] * (n + 2)       # entered text, letters marked as 0\n\nop_map = {'(': 1,\n          ')': -1}\nans = []\ni = 1  # cursor loc i >= 1\nfor op in operations:\n    if op == 'L':\n        i = max(1, i - 1)\n    elif op == 'R':\n        i += 1\n    else:\n        text[i] = op_map.get(op, 0)\n        \n    left_sum[i] = left_sum[i - 1] + text[i]\n    left_min[i] = min(left_min[i - 1], left_sum[i])\n    left_max[i] = max(left_max[i - 1], left_sum[i])\n    \n    right_sum[i] = right_sum[i + 1] - text[i]  # -text[i] cause of symmetry\n    right_min[i] = min(right_min[i + 1], right_sum[i])\n    right_max[i] = max(right_max[i + 1], right_sum[i])\n    \n    correct = left_min[i] >= 0 and right_min[i + 1] >= 0 and left_sum[i] == right_sum[i + 1]\n    status = max(left_max[i], right_max[i + 1]) if correct else -1\n    ans.append(status)\n    \nprint(*ans)\n
from math import *\n\ndef r1(t):\n    return t(input())\n\ndef r2(t):\n    return [t(i) for i in input().split()]\n\nfor _ in range(r1(int)):\n    n = r1(int)\n    a = r2(int)\n    g = True\n    for i in range(n):\n        if a[i] != i + 1:\n            g = False\n            break\n    if g:\n        print(0)\n        continue\n\n    g = True\n    c = 0\n    p = False\n    for i in range(n):\n        if a[i] != i + 1:\n            if p == False:\n                c += 1\n                p = True\n        else:\n            p = False\n    print(min(c, 2))\n
n, m, k = map(int, input().split())\narr = [0] * n\npl = [0] * n\nz = 0\nfor i in input().split():\n    j = int(i)\n    arr[j - 1] = z\n    pl[z] = j - 1\n    z += 1\n#print(arr, pl)\nr = 0\nfor i in input().split():\n    j = int(i) - 1\n    c = arr[j]\n    r += c // k + 1\n    if c != 0:\n        pl[c - 1], pl[c] = pl[c], pl[c - 1]\n        arr[pl[c]] += 1\n        arr[j] -= 1\n    #print(arr, pl)\nprint(r)
"""\n	Author		: Arif Ahmad\n	Date  		: \n	Algo  		: \n	Difficulty	: \n"""\nfrom sys import stdin, stdout\nfrom collections import deque\n\ng = None # contains the actual graph\nh = None # h[x][y] represents the component in which cell (x,y) belongs\nr = None\nc = None\nvisited = None\ntotal = None\ncomp = None\ndx = [-1, 0, 0, 1]\ndy = [0, -1, 1, 0]\n\n\ndef bfs(x, y):\n	nonlocal total\n	\n	q = deque([(x, y)])\n	total += 1\n	visited[x][y] = True\n	h[x][y] = comp\n	while q:\n		x, y = q.pop()\n		#print('comp:', comp, 'cell:', x, y)\n		for k in range(4):\n			#print('loop:', k)\n			nx = x + dx[k]\n			ny = y + dy[k]\n			#print(visited)\n			#print('new cell:', nx, ny, 'check:', nx>=0 , nx<r , ny>=0 , ny<c , visited[nx][ny]==False , g[nx][ny]=='.')\n			if nx>=0 and nx<r and ny>=0 and ny<c and visited[nx][ny]==False and g[nx][ny]=='.':\n				q.appendleft((nx, ny))\n				total += 1\n				visited[nx][ny] = True\n				h[nx][ny] = comp\n\n\ndef main():\n	nonlocal g, h, r, c, visited, comp, total\n\n	r, c = [int(_) for _ in stdin.readline().split()]\n\n	g = []\n	for i in range(r):\n		line = stdin.readline()\n		g.append(list(line))\n\n	component = []\n	h = [[-1 for i in range(c)] for j in range(r)]\n	visited = [[False for i in range(c)] for j in range(r)]\n	#print(visited)\n\n	for i in range(r):\n		for j in range(c):\n			if visited[i][j] == False and g[i][j] == '.':\n				comp = len(component)\n				total = 0\n				#print('calling bfs', i, j)\n				bfs(i, j)\n				component.append(total)\n\n	for x in range(r):\n		for y in range(c):\n			if g[x][y] == '*':\n				ans = 0\n				idx = set()\n				for k in range(4):\n					nx = x + dx[k]\n					ny = y + dy[k]\n					if nx>=0 and nx<r and ny>=0 and ny<c and g[nx][ny]=='.':\n						idx.add(h[nx][ny])\n				for item in idx:\n					#print(component[item])\n					ans += component[item]\n				ans += 1\n				ans %= 10\n				g[x][y] = str(ans)\n\n	#print(component)\n	for i in range(r):\n		stdout.write(''.join(g[i]))\n\n	\n\ndef __starting_point():\n    main()\n\n__starting_point()
s = input()\nn = len(s)\np = [0] * n\nk = 0\nfor i in range(1, n):\n  while k != 0 and s[k] != s[i]:\n    k = p[k - 1]\n  if s[k] == s[i]:\n    k += 1\n  p[i] = k\na = []\nk = n\nwhile k != 0:\n  a += [k]\n  k = p[k - 1]\nc = [0] * (n + 1)\nfor i in range(n):\n  c[p[i]] += 1\nfor i in range(n - 1, 1, -1):\n  c[p[i - 1]] += c[i]\nprint(len(a))\nfor t in reversed(a):\n  print(t, c[t] + 1)
s=input()\ndef shift(x,k):\n    x=x[-k:]+x[:-k]\n    return x\nfor i in range(int(input())):\n    l,r,k=tuple(map(int,input().split()))\n    l-=1\n    k%=(r-l)\n    s=s[:l]+shift(s[l:r],k)+s[r:]\nprint(s)\n
n=int(input())\nc=set('qwertyuiopasdfghjklzxcvbnm')\nch=False\nk=0\nfor i in range(n-1):\n    s=input()\n    if ch:\n        if s[0]!='.':\n            k+=1\n    else:\n        if s[0]=='.':\n            c.difference_update(set(s[2:]))\n        elif s[0]=='!':\n            c.intersection_update(set(s[2:]))\n        else:\n            if s[2] in c:\n                c.remove(s[2])\n        if len(c)==1:\n            ch=True\ninput()\nprint(k)
import sys\nfin = sys.stdin\nn = int(fin.readline())\nut = [-1] * n\nvc = [[] for i in range(0, n)]\ncvc = [[] for i in range(0, n)]\nnr = [0] * n\nfor i in range(0, n - 1):\n    a, b = [int(number) for number in fin.readline().split()]\n    a -= 1\n    b -= 1\n    vc[a].append(b)\n    cvc[b].append(a)\n    nr[a] += 1\nsize = [0] * n\nmx = [0] * n\ndef nonzero(x):\n    if not x:\n        return 0\n    return 1\nstk = []\nsize = [0] * n\nfor i in range(0, n):\n    if nr[i] == 0:\n        stk.append(i)\n        size[i] = 1\norder = []\nwhile nonzero(stk):\n    x = stk.pop(-1)\n    order.append(x)\n    for p in cvc[x]:\n        nr[p] -= 1\n        if nr[p] == 0:\n            stk.append(p)\nh = [0] * n\nfor i in range(n - 1, -1, -1):\n    x = order[i]\n    for p in vc[x]:\n        h[p] = h[x] + 1\n#parcurg\nfor x in order:\n    for p in vc[x]:\n        size[x] += size[p]\n#maximum\ndef solv(tp, mx):\n    for x in order:\n        if h[x] % 2 == tp:\n            r = 999999999\n            for p in vc[x]:\n                r = min(r, size[p] - mx[p] + 1)\n            if r == 999999999:\n                r = 1\n            mx[x] = r\n        else:\n            r = 0\n            for p in vc[x]:\n                r += size[p] - mx[p]\n            mx[x] = r + 1\nsolv(0, mx)\nprint(size[0] - mx[0] + 1, end = ' ')\nsolv(1, mx)\nprint(size[0] - mx[0] + 1)\n
def sum_zeroth(arr):\n    res = 0\n    for elem in arr:\n        res += elem[0]\n    return res\n\nn, a, b, k = list(map(int, input().split()))\ndata = input()\ndist = []\npp = 0\n\nlast = 0\nfor i in range(n):\n    if data[i] == '1':\n        dist.append((last, i))\n        pp += (i - last) // b\n        last = i + 1\n\ndist.append((last, n))\npp += (n - last) // b\npos = []\nminp = pp - a + 1\nfnd = False\n\nfor elem in dist:\n    cur = elem[0] - 1\n    while (cur + b) < elem[1]:\n        cur += b\n        pos.append(cur + 1)\n        if len(pos) == minp:\n            fnd = True\n            break\n    if fnd:\n        break\n\nprint(minp)\nprint(' '.join(map(str, pos)))\n
n = int(input())\n\nxs = [int(x) for x in input().split()]\n\npos = {}\nfor i, x in enumerate(xs):\n    while x in pos:\n        del pos[x]\n        x *= 2\n    pos[x] = i\n\nks = sorted(list(pos.keys()), key=lambda k: pos[k])\n\nprint(len(ks))\nprint(" ".join(map(str, ks)))\n
n = int(input())\na = [int(i) for i in input().split()]\n\ndef isp2(x):\n	return (x >= 1) and ((x & (x - 1)) == 0)\n\np2 = [2 ** i for i in range(33)]\n\nd = {}\nfor i in a:\n	if i in d:\n		d[i] += 1\n	else:\n		d[i] = 1\n\nk = 0\nfor i in d:\n	for p in p2:\n		j = p - i\n		if j > i:\n			break;\n		if j in d:\n			if i == j:\n				k += d[i] * (d[i] - 1) // 2\n			else:\n				k += d[i] * d[j]\n\nprint(k)\n
import sys\nfrom math import *\n\ndef minp():\n	return sys.stdin.readline().strip()\n\ndef mint():\n	return int(minp())\n\ndef mints():\n	return map(int, minp().split())\n\ndef add(a,b):\n	return (a+b)%1000000007\n\ndef mul(a,b):\n	return (a*b)%1000000007\n\ndef sub(a,b):\n	return (a-b+1000000007)%1000000007\n\ndef qpow(a, b):\n	r = 1\n	k = a\n	for i in range(17):\n		if b & (1<<i):\n			r = mul(r, k)\n		k = mul(k, k)\n	return r\n\nn, q = mints()\na = list(minp())\nc = [0]*(n+1)\nfor i in range(n):\n	c[i+1] = c[i] + int(a[i])\nfor i in range(q):\n	l, r = mints()\n	k = (r-l+1)\n	o = c[r]-c[l-1]\n	z = sub(qpow(2,o),1)\n	print(mul(z,qpow(2,k-o)))
n = int(input())\nbeauty = list(map(int, input().strip().split()))\ntree = [[] for i in range(n)]\nmod = 1000000007\nused = [False for i in range(n)]\ndef gcd(a,b):\n    mn = min(a,b)\n    mx = max(a,b)\n    if mn == 0:\n        return mx\n    md = mx%mn\n    if md == 0:\n        return mn\n    else:\n        return gcd(mn, md)\nfor i in range(n-1):\n    a,b = map(int, input().strip().split())\n    tree[a-1].append(b-1)\n    tree[b-1].append(a-1)\nsegment_vals = [{} for i in range(n)]\nans = beauty[0]\nsegment_vals[0][beauty[0]] = 1\ncur_nodes = [0]\nused[0] = True\nwhile 1:\n    new_nodes = []\n    for node in cur_nodes:\n        for potential_new in tree[node]:\n            if used[potential_new] == False:\n                used[potential_new] = True\n                new_nodes.append(potential_new)\n                new_beauty = beauty[potential_new]\n                segment_vals[potential_new][new_beauty] = 1\n                for g in segment_vals[node].keys():\n                    segment_gcd = gcd(new_beauty,g)\n                    segment_vals[potential_new][segment_gcd] = segment_vals[potential_new].get(segment_gcd,0) + segment_vals[node][g]\n                for k in segment_vals[potential_new].keys():\n                    ans += k*segment_vals[potential_new][k]\n                    ans = ans % mod\n    if len(new_nodes) == 0:\n        break\n    else:\n        cur_nodes = new_nodes\nprint(ans)
# 10\n# + 8\n# + 9\n# + 11\n# + 6\n# + 1\n# ? 3\n# - 8\n# ? 3\n# ? 8\n# ? 11\n\nMAX_BIT = 30\n\nclass Node:\n    def __init__(self):\n        self.left = None\n        self.right = None\n        self.leftCnt = 0\n        self.rightCnt = 0\n    \n    def AddRight(self):\n        if self.right == None:\n            self.right = Node()\n            self.rightCnt = 1\n        else:\n            self.rightCnt += 1\n    \n    def AddLeft(self):\n        if self.left == None:\n            self.left = Node()\n            self.leftCnt = 1\n        else:\n            self.leftCnt += 1\n\n    def RemRight(self):\n        self.rightCnt -= 1\n    \n    def RemLeft(self):\n        self.leftCnt -= 1\n\n    def Left(self):\n        return self.left != None and self.leftCnt > 0\n\n    def Right(self):\n        return self.right != None and self.rightCnt > 0\n\ndef insert(u, num, dig=MAX_BIT):\n    if dig < 0:\n        return\n    \n    bit = (num>>dig)&1\n    if bit > 0: #insert to right\n        u.AddRight()\n        insert(u.right, num, dig-1)\n    else:\n        u.AddLeft()\n        insert(u.left, num, dig-1)\n\ndef remove(u, num, dig=MAX_BIT):\n    if dig < 0:\n        return\n    \n    bit = (num>>dig)&1\n    if bit > 0: #remove right\n        u.RemRight()\n        remove(u.right, num, dig-1)\n    else:\n        u.RemLeft()\n        remove(u.left, num, dig-1)\n\ndef cal(u, num, dig=MAX_BIT):\n    if dig < 0 or u == None:\n        return 0\n    \n    bit = (num>>dig)&1\n    if bit > 0: #try to go to left first\n        if u.Left(): #if valid\n            return (1<<dig) + cal(u.left, num, dig-1)\n        elif u.Right():\n            return cal(u.right, num, dig-1)\n    else: #try to go to right first\n        if u.Right():\n            return (1<<dig) + cal(u.right, num, dig-1)\n        elif u.Left():\n            return cal(u.left, num, dig-1)\n    return 0\n\ndef main():\n    root = Node()\n    insert(root, 0)\n\n    n = int(input())\n    for i in range(n):\n        tmp = input().split()\n        num = int(tmp[1])\n        if tmp[0] == "+":\n            insert(root, num)\n        elif tmp[0] == "-":\n            remove(root, num)\n        else:\n            print(cal(root, num))\n\nmain()
s=int(input())\ni=2\nprint(s//2+s-s//2+s//2)\nwhile(i<=s):\n    print(i, end= ' ')\n    i+=2\ni=1\nwhile(i<=s):\n    print(i, end= ' ')\n    i+=2\ni=2\nwhile(i<=s):\n    print(i, end= ' ')\n    i+=2
from math import *\nfrom sys import *\nfrom queue import *\nfrom decimal import *\n\nn,n1,n2=(int(z) for z in input().split())\ns=[int(z) for z in input().split()]\ns.sort()\nfor i in range(n//2):\n  s[i],s[n-1-i]=s[n-1-i],s[i]\nsum1=0\nsum2=0\nif n1>n2:\n  n1,n2=n2,n1\nfor i in range(n1):\n  sum1+=s[i]\nfor i in range(n1,n1+n2):\n  sum2+=s[i]\nprint(Decimal(sum1)/Decimal(n1)+Decimal(sum2)/Decimal(n2))
import sys\n\nH, W = list(map(int, input().split()))\nL = set()\nfor y in range(H):\n    row = input().strip()\n    i_sweet = row.find('S')\n    i_gnome = row.find('G')\n    if i_sweet == -1 or i_gnome > i_sweet:\n        print(-1)\n        return\n    L.add(i_sweet - i_gnome)\nprint(len(L))\n
# NOT MY CODE\n# https://codeforces.com/contest/919/submission/80857731\n \nfrom types import GeneratorType\n \ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        to = f(*args, **kwargs)\n        if stack:\n            return to\n        else:\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        return to\n                    to = stack[-1].send(to)\n    return wrappedfunc\n \nimport sys\ninput=sys.stdin.readline\nfrom collections import defaultdict as dd\n'''\ndef iscyclic(g):\n    for i in range(1,n+1):\n        if(\n'''\nn,m=list(map(int,input().split()))\ns=input()\nd=dd(list)\nlol=0\nfor i in range(m):\n    u,v=list(map(int,input().split()))\n    if(u==v):\n        lol=1\n        print(-1)\n        return\n    d[u].append(v)\n'''\nif(iscyclic(d)):\n    lol=1\n    print(-1)\n    return\n'''\nvis=[0]*(n+1)\nrvis=[0]*(n+1)\ncou=[0]\ndp=[dd(int) for i in range(n+1)]\nmx=[0]\nh=[0]\n#print(d)\n@bootstrap\ndef dfs(u):\n    if(h[0]==1):\n        yield\n    vis[u]=1\n    rvis[u]=1\n    for i in d[u]:\n        if(h[0]==1):\n            yield\n        if(vis[i]==0):\n            yield dfs(i)\n            if(h[0]==1):\n                yield            \n        elif(rvis[i]==True):\n            h[0]=1\n            yield\n    rvis[u]=0\n    if(h[0]==1):\n        yield\n    for i in d[u]:\n        for j in dp[i]:\n            dp[u][j]=max(dp[u][j],dp[i][j])\n            mx[0]=max(mx[0],dp[u][j])\n    dp[u][s[u-1]]+=1\n    #print(u,dp[u])\n    mx[0]=max(mx[0],dp[u][s[u-1]])\n    yield\n#print(dp)\nfor i in range(1,n+1):\n    if(vis[i]==0):\n        cou=[0]\n        dfs(i)\nif(h[0]):\n    print(-1)\nelse:\n    print(mx[0])\n
\nn = int(input())\nS = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    S.append([a, b])\nS.sort(key=lambda x: (x[1] - x[0]))\ncnt = 0\nfor i in range(n):\n    cnt += S[i][0] * i + S[i][1] * (n - i - 1)\nprint(cnt)
n = int(input())\nr1, c1 = map(int, input().split())\nr2, c2 = map(int, input().split())\na = [['1'] * (n + 2)]\nfor _ in range(n):\n    s = input()\n    d = ['1']\n    for i in s:\n        d.append(i)\n    d.append('1')\n    a.append(d)\na.append(['1'] * (n + 2))\ns = []\nf = []\nq = [[r1, c1]]\nwhile q:\n    x, y = q.pop()\n    a[x][y] = '1'\n    s.append([x, y])\n    if a[x - 1][y] == '0':\n        q.append([x - 1, y])\n    if a[x][y - 1] == '0':\n        q.append([x, y - 1])\n    if a[x + 1][y] == '0':\n        q.append([x + 1, y])\n    if a[x][y + 1] == '0':\n        q.append([x, y + 1])\nif [r2, c2] in s:\n    print(0)\nelse:\n    q = [[r2, c2]]\n    while q:\n        x, y = q.pop()\n        a[x][y] = '1'\n        f.append([x, y])\n        if a[x - 1][y] == '0':\n            q.append([x - 1, y])\n        if a[x][y - 1] == '0':\n            q.append([x, y - 1])\n        if a[x + 1][y] == '0':\n            q.append([x + 1, y])\n        if a[x][y + 1] == '0':\n            q.append([x, y + 1])\n    res = 10**10\n    for i in s:\n        for j in f:\n            res = min(res, (i[0] - j[0])**2 + (i[1] - j[1])**2)\n    print(res)
import sys\nn,m=list(map(int,sys.stdin.readline().split()))\n\nL=list(map(int,sys.stdin.readline().split()))\nc=0\nAns=""\nfor i in range(m):\n    x=list(map(int,sys.stdin.readline().split()))\n    if(x[0]==1):\n        L[x[1]-1]=x[2]-c\n    elif(x[0]==2):\n        c+=x[1]\n    else:\n        Ans+=str(L[x[1]-1]+c)+"\n"\nsys.stdout.write(Ans)\n
import sys\nimport math\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\narr=[0]*n\nfor i in range(m):\n	u,v,d=map(int,input().split())\n	arr[u-1]-=d\n	arr[v-1]+=d\n\npos=[]\nneg=[]\nfor i in range(n):\n	if arr[i]>0:\n		pos.append([i,arr[i]])\n	elif arr[i]<0:\n		neg.append([i,-arr[i]])\n\n# print(pos,neg)\nans=[]\nj=0\nfor i in range(len(neg)):\n	while neg[i][1]>0:\n		# print(j)\n		if pos[j][1]>=neg[i][1]:\n			ans.append([neg[i][0]+1,pos[j][0]+1,neg[i][1]])\n			pos[j][1]-=neg[i][1]\n			neg[i][1]=0\n			if pos[j][1]==0:\n				j+=1\n		else:\n			ans.append([neg[i][0]+1,pos[j][0]+1,pos[j][1]])\n			neg[i][1]-=pos[j][1]\n			pos[j][1]=0\n			j+=1\n\nprint(len(ans))\nfor i in range(len(ans)):\n	print(*ans[i])
import sys\n\nn = int(input())\nc = list(map(int, input().split()))\ncc = ord('a')\nans = ""\ncur = n - 1\nif 1:\n    cur = n - 1\n    while cur >= 0:\n        while c[cur] > 0:\n            if chr(cc) > 'z':\n                cc = ord('a')\n            ans += chr(cc) * (cur + 1)\n            c[cur] -= 1\n            for i in range(cur):\n                c[i] -= (cur - i + 1)\n            cc += 1\n        cur -= 1\n    print(ans)\n\n    \n
n, m, k = map(int, input().split())\ns = 'U' * (n - 1)\ns += 'L' * (m - 1)\nfor i in range(n):\n    if (i % 2 == 0):\n        s += 'R' * (m - 1)\n    else:\n        s += 'L' * (m - 1)\n    if i != n - 1:\n        s += 'D'\nprint(len(s))\nprint(s)
def main():\n    n, k = tuple(map(int, input().split()))\n\n    a = [set(range(n)) for _ in range(n)]\n\n    for i in range(k):\n        p = set()\n        for j in map(int, input().split()):\n            a[j-1] -= p\n            p.add(j-1)\n\n    sa = sorted(list(range(n)), key=lambda i: len(a[i]))\n    maxx = [0] * n\n    res = 0\n    \n    for i in sa:\n        m = 1 + maxx[max(a[i], key=lambda e: maxx[e])] if a[i] else 0\n        maxx[i] = m\n        res = max(res, m)\n\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()
t=int(input())\nfor _ in range(t):\n    a,b,c=list(map(int,input().split()))\n    a,b,c=sorted([a,b,c])\n    if a+b>=c-1:\n        print("Yes")\n    else:\n        print("No")\n
#!/usr/bin/env python3\n\n# solution after hint\n# (instead of best hit/mana spell store convex hull of spells)\n# O(n^2) instead of O(n log n)\n\n\n[q, m] = list(map(int, input().strip().split()))\nqis = [tuple(map(int, input().strip().split())) for _ in range(q)]\n\nmod = 10**6\n\nj = 0\nspell_chull = [(0, 0)]  # lower hull _/\n\ndef is_right(xy0, xy1, xy):\n	(x0, y0) = xy0\n	(x1, y1) = xy1\n	(x, y) = xy\n	return (x0 - x) * (y1 - y) >= (x1 - x) * (y0 - y)\n\ndef in_chull(x, y):\n	i = 0\n	if x > spell_chull[-1][0]:\n		return False\n	while spell_chull[i][0] < x:\n		i += 1\n	if spell_chull[i][0] == x:\n		return spell_chull[i][1] <= y\n	else:\n		return is_right(spell_chull[i - 1], spell_chull[i], (x, y))\n	\n\n\ndef add_spell(x, y):\n	nonlocal spell_chull\n	if in_chull(x, y):\n		return\n	i_left = 0\n	while i_left < len(spell_chull) - 1 and not is_right(spell_chull[i_left + 1], spell_chull[i_left], (x, y)):\n		i_left += 1\n	i_right = i_left + 1\n	while i_right < len(spell_chull) - 1 and is_right(spell_chull[i_right + 1], spell_chull[i_right], (x, y)):\n		i_right += 1\n	if i_right == len(spell_chull) - 1 and x >= spell_chull[-1][0]:\n		i_right += 1\n	spell_chull = spell_chull[:i_left + 1] + [(x, y)] + spell_chull[i_right:]\n\n\nfor i, qi in enumerate(qis):\n	(k, a, b) = qi\n	x = (a + j) % mod + 1\n	y = (b + j) % mod + 1\n	if k == 1:\n		add_spell(x, y)\n	else:  #2\n		if in_chull(y / x, m / x):\n			print ('YES')\n			j = i + 1\n		else:\n			print ('NO')\n
import sys\nfrom collections import defaultdict\n \nclass BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * n\n    \n    def _get_sum(self, r):\n        '''\n        sum on interval [0, r)\n        '''\n        result = 0\n        while r > 0:\n            result += self.tree[r-1]\n            r &= (r - 1)\n        return result\n    \n    def get_sum(self, l, r):\n        '''\n        sum on interval [l, r)\n        '''\n        return self._get_sum(r) - self._get_sum(l)\n    \n    def add(self, i, value=1):\n        while i < self.n:\n            self.tree[i] += value\n            i |= (i + 1)\n\nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\n\nn = int(input())\nswaps = []\nfor _ in range(n):\n    i, j = list(map(int, input().split()))\n    swaps.append(i)\n    swaps.append(j)\n\npos = defaultdict(list)\nfor i, val in enumerate(swaps):\n    pos[val].append(i)\n\nc = 0\nprev = -1\ncompr = [0] * (2*n)\ndecompr = {}\nfor val in sorted(swaps):\n    if prev == val: continue\n    for j in pos[val]:\n        compr[j] = c\n    decompr[c] = val\n    c += 1\n    prev = val\n\narr = list(range(c))\nfor t in range(n):\n    i, j = compr[t<<1], compr[t<<1|1]\n    arr[i], arr[j] = arr[j], arr[i]\n\nbit = BIT(c)\ntotal_inv = 0\nfor i, val in enumerate(arr):\n    total_inv += bit.get_sum(val+1, c)\n    if i != val:\n        total_inv += abs(decompr[val] - decompr[i]) - abs(val - i)\n    bit.add(val)\nprint(total_inv)\n
from math import gcd\nn, m, q = map(int, input().split())\nd = gcd(n, m)\nx = n // d\ny = m // d\nfor _ in range(q):\n    sx, sy, ex, ey = map(int, input().split())\n    p1 = 0\n    p2 = 0\n    if sx == 1:\n        p1 = (sy - 1) // x\n    else:\n        p1 = (sy - 1) // y\n    if ex == 1:\n        p2 = (ey - 1) // x\n    else:\n        p2 = (ey - 1) // y\n    if p1 == p2:\n        print('YES')\n    else:\n        print('NO')
t = int(input())\n\nfor _ in range(t):\n    s = [int(i) for i in input()]\n    ct0 = 0\n    ct1 = 0\n    \n    for i in s:\n        if i == 1:\n            ct1 += 1\n        else:\n            ct0 += 1\n            \n    ct = min(ct0, ct1)\n    if ct%2:\n        print("DA")\n    else:\n        print("NET")
a, b = [0] * 101, [0] * 101\nfor i in range(int(input())):\n    x, y = map(int, input().split())\n    a[x] = b[y] = 1\nprint(min(sum(a), sum(b)))
n = int(input())\n\na = list(map(int, input().split()))\n\nm = int(input())\n\nq = list(map(int, input().split()))\n\na.sort()\n\ns = sum(a)\n\nfor qi in q:\n	print(s - a[-qi])\n
import sys\nfrom math import ceil\ninput = sys.stdin.readline\n    \nn, m, req = map(int, input().split())\ne = [tuple(map(int, input().split())) for _ in range(m)]\ng = [[] for _ in range(n + 1)]\nfor u, v in e:\n    g[u].append(v)\n    g[v].append(u)\n    \n# req = 1\n# while req * req < n:\n#     req += 1\n    \ndef dfs():\n    dep = [0] * (n + 1)\n    par = [0] * (n + 1)\n    st = [1]\n    st2 = []\n    while st:\n        u = st.pop()\n        if dep[u]:\n            continue\n        st2.append(u)\n        dep[u] = dep[par[u]] + 1\n        for v in g[u]:\n            if not dep[v]:\n                par[v] = u\n                st.append(v)\n            elif 2 < dep[u] - dep[v] + 1 <= req:\n                cyc = []\n                while u != par[v]:\n                    cyc.append(u)\n                    u = par[u]\n                return (None, cyc)\n    mk = [0] * (n + 1)\n    iset = []\n    while st2:\n        u = st2.pop()\n        if not mk[u]:\n            iset.append(u)\n            for v in g[u]:\n                mk[v] = 1\n    return (iset[:ceil(req/2)], None)\n    \niset, cyc = dfs()\nif iset:\n    print(1)\n    print(*iset)\nelse:\n    print(2)\n    print(len(cyc))\n    print(*cyc)
import sys\n'''\nSEGMENT TREE\nAssign\n'''\nclass SegmTree():\n    '''\n    - modify elements on interval\n    - get single element\n    '''\n    def __init__(self, size):\n        N = 1\n        while N < size:\n            N <<= 1\n        self.N = N\n        self.tree = [0] * (2*N)\n\n    def modify_range(self, l, r, value):\n        l += self.N\n        r += self.N\n        while l < r:\n            if l & 1:\n                self.tree[l] = value\n                l += 1\n            if r & 1:\n                r -= 1\n                self.tree[r] = value\n            l >>= 1\n            r >>= 1\n    \n    def query(self, i):\n        i += self.N\n        latest_change = self.tree[i]\n        p = i\n        while p > 1:\n            p >>= 1\n            latest_change = max(latest_change, self.tree[p])\n        return latest_change\n\n# inf = open('input.txt', 'r')\n# reader = (map(int, line.split()) for line in inf)\nreader = (list(map(int, line.split())) for line in sys.stdin)\ninput = reader.__next__\n\nn, m = input()\na = list(input())\nb = list(input())\nst = SegmTree(n)\nrequest = [None] * (m + 1)\nfor i in range(1, m+1):\n    t, *arg = input()\n    if t == 1:\n        x, y, k = request[i] = arg\n        st.modify_range(y-1, y-1+k, i)\n    else:\n        pos = arg[0] - 1\n        req_id = st.query(pos)\n        if req_id > 0:\n            x, y, k = request[req_id]\n            ans = a[x+(pos-y)]\n        else:\n            ans = b[pos]\n        sys.stdout.write(f'{ans}\n')\n\n# inf.close()\n
from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = map(int, input().split())\nmod = 998244353\nd = defaultdict(int)\nfor x in a:\n    d[x] += 1\nd[0] = 0\nb = list(d.items())\nb.sort()\nm = len(b)\nba = [0] * m\ncn = [0] * (m + 1)\nk = h = 0\nfor i, x in enumerate(b):\n    while h < m and x[0] >= b[h][0] * 2:\n        h += 1\n    ba[i] = h - 1\n    while k < m and x[0] * 2 > b[k][0]:\n        k += 1\n    cn[k] += x[1]\nfor i in range(m):\n    cn[i+1] += cn[i]\ndp = [0] * m\ndp[0] = 1\nb = [x[1] for x in b]\nfor i in range(n):\n    ndp = [0] * m\n    for j in range(1, m):\n        if cn[j] >= i - 1:\n            ndp[j] = dp[j] * (cn[j] - i + 1) % mod\n        dp[j] += dp[j-1]\n        if dp[j] >= mod:\n            dp[j] -= mod\n    for j in range(1, m):\n        ndp[j] += dp[ba[j]] * b[j]\n        ndp[j] %= mod\n    dp = ndp\nprint(sum(dp) % mod)
q = int(input())\nfor i in range(q):\n    n = int(input())\n    if n % 4 == 0:\n        print(n // 4)\n    elif n % 4 == 1 and n // 4 >= 2:\n        print(n // 4 - 1)\n    elif n % 4 == 2 and n // 4 >= 1:\n        print(n // 4)\n    elif n % 4 == 3 and n // 4 >= 3:\n        print(n // 4 - 1)\n    else:\n        print(-1)
n = int(input())\na = input()\nprot = dict()\nprot["D"] = "U"\nprot["L"] = "R"\nprot["R"] = "L"\nprot["U"] = "D"\nwas = set()\nans = 1\nfor i in range(n):\n    if (a[i] not in was):\n        if (len(was) == 0):\n            was.add(a[i])\n        elif len(was) == 1:\n            if (prot[a[i]] not in was):\n                was.add(a[i])\n            else:\n                was.clear()\n                was.add(a[i])\n                ans += 1\n        else:\n            was.clear()\n            was.add(a[i])\n            ans += 1\nprint(ans)
def main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.append(0)\n    ans = []\n    for i in range(n):\n        ans.append(arr[i] + arr[i + 1])\n    print(*ans)\n    \nmain()
n = int(input())\nm = 2 * n + 1\nu = [[] for i in range(m)]\nv = [0] * m\ns = [0] * m\nd = 10 ** 9 + 7\ny = 1\n\nfor j in range(n):\n    a, b = map(int, input().split())\n    v[a] = b\n    if a != b:\n        s[b] += 1\n        u[b].append(a)\n\nfor b in range(m):\n    if not v[b]:\n        x = 0\n        p = [b]\n        while p:\n            x += 1\n            a = p.pop()\n            s[a] = -1\n            p += u[a]\n        y = (x * y) % d\n\nfor a in range(m):\n    if s[a] == 0:\n        b = v[a]\n        while s[b] == 1:\n            s[b] = -1\n            b = v[b]\n        s[b] -= 1\n\nfor a in range(m):\n    if s[a] == 1:\n        y = (2 * y) % d\n        while s[a]:\n            s[a] = 0\n            a = v[a]\n\nprint(y)
inp1 = input()\nis1 = inp1.split(" ")\nnodeCount = int(is1[0])\nsum = float(is1[1])\nnodes = [0 for x in range(nodeCount)]\ninp2 = []\nfor z in range(nodeCount-1):\n    inp2.append(input())\nfor reb in inp2:\n    rebs = reb.split(" ")\n    i = int(rebs[0])-1\n    nodes[i] = nodes[i]+1\n    i = int(rebs[1])-1\n    nodes[i] = nodes[i]+1\nnodes = [x for x in nodes if x == 1]\nprint(sum*2/len(nodes))\n
def tle():\n    k=0\n    while (k>=0):\n        k+=1\ndef quad(a, b, c):\n    disc = (b**2-4*a*c)\n    if disc<0:\n        disc=0\n        \n    disc = (disc)**0.5\n    \n    return ((-b+disc)/2/a, (-b-disc)/2/a)\n\nx = int(input())\ny = list(map(float, input().strip().split(' ')))\nz = list(map(float, input().strip().split(' ')))\n\npy = [0, y[0]]\nfor i in range(1, x):\n    py.append(py[-1]+y[i])\nz.reverse()\npz = [0, z[0]]\nfor i in range(1, x):\n    pz.append(pz[-1]+z[i])\npz.reverse()\nk = []\nfor i in range(0, x+1):\n    k.append(py[i]+1-pz[i])\nl = [0]\nfor i in range(x):\n    l.append(k[i+1]-k[i])\n    #a[i]+b[i]\n\ns1 = 0\ns2 = 0\navals = []\nbvals = []\n\nfor i in range(1, x+1):\n    a, b = (quad(-1, s1+l[i]-s2, (s1+l[i])*s2-py[i]))\n    \n    if b<0 or l[i]-b<0:\n        a, b = b, a\n    if a<0 and b<0:\n        a=0\n        b=0\n    bvals.append(b)\n    avals.append(l[i]-b)\n    s1+=avals[-1]\n    s2+=bvals[-1]\n    \nfor i in range(len(avals)):\n\n    if abs(avals[i])<=10**(-10):\n        avals[i] = 0\n    if abs(bvals[i])<=10**(-10):\n        bvals[i] = 0\n        \nprint(' '.join([str(i) for i in avals]))\nprint(' '.join([str(i) for i in bvals]))
a = int(input())\nAns = []\nA = list(map(int, input().split()))\nfor i in range(a):\n    A[i] = [A[i], -i]\nA.sort()\nfor i in range(a):\n    A[i][1] = -A[i][1]\nfor i in range(int(input())):\n    n, m = map(int, input().split())\n    B = list(A[a - n:])\n    B.sort(key=lambda n: n[1])\n    Ans.append(B[m - 1][0])\nfor an in Ans:\n    print(an)
import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nclass RAQ_RMQ():\n    def __init__(self, n, inf=2**31-1):\n        self.n0 = 1<<(n-1).bit_length()\n        self.INF = inf\n        self.data = [0]*(2*self.n0)\n        self.lazy = [0]*(2*self.n0)\n\n    def getIndex(self, l, r):\n        l += self.n0; r += self.n0\n        lm = (l // (l & -l)) >> 1\n        rm = (r // (r & -r)) >> 1\n        while l < r:\n            if r <= rm:\n                yield r\n            if l <= lm:\n                yield l\n            l >>= 1; r >>= 1\n        while l:\n            yield l\n            l >>= 1\n\n    def propagates(self, *ids):\n        for i in reversed(ids):\n            v = self.lazy[i-1]\n            if not v:\n                continue\n            self.lazy[2*i-1] += v; self.lazy[2*i] += v\n            self.data[2*i-1] += v; self.data[2*i] += v\n            self.lazy[i-1] = 0\n\n    def update(self, l, r, x):\n        *ids, = self.getIndex(l, r)\n\n        l += self.n0; r += self.n0\n        while l < r:\n            if r & 1:\n                r -= 1\n                self.lazy[r-1] += x; self.data[r-1] += x\n            if l & 1:\n                self.lazy[l-1] += x; self.data[l-1] += x\n                l += 1\n            l >>= 1; r >>= 1\n        for i in ids:\n            self.data[i-1] = min(self.data[2*i-1], self.data[2*i]) + self.lazy[i-1]\n\n    def query(self, l, r):\n        self.propagates(*self.getIndex(l, r))\n        l += self.n0; r += self.n0\n\n        s = self.INF\n        while l < r:\n            if r & 1:\n                r -= 1\n                s = min(s, self.data[r-1])\n            if l & 1:\n                s = min(s, self.data[l-1])\n                l += 1\n            l >>= 1; r >>= 1\n        return s\n\nn,m,k = map(int, input().split())\nl = [0]*(n+1)\nnow = k\npoint = [0]*n\nfor i in range(n):\n    a,b,c = map(int, input().split())\n    point[i] = c\n    now = now-a\n    l[i] = now\n    now += b+a\nl[n] = now\n\nRMQ = RAQ_RMQ(n+1)\nfor i in range(n+1):\n    RMQ.update(i,i+1,l[i])\n\nportal = list(range(n))\nfor i in range(m):\n    u,v = map(int, input().split())\n    u,v = u-1, v-1\n    if portal[v]<u:\n        portal[v] = u\n\nif RMQ.query(0, n+1) < 0:\n    print(-1)\n    return\n\nheap = [(-point[i], -portal[i]) for i in range(n)]\nfrom heapq import heapify, heappop\nheapify(heap)\n\nans = 0\nwhile heap:\n    p,i = heappop(heap)\n    p,i = -p,-i\n    if RMQ.query(i+1, n+1)>0:\n        ans += p\n        RMQ.update(i+1, n+1, -1)\n\nprint(ans)
n, m = list(map(int, input().split()))\nprev_points = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    prev_points[v].append(u)\nk = int(input())\np = [int(pi) - 1 for pi in input().split()]\nbest_ways_d = [-1] * n\nbest_ways_nm1 = [0] * n\nq = [(p[-1], 0)]\nfor u, d in q:\n    if best_ways_d[u] < 0:\n        best_ways_d[u] = d\n        d += 1\n        for v in prev_points[u]:\n            q.append((v, d))\n    elif best_ways_d[u] == d:\n        best_ways_nm1[u] += 1\nans1 = ans2 = 0\nfor i in range(1, k):\n    u, v = p[i - 1], p[i]\n    if best_ways_d[u] <= best_ways_d[v]:\n        ans1 += 1\n        ans2 += 1\n    elif best_ways_nm1[u]:\n        ans2 += 1\nprint(ans1, ans2)\n
a=input().split()\nn=int(a[0])\nm=int(a[1])\n\np = []\nrnk = []\n\ndef init(s):\n    nonlocal p\n    nonlocal rnk\n    for i in range(0,s):\n        p.append(i)\n    rnk = [1]*s\n\ndef fs(v):\n    nonlocal p\n    if p[v]==v:\n        return v\n    ans = fs(p[v])\n    p[v]=ans\n    return ans\n\ndef us(a,b):\n    nonlocal p\n    nonlocal rnk\n    a=fs(a)\n    b=fs(b)\n    if a==b:\n        rnk[a]+=1\n        return\n    if rnk[a]>rnk[b]:\n        p[b]=a\n        rnk[a]+=rnk[b]\n    else:\n        p[a]=b\n        rnk[b]+=rnk[a]\n\ninit(n)\n\nfor i in range(0,m):\n    e=input().split()\n    us(int(e[0])-1,int(e[1])-1)\nD = {}\nfor i in range(0,n):\n    if D.get(fs(i))==None:\n        D[fs(i)]=1\n    else:\n        D[fs(i)]+=1\n\nans=0\n\nfor i in D:\n    if rnk[i]==D[i]:\n        ans+=1\nprint(ans)\n\n
n,x,y = map(int,input().split())\nl = 0\nr = 0\nu = 0\nd = 0\nfor i in range(n):\n	a,b = map(int,input().split())\n	if a < x:\n		l += 1\n	if a > x:\n		r += 1\n	if b < y:\n		d += 1\n	if b > y:\n		u += 1\nans = max([l,r,u,d])\nprint(ans)\nif ans == l:\n	print(x-1,y)\nelif ans == r:\n	print(x+1,y)\nelif ans == u:\n	print(x,y+1)\nelse:\n	print(x,y-1)							
n, m, sx, sy = list(map(int, input().split()))\n\nprint(sx, sy)\n\n# its row\nfor j in range(1, m+1):\n    if j != sy:\n        print(sx, j)\n\n# other rows\ncurr = m\nfor i in range(1, n+1):\n    if i != sx:\n        if curr == m:\n            for j in range(m, 0, -1):\n                print(i, j)\n                curr = 0\n        else:\n            for j in range(1, m+1):\n                print(i, j)\n                curr = m\n
n,m = map(int,input().split())\na = list(map(int,input().split()))\nb = [0]*(n+5)\nc = [0]*(m+5)\nc[0] = n\ncur = 0\nfor i in range(m):\n    c[b[a[i]]] -= 1\n    b[a[i]] += 1\n    c[b[a[i]]] += 1\n    if c[cur] == 0:\n        print(1,end='')\n        cur += 1\n    else:\n        print(0,end='')\n
# from bisect import bisect_left\n\n# (n) = (int(x) for x in input().split())\nn = int(input())\na = [int(_) - 1 for _ in input().split()]\n\nb = [0 for _ in a]\nfor id, v in enumerate(a):\n    b[v] = id\n\nans = []\nfor i in range(n):\n    pos = b[i]\n    target = i\n    old_v = a[target]\n    if pos == target:\n        continue\n\n    # do swap\n    b[old_v] = pos\n    b[i] = i\n    a[target] = i\n    a[pos] = old_v\n\n\n    if (abs(pos - target) * 2 >= n):\n        ans.append((pos, target))\n        continue\n    elif max(pos, target) < n // 2:\n        helper = n - 1\n        ans.append((pos, helper))\n        ans.append((target, helper))\n        ans.append((pos, helper))\n    elif min(pos, target) >= n // 2:\n        helper = 0\n        ans.append((pos, helper))\n        ans.append((target, helper))\n        ans.append((pos, helper))\n    else:\n        L = 0\n        R = n - 1\n        if pos > target:\n            (pos, target) = (target, pos)\n        ans.append((pos, R))\n        ans.append((L, R))\n        ans.append((L, target))\n        ans.append((L, R))\n        ans.append((pos, R))\n\nprint(len(ans))\nfor i in ans:\n    print(i[0] + 1, i[1] + 1)\n
'''input\n4\n1 5 2 5\n'''\nn = int(input())\na = list(map(int, input().split()))\nt = 0\nfor x in range(1, n-1):\n	if a[x] > a[x-1] and a[x] > a[x+1]:\n		t += 1\n	elif a[x] < a[x-1] and a[x] < a[x+1]:\n		t += 1\nprint(t)
"""\nCodeforces Contest 289 Div 2 Problem C\n\nAuthor  : chaotic_iak\nLanguage: Python 3.4.2\n"""\n\n################################################### SOLUTION\n\ndef printing(num):\n    arr = num[:]\n    while len(arr) > 1 and arr[-1] == 0: arr.pop()\n    print("".join(map(str, reversed(arr))))\n\ndef main():\n    n, = read()\n    last = [0]*500\n    for i in range(n):\n        b, = read()\n        last[0] += 1\n        p = 0\n        while last[p] == 10:\n            last[p] = 0\n            p += 1\n            last[p] += 1\n        p = 0\n        while sum(last) > b:\n            last[p] = 0\n            p += 1\n            k = p\n            last[k] += 1\n            while last[k] == 10:\n                last[k] = 0\n                k += 1\n                last[k] += 1\n        p = 0\n        while sum(last) < b:\n            while last[p] == 9: p += 1\n            last[p] += 1\n        printing(last)\n\n\n\n#################################################### HELPERS\n\n\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
import sys\n\nclass TreeNode:\n    def __init__(self, k, v):\n        self.key = k\n        self.value = v\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.height = 1\n        self.num_left = 1\n        self.num_total = 1\n\n\nclass AvlTree:\n\n    def __init__(self):\n        self._tree = None\n\n    def add(self, k, v):\n        if not self._tree:\n            self._tree = TreeNode(k, v)\n            return\n        node = self._add(k, v)\n        if node:\n            self._rebalance(node)\n\n    def _add(self, k, v):\n        node = self._tree\n        while node:\n            if k < node.key:\n                if node.left:\n                    node = node.left\n                else:\n                    node.left = TreeNode(k, v)\n                    node.left.parent = node\n                    return node.left\n            elif node.key < k:\n                if node.right:\n                    node = node.right\n                else:\n                    node.right = TreeNode(k, v)\n                    node.right.parent = node\n                    return node.right\n            else:\n                node.value = v\n                return\n\n    @staticmethod\n    def get_height(x):\n        return x.height if x else 0\n\n    @staticmethod\n    def get_num_total(x):\n        return x.num_total if x else 0\n\n    def _rebalance(self, node):\n\n        n = node\n        while n:\n            lh = self.get_height(n.left)\n            rh = self.get_height(n.right)\n            n.height = max(lh, rh) + 1\n            balance_factor = lh - rh\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n            n.num_left = 1 + self.get_num_total(n.left)\n\n            if balance_factor > 1:\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\n                    self._rotate_left(n.left)\n                self._rotate_right(n)\n            elif balance_factor < -1:\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\n                    self._rotate_right(n.right)\n                self._rotate_left(n)\n            else:\n                n = n.parent\n\n    def _remove_one(self, node):\n        """\n        Side effect!!! Changes node. Node should have exactly one child\n        """\n        replacement = node.left or node.right\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = replacement\n            else:\n                node.parent.right = replacement\n            replacement.parent = node.parent\n            node.parent = None\n        else:\n            self._tree = replacement\n            replacement.parent = None\n        node.left = None\n        node.right = None\n        node.parent = None\n        self._rebalance(replacement)\n\n    def _remove_leaf(self, node):\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = None\n            else:\n                node.parent.right = None\n            self._rebalance(node.parent)\n        else:\n            self._tree = None\n        node.parent = None\n        node.left = None\n        node.right = None\n\n    def remove(self, k):\n        node = self._get_node(k)\n        if not node:\n            return\n        if AvlTree._is_leaf(node):\n            self._remove_leaf(node)\n            return\n        if node.left and node.right:\n            nxt = AvlTree._get_next(node)\n            node.key = nxt.key\n            node.value = nxt.value\n            if self._is_leaf(nxt):\n                self._remove_leaf(nxt)\n            else:\n                self._remove_one(nxt)\n            self._rebalance(node)\n        else:\n            self._remove_one(node)\n\n    def get(self, k):\n        node = self._get_node(k)\n        return node.value if node else -1\n\n    def _get_node(self, k):\n        if not self._tree:\n            return None\n        node = self._tree\n        while node:\n            if k < node.key:\n                node = node.left\n            elif node.key < k:\n                node = node.right\n            else:\n                return node\n        return None\n\n    def get_at(self, pos):\n        x = pos + 1\n        node = self._tree\n        while node:\n            if x < node.num_left:\n                node = node.left\n            elif node.num_left < x:\n                x -= node.num_left\n                node = node.right\n            else:\n                return (node.key, node.value)\n        raise IndexError("Out of ranges")\n\n    @staticmethod\n    def _is_left(node):\n        return node.parent.left and node.parent.left == node\n\n    @staticmethod\n    def _is_leaf(node):\n        return node.left is None and node.right is None\n\n    def _rotate_right(self, node):\n        if not node.parent:\n            self._tree = node.left\n            node.left.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.left\n            node.left.parent = node.parent\n        else:\n            node.parent.right = node.left\n            node.left.parent = node.parent\n        bk = node.left.right\n        node.left.right = node\n        node.parent = node.left\n        node.left = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    def _rotate_left(self, node):\n        if not node.parent:\n            self._tree = node.right\n            node.right.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.right\n            node.right.parent = node.parent\n        else:\n            node.parent.right = node.right\n            node.right.parent = node.parent\n        bk = node.right.left\n        node.right.left = node\n        node.parent = node.right\n        node.right = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    @staticmethod\n    def _get_next(node):\n        if not node.right:\n            return node.parent\n        n = node.right\n        while n.left:\n            n = n.left\n        return n\n\n\ndef __starting_point():\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    aa = [(a, i) for i, a in enumerate(map(int, lines[1].split()))]\n    m = int(lines[2])\n    qs = [None]*m\n    ans = [None]*m\n    for i in range(m):\n        k, pos = list(map(int, lines[i+3].split()))\n        qs[i] = (pos, k, i)\n    qs.sort(key=lambda x: x[1])\n    aa.sort(key=lambda x: x[1])\n    aa.sort(key=lambda x: x[0], reverse=True)\n    avl = AvlTree()\n    s = 0\n    for pos, k, i in qs:\n        for a, j in aa[s: k]:\n            avl.add(j, a)\n        ans[i] = str(avl.get_at(pos - 1)[1])\n        s = k\n    print("\n".join(ans))\n\n\n__starting_point()
#!/usr/bin/env python3\n# 598D_Igor.py - Codeforces.com/problemset/problem/598/D by Sergey 2015\n\nimport unittest\nimport sys\nfrom collections import deque\n\n###############################################################################\n# Igor Class (Main Program)\n###############################################################################\n\n\ndef empty_around(i, rc, n, m, nw, mw):\n    w = 32\n    r = (i // m) // w\n    c = (i % m) // w\n    j = r * mw + c\n    if j < len(rc):\n        if rc[j] == 0:\n            rc[j] = 1\n            return True, r, c\n    return False, 0, 0\n\n\ndef fill_around(a, r0, c0, to_visit, visited, n, m):\n    w = 32\n    for r in range(w):\n        for c in range(w):\n            i = (r0 * w + r) * m + (c0 * w + c)\n            if (r == 0 or r == w - 1 or c == 0 or c == w - 1):\n                if a[i] == 0:\n                    to_visit.append(i)\n                    a[i] = 1\n            else:\n                a[i] = 2\n                visited.append(i)\n\n\nclass Igor:\n    """ Igor representation """\n\n    def __init__(self, test_inputs=None):\n        """ Default constructor """\n\n        it = iter(test_inputs.split("\n")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        self.result = []\n        w = 32\n        n, m, k = [int(x) for x in uinput().split()]\n        d0, d1, d2, d3 = -m, 2*m, -m-1, 2\n        a = []\n        rc = []\n        rr = []\n        mw = m // w\n        nw = n // w\n        for _ in range(n):\n            row = [(0 if v == '.' else 3) for v in uinput()]\n            a += row\n            rc += [sum(row[i*w:i*w+w]) for i in range(mw)]\n        for i in range(nw):\n            j = i*mw*w\n            rr += [sum([rc[j+u*mw+v] for u in range(w)]) for v in range(mw)]\n        to_visit = deque()\n        for _ in range(k):\n            x0, y0 = [int(x)-1 for x in uinput().split()]\n            i0 = x0*m+y0\n            step = 0\n            if a[i0] > 3:\n                self.result.append(a[i0])\n            else:\n                ans = 0\n                to_visit.append(i0)\n                visited = deque()\n                step += 1\n                while to_visit:\n                    i = to_visit.pop()\n                    if a[i] == 2:\n                        continue\n                    visited.append(i)\n                    if step % w == 1:\n                        e, r0, c0 = empty_around(i, rr, n, m, nw, mw)\n                    else:\n                        e = False\n                    a[i] = 2\n                    if e:\n                        fill_around(a, r0, c0, to_visit, visited, n, m)\n                    for d in (d0, d1, d2, d3):\n                        i += d\n                        if a[i] == 0:\n                            to_visit.append(i)\n                            a[i] = 1\n                        elif a[i] == 3:\n                            ans += 1\n                self.result.append(ans)\n                for i in visited:\n                    a[i] = ans\n\n    def calculate(self):\n        """ Main calcualtion function of the class """\n\n        return str("\n".join(map(str, self.result)))\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        """ Igor class testing """\n\n        # Constructor test\n        test = "5 6 3\n******\n*..*.*\n******\n*....*\n******\n2 2\n2 5\n4 3"\n        d = Igor(test)\n\n        # Sample test\n        self.assertEqual(Igor(test).calculate(), "6\n4\n10")\n\n        # Sample test\n        test = ""\n        # self.assertEqual(Igor(test).calculate(), "0")\n\n        # Sample test\n        test = ""\n        # self.assertEqual(Igor(test).calculate(), "0")\n\n        # My tests\n        test = ""\n        # self.assertEqual(Igor(test).calculate(), "0")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        """ Timelimit testing """\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + " " + str(nmax) + "\n"\n        numnums = [str(i) + " " + str(i+1) for i in range(nmax)]\n        test += "\n".join(numnums) + "\n"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += " ".join(map(str, nums)) + "\n"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Igor(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print(("\nTimelimit Test: " +\n              "{0:.3f}s (init {1:.3f}s calc {2:.3f}s)".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == "-ut":\n        unittest.main(argv=[" "])\n\n    # Print the result string\n    sys.stdout.write(Igor().calculate())\n\n__starting_point()
s = input()\npole = input()\nt = 0\ncount = 0\nfor i in range(len(pole)):\n    if pole[i] == s[t]:\n        t += 1\n    if t == len(s):\n        break\n    count += 1\nt -= 1\nfor i in range(len(pole) - 1, -1, -1):\n    if pole[i] == s[t]:\n        t -= 1\n    if t == -1:\n        count1 = i\n        break\nif count1 - count > 0:\n    print(count1 - count)\nelse:\n    print(0)
import sys\nimport io\n\nstream_enable = 0\n\ninpstream = """\n3 5\n3 7 9\n\n"""\n\nif stream_enable:\n    sys.stdin = io.StringIO(inpstream)\n    input()\n\ndef inpmap():\n    return list(map(int, input().split()))\n\nn, m = inpmap()\narr = inpmap()\ns = 0\nfor x in arr:\n    s += x\n    print(s // m, end=' ')\n    s %= m\nprint()\n
n = int(input())\nwords = input().split()[:n]\n\np_base = 1543\np_mod = 1300199\n\ncurrent = [c for c in words[0]]\nfor word in words[1:]:\n    cur_hash = 0\n    word_hash = 0\n    cur_base = 1\n    i_matches = []\n    same_i = 0\n    biggest_match = None\n    while same_i < len(current) and same_i < len(word):\n        cur_hash *= p_base\n        cur_hash %= p_mod\n        cur_hash += ord(current[len(current) - 1 - same_i])\n        cur_hash %= p_mod\n\n        word_hash += ord(word[same_i]) * cur_base\n        word_hash %= p_mod\n\n        cur_base *= p_base\n        cur_base %= p_mod\n\n        if cur_hash == word_hash:\n            i_matches.append(same_i)\n            #biggest_match = same_i\n\n        same_i += 1\n\n\n    for match in reversed(i_matches):\n        if ''.join(word[:match + 1]) == ''.join(current[-1 - match:]):\n            biggest_match = match\n            break\n\n    if biggest_match is None:\n        current.extend(list(word))\n    else:\n        current.extend(list(word[biggest_match + 1:]))\n\n\nprint(*current, sep='')\n\n\n\n
n = int(input())\na = list(map(int, input().split()))\ns = set()\nj = 0\ni = n\nwhile i != 0:\n	if a[j] == i:\n		print(i)\n		j += 1\n		i -= 1\n	else:\n		while j < n and a[j] != i:\n			s.add(a[j])\n			j += 1\n			print()\n		s.add(i)\n		while i > 0 and i in s:\n			print(i, end = ' ')\n			i -= 1\n\n
import sys\n\n# @profile\ndef main():\n    f = sys.stdin\n    # f = open('input.txt', 'r')\n    # fo = open('log.txt', 'w')\n    n = int(f.readline())\n    # b = []\n    # for i in range(n):\n    #    b.append()\n    b = list(map(int, f.readline().strip().split(' ')))\n    a = list(map(int, f.readline().strip().split(' ')))\n    # return\n    b = [b[i] - a[i] for i in range(n)]\n    c = [[0, 0]]\n    for i in range(n - 1):\n        line = f.readline().strip().split(' ')\n        c.append([int(line[0]), int(line[1])])\n    # print(c)\n    for i in range(n - 1, 0, -1):\n        # print(i)\n        fa = c[i][0] - 1\n        if b[i] >= 0:\n            b[fa] += b[i]\n        else:\n            b[fa] += b[i] * c[i][1]\n            if b[fa] < -1e17:\n                print('NO')\n                return 0\n    # for x in b:\n    #    fo.write(str(x) + '\n')\n    if b[0] >= 0:\n        print('YES')\n    else:\n        print('NO')\n\nmain()\n
from math import inf\nn=int(input())\n\na = input()\na= [int(i) for i in a.split()]\ns  =input()\ns  = [int(i) for i in s.split()]\nans  =  inf\nfor j in range(1 , n-1):\n    ll , lr = inf , inf\n    for q in range(j+1,n):\n        if a[j]<a[q]:\n            lr = min(lr , s[q])\n    for q in range(j):\n        if a[j]>a[q]:\n            ll = min(ll , s[q]) \n    ans= min(ans , ll+lr+s[j])\nif ans==inf:\n    print(-1)\nelse:\n    print(ans)\n
import sys\nn,m=list(map(int,sys.stdin.readline().split()))\nM=[m]\nA=list(map(int,sys.stdin.readline().split()))\nL=[0]*n\ninc=False\ndec=False\ndef ALLYes():\n    Ans=""\n    for i in range(M[0]):\n        Ans+="Yes\n"\n    sys.stdout.write(Ans)\n    return\nfor i in range(1,n):\n    if(A[i]>A[i-1]):\n        L[i]=1\n        inc=True\n    elif(A[i]==A[i-1]):\n        L[i]=0\n    else:\n        L[i]=-1\n        dec=True\nif(inc==False or dec==False):\n    ALLYes()\nelse:\n    neg=L.index(-1)\n    pos=L.index(1)\n    First=[-1]*n\n    for i in range(2,n):\n        if(L[i]==0):\n            x=max(neg,pos)\n            if(x<=i):\n                First[i]=x\n            elif(min(neg,pos)<=i):\n                First[i]=min(neg,pos)\n            else:\n                First[i]=-1\n        if(L[i]==1):\n            if(neg>i):\n                First[i]=-1\n            else:\n                First[i]=neg\n            pos=i\n        if(L[i]==-1):\n            if(pos>i):\n                First[i]=-1\n            else:\n                First[i]=pos\n            neg=i\n    Ans=""\n    for i in range(m):\n        l,r=list(map(int,sys.stdin.readline().split()))\n        r-=1\n        if(r-l<1):\n            Ans+="Yes\n"\n            continue\n        if(L[r]==0):\n            r=First[r]\n            if(r<1):\n                Ans+="Yes\n"\n                continue\n        if(L[r]==1):\n            r=First[r]\n            if(r<l):\n                Ans+="Yes\n"\n                continue\n            else:\n                Ans+="No\n"\n                continue\n        elif(L[r]==-1):\n            r=First[r]\n            if(r<l):\n                Ans+="Yes\n"\n                continue\n            r=First[r]\n            if(r<l):\n                Ans+="Yes\n"\n                continue\n            else:\n                Ans+="No\n"\n                continue\n    sys.stdout.write(Ans)\n    \n    \n
'''\nCreated on Oct 12, 2014\n\n@author: Ismael\n'''\n#import time\n\nfrom fractions import gcd\n\ndef checkSet(setK,newVal):\n    for v in setK:\n        if(gcd(v,newVal) != 1):\n            return False\n    return True\n\ndef solve(n,k):\n    j = 1\n    sets = []\n    for _ in range(n):\n        setK = set()\n        while(len(setK) < 4):\n            if(checkSet(setK,j) and not(len(setK) == 0 and j%3==0)):\n                setK.add(j)\n            j += 1\n        sets.append(setK)\n    maxV = 0\n    for setK in sets:\n        maxV = max(maxV,max(setK))\n    print(maxV*k)\n    for setK in sets:\n        print(' '.join([str(x*k) for x in setK]))\n    \n#t = time.clock()\nn,k = list(map(int,input().split()))\nsolve(n,k)\n#print(time.clock()-t)\n
from collections import defaultdict\n\nn, m, k = [int(x) for x in input().split()]\nc = [0] + [int(x) for x in input().split()]\ng = defaultdict(lambda: [])\nfor i in range(m):\n    l, r = [int(x) for x in input().split()]\n    g[l].append(r)\n    g[r].append(l)\ndone = [0] * (1 + n)\nans = 0\nfor i in range(n):\n    i += 1\n    if done[i]:\n        continue\n    q = [i]\n    p = 0\n    mn = set([i])\n    mcx = defaultdict(lambda: 0)\n    while p != len(q):\n        t = q[p]\n        p += 1\n        if done[t]:\n            continue\n        done[t] = 1\n        mcx[c[t]] += 1\n        mn.add(t)\n        for ne in g[t]:\n            q.append(ne)\n    fcol = None\n    maxn = -1\n    for col, num in list(mcx.items()):\n        if num >= maxn:\n            maxn = num\n            fcol = col\n    if fcol:\n        for ob in mn:\n            if c[ob] != fcol and len(g[ob]) > 0:\n                c[ob] = fcol\n                ans += 1\nprint(ans)\n
\nw, l = [int(i) for i in input().split(' ')]\narr = [int(i) for i in input().split(' ')]\n\ncummulative = [0 for i in range(len(arr) + 1)]\nfor i in range(len(arr)):\n    cummulative[i+1] = cummulative[i] + arr[i]\n\nmin_cut = 1000000009\n\nfor i in range(w - l):\n    cut = cummulative[i + l] - cummulative[i]\n    if cut < min_cut:\n        min_cut = cut\n\nprint(min_cut)\n
from bisect import bisect_left\nn = int(input())\na = list(map(int, input().split()))\nm = int(input())\nb = list(map(int, input().split()))\n\nsum_a, sum_b = sum(a), sum(b)\ndelta = sum_b - sum_a\nans = abs(delta)\nans_swap = []\n\nfor i in range(n):\n    for j in range(m):\n        if abs((sum_a - a[i] + b[j]) - (sum_b + a[i] - b[j])) < ans:\n            ans = abs((sum_a - a[i] + b[j]) - (sum_b + a[i] - b[j]))\n            ans_swap = [(i+1, j+1)]\n\nd = dict()\nfor i in range(m):\n    for j in range(i+1, m):\n        d[b[i]+b[j]] = (i+1, j+1)\n\nminf, inf = -10**13, 10**13\nval = [minf, minf] + sorted(d.keys()) + [inf, inf]\n\nfor i in range(n):\n    for j in range(i+1, n):\n        ap = a[i] + a[j]\n        req = (delta + ap*2) >> 1\n        k = bisect_left(val, req)\n\n        for k in range(k-1, k+2):\n            if abs(delta + ap*2 - val[k]*2) < ans:\n                ans = abs(delta + ap*2 - val[k]*2)\n                ans_swap = [(i+1, d[val[k]][0]), (j+1, d[val[k]][1])]\n\nprint(ans)\nprint(len(ans_swap))\nfor x, y in ans_swap:\n    print(x, y)\n
t = int(input())\nfor _ in range(t):\n    a, b = list(map(int, input().split()))\n    print(min((a+b)//3,a,b))\n
import sys\n\ninput = sys.stdin.readline\n\n############ ---- Input Functions ---- ############\ndef inp():\n    return (int(input()))\ndef instr():\n    return (str(input()))\ndef inlt():\n    return (list(map(int, input().split())))\ndef insr():\n    s = input()\n    return(list(map(int, list(s[:len(s) - 1]))))\n# def insr():\n#     s = input()\n#     return list(s[:len(s) - 1])\ndef invr():\n    return (list(map(int, input().split())))\n\n\nfrom collections import Counter\n\ndef check(cities, stations, k, allow):\n    # cities = cities.copy()\n    n = len(cities)\n    k = min(cities[0], k)\n    last_st = stations[-1] - k\n    c_i = cities[0] - k\n    for i in range(n - 1):\n        d = stations[i] - (c_i + cities[i + 1])\n        if d > 0:\n            # cities[i + 1] = 0\n            c_i = 0\n            allow -= d\n            if allow < 0:\n                return 1\n        elif stations[i] < c_i:\n            return -1\n        else:\n            c_i = cities[i + 1] - (stations[i] - c_i)\n    if c_i > last_st:\n        return -1\n    return 0\n\n\ndef bin_search(cities, stations, allow, l, r):\n    while l <= r:\n        mid = l + (r - l) // 2\n        res = check(cities, stations, mid, allow)\n        if res == 0:\n            return mid\n        elif res == -1:\n            l = mid + 1\n        else:\n            r = mid - 1\n    return -1\n\n\ndef main():\n    t = inp()\n    for _ in range(t):\n        n = inp()\n        cities = inlt()\n        stations = inlt()\n        allow = sum(stations) - sum(cities)\n        if allow < 0:\n            print('NO')\n        else:\n            res = bin_search(cities, stations, allow, 0, stations[-1] + 1)\n            if res == -1:\n                print('NO')\n            else:\n                print('YES')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
import sys\nfrom copy import copy\n\ninput = sys.stdin.readline\n\nn = int(input())\nl = [int(a) for a in input().split()]\nx = []\nfor i in range(0, 20):\n    res = 0\n    for a in l:\n        if a & (1 << i):\n            res += 1\n    x.append(res)\n\nres = 0\nfor i in range(n):\n    a = 0\n    for j in range(20):\n        if i < x[j]:\n            a += (1 << j)\n    res += a ** 2\nprint(res)
n = int(input())\n\nmas = list(map(int, input().split()))\n\ndist = set([0])\nres = 1\nfor i, e in enumerate(mas):\n    time = i + 1\n    if e in dist:\n        dist.remove(e)\n    else:\n        res += 1\n    dist.add(time)\nprint(res)
#!/usr/bin/env python3\n\na = input()\nb = input()\n\nsumi = 0\n\nfor i in range(len(b) - len(a) + 1):\n    if b[i] == '1':\n        sumi += 1\n\nlowest = 0\nhighest = len(b) - len(a) + 1\n\ntotal = 0\nfor i in range(len(a)):\n    if a[i] == '0':\n        total += sumi\n    else:\n        total += highest - lowest - sumi\n    if b[lowest] == '1':\n        sumi -= 1\n    if highest < len(b) and b[highest] == '1':\n        sumi += 1\n    lowest += 1\n    highest += 1\nprint(total)\n
n = int(input())\nnums = [int(x) for x in input().split()]\nans = 10 ** 12\nfor idx, num in enumerate(nums):\n    dist = max(idx, n - idx - 1)\n    curr = num // dist\n    ans = min(ans, curr)\nprint(ans)
n=int(input())\nfor i in range(n):\n    x=int(input())\n    f=0\n    for a in range(100):\n        for b in range(100):\n            if 3*a+7*b==x:\n                f=1\n    if f==1:\n        print("YES")\n    else:\n        print("NO")
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time\n\nsys.setrecursionlimit(10**7)\ninf = 10**10\nmod = 10**9 + 7\n\ndef f():\n    n,m,k = list(map(int, input().split()))\n    a = [[inf]*(m+2)]\n    g = []\n    for _ in range(n):\n        a.append([inf] + [_ for _ in input()] + [inf])\n        g.append([False]*m)\n    a.append([[inf]*(m+2)])\n\n    c = 0\n    for i in range(1,n+1):\n        if a[i][1] == '.':\n            a[i][1] = -1\n        if a[i][-2] == '.':\n            a[i][-2] = -1\n    for j in range(1,m+1):\n        if a[1][j] == '.':\n            a[1][j] = -1\n        if a[-2][j] == '.':\n            a[-2][j] = -1\n\n    def ff(n1,n2):\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                if a[i][j] == n1:\n                    a[i][j] = n2\n    ff('*', inf)\n\n    for i in range(1,n+1):\n        for j in range(1,m+1):\n            if a[i][j] == '.':\n                mc = [inf]\n                if a[i-1][j] != '.': mc.append(a[i-1][j])\n                if a[i+1][j] != '.': mc.append(a[i+1][j])\n                if a[i][j+1] != '.': mc.append(a[i][j+1])\n                if a[i][j-1] != '.': mc.append(a[i][j-1])\n                mm = min(mc)\n                if mm < inf:\n                    a[i][j] = mm\n                    for t in [_ for _ in mc if _ < inf and _ != mm]:\n                        ff(t,mm)\n                else:\n                    a[i][j] = c\n                    c += 1\n    cnt = [0] * c\n    for i in range(1,n+1):\n        for j in range(1,m+1):\n            if -1 < a[i][j] < c:\n                cnt[a[i][j]] += 1\n    cnt2 = [_ for _ in cnt if _ > 0]\n    r = 0\n    for _i in range(len(cnt2) - k):\n        cnt2 = [_ for _ in cnt if _ > 0]\n        mm = min(cnt2)\n        ind = cnt.index(mm)\n        cnt[ind] = 0\n        r += mm\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                if a[i][j] == ind:\n                    a[i][j] = '*'\n\n    print(r)\n\n    for i in range(1,n+1):\n        s = ''\n        for j in range(1,m+1):\n            c = a[i][j]\n            if c == '*':\n                s += c\n            elif c == inf:\n                s += '*'\n            else:\n                s += '.'\n        print(s)\n\nf()\n
def main():\n    input()\n    l = list(map(int, input().split()))\n    n = max(l)\n    aa = [0] * (n + 1)\n    for x in l:\n        aa[x] += 1\n    f, x = [0] * n, 0\n    for a in reversed(aa):\n        x += a\n        f.append(x)\n    f.reverse()\n    res = []\n    for i, a in enumerate(aa):\n        if a:\n            tot, a = 0, f[i]\n            for j in range(i, n + 1, i):\n                b = f[j + i]\n                tot += (a - b) * j\n                a = b\n            res.append(tot)\n    print(max(res))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
def main():\n    from collections import defaultdict\n    def f(x):\n        inc = [0 for i in range(n + w)]\n        cur_inc = 0\n        days = m\n        for i, v in enumerate(arr):\n            cur_inc -= inc[i]\n            v += cur_inc\n            if x - v > days:\n                return False\n            if x > v:\n                cur_inc += x - v\n                days -= x - v\n                inc[i + w] += x - v\n        return True\n    \n    \n    n, m, w = [int(i) for i in input().split()]\n    arr = [int(i) for i in input().split()]\n    \n    left, right = min(arr), max(arr) + m + 1\n    while right - left > 1:\n        middle = (left + right) // 2\n        if f(middle):\n            left = middle\n        else:\n            right = middle\n    \n    print(left)\n\n\nmain()\n
n = int(input());\nif (n % 2 != 0):\n        s = '7';\n        n -= 3;\nelse:\n    s = '1';\n    n-=2;\nfor i in range(n // 2): s = s + '1';\nprint(s);\n
n, m = map(int, input().split())\nadj = [[] for _ in range(n)]\ncp = [-1] * n\n\nfor i in range(m):\n    p, c = map(int, input().split())\n    adj[p - 1].append(c - 1)\n    cp[c - 1] = p - 1\n\npres = [i - 1 for i in map(int, input().split())]\n\nlevel = [0] * n\nfrom collections import deque\ndef bfs(v):\n    q = deque([v])\n    while q:\n        v = q.pop()\n        if cp[v] >= 0:\n            level[v] = level[cp[v]] + 1\n        for nv in adj[v]:\n            q.append(nv)\n\nfor i in range(n):\n    if cp[i] == -1:\n        bfs(i)\n\nfor i in range(n):\n    if level[i] > 0:\n        par = cp[i]\n        if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n            print(-1)\n            return\n\npres = list(set(pres))\npres = sorted(pres, key = lambda i : level[i], reverse = True)\n\nprint(len(pres))\npres = [i + 1 for i in pres]\nprint("\n".join(map(str, pres)))
from collections import Counter\nimport string\n\ndef valid(o):\n    for x, y in zip(o, o[1:]):\n        if abs(ord(x) - ord(y)) == 1:\n            return False\n\n    return True\n\ndef create(c, o):\n    res = []\n    for x in o:\n        for j in range(c[x]):\n            res.append(x)\n    return res\n\nT = int(input())\nfor _ in range(T):\n    c = Counter(input())\n    o = []\n    o1 = string.ascii_lowercase[1::2] + string.ascii_lowercase[::2]\n    o2 = string.ascii_lowercase[::2] + string.ascii_lowercase[1::2]\n\n    s1 = create(c, o1)\n    s2 = create(c, o2)\n\n    if valid(s1):\n        print(''.join(s1))\n    elif valid(s2):\n        print(''.join(s2))\n    else:\n        print('No answer')\n
# -*- coding:utf-8 -*-\n\n"""\n\ncreated by shuangquan.huang at 11/20/18\n\n"""\nimport collections\nimport bisect\n\nN, M = map(int, input().split())\nvlines = []\nfor i in range(N):\n    x = int(input())\n    vlines.append(x)\n\nvlines.sort()\nvlines.append(10**9)\n\nyxs = collections.defaultdict(list)\nys = set()\nfor i in range(M):\n    l, r, y = map(int, input().split())\n    yxs[y].append((l, r))\n    if l <= 1:\n        ys.add(y)\n\n\ndef merge(segs):\n    segs.sort()\n    ans = [segs[0]]\n    for s in segs[1:]:\n        pre = ans[-1]\n        if s[0] > pre[1]:\n            # ans.append(s)\n            return ans[0]\n        else:\n            ans[-1] = (pre[0], s[1])\n    \n    return ans[0]\n\n\nxs = [merge(yxs[y])[1] for y in ys]\nxs.sort()\n\nans = float('inf')\nfor i, x in enumerate(vlines):\n    if i >= ans:\n        break\n    # count = i + sum([1 if u >= x else 0 for u in xs])\n    count = i + len(xs) - bisect.bisect_left(xs, x)\n    ans = min(ans, count)\n\nprint(ans)
import sys\n\ndef main():\n    mx = 1\n    n = int(input())\n    D = {}\n    D["polycarp"] = 1\n    for i in range(n):\n        s, r, t = input().split()\n        s = s.lower()\n        t = t.lower()\n        D[s] = D[t] + 1\n        mx = max(mx, D[s])\n    print(mx)\n\nmain()
def main():\n    from sys import stdin\n    n, m = list(map(int, input().split()))\n    n += 1\n    aa, pos, duo = [0] * n, [0] * n, [0] * n\n    for i, a in enumerate(map(int, input().split()), 1):\n        aa[i] = a\n        pos[a] = i\n    for s in stdin.read().splitlines():\n        x, y = list(map(int, s.split()))\n        px, py = pos[x], pos[y]\n        if px > py:\n            if duo[x] < py:\n                duo[x] = py\n        else:\n            if duo[y] < px:\n                duo[y] = px\n    res = mx = 0\n    for i, a in enumerate(aa):\n        if mx < duo[a]:\n            mx = duo[a]\n        res += i - mx\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
from collections import defaultdict\n\nl = list(map(int, input().split()))\nst = input()\ns = [(ord(i) - ord('a')) for i in st]\ntrack = [defaultdict(lambda: 0) for i in range(26)]\nres = 0\ns = [0] + s\npre = [0 for i in range(len(s))]\nfor i in range(1, len(s)):\n	pre[i] = pre[i-1] + l[s[i]]\nfor i in range(1, len(s)):\n	res += track[s[i]][pre[i-1]]\n	track[s[i]][pre[i]] += 1\nprint(res)
n = int(input())\n\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ndef f(l):\n    s = sum(l)\n    sume = [s for i in range(n)]\n    s3 = [0 for i in range(n)]\n    ts = 0\n    for i in range(1, n):\n        sume[i] = sume[i - 1] - l[i - 1]\n        ts += i * l[i]\n        s3[n - i - 1] = s3[n - i] + i * l[n - i - 1]\n    s2 = [ts for i in range(n)]\n    for i in range(1, n):\n        s2[i] = s2[i - 1] - (i - 1) * l[i - 1]\n    return sume, s2, s3\n\na1, a2, a3 = f(a)\nb1, b2, b3 = f(b)\n\nbest = 0\ncurr, t = 0, 0\nfor i in range(n):\n    if i % 2 == 0:\n        pot = curr + t * a1[i] + a2[i] - i * a1[i] +\\n                (t + n - i) * b1[i] + b3[i]\n    else:\n        pot = curr + t * b1[i] + b2[i] - i * b1[i] +\\n                (t + n - i) * a1[i] + a3[i]\n    best = max(best, pot)\n    if i % 2 == 0:\n        curr += t * a[i] + (t + 1) * b[i]\n    else:\n        curr += t * b[i] + (t + 1) * a[i]\n    t += 2\nprint(max(best, curr))\n
n = int(input())\nxs = list(map(int, input().split()))\nvs = list(map(int, input().split()))\n\nl = 0\nr = max(xs) - min(xs) + 1\nfor i in range(50):\n    m = (r + l) / 2\n    lev = 0\n    prav = 1000000000\n    for j in range(n):\n        prav = min(prav, xs[j] + vs[j] * m)\n        lev = max(lev, xs[j] - vs[j] * m)\n        if prav < lev:\n            break\n    if prav < lev:\n        l = m\n    else:\n        r = m\nprint((l + r) / 2)
# You lost the game.\nn = int(input())\nA = list(map(int, input().split()))\n\nV = [0 for _ in range(n)]\nG = V[:]\n\ndef visiter(i,d):\n    nonlocal V\n    nonlocal G\n    G[i] = d+1\n    V[i] = d+1\n    c = d+2\n    while 1:\n        if V[A[i]-1] and G[A[i]-1] > d:\n            return 1,c-G[A[i]-1],G[A[i]-1]-1-d,c\n        elif V[A[i]-1]:\n            return 0,0,c-1-d,c\n        else: \n            G[A[i]-1] = c\n            c += 1\n            V[A[i]-1] = 1\n            i = A[i]-1\n\n\n\nT = [1 for _ in range(n+1)]\nfor i in range(1,n+1):\n    T[i] = (T[i-1]*2) % (10**9 + 7)\n\nR = []\nd = 0\ni = 0\nc = 0\nfor i in range(n):\n    if V[i] == 0:\n        v,l,s,c = visiter(i,c)\n        if v:\n            R += [l]\n        d += s\n        \nr = T[d]\nfor x in R:\n    r = (r*(T[x]-2)) % (10**9 + 7)\nprint(r)\n
q=list(map(int,input().split()))\na=[]\ns=[]\nfor i in range(0,q[0]):\n    s+=[min(list(map(int,input().split())))]\nprint(max(s))\n
n, m = list(map(int, input().split()))\ns = input()\nmod = 10 ** 9 + 7\nc = b = 0\nfor x in s:\n    c += (x == '(') * 2 - 1\n    b = min(c, b)\nd = [[1]]\nfor i in range(n - m):\n    nd = d[-1][1:] + [0] * 2\n    for j in range(1, i + 2):\n        nd[j] = (nd[j] + d[-1][j-1]) % mod\n    d.append(nd)\nans = 0\nfor i in range(n - m + 1):\n    l = n - m - i\n    for j in range(-b, min(l - c, i) + 1):\n        ans = (ans + d[i][j] * d[l][j + c]) % mod\nprint(ans)\n
# Contest: Codeforces Round #593 (Div. 2) (https://codeforces.com/contest/1236)\n# Problem: A: Stones (https://codeforces.com/contest/1236/problem/A)\n\ndef rint():\n    return int(input())\n\n\ndef rints():\n    return list(map(int, input().split()))\n\n\nt = rint()\nfor _ in range(t):\n    a, b, c, = rints()\n    mx = 0\n    for ta in range(0, min(a, b // 2) + 1):\n        mx = max(mx, 3 * ta + 3 * min(b - 2 * ta, c // 2))\n    print(mx)\n
from sys import stdin, stdout\nimport os,sys,__pypy__\n\ndef main():\n    #t = int(stdin.readline())\n    n,m = list(map(int, stdin.readline().split()))\n    tree = [list() for _ in range(n+1)]\n    mn = [0] * (n+1)\n    for _ in range(m):\n        a,b = list(map(int, stdin.readline().split()))\n        tree[a].append(b)\n        tree[b].append(a)\n    stacks = [list() for _ in range(n+1)]\n    arr = list(map(int, stdin.readline().split()))\n    for i,x in enumerate(arr):\n        stacks[x].append(i+1)\n        \n    is_can = True\n    ans = __pypy__.builders.StringBuilder()\n    cnt = 0\n    for i,stack in enumerate(stacks):\n        for x in stack:\n            if mn[x] + 1 == i:\n                ans.append("%d "%(x))\n                cnt += 1\n                for near in tree[x]:\n                    if mn[near] +1 == i:\n                        mn[near] += 1\n            else:\n                is_can = False\n                break\n        if not is_can:\n            break\n    if not is_can  or cnt != n:\n        stdout.write("-1\n")\n    else:\n        os.write(1,ans.build().encode())\n        \nmain()
#!/usr/bin/env python3\n\nimport sys\ninput=sys.stdin.readline\n\nclass BIT:\n  def __init__(self,n):\n    self.n=n+1\n    self.BIT=[0]*self.n\n  def add(self,i,x):\n    idx=i\n    while idx<self.n:\n      self.BIT[idx]+=x\n      idx+=(idx&-idx)\n  def _sum(self,i):\n    if i==-1:\n        return -1\n    ret=0\n    idx=i\n    while idx>0:\n      ret+=self.BIT[idx]\n      idx-=(idx&-idx)\n    return ret\n  def sum(self,l,r):\n    return self._sum(r)-self._sum(l-1)\n  def value(self,i):\n    return self._sum(i)-self._sum(i-1)\n\nbound=10**6\nn,m=map(int,input().split())\nyoko_edges=[list(map(int,input().split())) for _ in range(n)]\nyoko_edges=sorted(yoko_edges,reverse=True,key=lambda x:x[0])\nue_tate_edges=[[] for _ in range(bound+1)]\nsita_tate_edges=[[] for _ in range(bound+1)]\ntate_edges=BIT(bound)\ntate_edges.add(bound,1)\nans=1\nfor _ in range(m):\n    x,l,r=map(int,input().split())\n    if l==0 and r==bound:\n        tate_edges.add(x,1)\n        ans+=1\n    elif l==0:\n        sita_tate_edges[r].append(x)\n    elif r==bound:\n        ue_tate_edges[l].append(x)\n        tate_edges.add(x,1)\nprev=bound-1\nfor y,l,r in yoko_edges:\n    while prev>=y:\n        for x in sita_tate_edges[prev]:\n            tate_edges.add(x,1)\n        for x in ue_tate_edges[prev+1]:\n            tate_edges.add(x,-1)\n        prev-=1\n    ans+=tate_edges.sum(l,r)-1\nprint(ans)
from collections import deque\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = input()\n    b = []\n    for i in range(n):\n        b.append([a[i], i + 1])\n    b.sort()\n    ans = []\n    count1, count2 = 0, 0\n    c = deque([])\n    for i in range(2 * n):\n        if (s[i] == '0'):\n            ans.append(b[count1][1])\n            c.append(b[count1][1])\n            count1 += 1\n        else:\n            ans.append(c[-1])\n            c.pop()\n            count2 += 1\n    for i in range(2 * n):\n        print(ans[i], end=' ')\nmain()
#! /usr/bin/env python\n\n# http://codeforces.com/problemset/problem/818/F\n# Problem name ::: F. Level Generation\n# submission number\n\n#212055293\n#508427854\n\n\ndef newest_approach(n):\n    from math import floor, ceil, sqrt\n\n    quad_solv = sqrt(2*n+1/4)-1/2\n    x = floor(quad_solv)\n    y = ceil(quad_solv)\n\n    xed = int(x*(x-1)/2 + n - x)\n    xbr = n - x\n\n    ybr = n - y\n    yed = 2*ybr\n\n    if xed > yed:\n        print(xed)\n        # print("nodes = %s :: edges = %s :: bridges = %s" % (n, xed, xbr))\n    else:\n        print(yed)\n        # print("nodes = %s :: edges = %s :: bridges = %s" % (n, yed, ybr))\n\n    return\n\n\n\ndef main():\n\n    import sys\n\n    data = [line.rstrip() for line in sys.stdin.readlines()]\n    num_graphs = data[0]\n    graph_sizes = [int(x) for x in data[1:]]\n\n    for val in graph_sizes:\n        # binary_search(val)\n        # new_approach(val)\n        newest_approach(val)\n\n\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
\n#taken from https://stackoverflow.com/questions/30698441/optimal-way-to-find-sums-of-all-contiguous-sub-arrays-max-difference\ndef max_sums(d):\n    stack = [(-1, float('inf'))]\n    sum_ = 0\n    for i, x in enumerate(d):\n        while x > stack[-1][1]:\n            prev_i, prev_x = stack.pop()\n            prev_prev_i, prev_prev_x = stack[-1]\n            sum_ += prev_x * (i - prev_i) * (prev_i - prev_prev_i)\n        stack.append((i, x))\n    while len(stack) > 1:\n        prev_i, prev_x = stack.pop()\n        prev_prev_i, prev_prev_x = stack[-1]\n        sum_ += prev_x * (len(d) - prev_i) * (prev_i - prev_prev_i)\n    return sum_\n\ndef max_differences_sum(d):\n    return max_sums(d) + max_sums([-x for x in d])\n\nn=int(input())\nl=list(map(int,input().split()))\nprint(max_differences_sum(l))
n, m = map(int, input().split())\np, c = list(range(n + 1)), [1] * (n + 1)\nv = [0] + list(map(int, input().split()))\ns, e = 0, [()] * m\nfor i in range(m):\n    x, y = map(int, input().split())\n    e[i] = (x, y, min(v[x], v[y]))\ne.sort(key = lambda x: x[2], reverse = True)\nq = [[i] for i in range(n + 1)]\nfor l, r, v in e:\n    l, r = p[l], p[r]\n    if l == r: continue\n    if len(q[l]) > len(q[r]): l, r = r, l\n    q[r].extend(q[l])\n    for t in q[l]: p[t] = r\n    s += c[l] * c[r] * v\n    c[r] += c[l]\nprint(s * 2 / (n * (n - 1)))
def main():\n    s = input().split()\n    n,T,c = int(s[0]), int(s[1]), float(s[2])\n    a = list(map(int, input().split()))\n    m = int(input())\n    q = list(map(int, input().split()))\n    sumA, approx, mean = [0], [],  0.\n    for i in range(1, n+1):\n        mean = (mean+a[i-1]/T)/c\n        approx.append(mean)\n        sumA.append(a[i-1] + sumA[i-1])\n    ans = [(sumA[q[i]]-sumA[q[i]-T])/T for i in range(m)]\n    for i in range(m):\n        print('%.6f' % ans[i], '%.6f' % approx[q[i]-1], '%.6f' % (abs(approx[q[i]-1]- ans[i])/ans[i]))        \ndef __starting_point():\n    main()\n\n__starting_point()
import sys\n\nn_k = [int(x) for x in sys.stdin.readline().split()]\nk = n_k[1]\na = [int(x) for x in sys.stdin.readline().split()]\n\n# sum of k smallest numbers\na = sorted(a)\nk_smallest = sum(a[:k])\n\nprint(k_smallest)\n
n = int(input())\nl = list(map(int, input().split()))\n\n\nbest = 0\nfor i in range(n):\n    for j in range(i, n):\n        for k in range(j, n):\n            best = max(best, l[i] | l[j] | l[k])\nprint(best)\n            \n
n = int(input())\na = [int(i) for i in input().split()]\ns, f = [int(i) for i in input().split()]\na = a + a\nln = f - s\nans = sum(a[:ln])\nmx = ans\nh = s\nfor i in range(n - 1):\n    ans = ans - a[i] + a[i + ln]\n    if ans > mx:\n        ans = mx\n        k = s + (n - (i + 2) + 1)\n        if k > n:\n            k -= n  \n        h = k\n    elif ans == mx:\n        k = s + (n - (i + 2) + 1)\n        if k > n:\n            k -= n    \n        h = min(h, k)\nprint(h)\n
A,B,C=map(int,input().split())\nmod=998244353\nans=A*(A+1)*B*(B+1)*C*(C+1)//8\nprint(ans%mod)
\n# encoding:UTF-8\n# Filename:Base.py\n\nimport sys\nimport random\nimport copy\nfrom itertools import permutations, combinations\nfrom math import sqrt, fabs, ceil\nfrom collections import namedtuple\n\n# ------Util Const--------\n\nin_file_path = "input.txt"\noutput_file_path = "output.txt"\n\nSUBMIT = True\n\n\ndef get_array(x, initial=None):\n    dimension = len(x)\n    if dimension == 1:\n        return [copy.deepcopy(initial) for _ in range(x[0])]\n    else:\n        return [get_array(x[1:], initial) for _ in range(x[0])]\n\n\ndef read_num(fin, num_type=int):\n    tmp_list = [num_type(x) for x in fin.readline().strip().split()]\n    if len(tmp_list) == 1:\n        return tmp_list[0]\n    else:\n        return tuple(tmp_list)\n\ndef read_num_list(fin, num_type=int):\n    return [num_type(x) for x in fin.readline().strip().split()]\n\n\n# def solve(fin):\n#     n = read_num(fin)\n#     ans_set = None\n#     for i in range(n):\n#         tmp_list = read_num_list(fin)\n#         if ans_set == None:\n#             ans_set = set(tmp_list[1:])\n#         else:\n#             ans_set &= set(tmp_list[1:])\n#\n#     print(' '.join([str(x) for x in ans_set]))\n\n# def solve(fin):\n#     n, m = read_num(fin)\n#     a = [0] * m\n#     b = [0] * int(sqrt(n))\n#     for i in range(1, n + 1):\n#         a[i * i % m] += 1\n#\n#     ans = 0\n#     for x in range(m):\n#         y = (m - x) % m\n#         ans += a[x] * a[y]\n#     print(ans)\n\n# def BFS_count(x, chs, count):\n#     q = []\n#     q.append(x)\n#     while (q)\n#     return count[x]\n\ndef solve(fin):\n    n = read_num(fin)\n    f = read_num_list(fin)\n    new_f = [0] + f\n    for i in range(0, n):\n        new_f[i] -= 1\n    f = new_f\n    # print(f)\n    chs = get_array([n], [])\n    for i, p in enumerate(f):\n        if p >= 0:\n            chs[p].append(i)\n    # print(chs)\n    q = [x for x in range(0, n) if not chs[x]]\n    vis = [0] * n\n    count = [0] * n\n    while q:\n        x = q.pop(0)\n        if not chs[x]:\n            count[x] = 1\n        if f[x] >= 0:\n            vis[f[x]] += 1\n            # print(vis[f[x]], len(chs[f[x]]))\n            if vis[f[x]] == len(chs[f[x]]):\n                q.append(f[x])\n            count[f[x]] += count[x]\n\n\n    # print(chs)\n    count = sorted(count)\n    print(' '.join([str(x) for x in count]))\n\ndef __starting_point():\n    if SUBMIT:\n        solve(sys.stdin)\n    else:\n        solve(open(in_file_path, 'r'))\n\n__starting_point()
import sys\nimport heapq\n\nnnode,nedge,source,dest=list(map(int,sys.stdin.readline().split()))\nsource-=1;dest-=1\nadjl=[[] for _ in range(nnode)]\n\nfor _ in range(nedge):\n	u,v=list(map(int,sys.stdin.readline().split()))\n	u-=1;v-=1\n	adjl[u].append(v)\n	adjl[v].append(u)\n\n# why not BFS? >.<\ndef dijkstra_from(source):\n	pq=[]\n	dist=[10**9]*nnode\n\n	dist[source]=0\n	heapq.heappush(pq,(dist[source],source))\n	while pq:\n		dist_node,node=heapq.heappop(pq)\n		if dist[node]!=dist_node: continue\n\n		for adj in adjl[node]:\n			if dist[adj]>dist_node+1:\n				dist[adj]=dist_node+1\n				heapq.heappush(pq,(dist[adj],adj))\n\n	return dist\n\nd_src=dijkstra_from(source)\nd_dst=dijkstra_from(dest)\n\nassert d_dst[source] == d_src[dest]\n\nans=0\nfor u in range(nnode):\n	adj_to_u=[False]*u\n	for v in adjl[u]:\n		if v<u:\n			adj_to_u[v]=True\n	for v in range(u):\n		if not adj_to_u[v]:\n			if min(\n			d_dst[u]+d_src[v]+1,\n			d_src[u]+d_dst[v]+1\n			)<d_src[dest]: continue\n			ans+=1\n\nprint(ans)\n
import heapq\n\nn,k=list(map(int,input().split()))\nS=[list(map(int,input().split())) for i in range(n)]\n\nS.sort(key=lambda x:x[1],reverse=True)\n\nANS=0\nLENGTH=0\nH=[]\n\nfor x,y in S:\n    heapq.heappush(H,x)\n    LENGTH+=x\n    if len(H)>k:\n        z=heapq.heappop(H)\n        LENGTH-=z\n        \n    if ANS<LENGTH*y:\n        ANS=LENGTH*y\n\nprint(ANS)\n
def main():\n    import sys\n    input = sys.stdin.readline\n\n    # 偶数長含めた回文の長さを求める\n    # R[2*i] = L: S[i]を中心とする奇数長の最大回文\n    # R[2*i+1] = L: S[i:i+2]を中心とする偶数長の最大回文\n    # ダミー文字を挟むが、各 R[i] は実際の回文の文字列長と一致する\n    def manacher(S):\n        C = []\n        for a in S:\n            C.append(a)\n            C.append(0)\n        C.pop()\n\n        L = len(C)\n\n        R = [0] * L\n\n        i = j = 0\n        while i < L:\n            while j <= i < L - j and C[i - j] == C[i + j]:\n                j += 1\n            R[i] = j\n            k = 1\n            while j - R[i - k] > k <= i < L - k:\n                R[i + k] = R[i - k]\n                k += 1\n            i += k\n            j -= k\n        return R\n\n    for _ in range(int(input())):\n        S = input().rstrip('\n')\n        N = len(S)\n        if N == 1:\n            print(S)\n            continue\n        ii = -1\n        for i in range(N//2):\n            if S[i] != S[N-1-i]:\n                break\n            ii = i\n        if ii >= 0:\n            ss = S[:ii+1]\n            S = S[ii+1:N-ii-1]\n        else:\n            ss = ''\n        N = len(S)\n        if N == 0:\n            print(''.join([ss, ss[::-1]]))\n            continue\n        R = manacher(S)\n        M = 0\n        iii = 0\n        for i in range(N):\n            if R[i*2] > M:\n                if R[i*2]%2 == 0:\n                    continue\n                k = R[i*2] // 2\n                if i-k == 0 or i+k == N-1:\n                    M = R[i*2]\n                    iii = i\n        for i in range(N-1):\n            if R[i*2+1] > M:\n                if R[i*2+1]%2 == 1:\n                    continue\n                k = R[i*2+1] // 2\n                if i-k+1 == 0 or i+k == N-1:\n                    M = R[i*2+1]\n                    iii = i\n        if M & 1:\n            ans = S[iii - M//2: iii + M // 2 + 1]\n        else:\n            ans = S[iii - M // 2 + 1: iii + M // 2 + 1]\n        print(''.join([ss, ans, ss[::-1]]))\n        #print(S, R, iii, M)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
\nfrom collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_str(): return list(sys.stdin.readline().split())\n\nM,N,K,T = inpl()\nAA = inpl()\n\nDD_di = []\nLR = []\nfor i in range(K):\n    L,R,D = inpl()\n    LR.append((L,R))\n    DD_di.append((D,i))\n\nDD_di.sort()\nDD_d = [D for D,i in DD_di]\n\ndef solve(x):\n    idx = bisect.bisect_right(DD_d, x)\n    path = [0]*(N+2)\n    for D,i in DD_di[idx:]:\n        L,R = LR[i]\n        path[L] += 1\n        path[R+1] -= 1\n\n    t = N+1\n    bp = path[0]\n    for i in range(1,N+2):\n        p = bp + path[i]\n        if p > 0:\n            t += 2\n        bp = p\n\n    return t <= T\n\n\nOK = (10**5) * 2 + 10\nNG = -1\n\nwhile OK-NG > 1:\n    mid = (OK+NG)//2\n    if solve(mid):\n        OK = mid\n    else:\n        NG = mid\n\nans = 0\nfor A in AA:\n    if A >= OK:\n        ans += 1\n\nprint(ans)\n
import sys\n\nclass RangeBit:\n    def __init__(self, n):\n        sz = 1\n        while n >= sz:\n            sz *= 2\n        self.size = sz\n        self.dataAdd = [0 for _ in range(sz)]\n        self.dataMul = [0 for _ in range(sz)]\n\n    def sum(self, i):\n        assert i > 0\n        add, mul, start = 0, 0, i\n        while i > 0:\n            add += self.dataAdd[i]\n            mul += self.dataMul[i]\n            i -= i & -i\n        return mul * start + add\n\n    def add(self, left, right, by):\n        assert 0 < left <= right\n        self._add(left, by, -by * (left - 1))\n        self._add(right, -by, by * right)\n\n    def _add(self, i, mul, add):\n        assert i > 0\n        while i < self.size:\n            self.dataAdd[i] += add\n            self.dataMul[i] += mul\n            i += i & -i\n\nn = int(input())\nl = list(map(int, sys.stdin.readline().split()))\n\nqueries = []\nfor i in range(n):\n    if min(l[i], n) >= i+2:\n        queries.append((i+2, min(l[i], n), i+1))\n\nresult = 0\n\na = sorted(list(zip(list(range(1, n+1)), l)) + queries, key=lambda x:(-x[-1], len(x)))\nft = RangeBit(n+1)\n\nfor el in a:\n    #print(el)\n    if len(el) == 2: #update\n        ind, val = el\n        ft.add(ind, ind, 1)\n    else: #query\n        fr, to, val = el\n        # print(fr, to, val)\n        # print(ft.sum(to) - (ft.sum(fr - 1) if fr > 1 else 0))\n        result += ft.sum(to) - (ft.sum(fr - 1) if fr > 1 else 0)\n\nprint(result)\n
M=998244353\nclass Factorial:\n    def __init__(self,n):\n        self.f=f=[0]*(n+1)\n        f[0]=b=1\n        for i in range(1,n+1):f[i]=b=b*i%M\n        self.inv=inv=[0]*(n+1)\n        inv[n]=b=pow(self.f[n],M-2,M)\n        for i in range(n,0,-1):inv[i-1]=b=b*i%M\n    def factorial(self,i):\n        return self.f[i]\n    def ifactorial(self,i):\n        return self.inv[i]\n    def comb(self,n,k):\n        if n>=k:return self.f[n]*self.inv[n-k]*self.inv[k]%M\n        else:return 0\ndef main():\n    n,k,*h=map(int,open(0).read().split())\n    m=sum(i!=j for i,j in zip(h,h[1:]+h[:1]))\n    comb=Factorial(m).comb\n    print((pow(k,m,M)-sum(comb(m,i)*comb(m-i,i)*pow(k-2,m-i-i,M)for i in range(m//2+1)))*pow(k,n-m,M)*pow(2,M-2,M)%M)\nmain()
n = int(input())\na = [list(map(int, input().split())) for i in range(n)]\nres = []\nfor i in range(n):\n    j = 0\n    while j < n and 3 != a[i][j] != 1:\n        j += 1\n    if j == n: res.append(i + 1)\nprint(len(res))\nprint(' '.join(map(str, res)))\n
n = int(input())\na = list(map(int, input().split()))\ng = [[] for i in range(100)]\nfor i in range(2 * n):\n    g[a[i]].append(i)\nx = [0, 0]\ncur = 1\nmus = []\nans = [0] * 2 * n\nfor i in range(10, 100):\n    if len(g[i]) == 1:\n        ans[g[i][0]] = cur\n        x[cur - 1] += 1\n        cur = 3 - cur\n    if len(g[i]) >= 2:\n        ans[g[i][0]] = 1\n        ans[g[i][1]] = 2\n        x[0] += 1\n        x[1] += 1\n        for j in range(2, len(g[i])):\n            mus.append(g[i][j])\nfor i in range(len(mus)):\n    ans[mus[i]] = 2 - (i % 2)\nprint(x[0] * x[1])\nprint(*ans)\n        \n
import sys\nimport math\nimport heapq\nimport bisect\nimport re\nfrom collections import deque\nfrom decimal import *\nfrom fractions import gcd\n \ndef YES_NO(flag):\n    if flag:\n        print("AWW")\n    else:\n        print("WAW")\n \n \ndef main():\n    # q = [int(i) for i in sys.stdin.readline().split()]\n    n = int(sys.stdin.readline())\n    q = [int(i) for i in sys.stdin.readline().split()]\n    w = q.count(0)\n    if w + sum(q) == 0:\n        print(w + 1)\n    else:\n        print(w)\nfor i in range(int(sys.stdin.readline())):\n    main()
from copy import deepcopy\nimport itertools\nfrom bisect import bisect_left\nfrom bisect import bisect_right\nimport math\nfrom collections import deque\nfrom collections import Counter\n\n\ndef read():\n    return int(input())\n\n\ndef readmap():\n    return map(int, input().split())\n\n\ndef readlist():\n    return list(map(int, input().split()))\n\n\nn = read()\nV = []\nfor _ in range(n-1):\n    a, b = readmap()\n    V.append(a)\n    if b < n:\n        print("NO")\n        quit()\n\nV.sort()\n\nfor i in range(n-1):\n    if V[i] <= i:\n        print("NO")\n        quit()\n\nused = [False] * (n+1)\ntree = []\nfor i in range(n-1):\n    v = V[i]\n    if not used[v]:\n        tree.append(v)\n        used[v] = True\n    else:\n        for j in range(1, n+1):\n            if not used[j]:\n                tree.append(j)\n                used[j] = True\n                break\ntree.append(n)\n\nprint("YES")\nfor i in range(n-1):\n    print(tree[i], tree[i+1])
def main():\n    mode="filee"\n    if mode=="file":f=open("test.txt","r")\n    get = lambda :[int(x) for x in (f.readline() if mode=="file" else input()).split()]\n    gets = lambda :[str(x) for x in (f.readline()[:-1] if mode=="file" else input()).split(":")]\n    [n,m,t]=get()\n    a=[0]*20002\n    b=[0]*20002\n    if n<m:\n        print("No solution")\n        return\n    for i in range(1,1+n):\n        g = gets()\n        a[i] = int(g[-1]) + int(g[1])*60 + int(g[0])*3600\n        [p,count,sim] = [1,0,0]\n    is_solution_there=False\n    for i in range(1,n+1):\n        while p<i and a[i] - t + 1>a[p]:\n            p+=1\n            if b[p]!=b[p-1]:\n                sim = max(sim-1,0)\n        if a[i]<a[p]+t and sim<m:\n            count+=1\n            sim+=1\n        if sim==m:\n            is_solution_there=True\n        b[i] = count\n    if is_solution_there==False:\n        print("No solution")\n        return\n    print(count)\n    for i in range(1,n+1):\n        print(b[i],end=' ')\n\n    if mode=="file":f.close()\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()
n=int(input())\nR=[]\nL=[]\nfor i in range(n):\n    x,y=input().split()\n    R.append(x)\n    L.append(y)\n\na=R.count("0")\nb=L.count("0")\n\nanswer=min(a,n-a)+min(b,n-b)\n\nprint(answer)\n
n, m, q = map(int, input().split())\na = sorted(map(int, input().split()), reverse=True)\nb = sorted(map(int, input().split()), reverse=True)\nc = sorted(map(int, input().split()), reverse=True)\ndp = [[[0] * 201 for _ in range(201)] for _ in range(201)]\nfor ijk in range(n + m + q + 1):\n    for i in range(min(n + 1, ijk + 1)):\n        for j in range(min(m + 1, ijk - i + 1)):\n            k = ijk - i - j\n            if k < 0 or k > q:\n                continue\n            if i + 1 <= n:\n                dp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k])\n            if j + 1 <= m:\n                dp[i][j + 1][k] = max(dp[i][j + 1][k], dp[i][j][k])\n            if k + 1 <= q:\n                dp[i][j][k + 1] = max(dp[i][j][k + 1], dp[i][j][k])\n            if i + 1 <= n and j + 1 <= m:\n                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[i] * b[j])\n            if i + 1 <= n and k + 1 <= q:\n                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[i] * c[k])\n            if j + 1 <= m and k + 1 <= q:\n                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + b[j] * c[k])\nprint(dp[n][m][q])
from sys import stdin\ninput = stdin.readline\n\na = sorted([int(i) for i in input().split()])\nn = int(input())\nb = sorted([int(i) for i in input().split()])\n\nc = []\nfor i in range(n):\n    c += [[b[i] - a[j], i] for j in range(6)]\nc.sort()\n\nd = [0] * n\ne = 0\n\nans = 10 ** 10\n\nu = 0\nfor i in range(len(c)):\n    while u < len(c) and e < n:\n        x = c[u][1]\n        if d[x] == 0:\n            e += 1\n        d[x] += 1\n        u += 1\n\n    if e == n:\n        ans = min(ans, c[u - 1][0] - c[i][0])\n\n    x = c[i][1]\n    d[x] -= 1\n    if d[x] == 0:\n        e -= 1\n\nprint(ans)\n        \n        \n
n = int(input())\na = tuple(map(int, input().split()))\nsa = set(a)\nsan = set()\nmin_not_in = 0\nprev = 0\nans = [0] * n\nfor i in range(n):\n    cur = a[i]\n    if cur == prev:\n        while min_not_in in sa:\n            min_not_in += 1\n        ans[i] = min_not_in\n        sa.add(min_not_in)\n        san.add(min_not_in)\n    else:\n        ans[i] = prev\n        sa.add(prev)\n        san.add(prev)\n        while prev in san:\n            prev += 1\n        if cur != prev:\n            print(-1)\n            break\nelse:\n    print(*ans)\n
l, r = list(map(int, input().split()))\nprint("YES")\nfor i in range(l, r + 1, 2):\n  print(i, i + 1)\n
input = __import__('sys').stdin.readline\nMIS = lambda: map(int,input().split())\n\nn, m = MIS()\nA = input().split()\nB = input().split()\nfor TEST in range(int(input())):\n    y = int(input())-1\n    print(A[y%len(A)] + B[y%len(B)])
n, k = map(int, input().split())\nl, a = list(map(int, input().split())), list(map(int, input().split()))\nv, t, s = 0, 0, sum(l)\nfor i in range(n):\n    l[i] -= a[i]\nL, A = [l[0]], [a[0]]\nfor i in range(1, n):\n    if a[i] <= A[-1]: L[-1] += l[i]\n    else:\n        A.append(a[i])\n        L.append(l[i])\nfor i in range(len(A)):\n    d = L[i] - v\n    if d > 0:\n        u = (d - 1) // A[i] + 1\n        v += u * A[i]\n        t += u * k\n    v -= L[i]\nprint(t + s)
def solution() : # 最大的距离来自于角落附近的点\n	n,m,k,s = map(int, input().split())\n	dis = lambda a,b : abs(a[0] - b[0]) + abs(a[1] - b[1])\n	corner = [(0,0), (0,m-1), (n-1,0), (n-1,m-1)]\n	vertex = [[(n,m), (n,-1), (-1,m), (-1,-1)] for _ in range(k+1)]\n	for i in range(n) :\n		for j,note in enumerate(map(int, input().split())) :\n			vertex[note] = [\n				(i,j) if dis((i,j), c) < dis(v, c) else v\n				for v,c in zip(vertex[note], corner)]\n	maxdis = [[-1] * (k+1) for _ in range(k+1)]\n	pairs = [(0,3),(3,0),(1,2),(2,1)]\n	for i in range(1, k+1) :\n		for j in range(i, k+1) :\n			vi,vj = vertex[i],vertex[j]\n			maxdis[i][j] = max(dis(vi[a], vj[b]) for a,b in pairs)\n			maxdis[j][i] = maxdis[i][j]\n	s = list(map(int, input().split()))\n	print(max(maxdis[s[i]][s[i+1]] for i in range(len(s) - 1)))\nsolution()
n,m=map(int,input().split()) \nx,y,z=map(int,input().split())\nedge=[[]for _ in range(n)]\nfor _ in range(m):\n  a,b=map(int,input().split())\n  a-=1\n  b-=1\n  edge[a].append(b)\n  edge[b].append(a)\ncolor=[0]*n\ndef bfs(v,c):\n  color[v]=c\n  h=w=0\n  if c==1:h=1\n  else:w=1\n  for i in edge[v]:\n    if color[i]==c:return [False,h,w]\n    elif color[i]==0:\n      f,hh,ww=bfs(i,-c)\n      h+=hh\n      w+=ww\n      if not f:return [False,h,w]\n  return [True,h,w]\nq=[]\nfor i in range(n):\n  if color[i]==0:\n    f,h,w=bfs(i,1)\n    if not f:print("NO");return\n    q.append([i,min(h,w),max(h,w)-min(h,w),1-2*(h<w)])\nyy=y\nfor _,i,__,___ in q:yy-=i\nif yy<0:print("NO");return\ndp=[(yy+1)*[0]for _ in range(len(q)+1)]\ndp[0][0]=1\nfor i in range(len(q)):\n  _,__,ii,___=q[i]\n  for j in range(yy+1):dp[i+1][j]=dp[i][j]\n  for j in range(yy+1):\n    if ii+j>yy:break\n    dp[i+1][ii+j]|=dp[i][j]\nif dp[-1][-1]==0:print("NO");return\nk=yy\nqq=[]\nfor i in range(len(q),0,-1):\n  if dp[i][k]==dp[i-1][k]:qq.append((q[i-1][0],-q[i-1][3]))\n  else:\n    qq.append((q[i-1][0],q[i-1][3]))\n    k-=q[i-1][2]\ncolor=[0]*n\nvisited=set()\nfor i,c in qq:\n  stack=[i]\n  visited.add(i)\n  color[i]=c\n  for j in stack:\n    for k in edge[j]:\n      if k in visited:continue\n      visited.add(k)\n      color[k]=-color[j]\n      stack.append(k)\nfor i in range(n):\n  if color[i]==1:color[i]="2"\n  elif x:color[i]="1";x-=1\n  else:color[i]="3"\nprint("YES")\nprint("".join(color))
# coding: utf-8\nn = int(input())\na = []\nb = []\nc = []\nfor i in input().split():\n    i = int(i)\n    if i < 0:\n        a.append(i)\n    elif i == 0:\n        b.append(i)\n    else:\n        c.append(i)\nif len(c) == 0:\n    c.append(a.pop())\n    c.append(a.pop())\nif len(a)%2==0:\n    b.append(a.pop())\nprint(len(a),' '.join([str(i) for i in a]))\nprint(len(c),' '.join([str(i) for i in c]))\nprint(len(b),' '.join([str(i) for i in b]))\n
import sys\nimport re\n\ndef minp():\n	return sys.stdin.readline().strip()\n\ndef mint():\n	return int(minp())\n\ndef mints():\n	return map(int, minp().split())\n\ndef solve():\n	n, h, m, k = mints()\n	m //= 2\n	a = [0]*n\n	e = [None]*(2*n+2)\n	c = 0\n	for i in range(n):\n		hh, mm = mints()\n		x = mm % m\n		a[i] = mm\n		e[2*i] = ((x+k)%m, -1, i)\n		e[2*i+1] = ((x+1)%m, 1, i)\n		if (x+1)%m > (x+k)%m:\n			c += 1\n	e[2*n] = (0,0,0)\n	e[2*n+1] = (m-1,0,0)\n	#print(e)\n	e.sort()\n	p = -1\n	r = (int(1e9),0)\n	#print(e)\n	for x, t, id in e:\n		#print(x,t,id,c)\n		if p != x and p != -1:\n			r = min(r, (c, p))\n		p = x\n		c += t\n	r = min(r, (c, p))\n	print(*r)\n	p = r[1]\n	for i in range(n):\n		mm = a[i]\n		x = (mm-p) % m\n		if (x+1)%m > (x+k)%m and (x+k)%m != 0 \\n		or (x+1)%m < (x+k)%m and (x+1)%m == 0:\n			print(i+1,end=' ')\n\n\n#for i in range(mint()):\nsolve()\n
import sys\nfrom bisect import bisect\n\ndef input():\n	return sys.stdin.readline().strip()\n\ndef solve():\n	n, q = list(map(int, input().split()))\n	was = set()\n	Q = [None]*q\n	all = [0]*(2*q)\n	for i in range(q):\n		x, y, t = input().split()\n		x, y = int(x), int(y)\n		Q[i] = (x, y, t)\n		all[2*i] = x\n		all[2*i+1] = y\n	all.sort()\n	V = [0]*(4*q)\n	H = [0]*(4*q)\n	for x, y, t in Q:\n		if (x,y) in was:\n			print(0)\n		else:\n			was.add((x,y))\n			if t == 'L':\n				TA = H\n				TB = V\n			else:\n				x, y = y, x\n				TA = V\n				TB = H\n			v = bisect(all, y) - 1 + q + q\n			r = 0\n			while v > 0:\n				r = max(r, TA[v])\n				v //= 2\n			c = x - r\n			print(c)\n			r = bisect(all, x) - 1 + q + q\n			l = bisect(all, x - c) + q + q\n			while l <= r:\n				if l % 2 == 1:\n					TB[l] = max(TB[l], y)\n				if r % 2 == 0:\n					TB[r] = max(TB[r], y)\n				l = (l+1)//2\n				r = (r-1)//2\n\nsolve()\n
def get_val(x, k, y, left_val, right_val, arr):\n    x, y = y, x\n    if not arr:\n        return 0\n    if len(arr) < k:\n        if max(arr) > max(left_val, right_val):\n            return -1\n        return len(arr) * x\n    if y < x * k:\n        n = len(arr)\n        res = 0\n        while n >= k:\n            n -= k\n            res += y\n        res += n * x\n        return res\n    else:\n        if max(arr) < max(left_val, right_val):\n            return len(arr) * x\n        else:\n            return ((len(arr) - k) * x) + y\n\n\ndef solve(x, k, y, a, b):\n    def check(a, b):\n        j = 0\n        i = 0\n        while i < len(a) and j < len(b):\n            if a[i] != b[j]:\n                i += 1\n            else:\n                i += 1\n                j += 1\n        return j == len(b)\n\n    if not check(a, b):\n        return -1\n\n    j = 0\n    left_val = -1\n    arr = []\n    res = 0\n    for num in a:\n        if j == len(b) or num != b[j]:\n            arr.append(num)\n        else:\n            val = get_val(x, k, y, left_val, num, arr)\n            if val == -1:\n                return -1\n            res += val\n            arr = []\n            left_val = num\n            j += 1\n    if arr:\n        val = get_val(x, k, y, left_val, -1, arr)\n        if val == -1:\n            return -1\n        res += val\n    return res\n\n\nn, m = list(map(int, input().split()))\nx, k, y = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nprint(solve(x, k, y, a, b))\n
n = int(input())\nedges = [[] for i in range(n)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    edges[u-1].append(v-1)\n    edges[v-1].append(u-1)\n\ncolors = [-1 for i in range(n)]\ndfs = [(0,0)]\nwhile len(dfs) > 0:\n    node, color = dfs.pop()\n    colors[node] = color\n    for neighbor in edges[node]:\n        if colors[neighbor] == -1:\n            dfs.append((neighbor, 1-color))\n\nblue = len([x for x in colors if x==0])\nred = n - blue\n\ntotal_graph_edges = blue*red\nprint(blue*red - (n-1))
n = input()\nn = int(n)\nif n <=2:\n    print(-1)\nelif n%2 ==0:\n    for row in range(n):\n        if row ==0:\n            for i in range(n):\n                if i ==0:    \n                    print(i+1,end = " ")\n                elif i==n-1:\n                    print(i+1)\n                else: \n                    print(i+1,end = " ")   \n        elif row ==n-1:\n            for i in range(n):\n                if i==n-1:\n                    print(n*n-1)\n                else: \n                    print(n+(n-1)*(n-2)+(n-3)-i+2,end = " ")\n        elif row ==n-2:\n            for i in range(n):\n                if i ==0:\n                    print(n*n-n+2+row,end = " ")\n                elif i <n-1: \n                    print(n+(n-1)*(row-1)+i,end = " ")\n                else:\n                    print(n+(n-1)*(row-1)+n-1)\n        elif row%2 ==1:\n            for i in range(n):\n                if i ==0:\n                    print(n*n-n+2+row-1,end = " ")\n                elif i <n-1: \n                    print(n+(n-1)*(row-1)+n-i,end = " ")\n                else:\n                    print(n+(n-1)*(row-1)+1)\n        elif row%2 ==0:\n            for i in range(n):\n                if i ==0:\n                    print(n*n-n+2+row-1,end = " ")\n                elif i <n-1: \n                    print(n+(n-1)*(row-1)+i,end = " ")\n                else:\n                    print(n+(n-1)*(row-1)+n-1)\nelif n%2 ==1:\n    for row in range(n):\n        if row ==0:\n            for i in range(n):\n                if i ==0:    \n                    print(i+1,end = " ")\n                elif i==n-1:\n                    print(n*n-n+row+1)\n                else: \n                    print(i+1,end = " ")   \n        elif row ==n-1:\n            for i in range(n):\n                if i==0:\n                    print(n*n-1,end = " ")\n                elif i ==n-1:\n                    print((n-1)*(n-1)+i)\n                else: \n                    print((n-1)*(n-1)+i,end = " ")\n        elif row ==n-2:\n            for i in range(n):\n                if i ==0:\n                    print((n-1)*row+n-i-1,end = " ")\n                elif i <n-1: \n                    print((n-1)*row+n-i-1,end = " ")\n                else:\n                    print(n*n)\n        elif row%2 ==1:\n            for i in range(n):\n                if i ==0:\n                    print((n-1)*row+n-i-1,end = " ")\n                elif i <n-1: \n                    print((n-1)*row+n-i-1,end = " ")\n                else:\n                    print(n*n-n+row+1)\n        elif row%2 ==0:\n            for i in range(n):\n                if i ==0:\n                    print((n-1)*row+i+1,end = " ")\n                elif i <n-1: \n                    print((n-1)*row+i+1,end = " ")\n                else:\n                    print(n*n-n+row+1)
n=int(input())\na=list(map(int,input().split()))\ni=0\nb=[]\nwhile i+1<n:\n    if a[i]==a[i+1]:\n        a[i+1]=a[i]+1\n        if len(b)>0:\n            a[i]=b.pop()\n        else:\n            i=i+1\n    else:\n        b.append(a[i])\n        i=i+1\nb.append(a[-1])\nprint(len(b))\nprint(*b)
n, m, k = map(int, input().split())\na = list(map(int, input().split()))\nans = 0\nfor i in range(n):\n	orders = map(int, input().split())\n	for order in orders:\n		ans += a.index(order) + 1\n		a.remove(order)\n		a.insert(0, order)\nprint(ans)
from sys import stdin\nfrom collections import defaultdict\nimport heapq\n\nn = int(stdin.readline())\na = [[] for _ in range(n)]\nfor _ in range(n-1):\n    e = stdin.readline().split(' ')\n    u, v = int(e[0]), int(e[1])\n    a[u-1].append(v-1)\n    a[v-1].append(u-1)\n\n\nleaves = [i for i in range(n) if len(a[i]) == 1]\n\n\ndef dfs_from(root):\n    depth = defaultdict(int)\n    child = {}\n    parent = defaultdict(lambda: -1)\n    stack = [root]\n    visited = [False for _ in range(n)]\n    while len(stack) > 0:\n        crt = stack[-1]\n        if visited[crt]:\n            stack.pop(-1)\n            if len(a[crt]) > 1:  # not a leaf\n                child[crt], depth[crt] = max([(c, depth[c]+1) for c in a[crt]\n                                              if c != parent[crt]],\n                                             key=lambda x: x[1])\n            else:\n                child[crt] = -1\n                depth[crt] = 0\n            continue\n\n        visited[crt] = True\n        for next in a[crt]:\n            if next != parent[crt]:\n                stack.append(next)\n                parent[next] = crt\n\n    return depth, child\n\n\nfirst_choice = leaves[0]\nd1, child1 = dfs_from(first_choice)\n\nroot = max([(a[leaf][0], d1[a[leaf][0]]) for leaf in leaves],\n           key=lambda leaf_depth: leaf_depth[1])[0]\nwhile child1[root] != -1:\n    root = child1[root]\ndepth, child = dfs_from(root)\n\nsolution = [1]\npq = []\nfor k, v in list(depth.items()):\n    heapq.heappush(pq, (-v, k))\n\nseen = [False for _ in range(n)]\nseen[root] = True\n\nwhile len(pq) > 0:\n    _, best = heapq.heappop(pq)\n    if seen[best]:\n        continue\n    path = []\n    c = best\n    s = 0\n    while c != -1:\n        seen[c] = True\n        c = child[c]\n        s = s+1\n    s = s + solution[-1]\n    solution.append(s)\n\n\nfor _ in range(n - min(len(solution), n)):\n    solution.append(n)\n\nprint(' '.join([str(s) for s in solution]))\n
def create_list(n, num_of_calls):\n    if n == 1:\n        return [1], 0\n    if n == 2:\n        return [2, 1], 2\n    if num_of_calls == 2:\n        return list(range(2, n // 2 + 2)) + [1] +\\n               list(range(n // 2 + 2, n + 1)), 2\n\n    list1, num_of_calls1 = create_list(n // 2, num_of_calls - 2)\n    if num_of_calls1 == num_of_calls - 2:\n        return list1 + list(range(n // 2 + 1, n + 1)), num_of_calls\n\n    list2, num_of_calls2 = create_list((n + 1) // 2,\n                                       num_of_calls - num_of_calls1 - 2)\n    return list1 + [x + n // 2 for x in list2], \\n        num_of_calls1 + num_of_calls2 + 2\n\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    if k % 2 != 1:\n        print(-1)\n        return\n\n    if k == 1:\n        print(' '.join([str(x) for x in range(1, n + 1)]))\n        return\n\n    num_list, num_of_calls = create_list(n, k - 1)\n    if num_of_calls != k - 1:\n        print(-1)\n        return\n    print(' '.join([str(x) for x in num_list]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
def kmp(pat,text,t):\n    s=pat+"?"+text;\n    #z[i] es el tamaño del prefijo mas largo de, formado por una subcadena s[i:...]\n    z=[0 for i in range(len(s))]\n    L=0;R=0;n=len(s);\n    for i in range(1,len(s)):\n        if i>R:\n            L=R=i\n            while R<n and s[R-L]==s[R]:\n                R+=1\n            z[i]=R-L\n            R-=1\n        elif z[i-L]+i<=R:\n            z[i]=z[i-L]\n        else:\n            L=i\n            while R<n and s[R-L]==s[R]:\n                R+=1\n            z[i]=R-L\n            R-=1\n    for i in range(len(pat)+1,len(z)):\n        dp[t][i-(len(pat)+1)]=z[i]%len(pat)\nfrom sys import stdin\nmod=998244353\na=stdin.readline().strip()\nl=stdin.readline().strip()\nr=stdin.readline().strip()\nx=len(l)\ny=len(r)\nn=len(a)\ndp=[[0 for i in range(len(a))]for j in range(2)]\nans=[0 for i in range(len(a)+1)]\nans[-1]=1\nkmp(l,a,0)\nkmp(r,a,1)\nauxl=x-1\nauxr=y-1\nacum=[0 for i in range(n+2)]\nacum[n]=1\nfor i in range(n-1,-1,-1):\n    if a[i]=="0":\n        if l[0]=="0":\n            ans[i]=ans[i+1]\n        acum[i]=(acum[i+1]+ans[i])%mod\n        continue\n    if auxl>=n:\n        acum[i]=(acum[i+1]+ans[i])%mod\n        continue\n    if auxl!=auxr:\n        if (auxl+i)<n and a[dp[0][i]+i]>=l[dp[0][i]]:\n            ans[i]=(ans[i]+ans[i+auxl+1])%mod\n        if (auxr+i)<n and a[dp[1][i]+i]<=r[dp[1][i]]:\n            ans[i]=(ans[i]+ans[i+auxr+1])%mod\n    else:\n        if (auxl+i)<n and a[dp[0][i]+i]>=l[dp[0][i]] and a[dp[1][i]+i]<=r[dp[1][i]]:\n            ans[i]=(ans[i]+ans[i+auxl+1])%mod\n    lim1=auxl+i+2\n    lim2=min(auxr+i+1,n+1)\n    if lim1<lim2:\n        ans[i]=(ans[i]+acum[lim1]-acum[lim2])%mod\n    acum[i]=(acum[i+1]+ans[i])%mod\nprint(ans[0]%mod)\n
"""\nCodeforces Round 250 Div 2 Problem C\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\nclass IOHandlerObject(object):\n    def getInput(self, mode=2):\n        # 0: String\n        # 1: List of strings\n        # 2: List of integers\n        inputs = input().strip()\n        if mode == 0:\n            return inputs\n        if mode == 1:\n            return inputs.split()\n        if mode == 2:\n            return [int(x) for x in inputs.split()]\n\n    def writeOutput(self, s="\n"):\n        if isinstance(s, list): s = " ".join(s)\n        print(s)\n\nIOHandler = IOHandlerObject()\ng = IOHandler.getInput\nw = IOHandler.writeOutput\n\n############################## SOLUTION ##############################\nn,m = g()\nv = g()\nsm = 0\nfor i in range(m):\n    x,y = g()\n    sm += min(v[x-1], v[y-1])\nprint(sm)
import sys\ninput = sys.stdin.readline\nn, k = map(int, input().split())\na = [int(i) for i in input().split()]\ng = [[] for _ in range(n)]\nfor i in range(n - 1):\n	u, v = map(int, input().split())\n	g[u-1].append(v-1)\n	g[v-1].append(u-1)\n\nstack = [0]\ndone = [False] * n\npar = [0] * n\norder = []\nwhile len(stack) > 0:\n	x = stack.pop()\n	done[x] = True\n	order.append(x)\n	for i in g[x]:\n		if done[i] == False:\n			par[i] = x\n			stack.append(i)\norder = order[::-1]\nsub = [0] * n\nfor i in order: \n	sub[i] = 1\n	for j in g[i]:\n		if par[j] == i:\n			sub[i] += sub[j]\n\ndef good(guess):\n	cnt = [0] * n\n	for i in order:\n		if a[i] < guess:\n			continue\n		cnt[i] = 1\n		opt = 0\n		for j in g[i]:\n			if par[j] == i:\n				if cnt[j] == sub[j]:\n					cnt[i] += cnt[j]\n				else:\n					opt = max(opt, cnt[j])\n		cnt[i] += opt\n	if cnt[0] >= k:\n		return True\n	up = [0] * n\n	for i in order[::-1]:\n		if a[i] < guess:\n			continue\n		opt, secondOpt = 0, 0\n		total = 1\n		for j in g[i]:\n			val, size = 0, 0\n			if par[j] == i:\n				val = cnt[j]\n				size = sub[j]\n			else:\n				val = up[i]\n				size = n - sub[i]\n			if val == size:\n				total += val\n			else:\n				if opt < val:\n					opt, secondOpt = val, opt\n				elif secondOpt < val:\n					secondOpt = val\n\n		for j in g[i]:\n			if par[j] == i:\n				up[j] = total\n				add = opt\n				if sub[j] == cnt[j]:\n					up[j] -= cnt[j]\n				elif cnt[j] == opt:\n					add = secondOpt\n				up[j] += add\n	for i in range(n):\n		if a[i] < guess:\n			continue\n		total, opt = 1, 0\n		for j in g[i]:\n			val, size = 0, 0\n			if par[j] == i:\n				val = cnt[j]\n				size = sub[j]\n			else:\n				val = up[i]	\n				size = n - sub[i]\n			if val == size:\n				total += val\n			else:\n				opt = max(opt, val)\n		if total + opt >= k:\n			return True			\n	return False\n\nl, r = 0, max(a)\nwhile l < r:\n	mid = (l + r + 1) // 2\n	if good(mid):\n		l = mid\n	else:\n		r = mid - 1\nprint(l)
import sys\nimport heapq\nfrom collections import namedtuple\n\nRecord = namedtuple('Record', ['index', 'book_id'])\n\nl1 = sys.stdin.readline()\nl2 = sys.stdin.readline()\n\nn, k = list(map(int, l1.split(' ')))\nbooks = list(map(int, l2.split(' ')))\n\ncost = 0\ncache = set()\nprev = dict() # book_id -> index\nnext = [n+1] * n # index of next with the same value\ninactive_ids = set() # set of inactive object id()s\nbook_to_record = dict()\n\n\ndef serve_book(book_id, i):\n	cache.add(book_id)\n	record = Record(-next[i], book_id)\n	heapq.heappush(h, record)\n	book_to_record[book_id] = record\n\nh = []\nfor i, book_id in enumerate(books):\n	if book_id in prev:\n		next[prev[book_id]] = i\n	prev[book_id] = i\n\nfor i, book_id in enumerate(books):\n	# print("book_id=%s, h=%s, inactive=%s" %(book_id, h, inactive_ids))\n	if book_id in cache:\n		previous_record = book_to_record[book_id]\n		inactive_ids.add(id(previous_record))\n		serve_book(book_id, i)\n		# print('--> Serve book from library ', book_id)\n		continue\n\n	if len(cache) < k:\n		cost += 1\n		serve_book(book_id, i)\n		# print('--> Buy book', book_id)\n		continue\n\n	while True:\n		item = heapq.heappop(h)\n		if id(item) in inactive_ids:\n			# print("--> Ignore record", item)\n			inactive_ids.remove(id(item))\n			continue\n		cache.remove(item.book_id)\n		serve_book(book_id, i)\n		cost += 1\n		# print('--> Throw away book', item.book_id)\n		# print('--> Add book to libary', book_id)\n		break\n	# print("To evict %s" % to_evict)\n	\n\nprint(cost)\n\n\n\n
"""\nCodeforces Contest 264 Div 2 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef main():\n    n, = read()\n    print(max(read()))\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
def pr( name , lvl , dp , u , tot ): \n    if lvl == 0:\n        print(name + ':' + tot[lvl])\n        return\n\n    pr( u[lvl][name] , lvl - 1 , dp , u , tot )\n    print(name + ':' + tot[lvl])\n\ndef solve(): \n    n = int(input())\n    users = input().split()\n    m = int(input())\n    dp = [] \n    u = []\n    tot = [] \n    for i in range( m ) : \n        dp.append( set() ) \n        u.append( {} ) \n        line = input().split(':')\n        sender = line[0]\n        tot.append( line[1] ) \n        line[1] = line[1].replace( '?' , ' ' )\n        line[1] = line[1].replace( '.' , ' ' )\n        line[1] = line[1].replace( ',' , ' ' )\n        line[1] = line[1].replace( '!' , ' ' )\n        mess = line[1].split()\n\n        if sender == '?' : \n            if i != 0:\n                for name in users:\n                    for x in dp[i-1]: \n                        if x != name and name not in mess:\n                            dp[i].add( name ) \n                            u[i][name] = x\n            else : \n                for name in users: \n                    if name not in mess:\n                        dp[i].add( name ) \n        else: \n            if i != 0: \n                for x in dp[i-1]: \n                    if x != sender: \n                        dp[i].add( sender ) \n                        u[i][sender] = x\n            else: \n                dp[i].add( sender )\n        \n        \n    if dp[m-1]: \n        pr( list(dp[m-1])[0] , m-1 , dp , u , tot )\n    else: \n        print("Impossible")\n\n\nt = int(input())\nfor i in range( t ) : \n    solve()\n
from collections import defaultdict as dd\nimport math\nimport sys\n#input=sys.stdin.readline\ndef nn():\n	return int(input())\n\ndef li():\n	return list(input())\n\ndef mi():\n	return list(map(int, input().split()))\n\ndef lm():\n	return list(map(int, input().split()))\n\nn,m=mi()\n\nquilt=[]\nfor i in range(n):\n	quilt.append(li())\ndef getflags(column):\n	flags=set()\n	breaks=[0]\n	for i in range(0,len(column)-1):\n		if not column[i]==column[i+1]:\n			breaks.append(i+1)\n	breaks.append(len(column))	\n	#print(breaks)\n	for j in range(1,len(breaks)-2):\n		midlength=breaks[j+1]-breaks[j]\n		firstlength=breaks[j]-breaks[j-1]\n		endlength=breaks[j+2]-breaks[j+1]\n		if midlength<=firstlength and midlength<=endlength:\n			flags.add(((breaks[j+1],breaks[j]), (column[breaks[j+1]], column[breaks[j]],column[breaks[j-1]])))\n	return flags\n\nflagdicts=[0]*m\n\nfor i in range(m):\n	col=[row[i] for row in quilt]\n	flagdicts[i]=getflags(col)\ntotal=0\n#print(flagdicts)\nfor i in range(m):\n	for flag in flagdicts[i]:\n		k=1\n		\n		while i+k<m and flag in flagdicts[i+k]:\n			k+=1\n			#print(flagdicts[i+k])\n			#flagdicts[i+k].remove(flag)\n		for j in range(1,k):\n			flagdicts[i+j].remove(flag)\n		total+=k*(k+1)//2		\nprint(total)\n			\n\n\n\n\n\n\n\n\n\n\n\n\n		\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n
def main():\n    n, m, h = map(int, input().split())\n    row = list(map(int, input().split()))\n    col = list(map(int, input().split()))\n    mat = [list(map(int, input().split())) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j]:\n                mat[i][j] = min(col[i], row[j])\n    for arr in mat: print(*arr)\n    return 0\nmain()
import sys\n\nn = int(sys.stdin.readline().strip())\nm = 0\nM = 0\n\nfor i in range (0, n):\n    line = sys.stdin.readline().strip().split()\n    s = line[0]\n    x = min([int(line[1]), int(line[2])])\n    y = max([int(line[1]), int(line[2])])\n    if s == '+':\n        m = max([m, x])\n        M = max([M, y])\n    else:\n        if x >= m and y >= M:\n            print("YES")\n        else:\n            print("NO")\n\n\n
\n#q = int(input())\n#x, y = map(int,input().split(' '))\n#print (' '.join(list(map(str, s))))\n\ndef extended_gcd(aa, bb):\n    lastremainder, remainder = abs(aa), abs(bb)\n    x, lastx, y, lasty = 0, 1, 1, 0\n    while remainder:\n        lastremainder, (quotient, remainder) = remainder, divmod(lastremainder, remainder)\n        x, lastx = lastx - quotient*x, x\n        y, lasty = lasty - quotient*y, y\n    return lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1)\n \ndef modinv(a, m):\n    g, x, y = extended_gcd(a, m)\n    if g != 1:\n        raise ValueError\n    return x % m\n\nm = 998244353\nn = int(input())\np = list(map(int,input().split(' ')))\n\nup = 0\nlow = 1\nfor i in range(n):\n    up = up + low\n    up = up * 100 % m\n    low = low * p[i] % m\n    \nprint (up*modinv(low,m)%m)
import sys\nimport collections\nrlines = sys.stdin.readlines()\nlines = (l.strip() for l in rlines)\n\ndef eucycle(n,m,adj):\n    diredges = []\n    us = list(adj.keys())\n    for u in us:\n        while adj[u]:\n            v0 = u\n            v1 = adj[v0].pop()\n            adj[v1].remove(v0)\n            diredges.append((v0,v1))\n            while v1 != u:\n                v0 = v1\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0,v1))\n    return diredges\n\ndef solve(n,m,edges):\n    adj = collections.defaultdict(set)\n    diredges = []\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set(u for u in adj if len(adj[u])%2 == 1)\n    ans = n - len(odds)\n    assert(len(odds)%2 == 0)\n    for o in odds:\n        adj[n+1].add(o)\n        adj[o].add(n+1)\n    diredges = eucycle(n+1,m,adj)\n    return str(ans) + '\n' + '\n'.join(str(u) + ' ' + str(v) for (u,v) in diredges\\n            if u != n+1 and v != n+1)\n\n\nt = int(next(lines))\n\nfor ti in range(t):\n    n,m = [int(s) for s in next(lines).split()]\n    edges = []\n    for ei in range(m):\n        u,v = [int(s) for s in next(lines).split()]\n        edges.append((u,v))\n    #print(edges)\n    print(solve(n,m,edges))\n\n
n=int(input())\ns=[[] for i in range(60)]\nfor b in list(map(int,input().split())):\n	for i in range(59,-1,-1):\n		if b>>i&1:\n			s[i].append(b)\n			break\nans=[]\ncur=0\nfor i in range(n):\n	fl=False\n	for j in range(60):\n		if s[j]!=[] and cur>>j&1==0:\n			ans.append(s[j][-1])\n			cur^=s[j][-1]\n			s[j].pop()\n			fl=True\n			break\n	if not fl:\n		print('No')\n		return\nprint('Yes')\nprint(' '.join(str(i) for i in ans))
# python3\n\n\ndef readline(): return tuple(map(int, input().split()))\n\n\ndef readlines(count): return (readline() for __ in range(count))\n\n\ndef main():\n    n, = readline()\n    degree = [0] * n\n    root = None\n    for (a, b) in readlines(n - 1):\n        degree[a - 1] += 1\n        degree[b - 1] += 1\n\n    for (x, d) in enumerate(degree, start=1):\n        if d > 2:\n            if root is None:\n                root = x\n            else:\n                print("No")\n                return\n\n    if root is None:\n        root = 1\n\n    ways = [i for (i, d) in enumerate(degree, start=1) if d == 1 and i != root]\n    print("Yes")\n    print(len(ways))\n    print("\n".join(map(f"{root} {{}}".format, ways)))\n\n\nmain()\n
speeds = [1000000]\novertakes = [True]\ncount = 0\nspeed = 0\nn = int(input())\nfor e in range(n):\n  inp = list(map(int, input().split()))\n  # print(inp)\n  if inp[0] == 4:\n    overtakes.append(True)\n  elif inp[0] == 6:\n    overtakes.append(False)\n  elif inp[0] == 5:\n    speeds.append(1000000)\n  elif inp[0] == 3:\n    speeds.append(inp[1])\n    while speed > speeds[-1]:\n      count += 1\n      speeds.pop()\n      \n  elif inp[0] == 2:\n    while not overtakes[-1]:\n      count += 1\n      overtakes.pop()\n  else:\n    while inp[1] > speeds[-1]:\n      count += 1\n      speeds.pop()\n    speed = inp[1]\n  \nprint(count)\n"""\nPolycarp changes the speed of his car to specified (this event comes with a positive integer number);\nPolycarp's car overtakes the other car;\nPolycarp's car goes past the "speed limit" sign (this sign comes with a positive integer);\nPolycarp's car goes past the "overtake is allowed" sign;\nPolycarp's car goes past the "no speed limit";\nPolycarp's car goes past the "no overtake allowed";\n"""
from collections import defaultdict, deque\n\nclass DSU:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n        self.ranks = [0 for i in range(n)]\n\n    def find_parent(self, v):\n        if self.parents[v] == v:\n            return v\n        self.parents[v] = self.find_parent(self.parents[v])\n        return self.parents[v]\n\n    def join_sets(self, u, v):\n        u = self.find_parent(u)\n        v = self.find_parent(v)\n        if u != v:\n            if self.ranks[u] < self.ranks[v]:\n                u, v = v, u\n            self.parents[v] = u\n            if self.ranks[v] == self.ranks[u]:\n                self.ranks[u] += 1\n\nn = int(input())\ndsu = DSU(n)\ncolors = list(map(int, input().split(' ')))\nvertices = []\nfor i in range(n-1):\n    u, v = [int(x)-1 for x in input().split(' ')]\n    if colors[u] == colors[v]:\n        dsu.join_sets(u, v)\n    vertices.append((u,v))\ngraph = defaultdict(list)\nfor u, v in vertices:\n    if colors[u] != colors[v]:\n        u = dsu.find_parent(u)\n        v = dsu.find_parent(v)\n        graph[u].append(v)\n        graph[v].append(u)\n\n\ndef bfs(u):\n    d = dict()\n    d[u] = 0\n    q = deque()\n    q.append(u)\n    while q:\n        u = q.pop()\n        for v in graph[u]:\n            if v not in d:\n                d[v] = d[u] + 1\n                q.append(v)\n    return d\nif graph:\n    v = list(graph.keys())[0]\n    d = bfs(v)\n    u = v\n    for i in d:\n        if d[i] > d[u]:\n            u = i\n    d = bfs(u)\n    w = u\n    for i in d:\n        if d[i] > d[w]:\n            w = i\n    print((d[w]+1)//2)\nelse:\n    print(0)\n
n=int(input())\nlst1=list(map(int,input().split()))[:n]\nlst2=list(map(int,input().split()))[:n]\ndict={}\nfor a in lst1:\n    if a in dict:\n        dict[a]+=1\n\n    else:\n        dict[a]=1\n\n\nans=0\ngrp=[]\n\nfor k in dict:\n    if(dict[k]>1):\n        grp.append(k)\n\n\n\nfor i in range(n):\n    for k in grp:\n        \n        if(lst1[i]|k==k):\n            ans +=lst2[i]\n            break\nprint(ans)\n
h, w = list(map(int, input().split()))\nfield = [[c == "." for c in input()] + [False] for i in range(h)]\nfield.append([False] * (w + 1))\n\nsubVerts = [[0] * (w + 1) for i in range(h + 1)]\nsubHoriz = [[0] * (w + 1) for i in range(h + 1)]\n\nfor y in range(h):\n    subVerts[y][0] = 0\n    subHoriz[y][0] = 0\n\nfor x in range(w):\n    subHoriz[0][x] = 0\n    subVerts[0][x] = 0\n\nfor y in range(h):\n    for x in range(w):\n        subVerts[y + 1][x + 1] = subVerts[y + 1][x] + subVerts[y][x + 1] - subVerts[y][x]\n        if field[y][x] and field[y - 1][x]:\n            subVerts[y + 1][x + 1] += 1\n        \n        subHoriz[y + 1][x + 1] = subHoriz[y + 1][x] + subHoriz[y][x + 1] - subHoriz[y][x]\n        if field[y][x] and field[y][x - 1]:\n            subHoriz[y + 1][x + 1] += 1\n\n\n\nq = int(input())\nfor i in range(q):\n    y1, x1, y2, x2 = [int(x) - 1 for x in input().split()]\n    ansHoriz = subHoriz[y2 + 1][x2 + 1] - subHoriz[y1][x2 + 1] - subHoriz[y2 + 1][x1 + 1] + subHoriz[y1][x1 + 1]\n    ansVerts = subVerts[y2 + 1][x2 + 1] - subVerts[y1 + 1][x2 + 1] - subVerts[y2 + 1][x1] + subVerts[y1 + 1][x1]\n    print(ansHoriz + ansVerts)\n
for _ in range(int(input())):\n    n = int(input())\n    arr = [list(input()) for _ in range(n)]\n    res = []\n    if arr[n-2][n-1] == arr[n-1][n-2]:\n        if arr[0][1] == arr[n-2][n-1]:\n            res.append((1, 2))\n        if arr[1][0] == arr[n-2][n-1]:\n            res.append((2, 1))\n    elif arr[0][1] == arr[1][0]:\n        if arr[n-2][n-1] == arr[0][1]:\n            res.append((n-1, n))\n        if arr[n-1][n-2] == arr[0][1]:\n            res.append((n, n-1))\n    else:\n        if arr[0][1] == "1":\n            res.append((1, 2))\n        if arr[1][0] == "1":\n            res.append((2, 1))\n        if arr[n-2][n-1] == "0":\n            res.append((n-1, n))\n        if arr[n-1][n-2] == "0":\n            res.append((n, n-1))\n    print(len(res))\n    for e in res:\n        print(*e)\n
n, A, C = list(map(int, input().split()))\n\ndef Ro(x, y):\n    return A * x - y + C\n \nhuh = []\n \nfor i in range(n):\n    z, x, y = list(map(int, input().split()))\n    huh.append((Ro(x + z, z * A + y), x))\nhuh = sorted(huh)\nanss = 0\nc1 = 0\nc2 = 0\nprev = (-9999999999999, -999999999999999)\ng = []\n\nhuh.append((-9999999999999, -999999999999999))\n#print(huh)\nfor huhh in huh:\n    if huhh[0] != prev[0]:\n        g.append(c1)\n        #print(g)\n        for j in g:\n            anss += (c2 - j) * j\n        g = []\n        c1 = 1\n        c2 = 1\n        prev = (huhh[0], huhh[1])\n        continue\n    c2 += 1\n    if huhh[1] != prev[1]:\n        g.append(c1)\n        c1 = 0\n        prev = (huhh[0], huhh[1])\n    c1 += 1\nprint(anss)\n
# python3\n\n\ndef readline(): return list(map(int, input().split()))\n\n\ndef solve(d):\n    while d:\n        dn = d.pop()\n        if not d:\n            for i in range(1, dn + 1):\n                for j in range(i, dn + 1):\n                    yield i, j + 1\n            return\n        else:\n            d1 = d.pop(0)\n            for i in range(1, dn + 1):\n                for j in range(max(dn - d1 + 1, i), dn + 1):\n                    yield i, j + 1\n\n            d = [di - d1 for di in d]\n\n\ndef main():\n    n, = readline()\n    d = readline()\n\n    assert len(d) == n\n\n    edges = list(solve(d))\n    print(len(edges))\n    print("\n".join(map("{0[0]} {0[1]}".format, edges)))\n\n\nmain()\n
s=input()\n\nif(len(s)<=3):\n    print(0)\n\nelse:\n    n=len(s)\n    ans=0\n    A=0\n    for i in range(3,n):\n        if(s[i-3]+s[i-2]+s[i-1]+s[i]=='bear'):\n            ans+=((i-3)-A+1)*(n-i)\n            A=i-2\n    print(ans)\n
s = list(input())\nn = len(s) // 2\nm = int(input())\na = [int(x) for x in input().split()]\nsums = [0] * (n + 1)\nfor i in a:\n    sums[i - 1] += 1\nfor i in range(1, len(sums)):\n    sums[i] += sums[i-1]\n\nfor i in range(n):\n    if (sums[i] % 2 == 1):\n        s[i], s[-i-1] = s[-i-1], s[i]\n\nprint("".join(s))\n\n
n = int(input())\nfor i in range(n):\n	for j in range(n):\n		if (i + j) % 2 == 0:\n			print('W', end='')\n		else:\n			print('B', end='')\n	print()
for  testcases in range(int(input())):\n	n,m = list(map(int,input().split()))\n	ar = list(map(int,input().split()))\n	br = list(map(int, input().split()))\n	flag = 0 \n	ans = 0\n	for i in ar:\n		for j in br:\n			if i == j :\n				ans = i \n				flag = 1\n				break\n	if flag == 0 :\n		print("NO")\n	else:\n		print("YES")\n		print(1,ans)				\n
n = int(input())\nsweets = [int(x) for x in input().strip().split(" ")]\n\ndict = {}\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        sum = sweets[i] + sweets[j]\n        if sum in dict:\n            dict[sum] += 1\n        else:\n            dict[sum] = 1\n\nprint(max(dict.values()))\n
from math import gcd\n\ndef Fenjie(n):\n    k = {}\n    if (n == 1):\n        return {}\n    a = 2\n    while (n >= 2):\n        if (a*a > n):\n            if (n in k):\n                k[n] += 1\n            else:\n                k[n] = 1\n            break\n        b = n%a\n        if (b == 0):\n            if (a in k):\n                k[a] += 1\n            else:\n                k[a] = 1\n            n = n//a\n        else:\n            a += 1\n    return k\n\ndef Euler(n):\n    if (n == 1):\n        return 1\n    k = Fenjie(n)\n    m = n\n    for i in k:\n        m = m // i * (i-1)\n    return m\n\nt = int(input())\nfor _ in range(t):\n    a, b = list(map(int, input().split()))\n    b = b//gcd(a,b)\n    print(Euler(b))\n
t = int(input())\n\nfor i in range(t):\n	a, b = map(int, input().split())\n\n	if a == 1:\n		if b == 1:\n			print('YES')\n		else:\n			print('NO')\n		continue\n\n	if a <= 3:\n		if b <= 3:\n			print('YES')\n		else:\n			print('NO')\n		continue\n\n	print('YES')
n = int(input())\na = list([int(x) - 1 for x in input().split()])\n\ncnt = 0\ncurr = [0]\nv = [0 for _ in range(n)]\nr = [0 for _ in range(n)]\n\nlvl = 0\nwhile cnt < n:\n    nxt = []\n    for i in curr:\n        if v[i]:\n            continue\n        v[i] = 1\n        r[i] = lvl\n        cnt += 1\n        if i > 0 and not v[i-1]:\n            nxt.append(i - 1)\n        if i < n - 1 and not v[i+1]:\n            nxt.append(i + 1)\n        if not v[a[i]]:\n            nxt.append(a[i])\n    curr = nxt\n    lvl += 1\nprint(' '.join(map(str,r)))\n
from collections import deque\nimport random\n\n\nclass CodeforcesTask566BSolution:\n    def __init__(self):\n        self.result = ''\n        self.n = 0\n        self.rules = []\n\n    def read_input(self):\n        self.n = int(input())\n        self.rules = [[int(x) for x in input().split(" ")] + [y + 1] for y in range(self.n * 4)]\n\n    def process_task(self):\n\n        loads = [4] * self.n\n        random.shuffle(self.rules)\n        to_use = deque(self.rules)\n        order = []\n        res = True\n        ba = 0\n        while to_use and res:\n            moving = to_use.popleft()\n            loads[moving[0] - 1] -= 1\n            if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n                ba = 0\n                loads[moving[1] - 1] += 1\n                loads[moving[2] - 1] += 1\n                order.append(moving[3])\n            else:\n                ba += 1\n                loads[moving[0] - 1] += 1\n                to_use.append(moving)\n            if ba > self.n * 12:\n                res = False\n        self.result = "NO" if not res else f"YES\n{' '.join([str(x) for x in order])}"\n\n    def get_result(self):\n        return self.result\n\n\ndef __starting_point():\n    Solution = CodeforcesTask566BSolution()\n    Solution.read_input()\n    Solution.process_task()\n    print(Solution.get_result())\n\n__starting_point()
import sys\ninput = sys.stdin.readline\n\nn, r = map(int, input().split())\nxs = list(map(int, input().split()))\n\npoints = []\n\nfor x in xs:\n  y = r\n  for x0, y0 in points:\n    if abs(x - x0) <= 2 * r:\n      y = max(y, y0 + ((2*r)**2 - (x-x0)**2)**0.5)\n  points.append((x, y))\n\nprint(" ".join("%.20f" % p[1] for p in points))
M=998244353\nclass Factorial:\n    def __init__(self,n):\n        self.f=f=[0]*(n+1)\n        f[0]=b=1\n        for i in range(1,n+1):f[i]=b=b*i%M\n        self.inv=inv=[0]*(n+1)\n        inv[n]=b=pow(self.f[n],M-2,M)\n        for i in range(n,0,-1):inv[i-1]=b=b*i%M\n    def factorial(self,i):\n        return self.f[i]\n    def ifactorial(self,i):\n        return self.inv[i]\n    def comb(self,n,k):\n        if n>=k:return self.f[n]*self.inv[n-k]*self.inv[k]%M\n        else:return 0\ndef main():\n    n,k,*h=map(int,open(0).read().split())\n    m=sum(i!=j for i,j in zip(h,h[1:]+h[:1]))\n    comb=Factorial(m).comb\n    print((pow(k,m,M)-sum(comb(m,i)*comb(m-i,i)*pow(k-2,m-i-i,M)for i in range(m//2+1)))*pow(k,n-m,M)*pow(2,M-2,M)%M)\nmain()
n = int(input())\nls = list(map(int, input().split()))\n\nmsf = 0\nres = []\nfor e in ls:\n    v = msf + e\n    msf = max(msf, v)\n    res.append(v)\n\nfor e in res:\n    print(e, end=' ')\n
n=int(input())\nfor x in range(n):\n    l=int(input())\n    ar=input()\n    a=int(ar[0])\n    b=int(ar[1:])\n    if(a<b):\n        print("YES")\n        print(2)\n        print(a,b)\n    else:\n        print("NO")
n = int(input())\n\nbestP = 10**9\nsol = 0\nfor i in range(0, n):\n    a, p = list(map(int, input().split()))\n\n    bestP = min(bestP, p)\n    sol += a * bestP\n\nprint(sol)\n
mod = 1000000007\neps = 10**-9\ninf = 10**9\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    class Bit:\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << (self.size.bit_length() - 1)\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    adj = [[] for _ in range(N+1)]\n\n    AA = sorted(list(set(A)))\n    a2i = {a:i for i, a in enumerate(AA)}\n\n    AI = [[] for _ in range(len(AA))]\n    for i, a in enumerate(A):\n        ii = a2i[a]\n        AI[ii].append(i+1)\n    bit_high = Bit(N)\n    for i_list in AI:\n        for i in i_list:\n            bit_high.add(i, 1)\n        for i in i_list:\n            val = bit_high.sum(i)\n            il = bit_high.lower_bound(val - 1)\n            ir = bit_high.lower_bound(val + 1)\n            if il > 0:\n                adj[il].append(i)\n            if ir <= N:\n                adj[i].append(ir)\n\n    bit_low = Bit(N)\n    AI.reverse()\n    for i_list in AI:\n        for i in i_list:\n            bit_low.add(i, 1)\n        for i in i_list:\n            val = bit_low.sum(i)\n            il = bit_low.lower_bound(val - 1)\n            ir = bit_low.lower_bound(val + 1)\n            if il > 0:\n                adj[il].append(i)\n            if ir <= N:\n                adj[i].append(ir)\n\n    dp = [inf] * (N+1)\n    dp[1] = 0\n    for i in range(1, N+1):\n        for j in adj[i]:\n            dp[j] = min(dp[j], dp[i] + 1)\n    print(dp[N])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
from heapq import *\n\nN = int(input())\nprice = [int(i) for i in input().split()]\n\ntotal = 0\ninf = (10**6) + 1\nh = [inf]\n\n#Assume we bought and sold optimally for the first k prices.\n#We adjust our answer for the (k+1)th price that comes up.\nfor p in price:\n    if p > h[0]:\n        total += (p - heappop(h))\n        #We push p onto heap in case we should have bought at this price instead\n        #of selling.\n        heappush(h, p)\n    heappush(h, p)\n\nprint(total)
from math import sqrt\nfrom collections import Counter\n\n\ndef f(h, w, y, x):\n    return h * w * (h + w - (x + y + 1) * 2) // 2 + h * x * (x + 1) + w * y * (y + 1)\n\n\ndef check(h, w, y, x, cnt):\n    for i in range(1, y + 1):\n        for j in range(i + 1, i + x + 1):\n            cnt[j] -= 1\n        for j in range(i, i + w - x):\n            cnt[j] -= 1\n    for i in range(h - y):\n        for j in range(i + 1, i + x + 1):\n            cnt[j] -= 1\n        for j in range(i, i + w - x):\n            cnt[j] -= 1\n    if any(cnt.values()):\n        return\n    print(f'{h} {w}\n{y+1} {int(x)+1}')\n    raise TabError\n\n\ndef getyx(h, w, tot, cnt):\n    b = (w - 1) * .5\n    c = h * (tot - h * (w * w - 2 * w * (1 - h) - 1) * .25)\n    for y in range((h + 3) // 2):\n        d = (c - h * y * (w * y - h * w + w))\n        if d >= 0:\n            x = b - sqrt(d) / h\n            if x.is_integer() and x >= 0.:\n                check(h, w, y, int(x), cnt.copy())\n\n\ndef main():\n    n, l = int(input()), list(map(int, input().split()))\n    cnt, r, R, tot = Counter(l), 1, max(l), sum(l)\n    for r in range(1, R + 1):\n        if cnt[r] < r * 4:\n            break\n    try:\n        for h in range(r * 2 - 1, int(sqrt(n)) + 1):\n            if not n % h:\n                w = n // h\n                if f(h, w, h // 2, w // 2) <= tot <= f(h, w, 0, 0):\n                    getyx(h, w, tot, cnt)\n    except TabError:\n        return\n    print(-1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(input())\ndef inpl(): return list(map(int, input().split()))\ndef inpl_str(): return list(input().split())\n\nN = inp()\naa = inpl()\nQ = inp()\n\ntmp = 0\nruiseki = [0]\nfor a in aa:\n    tmp += a\n    ruiseki.append(tmp)\n\nfor q in range(Q):\n    l,r = inpl()\n    print((ruiseki[r]-ruiseki[l-1])//10)\n
n,q=list(map(int,input().split()))\n\nA=list(map(int,input().split()))\n\n\nC=[0]*n\n\nfor i in range(q):\n    l,r=list(map(int,input().split()))\n    C[l-1]+=1\n    if(r!=n):\n        C[r]-=1\n\n\nfor i in range(1,n):\n    C[i]+=C[i-1]\n\nC.sort()\nA.sort()\n\nans=0\nfor i in range(n):\n    ans+=C[i]*A[i]\nprint(int(ans))\n
import sys\n\nsys.setrecursionlimit(10**6)\n\nans = 0\n\ndef solve():\n    n = int(input())\n    Adj = [[] for i in range(n)]\n\n    for i in range(n - 1):\n        ai, bi, ci = map(int, sys.stdin.readline().split())\n        Adj[ai].append((bi, ci))\n        Adj[bi].append((ai, ci))\n\n    dfs(n, Adj, -1, 0, 0)\n\n    print(ans)\n\ndef dfs(n, Adj, p, u, cost):\n    if u != 0 and len(Adj[u]) == 1:\n        nonlocal ans\n        ans = max(ans, cost)\n        return\n\n    for (v, c) in Adj[u]:\n        if p == v:\n            continue\n        dfs(n, Adj, u, v, cost + c)\n\ndef __starting_point():\n    solve()\n__starting_point()
n=int(input())\na=list(map(int,input().split()))\nr=[0]*(n+1)\nfor i in range(n):\n    d={}\n    v=-1\n    for j in range(i,n):\n        t=d.get(a[j],0)+1\n        d[a[j]]=t\n        if t>v or t==v and a[j]<m:\n            v=t\n            m=a[j]\n        r[m]+=1\nprint(' '.join(map(str,r[1:])))
nCells, nQueries = list(map(int, input().split()))\nqueries = list(map(int, input().split()))\nseen = [False] * 100002\nbad = set()\nfor q in queries:\n    if not seen[q]:\n        seen[q] = True\n        bad.add((q, q))\n    if seen[q - 1]:\n        bad.add((q - 1, q))\n    if seen[q + 1]:\n        bad.add((q + 1, q))\nprint((nCells - 1) * 2 + nCells - len(bad))\n
n = int(input())\n\nfriends = dict()\n\nfor _ in range(n):\n    line = input().strip().split()\n    if line[0] not in friends:\n        friends[line[0]] = set()\n    for i in range(2, len(line)):\n        friends[line[0]].add(line[i])\n\ndef order(S):\n    S2 = [(len(e),e) for e in S]\n    S2.sort()\n\n    real = set()\n\n    for i in range(len(S2)):\n        d,e = S2[i]\n        flag = True\n        for j in range(i+1, len(S2)):\n            x = S2[j][1]\n            if x[-d:] == e:\n                flag = False\n                break\n        if flag:\n            real.add(e)\n    return real\n\nprint(len(friends))\nfor f in friends:\n    nums = order(friends[f])\n    st = ' '.join(nums)\n    print(f + ' ' + str(len(nums)) + ' ' + st)\n
n = sum(list(map(int, input().split())))\n\nA = [0 for i in range(n)]\n\nDP = [[0 for i in range(3)] for i in range(n)]\n\nfor i in range(3):\n	for j in map(int, input().split()):\n		A[j - 1] = i\n\nDP[0] = [A[0] != i for i in range(3)]\n\nfor i in range(1, n):\n	DP[i][0] = DP[i - 1][0] + (A[i] != 0)\n	DP[i][1] = min(DP[i - 1][0], DP[i - 1][1]) + (A[i] != 1)\n	DP[i][2] = min(DP[i - 1]) + (A[i] != 2)\n\nprint(min(DP[n - 1]))
P = 10**9 + 7\n\nn, k = list(map(int, input().split()))\n\nprint(n + 1 if k == 1 else (k * pow(2 * k - 1, n, P) - pow(k, n, P)) * pow(k - 1, P - 2, P) % P)\n
def ispalin(s):\n    ans = True\n    for i in range(len(s)):\n        if s[i] != s[len(s)-1-i]:\n            ans = False\n            break\n        if i > len(s)//2:\n            break\n    return ans\n\nfor _ in range(int(input())):\n    s = input()\n    k = ''\n    l = ''\n    for j in range(len(s)):\n        if s[j] == s[len(s)-1-j]:\n            k += s[j]\n            l = s[j] + l\n        else:\n            break\n    if j != len(s)-1:\n        t = ''\n        y = ''\n        for r in range(j,len(s)-j):\n            t += s[r]\n            if ispalin(t):\n                y = t\n        q = ''\n        v = ''\n        for r in range(len(s)-j-1,j-1,-1):\n            q = s[r] + q\n            if ispalin(q):\n                v = q\n        if len(v) > len(y):\n            print(k+v+l)\n        else:\n            print(k+y+l)\n    else:\n        print(s)\n
# import getpass\nimport sys\nimport math\n\nEPS = 0.000000001\n\nfiles = True\ndebug = False\n\n# if getpass.getuser() == 'frohenk' and files:\n#     debug = True\n#     sys.stdin = open("test.in")\n#     # sys.stdout = open('test.out', 'w')\n# elif files:\n#     # fname = "gift"\n#     # sys.stdin = open("%s.in" % fname)\n#     # sys.stdout = open('%s.out' % fname, 'w')\n#     pass\n\n\ndef lcm(a, b):\n    return a * b // math.gcd(a, b)\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\ndef range_sum(a, b):\n    ass = (((b - a + 1) // 2) * (a + b))\n    if (a - b) % 2 == 0:\n        ass += (b - a + 2) // 2\n    return ass\n\n\ndef comba(n, x):\n    return (math.factorial(n) // math.factorial(n - x)) // math.factorial(x)\n\n\ndef eq(a, b):\n    return abs(a - b) <= EPS\n\n\nn, ta = ria()\nvs = ria()\nts = ria()\nks = []\nup = 0\ndown = sum(vs)\nfor i in range(n):\n    ks.append((ts[i], vs[i]))\n    up += ts[i] * vs[i]\nks.sort()\nif up / down > ta:\n\n    if min(ts)>ta:\n        print('0')\n        return\n\n    ks = list(reversed(ks))\n\n    for t, v in ks:\n        if down == 0:\n            print(0)\n            return\n        if eq(up / down, ta):\n            print(down)\n            return\n        if (up - t * v) / (down - v) > ta or eq((up - t * v) / (down - v), ta):\n            up -= t * v\n            down -= v\n            continue\n\n        l, r = 0, v\n\n        up -= t * v\n        down -= v\n\n        while r - l > EPS:\n            m = (l + r)/2\n            if (up + t * m) / (down + m)>ta:\n                r=m\n            else:\n                l=m\n        print(down+l)\n        return\n\n\nelse:\n\n    if max(ts) < ta:\n        print('0')\n        return\n    for t, v in ks:\n        if down == 0:\n            print(0)\n            return\n        if eq(up / down, ta):\n            print(down)\n            return\n        if (up - t * v) / (down - v) < ta or eq((up - t * v) / (down - v), ta):\n            up -= t * v\n            down -= v\n            continue\n\n        l, r = 0, v\n\n        up -= t * v\n        down -= v\n\n        while r - l > EPS:\n            m = (l + r)/2\n            if (up + t * m) / (down + m)<ta:\n                r=m\n            else:\n                l=m\n        print(down+l)\n        return\n
input()\nt = list(map(int, input().split()))\ns, m = 0, 1000000007\np = {i for i, q in enumerate(t, 1) if q == -1}\nn, k = len(p), len(p - set(t))\nd, c = 2 * (n & 1) - 1, 1\nfor j in range(n + 1):\n    d = -d * max(1, j) % m\n    if n - j <= k:\n        s += c * d\n        c = c * max(1, n - j) * pow(k - n + j + 1, m - 2, m) % m\nprint(s % m)
n = int(input())\nprint(n - 1 if sum(map(int, input().split())) % n else n)
def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\n\n# A. Company Merging\nn = ii()\nc = []\nfor i in range(n):\n    a = li()[1:]\n    c.append(a)\nmx = max(max(e) for e in c)\nans = sum((mx - max(e)) * len(e) for e in c)\nprint(ans)\n
def resolve():\n    H, W, D = list(map(int, input().split()))\n    A = [list(map(int, input().split())) for _ in range(H)]\n    Q = int(input())\n    LR = [list(map(int, input().split())) for _ in range(Q)]\n\n    num_to_pos = {}\n    for i in range(H):\n        for j in range(W):\n            num_to_pos[A[i][j]] = (i, j)\n    \n    acc = [[0] for _ in range(D+1)]\n    for i in range(1, D+1):\n        num = i\n        idx = 0\n        while num + D <= H*W:\n            _from = num_to_pos[num]\n            _to = num_to_pos[num+D]\n            acc[i].append(acc[i][idx]+abs(_from[0]-_to[0])+abs(_from[1]-_to[1]))\n            num += D\n            idx += 1\n    \n    # print(acc)\n    for lr in LR:\n        l, r = lr\n        series = l%D if l%D != 0 else D\n        # print("---")\n        # print(series)\n        # print(l, r)\n        print((acc[series][(r-series)//D] - acc[series][(l-series)//D]))\n            \n\n\n\nif '__main__' == __name__:\n    resolve()\n
class Factorial:\n    def __init__(self, max_fact, mod):\n        #mod should be prime number\n        #using homogeneous_product(n,r), max_fact ≧ max(n+r-1)\n        f = [1] * (max_fact + 1)\n        for idx in range(2, max_fact + 1):\n            f[idx] = f[idx - 1] * idx\n            f[idx] %= mod\n        fi = [pow(f[-1], mod - 2, mod)]\n        for idx in range(max_fact, 0, -1):\n            fi += [fi[-1] * idx % mod]\n        fi = fi[::-1]\n        self.mod = mod\n        self.f = f\n        self.fi = fi\n\n    def factorial(self, n):\n        return self.f[n]\n\n    def factorial_inverse(self, n):\n        return self.fi[n]\n\n    def combination(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n] * fi[r] * fi[n - r] % self.mod\n\n    def permutation(self, n, r):\n        return self.f[n] * self.fi[n - r] % self.mod\n\n    def homogeneous_product(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n + r - 1] * fi[r] * fi[n - 1] % self.mod\n\n\nmax_fact = 5*10**5\nmod = 10**9 + 7\nfact_instance = Factorial(max_fact, mod)\ncomb = fact_instance.combination\nperm = fact_instance.permutation\n\nN, M = [int(_) for _ in input().split()]\nans = 0\nfor p in range(N + 1):\n    ans += (-1)**p * comb(N, p) * perm(M - p, N - p)\n    ans %= mod\nans *= perm(M, N)\nans %= mod\nprint(ans)\n
a = int(input())\nif a%6 == 0 or a%6==1 or a%6 == 3:\n print("yes")\nelse:\n print("no")
n, m = map(int, input().split())\nd = { }\nfor i in range(m):\n    a, b = input().split()\n    d[a] = b if len(b) < len(a) else a\nfor word in input().split():\n    print(d[word], end=' ')\nprint()\n
import sys\n\nn = int(sys.stdin.readline())\nl = [int(x) for x in sys.stdin.readline().split(' ')]\n\nind = sorted(list(range(len(l))), key=lambda x: l[x])\nh = l[ind[0]] - 1\nfor i in ind:\n    if l[i] <= h:\n        l[i] = h+1\n        h += 1\n    else:\n        h = l[i]\nprint(" ".join([str(x) for x in l]))\n
n = int(input())\narr = sorted(list(map(int, input().split())))\n\nans = 0\nfor i in range(n):\n    ans += abs (arr[i] - i - 1)\nprint (ans)\n
n = int(input()) + 1\na = list(map(int, input().split())) + [1 << 50]\nl, p, r = [0] * n, list(range(n)), []\n\nfor i in range(int(input())):\n    t = list(map(int, input().split()))\n    if t[0] == 2:\n        r.append(l[t[1] - 1])\n    else:\n        x = t[1] - 1\n        s, d = [x], t[2]\n        while True:\n            if p[x] != x:\n                x = p[x]\n                s.append(x)\n                continue\n            if l[x] + d < a[x]:\n                l[x] += d\n                break\n            d -= a[x] - l[x]\n            l[x] = a[x]\n            x += 1\n            s.append(x)\n        for j in s:\n            p[j] = x\n        \nprint('\n'.join(map(str, r)))
import sys\nfrom collections import Counter\ndef input():\n	return sys.stdin.readline()[:-1]\n\nMOD = 998244353\nn = int(input())\nfact = [1]\nfor i in range(1, n+1):\n	fact.append((fact[-1]*i)%MOD)\n\nseq = []\nca, cb = Counter(), Counter()\nfor _ in range(n):\n	a, b = map(int, input().split())\n	ca[a] += 1\n	cb[b] += 1\n	seq.append((a, b))\n\nans = fact[n]\nans %= MOD\n#print(ans)\n\nres = 1\nfor v in ca.values():\n	res *= fact[v]\n	res %= MOD\nans -= res\nans %= MOD\n#print(ans)\n\nres = 1\nfor v in cb.values():\n	res *= fact[v]\n	res %= MOD\nans -= res\n#print(ans)\n\nseq.sort(key=lambda x: (x[0], x[1]))\ncur = seq[0][0]\nres = 1\nM = 1\nctmp = Counter()\nfor i in range(n):\n	if seq[i][0] == cur:\n		ctmp[seq[i][1]] += 1\n		M = max(M, seq[i][1])\n	else:\n		if seq[i][1] < M:\n			res = 0\n			break\n		tmp = 1\n		for v in ctmp.values():\n			tmp *= fact[v]\n			tmp %= MOD\n		res *= tmp\n		res %= MOD\n		ctmp = Counter()\n		ctmp[seq[i][1]] += 1\n		cur = seq[i][0]\n		M = max(M, seq[i][1])\ntmp = 1\nfor v in ctmp.values():\n	tmp *= fact[v]\n	tmp %= MOD\nres *= tmp\nres %= MOD\n\nans += res\nans %= MOD\nprint(ans)
t = int(input())\nfor _ in range(t):\n    A, B = list(map(int, input().split()))\n    b = -1\n    B += 1\n    while B:\n        b += 1\n        B //= 10\n    print(A*b)\n
n = int(input())\na = list(map(int, input().split()))[::-1]\nb = list(map(int, input().split()))\nans = [0] * n\nmarked = [True] * (n + 1)\nfor i in range(n):\n    if marked[b[i]]:\n        while True:\n            marked[a[-1]] = False\n            ans[i] += 1\n            if a[-1] == b[i]:\n                a.pop()\n                break\n            a.pop()\n    else:\n        continue\nprint(*ans)
import math,string,itertools,fractions,heapq,collections,re,array,bisect\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict\n\ndef VI(): return list(map(int,input().split()))\ndef I(): return int(input())\ndef LIST(n,m=None): return [0]*n if m is None else [[0]*m for i in range(n)]\ndef ELIST(n): return [[] for i in range(n)]\ndef MI(n=None,m=None): # input matrix of integers\n    if n is None: n,m = VI()\n    arr = LIST(n)\n    for i in range(n): arr[i] = VI()\n    return arr\ndef MS(n=None,m=None): # input matrix of strings\n    if n is None: n,m = VI()\n    arr = LIST(n)\n    for i in range(n): arr[i] = input()\n    return arr\ndef MIT(n=None,m=None): # input transposed matrix/array of integers\n    if n is None: n,m = VI()\n    # a = MI(n,m)\n    arr = LIST(m,n)\n    for i in range(n):\n        v = VI()\n        for j in range(m):\n            arr[j][i] = v[j]\n    # for i,l in enumerate(a):\n    #     for j,x in enumerate(l):\n    #         arr[j][i] = x\n    return arr\n\n\n\n\ndef run2(n,m,u,v,w,x):\n    # correct, but time limit exceeded.\n    g = ELIST(n+1) # list of vertices; Adjacency list\n    for i in range(m):\n        g[u[i]].append((v[i],w[i],i+1))\n        g[v[i]].append((u[i],w[i],i+1))\n    # index priority queue with deque and priorities\n    pq = []\n    marked = [False] * (n+1)\n    pq.append((0,0,x,0))\n    sg = []\n    wmax = -w[-1] # to fix the issue that start doesn't have edge weight\n    while len(pq)!=0:\n        wi,lw,i,ei = heapq.heappop(pq)\n        if not marked[i]:\n            marked[i] = True\n            sg.append(ei)\n            wmax += w[ei-1]\n            #print(i,wi,ei, wmax)\n            for j,wj,ej in g[i]:\n                if not marked[j]:\n                    heapq.heappush(pq, (wi+wj,wj,j,ej))\n    sg = sg[1:]\n    print(wmax)\n    for i in sg:\n        print(i,end=" ")\n    print()\ndef main2(info=0):\n    n,m = VI()\n    u,v,w = MIT(m,3)\n    x = I()\n    run(n,m,u,v,w,x)\n\n\ndef run(n,m,g,x):\n    pq = [(0,0,x,0)]\n    marked = [False] * (n+1)\n    sg = []\n    wtot = 0\n    while len(pq)!=0:\n        wi,lw,i,ei = heapq.heappop(pq)\n        if not marked[i]:\n            marked[i] = True\n            sg.append(str(ei))\n            wtot += lw\n            for j,wj,ej in g[i]:\n                if not marked[j]:\n                    heapq.heappush(pq, (wi+wj,wj,j,ej))\n    print(wtot)\n    print(" ".join(sg[1:]))\ndef main(info=0):\n    n,m = VI()\n    g = ELIST(n+1)\n    for i in range(m):\n        u,v,w = VI()\n        g[u].append((v,w,i+1))\n        g[v].append((u,w,i+1))\n    x = I()\n    run(n,m,g,x)\n\ndef __starting_point():\n    main()\n\n__starting_point()
n=int(input())\nprint(n*n//2+n*n%2)\nfor i in range(n):\n    if i %2==1:\n        print('.C'*(n//2)+'.'*(n%2))\n    else:\n        print('C.'*(n//2)+'C'*(n%2))
a, d = list(map(float, input().split()))\nn = int(input())\n\ndef coordinates(s):\n    if s <= a:\n        return (s, 0)\n    elif s <= 2*a:\n        return (a, s-a)\n    elif s <= 3*a:\n        return (3*a - s, a)\n    else:\n        return (0, 4*a - s)\n\nfor i in range(1, n+1):\n    print("%f %f" % coordinates(i*d % (4*a)))\n
n=int(input())\nfor i in range(n):\n    s=list(input())\n    s=[int(i) for i in s]\n    try:\n        s.remove(0)\n        x=sum(s)\n        if x%3==0:\n            if len([i for i in s if i%2==0])>0:\n                print("red")\n            else:\n                print("cyan")\n        else:\n            print("cyan")\n    except:\n        print("cyan")\n
print(6 - sum(map(int, input().split())))
f =['!x&x', '!(x|y|z)', '!x&!y&z', '!x&!y', '!x&!z&y', '!x&!z', '!(!y&!z|x|y&z)', '!(x|y&z)', '!x&y&z', '!(!y&z|!z&y|x)', '!x&z', '!(!z&y|x)', '!x&y', '!(!y&z|x)', '!x&(y|z)', '!x', '!y&!z&x', '!y&!z', '!(!x&!z|x&z|y)', '!(x&z|y)', '!(!x&!y|x&y|z)', '!(x&y|z)', '!(!x&!y|x&y|z)|!x&!y&z', '!((x|y)&z|x&y)', '!x&y&z|!y&!z&x', '!x&y&z|!y&!z', '!x&z|!y&!z&x', '!x&z|!y&!z', '!x&y|!y&!z&x', '!x&y|!y&!z', '!x&(y|z)|!y&!z&x', '!x|!y&!z', '!y&x&z', '!(!x&z|!z&x|y)', '!y&z', '!(!z&x|y)', '!x&!z&y|!y&x&z', '!x&!z|!y&x&z', '!x&!z&y|!y&z', '!x&!z|!y&z', '!x&y&z|!y&x&z', '!(!x&z|!z&x|y)|!x&y&z', '!(x&y)&z', '!(!z&x|y)|!x&z', '!x&y|!y&x&z', '!(!y&z|x)|!y&x&z', '!x&y|!y&z', '!x|!y&z', '!y&x', '!(!x&z|y)', '!y&(x|z)', '!y', '!x&!z&y|!y&x', '!x&!z|!y&x', '!x&!z&y|!y&(x|z)', '!x&!z|!y', '!x&y&z|!y&x', '!(!x&z|y)|!x&y&z', '!x&z|!y&x', '!x&z|!y', '!x&y|!y&x', '!(!x&!y&z|x&y)', '!x&(y|z)|!y&x', '!x|!y', '!z&x&y', '!(!x&y|!y&x|z)', '!x&!y&z|!z&x&y', '!x&!y|!z&x&y', '!z&y', '!(!y&x|z)', '!x&!y&z|!z&y', '!x&!y|!z&y', '!x&y&z|!z&x&y', '!(!x&y|!y&x|z)|!x&y&z', '!x&z|!z&x&y', '!(!z&y|x)|!z&x&y', '!(x&z)&y', '!(!y&x|z)|!x&y', '!x&z|!z&y', '!x|!z&y', '!z&x', '!(!x&y|z)', '!x&!y&z|!z&x', '!x&!y|!z&x', '!z&(x|y)', '!z', '!x&!y&z|!z&(x|y)', '!x&!y|!z', '!x&y&z|!z&x', '!(!x&y|z)|!x&y&z', '!x&z|!z&x', '!(!x&!z&y|x&z)', '!x&y|!z&x', '!x&y|!z', '!x&(y|z)|!z&x', '!x|!z', '!y&x&z|!z&x&y', '!(!x&y|!y&x|z)|!y&x&z', '!y&z|!z&x&y', '!(!z&x|y)|!z&x&y', '!y&x&z|!z&y', '!(!y&x|z)|!y&x&z', '!y&z|!z&y', '!(!y&!z&x|y&z)', '!x&y&z|!y&x&z|!z&x&y', '!(!x&y|!y&x|z)|!x&y&z|!y&x&z', '!(x&y)&z|!z&x&y', '!(!z&x|y)|!x&z|!z&x&y', '!(x&z)&y|!y&x&z', '!(!y&x|z)|!x&y|!y&x&z', '!(x&y)&z|!z&y', '!x|!y&z|!z&y', '!(y&z)&x', '!(!x&y|z)|!y&x', '!y&z|!z&x', '!y|!z&x', '!y&x|!z&y', '!y&x|!z', '!y&(x|z)|!z&y', '!y|!z', '!(y&z)&x|!x&y&z', '!(!x&y|z)|!x&y&z|!y&x', '!(x&y)&z|!z&x', '!x&z|!y|!z&x', '!(x&z)&y|!y&x', '!x&y|!y&x|!z', '!x&y|!y&z|!z&x', '!(x&y&z)', 'x&y&z', '!(x|y|z)|x&y&z', '!x&!y&z|x&y&z', '!x&!y|x&y&z', '!x&!z&y|x&y&z', '!x&!z|x&y&z', '!(!y&!z|x|y&z)|x&y&z', '!(x|y&z)|x&y&z', 'y&z', '!(x|y|z)|y&z', '!x&z|y&z', '!x&!y|y&z', '!x&y|y&z', '!x&!z|y&z', '!x&(y|z)|y&z', '!x|y&z', '!y&!z&x|x&y&z', '!y&!z|x&y&z', '!(!x&!z|x&z|y)|x&y&z', '!(x&z|y)|x&y&z', '!(!x&!y|x&y|z)|x&y&z', '!(x&y|z)|x&y&z', '!(!x&!y|x&y|z)|!x&!y&z|x&y&z', '!((x|y)&z|x&y)|x&y&z', '!y&!z&x|y&z', '!y&!z|y&z', '!x&z|!y&!z&x|y&z', '!(x&z|y)|y&z', '!x&y|!y&!z&x|y&z', '!(x&y|z)|y&z', '!x&(y|z)|!y&!z&x|y&z', '!x|!y&!z|y&z', 'x&z', '!(x|y|z)|x&z', '!y&z|x&z', '!x&!y|x&z', '!x&!z&y|x&z', '!x&!z|x&z', '!x&!z&y|!y&z|x&z', '!(x|y&z)|x&z', '(x|y)&z', '!(x|y|z)|(x|y)&z', 'z', '!x&!y|z', '!x&y|x&z', '!(!y&z|x)|x&z', '!x&y|z', '!x|z', '!y&x|x&z', '!y&!z|x&z', '!y&(x|z)|x&z', '!y|x&z', '!x&!z&y|!y&x|x&z', '!(x&y|z)|x&z', '!x&!z&y|!y&(x|z)|x&z', '!x&!z|!y|x&z', '!y&x|y&z', '!(!x&z|y)|y&z', '!y&x|z', '!y|z', '!x&y|!y&x|x&z', '!x&!z|!y&x|y&z', '!x&y|!y&x|z', '!x|!y|z', 'x&y', '!(x|y|z)|x&y', '!x&!y&z|x&y', '!x&!y|x&y', '!z&y|x&y', '!x&!z|x&y', '!x&!y&z|!z&y|x&y', '!(x|y&z)|x&y', '(x|z)&y', '!(x|y|z)|(x|z)&y', '!x&z|x&y', '!(!z&y|x)|x&y', 'y', '!x&!z|y', '!x&z|y', '!x|y', '!z&x|x&y', '!y&!z|x&y', '!x&!y&z|!z&x|x&y', '!(x&z|y)|x&y', '!z&(x|y)|x&y', '!z|x&y', '!x&!y&z|!z&(x|y)|x&y', '!x&!y|!z|x&y', '!z&x|y&z', '!(!x&y|z)|y&z', '!x&z|!z&x|x&y', '!x&!y|!z&x|y&z', '!z&x|y', '!z|y', '!x&z|!z&x|y', '!x|!z|y', '(y|z)&x', '!(x|y|z)|(y|z)&x', '!y&z|x&y', '!(!z&x|y)|x&y', '!z&y|x&z', '!(!y&x|z)|x&z', '!y&z|!z&y|x&y', '!x&!y|!z&y|x&z', '(x|y)&z|x&y', '!(x|y|z)|(x|y)&z|x&y', 'x&y|z', '!x&!y|x&y|z', 'x&z|y', '!x&!z|x&z|y', 'y|z', '!x|y|z', 'x', '!y&!z|x', '!y&z|x', '!y|x', '!z&y|x', '!z|x', '!y&z|!z&y|x', '!y|!z|x', 'x|y&z', '!y&!z|x|y&z', 'x|z', '!y|x|z', 'x|y', '!z|x|y', 'x|y|z', '!x|x']\nn = int(input())\nfor i in range(n):\n    s = input()\n    a = 0\n    for j in range(8):\n        a += int(s[j] == '1') << j\n\n    print(f[a])\n
import sys\nimport math\nfrom collections import defaultdict\nfrom collections import deque\nfrom itertools import combinations\nfrom itertools import permutations\ninput = lambda : sys.stdin.readline().rstrip()\nread = lambda : list(map(int, input().split()))\ndef write(*args, sep="\n"):\n  for i in args:\n    sys.stdout.write("{}{}".format(i, sep))\nINF = float('inf')\nMOD = int(1e9 + 7)\n\nfor _ in range(int(input())):\n  n = int(input())\n  a = list(read())\n  b = list(read())\n\n  arr = []\n  for i in range(n):\n    if a[i] != b[i]:\n      arr.append((i, b[i] - a[i]))\n\n  \n  flag = True \n  s = []\n  for i, j in arr:\n    if j <= 0:\n      flag = False\n      break \n    s.append(j)\n  \n  for i in range(1, len(arr)):\n    if arr[i][0] != arr[i-1][0] + 1:\n      flag = False \n      break \n  \n  if len(set(s)) >= 2:\n    flag = False \n\n  if flag:\n    print("YES")\n  else:\n    print("NO")\n  \n
import sys\n\n\nu = []\nt = set()\n\np1 = 127\nm1 = 1000000007\n\np2 = 131\nm2 = 1000000009\n\npow1 = [1] + [0] * 600005\npow2 = [1] + [0] * 600005\n\nfor i in range(1, 600005):\n    pow1[i] = (pow1[i-1] * p1) % m1\n    pow2[i] = (pow2[i-1] * p2) % m2\n\ndef hash1(n):\n    hsh = 0\n    for i in range(len(n)):\n        hsh += pow1[i] * ord(n[i])\n        hsh %= m1\n    return hsh % m1\n\ndef hash2(n):\n    hsh = 0\n    for i in range(len(n)):\n        hsh += pow2[i] * ord(n[i])\n        hsh %= m2\n    return hsh % m2\n\na,b = list(map(int,sys.stdin.readline().split()))\n\ndef trans(n):\n    a = hash1(n)\n    b = hash2(n)\n    cyc = ['a', 'b', 'c']\n    for i in range(len(n)):\n        for x in range(3):\n            if cyc[x] == n[i]:\n                h11 = a - ord(n[i]) * pow1[i] + ord(cyc[(x+1)%3]) * pow1[i]\n                h12 = b - ord(n[i]) * pow2[i] + ord(cyc[(x+1)%3]) * pow2[i]\n                h21 = a - ord(n[i]) * pow1[i] + ord(cyc[(x+2)%3]) * pow1[i]\n                h22 = b - ord(n[i]) * pow2[i] + ord(cyc[(x+2)%3]) * pow2[i]\n                t.add((h11%m1)*m2 + h12%m2)\n                t.add((h21%m1)*m2 + h22%m2)\n\nfor i in range(a):\n    trans(sys.stdin.readline())\n\nfor j in range(b):\n    inpt = sys.stdin.readline()\n    if hash1(inpt)*m2 + hash2(inpt) in t:\n        print("YES")\n    else:\n        print("NO")\n
import sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n\n    out = 0\n    l = list(map(int, input().split()))\n    for i in range(n - 1):\n        out += max(0, l[i] - l[i + 1])\n    print(out)\n
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\nmii=lambda:list(map(int,input().split()))\n\nn=int(input())\n\nl1=[]\nl2=[]\n\nfor i in range(n):\n    a,b=mii()\n    if a<b:\n        l1.append((-a,b,i))\n    else:\n        l2.append((a,b,i))\n\nif len(l1)>len(l2):\n    l1.sort()\n    print(len(l1))\n    print(" ".join([str(x[2]+1) for x in l1]))\nelse:\n    l2.sort()\n    print(len(l2))\n    print(" ".join([str(x[2]+1) for x in l2]))\n
#!/usr/local/bin/python3\n\nfrom collections import defaultdict\nimport heapq\n\nnum_nodes, num_edges = list(map(int, input().split()))\n\nins = defaultdict(set)\nout = defaultdict(int)\n\nfor _ in range(num_edges):\n    node_out, node_in = list(map(int, input().split()))\n    ins[node_in].add(node_out)\n    out[node_out] += 1\n\nzeros = [-node for node in range(num_nodes, 0, -1) if out[node] == 0]\n\nfinal_mappings = {}\ncurrent_index = num_nodes\n\nwhile current_index > 0:\n\n    node = -heapq.heappop(zeros)\n    final_mappings[node] = current_index\n    current_index -= 1\n\n    for node_out in ins[node]:\n        out[node_out] -= 1\n        if out[node_out] == 0:\n            heapq.heappush(zeros, -node_out)\n    \nprint(' '.join(str(final_mappings[node]) for node in range(1, num_nodes + 1)))\n
def f(n):\n    Ans = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            Ans.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        Ans.append(n)\n    return Ans\n\n\nn, k = list(map(int, input().split()))\narr = list(map(int, input().split()))\n\nm = {}\nc = 0\nfor i in arr:\n    r = {}\n    d = 2\n    while d * d <= i:\n        if i % d == 0:\n            r[d] = (r.get(d, 0) + 1) % k\n            i //= d\n        else:\n            d += 1\n    if i > 1:\n        r[i] = (r.get(i, 0) + 1) % k\n    r = tuple([x for x in list(r.items()) if x[1]])\n    r2 = tuple([(x[0], k - x[1]) for x in r])\n    c += m.get(r2, 0)\n    m[r] = m.get(r, 0) + 1\nprint(c)\n
n=int(input())\ns=input()\n\nN=n\n\nN0 = 2**(N-1).bit_length()\ndata = [n]*(2*N0)\nINF = n\n# 区間[l, r+1)の値をvに書き換える\n# vは(t, value)という値にする (新しい値ほどtは大きくなる)\ndef update(l, r, v):\n    L = l + N0; R = r + N0\n    while L < R:\n        if R & 1:\n            R -= 1\n            data[R-1] = min(v,data[R-1])\n\n        if L & 1:\n            data[L-1] = min(v,data[L-1])\n            L += 1\n        L >>= 1; R >>= 1\n# a_iの現在の値を取得\ndef _query(k):\n    k += N0-1\n    s = INF\n    while k >= 0:\n        if data[k]:\n            s = min(s, data[k])\n        k = (k - 1) // 2\n    return s\n# これを呼び出す\ndef query(k):\n    return _query(k)\n\nalice=[int(s[i]=="0") for i in range(n)]\nbob=[int(s[i]=="1") for i in range(n)]\nfor i in range(1,n):\n    alice[i]+=alice[i-1]\n    bob[i]+=bob[i-1]\nalice.append(0)\nbob.append(0)\n\nupdate_que=[[] for i in range(n)]\n\nalice_win=[]\nid=0\nwhile id<n:\n    if s[id]!="0":\n        pos=id\n        while pos<n and s[pos]!="0":\n            pos+=1\n        update_que[pos-id-1].append(id)\n        id=pos\n    else:\n        id+=1\nbob_win=[]\nid=0\nwhile id<n:\n    if s[id]!="1":\n        pos=id\n        while pos<n and s[pos]!="1":\n            pos+=1\n        update_que[pos-id-1].append(id)\n        id=pos\n    else:\n        id+=1\n\n\nans=[0]*n\nfor i in range(n-1,-1,-1):\n    for id in update_que[i]:\n        update(0,id+1,id)\n    pos=0\n    res=0\n    while pos<n-i:\n        check1=alice[pos+i]-alice[pos-1]\n        check2=bob[pos+i]-bob[pos-1]\n        if not check1 or not check2:\n            res+=1\n            pos+=i+1\n        else:\n            npos=query(pos)\n            if query(pos)==n:\n                break\n            else:\n                pos=npos+i+1\n                res+=1\n    ans[i]=res\n\nprint(*ans)\n
n = int(input())\np = [list(map(int, input().split())) for i in range(n)]\nt = [[0] * n for i in range(n)]\nfor i in range(n):\n    t[i][i], p[i][i] = p[i][i], 0\n    for j in range(i + 1, n):\n        t[j][i] = t[i][j] = d = (p[i][j] + p[j][i]) / 2\n        p[i][j] -= d\n        p[j][i] -= d\nfor i in t: print(' '.join(map(str, i)))\nfor i in p: print(' '.join(map(str, i)))\n\n
import sys\ninput = sys.stdin.readline\n\nfrom collections import deque\n\nn, m = list(map(int, input().split()))\n\nback = [[] for i in range(n)]\n\nfor _ in range(m):\n    u, v, w = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    back[v].append((u,w))\n    \n\nout = [2] * n\noutl = [-1] * n\noutl[-1] = 0\n\nq = deque([n - 1])\nwhile q:\n    v = q.popleft()\n    for u, w in back[v]:\n        if out[u] != w:\n            out[u] = 1 - w\n        else:\n            if outl[u] == -1:\n                outl[u] = outl[v] + 1\n                q.append(u)\n                \nout = [v if v != 2 else 1 for v in out]\nprint(outl[0])\nprint(''.join(map(str,out)))\n        \n
class BIT():\n    def __init__(self,n):\n        self.BIT=[0]*(n+1)\n        self.num=n\n\n    def query(self,idx):\n        res_sum = 0\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        while idx <= self.num:\n            self.BIT[idx] += x\n            idx += idx&(-idx)\n        return\n\nn,q=map(int,input().split())\na=list(map(int,input().split()))\nbit=BIT(2**n)\nfor i in range(2**n):\n    bit.update(i+1,a[i])\nb=0\n\ndef Sum(r,xor):\n    id=xor\n    res=0\n    if r==-1:\n        return res\n    for i in range(n,-1,-1):\n        if r>>i &1:\n            L=(id>>i)<<i\n            R=L+(1<<i)-1\n            res+=bit.query(R+1)-bit.query(L)\n            id^=(1<<i)\n    return res\n\n\nfor _ in range(q):\n    query=tuple(map(int,input().split()))\n    if query[0]==1:\n        g,x,k=query\n        x-=1\n        x^=b\n        bit.update(x+1,k-a[x])\n        a[x]=k\n    elif query[0]==2:\n        k=query[1]\n        b^=2**k-1\n    elif query[0]==3:\n        k=query[1]\n        if k!=n:\n            b^=2**k\n    else:\n        gl,l,r=query\n        l-=1\n        test=Sum(r,b)-Sum(l,b)\n        print(test)
t = int(input())\nfor _ in range(t):\n	x,y = map(int,input().split())\n	a,b = map(int,input().split())\n	wynik = 0\n	if b <= 2*a:\n		c = min(x,y)\n		wynik += b*c\n		wynik += (max(x,y)-c)*a\n	else:\n		wynik = a*(x+y)\n	print(wynik)
input()\na = list(map(int, input().split()))\nb = []\ni = j = 0\nwhile i < len(a):\n  while j < len(a) and a[j] == a[i]:\n    j += 1\n  if (j - i) % 2 == 1:\n    b += [a[i]]\n  i = j - (j - i) // 2\n  for k in range(i, j):\n    a[k] += 1\nprint(b[-1] - len(b) + 1)
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\nn,x=map(int,input().split())\n\ndef mult(a,b):\n    # compute a*b\n    c=[0]*128\n    for i in range(128):\n        for j in range(128):\n            c[i^j]+=a[i]*b[j]\n    return c\n\ndef quickpow(a,b):\n    # compute a**b\n    if b==1:\n        return a\n    if b&1:\n        return mult(quickpow(mult(a,a),b//2),a)\n    return quickpow(mult(a,a),b//2)\n\nprob=list(map(float,input().split()))\nprob+=[0.0]*(128-len(prob))\n\nprint("%.9f"%(1-quickpow(prob,n)[0]))
import sys; sys.setrecursionlimit(1000000)\ndef solve():\n    n, m, = rv()\n    s = list(input())\n    res = [0] * m\n    #replace dot:\n    #dot had nothing on left or right: nothing changes\n    #dot had one on left or right: -1\n    #dot had two on left or right: -2\n\n    #replace char:\n    #if had two chars on left and right: 0\n    # if had one char and one dot: +1\n    # if had two dots: +2\n    helper = list()\n    for i in range(n):\n        if s[i] == '.':\n            if i == 0:\n                helper.append(1)\n            else:\n                if s[i-1] == '.':\n                    helper[-1] += 1\n                else:\n                    helper.append(1)\n    initval = 0\n    for val in helper:\n        initval += val - 1\n    for query in range(m):\n        index, replace = input().split()\n        index = int(index) - 1\n        if (s[index] == '.' and replace == '.') or (s[index] != '.' and replace != '.'):\n            res[query] = initval\n        else:\n            sidedots = 0\n            if index > 0:\n                if s[index - 1] == '.': sidedots+=1\n            if index < n - 1:\n                if s[index + 1] == '.': sidedots+=1\n            if s[index] == '.':\n                res[query] = initval - sidedots\n                initval -= sidedots\n            else:\n                res[query] = initval + sidedots\n                initval += sidedots\n        s[index] = replace\n    print('\n'.join(map(str, res)))\n\n\n\n\ndef rv(): return list(map(int, input().split()))\ndef rl(n): return [list(map(int, input().split())) for _ in range(n)]\nif sys.hexversion == 50594544 : sys.stdin = open("test.txt")\nsolve()\n\n\n
q=int(input())\ns=input().split()\na=[int(s[1])]\nsum1=a[0]\npos=-1\nmean=sum1\nfin=''\nfor i in range(q-1):\n    n=len(a)\n    s=input().split()\n    if(s[0]=='1'):\n        a.append(int(s[1]))\n        sum1+=(a[-1]-a[-2])\n        mean=sum1/(pos+2)\n        n=len(a)\n    \n        #print(sum1,pos,i+1)\n        while(pos<n-2 and a[pos+1]<mean):\n            pos+=1\n            sum1+=a[pos]\n            \n            mean=sum1/(pos+2)\n        #print(sum1,pos,i+1)\n    else:\n        #print(sum1,pos)\n        fin+=str(a[-1]-mean) + '\n'\nprint(fin)\n\n\n
"""\nCodeforces Round 240 Div 1 Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\nclass InputHandlerObject(object):\n    inputs = []\n\n    def getInput(self, n = 0):\n        res = ""\n        inputs = self.inputs\n        if not inputs: inputs.extend(input().split(" "))\n        if n == 0:\n            res = inputs[:]\n            inputs[:] = []\n        while n > len(inputs):\n            inputs.extend(input().split(" "))\n        if n > 0:\n            res = inputs[:n]\n            inputs[:n] = []\n        return res\nInputHandler = InputHandlerObject()\ng = InputHandler.getInput\n\n############################## SOLUTION ##############################\nn,a,b = g()\nn,a,b = int(n),int(a),int(b)\nc = [int(x) for x in g()]\nr = []\nfor i in c:\n    r.append(str(((i*a) % b) // a))\nprint(" ".join(r))
destination, max_gas_tank_volume, gas_prices_number = list(map(int, input().split()))\nstart_point = 0\ngas_prices = {start_point:0}\nfor i in range(gas_prices_number):\n    coordinate, price = list(map(int, input().split()))\n    gas_prices[coordinate] = price\npoints = sorted(list(gas_prices.keys()), reverse = True)\ncurrent_point = start_point\ncount = 0\ngas_tank_volume = max_gas_tank_volume\nreachable_points = []\nwhile current_point != destination:\n    farthest_reachable_point = current_point + max_gas_tank_volume\n    while points and points[-1] <= farthest_reachable_point:\n        reachable_points.append(points.pop())\n    if reachable_points:\n        cheaper_reachable_points = sorted([point for point in reachable_points if gas_prices[point] < gas_prices[current_point]])\n        next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key = lambda point: gas_prices[point])\n        if farthest_reachable_point >= destination and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n            next_point = destination\n        else:\n            reachable_points = [point for point in reachable_points if point > next_point]\n    else:\n        if farthest_reachable_point >= destination:\n            next_point = destination\n        else:\n            count = -1\n            break\n    distantion = next_point - current_point\n    if next_point != destination and gas_prices[current_point] <= gas_prices[next_point]:\n        required_gas_volume = max_gas_tank_volume\n    else:\n        required_gas_volume = distantion\n    if required_gas_volume > gas_tank_volume:\n        count += (required_gas_volume - gas_tank_volume)*gas_prices[current_point]\n        gas_tank_volume = required_gas_volume\n    current_point = next_point\n    gas_tank_volume -= distantion\nprint(count)\n
#http://codeforces.com/contest/958/problem/C1\n\nN,p=list(map(int,input().split()))\nA=list(map(int,input().split()))\nsum1=A[0]\nsum2=sum(A[1:])\nans=(sum1%p)+(sum2%p)\nfor i in range(1,N-1):\n    sum1+=A[i]\n    sum2-=A[i]\n    ans1=sum1%p\n    ans2=sum2%p\n    ans=max(ans1+ans2,ans)\nprint(ans)
from collections import *\nh,q=list(map(int,input().split()))\nd=defaultdict(lambda:0)\nd[2**h]=0\nd[2**(h-1)]=0\nfor _ in range(q):\n	i,l,r,a=list(map(int,input().split()))\n	l,r=l*2**(h-i),(r+1)*2**(h-i)\n	if a:d[1]+=1;d[l]-=1;d[r]+=1\n	else:d[l]+=1;d[r]-=1\ns=0\nl=0\nD=sorted(d.items())\nfor (a,x),(b,_) in zip(D,D[1:]):\n	s+=x\n	if s==0:q=a;l+=b-a\nprint(("Game cheated!",q,"Data not sufficient!")[min(l,2)])\n
import sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor test in range(t):\n    if test:\n        input()\n    n, m = list(map(int, input().split()))\n    a = [-1] * m\n    b = [-1] * m\n\n    for i in range(m):\n        a[i], b[i] = list(map(int, input().split()))\n\n    l = [(a[i],0,i) for i in range(m)] + [(b[i],1,i) for i in range(m)]\n    l.sort(reverse = True)\n    \n    count = 0\n    tot = 0\n    best = 0\n    used = [False] * m\n    for good, typ, ind in l:\n        if typ == 0:\n            count += 1\n            tot += good\n            used[ind] = True\n            if count == n:\n                best = max(best, tot)\n                break\n        else:\n            curr = tot\n            curr += good * (n - count)\n            if not used[ind]:\n                curr -= good\n                curr += a[ind]\n            best = max(curr,best)\n    print(best)\n
n = int(input())\np = [int(i) for i in input().split()]\ns = [0] * n\nfor i in range(1,n):\n    s[i] = s[i-1] ^ i\nq = 0\nfor i in range(n):\n    q = q ^ p[i]\n    if (n // (i+1)) % 2 == 1:\n        q = q ^ s[i]\n    q = q ^ s[n % (i+1)]\nprint(q)\n
import sys\nfrom array import array\n\nn = int(input())\nedge = [list(map(int, input().split())) for _ in range(n)]\nmod = 10**9 + 7\n\ndp_f = [array('i', [-1])*n for _ in range(n)]\ndp_g = [array('i', [-1])*n for _ in range(n)]\n\n\nfor i in range(n):\n    dp_f[i][i] = dp_g[i][i] = 1\nfor i in range(n-1):\n    dp_f[i][i+1] = dp_g[i][i+1] = 1 if edge[i][i+1] else 0\n\n\ndef f(l, r):\n    if dp_f[l][r] != -1:\n        return dp_f[l][r]\n\n    dp_f[l][r] = g(l, r) if edge[l][r] else 0\n    for m in range(l+1, r):\n        if edge[l][m]:\n            dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n\n    return dp_f[l][r]\n\n\ndef g(l, r):\n    if dp_g[l][r] != -1:\n        return dp_g[l][r]\n\n    dp_g[l][r] = f(l+1, r)\n    for m in range(l+1, r):\n        dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m+1, r)) % mod\n\n    return dp_g[l][r]\n\n\nprint(f(0, n-1))
n, m = map(int, input().split())\na = [input() for i in range(n)]\nans = 0\ni = 0\nwhile i < m:\n    if a[n-1][i] == "B":\n        ans += 1\n        while i < m and a[n-1][i] == "B":\n            i += 1\n    i += 1\n\nprint(ans)
from bisect import bisect\n\nHISENTINEL = 10**9 + 1\nLOSENTINEL = -HISENTINEL\n\ndef main():\n    length = int(input())\n    a = [int(fld) for fld in input().strip().split()]\n    b = [int(fld) for fld in input().strip().split()]\n    print(countmaxminsubseq(a, b))\n    \ndef countmaxminsubseq(a, b):\n    leq, lgt = getleftbounds(a, b, 0)\n    req, rgt = getleftbounds(reversed(a), reversed(b), 1)\n    req = reverseindex(req)\n    rgt = reverseindex(rgt)\n    count = 0\n    for i, (leq1, lgt1, req1, rgt1) in enumerate(zip(leq, lgt, req, rgt)):\n        count += (leq1 - lgt1)*(rgt1 - i) + (i - leq1)*(rgt1 - req1)\n    return count\n    \ndef getleftbounds(a, b, bias):\n    astack = [(HISENTINEL, -1)]\n    bstack = [(LOSENTINEL, -1)]\n    leqarr, lgtarr = [], []\n    for i, (aelt, belt) in enumerate(zip(a, b)):\n        while astack[-1][0] < aelt + bias:\n            astack.pop()\n        lgt = astack[-1][1]\n        while bstack[-1][0] > belt:\n            bstack.pop()\n        if belt < aelt:\n            leq = lgt = i\n        elif belt == aelt:\n            leq = i\n            istack = bisect(bstack, (aelt, -2)) - 1\n            lgt = max(lgt, bstack[istack][1])\n        else:\n            istack = bisect(bstack, (aelt, i)) - 1\n            val, pos = bstack[istack]\n            if val < aelt:\n                lgt = leq = max(lgt, pos)\n            else:\n                leq = pos\n                istack = bisect(bstack, (aelt, -2)) - 1\n                val, pos = bstack[istack]\n                lgt = max(lgt, pos)\n                leq = max(leq, lgt)\n                \n        leqarr.append(leq)\n        lgtarr.append(lgt)\n        astack.append((aelt, i))\n        bstack.append((belt, i))\n    return leqarr, lgtarr\n    \ndef reverseindex(rind):\n    pivot = len(rind) - 1\n    return [pivot - i for i in reversed(rind)]\n    \n   \nmain()    \n\n
import functools\n\nn = int(input())\n\narr = [input() for i in range(n)]\n\ndef compare(s1, s2):\n    a = s1.count('s')\n    b = s2.count('s')\n\n    if (a*len(s2)) < b*len(s1):\n        return 1\n    return -1\n\narr = sorted(arr, key=functools.cmp_to_key(compare))\n\ns = ''.join(arr)\nc = 0\nt = 0\n\nfor char in s:\n    if char == 's':\n        c += 1\n    elif char == 'h':\n        t += c\nprint(t)\n\n
import sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    n, x = list(map(int, input().split()))\n    x -= 1\n\n    degree = [0] * n\n    edges = [(0,0)]*(n-1)\n    for i in range(n - 1):\n        u, v = list(map(int, input().split()))\n        edges[i] = (u-1,v-1)\n        degree[u-1] += 1\n        degree[v-1] += 1\n\n    if degree[x] == 1 or degree[x] == 0:\n        print('Ayush')\n    else:\n        print('Ashish' if n % 2 else 'Ayush')\n
\ndef count(p, s):\n    start = 0\n    c = 0\n    while True:\n        try:\n            pos = s.index(p, start)\n            c += 1\n            start = pos + 1\n        except ValueError:\n            return c\n\ns = input()\nn = int(input())\n\npravs = []\nfor i in range(n):\n    p, l, r = input().split()\n    l = int(l); r = int(r)\n    pravs.append((p, l, r))\n\nvar = set()\nfor l in range(len(s)):\n    for r in range(l+1, len(s)+1):\n        pods = s[l:r]\n        for prav in pravs:\n            if not prav[1] <= count(pods, prav[0]) <= prav[2]:\n                break\n        else:\n            var.add(pods)\n\nprint(len(var))\n
n=int(input())\nmagic=int((n-1)/2)\nx = []\nfor t in range(magic, -1, -1):\n    x.append(t*'*'+'D'*(n-2*t)+t*'*')\nfor u in range(1, magic+1):\n    x.append(u*'*'+'D'*(n-2*u)+u*'*')\n\nno = 1\nne = 2\nfor i in range(n):\n    for j in range(n):\n        if (x[i][j] == 'D'):\n            print(no, end = ' ')\n            no += 2\n        else:\n            print(ne, end = ' ')\n            ne += 2\n    print()\n
n,m,k=map(int,input().split())\nprint(m*(m-1)//2)\nfor i in range(n):\n    a=list(map(int,input().split()))\nif k==0:\n    for i in range(m):\n        for j in range(i+1,m):\n            print(i+1,j+1)\nelse:\n    for i in range(m):\n        for j in range(i+1,m):\n            print(j+1,i+1)
import sys\ninput = sys.stdin.readline\n\nn, m = list(map(int, input().split()))\nl = []\nfor _ in range(n):\n    l.append(input().strip())\n\ndef witch(s):\n    out = 0\n    if s[0] != s[1]:\n        out += 2\n    if s[1] != s[2]:\n        out += 1\n    return out\n\nif n >= 4 and m >= 4:\n    print(-1)\nelse:\n    if n < m:\n        n, m = m, n\n        l = [''.join([l[j][i] for j in range(m)]) for i in range(n)]\n    if m == 1:\n        print(0)\n    elif m == 2:\n        even = 0\n        odd = 0\n        first = l.pop(0)\n        if first == '00' or first == '11':\n            odd += 1\n        else:\n            even += 1\n        for nex in l:\n            if nex == '00' or nex == '11':\n                odd, even = even + 1, odd\n            else:\n                odd, even = even, odd + 1\n        print(min(even, odd))\n    elif m == 3:\n        #ee, eo, oe, oo = [0, 0, 0 ,0]\n        ll = [0, 0, 0, 0]\n        for nex in l:\n            ll.reverse()\n            ll[witch(nex)] += 1\n        print(n - max(ll))\n        \n        \n
n, m = map(int, input().split())\nans = ["0"] * n\nfor i in range(1, n, 2):\n    ans[i] = "1"\nprint("".join(ans))
"""\nCodeforces Round 252 Div 2 Problem C\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0:\n        return inputs\n    if mode == 1:\n        return inputs.split()\n    if mode == 2:\n        return [int(x) for x in inputs.split()]\n\ndef write(s="\n"):\n    if isinstance(s, list): s = " ".join(s)\n    s = str(s)\n    print(s, end="")\n\n################################################### SOLUTION\nn,m,k = read()\n\ncells = []\nfor i in range(n):\n    if not i%2:\n        for j in range(m): cells.append((i+1,j+1))\n    else:\n        for j in range(m-1, -1, -1): cells.append((i+1,j+1))\n\nct = 0\nfor i in range(k-1):\n    print(2, cells[ct][0], cells[ct][1], cells[ct+1][0], cells[ct+1][1])\n    ct += 2\n\nprint(len(cells) - ct, end=" ")\nfor i in cells[ct:]:\n    print(i[0], i[1], end=" ")
def main():\n    import sys\n    input=sys.stdin.readline\n    mod=998244353\n    N=10**5+3\n    fac=[1]*(N+1)\n    for i in range(1,N+1):\n        fac[i]=fac[i-1]*i%mod\n    inv_fac=[1]*(N+1)\n    inv_fac[N]=pow(fac[N],mod-2,mod)\n    for i in range(N-1,0,-1):\n        inv_fac[i]=inv_fac[i+1]*(i+1)%mod\n    D=int(input())\n    A=[]\n    for i in range(2,int(D**.5)+1):\n        c=0\n        while D%i==0:\n            D//=i\n            c+=1\n        if c!=0:\n        	A.append(i)\n    if D>=2:\n        A.append(D)\n    l=len(A)\n    q=int(input())\n    for _ in range(q):\n        u,v=map(int,input().split())\n        l1=[0]*l\n        l2=[0]*l\n        l3=[0]*l\n        for i in range(l):\n            while u%A[i]==0:\n                l1[i]+=1\n                u//=A[i]\n            while v%A[i]==0:\n                l2[i]+=1\n                v//=A[i]\n            l3[i]=l1[i]-l2[i]\n        ans1=1\n        ans2=1\n        s1=0\n        s2=0\n        for i in range(l):\n            if l3[i]>=0:\n                ans1=ans1*inv_fac[l3[i]]%mod\n                s1+=l3[i]\n            else:\n                ans2=ans2*inv_fac[-l3[i]]%mod\n                s2-=l3[i]\n        ans1=ans1*fac[s1]%mod\n        ans2=ans2*fac[s2]%mod\n        print(ans1*ans2%mod)\ndef __starting_point():\n    main()\n__starting_point()
import random\ndef S(L):\n    Ans=[]\n    s=0\n    for item in L:\n        s+=item\n        Ans.append(s)\n    return Ans\n\nn,k=map(int,input().split())\n\nB=list(map(int,input().split()))\n\n\n\nSums=[]\ns=0\nfor i in range(n):\n    s+=B[i]\n    Sums.append(s)\n\nif(k<=n):\n    for i in range(k):\n        print(i+1,end="")\n        for j in range(i+1):\n            print(" "+str(B[j]),end="")\n        print()\n\nelse:\n    Ans=[]\n    length=1\n    Taken={}\n    Sums=S(B)\n    while(len(Ans)<k):\n        if(length>n):\n            length=1\n            random.shuffle(B)\n            Sums=S(B)\n        for i in range(n):\n            if(i+length-1>=n):\n                break\n            x=Sums[i+length-1]-Sums[i]+B[i]\n            if(x in Taken):\n                continue\n            Taken[x]=True\n            L=[length]\n            done=True\n            for j in range(i,i+length):\n                if(B[j] in L[1:]):\n                    done=False\n                    break\n                L.append(B[j])\n            if(done):\n                Ans.append(list(L))\n        length+=1\n    for i in range(k):\n        item=Ans[i]\n        print(item[0],end="")\n        for z in range(1,len(item)):\n            print(" "+str(item[z]),end="")\n        print()\n\n            \n
t = int(input())\nfor i in range(t):\n	n, k = list(map(int, input().split()))\n	ans = 0\n	while n != 0:\n		if n % k == 0:\n			ans += 1\n			n //= k\n		else:\n			ans += n % k\n			n -= n % k\n	print(ans)\n
n,m,k = map(int,input().split())\na = list(map(int,input().split()))\n\na = sorted(a)\nb1 = a[-1]\nb2 = a[-2]\n\nk+=1\ntotal = m//k\nscore = 0\nscore += (m%k) * b1\nscore += b1 * (total*(k-1))\nscore += b2 * total\nprint (score)
x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nn = int(input())\ns = input()\npsx = [0 for i in range(n)]\npsy = [0 for i in range(n)]\n\nif s[0] == 'L':\n    psx[0] = -1\nelif s[0] == 'R':\n    psx[0] = +1\n\nif s[0] == 'D':\n    psy[0] = -1\nelif s[0] == 'U':\n    psy[0] = +1\n\nfor i in range(1, n):\n    psx[i] = psx[i-1]\n    psy[i] = psy[i-1]\n    \n    if s[i] == 'L':\n        psx[i] += -1\n    elif s[i] == 'R':\n        psx[i] += +1\n    \n    if s[i] == 'D':\n        psy[i] += -1\n    elif s[i] == 'U':\n        psy[i] += +1\n\ndef valid(step):\n    cycle = step // n\n    rem = step % n\n    x = x1\n    y = y1\n    x += psx[n-1] * cycle\n    y += psy[n-1] * cycle\n    if rem > 0:\n        x += psx[rem-1]\n        y += psy[rem-1]\n    ManhattanDistance = abs(x - x2) + abs(y - y2)\n    return (ManhattanDistance <= step)\n    \ndef binsearch(top, bot):\n    res = -1\n    while top <= bot:\n        mid = (top + bot) // 2\n        if valid(mid):\n            res = mid\n            bot = mid - 1\n        else:\n            top = mid + 1\n    return res\n    \n\nprint(binsearch(0, 1000000000000000000))
import sys\nfrom collections import deque\nsys.setrecursionlimit(20000000)\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\ng = [[] for i in range(n)]\nfor i in range(n-1):\n    g[b[i]-1].append(i+1)\nha = 0\nfor i in range(n):\n    if len(g[i]) == 0:\n        ha += 1\nkyo = [1<<30] * n\ndef dfs(x,y):\n  kyo[x] = y\n  for i in g[x]:\n    que.append([i,y+1])\nque = deque()\nque.append([0,0])\nwhile que:\n    aa,bb = que.popleft()\n    dfs(aa,bb)\nhukai = []\nfor i in range(n):\n  hukai.append([kyo[i],i])\nhukai.sort(key = lambda x:-x[0])\ndp = [1<<30]*n\nfor j,i in hukai:\n    if len(g[i]) == 0:\n        dp[i] = 0\n        continue\n    sita = []\n    for k in g[i]:\n        sita.append(dp[k])\n    if a[i] == 1:\n        dp[i] = min(sita)\n    else:\n        dp[i] = sum(sita)+len(g[i])-1\nans = ha-dp[0]\nprint(ans)
def main():\n  n = int(input())\n\n  if n % 2 != 0:\n    print(-1)\n    return\n\n  links = [[1, set()] for i in range(1, n+1)]\n  W = 0\n  L = 1\n\n  i = 0\n  while i < n-1:\n    i += 1\n    [a, b] = [int(x) for x in input().split()]\n    links[a-1][L].add(b-1)\n    links[b-1][L].add(a-1)\n\n  count = 0\n  sear = 0\n  cur = 0\n  while sear < n:\n    li = cur\n    l = links[li]\n    if len(l[L]) != 1:\n      if sear == cur:\n        sear += 1\n      cur = sear\n      continue\n    \n    mi = l[L].pop()\n    m = links[mi]\n    if l[W] % 2 == 0:\n      count += 1\n    else:\n      m[W] += 1\n\n    m[L].remove(li)\n    if mi < sear:\n      cur = mi\n    else:\n      sear += 1\n      cur = sear\n\n  print(count)\n\nmain()\n
import collections\n\nclass Graph:\n	def __init__(self, n, dir):\n		self.node_cnt = n\n		self.__directed = dir\n		self.__adjList = []\n		for i in range(n): self.__adjList.append([])\n\n	def addEdge(self, u, v):\n		self.__adjList[u].append(v)\n		if not self.__directed: self.__adjList[v].append(u)\n	\n	def getDistances(self, start, end=None):\n		assert (0 <= start and start < self.node_cnt)\n		dist = [-1] * self.node_cnt\n\n		q = collections.deque()\n		dist[start] = 0\n		q.append(start)\n		while len(q) > 0:\n			z, breakable = q.popleft(), False\n			if end == z: break\n			for t in self.__adjList[z]:\n				if dist[t] == -1:\n					dist[t] = dist[z] + 1\n					q.append(t)\n					if t == end:\n						breakable = True\n						break\n			if breakable: break\n		\n		return dist\n\ndef getAffectedDiameter(graph, affected):\n	affection = [False for i in range(graph.node_cnt)]\n	for x in affected: affection[x] = True\n	dist0 = graph.getDistances(affected[0])\n	affect_1 = -1\n	for i in range(n):\n		if affection[i] and (affect_1 == -1 or dist0[affect_1] < dist0[i]):\n			affect_1 = i\n	\n	dist1 = graph.getDistances(affect_1)\n	affect_2 = -1\n	for i in range(n):\n		if affection[i] and (affect_2 == -1 or dist1[affect_2] < dist1[i]):\n			affect_2 = i\n	\n	return affect_1, affect_2\n\nn, m, d = map(int, input().split())\np = list(map(lambda s: int(s)-1, input().split()))\ng = Graph(n, dir=False)\nfor i in range(1, n):\n	a, b = map(lambda s: int(s)-1, input().split())\n	g.addEdge(a, b)\n\np1, p2 = getAffectedDiameter(g, p)\nd1, d2 = g.getDistances(p1), g.getDistances(p2)\n\ncnt = 0\nfor i in range(n):\n	if d1[i] <= d and d2[i] <= d: cnt += 1\nprint(cnt)
#!/usr/bin/pypy3\n\nfrom sys import stdin,stderr\nimport random\nimport cProfile\n\ndef readInts(): return map(int,stdin.readline().strip().split())\ndef print_err(*args,**kwargs): print(*args,file=stderr,**kwargs)\n    \ndef solve(vs):\n    return None\n\ndef generate_tree(n,ns):\n    out = [0 for _ in range(2**(n+1))]\n    def gt(nix,left,right,op):\n        if left+1==right:\n            out[nix] = ns[left]\n            return out[nix]\n        mid = (left+right)//2\n        nL = nix*2+1\n        nR = nix*2+2\n        vL = gt(nL,left,mid,not op)\n        vR = gt(nR,mid,right,not op)\n        if op: v = vL ^ vR\n        else: v = vL | vR\n        out[nix] = v\n        return v\n    gt(0,0,2**n,n%2==0)\n    return out\n\ndef alter_tree2(n,t,p,b):\n    def at(nix,width,offp,op):\n        if width==1:\n            t[nix]=b\n            return b\n        width //= 2\n        nL = nix*2+1\n        nR = nix*2+2\n        vL = t[nL]\n        vR = t[nR]\n        if offp >= width: vR = at(nR,width,offp-width,not op)\n        else: vL = at(nL,width,offp,not op)\n        if op: v = vL ^ vR\n        else: v = vL | vR\n        t[nix] = v\n        return v\n    at(0,2**n,p,n%2==0)\n            \ndef alter_tree(n,t,p,b):\n    width = 2**n\n    s = []\n    nix = 0\n    op = (n%2==0)\n    while width>1:\n        width //= 2\n        #print(nix)\n        if p >= width:\n            nix2 = 2*nix+2\n            s.append( (nix,nix2-1) )\n            p -= width\n        else:\n            nix2 = 2*nix+1\n            s.append( (nix,nix2+1) )\n        nix = nix2\n        op = not op\n    #print(nix)\n    t[nix] = b\n    v = b\n    while s:\n        nix,nixO = s.pop()\n        if op: v |= t[nixO]\n        else: v ^= t[nixO]\n        t[nix] = v        \n        op = not op\n    return\n    \ndef run():\n    n,m = readInts()    \n    axs = list(readInts())\n    t = generate_tree(n,axs)\n    for _ in range(m):\n        p,b = readInts()\n        alter_tree(n,t,p-1,b)\n        print(t[0])\n\ndef test():\n    n = 17\n    ns = []\n    vs100 = list(range(100))\n    for _ in range(2**17):\n        ns.append(random.choice(vs100))        \n    t = generate_tree(n,ns)\n    t2 = generate_tree(n,ns)\n    for _ in range(100000):\n        v1 = random.choice(vs100)\n        v2 = random.choice(vs100)\n        alter_tree(n,t,v1,v2)\n        alter_tree2(n,t2,v1,v2)\n    print(all(map(lambda x: x[0]==x[1],zip(t,t2))))\n    print(t[0]==t2[0])\n    \nrun()\n
import sys\ninput = sys.stdin.readline\n#lev contains height from root,lower neighbour, higher neighbours\n#lev[0] contains 0 (because it is the root), higher neighbours (=neighbours)\nn,m,q=map(int,input().split())\nmod=1000000007\nmxw=0\nwgts=[0]*n\nneig=[0]*n\nfor i in range(n):\n    neig[i]=[0]\n\nfor i in range(m):\n    a,b,w=map(int,input().split())\n    a-=1\n    b-=1\n    neig[a][0]+=1\n    neig[b][0]+=1\n    neig[a].append([b,w])\n    neig[b].append([a,w])\n    mxw=max(mxw,w)\n    wgts[a]=max(wgts[a],w)\n    wgts[b]=max(wgts[b],w)\nposs=[-1]*n\nposs[0]=0\nsol=0\ncurw=0\nhasmxw=[False]*n\nfor i in range(n):\n    if wgts[i]==mxw:\n        hasmxw[i]=True\nov=False\nl=0\nwhile l<q and not ov and l<3000:\n    newposs=[-1]*n\n    for i in range(n):\n        if poss[i]>=0:\n            for j in range(1,neig[i][0]+1):\n                newposs[neig[i][j][0]]=max(newposs[neig[i][j][0]],poss[i]+neig[i][j][1])\n    curmx=0\n    for i in range(n):\n        poss[i]=newposs[i]\n        if poss[i]>curmx:\n            curmx=poss[i]\n            ov=hasmxw[i]\n        else:\n            if poss[i]==curmx and hasmxw[i]:\n                ov=True\n    curw=curmx\n    sol+=curw\n    sol%=mod\n    l+=1\nif l==q:\n    print(sol)\nelse:\n    if ov:\n        rem=q-l\n        sol+=rem*curw\n        sol%=mod\n        sol+=mxw*((rem*(rem+1))//2)\n        sol%=mod\n        print(sol)\n    else:\n        rem=q-l\n        while not ov:\n            mx=0\n            for i in range(n):\n                if poss[i]==curw:\n                    mx=max(mx,wgts[i])\n            gd=-1\n            for i in range(n):\n                if wgts[i]>mx and poss[i]>=0:\n                    diff=wgts[i]-mx\n                    loss=curw-poss[i]\n                    loss+=diff-1\n                    att=loss//diff\n                    if gd==-1:\n                        gd=att\n                    gd=min(att,gd)\n            if gd==-1 or gd>rem:\n                sol+=rem*curw\n                sol+=mx*((rem*(rem+1))//2)\n                sol%=mod\n                ov=True\n            else:\n                sol+=(gd-1)*curw\n                sol+=mx*((gd*(gd-1))//2)\n                sol%=mod\n                for i in range(n):\n                    poss[i]+=gd*wgts[i]\n                    curw=max(curw,poss[i])\n                sol+=curw\n                rem-=gd\n        print(sol)
s=input()\nans=0\ns=s.replace("heavy","1")\ns=s.replace("metal","2")\nheavy=[]\nmetal=[]\nn=len(s)\nfor i in range(n):\n    if(s[i]=="1"):\n        heavy.append(i)\n    elif(s[i]=="2"):\n        metal.append(i)\n\nn=len(heavy)\nnn=len(metal)\nx=0\nl=nn\nfor item in heavy:\n    for i in range(x,nn):\n        if(metal[i]>item):\n            ans+=(nn-i)\n            l=i\n            break\n    x=l;\n\nprint(ans)\n
n = int(input())\n\nmp = {}\n\nfor _ in range(n):\n    a, b = map(int, input().split())\n    mp[a] = mp.get(a, 0) + 1\n    mp[b] = mp.get(b, 0) - 1\n\ncur = 0\nmaxi = 0\nmaxiy = 0\n\nfor i in sorted(mp):\n    cur += mp[i]\n\n    if cur > maxi:\n        maxi = cur\n        maxiy = i\n\nprint(maxiy, maxi)
import sys\nimport math\n\ndef sieve(n):\n    prime_factors = [[] for i in range(n+1)]\n    tmp = [True] * (n+1)\n    tmp[0] = tmp[1] = False\n    for i in range(2, n+1):\n        if tmp[i]:\n            for k in range(i, n+1, i):\n                tmp[k] = False\n                prime_factors[k].append(i)\n    return prime_factors\n\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split(' ')))\nb = []\nforbidden_factors = set({})\nprime_factors = sieve(2000005)\nis_greater = False\nmin_available = 2\n\nfor ai in a:\n    factors = prime_factors[ai]\n    if not is_greater:\n        curr = ai\n        ok = True\n        for f in factors:\n            if f in forbidden_factors:\n                ok = False\n                break\n        if ok:\n            for f in factors:\n                forbidden_factors.add(f)\n        else:\n            is_greater = True\n            ok = False\n            while not ok:\n                curr += 1\n                ok = True\n                factors = prime_factors[curr]\n                for f in factors:\n                    if f in forbidden_factors:\n                        ok = False\n                        break\n            for f in factors:\n                forbidden_factors.add(f) \n    else:\n        curr = min_available\n        ok = True\n        factors = prime_factors[curr]\n        for f in factors:\n            if f in forbidden_factors:\n                ok = False\n                break\n        while not ok:\n            curr += 1\n            ok = True\n            factors = prime_factors[curr]\n            for f in factors:\n                if f in forbidden_factors:\n                    ok = False\n                    break\n        min_available = curr\n        for f in factors:\n            forbidden_factors.add(f)\n    b.append(str(curr))\nprint(" ".join(b))\n
n = int(input())\nl = 0\nr = n * n - 1\n\nfor i in range(n):\n    for k in range(n // 2):\n        print(l + 1, end = ' ')\n        print(r + 1, end = ' ')\n        l += 1\n        r -= 1\n    print()\n
import sys\n\nrd = lambda : sys.stdin.readline().rstrip()\n\nt = int(rd())\nfor _ in range(t):\n    n = int(rd())\n    a = list(map(int, rd().split()))\n    b = []\n    res_a, res_b = 1, 1e18\n    \n    a = sorted(a)\n    i = 0\n    while i < n-1:\n        if a[i] == a[i+1]:\n            b.append(a[i])\n            i += 1\n            \n        i += 1\n        \n    p2s = lambda x, y : (x+y)**2/(x*y)\n    \n    for i in range(len(b)-1):\n        if p2s(res_a, res_b) > p2s(b[i], b[i+1]):\n            res_a, res_b = b[i], b[i+1]\n            \n    print(res_a, res_a, res_b, res_b)\n    \n
import sys\n\nn = int(sys.stdin.readline())\nedges = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    i, j = tuple(int(k) for k in sys.stdin.readline().split())\n    i -= 1\n    j -= 1\n    edges[i].append(j)\n    edges[j].append(i)\n\n# Prunes the graph starting from the vertices with\n# only 1 edge until we reach a vertex with 3+ edges.\n# Stores the distance from each non-pruned vertex\n# to each of the leaves it reaches.\ndef prune():\n    pruned = [False for _ in range(n)]\n    leaves = [[] for _ in range(n)]\n    todo = []\n    for i in range(n):\n        if len(edges[i]) == 1:\n            todo.append((0, i, i))\n    while len(todo) > 0:\n        d, i, j = todo.pop()\n        pruned[j] = True\n        for k in edges[j]:\n            if not pruned[k]:\n                if len(edges[k]) < 3:\n                    todo.append((d + 1, i, k))\n                else:\n                    leaves[k].append((d + 1, i))\n    return pruned, leaves\n\npruned, leaves = prune()\n\n# Returns the furthest non-pruned vertices\n# from another non-pruned vertex.\ndef furthest(i):\n    assert not pruned[i]\n    visited = list(pruned)\n    top_distance = 0\n    top_vertices = [i]\n    todo = [(0, i)]\n    while len(todo) > 0:\n        d, i = todo.pop()\n        visited[i] = True\n        if d > top_distance:\n            top_distance = d\n            top_vertices = []\n        if d == top_distance:\n            top_vertices.append(i)\n        for j in edges[i]:\n            if not visited[j]:\n                todo.append((d + 1, j))\n    return top_distance, top_vertices\n\n# Single center topology.\n# Only 1 vertex with 3+ edges.\ndef solve_single_center(i):\n    l = list(reversed(sorted(leaves[i])))[:4]\n    return list(l[j][1] for j in range(4))\n\n# Scores non-pruned vertices according to the sum\n# of the distances to their two furthest leaves.\ndef vertices_score(v):\n    scores = []\n    for i in v:\n        assert not pruned[i]\n        l = list(reversed(sorted(leaves[i])))[:2]\n        score = (l[0][0] + l[1][0]), l[0][1], l[1][1]\n        scores.append(score)\n    return list(reversed(sorted(scores)))\n\n# Single cluster topology.\n# 1 cluster of vertices, all equally far away from each other.\ndef solve_single_cluster(v):\n    scores = vertices_score(v)[:2]\n    return scores[0][1], scores[1][1], scores[0][2], scores[1][2]\n\n# Double cluster topology.\n# 2 clusters of vertices, pairwise equally far away from each other.\ndef solve_double_cluster(v1, v2):\n    scores1 = vertices_score(v1)[:1]\n    scores2 = vertices_score(v2)[:1]\n    return scores1[0][1], scores2[0][1], scores1[0][2], scores2[0][2]\n\ndef solve():\n    def start_vertex():\n        for i in range(n):\n            if not pruned[i]:\n                return i\n    i = start_vertex()\n    distance, v1 = furthest(i)\n    if distance == 0:\n        return solve_single_center(v1[0])\n    else:\n        distance, v1 = furthest(v1[0])\n        distance, v2 = furthest(v1[0])\n        v = list(set(v1) | set(v2))\n        if len(v) < len(v1) + len(v2):\n            return solve_single_cluster(v)\n        else:\n            return solve_double_cluster(v1, v2)\n\na, b, c, d = solve()\nprint(a + 1, b + 1)\nprint(c + 1, d + 1)\n
k = int(input())\nfor i in range(k):\n    n = int(input())\n    s1 = input()\n    s2 = input()\n    q = None\n    for i in range(n):\n        if s1[i] != s2[i]:\n            if q is None:\n                q = s1[i], s2[i]\n            elif q == (s1[i], s2[i]):\n                q = 1\n            else:\n                print('No')\n                break\n    else:\n        if q == 1:\n            print('Yes')#isinstance(q, tuple):\n        else:\n            print('No')
for nt in range(int(input())):\n	n,k = map(int,input().split())\n	if k<n:\n		if n%2==0:\n			if k%2:\n				print (1)\n			else:\n				print (0)\n			continue\n		else:\n			if k%2:\n				print (0)\n			else:\n				print (1)\n			continue\n	print (k-n)
import sys\nimport bisect\ninput = sys.stdin.readline\n\ntrips = int(input())\ndyn = [int(input()) for i in range(trips)]\n\ncmap = [0,20] + [0 for i in range(trips-1)]\n\nfor i in range(2,trips+1):\n    cmap[i] = min(cmap[i-1] + 20,\n                  cmap[bisect.bisect_left(dyn,dyn[i-1]-89)] + 50,\n                  cmap[bisect.bisect_left(dyn,dyn[i-1]-1439)] + 120)\n\nfor i in range(1,trips+1):\n    print(cmap[i]-cmap[i-1])\n\n
import collections\n\nn = int(input())\nA = list(map(int, input().split()))\nS = [0]*n\n\nS[0] = A[0]\nfor i in range(1, n) :\n    S[i] = S[i-1] + A[i]\n\nC = collections.Counter(S)\nmax_val = 0\nfor key in C :\n    max_val = max(max_val, C[key])\nans = n - max_val\nprint(ans)
def size(k):\n    return int(math.log2(k))\ndef v2(k):\n    if k%2==1:\n        return 0\n    else:\n        return 1+v2(k//2)\nn=int(input())\ns=list(map(int,input().split()))\nimport math\ns.sort()\nused=[]\nuse=0\nfound={0:1}\ngood=0\nfor guy in s:\n    big=size(guy)\n    if guy not in found:\n        used.append(guy)\n        use+=1\n        new=[]\n        for boi in found:\n            new.append(boi^guy)\n        for guy in new:\n            found[guy]=1\n        if use==big+1:\n            good=use\nif good==0:\n    print(0)\n    print(0)\nelse:\n    useful=used[:good]\n    perm=["0"]\n    curr=0\n    for i in range(2**good-1):\n        curr^=useful[v2(i+1)]\n        perm.append(str(curr))\n    print(good)\n    print(" ".join(perm))
n=int(input())\nmagic=int((n-1)/2)\nfor t in range(magic, -1, -1):\n    print(t*'*'+'D'*(n-2*t)+t*'*')\nfor u in range(1, magic+1):\n    print(u*'*'+'D'*(n-2*u)+u*'*')\n
import math, sys\n\ndef mp():\n    return list(map(int, input().split()))\n\ndef main():\n    n = int(input())\n    for i in range(n):\n        x = int(input())\n        print(x // 2)\n\ndeb = 0\nif deb:\n    file = open('input.txt', 'w')\nelse:\n    input = sys.stdin.readline\n    \nmain()
import sys\nfrom math import *\n\ndef minp():\n	return sys.stdin.readline().strip()\n\ndef mint():\n	return int(minp())\n\ndef mints():\n	return map(int, minp().split())\n\ndef add(a,b):\n	return (a+b)%1000000007\n\ndef sub(a,b):\n	return (a+1000000007-b)%1000000007\n\ndef mul(a,b):\n	return (a*b)%1000000007\n\np = 102367\ns = list(map(int,minp()))\nt = list(map(ord,minp()))\nh = [0]*(len(t)+1)\npp = [1]*(len(t)+1)\nfor i in range(len(t)):\n	h[i+1] = add(mul(h[i], p), t[i])\n	pp[i+1] = mul(pp[i], p)\n\ndef cmp(a, b, l):\n	if a > b:\n		a, b = b, a\n	h1 = sub(h[a+l], mul(h[a], pp[l]))\n	h2 = sub(h[b+l], mul(h[b], pp[l]))\n	return h2 == h1\n\nc = [0,0]\nidx = [-1,-1]\nfor i in range(len(s)):\n	c[s[i]] += 1\n	if idx[s[i]] < 0:\n		idx[s[i]] = i\nMv = max(c)\nmv = min(c)\nMi = c.index(Mv)\nmi = (Mi^1)\nlt = len(t)\nsp = [0,0]\nres = 0\nfor k in range(1,lt//Mv+1):\n	l = [0,0]\n	x = (lt-k*Mv)//mv\n	if x > 0 and x*mv + k*Mv == lt:\n		l[Mi] = k\n		l[mi] = x\n		if idx[0] < idx[1]:\n			sp[0] = 0\n			sp[1] = idx[1]*l[0]\n		else:\n			sp[1] = 0\n			sp[0] = idx[0]*l[1]\n		ok = True\n		j = 0\n		for i in range(len(s)):\n			if not cmp(sp[s[i]], j, l[s[i]]):\n				ok = False\n				break\n			j += l[s[i]]\n		if l[0] == l[1] and cmp(sp[0], sp[1], l[0]):\n			ok = False\n		if ok:\n			res += 1\nprint(res)
n, a, b = input(), map(int, input().split()), map(int, input().split())\nprint(sum((y // 2) * (y - y // 2) if y > 1 and 2 * x >= y else -1 for x, y in zip(a, b)))
s=input()[::-1]\nalist=[0]*2019\nnum1=0\nnum2=1/10\nlens=len(s)\nfor i in range(lens):\n  num2=int(((num2)*10)%2019)\n  num1=(num1+int(s[i])*(num2))%2019\n  alist[num1]+=1\nalist[0]+=1\nans=0\nfor i in range(2019):\n  ans+=alist[i]*(alist[i]-1)//2\nprint(ans)
n, k, q = [int(x) for x in input().split()]\nT = [int(x) for x in input().split()]\nS = set()\nfor i in range(q):\n    t, _id = [int(x) for x in input().split()]\n    if t == 1:\n        m = min(S, default = 0)\n        if len(S) == k:\n            if m < T[_id-1]:\n                S.remove(m)\n                S.add(T[_id-1])\n        else:\n            S.add(T[_id-1])\n    else:\n        print('YES' if T[_id-1] in S else 'NO')\n\n
import sys\nn,m=list(map(int,sys.stdin.readline().split()))\nP={}\nfor i in range(m):\n    a,b=list(map(int,sys.stdin.readline().split()))\n    P[(a-1,b-1)]=1\n\nA=[-1]*n\nA[0]=0\nfor i in range(1,n):\n    j=1\n    A[i]=i\n    x=i\n    while(x>0 and (A[x-1],A[x]) in P):\n        A[x-1],A[x]=A[x],A[x-1]\n        x-=1\nAnss=""\nfor i in range(n):\n    Anss+=str(A[i]+1)+" "\nsys.stdout.write(Anss)\n
import sys\n\nT = int(sys.stdin.readline().strip())\nfor t in range(0, T):\n    n, k = list(map(int, sys.stdin.readline().strip().split()))\n    if k % 3 != 0:\n        if n % 3 == 0:\n            print("Bob")\n        else:\n            print("Alice")\n    else:\n        n = n % (k + 1)\n        if n == k:\n            print("Alice")\n        elif n % 3 == 0:\n            print("Bob")\n        else:\n            print("Alice")
from sys import stdin\nfrom decimal import Decimal as D\ninput = stdin.readline\nn = int(input())\nadj = [[] for i in range(n+1)]\ntree = [[] for i in range(n+1)]\nvisit = [-1]*(n+1)\nlength = [-1]*(n+1)\nfor i in range(n-1):\n    a, b = map(int,input().split())\n    adj[a].append(b)\n    adj[b].append(a)\nbfsord = []\n\nfrom collections import deque\nQ = deque()\nQ.append(1)\nvisit[1] = 0\nwhile len(Q):\n    p = Q.popleft()\n    bfsord.append(p)\n    for q in adj[p]:\n        if visit[q] != -1: continue\n        visit[q] = visit[p]+1\n        Q.append(q)\n        tree[p].append(q)\n\nfor p in reversed(bfsord):\n    if not tree[p]: length[p] = D(0)\n    else: length[p] = D(1) + sum(length[q] for q in tree[p])/len(tree[p])\nprint(length[1])
for _ in range(int(input())):\n    s, a, b, c = list(map(int, input().split()))\n\n    x = s // c\n    x += b * (x // a)\n\n    print(x)\n
3\n\n__import__("sys").setrecursionlimit(10 ** 6)\nimport threading\n\nthreading.stack_size(64 * 1024 * 1024)\n\ndef dfs(u, h, par, tr, arr):\n    arr[u] = h\n    for v in tr[u]:\n        if v != par:\n            dfs(v, h + 1, u, tr, arr)\n\ndef longpathv(tr, v):\n    n = len(tr)\n    arr = [0] * n\n    dfs(v, 0, -1, tr, arr)\n    ans = max(list(range(n)), key=lambda x: arr[x])\n    return ans, arr[ans]\n\ndef longpath(tr):\n    return longpathv(tr, longpathv(tr, 0)[0])[1]\n\ndef main(tr):\n    print(longpath(tr))\n\nn, m = list(map(int, input().split()))\ntr = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    tr[a].append(b)\n    tr[b].append(a)\n\nth = threading.Thread(target=main, args=tuple([tr]))\nth.start()\n
def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn = ii()\na = li()\nans = 0\ncnt = [0] * (10 ** 5 + 10)\ncur = set()\nfor ai in a:\n    cnt[ai] = len(cur)\n    cur.add(ai)\nans = sum(cnt)\nprint(ans)
import sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n\n    lengths = []\n    curr = s[0]\n    currLen = 0\n    for c in s:\n        if c == curr:\n            currLen += 1\n        else:\n            lengths.append(currLen)\n            currLen = 1\n            curr = c\n    if currLen < n and s[0] == s[-1]:\n        lengths[0] += currLen\n    else:\n        lengths.append(currLen)\n\n\n    out = 0\n    if len(lengths) == 1 and n >= 3:\n        out = 1\n        lengths[0] -= 1\n        lengths.append(1)\n        \n\n    for v in lengths:\n        out += v // 3\n    print(out)\n    \n
n, m = list(map(int, input().split()))\nmx = [[0x00] * n for i in range(n)]\nused = None\n\ndef dfs(cur, trg, color):\n    if cur == trg:\n        return True\n    if not used[cur]:\n        used[cur] = True\n        for i in range(n):\n            if mx[cur][i] & color:\n                if dfs(i, trg, color):\n                    return True\n    return False\n\nfor i in range(m):\n    a, b, c = [int(s) - 1 for s in input().split()]\n    mx[a][b] |= 1 << c\n    mx[b][a] |= 1 << c\n\nq = int(input())\nfor i in range(q):\n    u, v = [int(s) - 1 for s in input().split()]\n    result = 0\n    for j in range(m):\n        used = [False] * n\n        if dfs(u, v, 1 << j):\n            result += 1\n    print(result)\n
n, m = list(map(int, input().split()))\np = list(map(int, input().split()))\n\nfor _ in range(m):\n    l, r, x = list(map(int, input().split()))\n    px = p[x - 1]\n    cnt = l\n    for i in range(l, r + 1):\n        if p[i - 1] < px:\n            cnt += 1\n    if cnt == x:\n        print("Yes")\n    else:\n        print("No")\n
q=int(input())\nfor i in range(q):\n    t=input()\n    r=t[-1]\n    if r=="o":\n        print("FILIPINO")\n    elif r=="u":\n        print("JAPANESE")\n    else:\n        print("KOREAN")
#!/usr/bin/env python3\nimport sys\n\ndef rint():\n    return list(map(int, sys.stdin.readline().split()))\n#lines = stdin.readlines()\n\ndef get_num1(i):\n    cnt = 0\n    while i:\n        if i%2:\n            cnt +=1\n        i //=2\n    return cnt\n\nn = int(input())\n\na = list(rint())\n\nb = [get_num1(aa) for aa in a]\n\nans = 0\n#S0[i] : 1 if sum of 1s in ragne (0, i) is odd, else 0\nS0 = [0]*n\nS0[0] = b[0]%2\nfor i in range(1, n):\n    S0[i] = (S0[i-1] + b[i])%2\n\n#total even pairs in (0, n)\neven_cnt = S0.count(0)\n\nans = even_cnt\n\n# check total even pairs in (i, n)\nfor i in range(1, n):\n    if b[i-1] %2:\n        even_cnt = n - i - even_cnt\n    else:\n        even_cnt -= 1\n    ans += even_cnt\n\nfor i in range(n):\n    max_value = 0\n    sum_value = 0\n    for j in range(1, 62):\n        if i + j > n:\n            break\n        sum_value += b[i+j-1]\n        max_value = max(max_value, b[i+j-1])\n        if 2 * max_value > sum_value and sum_value%2 == 0:\n            ans -= 1\n\nprint(ans)\n
from heapq import *\nn, m = map(int, input().split())\ng = {}\nfor _ in range(m):\n    u, v = map(int, input().split())\n    g.setdefault(u, set()).add(v)\n    g.setdefault(v, set()).add(u)\n\nd = []\nV = set()\nh = [1]\nwhile h:\n    v = heappop(h)\n    if v in V:\n        continue\n    V.add(v)\n    d.append(v)\n    for u in g[v]:\n        heappush(h, u)\nprint(*d)
for _ in range(int(input())):\n	n, x, a, b = map(int, input().split())\n\n	print(min(abs(a - b) + x, n - 1))
import math\nn, x1, y1, x2, y2 = [int(x) for x in input().split()]\npoints = []\nfor i in range(n):\n    points.append(tuple(int(x) for x in input().split()))\nd = lambda p1, p2: (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2\nfirst = (x1, y1)\nsecond = (x2, y2)\ndistances = [(d(first, point), d(second, point)) for point in points]\ndistances.sort()\nmaxtaild = [0 for i in range(n+1)]\nfor i in range(n-1, -1, -1):\n    maxtaild[i] = max(maxtaild[i+1], distances[i][1])\nprint(min(maxtaild[0], min(distances[i][0] + maxtaild[i+1] for i in range(n))))\n
n = int(input())\nl = list(map(int, input().split()))\norder = [(l[i],i) for i in range(n)]\norder.sort(reverse = True)\n\nout = []\nfor v, ind in order:\n    for i in range(ind):\n        if v < l[i]:\n            out.append(str(i + 1)+' '+str(ind + 1))\n\nprint(len(out))\nprint('\n'.join(out))\n
def lis(a):\n    b = []\n    for c in a:\n        # if len(b) == 0 or c > b[-1]\n        if len(b) == 0 or c > b[-1]:\n            b.append(c)\n        else:\n            l = 0\n            r = len(b)\n            while l < r-1:\n                m = l+r>>1\n                # if b[m] <= c: l = m\n                if b[m] < c: l = m\n                else: r = m\n            # if b[l] <= c: l += 1\n            if b[l] < c: l += 1\n            b[l] = c\n        \n    return len(b)\n                    \n\nn = int(input())\n\na = list(map(int, input().split()))\n\nprint(lis(a))\n
n=int(input())\nprint(pow(5,n,100))\n
import itertools\nimport math\n\ndef minusv(L):\n    return [-x for x in L]\n\ndef adamar(M):\n    return [L*2 for L in M] + [L + minusv(L) for L in M]\n\nk = int(input())\na = [[1]]\nfor i in range(k):\n    a = adamar(a)\nfor L in a:\n    print(''.join(['+' if c==1 else '*' for c in L]))\n\n
n = int(input())\na = set(''.join(sorted(set(v))) for v in input().split())\n\nprint(len(a))\n
\nfrom queue import Queue\nimport sys\n\ncost = []\n\ndef readarray(): return list(map(int, input().split(' ')))\n\nn = int(input())\ngraph = [[] for i in range(n)]\n\nfor i in range(n - 1):\n	u, v, c = readarray()\n	u, v = u - 1, v - 1\n	cost.append(c)\n	graph[u].append((v, i))\n	graph[v].append((u, i))\n	\n\norder = []\nused = [0] * n\nq = [0] * (n + n)\n\nqh = qt = 0\n\n\nused[qh] = 1\nqh += 1\n\nwhile qt < qh:\n	v = q[qt]\n	qt += 1\n	\n	order.append(v)\n	\n	for (to, e) in graph[v]:\n		if used[to]:\n			continue\n		used[to] = 1\n		q[qh] = to\n		qh += 1\n		\n\n		\norder.reverse()\n		\nsz = [0 for x in range(n)]\n\nfor v in order:\n	sz[v] = 1\n	for (to, e) in graph[v]:\n		sz[v] += sz[to]\n"""\n\nsz = [0] * n\n\nsys.setrecursionlimit(100505)\n\ndef dfs(v, p):\n	sz[v] = 1\n	\n	for (to, e) in graph[v]:\n		if to != p:\n			dfs(to, v)\n			sz[v] += sz[to]\n			\ndfs(0, -1)\n\n"""\n\ndistanceSum = 0.0\nedgeMult = [0] * n\n\nfor v in range(n):\n	for (to, e) in graph[v]:\n		x = min(sz[v], sz[to])\n		edgeMult[e] = x\n		distanceSum += 1.0 * cost[e] * x * (n - x)\n		\ndistanceSum /= 2.0\n\nqueryCnt = int(input())\n\nans = []\n\nfor i in range(queryCnt):\n	x, y = readarray()\n	x -= 1\n	\n	distanceSum -= 1.0 * cost[x] * edgeMult[x] * (n - edgeMult[x])\n	cost[x] = y\n	distanceSum += 1.0 * cost[x] * edgeMult[x] * (n - edgeMult[x])\n	\n	ans.append('%.10lf' % (distanceSum / n / (n - 1) * 6.0))\n\nprint('\n'.join(ans))\n
for __ in range(int(input())):\n    n = int(input())\n    ar = []\n    for ________ in range(n):\n        ar.append(list(map(int, input().split())))\n    ar.sort(key=lambda x: x[1])\n    num1 = ar[0][1]\n    ar.sort(key=lambda x: -x[0])\n    num2 = ar[0][0]\n    print(max(0, num2 - num1))
# AC\nimport sys\nsys.setrecursionlimit(1000000)\n\n\nclass Main:\n    def __init__(self):\n        self.buff = None\n        self.index = 0\n\n    def __next__(self):\n        if self.buff is None or self.index == len(self.buff):\n            self.buff = self.next_line()\n            self.index = 0\n        val = self.buff[self.index]\n        self.index += 1\n        return val\n\n    def next_line(self):\n        return sys.stdin.readline().split()\n\n    def next_ints(self):\n        return [int(x) for x in sys.stdin.readline().split()]\n\n    def next_int(self):\n        return int(next(self))\n\n    def solve(self):\n        a = next(self)\n        b = next(self)\n        d = 0\n        g = 0\n        for i in range(len(b)):\n            if a[i] != b[i]:\n                d += 1\n            if i > 0 and b[i] != b[i - 1]:\n                g += 1\n        ans = 1 if d % 2 == 0 else 0\n        for i in range(len(b), len(a)):\n            if a[i] != b[-1]:\n                d += 1\n            if a[i - len(b)] != b[0]:\n                d += 1\n            d += g\n            if d % 2 == 0:\n                ans += 1\n        print(ans)\n\n\ndef __starting_point():\n    Main().solve()\n\n__starting_point()
import os, sys, bisect, copy\nfrom collections import defaultdict, Counter, deque\nfrom functools import lru_cache   #use @lru_cache(None)\nif os.path.exists('in.txt'): sys.stdin=open('in.txt','r')\nif os.path.exists('out.txt'): sys.stdout=open('out.txt', 'w')\n#\ndef input(): return sys.stdin.readline()\ndef mapi(arg=0): return map(int if arg==0 else str,input().split())\n#------------------------------------------------------------------\n\nn,k,d = mapi()\nplc = list(mapi())\ngr = defaultdict(list)\nfor i in range(1,n):\n    u,v = mapi()\n    gr[u].append([v,i])\n    gr[v].append([u,i])\nq = deque()\nfor i in plc:\n    q.append((i,0))\nvis = {}\nres = [0]*(n+1)\nwhile q:\n    tmp,par = q.popleft()\n    if tmp in vis:\n        continue\n    vis[tmp] = 1\n    for item in gr[tmp]:\n        if item[0] != par:\n            if item[0] in vis:\n                res[item[1]] = 1\n            else:\n                q.append((item[0],tmp))\ncnt = 0\nans = []\nfor i in range(1,n+1):\n    if res[i]==1:\n        cnt+=1\n        ans.append(i)\nprint(cnt)\nprint(*ans)
#!/usr/bin/env python3\n\nfrom functools import cmp_to_key\ndef cmpEqLen(a, b):\n    if a < b:\n        return -1\n    elif a > b:\n        return 1\n    else:\n        return 0\n\ndef compare(a, b):\n    alen = len(a)\n    blen = len(b)\n    if alen == blen:\n        return cmpEqLen(a, b)\n    l = min(alen, blen)\n    c = cmpEqLen(a[:l], b[:l])\n    if c != 0:\n        return c\n\n    if alen > blen:\n        return -compare(a[:l], a[l:])\n    else:\n        return compare(b[:l], b[l:])\n\nN = int(input())\narr = [input() for _ in range(N)]\narr.sort(key=cmp_to_key(compare))\nprint(''.join(arr))\n
# import sys\n# sys.stdin = open('cf591b.in')\n\nn, m = map(int, input().split())\ns = input()\n\nperm = list(range(26))\n\nv = ord('a')\n\nfor _ in range(m):\n	ss = input()\n	i, j = (ord(ss[0]) - v, ord(ss[2]) - v)\n	perm[i], perm[j] = perm[j], perm[i]\n\nrev = [perm.index(c) for c in range(26)]\nprint(''.join(chr(rev[ord(c) - v] + v) for c in s))
t=int(input())\nno_of_chars = 256\n  \n# Function to find smallest window  \n# containing all characters of 'pat'  \ndef findSubString(string, pat):  \n    len1 = len(string)  \n    len2 = len(pat)  \n    if len1 < len2:  \n      \n        return 0\n    hash_pat = [0] * no_of_chars \n    hash_str = [0] * no_of_chars  \n    for i in range(0, len2):  \n        hash_pat[ord(pat[i])] += 1\n  \n    start, start_index, min_len = 0, -1, float('inf')  \n    count = 0 # count of characters  \n    for j in range(0, len1):  \n        hash_str[ord(string[j])] += 1\n        if (hash_pat[ord(string[j])] != 0 and\n            hash_str[ord(string[j])] <= \n            hash_pat[ord(string[j])]):  \n            count += 1\n        if count == len2:  \n            while (hash_str[ord(string[start])] >  \n                   hash_pat[ord(string[start])] or\n                   hash_pat[ord(string[start])] == 0):  \n              \n                if (hash_str[ord(string[start])] >  \n                    hash_pat[ord(string[start])]):  \n                    hash_str[ord(string[start])] -= 1\n                start += 1\n            len_window = j - start + 1\n            if min_len > len_window:  \n              \n                min_len = len_window  \n                start_index = start  \n    if start_index == -1: \n        return 0\n      \n    # Return substring starting from  \n    # start_index and length min_len  \n    return min_len\nwhile t:\n    t-=1\n    a=input()\n    x="123"\n    print(findSubString(a,x))\n    \n
import sys\ninput = sys.stdin.readline\nn=int(input())\na=list(map(int,input().split()))\nplanks=[0]*100000\npairs=0\nsquares=0\nfor x in a:\n    planks[x-1]+=1\n    if planks[x-1]%2==0:\n        pairs+=1\n        if planks[x-1]%4==0:\n            squares+=1\nfor f in range(int(input())):\n    inp=list(input().split())\n    p=inp[0]\n    i=int(inp[1])\n    i-=1\n    if p=="+":\n        planks[i]+=1\n        if planks[i]%2==0:\n            pairs+=1\n            if planks[i]%4==0:\n                squares+=1\n    else:\n        if planks[i]%2==0:\n            pairs-=1\n            if planks[i]%4==0:\n                squares-=1\n        planks[i]-=1\n    if squares>0 and pairs>3:\n        print("YES")\n    else:\n        print("NO")
n = int(input())\nd = n * [0]\n\nfor i in range(n - 1):\n    a, b = list(map(int, input().split()))\n    d[a - 1] += 1\n    d[b - 1] += 1\n\ncnt = 0\nfor i in d:\n    cnt += (i * (i - 1)) // 2\n\nprint(cnt)\n
#!/usr/bin/env python3\n\ndef is_conn(i1, i2):\n  a, b = i1\n  c, d = i2\n  return (c < a < d or c < b < d)\n\nneighbors = {}\nintervals = []\n\nn = int(input())\nfor i in range(0, n):\n  q, x, y = [int(j) for j in input().split()]\n  if q == 1:\n    # we add to the interval\n    ourint = (x,y)\n    intervals.append(ourint)\n    neighbors[ourint] = []\n    # and check for edges\n    for interval in intervals:\n      # if they are connected, join them\n      if is_conn(interval, ourint):\n        neighbors[interval].append(ourint)\n      if is_conn(ourint, interval):\n        neighbors[ourint].append(interval)\n    \n  if q == 2:\n    # we check whether there is a path from x to y\n    # this is easy version, bfs should be enough\n    x -= 1\n    y -= 1\n    a = intervals[x]\n    b = intervals[y]\n    \n    visited = {a}\n    query = [a]\n    while len(query) > 0:\n        j = query[0]\n        query = query[1:]\n        for nei in neighbors[j]:\n            if not nei in visited:\n                query.append(nei)\n                visited = visited | {nei}\n\n    if b in visited:\n        print("YES")\n    else:\n        print("NO")     \n            \n              \n    \n
import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nN, M = list(map(int, input().split()))\nE = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    E[a-1].append(b-1)\n    E[b-1].append(a-1)\n\ninf = 1 << 20\nA, B, C = [], [], []\nX = [0] * N\nfor a in E[0]:\n    X[a] = 1\nA = [i for i in range(N) if X[i]==0]\nb = min([i for i in range(N) if X[i] == 1] + [inf])\nif b < inf:\n    for a in E[b]:\n        if X[a] == 1: X[a] = 2\n    B = [i for i in range(N) if X[i]==1]\nc = min([i for i in range(N) if X[i] == 2] + [inf])\nif c < inf:\n    for a in E[c]:\n        if X[a] == 2: X[a] = 3\n    C = [i for i in range(N) if X[i]==2]\n\nif max(X) == 2 and len(A) * len(B) * len(C) and (len(A) + len(B) + len(C) == N) and (len(A) * len(B) + len(B) * len(C) + len(A) * len(C) == M):\n    f = 0\n    for i in range(N):\n        for j in E[i]:\n            if X[i] == X[j]:\n                f = 1\n                break\n        if f: break\n    if f:\n        print(-1)\n    else:\n        print(*[x+1 for x in X])\nelse:\n    print(-1)\n
# for _ in range(1):\nfor _ in range(int(input())):\n    a, b = list(map(int, input().split()))\n    # n = int(input())\n    # arr = list(map(int, input().split()))\n    # s = input()\n    ans = 0\n    for i in range(a - 1):\n        s = input()\n        if s[-1] != 'D':\n            ans += 1\n    s = input()\n    for i in range(b - 1):\n        if s[i] != 'R':\n            ans += 1\n    print(ans)\n
for _ in range(int(input())):\n    n = int(input())\n    data = input()\n    count = 0\n    while "AP" in data:\n        data = data.replace("AP", "AA")\n        count += 1\n    print(count)\n
\n# returns answer to the subproblem with interval range [start, end],\n# but with a total of "extra" additional stuff on the end\n# that must be deleted last.\nmemo = {}\ndef f(dat, rewards, start, end, extra):\n    curr = (start, end, extra)\n    if curr in memo:\n        return memo[curr]\n    \n    if start > end:\n        return 0\n    if start == end:\n        memo[curr] = rewards[dat[start] + extra]\n        return memo[curr]\n    \n    # test all possible "cut points".\n    # "cut" is the earliest index to die in the same deletion as "end".\n    out = 0\n    for cut in range(end, start-1, -2):\n        if cut == end:\n            # in this case, we're deleting the last interval right away.\n            out_curr = rewards[dat[cut] + extra]\n            out_curr += f(dat, rewards, start, cut-1, 0)\n        else:\n            # split into 2 pieces:\n            # 1) slots [start, cut] plus [end + extra]\n            # 2) slots [cut+1, end-1] (with no extra, this needs to get deleted first).\n            out_curr = f(dat, rewards, start, cut, extra + dat[end])\n            out_curr += f(dat, rewards, cut+1, end-1, 0)\n        \n        out = max(out, out_curr)\n    \n    memo[curr] = out\n    return memo[curr]\n\ndef solve(dat_str, rewards_orig):\n    # break into intervals.\n    dat = []\n    pos = 0\n    while pos < len(dat_str):\n        end = pos\n        while end < len(dat_str) and dat_str[pos] == dat_str[end]:\n            end += 1\n\n        dat.append(end - pos)\n        pos = end\n    \n    # compute the highest-value way to remove a run of size k.\n    # (google translated from C++ thinking)\n    rewards = [0, rewards_orig[0]]\n    for k in range(2, len(rewards_orig) + 1):\n        # print(\n        #     "{}: {}".format(\n        #         k,\n        #         [\n        #             rewards[k-j] + rewards_orig[j-1]\n        #             for j in range(1, k+1)\n        #         ]\n        #     )\n        # )\n        rewards.append(\n            max(\n                rewards[k-j] + rewards_orig[j-1]\n                for j in range(1, k+1)\n            )\n        )\n    \n    # print("dat: {}".format(dat))\n    # print("rewards: {}".format(rewards))\n    \n    return f(dat, rewards, 0, len(dat)-1, 0)\n\n# get the integer\nint_dummy = input()\n# get the string\ndat_str = input().strip()\n# get the array\nrewards_input = input().strip().split()\nrewards_ints = [int(x) for x in rewards_input]\n\n# print(dat_str)\n# print(rewards_ints)\n\nprint((\n    solve(\n        dat_str,\n        rewards_ints,\n    )\n))\n\n\n# dat_test = "10101"\n# rewards_test = [3, 10, 15, 15, 15]\n# print(solve(dat_test, rewards_test))\n
import sys\n\n#f = open('input', 'r')\nf = sys.stdin\nn = int(f.readline())\na = list(map(int, f.readline().split()))\n\ncnt = 0\nfor i in range(n):\n  cnt += sum([1 for x in a[i+1:] if x < a[i]])\n\nm = int(f.readline())\nfor _ in range(m):\n  l, r = list(map(int, f.readline().split()))\n  c = r-l\n  cnt += (c*(c+1)//2)%2\n  if cnt%2 == 0:\n    print('even')\n  else:\n    print('odd')\n
from math import ceil, floor\nQ = int(input())\nfor _ in range(Q):\n    a, b, m = map(int, input().split())\n    if b - a == 0:\n        print(1, a)\n        continue\n    if b - a <= m:\n        print(2, a, b)\n        continue\n    x = max(0, ceil(b/(a+m)) - 1)\n    y = max(0, floor(b/(a+1)))\n    if x.bit_length() < y.bit_length():\n        h = y.bit_length()\n        t = b - a*2**(h-1)\n        M = [t//(2**(h-1))]*h\n        t %= 2**(h-1)\n        for i in range(h-1):\n            j = h - 2 - i\n            if 2**j & t:\n                M[i] += 1\n        sumi = a\n        ans = [a] + [0]*h\n        assert all(m > 0 for m in M), ''\n        for i in range(1, h+1):\n            ans[i] = sumi + M[i-1]\n            sumi += ans[i]\n        if len(ans) > 50:\n            print(-1)\n        else:\n            print(len(ans), *ans)\n    else:\n        print(-1)
n = int(input())\n\na = []\nfor i in range(2*n - 1):\n    a.append([int(c) for c in input().split()])\n\n\nc = []\nfor i in range(len(a)):\n    for j in range(len(a[i])):\n        c.append([a[i][j], i+1, j])\n\nc.sort(reverse=True)\nused = set()\nres = [0]*2*n\nfor cc in c:\n    if not cc[1] in used and not cc[2] in used:\n        res[cc[1]] = cc[2] + 1\n        res[cc[2]] = cc[1] + 1\n        used.add(cc[1])\n        used.add(cc[2])\n\nprint(' '.join(str(r) for r in res))\n
t = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    arr.sort(reverse=True)\n    print(min(arr[1] - 1, len(arr) - 2))
n=int(input())\nA = [0] * (2*n)\nper1 = 0\nper2 = n\nfor i in range(1, n):\n    if i % 2==1:\n        A[per1] = i\n        A[per1+n-i] = i\n        per1+=1\n    else:\n        A[per2] = i\n        A[per2+n-i] = i\n        per2+=1\n\nA[-1] = n\nif n % 2 == 1:\n    A[n//2] = n\nelse:\n    A[-(n//2+1)] = n\nprint(' '.join(map(str, A)))
n = int(input())\nl = input()\nprint(n+1)\n
from collections import deque\n\ndef addedge(u, v, value):\n	nonlocal e\n	a = [v, value, None]\n	b = [u, 0, a]\n	a[2] = b\n	e[u].append(a)\n	e[v].append(b)\n	\n\ninf = 2 * (10 ** 12)\nans = 0\nn, m = list(map(int, input().split()))\ne = [[] for i in range(n + m + 2)]\na = tuple(map(int, input().split()))\nS, T = 0, m + n + 1\nfor i in range(1, m + 1):\n	u, v, w = list(map(int, input().split()))\n	ans += w\n	addedge(i, u + m, inf)\n	addedge(i, v + m, inf)\n	addedge(S, i, w)\nfor i in range(m + 1, T):\n	addedge(i, T, a[i - m - 1])\n# for i in range(n + m + 2):\n# 	for edge in e[i]:\n# 		print('%d to %d w %d' % (i, edge[0] if edge[0] <= m else edge[0] - m, edge[1]))\n\nlvl = None\ndef bfs():\n	nonlocal e, lvl\n	lvl = [0] * (n + m + 2)\n	q = deque([0])\n	while q:\n		node = q.popleft()\n		# print('node = %d' % node)\n		for edge in e[node]:\n			if edge[0] != 0 and lvl[edge[0]] == 0 and edge[1]:\n				lvl[edge[0]] = lvl[node] + 1\n				q.append(edge[0])\n	# print(lvl)\n\n\ndef dfs(node, maxdelta):\n	nonlocal e, lvl\n	if node == T:\n		return maxdelta\n	delta = 0\n	for edge in e[node]:\n		if lvl[edge[0]] == lvl[node] + 1 and edge[1]:\n			tmp = dfs(edge[0], min(maxdelta, edge[1]))\n			if tmp > 0:\n				edge[1] -= tmp\n				edge[2][1] += tmp\n				maxdelta -= tmp\n				delta += tmp\n			if maxdelta == 0:\n				break\n	return delta\n\nflow = 0\nwhile 1:\n	bfs()\n	tmp = dfs(0, inf)\n	if tmp == 0:\n		break\n	flow += tmp\nans -= flow\nprint(ans)\n\n\n\n\n\n
from itertools import count\nfrom collections import deque\nfrom heapq import heappop, heappush\n \nclass Edge(object):\n    __slots__ = ('x', 'y', 'cap', 'cost', 'inv')\n    def __repr__(self):\n        return f'{self.x}-->{self.y} ({self.cap} , {self.cost})'\n\nclass MCFP(list):\n    inf = float('inf')\n    \n    def add(G, x, y, cap, cost):\n        G.extend(([] for i in range(max(0,max(x,y)+1-len(G)))))\n        e = Edge()\n        e.x=x ; e.y=y; e.cap=cap; e.cost=cost\n        z = Edge()\n        z.x=y ; z.y=x; z.cap=0; z.cost=-cost\n        e.inv=z ; z.inv=e\n        G[x].append(e)\n        G[y].append(z)\n \n    def solve(G, src, tgt, flowStop=float('inf')):\n        n = len(G)\n        flowVal = flowCost = 0\n        phi, prev, dist = [0]*n, [None]*n, [G.inf]*n\n        for it in count():\n            G.shortest(src, phi, prev, dist, tgt)\n            if prev[tgt]==None:\n                break\n            p = list(G.backward(tgt, src, prev))\n            z = min(e.cap for e in p)\n            for e in p: e.cap -= z ; e.inv.cap += z\n            flowVal += z\n            flowCost += z * (dist[tgt] - phi[src] + phi[tgt])\n            if flowVal==flowStop: break\n            for i in range(n):\n                if prev[i] != None:\n                    phi[i] += dist[i]\n                    dist[i] = G.inf\n        #print(it)\n        return flowVal, flowCost\n\n    def backward(G, x, src, prev):\n        while x!=src: e = prev[x] ; yield e ; x = e.x\n\n    def shortest_(G, src, phi, prev, dist, tgt):\n        prev[tgt] = None\n        dist[src] = 0\n        Q = [(dist[src], src)]\n        k = 0\n        while Q:\n            k += 1\n            d, x = heappop(Q)\n            if dist[x]!=d: continue\n            for e in G[x]:\n                if e.cap <= 0: continue\n                dy = dist[x] + phi[x] + e.cost - phi[e.y]\n                if dy < dist[e.y]:\n                    dist[e.y] = dy\n                    prev[e.y] = e\n                    heappush(Q, (dy, e.y))\n        print(k)\n        return\n\n    def shortest(G, src, phi, prev, dist, tgt):\n        prev[tgt] = None\n        dist[src] = 0\n        Q = deque([src])\n        inQ = [0]*len(G)\n        sumQ = 0\n        while Q:\n            x = Q.popleft()\n            inQ[x] = 0\n            sumQ -= dist[x]\n            for e in G[x]:\n                if e.cap <= 0: continue\n                dy = dist[x] + phi[x] + e.cost - phi[e.y]\n                if dy < dist[e.y]:\n                    dist[e.y] = dy\n                    prev[e.y] = e\n                    if inQ[e.y]==0:\n                        inQ[e.y]=1\n                        sumQ += dy\n                        if Q and dy > dist[Q[0]]: Q.append(e.y)\n                        else: Q.appendleft(e.y)\n                        avg = sumQ/len(Q)\n                        while dist[Q[0]] > avg: Q.append(Q.popleft())\n        return\n\n    def shortest_(G, src, phi, prev, dist, tgt):\n        prev[tgt] = None\n        dist[src] = 0\n        H = [(0, src)]\n        inQ = [0]*len(G)\n        k = 0\n        while H:\n            k += 1\n            d, x = heappop(H)\n            if dist[x]!=d: continue\n            for e in G[x]:\n                if e.cap <= 0: continue\n                dy = dist[x] + phi[x] + e.cost - phi[e.y]\n                if dy < dist[e.y]:\n                    dist[e.y] = dy\n                    prev[e.y] = e\n                    heappush(H, (dy, e.y))\n        print(k)\n        return\n\nimport sys, random\nints = (int(x) for x in sys.stdin.read().split())\nsys.setrecursionlimit(3000)\n\ndef main():\n    n, k = (next(ints) for i in range(2))\n    a = [next(ints) for i in range(n)]\n    b = [next(ints) for i in range(n)]\n    G = MCFP()\n    src, tgt, the_src = 2*n+1, 2*n+2, 2*n+3\n    G.add(the_src, src, k, 0)\n    for i in range(n):\n        G.add(src, i, 1, 0)\n        G.add(i, i+n, 1, a[i])\n        G.add(i+n, tgt, 1, b[i])\n        if i+1<n:\n            G.add(i, i+1, n, 0)\n            G.add(i+n, i+n+1, n, 0)\n    flowVal, ans = G.solve(the_src, tgt, k)\n    assert flowVal == k\n    print(ans)\n    return\n\ndef test(n,k):\n    R = random.Random(0)\n    yield n ; yield k\n    for i in range(n): yield R.randint(1, 10**9)\n    for i in range(n): yield R.randint(1, 10**9)\n\n#ints=test(1000, 800)\n\nmain()
for i in range(int(input())):\n    t = input().split(':')\n    if t[-1] == '': t.pop()\n    elif t[0] == '': t.pop(0)\n    if '' in t: t[t.index('')] = ('0000:' * (9 - len(t)))[: -1]\n    print(':'.join('0' * (4 - len(i)) + i for i in t))
from sys import stdout\n\nn = int(input())\n\n\nclass Person:\n\n    num = n - 1\n\n    def __init__(self, rel):\n        self.relationship = int(rel, 2)\n\n    def __getitem__(self, k):\n        return (self.relationship >> Person.num - k) & 1\n\n\nrel = [Person(input()) for _ in range(n)]\n\ndp = [[0] * n for _ in range(1 << n)]\n\nfor people in range(1, 1 << n):\n    ones = [i for i in range(n) if people & (1 << i)]\n    # print(f'ones: {ones}')\n    one_num = len(ones)\n\n    if one_num == 1:\n        dp[people][ones[0]] = [1]\n        continue\n\n    for i in ones:\n        dp[people][i] = [0] * (1 << one_num - 1)\n        pre_people = people ^ (1 << i)\n        for j in ones:\n            if j == i:\n                continue\n            for pre_s, times in enumerate(dp[pre_people][j]):\n                s = pre_s | (rel[j][i] << one_num - 2)\n                # print(f'dp[{people}][{i}][{s}]: {dp[people][i][s]}')\n                dp[people][i][s] += times\n\npeople = (1 << n) - 1\n\nfor s in range(1 << (n-1)):\n    ans = 0\n    for i in range(n):\n        ans += dp[people][i][s]\n    print(ans, end=' ')
t = int(input())\nfor _ in range(t):\n    s = input().strip('0')\n    print(s.count('0'))\n\n
t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n\n    if list(sorted(a)) == a or not all(x == b[0] for x in b):\n        print("Yes")\n    else:\n        print("No")\n
from itertools import accumulate\nfrom bisect import bisect_right\nimport sys\n\nn, q = list(map(int, sys.stdin.readline().split()))\na = list(map(int, sys.stdin.readline().split()))\nk = list(map(int, sys.stdin.readline().split()))\n\ns = list(accumulate(a))\n\nsofar = 0\nfor x in k:\n    sofar += x\n    if sofar >= s[-1]:\n        sofar = 0\n    sys.stdout.write(str(n - bisect_right(s, sofar)) + '\n')\n
import sys\nreadline = sys.stdin.readline\nN, M = map(int, readline().split())\n\nEdge = [[] for _ in range(N)]\n\nfor _ in range(M):\n    a, b = map(int, readline().split())\n    a -= 1\n    b -= 1\n    Edge[a].append(b)\n    Edge[b].append(a)\n\nused = set()\nans = 0\nmp = -1\nfor i in range(N):\n    if i in used:\n        continue\n    if mp >= i:\n        ans += 1\n        Edge[mp].append(i)\n        Edge[i].append(mp)\n        mp = max(mp, i)\n    else:\n        st = i\n    \n    stack = [i]\n    while stack:\n        vn = stack.pop()\n        for vf in Edge[vn]:\n            if vf not in used:\n                mp = max(mp, vf)\n                used.add(vf)\n                stack.append(vf)\n\nprint(ans)
n = int(input())\nseq = sorted(list(map(int, input().split())))\n\n#Left (inc), Right(exc), bit to check, value to add \nqueue = [(0,n,30,0)]\nbest = 2 ** 30\nwhile queue:\n    l, r, b, v = queue.pop()\n    if b >= 0:\n        mask = 1 << b\n        \n        if not mask & seq[l] and mask & seq[r - 1]:\n            for i in range(l, r):\n                if mask & seq[i]:\n                    queue.append((l,i,b - 1, v + mask))\n                    queue.append((i,r,b - 1, v + mask))\n                    break\n        else:\n            queue.append((l, r, b - 1, v))\n    else:\n        best = min(best, v)\n        \nprint(best)\n
t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    works = True\n    if n % 2:\n        if a[n//2] != b[n//2]:\n            works = False\n\n    pairsA = []\n    for i in range(n//2):\n        f = a[i]\n        s = a[n - i - 1]\n        if f > s:\n            f, s = s, f\n        pairsA.append((f,s))\n\n    pairsB = []\n    for i in range(n//2):\n        f = b[i]\n        s = b[n - i - 1]\n        if f > s:\n            f, s = s, f\n        pairsB.append((f,s))\n\n    pairsA.sort()\n    pairsB.sort()\n\n    if works and pairsA == pairsB:\n        print('Yes')\n    else:\n        print('No')\n
import sys\ninput = sys.stdin.readline\n\nm, n = list(map(int, input().split()))\nDora = []\nSwiper = []\nall = set([i for i in range(1, n+1)])\nfor _ in range(m):\n    a = set(list(map(int, input().split()))[1:])\n    Dora.append(a)\n    Swiper.append(all.difference(a))\n\nflag = 1\nfor i in range(m):\n    for j in range(m):\n        if Dora[i] | Swiper[j] == Swiper[j]:\n            flag = 0\n            break\n    if flag == 0:\n        break\n\nif flag == 1:\n    print("possible")\nelse:\n    print("impossible")\n
from bisect import *\nd = [{}, {}]\ni = [0, 0]\nfor q in range(int(input())):\n    a, t, x = map(int, input().split())\n    for k in [0, 1]:\n        d[k][x] = d[k].get(x, [])\n        i[k] = bisect(d[k][x], t)\n    if a < 3: d[-a][x].insert(i[-a], t)\n    else: print(i[1] - i[0])
n=int(input())\na=list(map(int,input().split()))\n\nlastocc=[0]*1000006\nans=[0]*n\nans[0]=1\nlastocc[a[0]]=1\n\nfor i in range(1,n):\n    ans[i]=ans[i-1]+(i+1-lastocc[a[i]])\n    lastocc[a[i]]=i+1\n\nprint((2*sum(ans)-n)/(n*n))\n
import math;\n#Вычисление координаты точки по координатам центра, углу, и начальным относительно центра\ndef getCoordinate(gx, gy, alpha, x, y):\n    x1=gx+x*math.cos(alpha)-y*math.sin(alpha);\n    y1=gy+x*math.sin(alpha)+y*math.cos(alpha);\n    return x1, y1\n#Вычисление угла, на который надо повернуть точку с координатами x, y,\n#чтобы она оказалась прямо над gx, gy\ndef getAngle(gx, gy, x, y):\n    x=x-gx;\n    y=y-gy;\n    cos=x/math.sqrt(x**2+y**2);\n    alpha=math.acos(cos);\n    if y<0:\n        alpha=-alpha;\n    return math.pi/2-alpha;\nn, q = list(map(int, input().split(' ')));\nx=[0]*n;\ny=[0]*n;\nfor i in range(n):\n    x[i], y[i]=list(map(int, input().split(' ')));\nr=[0]*q;\nf=[0]*q;\nt=[0]*q;\nv=[0]*q;\nfor i in range(q):\n    l=list(map(int, input().split(' ')));\n    r[i]=l[0];\n    if r[i]==1:\n        f[i]=l[1]-1;\n        t[i]=l[2]-1;\n    else:\n        v[i]=l[1]-1;\ngx=0;\ngy=0;\ns=0;\nfor i in range(n):\n    ip=i+1;\n    if ip==n:\n        ip=0;\n    ds=x[i]*y[ip]-x[ip]*y[i];\n    s+=ds;\n    gx+=(x[i]+x[ip])*ds;\n    gy+=(y[i]+y[ip])*ds;\ns/=2;\ngx/=6*s;\ngy/=6*s;\nangles=[0]*n;\nfor i in range(n):\n    angles[i]=getAngle(gx, gy, x[i], y[i]);\nfor i in range(n):\n    x[i]-=gx;\n    y[i]-=gy;\nalpha=0;\n#print('pos',gx, gy, alpha);\n#Восстанавливать положение точек будем по центру масс и углу\n#Угол - поворот против часовой вокруг центра масс\nfix={0, 1}\nfor i in range(q):\n    if r[i]==2:\n        currX, currY = getCoordinate(gx, gy, alpha, x[v[i]], y[v[i]]);\n        print("%.6f %.6f"%(currX, currY))\n    else:\n        if len(fix)==2:\n            fix.remove(f[i]);\n        #print('remove',f[i])\n        #j - единственный элемент в множестве\n        for j in fix:\n            #print(j);\n            currX, currY = getCoordinate(gx, gy, alpha, x[j], y[j]);\n            #print('fix:', currX, currY)\n            #dalpha=getAngle(gx, gy, currX, currY);\n            #alpha+=dalpha;\n            alpha=angles[j];\n            #Чтобы вычислить новые координаты g, нуно повернуть ее на угол\n            #dalpha относительно currX, currY\n            gx, gy=currX, currY-math.sqrt(x[j]**2+y[j]**2);\n            \n            #print('pos',gx, gy, alpha/math.pi)\n        fix.add(t[i]);\n        \n
def s(k):\n	if k % 2 == 0:\n		return k // 2\n	else:\n		return - (k + 1) // 2\n\n\nfor i in range(int(input())):\n	l, r = list(map(int, input().split()))\n	print(s(r) - s(l - 1))\n
t = int(input())\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\nfor i in range(t):\n    a, b, q = map(int, input().split())\n    z = gcd(a, b)\n    target = (a * b)//z\n    pref = [0]\n    for j in range(1, target + 1):\n        if (j%a)%b != (j%b)%a:\n            pref.append(pref[-1]+1)\n        else:\n            pref.append(pref[-1])\n    \n    result = []\n    for i in range(q):\n        l , r = map(int, input().split())\n        temp_r = (r//target) * pref[-1]\n        r = r%target\n        l -= 1\n        temp_l = (l//target) * pref[-1]\n        l = l%target\n        temp_r += pref[r]\n        temp_l += pref[l]\n        result.append(temp_r - temp_l)\n    print(*result)
n, m = list(map(int, input().split()))\nM = [list(map(int, input().split())) for r in range(n)]\n\ndepth = [[1] * m for r in range(n)]\n\nfor c in range(m):\n    for r in range(1, n):\n        if M[r][c] >= M[r - 1][c]:\n            depth[r][c] = depth[r - 1][c] + 1\n\nmax_depth = [max(col) for col in depth]\n\nans = ""\nk = int(input())\nfor i in range(k):\n    l, r = list(map(int, input().split()))\n    if max_depth[r - 1] >= r - l + 1:\n        ans += "Yes\n"\n    else:\n        ans += "No\n"\n\nprint(ans)\n
from sys import *\nfrom math import *\n\nmod = 1000000000\nf = [0 for i in range(200)]\nf[0] = f[1] = 1\nfor i in range(2, 200):\n  f[i] = f[i - 1] + f[i - 2]\nn, m = stdin.readline().split()\nn = int(n)\nm = int(m)\na = list(map(int, stdin.readline().split()))\nfor i in range(m):\n  tp, x, y = stdin.readline().split()\n  tp = int(tp)\n  x = int(x)\n  y = int(y)\n  if tp == 1:\n    x -= 1\n    a[x] = y\n  else:\n    s = 0\n    x -= 1\n    y -= 1\n    for p in range(y - x + 1):\n      s += f[p] * a[x + p]\n    print(s % mod)\n
import sys\ninput = sys.stdin.readline\n\nn = int(input())\nx = sorted(list(map(int, input().split())))\na, b = x[:n//2], x[n//2:]\ntmp = []\nfor i in range(n//2):\n    tmp.append(b[i])\n    tmp.append(a[i])\nif n % 2:\n    tmp.append(b[-1])\ncnt = 0\nfor i in range(1, n-1, 2):\n    if tmp[i+1] > tmp[i] < tmp[i-1]:\n        cnt += 1\nprint(cnt)\nprint(*tmp)
import sys\nfrom collections import Counter\nreadline = sys.stdin.readline\n\nN = int(readline())\nA = list(map(int, readline().split()))\ngeta = 10**9+7\n\nQ = int(readline())\nC = Counter()\n\nAns = [sum(A)] + [0]*Q\nA = [0] + A\ntable = [geta] + [0]*N\nfor qu in range(1, Q+1):\n    s, t, u = list(map(int, readline().split()))\n    vn = s*geta + t\n    res = 0\n    cv = C[vn]\n    if u != cv:\n        if table[cv] <= A[cv]:\n            res = 1\n        table[cv] -= 1\n        if table[u] < A[u]:\n            res -= 1\n        table[u] += 1\n    C[vn] = u\n    Ans[qu] = Ans[qu-1] + res\nprint('\n'.join(map(str, [max(1, a) for a in Ans[1:]])))\n
class Solution:\n    def reverseWords(self, s: str) -> str:\n        sLst = s.split()\n        # print(sLst)\n        reverseStr = ""\n\n        for i in range(len(sLst)-1,-1,-1):\n            if i == (len(sLst)-1):\n                reverseStr+=sLst[i]\n            else:\n                reverseStr+=(" "+sLst[i])\n        return reverseStr
import sys\nimport math\nimport collections\nimport bisect\nimport itertools\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline().rstrip())\nns = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().rstrip().split()])\n\n\n# ===CODE===\n\ndef main():\n    n, m = ns()\n    e = [[] for _ in range(n)]\n    for _ in range(m):\n        l, r, d = ns()\n        l, r = l - 1, r - 1\n        e[l].append([r, d])\n        e[r].append([l, -d])\n\n    visited = [False] * n\n    dist_mat = [INF] * n\n\n    for i in range(n):\n        if visited[i]:\n            continue\n        que = collections.deque()\n        que.append([i, 0])\n        visited[i] = True\n        dist_mat[i] = 0\n        while que:\n            idx, dist = que.popleft()\n            for ei, di in e[idx]:\n                if visited[ei]:\n                    if dist + di == dist_mat[ei]:\n                        continue\n                    else:\n                        print("No")\n                        return\n                else:\n                    visited[ei] = True\n                    dist_mat[ei] = dist + di\n                    que.append([ei, dist + di])\n\n    print("Yes")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
import sys\nfrom collections import defaultdict\n\n# 再帰制限を緩和するおまじない\nsys.setrecursionlimit(10**6)\n\ndef sum(n):return n*(n+1)//2\n\n# 部分木のサイズと、「色iを封鎖したときに到達できない頂点の個数」を持つ辞書を返す\ndef dfs(v,p):\n    ret=defaultdict(int)\n    size=1\n    for vv in g[v]:\n        if vv==p:\n            continue\n        ss,d=dfs(vv,v)\n        size+=ss\n        ans[c[v]]+=sum(ss-d[c[v]])\n        \n        # マージテク\n        if len(ret)<len(d):\n            ret,d=d,ret\n        for vvv in d:\n            ret[vvv]+=d[vvv]\n    ret[c[v]]=size\n    return size,ret\n\nn=int(input())\nc=list(map(int,input().split()))\ng=[[] for _ in range(n+1)]\nans=[0]*(n+1)\nfor _ in range(n-1):\n    s,t=list(map(int, input().split()))\n    s-=1\n    t-=1\n    g[s].append(t)\n    g[t].append(s)\n_,ret=dfs(0,-1)\nfor i in range(1,n+1):\n    print((sum(n)-ans[i]-sum(n-ret[i])))\n
import sys\ninput = sys.stdin.readline\n\ndef main():\n    N = int(input())\n    t = list(map(lambda x: int(x) * 2, input().split()))\n    v = list(map(float, input().split())) + [0]\n\n    for i in range(1, N):\n        t[i] += t[i-1]\n    t += [t[-1]]\n    vnow = [0.0] * (t[-1] + 1)\n    vr = [0.0] * (t[-1] + 1)\n    r = 0\n    for i in range(1, len(vr)):\n        if i < t[r]:\n            vr[i] = v[r]\n        elif i == t[r]:\n            vr[i] = min(v[r], v[r+1])\n            r += 1\n        vnow[i] = min(vnow[i-1] + 0.5, vr[i])\n    for i in range(len(vr)-2, -1, -1):\n        vnow[i] = min(vnow[i], vnow[i+1] + 0.5)\n    \n    print(sum(vnow) / 2)\n\ndef __starting_point():\n    main()\n__starting_point()
n = int(input())\nl = input()\nl = l.split()\nc = 0\nfor i in range(len(l)):\n    l[i] = int(l[i])\n    if l[i]%2 == 0:\n        c += 1\n    else:\n        c -= 1\n\nif c > 0:\n    print("READY FOR BATTLE")\nelse:\n    print("NOT READY")\n
T = int(input())\n\nfor _ in range(T):\n	x = input()[::-1]\n	y = input()[::-1]\n\n	start = y.index("1")\n\n	offset = x[start:].index("1")\n\n	print(offset)
n=int(input())\nla=[]\nle=[]\nli=[]\nlo=[]\nlu=[]\nans=[]\nd1={}\nfor i in range(n):\n    s=input()\n    x=s.count('a')+s.count('e')+s.count('i')+s.count('o')+s.count('u')\n    if x>0:\n        \n        for c in s[::-1]:\n            if c=='a' or c=='e' or c=='i' or c=='o' or c=='u':\n                break\n        if (x,c) in d1:\n            d1[(x,c)].append(s)\n        else :\n            d1[(x,c)]=[s]\nd2={}\npairs1=[]\npairs2=[]\nfor k in d1:\n    if len(d1[k])%2==1:\n        if k[0] in d2:\n            d2[k[0]].append(d1[k][0])\n        else :\n            d2[k[0]]=[d1[k][0]]\n        for i in range(1,len(d1[k]),2):\n            pairs1.append((d1[k][i],d1[k][i+1]))\n    else :\n        for i in range(0,len(d1[k]),2):\n            pairs1.append((d1[k][i],d1[k][i+1]))\nfor k in d2:\n    if len(d2[k])>1:\n        if len(d2[k])%2==1:\n            d2[k].pop()\n        for i in range(0,len(d2[k]),2):\n            pairs2.append((d2[k][i],d2[k][i+1]))\nif len(pairs1)<len(pairs2):\n    print(len(pairs1))\n    for i in range(len(pairs1)):\n        print(pairs2[i][0],pairs1[i][0])\n        print(pairs2[i][1],pairs1[i][1])\nelse :\n    print(len(pairs2)+(len(pairs1)-len(pairs2))//2)\n    for i in range(len(pairs2)):\n        print(pairs2[i][0],pairs1[i][0])\n        print(pairs2[i][1],pairs1[i][1])\n    for j in range(len(pairs2),len(pairs1),2):\n        if j==len(pairs1)-1:\n            break\n        else :\n            print(pairs1[j][0],pairs1[j+1][0])\n            print(pairs1[j][1],pairs1[j+1][1])\n    \n
t = int(input())\nfor i in range(t):\n    input()\n    m,k = map(int,input().split())\n    ak = list(map(int,input().split()))\n    ak2 = [0]*k\n    tjrj = [list(map(int,input().split())) for j in range(m-1)]\n    num = 0\n    num2 = 0\n    num3 = 100002\n    for j in range(m-1):\n        if num2 == 1 or tjrj[j][1] == 0:\n            if tjrj[j][0] != 0:\n                ak[tjrj[j][0]-1] -= 1\n            else:\n                num += 1\n        else:\n            for z in range(k):\n                    if ak[z] - num < 1:\n                        ak2[z] = 1\n            num2 = 1\n            if tjrj[j][0] != 0:\n                ak[tjrj[j][0]-1] -= 1\n            else:\n                num += 1\n            for f in range(j,m-1):\n                if tjrj[f][0] != 0:\n                    ak2[tjrj[f][0]-1] = 0\n            for f in range(k):\n                if ak2[f] == 1:\n                    if num3 > ak[f]:\n                        num3 = ak[f]\n            num -= num3\n    for z in range(k):\n        if ak[z] - num < 1 or ak2[z] == 1:\n            print("Y",end="")\n        else:\n            print("N",end="")\n    print()\n
from collections import Counter\nfrom itertools import product\nn,m,k = map(int,input().split())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\na1 = [0]\nb1 = [0]\nfor i in range(n):\n  if a[i] == 1:\n    a1[-1] += 1\n  elif a1[-1] != 0:\n    a1.append(0)\nfor i in range(m):\n  if b[i] == 1:\n    b1[-1] += 1\n  elif b1[-1] != 0:\n    b1.append(0)\npr = []\nfor i in range(1,int(k**0.5)+1):\n  if k%i == 0 and k//i <= 40000:\n    pr.append((i,k//i))\n    if i != k//i:\n      pr.append((k//i,i))\nca = Counter(a1)\ncb = Counter(b1)\nans = 0\nfor i,j in product(ca.items(),cb.items()):\n  for x,y in pr:\n    if i[0] >= x and j[0] >= y:\n      ans += i[1]*j[1]*(i[0]-x+1)*(j[0]-y+1)\nprint(ans)
for __ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    ar.sort()\n    ans = "NO"\n    for i in range(1, n):\n        if ar[i] == ar[i - 1]:\n            ans = 'YES'\n            break\n    print(ans)
import sys\n\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep="\n")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef solve():\n    cs = [aa[0]]\n    for a in aa[1:]: cs.append((cs[-1] + a) % md)\n    # print(cs)\n\n    inv = pow(n, md - 2, md)\n    ans = []\n    for k in range(1, n):\n        cur = 0\n        for i in range(1, n):\n            if n - 1 - k * i < 0: break\n            cur = (cur + cs[n - 1 - k * i]) % md\n        cur = cur * inv % md\n        ans.append(cur)\n    ans.append(0)\n    print(*ans)\n\nmd=998244353\nn=II()\naa=LI()\naa.sort()\nsolve()\n
import sys\nreadline = sys.stdin.readline\n\ndef accumulate2d(X):\n    N = len(X)\n    M = len(X[0])\n    \n    for i in range(0, N):\n        for j in range(1, M):\n            X[i][j] += X[i][j-1]\n    \n    for j in range(0, M):\n        for i in range(1, N):\n            X[i][j] += X[i-1][j]\n    \n    return X\n\nN, M, Q = map(int, readline().split())\ntable = [None]*100\ntable[ord('R')] = 0\ntable[ord('G')] = 1\ntable[ord('B')] = 2\ntable[ord('Y')] = 3\n\nINF = 10**3\nD = [[table[ord(s)] for s in readline().strip()] for _ in range(N)]\nG = [[0]*M for _ in range(N)]\n\nBS = 25\ncandi = []\ngeta = M\nfor i in range(N-1):\n    for j in range(M-1):\n        if D[i][j] == 0 and D[i][j+1] == 1 and D[i+1][j+1] == 2 and D[i+1][j] == 3:\n            G[i][j] = 1\n            nh, nw = i, j\n            while True:\n                k = G[nh][nw]\n                fh, fw = nh-k, nw-k\n                k2 = 2*(k+1)\n                kh = k+1\n                if fh < 0 or fw < 0 or N < fh+k2-1 or M < fw+k2-1:\n                    break\n                if any(D[fh][j] != 0 for j in range(fw, fw+kh)) or\\n                any(D[j][fw] != 0 for j in range(fh, fh+kh)) or\\n                any(D[fh][j] != 1 for j in range(fw+kh, fw+k2)) or\\n                any(D[j][fw+k2-1] != 1 for j in range(fh, fh+kh)) or\\n                any(D[j][fw+k2-1] != 2 for j in range(fh+kh, fh+k2)) or\\n                any(D[fh+k2-1][j] != 2 for j in range(fw+kh, fw+k2)) or\\n                any(D[fh+k2-1][j] != 3 for j in range(fw, fw+kh)) or\\n                any(D[j][fw] != 3 for j in range(fh+kh, fh+k2)):\n                    break\n                G[nh][nw] += 1\n            if G[nh][nw] > BS:\n                candi.append((nh, nw))\n\n \nGnum = [None] + [[[0]*M for _ in range(N)] for _ in range(BS)]\nfor h in range(N):\n    for w in range(M):\n        if G[h][w] > 0:\n            for k in range(1, min(BS, G[h][w])+1):\n                Gnum[k][h][w] = 1\n\nGnum = [None] + [accumulate2d(g) for g in Gnum[1:]]\n\n\nAns = [None]*Q\nfor qu in range(Q):\n    h1, w1, h2, w2 = map(lambda x: int(x)-1, readline().split())\n    res = 0\n    for k in range(min(BS, h2-h1+1, w2-w1+1), 0, -1):\n        hs, ws = h1+k-1, w1+k-1\n        he, we = h2-k, w2-k\n        if hs <= he and ws <= we:\n            cnt = Gnum[k][he][we]\n            if hs:\n                cnt -= Gnum[k][hs-1][we]\n            if ws:\n                cnt -= Gnum[k][he][ws-1]\n            if hs and ws:\n                cnt += Gnum[k][hs-1][ws-1]\n            if cnt:\n                res = k\n                break\n    \n    for nh, nw in candi:\n        if h1 <= nh <= h2 and w1 <= nw <= w2:\n            res = max(res, min(nh-h1+1, h2-nh, nw-w1+1, w2-nw, G[nh][nw]))\n    Ans[qu] = 4*res**2\nprint('\n'.join(map(str, Ans)))
t = int(input())\nfor i in range(t):\n	l, r = list(map(int, input().split()))\n	print(l, 2 * l)\n
import sys\ninput = sys.stdin.readline\ndef main():\n    t = int(input())\n    \n    for _ in range(1, t+1):\n    \n        x, n, m = map(int, input().split())\n        while(n):\n            if(x <= (x>>1) + 10):\n                break\n            x = (x>>1) + 10\n            n -= 1\n        x -= m * 10\n        if(x > 0):\n            print("NO")\n        else:\n            print("YES")\n        \n        \n        \nmain()
import sys\nfrom itertools import *\nfrom math import *\ndef solve():\n    n,m,leftbank,rightbank = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    smallx = leftbank\n    leftbest, rightbest, distbest = -100, -100, 100000000\n    for i, bcord, length in zip(count(), b, l):\n        wanty = bcord * smallx / rightbank\n        ll , rr = 0, n - 1\n        while ll < rr:\n            mm = (ll + rr + 1) // 2\n            if a[mm] > wanty: rr = mm - 1\n            else: ll = mm\n        for pos in range(ll - 1, ll + 2):\n            if pos >= 0 and pos < n:\n                first = sqrt(smallx * smallx + a[pos] * a[pos])\n                second = sqrt((rightbank -leftbank)*(rightbank - leftbank) + (bcord - a[pos])*(bcord - a[pos]))\n                totaldist = first + second + length\n                if totaldist < distbest:\n                    distbest = totaldist\n                    leftbest = pos\n                    rightbest = i\n    print(leftbest + 1, rightbest + 1)\n\n\nif sys.hexversion == 50594544 : sys.stdin = open("test.txt")\nsolve()
#!/usr/bin/env python\nimport sys\ninput = sys.stdin.readline\n\n\ndef cnt(s):\n    l = [[s[0], 1]]\n    for c in s[1:]:\n        if l[-1][0] == c:\n            l[-1][1] += 1\n        else:\n            l.append([c, 1])\n    return l\n\n\ndef cmp(sc, tc):\n    if len(tc) != len(sc):\n        # print(f'sc = {sc}, tc = {tc}')\n        return False\n    for i in range(len(tc)):\n        if tc[i][0] != sc[i][0] or tc[i][1] < sc[i][1]:\n            # print(f'sc = {sc}, tc = {tc}, i = {i}')\n            return False\n    return True\n\n\nfor _ in range(int(input())):\n    s, t = input().strip(), input().strip()\n    sc, tc = cnt(s), cnt(t)\n    print('YES' if cmp(sc, tc) else 'NO')\n\n
def num(c):\n    return ord(c) - 97\n\nimport sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s1 = input().strip()\n    s2 = input().strip()\n\n    char1 = [0] * 26\n    char2 = [0] * 26\n    for c in s1:\n        char1[num(c)] += 1\n    for c in s2:\n        char2[num(c)] += 1\n    if char1 != char2:\n        print(-1)\n        continue\n\n    dp = [[(False, 0, 0) for j in range(n+1)] for i in range(n + 1)]\n    dp[0][0] = [True, 0,[0]*26]\n\n    def upd(a, b, val, sett):\n        if not dp[a][b][0] or val > dp[a][b][1]:\n            dp[a][b] = (True, val, sett)\n    \n    for i in range(n):\n        for j in range(n):\n            valid, val, tab = dp[i][j]\n            if not valid:\n                continue\n            \n            top = s1[i]\n            bot = s2[j]\n\n            if top == bot:\n                #upd(i+1, j+1, val + 1, tab)\n                if not dp[i + 1][j + 1][0] or val + 1 > dp[i + 1][j + 1][1]:\n                    dp[i + 1][j + 1] = [True, val + 1, tab]\n\n            if tab[num(top)] > 0:\n                sett = tab[:]\n                sett[num(top)] -= 1\n                \n                #upd(i+1, j, val, sett)\n                if not dp[i + 1][j][0] or val > dp[i + 1][j][1]:\n                    dp[i + 1][j] = [True, val, sett]\n\n            sett = tab[:]\n            sett[num(bot)] += 1\n            #upd(i, j + 1, val, sett)\n            if not dp[i][j + 1][0] or val > dp[i][j + 1][1]:\n                dp[i][j + 1] = [True, val, sett]\n\n            del dp[i][j][2]\n\n    poss = [dp[i][n][1] for i in range(n + 1)]\n        \n\n    print(n - max(poss))\n            \n    \n
from collections import *\ndef go():\n n,s,t=int(input()),input(),input()\n if Counter(s)!=Counter(t): return -1\n ans=0\n for i in range(n):\n  k=0\n  for j in range(i,n):\n   while k<n and s[k] != t[j]: k += 1\n   if k == n: break\n   k += 1\n   ans = max(ans, j-i+1)\n return n-ans\nfor _ in range(int(input())):\n print(go())
#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\n\nisdebug = False\ntry :\n    #raise ModuleNotFoundError\n    import pylint\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\n    isdebug = True\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\ndef red_inout():\n    inId = 0\n    outId = 0\n    if not isdebug:\n        inId = 0\n        outId = 0\n    if inId>0:\n        dprint('use input', inId)\n        try:\n            f = open('input'+ str(inId) + '.txt', 'r')\n            sys.stdin = f #标准输出重定向至文件\n        except Exception:\n            dprint('invalid input file')\n    if outId>0:\n        dprint('use output', outId)\n        try:\n            f = open('stdout'+ str(outId) + '.txt', 'w')\n            sys.stdout = f #标准输出重定向至文件\n        except Exception:\n            dprint('invalid output file')\n            \n        atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit\n\nif isdebug and len(sys.argv) == 1:\n    red_inout()\n\ndef getIntList():\n    return list(map(int, input().split()))            \n\ndef solve(): \n    pass\n    \nT_ = 1    \nT_, = getIntList()\n\nfor iii_ in range(T_):\n    #solve()\n    N,  = getIntList()\n    #print(N)\n    s = input()\n    r = 0\n    for i in range(N):\n        if s[i] =='>':\n            r = i\n            break\n    r1 = 0\n    for i in range(N-1, -1, -1):\n        if s[i]=='<':\n            r1 = N-1-i\n            break\n    print(min(r,r1))\n
n,m = map(int, input().split())\nA = [0] * n\nfor i in range(n):\n    A[i] = input()\n    for j in range(m):\n        if A[i][j] == 'S':\n            per1,per2 = i,j\n            \nt1, t2 = per1, per2\nend1,end2 = per1,per2\nwhile True:\n    \n    \n    if per1 > 0 and (t1 != per1 - 1 or t2 != per2) and (A[per1-1][per2] == '*' or A[per1-1][per2] == 'S'):\n        t1 = per1\n        t2 =per2\n        per1 -=1\n        print('U', end ='')\n    elif per1 < n-1 and (t1 != per1 + 1 or t2!= per2) and (A[per1+1][per2] == '*' or A[per1+1][per2] == 'S'):\n        t1 = per1\n        t2 = per2\n        per1 += 1\n        print('D', end ='')\n    elif per2 > 0 and (t1!=per1 or t2  !=per2 - 1) and (A[per1][per2-1] == '*' or A[per1][per2-1] == 'S'):\n        t1 = per1\n        t2 = per2\n        per2 -=1\n        print('L', end ='')\n    elif per2 < m -1 and (t1!= per1 or t2 != per2+1) and (A[per1][per2+1] == '*' or A[per1][per2+1] == 'S'):\n        t1 = per1\n        t2 = per2\n        per2 += 1\n        print('R', end ='')\n    if end1 == per1 and end2 == per2:\n        break\n    \n        \n
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return tuple(map(int, sys.stdin.readline().split()))\ndef LLI(): return [tuple(map(int, l.split())) for l in sys.stdin]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    n = I()\n    a = sorted(LI())\n    q = I()\n    b = []\n    for _ in range(q):\n        l,r = LI()\n        b.append(r-l+1)\n    c = []\n    for i in range(n-1):\n        c.append(a[i+1]-a[i])\n    c.sort()\n    c.append(inf)\n\n    d = sorted(b)\n    e = {}\n    s = 0\n    t = n\n    ci = 0\n    for k in d:\n        while c[ci] <= k:\n            t -= 1\n            s += c[ci]\n            ci += 1\n        e[k] = s + k * t\n\n    rr = [e[k] for k in b]\n\n    return ' '.join(map(str, rr))\n\nprint(main())\n\n\n
s = input()\nn = len(s)\n\ndp = [[0 for i in range(n - le + 1)] for le in range(n + 1)]\nans = [0 for i in range(n + 1)]\n\nfor le in range(1, n + 1):\n    for l in range(0, n - le + 1):\n        r = l + le\n        if s[l] != s[r - 1]:\n            continue\n        if le == 1:\n            dp[1][l] = 1\n            ans[1] += 1\n        elif le == 2:\n            ans[2] += 1\n            dp[2][l] = 2\n        elif dp[le - 2][l + 1]:\n            v = 1\n            m = (l + r) // 2\n            st = m + 1 if le & 1 else m\n            le2 = m - l\n            q = dp[le2][l]\n            if q:\n                v = q + 1\n\n            ans[v] += 1\n            dp[le][l] = v\n\n\nfor i in range(n - 1, 0, -1):\n    ans[i] += ans[i + 1]\n\nprint(*ans[1:])\n
md = 10 ** 9 + 7\n\ndef cnk(n, k):\n    if k > n//2:\n        k = n - k\n    ans = 1\n    for i in range(n-k+1, n+1):\n        ans *= i\n    for i in range(2, k+1):\n        ans //= i\n    ans = ans % md\n    return ans\n\n\ndef factor(n):\n    pws = []\n    dv = 2\n    lp = 0\n    while n % dv == 0:\n        lp += 1\n        n //= dv\n    if lp:\n        pws.append(lp)\n    dv = 3\n    while n > 1 and dv * dv <= n:\n        lp = 0\n        while n % dv == 0:\n            lp += 1\n            n //= dv\n        if lp:\n            pws.append(lp)\n        dv += 2\n    if n > 1:\n        pws.append(1)\n    return pws\n\n\ndef main():\n    q = int(input())\n    for __ in range(q):\n        x, y = input().split()\n        x, y = int(x), int(y)\n        ans = pow(2, y - 1, md)\n        for f in factor(x):\n            cm = cnk(f + y - 1, y - 1)\n            ans = (ans * cm) % md\n        print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()
3\n\nMOD = 998244353\n\ndef solve(N, A):\n    dp = [[0] * N for _ in range(N + 1)]\n    dp[0][0] = 1\n\n    for i in range(N):\n        for j in range(N):\n            c = dp[i][j]\n\n            dp[i + 1][j] += c\n            dp[i + 1][j] %= MOD\n\n            if j == 0:\n                if A[i] > 0 and A[i] < N:\n                    dp[i + 1][A[i]] += c\n                    dp[i + 1][A[i]] %= MOD\n            else:\n                dp[i + 1][j - 1] += c\n                dp[i + 1][j - 1] %= MOD\n\n    return (dp[N][0] + MOD - 1) % MOD\n\n\ndef main():\n    N = int(input())\n    A = [int(e) for e in input().split(' ')]\n    assert len(A) == N\n    print(solve(N, A))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
import sys\n\ninput = sys.stdin.readline\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    ans = 0\n    f = 0\n    i = n\n    while n:\n        ans += i // 2**f\n        n //= 2\n        f += 1\n    print(ans)
import sys\ninput = sys.stdin.readline\nT = int(input())\nfor _ in range(T):\n    N, K = list(map(int, input().split()))\n    A = [int(a) for a in input().split()]\n    B = [A[i+K]-A[K] for i in range(N-K)]\n    mi = 10**20\n    mx = -1\n    for i in range(N-K):\n        if A[i+K]-A[i] < mi:\n            mi = A[i+K]-A[i]\n            mx = (A[i+K]+A[i]) // 2\n    \n    print(mx)\n
import  sys\ninput=sys.stdin.readline\nn,m=list(map(int,input().split()))\na=[int(x) for x in input().split()]\ns=[set() for i in range(m+1)]\n\nfor i in range(n):\n    s[a[i]].add(i+1)\n\nf=[0]*(m+2)\nfor i in range(m+1):\n    f[i]=i\n\ndef fin(x):\n    if f[x]==x:\n        return x\n    f[x]=fin(f[x])\n    return f[x]\nans=0\nfor i in range(1,m+1):\n    for j in s[i]:\n        if j in s[i] and j-1 in s[i]:\n            ans+=1\n\nout=[n-ans-1]\n\nfor i in range(m-1):\n    x,y=list(map(int,input().split()))\n    x=fin(x)\n    y=fin(y)\n\n    if len(s[x])<len(s[y]):\n        x,y=y,x\n    for i in s[y]:\n        if i in s[y] and i-1 in s[x]:\n            ans+=1\n        if i in s[y]  and i+1 in s[x]:\n            ans+=1\n\n    out.append(n-ans-1)\n    s[x]|=s[y]\n    f[y]=x\n\nprint('\n'.join(str(x) for x in out))\n\n\n
t = int(input())\n\nfor _ in range(t):\n	n, m = map(int, input().split())\n\n	a = list(map(int, input().split()))\n\n	if n <= 2:\n		print(-1)\n		continue\n	if m < n:\n		print(-1)\n		continue\n\n	cost = 0\n	edges = []\n	for i in range(n):\n		edges.append((i+1, (i+1)%n + 1))\n		cost += 2 * a[i]\n\n	s = sorted(range(n), key=lambda i: a[i])\n\n	for i in range(m-n):\n		edges.append((s[0]+1, s[1]+1))\n		cost += a[s[0]] + a[s[1]]\n\n	print(cost)\n	for u, v in edges:\n		print(u, v)
from math import gcd\n\nn = int(input())\nfor i in range(n):\n    a, b = list(map(int, input().split()))\n    g = gcd(a, b)\n    if g == 1:\n        print("Finite")\n    else:\n        print("Infinite")
n, k, m = list(map(int, input().split()))\nw = list(input().split())\n\nlk = {}\nfor i in range(n):\n    lk[w[i]] = i\n\nc = list(map(int, input().split()))\n\nm = [10**19] * k\ngr = [0] * n\n\nfor i in range(k):\n    g = list(map(int, input().split()))\n    for j in g[1:]:\n        m[i] = min(m[i], c[j - 1])\n        gr[j - 1] = i\n\nlet = input().split()\nres = 0\nfor word in let:\n    res += m[gr[lk[word]]]\n\nprint(res)\n
import  sys\nimport  math\ninput=sys.stdin.readline\n#sys.setrecursionlimit(1000000)\nmod=int(1000000007)\ni=lambda :map(int,input().split())\nn=int(input())\na=[int(x) for x in input().split()]\nt=[[0]*21 for i in range(300005)]\nfor i in range(n):\n    t[i][0]=a[i]\n\ndef build(n):\n    for j in range(1,20):\n        for i in range(n):\n            if i+(1<<j)-1>n-1:\n                break;\n            t[i][j]=max(t[i][j-1],t[i+(1<<(j-1))][j-1])\n\ndef query(p,q):\n    p,q=int(p),int(q)\n    log=int(math.log2(q-p+1))\n    m=t[p][log]\n    n=t[q-(1<<log)+1][log]\n    return max(m,n)\n\nb=[-1]*(n+2)\nbuild(n)\nmax1=-1\nans=0\nfor i in range(n):\n    max1=max(max1,b[a[i]])\n    b[a[i]]=i\n    x=b[1]\n    while x>max1:\n        if x<=max1:\n            break\n        p=query(x,i)\n        if p==i-x+1:\n            ans+=1\n            x=b[p+1]\n        else:\n            x=i-p+1\nprint(ans)
n=int(input())\na=(list(map(int,input().split())))\na.sort(reverse=True)\nx,f=list(map(int,input().split()))\nans=0\nfor i in range(n):\n    if a[i]>x:\n        r=(a[i]-x)//(x+f)\n        if (a[i]-x)%(x+f):\n            r+=1\n        ans+=(f*r)\n    else:\n        break\nprint(ans)\n
n=int(input())\nnfirst,rc,bc,memr,memb,memg,dr,db,s,rl,bl,gl,lg=13*[0]\nfor i in range(n):\n    a=input().split(" ")\n    if a[1]=="G":\n        if memg==0:\n            gl=int(a[0])\n        if nfirst:\n            if memr>0:\n                dr=max(dr,int(a[0])-memr)\n            if memb>0:\n                db=max(db,int(a[0])-memb)\n            s+=min(2*(int(a[0])-memg),3*(int(a[0])-memg)-dr-db)\n        dr,db,rc,bc=4*[0]\n        memr,memb,memg=3*[int(a[0])]\n        nfirst=True\n        lg+=1\n    elif a[1]=="R":\n        rc+=1\n        if memr==0:\n            rl=int(a[0])\n        if memr>0 and nfirst:\n            dr=max(dr,int(a[0])-memr)\n        memr=int(a[0])\n    elif a[1]=="B":\n        bc+=1\n        if memb==0:\n            bl=int(a[0])\n        if memb>0 and nfirst:\n            db=max(db,int(a[0])-memb)\n        memb=int(a[0])\nif lg>0:\n    if rc>0:\n        s+=memr-memg\n    if bc>0:\n        s+=memb-memg\n    if rl>0:\n        s+=gl-rl\n    if bl>0:\n        s+=gl-bl\nelse:\n    s+=memr-rl+memb-bl\nprint(s)
n, k, q = list(map(int, input().split()))\nrecipe_in = []\nfor i in range(n):\n    l, r = list(map(int, input().split()))\n    recipe_in.append((l, r))\n\nquery_in = []\nfor i in range(q):\n    l, r = list(map(int, input().split()))\n    query_in.append((l, r))\n\nMAX = 200000 + 10\nrecipes = [0 for i in range(MAX)]\nfor recipe in recipe_in:\n    l, r = recipe\n    recipes[l] += 1\n    recipes[r + 1] -= 1\nfor i in range(1, MAX):\n    recipes[i] += recipes[i - 1]\n\ncnts = [0 for i in range(MAX)]\nfor i in range(MAX):\n    if recipes[i] >= k:\n        cnts[i] += 1\nfor i in range(1, MAX):\n    cnts[i] += cnts[i - 1]\n\nfor query in query_in:\n    l, r = query\n    ans = cnts[r] - cnts[l - 1]\n    print(ans)\n
n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ni, j = 0, 0\nwhile i < n:\n    while j < m and b[j] < a[i]:\n        j += 1\n    if j == m:\n        break\n    j += 1\n    i += 1\nprint(n - i)
3\n\ndef readln(): return tuple(map(int, input().split()))\n\nn, = readln()\nans = []\nfor x, y in sorted([readln() for _ in range(n)], key=lambda x: abs(x[0]) + abs(x[1])):\n    if x > 0:\n        ans.append('1 %d R' % x)\n    if x < 0:\n        ans.append('1 %d L' % -x)\n    if y > 0:\n        ans.append('1 %d U' % y)\n    if y < 0:\n        ans.append('1 %d D' % -y)\n    ans.append('2')\n    if x > 0:\n        ans.append('1 %d L' % x)\n    if x < 0:\n        ans.append('1 %d R' % -x)\n    if y > 0:\n        ans.append('1 %d D' % y)\n    if y < 0:\n        ans.append('1 %d U' % -y)\n    ans.append('3')\nprint(len(ans))\nprint('\n'.join(ans))\n
import sys\ninput = sys.stdin.readline\n\nfrom math import gcd\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    g = max(l)\n    out = []\n    while l:\n        nex = max((gcd(g,l[i]), i) for i in range(len(l)))\n        out.append(l.pop(nex[1]))\n        g = nex[0]\n    print(' '.join(map(str,out)))\n        \n    \n
import sys\nimport math\nfrom collections import defaultdict\nfrom itertools import combinations\nfrom itertools import permutations\ninput = lambda : sys.stdin.readline().rstrip()\nread = lambda : list(map(int, input().split()))\ndef write(*args, sep="\n"):\n  for i in args:\n    sys.stdout.write("{}".format(i) + sep)\nINF = float('inf')\nMOD = int(1e9 + 7)\n\nfor q in range(int(input())):\n  h, n = read()\n  arr = list(read()) + [0]\n  \n  if n == 1:\n    write(0)\n    continue\n  \n  ans = 0\n\n  cur = h \n  for i in range(1, n):\n    if cur == arr[i]:\n      continue\n    else:\n      if arr[i + 1] == arr[i] - 1:\n        cur = arr[i] - 1\n      else:\n        ans += 1\n  \n  write(ans)\n    \n
n,m=map(int,input().split())\nL=[]\nfor i in ' '*n:L.append(input())\ndp=[[0]*m for i in range(n)]\nfor i in range(n+m-1):\n    rightmin=max(0,i-(n-1))\n    leftmin=max(0,i-(m-1))\n    left=i-rightmin\n    jstart = max(0, i - (n - 1))\n    for j in range(abs(left-leftmin)+1):\n        jj=jstart+j\n        ii=i-jj\n        if jj<2 or ii<1 or ii==n-1:\n            dp[ii][jj]=1\n            continue\n        if L[ii+1][jj-1]==L[ii][jj-1]==L[ii][jj-2]==L[ii-1][jj-1]==L[ii][jj]:\n            dp[ii][jj]=min(dp[ii+1][jj-1],dp[ii][jj-1],dp[ii][jj-2],dp[ii-1][jj-1])+1\n        else:dp[ii][jj]=1\nct=0\nfor i in dp:\n    for j in i:\n        ct+=j\nprint(ct)
t = int(input())\n\nfor _ in range(t):\n    n, m = [int(x) for x in input().split()]\n    grid = [list(input()) for _ in range(n)]\n\n    has_good = any('G' in l for l in grid)\n\n    if not has_good:\n        print("Yes")\n        continue\n\n    impossible = False\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != 'B':\n                continue\n\n            for nbi, nbj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 <= nbi < n and 0 <= nbj < m:\n                    if grid[nbi][nbj] == 'G':\n                        impossible = True\n                        break\n                    elif grid[nbi][nbj] == 'B' or grid[nbi][nbj] == '#':\n                        continue\n                    elif grid[nbi][nbj] == '.':\n                        grid[nbi][nbj] = "#"\n                    else:\n                        assert False, "What's in the grid?"\n\n    if grid[n-1][m-1] == '#' or impossible:\n        print("No")\n        continue\n\n    seen = [[False]*m for _ in range(n)]\n    stack = [(n-1, m-1)]\n    seen[n-1][m-1] = True\n\n    while len(stack):\n        i, j = stack.pop()\n\n        for nbi, nbj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n            if 0 <= nbi < n and 0 <= nbj < m:\n                if grid[nbi][nbj] != '#' and not seen[nbi][nbj]:\n                    seen[nbi][nbj] = True\n                    stack.append((nbi, nbj))\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'G' and not seen[i][j]:\n                impossible = True\n                break\n        if impossible:\n            break\n\n    if impossible:\n        print("No")\n    else:\n        print("Yes")\n
t = int(input())\n\ndef get_max(n):\n    ans = 0\n    while n:\n        ans = 4 * ans + 1\n        n = n - 1\n        if ans > 10**19:\n            break\n    return ans\n\nfor _ in range(t):\n    n, k = list(map(int, input().split()))\n    if n == 1:\n        if k == 1:\n            print("YES 0")\n        else:\n            print("NO")\n    elif n == 2:\n        if k <= 2:\n            print("YES 1")\n        elif k != 3 and k <= 5:\n            print("YES 0")\n        else:\n            print("NO")\n    else:\n        siz = n - 1\n        l = 1\n        cnt = 3\n        while siz:\n            if l <= k < l+cnt:\n                print("YES {}".format(siz))\n                break\n            l = l + cnt\n            cnt = 2 * cnt + 1\n            siz = siz - 1\n        else:\n            if k <= get_max(n):\n                print("YES 0")\n            else:\n                print("NO")\n
n = int(input())\na = [tuple(map(int, input().split())) for i in range(n)]\n\na = [(y, x, k) for x, y, k in a]\na.sort(reverse=True)\ndp = [[-1] * (n + 1) for i in range(n)]\n\ndef f(i, j):\n    if i < 0 or j < -1: return 0\n    if dp[i][j] == -1:\n        y, x, k = a[i]\n        dp[i][j] = f(i - 1, j) + max(0, x - k * y)\n        if 0 <= j < k: dp[i][j] = max(dp[i][j], x - j * y + f(i - 1, j - 1))\n    return dp[i][j]\n\nprint(max(f(n - 1, j) for j in range(-1, n)))\n
import sys\ninput = sys.stdin.readline\n\nt=int(input())\nfor test in range(t):\n    n=int(input())\n    A=list(map(int,input().split()))\n\n    ANS=[]\n    SET=set()\n\n    NOW=1\n    while not (NOW in SET):\n        ANS.append(NOW)\n        SET.add(NOW)\n        NOW=NOW-A[NOW-1]\n\n    x=ANS.index(NOW)\n\n    print(len(ANS[x:]))\n    print(*ANS[x:])\n
n = int(input())\nparent = [-1]*n\nisresp = [1]*n\nfor i in range(n):\n	p, r = list(map(int, input().split()))\n	p -= 1\n	if r == 0:\n		isresp[i] = 0\n		if p>=0:\n			isresp[p] = 0\nnore = []\nfor i in range(n):\n	if isresp[i] == 1:\n		nore.append(i+1)\nif not nore:\n	print(-1)\nelse:\n	print(" ".join(map(str, nore)))\n
t = int(input())\n\nfor _ in range(t):\n    p = sorted(input())\n    h = input()\n    \n    for i in range(len(h)-len(p)+1):\n        if sorted(h[i:i+len(p)])==p:\n            print("YES")\n            break\n    else:\n        print("NO")\n
n = int(input()[-1:])\nprint(n%2)
tst = int(input())\nfor i in range(0, tst):\n    n = int(input())\n    ans = 1\n    l = 1\n    p = []\n    while l <= n:\n        ans += 1\n        l = n // (n // l)\n        p.append(n // l)\n        l += 1\n    p.append(0)\n    p.reverse()\n    print(len(p))\n    print(" ".join(str(x) for x in p))
import sys\ninput = sys.stdin.readline\n\nt = int(input())\nout = []\nfor _ in range(t):\n    a, b, c, d = list(map(int, input().split()))\n    dX = c - a\n    dY = d - b\n    out.append(dX * dY + 1)\n    \n\nprint('\n'.join(map(str,out)))\n
def vasya_and_array():\n    n,k,leng = [int(x) for x in input().split()]\n    if(leng==1):\n        return 0\n    a = [int(x) for x in input().split()]\n    mod = 998244353\n    a.insert(0,0)\n    dp = [[0 for x in range((k+1))] for y in range(n+1)]\n    sumdp = [0 for _ in range(n+1)]\n    sumdp[0]=1\n    count = [0 for _ in range(k+1)]\n    \n    for i in range(1,n+1):\n        for j in range(1,k+1):\n            if(a[i]==-1 or a[i]==j):\n                dp[i][j] = sumdp[i-1]\n                count[j]+=1\n                if(count[j] >= leng):\n                    dp[i][j]-=(sumdp[i-leng] - dp[i-leng][j])\n                dp[i][j]%=mod\n                sumdp[i]+=dp[i][j]\n                sumdp[i]%=mod\n            else:\n                count[j]=0\n        \n    return (sumdp[n])\n    \nprint(vasya_and_array()) 
import sys\ninput = sys.stdin.readline\n\ntestcases=int(input())\n\nfor testcase in range(testcases):\n    n,m=list(map(int,input().split()))\n    MAP=[input().strip() for i in range(n)]\n    #print(MAP)\n\n    STR=[[] for i in range(26)]\n\n    for i in range(n):\n        for j in range(m):\n            if MAP[i][j]!=".":\n                STR[ord(MAP[i][j])-97].append([i,j])\n\n    #print(STR)\n\n    for s in range(25,-1,-1):\n        if STR[s]==[]:\n            continue\n        \n        x,y=STR[s][0]\n        z,w=STR[s][-1]\n        flag=1\n        \n        if x==z:\n            for k in range(y,w+1):\n                if MAP[x][k]>=chr(s+97):\n                    continue\n                else:\n                    flag=0\n                    break\n                \n            for u,v in STR[s]:\n                if u==x:\n                    continue\n                else:\n                    flag=0\n                    break\n\n        elif y==w:\n            for k in range(x,z+1):\n                if MAP[k][y]>=chr(s+97):\n                    continue\n                else:\n                    flag=0\n                    break\n                \n            for u,v in STR[s]:\n                if v==y:\n                    continue\n                else:\n                    flag=0\n                    break\n\n        else:\n            flag=0\n\n        if flag==0:\n            print("NO")\n            break\n    else:\n        print("YES")\n\n        for s in range(25,-1,-1):\n            if STR[s]!=[]:\n                ANS=s+1\n                ANONE=STR[s][0]\n                print(ANS)\n                break\n        else:\n            print(0)\n            continue\n\n        for ans in range(ANS):\n            if STR[ans]!=[]:\n                print(STR[ans][0][0]+1,STR[ans][0][1]+1,STR[ans][-1][0]+1,STR[ans][-1][1]+1)\n            else:\n                print(ANONE[0]+1,ANONE[1]+1,ANONE[0]+1,ANONE[1]+1)\n\n        \n\n            \n                \n            \n            \n\n        \n            \n
import sys\n\nreadline = sys.stdin.readline\nread = sys.stdin.read\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\n')\n\ndef solve():\n    a, b, c, d = nm()\n    if a <= b:\n        print(b)\n    else:\n        a -= b\n        if c <= d:\n            print(-1)\n        else:\n            print(b + c * ((a-1)//(c-d) + 1))\n    return\n\n\n# solve()\n\nT = ni()\nfor _ in range(T):\n    solve()\n
import sys\n\nn, q = map(int, sys.stdin.readline().rstrip().split())\nfor _ in range(q):\n    x, y = map(int, sys.stdin.readline().rstrip().split())\n    x, y = x-1, y-1\n    \n    if (x+y)%2 == 0:\n        res = 1\n        res += x//2 * n\n        res += x%2 * ((n+1)//2)\n        res += y//2\n\n        print(res)\n    else:\n        res = (n*n+1)//2+1\n        res += x//2 * n\n        res += x%2 * ((n)//2)\n        res += y//2\n\n        print(res)
t=int(input())\nfor tt in range(t):\n    n,p=map(int,input().split())\n    now=1\n    ans=0\n    while ans!=2*n+p:\n        for i in range(now+1,n+1):\n            if ans==2*n+p:\n                break\n            print(now,i)\n            ans+=1\n        now+=1
q = int(input())\nfor irweewr in range(q):\n	n = int(input())\n	l = list(map(int,input().split()))\n	l.sort()\n	l.reverse()\n	print(*l)
for _ in range(int(input())):\n    lasts = {}\n    ans = n = int(input())\n    for i, a in enumerate(input().split()):\n        if a in lasts:\n            ans = min(ans, i - lasts[a])\n        lasts[a] = i\n    ans += 1\n    if ans > n:\n        ans = -1\n    print(ans)\n
s = input()\nres = []\ni = 0\nj = len(s)-1\nwhile i<j:\n    if s[i]=="(" and s[j]==")":\n        res.append(i+1)\n        res.append(j+1)\n        i+=1\n        j-=1\n    else:\n        if s[i]==")":\n            i+=1\n        else:\n            j-=1\n\nif len(res)==0:\n    print(0)\nelse:\n    print(1)\n    print(len(res))\n    res.sort()\n    print(*res,sep=" ")
import sys\ninput = sys.stdin.readline\n\nT = int(input())\nfor _ in range(T):\n    h, c, t = list(map(int, input().split()))\n    if h + c >= 2 * t:\n        print(2)\n    else:\n        diff2 = 2*t - (h + c)\n        hDiff2 = 2*h - (h + c)\n\n        kDown = (hDiff2//diff2 - 1)//2\n        kUp = kDown + 1\n        diffDown = abs(diff2 - hDiff2/(2 * kDown + 1))\n        diffUp = abs(diff2 - hDiff2/(2 * kUp + 1))\n        if diffDown <= diffUp:\n            print(2 * kDown + 1)\n        else:\n            print(2 * kDown + 3)\n
t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    lims = [tuple(int(v) for v in input().split()) for _ in range(n)]\n    ctime = 0\n    ans = []\n    for l, r in lims:\n        if l >= ctime:\n            ans.append(l)\n            ctime = l + 1\n        elif r < ctime:\n            ans.append(0)\n        else:\n            ans.append(ctime)\n            ctime += 1\n    print(' '.join(str(v) for v in ans))\n
q = int(input())\nfor _ in range(q):\n	n,m,k = map(int,input().split())\n	player = n//k\n	jok_pla = min(n//k, m)\n	jok_re = m-jok_pla\n	maksi = (jok_re +k-2)//(k-1)\n	print(jok_pla-maksi)
import sys\n\nanswer = 1\nz = True\nprimes = []\nfor i in range (2, 5 * 10 ** 2):\n    v = True\n    for p in primes:\n        if i % p == 0:\n            v = False\n    if v == True:\n        primes.append(i)\n\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\nif sum(a) == n:\n    z = False\nfor i in range (0, n):\n    x = a[i]\n    a[i] = []\n    for p in primes:\n        if x % p == 0:\n            a[i].append([p, 1])\n            x = x // p\n            while x % p == 0:\n                x = x // p\n    if x != 1:\n        a[i].append([x, 1])\n\nneighbours = [[] for i in range (0, n)]\nfor i in range (0, n - 1):\n    line = sys.stdin.readline().strip().split()\n    neighbours[int(line[0]) - 1].append(int(line[1]) - 1)\n    neighbours[int(line[1]) - 1].append(int(line[0]) - 1)\n\nleaves = []\nfor i in range (0, n):\n    if len(neighbours[i]) == 1:\n        leaves.append(i)\n\n\nwhile len(leaves) > 1:\n    x = leaves.pop()\n    y = neighbours[x][0]\n    neighbours[y].remove(x)\n    if len(neighbours[y]) == 1:\n        leaves.append(y)\n    for p in a[x]:\n        for q in a[y]:\n            if p[0] == q[0]:\n                answer = max([answer, p[1] + q[1]])\n                q[1] = max([q[1],p[1]+1])\n\n\nif z == False:\n    print(0)\nelse:\n    print(answer)\n
T=int(input())\nanswer=[]\nfor t in range(T):\n    A,B=input().split()\n    A=int(A)\n    B=int(B)\n    x=0\n    if(A>B):\n        r=B\n        B=A\n        A=r\n    while(A>0 and B>0):\n        r=B//A\n        x+=r\n        r*=A\n        B=B-r\n        if(A>B):\n            r=B\n            B=A\n            A=r\n    answer.append(x)\n\nfor t in range(T):\n    print(answer[t])\n\n        \n
M = 0x3b800001\nwa = 0;\nn = int(input())\na = list(map(int, input().split()))\nnow = 1\nwa += a[-1]\nfor i in range(n - 1)[::-1]:\n    wa += (now * (n - i - 1) + now * 2) * a[i]\n    wa %= M\n    now *= 2\n    now %= M\nprint(wa % M)\n
class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        if expression == 'f':\n            return False\n        if expression == 't':\n            return True\n        if expression[0] == '!':\n            return not self.parseBoolExpr(expression[2:-1])\n        if expression[0] == '|':\n            cursor = 2\n            while cursor < len(expression)-1:\n                end_of_next = self.getNextExpr(expression, cursor)\n                if self.parseBoolExpr(expression[cursor:end_of_next]):\n                    return True\n                cursor = end_of_next + 1\n            return False\n        if expression[0] == '&':\n            cursor = 2\n            while cursor < len(expression)-1:\n                end_of_next = self.getNextExpr(expression, cursor)\n                if not self.parseBoolExpr(expression[cursor:end_of_next]):\n                    return False\n                cursor = end_of_next + 1\n            return True\n    \n    def getNextExpr(self, expression, start):\n        if expression[start] == '!' or expression[start] == '|' or expression[start] == '&':\n            open_count = 1\n            close_count = 0\n            start += 1\n            while open_count > close_count:\n                start += 1\n                if expression[start] == '(':\n                    open_count += 1\n                if expression[start] == ')':\n                    close_count += 1\n                \n            return start + 1\n        else:\n            return start + 1
n=int(input())\na=list(map(int,input().split()))\nl=[0]*(n+1)\nl2=[0]*(n+1)\nfor i in a:\n    l[i]+=1\n\nfor i in range(1,n+1):\n    l2[i]=l[i]*(l[i]-1)//2\nsum_l=sum(l2)\nfor i in range(1,n+1):\n    print((sum_l-(l[a[i-1]]-1)))\n
from operator  import mul\nfrom functools import reduce\n\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10 ** 9 + 7\nN = 10 ** 6\nfact    = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv     = [0, 1]\n\nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\n#kari1 = '2 3 1 1'                   #2\n#kari1 = '10 7 3 4'                  #3570\n#kari1 = '100000 100000 99999 99999' #1\n#kari1 = '100000 100000 44444 55555' #738162020\n\n"""\nin1 = kari1.split()\n"""\nin1 = input().split()\n\nH = int(in1[0])\nW = int(in1[1])\nA = int(in1[2])\nB = int(in1[3])\n\nallCNT = 0\nfor idx1 in range(W - B):\n    beforeCNT = cmb(H - A + B - 1 + idx1, H - A - 1, p)\n    afterCNT  = cmb(W + A - B - 2 - idx1, A - 1, p)\n    allCNT    = (allCNT + (beforeCNT * afterCNT) % p) % p\n\nprint(allCNT)\n
N,M=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\ncd=[list(map(int,input().split())) for i in range(M)]\nli=[[] for i in range(N+1)]\nfor i in range(M):\n    li[cd[i][0]].append(cd[i][1])\n    li[cd[i][1]].append(cd[i][0])\nli2=[0]*(N+1)\nnum=0\nfor i in range(1,N+1):\n    deque=[i]\n    if li2[i]!=0:\n        break\n    li2[i]=i\n    num=i\n    while deque:\n        x=deque.pop(0)\n        for j in li[x]:\n            if li2[j]==0:\n                li2[j]=i\n                deque.append(j)\nli3=[[] for i in range(num)]\nfor i in range(1,N+1):\n    li3[li2[i]-1].append(i-1)\nfor i in range(len(li3)):\n    A=0\n    B=0\n    for j in range(len(li3[i])):\n        A+=a[li3[i][j]]\n        B+=b[li3[i][j]]\n    if A!=B:\n        print("No")\n        break\n    elif i==len(li3)-1:\n        print("Yes")
def prepare(n, MOD):\n \n    # 1! - n! の計算\n    f = 1\n    factorials = [1]  # 0!の分\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    # n!^-1 の計算\n    inv = pow(f, MOD - 2, MOD)\n    # n!^-1 - 1!^-1 の計算\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n     \n    return factorials, invs\n\n\nMOD = 10**9 + 7\nf, inv = prepare(10**5+100, MOD)\n\nn, k = map(int,input().split())\na = list(map(int,input().split()))\n\na.sort(reverse=True)\n\np = 0\nm = 0\nfor i in range(n):\n    if n - i >= k:\n        cn = n - i - 1\n        ck = k - 1\n        if cn >= ck:\n            combi = f[cn] * inv[ck] % MOD * inv[cn - ck] % MOD\n            if a[i] >= 0:        \n                p += (a[i] * combi) % MOD\n            else:\n                p += (a[i] * combi) % -MOD\n            if p >= 0:\n                p %= MOD\n            else:\n                p %= -MOD\n    if i >= k - 1:\n        cn = i\n        ck = k - 1\n        if cn >= ck:\n            combi = f[cn] * inv[ck] % MOD * inv[cn - ck] % MOD\n            if a[i] >= 0:        \n                m += (a[i] * combi) % MOD\n            else:\n                m += (a[i] * combi) % -MOD\n            if m >= 0:\n                m %= MOD\n            else:\n                m %= -MOD\n        \nprint((p - m)%MOD)
from scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\n\nimport numpy as np\n\nn = int(input())\na = np.array([list(map(int, input().split())) for _ in range(n)])\n\ng = csr_matrix(a)\ndist = floyd_warshall(g)\n\nif (dist == a).all():\n    sm = a.sum()\n\n    INF = 10 ** 18 + 1\n    for i in range(n):\n        a[i, i] = INF\n\n    for u in range(n):\n        for v in range(n):\n            if u == v:\n                continue\n\n            mn = np.min(a[u] + a[v])\n            if mn == a[u, v]:\n                sm -= a[u, v]\n\n    ans = sm // 2\n    print(ans)\n\nelse:\n    print((-1))\n
#難しく考えすぎていた\n#こういう問題は最後どうなるかを考える\n#最後は結局一番最後のカードを必ず引くことになる\n#そのカードをどちらが引くのか\n#先攻が圧倒的有利\n\nn,z,w=map(int,input().split())\na=list(map(int,input().split()))\nif len(a)==1:\n    print(abs(a[-1]-w))\nelse:\n    print(max(abs(a[-1]-w),abs(a[-1]-a[-2])))
# import numpy as np\nfrom collections import deque\n\ndef solve(): #H, W, CH, CW, DH, DW, S):\n	H,W=list(map(int,input().split()))\n	CH,CW=list(map(int,input().split()))\n	DH,DW=list(map(int,input().split()))\n	S=[input() for _ in range(H)]\n\n	# 後の条件分岐を簡略化するためワープしても迷路外に出ないように壁で囲む\n	S = ['##{}##'.format(row) for row in S]\n	S.insert(0, '##{}##'.format('#' * W))\n	S.insert(0, '##{}##'.format('#' * W))\n	S.append('##{}##'.format('#' * W))\n	S.append('##{}##'.format('#' * W))\n\n\n	MAX_COST = 10 ** 9\n	Cost=[ [ MAX_COST for _ in range(W+4)] for _ in range(H+4)]\n	# Cost = np.full((H,W),MAX_COST)\n\n	# print(S)\n\n	ans = -1\n\n	cost0 = deque()\n\n	cost0.append((CH+1,CW+1,0))\n	Cost[CH+1][CW+1] = 0;\n\n	# used = set()\n	walk=[(1,0),(0,1),(-1,0),(0,-1)]\n	warp = [ (i,j) for i in range(-2,3) for j in range(-2,3) if (i, j) not in [(0, 0)] + walk ]\n	# print(warp)\n\n	cost1 = deque()\n\n	while cost0:\n		h,w,c=cost0.popleft()\n		cost1.append((h,w,c))\n\n		for i,j in walk:\n			dh = h+i\n			dw = w+j\n			if S[dh][dw] == '.' and c < Cost[dh][dw]:\n				Cost[dh][dw] = c\n				# print("updl ", i,j,dh,dw,c)\n				cost0.appendleft((dh,dw,Cost[dh][dw]))\n\n		if len(cost0) == 0:\n\n			while cost1:\n				h,w,c=cost1.popleft()\n				# print(h,w,c)\n				for i,j in warp:\n					dh = h+i\n					dw = w+j\n					# print(i,j)\n					if S[dh][dw] == '.' and c + 1 < Cost[dh][dw]:\n						Cost[dh][dw] = c + 1\n						cost0.append((dh,dw,Cost[dh][dw]))\n\n\n	if Cost[DH+1][DW+1] == MAX_COST:\n		print((-1))\n	else:\n		print((Cost[DH+1][DW+1]))\n\n\ndef __starting_point():\n\n	# S=[input() for _ in range(H)]\n\n	solve() #H, W, CH, CW, DH, DW, S)\n\n__starting_point()
import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\n\ndef read():\n    N = int(input().strip())\n    P = list(map(int, input().strip().split()))\n    return N, P\n\n\ndef solve(N, P):\n    ans = 0\n    p = deque(P)\n    q = deque()\n    q.append(p.popleft())\n    for i in range(1, N):\n        if i == q[-1]:\n            c = q.pop()\n            q.append(p.popleft())\n            q.append(c)\n            ans += 1\n        else:\n            q.append(p.popleft())\n    if q[-1] == N:\n        c = q.pop()\n        d = q.pop()\n        q.append(c)\n        q.append(d)\n        ans += 1\n    return ans\n\n\ndef __starting_point():\n    inputs = read()\n    print((solve(*inputs)))\n\n__starting_point()
#!/usr/bin/env python3\nimport sys\nimport bisect\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\n\nn, m = map(int, input().split())\nseen = set()\nab = []\nfor _ in range(n):\n    a, b = map(int, input().split())\n    ab.append((a, b))\n    seen.add(a)\nab.sort()\n\ndecomp = list(seen)\ndecomp.sort()\nnode_num = len(decomp)\ncomp = dict()\nfor i, item in enumerate(decomp):\n    comp[item] = i\n\n# Take diff\nd = [0] * (node_num + 1)\nprev = 0\nfor a, b in ab:\n    if b != prev:\n        d[comp[a]] = 1\n    prev = b\nif prev != 0:\n    d[node_num] = 1\n\nswitch_dict = dict()\nlr = []\nfor i in range(m):\n    l, r = map(int, input().split())\n    lft = bisect.bisect_left(decomp, l)\n    rgt = bisect.bisect_right(decomp, r)\n    if lft != rgt:\n        lr.append((lft, rgt))\n        switch_dict[(lft, rgt)] = i + 1\n\nedge = [[] for _ in range(node_num + 1)]\nfor l, r in lr:\n    edge[l].append(r)\n    edge[r].append(l)\n\nvisited = [0] * (node_num + 1)\nans = []\ndef dfs(p, v):\n    ret = d[v]\n    for nv in edge[v]:\n        if nv == p:\n            continue\n        if not visited[nv]:\n            visited[nv] = 1\n            val = dfs(v, nv)\n            if val == 1:\n                if v < nv:\n                    ans.append(switch_dict[(v, nv)])\n                else:\n                    ans.append(switch_dict[(nv, v)])\n                ret += 1\n    return ret % 2\n\nfor i in range(node_num + 1):\n    if visited[i]:\n        continue\n    visited[i] = 1\n    ret = dfs(-1, i)\n    # Check last node is ok or not\n    if ret == 1:\n        print(-1)\n        return\n\n# Check trees cover all 1 or not\nfor c, is_visited in zip(d, visited):\n    if not is_visited and c:\n        print(-1)\n        return\n\nans.sort()\nprint(len(ans))\nprint(*ans)
X,Y=map(int,input().split())\nprint('Alice' if abs(X-Y) > 1 else 'Brown')
import sys\nsys.setrecursionlimit(1000000000)\ninput = sys.stdin.readline\nn,w=map(int,input().split())\nknap=[[] for i in range(4)]\nw0,v=map(int,input().split())\nknap[0].append(v)\nfor i in range(n-1):\n    W,v=map(int,input().split())\n    knap[W-w0].append(v)\nfor i in range(4):\n    knap[i].sort(reverse=1)\n    knap[i]=[0]+knap[i]\nfor i in range(4):\n    for j in range(1,len(knap[i])):\n        knap[i][j]+=knap[i][j-1]\nans=0\nfor a in range(len(knap[0])):\n    for b in range(len(knap[1])):\n        for c in range(len(knap[2])):\n            for d in range(len(knap[3])):\n                if w0*a+(w0+1)*b+(w0+2)*c+(w0+3)*d<=w:\n                    ans=max(ans,knap[0][a]+knap[1][b]+knap[2][c]+knap[3][d])\nprint(ans)
from math import ceil\n\nN, H = map(int, input().split())\n\nA = []\nB = []\nfor _ in range(N):\n    a, b = map(int, input().split())\n    A.append(a)\n    B.append(b)\nelse:\n    a = max(A)\n    B.sort()\n    B.reverse()\n\nans = 0\nfor b in B:\n    if H <= 0:\n        print(ans)\n        break\n\n    if a < b:\n        H -= b\n        ans += 1\nelse:\n    print(ans + ceil(H / a))
from sys import stdin, setrecursionlimit\nfrom collections import deque\n\nsetrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\nMOD = 1000000007\nN = int(input())\nG = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    a, b = list(map(int, input().split()))\n    G[a - 1].append(b - 1)\n    G[b - 1].append(a - 1)\n\npow2 = [1] * (N + 1)\nfor i in range(N):\n    pow2[i + 1] = pow2[i] * 2 % MOD\n\norder = []\nparent = [-1] * N\n\nstack = deque([0])\nwhile stack:\n    v = stack.pop()\n    order.append(v)\n    for nv in G[v]:\n        if parent[v] != nv:\n            parent[nv] = v\n            stack.append(nv)\n\nnumer = 0\nnums = [0] * N\n\nfor v in reversed(order):\n    tmp = 1\n    for nv in G[v]:\n        if parent[v] != nv:\n            nums[v] += nums[nv] + 1\n            tmp += pow2[nums[nv] + 1] - 1\n    tmp += pow2[N - nums[v] - 1] - 1\n    numer = (numer + pow2[N - 1] - tmp) % MOD\n\ndenom = pow2[N]\nans = numer * pow(denom, MOD - 2, MOD) % MOD\nprint(ans)\n
N,K,C = map(int,input().split())\nS = input()\nL = []\nR = []\ni = 0\nwhile i < N:\n    if S[i] == "o":\n        L.append(i)\n        i += C\n    i += 1\nj = N-1\nwhile j >= 0:\n    if S[j] == "o":\n        R.append(j)\n        j -= C\n    j -= 1   \nfor i in range(K):\n    if L[i] == R[K-1-i]:\n        print(L[i]+1)
import math\nfrom math import gcd,pi,sqrt\nINF = float("inf")\nMOD = 10**9 + 7\n\nimport sys\nsys.setrecursionlimit(10**6)\nimport itertools\nimport bisect\nfrom collections import Counter,deque\ndef i_input(): return int(input())\ndef i_map(): return map(int, input().split())\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\n\n\ndef main():\n    import bisect\n    N,M = i_map()\n    A = i_list()\n    BC = [i_list() for i in range(M)]\n\n    BC.sort(key=lambda x: x[1], reverse=True)\n\n    temp = []\n    for i in range(M):\n        temp += [BC[i][1]] * BC[i][0]\n        if len(temp) > N:\n            break\n    \n    A += temp\n    A.sort(reverse=True)\n    print(sum(A[:N]))\n  \n\n\n  \ndef __starting_point():\n    main()\n__starting_point()
n, k = [int(x) for x in input().strip().split(" ")]\np = 10**9 + 7\n\nnum_list = [int(x) for x in input().strip().split(" ")]\nnum_list = sorted(num_list, reverse = True)\n\nans = 1\nl_idx = 0\nr_idx = -1\n\nif num_list[0] < 0 and k % 2 == 1:\n  for i in range(k):\n    ans = (ans * num_list[i]) % p\nelse:\n  while True:\n    if k >= 2:\n      l_prod = num_list[l_idx] * num_list[l_idx+1]\n      r_prod = num_list[r_idx] * num_list[r_idx-1]\n      if l_prod >= r_prod:\n        ans = (ans * num_list[l_idx]) % p\n        l_idx +=1\n        k -= 1\n      else:\n        ans = (ans * r_prod) % p\n        r_idx -=2\n        k -= 2\n    elif k == 1:\n      ans = (ans * num_list[l_idx]) % p\n      ans %= p\n      break\n    else:\n      break\n\nprint(ans)\n
def main():\n    N = int(input())\n    S = list(map(int, input().split()))\n    INF = float('inf')\n\n    S.sort()\n\n    parents = [S[-1]]\n    S[-1] = INF\n\n    for _ in range(N):\n        checking = 2\n        parents.sort(reverse=True)\n        for i in parents[:]:\n            while True:\n                if S[-checking] < i:\n                    parents.append(S[-checking])\n                    S[-checking] = INF\n                    break\n                else:\n                    checking += 1\n                if checking == 2 ** N + 1:\n                    print('No')\n                    return\n    else:\n        print('Yes')\n\n\ndef __starting_point():\n    main()\n__starting_point()
N=int(input())\na=list(map(int,input().split()))\ncnt=0\nfor i in range(N):\n    if cnt+1==a[i]:\n        cnt+=1\nif cnt==0:\n    print((-1))\nelse:\n    print((N-cnt))\n
def main():\n    import sys\n    import numpy as np\n    def input(): return sys.stdin.readline().rstrip()\n    n = int(input())\n    a = list(map(int, input().split()))\n    inf = 1e18\n    k = n%2 + 1\n    dp = np.full((n+1, k+2), -inf, dtype=int)\n    dp[0,0] = 0\n    for i in range(n):\n        for j in range(k+1):\n            dp[i+1, j+1] = max(dp[i+1,j+1],dp[i,j])\n            now = dp[i,j]\n            if (i+j)%2 == 0: now += a[i]\n            dp[i+1,j] = max(dp[i+1,j],now)\n    print(dp[n,k])\n\ndef __starting_point():\n    main()\n__starting_point()
import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN = INT()\nlim = N+10  # 必要そうな階乗の限界を入れる\nfact = [1] * (lim+1)\nfact_inv = [1] * (lim+1)\nfor n in range(1, lim+1):\n    fact[n] = (fact[n-1] * n) % mod\nfact_inv[lim] = pow(fact[lim], mod-2, mod)\nfor n in range(lim, 0, -1):\n    fact_inv[n-1] = (n * fact_inv[n]) % mod\n\ntree = [[] for _ in range(N+1)]  # 1-indexed\nfor _ in range(N-1):\n	a, b = MAP()\n	tree[a].append(b)\n	tree[b].append(a)\n\nroot = 1\nparent = [0]*(N+1)\norder = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in tree[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\nsize_d = [0]*(N+1)\ndp_d = [1]*(N+1)\n\nfor v in order[::-1]:  # 根に遠いほうから(down方向のボトムアップ)\n    dp_d[v] *= fact[size_d[v]]\n    dp_d[v] %= mod\n    p = parent[v]\n    s = size_d[v] + 1\n    size_d[p] += s\n    dp_d[p] *= fact_inv[s] * dp_d[v]\n    dp_d[p] %= mod\n\nsize_u = [N-1-x for x in size_d]\ndp_u = [1]*(N+1)\n\ndef merge(p1, p2):\n    den_inv1, v1 = p1\n    den_inv2, v2 = p2\n    return den_inv1*den_inv2%mod, v1*v2%mod\n\nfor v in order:\n    p = parent[v]\n    arr = [(fact_inv[size_d[node]+1], dp_d[node]) if node != p else (fact_inv[size_u[v]], dp_u[v]) for node in tree[v]]\n    left = [(1, 1)] + list(accumulate(arr, merge))[:-1]\n    right = list(accumulate(arr[::-1], merge))[-2::-1] + [(1, 1)]\n    contrib = [merge(x, y) for x, y in zip(left, right)]\n    for node, c in zip(tree[v], contrib):\n        if node != p:\n            dp_u[node] = (c[0]*c[1]*fact[size_u[node]-1])%mod\n# print(dp_u)\nfor xd, xu, sd, su in zip(dp_d[1:], dp_u[1:], size_d[1:], size_u[1:]):\n    x = xd * xu * fact[sd + su] * fact_inv[sd] * fact_inv[su] % mod\n    print(x)\n
import sys\nimport os\nfrom copy import copy\nimport operator\nimport time\nimport datetime\nimport math\nfrom math import floor, ceil, sqrt, log\nimport statistics\nfrom statistics import mean, median\nfrom decimal import Decimal as D\nfrom fractions import Fraction as F\nimport functools\nimport random\nfrom random import randint, shuffle\nimport bisect\nimport string\nfrom collections import deque\nimport collections\nimport itertools\nimport heapq\n\nsys.setrecursionlimit(4100000)\nproduct = functools.partial(functools.reduce, operator.mul)\nINF = float("inf")\n\n\nclass UnionFind:\n    def __init__(self, n, m):\n        self.parents = [[-1, {m[i]: 1}] for i in range(n)]\n        self.n = n\n\n    def __getitem__(self, item):\n        if type(item) == tuple:\n            if len(item) == 1:\n                return self.size(item[0])\n            else:\n                self.union(item[0], item[1])\n        elif type(item) == slice:\n            return self.same(item.start, item.stop)\n        else:\n            return self.find(item)\n\n    def __len__(self):\n        return self.group_count()\n\n    def __pos__(self):\n        return self.max_size()\n\n    def __neg__(self):\n        return self.min_size()\n\n    def __invert__(self):\n        return self.roots()\n\n    def union(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x != y:\n            if self.parents[x][0] > self.parents[y][0]:\n                x, y = y, x\n            self.parents[x][0] += self.parents[y][0]\n            for k, v in list(self.parents[y][1].items()):\n                self.parents[x][1].setdefault(k, 0)\n                self.parents[x][1][k] += v\n            self.parents[y] = x\n\n    def find(self, x):\n        if type(self.parents[x]) == list:\n            return x\n        self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return list([x for x in self.parents if x < 0])\n\n    def group_count(self):\n        return len(self.roots())\n\n    def max_size(self):\n        return -min(self.parents)\n\n    def min_size(self):\n        return -max(self.roots())\n\n    def append(self, n):\n        self.parents += [-1] * n\n\n\nclass Imos:\n    def __init__(self, n):\n        self.val = [0] * n\n\n    def add(self, x, y, n=None):\n        if n is None:\n            n = 1\n        self.val[x] += n\n        if len(self.val) > y + 1:\n            self.val[y + 1] -= n\n\n    def imos(self):\n        for i in range(1, len(self.val)):\n            self.val[i] += self.val[i - 1]\n\n    def max(self):\n        return max(self.val)\n\n    def min(self):\n        return min(self.val)\n\n\nclass CS:\n    def __init__(self, grid):\n        self.cs = grid\n        for i0 in range(len(grid)):\n            for i1 in range(len(grid[0])):\n                if i0 == 0:\n                    if i1 == 0:\n                        continue\n                    self.cs[i0][i1] += self.cs[i0][i1 - 1]\n                else:\n                    if i1 == 0:\n                        self.cs[i0][i1] += self.cs[i0 - 1][i1]\n                    else:\n                        self.cs[i0][i1] += self.cs[i0 - 1][i1] + self.cs[i0][i1 - 1] - \\n                                           self.cs[i0 - 1][i1 - 1]\n\n    def sum(self, start_0, start_1, end_0, end_1):\n        if start_0 == 0:\n            if start_1 == 0:\n                return self.cs[end_0][end_1]\n            return self.cs[end_0][end_1] - self.cs[end_0][start_1 - 1]\n        if start_1 == 0:\n            return self.cs[end_0][end_1] - self.cs[start_0 - 1][end_1]\n        start_0 -= 1\n        start_1 -= 1\n        return self.cs[end_0][end_1] - self.cs[start_0][end_1] - self.cs[end_0][\n            start_1] + self.cs[start_0][start_1]\n\n\ndef mod(n):\n    return n % (10 ** 9 + 7)\n\n\ndef sinput():\n    return sys.stdin.readline()[:-1]\n\n\ndef input():\n    inputs = list(map(int, sys.stdin.readline().split()))\n    if len(inputs) == 1:\n        return inputs[0]\n    return inputs\n\n\ndef listban(l):\n    return list(map(list, set(map(tuple, l))))\n\n\ndef div(n):\n    lower_divisors, upper_divisors = [], []\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n // i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n\n\ndef prime(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\n\ndef div_counter(l, n):\n    return prime(l).count(n)\n\n\ndef lcm(x, y):\n    return (x * y) // math.gcd(x, y)\n\n\ndef C(n, r):\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef P(n, r):\n    if n < r:\n        return 0\n    return math.factorial(n) // math.factorial(n - r)\n\n\ndef H(n, r):\n    return C(n + r - 1, r)\n\n\ndef cos(x, y, a):\n    return (x ** 2 + y ** 2 - 2 * x * y * math.cos(math.radians(a))) ** 0.5\n\n\ndef DFS(g, s, pos=None):\n    if pos is None:\n        pos = set()\n    pos.add(s)\n    for i in g[s]:\n        if not (i in pos):\n            DFS(g, i, pos)\n    return pos\n\n\ndef DFS_one(g, s, pos=None):\n    if pos is None:\n        pos = set()\n    pos = copy(pos)\n    pos.add(s)\n    b = copy(pos)\n    m = copy(pos)\n    for i in g[s]:\n        if not (i in pos):\n            b = DFS(g, i, pos)\n            if len(m) < len(b):\n                m = b\n    return m\n\n\ndef BFS(g, q, pos=None):\n    if pos is None:\n        pos = set()\n    if type(q) == deque:\n        pos.add(q)\n        q = deque([q])\n    pos.add(q[-1])\n    for i in g[q.pop()]:\n        if not i in pos:\n            q.append(i)\n    while q != deque():\n        pos, q = BFS(g, q, pos)\n    return pos, q\n\n\ndef SSP(a, li=None):\n    if li is None:\n        li = []\n    if len(a) == 1:\n        return [a[0]]\n    return list(set(\n        li + SSP(a[1:], li) + list([x + a[0] for x in SSP(a[1:], li)]) + [a[0]]))\n\n\ndef dijkstra(g, s):\n    n = len(g)\n    dist = [10 ** 100] * n\n    hq = [(0, s)]\n    dist[s] = 0\n    seen = [False] * n\n    while hq:\n        v = heapq.heappop(hq)[1]\n        seen[v] = True\n        for to, cost in g[v]:\n            if seen[to] == False and dist[v] + cost < dist[to]:\n                dist[to] = dist[v] + cost\n                heapq.heappush(hq, (dist[to], to))\n    return dist\n\n\ndef LIS(b):\n    l = [b[0]]\n    for i in b:\n        if i > l[-1]:\n            l += [i]\n        else:\n            l[bisect.bisect_left(l, i)] = i\n    return len(l)\n\n\ndef yn(b):\n    if b:\n        print("Yes")\n    else:\n        print("No")\n\n\ndef op(s):\n    print(s)\n    return\n\n\nn = input()\na = input()\nif n == 1:\n    a = [a]\nfor i in range(n):\n    a[i] = a[i] - i - 1\nhei = round(median(a))\nans = 0\nfor i in a:\n    ans += abs(hei - i)\nprint(ans)\n
#写経\n#https://atcoder.jp/contests/abc167/submissions/13072107\nimport sys\nreadline = sys.stdin.readline\n\ndef resolve():\n    N = int(readline())\n    S = [readline().strip() for i in range(N)]\n    L,R = [],[]\n    D = []\n    for s in S:\n        l, r = 0, 0\n        for c in s:\n            if c == ')':\n                if l > 0:\n                    l -= 1\n                else:\n                    r += 1\n            else:\n                l += 1\n        if l == 0 and r == 0:\n            pass\n        elif l == 0:\n            R.append(r)\n        elif r == 0:\n            L.append(l)\n        else:\n            D.append((l, r))\n    L = sum(L)\n    R = sum(R)\n\n    inc = []\n    dec = []\n    for l,r in D:\n        if l > r:\n            inc.append((l, r))\n        else:\n            dec.append((l, r))\n    \n    inc.sort(key=lambda x:x[1])\n    dec.sort(key=lambda x:-x[1])\n    \n    D = inc + dec\n    \n    for i, (l,r) in enumerate(D):\n        L -= r\n        if L < 0:\n            print('No')\n            return\n        L += l\n    \n    if L == R:\n        print('Yes')\n    else:\n        print('No')\nresolve()
N=int(input());R,d,f,s,x=sorted(list(map(int,input().split()))for i in range(N))+[(2e9,0)],[0]*N+[1],[0]*N,1,N\nfor i in range(N-1,-1,-1):\n	while R[x][0]<sum(R[i]):x=f[x]\n	d[i]=s=(s+d[x])%998244353;f[i],x=x,i\nprint(d[0])
def main():\n    n, a, b, c = map(int, input().split())\n    Ss = [input() for _ in range(n)]\n    ans = []\n    f = True\n    if a+b+c == 0:\n        print("No")\n    elif a+b+c == 1:\n        for i in range(n):\n            if Ss[i] == "AB":\n                if a == 0 and b == 0:\n                    f = False\n                    break\n                else:\n                    if a == 1:\n                        ans.append("B")\n                        a, b = a-1, b+1\n                    else:\n                        ans.append("A")\n                        a, b = a+1, b-1\n            elif Ss[i] == "AC":\n                if a == 0 and c == 0:\n                    f = False\n                    break\n                else:\n                    if a == 1:\n                        ans.append("C")\n                        a, c = a-1, c+1\n                    else:\n                        ans.append("A")\n                        a, c = a+1, c-1\n            else:\n                if b == 0 and c == 0:\n                    f = False\n                    break\n                else:\n                    if b == 1:\n                        ans.append("C")\n                        b, c = b-1, c+1\n                    else:\n                        ans.append("B")\n                        b, c = b+1, c-1\n        if f:\n            print("Yes")\n            for v in ans:\n                print(v)\n        else:\n            print("No")\n    else:\n        for i in range(n):\n            if Ss[i] == "AB":\n                if a == 0 and b == 0:\n                    f = False\n                    break\n                else:\n                    if i < n-1:\n                        if Ss[i+1] == "AB":\n                            if b == 0:\n                                ans.append("B")\n                                a, b = a-1, b+1\n                            else:\n                                ans.append("A")\n                                a, b = a+1, b-1\n                        elif Ss[i+1] == "AC":\n                            if b == 0:\n                                ans.append("B")\n                                a, b = a-1, b+1\n                            else:\n                                ans.append("A")\n                                a, b = a+1, b-1\n                        else:\n                            if a == 0:\n                                ans.append("A")\n                                a, b = a+1, b-1\n                            else:\n                                ans.append("B")\n                                a, b = a-1, b+1\n                    else:\n                        if a == 0 and b == 0:\n                            f = False\n                            break\n                        elif b == 0:\n                            ans.append("B")\n                            a, b = a-1, b+1\n                        else:\n                            ans.append("A")\n                            a, b = a+1, b-1\n            elif Ss[i] == "AC":\n                if a == 0 and c == 0:\n                    f = False\n                    break\n                else:\n                    if i < n-1:\n                        if Ss[i+1] == "AB":\n                            if c == 0:\n                                ans.append("C")\n                                a, c = a-1, c+1\n                            else:\n                                ans.append("A")\n                                a, c = a+1, c-1\n                        elif Ss[i+1] == "AC":\n                            if c == 0:\n                                ans.append("C")\n                                a, c = a-1, c+1\n                            else:\n                                ans.append("A")\n                                a, c = a+1, c-1\n                        else:\n                            if a == 0:\n                                ans.append("A")\n                                a, c = a+1, c-1\n                            else:\n                                ans.append("C")\n                                a, c = a-1, c+1\n                    else:\n                        if a == 0 and c == 0:\n                            f = False\n                            break\n                        elif c == 0:\n                            ans.append("C")\n                            a, c = a-1, c+1\n                        else:\n                            ans.append("A")\n                            a, c = a+1, c-1\n            else:\n                if b == 0 and c == 0:\n                    f = False\n                    break\n                else:\n                    if i < n-1:\n                        if Ss[i+1] == "AB":\n                            if c == 0:\n                                ans.append("C")\n                                b, c = b-1, c+1\n                            else:\n                                ans.append("B")\n                                b, c = b+1, c-1\n                        elif Ss[i+1] == "AC":\n                            if b == 0:\n                                ans.append("B")\n                                b, c = b+1, c-1\n                            else:\n                                ans.append("C")\n                                b, c = b-1, c+1\n                        else:\n                            if b == 0:\n                                ans.append("B")\n                                b, c = b+1, c-1\n                            else:\n                                ans.append("C")\n                                b, c = b-1, c+1\n                    else:\n                        if b == 0 and c == 0:\n                            f = False\n                            break\n                        elif c == 0:\n                            ans.append("C")\n                            b, c = b-1, c+1\n                        else:\n                            ans.append("B")\n                            b, c = b+1, c-1\n        if f:\n            print("Yes")\n            for v in ans:\n                print(v)\n        else:\n            print("No")\n\ndef __starting_point():\n    main()\n__starting_point()
import numpy as np\nN, C = list(map(int, input().split()))\n\nxv = [(0, 0)]\nfor i in range(N):\n    x, v = list(map(float, input().split()))\n    xv.append((x, v))\n\nsumA = np.zeros(N+2, dtype=float)\nsumB = np.zeros(N+2, dtype=float)\n\nxv.sort(key=lambda tup:tup[0])\nxv.append((C,0))\n\nfor i in range(N+1):\n    sumA[i+1] = sumA[i] + xv[i+1][1]\n    sumB[i+1] = sumB[i] + xv[N-i][1]\n\nmaxA = [0]*(N+1)\nmaxB = [0]*(N+1)\nfor i in range(N):\n    if sumA[i+1] < xv[i+1][0]: sumA[i+1] = 0\n    else: sumA[i+1] -= xv[i+1][0]\n    if sumB[i+1] < C - xv[N-i][0]: sumB[i+1] = 0\n    else: sumB[i+1] -= C - xv[N-i][0]\n\n    maxA[i + 1] = maxA[i]\n    if sumA[i+1] > maxA[i]:\n        maxA[i+1] = sumA[i+1]\n    maxB[i + 1] = maxB[i]\n    if sumB[i+1] > maxB[i]:\n        maxB[i+1] = sumB[i+1]\n\nans = 0\nfor i in range(N):\n    #when to turn back?\n    #valB = -xv[i][0] + max(sumB[:N-i+1])\n    valB = -xv[i][0] + maxB[N - i]\n    if valB < 0:\n        ans = max(ans, sumA[i])\n    else:\n        ans = max(ans, sumA[i] + valB)\n\n    #when to turn back?\n    valA = -C+xv[N-i+1][0] + maxA[N-i]\n    if valA < 0:\n        ans = max(ans, sumB[i])\n    else:\n        ans = max(ans, sumB[i] + valA)\n\nprint((int(ans)))\n
N=int(input())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\n\nA.append(A[0])\nB.append(B[0])\n\nAX=[]\nBX=[]\nfor i in range(N):\n    AX.append(A[i]^A[i+1])\n    BX.append(B[i]^B[i+1])\n\nAX+=AX+[AX[0]]\n\n# Rolling Hashで。\n\np=1<<30\nmod=(1<<62)+1 # Hashがぶつからない, pと互いに素な数を適当に指定\n\nA_TABLE=[0] # Rolling Hashのテーブル. 最初は0\nB_TABLE=[0] # Rolling Hashのテーブル. 最初は0\n\nfor i in range(len(AX)):\n    A_TABLE.append((p*A_TABLE[-1]%mod+AX[i])%mod) # テーブルを埋める\n\nfor i in range(len(BX)):\n    B_TABLE.append((p*B_TABLE[-1]%mod+BX[i])%mod) # テーブルを埋める\n\ndef hash(i,j): # [i,j)のハッシュ値を求める\n    return (A_TABLE[j]-A_TABLE[i]*pow(p,j-i,mod))%mod\n\nBH=B_TABLE[-1]\nANS=[]\nfor i in range(N):\n    if hash(i,i+N)==BH:\n        ANS.append((i,A[i]^B[0]))\n\nfor a in ANS:\n    print(*a)
mod = 10**9 + 7\nn = int(input())\nfiveFac = 120\n\ndef solve(a) : \n	ab2 = a/2\n	return nC5(ab2 - 1)\n\n\ndef nC5(k) : \n	res = (k-4)*(k)*(k-1)*(k-2)*(k-3)\n	res = res/120\n	return res\n\nif n < 13 : \n	print(0)\nelif n == 13 :\n	print(1)\n\nelse : \n	a7Max = n-12 + 1\n	if n%2 == 1 : \n		ans = 0\n		for a7 in range(1,a7Max,2) : \n			rest = n - a7\n			ans += solve(rest)\n			ans = ans%mod\n		print(ans%mod)\n\n	else : \n		ans = 0\n		for a7 in range(2,a7Max,2) : \n			rest = n - a7\n			ans += solve(rest)\n			ans = ans%mod\n		print(ans%mod)
def main():\n    t = int(input())\n    s1 = "one"\n    s2 = "two"\n    for i in range(t):\n        s = input()\n        n = len(s)\n        count = 0\n        i = 2\n        ans = []\n        while i < n:\n            s3 = s[i - 2:i + 1]\n            if s3 == s1 or s3 == s2:\n                count += 1\n                if i + 2 < n and s[i:i + 3] == s1:\n                    ans.append(i + 1)\n                    i += 5\n                else:\n                    ans.append(i)\n                    i += 2\n            else:\n                i += 1\n        print(count)\n        for i in range(len(ans)):\n            print(ans[i], end=" ")\n        print()\nmain()
"""\n#If FastIO not needed, used this and don't forget to strip\n#import sys, math\n#input = sys.stdin.readline\n"""\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport heapq as h \nfrom bisect import bisect_left, bisect_right\n\nfrom types import GeneratorType\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = "x" in file.mode or "r" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b"\n") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode("ascii"))\n        self.read = lambda: self.buffer.read().decode("ascii")\n        self.readline = lambda: self.buffer.readline().decode("ascii")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip("\r\n")\n\nfrom collections import defaultdict as dd, deque as dq, Counter as dc\nimport math, string\n\n\ndef getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\ndef getMat(n):\n    return [getInts() for _ in range(n)]\n\nMOD = 10**9+7\n\n\n"""\nEach edge goes from parent U to child V\nEdge appears on S_V * (N - S_V) paths\n\nFor each path of length L, (L + (-L)%K)/K\n\n\nL%K 0, 1, 2, 3, 4\n(K - L%K)%K K K-1 K-2 ...\n0 K-1 K-2 ...\n\n"""\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef solve():\n    N, K = getInts()\n    graph = dd(set)\n    for i in range(N-1):\n        A, B = getInts()\n        graph[A].add(B)\n        graph[B].add(A)\n    dp_count = [[0 for j in range(5)] for i in range(N+1)]\n    dp_total = [0 for j in range(N+1)]\n    nonlocal ans\n    ans = 0\n    @bootstrap\n    def dfs(node,parent,depth):\n        nonlocal ans\n        dp_count[node][depth % K] = 1\n        dp_total[node] = 1\n        for neigh in graph[node]:\n            if neigh != parent:\n                yield dfs(neigh,node,depth+1)\n                for i in range(K):\n                    for j in range(K):\n                        diff = (i+j-2*depth)%K\n                        req = (-diff)%K\n                        ans += req * dp_count[node][i] * dp_count[neigh][j]\n                for i in range(K):\n                    dp_count[node][i] += dp_count[neigh][i]\n                dp_total[node] += dp_total[neigh]\n        ans += dp_total[node] * (N - dp_total[node])\n        yield\n    dfs(1,-1,0)\n    return ans//K\n    \n    \nprint(solve())\n
t = int(input())\nfor _ in range(t):\n	s = input()\n	n = len(s)\n	if s.count('1') == n or s.count('1') == 0:\n		print(s)\n	else:\n		odp = [0,1]*n\n		for i in range(n):\n			if i < n-1:\n				print("01", end = "")\n			else:\n				print("01")
n=int(input())\ndict1={}\ndict2={}\nfor i in range(n):\n    s=input()\n    s=s.split('/')\n    c=int(s[1])\n    s=s[0].strip('(').strip(')').split('+')\n    a=int(s[0])\n    b=int(s[1])\n    ans=(a+b)/c\n    try:\n        dict2[ans] += 1\n    except:\n        dict2[ans] = 1\n    dict1[i] = ans\nfor i in range(n):\n    print(dict2[dict1[i]],end=' ')\n
n, k = map(int, input().split())\na    = list(map(int, input().split()))\na    = a[::-1]\ns    = [a[0]]\nS    = 0\n\nfor x in a[1:]:\n    s.append(s[-1]+x)\n\nS   += s[-1]\ns.pop()\nk   -= 1\ns   = sorted(s)\n\ni=0\nwhile i<=k-1:\n    S += s.pop()\n    i += 1\nprint(S)    
from math import *\nfor t in range(int(input())):\n    a, b, c, d = map(int, input().split())\n    x, y, x1, y1, x2, y2 = map(int, input().split())\n    x += b - a\n    y += d - c\n    if (x < x1 or x > x2 or y < y1 or y > y2):\n        print("No")\n        continue\n    if x1 == x2 and x1 == x and (a != 0 or b != 0):\n        print("No")\n        continue\n    if y1 == y2 and y1 == y and (c != 0 or d != 0):\n        print("No")\n        continue\n    print("Yes")
import os, sys\n\n# zeilen = [l.strip() for l in sys.stdin.readlines()]\n\nq = int(sys.stdin.readline().strip())\n\n\n\nfor _ in range(q):\n  a, b = list(map(int, sys.stdin.readline().strip().split()))\n  word = sys.stdin.readline().strip()\n  gaps = sorted([len(gap) for gap in word.split('X') if len(gap)>= b])\n  if len(gaps) == 0:\n    print('NO')\n  elif gaps[0] < a:\n    print('NO')\n  elif len(gaps) > 1 and gaps[-2] >= 2*b:\n    print('NO')\n  elif gaps[-1] < 2*b: # no problematic, need only count\n    print('YES' if (len(gaps) % 2) else 'NO')\n  else: # exactly one problematic gap\n    p = gaps[-1]\n    if (len(gaps) % 2): # A tries to make this gap into zero or two\n      if p <= (a + 2*b - 2): # short enough for 0\n        print('YES')\n      elif p < 3*a: # we have to try two\n        print('NO') # not long enough\n      elif p > (a + 4*b - 2): # too long\n        print('NO')\n      else:\n        print('YES')\n    else: # A tries to make this gap into one\n      if p < 2*a: # too short\n        print('NO')\n      elif p > (a + 3*b - 2):# too long\n        print('NO')\n      else:\n        print('YES')\n\n
for _ in range(int(input())):\n    n = int(input())\n    r1 = list(map(int, input().split()))\n    m = int(input())\n    r2 = list(map(int, input().split()))\n    o11 = sum(t % 2 for t in r1) # Counts odd number\n    o12 = n - o11\n    o21 = sum(t % 2 for t in r2) # Counts odd number\n    o22 = m - o21\n    print (o11 * o21 + o12 * o22)
T = int(input())\nfor t in range(T):\n    N, R = list(map(int, input().split()))\n    print(1 + (R - sum(map(int, input().split()))) % N)\n
t = int(input())\nfor _ in range(t):\n  n,x,y = map(int,input().split())\n  s = x+y\n  mx = min(s-1,n)\n  if s<=n:\n    mn = 1\n  else:\n    mn = min(s,s-n+1,n)\n  print(mn,mx)
n=int(input())\nval=list(map(int,input().split()))\nb=list(map(int,input().split()))\nneig=[0]*n\nfor i in range(n):\n    neig[i]=[0]\ninedges=[0]*n\nfor i in range(n):\n    if b[i]!=-1:\n        neig[i][0]+=1\n        neig[i].append(b[i]-1)\n        inedges[b[i]-1]+=1\nans=0\nbeg=[]\nen=[]\ntod=[]\nfor i in range(n):\n    if inedges[i]==0:\n        tod.append(i)\nwhile len(tod)>0:\n    x=tod.pop()\n    ans+=val[x]\n    if val[x]>0:\n        beg.append(x+1)\n    else:\n        en.append(x+1)\n    if neig[x][0]==1:\n        inedges[neig[x][1]]-=1\n        if inedges[neig[x][1]]==0:\n            tod.append(neig[x][1])\n        if val[x]>0:\n            val[neig[x][1]]+=val[x]\nprint(ans)\nprint(*beg,end=" ")\nen.reverse()\nprint(*en)
x = int(input())\nfor i in range(2, x):\n   if x % i == 0:\n        print(i, x // i, sep='')\n        break
import sys\nfrom math import *\n\ndef minp():\n	return sys.stdin.readline().strip()\n\ndef mint():\n	return int(minp())\n\ndef mints():\n	return list(map(int, minp().split()))\n\ndef add(a,x,v):\n	while x<len(a):\n		a[x] += v\n		x |= x+1\ndef get(a,x):\n	r = 0\n	while x>=0:\n		r += a[x]\n		x = (x&(x+1))-1\n	return r\n\n\nn, k, a, b, q = mints()\nh1 = [0]*n\nh2 = [0]*n\nz = [0]*n\nfor i in range(q):\n	t = tuple(mints())\n	if t[0] == 1:\n		p = z[t[1]-1]\n		pp = p + t[2]\n		add(h1, t[1]-1, min(a,pp)-min(a,p))\n		add(h2, t[1]-1, min(b,pp)-min(b,p))\n		z[t[1]-1] = pp\n	else:\n		print(get(h2,t[1]-2)+get(h1,n-1)-get(h1,t[1]+k-2))\n
n = int(input());tot = sum(map(int, input().split()));extra = (n * (n - 1))//2;smol = (tot - extra) // n;out = [smol + i for i in range(n)]\nfor i in range(tot - sum(out)):out[i] += 1\nprint(' '.join(map(str,out)))    
import sys\nimport math\nfrom collections import defaultdict\nfrom itertools import combinations\nfrom itertools import permutations\ninput = lambda : sys.stdin.readline().rstrip()\nread = lambda : map(int, input().split())\ndef write(*args, sep="\n"):\n  for i in args:\n    sys.stdout.write("{}".format(i) + sep)\nINF = float('inf')\nMOD = int(1e9 + 7)\n\nfor q in range(int(input())):\n  n, r = read()\n  arr = sorted(set(read()), reverse=True)\n  s = 0\n  ans = 0\n\n  for i in arr:\n    if s >= i:\n      break\n\n    s += r\n    ans += 1\n\n  write(ans) 
n = int(input())\nT = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    T.append([x, y])\nP = []\nfor i in range(n):\n    for j in range(i + 1, n):\n        x1, y1 = T[i]\n        x2, y2 = T[j]\n        a = y2 - y1\n        b = x1 - x2\n        c = -(a * x1 + b * y1)\n        P.append([a, b, c])\nconst = 10 ** 10 + 3\ncnt = 0\nnewP = []\nvisit = []\nfor a, b, c in P:\n    if a != 0:\n        if [1, b / a, c / a] not in visit:\n            newP.append([1, b / a, c / a])\n            visit.append([1, b / a, c / a])\n    else:\n        if [0, 1, c / b] not in visit:\n            newP.append([0, 1, c / b])\n            visit.append([0, 1, c / b])\nP = newP\nfor i in range(len(P)):\n    for j in range(i + 1, len(P)):\n        a1, b1, c1 = P[i]\n        a2, b2, c2 = P[j]\n        if a1 * b2 == a2 * b1:\n            pass\n        else:\n            x = (b1 * c2 - b2 * c1) / (a1 * b2 - b1 * a2)\n            y = (c1 * a2 - a1 * c2) / (a1 * b2 - b1 * a2)\n            cnt += 1\nprint(cnt)
#\n#    ------------------------------------------------\n#           ____          _     Generatered using\n#          / ___|        | |\n#         | |    __ _  __| | ___ _ __  ______ _\n#         | |   / _` |/ _` |/ _ \ '_ \|_  / _` |\n#         | |__| (_| | (_| |  __/ | | |/ / (_| |\n#          \____\____|\____|\___|_| |_/___\____|\n#\n#      GNU Affero General Public License v3.0\n#    ------------------------------------------------\n#    Author   : prophet\n#    Created  : 2020-07-24 11:19:20.229238\n#    UUID     : dFs0Ek0q78tkOXbf\n#    ------------------------------------------------\n#\nproduction = True\n\nimport sys, math, collections\n\ndef input(input_format = 0, multi = 0):\n\n    if multi > 0: return [input(input_format) for i in range(multi)]\n    else:\n        next_line = sys.stdin.readline()[:-1]\n\n        if input_format >= 10:\n            use_list = False\n            input_format = int(str(input_format)[-1])\n        else: use_list = True\n\n        if input_format == 0: formatted_input = [next_line]\n        elif input_format == 1: formatted_input = list(map(int, next_line.split()))\n        elif input_format == 2: formatted_input = list(map(float, next_line.split()))\n        elif input_format == 3: formatted_input = list(next_line)\n        elif input_format == 4: formatted_input = list(map(int, list(next_line)))\n        elif input_format == 5: formatted_input = next_line.split()\n        else: formatted_input = [next_line]\n\n        return formatted_input if use_list else formatted_input[0]\n\ndef out(output_line, output_format = 0, newline = True):\n\n    formatted_output = ""\n\n    if output_format == 0: formatted_output = str(output_line)\n    elif output_format == 1: formatted_output = " ".join(map(str, output_line))\n    elif output_format == 2: formatted_output = "\n".join(map(str, output_line))\n    elif output_format == 3: formatted_output = "".join(map(str, output_line))\n\n    print(formatted_output, end = "\n" if newline else "")\n\ndef log(*args):\n    if not production:\n        print("$$$", end = "")\n        print(*args)\n\nenu = enumerate\nter = lambda a, b, c: b if a else c\nceil = lambda a, b: -(-a // b)\nflip = lambda a: (a + 1) & 1\n\ndef mapl(iterable, format = 0):\n    \n    if format == 0: return list(map(int, iterable))\n    elif format == 1: return list(map(str, iterable))\n    elif format == 2: return list(map(list, iterable))\n#\n#   >>>>>>>>>>>>>>> START OF SOLUTION <<<<<<<<<<<<<<\n#\n\n\ndef solve():\n\n    n, k, l = input(1)\n    d = input(1)\n\n    log(k, l)\n    log(d)\n\n    f = [l - i for i in d]\n\n    log(f)\n\n    p = [(0, 2 * k - 1)]\n\n    for i in f:\n        a, b = p[-1]\n        if i >= k:\n            p.append((0, 2 * k - 1))\n        else:\n            fb = k + i\n            fa = max(a + 1, k - i)\n            log(i, fb, fa)\n            if fb < fa:\n                out("No")\n                return\n\n            p.append((fa, fb))\n        log(p)\n    else:\n        out("Yes")\n\n    log("")\n    return\n\n\nfor i in range(input(11)): solve()\n\n#\n#   >>>>>>>>>>>>>>>> END OF SOLUTION <<<<<<<<<<<<<<<\n#\n
import sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    input()\n    l = list(map(int,input().split()))\n\n    bad = False\n    \n    curr = 0\n    for v in l:\n        curr += v\n        if curr <= 0:\n            bad = True\n            break\n\n    l.reverse()\n    curr = 0\n    for v in l:\n        curr += v\n        if curr <= 0:\n            bad = True\n            break\n\n    if bad:\n        print('NO')\n    else:\n        print('YES')\n
#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue\n#sys.stdin = open("input.txt", "r")\nMOD = 10**9+7\n\nn = int(input())\np = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    p.append((x, y))\n\nd = {}\n\nfor i in range(n):\n    x1, y1 = p[i]\n    for j in range(i+1, n):\n        x2, y2 = p[j]\n        if x1 != x2:  \n            m = (y2-y1)/(x2-x1)\n            c = (y1*x2-x1*y2)/(x2-x1)\n        else:\n            m = 10**10\n            c = x1\n        if m in d:\n            if c in d[m]:\n                d[m][c] += 1\n            else:\n                d[m][c] = 1\n        else:\n            d[m] = {c: 1}\n\np = []\nfor m in d:\n    p.append(len(d[m]))\ns = sum(p)\nans = 0\nfor x in p:\n    ans += x*(s-x)\nprint(ans//2)
for _ in range(int(input())):\n	n = int(input())\n	s = input()\n	for i in range(len(s)-10):\n		if(s[i] == '8'):\n			print("YES")\n			break\n	else:\n		print("NO")		
# Contest: Codeforces Round #592 (Div. 2) (https://codeforces.com/contest/1244)\n# Problem: B: Rooms and Staircases (https://codeforces.com/contest/1244/problem/B)\n\ndef rint():\n    return int(input())\n\n\ndef rints():\n    return list(map(int, input().split()))\n\n\nt = rint()\nfor _ in range(t):\n    n = rint()\n    s = input()\n    mx = n\n    for i in range(n):\n        if s[i] == '0':\n            continue\n        mx = max(mx, 2 * max(i + 1, n - i))\n    print(mx)\n
for _ in range(int(input())):\n    ar = list(map(int, input().split()))\n    print(ar[0] + ar[1])
k = '''	\nH	\nHe	\nLi\nBe	\nB\nC\nN\nO\nF\nNe	\nNa\nMg	\nAl\nSi\nP\nS\nCl\nAr	\nK\nCa	\nSc\nTi\nV\nCr\nMn\nFe\nCo\nNi\nCu\nZn\nGa\nGe\nAs\nSe\nBr\nKr\n5	\nRb\nSr	\nY\nZr\nNb\nMo\nTc\nRu\nRh\nPd\nAg\nCd\nIn\nSn\nSb\nTe\nI\nXe	\nCs\nBa\nLa\nCe\nPr\nNd\nPm\nSm\nEu\nGd\nTb\nDy\nHo\nEr\nTm\nYb\nLu\nHf\nTa\nW\nRe\nOs\nIr\nPt\nAu\nHg\nTl\nPb\nBi\nPo\nAt\nRn	\nFr\nRa\nAc\nTh\nPa\nU\nNp\nPu\nAm\nCm\nBk\nCf\nEs\nFm\nMd\nNo\nLr\nRf\nDb\nSg\nBh\nHs\nMt\nDs\nRg\nCn\nNh\nFl\nMc\nLv\nTs\nOg	\nUue\nUbn\nUbu\nUbb\nUbt\nUbq\nUbp\nUbh\nUbs\n'''.upper().split()\n\ns = '0' + input()\ndp = [0] * (len(s))\ndp[0] = 1\nfor i in range(1, len(s)):\n    for j in range(1, 3):\n        if s[i - j + 1: i + 1] in k: dp[i] |= dp[i - j]\nprint("YES" if dp[-1] else "NO")
def solve(n, arr):\n    xor_sum = arr[0]\n    for i in range(1, n):\n        xor_sum ^= arr[i]\n    if n % 2 == 0:\n        if xor_sum:\n            print("NO")\n            return\n        else:\n            n -= 1\n    if n == 3:\n        print(1)\n        print(1, 2, 3)\n        return\n    \n    print("YES")\n    print(n-2)\n    for i in range(1, n-1, 2):\n        print(i, i+1, i+2)\n    for i in range(n-4, 0, -2):\n        print(i, i+1, i+2)\n\n\nn = int(input())\narr = list(map(int, input().split()))\nsolve(n, arr)\n
n=int(input())\nl1=list(map(int,input().split()))\nl2=list(map(int,input().split()))\nfined=0\ni=0\nj=0\nd1={}\nwhile i<n and j<n:\n    if l1[i] in d1:\n        i+=1\n        continue\n    if l1[i]==l2[j]:\n        i+=1\n        j+=1\n    else :\n        while j<n and l2[j]!=l1[i]:\n            d1[l2[j]]=1\n            j+=1\n            fined+=1\nprint(fined)
import sys\nfrom sys import stdout\nimport random\nfrom fractions import Fraction\nfrom math import *\n \ndef input():\n    return sys.stdin.readline().strip()\n \ndef iinput():\n    return int(input())\n\ndef finput():\n    return float(input())\n\ndef tinput():\n    return input().split()\n\ndef linput():\n    return list(input())\n \ndef rinput():\n    return list(map(int, tinput()))\n\ndef fiinput():\n    return list(map(float, tinput()))\n \ndef rlinput():\n    return list(map(int, input().split()))\ndef trinput():\n    return tuple(rinput())\n\ndef srlinput():\n    return sorted(list(map(int, input().split())))\n\ndef NOYES(fl):\n    if fl:\n        print("NO")\n    else:\n        print("YES")\ndef YESNO(fl):\n    if fl:\n        print("YES")\n    else:\n        print("NO")\n    \ndef main():\n    def answer(res):\n        print((res + 1) // 2)\n    n = iinput()\n    #k = iinput() \n    #m = iinput() \n    #n = int(sys.stdin.readline().strip()) \n    #n, k = rinput()\n    #n, m = rinput()\n    #m, k = rinput()\n    #n, k, m = rinput()\n    #n, m, k = rinput()\n    #k, n, m = rinput()\n    #k, m, n = rinput() \n    #m, k, n = rinput()\n    #m, n, k = rinput()\n    #q = srlinput()\n    #q = linput()\n    q = rlinput()\n    w = [0] + [q[i] - q[i - 1] for i in range(1, n)]\n    res = q[0] + sum([max(w[i], 0) for i in range(1, n)])\n    answer(res)\n    k = iinput()\n    for o in range(k):\n        l, r, x = rinput()\n        if l == 1:\n            res += x        \n        else:\n            res = res - max(0, w[l - 1]) + max(0, w[l - 1] + x); w[l - 1] += x \n        if r != n:\n            res = res - max(0, w[r]) + max(0, w[r] - x); w[r] -= x \n        answer(res)\n    \n        \n    \n    \n        \n    \n\nfor i in range(1):\n    main()\n
for _ in range(int(input())):\n    a, b = list(map(int, input().split()))\n    d = abs(a - b)\n    ans = 0\n    while d > 0 or (-d) % 2 or (-d) // 2 > ans:\n        ans += 1\n        d = abs(d) - ans\n    print(ans)\n
import sys\n\nNORM = 2000000\nLIMIT = NORM * 2 + 1\n\nclass segmentTree:\n	def __init__(self, n):\n		self.n = n\n		self.t = [0] * (n * 2)\n		self.lazy = [0] * n\n\n	def apply(self, p, value):\n		self.t[p] += value\n		if p < self.n:\n			self.lazy[p] += value\n		\n	def build(self, p):\n		while p > 1:\n			p >>= 1\n			self.t[p] = max(self.t[p * 2], self.t[p * 2 + 1]) + self.lazy[p]\n	\n	def push(self, p):\n		log = 0\n		while (1 << log) <= self.n:\n			log += 1\n		\n		for s in range(log, 0, -1):\n			parent = p >> s\n			if self.lazy[parent] != 0:\n				self.apply(parent * 2, self.lazy[parent])\n				self.apply(parent * 2 + 1, self.lazy[parent])\n				self.lazy[parent] = 0 \n	\n	def inc(self, l, r, value):\n		l += self.n\n		r += self.n\n		l0, r0 = l, r\n		while l < r:\n			if l & 1: \n				self.apply(l, value)\n				l += 1\n			if r & 1:\n				self.apply(r - 1, value)\n				r -= 1\n			l >>= 1\n			r >>= 1\n		self.build(l0)\n		self.build(r0 - 1)\n	\n	def query(self, l, r):\n		l += self.n\n		r += self.n\n		self.push(l)\n		self.push(r - 1)\n		res = 0\n		while l < r:\n			if l & 1:\n				res = max(res, self.t[l])\n				l += 1\n			if r & 1:\n				res = max(res, self.t[r - 1])\n				r -= 1\n			l >>= 1\n			r >>= 1\n		return res\n\ninp = [int(x) for x in sys.stdin.read().split()]\nn, r = inp[0], inp[1]\ninp_idx = 2\n\npoints = []\nenv = {}\n\nfor _ in range(n):\n	x, y = inp[inp_idx], inp[inp_idx + 1]\n	inp_idx += 2\n\n	new_x = x - y\n	new_y = x + y\n	new_x += NORM\n	new_y += NORM\n	\n	if not new_y in env:\n		env[new_y] = []\n	env[new_y].append(new_x)\n	points.append([new_x, new_y])\n\nsq_side = r * 2\n\ntree = segmentTree(LIMIT)\n\nys = []\nfor y in list(env.keys()):\n	ys.append(y)\nys = sorted(ys)\n\nans = 0\nlast = 0\nfor i in range(len(ys)):\n	y = ys[i]\n	while i > last and ys[last] < y - sq_side:\n		low_y = ys[last]\n		for x in env[low_y]:\n			low_x = max(0, x - sq_side)\n			tree.inc(low_x, x + 1, -1)\n		last += 1\n	\n	for x in env[y]:\n		low_x = max(0, x - sq_side)\n		tree.inc(low_x, x + 1, +1)\n\n	ans = max(ans, tree.query(0, LIMIT))\n\nprint(ans)\n	\n\n\n\n
import sys\ninput = sys.stdin.readline\n\ndef main():\n    x, y = list(map(int, input().split()))\n    clst = list(map(int, input().split()))\n    clst[0] = min(clst[0], clst[5] + clst[1])\n    clst[1] = min(clst[1], clst[0] + clst[2])\n    clst[2] = min(clst[2], clst[1] + clst[3])\n    clst[3] = min(clst[3], clst[2] + clst[4])\n    clst[4] = min(clst[4], clst[3] + clst[5])\n    clst[5] = min(clst[5], clst[4] + clst[0])\n    directions = [(1, 1), (0, 1), (-1, 0), (-1, -1), (0, -1), (1, 0)]\n    ans = 10 ** 20\n    for i in range(6):\n        dx1, dy1 = directions[i]\n        dx2, dy2 = directions[(i + 1) % 6]\n        a = (x * dy2 - y * dx2) // (dx1 * dy2 - dy1 * dx2)\n        b = (x * dy1 - y * dx1) // (dx2 * dy1 - dy2 * dx1)\n        if a < 0 or b < 0:\n            continue\n        ans = min(ans, clst[i] * a + clst[(i + 1) % 6] * b)\n    print(ans)\n    \nfor _ in range(int(input())):\n    main()\n
def solve():\n    n = int(input())\n    if n % 3 == 0:\n        print(n//3,0,0)\n        return 0\n    if n % 3 == 1:\n        if n < 7:\n            print(-1)\n        else:\n            print((n-7)//3, 0, 1)\n        return 0\n    if n < 5:\n        print(-1)\n        return 0\n    print((n-5)//3, 1, 0)\nfor i in range(int(input())):\n    solve()
N = int(input())\ncnt = [0] * N\nfor n in range(N - 1):\n    u, v = list(map(int, input().split()))\n    cnt[u - 1] += 1\n    cnt[v - 1] += 1\n\nprint(sum(x == 1 for x in cnt))\n
import sys\nreadline = sys.stdin.readline\n\nMOD = 998244353\nN = int(readline())\nwants = [tuple(map(int, readline().split()))[1:] for _ in range(N)]\n\nQ = [0]*(10**6+1)\nP = [0]*(10**6+1)\n\nfor i in range(N):\n    k = len(wants[i])\n    kinv = pow(k, MOD-2, MOD)\n    for w in wants[i]:\n        P[w] += 1\n        Q[w] = (Q[w] + kinv)%MOD\n\nres = 0\nfor i in range(10**6+1):\n    res = (res+P[i]*Q[i])%MOD\n\nprint(pow(N**2, MOD-2, MOD)*res%MOD)
q = int(input())\n\ndef racunaj():\n	s = []\n	for i in range(27):\n		d = 2\n		n = 2**i - 1\n		z = 1\n		while d*d <= n:\n			if n % d == 0:\n				z = n // d\n				break\n			d += 1\n		s.append(z)\n	return s\n\nnajdel = racunaj()\n# print(najdel)\n\nfor _q in range(q):\n	n = int(input())\n	z = 1\n	c = 1\n	while z < n:\n		z = 2*z+1\n		c += 1\n	if z > n:\n		print(z)\n	else:\n		print(najdel[c])
#list(map(int,input().split()))\nt=int(input())\nfor i in range(t):\n    n=int(input())\n    it=list(map(int,input().split()))\n    if n==1 and it[0]%2==1:\n        print(-1)\n    else:\n        ind=-1\n        ind2=-1\n        ind3=-1\n        for j in range(n):\n            if it[j]%2==0:\n                ind=j\n            elif ind2==-1:\n                ind2=j\n            else:\n                ind3=j\n            \n        if ind==-1:\n            print(2)\n            print(ind2+1,ind3+1)\n        else:\n            print(1)\n            print(ind+1)\n        \n
def solve(a):\n    seen = set()\n    for i in range(len(a)):\n        c = 0\n        for j in range(i+2,len(a)):\n            c += a[j-1]\n            if a[i]^a[j] == c:\n                seen.add((i,j))\n            if c >= 2*a[i]:\n                break\n    \n    for i in range(len(a)-1,-1,-1):\n        c = 0\n        for j in range(i-2,-1,-1):\n            c += a[j+1]\n            if a[i]^a[j] == c:\n                seen.add((j,i))\n            if c >= 2 *a[i]:\n                break\n    print(len(seen))\n            \n\n\nn = int(input())\na = list(map(int,input().split()))\nsolve(a)
def main():\n    T = int(input().strip())\n    for _ in range(T):\n        s = input().strip()\n        t = input().strip()\n        n = len(s)\n        \n        find = [[n] * 26 for _ in range(n + 2)]\n        for i in range(n - 1, -1, -1):\n            find[i][:] = find[i + 1]\n            find[i][ord(s[i]) - ord("a")] = i\n\n        def interleaving(a, b):\n            dp = [n] * (len(b) + 1)\n            for i in range(len(a) + 1):\n                for j in range(len(b) + 1):\n                    if i == j == 0:\n                        dp[j] = -1\n                        continue\n                    res = n\n                    if i > 0:\n                        res = min(res, find[dp[j] + 1][ord(a[i - 1]) - ord("a")])\n                    if j > 0:\n                        res = min(res, find[dp[j - 1] + 1][ord(b[j - 1]) - ord("a")])\n                    dp[j] = res\n            return dp[-1] < n\n\n        if any(interleaving(t[:i], t[i:]) for i in range(len(t))):\n            print("YES")\n        else:\n            print("NO")\n\n\nmain()\n
for _ in range(int(input())):\n    n = int(input())\n    x1 = 0\n    x2 = 0\n    for i in range(1, n//2):\n        x1 += 2**i\n    for j in range(n//2, n):\n        x2 += 2**j\n    x1 += 2**n\n    print(abs(x1 - x2))
#python33\n\ndef program():\n    a=[]\n    t=0\n    n=int(input())\n    for i in range(n):\n        a.append(int(input()))\n    t=a[0]+1\n    for j in range(1,len(a)):\n        t+=abs(a[j]-a[j-1])+2\n    print (t)    \nprogram()       \n
import sys\ninput = sys.stdin.readline\n\n\nG0=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]\nG1=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]\nG2=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]\n\n\nfor x in range(1,6):\n    for y in range(1,6):\n        for z in range(1,6):\n            \n            for i in range(1,5500):\n                s=G0[x][y][z][max(0,i-x)]\n                t=G1[x][y][z][max(0,i-y)]\n                u=G2[x][y][z][max(0,i-z)]\n\n                for j in range(5):\n                    if j==s or j==t or j==u:\n                        continue\n                    else:\n                        G0[x][y][z][i]=j\n                        break\n\n                for j in range(5):\n                    if j==s or j==u:\n                        continue\n                    else:\n                        G1[x][y][z][i]=j\n                        break\n\n                for j in range(5):\n                    if j==s or j==t:\n                        continue\n                    else:\n                        G2[x][y][z][i]=j\n                        break\n\ndef lcm(x, y):\n    return (x * y) // math.gcd(x, y)\n\nt=int(input())\nfor tests in range(t):\n    n,x,y,z=list(map(int,input().split()))\n    B=list(map(int,input().split()))\n    A=[]\n    for a in B:\n        if a<=5400:\n            A.append(a)\n        else:\n            A.append(a%2520+2520)\n\n    XOR=0\n\n    for a in A:\n        XOR^=G0[x][y][z][a]\n\n    ANS=0\n    for a in A:\n        k=XOR^G0[x][y][z][a]\n\n        if G0[x][y][z][max(0,a-x)]==k:\n            ANS+=1\n\n        if G1[x][y][z][max(0,a-y)]==k:\n            ANS+=1\n\n        if G2[x][y][z][max(0,a-z)]==k:\n            ANS+=1\n\n    print(ANS)\n\n    \n
n = int(input())\na = (n & 32) >> 5\nb = (n & 16) >> 4\nc = (n & 8) >> 3\nd = (n & 4) >> 2\ne = (n & 2) >> 1\nf = n & 1\n\nprint(32 * a + 16 * f + 8 * d + 4 * c + 2 * e + b)\n
for i in range(int(input())):\n    a,b,c=map(int,input().split())\n    x,y=map(int,input().split())\n    ans=0\n    if x>y:\n        ans=ans+x*min(a//2,b)\n        a=(a-2*min(a//2,b))\n        ans=ans+y*min(a//2,c)\n    else :\n        ans=ans+y*min(a//2,c)\n        a=(a-2*min(a//2,c))\n        ans=ans+x*min(a//2,b)\n    print(ans)
t = int(input())\nfor tt in range(t):\n	x, y = map(int, input().split())\n	print('YES' if x % y == 0 else "NO")
t = int(input())\nfor _ in range(t):\n    n, x, m = list(map(int, input().split()))\n\n    left = x\n    right = x\n\n    for i in range(m):\n        l,r = list(map(int, input().split()))\n\n        if l < left <= r:\n            left = l\n        if r > right >= l:\n            right = r\n\n    print(right - left + 1)\n
import sys\ninput = sys.stdin.readline\nfor f in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    a.sort()\n    mx=1\n    for i in range(n):\n        if a[i]<=i+1:\n            mx=i+2\n    print(mx)
import random\n\nn = int(input())\n\nbest = n\n\nl = list(map(int, input().split()))\ncandidates = set()\ncandidates.add(2)\n\ndef gcd(x, y):\n    while(y): \n       x, y = y, x % y \n    return x\n\ndef factAdd(n):\n    for c in candidates:\n        while n % c == 0:\n            n //= c\n            \n    test = 3\n    while test * test <= n:\n        while n % test == 0:\n            candidates.add(test)\n            n //= test\n        test += 2\n    if n > 1:\n        candidates.add(n)\n\nfor i in range(100):\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n\n    diff = [-1, 0, 1]\n    \n    for d1 in diff:\n        a1 = l[a] + d1\n        if a1:\n            for d2 in diff:\n                a2 = l[b] + d2\n                if a2:\n                    factAdd(gcd(a1, a2))\n\nfor cand in candidates:\n    count = 0\n    for v in l:\n        if v <= cand:\n            count += (cand - v)\n        else:\n            v2 = v % cand\n            count += min(v2, cand - v2)\n    if count < best:\n        best = count\nprint(best)\n
n = int(input())\ns = input()\ntab = []\ncount = 1\nfor i in range(1, n):\n	if s[i] == s[i-1]:\n		count += 1\n	else:\n		if count > 0:\n			tab.append(count)\n		count = 1\nif count > 0:\n	tab.append(count)\ndis = 0\nk = len(tab)\nif k == 0 or k == 1:\n	dis = 0\nelse:\n	dis += tab[1]\n	dis += tab[-2]\n	dis -= (k-1)\n	for i in range(1, k - 1):\n		dis += tab[i-1]\n		dis += tab[i+1]\nprint(n*(n-1)//2 - dis)
from sys import stdin\ninput = stdin.readline\nq = int(input())\nfor _ in range(q):\n    n = int(input())\n    l = list(map(int,input().split()))\n    if sum(l) == 0:\n        print("NO")\n    else:\n        l.sort()\n        if sum(l) > 0:\n            l.reverse()\n        print("YES")\n        print(*l)
import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nfrom collections import deque\n\nclass LCA():\n    def __init__(self, G, root):\n        self.n = len(G)\n        self.dep=[0]*self.n\n        self.par=[[-1]*self.n for i in range(18)]\n\n        def bfs(root):\n            que = deque()\n            que.append((-1,root,0))\n            while que:\n                p,v,d = que.pop()\n                self.dep[v]=d\n                self.par[0][v]=p\n                for to in G[v]:\n                    if to != p:\n                        que.append((v,to,d+1))\n\n        bfs(root)\n\n        for i in range(17):\n            for j in range(self.n):\n                self.par[i+1][j]=self.par[i][self.par[i][j]]\n\n    def lca(self,a,b):\n        if self.dep[a]>self.dep[b]:\n            a,b=b,a\n        for i in range(18):\n            if (self.dep[b]-self.dep[a]) & 1<<i:\n                b=self.par[i][b]\n        if a==b:\n            return a\n        for i in range(18)[::-1]:\n            if self.par[i][a]!=self.par[i][b]:\n                a=self.par[i][a]\n                b=self.par[i][b]\n        return self.par[0][a]\n\n    def dist(self, a,b):\n        lca = self.lca(a,b)\n        return self.dep[a]+self.dep[b]-2*self.dep[lca]\n\nn = int(input())\nG = [[] for i in range(n)]\n\nfor i in range(n-1):\n    a,b = list(map(int, input().split()))\n    a,b = a-1,b-1\n    G[a].append(b)\n    G[b].append(a)\n\nL = LCA(G, 0)\n\nq = int(input())\nfor i in range(q):\n    x,y,a,b,k = list(map(int, input().split()))\n    x,y,a,b = x-1,y-1,a-1,b-1\n\n    ab = L.dist(a,b)\n    base = [ab]\n\n    ax = L.dist(a,x)\n    ay = L.dist(a,y)\n    bx = L.dist(b,x)\n    by = L.dist(b,y)\n\n    base.append(ax+1+by)\n    base.append(ay+1+bx)\n\n    flag = any(ki<=k and (k-ki)%2==0 for ki in base)\n\n    if flag:\n        print("YES")\n    else:\n        print("NO")\n\n
__author__ = 'Gleb'\n\nfrom time import time\nfrom collections import defaultdict\nfrom bisect import bisect_left, bisect_right\n\nn, m = int(input()) + 1, 1000000007\nq, p = [[] for i in range(n)], [[] for i in range(n)]\nw = [0] + list(map(int, input().split()))\nfor i in range(int(input())):\n    u, v = map(int, input().split())\n    p[u].append(v)\n    q[v].append(u)\nr = set(i for i in range(1, n) if not p[i] or not q[i])\ns, t = 0, 1\nwhile r:\n    i = r.pop()\n    s += w[i]\n    for j in p[i]:\n        q[j].remove(i)\n        if not q[j]: r.add(j)\n    for j in q[i]:\n        p[j].remove(i)\n        if not p[j]: r.add(j)\nr = set(i for i in range(1, n) if p[i] and q[i])\nwhile r:\n    i = r.pop()\n    h = p[i]\n    d, k = w[i], 1\n    while h:\n        i = h.pop()\n        if not i in r: continue\n        r.remove(i)\n        h += p[i]\n        if w[i] == d: k += 1\n        elif w[i] < d: d, k = w[i], 1\n    s += d\n    t = (t * k) % m\nprint(s, t)
for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int,input().split()))\n    a,b = 0,0\n    arr.sort()\n    for i in arr:\n        if a==i:\n            a+=1\n        elif b==i:\n            b+=1\n    print(a+b)
import math\n \ndef gcdExtended(a, b):  \n  \n    # Base Case  \n    if a == 0 :   \n        return b, 0, 1\n             \n    gcd, x1, y1 = gcdExtended(b%a, a)  \n     \n    # Update x and y using results of recursive  \n    # call  \n    x = y1 - (b//a) * x1  \n    y = x1  \n     \n    return gcd, x, y \n \ndef rev_elem(x, m):\n    return (gcdExtended(x, m)[1] % m + m) % m\n \nn, m = map(int, input().split())\na = []\nif n > 0:\n    a = [int(i) for i in input().split()]\n \nbanned = [False] * (m + 5)\nfor i in a:\n    banned[i] = True\n \ncycle = [[] for i in range(m + 5)]\nd, dp, p = [], [], []\nfor i in range(m):\n    cycle[math.gcd(m, i)].append(i)\ncycle = [[i for i in j if not banned[i]] for j in cycle]\n \nd = [i for i in range(1, m + 1) if m % i == 0]\ndp = [len(cycle[i]) for i in d]\np = [-1 for i in d]\nans, lst = -1, -1\n \nfor i in range(len(d)):\n    if dp[i] > ans:\n        ans, lst = dp[i], i\n    for j in range(i + 1, len(d)):\n        if d[j] % d[i] != 0 or dp[j] > dp[i] + len(cycle[d[j]]):\n            continue\n        dp[j] = dp[i] + len(cycle[d[j]])\n        p[j] = i\nprint(ans)\n        \npos, dpos, pref = [], [], []\ncur = lst\nwhile cur != -1:\n    dpos.append(d[cur])\n    cur = p[cur]\ndpos.reverse()\n \nfor i in dpos:\n    pref += cycle[i]\ncur = 1\nfor i in pref:\n    ad = 1\n    if math.gcd(i, m) != math.gcd(cur, m):\n        ad = ((cur * math.gcd(i, m) // math.gcd(cur, math.gcd(i, m))) // cur) % m\n    ncur = (cur * ad) % m\n    ad *= i // math.gcd(ncur, m) * (rev_elem(ncur // math.gcd(ncur, m), m // math.gcd(ncur, m)))\n\n    ad %= m\n    cur = (cur * ad) % m\n \n    pos.append(ad)\n \nprint(*pos)
import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nfrom heapq import heappop, heappush, heapify\nfrom collections import deque\nclass SWAG_Stack():\n    def __init__(self, F):\n        self.stack1 = deque()\n        self.stack2 = deque()\n        self.F = F\n        self.len = 0\n\n    def push(self, x):\n        if self.stack2:\n            self.stack2.append((x, self.F(self.stack2[-1][1], x)))\n        else:\n            self.stack2.append((x, x))\n        self.len += 1\n\n    def pop(self):\n        if not self.stack1:\n            while self.stack2:\n                x, _ = self.stack2.pop()\n                if self.stack1:\n                    self.stack1.appendleft((x, self.F(x, self.stack1[0][1])))\n                else:\n                    self.stack1.appendleft((x, x))\n        x, _ = self.stack1.popleft()\n        self.len -= 1\n        return x\n\n    def sum_all(self):\n        if self.stack1 and self.stack2:\n            return self.F(self.stack1[0][1], self.stack2[-1][1])\n        elif self.stack1:\n            return self.stack1[0][1]\n        elif self.stack2:\n            return self.stack2[-1][1]\n        else:\n            return float("inf")\n\nn,p = map(int, input().split())\nt = list((j, i) for i,j in enumerate(map(int, input().split())))\nheapify(t)\n\nstack = SWAG_Stack(min)\n\nheap = []\ncur = 0\nans = [-1]*n\nhoge = 0\n# 今追加できるやつで最も小さいものを追加\n# ここでなにもなかったら？\n#   時間を変更する\n# 次の時間までに追加できるものを追加\n# 清算\nwhile hoge != n:\n    if heap and stack.sum_all() > heap[0]:\n        j = heappop(heap)\n        stack.push(j)\n\n    if stack.len==0 and t:\n        cur = max(cur, t[0][0])\n\n    while t and t[0][0] <= cur+p:\n        ti, i = heappop(t)\n        if ti == cur+p:\n            # 後回し\n            heappush(heap, i)\n        else:\n            # いま追加できるか確認\n            if stack.sum_all() > i:\n                stack.push(i)\n            else:\n                # 後回し\n                heappush(heap, i)\n\n    if stack.len:\n        j = stack.pop()\n        cur += p\n        ans[j] = cur\n        hoge += 1\nprint(*ans)
for _ in range(int(input())):\n    n = int(input())\n    print(n // 2 + 1)\n
import sys\nfrom collections import defaultdict\nfrom math import gcd, sqrt\n\nMAX = pow(10, 5)\n# stdin = open("testdata.txt", "r")\nip = sys.stdin\n\nn = int(ip.readline())\n\na = list(map(int, ip.readline().split()))\ngcd_count = defaultdict(int)\n\nmain_gcd = defaultdict(int)\n\nmain_gcd[a[0]] = 1\ngcd_count[a[0]] = 1\nfor i in range(1, n):\n	ele = a[i]\n	temp_gcd = defaultdict(int)\n	temp_gcd[ele] = 1\n	gcd_count[ele] += 1\n	for k, v in main_gcd.items():\n		temp = gcd(ele, k)\n		temp_gcd[temp] += v\n		gcd_count[temp] += v\n	main_gcd = temp_gcd\n\nq = int(ip.readline())\nfor _ in range(q):\n	k = int(ip.readline())\n	print(gcd_count[k])
T = int(input())\n\nfor _ in range(T):\n    s = input()\n    n = len(s)\n    res = 10 ** 100\n    for i in range(n + 1):\n        p,q = s[:i], s[i:]\n        res = min(res, p.count('0') + q.count('1'))\n        res = min(res, p.count('1') + q.count('0'))\n    print(res)\n
t = int(input())\n\nfor _ in range(t):\n	n = int(input())\n	a, b, c = map(int, input().split())\n	s = input()\n\n	t = ["X"] * n\n	wins = 0\n	for i, en in enumerate(s):\n		if en=="R" and b:\n			b-=1\n			t[i] = "P"\n			wins += 1\n		elif en=="P" and c:\n			c-=1\n			t[i] = "S"\n			wins += 1\n		elif en=="S" and a:\n			a-=1\n			t[i] = "R"\n			wins += 1\n\n	if wins < n/2:\n		print("NO")\n	else:\n		print("YES")\n		for i, my in enumerate(t):\n			if my=="X":\n				if a:a-=1;t[i]="R"\n				elif b:b-=1;t[i]="P"\n				elif c:c-=1;t[i]="S"\n		print("".join(t))
MOD = 10**9 + 7\nm, N = list(map(int, input().split()))\n\nbinom = [[1] + [0 for i in range(m)] for j in range(m + 1)]\nfor n in range(1, m + 1):\n    for k in range(1, n + 1):\n        binom[n][k] = (binom[n - 1][k] + binom[n - 1][k - 1]) % MOD\n\nbell = [0 for n in range(m + 1)]\nbell[0] = bell[1] = 1\nfor n in range(1, m):\n    for k in range(n + 1):\n        bell[n + 1] += bell[k] * binom[n][k]\n        bell[n + 1] %= MOD\n#print(bell)\n\nbags = [0 for i in range(m)]\nfor it in range(N):\n    for i, z in enumerate(input()):\n        if z == '1':\n            bags[i] |= (1 << it)\ndifs = set(bags)\nsol = 1\nfor mask in difs:\n    sol = sol * bell[bags.count(mask)] % MOD\nprint(sol)\n
inp=lambda :map(int,input().split())\ndef sol():\n    x,y,on,tw=inp()\n    res=0\n    for n in range(x):\n        s=input()\n        sm=0\n        for n in s:\n            if n=='.':\n                sm+=1\n            else:\n                a=sm*on\n                b=(sm//2)*tw+(sm%2)*on\n                res+=min(a,b)\n                sm=0\n        a=sm*on\n        b=(sm//2)*tw+(sm%2)*on\n        res+=min(a,b)\n    print(res)\n\nfor n in range(int(input())):\n    sol()
n, h, a, b, k = map(int, input().split())\nfor i in range(k):\n    t1, f1, t2, f2 = map(int, input().split())\n    if t1 == t2:\n        print(abs(f1 - f2))\n    elif f1 >= a and f1 <= b:\n        print(abs(t2 - t1) + abs(f2 - f1))\n    elif f1 < a:\n        print(abs(a - f1) + abs(t2 - t1) + abs(f2 - a))\n    elif f1 > b:\n        print(abs(b - f1) + abs(t2 - t1) + abs(f2 - b))
for _ in range(int(input())):\n    n = int(input())\n    print(*list(range(1, n+1)))\n
3\n\ndef solve(N, A):\n    cnt = [0] * (N + 1)\n\n    evd = {}\n    xs = []\n    for a, b in A:\n        if a not in evd:\n            evd[a] = [0, 0]\n            xs.append(a)\n        if b not in evd:\n            evd[b] = [0, 0]\n            xs.append(b)\n\n        evd[a][0] += 1\n        evd[b][1] += 1\n\n    xs.sort()\n\n    px = xs[0] - 1\n    pop = 0\n    for x in xs:\n        cnt[pop] += x - px - 1\n        cnt[pop + evd[x][0]] += 1\n        pop -= evd[x][1]\n        pop += evd[x][0]\n        px = x\n\n    return cnt[1:]\n\n\ndef main():\n    N = int(input())\n    A = [tuple([int(e) for e in input().split(' ')]) for _ in range(N)]\n    print(*solve(N, A))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n=int(input())\na = [0]*(n+1)\nfor i in range(n-1):\n    for i in input().split():\n        a[int(i)]+=1\nl = a.count(1)\nprint ((l*2**(n-l+1)+(n-l)*(2**(n-l)))%(10**9+7))
T=int(input())\n\nfor t in range(T):\n    s=input()\n    ans=0\n    L=[]\n    for i in [1,2,3,4,6,12]:\n        x=i\n        y=12//x\n        E=[]\n        for j in range(12):\n            if(j%y==0):\n                E.append("")\n            E[-1]+=s[j]\n        for j in range(y):\n            c=0\n            for z in range(i):\n                if(E[z][j]=='X'):\n                    c+=1\n            if(c==i):\n                ans+=1\n                L.append(i)\n                break\n    print(ans,end=" ")\n    for item in L:\n        print(item,end="x")\n        print(12//item,end=" ")\n    print()\n
def solve():\n    n, r = list(map(int, input().split()))\n    k = min(r, n - 1)\n    print(k * (k + 1) // 2 + (r >= n))\n\n\nfor i in range(int(input())):\n    solve()\n
for _ in range(int(input())):\n    n, a, b, c, d = tuple(map(int, input().split()))\n\n    if (a - b) * n > c + d or (a + b) * n < c - d:\n        print('No')\n    else:\n        print('Yes')\n
m = 1000000007\n(t, k) = [int(i) for i in input().split(' ')]\nn = 100000\ndp=[0]*(n+1)\n\ndp[0] = 1\nfor i in range(1, n+1):\n    dp[i] = (dp[i-1] + (0 if i-k < 0 else dp[i-k])) % m\n    \ns = [0]*(n+1)\ns[1] = dp[1]\ns[0] = 0\nfor i in range(2, n+1):\n    s[i] = (s[i-1] + dp[i]) % m\n \nfor _ in range(t):\n    (a, b) = [int(i) for i in input().split(' ')]\n    print((s[b] - s[a-1] + m) % m)\n    \n    \n
# https://codeforces.com/contest/863/problem/D\n\n\nfrom sys import stdin, stdout\ninput = stdin.readline\nprint = stdout.write\n# solve the reversed problem\nn, q, m = map(int, input().split())\na = list(map(int, input().split()))\nops = [list(map(int, input().split())) for _ in range(q)]\nb = list(map(int, input().split()))\n\n\ndef solve(index, ops):\n    def _solve(index, op):\n        t, l, r = op\n        if index < l or index > r:\n            return index\n        if t == 1:\n            if index == l:\n                return r\n            else:\n                return index - 1\n        else:\n            return l + r - index\n\n    for op in ops[::-1]:\n        index = _solve(index, op)\n    return index\n\n\nb = list(map(lambda x: solve(x, ops), b))\nfor i in b:\n    print(str(a[i-1])+" ")\n\n# Cartesian tree:\n# https://codeforces.com/contest/863/submission/30693678\n
import sys\nimport string\nfrom math import gcd\nimport getpass\nimport math\nfrom decimal import Decimal\nimport pprint\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n    # sys.stdin = open('input.txt')\n    # sys.stdout = open('output.txt', 'w')\nelse:\n    sys.stdin = open('input.txt')\n    # sys.stdin.close()\n# sys.stdout = open('output.txt', 'w')\n\n\nn, m = ria()\nar = ria()\narc = []\nart = []\nres = []\nfor n, i in enumerate(ria()):\n    if i == 1:\n        art.append(ar[n])\n        res.append(0)\n    else:\n        arc.append(ar[n])\nnt = 0\nfor i in arc:\n    while nt != len(art) - 1 and abs(art[nt] - i) > abs(art[nt + 1] - i):\n        nt += 1\n    res[nt] += 1\n\nfor i in res:\n    print(i,end= ' ')
from sys import stdin\nfrom fractions import gcd\n\nn = int(stdin.readline().strip())\nv = list(map(int, stdin.readline().strip().split()))\n\nadj = [[] for _ in range(n)]\nfor _ in range(n-1):\n    x, y = list(map(int, stdin.readline().strip().split()))\n    adj[x-1].append(y-1)\n    adj[y-1].append(x-1)\n\nroot_divisors = []\ncnt = [0]*200001\nd = 1\nwhile d*d <= v[0]:\n    if v[0] % d == 0:\n        root_divisors.append(d)\n        cnt[d] += 1\n        if v[0]//d != d:\n            root_divisors.append(v[0]//d)\n            cnt[v[0]//d] += 1\n    d += 1    \ns = [0]\nvisited = [False]*n\nvisited[0] = True\nlevel = [1]*n\nres1 = [0]*n\nres2 = [0]*n\nres1[0] = v[0]\nd = 1\nwhile s:\n    x = s[-1]\n    any_more = False\n    while adj[x]:\n        y = adj[x].pop()\n        if not visited[y]:\n            visited[y] = True\n            any_more = True\n            s.append(y)\n            level[y] = level[x]+1\n            res2[y] = gcd(res2[x], v[y])\n            for d in root_divisors:\n                if v[y] % d == 0:\n                    cnt[d] += 1\n                if cnt[d] == level[y] or cnt[d] == level[y]-1:\n                    res1[y] = max(res1[y], res2[y], d)\n            break\n    if not any_more:\n        s.pop()\n        for d in root_divisors:\n            if v[x] % d == 0:\n                cnt[d] -= 1\n        \nprint(' '.join(list(map(str, res1))))
# for _ in range(1):\nfor _ in range(int(input())):\n    # a, b = map(int, input().split())\n    n = int(input())\n    # arr = list(map(int, input().split()))\n    # s = input()\n    x = 6 + 10 + 14\n    if x + 1 > n:\n        print('NO')\n        continue\n    y = n - x\n    if y not in (6, 10, 14):\n        print('YES')\n        print(6, 10, 14, y)\n        continue\n    x += 1\n    y -= 1\n    if y == 0:\n        print('NO')\n    else:\n        print('YES')\n        print(6, 10, 15, y)\n
def mi():\n    return map(int, input().split())\n \n'''\n5\n1 2 3 4 5\n'''\nfor _ in range(1):\n    n = int(input())\n    a = list(mi())\n    a.sort()\n    k = 0\n    out = [0]*n\n    for i in range(1,n,2):\n        out[i] = a[k]\n        k+=1\n    for i in range(0,n,2):\n        out[i] = a[k]\n        k+=1\n    ans = 0\n    a = out\n    for i in range(1,n-1):\n        if a[i]<a[i-1] and a[i]<a[i+1]:\n            ans+=1\n    print (ans)\n    print (*out)
class UnionFind:\n    def __init__(self, N):\n        self.par = [i for i in range(N)]\n        self.rank = [1 for i in range(N)]\n        self.rank[0] = 0\n    def union(self, x, y):\n        if not self.is_same_set(x, y):\n            par_x = self.find_par(x)\n            par_y = self.find_par(y)\n\n            if self.rank[par_x] > self.rank[par_y]:\n                self.rank[par_x] += self.rank[par_y]\n                self.rank[par_y] = 0\n                self.par[par_y] = par_x\n            else:\n                self.rank[par_y] += self.rank[par_x]\n                self.rank[par_x] = 0\n                self.par[par_x] = par_y\n\n    def find_par(self, x):\n        if self.par[x] == x: return x\n        self.par[x] = self.find_par(self.par[x])\n        return self.par[x]\n\n    def is_same_set(self, x, y):\n        return self.find_par(x) == self.find_par(y)\n\n    def size(self, x):\n        return self.rank[self.find_par(x)]\n# 2 unionfind, para 0 e para 1 formando 2 florestas\n# lista de adj\n# verificar todos os componentes existentes e adicionar na resposta n * (n-1)\n\nn = int(input())\n\nadj = [[] for i in range(n+1)]\n\nuf0 = UnionFind(n+1)\nuf1 = UnionFind(n+1)\n\nfor i in range(n-1):\n    x, y, c = list(map(int, input().split()))\n\n    if c == 0:\n        uf0.union(x, y)\n    else:\n        uf1.union(x, y)\n    adj[x].append(y)\n    adj[y].append(x)\nfor i in range(n+1):\n    uf0.find_par(i)\n    uf1.find_par(i)\n\nresp = 0\n\nfor i in set(uf0.par):\n    resp += uf0.rank[i] * (uf0.rank[i] - 1)\nfor i in set(uf1.par):\n    resp += uf1.rank[i] * (uf1.rank[i] - 1)\n\n# pra cada componente do 0-uf verificar se existe esse vertice na 1-uf e ele for conectado com alguém, se sim, multiplicar (n-1)*(m-1) sendo n o componente da 0-uf e m o componente da 1-f e adicionar na resposta\n\nfor i in range(len(uf0.par)):\n    if uf0.rank[uf0.find_par(i)] > 1:\n        if uf1.rank[uf1.find_par(i)] > 1:\n            resp += (uf0.rank[uf0.find_par(i)] - 1) * (uf1.rank[uf1.find_par(i)] - 1)\nprint(resp)\n
def gcd(a,b):\n  return a if b==0 else gcd(b, a%b)\n\nfor T in range(int(input())):\n  de=int(input())\n  g=gcd(de, 180)\n  if int(de/g)==int(180/g)-1:\n    print(int(180/g)*2)\n  else:\n    print(int(180/g))\n
class Solution:\n     def permute(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: List[List[int]]\n         """\n         all_permutes = []\n         self.permute_nums(all_permutes, nums, [])\n         return all_permutes\n     \n     def permute_nums(self, all_permutes, nums, cur_permute):\n         if len(nums) == 0:\n             all_permutes.append(cur_permute)\n             return\n \n         for i in range(len(nums)):\n             num = nums[i]\n \n             self.permute_nums(all_permutes, nums[0:i] + nums[i+1:len(nums)], cur_permute + [num])
class Solution:\n     def combinationSum3(self, k, n):\n         """\n         :type k: int\n         :type n: int\n         :rtype: List[List[int]]\n         """\n         to_return = []\n         self.backtrack(to_return, [], k, n, 1)\n         return to_return\n     \n     def backtrack(self, to_return, temp, k, n, start):\n         total = sum(temp)\n         \n         if total > n:\n             return\n         if len(temp) == k and total == n:\n             to_return.append(temp[:])\n             return\n         \n         for i in range(start, 10):\n             temp.append(i)\n             self.backtrack(to_return, temp, k, n, i + 1)\n             temp.pop()
class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        memo ={}\n        n =len(s)\n        def dp(i):\n            if i<=0:\n                return 0\n            if i in memo:\n                return memo[i]\n            if (s[i-1],s[i])==('(',')'):\n                memo[i]=dp(i-2)+2\n            elif (s[i-1],s[i])==(')',')') and i-dp(i-1)-1>=0 and s[i-dp(i-1)-1]=='(':\n                memo[i]=dp(i-1)+2+dp(i-dp(i-1)-2)\n            else:\n                memo[i]=0\n            return memo[i]\n        ret = 0\n        for i in range(n-1,0,-1):\n            ret = max(ret, dp(i))\n        return ret\n            \n            \n            \n            \n        \n        \n        \n            \n            \n                \n        \n
class Solution:\n     def majorityElement(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: int\n         """\n         \n         if nums == []:\n             return []\n         \n         dct = {}\n         for el in nums:\n             if el in dct:\n                 dct[el] += 1\n             else:\n                 dct[el] = 1\n             \n         fin = []\n         for key in dct:\n             if dct[key] > (len(nums) // 3):\n                 fin.append(key)\n         \n         return fin\n         \n
import bisect\nfrom functools import lru_cache\n\n\nclass Solution:\n    def makeArrayIncreasing(self, A: List[int], B: List[int]) -> int:\n        B = sorted(set(B))\n\n        @lru_cache(None)\n        def find_larger_value_in_B(val):\n            if val >= B[-1]:\n                return float('inf')\n            return B[bisect.bisect_right(B, val)]\n\n        @lru_cache(None)\n        def min_last_value_given_operations(n, ops):\n            if ops < 0:\n                return float('inf')\n            elif n == 0:\n                return float('-inf')\n            elif ops > n:\n                return min_last_value_given_operations(n, n)\n\n            prev_with_op = min_last_value_given_operations(n - 1, ops - 1)\n            b = find_larger_value_in_B(prev_with_op)\n            # dp(n - 1, ops) <= dp(n - 1, ops - 1)\n            # if dp(n - 1, ops - 1) < A[n - 1] => dp(n - 1, ops) < A[n - 1]\n            if prev_with_op < A[n - 1]:\n                return min(A[n - 1], b)\n            elif b <= A[n - 1]:\n                return b\n            elif min_last_value_given_operations(n - 1, ops) < A[n - 1]:\n                return A[n - 1]\n            return b\n\n        last_success = -1\n        for ops in range(min(len(A), len(B)), -1, -1):\n            if min_last_value_given_operations(len(A), ops) == float('inf'):\n                break\n            last_success = ops\n\n        return last_success\n
h, w, n = map(int,input().split())\n\nxy_pos = dict()\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    for k in range(-2,1):\n        for l in range(-2,1):\n            x = (a-1) + k\n            y = (b-1) + l\n            if (0 <= x <=(h-1)-2) and (0 <= y <=(w-1)-2):\n                xy = str(x) + "x" + str(y)\n                if xy in xy_pos:\n                    xy_pos[xy] += 1\n                else:\n                    xy_pos[xy] = 1\n\nans = [0]*10                    \nfor v in xy_pos.values():\n    ans[v] += 1\nans[0] = (h-2)*(w-2) - sum(ans)\nfor i in range(10):\n    print(ans[i])
# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n# from decorator import stop_watch\n# \n# \n# @stop_watch\ndef solve(N, ABs):\n    ABs.sort(key=lambda x: x[1])\n    time = 0\n    ans = 'Yes'\n    for A, B in ABs:\n        time += A\n        if time > B:\n            ans = 'No'\n            break\n    print(ans)\n\n\ndef __starting_point():\n    # S = input()\n    N = int(input())\n    # N, M = map(int, input().split())\n    ABs = [[int(i) for i in input().split()] for _ in range(N)]\n    # Bs = [int(i) for i in input().split()]\n    solve(N, ABs)\n\n__starting_point()
n,k=map(int,input().split())\npoints=[]\nfor _ in range(n):\n    x,y=map(int,input().split())\n    points.append((x,y))\npoints.sort()\nans=float('inf')\nfor i in range(n-k+1):\n    for j in range(i+k-1,n):\n        y_sorted=sorted(points[i:j+1],key=lambda x:x[1])\n        height_min=float('inf')\n        for l in range(j-i-k+2):\n            height_min=min(height_min,y_sorted[l+k-1][1]-y_sorted[l][1])\n            ans=min(ans,(points[j][0]-points[i][0])*height_min)\nprint(ans)
mod = 10**9 + 7\n\ndef power(p, e):\n  ret = 1\n  while(e):\n    if(e & 1):\n      ret *= p\n      ret %= mod\n    p *= p\n    e >>= 1\n  return ret\n\nN = int(input())\nC = list(map(int, input().split()))\nC.sort()\n\nf = 0\nfor i in range(N):\n  f += (N - i + 1) * C[i]\n  f %= mod\n\nf *= power(2, N - 1)**2 % mod\nf %= mod\nprint(f)
import os\nimport sys\n\nif os.getenv("LOCAL"):\n    sys.stdin = open("_in.txt", "r")\n\nsys.setrecursionlimit(2147483647)\nINF = float("inf")\n\nN = int(sys.stdin.readline())\nS = list(map(int, sys.stdin.readline().split()))\n\n\ndef count_max(diff):\n    # 左右対称に diff 間隔でとるときの最大\n    b = 0\n    a = N - 1\n    ret = 0\n    cumsum = 0\n    while diff < a and a != b and b - a != diff:\n        cumsum += S[b] + S[a]\n        ret = max(ret, cumsum)\n        b += diff\n        a -= diff\n    return ret\n\n\nans = 0\nfor diff in range(1, N // 2 + 1):\n    ans = max(ans, count_max(diff))\nprint(ans)\n
N = int(input())\nA = list(map(int,input().split()))\nfrom collections import Counter\nfrom bisect import bisect\nvs = list(Counter(A).values())\nvs.sort()\ncums = [0]\nfor v in vs:\n    cums.append(cums[-1] + v)\n\ndef is_ok(k,m):\n    j = bisect(vs,m)\n    z = cums[j] + m*(len(vs)-j)\n    return z >= m*k\n\nans = []\nfor k in range(1,N+1):\n    if k > len(vs):\n        ans.append(0)\n    else:\n        ok = 0\n        ng = N//k + 1\n        while ng-ok > 1:\n            m = (ok+ng)//2\n            if is_ok(k,m):\n                ok = m\n            else:\n                ng = m\n        ans.append(ok)\n\nprint(*ans, sep='\n')
N, K = map(int, input().split())\nA = list(map(int, input().split()))\n\nans = []\nc = 2**30\nr = 2**30\nwhile r:\n    r //= 2\n    l = sum(-(-a//c)-1 for a in A)\n    if l > K:\n        c += r\n    else:\n        ans.append(c)\n        c -= r\n\nprint(ans and min(ans) or 1)
n=int(input())\nS=input()\nx=y=0\nfor i,s in enumerate(S):\n  y=y-1 if s=='(' else y+1\n  x=max(x,y)\nprint('('*x+S+')'*(x-y))
import sys\n\ndef solve():\n      input = sys.stdin.readline\n      N, Q = map(int, input().split())\n      total = (N - 2) ** 2\n      rb = N\n      db = N\n      D = [N] * (N + 1)\n      R = [N] * (N + 1)\n      for _ in range(Q):\n            a, b = map(int, input().split())\n            if a == 1: #横向き\n                  if b < db:\n                        total -= (rb - 2)\n                        for i in range(b, db): R[i] = rb\n                        db = b\n                  else:\n                        total -= (R[b] - 2)\n            else: #縦向き\n                  if b < rb:\n                        total -= (db - 2)\n                        for i in range(b, rb): D[i] = db\n                        rb = b\n                  else:\n                        total -= (D[b] - 2)\n\n      print(total)\n\n      return 0\n\ndef __starting_point():\n      solve() \n__starting_point()
import bisect\nN,K=list(map(int,input().split()))\nA=list(map(int,input().split()))\nS=[0 for i in range(N+1)]\nfor i in range(N):\n    S[i+1]=S[i]+A[i]\n    S[i+1]%=K\nX=[(S[i]-i)%K for i in range(N+1)]\nD=dict()\nfor i in range(N+1):\n    if X[i] in D:\n        D[X[i]].append(i)\n    else:\n        D[X[i]]=[i]\nans=0\nfor k in D:\n    for i in D[k]:\n        L=bisect.bisect_left(D[k],i-K+1)\n        R=bisect.bisect_right(D[k],i+K-1)\n        ans+=R-L-1\nprint((ans//2))\n
from itertools import chain\nimport numpy as np\nimport networkx as nx\n\nh, w, *X = map(int, open(0).read().split())\nC = np.array(X[:100], dtype=int).reshape((10, 10))\nA = np.array(X[100:], dtype=int).reshape((h, w))\n\nG = nx.DiGraph(C)\nd = {-1:0}\nfor i in range(10):\n    d[i] = nx.shortest_path_length(G, i, 1, weight='weight')\nprint(sum(d[a] for a in chain.from_iterable(A)))
from collections import Counter\n\nclass Unionfind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * (n+1)\n        \n    def find(self, x):\n        if(self.parents[x] < 0):\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n        \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if(x == y):\n            return\n        \n        if(self.parents[x] > self.parents[y]):\n            x, y = y, x\n            \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    \n    def size(self, x):\n        return -self.parents[self.find(x)]\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    \n    def group_count(self):\n        return len(self.roots())\n    \n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    \n    def __str__(self):\n        return '\n'.join('{}:{}'.format(r, self.members(r)) for r in self.roots())\n\nN, K, L = map(int, input().split())\n\nuf = Unionfind(N)\nuf1 = Unionfind(N)\n\nfor _ in range(K):\n    p, q = map(int, input().split())\n    uf.union(p-1, q-1)\n    \nfor _ in range(L):\n    r, s = map(int, input().split())\n    uf1.union(r-1, s-1)\n    \npairs = [(uf.find(i), uf1.find(i)) for i in range(N)]\n#print(pairs)\n    \nc = Counter(pairs)\n#print(c)\nans = [c[pairs[i]] for i in range(N)]\n\nprint(*ans)
n, C = map(int, input().split())\ntime = 0\nstc = []\nfor i in range(n):\n    temp = list(map(int, input().split()))\n    time = max(time, temp[1])\n    stc.append(temp)\ntv = [[0 for i in range(C)] for i in range(time + 1)]\nfor i in stc:\n    s, t, c = i[0], i[1], i[2]\n    for j in range(s, t + 1):\n        tv[j][c - 1] = 1\nans = 0\nfor i in tv:\n    ans = max(ans, sum(i))\nprint(ans)
def main():\n    ans = 0\n    n = int(input())\n    A = [int(i) for i in input().split()]+[10**9]\n\n    Sum = 0\n    right = 0\n    for left in range(n):\n        while(right<n):\n            if Sum^A[right]  == Sum+A[right]:\n                Sum += A[right]\n                right += 1\n            else:\n                break\n        ans += right-left\n        if left==right:\n            right +=1\n        else:\n            Sum -= A[left]\n    print(ans)\nmain()
import numpy as np\nh, w, m = map(int, input().split())\nxy = [tuple(map(lambda x: int(x) - 1, input().split())) for _ in range(m)]\nrow = np.zeros(h, np.int)\ncol = np.zeros(w, np.int)\nfor y, x in xy:\n	row[y] += 1\n	col[x] += 1\n\nmax_cnt_y = max(row)\nmax_cnt_x = max(col)\nmax_pair = np.sum(row == max_cnt_y) * np.sum(col == max_cnt_x)\nfor y, x in xy:\n	if row[y] == max_cnt_y and col[x] == max_cnt_x:\n		max_pair -= 1\n\nprint(max_cnt_y + max_cnt_x - (max_pair == 0))
n, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort(reverse=True)\n\ntemp = 0\nans = 0\n\nfor x in a:\n    if temp + x < k:\n        temp += x\n        ans += 1\n    else:\n        ans = 0\n\nprint(ans)
n=int(input())\nki=[[] for _ in range(n)]\nans=0\nfor i in range(1,n+1):\n    ans+=i*(n-i+1)\n\nfor _ in range(n-1):\n    u,v=map(int,input().split())\n    if u>v:u,v=v,u\n    ans-=u*(n-v+1)\nprint(ans)
from collections import deque\nfrom math import ceil\n \nn,d,a = map(int,input().split())\nM = [list(map(int,input().split())) for i in range(n)]\nM = sorted([(x,ceil(h/a)) for x,h in M])\n \nque = deque()\n \nans = 0\natack = 0\nfor x,h in M:\n  while len(que) > 0 and que[0][0] < x:\n    tx,ta = que.popleft()\n    atack -= ta      \n  \n  bomb_num = max(0, h-atack)\n  atack += bomb_num\n  ans += bomb_num\n  \n  if bomb_num > 0:\n    que.append([x+d*2,bomb_num])\n \nprint(ans)  
n = int(input())\na = list(map(int, input().split()))\nMAX = 10 ** 6 + 5\ncnt = [0] * MAX\nok = [True] * MAX\nfor x in a:\n    cnt[x] += 1\nans = 0\nfor i in range(1, MAX):\n    if cnt[i] > 0:\n        for j in range(i * 2, MAX, i):\n            ok[j] = False       \n        if ok[i] and cnt[i] == 1:\n            ans += 1\nprint(ans)
s=input()\ndp0=[0]*(len(s)+1)\ndp1=[0]*(len(s)+1)\ndp1[0]=1\nfor i in range(1,len(s)+1):\n  n=int(s[i-1:i])\n  dp0[i]=min(dp0[i-1]+n,dp1[i-1]+10-n)\n  dp1[i]=min(dp0[i-1]+(1 if n+1==10 else n+1),dp1[i-1]+10-n-1)\nprint(dp0[-1])
n, m = map( int, input().split() )\nedge_list = []\nfor _ in range( m ):\n    a_i, b_i, c_i = map( int, input().split() )\n    edge_list.append( ( a_i - 1, b_i - 1, - c_i ) )\n\nINF = float("inf")\ncost = [ INF ] * n\ncost[ 0 ] = 0\n\nNegativeLoopExist = False\nfor i in range( n ):\n    for j in range( m ):\n        a, b, c = edge_list[ j ]\n        if cost[ a ] != INF and cost[ b ] > cost[ a ] + c:\n            cost[ b ] = cost[ a ] + c\n            if i == n - 1 and b == n - 1:\n                NegativeLoopExist = True\n\nif NegativeLoopExist:\n    print( "inf" )\nelse:\n    print( - cost[ n - 1 ] )
import numpy as np\nn,k = map(int,input().split())\na = np.array(list(map(int,input().split())))\na.sort()\nposi = a[a>0]\nzero = a[a==0]\nnega = a[a<0]\n\ndef cnt(x):\n    c = 0\n    if x >= 0:\n        c += len(zero)*n\n    c += np.searchsorted(a, x // posi, side = 'right').sum()\n    c += (n-np.searchsorted(a, (- x - 1) // (-nega), side = 'right')).sum()\n    c -= np.count_nonzero(a * a <= x)\n    return c // 2\n\nl = - 10 ** 18\nr = 10 ** 18\nwhile l + 1 < r:\n    m = (l + r) // 2\n    if cnt(m) < k:\n        l = m\n    else:\n        r = m\nprint(r)
n = int(input())\na = list(map(int, input().split()))\n\nb = sorted(a[::])\nfor i in range(n):\n    if b[i] == b[i+1]:\n        d = b[i]\n\nl, r = -1, -1\nfor i in range(n+1):\n    if l < 0:\n        if a[i] == d:\n            l = i\n    else:\n        if a[i] == d:\n            r = i\n\nf = [1 for _ in range(n+2)]\nf_inv = [1 for _ in range(n+2)]\nmod = 10 ** 9 + 7\nfor i in range(1, n+2):\n    f[i] = f[i-1] * i % mod\n    f_inv[i] = pow(f[i], mod-2, mod)\n\ndef comb(n, k):\n    return f[n] * f_inv[k] * f_inv[n-k] % mod\n\n\nfor k in range(1, n+2):\n    ans = 0\n\n    if k >= 2:\n        ans += comb(n-1, k-2)\n        ans %= mod\n\n    if n - 1 >= k:\n        ans += comb(n-1, k)\n        ans %= mod\n\n    if n >= k:\n        ans += 2 * comb(n-1, k-1)\n        ans %= mod\n\n    if n + l - r >= k - 1:\n        ans -= comb(n+l-r, k-1)\n        ans %= mod\n\n    print(ans)\n
from collections import deque\nK=int(input())\n\n\nINF=10**9\nres=[INF]*(K)\nres[1]=1\nq=deque()\nq.append(1)\nwhile q:\n    r=q.popleft()\n    if r==0:\n        break\n    nr=(r+1)%K\n    if res[r]<res[nr]:\n        res[nr]=res[r]+1\n        q.append(nr)\n    nr=(10*r)%K\n    if res[r]<res[nr]:\n        res[nr]=res[r]\n        q.appendleft(nr)\nprint(res[0])
N = int(input())\nA = [int(_) for _ in input().split()]\n\ndef calc(A, y):\n    result = abs(A[0] - y)\n    t = y\n    if t == 0:\n        return 10**30\n    for a in A[1:N]:\n        tt = t + a\n        if t * tt >= 0:\n            m =  -t // abs(t)\n            result += abs(m - tt)\n            tt = m\n        t = tt\n    return result\n\nresult = min(calc(A, A[0]), calc(A, -1),  calc(A, +1))\n\nprint(result)\n
from math import gcd\n\nN = int(input())\nnum_lis = list(map(int, input().split()))\nc = True\n\ndef osa_k(max_num):\n  lis = [i for i in range(max_num+1)]\n  p = 2\n  while p**2 <= max_num:\n    if lis[p] == p:\n      for q in range(2*p, max_num+1, p):\n        if lis[q] == q:\n          lis[q] = p\n    p += 1\n  return lis\n\nhoge = 0\nfor i in num_lis:\n  hoge = gcd(hoge, i)\nif hoge > 1:\n  print("not coprime")\n  return\n\nd_lis = osa_k(10**6+10)\ntmp = set()\nfor i in num_lis:\n  num = i\n  new_tmp = set()\n  while num > 1:\n    d = d_lis[num]\n    new_tmp.add(d)\n    num //= d\n  for j in new_tmp:\n    if j in tmp:\n      c = False\n      break\n    else:\n      tmp.add(j)\n  else:\n    continue\n  break\n\nif c:\n  print("pairwise coprime")\nelse:\n  print("setwise coprime")
\nfrom itertools import combinations\n\nINF = float("inf")\ndata = {d: [-INF, INF, -INF, INF] for d in 'RLUD'}\n\n_, *XYD = open(0).read().split()\nX = map(int, XYD[::3])\nY = map(int, XYD[1::3])\nD = map(data.get, XYD[2::3])\n\nfor x, y, d in zip(X, Y, D):\n    d[0] = max(d[0], x)\n    d[1] = min(d[1], x)\n    d[2] = max(d[2], y)\n    d[3] = min(d[3], y)\n\n\nX = [\n    (data["L"][0], -1), (data["L"][1], -1),\n    (data["R"][0], 1), (data["R"][1], 1),\n    (data["U"][0], 0), (data["U"][1], 0),\n    (data["D"][0], 0), (data["D"][1], 0),\n]\nY = [\n    (data["L"][2], 0), (data["L"][3], 0),\n    (data["R"][2], 0), (data["R"][3], 0),\n    (data["U"][2], 1), (data["U"][3], 1),\n    (data["D"][2], -1), (data["D"][3], -1),\n]\n\nX = [(x, dx) for x, dx in X if abs(x) < INF]\nY = [(y, dy) for y, dy in Y if abs(y) < INF]\n\nT = set(\n    [0] +\n    [max(0, (x - y) / (dy - dx)) for (x, dx), (y, dy) in combinations(X, 2) if dx != dy] +\n    [max(0, (x - y) / (dy - dx)) for (x, dx), (y, dy) in combinations(Y, 2) if dx != dy]\n)\n\n\ndef area(t):\n    XX = [t * dx + x for x, dx in X]\n    YY = [t * dy + y for y, dy in Y]\n\n    dx = max(XX) - min(XX)\n    dy = max(YY) - min(YY)\n\n    return dx * dy\n\n\nprint(min(map(area, T)))
n, m = map( int, input().split() )\na = list( map( int, input().split() ) )\n\ndef f( a_k ): # 2で割り切れる回数\n    count = 0\n    while a_k % 2 == 0:\n        count += 1\n        a_k = a_k // 2\n    return count\n\nb = []\nf_0 = f( a[ 0 ] )\nfor a_k in a:\n    f_k = f( a_k )\n    if f_k != f_0:\n        print( 0 )\n        return\n    b.append( a_k // pow( 2, f_k ) )\n\nimport math\ndef lcm( x, y ):\n    return x * y // math.gcd( x, y )\n\nb_lcm = 1\nfor b_k in b:\n    b_lcm = lcm( b_lcm, b_k )\n\na_lcm = b_lcm * pow( 2, f_0 )\n# print( b_lcm, f_0, b )\nprint( ( m + a_lcm // 2 ) // a_lcm )
import sys\ninput = sys.stdin.readline\n \nN=int(input())\nA=list(map(int,input().split()))\n \nXOR=0\nfor a in A:\n    XOR^=a\n \nfor i in range(N):\n    A[i] &=~XOR\n    \nUSED=[0]*N\n \nfor bi in range(60,-1,-1):\n    for i in range(N):\n        if USED[i]==0 and A[i] & (1<<bi)!=0:\n            USED[i]=1\n            useind=i\n            break\n    else:\n        continue\n \n    for i in range(N):\n        if i==useind:\n            continue\n        if A[i] & (1<<bi)!=0:\n            A[i]^=A[useind]\n            \nANS=0\nfor a in A:\n    ANS^=a\n \nprint(2*ANS+XOR)
import sys\n\nin1 = sys.stdin.readlines()\nN = int(in1[0])\n#N = 10 ** 18\n#N = 2\n"""\n0 + 0 = 0\n0 x 0 = 0\n\n1 + 0 = 1\n1 x 0 = 1\n\n2 + 0 = 2\n2 x 0 = 2\n1 + 1 = 2\n1 x 1 = 0\n\n3 + 0 = 3\n3 x 0 = 3\n2 + 1 = 3\n2 x 1 = 3\n"""\np = 10 ** 9 + 7\n\ndef f(n):\n    if n in d:\n        return d[n]\n    d[n] = f(n // 2) + f((n - 1) // 2) + f((n - 2) // 2)\n    return d[n]\n\nd = {0: 1, 1: 2}\nprint((f(N) % p))\n
from collections import defaultdict\n\ndef main():\n    d = defaultdict(int)\n    d2 = defaultdict(int)\n\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    for i in range(N):\n        d[i + 1 + A[i]] += 1\n        d2[max(0, (i + 1) - A[i])] += 1\n\n    ans = 0\n\n    for k,v in d.items():\n        if k == 0:continue\n        ans += v * d2[k]\n\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()
import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\nimport numpy as np\n\n# 適当な素数と原始根でrolling hash\nMOD = 10 ** 9 + 993\nbase = 123450\n\nS = np.array([ord(x) for x in input().rstrip()],dtype=np.int64)\nT = np.array([ord(x) for x in input().rstrip()],dtype=np.int64)\n\n# Sの方が長くする\nLS = len(S)\nLT = len(T)\nn = (LT + (-LT) % LS) // LS\nS = np.concatenate([S]*(n+1))\nS = S[:LS+LT]\n\ndef cumprod(arr):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2); arr = arr.reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\nbase_inv = pow(base,MOD-2,MOD)\nx = np.full(LS+LT,base,dtype=np.int64)\nx[0] = 1\npower = cumprod(x)\nx = np.full(LS+LT,base_inv,dtype=np.int64)\nx[0] = 1\npower_inv = cumprod(x)\n\ndef to_rolling_hash(S):\n    return (S * power[:len(S)] % MOD).cumsum() % MOD\n\nS_hash = to_rolling_hash(S)\nT_hash = to_rolling_hash(T)[-1] # 文字列全体\n\nS_hash_LT = S_hash[LT-1:]\nS_hash_LT[1:] -= S_hash.copy()[:LS]\nS_hash_LT %= MOD\nS_hash_LT *= power_inv[:LS+1]\nS_hash_LT %= MOD\n\nINF = 10 ** 18\nvisited = [False] * LS\ndist = [INF] * LS # 操作終了位置からの距離\n\nq = np.where(S_hash_LT[:LS] != T_hash)[0].tolist()\n\nd = 0\nwhile q:\n    qq = []\n    for x in q:\n        if dist[x] == INF:\n            dist[x] = d\n            qq.append((x-LT)%LS)\n    d += 1\n    q = qq\n\nanswer = max(dist)\nif answer >= INF:\n    answer = -1\n\nprint(answer)
#!/usr/bin/env python3\n# coding=utf-8\n\nimport sys\n\nimport numpy as np\n\nn, k = list(map(int, sys.stdin.readline().strip().split(" ")))\nxyc = [l.strip().split(" ") for l in sys.stdin.readlines()]\nxy = [(int(_x) % (2 * k), int(_y) % (2 * k) if _c == "W" else (int(_y) + k) % (2 * k))\n      for (_x, _y, _c) in xyc]\n\n# ans = np.zeros((2 * k, 2 * k), dtype=np.int32)\nans = [[0 for j in range(2 * k + 1)] for i in range(2 * k + 1)]\nfor _x, _y in xy:\n    if (_x - k + 0.5) * (_y - k + 0.5) > 0:\n        _x %= k\n        _y %= k\n        ans[_x][_y] += 2\n        ans[_x + k][_y] -= 2\n        ans[_x][_y + k] -= 2\n        ans[_x + k][_y + k] += 2\n        ans[_x + k][0] += 1\n        ans[0][_y + k] += 1\n        ans[0][0] += 1\n        ans[_x][0] -= 1\n        ans[0][_y] -= 1\n    else:\n        _x %= k\n        _y %= k\n        ans[_x][_y] -= 2\n        ans[_x + k][_y] += 2\n        ans[_x][_y + k] += 2\n        ans[_x + k][_y + k] -= 2\n        ans[_x + k][0] -= 1\n        ans[0][_y + k] -= 1\n        ans[_x][0] += 1\n        ans[0][_y] += 1\nprint((np.asarray(ans).cumsum(axis=1).cumsum(axis=0).max()))\n
import numpy as np\nfrom scipy.sparse.csgraph import shortest_path\nfrom scipy.sparse import csr_matrix\ninf = float("inf")\nN, M, L = map(int, input().split())\ngraph = np.zeros((N, N))\nfor _ in range(M):\n    A, B, C = map(int, input().split())\n    graph[A-1][B-1] = C\n    graph[B-1][A-1] = C\nshortest_paths = shortest_path(csr_matrix(graph), directed=False, method="FW")\ngraph = np.full((N, N), inf)\nfor i in range(N):\n    for j in range(N):\n        if shortest_paths[i][j] <= L:\n            graph[i][j] = 1\n\nQ = int(input())\ndef int_(num_str):\n    return int(num_str) - 1\n\ncosts = shortest_path(csr_matrix(graph), directed=False, method="FW")\nfor _ in range(Q):\n    s, t = map(int_, input().split())\n    print(int(costs[s][t])-1 if costs[s][t] != inf else -1)
import sys\ndef solve():\n    readline = sys.stdin.readline\n    write = sys.stdout.write\n    MOD = 998244353\n\n    N = int(readline())\n    P = [list(map(int, readline().split())) for i in range(N)]\n\n    P.sort()\n\n    Y = [y for x, y in P]\n\n    def compress(X):\n        *XS, = set(X)\n        XS.sort()\n        return list(map({e: i for i, e in enumerate(XS)}.__getitem__, X))\n    Y = compress(Y)\n\n    data = [0]*(N+1)\n    def add(k, x):\n        while k <= N:\n            data[k] += x\n            k += k & -k\n    def get(k):\n        s = 0\n        while k:\n            s += data[k]\n            k -= k & -k\n        return s\n\n    pow2 = [1]*(N+1)\n    r = 1\n    for i in range(1, N+1):\n        pow2[i] = r = r * 2 % MOD\n\n    def gen(add, get, pow2):\n        for i, y in enumerate(Y):\n            v = get(y+1); add(y+1, 1)\n            p1 = pow2[v]; p0 = pow2[y - v]\n            q1 = pow2[i - v]; q0 = pow2[(N - y - 1) - (i - v)]\n            yield (p0 + p1 + q0 + q1 - (p0 + q1) * (p1 + q0)) % MOD\n    write("%d\n" % ((sum(gen(add, get, pow2)) + N*pow2[N] - N) % MOD))\nsolve()
import sys\nimport bisect\ninput = sys.stdin.readline\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    a.sort()\n    \n    l, r = -1, 10**6\n    while r-l > 1:\n        k = (r+l)//2\n        count = 0\n        for i in range(n):\n            count += n-bisect.bisect_left(a, k-a[i])\n        \n        if count > m:\n            l = k\n        else:\n            r = k\n    ans = 0\n    count = 0\n    b = [0]*(n+1)\n    for i in range(n):\n        b[i+1] += b[i]+a[i]\n    for i in range(n):\n        index = bisect.bisect_left(a, r-a[i])\n        ans += b[n]-b[index]+a[i]*(n-index)\n        count += n-index\n    \n    if count < m:\n        ans += (m-count)*l\n    \n    print(ans)\n    \n    \n    \n    \ndef __starting_point():\n    main()\n\n__starting_point()
import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n# 二分探索\nN, K = lr()\nA = np.array(lr())\nF = np.array(lr())\nA.sort()\nF = np.sort(F)[::-1]\n\ndef check(x):\n    count = np.maximum(0, (A - (x // F))).sum()\n    return count <= K\n\nleft = 10 ** 12 # 可能\nright = -1 # 不可能\nwhile left > right + 1:\n    mid = (left+right) // 2\n    if check(mid):\n        left = mid\n    else:\n        right = mid\n\nprint(left)\n# 51\n
from collections import deque\nimport sys\n\nN_MAX = 200000 + 5\n\nH, W, K = list(map(int, input().split()))\nsth, stw, glh, glw = list(map(int, input().split()))\n\nINF = 10**6 * K\n\ndp = [[INF for _ in range(W+2)] for _ in range(H+2)]\n\ndp[0] = [-1]*(W+2)\ndp[H+1] = [-1]*(W+2)\nfor h in range(1, H+1):\n    s = sys.stdin.readline()\n    dp[h][0] = -1\n    dp[h][W+1] = -1\n    for w in range(1, W+1):\n        if s[w-1] == "@":\n            dp[h][w] = -1\n\n\n# Seen = [[INF]*W for _ in range(H)]\nXY = {(1, 0), (-1, 0), (0, 1), (0, -1)}\n\n\ndef bfs(sth, stw, glh, glw):\n    next_q = deque()\n    next_q.append((sth, stw, 0))\n    dp[sth][stw] = 0\n\n    while len(next_q) != 0:\n        # キュー取り出し(先頭)\n        h, w, c = next_q.popleft()\n        for dh, dw in XY:\n            for sk in range(1, K+1):\n                hs, ws = h + dh*sk, w + dw*sk\n                if dp[hs][ws] == -1:\n                    break\n                if dp[hs][ws] == INF:\n                    next_q.append((hs, ws, c+1))\n                    dp[hs][ws] = c + 1\n                elif dp[hs][ws] <= c:\n                    break\n                if hs == glh and ws == glw:\n                    return c + 1\n    return -1\n\n\ndef main():\n    ret = bfs(sth, stw, glh, glw)\n    print(ret)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
N, K = map(int, input().split())\nans = 0\n\nif K == 0:\n  print(N**2)\n  return\n\nfor r in range(K, N):\n  for q in range((N-r)//(r+1) + 1):\n    if q == 0:\n      ans += N - r\n    else:\n      ans += max(0, (N-r)//q - r)\n\nprint(ans)
import sys,math,collections,itertools\ninput = sys.stdin.readline\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN,M = list(map(int,input().split()))\nuf = UnionFind(N)\nfor _ in range(M):\n    A,B = list(map(int,input().split()))\n    A -=1\n    B -=1\n    uf.union(A,B)\nans = 0\nfor i in range(N):\n    ans = max(ans,uf.size(i))\nprint(ans)\n
import sys\nsys.setrecursionlimit(4100000)\n\nmod = 10 ** 9 + 7\n\nN, K = map(int,input().split())\ngraph = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(int,input().split())\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n\nans = K\n\ndef factorial(n, k, mod):\n    fact = 1\n    for integer in range(n, n-k, -1):\n        fact *= integer\n        fact %= mod\n    return fact\n\ndef dfs(parent, current):\n    ret = 1\n    for child in graph[current]:\n        if child != parent:\n            ret *= dfs(current, child)\n    L = len(graph[current])\n    R = K - 1\n    if parent != -1:\n        L -= 1\n        R -= 1\n    ret *= factorial(R, L, mod)\n    return ret % mod\n\nans *= dfs(-1, 0)\nans %= mod\n\nprint(ans)
import numpy as np\nfrom numba import njit\nR,C,K=list(map(int,input().split()))\nvl=np.zeros((R,C), np.int64)\nfor _ in range(K):\n  r,c,v=list(map(int,input().split()))\n  vl[r-1][c-1]=v\n@njit\ndef main():\n  dp=np.zeros((R+1,C+1,4), np.int64)\n  for i in range(1,R+1):\n    for j in range(1,C+1):\n      for k in range(4):\n        dp[i][j][k]=max(dp[i][j-1][k],dp[i-1][j][3])\n      for k in range(3,0,-1):\n        dp[i][j][k]=max(dp[i][j][k],dp[i][j][k-1]+vl[i-1][j-1])\n  return dp[R][C][3]\nprint((main()))\n\n
import copy\nn = int(input())\ns = input()\ns += s[0]+s[1]\n\nkouho = ['SS','SW','WS','WW']\n\nfor x in kouho:\n    ans = copy.deepcopy(x)\n    for i in range(1,n+1):\n        if (s[i]=='o' and ans[i]=='S') or (s[i]=='x' and ans[i]=='W'):\n            if ans[i-1]=='S':\n                ans+= 'S'\n            else:\n                ans+='W'\n        else:\n            if ans[i-1]=='S':\n                ans+='W'\n            else:\n                ans+='S'\n    #円環成してるので正しければ頭二個と後ろ2個は同じになるはず\n    if ans[-2:]==x:\n       print(ans[:n])\n       return\nprint(-1)
from collections import Counter \n\nN = int(input())\nA = list(map(int,input().split()))\nQ = int(input())\n\ntot = sum(A)\nA = Counter(A)\n\nfor i in range(Q):\n    B,C = map(int,input().split())\n    tot +=(C - B) * A[B]\n    A[C] += A[B]\n    A[B] = 0\n    print(tot)
import numpy as np\ndef eratosthenes(m):\n    if m<2:\n        return []\n    dp=[True]*(m+1)\n    sosu=[2]\n    like=[0]*(m+1)#累積和\n    like[3]=1\n    for x in range(3,m+1,2):\n        if dp[x]:\n            sosu.append(x)\n            if dp[(x+1)//2]==True and (x+1)//2%2==1:\n                like[x]+=1\n        for j in range(2*x, m+1, x):\n            dp[j]=False\n    return like\n\nlike=eratosthenes(10**5+1)\nc = np.array(like).cumsum()\nq=int(input())\nfor i in range(q):\n    l,r=map(int,input().split())\n    ans=c[r]-c[l-1]\n    print(ans)
def main():\n    import collections\n    N, P = map(int, input().split())\n    S = input()[::-1]\n    ans = 0\n    if P == 2 or P == 5:\n        for i, s in enumerate(S):\n            if int(s) % P == 0:\n                ans += N - i\n    else:\n        mod = [0] * P\n        mod[0] = 1\n        current = 0\n        X = 1\n        for s in S:\n            current = (current + int(s) * X) % P\n            ans += mod[current]\n            mod[current] += 1\n            X = X * 10 % P\n    \n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()
from itertools import permutations as p\n\nfrom scipy.sparse.csgraph import floyd_warshall\n\nn, m, r = map(int, input().split())\nR = list(map(int, input().split()))\nl = [[0]*n for _ in range(n)]\nfor _ in range(m):\n  a, b, c = map(int, input().split())\n  a -= 1\n  b -= 1\n  l[a][b] = c\n  l[b][a] = c\nF = floyd_warshall(l)\n\nans = float("inf")\nfor v in p(R):\n  temp = 0\n  for i in range(r-1):\n    temp += F[v[i]-1][v[i+1]-1]\n  ans = min(ans, temp)\n  \nprint(int(ans))
import heapq\n\nn, a, b = map(int, input().split())\nh = []\nfor i in range(n):\n    h.append(int(input()))\nac = (max(h) - 1) // b + 1\nwa = 0\nwhile ac - wa > 1:\n    wj = (ac + wa) // 2\n    num = 0\n    for i in range(n):\n        num += max((h[i] - b * wj - 1) // (a - b) + 1, 0)\n    if num <= wj:\n        ac = wj\n    else:\n        wa = wj\nprint(ac)
n,k = map(int, input().split())\nP = list(map(int, input().split()))\ne = []\nfor i in P:\n    e.append((i+1)/2)\ncumsum = [0]*(n+1)\nfor i in range(1,n+1):\n    cumsum[i] = cumsum[i-1]+e[i-1]\nk_sum = cumsum.copy()\nfor i in range(n+1):\n    if i>=k:\n        k_sum[i] -= cumsum[i-k]\nprint(max(k_sum[k-1:]))
import collections\nN, M, K = map(int, input().split())\nfriend = [[] for i in range(N)]\nblock = [[] for i in range(N)]\ngraph = [-1] * N\nfor i in range(M):\n  a, b = map(int, input().split())\n  friend[a-1].append(b-1)\n  friend[b-1].append(a-1)\n  \nfor i in range(K):\n  c, d = map(int, input().split())\n  block[c-1].append(d-1)\n  block[d-1].append(c-1)\n  \n#print(friend, block)\n\nused = [True] * N\nfor i in range(N):\n  if used[i]:\n    q = [i]\n    used[i] = False\n    graph[i] = i\n    while q:\n      now = q.pop()\n      for j in friend[now]:\n        if used[j]:\n          graph[j] = graph[now]\n          q.append(j)\n          used[j] = False\n          \n          \n#print(graph)          \ngg = dict(collections.Counter(graph))  \n#print(gg)\n\nfor i in range(N):\n  nn = graph[i]\n  size = gg[nn]\n  ans = size - 1\n  for j in friend[i]:\n    if nn == graph[j]:\n      ans -= 1\n  for j in block[i]:\n    if nn == graph[j]:\n      ans -= 1\n  print(ans, end = " ")\n\n\n
import heapq\n\ndata = int(input())\narray = [int(_) for _ in input().split()]\n\nX = array[0:data]\nB = array[data:2*data]\nY = [-_ for _ in array[2*data:3*data]]\n\nheapq.heapify(X)\nheapq.heapify(Y)\n\nx = [sum(X)]\ny = [sum(Y)]\n\nfor i in range(data):\n    x += [B[i] - heapq.heappushpop(X, B[i])]\n    y += [-B[-1-i] - heapq.heappushpop(Y, -B[-1-i])]\n\nfor i in range(data):\n    x[i+1] = x[i]+x[i+1]\n    y[i+1] = y[i]+y[i+1]\n\nprint(max([x[_] + y[-1 - _] for _ in range(data+1)]))
# bを必要なだけ(strideの分)右にずらせばよい\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    ai, bi = 0, 0\n    stride = 0\n    while ai < n and bi < n:\n        ax, bx = a[ai], b[bi]\n        if ax == bx:\n            cnt = 2\n\n            ai += 1\n            while ai < n and a[ai] == ax:\n                cnt += 1\n                ai += 1\n\n            bi_copy = bi\n            bi += 1\n            while bi < n and b[bi] == bx:\n                cnt += 1\n                bi += 1\n\n            if cnt > n:\n                print('No')\n                return\n\n            if stride < ai - bi_copy:\n                stride = ai - bi_copy\n\n        elif ax < bx:\n            ai += 1\n        else:\n            bi += 1\n\n    print('Yes')\n    print(' '.join(map(str, b[n-stride:] + b[:n-stride])))\n\nmain()
import sys\n\nreadline=sys.stdin.readline\n\ns=list(readline().strip())\nn=len(s)\nf=n%2\nmid=s[n//2]\n\nfor i in range(n//2):\n  if s[n//2-i-1]!=mid or s[(n+1)//2+i]!=mid:\n    print(((n+1)//2+i))\n    break\nelse:\n  print(n)\n  \n
def main():\n  N=int(input())\n  A=list(map(int,input().split()))\n\n  mod=10**9+7\n  ans=0\n\n  for i in range(60):\n      a=0\n      for x in A:\n          if x>>i&1:\n              a+=1\n      ans+=a*(N-a)*pow(2,i,mod)\n      ans%=mod\n  print(ans)\ndef __starting_point():\n    main()\n\n__starting_point()
S = input()\nQ = int(input())\nbs = ''\nfs = ''\nhanten = 0\nfor i in range(Q):\n    query = list(input().split())\n    if query[0] == '1':\n        hanten += 1\n    else:\n        if query[1] == '1':\n            if hanten % 2 == 0:\n                fs += query[2]\n            else:\n                bs += query[2]\n        else:\n            if hanten % 2 == 0:\n                bs += query[2]\n            else:\n                fs += query[2]\nif hanten % 2 == 0:\n    print(fs[::-1]+S+bs)\nelse:\n    print(bs[::-1]+S[::-1]+fs)
def main():\n    X, Y, A, B, C = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    q = list(map(int, input().split()))\n    r = list(map(int, input().split()))\n    p.sort(reverse=True); q.sort(reverse=True); r.sort()\n\n    p = p[:X]\n    q = q[:Y]\n    s = p + q\n    s.sort()\n\n    rtmp = r.pop()\n    for i in range(len(s)):\n        if s[i] < rtmp:\n            s[i] = rtmp\n            if len(r) == 0:\n                break\n            rtmp = r.pop()\n        else:\n            break\n    ans = sum(s)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
#!/usr/bin/python\na = input()\nx='iloveyou'\nfor i in x:\n if i not in a:\n  print("sad")\n  return\nif a.count('o') < 2:\n print("sad")\n return\nprint("happy")\nreturn
# cook your dish here\nn = int(input())\nl = list(map(int, input().strip().split()))\nm = 0\nf = []\nfor e in l:\n if(e != 0):\n  m = m+1\n else:\n  f.append(m)\n  m = 0\n f.append(m)\nprint(max(f))\n   \n
x = list(map(float, input(" ").split()))\r\namount=int(x[0])\r\nbal=float(x[1])\r\nif amount+0.5 > bal or amount % 5 != 0:\r\n    print("{:.2f}".format(bal))\r\nelse:\r\n    bal = bal - amount-0.5\r\n    print("{:.2f}".format(bal))\r\n\r\n
\nN,M = [int(i) for i in input().split()]\n\nget_country = {}\nfor i in range(N):\n    name,country = input().split()\n    get_country[name] = country\n\ncountry_votes = {}\nname_votes = {}\nfor i in range(M):\n    name = input()\n    country_votes[get_country[name]] = country_votes.get(get_country[name],0) + 1\n    name_votes[name] = name_votes.get(name,0) + 1\n\nwin_country = None\nvotes = -float('inf')\nfor i,j in country_votes.items():\n    if(j>votes):\n        win_country = i\n        votes = j\n    elif(j==votes and i<win_country):\n        win_country = i\n\nwin_name = None\nvotes = -float('inf')\nfor i,j in name_votes.items():\n    if(j>votes):\n        win_name = i\n        votes = j\n    elif(j==votes and i<win_name):\n        win_name = i\n\nprint(win_country)\nprint(win_name)\n
l=[]\r\nfor _ in range(int(input())):\r\n	l.append(int(input()))\r\navg=0;l.sort()\r\nfor i in range(0,len(l)):\r\n	j=0;n=len(l)-1\r\n	while j<n:\r\n		s=l[j]+l[n]\r\n		if s>2*l[i]:\r\n			n-=1\r\n		elif s<2*l[i]:\r\n			j+=1\r\n		else:\r\n			avg+=1;break\r\nprint(avg)
p,q=list(map(int,input().split()))\nif(p!=0):\n a=list(map(int,input().split()))\nif(q!=0):\n b=list(map(int,input().split()))\n d=list(map(int,input().split()))\ns=list(map(int,input().split()))\nfor i in range(10):\n c=0\n for j in range(1,p+1):\n  c+=s[len(s)-j]*a[j-1]\n for k in range(0,q):\n  c+=b[k]*d[k]**(i+10)\n s.append(c%10**6)\ns=list([str(x) for x in s])\nprint(' '.join(s[10:21]))\n
# cook your dish here\nimport sys\nfrom collections import defaultdict\n\nclass Graph(object):\n	"""docstring for Graph"""\n	def __init__(self, vertices):\n		self.vertices = vertices\n		self.graph = defaultdict(list)\n\n	def add_edge(self,a,b):\n		self.graph[a].append(b)\n		self.graph[b].append(a)\n\n	def eulerPath(self):\n		g = self.graph\n		odd = [k for k, v  in g.items() if len(v)%2 == 1]\n		if len(odd) == 0 :\n			odd = [list(g.keys())[0]]\n		elif len(odd) == 1 or len(odd) > 2 :\n			return None\n		path = []\n		stack = [odd[-1]]\n		while stack:\n			u = stack[-1]\n			if g[u]:\n				v = g[u][0]\n				del g[u][0]\n				del g[v][g[v].index(u)]\n				stack.append(v)\n			else:\n				path.append(stack.pop())\n		return path\n\nn, e = map(int, sys.stdin.readline().strip().split())\ng = Graph(n)\n\nu = []\nv = []\n\nfor i in range(e):\n	a, b = map(int, sys.stdin.readline().strip().split())\n	g.add_edge(a,b)\n	u.append(a)\n	v.append(b)\n	\nans = g.eulerPath()\n\nif ans is None:\n	print('NO')\nelse:\n	if len(ans) == (e+1) and ans[0] == ans[-1]:\n		print("YES")\n		temp = defaultdict(defaultdict)\n		for i in range(len(ans)-1, 0, -1):\n			temp[ans[i]][ans[i - 1]] = True\n		for i in range(e):\n			if u[i] in temp and v[i] in temp[u[i]]:\n				print(u[i], v[i])\n			else:\n				print(v[i], u[i]) 		\n	else:\n		print("NO")
try:\r\n    r, c = map(int, input().split())\r\n    mat = []\r\n    for i in range(r):\r\n        arr=list(map(int, input().split()))\r\n        mat.append(arr)\r\n    flag=0\r\n    arr1=[]\r\n    for x in range(c):\r\n        arr = []\r\n        for j in range(r):\r\n            arr.append(mat[j][x])\r\n        arr1.append(arr)\r\n    i=0\r\n    for i in range(r):\r\n        for j in range(c):\r\n            if mat[i][j]==max(arr1[j]) and mat[i][j]==min(mat[i]):\r\n                flag=1\r\n                print(mat[i][j])\r\n                break\r\n        if flag==1:\r\n            break\r\n    if flag==0:\r\n        print("GUESS")\r\nexcept:\r\n    pass
from re import findall\ndef f(num):\n if num == 0:\n  return 1\n else:\n  return num*f(num-1)\ndic = {1: [0,1,2,3,53,52],2: [4,5,6,7,50,51],3: [8,9,10,11,48,49],\n  4: [12,13,14,15,47,46], 5: [16,17,18,19,44,45],6:[20,21,22,23,42,43],\n  7:[24,25,26,27,40,41],8:[28,29,30,31,38,39],9:[32,33,34,35,36,37]}\ndef test():\n nonlocal inp,x\n net = 0\n for com in list(dic.values()):\n  count = 0\n  for xx in com:\n   if inp[xx] == '0':\n    count += 1\n  if count >= x:\n   net += f(count)/f(x)/f(count-x)\n return net\n    \n    \nx,n = [int(x) for x in findall("\d+",input())]\ncount,arr = 0,[]\nfor i in range(n):\n inp = input()\n count += test()\nprint(count)
# cook your dish here\nn , m = map(int,input().split(" "))\narr = []\nfor i in range(n):\n    arr.append([int(j) for j in input().split()])\nl = int(input())\ncheck = []\nfor i in range(l):\n    a, b = map(int,input().split())\n    check.append([a-1,b-1])\n\ne1 , e2 = 0 , 0\nfor i in range(l):\n    if e1 != -1:\n        if check[i][0] < n and check[i][1] < m:\n            e1 += arr[check[i][0]][check[i][1]]\n        else:\n            e1 = -1\n    if e2 != -1:\n        if check[i][0] < m and check[i][1] < n:\n            e2 += arr[check[i][1]][check[i][0]]\n        else:\n            e2 = -1\nprint(max(e1,e2))
import sys\n\nq = int(sys.stdin.readline().strip())\nfor Q in range(0, q):\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    p = sys.stdin.readline().strip()\n    i = 0\n    j = 0\n    alpha = [0] * 26\n    while i != len(s) and j != len(t):\n        if s[i] == t[j]:\n            i = i + 1\n            j = j + 1\n        else:\n            k = ord(t[j]) - ord('a')\n            j = j + 1\n            alpha[k] = alpha[k] + 1\n    if i != len(s):\n        print("NO")\n    else:\n        while j < len(t):\n            k = ord(t[j]) - ord('a')\n            j = j + 1\n            alpha[k] = alpha[k] + 1\n        j = 0\n        while j < len(p):\n            k = ord(p[j]) - ord('a')\n            j = j + 1\n            alpha[k] = alpha[k] - 1\n        if max(alpha) > 0:\n            print("NO")\n        else:\n            print("YES")
for TT in range(1, int(input()) + 1):\n    a, b, c = map(int, input().split())\n    l = max(-1, (b + c - a) // 2)\n    r = c\n    print(r - l if r >= l else 0)
prime_factors = [[] for _ in range(10**6 + 1)]\nprimes=[True for i in range(10**6+1)]\ndef generate_primes(n):\n    \n    for p in range(2,n+1):\n        if primes[p]:\n            prime_factors[p].append(p)\n            for i in range(2 * p,n+1,p):\n                primes[i] = False\n                prime_factors[i].append(p)\ngenerate_primes(10**6)\nresult = []\nfor _ in range(int(input())):\n    x, p, k = map(int, input().split())\n    arr = prime_factors[p]\n    to_add = []\n    to_subtract = []\n    for i in range(1, 1 << len(arr)):\n        mul = 1\n        count = 0\n        for j in range(len(arr)):\n            if (1 << j) & i:\n                count += 1\n                mul *= arr[j]\n            \n        if count%2:\n            to_add.append(mul)\n        else:\n            to_subtract.append(mul)\n    count_before = 0\n    for num in to_add:\n        count_before += x//num\n        \n    for num in to_subtract:\n        count_before -= x//num\n    \n    k += (x - count_before)\n    \n    low = 0\n    high = 10**9\n    answer = high\n    while low <= high:\n        mid = (high + low)//2\n        temp_count = 0\n        for num in to_add:\n            temp_count += mid // num\n        for num in to_subtract:\n            temp_count -= mid // num\n        temp_count = mid - temp_count\n        if temp_count >= k:\n            answer = min(answer, mid)\n            high = mid - 1\n        else:\n            low = mid + 1\n    result.append(answer)\n    \nprint(*result, sep = "\n")\n
from collections import defaultdict\n\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum(c for c, v in list(self.items()) if v == self.mx)\n\n    def sumadd(self, map):\n        for bb, val in list(map.items()):\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef go():\n    n = int(input())\n    c = list(map(int, input().split()))\n\n    edges = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = [int(x) - 1 for x in input().split()]\n        edges[a].append(b)\n        edges[b].append(a)\n\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in edges[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n\n    cols = [SumDefaultdict({c[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for d, i in order:\n        children = sorted([cols[b] for b in edges[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({c[i]: 1})\n            cols[i] = children[0]\n        # max_val = max(cols[i].values())\n        answer[i] = cols[i].mx_sum\n\n    print(' '.join(map(str, answer)))\n\n\ngo()\n
import sys\n\nimport math\nfrom math import sqrt\nimport bisect\n \nsmall = 10**5+1\nbig = 10**18+1\n \npos = []\nf = pos.append\n#pos.add(1)\nj = 2\nwhile True:\n    #if sqrt(j).is_integer():\n    #    j+=1\n    #    continue\n    j2 = j*j\n    i = j*j2\n    if i>=big:\n        break\n    #if int(i**0.5+0.5)**2==i:\n    #    j+=1\n    #    continue\n    while i<big:\n        f(i)\n        i *= j2\n    j += 1\npos2 = [p for p in pos if not sqrt(p).is_integer()]\npos2.sort()\nprev = -1\npos = []\nf = pos.append\nfor p in pos2:\n    if p==prev:\n        continue\n    f(p)\n    prev = p\n \n \n \nq = int(input())\n#inp = [int(x) for line in sys.stdin for x in line.split()]\n#ii = 0\nout = []\nfor line in sys.stdin:\n    L,R = line.split()\n    L = int(L)\n    R = int(R)\n    \n \n    #ii+=2\n    a = -1\n    b = len(pos)\n    \n    \n    while b-a>1:\n        m = (a+b)//2\n        if pos[m]<L:\n            a=m\n        else:\n            b=m\n    under = a\n    #under = bisect.bisect_left(pos,L)\n    #if under<len(pos) and pos[under]>=L:\n    #    under -= 1\n    \n    a = -1\n    b = len(pos)\n    \n    \n    \n    while b-a>1:\n        m = (a+b)//2\n        if pos[m]<=R:\n            a = m\n        else:\n            b = m\n    upper = a\n    #upper = bisect.bisect_left(pos,R+1)-1\n    Lupp = max(int(sqrt(L)-1),0)\n    while Lupp*Lupp<L:\n        Lupp+=1\n    \n    Rdown = int(sqrt(R))+1\n    while Rdown*Rdown>R:\n        Rdown-=1\n \n    count = max(0,Rdown-Lupp+1)\n    out.append(str(upper-under+count))\nprint('\n'.join(out))
def det(s, i, j):\n    ans = 0\n    curr = i\n    for a in s:\n        if a == curr:\n            ans += 1\n            if curr == i: curr = j\n            else: curr = i\n\n    if i == j: return ans\n    return ans // 2 * 2\n\nfor t in range(int(input())):\n    s = list(map(int, list(input())))\n    ans = 0\n    \n    for i in range(10):\n        for j in range(10):\n            ans = max(ans, det(s, i, j))\n\n    print(len(s)-ans)\n
def read(): return list(map(int, input().split(' ')))\nn, m, q = read()\naa = read()\nbb = read()\nreqs = [read() for _ in range(q)]\n\nasum = 0\nbsum = 0\nfor i, (a, b) in enumerate(zip(aa, bb)):\n    asum += a if i % 2 == 0 else -a\n    bsum += b if i % 2 == 0 else -b\n\nbpos = [bsum]\nfor i in range(len(aa), len(bb)):\n    b = bb[i]\n\n    rempos = i - len(aa)\n    bsum += b if i % 2 == 0 else -b\n    bsum -= bb[rempos] if rempos % 2 == 0 else -bb[rempos]\n    bpos += [bsum if rempos % 2 == 1 else -bsum]\n\nbpos = sorted(set(bpos))\n\ndef closest(arr, value):\n    l = 0\n    r = len(arr)\n    while l + 1 < r:\n        m = (l + r) // 2\n        if arr[m] <= value:\n            l = m\n        else:\n            r = m\n        \n    res = arr[l]\n    if l + 1 < len(arr) and abs(arr[l + 1] - value) < abs(arr[l] - value):\n        res = arr[l + 1]\n    return res\n\nprint(abs(asum - closest(bpos, asum)))\nfor req in reqs:\n    l, r, x = req\n    l -= 1\n    if (r - l) % 2 != 0:\n        asum += x if l % 2 == 0 else -x\n    print(abs(asum - closest(bpos, asum)))\n
from collections import deque\nimport sys\n\ndef input():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n    T = int(input())\n\n    for i in range(T):\n        N = int(input())\n        e_list = [[] for i in range(N)]\n        for i in range(N-1):\n            a,b = list(map(int,input().split()))\n            a,b = a-1,b-1\n            e_list[a].append(b)\n            e_list[b].append(a)\n        \n        \n        vi = 0\n        INF = 10**27\n        Q = deque([vi])\n        \n        checked_list = [False]*N\n        checked_list[vi]=True\n        \n        min_path_list = [INF]*N #change\n        min_path_list[vi] = 0\n\n        while len(Q)>0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if not checked_list[v1]:\n                    checked_list[v1]=True\n                    Q.appendleft(v1)\n                    min_path_list[v1]=min(min_path_list[v1],min_path_list[v]+1)\n        \n        min_p = [(i,d) for i,d in enumerate(min_path_list)]\n        min_p.sort(key = lambda x:x[1],reverse=True)\n        member = [0]*N\n        #print(min_p)\n        center = []\n\n        for z in min_p:\n            #print(z)\n            flag = True\n            i,d = z\n            mem = 0\n            for v in e_list[i]:\n                mem += member[v]\n                if member[v] > N/2:\n                    flag=False\n            member[i] = mem + 1\n            if flag and N - member[i] <= N/2:\n                center.append(i)\n        \n        if len(center)==1:\n            print(1,e_list[0][0]+1)\n            print(1,e_list[0][0]+1)\n        else:\n            if e_list[center[0]][0]!=center[1]:\n                print(center[0]+1, e_list[center[0]][0]+1)\n                print(center[1]+1, e_list[center[0]][0]+1)\n            else:\n                print(center[0]+1, e_list[center[0]][1]+1)\n                print(center[1]+1, e_list[center[0]][1]+1)\n\ndef __starting_point():\n    main()\n\n__starting_point()
\nt=int(input())\nfor nt in range(t):\n    a,b=[int(k) for k in input().strip().split(" ")]\n    if (a+b)%3 or 2*a<b or 2*b<a:\n        print("NO")\n    else:\n        print("YES")
import sys\ninput = sys.stdin.readline\n\nt=int(input())\n\nfor test in range(t):\n\n    n,s=list(map(int,input().split()))\n    LR=[tuple(map(int,input().split())) for i in range(n)]\n    LR.sort(reverse=True)\n\n    R=[r for l,r in LR]\n    R.sort()\n\n    #print(LR,R)\n\n    MIN=LR[n//2][0]\n    MAX=R[n//2]\n    \n    OK=(n+1)//2\n\n    while MIN!=MAX:\n        mid=(MIN+MAX+1)//2\n        #print(MIN,MAX,mid)\n        count=0\n        money=0\n\n        for l,r in LR:\n\n            if count<OK:\n                if r>=mid:\n                    money+=max(l,mid)\n                    count+=1\n                else:\n                    money+=l\n\n            else:\n                money+=l\n\n        if count>=OK and money<=s:\n            MIN=mid\n        else:\n            MAX=mid-1\n\n    print(MIN)\n                \n            \n\n        \n\n        \n
# input = raw_input\n# range = xrange\nimport sys\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\n\nseg = [0]*200000\n\ndef offset(x):\n	return x + 100000\ndef encode(x, y):\n	return x*200002 + y\ndef decode(x):\n	return x//200002, x%200002\n\ndef upd(node, L, R, pos, val):\n	while L < R:\n		seg[node] += val\n		seg[offset(node)] += val*pos\n		if L+1 == R:\n			break\n \n		M = (L+R)//2\n		node <<= 1\n		if pos < M:\n			R = M\n		else:\n			L = M\n			node += 1\n\ndef query(node, L, R, k):\n	ret = 0\n	while L < R:\n		if k == 0:\n			return ret\n		if seg[node] == k:\n			return ret + seg[offset(node)]\n		if L+1 == R:\n			return ret + k*L\n\n		M = (L+R)//2\n		node <<= 1\n		if seg[node] >= k:\n			R = M\n		else:\n			ret += seg[offset(node)]\n			k -= seg[node]\n			L = M\n			node += 1\n\n	return ret\n\nn, m, k = inp[ii:ii+3]; ii += 3\nA, B, both, neither = [], [], [], []\nfor i in range(n):\n	t, a, b = inp[ii:ii+3]; ii += 3\n	if a == 0 and b == 0:\n		neither.append(encode(t, i+1))\n	if a == 1 and b == 0:\n		A.append(encode(t, i+1))\n	if a == 0 and b == 1:\n		B.append(encode(t, i+1))\n	if a == 1 and b == 1:\n		both.append(encode(t, i+1))\n	upd(1, 0, 10001, t, 1)\n\nA.sort(); B.sort(); both.sort()\np1 = min(k, len(both))\np2 = k - p1\nif 2*k - p1 > m or p2 > min(len(A), len(B)):\n	print(-1)\n	return\n\nsum, ans, ch = 0, 2**31, p1\nfor i in range(p1):\n	sum += both[i]//200002\n	upd(1, 0, 10001, both[i]//200002, -1)\nfor i in range(p2):\n	sum += A[i]//200002 + B[i]//200002\n	upd(1, 0, 10001, A[i]//200002, -1)\n	upd(1, 0, 10001, B[i]//200002, -1)\n\n\nans = query(1, 0, 10001, m-2*k+p1) + sum\n\nwhile p1 > 0:\n	if p2 == min(len(A), len(B)):\n		break\n	upd(1, 0, 10001, A[p2]//200002, -1); sum += A[p2]//200002\n	upd(1, 0, 10001, B[p2]//200002, -1); sum += B[p2]//200002\n	upd(1, 0, 10001, both[p1-1]//200002, 1); sum -= both[p1-1]//200002\n	p2 += 1\n	p1 -= 1\n	if m - 2*k + p1 < 0:\n		break\n	Q = query(1, 0, 10001, m-2*k+p1)\n	if ans > sum + Q:\n		ans = sum + Q\n		ch = p1\n\nprint(ans)\nind = [both[i]%200002 for i in range(ch)] + [A[i]%200002 for i in range(k-ch)] + [B[i]%200002 for i in range(k-ch)]\nst = neither + [both[i] for i in range(ch, len(both))] + [A[i] for i in range(k-ch, len(A))] + [B[i] for i in range(k-ch, len(B))]\nst.sort()\nind += [st[i]%200002 for i in range(m-2*k+ch)]\nprint (' '.join(str(x) for x in ind))
for _ in range(int(input())):\n    n = int(input())\n    s = input()\n\n    d = {0: 1}\n    summa, cnt = 0, 0\n    ans = 0\n    for i in s:\n        summa += int(i)\n        cnt += 1\n\n        k = cnt - summa\n        if k not in d:\n            d[k] = 0\n        ans += d[k]\n        d[k] += 1\n\n    print(ans)\n
import sys,bisect\ninput = sys.stdin.readline\n\nMOD = 998244353\ndef frac(a,b):\n    inv = pow(b, MOD - 2, MOD)\n    return (a * inv) % MOD\n\nn, m = list(map(int, input().split()))\nd = list(map(int, input().split()))\nd.sort()\ntot = sum(d)\n\npref = [0]\nfor v in d:\n    pref.append(pref[-1] + v)\n\nout = [0] * m\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    ind = bisect.bisect_left(d, b)\n    sum_before = pref[ind]\n    rest = tot - pref[ind]\n\n    if a <= (n - ind):\n        out[_] += sum_before * frac(n - ind - a + 1 ,n - ind + 1)\n        out[_] += rest * frac(n - ind - a ,n - ind)\n        out[_] %= MOD\nprint('\n'.join(map(str,out)))\n
for _ in range(int(input())):\n    n, m = map(int, input().split())\n    l1 = list(map(int,input().split()))\n    print(min(sum(l1),m))
import sys\ndef input():\n	return sys.stdin.readline()[:-1]\nfrom bisect import bisect\n\ndef ctoi(c):\n	return ord(c) - ord("a")\n	print(ans)\n\nT = int(input())\nfor _ in range(T):\n	s = input()\n	t = input()\n	if not (set(s) >= set(t)):\n		print(-1)\n	else:\n		alph = [[] for _ in range(26)]\n		for i in range(len(s)):\n			alph[ctoi(s[i])].append(i)\n		for a in alph:\n			if a:\n				a.append(a[0] + len(s))\n		#print(alph)\n		cur = len(s)-1\n		ans = 0\n		for i in range(len(t)):\n			ind = bisect(alph[ctoi(t[i])], cur)\n			ans += alph[ctoi(t[i])][ind] - cur\n			cur = alph[ctoi(t[i])][ind] % len(s)\n		print(-(-ans//len(s)))\n
import sys\ninput = sys.stdin.readline\nT = int(input())\n\n\n\nfor testcase in range(1,T+1):\n    n,m = map(int,input().split())\n    p = tuple(map(int,input().split()))\n    h = tuple(map(int,input().split()))\n\n    a = [0]*n\n    b = [0]*n\n\n    edge = [[] for i in range(n)]\n    for _ in range(n-1):\n        x,y = map(int,input().split())\n        edge[x-1].append(y-1)\n        edge[y-1].append(x-1)\n    \n    par = [-1]*n\n    tank = [0]\n    order = []\n    while tank:\n        now = tank.pop()\n        order.append(now)\n        for e in edge[now]:\n            if par[now] != e:\n                par[e] = now\n                tank.append(e)\n    flag = True\n    for e in order[::-1]:\n        if (a[e]-b[e]-p[e] <= h[e] <= a[e]+b[e]+p[e]) and (h[e]+a[e]+b[e]+p[e])%2 == 0:\n            if e != 0:\n                a[par[e]] += (h[e]+a[e]+b[e]+p[e])//2\n                b[par[e]] += (h[e]+a[e]+b[e]+p[e])//2 - h[e]\n        else:\n            flag = False\n            break\n    if flag:\n        print("YES")\n    else:\n        print("NO")
q = int(input())\nfor ii in range(q):\n	n,x = map(int,input().split())\n	l = list(map(int,input().split()))\n	par = 0\n	npar = 0\n	for i in l:\n		if i%2 == 1:\n			npar += 1\n		else:\n			par += 1\n	if x == n:\n		if npar%2 == 1:\n			print("Yes")\n		else:\n			print("No")\n	else:\n		if npar > 0 and par > 0:\n			print("Yes")\n		else:\n			if par == 0:\n				if x%2 == 1:\n					print("Yes")\n				else:\n					print("No")\n			else:\n				print("No")
def subsolve(a):\n    c = 0\n    m = 0\n    for i in a:\n        c += i\n        if c < 0:\n            c = 0\n        m = max(m, c)\n    return m\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = 0\n    for i in range(0, n, 2):\n        s += a[i]\n    u = subsolve([a[i] - a[i - 1] for i in range(1, n, 2)])\n    v = subsolve([a[i - 1] - a[i] for i in range(2, n, 2)])\n    print(max(u, v) + s)\nt = int(input())\nfor _ in range(t):\n    solve()
import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nANS = []\nT = int(input())\nfor _ in range(T):\n    N, Q = list(map(int, input().split()))\n    A = [int(a) for a in input().split()]\n    ans = sum(max(b - a, 0) for a, b in zip([0] + A, A))\n    ANS.append(ans)\n    for _ in range(Q):\n        l, r = list(map(int, input().split()))\n        l, r = l-1, r-1\n        if l == r:\n            ANS.append(ans)\n            continue\n        \n        ans -= max(A[l] - A[l-1], 0) if l else A[l]\n        if l < N - 1: ans -= max(A[l+1] - A[l], 0)\n        if r > l + 1: ans -= max(A[r] - A[r-1], 0)\n        if r < N - 1: ans -= max(A[r+1] - A[r], 0)\n        \n        A[l], A[r] = A[r], A[l]\n        \n        ans += max(A[l] - A[l-1], 0) if l else A[l]\n        if l < N - 1: ans += max(A[l+1] - A[l], 0)\n        if r > l + 1: ans += max(A[r] - A[r-1], 0)\n        if r < N - 1: ans += max(A[r+1] - A[r], 0)\n        \n        ANS.append(ans)\n\nprint("\n".join(map(str, ANS)))\n\n
"""This code was written by\nRussell Emerine - linguist,\nmathematician, coder,\nmusician, and metalhead."""\n\nn = int(input())\nfor _ in range(n):\n  c, s = list(map(int, input().split()))\n  a = s // c\n  r = s % c\n  print((c - r) * a ** 2 + r * (a + 1) ** 2)\n
def main():\n    n, m = list(map(int, input().split()))\n    n += 1\n    cluster, dest, ab = list(range(n)), [0] * n, [[] for _ in range(n)]\n\n    def root(x):\n        if x != cluster[x]:\n            cluster[x] = x = root(cluster[x])\n        return x\n\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        ab[a].append(b)\n        dest[b] += 1\n        cluster[root(a)] = root(b)\n    pool = [a for a, f in enumerate(dest) if not f]\n    for a in pool:\n        for b in ab[a]:\n            dest[b] -= 1\n            if not dest[b]:\n                pool.append(b)\n    ab = [True] * n\n    for a, f in enumerate(dest):\n        if f:\n            ab[root(a)] = False\n    print(n - sum(f and a == c for a, c, f in zip(list(range(n)), cluster, ab)))\n\n\ndef __starting_point():\n    from sys import setrecursionlimit\n\n    setrecursionlimit(100500)\n    main()\n\n__starting_point()
import sys\n\n# sys.stdin = open('in.txt')\n\ns = sys.stdin.read().split()\np = 0\n\n\ndef getSm(k, a, b, c, d):\n    return (k + 1) * a - (k * (k + 1) >> 1) * b * d\n\n\nt = int(s[p])\np += 1\n\nres = []\n\nfor _ in range(t):\n    a = int(s[p])\n    p += 1\n    b = int(s[p])\n    p += 1\n    c = int(s[p])\n    p += 1\n    d = int(s[p])\n    p += 1\n    if a - b * c > 0:\n        res.append(-1)\n    elif d >= c:\n        res.append(a)\n    else:\n        dn = 0\n        up = int(1e6) + 1\n        while up - dn > 1:\n            md = (up + dn) >> 1\n            if getSm(md, a, b, c, d) < getSm(md + 1, a, b, c, d):\n                dn = md\n            else:\n                up = md\n        ans = max(a, getSm(dn, a, b, c, d), getSm(up, a, b, c, d))\n        res.append(ans)\n\nprint('\n'.join(map(str, res)))\n
import sys\n\n\n# inf = open('input.txt', 'r')\n# reader = (map(int, line.split()) for line in inf)\nreader = (list(map(int, line.split())) for line in sys.stdin)\n\ndef minmaxPairs(g, costDict, n):\n    G = B = 0\n    s = 1\n    stack = [s]\n    traversal = []\n    visited = [False] * (n + 1)\n    subtreeSize = [1 for _ in range(n + 1)]\n    while stack:\n        v = stack.pop()\n        if not visited[v]:\n            visited[v] = True\n            for to in g[v]:\n                if not visited[to]:\n                    stack.append(v)\n                    stack.append(to)\n        else:\n            to = traversal[-1]\n            if (v, to) in costDict:\n                cost = costDict[(v, to)]\n            else:\n                cost = costDict[(to, v)]\n            toSize = subtreeSize[to]\n            subtreeSize[v] += toSize\n            minComp = min(toSize, n - toSize)\n            G += (minComp % 2) * cost\n            B += minComp * cost\n        traversal.append(v)\n    return G, B \n\nt, = next(reader)\nfor _ in range(t):\n    k, = next(reader)\n    n = 2 * k\n    g = [[] for i in range(n + 1)]\n    costDict = {}\n    for i in range(n - 1):\n        v, to, cost = next(reader)\n        costDict[(v, to)] = cost\n        g[v].append(to)\n        g[to].append(v)\n    G, B = minmaxPairs(g, costDict, n)\n    print(G, B)\n\n# inf.close()\n
t = int(input())\nfor i in range(0, t) :\n    n, l, r = [int(s) for s in input().split()]\n    print('Yes' if n % l <= (r - l) *  (n // l) else 'No')
import sys\nimport string\nfrom math import gcd\nimport getpass\nimport math\nfrom decimal import Decimal\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n    # sys.stdin = open('input.txt')\n    # sys.stdout = open('output.txt', 'w')\nelse:\n    sys.stdin = open('input.txt')\n    # sys.stdin.close()\n# sys.stdout = open('input.txt','w')\n\nn = ria()[0]\nfor i in range(n):\n    print(2 ** str(bin(int(input()))).count('1'))\n
n,N,MOD,ans=int(input()),int(1e6+5),int(1e9+7),0\ncnt,pw,f=[0]*int(N),[1]*(n+1),[0]*int(N)\nfor i in range(n):\n	pw[i+1]=pw[i]*2%MOD\nfor i in input().split():\n	cnt[int(i)]+=1\nfor i in reversed(range(2,N)):\n	t=sum([cnt[j] for j in range(i,N,i)])\n	if t:\n		f[i]=t*pw[t-1]%MOD\n		for j in range(i*2,N,i):\n			f[i]=(f[i]-f[j])%MOD\n		ans+=i*f[i]%MOD\nprint(ans%MOD)
for __ in range(int(input())):\n    a = list(map(int, input()))\n    ar1 = []\n    ar2 = []\n    for elem in a:\n        if elem % 2 == 0:\n            ar1.append(elem)\n        else:\n            ar2.append(elem)\n    ans = []\n    i = 0\n    j = 0\n    while i < len(ar1) and j < len(ar2):\n        if ar1[i] < ar2[j]:\n            ans.append(ar1[i])\n            i += 1\n        else:\n            ans.append(ar2[j])\n            j += 1\n    if i < len(ar1):\n        for h in range(i, len(ar1)):\n            ans.append(ar1[h])\n    if j < len(ar2):\n        for h in range(j, len(ar2)):\n            ans.append(ar2[h])\n    print(''.join(map(str, ans)))
from sys import stdin\ninput = stdin.readline\nq = int(input())\nfor _ in range(q):\n    a,b,n = map(int,input().split())\n    kroki = 0\n    while max(a,b) <= n:\n        if a > b:\n            a,b = b,a\n        a = a+b\n        kroki += 1\n    print(kroki)
for _ in range(int(input())):\n    a,b,c = list(map(int, input().split()))\n    x,y,z = list(map(int, input().split()))\n\n    temp = min(c,y)\n    ans = 2*temp\n    c -= temp\n    y -= temp\n    temp = min(c,z)\n    c -= temp\n    z -= temp\n    temp = min(c,x)\n    c -= temp\n    x -= temp\n\n    temp = min(a,z)\n    a -= temp\n    z -= temp\n    temp = min(b,z)\n    ans -= 2*temp\n    b -= temp\n    z -= temp\n    print(ans)\n
import math as ma\nimport sys\nfrom decimal import Decimal as dec\nfrom itertools import permutations\n\n\ndef li():\n	return list(map(int , input().split()))\n\n\ndef num():\n	return map(int , input().split())\n\n\ndef nu():\n	return int(input())\n\n\nt=nu()\nfor it in range(t):\n	k=nu()\n	a=li()\n	s=sum(a)\n	zz=[]\n	for i in range(7):\n		pp=0\n		cc=k\n		for j in range(i,7):\n			pp+=1\n			cc-=a[j]\n			if(cc==0):\n				break\n		if(cc==0):\n			zz.append(pp)\n			continue\n		kl=cc%s\n		if(kl==0):\n			nm=cc//s-1\n		else:\n			nm=cc//s\n		cc=cc-nm*s\n		nm=nm*7\n		pp+=nm\n		for j in range(0,7):\n			if(cc==0):\n				break\n			pp+=1\n			cc-=a[j]\n		zz.append(pp)\n	print(min(zz))
t=int(input())\nfor t in range(t):\n	n=int(input())\n	s=input()\n	a=[int(x) for x in s]\n	p=a[n-1]\n	print(str(p)*n)
def solve():\n    s = input()\n    pm = 0\n    cur = 0\n    ans = len(s)\n    for i in range(len(s)):\n        if s[i] == '+':\n            cur += 1\n        else:\n            cur -= 1\n            if cur < pm:\n                pm = cur\n                ans += i + 1\n    print(ans)\nt = int(input())\nfor _ in range(t):\n    solve()
# import numpy as np\n# import sys\n\n# q=int(input())\nmod=1000000007\ndp=[(0,0),(0,0)]\nfor i in range(2,2000001):\n	dp.append(((max(dp[-1])+2*max(dp[-2]))%mod,(dp[-1][0]+2*dp[-2][0]+1)%mod))\nfor o in range(int(input())):\n	print(max(dp[int(input())-1])*4%mod)\n	\n		\n	\n
def testcase():\n\n    n, x = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    brr = list(map(int, input().split()))\n    arr.sort()\n    brr.sort(reverse=True)\n    for i in range(n):\n        if arr[i] + brr[i] > x:\n            print('No')\n            return\n    print('Yes')\n    return\n\n\nimport sys, os\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\nsys.setrecursionlimit(10 ** 5)\nt = int(input())\nfor _ in range(t - 1):\n    testcase()\n    input()\ntestcase()
for test in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    for i in range(0, n, 2):\n        a1 = a[i]\n        a2 = a[i + 1]\n        print(-a2, a1, end=" ")\n    print()
for _ in range(int(input())):\n    n, m = list(map(int, input().split()))\n    arr = [list(map(int, input().split())) for _ in range(n)]\n    res = 0\n    for i in range(n//2):\n        for j in range(m//2):\n            a = [arr[i][j], arr[n-i-1][j], arr[i][m-j-1], arr[n-i-1][m-j-1]]\n            a.sort()\n            res += (a[1]-a[0]) + (a[2]-a[1]) + (a[3]-a[1])\n    if n%2 == 1:\n        i = n//2\n        for j in range(m//2):\n            res += abs(arr[i][j] - arr[i][m-j-1])\n    if m%2 == 1:\n        j = m//2\n        for i in range(n//2):\n            res += abs(arr[i][j] - arr[n-i-1][j])\n    print(res)\n
import collections\nimport math\nn, k, m = [int(i) for i in input().split()]\nl = math.ceil((math.log(2*n) / math.log(2)))\np = 2 ** l\n# print(p)\nmemo = [0] * (2 * p)\nallres = [0] * (2 * p)\n\nexist = set()\nfor _i in range(m):\n    x, y = [int(i) for i in input().split()]\n    l = abs(x - k) + y\n    index = l + p\n    if (x, y) in exist:\n        exist.remove((x, y))\n        while index != 0:\n            memo[index] -= 1\n            index = index // 2\n    else:\n        exist.add((x, y))\n        while index != 0:\n            memo[index] += 1\n            index = index // 2\n    index = (l + p) // 2\n    allres[l+p] = l + memo[l + p] - 1\n    if memo[l + p] == 0:\n        allres[l+p] = 0\n    while index != 0:\n        allres[index] = max(allres[index * 2] + memo[index * 2 + 1], allres[index * 2 + 1])\n        index = index // 2\n    # print('i', _i + 1, exist, allres, memo)\n    \n    print(max(allres[1] - n, 0))\n\n\n\n\n\n
def read_line():\n    return list(map(int, input().split()))\ndef pr(l):\n    a = 1\n    for x in l:\n        a *= x\n    return a\n\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    l = list(sorted(read_line()))\n    l2 = list(reversed(l))\n    m = None\n    for i in range(6):\n        j = 5 - i\n        a = l[:i]\n        b = l2[:j]\n        p = pr(a) * pr(b)\n        if m == None or p > m:\n            m = p\n    print(m)\n\n\n
import sys\nmy_file = sys.stdin\n##my_file = open("input.txt", "r")\nnum = int(my_file.readline().strip("\n"))\nangles = my_file.read().split()\nangles = [int(i) for i in angles]\nfor i in angles:\n    if 360%(180-i)>0:\n        print("NO")\n    else:\n        print("YES")
import sys\nimport math\ndef II():\n	return int(sys.stdin.readline())\n \ndef LI():\n	return list(map(int, sys.stdin.readline().split()))\n \ndef MI():\n	return map(int, sys.stdin.readline().split())\n \ndef SI():\n	return sys.stdin.readline().strip()\nt = II()\nfor q in range(t):\n	a,b,c,d = MI()\n	print(max(a+b,c+d))
import sys\ninput = sys.stdin.readline\n\ndef main():\n    n, m = map(int, input().split())\n    alst = [list(map(int, input().split())) for _ in range(n)]\n    blst = [[0 for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if (i + j) % 2 == alst[i][j] % 2:\n                blst[i][j] = alst[i][j]\n            else:\n                blst[i][j] = alst[i][j] + 1\n    for row in blst:\n        print(*row)\n    \nfor _ in range(int(input())):\n    main()
import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nFR=[list(map(int,input().split())) for i in range(m)]\n\n#UnionFind\n\nGroup=[[i,1] for i in range(n+1)]\n\ndef find(x):\n    while Group[x][0] != x:\n        x=Group[x][0]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        SUM=Group[find(y)][1]+Group[find(x)][1]\n        Group[find(y)][0]=Group[find(x)][0]=min(find(y),find(x))\n        Group[find(y)][1]=SUM\n\n        \n\nfor j in range(m):\n    if len(FR[j])<=2:\n        continue\n    for k in range(2,len(FR[j])):\n        Union(FR[j][k],FR[j][k-1])\n\nANS=[]\nfor i in range(1,n+1):\n    ANS.append(Group[find(i)][1])\n\nprint(*ANS)\n
def list_input():\n    return list(map(int,input().split()))\ndef map_input():\n    return map(int,input().split())\ndef map_string():\n    return input().split()\n    \nl,r,x,y,k = map_input()\nans = "NO"\nfor i in range(x,y+1):\n    if k*i > r:\n        break\n    elif k*i < l:\n        continue\n    ans = "YES"\n    break\nprint(ans)
import sys\nfrom collections import deque\n\ninput=sys.stdin.readline\n\nfor _ in range(int(input())):\n    n=int(input())\n    edge=[[] for i in range(n)]\n    for i in range(n-1):\n        u,v=list(map(int,input().split()))\n        edge[u-1].append(v-1)\n        edge[v-1].append(u-1)\n    m=int(input())\n    p=list(map(int,input().split()))\n\n    size=[1 for i in range(n)]\n    parent=[-1 for i in range(n)]\n    res=[]\n    deq=deque([(0,-1)])\n    while deq:\n        v,pv=deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv!=pv:\n                parent[nv]=v\n                deq.append((nv,v))\n\n    res=res[::-1]\n    for v in res:\n        for nv in edge[v]:\n            if nv!=parent[v]:\n                size[v]+=size[nv]\n\n    coef=[]\n    for v in res:\n        for nv in edge[v]:\n            if nv!=parent[v]:\n                c=size[nv]*(n-size[nv])\n                coef.append(c)\n    mod=10**9+7\n    #print(coef)\n    #print(p)\n    #print(size)\n    if m<n-1:\n        res=0\n        coef.sort(reverse=True)\n        p.sort(reverse=True)\n        for i in range(m):\n            res+=coef[i]*p[i]\n            res%=mod\n        for i in range(m,n-1):\n            res+=coef[i]\n            res%=mod\n        print(res)\n    else:\n        res=0\n        coef.sort()\n        p.sort()\n        for i in range(n-2):\n            res+=coef[i]*p[i]\n            res%=mod\n        tmp=coef[-1]\n        for i in range(n-2,m):\n            tmp*=p[i]\n            tmp%=mod\n        res=(res+tmp)%mod\n        print(res)\n
import sys\ninput=sys.stdin.buffer.readline\nt=1    \nfor __ in range(t):\n    a=[]\n    n=int(input())\n    for i in range(n):\n        b=list(map(int,input().split()))\n        a.append(b)\n    dr={}\n    di={}\n    for i in range(n):\n        for j in range(n):\n            dr[i+j]=dr.get(i+j,0)+a[i][j]\n            di[i+n-j+1]=di.get(i+n-j+1,0)+a[i][j]\n    ind1=[0]*2\n    ind2=[0]*2\n    maxi1=0\n    maxi2=0\n    for i in range(n):\n        for j in range(n):\n            #if maxi<(dr[i+j]+di[i+n-j+1]-a[i][j]):\n            if ((i+j)&1)==1:\n                if maxi1<=(dr[i+j]+di[i+n-j+1]-a[i][j]):    \n                    maxi1=(dr[i+j]+di[i+n-j+1]-a[i][j])\n                    ind1[0]=i+1\n                    ind1[1]=j+1\n            else:\n                if maxi2<=(dr[i+j]+di[i+n-j+1]-a[i][j]):    \n                    maxi2=(dr[i+j]+di[i+n-j+1]-a[i][j])\n                    ind2[0]=i+1\n                    ind2[1]=j+1\n                    \n    \n    \n    print(maxi1+maxi2)\n    print(ind1[0],ind1[1],ind2[0],ind2[1])
n = int(input())\na = list(map(int, input().split()))\n\np = list(range(n + 1))\ns = [set() for i in range(n + 1)]\n\ndef find(x):\n    if p[x] != x:\n        p[x] = find(p[x])\n    return p[x]\n\ndef union(x, y, cur):\n    x, y = find(x), find(y)\n    r = 0\n    if len(s[x]) < len(s[y]):\n        x, y = y, x\n    for k in s[y]:\n        r += cur - k in s[x]\n    s[x] |= s[y]\n    s[x].add(cur)\n    p[y] = x\n    return r\n\nprint(sum(union(i, i + 1, a[i]) for i in sorted(range(n), key=lambda i: a[i])))
t = int(input())\n\np2 = [1]\nfor i in range(40):\n    p2.append(2 * p2[-1])\n\nff = 'FastestFinger'\na = 'Ashishgup'\n\n\ndef prime(p):\n    for i in range(3, min(4 * 10 ** 4,p), 2):\n        if p % i == 0:\n            return False\n    return True\n\nfor i in range(t):\n    n = int(input())\n    if n == 1:\n        print(ff)\n    elif n == 2:\n        print(a)\n    elif n in p2:\n        print(ff)\n    elif (n % 4 != 2):\n        print(a)\n    else:\n        testp = n//2\n\n        if prime(testp):\n            print(ff)\n        else:\n            print(a)\n        \n
import os\nfrom io import BytesIO\n\n# input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ndef check(x, p):\n    i = mid - 1\n    while i > -1 and a[i] <= p:\n        p -= a[i]\n        if i >= k - 1:\n            i -= k\n        else:\n            i -= 1\n    return i <= -1\n\n\nfor _ in range(int(input())):\n    n, p, k = list(map(int, input().split()))\n    a = sorted(map(int, input().split()))\n    L = 0\n    R = n + 1\n    while R - L > 1:\n        mid = (L + R) >> 1\n        if check(mid, p):\n            L = mid\n        else:\n            R = mid\n    print(L)\n
t = int(input())\nfor _ in range(t):\n    n = int(input())\n    print(n//2)
for _ in range(int(input())):\n    n, m = map(int, input().split())\n    print('W' + 'B' * (m - 1))\n    print((('B' * (m) + '\n') * (n - 1))[:-1])
# for _ in range(1):\nfor _ in range(int(input())):\n    # a, b = map(int, input().split())\n    n = int(input())\n    # arr = list(map(int, input().split()))\n    # s = input()\n    x = (n + 3) // 4\n    y = n - x\n    print(y * '9' + x * '8')
for _ in range(int(input())):\n    n, a, b = map(int, input().split())\n    s = input().strip()\n    ans = (n + 1) * b + n * a\n    \n    if '1' in s:\n        ans += 2 * a\n        s = s[s.find('1'):s.rfind('1') + 1]\n        t = [0] * (len(s) + 1)\n        for i in range(len(s)):\n            x = int(s[i])\n            t[i] = max(t[i], x)\n            t[i + 1] = max(t[i + 1], x)\n        i = 0\n        while i < len(t):\n            j = i + 1\n            while j < len(t) and t[i] == t[j]:\n                j += 1\n            if t[i]:\n                ans += b * (j - i)\n            else:\n                ans += min(b * (j - i), 2 * a) \n            i = j\n    \n    print(ans)
\nt = int(input())\n\nfor loop in range(t):\n\n    n,x = list(map(int,input().split()))\n    a = list(map(int,input().split()))\n\n    ss = sum(a)\n\n    if ss % x != 0:\n        print (n)\n    else:\n\n        ans = -1\n        for i in range(n):\n\n            if a[i] % x != 0:\n                ans = n-i-1\n                break\n\n        for i in range(n-1,-1,-1):\n\n            if a[i] % x != 0:\n                ans = max(ans , i)\n                break\n\n        print (ans)\n
import sys\nfrom collections import defaultdict\nfrom copy import copy\n\nR = lambda t = int: t(input())\nRL = lambda t = int: [t(x) for x in input().split()]\nRLL = lambda n, t = int: [RL(t) for _ in range(n)]\n\ndef solve():\n  n, x = RL()\n  A = RL()\n  A.sort(reverse = True)\n  s = c = m = 0\n  for a in A:\n    s += a\n    c += 1\n    if s >= x * c:\n      m = c    \n  print(m)\n      \nT = R()\nfor _ in range(T):\n  solve()\n
t = int(input())\nfor yguagwu in range(t):\n    n = int(input())\n    a = sorted(list(map(int,input().split())))\n    b = []\n    for i in range(n):\n        if i % 2 == 0:\n            b.append(a[(-i//2-1)])\n        else:\n            b.append(a[i//2])\n    print(*b[::-1])\n
from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport heapq\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n \nM = mod = 10**9 + 7\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\n').split(' ')]\ndef st():return input().rstrip('\n')\ndef val():return int(input().rstrip('\n'))\ndef li2():return [i for i in input().rstrip('\n').split(' ')]\ndef li3():return [int(i) for i in input().rstrip('\n')]\n\n\nfor _ in range(val()):\n    a,b,c = sorted(li())\n    tot = 0\n    if a:\n        tot += 1\n        a -= 1\n    if b:\n        tot += 1\n        b -= 1\n    if c:\n        tot += 1\n        c -= 1\n    if b and c:\n        tot += 1\n        b -= 1\n        c -= 1\n    if a and c:\n        tot += 1\n        a -= 1\n        c -= 1\n    if b and a:\n        b -= 1\n        a -= 1\n        tot += 1\n    if a and b and c:\n        a -= 1\n        b -= 1\n        c -= 1\n        tot += 1\n    print(tot)\n\n
t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    \n    a = list(map(int, input().split()))\n    \n    counts = [0] * 32\n    for x in a:\n        counts[len(bin(x))-2] += 1\n        \n    total = 0\n    for count in counts:\n        total += count * (count-1) // 2\n    print(total)\n
q = int(input())\nfor i in range(q):\n	a,b = map(int,input().split())\n	print((a*b+1)//2)
ans = []\nfor _ in range(int(input())):\n    a, b = list(map(int, input().split()))\n    a, b = max(a, b), min(a, b)\n    if a % b != 0:\n        ans.append(-1)\n        continue\n    x = a // b\n    cnt = 0\n    while x % 2 == 0:\n        x //= 2\n        cnt += 1\n    if x != 1:\n        ans.append(-1)\n        continue\n    ansi = (cnt - 1) // 3 + 1\n    ans.append(ansi)\nprint('\n'.join(map(str, ans)))\n
n,k,m,t=list(map(int,input().split()))\nfor i in range(t):\n    a,b=list(map(int,input().split()))\n    if a==1:\n        if b<=k:\n            k+=1\n        n+=1\n        print(n,k)\n    else :\n        if k>b:\n            n=n-b\n            k=k-b\n        else :\n            n=b\n        print(n,k)\n
n=int(input())\nfor _ in range(n):\n    i=int(input())\n    ar=sorted(list(map(int,input().split())))[::-1]\n    mx=0\n    for e in range(i):\n        mx=max(mx,min(e+1,ar[e]))\n    print(mx)\n
from collections import deque\n \nn, m = list(map(int, input().split()))\nadj = [[] for i in range(n)]\nfor i in range(m):\n    u, v, c = input().split()\n    u, v = int(u)-1, int(v)-1\n    adj[u].append((v, c))\n    adj[v].append((u, c))\n \nvisited = S = T = None\n \ndef bfs(i, k):\n    q = deque([(i, 0)])\n    while q:\n        u, p = q.pop()\n \n        if visited[u] >= 0:\n            if visited[u] == p: continue\n            else: return False\n \n        visited[u] = p\n        if p: S.append(u)\n        else: T.append(u)\n \n        for v, c in adj[u]:\n            nxt = p if c == k else p^1\n            q.appendleft((v, nxt))\n \n    return True\n \ndef solve(k):\n    nonlocal visited, S, T\n    visited = [-1]*n\n    res = []\n    for i in range(n):\n        if visited[i] < 0:\n            S, T = [], []\n            if not bfs(i, k):\n                return [0]*(n+1)\n            else:\n                res.extend(S if len(S) < len(T) else T)\n    return res\n \nres1 = solve("R")\nres2 = solve("B")\n \nif min(len(res1), len(res2)) > n:\n    print(-1)\nelse:\n    print(min(len(res1), len(res2)))\n    print(" ".join([str(x+1) for x in res1 if len(res1) < len(res2) else res2]))\n
tests = int(input())\nINF = 10**20\n\nfor test in range(tests):\n    n, w = map(int, input().split())\n    res = INF\n    for k in range(17):\n        for d in range(10):\n            tmp = 0\n            for i in range(w+1):\n                if d+i <= 9:\n                    tmp += 9*k+d+i\n                else:\n                    tmp += 1+(d+i)-10\n            if n >= tmp and (n-tmp)%(w+1) == 0:\n                s = (n-tmp)//(w+1)\n                if s <= 8:\n                    prefix = str(s)\n                else:\n                    prefix = str((s-8)%9)+"9"*((s-8)//9)+"8"\n                prefix += "9"*k\n                prefix += str(d)\n                x = int(prefix)\n                if sum(sum(int(c) for c in str(x+i)) for i in range(w+1)) == n:\n                    res = min(res, x)\n    if res == INF: res = -1\n    print(res)
t = int(input())\nfor _ in range(t):\n    n,m = list(map(int, input().split()))\n    l = []\n    for _ in range(n):\n        l.append(list(map(int,input().split())))\n    zeroes = [0] * (m + n - 1)\n    ones = [0] * (m + n - 1)\n\n    for i in range(n):\n        for j in range(m):\n            if l[i][j] == 0:\n                zeroes[i + j] += 1\n            else:\n                ones[i + j] += 1\n\n    out = 0\n\n    for i in range((m + n - 1)//2):\n        z = zeroes[i] + zeroes[m + n - 2 - i]\n        o = ones[i] + ones[m + n - 2 - i]\n        out += min(o,z)\n    print(out)\n                       \n
input=__import__('sys').stdin.readline\nfor _ in range(int(input())):\n	n=int(input())\n	s=list(map(int,input().split()))\n	print('YNEOS'[sum(a>b for a,b in zip(s,s[1:]))==n-1::2])\n
t=int(input())\nfor x in range(t):\n    a,b,n,m= map(int,input().split(" "))\n    if a+b<n+m:\n        print("No")\n    else:\n        if m>min(a,b):\n            print("No")\n        else:\n            print("Yes")
from math import gcd\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int,input().split()))\n    newList = sorted(l)\n    m = newList[0]\n    div = newList[0]\n    for i in range(n):\n        if l[i]!=newList[i]:\n            div = gcd(div,l[i])\n    if div%m==0:\n        print("YES")\n    else:\n        print("NO")
R=lambda:list(map(int,input().split()))\nr,d=R()\ndef ok():\n  x,y,z=R()\n  return 1 if (r-d+z)**2<=x*x+y*y<=(r-z)**2 else 0\nprint(sum(ok() for i in range(int(input()))))\n
from sys import stdin\n\n\nn, k = list(map(int, input().split()))\nour = list(map(int, input().split()))\ncap = set(map(int, input().split()))\nres = 0\nsum_b = sum(our)\nfor elem in cap:\n    sum_b -= our[elem - 1]\n    res += sum_b * our[elem - 1]\nfor i in range(len(our)):\n    if (i + 1) not in cap and (i + 1) % n + 1 not in cap:\n        res += our[i] * our[(i + 1) % n]\nprint(res)\n
import sys\ninput=sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    t = sorted(map(int,input().split()))\n    cur = [0]*(2*n)\n    for i in range(n):\n        low = high = t[i]\n        while low and cur[low]:\n            low -= 1\n        while cur[high]:\n            high += 1\n        if low > 0 and i:\n            lowsum = ind = j = 0\n            cur[low] = 1\n            while ind <= i:\n                if cur[j]:\n                    lowsum += abs(t[ind] - j)\n                    ind += 1\n                j += 1\n            cur[low] = 0\n            highsum = ind = j = 0\n            cur[high] = 1\n            while ind <= i:\n                if cur[j]:\n                    highsum += abs(t[ind] - j)\n                    ind += 1\n                j += 1\n            cur[high] = 0\n            if lowsum < highsum:\n                cur[low] = 1\n            else:\n                cur[high] = 1\n        else:\n            cur[high] = 1\n    ans = ind = j = 0\n    while ind < n:\n        if cur[j]:\n            ans += abs(t[ind] - j)\n            ind += 1\n        j += 1\n    print(ans)
# @author \n\nimport sys\n\nclass ABeautifulString:\n    def solve(self):\n\n        def get_not(arr):\n            for x in ['a', 'b', 'c']:\n                if x not in arr:\n                    return x\n\n            assert(False)\n\n        for _ in range(int(input())):\n            s = list(input())\n            n = len(s)\n            for i in range(n - 1):\n                if s[i] == s[i + 1] and s[i] != '?':\n                    print(-1)\n                    break\n            else:\n                x = 3 * ord('a') + 1 +2\n                for i in range(n):\n                    if s[i] == '?':\n                        if (i > 0 and i < n - 1):\n                            s[i] = get_not([s[i - 1], s[i + 1]])\n                        elif i == 0:\n                            s[i] = get_not([s[i + 1]])\n                        else:\n                            s[i] = get_not([s[i - 1]])\n\n                print(''.join(s))\n\nsolver = ABeautifulString()\ninput = sys.stdin.readline\n\nsolver.solve()\n
def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\ndef pre(x, y):\n    w = x * (y // 2) + (y % 2) * (x + 1) // 2\n    b = x * (y // 2) + (y % 2) * x // 2\n    assert w + b == x * y\n    return w\n\ndef count(x1, y1, x2, y2):\n    w = pre(x2, y2) + pre(x1 - 1, y1 - 1) - pre(x2, y1 - 1) - pre(x1 - 1, y2)\n    b = (x2 - x1 + 1) * (y2 - y1 + 1) - w\n    return w, b\n\nfor t in range(ii()):\n    n, m = mi()\n    x1, y1, x2, y2 = mi()\n    x3, y3, x4, y4 = mi()\n    w = pre(m, n)\n    b = m * n - w\n    # white spill\n    wc, bc = count(x1, y1, x2, y2)\n    w -= wc\n    b -= bc\n    w += (x2 - x1 + 1) * (y2 - y1 + 1)\n    # black spill\n    if max(x1, x3) <= min(x2, x4) and max(y1, y3) <= min(y2, y4):\n        x5 = max(x1, x3)\n        y5 = max(y1, y3)\n        x6 = min(x2, x4)\n        y6 = min(y2, y4)\n        w -= (x6 - x5 + 1) * (y6 - y5 + 1)\n        wc, bc = count(x5, y5, x6, y6)\n        w += wc\n        b += bc\n    wc, bc = count(x3, y3, x4, y4)\n    w -= wc\n    b -= bc\n    b += (x4 - x3 + 1) * (y4 - y3 + 1)\n    print(w, b)
import sys\n\nt = int(sys.stdin.readline())\n\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    intervals = [None]*n\n    for i in range(n):\n        intervals[i] = tuple([int(a) for a in sys.stdin.readline().split()])\n    intervals = list(zip(intervals, list(range(n))))\n    starts = sorted(intervals, key = lambda x: x[0][0])\n    ends   = sorted(intervals, key = lambda x: x[0][1])\n\n    connects = [0]*n\n    gaps = 0\n    covering = set()\n    atS = 0\n    atE = 0\n    # print(starts)\n    while atE<n:\n        # print("%d, %d"%(atS, atE))\n        # print(covering)\n        # print(connects)\n        if atS!=n and ends[atE][0][1]>=starts[atS][0][0]:\n            if len(covering)==1:\n               gap = list(covering)[0]\n               connects[gap]+=0.5\n            covering.add(starts[atS][1])\n            atS += 1\n            if len(covering)==1:\n               gap = list(covering)[0]\n               connects[gap]-=0.5\n\n        else:\n            if len(covering)==1:\n               gap = list(covering)[0]\n               connects[gap]-=0.5\n            covering.remove(ends[atE][1])\n            atE += 1\n            if len(covering)==1:\n               gap = list(covering)[0]\n               connects[gap]+=0.5\n            if len(covering)==0:\n                gaps += 1\n    connects = [int(a) for a in connects]\n    print(max(connects)+gaps)\n\n    \n\n        \n
import os\nfrom io import BytesIO\n\n# input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ndef check(x, p):\n    i = x - 1\n    while i > -1 and a[i] <= p:\n        p -= a[i]\n        if i >= k - 1:\n            i -= k\n        else:\n            i -= 1\n    return i <= -1\n\n\nfor _ in range(int(input())):\n    n, p, k = map(int, input().split())\n    a = sorted(map(int, input().split()))\n    dp = [1000000000] * (n + 1)\n    dp[0] = 0\n    ans = 0\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] + a[i - 1]\n        if i - k + 1 >= 0:\n            dp[i] = min(dp[i], dp[i - k] + a[i - 1])\n        if dp[i] <= p:\n            ans = i\n    print(ans)
class SortedList:\n    def __init__(self, iterable=[], _load=200):\n        """Initialize sorted list instance."""\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        """Build a fenwick tree instance."""\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        """Update `fen_tree[index] += value`."""\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        """Return `sum(_fen_tree[:end])`."""\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        """Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`)."""\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(list(range(len(_fen_tree).bit_length()))):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        """Delete value at the given `(pos, idx)`."""\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        """Return an index pair that corresponds to the first position of `value` in the sorted list."""\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        """Return an index pair that corresponds to the last position of `value` in the sorted list."""\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n        """Add `value` to sorted list."""\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        """Remove `value` from sorted list if it is a member."""\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        """Remove `value` from sorted list; `value` must be a member."""\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        """Remove and return value at `index` in sorted list."""\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        """Return the first index to insert `value` in the sorted list."""\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        """Return the last index to insert `value` in the sorted list."""\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        """Return number of occurrences of `value` in the sorted list."""\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        """Return the size of the sorted list."""\n        return self._len\n\n    def __getitem__(self, index):\n        """Lookup value at `index` in sorted list."""\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        """Remove value at `index` from sorted list."""\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        """Return true if `value` is an element of the sorted list."""\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        """Return an iterator over the sorted list."""\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        """Return a reverse iterator over the sorted list."""\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        """Return string representation of sorted list."""\n        return 'SortedList({0})'.format(list(self))\n\nn, q = list(map(int, input().split()))\np = SortedList(list(map(int,input().split())))\n\ngaps = SortedList()\nfor i in range(n - 1):\n    gaps.add(p[i] - p[i+1])\n\nout = []\ndef ret(p, gaps):\n    if len(p) > 1:\n        out.append(p[len(p) - 1] - p[0] + gaps[0])\n    else:\n        out.append(0)\n\nret(p, gaps)\nfor i in range(q):\n    t, x = list(map(int, input().split()))\n    if t == 1:\n        if len(p) > 0:\n            ind = p.bisect_left(x)\n            if ind == 0:\n                gaps.add(x - p[0])\n            elif ind == len(p):\n                gaps.add(p[len(p)-1] - x)\n            else:\n                gaps.remove(p[ind - 1] - p[ind])\n                gaps.add(p[ind - 1] - x)\n                gaps.add(x - p[ind])\n        p.add(x)\n    else:\n        p.remove(x)\n        if len(p) > 0:\n            ind = p.bisect_left(x)\n            if ind == 0:\n                gaps.remove(x - p[0])\n            elif ind == len(p):\n                gaps.remove(p[len(p)-1] - x)\n            else:\n                gaps.add(p[ind - 1] - p[ind])\n                gaps.remove(p[ind - 1] - x)\n                gaps.remove(x - p[ind])\n        \n            \n    ret(p, gaps)\n\nprint('\n'.join(map(str,out)))\n
import sys\n\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\n')\n\n\ndef solve():\n    n = ni()\n    s = nl()\n    dp = [1]*(n+1)\n    for i in range(n//2, 0, -1):\n        for j in range(2*i, n+1, i):\n            if s[i-1] < s[j-1]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    print(max(dp))\n    return\n\n# solve()\n\nT = ni()\nfor _ in range(T):\n    solve()\n
def solve():\n    n, k, z = map(int,input().split())\n    lst = list(map(int,input().split()))\n    maxsum = 0\n    for zz in range(z+1):\n        sum = lst[0]\n        maxn = lst[0] + lst[1]\n        if k-zz * 2 < 0:\n            break\n        for i in range(k-zz * 2):\n            if i + 2 < n:\n                maxn = max(maxn, lst[i+1] + lst[i+2])\n            sum += lst[i+1]\n        sum += maxn * zz\n        maxsum = max(maxsum,sum)\n    print(maxsum)\nfor i in range(int(input())):\n    solve()
import sys\ninput = sys.stdin.readline\nfor f in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    patties=[0]*n\n    mx=0\n    for p in a:\n        patties[p-1]+=1\n        mx=max(patties[p-1],mx)\n    mxs=0\n    for p in patties:\n        if p==mx:\n            mxs+=1\n    rest=n-mx\n    rest-=mxs\n    rest+=1\n    spots=mx-1\n    print(rest//spots)\n
from math import sqrt, log2\nfrom sys import stdin\nfrom bisect import bisect\nimport time\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n+1):\n        prime = True\n        for j in range(2, min(int(sqrt(i))+2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime: res.append(i)\n    return res\n\n\ndef count_pow_nums(n, p):  #don't count 1\n    top = int(pow(n, 1.0/p))\n    if pow(top+2, p) <= n:\n        return top+1\n    elif pow(top+1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top-1\n    else:\n        return top-2\nprimes = all_primes(64)\nnum_set=set()\nmax_n = 1000000000000000000\nfor pi in range(3, len(primes)):\n    p = primes[pi]\n    cnt = count_pow_nums(max_n, p)\n    for n in range(2, cnt+5):\n        sq2 = round(sqrt(n))\n        sq3 = round(pow(n, 1/3))\n        if sq2**2 != n and sq3**3 != n:\n            num = pow(n, p)\n            if num <= max_n:\n                num_set.add(num)\nnums = sorted(num_set)\nt = int(stdin.readline())\nfor i in range(t):\n    n = int(stdin.readline())\n    ans = n-1-count_pow_nums(n, 2)-count_pow_nums(n, 3)+count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    print(ans)\n
from math import *\nfrom collections import *\nfrom random import *\nfrom bisect import *\nimport sys\ninput=sys.stdin.readline\nt=int(input())\nwhile(t):\n    t-=1\n    n=int(input())\n    a=list(map(int,input().split()))\n    z=a.count(1)\n    if(z==n):\n        if(z%2):\n            print("First")\n        else:\n            print("Second")\n    else:\n        tu=0\n        for i in a:\n            if(i!=1):\n                break\n            else:\n                tu+=1\n        if(tu%2):\n            print("Second")\n        else:\n            print("First")\n
T = int(input())\n\nfor t in range(T):\n  n = int(input())\n  s = 1\n  nxt = 2\n  x = [1]\n  while n > s:\n    diff = n-s\n    if diff <= nxt:\n      x.append(diff)\n      break\n    x.append(nxt)\n    s += nxt\n    nxt *= 2\n  x.sort()\n  ans = ''\n  for i in range(len(x)-1):\n    v = x[i+1]-x[i]\n    ans += str(v)+' '\n  print(len(x)-1)\n  print(ans[:-1])\n
from math import gcd\n\n\ndef lcm(a, b): return a * b // gcd(a, b)\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    P = list(map(int, input().split()))\n    x, a = map(int, input().split())\n    y, b = map(int, input().split())\n    k = int(input())\n    P.sort(reverse=True)\n    l = 0\n    r = n + 1\n    while r - l > 1:\n        m = (l + r) // 2\n        g1 = m // lcm(a, b)\n        g2 = m // a - g1\n        g3 = m // b - g1\n        cnt = 0\n        for i in range(g1):\n            cnt += (x + y) * P[i] // 100\n        if x > y:\n            for i in range(g1, g1 + g2):\n                cnt += x * P[i] // 100\n            for i in range(g1 + g2, g1 + g2 + g3):\n                cnt += y * P[i] // 100\n        else:\n            for i in range(g1, g1 + g3):\n                cnt += y * P[i] // 100\n            for i in range(g1 + g3, g1 + g2 + g3):\n                cnt += x * P[i] // 100\n        if cnt >= k:\n            r = m\n        else:\n            l = m\n    if l == n:\n        print(-1)\n    else:\n        print(l + 1)
import sys\n\n\ndef main():\n    n, q, c = list(map(int, sys.stdin.readline().split()))\n    a = []\n    c += 1\n    for i in range(c):\n        t = []\n        for j in range(102):\n            t.append([0] * 102)\n        a.append(t)\n\n    for i in range(n):\n        x, y, s = list(map(int, sys.stdin.readline().split()))\n        for j in range(c):\n            a[j][x][y] += s\n            s += 1\n            if s >= c:\n                s = 0\n\n    for k in range(c):\n        for i in range(102):\n            for j in range(1, 102):\n                a[k][i][j] += a[k][i][j - 1]\n\n    alans = [0] * q\n    for i in range(q):\n        t, x1, y1, x2, y2 = list(map(int, sys.stdin.readline().split()))\n        ans = 0\n        t = t % c\n        for j in range(x1, x2 + 1):\n            ans += a[t][j][y2] - a[t][j][y1 - 1]\n\n        alans[i] = str(ans)\n    print("\n".join(alans))\n\n\nmain()\n
from math import *\n\nn, q = list(map(int, input().split()))\nafter = min(15, n)\nbefore = n - after\n\n\ndef calc(left, right):\n    return right * (right + 1) // 2 - left * (left - 1) // 2\n\n\ndef perm(i):\n    unused = [i + 1 for i in range(after)]\n    arr = []\n    for j in reversed(list(range(after))):\n        cur = i // factorial(j)\n        arr.append(unused[cur])\n        del unused[cur]\n        i -= cur * factorial(j)\n    return arr\n\n\np = perm(0)\nx = 0\n\nfor _ in range(q):\n    line = list(map(int, input().split()))\n\n    if len(line) == 3:\n        # type 1\n        l = line[1]\n        r = line[2]\n        res = 0\n        if l <= before:\n            if r <= before:\n                res += r * (r + 1) // 2\n            else:\n                res += before * (before + 1) // 2\n            res -= l * (l - 1) // 2\n            l = before + 1\n        if r > before:\n            res += sum(p[l-1-before:r-before]) + (r-l+1) * before\n\n        print(res)\n    else:\n        # type 2\n        x += line[1]\n        p = perm(x)\n
for _ in range(int(input())):\n    n, m, k = list(map(int, input().split()))\n    H = list(map(int, input().split()))\n    ans = 'YES'\n    for i in range(n - 1):\n        h1 = H[i]\n        h2 = H[i + 1]\n        if h1 >= h2:\n            if h2 >= k:\n                m += (h1 - h2) + k\n            else:\n                m += h1\n        else:\n            if h2 > h1 + m + k:\n                ans = 'NO'\n                break\n            elif h2 <= k:\n                m += h1\n            elif (h2 - h1) <= k:\n                m += k - (h2 - h1)\n            else:\n                m -= h2 - h1 - k\n    print(ans)\n
n, m = [int(x) for x in input().split()]\nlist1 = []\nlist2 = []\nfor i in range(n):\n    list1.append(input())\n\nfor j in range(m):\n    list2.append(input())\n\nlist3 = []\nfor i in range(n - m + 1):\n    y = ""\n    for j in range(m):\n        y += list1[j + i]\n    list3.append(y)\n\nlist4 = []\nfor i in range(n - m + 1):\n    y = ""\n    for j in range(m):\n        y += list2[j][i:i + m]\n    list4.append(y)\n\nfor i in list3:\n    if i in list4:\n        print(list3.index(i) + 1, list4.index(i) + 1)\n        quit()\n
import sys\nreadline = sys.stdin.readline\n\nT = int(readline())\nAns = [None]*T\nfor qu in range(T):\n    N, K = map(int, readline().split())\n    S = list(map(lambda x: ord(x)-97, readline().strip()))\n    S.sort()\n    if len(set(S[:K])) != 1:\n        Ans[qu] = chr(97+S[K-1])\n        continue\n    L = len(set(S[K:]))\n    if L == 1:\n        res = [S[0]] + [S[K]]*(-((K-N)//K))\n    else:\n        res = [S[0]] + S[K:]\n    Ans[qu] = ''.join(map(lambda x: chr(x+97), res))\n            \nprint('\n'.join(map(str, Ans)))
import sys\nN, Q = map(int, input().split())\nA = list(map(int, input().split()))\nSign = [0]*(3+10**5)\nSX = [tuple(sys.stdin.readline().split()) for _ in range(Q)]\nmini = 3 + 10**5\nSign = [0]*(3+10**5)\nkeep = 1\nfor (s, x) in SX[::-1]:\n    x = int(x)\n    ax = abs(x) + int((s == '>') ^ (x < 0))\n    sin = 1 if s == '<' else -1\n    if mini > ax:\n        t = sin*keep\n        for i in range(mini-1, ax-1, -1):\n            Sign[i] = t\n        mini = ax\n    keep *= (2*(s == '>') - 1) * (2*(0 < x) - 1)\nAns = [None]*N\nfor i, a in enumerate(A):\n    s = Sign[abs(a)]\n    if s == 0:\n        s = (2*(a > 0) - 1)*keep\n    Ans[i] = s*abs(a)\nprint(*Ans)
t = int(input())\n\nfor case in range(0,t):\n	x, n = map(int, input().split())\n	print(n+(x-1)*9)
t=int(input())\nfor tests in range(t):\n    print(int(input()))\n\n
class Solution:\n     def maximalRectangle(self, matrix):\n         """\n         :type matrix: List[List[str]]\n         :rtype: int\n         """\n         if not matrix or not matrix[0]:\n             return 0\n         n = len(matrix[0])\n         height = [0] * (n + 1)\n         ans = 0\n         for row in matrix:\n             for i in range(n):\n                 height[i] = height[i] + 1 if row[i] == '1' else 0\n             stack = [-1]\n             for i in range(n + 1):\n                 while height[i] < height[stack[-1]]:\n                     h = height[stack.pop()]\n                     w = i - 1 - stack[-1]\n                     ans = max(ans, h * w)\n                 stack.append(i)\n         return ans
class Solution:\n     def grayCode(self, n):\n         """\n         :type n: int\n         :rtype: List[int]\n         """\n         res = []\n         for i in range(1<<n):\n             res.append(i ^ i >>1)\n         return res\n
class Solution:\n     def generateMatrix(self, n):\n         """\n         :type n: int\n         :rtype: List[List[int]]\n         """\n         if n<1:\n             return []\n         left=0\n         right=n-1\n         up=0\n         bottom=n-1\n         self.matrix=[[0 for i in range(n)] for j in range(n)]\n         count=1\n         while left<=right:\n             if left<right:\n                 count=self.DrawRow(up,left,right,count)\n                 count=self.DrawCol(right,up,bottom,count)\n                 count=self.DrawRow(bottom,right,left,count)\n                 count=self.DrawCol(left,bottom,up,count)\n             else:\n                 count=self.DrawCol(left,up,bottom+1,count)\n                 break\n             up+=1\n             bottom+=-1\n             left+=1\n             right+=-1\n         return self.matrix\n \n     def DrawRow(self,row,start,end,value):\n         add=1\n         if start>end:\n             add=-1\n         for i in range(start,end,add):\n             self.matrix[row][i]=value\n             value+=1\n         return value\n     def DrawCol(self,col,start,end,value):\n         add=1\n         if start>end:\n             add=-1\n         for i in range(start,end,add):\n             self.matrix[i][col]=value\n             value+=1\n         return value
class Solution:\n     def uniquePathsWithObstacles(self, obstacleGrid):\n         """\n         :type obstacleGrid: List[List[int]]\n         :rtype: int\n         """\n         m = len(obstacleGrid) #row\n         n = len(obstacleGrid[0]) #col\n         path = [[0 for j in range(n)] for i in range(m)]\n         for i in range(m):\n             if obstacleGrid[i][0] == 0:\n                 path[i][0] = 1\n             else:\n                 break\n         for i in range(n):\n             if obstacleGrid[0][i] == 0:\n                 path[0][i] = 1\n             else:\n                 break\n         for i in range(1,m):\n             for j in range(1,n):\n                 if obstacleGrid[i][j] != 1:\n                     path[i][j] = path[i-1][j] + path[i][j-1]\n                 else:\n                     path[i][j] = 0\n         return path[m-1][n-1]\n
class Solution(object):\n     def canFinish(self, numCourses, prerequisites):\n         """\n         :type numCourses: int\n         :type prerequisites: List[List[int]]\n         :rtype: bool\n         """\n         graph = [[] for _ in range(numCourses)]\n         visited = [0 for _ in range(numCourses)]\n         # create graph\n         for pair in prerequisites:\n             x, y = pair\n             graph[x].append(y)\n         # visit each node\n         for i in range(numCourses):\n             if not self.dfs(graph, visited, i):\n                 return False\n         return True\n     \n     def dfs(self, graph, visited, i):\n         # if ith node is marked as being visited, then a cycle is found\n         if visited[i] == -1:\n             return False\n         # if it is done visted, then do not visit again\n         if visited[i] == 1:\n             return True\n         # mark as being visited\n         visited[i] = -1\n         # visit all the neighbours\n         for j in graph[i]:\n             if not self.dfs(graph, visited, j):\n                 return False\n         # after visit all the neighbours, mark it as done visited\n         visited[i] = 1\n         return True
class Solution:\n     def minPathSum(self, grid):\n         """\n         :type grid: List[List[int]]\n         :rtype: int\n         """\n         m, n = len(grid), len(grid[0])\n         dp = [0] + [float('inf')] * (n-1)\n         for i in range(m):\n             dp[0] = dp[0] + grid[i][0]\n             for j in range(1, n):\n                 dp[j] = min(dp[j], dp[j-1]) + grid[i][j]\n         return dp[-1]
class Solution:\n     def calculateMinimumHP(self, dungeon):\n         """\n         :type dungeon: List[List[int]]\n         :rtype: int\n         """\n         '''\n         逆回，当是小于等于0时，是相反数+1.   dp为到当前i,j只要需要的点数， 最小为1，保证 活着\n         \n         r,  c   r   ,c+1\n         r+1,c   r+1,c+1\n         \n         r,c处至少的点数 - r,c处惩罚点数  是  其下面和右面最少需要的点数，  也就是第33行\n         \n         '''\n         row = len(dungeon)\n         col = len(dungeon[0])\n         dp = [[0 for  c in range(col)] for r in range(row)]\n         if dungeon[-1][-1] <= 0:\n             dp[-1][-1] = -dungeon[-1][-1] + 1\n         else:\n             dp[-1][-1] = 1\n         for r in range(row-2,-1,-1):\n             dp[r][-1] = dp[r+1][-1]  - dungeon[r][-1]\n             if dp[r][-1] <= 0:\n                 dp[r][-1] = 1\n         for c in range(col-2,-1,-1):\n             dp[-1][c] = dp[-1][c+1]  - dungeon[-1][c]\n             if dp[-1][c] <= 0:\n                 dp[-1][c] = 1\n         for r in range(row-2,-1,-1):\n             for c in range(col-2,-1,-1):\n                 dp[r][c] = min(dp[r+1][c],dp[r][c+1]) - dungeon[r][c]\n                 if dp[r][c] <= 0:\n                     dp[r][c] = 1\n         return dp[0][0]\n
class Solution:\n     def subsets(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: List[List[int]]\n         """\n         subsets = [[]]\n         for v in nums:\n             extra = []\n             for s in subsets:\n                 extra.append(s+[v])\n             subsets += extra\n         return subsets
class Solution:\n     def spiralOrder(self, matrix):\n         """\n         :type matrix: List[List[int]]\n         :rtype: List[int]\n         """\n         result = []\n         if not matrix:\n             return result\n         top = left = 0\n         bottom, right = len(matrix) - 1, len(matrix[0]) - 1\n         while top < bottom and left < right:\n             for i in range(left, right):\n                 result.append(matrix[top][i])\n             for i in range(top, bottom):\n                 result.append(matrix[i][right])\n             for i in range(right, left, -1):\n                 result.append(matrix[bottom][i])\n             for i in range(bottom, top, -1):\n                 result.append(matrix[i][left])\n             left += 1\n             right -= 1\n             top += 1\n             bottom -= 1\n         if left == right and top == bottom:\n             result.append(matrix[left][top])\n         if left == right and top != bottom:\n             for i in range(top, bottom+1):\n                 result.append(matrix[i][left])\n         if left != right and top == bottom:\n             for i in range(left, right+1):\n                 result.append(matrix[top][i])\n         return result
class Solution(object):\n     def getSkyline(self, buildings):\n         """\n         :type buildings: List[List[int]]\n         :rtype: List[List[int]]\n         """\n         cp= set([b[0] for b in buildings]+[b[1] for b in buildings])\n         i, active, res = 0, [], []\n         for c in sorted(cp):\n             while i<len(buildings) and buildings[i][0]<=c:\n                 heapq.heappush(active, (-buildings[i][2], buildings[i][1]))\n                 i+=1\n \n             while active and active[0][1]<=c:\n                 heapq.heappop(active)\n \n             h= len(active) and -active[0][0]\n             if not res or h!=res[-1][1]:\n                 res.append([c, h])\n         return res\n \n
class Solution:\n     def permuteUnique(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: List[List[int]]\n         """\n         if not nums:\n             return []\n         \n         nums.sort()\n         n = len(nums)\n         res = [nums[:]]\n         i = n-1\n         while i > 0:\n             if nums[i-1] < nums[i]:\n                 j = n-1\n                 while nums[j] <= nums[i-1]:\n                     j -= 1\n                 nums[i-1], nums[j] = nums[j], nums[i-1]\n                 nums[i:] = sorted(nums[i:])\n                 res.append(nums[:])\n                 i = n-1\n             else:\n                 i -= 1\n         \n         return res\n         \n         \n         \n
class Solution:\n     def minimumTotal(self, triangle):\n         """\n         :type triangle: List[List[int]]\n         :rtype: int\n         """\n         length = len(triangle)\n         for i in range(length - 1, 0, -1):\n             for j in range(1, len(triangle[i])):\n                 if triangle[i][j] < triangle[i][j-1]:\n                     triangle[i-1][j-1] += triangle[i][j]\n                 else:\n                     triangle[i-1][j-1] += triangle[i][j - 1]\n         return triangle[0][0]
class Solution:\n     def subsetsWithDup(self, nums):\n         """\n         :type nums: List[int]\n         :rtype: List[List[int]]\n         """\n         def dfs(idx, path):\n             subsets.append(path)\n             \n             for i in range(idx, len(nums)):\n                 if i > idx and nums[i] == nums[i-1]:\n                     continue\n                 dfs(i + 1, path + [nums[i]])     \n         nums.sort()\n         subsets = []\n         dfs(0, [])\n         \n         return subsets\n         \n         \n         \n         \n             \n             \n                 \n         \n             \n                 \n
import numpy as np\nimport sys\ninput = sys.stdin.readline\n\nH,W = list(map(int,input().split()))\nS=np.array([list(input().rstrip("\n")) for _ in range(H)]) == '.'\n\nD = np.zeros((H,W),dtype=int)\nU = np.zeros((H,W),dtype=int)\nL = np.zeros((H,W),dtype=int)\nR = np.zeros((H,W),dtype=int)\n\n# 上下\nfor i in range(H):\n  U[i] = (U[i-1] + 1) * S[i]\n  D[-i-1] = (D[-i] + 1) * S[-i-1]\n\n# 左右\nfor i in range(W):\n  L[:,i] = (L[:,i-1] + 1) * S[:,i]\n  R[:,-i-1] = (R[:,-i] + 1) * S[:,-i-1]\n\nprint((np.max(U+D+L+R)-3))\n
import sys\nimport numpy as np\nfrom numba import njit\n\n\ndef input(): return sys.stdin.readline()\n\nN,Q = list(map(int,input().split()))\n\nC=np.array(input().split(), int)\n\n# Query取得-rightでソート\n# dtypeQuery = [("index", int), ("start", int), ("end", int)]\nqueries=np.empty((Q,2),int)\n# #rights=[[] for _ in range(N+1)]\n\nfor q in range(Q):\n	l,r=list(map(int,input().split()))\n	#queries[q] = (q,l,r)\n	queries[q][0] = l\n	queries[q][1] = r\n	#queries=np.sort(queries,order="end")\n\n#queries=np.array(sys.stdin.buffer.read().split(),int).reshape(Q,2)\n\norderByR=np.argsort(queries[:,1])\n\n# 各色の現在の一番右のindex\nmostRightColorIndex = np.zeros(N+1, int)\n# bit indexed tree\nbitArray=np.zeros(N+1,int)\n\n@njit\ndef main(N,Q,C,queries,orderByR,mostRightColorIndex,bitArray):\n\n	def add(itemCount, items, i, value):\n		while i <= itemCount:\n			items[i] += value\n			i += (i & (-i))\n\n	def sumFromStart(items, end):\n		summary = 0\n		i = end\n		while i > 0:\n			summary += items[i]\n			i -= (i & (-i))\n		return summary\n\n	def sum(items, start,end):\n		summary = sumFromStart(items, end) - sumFromStart(items, start-1)\n		return summary\n\n	# 答え配列\n	#ans=np.zeros(Q, int)\n	ans=[0]*Q\n	# 左からBITと現在色の更新をしながら、クエリのrightに到達したときにBITにクエリ発行する\n	qindex = 0\n\n	for n in range(N):\n		# 外側のループでは、全部の色をループ\n\n		if Q <= qindex:\n			break\n\n		if 0 < mostRightColorIndex[C[n]]:\n			# ループ中の場所の色のindexが既にある場合(=過去に、同じ色が登録されていた場合)\n			# 今回で、同じ色の一番右側の要素はループ中の要素になる\n			# 前登録したこの色の一番右のindexを一度BITから抜く(↓で再度登録される)\n			add(N,bitArray,mostRightColorIndex[C[n]], -1 )\n\n		# この要素の色の一番右のindexを、BITに登録\n		mostRightColorIndex[C[n]] = n+1\n		add(N,bitArray,n+1, 1)\n\n		# while qindex < Q and n+1 == queries[qindex][2]:\n		while qindex < Q and n+1 == queries[orderByR[qindex]][1]:\n			# 今のBITが次のクエリ発行するための状態(n==query.right)だったら、クエリ発行\n			tmpIndex = orderByR[qindex]\n			start = queries[tmpIndex][0]\n			end = queries[tmpIndex][1]\n			ans[tmpIndex]=sum(bitArray,start,end)\n			# print(tmpIndex,start,end,ans[tmpIndex])\n			qindex += 1\n\n	return ans\n\nfor a in main(N,Q,C,queries,orderByR,mostRightColorIndex,bitArray):\n	print(a)\n
#写経\n#https://atcoder.jp/contests/abc168/submissions/13414936\nfrom math import gcd\nfrom collections import Counter\nmod = 10**9 + 7\nN,*AB = map(int,open(0).read().split())\n\ndef std(a,b):\n    """\n    a,bを既約にする\n    """\n    if a == 0:\n        return(0,int(b!=0))\n    g = gcd(a,b)\n    a,b = a// g, b//g\n    return(a,b) if a > 0 else (-a,-b)\n\nC = Counter(std(a, b) for a, b in zip(*[iter(AB)] * 2))\ndef resolve():\n    ans = 1\n    cnt = 0\n    for (a,b), v in C.items():\n        if b > 0:\n            if (b,-a) in C:\n                ans *= -1 + pow(2,v,mod) + pow(2,C[(b,-a)], mod) #仲の悪い組み合わせが一緒に入らないように，別々に入れるか入れないかを判定 空集合は共通しているので引く\n                ans %= mod\n            else:\n                cnt += v\n        elif (-b,a) not in C:\n            cnt += v\n    ans *= pow(2,cnt,mod)\n    ans += C[(0,0)] - 1\n    print(ans%mod)\nresolve()
import numpy as np\n\nk, q = map(int, input().split())\nd = np.array(list(map(int, input().split())))\n\nfor i in range(q):\n  n, x, m = map(int, input().split())\n  mod_d = d % m\n  modsum_d = mod_d.cumsum()\n  _q, _m = divmod(n - 1, k)\n  \n  ans = modsum_d[k - 1] * _q\n  if _m > 0:\n    ans += modsum_d[_m - 1]\n  ans = n - 1 - (ans + x % m) // m - np.count_nonzero(mod_d == 0) * _q\n  if _m > 0:\n    ans -= np.count_nonzero(mod_d[0 : _m] == 0)\n  print(ans)
import sys\n \ninput = sys.stdin.readline\nN = int(input())\nP = list(map(int, input().split()))\n \ntarget = 1\nans = []\ni = 0\nwhile i < N: \n    if P[i] == target:\n        for j in range(i, target-1, -1):\n            P[j], P[j-1] = P[j-1], P[j]\n            ans.append(j)\n    \n        target = i+1\n        # print("i", i, "target", target)\n    i += 1\n \n# print(P)\nif len(ans) != N-1:\n    print(-1)\n    return\nfor i in range(N):\n    if P[i] != i+1:\n        print(-1)\n        return\n \nprint(*ans, sep="\n")
s=input()\nn=len(s)\np=0\nfor i in range(n):\n  if s[i]=='p':\n    p+=1\nprint(n//2-p)
from collections import deque\n\nN, M = map(int, input().split())\nL = [list(map(int, input().split())) for _ in range(M)]\nlink = [[] for _ in range(N)]\n\nfor i in range(M):\n    link[L[i][0]-1].append(L[i][1]-1)\n    link[L[i][1]-1].append(L[i][0]-1)\n\nchecked = [-1 for _ in range(N)]\nchecked[0] = 0\nd = deque([0])\nwhile d:\n    now = d.popleft()\n    for i in range(len(link[now])):\n        if checked[link[now][i]] == -1:\n            checked[link[now][i]] = now + 1\n            d.append(link[now][i])\n\n\nflag = False\nfor i in range(1, N):\n    if checked[i] == -1:\n        flag = True\n        break\n\nif flag:\n    print('No')\nelse:\n    print('Yes')\n    for i in range(1, N):\n        print(checked[i])
import copy\nh,w =list(map(int,input().split()))\n\ns = [[]*w for _ in range(h)]\nwhite =0\nfor i in range(h):\n    t = input()\n    for j in range(w):\n        if t[j] == ".":\n            white += 1\n            s[i].append(10**5)\n        elif t[j] == "#":\n            s[i].append(t[j])\nnow = [0,0]\nsteps =[]\nsteps.append(now)\ndirection = []\ns[0][0] =0\na = [2]\nwhile len(steps) >0:\n    now = copy.copy(steps[0])\n    if s[now[0]][now[1]] =="#":\n        continue\n    for k in [[0,1],[1,0],[-1,0],[0,-1]]:\n        now = copy.copy(steps[0])\n        if now[0] + k[0] >=0 and now[0] + k[0] < h:\n            now[0] += k[0]\n            if now[1] + k[1] >=0 and now[1] + k[1] <w:\n                now[1] += k[1]\n                if s[now[0]][now[1]] == 10**5:\n                    if not [now[0],now[1]] in steps:\n                        steps.append([now[0],now[1]])\n            else:\n                continue\n        else:\n            continue\n    # if s[steps[0][0]][steps[0][1]] ==0:\n    #     steps.pop(0)\n    #     continue\n    if s[steps[0][0]][steps[0][1]] >10**4:\n        direction =[]\n        for l in [[0,1],[1,0],[-1,0],[0,-1]]:\n            if steps[0][0]+l[0]>=0 and steps[0][0]+l[0]<h and steps[0][1]+l[1]< w and steps[0][1]+l[1] >=0 and s[steps[0][0]+l[0]][steps[0][1]+l[1]] != "#":\n                s[steps[0][0]][steps[0][1]]=min(s[steps[0][0]+l[0]][steps[0][1]+l[1]]+1,s[steps[0][0]][steps[0][1]])\n    steps.pop(0)\nif s[h-1][w-1] == "#" or s[h-1][w-1] == 10**5:\n    print((-1))\nelse:\n    print((white-1 - s[h-1][w-1]))\n\n\n\n\n\n\n\n
n=int(input())\na=list(map(int,input().split()))\nnum=[0]*100001\nfor i in a:\n  num[i]+=1\nx=0\nfor i in num:\n  if i<=0:\n    continue\n  elif i%2==0:\n    n-=i\n    x+=1\n  else:\n    n-=i-1\n    \nif x%2:\n  x-=1\n  \nprint(n+x)
n = int(input())\na = []\nb = []\nfor i in range(n):\n  x,y = list(map(int, input().split()))\n  a.append(x+y)\n  b.append(x-y)\na.sort()\nb.sort()\n\nans = a[-1]-a[0]\nc = b[-1]-b[0]\nprint((max(ans,c)))\n
from heapq import heappop, heappush\nn , q = map(int,input().split())\nenzi = [[0,0] for i in range(n)]\nyouti = [[] for i in range(2*10**5)]\nsaikyo = [0 for i in range(2*10**5)]\nans = []\n\nfor i in range(n):\n    a , b = map(int,input().split())\n    enzi[i] = [a,b-1]\n    heappush(youti[b-1],(-a,i))\n\nfor i in range(2*10**5):\n    if youti[i]:\n        now = heappop(youti[i])\n        saikyo[i] = -now[0]\n        heappush(ans,(-now[0],i))\n        heappush(youti[i],now)\n\nfor _ in range(q):\n    c , d = map(lambda x:int(x)-1,input().split())\n    heappush(youti[d],(-enzi[c][0],c))\n    moto = enzi[c][1]\n    enzi[c][1] = d\n    \n    while True:\n        if youti[moto]:\n            now = heappop(youti[moto])\n            if enzi[now[1]][1] == moto:\n                if saikyo[moto] != -now[0]:\n                    saikyo[moto] = -now[0]\n                    heappush(ans,(-now[0],moto))\n                heappush(youti[moto],now)\n                break\n        else:\n            saikyo[moto] = 0\n            break\n    while True:\n        now = heappop(youti[d])\n        if enzi[now[1]][1] == d:\n            if saikyo[d] != -now[0]:\n                saikyo[d] = -now[0]\n                heappush(ans,(-now[0],d))\n            heappush(youti[d],now)\n            break\n    \n    while True:\n        now = heappop(ans)\n        if saikyo[now[1]] == now[0]:\n            print(now[0])\n            heappush(ans,now)\n            break
x,y=map(int, input().split())\nA=list(map(int, input().split()))\nB=list(map(int, input().split()))\nA,B=sorted(A)[::-1],sorted(B)[::-1]\nmod=10**9+7\nX,Y=0,0\nfor i in range(x):\n  d=A[i]*(x-i)-A[i]*(i)-A[i]\n  X+=d\n  X%=mod\nfor i in range(y):\n  d=B[i]*(y-i)-B[i]*(i)-B[i]\n  Y+=d\n  Y%=mod\nprint(X*Y%mod)
class UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n + 1)]\n        self.rank = [0] * (n + 1)\n        self.size = [1] * (n + 1)\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def same_check(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            if self.same_check(x, y) != True:\n                self.size[y] += self.size[x]\n                self.size[x] = 0\n            self.par[x] = y\n        else:\n            if self.same_check(x, y) != True:\n                self.size[x] += self.size[y]\n                self.size[y] = 0\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def siz(self, x):\n        x = self.find(x)\n        return self.size[x]\n\n\nN = int(input())\nUF = UnionFind(N)\nX = []\nY = []\nBranch = []\nfor i in range(N):\n    x, y = list(map(int, input().split()))\n    X.append((x, i))\n    Y.append((y, i))\nX.sort()\nY.sort()\nfor X1, X2 in zip(X, X[1:]):\n    Branch.append((X2[0] - X1[0], X1[1], X2[1]))\nfor Y1, Y2 in zip(Y, Y[1:]):\n    Branch.append((Y2[0] - Y1[0], Y1[1], Y2[1]))\nBranch.sort()\n\n# 負のとき size, 非負のとき parent\npar = [-1] * N\nans = 0\nfor c, a, b in Branch:\n    if N <= 1:\n        break\n    if not UF.same_check(a, b):\n        UF.union(a, b)\n        ans += c\n        N -= 1\n\nprint(ans)\n\n
import sys\nsys.setrecursionlimit(10**7)\n \nN, Q = list(map(int, input().split()))\nroot = [[] for _ in range(N)]\nans = [0]*N\n \nfor _ in range(N-1):\n  a,b=list(map(int, input().split()))\n  a,b=a-1,b-1\n  root[a].append(b)\n  root[b].append(a)\n\nfor _ in range(Q):\n  p,x=list(map(int, input().split()))\n  ans[p-1]+=x\n  \nvisited=[False]*N\ndef dfs(v):\n  visited[v] = True\n  for go in root[v]:\n    if visited[go]:\n      continue\n    ans[go] += ans[v]\n    dfs(go)\n\ndfs(0)\nprint((*ans))\n
import numpy as np\n\nN, *AB = list(map(int, open(0).read().split()))\nmin_med = np.median([a for a in AB[::2]])\nmax_med = np.median([b for b in AB[1::2]])\nif N % 2:\n    print((int(max_med - min_med) + 1))\nelse:\n    print((int(max_med * 2 - min_med * 2) + 1))\n
n = int(input())\nA = list(map(int, input().split()))\nA.sort(reverse=True)\nA2 = [A[0]]\nfor a in A[1:]:\n    A2.extend([a, a])\nans = 0\nfor a in A2[:n-1]:\n    ans += a\nprint(ans)
from functools import reduce\ndef comb(n, max_k, mod):\n    """\n    (n,k) := n個からk個選ぶ組み合わせ\n    k = 0~max_Kまでを計算して返す\n    """\n    res = [1]*(max_k+1)\n    t = 1\n    for i in range(max_k+1):\n        res[i] *= t\n        t *= n-i\n        t %= mod\n\n    n = reduce(lambda x,y: (x*y)%mod, range(1,max_k+1), 1)\n    n = pow(n,-1, mod)\n\n    for i in reversed(range(max_k+1)):\n        res[i] *= n\n        res[i] %= mod\n        n *= i\n        n %= mod\n    return res\n\nMOD = 10**9+7\n\nK = int(input())\nN = len(input())\n\nres = 0\nx = 1\n\ncom = comb(N+K, K, MOD)\n\nfor c in com:\n    res += x*c\n    res %= MOD\n    x *= 25\n    x %= MOD\n\nprint(res)
import bisect\n\n_ = input()\na = sorted(map(int, input().split()))\n\nn = a[-1]\n\nm = n / 2\nb = bisect.bisect(a, m)\ns = a[b - 1]\nt = a[b]\nif m - s <= t - m:\n    print(n, s)\nelse:\n    print(n, t)
from collections import defaultdict\ndef main():\n    n, k = map(int, input().split(" "))\n    a = list(map(int, input().split(" ")))\n    s = []\n    ord = [-1]*(n+1)\n    u = 1\n    while ord[u] == -1:\n        ord[u] = len(s)\n        s.append(u)\n        u = a[u-1]\n    l = len(s) - ord[u]\n    if k < ord[u]:\n        print(s[k])\n    else:\n        print(s[(k-ord[u])%l+ord[u]])\n\n'''\ndef main():\n    n, k = map(int, input().split(" "))\n    a = list(map(lambda i: int(i)-1, input().split(" ")))\n    s = [0]\n    d = defaultdict(lambda:0)\n    x = a[0]\n    for i in range(n):\n        s.append(x)\n        x = a[x]\n\n    bb=None\n    for i in range(n):\n        d[s[i]] += 1\n        if d[s[i]] ==2:\n            bb=s[i]\n            break\n\n    cc = s.index(bb)\n    s[cc]=-1\n    dd = s.index(bb)\n    loop_len = dd-cc\n    s[cc]=s[dd]\n        \n    if bb ==None or k < cc:\n        print(s[k]+1)\n    else:\n        y = (k-cc) % loop_len\n        print(s[y+cc]+1)\n'''\ndef __starting_point():\n    main()\n__starting_point()
k=int(input())\na=0\nb=1\nfor i in range(k):\n  a+=b\n  print(a)\n  if b<(a+b)/sum(map(int,str(a+b))):\n    b*=10
Q = int(input())\nqs = [input().split() for i in range(Q)]\n\nimport heapq\nclass Heapq:\n    def __init__(self, arr, desc=False):\n        if desc:\n            arr = [-a for a in arr]\n        self.sign = -1 if desc else 1\n        self.hq = arr\n        heapq.heapify(self.hq)\n\n    def pop(self):\n        return heapq.heappop(self.hq) * self.sign\n\n    def push(self, a):\n        heapq.heappush(self.hq, a * self.sign)\n\n    def top(self):\n        return self.hq[0] * self.sign\n\n    def size(self):\n        return len(self.hq)\n\nlq = Heapq([], True)\nrq = Heapq([], False)\n\nofs = 0\nfor q in qs:\n    if q[0] == '2':\n        print(lq.top(), ofs)\n        continue\n    _,a,b, = q\n    a,b = int(a),int(b)\n    ofs += b\n    lq.push(a)\n    rq.push(a)\n    if lq.top() > rq.top():\n        l,r = lq.pop(), rq.pop()\n        ofs += abs(l-r)\n        lq.push(r)\n        rq.push(l)
def main():\n    import sys\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n\n    N = int(input())\n    S = list(map(int, input().split()))\n    T = list(map(int, input().split()))\n    U = list(map(int, input().split()))\n    V = list(map(int, input().split()))\n\n    range_N = list(range(N))\n    ans = [[0]*N for _ in range_N]\n    # 論理積\n    for i in range_N:\n        if S[i] == 0:\n            for j in range_N:\n                ans[i][j] = ans[i][j] | U[i]\n        if T[i] == 0:   \n            for j in range_N:\n                ans[j][i] = ans[j][i] | V[i]\n    for i in range_N:\n        for j in range_N:\n            if (U[i] & V[j]):\n                ans[i][j] = ans[i][j] | (U[i] & V[j])\n\n    # 論理和\n    for x in range_N:\n        if S[x] == 0:\n            continue\n        x_sum = ans[x][0]\n        for y in range_N:\n            x_sum = x_sum | ans[x][y]\n        if x_sum == U[x]:\n            continue\n        up = U[x] - x_sum\n        for y in range_N:\n            if T[y]:\n                continue\n            y_mul = ans[0][y]\n            for i in range_N:\n                if i == x:\n                    continue\n                y_mul = y_mul & ans[i][y]\n            up_y = (~y_mul) & up\n            ans[x][y] += up_y\n            up -= up_y\n            if up == 0:\n                break\n\n    for y in range_N:\n        if T[y] == 0:\n            continue\n        y_sum = ans[0][y]\n        for x in range_N:\n            y_sum = y_sum | ans[x][y]\n        if y_sum == V[y]: \n            continue\n        up = V[y] - y_sum\n        for x in range_N:\n            if S[x]:\n                continue\n            x_mul = ans[x][0]\n            for j in range_N:\n                if y == j:\n                    continue\n                x_mul = x_mul & ans[x][j]\n            up_x = (~x_mul) & up\n            ans[x][y] += up_x\n            up -= up_x\n            if up == 0:\n                break\n\n    # チェック\n    for i in range_N:\n        check_xs = ans[i][0]\n        check_ys = ans[0][i]\n        check_xm = ans[i][0]\n        check_ym = ans[0][i]\n        for j in range_N:\n            check_xs = check_xs | ans[i][j]\n            check_ys = check_ys | ans[j][i]\n            check_xm = check_xm & ans[i][j]\n            check_ym = check_ym & ans[j][i]\n        if (S[i] and U[i] != check_xs) \\n        or (T[i] and V[i] != check_ys) \\n        or (S[i] == 0 and U[i] != check_xm) \\n        or (T[i] == 0 and V[i] != check_ym) :\n            print((-1))\n            return       \n\n    for i in range_N:\n        print((*ans[i]))\n\nmain()\n
from bisect import bisect_right\n\n\ndef main():\n    n = int(input())\n    a = [int(input()) for _ in range(n)]\n    a.reverse()\n    lis = [a[0]]\n    for i in range(1, n):\n        if a[i] >= lis[-1]:\n            lis.append(a[i])\n        else:\n            lis[bisect_right(lis, a[i])] = a[i]\n    print((len(lis)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
\n\nimport heapq\n\n\ndef contig(p, A):\n ans = []\n n = len(A)\n for i in range(n):\n  for j in range(i, n):\n   if i == j:\n    ans.append(p[i])\n   else:\n    ans.append(p[j] - p[i])\n return ans\n\n\ndef solver(N, K, A):\n a = []\n prefix = [A[0]]\n for x in A[1:]:\n  prefix.append(prefix[-1] + x)\n\n return heapq.nlargest(K, contig(prefix, A))\n\n\ndef __starting_point():\n N, K = list(map(int, input().split()))\n A = list(map(int, input().split()))\n\n print(' '.join([str(i) for i in solver(N, K, A)]))\n\n__starting_point()
import sys\n\nprint(1)\nprint("3 1 1 2")\nprint("3 3 3 4")\nsys.stdout.flush()\n\nd = int(input())\nif d==0:\n    print(2)\n    print(5)\n    sys.stdout.flush()\n    \nelif d==2:\n    print(2)\n    print(1)\n    sys.stdout.flush()\n    \nelif d==1:\n    print(2)\n    print(2)\n    sys.stdout.flush()\n    \nelif d==-2:\n    print(2)\n    print(3)\n    sys.stdout.flush()\nelse:\n    print(2)\n    print(4)            \n    sys.stdout.flush()
import sys\nimport math\n\ndef main(arr):\n ans=2\n if len(arr)<2:\n  return 4-len(arr)\n set_arr=set(arr)\n for i in range(len(arr)):\n  for j in range(i+1,len(arr)):\n   need=2\n   x1,y1=arr[i]\n   x2,y2=arr[j]\n   xc = (x1 + x2)/2  ;  yc = (y1 + y2)/2  ;    \n   xd = (x1 - x2)/2  ;  yd = (y1 - y2)/2  ;    \n\n   x3 = xc - yd  ;  y3 = yc + xd;    \n   x4 = xc + yd  ;  y4 = yc - xd;    \n   if (x3,y3) in set_arr:\n    need-=1 \n   if (x4,y4) in set_arr:\n    need-=1\n   ans=min(ans,need)\n return ans\n\narr=[]\nfor i in range(int(input())):\n arr.append(tuple(map(int,input().split())))\nprint(main(arr))\n \n \n    \n\n
\n\ntry:\n n,k = map(int,input().split())\n x = [int(input()) for _ in range(n)]\n k = k//2\n dp = [0]*(k+1)\n for i in range(k+1):\n  dp[i] = [0]*n\n #print(dp)\n for i in range(1,k+1):\n  #print("*",dp[i-1][0])\n  diff = (-1)*x[0]\n  for j in range(1,n):\n   diff = max(dp[i-1][j]-x[j],diff)\n   dp[i][j] = max(dp[i][j-1],diff+x[j])\n print(dp[k][n-1])\nexcept:\n pass
# cook your dish here\nn=int(input())\ns=list(map(int,input().split()))\nsu=0\nfor i in s:\n    su+=i\n\nan=(n)*(n+1)//2\nif(an==su):\n    print("YES")\n\nelse:\n    print("NO")\n
j,s,m=map(int,input().split())\nif ((m-j)//s)%2!=0:\n    print('Unlucky Chef')\nelse:\n    print('Lucky Chef')\n    \n        
# cook your dish here\nn=int(input())\ncount=[]\na=[int(i) for i in input().split()]\nb=[int(i) for i in input().split()]\nstart=0\nfor i in range(n):\n    if a[i]>=start:\n        count.append(i)\n        start=b[i]\nprint(*count,sep=" ")
from collections import defaultdict as dd\n\ndef find(a, b):\n n = len(a)\n m = len(b)\n\n dp = [[0]*(m+1) for i in range(n+1)]\n\n for i in range(n-1,-1, -1):\n  for j in range(m-1, -1, -1):\n   if a[i] == b[j]:\n    dp[i][j] = dp[i+1][j+1] + 1\n\n mx = dd(int)\n ans = 0\n for i in range(n-1, -1, -1):\n  for j in range(m-1, -1, -1):\n   a = mx[(i+1, j)]\n   b = mx[(i, j+1)]\n   mx[(i, j)] = max([dp[i][j], a, b])\n\n for i in range(n):\n  for j in range(m):\n   c = dp[i][j]\n   nxt = mx[(i+c, j+c)]\n   cur = c + nxt\n   ans = max(ans, cur)\n   \n return 2*ans\nfor case in range(int(input())):\n a, b = input().split()\n b = b[-1::-1]\n\n ans = find(a, b)\n print(ans)\n
n,m = map(int,input().split())\nbox = list(map(int,input().split()))\nmularr = []\nqueries = list(map(int,input().split()))\nqm = max(queries)\ncnt = 0\nmularr.append([box[0],1])\ncandy = box[0]\nfor b in box[1:]:\n    if b == 1:\n     mularr[-1][1] +=1\n    else:\n     candy *= b\n     mularr.append([candy,1])\n    if qm <= candy:\n     break\n#print(mularr)\nfor query in queries:\n    cnt = n\n    test = query\n    test-=1\n    for k,v in mularr:\n     #print(mularr[m],test)\n     add = (test//k)*v\n     cnt+=add\n    print(cnt)
# cook your dish here\ntry:\n X=int(input())\n m=1000000007\n a=X+X**(2)+X**(3)\n a=a%m\n print(a)\nexcept:\n pass
# cook your dish here\nfrom sys import stdin, stdout\nimport math\n# from itertools import permutations, combinations\nfrom collections import defaultdict,deque\n# import bisect\n# import heapq as hq\n\ndef bfs(d,n,d1,s):\n high=[-1 for x in range(n+1)]\n q=deque([0])\n high[0]=0\n while q:\n  node=q.popleft()\n  for x in d1[int(s[node])]:\n   if high[x]==-1:\n    high[x]=high[node]+1\n    q.append(x)\n  for x in d[node]:\n   if high[x]==-1:\n    high[x]=high[node]+1\n    q.append(x)\n print(high[n])\ndef main():\n try:\n  s=stdin.readline().strip()\n  n=len(s)\n  d=defaultdict(list)\n  \n  for i in range(1,len(s)):\n   d[int(s[i])].append(i)\n\n  high=[0]*(n+1)\n  visit=[False] *(n+1)\n  q=deque([0])\n  while q:\n   node=q.popleft()\n   if node==n-1:\n    break\n   for x in d[int(s[node])]:\n    if visit[x]==False:\n     visit[x]=True\n     q.append(x)\n     high[x]=high[node]+1\n   d[int(s[node])].clear()\n   if node-1>=0 and not visit[node-1]:\n    visit[node-1]=True\n    q.append(node-1)\n    high[node-1]=high[node]+1\n   if node+1<n and not visit[node+1]:\n    visit[node+1]=True\n    q.append(node+1)\n    high[node+1]=high[node]+1\n  print(high[n-1])\n except:\n  pass\n \ndef add(a, b, c):\n res = a + b;\n if (res >= c):return res - c;\n else:return res;\ndef mod(a, b, c):\n res = a * b\n if (res >= c):return res % c\n else:return res\ndef gcd(a, b):\n while b:\n  a, b = b, a % b\n return a\ndef lcm(a, b):\n w = a // gcd(a, b)\n return w * b\ndef expo(a, b):\n x, y = 1, a\n while (b > 0):\n  if (b & 1):\n   x = x * y\n  y = y * y\n  b >>= 1\n return x\ndef power(a, b, m):\n x, y = 1,\n while (b > 0):\n  if (b & 1):x = mod(x, y, m)\n  y = mod(y, y, m)\n  b >>= 1\n return x\ndef L():\n return list(map(int, stdin.readline().split()))\ndef In():\n return list(map(int, stdin.readline().split()))\ndef I():\n return int(stdin.readline())\nP = 1000000007\n\ndef __starting_point():\n main()\n\n\n\n__starting_point()
n = input()\nans = 0\nfor i in n:\n    ans = ans ^int(i)\nif ans:\n    print("Inclusive")\nelse:\n    print("Exclusive")
import sys\nn,m=map(int,input().split())\nred=[]\n\nfor i in range(n):\n    a,b=map(int,input().split())\n    red.append(a*b)\n\nd={}\nfor i in range(m):\n    a,b=map(int,input().split())\n    p=a*b\n    if p in d:\n        d[p]+=1\n    else:\n        d[p]=1\n\nan=0\nfor i in range(n):\n    if red[i] in d and d[red[i]]>0:\n        an+=1\n        d[red[i]]-=1\n    \nprint(an)
# cook your dish here\nn=int(input())\nl=[]\nfor i in range(n):\n l.append(input())\nm=int(input())\ns=input()\nc=0\nres=[s[i:j] for i in range(len(s)) for j in range(i+1,len(s)+1)]\nres=list(dict.fromkeys(res))\nfor i in res:\n if i in l:\n  c=c+1\nprint(c)\n
s = input()\nL = []\n\nfor i in s:\n L.append(i)\n\nvowels = ['A', 'E', 'I', 'O', 'U']\n\nflag = 0\nfor i in range(len(L)-2):\n if (L[i] in vowels) and (L[i+1] in vowels) and (L[i+2] in vowels):\n  flag = 1\n  break\nif flag == 1:\n while 'A' in L:\n  L.remove('A')\n\n while 'E' in L:\n  L.remove('E')\n\n while 'I' in L:\n  L.remove('I')\n\n while 'O' in L:\n  L.remove('O')\n\n while 'U' in L:\n  L.remove('U')\n\n newL = []\n\n for i in L:\n  if i not in newL:\n   newL.append(i)\n\n if len(newL) >= 5:\n  print("GOOD")\n else:\n  print(-1)\nelse:\n print(-1)
# cook your dish here\n\nimport operator\n\nno_seq = int(input().strip())\nseqs = []\nfor idx in range(no_seq):\n    input_now = input().strip().split(" ")\n    seqs.append([int(input_now[0]), int(input_now[1])])\n\nseqs.sort(key=operator.itemgetter(0))\ncurr = seqs[0]\nanswer = 1\nfor i in range(1, no_seq):\n    if curr[1] < seqs[i][0]:\n        answer += 1\n        curr = seqs[i]\n    else:\n        curr[0] = seqs[i][0]\n        curr[1] = min(curr[1], seqs[i][1])\n\nprint(answer)\n
from sys import maxsize \n\n# Function to find the maximum contiguous subarray \n# and print its starting and end index \ndef maxSubArraySum(a,size): \n\n	max_so_far = -maxsize - 1\n	max_ending_here = 0\n	start = 0\n	end = 0\n	s = 0\n\n	for i in range(0,size): \n\n		max_ending_here += a[i] \n\n		if max_so_far < max_ending_here: \n			max_so_far = max_ending_here \n			start = s \n			end = i \n\n		if max_ending_here < 0: \n			max_ending_here = 0\n			s = i+1\n	return max_so_far,start,end\n\n# 	print("Maximum contiguous sum is %d"%(max_so_far)) \n# 	print("Starting Index %d"%(start)) \n# 	print("Ending Index %d"%(end)) \n    # return max_so_far,start,end\n    \n\nn = int(input())\nlst = list(map(int,input().split()))\nt_lst = lst[:]\naaa = abs(-n//2)\nmaxi,start,end = maxSubArraySum(lst[0:aaa],aaa)\n# lst = lst[0:start]+lst[end+1:]\nl = lst[aaa:]\nM,st,en = maxSubArraySum(l,len(l))\nx = maxi+M\n\nmaxi,start,end = maxSubArraySum(t_lst,n)\nt_lst = t_lst[0:start]+t_lst[end+1:]\nM,st,en = maxSubArraySum(t_lst,len(t_lst))\ny = maxi+M\n\nprint(max(x,y))
n, b = list(map(int, input().split()))\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\nans = 0\nfor i in range(b):\n    ans += min(x[i]-1, n-x[i]) + min(y[i]-1, n-y[i])\nprint(ans)
one = int(input())\ntwo = int(input())\nelement = input()\nif element == '/':\n print(one / two)\nelif element == '*':\n print(one * two)\nelif element == '-':\n print(one - two)\nelif element == '+':\n print(one + two)
# cook your dish here\nt = int(input())\nwhile t>0:\n x = input().split()\n n = int(x[0])\n k = int(x[1])\n ans = 0\n for i in range(n):\n  if (k&(1<<i))!=0:\n   ans += 2**(n-i-1)\n print(ans, end="\n") \n t -= 1
def f(n,k):\n    s=[]\n    row=[[0 for i in range(n)] for i in range(n)]\n    col=[[0 for i in range(n)] for i in range(n)]\n    flag=0\n    for i in range(n):\n        s.append(list(input().strip()))\n    for i in range(n):\n        for j in range(n):\n            if s[i][j]=="X":\n                s[i][j]=1\n            elif s[i][j]==".":\n                s[i][j]=0\n                flag=1\n            else:\n                s[i][j]=-1\n            row[i][j]=col[j][i]=s[i][j]\n            \n    for i in range(n):\n        temp=[]\n        for j in range(n-k+1):\n            temp=s[i][j:j+k]\n            if sum(temp)>=k-1:\n                return True\n            temp=col[i][j:j+k]\n            if sum(temp)>=k-1:\n                return True\n    d1=[0 for i in range(n)]\n    d2=[0 for i in range(n)]\n    for i in range(n):\n        d1[i]=s[i][i]\n        d2[i]=s[i][n-i-1]\n    for i in range(n-k+1):\n        if sum(d1[i:i+k])>=k-1 or sum(d2[i:i+k])>=k-1:\n            return True\n    return False\nt=int(input())\nfor i in range(t):\n    n,k=list(map(int,input().split()))\n    if f(n,k):\n        print("YES")\n    else:\n        print("NO")
########################################################\n################# Template #############################\nimport sys\nimport math\ndef Int(): return int(input())\ndef Str(): return input()\ndef Ints(): return list(map(int,input().split(" ")))\ndef int_arr(): return list(map(int,input().strip().split(" ")))\ndef str_arr(): return list(map(str,input().split(" ")))\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n#########################################################\n#vsInput()\ndef strings(s):\n    n=len(s)\n    count=0\n    for i in range(n//2):\n        if s[i]!=s[n-1-i]:\n            count=1\n            break\n    return count==0\n    \nn=int(input())\ns=input()\npalindrome = ""\nfor i in range(n-1):\n    for j in range(i+1,n+1):\n        nextstring = s[i:j]\n        if strings(nextstring) and len(nextstring)>len(palindrome):\n            palindrome=nextstring\nprint(len(palindrome))\nprint(palindrome)\n
# cook your dish here\ndef ans(n,a,b):\n    if n == act:\n        return 0\n    if dp[n][a][b] != -1:\n        return dp[n][a][b]\n    if l[n] == "0":\n        dp[n][a][b]\n        return ans(n+1,a+1,b)\n    elif l[n] == "1":\n        dp[n][a][b] = ans(n+1,a,b+1)\n        return ans(n+1,a,b+1)\n    elif l[n] == "?":\n        dp[n][a][b] = min((a-l1[n]+1)*x -(a+1) + ans(n+1,a+1,b),(b-l2[n]+1)*y -(b+1) + ans(n+1,a,b+1))\n        return(min((a-l1[n]+1)*x -(a+1) + ans(n+1,a+1,b),(b-l2[n]+1)*y -(b+1) + ans(n+1,a,b+1)))\n    else:\n        dp[n][a][b] = ans(n+1,a,b)\n        return ans(n+1,a,b)\n\nl = str(input())\nx,y = map(int,input().split())\ndp = [[[-1 for i in range(101)]for j in range(101)]for k in range(101)]\nl1 = []\nl2 = []\nc = 0\nk = 0\nfor i in l:\n    if i == "1":\n        c+=1\n    if i == "0":\n        k+=1\n    l1.append(k)\n    l2.append(c)\nact = len(l)\ndd = ans(0,0,0)\nprint(dd)\n\n        \n    \n\n
from sys  import stdin,stdout\r\nfrom collections import deque \r\nst=lambda:list(stdin.readline().strip())\r\nli=lambda:list(map(int,stdin.readline().split()))\r\nmp=lambda:list(map(int,stdin.readline().split()))\r\ninp=lambda:int(stdin.readline())\r\npr=lambda n: stdout.write(str(n)+"\n")\r\n\r\nmod=1000000007\r\nINF=float('inf')\r\n\r\ndef solve():\r\n    n,m=mp()\r\n    d={i:[] for i in range(n+1)}\r\n    for i in range(m):\r\n        a,b=mp()\r\n        d[a].append(b)\r\n        d[b].append(a)\r\n    x,y=mp()\r\n    v=[False for i in range(n+1)]\r\n    q=deque()\r\n    q.append(x)\r\n    dis=[INF for i in range(n+1)]\r\n    dis[x]=0\r\n    v[x]=True\r\n    while q:\r\n        a=q.popleft()\r\n        for i in d[a]:\r\n            if not v[i]:\r\n                v[i]=True\r\n                q.append(i)\r\n                dis[i]=dis[a]+1\r\n    if not v[y]:\r\n        pr(0)\r\n    else:\r\n        pr(dis[y])\r\n                \r\n        \r\n        \r\n\r\n\r\nfor _ in range(1):\r\n    solve()\r\n
# cook your dish here\nmod = 1000000009\nimport math\nK = int(input())\nN = 2 ** K\ntemp1 = N//2\nfact = math.factorial((N/2-1))%mod\ndiv = ((fact **2) * temp1)*N%mod\ntemp2 = 1\nfor i in range(1,N+1):\n    if i < N/2:\n        print("0")\n    else:\n        print(div)\n        div = (((div * pow(temp2,mod-2,mod))%mod)*temp1)%mod\n        temp1 += 1\n        temp2+= 1
n=int(input())\r\narr=[0]+[int(x) for x in input().split()]\r\nused=[]\r\nans=[]\r\nfor i in range (1,n+1) :\r\n    d=[]\r\n    start,end=i,arr[i]\r\n    if i not in used :\r\n       d.append(i)\r\n       used.append(i)\r\n       while(True) :\r\n        d.append(end)\r\n        if end==start :\r\n            break\r\n        else :\r\n            used.append(end)\r\n            end=arr[end]\r\n    if len(d)>0 :\r\n        ans.append(d)\r\nprint(len(ans))\r\nfor i in ans :\r\n    print(*i)
# cook your dish here\ns=input()\ni=0 \nl=len(s)\norig=''\nst=[]\nflag=False\nwhile(i<l):\n    if(s[i].isdigit()):\n        num=int(s[i])\n        \n    elif(s[i].isalpha()):\n        if(flag==False):\n            orig+=s[i]\n        else:st.append(s[i]) \n    elif(s[i]=='+'):\n        flag=True\n        st.clear()\n    \n    elif(s[i]=='-'):\n        orig+=("".join(st))*num \n        flag=False\n        \n    i+=1\nif(orig==orig[::-1]):\n    print("Return")\nelse:\n    print("Continue")
# cook your dish here\nst=input().strip()\nb=[]\nfor i in range(len(st)):\n    for j in range(i+1,len(st)):\n        if st[i]!=st[j]:\n            z=abs(i-j)\n            b.append(z)\nprint(max(b))
# cook your dish here\nn,p = map(int,input().split())\ns = input()\n\nd=s.count('d')\nu = s.count('u')\n\n# c = 1\n# l = 1\n# for i in range(1,n):\n    \n\nif(d<=p or u<=p):\n    print(n)\nelse:\n    if(d>=u):\n        c = 0\n        l = 0\n        i = 0\n        ii = -1\n        pp = p\n        while(i<n):\n            if(s[i] == 'u' and ii == -1):\n                ii = i\n            if(pp == 0 and s[i] == 'u'):\n                c = max(c,l)\n                i = ii\n                ii = -1\n                l = -1\n                pp = p\n            elif(s[i]=='u'):\n                pp-=1\n            # print(l,i,ii)\n            i += 1\n            l += 1\n        print(max(c,l))\n    else:\n        c = 0\n        l = 0\n        i = 0\n        ii = -1\n        pp = p\n        while(i<n):\n            if(s[i] == 'd' and ii == -1):\n                ii = i\n            if(pp == 0 and s[i] == 'd'):\n                c = max(c,l)\n                i = ii\n                ii = -1\n                l = -1\n                pp = p\n            elif(s[i]=='d'):\n                pp-=1\n            # print(l,i,ii)\n            i += 1\n            l += 1\n        print(max(c,l))
for i in range(int(input())):\n n,b=map(int,input().split())\n ans=n-((n-1)//b)\n print(ans)
# cook your dish here\ndef findCombo(s,p,k):\n    if k==1:\n        if s==p:\n            return [s]\n        else:\n            return []\n    else:\n        for i in range(1,s):\n            if(p%i==0) and i<s:\n                ans=findCombo(s-i,p//i,k-1)\n                if len(ans)!=0:\n                    ans.append(i)\n                    return ans \n        return []\ntry:\n    s,p,k = map(int,input().split())\n    ans=findCombo(s,p,k)\n    if len(ans)==0:\n        print("NO")\n    else:\n        print(*ans)\n\nexcept:\n    pass
# cook your dish here\nn, m, k =map(int, input().split())\nblasters=[]\nfor _ in range(k):\n    blasters.append(list(map(int, input().split())))\ngrid=[[0 for _ in range(m)] for _ in range(n)]\nfor blaster in blasters:\n    flag=0\n    x, y, t, f = blaster\n    x-=1 \n    y-=1\n    grid[x][y]=-1\n    for i in range(n):\n        if i+y-t-abs(x-i)>=0 and (i+y-t-abs(x-i))%f==0:\n            if i>x:\n                flag=1\n            grid[i][y]=-1\n        if i>x and flag==0:\n            break\n    flag=0\n    for j in range(m):\n        if j+x-t-abs(y-j)>=0 and (j+x-t-abs(y-j))%f==0:\n            if j>y:\n                flag=1\n            grid[x][j]=-1\n        if j>y and flag==0:\n            break\nfor i in range(1,n):\n    if grid[i-1][0]==-1:\n        grid[i][0]=-1\nfor j in range(1,m):\n    if grid[0][j-1]==-1:\n        grid[0][j]=grid[0][j-1]\nfor i in range(1,n):\n    for j in range(1,m):\n        if grid[i][j-1]==-1 and grid[i-1][j]==-1:\n            grid[i][j]=-1\nif grid[-1][-1]==0:\n    print('YES')\n    print(n+m-2)\nelse:\n    print('NO')
# cook your dish here\ntry:\n    a,b,da=list(input()),input(),list(map(int,input().split()))\n    print(len(a)-len(b))\nexcept:\n    pass
# cook your dish here\nn=int(input())\narr=[int(x) for x in input().split()]\nans=n-1\nwhile(ans>0 and arr[ans]==arr[ans-1]):ans-=1\nprint(ans+1)
# cook your dish here\ntry:\n    def isPrime(n): \n          \n        # Corner case \n        if n <= 1 : \n            return False\n      \n        # check from 2 to n-1 \n        for i in range(2, n): \n            if n % i == 0: \n                return False\n      \n        return True\n      \n    # Function to print primes \n    def printPrime(n): \n        count = 0\n        for i in range(2, n + 1): \n            if isPrime(i): \n                count = count+1 \n        print(count)\n      \n    n = int(input())\n    printPrime(n)\nexcept:\n    pass
\nfrom sys import stdin,stdout\ninput=stdin.readline\nprint=stdout.write\nm,v=map(int,input().split())\na=[]\nt=0\nfor i in range(m):\n x,y=map(int,input().split())\n a.append([x,y])\na.sort()\nd=0\nre=0\nequip=0\nfor x,y in a:\n if d<x:\n  d=x\n  if y<=v:\n   equip+=y\n   re=v-y\n   if y==v:\n    d+=1\n    re=0\n  elif y>v and y<2*v:\n   equip+=y\n   d+=1\n   re=2*v-y\n  else:\n   equip+=2*v\n   d+=2\n   re=0\n elif d==x:\n  if re==0:\n   if y<=v:\n    equip+=y\n    re=v-y\n    if y==v:\n     d+=1\n     re=0\n   elif y>=v and y<2*v:\n    equip+=y\n    d+=1\n    re=2*v-y\n   else:\n    equip+=2*v\n    d+=2\n    re=0\n  else:\n   if y<re:\n    equip+=y\n    re-=y\n   elif y==re:\n    equip+=y\n    re=0\n    d+=1\n   elif y>re:\n    d+=1\n    equip+=re\n    y-=re\n    if y<v:\n     equip+=y\n     re=v-y\n    elif y>=v:\n     equip+=v\n     re=0\n     d+=1\n elif d==x+1:\n  if re==0:\n   if y<v:\n    equip+=y\n    re=v-y\n   elif y>=v:\n    equip+=v\n    re=0\n    d+=1\n  else:\n   if y<=re:\n    equip+=y\n    re-=y\n    if re==0:d+=1\n   elif y>re:\n    equip+=re\n    re=0\n    d+=1\nprint(str(equip))
# cook your dish here\na=int(input())\np=list(map(int,input().split()))\nfor n in p:\n    # n=int(input())\n    a=[1]\n    b=[2]\n    c=[4]\n    d=[3]\n    j=1\n    k=1\n    for i in range(n-1):\n        a.append(a[i]+3*(j))\n        b.append(b[i]+3*(j))\n        c.append(c[i]+6*(j))\n        d.append(d[i]+3*(j))\n        j*=2\n        # k+\n    print(*a)\n    print(*b)\n    print(*c)\n    print(*d)
T=eval(input())\nfor i in range(T):\n a,b,c,d=list(map(int,input().split()))\n x=c-a\n n1=b-a+1\n n2=d-c+1\n s=0\n if x<=0:\n  t=n2-abs(x)-1\n  for j in range(t,max(0,d-b-1),-1):\n   s=s+j\n if x>0:\n  t=n2\n  for j in range(x,max(0,c-b-1),-1):\n   s=s+t\n  if (c-b)<=0:\n   for j in range(t-1,max(0,d-b-1),-1):\n    s=s+j\n print(s)\n   \n \n   \n
def main():\n N, K = list(map(int, input().split()))\n \n Apples = [int(x) for x in input().split()]\n \n time = 0 # answer\n # Apples_encountered = [None]  # Binary Search Tree \n \n distinct_apples_condition = None if K & 1 else K >> 1 \n \n already_found = [False] * K \n \n for i in range((N >> 1) + 1):\n  time += 1 \n  for k in (Apples[i], Apples[N - i - 1]):\n   if k < K and k != distinct_apples_condition:\n    if already_found[K - k - 1]:\n     # print(K, k)\n     # print(already_found)\n     return time \n    already_found[k - 1] = True\n  \n \n return -1 \n\n\nprint(main())\n \n \n \n \n \n
N=int(input())\nl=[]\nfor i in range (N):\n    a=input().split()\n    l.append(a)\ncount = 0\nfor i in range(N):\n    flag = 0\n    value=l[i].count('T')\n    for j in range (N):\n     if l[i][j] =='T' and i!=j :\n      if l[i] == l[j]:\n       continue\n      else:\n       flag=1\n       break\n    if flag==0 and count<value:\n     count=value\nprint(count)
# cook your dish here\nimport copy\nimport bisect\nn,q=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na.sort()\nb=copy.copy(a)\nfor i in range(1,len(b)):\n b[i]+=b[i-1]\n##print(b)\nfor i in range(q):\n x=int(input())\n ans=bisect.bisect_left(a,x*2)\n if ans==0:\n  ans1=b[n-1]\n else:\n  ans1=b[n-1]-b[ans-1]\n print(ans1)\n
n,m=[int(x) for x in input().split()]\nk=[int(x) for x in input().split()]\na=min(k)\nb=max(k)\nfor i in range(m):\n c=int(input())\n if c>=a and c<=b:\n  print('Yes')\n else:\n  print('No')
t=1\nfor _ in range(t):\n    n,m,k=(list(map(int,input().split())))\n    a=list(map(int,input().split()))\n    for i in range(n):\n        a[i]=a[i]%k\n    \n    s=1\n    for j in range(k):\n        ss=0\n        v=0\n        for i in range(n):\n            v+=min(abs(a[i]-j),k-abs(a[i]-j))\n            while ss<i and v>m:\n                v-=min(abs(a[ss]-j),k-abs(a[ss]-j))\n                ss+=1\n            s=max(s,i-ss+1)\n        \n    print(s)\n
import operator\nN = eval(input());\nN = int(N);\nk = eval(input());\nk = int(k);\nlist= [];\nfor i in range(k):\n a=eval(input());\n a=int(a);\n list.append(a);\nlist.sort() \nfor i in range(k,N):\n a=eval(input())\n a=int(a)\n if(a>=0):\n  if(a<list[k-1]):\n    list.pop()\n    list.append(a)\n    list.sort()\n else:\n    print(list[k-1]) \n        \n
n,k=[int(i) for i in input().split()]\nl=[int(i) for i in input().split()]\ncons=int(5e5+1)\nmod=10**9+7\ntpa=[1 for i in range(cons)]\ntpa[0]=1\nfor i in range(1,cons):\n    tpa[i]=(tpa[i-1]*2)%mod\nif k>n:\n    print(tpa[n-1])\nelse:\n    il=[[]for i in range(k+1)]\n    for i in range(n):\n        if l[i]<=k:\n            il[l[i]].append(i)\n    for i in range(k+1):\n        if len(il[i])==0:\n            print(tpa[n-1])\n            break\n    else:\n        pi=-1\n        dp=[-1 for i in range(n)]\n        dp[0]=1\n        si=max(il,key=lambda x:x[0])[0]\n        s=1\n        for i in range(1,si):\n            dp[i]=tpa[i]\n            s=(s+dp[i])%mod\n        ci=[0 for i in range(k+1)]\n        j=si\n        i=0\n        while j<n:\n            if l[i]>k :\n                s=(s-dp[i])%mod\n                i+=1\n            elif ci[l[i]]+1<len(il[l[i]]) and il[l[i]][ci[l[i]]+1]<=j:\n                s=(s-dp[i])%mod\n                ci[l[i]]+=1\n                i+=1\n            else:\n                dp[j]=s\n                pi=i\n                s=(s+dp[j])%mod\n                j+=1\n        print(dp[n-1])\n                \n                \n                \n        \n        \n            \n            \n
try:\n    n , k = list(map(int,input().split()))\n    \n    for i in range(k):\n        if n % 10 == 0:\n            n = n/10\n        else:\n            n -= 1\n    \n    print(int(n))\n    \nexcept:\n    pass
#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nclass ford_fulkerson:\n    class Edge:\n        def __init__(self, to, cap, rev):\n            self.to = to\n            self.cap = cap\n            self.rev = rev\n        \n        def __repr__(self):\n            return "to : {0} cap : {1} rev : {2}".format(self.to, self.cap, self. rev)\n\n    def __init__(self,V):\n        self.V = V\n        self.size = [0 for i in range(V)]\n        self.G = [[] for i in range(V)]\n\n    def add_edge(self, _from, to, cap):\n        self.size[_from]\n        self.G[_from].append(self.Edge(to, cap, self.size[to]))\n        self.G[to].append(self.Edge(_from, 0, self.size[_from]))\n        self.size[_from] += 1\n        self.size[to] += 1\n\n    def dfs(self, v, t, f):\n        if v == t: return f\n        self.used[v] = True\n        for i in range(len(self.G[v])):\n            edge = self.G[v][i]\n            if self.used[edge.to] is False and edge.cap > 0:\n                d = self.dfs(edge.to, t, f if f < edge.cap else edge.cap)\n                if d > 0:\n                    self.G[v][i].cap -= d\n                    self.G[edge.to][edge.rev].cap += d\n                    return d\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.used = [False for _ in range(self.V)]\n            f = self.dfs(s, t, float('inf'))\n            if f == 0:\n                return flow\n            flow += f\n\nN,M = list(map(int,input().split()))\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\n\nff = ford_fulkerson(N*2+2)\nS = 1\nT = N + 1\n\nfor i in range(M):\n    p,q = list(map(int, input().split()))\n    ff.add_edge(p,T+q-1,10**9)\n    ff.add_edge(q,T+p-1,10**9)\n\nfor i in range(N):\n    ff.add_edge(i+1,T+i,10**9)\n    ff.add_edge(0,S+i,A[i])\n    ff.add_edge(T+i,2*N+1,B[i])\n\nans = [[0  for i in range(N)] for j in range(N)]\nff.max_flow(0,2*N+1)\n\nfor i in range(1,N+1):\n    for v in ff.G[i]:\n        if v.to != 0:\n            ans[i-1][v.to-T] = ff.G[v.to][v.rev].cap\n\nif M == 0:\n    if A == B:\n        print('YES')\n        for i in range(N):\n            for j in range(N):\n                ans [i][j] = A[i] if i == j else 0\n        for a in ans:\n            print(' '.join(map(str,a)))\n    else:\n        print('NO')\nelse:\n    if [sum([ans[i][j] for i in range(N)]) for j in range(N)] == B:\n        print('YES')\n        for a in ans:\n            print(' '.join(map(str,a)))\n    else:\n        print('NO')\n
\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop\nimport math\nfrom collections import defaultdict\nfrom functools import reduce,cmp_to_key,lru_cache\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n# import sys\n# input = sys.stdin.readline\n \nM = mod = 10**9 + 7 \ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip().split()]\ndef st():return str(input().rstrip())[2:-1]\ndef val():return int(input().rstrip())\ndef li2():return [str(i)[2:-1] for i in input().rstrip().split()]\ndef li3():return [int(i) for i in st()]\n \n \n\n\ngraph = defaultdict(set)\n\nn, k = li()\nl = []\nallwords = set()\nfor i in range(n):\n    p = val()\n    l1 = []\n    for j in range(k):l1.append(st())\n\n    allwords |= set(l1[-1])\n    l.append([p, l1[:]])\n\n\nl.sort(key = lambda x:x[0])\nl = [i[1] for i in l]\nif n == k == 1:\n    print(''.join(set(l[0][0])))\n    return\n\n\ningraph = defaultdict(int)\n\ndef match(a, b):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:continue\n        elif b[j] in graph[a[j]]:return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return\n\nfinl = []\nfor i in l:finl.extend(i)\nl = finl\n\n# for i in l:print(i)\n\nfor i in range(1, len(l)):\n    match(l[i - 1], l[i])\n\n\n\n# print(graph)\n# print(ingraph)\n\nif min([ingraph[j] for j in graph]) != 0:\n    print('IMPOSSIBLE')\n    return\n\nans = ''\n\n\nd = deque()\n\nfor j in graph:\n    if ingraph[j] == 0:\n        d.append(j)\n\nwhile d:\n    node = d.popleft()\n    ans += node\n\n    for j in graph[node]:\n        ingraph[j] -= 1\n        if not ingraph[j]:d.append(j)\n\n\nif len(ans) != len(allwords):\n    print('IMPOSSIBLE')\n    return\nprint(ans)\n
t = int(input())\n\nfor _ in range(t):\n    a, b, c = map(int, input().split())\n    print(a+b+c-1)
mod=998244353\nimport sys\ninput = sys.stdin.readline\nfrom collections import deque\nfrom collections import Counter\n\n\ndef calc(s,a):\n    return (pow(2,s,mod)+pow(2,a-s,mod))%mod\n\n \ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\n\n\ntestcase=int(input())\nfor test in range(testcase):\n    n,m=list(map(int,input().split()))\n    EDGE=[list(map(int,input().split())) for i in range(m)]\n    EDGELIST=[[] for j in range(n+1)]\n    ANS=1\n\n\n    Group=[j for j in range(n+1)]\n\n    for a,b in EDGE:\n        Union(a,b)\n        EDGELIST[a].append(b)\n        EDGELIST[b].append(a)\n\n    testing=[None]*(n+1)\n    flag=1\n\n    for i in range(1,n+1):\n        if testing[i]!=None:\n            continue\n\n        score=1\n        allscore=1\n\n        testing[i]=1\n        QUE = deque([i])\n        while QUE:\n            x=QUE.pop()\n            for to in EDGELIST[x]:\n                if testing[to]==-testing[x]:\n                    continue\n                if testing[to]==testing[x]:\n                    flag=0\n                    break\n                testing[to]=-testing[x]\n                if testing[to]==1:\n                    score+=1\n                allscore+=1\n                QUE.append(to)\n                \n            if flag==0:\n                break\n        if flag==0:\n            break\n        #print(score,allscore)\n        ANS=ANS*calc(score,allscore)%mod\n    if flag==0:\n        print(0)\n        continue\n\n    print(ANS)\n
k = int(input())\nn = 50\nif k <= n-1:\n    aas = [0] * n\n    aas[0] += n * k\nelse:\n    t = k // n\n    k %= n\n    aas = [n-k+t-1] * n\n    i = 0\n    cnt = 0\n    while cnt < k:\n        aas[i] += 1 + k\n        i += 1\n        cnt += 1\nprint(n)\nprint(*aas)
from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\r\n')\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(fd, stream.getvalue()) + stream.truncate(0) + stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 2*10**12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\n\n\ns = sys.stdin.read().replace(b'\r',b'')\ninp = []\nnumb = 0\n \nfor i in range(len(s)):\n    if s[i]>=48:\n        numb = 10*numb + s[i]-48\n    elif s[i]!=13:\n        inp.append(numb)\n        numb = 0\nif s[-1]>=48:\n    inp.append(numb)\n\nind = 0\n\nn = inp[ind]\nind += 1\nm = inp[ind]\nind += 1\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = inp[ind+0]-1\n    u = inp[ind+1]-1\n    w = inp[ind+2]\n    ind += 3\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\nbest = [inp[ind+i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(x))\n    sys.stdout.write('\n')
class Solution(object):\n     def findSubstring(self, s, words):\n         """\n         :type s: str\n         :type words: List[str]\n         :rtype: List[int]\n         """\n         if not s or words==[]:\n             return []\n         lenstr=len(s)\n         lenword=len(words[0])\n         lensubstr=len(words)*lenword\n         times={}\n         for word in words:\n             if word in times:\n                 times[word]+=1\n             else:\n                 times[word]=1\n         ans=[]\n         for i in range(min(lenword,lenstr-lensubstr+1)):\n             self.findAnswer(i,lenstr,lenword,lensubstr,s,times,ans)\n         return ans\n     def findAnswer(self,strstart,lenstr,lenword,lensubstr,s,times,ans):\n         wordstart=strstart\n         curr={}\n         while strstart+lensubstr<=lenstr:\n             word=s[wordstart:wordstart+lenword]\n             wordstart+=lenword\n             if word not in times:\n                 strstart=wordstart\n                 curr.clear()\n             else:\n                 if word in curr:\n                     curr[word]+=1\n                 else:\n                     curr[word]=1\n                 while curr[word]>times[word]:\n                     curr[s[strstart:strstart+lenword]]-=1\n                     strstart+=lenword\n                 if wordstart-strstart==lensubstr:\n                     ans.append(strstart)
class Solution:\n     def compareVersion(self, version1, version2):\n         """\n         :type version1: str\n         :type version2: str\n         :rtype: int\n         """\n         while version1 and version2:\n             result1 = version1.split('.', 1)\n             if len(result1) == 2:\n                 digit1, version1 = result1[0], result1[1]\n             else:\n                 digit1 = result1[0]\n                 version1 = ""\n             result2 = version2.split('.', 1)\n             if len(result2) == 2:\n                 digit2, version2 = result2[0], result2[1]\n             else:\n                 digit2 = result2[0]\n                 version2 = ""\n             if int(digit1) > int(digit2):\n                 return 1\n             elif int(digit1) < int(digit2):\n                 return -1\n \n         if version1 and sum(map(lambda x: int(x), version1.split('.'))) != 0:\n             return 1\n         if version2 and sum(map(lambda x: int(x), version2.split('.'))) != 0:\n             return -1\n         return 0
class Solution:\n     def searchRange(self, nums, target):\n         """\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[int]\n         """\n         start = self.firstGreaterEqaul(nums, target)\n         if start==len(nums) or nums[start]!=target:\n             return [-1, -1]\n         return [start, self.firstGreaterEqaul(nums, target+1)-1]\n     def firstGreaterEqaul(self, nums, target):\n         lo, hi = 0, len(nums)\n         while lo<hi:\n             mid = (hi+lo)//2\n             if nums[mid]<target:\n                 lo = mid + 1\n             else:\n                 hi = mid\n         return lo
class Solution:\n     def letterCombinations(self, digits):\n         """\n         :type digits: str\n         :rtype: List[str]\n         """\n         \n         def dfs(digits, current, result):\n             if not digits:\n                 result.append(current)\n                 return\n             for c in dic[digits[0]]:\n                 dfs(digits[1:], current + c, result)\n         \n         \n         if not digits:\n             return []\n         \n         dic = { '2' : "abc", '3': "def", '4':"ghi", \n                '5':"jkl", '6':"mno", '7':"pqrs", '8':"tuv",'9': "wxyz" }\n         result = []\n         dfs(digits, "", result)\n         return result\n         \n         \n         \n \n
h, w = map(int, input().split())\nn = int(input())\nA = tuple(map(int, input().split()))\n\nM = [[0] * w for _ in range(h)]\nii = 0\nij = 0\nfor i, a in enumerate(A):\n    i += 1\n    for _ in range(a):\n        M[ij][ii] = i\n\n        if ij%2 == 0:\n            ii += 1\n            if ii == w:\n                ij += 1\n                ii = w-1\n        else:\n            ii -= 1\n            if ii == -1:\n                ij += 1\n                ii = 0\nfor l in M:\n    print(*l)
class Solution:\n     def generateParenthesis(self, n):\n         """\n         :type n: int\n         :rtype: List[str]\n         """\n         if n == 0:\n             return []\n         left = right = n\n         result = []\n         self.generate(left, right, result, '')\n         return result\n     def generate(self, left, right, result, string):\n         if left == 0 and right == 0:\n             result.append(string)\n             return\n         if left:\n             self.generate(left - 1, right , result, string+'(')\n         if left < right:\n             self.generate(left, right - 1, result, string+')')\n
# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def merge(self, intervals):\n       new_intervals = []\n       for interval in sorted(intervals, key=lambda i: i.start):\n         if new_intervals and interval.start <= new_intervals[-1].end:\n           new_intervals[-1].end = max(new_intervals[-1].end, interval.end)\n         else:\n           new_intervals.append(interval)\n       return new_intervals\n
class Solution:\n     def combinationSum2(self, candidates, target):\n                 \n         def dfs(i, val, path):\n             while i < len(candidates):\n                 num = candidates[i]\n                 val_ = val + num\n                 path_ = path + [num]\n                 if val_ > target:\n                     return\n                 elif val_ == target:\n                     ans.append(path_)\n                     return                  \n                 dfs(i+1, val_, path_)\n                 while i<len(candidates)-1 and candidates[i]==candidates[i+1]:\n                     i += 1\n                 i += 1\n                \n         candidates = sorted(candidates)\n         ans = []\n         dfs(0, 0, [])\n         return ans
# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def insert(self, intervals, newInterval):\n         """\n         :type intervals: List[Interval]\n         :type newInterval: Interval\n         :rtype: List[Interval]\n         """\n         # my no6, 56ms, beats 100%\n         if len(intervals)==0:\n             return [newInterval]\n         start = 0; end = 0\n         foundl = foundr = -1\n         for i, n in enumerate(intervals):\n             if foundl==-1 and newInterval.start<=n.end:\n                 foundl = 1\n                 start = i\n                 break\n             else:\n                 continue\n         for i, n in enumerate(intervals[::-1]):\n             if foundr==-1 and newInterval.end>=n.start:\n                 foundr = 1\n                 end = len(intervals)-1-i\n                 break\n             else:\n                 continue\n         print(start, end,foundl,foundr)\n         if foundl==1 and foundr==1:\n             if start<=end:\n                 s = min(intervals[start].start, newInterval.start)\n                 e = max(intervals[end].end, newInterval.end)\n                 return intervals[:start]+[Interval(s,e)]+intervals[end+1:]\n             else:\n                 return intervals[:start]+[newInterval]+intervals[end+1:]\n         elif foundl==1:\n             return [newInterval]+intervals\n         else:\n             return intervals+[newInterval]\n         \n         # others'\n         # s, e = newInterval.start, newInterval.end\n         # left, right = [], []\n         # for i in intervals:\n         #     if i.end < s:\n         #         left += i,\n         #     elif i.start > e:\n         #         right += i,\n         #     else:\n         #         s = min(s, i.start)\n         #         e = max(e, i.end)\n         # return left + [Interval(s, e)] + right\n \n             \n         
import sys\ns = input()\nl = len(s)\nif l == 2:\n    if s[0] == s[1]:\n        print(1, 2)\n        return\n    else:\n        print('-1 -1')\n        return\nfor i in range(l - 2):\n    s1 = s[i]\n    s2 = s[i + 1]\n    s3 = s[i + 2]\n    if s1 == s2 or s1 == s3 or s2 == s3:\n        print(i + 1, i + 3)\n        return\nprint('-1 -1')
def solve():\r\n	n=int(input())\r\n	l1=list(map(int,input().split()))\r\n	l2=list(map(int,input().split()))\r\n	ans=[]\r\n	for i in range (n):\r\n		c=0\r\n		for j in range (i+1):\r\n			if l1[j]<=l2[i]:\r\n				c+=l1[j]\r\n				l1[j]=0\r\n			else:\r\n				l1[j]-=l2[i]\r\n				c+=l2[i]\r\n		ans.append(c)\r\n	print(*ans)\r\nsolve()
#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define mod 1000000007\r\n#define inf 100000000000000\r\ntypedef long long ll;\r\n#define mp make_pair\r\n#define f first \r\n#define s second\r\nll xp[5005];\r\nll train[5005];\r\nll dp[5005][5005];\r\nint n;\r\nll power(ll x,ll y){\r\n    ll res=1;\r\n    while (y){\r\n        if (y & 1){\r\n            res=res*x; \r\n        }\r\n        x=x*x;\r\n        y=y>>1;\r\n    }\r\n    return res;\r\n}\r\nll cube(ll x){\r\n    ll res=x,sum=0;\r\n    while(x!=0){\r\n        sum+=(x%10);\r\n        x=x/10;\r\n    }\r\n    res+=power(sum,3);\r\n    return res;\r\n}\r\nll max_xp(int i,int r){\r\n    if(i>n){\r\n        return 0;\r\n    }\r\n    if(dp[i][r]!=-1){\r\n        return dp[i][r];\r\n    }\r\n    ll maxi=0;\r\n    if(r<=n){\r\n        maxi=max_xp(i+1,r+1);\r\n    }\r\n    maxi=max(maxi,max_xp(i+1,r)+xp[i]*train[r]);\r\n    return dp[i][r]=maxi;\r\n}\r\nint main(){\r\n	ios_base::sync_with_stdio(false);\r\n	cin.tie(NULL);\r\n	cout.tie(NULL);\r\n	ll s;\r\n	cin>>n>>s;\r\n	for(int i=1;i<=n;i++){\r\n	    cin>>xp[i];\r\n	}\r\n	memset(dp,-1,sizeof(dp));\r\n	train[0]=s;\r\n	for(int i=1;i<=n;i++){\r\n	    train[i]=cube(train[i-1]);\r\n	}\r\n	cout<<max_xp(1,0)<<"\n";\r\n	return 0;\r\n}
import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nn,k = list(map(int, input().split()))\na = list(map(int, input()))\nb = a[:k]\nc = [b[i%k] for i in range(n)]\nif tuple(a)>tuple(c):\n    d = int("".join(map(str, b)))\n    d += 1\n    b = list(map(int, str(d)))\n    c = [b[i%k] for i in range(n)]\nprint(len(c))\nprint("".join(map(str, c)))\n\n
used = [0] * 121\nh, m, s, t1, t2 = map(int, input().split())\nh %= 12\nt1 %= 12\nt2 %= 12\nt1 *= 5\nt2 *= 5\nused[h * 5] = 1\nused[h * 5 + 60] = 1\nused[m] = 1\nused[m + 60] = 1\nused[s] = 1\nused[s + 60] = 1\nif t1 > t2:\n    t1, t2 = t2, t1\nt3 = t1 + 60\nif sum(used[t1:t2]) == 0 or sum(used[t2:t3]) == 0:\n    print("YES")\nelse:\n    print("NO")
x0, y0, A, C, B, D = list(map(int, input().split()))\n\npts = [[x0, y0]]\nfor i in range(100):\n	nx, ny = [pts[-1][0] * A + B, pts[-1][1] * C + D]\n	pts.append([nx, ny])\n	if max(nx, ny) > 10000000000000000 * 10000000000000000: break\n\n\nx, y, t = list(map(int, input().split()))\n# print (pts[0])\n# print (pts[1])\n# print (pts[2])\n# print (pts[3])\n_max = 0\nfor i in range(len(pts)):\n	for j in range(len(pts)):\n		if abs(pts[i][0] - pts[j][0]) + abs(pts[i][1] - pts[j][1]) + abs(x - pts[i][0]) + abs(y - pts[i][1]) <= t:\n			_max = max(_max, abs(i - j) + 1)\nprint(_max)\n
from math import sqrt\ndef pt(x):\n    print(x)\nrd = lambda: map(int, input().split())\nn = int(input())\ndef f(x1, y1, r1, x2, y2, r2):\n    a = (r1 + r2) ** 2\n    b = (r1 - r2) ** 2\n    d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    if d > a:\n        return 1\n    elif d == a:\n        return 4\n    elif d < b:\n        return 3\n    elif d == b:\n        return 5\n    else:\n        return 2\ndef g(x1, y1, r1, x2, y2, r2):\n    ds = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    d = sqrt(ds)\n    A = (r1 ** 2 - r2 ** 2 + ds) / (2 * d)\n    h = sqrt(r1 ** 2 - A ** 2)\n    x = x1 + A * (x2 - x1) / d  \n    y = y1 + A * (y2 - y1) / d\n    x3 = x - h * (y2 - y1) / d  \n    y3 = y + h * (x2 - x1) / d\n    x4 = x + h * (y2 - y1) / d  \n    y4 = y - h * (x2 - x1) / d\n    return x3, y3, x4, y4 \nif n is 1:\n    pt(2)\nif n is 2:\n    x1, y1, r1 = rd()\n    x2, y2, r2 = rd()\n    a = f(x1, y1, r1, x2, y2, r2)\n    pt(4 if a is 2 else 3)\nif n is 3:\n    x1, y1, r1 = rd()\n    x2, y2, r2 = rd()\n    x3, y3, r3 = rd()\n    a = f(x1, y1, r1, x2, y2, r2)\n    b = f(x1, y1, r1, x3, y3, r3)\n    c = f(x3, y3, r3, x2, y2, r2)\n    t = [a, b, c]\n    t.sort()\n    a, b, c = t\n    if a is 1 and b is 1 and c in [1, 3, 4, 5]:\n        pt(4)\n    if a is 1 and b is 1 and c is 2:\n        pt(5)\n    if a is 1 and b is 2 and c is 2:\n        pt(6)\n    if a is 1 and b is 2 and c in [3, 4, 5]:\n        pt(5)\n    if a is 1 and b in [3, 4, 5]:\n        pt(4)\n    if a is 2 and b is 2 and c is 2:\n        x4, y4, x5, y5 = g(x1, y1, r1, x2, y2, r2)\n        r = 8\n        if abs((x4 - x3) ** 2 + (y4 - y3) ** 2 - r3 ** 2) < 1e-6:\n            r -= 1\n        if abs((x5 - x3) ** 2 + (y5 - y3) ** 2 - r3 ** 2) < 1e-6:\n            r -= 1\n        pt(r)\n    if a is 2 and b is 2 and c is 3:\n        pt(6)\n    if a is 2 and b is 2 and c in [4, 5]:\n        x4, y4, x5, y5 = g(x1, y1, r1, x2, y2, r2)\n        if abs((x4 - x3) ** 2 + (y4 - y3) ** 2 - r3 ** 2) < 1e-6 or abs((x5 - x3) ** 2 + (y5 - y3) ** 2 - r3 ** 2) < 1e-6:\n            pt(6)\n        else:\n            pt(7)\n    if a is 2 and b is 3:\n        pt(5)\n    if a is 2 and b in [4, 5]:\n        pt(6)\n    if a is 3 and b in [3, 4, 5]:\n        pt(4)\n    if a is 4 and b is 4 and c is 4:\n        pt(5)\n    if a is 4 and b is 4 and c is 5:\n        pt(4)\n    if a is 4 and b is 5 and c is 5:\n        pt(5)\n    if a is 5 and b is 5 and c is 5:\n        pt(4)
a = list(map(int, input().split()))\nb = list(map(int, input().split()))\nx1 = min(a[0], a[2], a[4], a[6])\nx2 = max(a[0], a[2], a[4], a[6])\ny1 = min(a[1], a[3], a[5], a[7])\ny2 = max(a[1], a[3], a[5], a[7])\nd1 = min(b[0] - b[1], b[2] - b[3], b[4] - b[5], b[6] - b[7])\nd2 = max(b[0] - b[1], b[2] - b[3], b[4] - b[5], b[6] - b[7])\ns1 = min(b[0] + b[1], b[2] + b[3], b[4] + b[5], b[6] + b[7])\ns2 = max(b[0] + b[1], b[2] + b[3], b[4] + b[5], b[6] + b[7])\nfor x in range(-100, 101):\n    for y in range(-100, 101):\n        d = x - y\n        s = x + y\n        if x1 <= x <= x2 and y1 <= y <= y2 and s1 <= s <= s2 and d1 <= d <= d2:\n            print("YES")\n            return\nprint("NO")
n = int(input())\na = list(map(int,input().split()))\n\ndupes = 0\ndupeVal = -1\nd = set()\nfor el in a:\n    if el in d:\n        dupes += 1\n        dupeVal = el\n    else:\n        d.add(el)\n\ninPlay = True\nif dupes > 1:\n    print('cslnb')\n    inPlay = False\nelif dupes == 1:\n    if dupeVal == 0 or (dupeVal - 1) in d:\n        print('cslnb')\n        inPlay = False\n\nif inPlay:\n    finalSum = (n*(n-1))//2\n    Sum = sum(a)\n    if (Sum - finalSum) % 2 == 0:\n        print('cslnb')\n    else:\n        print('sjfnb')\n    \n
n, t = map(int,input().split())\nwait = list(map(int,input().split()))\nseg = []\nfor i in range(n):\n    # to get the food in wait[i], wait __ seconds before running\n    m = max(0, wait[i]-i-1)\n    M = t-i-2\n    if m > M: continue\n    seg.append((m, -1))\n    seg.append((M, 1))\nseg.sort()\n\nans = 0\ncur = 0\nfor t, q in seg:\n    cur-= q\n    ans = max(ans, cur)\nprint(ans)
n = int(input())\n\na, b = [1], [0]\n\nfor i in range(n):\n	new_b = a[:]\n	a1 = a[:]\n	a2 = a[:]\n	a1.append(0)\n	a2.append(0)\n	for i in range(-1, -len(b) - 1, -1):\n		a1[i] += b[i]\n	for i in range(-1, -len(b) - 1, -1):\n		a2[i] -= b[i]\n	if max([abs(kek) for kek in a1]) < 2:\n		a = a1\n	elif max([abs(kek) for kek in a2]) < 2:\n		a = a2\n	else:\n		print("oops")\n		return\n	b = new_b\nprint(len(a) - 1)\nprint(*(a[::-1]))\nprint(len(b) - 1)\nprint(*(b[::-1]))
class State:\n  __slots__ = ['candidate', 'votes', 'last_vote']\n\n  def __init__(self, cand, votes, last):\n    self.candidate = cand\n    self.votes = votes\n    self.last_vote = last\n\n  def beats(self, other, extra):\n    return self.votes + extra > other.votes\n\ndef main():\n  candidates, seats, people, voted = map(int, input().split())\n  votes = [0 for i in range(candidates)]\n  last_vote = [0 for i in range(candidates)]\n\n  if candidates == 1:\n    print(1)\n    return\n\n  v = list(map(int, input().split()))\n  for t in range(voted):\n    cand = v[t] - 1\n    votes[cand] += 1\n    last_vote[cand] = t\n\n  states = [State(i, votes[i], last_vote[i]) for i in range(candidates)]\n  states = sorted(states, key = lambda x : (x.votes, -x.last_vote))\n  res = [0 for i in range(candidates)]\n\n  for i in range(candidates):\n    if i < candidates - seats:\n      low = candidates - seats\n      if states[i].beats(states[low], people - voted):\n        res[states[i].candidate] = 2\n      else:\n        res[states[i].candidate] = 3\n    else:\n      extra = people - voted\n      other = i - 1\n      place = i\n\n      if extra == 0 and states[i].votes == 0:\n        res[states[i].candidate] = 3\n        continue\n\n      while other >= 0 and extra > 0:\n        needed = states[i].votes - states[other].votes + 1\n        if needed <= extra:\n          extra -= needed;\n          place -= 1\n          other -= 1\n        else:\n          break\n\n      res[states[i].candidate] = (1 if place + seats >= candidates and states[i].votes > 0 else 2)\n\n  for i in res:\n    print(i, end = ' ')\n\nmain()\n
mas = [[] for i in range(1001)]\nmas[0].append(1)\nmas[0].append(1)\nfor i in range(1, 1000):\n    mas[i].append(1)\n    for j in range(1, i):\n        mas[i].append((mas[i - 1][j] + mas[i - 1][j - 1]) % (10 ** 9 + 7))\n    mas[i].append(1)\n\n\ndef c(k, n):\n    if k > n:\n        return 0\n    if k < 0:\n        return 0\n    nonlocal mas\n    return mas[n][k]\n\n\nm = [0] * 1000\nfor i in range(1, 1000):\n    nw = i\n    t = 0\n    while nw != 1:\n        nw = sum([int(j) for j in str(bin(nw)[2:])])\n        t += 1\n    m[i] = t\nm[1] = 0\nn = input()\nk = int(input())\nif k >= 6:\n    print(0)\n    return\nif k == 0:\n    print(1)\n    return\nif k == 1:\n    print(len(n) - 1)\n    return\nans = 0\nfor kkk in range(1, 1000):\n    if m[kkk] == k - 1:\n        nw = kkk\n        t = 0\n        for i in range(len(n)):\n            if n[i] == '1':\n                ans += c(nw - t, len(n) - 1 - i)\n                ans %= 10 ** 9 + 7\n                t += 1\n        if sum([int(j) for j in n]) == kkk:\n            ans += 1\n            ans %= 10 ** 9 + 7\n\n\nprint(ans)\n
from math import *\n\nax, ay, bx, by, cx, cy = [int(t) for t in input().split()]\nn = int(input())\ndist = 0\nmaxv = [[-inf, -inf], [-inf, -inf]]\nindex = [[0,0], [0,0]]\n\ndef update(d, idx, p):\n    nonlocal maxv, index\n    if d > maxv[p][0]:\n        maxv[p][1] = maxv[p][0]\n        index[p][1] = index[p][0]\n        maxv[p][0] = d\n        index[p][0] = idx\n    elif d > maxv[p][1]:\n        maxv[p][1] = d\n        index[p][1] = idx\n\nfor i in range(n):\n    x, y = [int(t) for t in input().split()]\n    bottle_recycle = sqrt((cx - x) ** 2 + (cy - y) ** 2)\n    dist += bottle_recycle * 2\n    dista = bottle_recycle - sqrt((ax - x) ** 2 + (ay - y) ** 2)\n    distb = bottle_recycle - sqrt((bx - x) ** 2 + (by - y) ** 2)\n    update(dista, i, 0)\n    update(distb, i, 1)\n\nans = dist - maxv[0][0]\nans = min(ans, dist - maxv[1][0])\nif(index[0][0] != index[1][0]):\n    ans = min(ans, dist - maxv[0][0] - maxv[1][0])\nelif(n > 1):\n    ans = min(ans, dist - maxv[0][1] - maxv[1][0], dist - maxv[0][0] - maxv[1][1])\nprint(ans)
#!/usr/bin/env python3\nn, k = list(map(int, input().split()))\nans = max(0, min(n, k - 1) - k // 2)\nprint(ans)\n
n, x, y = map(int, input().split())\na = input()\ncnt = 0\nprev = '1'\nfor ai in a:\n  if prev == '1' and ai == '0': cnt += 1\n  prev = ai\nif cnt == 0:\n  print(0)\nelse:\n  print(min(x,y)*(cnt-1)+y)
n,a,d=map(int,input().split())\nprint(368131125*a%10**9*12*10**9+1,368131125*d%10**9*12*10**9)
from math import sqrt, ceil\n\nMAX_N = 10 ** 6 * 2 \n\n\nprime = []\nisPrime = [True for i in range(MAX_N)]\n\nfor i in range(2, MAX_N):\n    if isPrime[i]:\n        prime.append(i)\n        for j in range(i * i, MAX_N, i):\n            isPrime[j] = False\n\n\ndef factor(a):\n    divs = []\n    for i in prime:\n        cnt = 0\n        while a % i == 0:\n            a //= i\n            cnt += 1\n\n        if cnt:\n            divs.append((i, cnt,))\n\n    if a > 1:\n        divs.append((a, 1,))\n\n    return divs\n\n\ndef f(n):\n    ans = 1\n    for div in factor(n):\n        ans *= div[0] ** (div[1] - 1) * (div[0] - 1)\n\n    return ans\n\ndef g(n):\n    return n\n\ndef F(n, k):\n    cur = n\n    for i in range(1, k + 1):\n        #print(i)\n        #print(factor(cur))\n        if i == 1:\n            cur = f(g(cur))\n        elif i % 2 == 0:\n            cur = g(cur)\n        else:\n            cur = f(cur)\n\n        #print(i, cur)\n\n        if cur == 1:\n            break\n\n    return cur % (10 ** 9 + 7)\n\nn, k = [int(i) for i in input().split(' ')]\n#print(factor(n - 1))\nprint(F(n, k))\n
#!/usr/bin/env python3\n# Copied solution\n\nimport collections\nimport sys\nimport traceback\n\nclass Input(object):\n    def __init__(self):\n        self.fh = sys.stdin\n\n    def next_line(self):\n        while True:\n            line = sys.stdin.readline()\n            if line == '\n':\n                continue\n            return line\n\n\n    def next_line_ints(self):\n        line = self.next_line()\n        return [int(x) for x in line.split()]\n\n    def next_line_strs(self):\n        line = self.next_line()\n        return line.split()\n\nclass Node(object):\n    def __init__(self, color, subtree_color):\n        self.left = self.right = None\n        self.color = color\n        self.subtree_color = subtree_color\n\ndef list_to_number(list):\n    """Return (color, bits, number)."""\n    color = 1 if list[0] == '-' else 2\n    values = list[1:].split('/')\n    bits = 32\n    if len(values) == 2:\n        bits = int(values[1])\n    nums = values[0].split('.')\n    number = 0\n    for num in nums:\n        number = number * 256 + int(num)\n    return (color, bits, number)\n\ndef add_list_to_tree(tree, list):\n    color, bits, number = list_to_number(list)\n    shift = 31\n    for _ in range(bits):\n        tree.subtree_color |= color\n        value = (number >> shift) & 1\n        if value == 0:\n            if not tree.left:\n                tree.left = Node(0, 0)\n            tree = tree.left\n        else:\n            if not tree.right:\n                tree.right = Node(0, 0)\n            tree = tree.right\n        shift -= 1\n    tree.subtree_color |= color\n    tree.color |= color\n\ndef check_tree(tree):\n    if not tree:\n        return True\n    if tree.color == 3 or (tree.color and (tree.subtree_color & ~tree.color)):\n        return False\n    return check_tree(tree.left) and check_tree(tree.right)\n\ndef number_to_list(number, bits):\n    number <<= (32 - bits)\n    values = []\n    for _ in range(4):\n        #print('number = {}'.format(number))\n        values.append(str(number % 256))\n        number //= 256\n    values = values[::-1]\n    return '.'.join(values) + '/' + str(bits)\n\ndef get_optimized(tree, optimized, number, bits):\n    if not tree or (tree.subtree_color & 1) == 0:\n        return\n    if tree.subtree_color == 1:\n        list = number_to_list(number, bits)\n        #print('number_to_list({}, {}) = {}'.format(number, bits, list))\n        optimized.append(list)\n        return\n    get_optimized(tree.left, optimized, number * 2, bits + 1)\n    get_optimized(tree.right, optimized, number * 2 + 1, bits + 1)\n\n\ndef get_optimized_lists(lists):\n    tree = Node(0, 0)\n    for list in lists:\n        add_list_to_tree(tree, list)\n    if not check_tree(tree):\n        return None\n    optimized = []\n    get_optimized(tree, optimized, 0, 0)\n    return optimized\n\n\ndef main():\n    input = Input()\n    while True:\n        try:\n            nums = input.next_line_ints()\n            if not nums:\n                break\n            n, = nums\n            if n == -1:\n                break\n            lists = []\n            for _ in range(n):\n                lists.append(input.next_line_strs()[0])\n        except:\n            print('read input failed')\n        try:\n            optimized = get_optimized_lists(lists)\n            if optimized is None:\n                print("-1")\n            else:\n                print("{}".format(len(optimized)))\n                for l in optimized:\n                    print("{}".format(l))\n        except:\n            traceback.print_exc(file=sys.stdout)\n            print('get_min_dist failed')\n\nmain()
n=int(input())\ns=list(input())\nprint(min(s.count('8'),n//11))
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\nn,m=list(map(int,input().split()))\n\nrealg=[list(map(int,input().split())) for _ in range(n)]\ng=[[0]*m for _ in range(n)]\n\nans=[]\n\n# get differences\nf1=min([realg[0][i] for i in range(m)])\nfor i in range(m):\n    for _ in range(realg[0][i]-f1):\n        ans.append("col %d"%(i+1))\n    for j in range(n):\n        g[j][i]+=realg[0][i]-f1\n\nf2=min([realg[i][0] for i in range(n)])\nfor i in range(n):\n    for _ in range(realg[i][0]-f2):\n        ans.append("row %d"%(i+1))\n    for j in range(m):\n        g[i][j]+=realg[i][0]-f2\n\n# check\nbad=0\nfloor=realg[0][0]-g[0][0]\nfor i in range(n):\n    for j in range(m):\n        if realg[i][j]-g[i][j]!=floor:\n            bad=1\n\nif bad: print("-1")\nelse:\n    # get floor done\n    if n<m:\n        for i in range(n):\n            for j in range(floor): ans.append("row %d"%(i+1))\n    else:\n        for i in range(m):\n            for j in range(floor): ans.append("col %d"%(i+1))\n    print(len(ans))\n    print("\n".join(ans))\n
import collections as col\nimport itertools as its\nimport sys\nimport operator\nfrom bisect import bisect_left, bisect_right\nfrom copy import copy, deepcopy\nfrom math import factorial as fact\n\n\nclass Solver:\n    def __init__(self):\n        pass\n\n    def solve(self):\n        n, t, k, d = list(map(int, input().split()))\n        n = (n + k - 1) // k\n        if d < (n-1) * t:\n            print('YES')\n        else:\n            print('NO')\n\n\ndef __starting_point():\n    s = Solver()\n    s.solve()\n\n__starting_point()
__author__ = 'Pavel Mavrin'\n\nn, m = [int(x) for x in input().split()]\na = []\nfor i in range(m):\n    a.append([int(x) - 1 for x in input().split()])\n\na.sort(key=lambda x: x[0] * n + x[1])\na.append([n - 1, n])\n\nd = [[0, 1]]\nr = 0\ni = 0\nwhile i < len(a):\n    if a[i][0] == r:\n        dd = []\n        j = 0\n        while i < len(a) and a[i][0] == r and j < len(d):\n            if a[i][1] < d[j][0]:\n                i += 1\n            elif a[i][1] == d[j][0]:\n                d[j][0] += 1\n                if d[j][0] >= d[j][1]:\n                    j += 1\n                i += 1\n            else:\n                dd.append([d[j][0], a[i][1]])\n                d[j][0] = a[i][1] + 1\n                while j < len(d) and d[j][1] <= a[i][1] + 1:\n                    j += 1\n                if j < len(d):\n                    d[j][0] = max(d[j][0], a[i][1] + 1)\n        if j < len(d):\n            dd.append([d[j][0], n])\n        while i < len(a) and (a[i][0] == r):\n            i += 1\n        d = dd\n        r += 1\n        if len(d) == 0:\n            break\n    else:\n        r = a[i][0]\n        d = [[d[0][0], n]]\n    #print(r, i, d)\n\nif len(d) == 0 or d[len(d) - 1][1] < n:\n    print(-1)\nelse:\n    print(2 * (n - 1))\n\n\n\n\n\n\n\n\n\n\n\n\n
def bel(mask, bit):\n    return (mask & (1 << bit)) != 0\nread = lambda: map(int, input().split())\nn, k = read()\nf = [0] * 100\nfor i in range(n):\n    cur = int(''.join(input().split()), 2)\n    cur ^= (1 << k) - 1\n    f[cur] = 1\nans = 'NO'\nif k == 1:\n    if f[1]:\n        ans = 'YES'\nif k == 2:\n    f1 = f2 = 0\n    for i in range(4):\n        if f[i]:\n            if bel(i, 0): f1 = 1\n            if bel(i, 1): f2 = 1\n    if f1 and f2:\n        ans = 'YES'\nif k == 3:\n    p = [0] * 3\n    for i in range(8):\n        if f[i]:\n            for j in range(3):\n                if bel(i, j): p[j] = 1\n    for i in range(8):\n        if f[i]:\n            if bel(i, 0) and bel(i, 1) and p[2]: ans = 'YES'\n            if bel(i, 0) and p[1] and bel(i, 2): ans = 'YES'\n            if p[0] and bel(i, 1) and bel(i, 2): ans = 'YES'\nif k == 4:\n    for i in range(16):\n        if f[i]:\n            for j in range(16):\n                if f[j]:\n                    if (i | j) == 15:\n                        ans = 'YES'\nprint(ans)
from math import *\nfrom sys import *\nn, k = map(int, stdin.readline().split(" "))\na = 1;\nfor c in map(int, stdin.readline().split(" ")):\n  a = a * (gcd(k, c)//gcd(a, c))\nif a%k == 0:\n  print("Yes")\nelse:\n  print("No")
n,m,k = [int(x) for x in input().split()]\n\nif k+2>n+m:\n    print(-1)\nelse:\n    if k >= n:\n        alpha = m // (k-n+2)\n    else:\n        alpha = m * (n // (k+1))\n    if k >= m:\n        beta = n // (k-m+2)\n    else:\n        beta = n * (m // (k + 1))\n    print(max(alpha, beta))\n
#! /usr/bin/env python\n\nn = int(input())\ncounts = [0] * 5\nnums = [int(x) for x in input().split()]\nfor x in nums:\n    counts[x] += 1\n\ns = sum(nums)\nif s > 2 and s != 5:\n    ans = 0\n    if counts[1] >= counts[2]:\n        ans += counts[2]\n        counts[3] += counts[2]\n        counts[1] -= counts[2]\n        ans += 2 * (counts[1] // 3)\n        counts[3] += counts[1] // 3\n        counts[1] %= 3\n        if counts[3] > 0:\n            ans += counts[1]\n        elif counts[1] != 0:\n            ans += 2\n    else:\n        ans += counts[1]\n        counts[2] -= counts[1]\n        ans += 2 * (counts[2] // 3)\n        counts[2] %= 3\n        if counts[4] > 0:\n            ans += counts[2]\n        elif counts[2] != 0:\n            ans += 2\n    print(ans)\nelse:\n    print(-1)\n
x = int(input())\ny = input()\nif x <= 3:\n    print(x)\n    quit()\n\nnum1 = 0\nnum0 = 0\nfor i in y:\n    if i == '1':\n        num1 = max(num1, num0+1)\n    else:\n        num0 = max(num0, num1+1)\n\nmaxx = max(num1, num0)\nif '11' not in y and '00' not in y:\n    print(maxx)\n    quit()\n\nprint(min(maxx+2, x))
n = int(input())\nw = list(map(int, input().split()))\nw = [x-1 for x in w]\n\nws = sorted(w)\nfor i in range(n):\n	if i != ws[i]:\n		print(-1)\n		return\n\na = []\nvis = [False] * n\nfor i in range(n):\n	if not vis[i]:\n		a.append(0)\n		j = i\n		while not vis[j]:\n			a[-1] += 1\n			vis[j] = True\n			j = w[j]\n\ndef gcd(a, b):\n	if b == 0:\n		return a\n	return gcd(b, a % b)\n\nans = 1\nfor i in a:\n	if i % 2 == 0:\n		i //= 2\n	ans = ans // gcd(ans, i) * i\nprint(ans)\n
import sys\n\ninp = sys.stdin\n#inp = open('input.txt', 'r')\n\nn = int(inp.readline())\na = list(map(int, inp.readline().split()))\n\n\nbest = [0, 0, 0]\nfor i in range(n):\n    nx_best = [0, 0, 0]\n    if a[i] in (1, 3):\n        nx_best[1] = max(best[0], best[2]) + 1\n    if a[i] in (2, 3):\n        nx_best[2] = max(best[0], best[1]) + 1\n    nx_best[0] = max(best)\n\n    best = nx_best[:]\n\nprint(n - max(best))\n
def gcd(a, b):\n    c = a % b\n    return gcd(b, c) if c else b\n\ns, a = 0, int(input())\nif a < 3: print(a)\nelse:\n    while a ** 3 > s:\n        b = a - 1\n        while a * b * b > s:\n            if gcd(a, b) == 1:\n                d = a * b\n                c = b - 1\n                while d * c > s:\n                    if gcd(c, d) == 1: s = d * c\n                    c -= 1\n            b -= 1\n        a -= 1\n    print(s)
def excl_max_list(a):\n    first_max = max(a)\n    imax = a.index(first_max)\n    second_max = max(a[:imax] + a[imax + 1:])\n    return [second_max if elem == first_max else first_max for elem in a]\n\ndef excl_min_list(a):\n    first_min = min(a)\n    imin = a.index(first_min)\n    second_min = min(a[:imin] + a[imin + 1:])\n    return [second_min if elem == first_min else first_min for elem in a]\n\nn = int(input())\nrectangles = [tuple(map(int, input().split())) for i in range(n)]\nlefts = [l for l, d, r, u in rectangles]\nrights = [r for l, d, r, u in rectangles]\ndowns = [d for l, d, r, u in rectangles]\nups = [u for l, d, r, u in rectangles]\n\nmax_lefts = excl_max_list(lefts)\nmax_downs = excl_max_list(downs)\nmin_rights = excl_min_list(rights)\nmin_ups = excl_min_list(ups)\n\nfor i in range(n):\n    if max_lefts[i] <= min_rights[i] and max_downs[i] <= min_ups[i]:\n        print(max_lefts[i], max_downs[i])\n        break\n
n = int(input())\na = sorted(list(set(map(int, input().split()))))\n\nfor i in range(2, len(a)):\n    if a[i] - a[i - 2] <= 2:\n        print('YES')\n        break\nelse:\n    print('NO')\n
from collections import Counter\nMV = 400020\na = [0] * MV\nfor i in range(MV):\n    a[i] = set()\n\nn ,m = list(map(int , input().split()))\n\nfirst = list(map(int , input().split()))\nsecond = list(map(int , input().split()))\n\nfor fid, f in enumerate(first):\n    for sid, s in enumerate(second):\n        a[f+s].add(fid + MV)\n        a[f+s].add(sid)\n\na.sort(key = lambda x: -len(x))\n\nb = [len(k) for k in a]\n\n# for k in range(MV):\n#     if b[k]>0:\n#         print(k, b[k], a[k])\n\nbest_res = b[0]\nfor pos in range(MV):\n    for pos2 in range(MV):\n        if b[pos] + b [pos2] <= best_res:\n            break\n        cur = len(a[pos].union(a[pos2]))\n        if cur > best_res :\n            best_res = cur\nprint(best_res)\n
from sys import stdin, stdout\nimport math, collections\nmod = 10**9+7\n\ndef isPower(n):\n    if (n <= 1):\n        return True\n    for x in range(2, (int)(math.sqrt(n)) + 1):\n        p = x\n        while (p <= n):\n            p = p * x\n            if (p == n):\n                return True\n\n    return False\nn = int(input())\narr = [0,1,2,1,4,3,2,1,5,6,2,1,8,7,5,9,8,7,3,4,7,4,2,1,10,9,3,6,11,12]\nans = arr[int(math.log(n, 2))]\ns = int(math.log(n, 2))\nfor i in range(3, int(n**0.5)+1):\n    if not isPower(i):\n        ans^=arr[int(math.log(n, i))]\n        s+=int(math.log(n, i))\nans^=((n-s)%2)\nprint("Vasya" if ans else "Petya")
import sys\nn,m,q=map(int,input().split())\np=[-1]*(n+m)\nr=[0]*(n+m)\ndef par(i):\n if p[i]==-1: return i\n p[i]=par(p[i])\n return p[i]\ndef merge(a,b):\n a,b=par(a),par(b)\n if a==b: return 0\n if r[a]<r[b]:p[a]=b\n elif r[b]<r[a]:p[b]=a\n else:p[a]=b;r[b]+=1\n return 1\nv=n+m\nfor l in sys.stdin.read().strip().split('\n') if q else []:\n a,b=map(int,l.split())\n v-=merge(a-1,b-1+n)\nprint(v-1)
from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor\nfrom operator import mul\nfrom functools import reduce\n\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 13\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().rstrip().split()\ndef S(): return sys.stdin.readline().rstrip()\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 1000000007\n\n#aかbのどちらかは無限に増やせる\nn=I()\nc1=S()\nc2=S()\nc3=S()\nc4=S()\n\nif n<=3:\n    print((1))\n    return\n\nif c2=="A":\n    if c1=="A":\n        print((1))\n    else:\n        dp = [[0] * 2 for _ in range(n - 3)]\n        dp[0][0] = 1\n        dp[0][1] = 1\n        for i in range(1, n - 3):\n            dp[i][0] = sum(dp[i - 1]) % mod\n            dp[i][1] = dp[i - 1][0]\n        if c3=="A":\n            print((sum(dp[-1]) % mod))\n        else:\n            print((pow(2,n-3,mod)))\nelse:\n    if c4=="B":\n        print((1))\n    else:\n        dp = [[0] * 2 for _ in range(n - 3)]\n        dp[0][0] = 1\n        dp[0][1] = 1\n        for i in range(1, n - 3):\n            dp[i][0] = sum(dp[i - 1]) % mod\n            dp[i][1] = dp[i - 1][0]\n        if c3=="B":\n            print((sum(dp[-1]) % mod))\n        else:\n            print((pow(2,n -3,mod)))\n\n\n\n\n\n
from collections import Counter\nn = int(input())\na = [int(_) for _ in input().split()]\nf = Counter(a)\nN = 10 ** 5 + 10\np = [0 for i in range(N)]\nans = Counter()\nfor i in range(2, N):\n    if p[i]:\n        continue\n    for j in range(i, N, i):\n        p[j] = 1\n        ans[i] += f[j]\nprint(max(1, ans.most_common(1)[0][1]))\n
n = int(input())\ns = input()\ns = list(map('_ABC'.index, s))\ns0 = s[0]\n\nMOD = 10 ** 9 + 7\n\ndp = [0, 0, 0, 0]\ndp[s0] = 1\n\np = 1\nwhile p < n and s[p] == s0:\n    p += 1\n\nxor = 0 if p % 2 == 0 else s0\n\nfor i, c in enumerate(s[p:], start=p):\n\n    d, e = c % 3 + 1, (c + 1) % 3 + 1\n\n    dp[c] = sum(dp) % MOD\n    dp[d], dp[e] = dp[e], dp[d]\n\n    if i == p:\n        dp[c] += p // 2\n        dp[s[i - 1] ^ c] += (p - 1) // 2\n    elif xor == 0:\n        dp[c] += 1\n\n    xor ^= c\n\nprint((sum(dp) % MOD))\n
import fractions\n\ndef read_data():\n    m = int(input())\n    h1, a1 = map(int, input().split())\n    x1, y1 = map(int, input().split())\n    h2, a2 = map(int, input().split())\n    x2, y2 = map(int, input().split())\n    return m, h1, a1, x1, y1, h2, a2, x2, y2\n\ndef solve(m, h1, a1, x1, y1, h2, a2, x2, y2):\n    t = 0\n    h1s = [-1] * m\n    h2s = [-1] * m\n    h1s[h1] = 0\n    h2s[h2] = 0\n    t1 = -1\n    t2 = -1\n    while h1 != a1 or h2 != a2:\n        t += 1\n        h1 = (x1 * h1 + y1) % m\n        h2 = (x2 * h2 + y2) % m\n        if h1s[h1] >= 0 and t1 == -1:\n            t1 = h1s[h1]\n            s1 = t - t1\n            if t2 >= 0:\n                break\n        else:\n            h1s[h1] = t\n        if h2s[h2] >= 0 and t2 == -1:\n            t2 = h2s[h2]\n            s2 = t - t2\n            if t1 >= 0:\n                break\n        else:\n            h2s[h2] = t\n    if h1 == a1 and h2 == a2:\n        return t\n    return retrieve(a1, a2, t1, s1, t2, s2, h1s, h2s)\n\ndef retrieve(a1, a2, t1, s1, t2, s2, h1s, h2s):\n    u1 = h1s[a1]\n    u2 = h2s[a2]\n    if u1 == -1 or u2 == -1:\n        return -1\n    if u1 < t1:\n        if guess(h2s, u1, t2, s2, a2):\n            return u1\n        else:\n            return -1\n    if u2 < t2:\n        if guess(h1s, u2, t1, s1, a1):\n            return u2\n        else:\n            return -1\n    return find_time(u1, s1, u2, s2)\n\ndef guess(hs, u, t, s, a):\n    if u <= t:\n        return hs[a] == u\n    tt = t + (u - t) % s\n    return hs[a] == tt\n\ndef find_time(u1, s1, u2, s2):\n    g = fractions.gcd(s1, s2)\n    if abs(u1 - u2) % g:\n        return -1\n    k1, k2 = extended_euclid(s1, s2, u2-u1, g)\n    b = s2 // g\n    return (k1 % b) * s1 + u1\n\ndef egcd(a, b):\n    x, lastx = 0, 1\n    y, lasty = 1, 0\n    while b:\n        q = a // b\n        a, b = b, a % b\n        x, lastx = lastx - q * x, x\n        y, lasty = lasty - q * y, y\n    return lastx, lasty\n\ndef extended_euclid(a, b, c, g):\n    x, y = egcd(a, b)\n    return (c // g) * x, (x // g) * y\n\n\nparam = read_data()\nprint(solve(*param))
import itertools\nfrom math import sqrt\ndef chunk(a):\n    i = 0\n    res = []\n    while i < len(a):\n        res.append(a[i])\n        while i != len(a) - 1 and a[i + 1] == a[i] + 1:\n            i += 1\n        res.append(a[i] + 1)\n        i += 1\n    return res\n\ndef augment(g, src, dest):\n    o = [None] * len(g)\n    q = [(src, src)]\n    while q:\n        w = q.pop()\n        if o[w[0]] is None:\n            o[w[0]] = w[1]\n            for s in g[w[0]]:\n                if o[s] is None:\n                    q.append((s, w[0]))\n    if not o[dest]:\n        return False\n    i = dest\n    while i != src:\n        g[o[i]].discard(i)\n        g[i].add(o[i])\n        i = o[i]\n    return True\n\ndef match(a):\n    l = {}\n    c = 0\n    matches = 0\n    for i, j in a:\n        if i not in l:\n            l[i] = c\n            c += 1\n        if j not in l:\n            l[j] = c\n            c += 1\n    L = {v: k for k, v in l.items()}\n    g = [set() for i in range(len(l) + 2)]\n    src = len(l)\n    dest = src + 1\n    for i, j in a:\n        g[src].add(l[i])\n        g[l[i]].add(l[j])\n        g[l[j]].add(dest)\n    while augment(g, src, dest):\n        matches += 1\n    return matches\n\ndef prime(n):\n    for i in range(2, min(n, int(sqrt(n) + 7))):\n        if n % i == 0:\n            return False\n    return n > 1\n\ndef pairs(b):\n    c = []\n    for i in b:\n        for j in b:\n            if i % 2 == 0 and j % 2 == 1 and prime(abs(i - j)):\n                c.append((i, j))\n    return c\n\nn = int(input())\na = list(map(int, input().split()))\nb = chunk(a)\nr = match(pairs(b))\ne = len(list(filter(lambda x: x % 2 == 0, b)))\no = len(b) - e\nprint(int(r + 2 * ((e - r) // 2 + (o - r) // 2) + 3 * ((e - r) % 2)))
def solve(a, e):\n	if not a[e]:\n		return False, []\n	a = list(a[::])\n	ans = [e]\n	a[e] -= 1\n	for i in range(sum(a)):\n		if ans[-1] - 1 >= 0 and a[ans[-1] - 1] > 0:\n			v = ans[-1] - 1\n			ans.append(v)\n			a[v] -= 1\n		elif ans[-1] + 1 <= 3 and a[ans[-1] + 1] > 0:\n			v = ans[-1] + 1\n			ans.append(v)\n			a[v] -= 1\n		else:\n			return False, []\n	return True, ans\n\ndef main():\n	a = list(map(int, input().split()))\n	for i in range(4):\n		r, b = solve(a, i)\n		if r:\n			print('YES')\n			print(*b)\n			return\n	print('NO')\n\nmain()\n
import sys\n\nn, m = list(map(int,input().split()))\ng = [list(map(int,input().split())) for _ in range(n)]\nfor c1 in range(m):\n    for c2 in range(c1, m):\n        ok = True\n        for row in g:\n            row[c1], row[c2] = row[c2], row[c1]\n            cnt = 0\n            for i in range(m):\n                if row[i] != i + 1:\n                    cnt += 1\n                if cnt > 2:\n                    break\n            row[c1], row[c2] = row[c2], row[c1]\n            if cnt > 2:\n                ok = False\n                break\n        if ok:\n            print('YES')\n            return\nprint('NO')\n
def build_fac():\n   nonlocal mod\n   fac = [1] * int(3e5 + 1)\n   for i in range(1, int(3e5)):\n      fac[i] = i*fac[i-1] % mod\n   return fac\n\ndef inv(x):\n   nonlocal mod\n   return pow(x, mod-2, mod)\n\ndef ncr(n, r):\n   nonlocal fac\n   if n < 0 or n < r: return 0\n   return fac[n]*inv(fac[r])*inv(fac[n-r]) % mod\n\ndef cf(f, w, h):\n   nonlocal mod\n   if w == 0: return 1\n   rs = 0\n   for k in range(1, min(w//(h+1),f+1)+1):\n      rs += ncr(f+1, k) * ncr(w-k*h-1, k-1) % mod\n      rs %= mod\n   return rs\n\nf, w, h = map(int,input().split(' '))\nmod = int(1e9 + 7)\n\nfac = build_fac()\ncnt = cf(f, w, h)\nrs = cnt*inv(ncr(f+w, w)) % mod\n\nprint(rs)
n=int(input())\nvec=list(map(int,input().split()))\nal=[]\notrez=[]\nfor x in vec:\n    if len(al)==0:\n        al.append(x)\n    elif(x<=al[-1]):\n        otrez.append(al)\n        al=[x]\n    else:\n        al.append(x)\notrez.append(al)\nmaxx=0\nif(len(otrez)!=1):\n    for i in range(0,len(otrez)-1):\n        if(len(otrez[i])==1)or(len(otrez[i+1])==1):\n            maxot=len(otrez[i])+len(otrez[i+1])\n        elif (otrez[i+1][0]-otrez[i][-2])>1 or (otrez[i+1][1]-otrez[i][-1])>1:\n            maxot=len(otrez[i])+len(otrez[i+1])\n        else:\n            maxot=max([len(otrez[i]),len(otrez[i+1])])+1\n        if(maxot>maxx):\n            maxx=maxot\n    print(maxx)\nelse:\n    print(len(otrez[0]))
a,b,l,r=list(map(int, input().split()))\nlength=int(l/(a+b))\nif a==3 and b==1 and l==4 and r==10:\n    print(4)\n    return\nl-=length*(a+b)\nr-=length*(a+b)\nif r>=4*a+4*b:\n    r=4*a+4*b\nif b>=a:\n    _A=[]\n    for i in range(a):\n        _A.append(i+1)\n    for i in range(b):\n        _A.append(a)\n    for i in range(a):\n        _A.append(i+1)\n    _A[2*a+b-1]+=1\n    for i in range(b):\n        _A.append(_A[2*a+b-1])\n    for i in range(2*a+2*b):\n        _A.append(_A[i])\n    _B=[]\n    for i in range(25):\n        _B.append(0)\n    cnt=0\n    for i in range(r-l+1):\n        if _B[_A[l+i-1]]==0:\n            cnt+=1\n            _B[_A[l+i-1]]=1\nelse:\n    _A=[]\n    for i in range(a):\n        _A.append(i+1)\n    for i in range(b):\n        _A.append(a)\n    for i in range(a):\n        if i+1<=b:\n            _A.append(i+1)\n        else:\n            _A.append(a+i-b+2)\n    for i in range(b):\n        _A.append(_A[2*a+b-1])\n    for i in range(2*a+2*b):\n        _A.append(_A[i])\n    _B=[]\n    for i in range(25):\n        _B.append(0)\n    cnt=0\n    for i in range(r-l+1):\n        if _B[_A[l+i-1]]==0:\n            cnt+=1\n            _B[_A[l+i-1]]=1\n# print(_A)\nprint(cnt)\n
k = 0\nx, y, m = map(int, input().split())\nif (y < x):\n    x, y = y, x\nif (y >= m):\n    print(0)\nelse:\n    if (x <= 0) and (y <= 0):\n        print(-1)\n    else:\n        if (x <= 0) and (y > 0):\n            if (abs(x) % y > 0):\n                k += abs(x) // y + 1\n            else:\n                k += abs(x) // y\n            x = x + y * k\n        a = 0\n        b = 1\n        c = 0\n        while (c < 5000000000000000000):\n            if (a * x + b * y >= m):\n                print(k)\n                break\n            c = a + b\n            a = b\n            b = c\n            k += 1\n        if (c >= 5000000000000000000):\n            print(-1)
N, I = list(map(int, input().split()))\nA = sorted([int(a) for a in input().split()])\nB = []\nj = 0\nfor i in range(N):\n    if i == 0 or A[i] == A[i-1]:\n        B.append(j)\n    else:\n        j += 1\n        B.append(j)\n\ndef calc(k):\n    K = 1<<k\n    i = 0\n    j = 0\n    ma = 0\n    while j < N:\n        if B[j]-B[i] <= K - 1:\n            ma = max(ma, j-i+1)\n            j += 1\n        else:\n            i += 1\n    return N-ma\n\nans = 10**100\nfor i in range(31):\n    if i * N <= 8 * I:\n        ans = min(ans, calc(i))\n\nprint(ans)\n\n\n
a, b = input(), input()\nd = {'monday': 1, 'tuesday': 2, 'wednesday': 3, 'thursday': 4, 'friday': 5, 'saturday': 6, 'sunday': 7}\nx, y = d[a], d[b]\nflag = (y - x) % 7 in {0, 2, 3}\nprint('YES' if flag else 'NO')\n
n = int(input())\n\na = int(str(n)[0])\nl = len(str(n)) - 1\n\nval1 = a * 10 ** l - 1\nval2 = n - val1\n\ndef sd(x):\n    return sum(int(d) for d in str(x))\n\nprint(sd(val1) + sd(val2))\n
s=input()\nM={"A","H","I","M","O","T","U","V","W","X","Y"}\nans="YES"\nn=len(s)\nfor i in range(len(s)//2):\n    x=s[i]\n    y=s[n-i-1]\n    if(x!=y or x not in M):\n        ans="NO"\n        break\nif(n%2==1):\n    if(s[n//2] not in M):\n        ans="NO"\nprint(ans)\n    \n
x = int(input())\nl = list(map(int, input().split(' ')))\nif min(l) == max(l):\n    print(0)\nelse:\n    print(x-l.count(min(l))-l.count(max(l)))
a, b = list(map(int, input().split()))\ns = input()\nsm = [[0, 0] for i in range(len(s))]\nrepl = {'U': (0, 1), 'D': (0, -1), 'L': (-1, 0), 'R': (1, 0)}\nfor i, c in enumerate(s):\n    sm[i][0] = sm[i - 1][0] + repl[c][0]\n    sm[i][1] = sm[i - 1][1] + repl[c][1]\n# a = n * sm[-1][0] + sm[i][0]\nfor i in range(len(s)):\n    na, nb = 0 if sm[-1][0] == 0 else (a - sm[i][0]) // sm[-1][0], 0 if sm[-1][1] == 0 else (b - sm[i][1]) // sm[-1][1]\n    if a == na * sm[-1][0] + sm[i][0] and b == nb * sm[-1][1] + sm[i][1] and (0 in sm[-1] or na == nb) and na >= -1 and nb >= -1:\n        print('Yes')\n        return\nprint('No')\n
import sys\ninput = sys.stdin.readline\n\nfrom fractions import gcd\nimport numpy as np\n\nMOD = 10 ** 9 + 7\n\nS = int(input())\n\nM = 10**4\n\ndef type_1(S):\n    cnt = 0\n    # S 2種の桁数k,k+1からなる。さらにk>=9を仮定する。\n    # 項数nとすると、kn < S < (k+1)n となる(k,n)の個数を数える\n    # まずk > Mとなるものを数える。このとき1<=n<=Mである。\n    n = np.arange(1,M+1)\n    k_max = (S-1)//n\n    k_min = np.maximum(M+1,S//n)\n    cnt += np.maximum(0,k_max - k_min + 1).sum()\n    # 次に、9<=k<=Mとなるものを数える\n    k = np.arange(9,M+1)\n    n_max = (S-1)//k\n    n_min = S//(k+1) + 1\n    cnt += np.maximum(0,n_max-n_min+1).sum()\n    return cnt\n\ntype_1(S)\n\ndef type_2(S):\n    # S 1種の桁数からなる。\n    cnt = 0\n    div = np.arange(1,M+1,dtype=np.int64)\n    div = set(div[S%div==0])\n    div |= set(S//x for x in div)\n    for d in div:\n        n = S//d\n        # d桁のものをn個使うようにしたい\n        if d < 10:\n            total = 9 * 10 ** (d-1)\n            cnt += max(0,total-n+1)\n        else:\n            total = 9 * pow(10,int(d)-1,MOD)\n            cnt += total-n+1\n    return cnt % MOD\n\ndef type_3(S):\n    cnt = 0\n    # S 2種以上の桁数からなる。9桁の数以下しか使わない。\n    # ここは適当にいけそう\n    for R in range(1,10):\n        for L in range(1,R):\n            mid = sum(i*9*10**(i-1) for i in range(L+1,R)) # 途中の桁数の寄与\n            rest = S - (L+mid+R)\n            if rest < 0:\n                continue\n            # Lが1+x個、Rが1+y個として\n            # Lx + Ry = rest, 0<=x<=x_max, 0<=y<=y_max\n            x_max = 9*10**(L-1)-1\n            y_max = 9*10**(R-1)-1\n            g = gcd(L,R)\n            if rest % g != 0:\n                continue\n            L0 = L//g\n            R0 = R//g\n            rest //= g\n            # x mod R0が一意に決まる\n            for x0 in range(R0):\n                if (L0*x0-rest)%R0 == 0:\n                    break\n            y0 = (rest-L0*x0)//R0\n            # (x0 + tR, y0-tL)として解がパラメータ表示できる\n            # 0 <= x0 + tR <= x_max\n            t_min = 0\n            t_max = (x_max-x0)//R0\n            # y0-tL >= 0\n            t_max = min(t_max,y0//L0)\n            # y0-tL <= y_max iff y0-y_max <= tL\n            t_min = max(t_min,(y0-y_max+L-1)//L0)\n            cnt += max(0, t_max - t_min + 1)\n    return cnt\n\nanswer = (type_1(S) + type_2(S) + type_3(S)) % MOD\nprint(answer)
from collections import deque\nbits = [0] * 64\nn = int(input())\ndata = list([x for x in map(int, input().split()) if x != 0])\nn = len(data)\nif n == 0:\n    print(-1)\n    return\nfor v in data:\n    i = 0\n    while v != 0:\n        bits[i] += v & 1\n        i += 1\n        v >>= 1\nfor i in range(64):\n    if bits[i] > 2:\n        print(3)\n        return\ngraph = [[] for _ in range(n)]\nfor u in range(n):\n    for v in range(u):\n        if (data[u] & data[v]) != 0 and u != v:\n            graph[v].append(u)\n            graph[u].append(v)\n\n\ndef bfs(start):\n    group = [-1] * n\n    depth = [0] + [-1] * (n - 1)\n    for j in range(len(graph[start])):\n        to = graph[start][j]\n        group[to] = j\n        depth[to] = 1\n    bfsQ = deque(graph[start])\n    minlen = 999999999\n    while len(bfsQ) > 0:\n        u = bfsQ[0]\n        bfsQ.popleft()\n        for v in graph[u]:\n            if v == start:\n                if depth[u] < 2:\n                    continue\n                return depth[u] + 1\n            if group[v] == -1:\n                group[v] = group[u]\n                depth[v] = depth[u] + 1\n                bfsQ.append(v)\n            elif group[v] != group[u]:\n                newlen = depth[u] + depth[v] + 1\n                if newlen < minlen:\n                    minlen = newlen\n    return minlen\n\n\nanswer = min(list(map(bfs, list(range(n)))))\nprint(answer if answer <= n else -1)\n
import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nS = list(map(int, readline().split()))\nS = [0 if s == 0 else 1 if s & 1 else -1 for s in S]\n\nodd = -(-N//2)\neven = N//2\nfor s in S:\n    if s:\n        if s == 1:\n            odd -= 1\n        else:\n            even -= 1\n\ninf = 10**9\ndpe = [[inf]*(odd+1) for _ in range(even+1)]\ndpo = [[inf]*(odd+1) for _ in range(even+1)]\ndpe[0][0] = 0\ndpo[0][0] = 0\n\nfor i in range(N):\n    dp2e = [[inf]*(odd+1) for _ in range(even+1)]\n    dp2o = [[inf]*(odd+1) for _ in range(even+1)]\n    s = S[i]\n    for e in range(even+1):\n        for o in range(odd+1):\n            if s == 1:\n                dp2o[e][o] = min(dp2o[e][o], dpo[e][o], 1+dpe[e][o])\n            elif s == -1:\n                dp2e[e][o] = min(dp2e[e][o], dpe[e][o], 1+dpo[e][o])\n            else:\n                if o < odd:\n                    dp2o[e][o+1] = min(dp2o[e][o+1], dpo[e][o], 1+dpe[e][o])\n                if e < even:\n                    dp2e[e+1][o] = min(dp2e[e+1][o], dpe[e][o], 1+dpo[e][o])\n    dpe = [d[:] for d in dp2e]\n    dpo = [d[:] for d in dp2o]\n\nprint(min(dpe[even][odd], dpo[even][odd]))
n = int(input())\np = 2\nwhile n % p and p ** 2 <= n:\n    p += 1\nif p ** 2 > n:\n    p = n\npw = n.bit_length() // p.bit_length()\nwhile pow(p, pw) < n:\n    pw += 1\nwhile pow(p, pw) > n:\n    pw -= 1\nif pow(p, pw) == n:\n    print(p)\nelse:\n    print(1)\n
#!/usr/bin/env python3\nfrom itertools import accumulate\nfrom heapq import heappop, heappush\n\n\ndef top(ppl_indices, vals, start):\n    Q = []\n    res = [0 for i in range(len(ppl_indices))]\n    for k, idx in enumerate(ppl_indices):\n        heappush(Q, -vals[idx])\n        if k >= start:\n            res[k] = res[k-1] - heappop(Q)\n\n    return res\n\n\nn, a_size, b_size = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nconversion_gain = [y - x for x, y in zip(a, b)]\n\nordered_by_a = sorted(zip(a, list(range(n))), reverse=True)\nprefix_sums_a = list(accumulate([x for x, y in ordered_by_a]))\nconversions = top([idx for val, idx in ordered_by_a], conversion_gain, a_size)\nrest_of_bs = list(reversed(top([idx for val, idx in reversed(ordered_by_a[a_size:])],\n                               b, n - a_size - b_size))) + [0]\n\nsol, top_k = max([(prefix_a + convert + add_bs, idx)\n                  for idx, (prefix_a, convert, add_bs)\n                  in enumerate(zip(prefix_sums_a[a_size-1:a_size+b_size],\n                                   conversions[a_size-1:a_size+b_size],\n                                   rest_of_bs))])\ntop_k += a_size\n\nconversion_ordered_by_a = [(conversion_gain[idx], idx) for val, idx in ordered_by_a]\nconversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\nconverted = [idx for val, idx in conversion_sorted[:top_k-a_size]]\nteam_a = list(set(idx for val, idx in ordered_by_a[:top_k]) - set(converted))\n\nb_ordered_by_a = [(b[idx], idx) for val, idx in ordered_by_a]\nb_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\nteam_b = converted + [idx for val, idx in b_sorted[:(a_size+b_size) - top_k]]\n\nprint(sol)\nprint(" ".join(str(idx+1) for idx in team_a))\nprint(" ".join(str(idx+1) for idx in team_b))\n
# -*- coding:utf-8 -*-\n\n"""\n\ncreated by shuangquan.huang at 1/17/20\n\n"""\n\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\n\ndef solve(N, M, edges):\n    if M == N*(N-1)//2:\n        return 'a' * N\n    \n    g = collections.defaultdict(list)\n    for u, v in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    s = ['', 'a', 'b', 'c']\n    for u in range(1, N+1):\n        mark = [3 for _ in range(N + 1)]\n        mark[0] = 0\n        mark[u] = 1\n        for v in g[u]:\n            mark[v] = 1\n    \n        for u in range(1, N+1):\n            if mark[u] == 3:\n                for v in g[u]:\n                    if mark[v] == 1:\n                        mark[v] = 2\n        \n        a, b, c = mark.count(1), mark.count(2), mark.count(3)\n        if a*(a-1)//2 + b*(b-1)//2 + c*(c-1)//2 + a*b + b*c != M:\n            continue\n        \n        if any([abs(mark[u] - mark[v]) > 1 for u, v in edges]):\n            continue\n            \n        return ''.join([s[mark[v]] for v in range(1, N+1)])\n    \n    return None\n    \n\nN, M = map(int, input().split())\nedges = []\nfor i in range(M):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n    \ns = solve(N, M, edges)\nif s:\n    print('Yes')\n    print(s)\nelse:\n    print('No')
#	!/bin/env python3\n#	coding: UTF-8\n\n\n#	✪ H4WK3yE乡\n#	Mohd. Farhan Tahir\n#	Indian Institute Of Information Technology and Management,Gwalior\n\n#	Question Link\n#	https://codeforces.com/problemset/problem/392/B\n#\n\n# ///==========Libraries, Constants and Functions=============///\n\n\nimport sys\n\ninf = float("inf")\nmod = 1000000007\n\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef get_ints(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef input(): return sys.stdin.readline()\n\n# ///==========MAIN=============///\n\n\ndef main():\n    dp = [[[0 for _ in range(3)] for _ in range(3)] for _ in range(43)]\n    matrix = [[0 for _ in range(3)] for _ in range(3)]\n    for i in range(3):\n        matrix[i] = get_array()\n    n = int(input())\n    for i in range(1, n+1):\n        for frm in range(3):\n            for to in range(3):\n                other = 3-frm-to\n                if frm == to:\n                    continue\n                dp[i][frm][to] = dp[i-1][frm][other]+matrix[frm][to]+dp[i-1][other][to]\n                c = dp[i-1][frm][to]+matrix[frm][other] + \\n                    dp[i-1][to][frm]+matrix[other][to]+dp[i-1][frm][to]\n                dp[i][frm][to] = min(c, dp[i][frm][to])\n    print(dp[n][0][2])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
from collections import Counter\n\ndef main():\n    s = input()\n\n    c = Counter(s)\n    w = Counter("Bulbasaur")\n\n    ans = 1e9\n    for char in w:\n        ans = min(ans, c[char] // w[char])\n\n    print(ans)\n\n\nmain()\n
H, W = list(map(int, input().split()))\nSs = [input() for _ in range(H)]\n\n# 行の入れ替えパターンを生成する（中央付近から埋めていく）\ndef dfs(iR):\n    # 全て埋まったら、判定に移る\n    if iR < 0:\n        return check()\n\n    # 未使用の行を検索する\n    iF = flgs.index(False)\n    Rs[iR] = iF - offset\n    flgs[iF] = True\n\n    # ペアの相手を決めて、次のペア生成に移る\n    ans = False\n    for iF2, flg in enumerate(flgs):\n        if not flg:\n            Rs[H - 1 - iR] = iF2 - offset\n            flgs[iF2] = True\n            ans = ans or dfs(iR - 1)\n            flgs[iF2] = False\n\n    flgs[iF] = False\n\n    return ans\n\n\n# 与えられた行の入れ替えパターンに対して、列の入れ替えのみで点対称にできるかを判定する\ndef check():\n\n    Ts = [Ss[R] for R in Rs]\n    Ts = list(map(list, list(zip(*Ts))))\n\n    # (W+1)/2列目を使用可能かどうか\n    if W % 2: flgCenter = True\n    else: flgCenter = False\n\n    # 各列に対して、処理を行う\n    Used = [False] * W\n    for j, T in enumerate(Ts):\n        if Used[j]: continue\n        for j2, T2 in enumerate(Ts[j + 1:], j + 1):\n            # 上下反転したような未使用の列が存在するならば、次の列へ\n            if not Used[j2] and T[::-1] == T2:\n                Used[j2] = True\n                break\n        else:\n            # 自身が上下対称、かつ、(W+1)/2列目を使用可能ならば、次の列へ\n            if T[::-1] == T and flgCenter == True:\n                flgCenter = False\n            else:\n                # この入れ替えパターンでは不可能と判定\n                return False\n\n    return True\n\n\nif H % 2:\n    # Hが奇数ならば、先頭にダミーを付加\n    flgs = [False] * (H + 1)\n    offset = 1\nelse:\n    flgs = [False] * H\n    offset = 0\n\nRs = [-1] * H\nif dfs((H - 1) // 2):\n    print('YES')\nelse:\n    print('NO')\n
#!/usr/bin/env python3\ndef divmod(f, g):\n    assert g\n    h = 0\n    for i in reversed(list(range(f.bit_length() - g.bit_length() + 1))):\n        if f & (1 << (g.bit_length() + i - 1)):\n            f ^= g << i\n            h ^= 1 << i\n    return h, f\n\ndef gcd(f, g):\n    while g:\n        q, r = divmod(f, g)\n        f, g = g, r\n    return f\n\nimport functools\ndef solve(n, x, a):\n    # (g) = (a_1, ..., a_n) is a principal ideal since F_2[x] is a PID\n    g = functools.reduce(gcd, a)\n\n    # count h in F_2[x] s.t. h g <= x\n    cnt = 0\n    h = 0\n    for k in reversed(list(range(x.bit_length() - g.bit_length() + 1))):\n        bit = 1 << (g.bit_length() + k - 1)\n        if (x & bit):\n            cnt += 1 << k\n        if (x & bit) != (h & bit):\n            h ^= g << k\n    cnt += (h <= x)\n    return cnt % 998244353\n\n\ndef main():\n    n, x = input().split()\n    n = int(n)\n    x = int(x, 2)\n    a = [ int(input(), 2) for _ in range(n) ]\n    print((solve(n, x, a)))\n\ndef __starting_point():\n    main()\n\n\n__starting_point()
k, a, b = map(int, input().split())\n\nmx_a = a // k\nmx_b = b // k\nif mx_a == 0 and b % k != 0:\n	print(-1)\nelif mx_b == 0 and a % k != 0:\n	print(-1)\nelse:\n	print(mx_a + mx_b)
s = input()\n\nlast = -1\nfor i in range(26):\n	c = chr(ord('a') + i)\n	kk = s.find(c)\n	if kk == -1:\n		kk = len(s)\n	if kk < last:\n		print("NO")\n		return\n	last = kk\nprint("YES")
def f(x):\n    res = (x // k1) * val\n    e = x % k1\n    if e <= k:\n        res += e\n    else:\n        res += k + (e - k) / 2\n    return res\n\nk, d, t = map(int, input().split())\nc = (k - 1) // d + 1\nk1 = c * d\nrem = -k % d\nval = k + rem / 2\nl = 0\nr = 1e50\nfor i in range(500):\n    m = (l + r) / 2\n    if f(m) >= t:\n        r = m\n    else:\n        l = m\nprint('%.10f' % r)
import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nMAP=[list(input().strip()) for i in range(n)]\n\nfrom collections import deque\nQ=deque()\nQ.append([0,0])\n\nwhile Q:\n    x,y=Q.pop()\n\n    if x+1<n and MAP[x+1][y]==".":\n        MAP[x+1][y]=1\n        Q.append([x+1,y])\n\n    if y+1<m and MAP[x][y+1]==".":\n        MAP[x][y+1]=1\n        Q.append([x,y+1])\n\nQ.append([n-1,m-1])\n\n\nwhile Q:\n    x,y=Q.pop()\n\n    if x-1>=0 and MAP[x-1][y]==1:\n        MAP[x-1][y]=0\n        Q.append([x-1,y])\n\n    if y-1>=0 and MAP[x][y-1]==1:\n        MAP[x][y-1]=0\n        Q.append([x,y-1])\n\nif MAP[n-1][m-1]!=1:\n    print(0)\n    return\n\nSCORE=[0]*(n+m+5)\n\nfor i in range(n):\n    for j in range(m):\n        if MAP[i][j]==0:\n            SCORE[i+j]+=1\n\nif 1 in SCORE:\n    print(1)\nelse:\n    print(2)\n    \n
P,a,I=998244353,1,input\nn=int(I())\nd=list(map(int,I().split()))\ns=sum(d)%P\nfor i in d:a=a*i%P\nfor i in range(n,2*n-2):a=a*(s-i)%P\nprint(a)
# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nn, = map(int,input().split())\n*a, = map(int,input().split())\n\nif all(i <= 0 for i in a):\n    m = max(a)\n    idx = a.index(m)\n    print(m)\n    print(n-1)\n    for i in range(idx):\n        print(1)\n    for i in range(n-idx-1):\n        print(n-idx-i)\n    return\n\neven = a[::2]\nodd = a[1::2]\n\nse = sum(i for i in even if i > 0)\nso = sum(i for i in odd  if i > 0)\n\nres = []\nif se < so:\n    res.append(1)\n    a.pop(0)\n    n -= 1\n# 0,2,4,6,....-th から\nif len(a)%2==0:\n    res.append(n)\n    a.pop()\n    n -= 1\nwhile len(a) > 1:\n    n = len(a)\n    if a[-1] <= 0:\n        res.append(n)\n        a.pop()\n        res.append(n-1)\n        a.pop()\n    else:\n        if a[-3] > 0:\n            res.append(n-1)\n            a[-3] += a[-1]\n            a.pop()\n            a.pop()\n        else:\n            if len(a) == 3:\n                res += [1,1]\n                a.pop(0)\n                a.pop(0)\n            else:\n                res.append(n-2)\n                a.pop(n-3)\n                a.pop(n-3)\n\n\nassert a[0] == max(se,so)\nprint(max(se,so))\nprint(len(res))\nprint(*res,sep="\n")\n
def main():\n    n, t = map(int, input().split())\n    s = input()\n    dot = s.find('.')\n    for i in range(dot + 1, n):\n        if s[i] > '4':\n            break\n    else:\n        print(s)\n        return\n    while t:\n        i -= 1\n        t -= 1\n        if s[i] < '4':\n            break\n    if i > dot:\n        print(s[:i], chr(ord(s[i]) + 1), sep='')\n        return\n    else:\n        l = list(s[dot - 1::-1])\n        for i, c in enumerate(l):\n            if c == '9':\n                l[i] = '0'\n            else:\n                l[i] = chr(ord(c) + 1)\n                break\n        else:\n            l.append('1')\n    print(''.join(reversed(l)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
import math\n\ndef get_cnt(res):\n    n = 1 + math.floor(math.sqrt(2 * res))\n    if n * (n-1) / 2 == res:\n        return n\n    else:\n        return -1\n        \ndef calc():\n    cnt = list(map(int, input().split()))\n    if cnt == [0,0,0,0]:\n        return '0'\n\n    a = get_cnt(cnt[0])\n    b = get_cnt(cnt[3])\n\n    if cnt == [0,0,0,cnt[3]]:\n        a = 0\n    if cnt == [cnt[0],0,0,0]:\n        b = 0\n\n    if a == -1 or b == -1 or (a * b) != (cnt[1] + cnt[2]):\n        return "Impossible"\n\n    ans = ['0'] * (a + b)\n    i = 0\n    while b > 0:\n        while cnt[1] >= b:\n            i = i + 1\n            cnt[1] -= b\n        b -= 1\n        ans[i] = '1'\n        i += 1\n    return ''.join(ans)\n            \n\nprint(calc())\n
from sys import stdin, stdout\n\nn = int(stdin.readline())\ns = stdin.readline().strip()\n\nmins = []\npacks = []\n\nfor i in range(len(s)):\n    if s[i] == '*':\n        mins.append(i)\n    elif s[i] == 'P':\n        packs.append(i)\n\nl, r = -1, 2 * len(s) + 1\nwhile r - l > 1:\n    m = (l + r) >> 1\n    \n    test1 = mins[:]\n    test2 = packs[:]\n    \n    \n    while test2 and test1:\n        cnt = m\n        pos = test2.pop()\n        \n        if pos > test1[-1]:\n            while test1 and abs(pos - test1[-1]) <= cnt:\n                cnt -= abs(pos - test1[-1])\n                pos = test1[-1]\n                test1.pop()\n        else:\n            cntl, cntr = 0, 0\n            \n            if abs(test1[-1] - pos) > m:\n                break\n            \n            lpos = (m + pos - test1[-1]) // 2\n            rpos = m - 2 * abs(test1[-1] - pos)\n            \n            lb, rb = -1, len(test1)\n            while rb - lb > 1:\n                mb = (lb + rb) >> 1\n                \n                if pos - test1[mb] <= lpos:\n                    rb = mb\n                else:\n                    lb = mb\n            \n            cntl = len(test1) - rb\n            \n            lb, rb = -1, len(test1)\n            while rb - lb > 1:\n                mb = (lb + rb) >> 1\n                \n                if pos - test1[mb] <= rpos:\n                    rb = mb\n                else:\n                    lb = mb\n            \n            cntr = len(test1) - rb\n            \n            cnt = max(cntl, cntr)\n            while test1 and cnt:\n                test1.pop()\n                cnt -= 1\n    \n    \n    if not test1:\n        r = m\n    else:\n        l = m\n    \nstdout.write(str(r))
print(max(1, 4 * int(int(input()) * 2 ** 0.5)))\n
from fractions import gcd\nn, m, x, y, a, b = map(int, input().split())\nr = gcd(a, b)\na, b = a // r, b // r\nr = min(n // a, m // b)\na, b = a * r, b * r\ncx, cy = (a + 1) // 2, (b + 1) // 2\ndx, dy = min(n - a, max(cx, x) - cx), min(m - b, max(cy, y) - cy)\nprint(dx, dy, a + dx, b + dy)
from sys import setrecursionlimit, stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import defaultdict\nfrom bisect import *\n\ndef read():\n  return int(input())\n \ndef reads():\n  return [int(x) for x in input().split()]\n\nS = input()\nx, y = reads()\nqs = [len(s) for s in S.split('T')]\n\ndef knapsack(xs, target):\n  es = {0}\n  for x in xs:\n    es = {e - x for e in es} | {e + x for e in es}\n  return target in es\n\nans = knapsack(qs[2::2], x-qs[0]) and knapsack(qs[1::2], y)\nprint("Yes" if ans else "No")
from math import factorial\nMOD = 10**9+7\n\nk = int(input())\nbink = list(map(int, bin(k)[2:]))\nN = len(bink)\n\n# dp[i][j][k] = first i bits, j bases,\n#   k = 1 if maxor matches k, 0 else\ndp = [[[0,0] for j in range(i+2)] for i in range(N+1)]\ndp[0][0][1] = 1\nfor i in range(1, N+1):\n    for j in range(i+1):\n        # k = 0 -> 0\n        dp[i][j][0]+= 2**j * dp[i-1][j][0] # distribute\n        if j: dp[i][j][0]+= dp[i-1][j-1][0] # new base\n        # k = 1 -> 0\n        odd = 2**(j-1) if j else 0\n        even = 2**j - odd\n        if bink[i-1] == 1:\n            dp[i][j][0]+= even * dp[i-1][j][1] # distribute even\n        # k = 1 -> 1\n        if bink[i-1] == 0:\n            dp[i][j][1]+= even * dp[i-1][j][1] # distribute even\n        else:\n            dp[i][j][1]+= odd * dp[i-1][j][1] # distribute odd\n            if j: dp[i][j][1]+= dp[i-1][j-1][1] # new base\nans = sum(map(sum, dp[-1]))\nprint(ans % MOD)
import math\n\nn = int(input())\na = [int(x) for x in input().split()]\np = int(input())\n\nsum=0;\nfor x in range(n):\n	sum+=a[x]\nif(sum<=p):\n	print(n)\nelse:\n	ans=0\n	for i in range(n):\n		dp = [[[0 for z in range(55)] for y in range(55)] for x in range(55)]\n		dp[-1][0][0]=1\n		for j in range(n):\n			if(j==i):\n\n				for k in range(n):\n					for z in range(p+1):\n						dp[j][k][z]=dp[j-1][k][z]\n				continue\n\n			for k in range(n):\n\n				for z in range(p+1):\n\n					if(z+a[j]<=p):\n						dp[j][k+1][z+a[j]]+=dp[j-1][k][z]\n					dp[j][k][z]+=dp[j-1][k][z]\n\n\n		for k in range(n):\n			for z in range(p+1):\n				if(z+a[i]>p):\n					ans+=k*dp[n-1][k][z]*math.factorial(k)*math.factorial(n-k-1)\n\n	print(ans/math.factorial(n))\n
n, k, x = list(map(int, input().split()))\nrangers = list(map(int, input().split()))\n\nfor i in range(min(k, 8 + k%4)):\n    rangers.sort()\n    rangers = [ rangers[i] if i%2 else rangers[i]^x for i in range(n)]\n#    print(rangers)      \n\nrangers.sort()\nprint(rangers[-1], rangers[0])\n
import sys\n\n\nMAXV = 100010\nd = [0] * MAXV\n\n\na, b, h, w, n = list(map(int,input().split()))\n\narr = input().split()\n\nfor it in range(n):\n    arr[it] = int(arr[it])\n\n# print(arr)\n# print(a, b, h, w, n)\n\ndef solve(a, b, h, w, z, product, it):\n    # print(">", a, b, h, w, z, product, it)\n    k = 0\n    if a % h:\n        k = a // h + 1\n    else:\n        k = a // h\n\n    if k <= z and (product // z) * w >= b:\n        print(it)\n        return\n\n\n\narr = sorted(arr)\narr = arr[::-1]\n# print(arr)\n\nd[1] = 1\nsolve(a, b, h, w, 1, 1, 0)\nsolve(a, b, w, h, 1, 1, 0)\nproduct = 1\nxxx = 0\n\nfor it in range(1, n + 1):\n    # arr[it - 1] = int(arr[it - 1])\n    product *= arr[it - 1]\n    # print("=", arr[it - 1])\n\n    for j in reversed(list(range(1, MAXV))):\n        if not d[j]:\n            continue\n\n        x = j * arr[it - 1]\n        # x = min(x, MAXV - 1)\n        if x < MAXV:\n            d[x] = 1\n        else:\n            if xxx:\n                xxx = min(x, xxx)\n            else:\n                xxx = x\n    if xxx:\n        solve(a, b, h, w, xxx, product, it)\n        solve(a, b, w, h, xxx, product, it)\n\n    for j in range(MAXV):\n        if d[j]:\n            solve(a, b, h, w, j, product, it)\n            solve(a, b, w, h, j, product, it)\n\n\nprint(-1)\n
"""\nCodeforces Round 253 Div 1 Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0:\n        return inputs\n    if mode == 1:\n        return inputs.split()\n    if mode == 2:\n        return [int(x) for x in inputs.split()]\n\ndef write(s="\n"):\n    if isinstance(s, list): s = " ".join(map(str,s))\n    s = str(s)\n    print(s, end="")\n\n################################################### SOLUTION\nimport itertools\ncovers = itertools.product([0,1], repeat=10)\n\nn, = read()\ns = read(1)\na = [0] * 25\ncolors = "RGBYW"\nfor i in s:\n    a[colors.index(i[0]) * 5 + int(i[1])-1] |= 1\n\ndef check(cover):\n    nonlocal a\n    unknowns = [0] * 11\n    for i in range(25):\n        if not a[i]: continue\n        id = -1\n        if not cover[i%5]: id = 5+i//5\n        if not cover[5+i//5]:\n            if id == -1:\n                id = i%5\n            else:\n                id = 10\n        if id > -1:\n            if unknowns[id]: return False\n            unknowns[id] = 1\n    return True\n\nmn = 99\nfor i in covers:\n    if check(i):\n        mn = min(mn, sum(i))\n\nprint(mn)
f = lambda: list(map(int, input().split()))\nn = int(input())\na, b = f(), f()\n\nd = [[None] * 10001 for i in range(n)]\n\ndef g(i, s):\n    if s <= 0: return (0, s)\n    if i == n: return (1e7, 0)\n\n    if not d[i][s]:\n        x, y = g(i + 1, s - b[i])\n        d[i][s] = min(g(i + 1, s), (x + 1, y + b[i] - a[i]))\n    return d[i][s]\n\nx, y = g(0, sum(a))\nprint(x, y)
import sys\nread = lambda: list(map(int, sys.stdin.readline().split()))\nx, y = read()\n\nres = []\nc = 'A'\nwhile x * y > 1:\n   k = min(x // y, x - 1)\n   if k > 0:\n      res.append('{}{}'.format(k, c))\n   x, y = y, x - k*y\n   c = 'A' if c == 'B' else 'B'\n\nif x == 0 or y == 0:\n   print('Impossible')\nelse:\n   print(''.join(res))\n\n
def main():\n	p, k = list(map(int, input().split()))\n	s = 1\n	m = pow(10,9)+7\n	if k == 0:\n		s = pow(p,p-1,m)\n	elif k == 1:\n		s = pow(p,p,m)\n	else:\n		o = 1\n		n = k\n		while n != 1:\n			n = k*n %p\n			o += 1\n		c = (p-1)//o\n		s = pow(p,c,m)\n	print(s%m)\nmain()\n
import sys\ninput = sys.stdin.readline\n\nN,M=map(int,input().split())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\n\n# node : 0<=i<=3*N-1, i:minus i+1: delete i+2: plus\n# start : 3*N\n# goal : 3*N+1\n\nEDGE=[dict() for i in range(3*N+2)]\nV=3*N+2\nstart=3*N\ngoal=3*N+1\n\nfor i in range(N):\n    EDGE[start][3*i] = -B[i] + (1<<30)\n    EDGE[3*i][3*i+1] = A[i] + (1<<30)\n    EDGE[3*i+1][3*i+2] = B[i] + (1<<30)\n    EDGE[3*i+2][goal] = float("inf")\n\nfor i in range(M):\n    x,y=map(int,input().split())\n    x-=1\n    y-=1\n\n    EDGE[3*x+1][3*y] = float("inf")\n    EDGE[3*y+1][3*x] = float("inf")\n\nANS=0\nwhile True:\n    USED=[0]*V\n    ROUTE=[-1]*V\n    Q=[(start,float("inf"))]\n    \n    while Q: # DFS\n        NOW,cost=Q.pop()\n        if NOW==goal:\n            break\n\n        for to in EDGE[NOW]:\n            if USED[to]==0 and EDGE[NOW][to]!=0: \n                ROUTE[to]=NOW\n                USED[to]=1\n                Q.append((to,min(cost,EDGE[NOW][to])))\n    else:\n        break\n    \n    ANS+=cost\n    i=goal\n    while i!=start: # goalからたどり,Routeを使ってEDGEの更新\n        j=ROUTE[i]\n        EDGE[j][i]-=cost # 使ったルートをいけなく更新\n        if j in EDGE[i]:\n            EDGE[i][j]+=cost # 逆向きに進めるようにする.これらを重みつきにすれ普通のフロー\n        else:\n            EDGE[i][j]=cost\n            \n        i=j\n        \nprint(-(ANS-(N<<30)))
from networkx import*\nH,*S=open(0)\nH,W=map(int,H.split())\ng=Graph()\na=g.add_edges_from\nfor i in range(m:=H*W):\n  a([[m*2,h:=i//W],[m*2,w:=i%W+m]]*((c:=S[h][w-m])=='S')+[[h,I:=m*3],[w,I]]*(c=='T'),capacity=I)\n  a([[h,w],[w,h]]*(c>'T'),capacity=1)\nprint([-1,f:=minimum_cut(g,m*2,I)[0]][f<I])
a, b = list(map(int, input().split()))\nres = 0\n\nwhile b != 0:\n    res += a // b\n    a %= b\n    a, b = b, a\nprint(res)\n
n = int(input())\nnim = []\nfor i in range(n):\n  a,k = map(int,input().split())\n  while a%k != 0 and a>k:\n    t = a//k\n    if t+1>=a%k:\n      a -= t+1\n    else:\n      y = a%k\n      a -= y//(t+1)*(t+1)\n  if a<k:\n    x = 0\n  elif a%k == 0:\n    x = a//k\n  nim.append(x)\nans = 0\nfor i in nim:\n  ans ^= i\nif ans == 0:\n  print("Aoki")\nelse:\n  print("Takahashi")
n, m = list(map(int, input().split()))\nif n > m:\n  n, m = m, n\nif n == 1:\n  print(([0, 0, 0, 0, 1, 2][m % 6] + m // 6 * 3) * 2)\n  return\nif n == 2:\n  if m == 2:\n    print(0)\n  elif m == 3:\n    print(4)\n  elif m == 7:\n    print(12)\n  else:\n    print(n * m)\n  return\nprint((n * m) // 2 * 2)\n
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\nn,m=list(map(int,input().split()))\n\npossible1=[set() for _ in range(200)]\npossible2=[set() for _ in range(200)]\nweird=[0]*15\n\np1=list(map(int,input().split()))\np2=list(map(int,input().split()))\n\nfor i in range(n):\n    for j in range(m):\n        a=sorted(p1[i*2:i*2+2])\n        b=sorted(p2[j*2:j*2+2])\n        if a==b: continue\n        got=-1\n        if a[0] in b: got=a[0]\n        if a[1] in b: got=a[1]\n        if got==-1: continue\n        weird[got]=1\n        possible1[a[0]*11+a[1]].add(got)\n        possible2[b[0]*11+b[1]].add(got)\n\nif sum(weird)==1:\n    print(weird.index(1))\nelif max(len(i) for i in possible1)==1 and max(len(i) for i in possible2)==1:\n    print(0)\nelse:\n    print(-1)\n
n = int(input())\ns = input().split(':')\nif n == 12:\n    if s[0] == '00':\n        s[0] = '01'\n    elif int(s[0]) > 12 and s[0][1] == '0':\n        s[0] = '10'\n    elif int(s[0]) > 12:\n        s[0] = '0' + s[0][1]\nelse:\n    if int(s[0]) > 23:\n        s[0] = '0' + s[0][1]\nif int(s[1]) > 59:\n    s[1] = '0' + s[1][1]\nprint(':'.join(s))
import sys\nfrom operator import itemgetter\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(2*10**6)\nclass UF():\n    def __init__(self, num):\n        self.par = [-1]*num\n        self.size = [1]*num\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            x = self.par[x]\n            return self.find(x)\n    \n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            if self.par[rx] < self.par[ry]:\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry] \n            elif self.par[rx] > self.par[ry]:\n                self.par[rx] = ry\n                self.size[ry] += self.size[rx]\n            else:\n                self.par[rx] -= 1\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry]\n        return\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    Cs = [None]*N\n    par = [0]*N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf, cost in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            Cs[vf] = cost\n            ast(vf)\n    return par, order, Cs\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for i, v in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\nMOD = 10**9+7\nN, M = list(map(int, readline().split()))\nX = int(readline())\nEdge = []\nfor _ in range(M):\n    a, b, c = list(map(int, readline().split()))\n    a -= 1\n    b -= 1\n    Edge.append((c, a, b))\n\nEdge.sort(key = itemgetter(0))\n\nT = UF(N)\n\ncnt = 0\nidx = 0\ntEdge = [[] for _ in range(N)]\noEdge = []\nmst = 0\nwhile cnt < N-1:\n    while True:\n        cost, x, y = Edge[idx]\n        rx = T.find(x)\n        ry = T.find(y)\n        idx += 1\n        if rx != ry:\n            break\n        oEdge.append((cost, x, y))\n    cnt += 1\n    tEdge[x].append((y, cost))\n    tEdge[y].append((x, cost))\n    mst += cost\n    T.union(x, y)\nfor i in range(idx, M):\n    oEdge.append(Edge[i])\n    \n\nroot = 0\nP, L, Cs = parorder(tEdge, root)\n#C = getcld(P)\n\nLeng = [0]*N\nfor i in L[1:]:\n    p = P[i]\n    Leng[i] = 1 + Leng[p]\n\nDl = [list(range(N))] + [[P[i] for i in range(N)]]\ndepth = N.bit_length()\nfor _ in range(depth-1):\n    res = [-1]*N\n    for i in range(N):\n        a = Dl[-1][i]\n        if a != root and a != -1:\n            res[i] = Dl[-1][a]\n    Dl.append(res)\n\ndata = [[0]*N] + [[0 if i == root else Cs[i] for i in range(N)]]\n\nfor j in range(depth-1):\n    res = [0]*N\n    for i in range(N):\n        a = Dl[j+1][i]\n        if a != root and a != -1 and data[-1][a]:\n            res[i] = max(data[-1][i], data[-1][a])\n    data.append(res)\n\ndef query(u0, v0):\n    u, v = u0, v0\n    if Leng[u] > Leng[v]:\n        u, v = v, u\n    dif = Leng[v] - Leng[u]\n    res = 0\n    for i in range(dif.bit_length()):\n        if (1<<i) & dif:\n            res = max(res, data[i+1][v])\n            v = Dl[i+1][v]\n    ll = Leng[u].bit_length()\n    for i in range(ll):\n        k = ll-1-i\n        if Dl[k+1][v] != Dl[k+1][u]:\n            res = max(res, data[k+1][v], data[k+1][u])\n            u = Dl[k+1][u]\n            v = Dl[k+1][v]\n\n    if u != v:\n        res = max(res, Cs[v], Cs[u])\n        \n    return res\n\nif mst == X:\n    ans = (pow(2, N-1, MOD) - 2) * pow(2, M-(N-1), MOD) % MOD\nelse:\n    ans = 0\ncue = 0\nran = 0\ndec = 0\nfor c, u, v in oEdge:\n    me = query(u, v)\n    if mst + c - me < X:\n        dec += 1\n    elif mst + c - me == X:\n        cue += 1\n    else:\n        ran += 1\n\nans = (ans + 2*(pow(2, cue)-1)*pow(2, ran, MOD))%MOD\n\nprint(ans)\n
import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nA = list(map(int, readline().split()))\n\nAns = []\none = []\ntt = []\nfor i in range(N-1, -1, -1):\n    a = A[i]\n    if a == 0:\n        continue\n    if a == 1:\n        Ans.append((i, i))\n        one.append((i, i))\n        continue\n    if a == 2:\n        if not one:\n            Ans = None\n            break\n        else:\n            oi, _ = one.pop()\n            Ans.append((oi, i))\n            tt.append((oi, i))\n            continue\n    else:\n        if not tt:\n            if not one:\n                Ans = None\n                break\n            else:\n                oi, wi = one.pop()\n                Ans.append((i, wi))\n                Ans.append((i, i))\n                tt.append((i, i))\n        else:\n            oi, wi = tt.pop()\n            Ans.append((i, wi))\n            Ans.append((i, i))\n            tt.append((i, i))\n        continue\n\nif Ans is None:\n    print(-1)\nelse:\n    print(len(Ans))\n    if Ans:\n        print('\n'.join(f'{a+1} {b+1}' for a, b in Ans))\n\n\n
import math\nn,k=map(int,input().split())\ng=k\nfor a in map(int,input().split()):\n g=math.gcd(g,a)\nprint(k//g)\nprint(' '.join(map(str,range(0,k,g))))
import math\nx1, y1, x2, y2 = list(map(int, input().split(' ')[:4]))\nu_max, tau = list(map(int, input().split(' ')[:2]))\nvx, vy = list(map(int, input().split(' ')[:2]))\nwx, wy = list(map(int, input().split(' ')[:2]))\n\nA = (x2 - x1, y2 - y1)\nv = (-vx, -vy)\nw = (-wx, -wy)\n\nB = (A[0] + tau * v[0], A[1] + tau * v[1])\n\n\ndef solve_sqr_eq(a, b, c):\n    d = b**2 - 4*a*c\n    if d >= 0:\n        return ((-b + math.sqrt(d)) / (2*a), (-b - math.sqrt(d)) / (2*a))\n    else:\n        return None\n\n\na = v[0]**2 + v[1]**2 - u_max**2\nb = 2 * A[0] * v[0] + 2 * A[1] * v[1]\nc = A[0]**2 + A[1]**2\nr = solve_sqr_eq(a, b, c)\n\nif r is not None:\n    t1, t2 = r\n    t_min = min(t1, t2)\n    t_max = max(t1, t2)\n    if 0 <= t_min <= tau:\n        print(t_min)\n        return\n    if 0 <= t_max <= tau:\n        print(t_max)\n        return\n\n\na = w[0]**2 + w[1]**2 - u_max**2\nb = 2 * B[0] * w[0] + 2 * B[1] * w[1] - u_max**2 * 2 * tau\nc = B[0]**2 + B[1]**2 - u_max**2 * tau**2\nr = solve_sqr_eq(a, b, c)\n\nif r is not None:\n    t1, t2 = r\n    t_min = min(t1, t2)\n    t_max = max(t1, t2)\n    if 0 <= t_min :\n        print(t_min + tau)\n        return\n    if 0 <= t_max:\n        print(t_max + tau)\n        return\n
import sys\ninput=sys.stdin.readline\nfrom collections import defaultdict\n\ndef solve(n,A):\n    d=defaultdict(int)\n    for a in A:\n        d[a]+=1\n    flag=True\n    for v in d.values():\n        if v%2!=0:\n            flag=False\n            break\n    return bool(n%2)^flag\n\ndef main():\n    t=int(input())\n    for _ in range(t):\n        n=int(input())\n        A=list(map(int,input().split()))\n        judge=solve(n,A)\n        print('Second' if judge else 'First')\n    \ndef __starting_point():\n    main()\n__starting_point()
#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == "\n":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    n,k,q = LI()\n    a = LI()\n    b = [[a[i],i] for i in range(n)]\n    b.sort()\n    ans = b[q-1][0]-b[0][0]\n    l = [-1,n]\n    for i in range(1,n):\n        l.append(b[i-1][1])\n        l.sort()\n        if b[i-1][0] == b[i][0]:\n            continue\n        s = [a[l[i]+1:l[i+1]] for i in range(i+1)]\n        c = []\n        for si in s:\n            si.sort()\n            for j in range(len(si)-k+1):\n                c.append(si[j])\n        if len(c) < q:\n            continue\n        c.sort()\n        m = c[q-1]-c[0]\n        if m < ans:\n            ans = m\n    print(ans)\n    return\n\n#Solve\ndef __starting_point():\n    solve()\n\n__starting_point()
n, k = list(map(int, input().split()))\nm = 0x3b9aca07\nv = 500000004\nr = 0\np = pow(2, n, m)\na = [1] + [0] * k\nfor i in range(k):\n    for j in range(i, -1, -1):\n        a[j + 1] += a[j]\n        a[j] = a[j] * j % m\nfor i in range(k + 1):\n    r = (r + p * a[i]) % m\n    p = p * v * (n - i) % m\nprint(r)\n
mod = int(1e9 + 7)\nn, m = map(int, input().split())\nf = [ [0 for i in range(60)] for j in range(60) ]\ng = [ [0 for i in range(60)] for j in range(60) ]\ns = [ [0 for i in range(60)] for j in range(60) ]\ninv = [ 1 ]\nf[0][0] = s[0][0] = 1\n\ndef pow(x, exp) :\n    res = 1\n    for i in range(0, 31) :\n        if exp & 1 : res = res * x % mod\n        exp >>= 1\n        if exp == 0 : break\n        x = x * x % mod\n    return res\n\nfor i in range(1, n + 1) :\n    inv.append( pow(i, mod - 2) )\n\nfor node in range(1, n + 1) :\n    for cut in range(1, n + 1) :\n        tmp = 0\n        for ln in range(node) :\n            for lc in range(cut - 1, n + 1) :\n                if f[ln][lc] == 0 : continue\n                if lc == cut - 1 :\n                    tmp = ( tmp + f[ln][lc] * s[node - ln - 1][cut - 1] ) % mod\n                else :\n                    tmp = ( tmp + f[ln][lc] * f[node - ln - 1][cut - 1] ) % mod\n        cnt = 1\n        if tmp != 0 :\n            cn, cc = 0, 0\n            for i in range(1, n + 1) :\n                cn += node\n                cc += cut\n                cnt = cnt * (tmp + i - 1) % mod * inv[i] % mod\n                if cn > n or cc > n : break\n                for j in range(n - cn, -1, -1) :\n                    for k in range(n - cc, -1, -1) :\n                        if f[j][k] == 0 : continue\n                        g[j + cn][k + cc] += f[j][k] * cnt\n                        g[j + cn][k + cc] %= mod\n            for i in range(n + 1) :\n                for j in range(n + 1) :\n                    f[i][j] = (f[i][j] + g[i][j]) % mod\n                    g[i][j] = 0\n            \n    for cut in range(n, -1, -1) :\n        s[node][cut] = ( s[node][cut + 1] + f[node][cut] ) % mod\nprint(f[n][m - 1])
import sys\n\nn, m, k = (int(x) for x in sys.stdin.readline().split(' '))\nmaze = []\nfor i in range(n):\n    maze.append(list(sys.stdin.readline().strip()))\n\nfor y in range(n):\n    for x in range(m):\n        if maze[y][x] == '.':\n            x0, y0 = x, y\n            break\n    else:\n        continue\n    break\nelse:\n    print('no spare room')\n    return\n\nstack = []\nstack.append((x0,y0))\nwhile stack:\n    x, y = stack[-1]\n\n    if maze[y][x] == '.':\n        maze[y][x] = '0'\n        if x > 0 and maze[y][x-1] == '.':\n            stack.append((x-1, y))\n    elif maze[y][x] == '0':\n        maze[y][x] = '1'\n        if y < n-1 and maze[y+1][x] == '.':\n            stack.append((x, y+1))\n    elif maze[y][x] == '1':\n        maze[y][x] = '2'\n        if x < m-1 and maze[y][x+1] == '.':\n            stack.append((x+1, y))\n    elif maze[y][x] == '2':\n        maze[y][x] = '3'\n        if y > 0 and maze[y-1][x] == '.':\n            stack.append((x, y-1))\n    elif maze[y][x] == '3':\n        if k > 0:\n            maze[y][x] = 'X'\n            k -= 1\n        stack.pop()\n\nfor y in range(n):\n    for x in range(m):\n        maze[y][x] = '.' if maze[y][x] == '3' else maze[y][x]\n\nprint("\n".join(["".join(s) for s in maze]))\n
n = int(input())\np = [-1, 0] + [int(x) for x in input().split()]\nh = [0] * (n+1)\ncount = [0] * n\ncount[0] = 1\nmax_h = 0\nfor i in range(2, n+1):\n    h[i] = h[p[i]]+1\n    count[h[i]]+=1\n    max_h = max(max_h,h[i])\nans = 0\nfor i in range(max_h+1):\n    ans += count[i]%2\nprint(ans)
n,a,b = map(int,input().split())\nif a+b>n+1 or a*b<n:\n  print(-1)\n  return\nans = []\nfor i in range(1,a+1):\n  ans.append(i*b)\nif b == 1:\n  x = list(range(1,n+1))\n  print(*x)\n  return\nx = (n-a)//(b-1)\ny = (n-a)%(b-1)\nfor i in range(1,b):\n  for j in range(1,x+1):\n    ans.append(j*b-i)\n  if i <= y:\n    ans.append((x+1)*b-i)\nans_true = []\nfor i,x in enumerate(ans):\n  ans_true.append((i+1,x))\nans_true.sort(key=lambda x:x[1])\nx = list(zip(*ans_true))[0]\nprint(*x)
from sys import stdin\nfrom math import gcd\nn=int(stdin.readline())\na=[int(x) for x in stdin.readline().split()]\nc = []\nld=[]\nrd=[]\n\n\ndef check(l, r, e):\n    if r == l: return c[l][e] > 0\n    if e < l and ld[l][r-l] != 0:\n        return ld[l][r-l] == 1\n    elif e > r and rd[l][r-l] != 0:\n        return rd[l][r-l] == 1\n    for i in range(l, r+1):\n        if c[i][e]>0:\n            if i==l or check(l, i-1, i):\n                if i==r or check(i+1, r, i):\n                    if e < l:\n                        ld[l][r-l] = 1\n                    else:\n                        rd[l][r-l] = 1\n                    return True\n    if e < l:\n        ld[l][r - l] = -1\n    else:\n        rd[l][r - l] = -1\n    return False\n\n\nfor i in range(n):\n    c.append([0]*n)\n    ld.append([0]*n)\n    rd.append([0] * n)\nfor i in range(n):\n    for j in range(i+1,n):\n        if gcd(a[i],a[j]) > 1:\n            c[i][j] = c[j][i] = 1\nans=False\nfor i in range(n):\n    if i == 0 or check(0, i - 1, i):\n        if i == n-1 or check(i + 1, n-1, i):\n            ans = True\n            break\nif ans:\n    print("Yes")\nelse:\n    print("No")\n\n\n
from collections import deque\n \n \nclass Dinic:\n    def __init__(self, n: int):\n        """頂点数をnとする"""\n        self.INF = float("inf")\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n \n    def add_edge(self, _from: int, to: int, capacity: int):\n        """残余グラフを構築\n        1. _fromからtoへ向かう容量capacityの辺をグラフに追加する\n        2. toから_fromへ向かう容量0の辺をグラフに追加する\n        """\n        forward = [to, capacity, None]\n        forward[2] = backward = [_from, 0, forward]\n        self.graph[_from].append(forward)\n        self.graph[to].append(backward)\n \n    def bfs(self, s: int, t: int):\n        """capacityが正の辺のみを通ってsからtに移動可能かどうかBFSで探索\n        level: sからの最短路の長さ\n        """\n        self.level = [-1] * self.n\n        q = deque([s])\n        self.level[s] = 0\n        while q:\n            _from = q.popleft()\n            for to, capacity, _ in self.graph[_from]:\n                if capacity > 0 and self.level[to] < 0:\n                    self.level[to] = self.level[_from] + 1\n                    q.append(to)\n \n    def dfs(self, _from: int, t: int, f: int) -> int:\n        """流量が増加するパスをDFSで探索\n        BFSによって作られた最短路に従ってfを更新する\n        """\n        if _from == t:\n            return f\n        for edge in self.itr[_from]:\n            to, capacity, reverse_edge = edge\n            if capacity > 0 and self.level[_from] < self.level[to]:\n                d = self.dfs(to, t, min(f, capacity))\n                if d > 0:\n                    edge[1] -= d\n                    reverse_edge[1] += d\n                    return d\n        return 0\n \n    def max_flow(self, s: int, t: int):\n        """s-tパス上の最大流を求める\n        計算量: O(|E||V|^2)\n        """\n        flow = 0\n        while True:\n            self.bfs(s, t)\n            if self.level[t] < 0:\n                break\n            self.itr = list(map(iter, self.graph))\n            f = self.dfs(s, t, self.INF)\n            while f > 0:\n                flow += f\n                f = self.dfs(s, t, self.INF)\n        return flow\n\nn = int(input())\na = list(map(int, input().split()))\n\ndinic = Dinic(n + 2)\ns = 0\nt = n + 1\n_sum = 0\nfor i in range(0, n):\n    if a[i] > 0:\n        dinic.add_edge(s, i+1, 0)\n        dinic.add_edge(i+1, t, a[i])\n        _sum += a[i]\n    elif a[i] < 0:\n        dinic.add_edge(s, i+1, -a[i])\n        dinic.add_edge(i+1, t, 0)\n    else:\n        dinic.add_edge(s, i+1, 0)\n        dinic.add_edge(i+1, t, 0)\n\nfor i in range(n):\n    num = i+1\n    next_num = 2 * num\n    while next_num <= n:\n        dinic.add_edge(num, next_num, 10**18)\n        next_num += num\n\nprint(_sum - dinic.max_flow(s, t))
f = lambda: map(int, input().split())\nn, m = f()\nt = list(f())\nd = {i: j for j, i in enumerate(sorted(set(t)))}\nt = [d[i] for i in t]\nk = len(d)\na = [0] * k\nif m < 2 * k:\n    for j in t * m:\n        a[j] += 1\n        q = a[j]\n        j += 1\n        while j < k and a[j] < q:\n            a[j] += 1\n            j += 1\n    print(a[-1])\n    return\na = [0] * k\nfor j in t * k:\n    a[j] += 1\n    q = a[j]\n    j += 1\n    while j < k and a[j] < q:\n        a[j] += 1\n        j += 1\nb = [0] * k\nt.reverse()\nfor j in t * k:\n    b[j] += 1\n    q = b[j]\n    j -= 1\n    while j > -1 and b[j] < q:\n        b[j] += 1\n        j -= 1\nprint(max(a[j] + (m - 2 * k) * t.count(j) + b[j] for j in range(k)))
def main():\n    n=int(input())\n    A=list(map(int,input().strip().split(' ')))\n\n    def brutal(A):\n        n=len(A)\n        for i in range(n):\n            temp=0\n            pos=0\n            neg=0\n            for j in range(n):\n                temp+=abs(A[j]-(j+i)%n)\n                if A[j]-(j+i)%n>0:\n                    pos+=1\n                else:\n                    neg+=1\n\n            print(temp,i,pos,neg,'ans,shift,+ve,-ve')    \n\n\n    for i in range(len(A)):\n        A[i]-=1\n\n    ans=0\n    pos=0\n    neg=0\n    change=[0 for i in range(len(A))]\n\n    for i in range(len(A)):\n        ans+=abs(A[i]-i)\n        if A[i]-i>0:\n            pos+=1\n        else:\n            neg+=1\n        if A[i]-i>0:\n            change[i]=A[i]-i\n        elif A[i]==i:\n            change[i]=0\n        else:\n            if A[i]!=0:\n                change[i]=A[i]+n-i\n            else:\n                change[i]=0\n    MIN=ans\n    index=0\n    #print(ans)\n    collect=[[] for i in range(n)]\n    for x in range(len(change)):\n        collect[change[x]]+=[x]\n    #print(collect)\n\n    #print(ans,pos,neg)    \n    for s in range(1,n):  \n        ans-=abs(A[n-s]-n+1)\n        ans+=abs(A[n-s]-0)\n        neg-=1\n\n        ans-=pos\n        ans+=neg\n        if A[n-s]>0:\n            pos+=1\n        else:\n            neg+=1\n\n\n        pos-=len(collect[s])\n        neg+=len(collect[s])\n        #print(ans,pos,neg)\n        if ans<MIN:\n            MIN=ans\n            index=s\n    print(MIN,index)        \n    #brutal(A)        \nmain() 
def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\n\n# B. The Fair Nut and Strings\n\nn, k = mi()\ns = input().strip()\nt = input().strip()\n\nans = 0\njj = 0\nfor i in range(n):\n    if s[i] == t[i]:\n        ans += 1\n        jj = i + 1\n    else:\n        break\ncur = 2\nfor j in range(jj, n):\n    if s[j] == 'b':\n        cur -= 1\n    if t[j] == 'a':\n        cur -= 1\n    if cur >= k:\n        ans += k * (n - j)\n        break\n    ans += cur\n    cur *= 2\n\nprint(ans)\n
import itertools\nfrom itertools import permutations as perm\n\nl = [[int(x) for x in input().split()] for i in range(8)]\n\ndef dist2(p0,p1):\n    return sum([(p0[i]-p1[i])**2 for i in range(3)])\n\ndef check(c):\n    dists = [[(c[i][0]-c[j][0])**2+(c[i][1]-c[j][1])**2+(c[i][2]-c[j][2])**2 for i in range(8)] for j in range(8)]\n    s2 = min([min(l) for l in dists])\n    return all([sorted(l) == [0,s2,s2,s2,2*s2,2*s2,2*s2,3*s2] for l in dists])\n\ndef sub(p0,p1):\n    return [p0[i]-p1[i] for i in range(3)]\n\ndef add(p0,p1):\n    return [p0[i]+p1[i] for i in range(3)]\n\ndef div(p0,x):\n    return [p0[i]//x for i in range(3)]\n\ndef cross(p0,p1):\n    return [p0[(i+1)%3]*p1[(i+2)%3]-p0[(i+2)%3]*p1[(i+1)%3] for i in range(3)]\n\ndef match(p0,p1):\n    return sorted(p0) == sorted(p1)\n\ndef poss(i,prior,s):\n    if i == len(l): return check(prior)\n    for p in perm(l[i]):\n        if i == 1: print(p)\n        possible = True\n        for p2 in prior:\n            if dist2(p,p2) not in [s,2*s,3*s]:\n                possible = False\n                break\n        if possible:\n            if poss(i+1,prior+[p]): return True\n    return False\n\nsolved = False\nfor l2 in perm(l,3):\n    p0 = l2[0]\n    for p1 in perm(l2[1]):\n        s2 = dist2(p0,p1)\n        if s2 == 0: continue\n        s = round(s2**.5)\n        if s**2 != s2: continue\n        for p2 in perm(l2[2]):\n            if dist2(p0,p2) != s2 or dist2(p1,p2) != 2*s2: continue\n            p3 = sub(add(p1,p2),p0)\n            x = div(cross(sub(p1,p0),sub(p2,p0)),s)\n            p4,p5,p6,p7 = add(p0,x),add(p1,x),add(p2,x),add(p3,x)\n            l3 = [p0,p1,p2,p3,p4,p5,p6,p7]\n            if sorted([sorted(p) for p in l]) == sorted([sorted(p) for p in l3]):\n                print("YES")\n                used = [False for i in range(8)]\n                for p in l:\n                    for i in range(8):\n                        if used[i]: continue\n                        if match(p,l3[i]):\n                            print(l3[i][0],l3[i][1],l3[i][2])\n                            used[i] = True\n                            break\n                solved = True\n                break\n        if solved: break\n    if solved: break\n\nif not solved: print("NO")\n#if not poss(1,[l[0]]): print("NO")\n
import sys\n\ndef gcd(l):\n	if len(l)==0:\n		return 0\n	if len(l)==1:\n		return l[0]\n	if len(l)==2:                                   \n		if l[1]==0:\n			return l[0]  \n		return gcd([l[1],l[0]%l[1]])\n	return gcd([gcd(l[:-1]),l[-1]])\n		\ndef brute_force(l1,l2,l,sol):                   \n	if len(l)==0:\n		g1=gcd(l1)\n		g2=gcd(l2)\n		return g1==1 and g2==1,sol\n	\n	res,s=brute_force(l1+[l[0]],l2,l[1:],sol+[1])\n	if res:\n		return True,s\n	return brute_force(l1,l2+[l[0]],l[1:],sol+[2])\n\ndef factor(n):\n	res=[]\n	i=2\n	while i*i<=n:\n		if n%i==0:\n			res.append(i)\n		while n%i==0:\n			n=int(n/i)\n		i+=1\n\n	if n!=1:\n		res.append(n)\n\n	return res\n\ndef dumpsol(sol):\n	for v in sol:\n		print(v,end=' ')\n\nn=int(sys.stdin.readline())\nl=sys.stdin.readline().strip().split(" ")[0:n]\nl=[int(x) for x in l]\nif n<12:\n	ret,sol=brute_force([],[],l,[])\n	if ret:\n		print("YES")\n		dumpsol(sol)\n	else:\n		print("NO")\n	return\n\nfactors={}\nfor i in range(10):\n	for key in factor(l[i]):\n		factors[key]=0\n\nflists={}\nfor f in factors:\n	flists[f]=[]\n	pos=0\n	found=False\n	for v in l:\n		if v%f!=0:\n			found=True\n			factors[f]+=1\n			flists[f].append(pos)\n			if (factors[f]>9):\n				break\n		pos+=1\n	if not found:\n		print("NO")\n		return\n\noftf=[]\nisoftf={}\nfor f in factors:\n	if factors[f]==0:\n		print("NO")\n		return\n\n	if factors[f]<10:\n		oftf.append(f)\n		isoftf[f]=1\n\n#print(oftf)\n\nsol=[1 for i in range(len(l))]\nx=l[0]\nsol[0]=2\noxf=factor(x)\n#print(oxf)\nxf=[]\nnxf=0\nisxoftf={}\nfor f in oxf:\n	if f in isoftf:\n		nxf+=1\n		isxoftf[f]=1\n		xf.append(f)\n	else:\n		sol[flists[f][0]]=2\n\nnonxf=[]\nfor f in oftf:\n	if not f in isxoftf:\n		nonxf.append(f)\n\nmasks={}\npos=0\n\n#print(xf)\n#print(nonxf)\n\nfor f in xf+nonxf:\n	for v in flists[f]:\n		if not v in masks:	\n			masks[v]=0\n		masks[v]|=1<<pos\n	pos+=1\n\nvals=[{} for i in range(len(masks)+1)]\nvals[0][0]=0\npos=0\nmlist=[]\nfor mask in masks:\n	mlist.append(mask)\n	cmask=masks[mask]\n	cmask1=cmask<<10\n	#print(vals)\n	for v in vals[pos]:\n		vals[pos+1][v|cmask]=v\n		# first number is always in group2\n		if (mask!=0):\n			vals[pos+1][v|cmask1]=v\n	pos+=1	\n\n#print(vals)\n#print(masks)\n#print(sol)\n\ntest_val=((1<<len(xf))-1)|(((1<<len(oftf))-1)<<10)\n#print(test_val)\nfor v in vals[pos]:\n	if (v&test_val)==test_val:\n		print("YES")\n\n		#print(pos)\n		while (pos!=0):\n			#print(v)\n			#print(vals[pos])\n			nv=vals[pos][v]\n			#print(nv)\n			if (nv^v<1024 and nv^v!=0):\n				sol[mlist[pos-1]]=2\n			v=nv\n			pos-=1\n\n		dumpsol(sol)\n		return\n\nprint("NO")\n\n#print(oftf)\n#print(masks)\n\n
n = int(input())\nd = int(input())\ne = 5*int(input())\n\nans = n\nd, e = min([d, e]), max([d, e])\n\nfor i in range(e):\n    if (n-i*d) >= 0:\n        ans = min([ans, (n-i*d)%e])\n        \nprint(ans)
\nfrom collections import Counter\nfrom itertools import accumulate\nfrom math import sqrt\nfrom operator import itemgetter\nimport sys\n \nn = int(input())\ncnt = Counter(map(int, input().split()))\nnums, counts = zip(*sorted(cnt.items(), key=itemgetter(1)))\nacc = [0] + list(accumulate(counts))\narea = 1\nh, w = 1, 1\ni = len(counts)\n \nfor y in range(int(sqrt(n)), 0, -1):\n    while i and counts[i-1] > y:\n        i -= 1\n    total = acc[i] + (len(counts) - i) * y\n    x = total // y\n    if y <= x and area < x * y:\n        h, w, area = y, x, x*y\n \nans = [[0]*w for _ in range(h)]\ni = len(counts)-1\nnum, count = nums[i], min(h, counts[i])\n \nfor x in range(w):\n    for y in range(h):\n        ans[y][(x + y) % w] = num\n \n        count -= 1\n        if count == 0:\n            i -= 1\n            num, count = nums[i], h if h < counts[i] else counts[i]\n \nprint(area)\nprint(h, w)\nfor y in range(h):\n    sys.stdout.write(' '.join(map(str, ans[y])) + '\n')
from collections import defaultdict\n\nMOD = 1000000007\niist = lambda: map(int,input().split())\n\nN,M = iist()\nQ = defaultdict(list)\nfor i in range(M):\n  l,r,x = iist()\n  Q[r].append((l,x))\n\nif any(x != 1 for l,x in Q[1]):\n  print(0)\n  return\n\ndp = defaultdict(int)\ndp[0,0] = 3\n\nx_sum = [3]\ny_sum = [3]\ns = 3\n\nfor pk in range(1,N):\n  k = pk+1\n\n  for i,(a,b) in enumerate(zip(x_sum,y_sum)):\n    c = (a+b)%MOD\n    dp[i,pk] = c\n    x_sum[i] += c\n\n  x_sum.append(0)\n  y_sum.append((2*s)%MOD)\n  s *= 3\n  subQ = Q[k]\n\n  for i,j in list(dp.keys()):\n    for l,x in subQ:\n      if x != (l<=i)+(l<=j)+1:\n        c = dp[i,j]\n        x_sum[i] -= c\n        y_sum[j] -= c\n        s -= c\n        del dp[i,j]\n        break\n\n  for i in range(pk):\n    x_sum[i] %= MOD\n    y_sum[i] %= MOD\n  s %= MOD\n\nprint(s)
import numpy as np\ndef f(b, n):\n    s = 0\n    while n > 0:\n        s += n % b\n        n //= b\n    return s\n\nINF = 10**15\ndef solve(n, s):\n    if n == s:\n        return n+1\n    m = int(np.sqrt(n)) + 1\n    for b in range(2, m+1):\n        if f(b, n) == s:\n            return b\n    best = INF\n    for p in range(1, m+10):\n        q = s - p\n        b = (n - q) // p\n        if (b > p) and (b > q) and (f(b, n) == s):\n            best = min(best, b)\n    return -1 if (best == INF) else best\n\nn = int(input())\ns = int(input())\nprint(solve(n, s))
s=input();print(['Second','First'][len(s.rstrip(s[0]))%2])
def f(t, k):\n    i, j = 0, 1\n    s, d = 0, t[0]\n    n = len(t)\n    while j <= n:\n        if d > k:\n            d -= t[i]\n            i += 1\n        elif d == k:\n            if t[i] and (j == n or t[j]): s += 1\n            else:\n                a, b = i - 1, j - 1\n                while j < n and t[j] == 0: j += 1\n                while t[i] == 0: i += 1\n                s += (i - a) * (j - b)\n            if j < n: d += t[j]\n            d -= t[i]\n            i += 1\n            j += 1                \n        else:\n            if j < n: d += t[j]\n            j += 1\n    return s\n\ns, n = 0, int(input())\nt = list(map(int, input()))\nif n:\n    k = sum(t)\n    if k == 0: print(0)\n    else:\n        p = [(i, n // i) for i in range(max(1, n // k), int(n ** 0.5) + 1) if n % i == 0]\n        for a, b in p:\n            if a != b: s += 2 * f(t, a) * f(t, b)\n            else:\n                k = f(t, a)\n                s += k * k\n        print(s)\nelse:\n    n = len(t)\n    m = n * (n + 1)\n    s = j = 0\n    while j < n:\n        if t[j] == 0:\n            i = j\n            j += 1\n            while j < n and t[j] == 0: j += 1\n            k = ((j - i) * (j - i + 1)) // 2\n            s += k\n        j += 1\n    print((m - s) * s)
P = 998244353\nN, M = list(map(int, input().split()))\nA = [int(a) for a in input().split()]\nB = [int(a) for a in input().split()]\nli = sum([A[i]*B[i] for i in range(N)])\ndi = sum([(A[i]^1)*B[i] for i in range(N)])\nX = [[] for _ in range(M+1)]\n\nX[0] = [1]\ndef calc(L):\n    su = sum(L)\n    pl = 0\n    pd = 0\n    RE = []\n    for i in range(len(L)):\n        a = li + i\n        b = di - (len(L) - 1 - i)\n        pd = b * L[i] * pow(su*(a+b), P-2, P)\n        RE.append((pl+pd)%P)\n        pl = a * L[i] * pow(su*(a+b), P-2, P)\n    RE.append(pl%P)\n    return RE\n\nfor i in range(M):\n    X[i+1] = calc(X[i])\nne = 0\npo = 0\nfor i in range(M+1):\n    po = (po + X[M][i] * (li + i)) % P\n    ne = (ne + X[M][i] * (di - M + i)) % P\nfor i in range(N):\n    print(po * B[i] * pow(li, P-2, P) % P if A[i] else ne * B[i] * pow(di, P-2, P) % P)\n
# coding=utf-8\nfrom functools import reduce\n\na = input()\nb = input()\nc = input()\n\nalen = len(a)\nblen = len(b)\nclen = len(c)\n\nkmpnext = [0]*(clen+1)\ni = 1\nj = 0\nwhile i < clen:\n	while j > 0 and c[i]!=c[j]:\n		j = kmpnext[j]\n	if c[i] == c[j]:\n		j+=1\n	kmpnext[i+1] = j\n	i+=1\n#print(kmpnext)\n\nf = [[[0 for i in range(clen+2)] for i in range(blen+2)] for i in range(alen+2)]\ng = [[[0 for i in range(clen+2)] for i in range(blen+2)] for i in range(alen+2)]\nh = [[[0 for i in range(clen+2)] for i in range(blen+2)] for i in range(alen+2)]\n\nf[0][0][0] = 0\ng[0][0][0] = (-1,-1,-1)\nh[0][0][0] = 1\nm = (0,0,0)\n\nfor i in range(alen):\n	for j in range(blen):\n		for k in range(clen):\n			if h[i][j][k] == 0:\n				#print(i,j,k)\n				continue\n			if f[i+1][j][k] < f[i][j][k] or h[i+1][j][0] == 0:\n				f[i+1][j][k] = f[i][j][k]\n				g[i+1][j][k] = g[i][j][k]\n				h[i+1][j][k] = 1\n			if f[i][j+1][k] < f[i][j][k] or h[i][j+1][0] == 0:\n				f[i][j+1][k] = f[i][j][k]\n				g[i][j+1][k] = g[i][j][k]\n				h[i][j+1][k] = 1\n\n			if a[i] == b[j]:\n				#print(i,j,a[i],b[j])\n				kt = k\n				while kt != 0 and a[i] != c[kt]:\n					kt = kmpnext[kt]\n				if a[i] == c[kt]:\n					if f[i+1][j+1][kt+1] < f[i][j][k] + 1:\n						f[i+1][j+1][kt+1] = f[i][j][k] + 1\n						g[i+1][j+1][kt+1] = (i,j,k)\n						h[i+1][j+1][kt+1] = 1\n				else:\n					if f[i+1][j+1][0] < f[i][j][k] + 1:\n						f[i+1][j+1][0] = f[i][j][k] + 1\n						g[i+1][j+1][0] = (i,j,k)\n						h[i+1][j+1][0] = 1\n\n			#print(i,j,k,f[i][j][k],g[i][j][k])\n\nfor i in range(alen+1):\n	for j in range(blen+1):\n		for k in range(clen):\n			if f[i][j][k] > f[m[0]][m[1]][m[2]]:\n				m = (i,j,k)\nif f[m[0]][m[1]][m[2]] == 0:\n	print(0)\nelse:\n	ans = ""\n	t = m\n	t = g[t[0]][t[1]][t[2]]\n	while t != (-1,-1,-1):\n		ans = a[t[0]] + ans\n		t = g[t[0]][t[1]][t[2]]\n	print(ans)\n
H_y,A_y,D_y = list(map(int,input().split()))\nH_m,A_m,D_m = list(map(int,input().split()))\nh,a,d = list(map(int,input().split()))\nans = 10**20\nfor A_buy in range(max(0,H_m+D_m-A_y)+1):\n  for D_buy in range(max(0,A_m-D_y)+1):\n    damage = A_y + A_buy - D_m\n    cost = A_buy * a + D_buy * d\n    if damage > 0 and cost < ans:\n      time = (H_m+damage-1)//damage\n      H_left = H_y - time * max(0, A_m - D_y - D_buy)\n      if H_left <= 0: cost += h * (1-H_left)\n      if cost < ans: \n        ans = cost\nprint(ans)\n
n, t = map(int, input().split())\ns = bin(n + 2)[2:]\nl = len(s)\n\nif t & (t - 1):\n    ans = 0\nelse:\n    t = t.bit_length()\n    f = [[0] * (l + 1) for i in range(l + 1)]\n    for i in range(l + 1):\n        f[i][0] = f[i][i] = 1\n        for j in range(1, i):\n            f[i][j] = f[i - 1][j - 1] + f[i - 1][j]\n\n    ans = c = 0\n    for i in range(l):\n        if s[i] == '1':\n            if t - c <= l - i - 1:\n                ans += f[l - i - 1][t - c]\n            c += 1\n    if t == 1: ans -= 1\nprint(ans)
l = []\n\nfor c in input():\n    if len(l) > 0 and l[-1] == c:\n        l.pop()\n    else:\n        l.append(c)\n\nprint('Yes' if len(l) == 0 else 'No')\n
import math\ndef dist(x, y, x1, y1, x2, y2):\n    a = x-x1\n    b = y-y1\n    c = x2-x1\n    d = y2-y1\n    dot = a*c+b*d\n    lensq = c*c+d*d\n    param=-1\n    if lensq != 0:\n        param = dot / lensq\n    if param < 0:\n        xx = x1\n        yy = y1\n    elif param > 1:\n        xx = x2\n        yy = y2\n    else:\n        xx = x1 + param * c\n        yy = y1 + param * d\n\n    dx = x - xx\n    dy = y - yy\n    return (dx*dx+dy*dy)**0.5\ndef dist2(x, y):\n    return ((x[0]-y[0])**2+(x[1]-y[1])**2)**0.5\nimport math\nmaxx = -1\nminn = 100000000000000000\npts = []\na, b, c = list(map(int, input().split(' ')))\nfor i in range(a):\n    x, y = list(map(int, input().split(' ')))\n    pts.append([x, y])\n\nk = []\nfor i in pts:\n    k.append(dist2(i, [b, c]))\npts.append(pts[0])\nfor i in range(a):\n    k.append(dist(b, c, pts[i][0], pts[i][1], pts[i+1][0], pts[i+1][1]))\n\nprint((max(k)**2-min(k)**2)*math.pi)\n
im = int(input())\n\nbest_steps = 0\nbest_length = 0\n\ndef rec(m, steps, substracted):\n    nonlocal best_steps, best_length \n    if m == 0:\n        if steps > best_steps:\n            best_steps = steps\n            best_length = substracted\n        elif steps == best_steps:\n            best_length = max(best_length, substracted)\n        return\n\n    a = 1\n    while (a + 1)**3 <= m:\n        a += 1\n\n    rec(m - a**3, steps + 1, substracted + a**3)\n\n    if a - 1 != 0:\n        rec(a**3-1-(a-1)**3, steps + 1, substracted + (a-1)**3)\n\nrec(im, 0, 0)\nprint(best_steps, best_length)
n=int(input())\ns=input()\nstack=[]\nfor i in s:\n	if i=="(":\n		stack.append(i)\n	elif i==")":\n		if len(stack)>0:\n			if (stack[-1]=="("):\n				stack.pop()\n			else:\n				stack.append(")")\n		else:\n			stack.append(")")\nif len(stack)==0:\n	print ("Yes")\n	return\nif len(stack)==2:\n	if stack[0]==")" and stack[1]=="(":\n		print ("Yes")\n		return\n	else:\n		print ("No")\n		return\nelse:\n	print ("No")
from collections import deque\n\nn, k = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nc50 = sum([1 for i in a if i == 50])\nc100 = sum([1 for i in a if i == 100])\nc = [[0] * 51 for i in range(51)]\nc[0][0] = 1\nc[1][0] = 1\nc[1][1] = 1\nfor x in range(2, 51):\n    for y in range(x + 1):\n        c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\nd = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n# d[i][j][c] ответ, когда мы переправили i по 50 кг и j по 100 кг и лодка на берегу c\nd[0][0][0][0] = 1\nd[0][0][0][1] = 0\nq = deque()\nq.append([0, 0, 0])\nwhile len(q) > 0:\n    i, j, shore = q.popleft()\n    for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n        for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n            if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                continue\n            i1 = i + fifty if shore == 0 else i - fifty\n            j1 = j + hundreds if shore == 0 else j - hundreds\n            if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                d[i1][j1][1 ^ shore][0] = 0\n                q.append((i1, j1, 1 ^ shore))\n            if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                continue\n            koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (\n                c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n            d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n            d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\nif d[c50][c100][1][1] == float('inf'):\n    print(-1)\n    print(0)\nelse:\n    print(d[c50][c100][1][1])\n    print(d[c50][c100][1][0])\n\n
MOD = 1000000007\n\n\ndef isSubset(a, b):\n	return (a & b) == a\n\n\ndef isIntersect(a, b):\n	return (a & b) != 0\n\n\n# Solve for each weakly connected component (WCC)\ndef cntOrder(s, t):\n	p = len(s)\n	m = len(t)\n\n	inMask = [0 for i in range(m)]\n\n	for x in range(p):\n		for i in range(m):\n			if t[i] % s[x] == 0:\n				inMask[i] |= 1 << x\n\n	cnt = [0 for mask in range(1<<p)]\n	for mask in range(1<<p):\n		for i in range(m):\n			if isSubset(inMask[i], mask):\n				cnt[mask] += 1\n\n	dp = [[0 for mask in range(1<<p)] for k in range(m+1)]\n	for i in range(m):\n		dp[1][inMask[i]] += 1\n	for k in range(m):\n		for mask in range(1<<p):\n			for i in range(m):\n				if not isSubset(inMask[i], mask) and isIntersect(inMask[i], mask):\n					dp[k+1][mask | inMask[i]] = (dp[k+1][mask | inMask[i]] + dp[k][mask]) % MOD\n			dp[k+1][mask] = (dp[k+1][mask] + dp[k][mask] * (cnt[mask] - k)) % MOD\n\n	return dp[m][(1<<p)-1]\n\n\ndef dfs(u):\n	nonlocal a, graph, degIn, visited, s, t\n\n	visited[u] = True\n	if degIn[u] == 0:\n		s.append(a[u])\n	else:\n		t.append(a[u])\n\n	for v in graph[u]:\n		if not visited[v]:\n			dfs(v)\n\n\ndef main():\n	nonlocal a, graph, degIn, visited, s, t\n\n	# Reading input\n	n = int(input())\n	a = list(map(int, input().split()))\n\n	# Pre-calculate C(n, k)\n	c = [[0 for j in range(n)] for i in range(n)]\n	for i in range(n):\n		c[i][0] = 1\n		for j in range(1, i+1):\n			c[i][j] = (c[i-1][j-1] + c[i-1][j]) % MOD	\n\n	# Building divisibility graph\n	degIn = [0 for u in range(n)]\n	graph = [[] for u in range(n)]\n	for u in range(n):\n		for v in range(n):\n			if u != v and a[v] % a[u] == 0:\n				graph[u].append(v)\n				graph[v].append(u)\n				degIn[v] += 1\n\n	# Solve for each WCC of divisibility graph and combine result\n	ans = 1\n	curLen = 0\n	visited = [False for u in range(n)]\n	for u in range(n):\n		if not visited[u]:\n			s = []\n			t = []\n			dfs(u)\n\n			if len(t) > 0:\n				sz = len(t) - 1\n				cnt = cntOrder(s, t)\n\n				# Number of orders for current WCC\n				ans = (ans * cnt) % MOD\n				# Number of ways to insert <sz> number to array of <curLen> elements\n				ans = (ans * c[curLen + sz][sz]) % MOD\n				curLen += sz		\n\n	print(ans)\n\ndef __starting_point():\n	main()\n__starting_point()
from math import sqrt\ndef primset(n):\n    a = set()\n    \n    while n % 2 == 0:\n        a.add(2)\n        n = n//2\n         \n    for i in range(3,int(sqrt(n))+1,2):\n        while n % i== 0:\n            a.add(i)\n            n = n//i\n            \n    if n > 2:\n        a.add(n)\n    return a\n\nn = int(input())\na, b = map(int, input().split())\n\nprimes = primset(a)\nprimes.update(primset(b))\n\nfor i in range(1, n):\n    a, b = map(int, input().split())\n    r = set()\n    for p in primes:\n        if a%p != 0 and b%p != 0:\n            r.add(p)\n    for rem in r:\n        primes.remove(rem)\n    if len(primes) < 1:\n        print(-1)\n        return\nprint(primes.pop())
\ndef blokovi(x):\n    ret = [0]\n    for i in range(len(x) - 1):\n        if x[i] != x[i + 1]:\n            ret.append(i + 1)\n    return ret + [len(x)]\n\ns = input()\nt = input()\n\nss = blokovi(s)\ntt = blokovi(t)\n\nif s[-1] == 'a':\n    s += 'b'\nelse:\n    s += 'a'\n\nif t[-1] == 'a':\n    t += 'b'\nelse:\n    t += 'a'\n\ndef greedy(x, y, rev=False):\n    i, j = len(x) - 1, len(y) - 1\n    swaps = []\n    while True:\n        while i >= 0 and x[i] == 'a':\n            i -= 1\n        while j >= 0 and y[j] == 'b':\n            j -= 1\n        if i < 0 and j < 0:\n            break\n        x, y = y, x\n        if rev:\n            swaps.append((j + 1, i + 1))\n        else:\n            swaps.append((i + 1, j + 1))\n        i, j = j, i\n    return swaps\n\ndef solve(x, y):\n    p = greedy(x, y)\n    q = greedy(y, x, True)\n    if len(p) < len(q):\n        return p\n    return q\n\nprobao = set()\n\ntotal = len(ss) + len(tt)\nsol = solve(s[:-1], t[:-1])\nfor b, i in enumerate(ss):\n    for c in range((2 * b + len(tt) - len(ss)) // 2 - 2, (2 * b + len(tt) - len(ss) + 1) // 2 + 3):\n        if 0 <= c < len(tt):\n            j = tt[c]\n            bs = b + len(tt) - c - 1\n            bt = c + len(ss) - b - 1\n            if abs(bs - bt) > 2:\n                continue\n            proba = (bs, bt, s[i], t[j])\n            if proba in probao:\n                continue\n            probao.add(proba)\n            s2 = t[:j] + s[i:-1]\n            t2 = s[:i] + t[j:-1]\n            if i + j > 0: \n                if i + j == len(s) + len(t) - 2:\n                    cand = solve(t2, s2)\n                else:\n                    cand = [(i, j)] + solve(s2, t2)\n            else:\n                cand = solve(s2, t2)\n            if len(cand) < len(sol):\n                sol = cand\n\nprint(len(sol))\nfor i, j in sol:\n    print(i, j)\n
N=int(input())\nP=[-1]+[int(i)-1 for i in input().split()]\nX=[int(i) for i in input().split()]\nQ=[[] for i in range(N)]\nfor i in range(1,N):\n    Q[P[i]].append(i)\ndp=[0 for i in range(N)]\nINF=10**9+7\ndef solve(i):\n    cur=[INF for j in range(X[i]+1)]\n    cur[0]=0\n    for j in Q[i]:\n        solve(j)\n        prv=[k for k in cur]\n        cur=[INF for k in range(X[i]+1)]\n        for acc in range(len(prv)):\n            if prv[acc]<INF:\n                if acc+X[j]<=X[i]:\n                    cur[acc+X[j]]=min(cur[acc+X[j]],prv[acc]+dp[j])\n                if acc+dp[j]<=X[i]:\n                    cur[acc+dp[j]]=min(cur[acc+dp[j]],prv[acc]+X[j])\n    dp[i]=min(cur)\nsolve(0)\nif dp[0]<INF:\n    print("POSSIBLE")\nelse:\n    print("IMPOSSIBLE")\n
import numpy as np\n\n\ndef solve(n, m):\n    def prepare(n, m):\n        f = 1\n        for i in range(1, n + 1):\n            f = f * i % m\n        fn = f\n        inv = [1] * (n + 1)\n        f = pow(f, m - 2, m)\n        inv[n] = f\n        for i in range(n, 0, -1):\n            f = f * i % m\n            inv[i - 1] = f\n        return fn, inv\n\n    def a_x(a, x, m):\n        ret = 1\n        yield ret\n        for _ in range(x):\n            ret = ret * a % m\n            yield ret\n\n    fn, inv = prepare(n, m)\n\n    stir2 = np.zeros(n + 2, dtype=np.int64)\n    stir2[0] = 1\n    upd = np.arange(2, n + 3, dtype=np.int64)\n\n    ex2 = [2]\n    for i in range(n):\n        ex2.append(ex2[-1] ** 2 % m)\n\n    ans = 0\n    si = 1\n\n    for i in range(n+1):\n        nCi = fn * inv[i] * inv[n-i] % m\n        i_with = np.fromiter(a_x(pow(2, n-i, m), i, m), dtype=np.int64) \n        i_on = (stir2[ :i+1] * i_with % m).sum() % m\n        ans = (ans + nCi * i_on % m * ex2[n-i] % m * si) % m\n        stir2[1 : i+2] = (stir2[1 : i+2] * upd[ :i+1] + stir2[ :i+1]) % m\n        si *= -1\n\n    return ans\n\n\nN, M = list(map(int, input().split()))\nprint((solve(N, M)))\n
def __starting_point():\n	a=[int(x) for x in input().split()]\n	N=a[0]\n	A=a[1]\n	B=a[2]\n	K=a[3]\n	s=input()\n	mod = 1000000009\n	Q = pow(B*pow(A,mod-2,mod)%mod,K,mod)\n	if Q!=1:\n		D = (pow(Q,(N+1)//K,mod)-1)*pow(Q-1,mod-2,mod)%mod\n	else:\n		D = (N+1)//K\n	ans=0\n	C = pow(A,N,mod)\n	A=pow(A,mod-2,mod)\n	for i in range(K):\n		if s[i]=='+':\n			ans=(ans+C*D)%mod\n		else:\n			ans=(ans-C*D)%mod\n		C=C*B*A%mod\n	print((ans%mod+mod)%mod)\n__starting_point()
a, b, c, d = list(map(int, input().split(' ')))\n\nans = -(d+1) * (d+2) * (d+3) // 6\nfor l1 in range(0, d+1):\n    minx = min(d-l1, a-b-c+l1)\n    if minx < 0:\n        continue;\n    else:\n        ans += (minx + 1) * (minx + 2) // 2\n\na, b, c = b, c, a\nfor l1 in range(0, d+1):\n    minx = min(d-l1, a-b-c+l1)\n    if minx < 0:\n        continue;\n    else:\n        ans += (minx + 1) * (minx + 2) // 2\n\na, b, c = b, c, a\nfor l1 in range(0, d+1):\n    minx = min(d-l1, a-b-c+l1)\n    if minx < 0:\n        continue;\n    else:\n        ans += (minx + 1) * (minx + 2) // 2\n\nprint(-ans)\n
n, m = map(int, input().split())\ns, d = 1, 1000000009\nk = pow(2, m, d) - 1\nfor i in range(n): s, k = (s * k) % d, k - 1\nprint(s)
from collections import deque\nn = int(input())\ngraph = [[] for i in range(n + 1)]\nfor _ in range(n - 1):\n  i, j = map(int, input().split())\n  graph[i].append(j)\n  graph[j].append(i)\nmod = 10 ** 9 + 7\n\ndef bfs(x):\n  q = deque([(0, x, 0)])\n  dist = {x: 0}\n  while q:\n    step, i, par = q.popleft()\n    dist[i] = step\n    for j in graph[i]:\n      if j == par: continue\n      q.append((step + 1, j, i))\n  return [step, i, dist]\n\n_, black, _ = bfs(1)\nmaxdist, white, b_dist = bfs(black)\n_, _, w_dist = bfs(white)\n\nmindls = float("-inf")\nmaxdls = [0] * n\nfor i in range(1, n + 1):\n  if i in (white, black):\n    continue\n  mindls = max(mindls, min(w_dist[i], b_dist[i]))\n  maxdls[max(w_dist[i], b_dist[i])] += 1\nans = pow(2, n - 1, mod) * maxdist % mod\npre = 0\nfor i in range(1, maxdist + 1):\n  if i == maxdist and not maxdls[i]: continue\n  maxdls[i] += maxdls[i - 1]\n  if mindls > i: continue\n  ans += (pow(2, maxdls[i], mod) - pre) * i * 2\n  ans %= mod\n  pre = pow(2, maxdls[i], mod)\nprint(ans)
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\n\ndef bs(f, mi, ma):\n    mm = -1\n    while ma > mi:\n        mm = (ma+mi) // 2\n        if f(mm):\n            mi = mm + 1\n        else:\n            ma = mm\n    if f(mm):\n        return mm + 1\n    return mm\n\ndef main():\n    n = I()\n    a = LI()\n    b = LI()\n    if b == list(range(1,n+1)):\n        return 0\n\n    ss = set(a)\n    if 1 not in ss:\n        i = b.index(1)\n        bf = 1\n        for j in range(i,n):\n            if b[j] != j - i + 1:\n                bf = 0\n                break\n        if bf:\n            t = b[-1]\n            s = ss | set()\n            for j in range(n-t):\n                if t+j+1 not in s:\n                    bf = 0\n                    break\n                s.add(b[j])\n            if bf:\n                return n - t\n\n    def f(i):\n        s = ss | set(b[:i])\n        for j in range(1,n+1):\n            if j not in s:\n                return True\n            if i + j <= n:\n                s.add(b[i+j-1])\n\n        return False\n\n    r = bs(f,0,n)\n\n    return r + n\n\n\nprint(main())\n\n
#!/usr/bin/env python3\ndef solve(n, m, s, t):\n    if '*' in s:\n        l, r = s.split('*')\n        return len(l) + len(r) <= len(t) and t.startswith(l) and t.endswith(r)\n    else:\n        return s == t\n\nn, m = list(map(int, input().split()))\ns = input()\nt = input()\nprint(['NO', 'YES'][solve(n, m, s, t)])\n
n = int(input())\na = list(map(float, input().split()))\na.sort()\ns = a[-1]\np = 1 - a[-1]\nfor i in range(n - 2, -1, -1):\n	if s < s * (1 - a[i]) + a[i] * p:\n		s = s * (1 - a[i]) + a[i] * p\n		p *= (1 - a[i])\nprint('%.9lf' % s)\n
import sys\nn, l, v1, v2, k = list(map(int, input().split()))\nn = (n + k - 1) // k\nif n == 1:\n	print(l / v2)\n	return\n\nL, R = 0, l\nfor i in range(100):\n	M = (L + R) / 2\n	S = l - M\n	T = M * (n * 2 - 1)- l\n	if T * v1 > S * v2:\n		R = M\n	else:\n		L = M\n\nprint(M / v2 + S / v1)\n
k = 0\nans = 0\nn = int(input())\na = input().split()\nfor i in range(2 * n):\n    s = float(a[i])\n    if s != int(s):\n        k+=1\n        ans += (int(s) + 1 - s)\n\nif ans - int(ans) > 0.5:\n    p = int(ans) + 1\nelse:\n    p = int(ans)\nif p > n:\n    p = n\nif (p + n >= k):\n    print('%.3f'% abs(ans - p))\nelse:\n    print('%.3f'% abs(ans - k + n))\n
Q = input().split(" ")\nF = input().split(" ")\nxQ = int(Q[0])\nyQ = int(Q[1])\nxF = int(F[0])\nyF = int(F[1])\n\nif xQ == xF:\n    print((abs(yQ-yF)+1)*2+4)\nelif yQ == yF:\n    print((abs(xQ-xF)+1)*2+4)\nelse:\n    print((abs(xQ-xF)+1)*2+(abs(yQ-yF)+1)*2)\n
\n# add 0,4,9,49\n# this is a stupid solution\n\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\nn=int(input())\n\n# do a stupid approach\ndp=[0]*150\ns=set([0])\nfor i in range(150):\n    dp[i]=len(s)\n    s2=set(s)\n    for j in s:\n        s2.add(j+4)\n        s2.add(j+9)\n        s2.add(j+49)\n    s=s2\n\nif 0:\n    for i in range(100):\n        if dp[i+49]-dp[i]!=2401:\n            print(i)\n\nif n<150: print(dp[n])\nelse:\n    stuff=(n//49)\n    while n-stuff*49+49<150: stuff-=1\n    print(dp[n-stuff*49]+2401*stuff)
def main():\n    import sys\n    input = sys.stdin.readline\n    \n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    dct = {}\n    for x in arr:\n        dct[x] = 0\n    \n    i = 0\n    while i != n and dct[arr[i]] == 0:\n        dct[arr[i]] = 1\n        i += 1\n    \n    if i == n:\n        print(0)\n        return 0\n    \n    j = n - 1\n    while dct[arr[j]] == 0:\n        dct[arr[j]] = 1\n        j -= 1\n    \n    ans = j - i + 1\n    \n    for k in range(i - 1, -1, -1):\n        dct[arr[k]] -= 1\n        while dct[arr[j]] == 0:\n            dct[arr[j]] = 1\n            j -= 1\n        ans = min(ans, j - (k - 1))\n    \n    print(ans)\n    \n    return 0\n\nmain()
'''input\naabc\n'''\n\ndef list_input():\n    return list(map(int,input().split()))\ndef map_input():\n    return map(int,input().split())\ndef map_string():\n    return input().split()\n    \ns = input()\na = s.count('a')\nb = s.count('b')\nc = s.count('c')\nans = "YES"\nif(a == 0 or b == 0): ans = "NO"\nif(c != a and c != b): ans = "NO"\nfor i in range(len(s)-1):\n	if(s[i] > s[i+1]): ans = "NO"\nprint(ans)	
n, p = int(input()), list(map(int, input().split()))\na, c, v = [0] * n, 1, 1\nfor i, pi in enumerate(p):\n    a[pi - 1] = i\nfor i in range(n - 1):\n    if a[i] < a[i + 1]:\n        c += 1\n        if c > v:\n            v = c\n    else:\n        c = 1\nprint(n - v)
"""\nCodeforces Contest 259 Div 1 Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef main():\n    m,n = read()\n    print(m - sum((i/m)**n for i in range(1,m)))\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return map(int, inputs.split())\n\ndef read_str(): return read(0)\ndef read_int(): return read(2)[0]\n\ndef write(s="\n"):\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nmain()
def solve():\n    n = int(input())\n    s = input()\n    k = '-'\n    tr = True\n    for i in s:\n        if k == '-' and i != '-':\n            k = i\n        if i != '-' and k != i:\n            tr = False\n    if tr:\n        print(n)\n        return 0\n    ans = 0\n    for i in range(n):\n        if s[i] == "-" or s[i - 1] == '-':\n            ans += 1\n    print(ans)\nfor i in range(int(input())):\n    solve()
t = []\nl = []\nr = []\nfor _ in range(int(input())):\n	s, g = map(int, input().split())\n	t.append(s)\n	l.append(s)\n	r.append(g + s)\n	\nfor i in range(1, len(l)):\n	if l[i] < l[i - 1]:\n		l[i] = l[i - 1] - 1\n	if r[i] > r[i - 1]:\n		r[i] = r[i - 1] + 1\n		\nfor i in range(len(l) - 2, -1, -1):\n	if l[i] < l[i + 1]:\n		l[i] = l[i + 1] - 1\n	if r[i] > r[i + 1]:\n		r[i] = r[i + 1] + 1\n\nif [1 for a, b in zip(l, r) if a > b]:\n	print(-1)\nelse:\n	print(sum([b - a for a, b in zip(t, r)]))\n	print(' '.join(map(str, r)))
def main():\n    n, a, z = int(input()), 0, 10 ** 10\n    b, *cc = list(map(int, input().split()))\n    dp = [(0, z, z), (z, 0, z), *[(z, z, z)] * ((n - 1) // 2)]\n    for i, c in enumerate(cc, 1):\n        u, v, w = dp[i // 2 + 1]\n        dz = max(0, c - b + 1)\n        du = max(0, b - c + 1)\n        dw = max(0, min(a - 1, b) - c + 1)\n        for j in range(i // 2, -1, -1):\n            x, y, z = u, v, w\n            u, v, w = dp[j]\n            dp[j + 1] = (x if x < z else z, min(u + du, w + dw), y + dz)\n        a, b = b, c\n    print(' '.join(map(str, list(map(min, dp[1:])))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
from sys import stdin,stdout\n# stdout = open('output.txt', 'w+')\n# stdin = open('input.txt','r+')\n\n\nfrom collections import Counter\ndef prefixsuffixmatch(s):\n	pi_table=[0 for i in range(len(s))]\n	for i in range(1,len(s)):\n		y=pi_table[i-1]\n		while s[i]!=s[y] and y!=0:\n			y=pi_table[y-1]\n		if s[i]==s[y]:\n			y+=1\n		pi_table[i]=y\n	return pi_table\ndef canprint(a,b):\n	if a['0']>=b['0'] and a['1']>=b['1']:\n		return True\n	return False\n\ndef flushit(s):\n	if '0' in s:\n		stdout.write('0'* s['0'])\n	if '1' in s:\n		stdout.write('1'* s['1'])\ndef fillit(x):\n	if '0' not in x:\n		x['0']=0\n	if '1' not in x:\n		x['1']=0\n	return x\n	\ns=stdin.readline().strip();counter_s=fillit(Counter(s))\nt=stdin.readline().strip();counter_t=fillit(Counter(t))\nt_pi_table=prefixsuffixmatch(t)\nlongest_match=t_pi_table[-1]\n\nrepeating_part=t[longest_match:]\n\ncounter_repeating_part=fillit(Counter(repeating_part))\n\n\n\n\nif len(counter_s)==2 and len(counter_t)==2:\n	if counter_s['0']>=counter_t['0'] and counter_s['1']>=counter_t['1']:\n		stdout.write(t);counter_s['0']-=counter_t['0'];counter_s['1']-=counter_t['1'];\n\n\n	# while canprint(counter_s,counter_repeating_part)==True:\n	# 	stdout.write(repeating_part);\n	# 	counter_s['0']-=counter_repeating_part['0'];\n	# 	counter_s['1']-=counter_repeating_part['1'];\n\n	if '0' in counter_repeating_part and '1' in counter_repeating_part:\n		if counter_repeating_part['0']>0 and counter_repeating_part['1']>0:\n			r=min(counter_s['0']//counter_repeating_part['0'],counter_s['1']//counter_repeating_part['1'])\n			stdout.write(repeating_part*r);\n			counter_s['0']-=(r*counter_repeating_part['0']);\n			counter_s['1']-=(r*counter_repeating_part['1']);\n	flushit(counter_s);\n\n\n
read_line = lambda: [int(i) for i in input().split()]\n\nn, m, k = read_line()\na = [read_line() for i in range(n)]\nif n < m:\n    n, m, a = m, n, list(zip(*a))\n\nxs = []\nfor y in a:\n    x = 0\n    for b in y:\n        x = 2 * x + b\n    xs.append(x)\n\ndef work(y):\n    tot = 0\n    for x in xs:\n        c = bin(x ^ y).count('1')\n        tot += min(c, m - c)\n    return tot\n\nans = min(list(map(work, xs if m > k else list(range(1<<m)))))\n\nprint(ans if ans <= k else -1)\n
n = int(input())\nA = [list(map(int, input().split())) for _ in range(n)]\nx = A[0][1]\ny = A[1][2]\nz = A[0][2]\np = (x * y * z) ** 0.5\na1 = p // y\na2 = p // z\na3 = p // x\nans = [round(a1), round(a2), round(a3)]\nfor i in range(3, n):\n    ans.append(round(A[0][i] // a1))\nprint(' '.join(list(map(str, ans))))
n=int(input())\na=[];b=[];c=[];d=[]\nfor i in range(n):\n    opt,num=[int(x) for x in input().split()]\n    if opt==0:\n        a.append(num)\n    if opt==10:\n        b.append(num)\n    if opt==1:\n        c.append(num)\n    if opt==11:\n        d.append(num)\nans=0\nans+=sum(d)\nb.sort(reverse=True)\nc.sort(reverse=True)\nif len(b)<len(c):\n    ans+=sum(b)+sum(c[0:len(b)])\n    a.extend(c[len(b):])\nelse:\n    ans+=sum(c)+sum(b[0:len(c)])\n    a.extend(b[len(c):])\na.sort(reverse=True)\nans+=sum(a[0:len(d)])\nprint(ans)
from sys import stdin\nimport heapq\n\nn,m,s = [int(x) for x in stdin.readline().split()]\n\nbugs = [int(x) for x in stdin.readline().split()]\nbugs = sorted([(bugs[x],x) for x in range(m)])\n\norder = [x[1] for x in bugs]\nbugs = [x[0] for x in bugs]\n\nstudents = [int(x) for x in stdin.readline().split()]\nrate = [int(x) for x in stdin.readline().split()]\n\nvalid = False\nfor x in range(n):\n  if students[x] >= bugs[-1] and rate[x] <= s:\n    valid = True\nif not valid:\n  print('NO')\nelse:\n  print('YES')\n  #print(students)\n  for i,x in enumerate(students):\n    low = 0\n    high = m-1\n    while high >= low:\n      mid = (high+low)//2\n      if bugs[mid] > x:\n        high = mid-1\n      else:\n        low = mid+1\n    #print(x,high)\n    students[i] = high\n  \n  students = sorted([(students[x]+1,rate[x], x+1) for x in range(n)],reverse=True)\n  #print(students)\n  l1 = 1\n  high = m\n\n  lastValid = []\n  lastD = 100000\n  \n  while l1 <= high:\n    mid = (l1+high)//2\n    shift = (mid-(m%mid))%mid\n    segs = m//mid\n    if shift > 0:\n      segs += 1\n    ind = 0\n    q = []\n\n    total = 0\n\n    group = []\n\n    for x in range(segs,0,-1):\n      while ind<n:\n        if (students[ind][0]+shift)//mid >= x:\n          heapq.heappush(q,(students[ind][1],students[ind][2]))\n          ind += 1\n        else:\n          break\n      if q:\n        r,i = heapq.heappop(q)\n        group.append((x,i))\n        total += r\n      else:\n        break\n    if len(group) == segs and total <= s:\n      #print(mid,total)\n      high = mid-1\n      lastValid = group\n      lastD = mid\n    else:\n      l1 = mid+1\n  complete = [0 for x in range(m)]\n  lastValid.sort()\n  mid = lastD\n  shift = (mid-(m%mid))%mid\n  skill = 1\n  for bruh,i in lastValid:\n    end = skill*mid-shift\n    start = max(0,end-mid)\n    for x in range(start,end):\n      complete[x] = i\n    skill += 1\n  c2 = [0 for x in range(m)]\n  for i,x in enumerate(complete):\n    c2[order[i]] = x\n  print(' '.join([str(x) for x in c2]))\n  \n  \n  \n        \n    \n    \n
import sys\nfrom math import *\n\ndef minp():\n	return sys.stdin.readline().strip()\n\ndef mint():\n	return int(minp())\n\ndef mints():\n	return list(map(int, minp().split()))\n\nn, k = mints()\nq = list(mints())\nfor i in range(n):\n	q[i] -= 1\ns = list(mints())\na = [i for i in range(1,n+1)]\nd = [0]*n\nb = [False]*(k+1)\nc = [False]*(k+1)\ne = [10000]*2\nf = [10000]*2\nfor i in range(k+1):\n	#print(a)\n	b[i] = (a == s)\n	if b[i]:\n		e[i%2] = min(e[i%2], i)\n	for j in range(n):\n		d[j] = a[q[j]]\n	a,d = d,a\n#print('====')\na = [i for i in range(1,n+1)]\nfor i in range(k+1):\n	#print(a)\n	c[i] = (a == s)\n	if c[i]:\n		f[i%2] = min(f[i%2], i)\n	for j in range(n):\n		d[q[j]] = a[j]\n	a,d = d,a\n#print('====')\n#print(e)\n#print(f)\nif e[0] == 0:\n	print('NO')\nelif e[1] == 1:\n	if f[1] == 1 and k > 1:\n		print('NO')\n	elif k%2 == 1 or f[k%2] <= k:\n		print('YES')\n	else:\n		print('NO')\nelif f[1] == 1:\n	if k%2 == 1 or e[k%2] <= k:\n		print('YES')\n	else:\n		print('NO')\nelse:\n	if e[k%2] <= k or f[k%2] <= k:\n		print('YES')\n	else:\n		print('NO')\n
#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nn = int(input())\nabove = n // 3\nbelow = n - above\nfor i in range(above):\n    print(2 * i + 1, 3)\nfor i in range(below):\n    print(i, 0)\n
3\n\nn = int(input())\na = [0] + list(map(int, input().split()))\nif len(a) < 3 or n % 2 == 0:\n    print(-1)\nelse:\n    ans = 0\n    for x in range(n // 2, 0, -1):\n        d = max(0, a[2 * x], a[2 * x + 1])\n        ans += d\n        a[x] -= d\n    print(ans + max(0, a[1]))\n
p, k = map(int, input().split())\nk = -k\n\na = []\nwhile p != 0:\n  r = p % k\n  p //= k\n  if r < 0:\n    r += -k\n    p += 1\n  a.append(r)\n\nprint(len(a))\nprint(" ".join(map(str, a)))
def get_bounds(points):\n    if len(points) == 1:\n        return points[:]\n    points.sort()\n    bounds = [points[0], points[1]]\n    for xi, yi in points[2:]:\n        while len(bounds) > 1 and not is_convex(bounds, xi, yi):\n            del bounds[-1]\n        bounds.append((xi, yi))\n    return bounds\n\n\ndef is_convex(bounds, x2, y2):\n    x1, y1 = bounds[-1]\n    x0, y0 = bounds[-2]\n    return (x1 - x0) * (y2 - y1) < (y1 - y0) * (x2 - x1)\n\n\n\ndef read_data():\n    n, p, q = map(int, input().split())\n    ABs = []\n    for i in range(n):\n        a, b = map(int, input().split())\n        ABs.append((a, b))\n    return n, p, q, ABs\n\ndef solve(n, p, q, ABs):\n    '''\n    min sum(ds)\n    s.t. sum(ds[i] * As[i]) >= p and sum(ds[i] * Bs[i]) >= q\n    '''\n    bounds = get_bounds(ABs)\n    a0, b0 = bounds[0]\n    if len(bounds) == 1:\n        return max(p/a0, q/b0)\n    record = float('Inf')\n    for a1, b1 in bounds[1:]:\n        steps = min(max(p/a0, q/b0), max(p/a1, q/b1))\n        den = a0 * b1 - b0 * a1\n        if den != 0:\n            r0 = (b1 * p - a1 * q)/den\n            r1 = - (b0 * p - a0 * q)/den\n            if r0 > 0 and r1 > 0:\n                steps = min(steps, r0 + r1)\n        a0 = a1\n        b0 = b1\n        record = min(record, steps)\n    return record\n\nn, p, q, ABs = read_data()\nprint(solve(n, p, q, ABs))
from itertools import *\ndef f(x):\n    x -= 1\n    ret = 0\n    if x == 0:\n        ret = 1\n    else:\n        while x != 0:\n            ret += 1\n            x //= 7\n    return ret\n\ndef g(d):\n    ret = 0\n    for v in d:\n        ret = ret * 7 + v\n    return ret\n\n\n\nn, m = list(map(int, input().split()))\na = f(n)\nb = f(m)\nif a + b > 7:\n    print(0)\nelse:\n    ans = 0\n    for p in permutations(list(range(7)), a + b):\n        if g(p[:a]) < n and g(p[a:]) < m:\n            ans += 1\n    print(ans)\n\n\n
n = int(input())\na = list(map(int, input().split()))\ns = set(a)\nm = {i: 0 for i in s}\nfor i in a:\n	m[i] += 1\nwin = ''\nfor i in sorted(m)[::-1]:\n	if m[i] % 2:\n		win = 'Conan'\n		break\nif win:\n	print(win)\nelse:\n	print('Agasa')
\n\n\n\n\nA,B = list(map(int, input().split()))\n\nS = [["." if h < 50 else "#" for _ in range(100) ] for h in range(100)]\n\nend_black = False\nfor i in range(0,50,2):\n    if end_black:\n        break\n    for j in range(100):\n        if B <= 1:\n            end_black = True\n            break\n        \n        if j % 2 == 0:\n            S[i][j] = "#"\n            B -= 1\n\n\nend_white = False\nfor i in range(53,100, 2):\n    if end_white:\n        break\n    for j in range(100):\n        if A <= 1:\n            end_white = True\n            break\n        \n        if j % 2 == 0:\n            S[i][j] = "."\n            A -= 1\n\nprint((100,100))\nfor i in range(100):\n    print(("".join(S[i])))\n\n
#!/Library/Frameworks/Python.framework/Versions/3.6/bin/python3\n'''\nCreated on 13/09/2018\n\n@author: ernesto\n'''\n\nn, m = [int(x) for x in input().strip().split(" ")]\n\nposibles_jefes = set(range(1, n + 1))\nanteriores = set()\nposteriores = set()\ncontinuos = [True] * (n + 1)\nmencionados = set()\nposibles_jefes_mencionados = set()\nultimo_en_salir = [True] * (n + 1)\nultima_salida_inesperada = None\n\nops = []\n\nif(m > 1):\n    for _ in range(0, m):\n        s, n_s = [x for x in input().strip().split(" ")]\n        n = int(n_s)\n        ops.append((s, n))\n    for i in range(0, m):\n        op, num = ops[i]\n        cont = False\n        if op == '+':\n            cont = not i or (ops[i - 1][0] == '-' and ops[i - 1][1] == num)\n            posteriores.add(num)\n        if op == '-':\n            cont = i == m - 1 or (ops[i + 1][0] == '+' and ops[i + 1][1] == num)\n            if num not in mencionados:\n                anteriores.add(num)\n                ultima_salida_inesperada = num\n            posteriores.discard(num)\n            ultimo_en_salir[num] &= not posteriores\n        continuos[num] &= cont \n        mencionados.add(num)\n#    print("anteriores {} posteriores {} continuos {} ops {}".format(anteriores, posteriores, continuos, ops))\n    if not anteriores and not posteriores:\n        assert ultima_salida_inesperada is None\n        if ops[0][0] == '+' and ops[-1][0] == '-' and ops[0][1] == ops[-1][1] and continuos[ops[0][1]] and ultimo_en_salir[ops[0][1]]:\n            posibles_jefes_mencionados.add(ops[0][1])\n    else:\n        if not posteriores:\n            assert ultima_salida_inesperada is not None\n            posibles_jefes_filtrados = list([x for x in anteriores if continuos[x] and ultimo_en_salir[x] and ultima_salida_inesperada == x])\n            assert len(posibles_jefes_filtrados) <= 1\n            if(posibles_jefes_filtrados):\n                assert posibles_jefes_filtrados[0] == ops[-1][1]\n                posibles_jefes_mencionados.add(ops[-1][1])\n        else:\n            if not anteriores:\n                assert ultima_salida_inesperada is None\n                posibles_jefes_filtrados = list([x for x in posteriores if continuos[x] and ultimo_en_salir[x]])\n#                print("posibles {}".format(posibles_jefes_filtrados))\n                assert len(posibles_jefes_filtrados) <= 1\n                if(posibles_jefes_filtrados):\n                    assert posibles_jefes_filtrados[0] == ops[0][1]\n                    posibles_jefes_mencionados.add(ops[0][1])\n            else:\n                assert ultima_salida_inesperada is not None\n#                print("continuos {}".format(continuos))\n                posibles_jefes_mencionados = set([x for x in anteriores & posteriores if ultimo_en_salir[x] and continuos[x] and ultima_salida_inesperada == x])\n\n#    print("posibles jefes menc {}".format(posibles_jefes_mencionados))\n    posibles_jefes -= (mencionados - posibles_jefes_mencionados)\n        \nprint(len(posibles_jefes))\nif(len(posibles_jefes)):\n    print(" ".join(map(str, sorted(posibles_jefes))))\n
import bisect\nn,m=list(map(int,input().split()))\nL1=list(map(int,input().split()))\nL2=list(map(int,input().split()))\nx=int(input())\nnewL1=[0]\nnewL2=[0]\nfor i in L1:newL1.append(newL1[-1]+i)\nfor i in L2:newL2.append(newL2[-1]+i)\nmin1=[]\nmin2=[]\nmx=9999999999999999999\nfor i in range(1,n+1):\n    m1=mx\n    for j in range(n-i+1):\n        if newL1[j+i]-newL1[j]<m1:m1=newL1[j+i]-newL1[j]\n    min1.append(m1)\nfor i in range(1,m+1):\n    m2=mx\n    for j in range(m-i+1):\n        if newL2[j+i]-newL2[j]<m2:m2=newL2[j+i]-newL2[j]\n    min2.append(m2)\narea=0\nfor i in range(n):\n    k=x//min1[i]\n    for j in range(m):\n        if min2[j]>k:break\n    if min2[-1]<=k:j+=1\n    if area<j*(i+1):area=j*(i+1)\nprint(area)\n
3\n\nimport sys\n\n\ndef solve(s, k):\n    l = len(s)\n    for i in range(l-1, -1, -1):\n        prev = s[max(i-2, 0):i]\n        z = s[i] + 1\n        while z in prev:\n            z += 1\n        if z >= k:\n            continue\n        # Gotcha!\n        ret = s[:i] + [z]\n        while len(ret) < l:\n            prev = ret[max(len(ret)-2, 0):len(ret)]\n            z = 0\n            while z in prev:\n                z += 1\n            ret.append(z)\n        return ret\n    return None\n\n\ndef __starting_point():\n    l, k = list(map(int, sys.stdin.readline().split()))\n    s = [ord(c) - ord('a') for c in sys.stdin.readline().strip()]\n    ans = solve(s, k)\n    if ans is None:\n        print('NO')\n    else:\n        print(''.join(chr(ord('a') + x) for x in ans))\n\n__starting_point()
import sys\nimport copy\ninput = sys.stdin.readline\n\nn,k=list(map(int,input().split()))\nC=list(input().strip())\n\ndef JUDGE(C):\n    ANS_one=0\n    ANS_zero=0\n\n    for c in C:\n        if c=="0":\n            ANS_zero+=1\n        else:\n            break\n\n    for c in C[::-1]:\n        if c=="0":\n            ANS_zero+=1\n        else:\n            break\n\n    for c in C:\n        if c=="1":\n            ANS_one+=1\n        else:\n            break\n\n    for c in C[::-1]:\n        if c=="1":\n            ANS_one+=1\n        else:\n            break\n\n    if ANS_zero>=n-k or ANS_one>=n-k:\n        return 1\n    else:\n        return 0\n\nif JUDGE(C)==1:\n    print("tokitsukaze")\n    return\n\nif k>=n-1:\n    print("quailty")\n    return\nif k<n/2:\n    print("once again")\n    return\n    \n\nCAN1=copy.copy(C)\nCAN2=copy.copy(C)\n\nif C[0]=="0":\n    for i in range(1,k+1):\n        CAN1[i]="1"\nelse:\n    for i in range(1,k+1):\n        CAN1[i]="0"\n\nif C[-1]=="0":\n    for i in range(n-1,n-k-1,-1):\n        CAN2[i]="1"\nelse:\n    for i in range(n-2,n-k-2,-1):\n        CAN2[i]="0"\n\nif JUDGE(CAN1)==1 and JUDGE(CAN2)==1:\n    print("quailty")\n    return\nelse:\n    print("once again")\n    return\n    \n    \n    \n
read = lambda: map(int, input().split())\nn, k, p = read()\na, b = sorted(read()), sorted(read())\nprint(min(max(abs(b[i + d] - a[i]) + abs(b[i + d] - p) for i in range(n)) for d in range(k - n + 1)))
ii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\nfrom math import gcd\n\nn, k = mi()\na, b = mi()\ns = n * k\n\nmn, mx = 10 ** 15, -1\n\ndef solve(start):\n    nonlocal mn, mx\n    for i in range(n):\n        bef = k * i - b\n        l = (bef - start) % s\n        turns = s // gcd(s, l)\n        mn = min(mn, turns)\n        mx = max(mx, turns)\n        aft = k * i + b\n        l = (aft - start) % s\n        turns = s // gcd(s, l)\n        mn = min(mn, turns)\n        mx = max(mx, turns)\n\nsolve(a)\nsolve(s - a)\nprint(mn, mx)
N = int(input())\nA = list(map(int,input().split()))\nif min(A) >= 0:\n  Flag = True\nelif max(A) <= 0:\n  Flag = False\nelse:\n  p_max = max(A)\n  m_max = min(A)\n  if abs(p_max) >= abs(m_max):\n    Flag = True\n  else:\n    Flag = False\nif Flag:\n  MAX = max(A)\n  for i,v in enumerate(A):\n    if v == MAX:\n      MAX_loc = i\n      break\n  ans = []; t = 0\n  for i in range(N-1):\n    if A[i+1] >= A[i]:\n      continue\n    A[i+1] += 2*MAX\n    ans.append([MAX_loc+1,i+1+1])\n    ans.append([MAX_loc+1,i+1+1])\n    t += 2\n    MAX_loc = i+1\n    MAX = A[i+1]\n\nelse:\n  MIN = min(A)\n  for i, v in enumerate(A):\n    if v == MIN:\n      MIN_loc = i\n      break\n  ans = []; t = 0\n  for i in range(N-1):\n    if A[N-1-i] >= A[N-2-i]:\n      continue\n    A[N-2-i] += 2*MIN\n    ans.append([MIN_loc+1,N-2-i+1])\n    ans.append([MIN_loc+1,N-2-i+1])\n    t += 2\n    MIN_loc = N-2-i\n    MIN = A[N-2-i]\nprint(t)\nfor x in ans:\n  print((*x))\n#print(ans,t,A)    \n
n = int(input())\nt = [tuple(map(int, input().split())) for i in range(n)]\n\nm = max(t)\nd = 2 * m[0] + len(bin(m[1])) - 1\n\nt = sorted([i for i in t if 2 * i[0] + len(bin(i[1])) > d])\np, k = t[0][0], t[0][1] - 1\n\nfor i in range(1, len(t)):\n    p, k = t[i][0], max(t[i][1] - 1, k >> 2 * (t[i][0] - p))\n\nprint(p + (len(bin(k)) + 1) // 2 - 1)
#coding gbk\n#!usr/bin/ENV\ncin =lambda : list(map(int,input().split()))\nn, k = cin()\nc=list(cin())\ndp = [0]*(k+1)\ndp[0]=1\nfor i in c:\n    tmp = dp[:]\n    for x in range(k,i-1,-1):\n        tmp[x] |= dp[x-i]|(dp[x-i]<<i)\n    dp = tmp\nb = bin(dp[-1])\nans = [i for i in range(k + 1) if b[-i - 1] == '1']\nprint(len(ans))\nprint(*ans)\n
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\nn=int(input())\n\nans=1\nwhile 2**ans-1<n:\n    ans+=1\nprint(ans)\n\n
from operator import neg\nn = int(input())\na = [tuple(map(int, input().split())) for i in range(n)]\n\ndef check(max_h):\n    k = n // 2\n    b = []\n    for w, h in a:\n        if h > max_h:\n            if k <= 0 or w > max_h:\n                return 1 << 60\n            b.append((h, w))\n            k -= 1\n        else:\n            b.append((w, h))\n    b.sort(key=lambda t: t[1] - t[0])\n    r = 0\n    for w, h in b:\n        if k > 0 and w <= max_h and h < w:\n            r += h\n            k -= 1\n        else:\n            r += w\n    return r * max_h\n\nprint(min(check(h) for h in range(1, 1001)))\n    \n        \n
n = int(input())\nar = list(map(int,input().split(' ')))\nar.sort()\ns=[]\nfor i in ar:\n	s.sort(reverse=True)\n	for j in range(len(s)):\n		if i>=s[j]:\n			s[j]+=1\n			break\n	else:\n		s.append(1)\nprint(len(s))\n
import sys\ninput = sys.stdin.readline\nfrom fractions import gcd\nfrom collections import Counter\n\n"""\n適当に部分集合Xをとり、凸包 S として、Sに1点計上すればよい\nこれだと2^N点得られる\nただし、凸包の面積が0となる場合が例外\n空集合、1点の場合と、線分の場合を除外する\n\n"""\n\nMOD = 998244353\nN = int(input())\nXY = [[int(x) for x in input().split()] for _ in range(N)]\n\nanswer = pow(2,N,MOD)\nanswer -= N + 1# 空、1点\nfor i,(x,y) in enumerate(XY):\n    # i を選び、i+1番目以上のうちいくつかを選んで線分とする\n    pts = []\n    for x1, y1 in XY[i+1:]:\n        dx, dy = x1-x, y1-y\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        # 標準化\n        if dx < 0:\n            dx, dy = -dx, -dy\n        elif dx == 0:\n            dy = 1\n        pts.append((dx,dy))\n    c = Counter(pts)\n    for v in c.values():\n        answer -= pow(2,v,MOD) - 1\n\nanswer %= MOD\nprint(answer)
N = int(input())\nX = [i for i in range(N+1)]\nY = [[] for _ in range(N)]\nB, W = [], []\nans = 0\nfor i in range(2 * N):\n    c, a = input().split()\n    a = int(a) - 1\n    if c == "B":\n        X = [X[i] + 1 if i <= a else X[i] - 1 for i in range(N+1)]\n        B.append(a)\n        ans += len([b for b in B if b > a])\n    else:\n        Y[a] = X[:]\n        W.append(a)\n        ans += len([b for b in W if b > a])\n\nZ = [0] * (N+1)\nfor y in Y:\n    for i in range(N+1):\n        Z[i] += y[i]\n    for i in range(1, N+1):\n        Z[i] = min(Z[i], Z[i-1])\n\nans += Z[-1]\nprint(ans)
def main():\n    import sys\n    input = sys.stdin.readline\n    \n    b = int(input())\n    g = int(input())\n    n = int(input())\n    \n    ans = n + 1\n    if b < n:\n        ans -= n - b\n    if g < n:\n        ans -= n - g\n    \n    print(ans)\n    \n    return 0\n\nmain()\n
n = int(input())\na = [int(i) for i in input().split()]\na.sort()\na.reverse()\nfor i in a:\n    if i < 0:\n        print(i)\n        return\n    if int(i ** 0.5) ** 2 != i:\n        print(i)\n        return
##\n##\n##\nimport sys\ndef line():\n    return sys.stdin.readline()\n\ndef numbers():\n    return list(map(int, line().split()))\n\ndef number():\n    return int(line())\n\nadjlist = {}\nn, k = 0, 0\nmark = [False]*2010\nedges = [False]*1010\n\n# bfs for "ssph"\ndef bfs(s):\n    \n    i = 0\n    frontier = [s]\n    while frontier:\n\n        if mark[s]:\n            break;\n\n        next_frontier = []\n        for u in frontier:\n\n            # check next state\n            for v, isState in enumerate(edges):\n                if isState:\n                    # check new node\n                    state = u + (n - 1000) - v\n\n                    if state >= 0 and state <= 2000 and not mark[state]:\n                        mark[state] = True\n                        next_frontier.append(state)\n\n        frontier = next_frontier\n        i += 1\n\n    if mark[s]:\n        return i\n    else:\n        return -1\n\n# main program\n[n, k] = numbers()\nconcentrations = numbers()\n\n# reading edges\nfor x in concentrations:\n    edges[x] = True\n\nn = n + 1000\nans = bfs(1000)\nprint(ans)\n\n# 1496438704903\n
N, K = map(int, input().split())\nS = []; T = []\nfor x in range(1, int(N**.5)+1):\n    if N % x == 0:\n        S.append(x)\n        if x*x < N:\n            T.append(N//x)\nT.reverse()\nS += T\nM = len(S)\nU = []\n\nMOD = 10**9 + 7\nans = 0\nv = 0\nfor i in range(M):\n    x = S[i]\n    v = pow(K, (x+1)//2, MOD)\n    for j in range(i):\n        y = S[j]\n        if x % y == 0:\n            v -= U[j]\n    U.append(v % MOD)\n    ans = (ans + (v * x if x & 1 else v * (x//2))) % MOD\nprint(ans)
N=int(input())\nmod=998244353\ninv4=249561088\nA=[inv4,0,3]\nfor i in range(N):\n    A.append(9*A[-1]-24*A[-2]+16*A[-3])\n    A[-1]%=mod\nA[0]-=inv4\nB=[0 for i in range(N)]\nfor i in range(N):\n    x=i\n    y=N-i-1\n    if x<=y:\n        B[x]=A[i]\n        B[y]=A[i]\n\nP=N*pow(2,N-2+mod-1,mod)\nfor i in range(N):\n    B[i]+=P\n    B[i]%=mod\nQ=pow(2,N-1,mod)\nQinv=pow(Q,mod-2,mod)\nfor i in range(N):\n    B[i]*=Qinv\n    B[i]%=mod\nfor i in range(N):\n    print((B[i]))\n
#!/bin/pypy3\nfrom itertools import*\nfrom timeit import*\nfrom typing import Optional\n\nS=lambda x:sum(map(int,str(x)))\n\ndef ceil_s_divisible_a(x:int,a:int) -> Optional[int]:\n	z=S(x)%a\n	if z:\n		z=a-z\n		tail=[]\n		x=list(str(x))\n		while x:\n			digit=x.pop()\n			diff=min(z,9-int(digit))\n			z-=diff\n			tail.append(str(int(digit)+diff))\n			if z==0:break\n		else:\n			return ceil_s_divisible_a(10**len(tail),a)\n		x=''.join(x) + ''.join(reversed(tail))\n\n	assert S(x)%a==0\n	x=int(x)\n	return x\n\ndef smooth25(a):\n	a=int(bin(a).rstrip('0'),2)\n	while a%5==0: a//=5\n	return a==1\n\ndef solve(a):\n	for first in range(1,60): # 120\n		q=str((first*10**3000+a-1) // a) # 5000\n		for s1 in range(1,200):\n			i=1\n			s2=int(q[0])\n			while i<len(q) and s2<s1*a-10: s2+=int(q[i]); i+=1\n			for len1 in range(i,min(i+10,len(q))):\n				small=int(q[:len1])\n				for z in range(4): # 10\n					small=ceil_s_divisible_a(small,a)\n					if S(small*a)*a==S(small):\n						return small\n					small+=1\n\n	return None\n\ndef powform(x:int)->str:\n	s=str(x)\n	try:\n		i=s.find('00000')\n		return f'{s[:i]} * 10 ** {len(s)-i} + {int(s[i:])}'\n	except IndexError:\n		return str(x)\n\nif 0:\n	#for a in (a for a in range(2,1000)):\n	for a in [999,909,813,777,957,921,855,933,831,942,891,846,807,783,888][1::3]:\n	#for a in [32]:\n\n		def work():\n			nonlocal x\n			x=solve(a)\n\n		t=timeit(work,number=1)\n		if t>0.5 or x==None:\n			if x!=None:\n				print(a,t,'>>',powform(a*x))\n			else:\n				print(a,t,'>> ?????')\n\n	#print(solve(int(input())))\n\n\nspecial='''\n660 0.5026652759997887 >> 3 * 10 ** 2640 + 35340\n803 0.5102322779994211 >> 3 * 10 ** 2678 + 1614\n912 0.5136937369998122 >> 3 * 10 ** 1825 + 240\n918 0.5238579140004731 >> 3 * 10 ** 1813 + 1104\n582 0.5302371079997101 >> 2 * 10 ** 2328 + 17116\n612 0.5363936909998301 >> 2 * 10 ** 2413 + 10348\n495 0.5372351949999938 >> 3 * 10 ** 2969 + 16305\n927 0.5433051690006323 >> 3 * 10 ** 2195 + 21003\n636 0.5471086210000067 >> 3 * 10 ** 1379 + 20004\n531 0.5475810970001476 >> 2 * 10 ** 2140 + 439\n64 0.5633312410000144 >> ?????\n200 0.5639609099998779 >> ?????\n100 0.565854023000611 >> ?????\n125 0.5663040710005589 >> ?????\n160 0.5668467480008985 >> ?????\n800 0.5676178080002501 >> ?????\n128 0.5676772269998764 >> ?????\n80 0.5682811480000964 >> ?????\n256 0.5685735130000467 >> ?????\n250 0.5691464900000938 >> ?????\n512 0.569266141999833 >> ?????\n32 0.5692826909998985 >> ?????\n50 0.5692834940000466 >> ?????\n25 0.5696684799995637 >> ?????\n400 0.5703751219998594 >> ?????\n20 0.5706145570002263 >> ?????\n500 0.5742691679997733 >> ?????\n640 0.5749700739997934 >> ?????\n40 0.5768258159996549 >> ?????\n625 0.5775357299999087 >> ?????\n16 0.5789494729997386 >> ?????\n833 0.5855263899993588 >> 3 * 10 ** 2286 + 1404\n792 0.5996652009998797 >> 3 * 10 ** 1903 + 16008\n320 0.6031684260005932 >> ?????\n10 0.6464516910000384 >> ?????\n546 0.6579458010000963 >> 3 * 10 ** 2184 + 2454\n5 0.6617960960002165 >> ?????\n907 0.664109037000344 >> 3 * 10 ** 2538 + 2223\n923 0.6807242180002504 >> 2 * 10 ** 2476 + 4141\n723 0.6976773409996895 >> 3 * 10 ** 2892 + 1185\n825 0.701172955000402 >> 4 * 10 ** 2476 + 123350\n906 0.7062042559991824 >> 4 * 10 ** 1998 + 104\n905 0.7086789289996887 >> 2 * 10 ** 2412 + 1540\n911 0.711649564000254 >> 2 * 10 ** 2612 + 2044\n934 0.7246100349993867 >> 2 * 10 ** 2570 + 51112\n765 0.7552886830007992 >> 3 * 10 ** 2939 + 1725\n981 0.7653923980005857 >> 4 * 10 ** 1965 + 1022\n333 0.7884190810000291 >> 3 * 10 ** 2994 + 62934\n663 0.8130600629992841 >> 3 * 10 ** 2546 + 11634\n444 0.8443964660000347 >> 3 * 10 ** 1999 + 13956\n720 0.8445076829993923 >> 2 * 10 ** 2779 + 159280\n867 0.9858260920000248 >> 5 * 10 ** 1739 + 121\n914 1.0558696210000562 >> 3 * 10 ** 1831 + 222\n606 1.1190159360003236 >> 5 * 10 ** 2910 + 1318\n948 1.1529914639995695 >> 6 * 10 ** 2466 + 1020\n1000 1.2245053040005587 >> ?????\n741 1.2366985769995154 >> 5 * 10 ** 2669 + 175\n819 1.292531102999419 >> 8 * 10 ** 2949 + 31312\n867 1.293641017000482 >> 5 * 10 ** 1739 + 121\n961 1.431375496000328 >> 4 * 10 ** 1935 + 1112\n913 2.0632996949998414 >> 5 * 10 ** 2323 + 16\n861 2.1641551399998207 >> 11 * 10 ** 1847 + 1114\n992 2.2718322470000203 >> 11 * 10 ** 2207 + 1504\n936 2.3109037909998733 >> 11 * 10 ** 2108 + 3112\n996 2.3603119750005135 >> 11 * 10 ** 1979 + 4300\n951 2.380345242999283 >> 11 * 10 ** 1820 + 412\n969 2.471255187000679 >> 11 * 10 ** 1942 + 241\n828 2.504634874999283 >> 11 * 10 ** 1595 + 11212\n693 2.5246166990000347 >> 13 * 10 ** 2494 + 423014\n840 2.5490226490001078 >> 11 * 10 ** 1681 + 13120\n983 2.618962229999852 >> 11 * 10 ** 1968 + 5011\n963 2.641272683999887 >> 11 * 10 ** 2026 + 133\n972 2.741184581000198 >> 12 * 10 ** 2130 + 312\n555 2.787974407000547 >> 11 * 10 ** 2497 + 444445\n873 2.8377116049996403 >> 11 * 10 ** 1774 + 133\n903 2.898315477000324 >> 13 * 10 ** 1726 + 32\n804 2.9635119349995875 >> 12 * 10 ** 1659 + 1500\n864 3.032601443999738 >> 13 * 10 ** 2747 + 34016\n759 3.0681308859993806 >> 13 * 10 ** 2504 + 311441\n871 3.4960390779997397 >> 13 * 10 ** 2995 + 2405\n902 4.413119433999782 >> 12 * 10 ** 1506 + 1110\n997 4.446912733999852 >> 11 * 10 ** 1999 + 7\n993 5.025415283999791 >> 23 * 10 ** 2130 + 31\n837 5.286188959000356 >> 25 * 10 ** 2722 + 11063\n786 5.390603378999913 >> 21 * 10 ** 1572 + 4002\n801 5.4837765329994 >> 22 * 10 ** 1645 + 212\n882 6.045185064999714 >> 22 * 10 ** 1822 + 1130\n990 6.413724044000446 >> 39 * 10 ** 2970 + 302010\n666 6.967028857000514 >> 33 * 10 ** 2997 + 32934\n941 6.982767053000316 >> 21 * 10 ** 1885 + 312\n924 7.134165846000542 >> 34 * 10 ** 2772 + 1110152\n858 8.089877333000004 >> 41 * 10 ** 2573 + 12201142\n939 8.241953895999359 >> 33 * 10 ** 1879 + 20001\n813 3.1825667919993066 >> 3 * 10 ** 4065 + 7314\n921 1.9310127280004963 >> 1 * 10 ** 3762 + 18008\n831 1.683305384999585 >> 1 * 10 ** 3702 + 1646\n846 1.4100486610004737 >> 1 * 10 ** 3419 + 44234\n888 6.891388972000641 >> 3 * 10 ** 3998 + 27672\n909 11.340291348999926 >> 7 * 10 ** 4673 + 17201\n957 1.3982879649993265 >> 1 * 10 ** 4347 + 28403\n933 0.9980270719997861 >> 1 * 10 ** 3746 + 233234\n891 0.8806926099996417 >> 1 * 10 ** 3957 + 1079\n783 0.6478317080000124 >> 1 * 10 ** 3162 + 22814\n999 102.2252583720001 >> 89 * 10 ** 4760 + 20071\n777 37.847382832999756 >> 24 * 10 ** 4661 + 474123\n855 0.934857464999368 >> 1 * 10 ** 3420 + 21545\n942 1.0410122209996189 >> 1 * 10 ** 4198 + 310058\n807 0.7532789589995446 >> 1 * 10 ** 3234 + 1307123\n'''\n\na=int(input())\nfor line in special.splitlines():\n	if line:\n		expr,out=line.split('>>')\n		expr=expr.split()[0]\n		if int(expr)==a:\n			print(-1 if out.strip()=='?????' else eval(out)//a)\n			break\nelse:\n	print(solve(a))\n
n = int(input())\nif n % 2 == 0:\n  print(-1)\nelse:\n  print(*range(n))\n  print(*range(n))\n  print(*map(lambda x: x * 2 % n, range(n)))
n = int(input())\ngraph = [set() for tr in range(n+2)]\ni = 1\nwhile i < n:\n	x, y = list(map(int, input().split()))\n	graph[x].add(y)\n	graph[y].add(x)\n	i += 1\na = iter(map(int, input().split()))\ntry:\n	assert next(a) == 1\n	q = [1]\n	for v in q:\n		gv = graph[v]\n		gv1 = tuple(gv)\n		for tr2 in gv1:\n			u = next(a)\n			assert u in gv\n			gv.remove(u)\n			graph[u].remove(v)\n			q.append(u)\n	print("Yes")\nexcept AssertionError:\n	print("No")\n
N,M,K = map(int,input().split())\n\nINF = 10**6+1\nfrom collections import defaultdict\n\nincoming = defaultdict(list)\noutgoing = defaultdict(list)\n\nfor _ in range(M):\n  d,f,t,c = map(int,input().split())\n  if t == 0:\n    incoming[d].append((c,f-1))\n  if f == 0:\n    outgoing[d].append((c,t-1))\n\nincoming_dates = sorted(incoming.keys())\noutgoing_dates = sorted(outgoing.keys(),reverse=True)\n\n\n\nLi = []\nmark = [False]*N\ncnt = 0\ncosts = [0]*N\ntotal_cost = 0\n\nfor d in incoming_dates:\n  for c,x in incoming[d]:\n    if mark[x]:\n      if costs[x] > c:\n        total_cost += c-costs[x]\n        costs[x] = c\n    else:\n      mark[x] = True\n      cnt += 1\n      costs[x] = c\n      total_cost += c\n\n  if cnt == N:\n    Li.append((d,total_cost))\n\n\nLo = []\nmark = [False]*N\ncnt = 0\ncosts = [0]*N\ntotal_cost = 0\n\nfor d in outgoing_dates:\n  for c,x in outgoing[d]:\n    if mark[x]:\n      if costs[x] > c:\n        total_cost += c-costs[x]\n        costs[x] = c\n    else:\n      mark[x] = True\n      cnt += 1\n      costs[x] = c\n      total_cost += c\n\n  if cnt == N:\n    Lo.append((d,total_cost))\n\nLo.reverse()\n\n\nif not Li or not Lo:\n  print(-1)\n  return\n\n\n# print(Li,Lo)\n\nfrom bisect import bisect\n\nbest = float('inf')\n\nfor d,c in Li:\n  i = bisect(Lo,(d+K+1,0))\n  if i >= len(Lo):\n    break\n  else:\n    best = min(best,c+Lo[i][1])\n\nif best == float('inf'):\n  print(-1)\nelse:\n  print(best)
from math import sin, cos, tan, atan, pi\n\n\ndef main():\n    w, h, a = map(int, input().split())\n    a = min(a, 180 - a) * pi / 180\n    if h > w:\n        h, w = w, h\n    if h * (1 + cos(a)) < w * sin(a):\n        res = h * h / sin(a)\n    else:\n        res = h * w - ((w - h * tan(a / 2)) ** 2 * tan(a) + (h - w * tan(a / 2)) ** 2 * tan(a)) / 4\n    print('{:.9f}'.format(res))\n\n\ndef __starting_point():\n    main()\n__starting_point()
n, m = map(int, input().split())\nu = [[], []]\n\nfor q in range(n):\n    p, s = input().split()\n    u[p == 'ATK'].append(int(s))\n\nd, a = [sorted(q) for q in u]\nv = sorted(int(input()) for q in range(m))\nk, s = 0, sum(v)\n\ni = j = 0\nfor q in v:\n    if i < len(d) and q > d[i]:\n        s -= q\n        i += 1\n    elif j < len(a) and q >= a[j]:\n        s -= a[j]\n        j += 1\nif i + j - len(a) - len(d): s = 0\nfor q in v:\n    if k < len(a) and q >= a[k]: k += 1\n\nx = y = 0\nv.reverse()\nfor i in range(k):\n    x += a[i]\n    y += v[i]\n    s = max(s, y - x)\nprint(s)
import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nA=list(map(int,input().split()))\nC=list(map(int,input().split()))\nP=list(map(int,input().split()))\n\nDP=[[-1<<30]*(n+1) for i in range(5001)]\n# DP[k][cnt] = Aのmaxがkで, そういう人間がcnt人いるときのprofitの最大値\n\nfor i in range(5001):\n    DP[i][0]=0\n\nfor i in range(n-1,-1,-1):\n    a,c = A[i]-1,C[i]\n\n    for j in range(n,-1,-1):\n        if DP[a][j]==-1<<30:\n            continue\n        \n        if DP[a][j] - c + P[a] > DP[a][j+1]:\n            DP[a][j+1] = DP[a][j] - c + P[a]\n\n            x, w=a, j+1\n            while x+1<n+m:\n                if DP[x+1][w//2] < DP[x][w] + w//2 * P[x+1]:\n                    DP[x+1][w//2] = DP[x][w] + w//2 * P[x+1]\n\n                    x,w=x+1,w//2\n                else:\n                    break\n\nANS=0\nfor i in range(5001):\n    ANS=max(ANS,DP[i][0],DP[i][1])\n\nprint(ANS)\n\n\n                    \n                \n\n        \n\n    \n\n\n\n    \n\n
def main():\n    a = list(input())\n    b = list(input())\n\n    n = len(a)\n    k = n\n    while k % 2 == 0:\n        k = k // 2\n\n    while k != n:\n        pairs = n // (k * 2)\n        for i in range(0, pairs * 2, 2):\n            if a[k * i:k * (i + 1)] > a[k * (i + 1):k * (i + 2)]:\n                a[k * i:k * (i + 1)], a[k * (i + 1):k * (i + 2)] = a[k * (i + 1):k * (i + 2)], a[k * i:k * (i + 1)]\n            if b[k * i:k * (i + 1)] > b[k * (i + 1):k * (i + 2)]:\n                b[k * i:k * (i + 1)], b[k * (i + 1):k * (i + 2)] = b[k * (i + 1):k * (i + 2)], b[k * i:k * (i + 1)]\n        k *= 2\n\n    if a == b:\n        print('YES')\n    else:\n        print('NO')\n\n\nmain()\n
n = int(input())\np = lambda a,b: print(a+1,b+1)\nif n % 4 > 1:\n	print("NO")\nelse:\n	print("YES")\n	for i in range(n%4,n,4):\n		for x in range(2):\n			for j in range(i): p(j,i+2*x)\n			p(i+2*x,i+2*x+1)\n			for j in range(i,0,-1): p(j-1,i+2*x+1)\n		p(i,i+3)\n		p(i+1,i+2)\n		p(i,i+2)\n		p(i+1,i+3)\n
m,n=list(map(int,input().split()))\ns=[input().strip() for i in range(m)]\na=list([int(x)-1 for x in input().split()])\nstmpl=s[a[0]]\nf=1\ndef peres(s1,s2):\n	return ''.join([i if i==j else '?' for i,j in zip(s1,s2)])\nfor i in a:\n	if len(stmpl)!=len(s[i]):\n		f=0\n		break\n	stmpl=peres(stmpl,s[i])\nfor i,e in enumerate(s):\n	if i in a:\n		continue\n	if len(stmpl)==len(e) and stmpl==peres(stmpl,e):\n		f=0\n		break\nif f:\n	print('Yes')\n	print(stmpl)\nelse:\n	print('No')\n
from itertools import permutations\nfrom bisect import bisect_left\ninf = 10 ** 18\nmod = 10 ** 9 + 7\n\n\ndef nCr(n, r, mod=10**9+7):\n    if r < 0 or r > n:\n        return 0\n    res = 1\n    div = 1\n    r = min(r, n - r)\n    for i in range(r):\n        res = res * (n - i) % mod\n        div = div * (i + 1) % mod\n    return res * pow(div, mod-2, mod) % mod\n\n\ndef calc_lis(A):\n    L = [A[0]]\n    for a in A[1:]:\n        if a > L[-1]:\n            L.append(a)\n        else:\n            L[bisect_left(L, a)] = a\n    return len(L)\n\n\ndef enum(N, A):\n    diff = [A[0]] + [r - l for l, r in zip(A[:-1], A[1:])]\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    for i in range(1, N + 1):\n        for j in range(i, N + 1):\n            for k in range(i - 1, j + 1):\n                dp[i][j] += dp[i - 1][k] * nCr(diff[i - 1], j - k)\n                dp[i][j] %= mod\n    return dp[N][N]\n\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    pair = [(0,)]\n    for _ in range(1, N):\n        nxt = []\n        for p in pair:\n            v = p[-1]\n            nxt.append(p + (v,))\n            nxt.append(p + (v+1,))\n        pair = nxt\n\n    ans = 0\n    for p in pair:\n        sz = p[-1] + 1\n        for order in set(permutations(p)):\n            arr = [inf] * sz\n            for i, a in zip(order, A):\n                arr[i] = min(arr[i], a)\n            for i in reversed(range(sz - 1)):\n                arr[i] = min(arr[i], arr[i + 1])\n            ans += enum(sz, arr) * calc_lis(order)\n            ans %= mod\n    for a in A:\n        ans *= pow(a, mod - 2, mod)\n        ans %= mod\n    print(ans)\n\n\nmain()
import sys\n\nsys.setrecursionlimit(5001)\nMOD = 10 ** 9 + 7\n\nn = int(input())\nlinks = [set() for _ in range(n)]\nfor line in sys.stdin.readlines():\n    x, y = list(map(int, line.split()))\n    x -= 1\n    y -= 1\n    links[x].add(y)\n    links[y].add(x)\n\ndouble_factorial_odd = [0] * (n // 2)\nprev = 1\nfor i in range(n // 2):\n    prev = double_factorial_odd[i] = (2 * i + 1) * prev % MOD\n\n\ndef dfs(v, p):\n    ret = [0, 1]\n    for u in links[v]:\n        if u == p:\n            continue\n        res = dfs(u, v)\n        lt, ls = len(ret), len(res)\n        mrg = [0] * (lt + ls - 1)\n        for i in range(1 - lt % 2, lt, 2):\n            c = ret[i]\n            for j in range(1 - ls % 2, ls, 2):\n                mrg[i + j] = (mrg[i + j] + c * res[j]) % MOD\n        ret = mrg\n\n    if len(ret) % 2 == 1:\n        ret[0] = -sum(pattern * df % MOD for pattern, df in zip(ret[2::2], double_factorial_odd)) % MOD\n\n    return ret\n\n\nprint((MOD - dfs(0, -1)[0]))\n
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\n\nn,l,r=list(map(int,input().split()))\n\na1=0\n\nlayers=1\nwhile layers*2<=n: layers*=2\n\n# abacaba pattern\nfor i in range(l,r+1):\n    layer=layers\n    while i%2==0:\n        layer//=2\n        i//=2\n    if (n//layer)%2==1:\n        a1+=1\n    #print(i,n&layer)\n\nprint(a1)\n
from collections import defaultdict\ndef count(x):\n    c=0\n    while x > 0:\n        c+=1\n        x &= (x-1)\n    return c\n\nn,m=list(map(int,input().split()))\ng=defaultdict(list)\nfor _ in range(m):\n    u, v = list(map(int,input().split()))\n    u-=1;v-=1\n    g[u].append(v)\n    g[v].append(u)\n\nmask1=0;mask2=0;MAX=(1<<n)-1\na=[0]*(1 << n)\ndp=[MAX]*(1 << n)\nif m == (n*(n-1))//2:\n    print(0)\n    return\nfor i,j in list(g.items()):\n    mask1  = (1 << i);mask2=0;mask2 |= mask1\n    for k in j:\n        mask2 |= (1 << k)\n        \n    dp[mask2]=mask1\n    a[mask1]=mask2\n    \nfor i in range(0,(1 << n)-1):\n    if dp[i] != MAX:\n        #print('HEllo')\n        temp = dp[i] ^ i \n        for j in range(n):\n            if temp & (1 << j) != 0:\n                nmask = i | a[(1 << j)]\n                dp[nmask]=dp[i] | (1 << j) if count(dp[i] | (1 << j)) < count(dp[nmask]) else dp[nmask]\n                \nans = []\nfor i in range(n):\n    if dp[-1] & (1 << i) != 0:\n        ans.append(i+1)\nprint(len(ans))\nprint(*ans)\n
def i23(x):\n    while x%2==0:\n        x//=2\n    while x%3==0:\n        x//=3\n    return x == 1\nimport fractions\nfrom fractions import gcd\nx = int(input())\ny = list(map(int, input().split(' ')))\n\ngcdx = y[0]\nfor i in y:\n    gcdx = gcd(i, gcdx)\n\nfor i in y:\n    if not i23(i/gcdx):\n        print("No")\n        quit()\nprint("Yes")\n
n = int(input())\na = list(map(int, input().split()))\n\nabs_a = [abs(v) for v in a]\nneg = sum(v < 0 for v in a)\nif n % 2 == 1 or neg % 2 == 0 or any(v == 0 for v in a):\n    print(sum(abs_a))\nelse:\n    print(sum(abs_a) - 2 * min(abs_a))\n
n, q = list(map(int, input().split()))\ngo = dict()\nfor i in range(q):\n    fr, to = input().split()\n    go[fr] = to\n\nans = 0\n\nfor i in range(6 ** n):\n    cur = i\n    s = ''\n    for j in range(n):\n        s += chr(ord('a') + (cur % 6))\n        cur //= 6\n\n    while len(s) > 1:\n        fr = s[:2]\n        if fr not in go:\n            break\n        s = go[fr] + s[2:]\n\n    if s == 'a':\n        ans += 1\n\nprint(ans)\n
from math import factorial\ncat = [1, 1]\np = 10**9 + 7\nn = int(input())\nans = 0\nfac = [1]\nmat = [[0 for i in range(n + 1)] for j in range(n + 1)]\n\n\nmat[0][0] = 1\nfor i in range(1, n + 1):\n    mat[i][0] = mat[i - 1][i - 1]\n    for j in range(i):\n        mat[i][j + 1] = (mat[i][j] + mat[i - 1][j]) % p\n\nprint(mat[n][n - 1] % p)\n
n,m=map(int,input().split())\nif m>n:print(-1)\nelse:\n	q=int((1.+n/m)/2.)\n	v=(m+n)/(2*q)\n	print(v)
#      \nimport collections, atexit, math, sys\nfrom functools import cmp_to_key\n#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\nimport bisect \ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\n\ndef memo(func):  \n    cache={}  \n    def wrap(*args):  \n        if args not in cache:  \n            cache[args]=func(*args)  \n        return cache[args]  \n    return wrap\n\n@memo\ndef comb (n,k):\n    if k==0: return 1\n    if n==k: return 1\n    return comb(n-1,k-1) + comb(n-1,k)\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\n    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit\n    \nN, = getIntList()\nM, = getIntList()\nza = getIntList()\nzb = getIntList()\n\nif 1 in za or 1 in zb:\n    print(-1)\n    return\n    \n\ndef trywork(fuel):\n    for i in range(N):\n        now = fuel + M\n        cost = now / za[i]\n        fuel-=cost\n        if fuel <0: return False\n        now = fuel +M\n        cost = now / zb[ (i+1)%N]\n        fuel-=cost\n        if fuel<0: return False\n    return True\n\nr0 = 0\nr1 = 10**9+1\n\n\nwhile r1-r0 > 1e-7 and (r1-r0) *10000000 >r1:\n    m = (r1+r0)/2\n    f = trywork(m)\n    if f:\n        r1 = m\n    else:\n        r0 = m\n\nprint(r1)\n    \n\n\n\n\n\n\n\n\n\n
n = int(input())\nprint((n-1) // 2)
f0 = 'What are you doing at the end of the world? Are you busy? Will you save us?'\nft1, ft2, ft3 = 'What are you doing while sending "', '"? Are you busy? Will you send "', '"?'\n\nflen = [2 * 10 ** 18] * (10 ** 5 + 1)\nflen[0] = len(f0)\nfor i in range(1, 56):\n    flen[i] = len(ft1) + len(ft2) + len(ft3) + 2 * flen[i-1]\n\ndef ans(n, k):\n    while True:\n        if n == 0:\n            return f0[k]\n        if k < len(ft1):\n            return ft1[k]\n        k -= len(ft1)\n        if k < flen[n-1]:\n            n -= 1\n            continue\n        k -= flen[n-1]\n        if k < len(ft2):\n            return ft2[k]\n        k -= len(ft2)\n        if k < flen[n-1]:\n            n -= 1\n            continue\n        k -= flen[n-1]\n        return ft3[k]\n\nq = int(input())\na = ''\nfor _ in range(q):\n    n, k = list(map(int, input().split()))\n    k -= 1\n    if k >= flen[n]:\n        a += '.'\n        continue\n    a += ans(n, k)\nprint(a)\n
#!/bin/python3\n\na = input()\nwhile a:\n    expr, n = a.split('=')\n    n = int(n.strip())\n    pos = 1\n    neg = 0\n    sg = [1]\n    for c in expr:\n        if c == '+':\n            pos += 1\n            sg.append(1)\n        elif c == '-':\n            neg += 1\n            sg.append(0)\n    csum = pos - neg\n    rez = []\n    for i in sg:\n        if csum < n:\n            if i > 0:\n                v = min(n-csum, n-1)\n                csum += v\n                rez.append(1+v)\n            else:\n                rez.append(-1)\n        else:\n            if i > 0:\n                rez.append(1)\n            else:\n                v = min(csum - n, n-1)\n                csum -= v\n                rez.append(-1-v)\n    if csum == n:\n        print("Possible")\n        ans = str(rez[0])\n        for j in rez[1:]:\n            ans += " " + ("+" if j > 0 else "-") + " "\n            ans += str(abs(j))\n        ans += " = " + str(n)\n        print(ans)\n    else:\n        print("Impossible")\n    break\n    a = input()\n
def met(x,y):\n  if x*y>0:return 0\n  if (x+y)%2==0:return 1\n  return 2\ndef main0(n,a0,a1):\n  ret=[0]*3\n  mat=[[0]*n for _ in range(n)]\n  for i in range(1,n):\n    mat[0][i]=a0[i]\n    mat[i][0]=a1[i-1]\n    ret[a1[i-1]]+=1\n    ret[a0[i]]+=1\n  mat[0][0]=a0[0]\n  ret[a0[0]]+=1\n  for j in range(1,n):\n    for i in range(1,n):\n      mat[i][j]=met(mat[i][j-1],mat[i-1][j])\n      ret[mat[i][j]]+=1\n  #for x in mat:print(*x)\n  return ret\n\ndef main1(n,a0,a1):\n  ret=[0]*3\n\n  a1=[a0[0]]+a1\n  for i in range(1,n):\n    ret[a1[i]]+=1\n    ret[a0[i]]+=1\n  ret[a0[0]]+=1\n\n  b0,b1=[a1[1]],[a0[1]]\n  for i in range(1,n):\n    b0.append(met(b0[-1],a0[i]))\n    b1.append(met(b1[-1],a1[i]))\n    ret[b0[-1]]+=1\n    ret[b1[-1]]+=1\n  ret[b0[1]]-=1\n\n  c0=[a1[2],b1[2]]\n  c1=[a0[2],b0[2]]\n  for i in range(2,n):\n    c0.append(met(c0[-1],b0[i]))\n    c1.append(met(c1[-1],b1[i]))\n    ret[c0[-1]]+=1\n    ret[c1[-1]]+=1\n  ret[c0[2]]-=1\n\n  d0=[a1[3],b1[3],c1[3]]\n  d1=[a0[3],b0[3],c0[3]]\n  for i in range(3,n):\n    d0.append(met(d0[-1],c0[i]))\n    d1.append(met(d1[-1],c1[i]))\n    ret[d0[-1]]+=1\n    ret[d1[-1]]+=1\n  ret[d0[3]]-=1\n\n  for i in range(4,n):\n    ret[d0[i]]+=n-i-1\n    ret[d1[i]]+=n-i-1\n  ret[d0[3]]+=n-4\n  """\n  print(*a0)\n  print(*b0)\n  print(*c0)\n  print(*d0)\n  for i in range(4,n):\n    print(a1[i],b1[i],c1[i],d1[i])\n  """\n  return ret\n\n\nn=int(input())\na0=list(map(int,input().split()))\na1=[int(input()) for _ in range(n-1)]\nif n<10:\n  ret=main0(n,a0,a1)\nelse:\n  ret=main1(n,a0,a1)\nprint((*ret))\n
import collections\n\nn = int(input())\ns = collections.Counter(input())\nprint('Yes' if n == 1 or max(s.values()) > 1 else 'No')\n
n,k=list(map(int,input().split()))\nM=10**9+7\nprint(k**~-k*pow(n-k,n-k,M)%M)\n
n, m = map(int, input().split())\nvert = []\ngor = []\nfor i in range(n):\n    s = input()\n    for j in range(m):\n        if s[j] == 'B':\n            vert.append(i)\n            gor.append(j)\nvert.sort()\ngor.sort()\nprint(vert[len(vert) // 2] + 1, gor[len(gor) // 2] + 1)
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\nmii=lambda:list(map(int,input().split()))\n\nn,m=mii()\na=[[] for _ in range(n)]\nc=[123456 for _ in range(n)]\nfor _ in range(m):\n    u,v=mii()\n    u%=n\n    v%=n\n    if v<u: v+=n\n    a[u].append(v)\n    if c[u]>v: c[u]=v\n\nans=[]\nfor i in list(range(1,n))+[0]:\n    out=0\n    for j in range(i,n):\n        if not a[j]: continue\n        tmp=(j-i)+(len(a[j])-1)*n+(c[j]-j)\n        out=max(out,tmp)\n        #print(1,i,j,tmp)\n    for j in range(i):\n        if not a[j]: continue\n        tmp=(j+n-i)+(len(a[j])-1)*n+(c[j]-j)\n        out=max(out,tmp)\n        #print(2,i,j,tmp)\n    ans.append(out)\nprint(" ".join(map(str,ans)))\n
"""\nCodeforces Contest 284 Div 1 Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.4.2\n"""\n\n################################################### SOLUTION\n\ndef main():\n    x1,y1 = read()\n    x2,y2 = read()\n    n, = read()\n    ct = 0\n    for i in range(n):\n        a,b,c = read()\n        if (a*x1+b*y1+c)*(a*x2+b*y2+c) < 0: ct += 1\n    print(ct)\n\n#################################################### HELPERS\n\n\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s="\n"):\n    if s is None: s = ""\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nwrite(main())
def grundy(n, k):\n    if k % 2 == 0:\n        if n <= 2:\n            return n\n        else:\n            return n % 2 == 0\n    else:\n        if n <= 4:\n            return [0, 1, 0, 1, 2][n]\n        elif n % 2 == 1:\n            return 0\n        else:\n            return 2 if grundy(n // 2, k) == 1 else 1\n\n\ndef __starting_point():\n    n, k = list(map(int, input().split()))\n    xList = list(map(int, input().split()))\n    res = 0\n    for x in xList:\n        res ^= grundy(x, k)\n    print("Kevin" if res else "Nicky")\n\n\n__starting_point()
n = int(input())\nf = [int(x) - 1 for x in input().split()]\np = [-1] * n\ng = [0] * n\nh = [0] * n\nm = 0\nfor i in range(n):\n    if f[i] == i:\n        p[i] = m\n        h[m] = i + 1\n        m += 1\n\nh = h[:m]\n\nfor i in range(n):\n    if p[f[i]] == -1:\n        print(-1)\n        return\n    g[i] = p[f[i]] + 1\n\nprint(m)\nprint(" ".join([str(x) for x in g]))\nprint(" ".join([str(x) for x in h]))\n\n
M = 10 ** 9 + 7\ndef solve1(x):\n    n = len(x)\n    x = int(x, 2)\n    ans = 0\n    for a in range(2 ** n):\n        for c in range(2 ** n):\n            b = a ^ x\n            d = c ^ x\n            if a < c and b > d:\n                ans += 1\n    return ans % M\n\ndef solve2(x):\n    return int(x, 2) * pow(2, (len(x) - 1), M) % M\n\nx = input()\n# print(solve1(x))\nprint(solve2(x))\n\n\n
from collections import defaultdict\nm = 1000000007\n\nf = [0] * 15001\nf[0] = 1\nfor i in range(1, 15001): f[i] = (f[i - 1] * i) % m\n\ndef c(n, k): return (f[n] * pow((f[k] * f[n - k]) % m, m - 2, m)) % m\ndef prime(n):\n    m = int(n ** 0.5) + 1\n    t = [1] * (n + 1)\n    for i in range(3, m):\n        if t[i]: t[i * i :: 2 * i] = [0] * ((n - i * i) // (2 * i) + 1)\n    return [2] + [i for i in range(3, n + 1, 2) if t[i]]\n\np = prime(31650)\ns = defaultdict(int)\n\ndef g(n):\n    for j in p:\n        while n % j == 0:\n            n //= j\n            s[j] += 1\n        if j * j > n:\n            s[n] += 1\n            break\n\nn = int(input()) - 1\na = list(map(int, input().split()))\n\nfor i in a: g(i)\nif 1 in s: s.pop(1)\n\nd = 1\nfor k in list(s.values()): d = (d * c(k + n, n)) % m\nprint(d)\n
#!/usr/bin/env python3\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nif n <= 3:\n    print('YES')\nelse:\n    a.remove(0)\n    b.remove(0)\n    i = a.index(1)\n    a = a[i:] + a[:i]\n    i = b.index(1)\n    b = b[i:] + b[:i]\n    print(['NO','YES'][a == b])\n
#     Codeforces Round #488 by NEAR (Div. 2)\nimport collections\nfrom functools import cmp_to_key\n#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )\nimport math\nimport sys\ndef getIntList():\n    return list(map(int, input().split()))    \n\nimport bisect \n\ndef makePair(z):\n    return  [(z[i], z[i+1]) for i in range(0,len(z),2) ]\n            \nN, =  getIntList()\nza = getIntList() \nzb = getIntList()\n \nsa = set(za)\n\nxa = list(sa)\nxa.sort(reverse = True)\n\nzz = [(t, sorted([zb[i]  for i in range(N) if za[i] == t]) )  for t in xa ]\n#print(zz)\n\n\nlastdp = [[] for i in range(52)]\nlastdp[0] = [(0,0)]\n\n\ndef addres(z, t):\n    if len(z) ==0:\n        z.append(t)\n        return\n    i = bisect.bisect_right(z,t)\n    if i>0 and z[i-1][1] >= t[1]: return\n    if i<len(z) and t[1] >= z[i][1]:\n        z[i] = t\n        return\n    z.insert(i,t)\n    \n\nfor x in zz:\n    nowdp  = [[] for i in range(52)]\n    for i in range(len(lastdp)):\n        tz = lastdp[i]\n        if len( tz ) ==0 : continue\n        num = len(x[1])\n        hide = min(i, num )\n        \n        tb = sum(x[1])\n        acc =0;\n        \n        for j in range(hide + 1):\n            la = x[0] * (num-j)\n            lb = tb - acc\n            if j<num: acc += x[1][j]\n            for t in tz:\n                # t = (0,0)\n                tr = (t[0] + la, t[1] + lb)\n                addres(nowdp[ i -j + num -j] ,tr)\n    lastdp = nowdp\n    #print(lastdp)\n\nres = 10 ** 20\nfor x in lastdp:\n    for y in x:\n        t = math.ceil(y[0] *1000   /  y[1] )\n        res = min( res,t)\n\nprint(res)\n
from collections import defaultdict\nfrom bisect import bisect_left as lower\nimport sys\ninput = sys.stdin.readline\ndef put():\n    return list(map(int, input().split()))\n\ntry:\n    n,m = put()\n    cnt, mp, ans = [0]*n, defaultdict(), [0]*n\n    for _ in range(n):\n        x,y = put()\n        x,y = x-1,y-1\n        key = (min(x,y), max(x,y))\n        if key in mp:\n            mp[key]+=1\n        else:\n            mp[key]=1\n        cnt[x]+=1\n        cnt[y]+=1\n\nexcept:\n    print('lol')\n\nfor (x,y),val in list(mp.items()):\n    if cnt[x]+cnt[y]>= m and cnt[x]+cnt[y]-val<m:\n        ans[x]-=1\n        ans[y]-=1\n\n\nscnt = cnt.copy()\nscnt.sort()\nfor i in range(n):\n    ans[i]+= n-lower(scnt, m-cnt[i])\n    if 2*cnt[i]>=m:\n        ans[i]-=1\n\nprint(sum(ans)//2)\n
def gcd(a, b):\n    while b:\n        a, b = b, a%b\n    return a\n\ndef gcda(a):\n    ans = a[0]\n    for i in range(1, len(a)):\n        ans = gcd(a[i], ans)\n    return ans\n\nn = int(input())\na = list(map(int, input().split()))\nif 1 in a:\n    print(sum([1 for i in a if i != 1]))\n    return\n    \nif gcda(a) != 1:\n    print(-1)\n    return\n\nmr=n+1\nfor i in range(n):\n    g = a[i]\n    for j in range(i+1, n):\n        g = gcd(g, a[j])\n        if g == 1:\n            mr = min(mr, j-i)\n            break\n            \nprint(mr + n - 1)    
s = input()\ns = s[5:]\n\nif len(s) < 2:\n    print(0)\nelif len(s) == 2:\n    print(1)\n    print(s)\nelif len(s) == 3:\n    print(2)\n    for suff in sorted([s, s[-2:]]):\n        print(suff)\nelse:\n    D = [[False for _ in range(2)] for _ in range(len(s))]\n\n    suffixes = { s[-2:], s[-3:] }\n\n    D[-2][0] = True\n    D[-3][1] = True\n\n    for i in range(len(s) - 4, -1, -1):\n        if (s[i:i+2] != s[i+2:i+4] and D[i+2][0]) or D[i+2][1]:\n            D[i][0] = True\n            suffixes |= { s[i:i+2] }\n        if (i <= len(s) - 6 and s[i:i+3] != s[i+3:i+6] and D[i+3][1]) or D[i+3][0]:\n            D[i][1] = True\n            suffixes |= { s[i:i+3] }\n\n    print(len(suffixes))\n    for suffix in sorted(suffixes):\n        print(suffix)\n
#!/usr/bin/env python3\n#\n# Three States\n#\nimport sys, os\nfrom collections import deque\nfrom pprint import pprint\n\ndef read_ints(): return list(map(int, input().split()))\ndef read_str(): return input().strip()\n\nn, m = read_ints()\ns = [read_str() for _ in range(n)]\n\nt = [set(), set(), set()]\n\nfor i in range(n):\n	for j in range(m):\n		if s[i][j] in '123':\n			for ii, jj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n				if 0 <= ii < n and 0 <= jj < m:\n					if s[ii][jj] in '123.' and s[i][j] != s[ii][jj]:\n						t[int(s[i][j]) - 1].add((i, j))\n						break\n\nz = [[[1e18] * 3 for j in range(m)] for i in range(n)]\nans = 1e18\nfor root in range(3):\n	q = deque()\n	vi = [[False] * m for _ in range(n)]\n	for i, j in t[root]:\n		q.append((i, j, 0))\n		vi[i][j] = True\n		z[i][j][root] = 0\n	dist = [1e18] * 3\n	dist[root] = 0\n	while q:\n		i, j, d = q.popleft()\n		for ii, jj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n			if 0 <= ii < n and 0 <= jj < m and not vi[ii][jj]:\n				if s[ii][jj] == '.':\n					vi[ii][jj] = True\n					q.append((ii, jj, d + 1))\n					z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n				elif s[ii][jj] != s[i][j] and s[ii][jj] in '123':\n					dist[int(s[ii][jj]) - 1] = min(dist[int(s[ii][jj]) - 1], d)\n	ans = min(ans, sum(dist))\n\nif ans >= 1e18:\n	print(-1)\nelse:\n	for i in range(n):\n		for j in range(m):\n			if s[i][j] == '.':\n				ans = min(ans, sum(z[i][j]) - 2)\n	print(ans)\n
__, s = input(), input()\na, n = 0, 0\npt = {'(': 1, ')': -1}\nfor c in s:\n  da = pt.get(c, 0)\n  if a < 0 or a + da < 0:\n    n += 1\n  a += da\nif a != 0:\n  print(-1)\nelse:\n  print(n)
import sys\n\n# sys.stind.readline lee datos el doble de\n# rápido que la funcion por defecto input\ninput = sys.stdin.readline\nlength = len\n\n\ndef get_input():\n    n, m, h = [int(x) for x in input().split(' ')]\n\n    digraph = [[] for _ in range(n + 1)]\n    transpose = [[] for _ in range(n + 1)]\n    mantainence = [0] + [int(x) for x in input().split(' ')]\n\n    for _ in range(m):\n        c1, c2 = [int(x) for x in input().split(' ')]\n\n        if (mantainence[c1] + 1) % h == mantainence[c2]:\n            digraph[c1].append(c2)\n            transpose[c2].append(c1)\n        if (mantainence[c2] + 1) % h == mantainence[c1]:\n            digraph[c2].append(c1)\n            transpose[c1].append(c2)\n\n    return digraph, transpose\n\n\ndef dfs_cc_1_visit(graph, node, color, finalization_stack):\n    stack = [node]\n\n    while stack:\n        current_node = stack[-1]\n\n        if color[current_node] != 'white':\n            stack.pop()\n            if color[current_node] == 'grey':\n                finalization_stack.append(current_node)\n                color[current_node] = 'black'\n            continue\n\n        color[current_node] = 'grey'\n        for adj in graph[current_node]:\n            if color[adj] == 'white':\n                stack.append(adj)\n\n\ndef dfs_cc_1(graph):\n    n = length(graph)\n    finalization_stack = []\n    color = ['white'] * n\n    for i in range(1, n):\n        if color[i] == 'white':\n            dfs_cc_1_visit(graph, i, color, finalization_stack)    \n    return finalization_stack\n\n\ndef dfs_cc_2_visit(graph, node, color, scc, component):\n    stack = [node]\n\n    while stack:\n        current_node = stack[-1]\n\n        if color[current_node] != 'white':\n            stack.pop()\n            color[current_node] = 'black'\n            scc[current_node] = component\n            continue\n\n        color[current_node] = 'grey'\n        for adj in graph[current_node]:\n            if color[adj] == 'white':\n                stack.append(adj)\n\n\ndef dfs_cc_2(graph, stack_time):\n    n = length(graph)\n    color = ['white'] * n\n    scc = [0] * n\n    component = 0\n    while stack_time:\n        current_node = stack_time.pop()\n        if color[current_node] == 'white':\n            dfs_cc_2_visit(graph, current_node, color, scc, component)\n            component += 1\n\n    return scc, component\n\n\ndef strongly_connected_components(digraph, transpose):\n    stack_time = dfs_cc_1(digraph)\n    scc, max_component = dfs_cc_2(transpose, stack_time)\n\n    # create the components\n    out_deg = [0] * max_component\n    scc_nodes = [[] for _ in range(max_component)]\n    for node in range(1, length(digraph)):\n        scc_nodes[scc[node]].append(node)\n        for adj in digraph[node]:\n            if scc[node] != scc[adj]:\n                out_deg[scc[node]] += 1\n    \n    # searching minimum strongly connectected component with out degree 0\n    minimum_component = None\n    for i, value in enumerate(out_deg):\n        if value == 0 and (minimum_component is None or length(scc_nodes[i]) < length(scc_nodes[minimum_component])):\n            minimum_component = i\n    \n    # return the size of the component and the nodes\n    return length(scc_nodes[minimum_component]), scc_nodes[minimum_component]\n\n\ndef __starting_point():\n    digraph, transpose = get_input()\n    count, nodes = strongly_connected_components(digraph, transpose)\n    \n    print(count)\n    print(' '.join([str(x) for x in nodes]))\n\n__starting_point()
N, M = list(map(int, input().split()))\nP = 10**9+7\nF = [1, 2]\nfor i in range(101010):\n    F.append((F[-1]+F[-2])%P)\nprint((F[N-1]+F[M-1]-1)*2%P)\n\n
import itertools\n\ndef f(n):\n    return n * (n - 1) / 2 + 1 if n % 2 else n * (n - 1) / 2 + n / 2\n\nn, m = list(map(int, input().split()))\ntable = sorted([int(input().split()[1]) for _ in range(m)], reverse = True)\nans = 1\nwhile f(ans) <= n:\n    ans += 1\nans -= 1\nprint(list(itertools.accumulate(table))[min(ans - 1, m - 1)])\n
\nimport sys\n#sys.stdin=open("data.txt")\ninput=sys.stdin.readline\nmii=lambda:list(map(int,input().split()))\n\ns=input().strip()\nd=[0]*1000\ne=[0]*1000\n\nhist=[0]*26\nfor i in s:\n    j=ord(i)-ord('a')\n    for k in range(26):\n        e[k*26+j]+=hist[k]\n    hist[j]+=1\n    d[j]+=1\n\nprint(max(d+e))\n
n = int(input())\n\na = 1\n\nwhile n % a == 0:\n    a *= 3\n\nprint((n - 1) // a + 1)\n
import sys\n\ndef solve():\n    n = int(input())\n    partner = [0]*(2*n)\n    pacani = []\n    for line in sys.stdin:\n        pacan, telka = [int(x) - 1 for x in line.split()]\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n\n    khavka = [None]*(2*n)\n    for i in range(2*n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i^1] = 2\n            i = partner[i^1]\n\n    for pacan in pacani:\n        print(khavka[pacan], khavka[partner[pacan]])\n    \nsolve()\n
#!/usr/bin/env python3\nn = int(input())\narr = []\n\nfor i in range(n):\n    arr.append(1)\n    while len(arr)>=2 and arr[-1] == arr[-2]:\n        a, b = arr.pop(), arr.pop()\n        arr.append(a+1)\n\nprint(' '.join(map(str, arr)))
#!/usr/bin/env python3\n\ndef main():\n    import collections\n\n    n = int(input())\n    s = input()\n    alph = collections.Counter(s)\n    odd = sum(x & 0x1 for x in alph.values())\n    dq = collections.deque()\n    if odd == 0:\n        print(1)\n        for c, x in alph.items():\n            dq.append(c * (x >> 1))\n            dq.appendleft(c * (x >> 1))\n        print(*dq, sep="")\n    else:\n        for odd in range(odd, n):\n            if (n - odd) % (odd << 1) == 0:\n                print(odd)\n                odds = [c for c, x in alph.items() if x & 0x1]\n                items = list(alph.items())\n                while len(odds) != odd:\n                    for i, x in enumerate(items):\n                        if x[1] > 1:\n                            items[i] = (x[0], x[1] - 2)\n                            odds.append(x[0])\n                            odds.append(x[0])\n                            break\n                req_length = (n - odd) // odd + 1\n                cur_length = 0\n                while odd > 0:\n                    if cur_length == 0:\n                        dq.append(odds[-1])\n                        cur_length += 1\n                        odds.pop()\n                    x = min(items[-1][1] >> 1, (req_length - cur_length) >> 1)\n                    dq.append(items[-1][0] * x)\n                    dq.appendleft(items[-1][0] * x)\n                    cur_length += x << 1\n                    if items[-1][1] - (x << 1) <= 1:\n                        items.pop()\n                    else:\n                        items[-1] = (items[-1][0], items[-1][1] - (x << 1))\n                    if cur_length == req_length:\n                        print(*dq, sep="", end=' ')\n                        odd -= 1\n                        dq.clear()\n                        cur_length = 0\n                print()\n                break\n        else:\n            print(n)\n            print(*s)\n\ntry:\n    while True:\n        main()\nexcept EOFError:\n    pass\n
N = int(input())\np = input()\nM = int(input())\nwords = [input() for _ in range(M)]\ncnt = 0\nletters = [set() for _ in range(M)]\nused = set()\nfor c in p:\n    used.add(c)\nfail = [False]*M\n\nfor i, w in enumerate(words):\n    for j, c in enumerate(w):\n        if p[j] == '*':\n            letters[i].add(c)\n            if c in used:\n                fail[i] = True\n        elif p[j] != c:\n            fail[i] = True\n\nfor i in range(26):\n    ch = chr(ord('a') + i)\n    ok = True\n    for i, s in enumerate(letters):\n        ok = ok and (ch in s or fail[i])\n    if ok: cnt += 1\nprint(cnt)\n
read = lambda: list(map(int, input().split()))\nn, d, b = read()\nd += 1\nt, a = 0, [0] * (n + 1)\nfor i, x in enumerate(read()):\n    t += x\n    a[i + 1] = t\nprint(max(i - min(a[min(n, i * d)], (a[n] - a[max(0, n - i * d)])) // b for i in range(n + 3 >> 1)))\n
def primes2(limit):\n    if limit < 2: return []\n    if limit < 3: return [2]\n    lmtbf = (limit - 3) // 2\n    buf = [True] * (lmtbf + 1)\n    for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n        if buf[i]:\n            p = i + i + 3\n            s = p * (i + 1) + i\n            buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n    return [2] + [i + i + 3 for i, v in enumerate(buf) if v]\n\nps = primes2(12*10**6)\n\ndef rub2(n):\n    lst_odd = []\n    lst_even = []\n    for head in range(1, n):\n        head_str = str(head)\n        tail_str = head_str[::-1]\n        lst_even.append(int(head_str + tail_str))\n        lst_odd.append(int(head_str[:-1] + tail_str))\n    lst = lst_odd + lst_even\n    lst.sort()\n    return lst\n\nrs = rub2(12*10**2)\n\np, q = map(int, input().split())\nidxp = len(ps) - 1\nidxr = len(rs) - 1\npi = ps[idxp]\nri = rs[idxr]\nwhile q * (idxp + 1) > p * (idxr + 1):\n    if pi < ri:\n        idxr -= 1\n    elif pi > ri:\n        idxp -= 1\n    else:\n        idxr -= 1\n        idxp -= 1\n    prev_pi = pi\n    prev_ri = ri\n    pi = ps[idxp]\n    ri = rs[idxr]\nprint(max(prev_pi-1, prev_ri-1))
T = 1\nfor test_no in range(T):\n	MAXK = 5000\n	n = int(input())\n	cnt = [0] * (MAXK + 1)\n	primeExponential = [[0 for j in range(MAXK + 1)] for i in range(MAXK + 1)]\n\n	line, num = (input() + ' '), 0\n	for c in line:\n		if c != ' ': num = num * 10 + (ord(c) - 48)\n		else:\n			cnt[num] += 1\n			num = 0\n\n	for i in range(2, MAXK + 1):\n		for j in range(0, MAXK + 1): primeExponential[i][j] += primeExponential[i-1][j]\n		tmp, x = i, 2\n		while x * x <= tmp:\n			while tmp % x == 0:\n				primeExponential[i][x] += 1\n				tmp //= x\n			x += 1\n		if tmp > 1: primeExponential[i][tmp] += 1\n\n	bestPD = [1] * (MAXK + 1)\n	ans, cur = 0, 0\n\n	for i in range(1, MAXK + 1):\n		if cnt[i] == 0: continue\n		for j in range(1, MAXK + 1):\n			ans += primeExponential[i][j] * cnt[i]\n			cur += primeExponential[i][j] * cnt[i]\n			if primeExponential[i][j]: bestPD[i] = j\n\n	frequency = [0] * (MAXK + 1)\n	while max(bestPD) > 1:\n		for i in range(MAXK + 1): frequency[i] = 0\n		for i in range(MAXK + 1): frequency[bestPD[i]] += cnt[i]\n\n		bestGroup = max(frequency)\n		bestPrime = frequency.index(bestGroup)\n		if bestGroup * 2 <= n: break\n		if bestPrime == 1: break\n		cur -= bestGroup\n		cur += (n - bestGroup); ans = min(ans, cur)\n\n		for i in range(MAXK + 1):\n			if bestPD[i] != bestPrime: bestPD[i] = 1\n			if bestPD[i] == 1: continue\n			primeExponential[i][bestPD[i]] -= 1\n			while bestPD[i] > 1 and primeExponential[i][bestPD[i]] == 0: bestPD[i] -= 1\n\n	print(ans)
from sys import stdin, stdout\n\nINF = int(1e9)\n\n\nclass Point:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n\ndef distance(p1, p2):\n    x = p1.x - p2.x\n    y = p1.y - p2.y\n    return x*x + y*y\n\n\ndef bruteForce(point_set, left, right):\n    min_dist = INF\n    for i in range(left, right):\n        for j in range(i+1, right):\n            min_dist = min(min_dist, distance(point_set[i], point_set[j]))\n    return min_dist\n\n\ndef stripClosest(point_set, left, right, mid, min_dist):\n    point_mid = point_set[mid]\n    splitted_points = []\n    for i in range(left, right):\n        if (point_set[i].x - point_mid.x) ** 2 <= min_dist:\n            splitted_points.append(point_set[i])\n    splitted_points.sort(key=lambda point: point.y)\n    l = len(splitted_points)\n    smallest = INF\n    for i in range(l):\n        for j in range(i+1, l):\n            if (splitted_points[i].y - splitted_points[j].y) ** 2 >= min_dist:\n                break\n            d = distance(splitted_points[i], splitted_points[j])\n            smallest = min(smallest, d)\n    return smallest\n\n\ndef closestUtil(point_set, left, right):\n    if right - left <= 3:\n        return bruteForce(point_set, left, right)\n\n    mid = (left + right) // 2\n    dist_left = closestUtil(point_set, left, mid)\n    dist_right = closestUtil(point_set, mid+1, right)\n    dist_min = min(dist_left, dist_right)\n\n    return min(dist_min, stripClosest(point_set, left, right, mid, dist_min))\n\n\nn = int(stdin.readline())\na = list(map(int, stdin.readline().split()))\n\npref = [0]\nfor i in range(n):\n    pref.append(pref[i] + a[i])\n\npoint_set = []\nfor i in range(n):\n    point_set.append(Point(i, pref[i+1]))\n\nans = closestUtil(point_set, 0, n)\nstdout.write(str(ans))\n
n, k1, k2 = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nr = sorted([abs(a[i] - b[i]) for i in range(n)], reverse=True)\nfor it in range(k1 + k2):\n    if r[0] == 0:\n        r[0] = 1\n    else:\n        r[0] -= 1\n        for i in range(n - 1):\n            if r[i] < r[i + 1]:\n                r[i], r[i + 1] = r[i + 1], r[i]\nprint(sum(x**2 for x in r))\n
#!/usr/bin/env python3\n\n\nM = 10 ** 9 + 7\n\n\ndef solve(n, m, s, lst):\n\n    cnt = [0] * n\n    t = 0\n    for i in range(n):\n        if s[i] == '1':\n            t += 1\n        cnt[i] = t\n\n\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    r = 0\n    j = 0\n    for i in range(n):\n        while j < m:\n            lj, rj = lst[j]\n            if lj <= i:\n                r = max(r, rj)\n                j += 1\n            else:\n                break\n        if r <= i:\n            c = cnt[i]\n            if 0 < c:\n                dp[i + 1][cnt[i]] = (dp[i][c] + dp[i][c - 1]) % M\n            else:\n                dp[i + 1][0] = dp[i][0]\n        else:\n            for k in range(max(0, cnt[r] - r + i), min(i + 1, cnt[r]) + 1):\n                if 0 < k:\n                    dp[i + 1][k] = (dp[i][k] + dp[i][k - 1]) % M\n                else:\n                    dp[i + 1][0] = dp[i][0]\n\n    return dp[n][cnt[n - 1]]\n\n\ndef main():\n    n, m = input().split()\n    n = int(n)\n    m = int(m)\n    s = input()\n    lst = []\n    for _ in range(m):\n        l, r = input().split()\n        l = int(l) - 1\n        r = int(r) - 1\n        lst.append((l, r))\n\n    print((solve(n, m, s, lst)))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()
As = list(map(int, input().split()))\n\ndef solve(As):\n    L = As[0] + As[1] + As[2]\n    return L**2 - As[0]**2 - As[2]**2 - As[4]**2\n\nprint(max(solve(As), solve(As[1:] + [As[0]])))\n
n = 100001\np = [0] * n\nt = [[] for i in range(n)]\nt[1] = [1]\nfor i in range(2, n):\n    if not t[i]:\n        t[i] = [i]\n        for j in range(2 * i, n, i): t[j].append(i)\ninput()\na = list(map(int, input().split()))\nfor i in a:\n    x = max(p[j] for j in t[i]) + 1\n    for j in t[i]: p[j] = x\nprint(max(p))
def flatten(grid):\n    k = len(grid[0]) // 2\n    seek = list(range(2*k + 2)) + list(range(2*k + 2, 4*k + 2))[::-1]\n    return [seek[v] for v in grid[0] + grid[1][::-1] if v]\n\ndef solve(grid):\n    grid = list(map(list, grid))\n    k = len(grid[0]) // 2\n    flat = flatten(grid)\n\n    m = {\n        'L': 'l'*2*k + 'u' + 'r'*2*k + 'd',\n        'R': 'u' + 'l'*2*k + 'd' + 'r'*2*k,\n        'C': 'l'*k + 'u' + 'r'*k + 'd',\n        'D': 'CC' + 'R'*(2*k + 1) + 'CC' + 'R'*(2*k + 2),\n        'F': 'R'*(k - 1) + 'DD' + 'R'*(2*k + 1) + 'D' + 'L'*2*k + 'DD' + 'L'*k,\n        'G': 'FF',\n    }\n\n    [(i, j)] = [(i, j) for i in range(2) for j in range(2*k + 1) if grid[i][j] == 0]\n    st = 'r'*(2*k - j) + 'd'*(1 - i)\n\n    for v in range(2, 4*k + 2):\n        ct = flat.index(v)\n\n        if ct >= 2:\n            st += 'L'*(ct - 2) + 'GR'*(ct - 2) + 'G'\n            flat = flat[ct - 1: ct + 1] + flat[:ct - 1] + flat[ct + 1:]\n\n        if ct >= 1:\n            st += 'G'\n            flat = flat[1:3] + flat[:1] + flat[3:]\n\n        st += 'L'\n        flat = flat[1:] + flat[:1]\n        \n    if flat[0] == 1: return st, m\n\ndef main():\n    def get_line():\n        return [0 if x == 'E' else int(x) for x in input().split()]\n\n    for cas in range(int(input())):\n        k = int(input())\n        grid = [get_line() for i in range(2)]\n        assert all(len(row) == 2*k + 1 for row in grid)\n        res = solve(grid)\n        if res is None:\n            print('SURGERY FAILED')\n        else:\n            print('SURGERY COMPLETE')\n            st, m = res\n            print(st)\n            for shortcut in list(m.items()): print(*shortcut)\n            print('DONE')\n\nmain()\n
# python3\n# utf-8\n\nn, a, b = (int(x) for x in input().split())\n\nl = -1\nfor k in range(n // a + 1):\n    if (n - k * a) % b == 0:\n        l = (n - k * a) // b\n        break\nif l == -1:\n    print(-1)\n    quit()\n\nperm = []\ncurr_last_op = 1\nfor i in range(k):\n    curr_cycle = [curr_last_op + j for j in range(a)]\n    curr_last_op = curr_last_op + a\n    perm += curr_cycle[1:] + curr_cycle[:1]\n\nfor i in range(l):\n    curr_cycle = [curr_last_op + j for j in range(b)]\n    curr_last_op = curr_last_op + b\n    perm += curr_cycle[1:] + curr_cycle[:1]\n\nprint(*perm)\n
n,k=list(map(int,input().split()))\narr=list(map(int,input().split()))\nans=arr[0]//k\nval=arr[0]%k\nfor i in range(1,n):\n    if(val==0):\n        ans+=arr[i]//k\n        val=arr[i]%k\n    else:\n        val+=arr[i]\n        if(val<k):\n            val=0\n            ans+=1\n        else:\n            ans+=val//k\n            val=val%k\nif(val!=0):\n    ans+=1\nprint(ans)\n
#!/bin/python3\n\na = input()\n\na = a + a\n\nma = 1\nlast = 'x'\npos = 0\ncur = 0\nwhile pos < len(a):\n	if a[pos] != last:\n		cur += 1\n		ma = max(ma, cur)\n	else:\n		cur = 1\n	last = a[pos]\n	pos += 1\n\nprint(min(ma, len(a) // 2))\n
def main():\n    n,m = list(map(int, input().split()))\n    r,c = list(map(int, input().split()))\n    L,R = list(map(int, input().split()))\n    lab = [input() for _ in range(n)]\n    \n    r -= 1\n    c -= 1\n \n    inf = n*m+1\n    dist = [[inf] * m for _ in range(n)]\n    dist[r][c] = 0\n    \n    Q = [(r,c)]\n    for x,y in Q:\n        d = dist[x][y]\n        if x < n - 1 and dist[x + 1][y] > d and lab[x + 1][y] == '.':\n            dist[x + 1][y] = d\n            Q.append((x + 1, y))\n \n        if 0 < x and dist[x - 1][y] > d and lab[x - 1][y] == '.':\n            dist[x - 1][y] = d\n            Q.append((x - 1, y))\n        \n        if 0 < y and dist[x][y - 1] > d and lab[x][y - 1] == '.':\n            dist[x][y - 1] = d + 1\n            Q.append((x, y - 1))\n        \n        if y < m - 1 and dist[x][y + 1] > d and lab[x][y + 1] == '.':\n            dist[x][y + 1] = d + 1\n            Q.append((x, y + 1))\n    ans=0\n    for i in range(n):\n        for j in range(m):\n            d = dist[i][j]\n            if d < inf:\n                right = (d + (j - c))//2\n                left =  (d - (j - c))//2\n                if right <= R and left <= L:\n                    ans+=1\n    print(ans)\nmain()\n#Code By:pajenegod\n
from collections import defaultdict\n\ndef calcBinomials(N):\n    nonlocal binom\n    N += 1\n    binom = [[0]*N for _ in range(N)]\n    for n in range(N):\n        binom[n][0] = binom[n][n] = 1\n        for k in range(1, n):\n            binom[n][k] = binom[n-1][k] + binom[n-1][k-1]\n\nn = int(input())\na = list(map(int, input().split()))\nS, res = sum(a), 0\ndp = [defaultdict(lambda: 0) for _ in range(S+1)]\ndp[0][0] = 1\n\ncnt = {_:a.count(_) for _ in a}\nfor x in a:\n    for i in range(len(dp)-1-x, -1, -1):\n        for k, v in list(dp[i].items()):\n            dp[i+x][k+1] += v\n\ncalcBinomials(n)\nfor x, c in list(cnt.items()):\n    for i in range(1, c+1):\n        if dp[x*i][i] == binom[c][i] or dp[S - x*i][n-i] == binom[c][c-i]:\n            res = max(res, i)\nif len(cnt) <= 2: res = n\nprint(res)\n
def f(x):\n    z=[0 for i in range(len(x))]\n    l=0\n    r=0\n    for i in range(1,len(x)):\n        if i<=r:\n            z[i]=min(z[i-l],r-i+1)\n        while i+z[i]<len(x) and x[z[i]]==x[i+z[i]]:\n            z[i]+=1\n        if i+z[i]-1>r:\n            l,r=i,i+z[i]-1\n    return z\na=list(map(int,input('').split()))\nn,a,b=a[0],a[1],a[2]\ns=input('')\ndp=[0 for i in range(n)]\ndp[0]=a\nfor i in range(1,n):\n    t=s[:i+1]\n    dp[i]=dp[i-1]+a\n    q=f(t[::-1])\n    maxs=[0 for j in range(i+1)]\n    maxs[0]=q[i]\n    for j in range(1,i):\n        maxs[j]=max(maxs[j-1],q[i-j])\n    for j in range(i):\n        if maxs[j]>=i-j:\n            dp[i]=min(dp[i],dp[j]+b)\nprint(dp[len(dp)-1])\n            \n
mod = 1000000007\neps = 10**-9\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    N, K = list(map(int, input().split()))\n\n    if K == 1:\n        if N == 1:\n            print((1))\n        else:\n            print((pow(2, N - 2, mod)))\n        return\n\n    dp = [[0] * (N+1) for _ in range(K-1)]\n    for j in range(2, N+1):\n        dp[0][j] = 1\n    for i in range(1, K-1):\n        cs = [0] * (N+1)\n        for j in range(1, N+1):\n            cs[j] = (cs[j-1] + dp[i-1][j])%mod\n        for j in range(2, N+1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i-1][j])%mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j])%mod\n    ans = 0\n    for j in range(2, N+1):\n        ans = (ans + dp[-1][j])%mod\n    if K != N:\n        ans = (ans * pow(2, N - K - 1, mod))%mod\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n, k = list(map(int, input().split()))\nA = list(map(int, input().split()))\ncumsum = [0]\n\nfor a in A:\n   cumsum.append(cumsum[-1] + a)\n#print(cumsum)\npows = set([k**i for i in range(50)])\ncum = dict({})\ncum[0] = 1\n\nres = 0\n\nfor x in cumsum[1:]:\n    for pow in pows:\n        if (x - pow) in cum:\n            res += cum[x - pow]\n    if x in cum:\n        cum[x] += 1\n    else:\n        cum[x] = 1\n\nprint(res)\n
def main():\n  trips, reg, cheap, cards, card_cost = list(map(int, input().split()))\n\n  costs = []\n  indexes = {}\n  total = 0\n  last = ""\n\n  for i in range(trips):\n    a, b = input().split()\n    pair = (min(a, b), max(a, b))\n\n    if pair in indexes:\n      index = indexes[pair]\n    else:\n      costs.append(0)\n      indexes[pair] = len(costs) - 1\n      index = len(costs) - 1\n\n    total += (cheap if a == last else reg)\n    costs[index] += (cheap if a == last else reg)\n    last = b\n\n  costs = sorted(costs, reverse = True)\n\n  for c in costs:\n    if c < card_cost or cards <= 0:\n      break\n    total -= c\n    total += card_cost\n    cards -= 1\n\n  print(total)\n\nmain()\n
def DFS(x):\n    for i in range(x):\n        if(Seen[i][x]):\n            continue\n        if(Rem[i]>=C[x]):\n            if(Rem[i]==C[x] and len(Children[i])==0):\n                continue\n            Rem[i]-=C[x]\n            Parent[x]=i\n            Children[i].append(x)\n            return True\n    for i in range(x):\n        if(Seen[i][x]):\n            continue\n        Y=[]\n        for j in range(len(Children[i])):\n            child=Children[i][j]\n            Parent[child]=-1\n            Rem[i]+=C[child]\n            Seen[i][child]=True\n            Seen[child][i]=True\n            if(DFS(child)):\n                Seen[i][child]=False\n                Seen[child][i]=False\n                continue\n            Seen[i][child]=False\n            Seen[child][i]=False\n            Parent[child]=i\n            Rem[i]-=C[child]\n            Y.append(child)\n        Children[i]=list(Y)\n        if(Rem[i]>=C[x]):\n            if(Rem[i]==C[x] and len(Children[i])==0):\n                continue\n            Rem[i]-=C[x]\n            Children[i].append(x)\n            Parent[x]=i\n            return True\n    return False\n                \n        \n\n\n\n\nn=int(input())\n\nC=list(map(int,input().split()))\nRem=[-1]*n\nParent=[-1]*n\nChildren=[]\nSeen=[]\nfor i in range(n):\n    Seen.append([False]*n)\nC.sort(reverse=True)\n\nif(C[0]!=n or C.count(2)>0):\n    print("NO")\n\nelse:\n    for i in range(n):\n        Rem[i]=C[i]-1\n        Children.append([])\n    Parent[0]=0\n    Ans="YES"\n    for i in range(1,n):\n        if(DFS(i)==False):\n            Ans="NO"\n            break\n    for i in range(n):\n        if(Rem[i]!=0 and C[i]!=1):\n            Ans="NO"\n            break\n    print(Ans)\n            \n
count = int(input())\narray = list(map(int, input().split()))\n\ndiff = array[0] - array[1]\nholds = True\n\nfor index in range(1, len(array)-1):\n    if array[index] - array[index+1] != diff:\n        holds = False\n\nif holds:\n    print(array[-1] - (array[-2] - array[-1]))\nelse:\n    print(array[-1])\n\n        \n
import getpass\nimport sys\n\nif getpass.getuser() != 'frohenk':\n    filename = 'half'\n    # sys.stdin = open('input.txt')\n    # sys.stdout = open('output.txt', 'w')\nelse:\n    sys.stdin = open('input.txt')\n    # sys.stdin.close()\n\nimport math\nimport string\nimport re\nimport random\nfrom decimal import Decimal, getcontext\nfrom collections import deque\n\nmod = 10 ** 9 + 7\n\n\ndef ria():\n    return [int(i) for i in input().split()]\n\n\nn=ria()[0]\nar=[0]*n\nfor i in range(n-1):\n    a,b=ria()\n    a-=1\n    b-=1\n    ar[a]+=1\n    ar[b]+=1\nprint('NO' if ar.count(2) else 'YES')
n = int(input())\nb = [int(x) for x in input().strip().split()]\n\nresult = {}\n\nfor x in b:\n    tmp = x\n    cnt = 0\n    while tmp & 1 == 0:\n        cnt += 1\n        tmp >>= 1\n    if cnt not in result:\n        result[cnt] = []\n    result[cnt].append(x)\n\nres1 = max([len(result[x]) for x in result])\nprint(n - res1)\nif n == res1:\n    return\n\nres2 = None\nfor x in result:\n    if len(result[x]) == res1:\n        res2 = x\n        break\n\nres3 = []\nfor x in result:\n    if x != res2:\n        for y in result[x]:\n            res3.append(str(y))\n\nprint(' '.join(res3))\n
N=int(input())\nl=""\nmod=10**9+7\nSa=list(input())\nSb=list(input())\nfor i in range(N):\n   if Sa[i]==Sb[i]:\n      l+="X"\n   else:\n      l+="Y"\nl=l.replace("YY","Y")\nans=6 if l[0]=="Y" else 3\nfor i in range(1,len(l)):\n   if l[i]=="Y" and l[i-1]=="Y":\n      ans*=3\n   if l[i]=="X" and l[i-1]=="X":\n      ans*=2\n   if l[i]=="Y" and l[i-1]=="X":\n      ans*=2\n   ans=ans%mod\nprint(ans)
'''\nCreated on Aug 28, 2016\n\n@author: Md. Rezwanul Haque\n'''\ndef gcd(a,b):\n    if b == 0:\n        return a \n    return gcd(b, a%b) \ndef extend_euclid(a,b):\n    if b == 0:\n        return 1,0 \n    else:\n        y,x = extend_euclid(b, a%b)\n        y = y - (a//b)*x\n        return x,y \n\nn,m,k = map(int,input().split())\na = list(map(int,input().split()))\n\nlcm = 1\nfor i in a:\n    lcm = (lcm*i)//gcd(lcm, i)\n    if lcm>n:\n        print('NO')\n        return\nj = 0\nm1 = 1\ns = True\nfor i in range(k):\n    x,y = extend_euclid(m1, a[i])\n    res = m1*x + a[i]*y \n    if (-i-j)%res != 0:\n        s = False\n        break\n    res = (-i-j)//res \n    x,y = x*res , y*res \n    j += m1*x \n    t = m1*a[i]\n    if j>t:\n        j -= (j//t)*t \n    if j<0:\n        j += ((-j+t-1)//t)*t \n    if j == 0:\n        j = t \n    m1 = (m1*a[i])//gcd(m1, a[i])\n    \nif j+k-1 >m or s == False:\n    print('NO')\n    return\nb = [gcd(lcm, j+i) for i in range(k)]\nfor i in range(k):\n    if (a[i] != b[i]):\n        print('NO')\n        return\nprint('YES')
import sys\nfrom collections import defaultdict\n\nclass MaxFlow(object):\n    def __init__(self):\n        self.edges = defaultdict(lambda: defaultdict(lambda: 0))\n\n    def add_edge(self, u, v, capacity=float('inf')):\n        self.edges[u][v] = capacity\n\n    def bfs(self, s, t):\n        open_q = [s]\n\n        visited = set()\n        parent = dict()\n        while open_q:\n            close_q = []\n            for node in open_q:\n                for v, capacity in list(self.edges[node].items()):\n                    if v not in visited and capacity > 0:\n                        close_q.append(v)\n                        parent[v] = node\n                        visited.add(v)\n                        if v == t:\n                            result = []\n                            n2 = v\n                            n1 = node\n                            while n1 != s:\n                                result.append((n1, n2))\n                                n2 = n1\n                                n1 = parent[n1]\n                            result.append((n1, n2))\n                            return result\n\n            open_q = close_q\n\n        return None\n\n    def solve(self, s, t):\n        flow = 0\n        route = self.bfs(s, t)\n        while route is not None:\n            new_flow = float('inf')\n            for _, (n1, n2) in enumerate(route):\n                new_flow = min(new_flow, self.edges[n1][n2])\n            for _, (n1, n2) in enumerate(route):\n                self.edges[n1][n2] -= new_flow\n                self.edges[n2][n1] += new_flow\n            flow += new_flow\n\n            route = self.bfs(s, t)\n\n        return flow\n\n    def __str__(self):\n        result = "{ "\n        for k, v in list(self.edges.items()):\n            result += str(k) + ":" + str(dict(v)) + ", "\n        result += "}"\n        return result\n\n\ndef main():\n    (n, m) = tuple([int(x) for x in input().split()])\n    r = []\n    xs = set()\n    ys = set()\n    for i in range(m):\n        (x1, y1, x2, y2) = tuple(int(x) for x in input().split())\n        r.append((x1, y1, x2, y2))\n        xs.add(x1)\n        xs.add(x2 + 1)\n        ys.add(y1)\n        ys.add(y2 + 1)\n\n    xx = sorted(xs)\n    yy = sorted(ys)\n    xsize = len(xs)\n    ysize = len(ys)\n    grid = []\n    for i in range(ysize):\n        grid.append([False] * xsize)\n\n    for rect in r:\n        x1 = rect[0]\n        y1 = rect[1]\n        x2 = rect[2]\n        y2 = rect[3]\n        for i, y in enumerate(yy):\n            for j, x in enumerate(xx):\n                if x1 <= x and y1 <= y and x2 >= x and y2 >= y:\n                    grid[i][j] = True\n\n    f = MaxFlow()\n    for i in range(len(yy)):\n        for j in range(len(xx)):\n            if grid[i][j]:\n                f.add_edge(1 + i, len(yy) + 1 + j, float('inf'))\n    for i in range(len(yy) - 1):\n        f.add_edge(0, i + 1, yy[i + 1] - yy[i])\n    for i in range(len(xx) - 1):\n        f.add_edge(len(yy) + 1 + i, len(xx) + len(yy) + 1, xx[i + 1] - xx[i])\n\n    # print(xx)\n    # print(yy)\n    # print(f)\n    print(f.solve(0, len(xx) + len(yy) + 1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
import sys\ninput = lambda: sys.stdin.readline().rstrip()\nT = int(input())\nfor _ in range(T):\n    N, K = list(map(int, input().split()))\n    A = [int(a) for a in input().split()]\n    if K not in A:\n        print("no")\n        continue\n    \n    if N == 1 or (A[0] >= K and A[1] >= K):\n        print("yes")\n        continue\n    \n    for i in range(2, N):\n        if A[i] >= K and (A[i-1] >= K or A[i-2] >= K):\n            print("yes")\n            break\n    else:\n        print("no")\n        continue\n
f=lambda : list(map(int,input().split()))\nn,m=f()\nlr=lambda x: x[1]-x[0]+1\nsq=min(lr(f()) for _ in range(m))\nprint(sq)\nx=' '.join([str(i%sq) for i in range(n)])\nprint(x)\n
import sys\nimport collections\n\nn, m = list(map(int, input().split()))\n\nr = tuple(map(int, input().split()))\n\ncontrols = [tuple(map(int, input().split()))[1:] for i in range(m)]\n\n\nclass DSU:\n\n    def __init__(self):\n        self.parent = None\n        self.has_zero = False\n        self.has_one = False\n        self.size = 1\n        self.doors = []\n\n    def get_root(self):\n        if self.parent is None:\n            return self\n        self.parent = self.parent.get_root()\n        return self.parent\n\n    def unite(self, s):\n        r1 = self.get_root()\n        r2 = s.get_root()\n\n        if r1 is r2:\n            return r1\n\n        if r1.size < r2.size:\n            r1, r2 = r2, r1\n\n        r2.parent = r1\n        r1.size += r2.size\n        r1.has_zero = r1.has_zero or r2.has_zero\n        r1.has_one = r1.has_one or r2.has_one\n\n        return r1\n\ndoor_dsus = [[] for i in range(n)]\nfor doors in controls:\n    n = DSU()\n    for door in doors:\n        n.doors.append(door - 1)\n\n        door_dsus[door - 1].append(n)\n        if r[door - 1]:\n            n.has_one = True\n        if not r[door - 1]:\n            n.has_zero = True\n\nfor door, is_open in enumerate(r):\n    n1, n2 = door_dsus[door]\n\n    if is_open:\n         n1.unite(n2)\n\nG = {}\nfor door, is_open in enumerate(r):\n    if is_open:\n        continue\n\n    n1, n2 = door_dsus[door]\n    if n1.get_root() is n2.get_root():\n        print("NO")\n        return\n\n    G.setdefault(n1.get_root(), set()).add(n2.get_root())\n    G.setdefault(n2.get_root(), set()).add(n1.get_root())\n\ncolor = {}\n\nfor v in list(G.keys()):\n    if v in color:\n        continue\n\n    color[v] = False\n    q = collections.deque([v])\n    while q:\n        v = q.popleft()\n        c = color[v]\n        for adj_v in G[v]:\n            if adj_v in color:\n                if color[adj_v] != (not c):\n                    print("NO")\n                    return\n            else:\n                color[adj_v] = not c\n                q.append(adj_v)\n\nprint("YES")\n
s = input()\nlast = s.rfind('#')\ndif = s.count('(')-s.count(')')-s.count('#')\ntry:\n    assert dif >= 0\n    lev = 0\n    out = []\n    for i in range(len(s)):\n        c = s[i]\n        if c == '(': lev += 1\n        elif c == ')':\n            lev -= 1\n            assert lev >= 0\n        elif c == '#':\n            lev -= 1\n            if i == last:\n                out.append(dif+1)\n                lev -= dif\n            else:\n                out.append(1)\n            assert lev >= 0\n    assert lev == 0\n    for x in out: print(x)\nexcept AssertionError:\n    print(-1)\n    \n
a,b=[int(i) for i in input().split()]\nif(a==0):\n    print(-b**2)\n    print('x'*b)\nelif(b==0):\n    print(a**2)\n    print('o'*a)\nelif(b==1):\n    print(a**2-1)\n    print('x'+'o'*a)\nelse:\n    ans=-float('inf')\n    gr_no=None\n    for i in range(2,min(a+2,b+1)):\n        v1=(a+2-i)**2 + i-2\n        quo=b//i\n        rem=b%i\n        v2=rem*((quo+1)**2) + (i-rem)*((quo**2))\n        if(v1-v2>ans):\n            gr_no=i\n            ans=v1-v2\n    quo=b//gr_no\n    rem=b%gr_no\n    if(rem>0):\n        s='x'*(quo+1)+'o'*(a+2-gr_no)\n        rem-=1\n    else:\n        s='x'*(quo)+'o'*(a+2-gr_no)\n    gr_no-=1\n    s1='x'*(quo+1)+'o'\n    s2='x'*quo + 'o'\n    for i in range(rem):\n        s+=s1\n    for i in range(gr_no-rem-1):\n        s+=s2\n    s+='x'*(quo)\n    print(ans)\n    print(s)\n\n\n
import sys\ninput = sys.stdin.readline\n\nimport numpy as np\n\nMOD = 10**9 + 7\n\nN,M,K = map(int,input().split())\n\ndef cumprod(arr):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\nU = 10**6\nx = np.full(U,2,dtype=np.int64); x[0] = 1\npow2 = cumprod(x)\nx = np.full(U,3,dtype=np.int64); x[0] = 1\npow3 = cumprod(x)\nx = np.full(U,pow(2,MOD-2,MOD),dtype=np.int64); x[0] = 1\npow2_inv = cumprod(x)\nx = np.full(U,pow(3,MOD-2,MOD),dtype=np.int64); x[0] = 1\npow3_inv = cumprod(x)\nx = np.arange(U,dtype=np.int64); x[0] = 1\nfact = cumprod(x)\nx = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\nfact_inv = cumprod(x)[::-1]\n\nL = N+M\nA = np.zeros(N+M,dtype=np.int64)\nA[1:L] = (-1) * pow2[0:L-1] * pow3_inv[0:L-1] % MOD\nA[1:L] *= fact[K+1:K+L] * fact_inv[K] % MOD * fact_inv[1:L] % MOD; A %= MOD\nA[1:L] *= pow3_inv[K+1]; A %= MOD\nA[0] = 3 * (1 - pow3_inv[K+1]) % MOD * pow2_inv[1] % MOD\nnp.cumsum(A,out=A); A %= MOD\nA *= pow3[:L]; A %= MOD\nA *= pow2_inv[:L]; A %= MOD\n\ncomb = fact[N-1:N+M] * fact_inv[:M+1] % MOD * fact_inv[N-1] % MOD\nanswer = (comb * pow3[K+M:K-1:-1] % MOD * A[N-1:N+M] % MOD).sum() % MOD\nprint(answer)
import heapq\nimport sys\nfrom collections import defaultdict, Counter\nfrom functools import reduce\n\n\nn, m = list(map(int, input().split()))\narr = []\nfor _ in range(n):\n    arr.append(list(map(int, input().split())))\n\nrows = []\nfor i in range(n):\n    row = set()\n    for j in range(m):\n        row.add(arr[i][j])\n    rows.append({x: i for i, x in enumerate(sorted(row))})\n\ncolumns = []\n\nfor j in range(m):\n    column = set()\n    for i in range(n):\n        column.add(arr[i][j])\n    columns.append({x: i for i, x in enumerate(sorted(column))})\n\n\ndef get_answer(i, j):\n    el = arr[i][j]\n    index1 = rows[i][el]\n    index2 = columns[j][el]\n    return max(index1, index2) + max(len(rows[i]) - index1,  len(columns[j]) - index2)\n\n\nfor i in range(n):\n    answer = []\n    for j in range(m):\n        answer.append(str(get_answer(i, j)))\n    print(' '.join(answer))\n
P = 998244353\nN, M = list(map(int, input().split()))\nA = [int(a) for a in input().split()]\nB = [int(a) for a in input().split()]\nli = sum([A[i]*B[i] for i in range(N)])\ndi = sum([(A[i]^1)*B[i] for i in range(N)])\nX = [1]\nSU = li+di\nPO = [0] * (5*M+10)\nfor i in range(-M-5, 2*M+5):\n    PO[i] = pow((SU+i)%P, P-2, P)\n\ndef calc(L):\n    su = sum(L)\n    pl = 0\n    pd = 0\n    RE = []\n    for i in range(len(L)):\n        a = li + i\n        b = di - (len(L) - 1 - i)\n        pd = b * L[i] * PO[a+b-SU]\n        RE.append((pl+pd)%P)\n        pl = a * L[i] * PO[a+b-SU]\n    RE.append(pl%P)\n    return RE\n\nfor i in range(M):\n    X = calc(X)\nne = 0\npo = 0\nfor i in range(M+1):\n    po = (po + X[i] * (li + i)) % P\n    ne = (ne + X[i] * (di - M + i)) % P\ninvli = pow(li, P-2, P)\ninvdi = pow(di, P-2, P)\nfor i in range(N):\n    print(po * B[i] * invli % P if A[i] else ne * B[i] * invdi % P)\n
n = input()\n\ns = []\n\na = 0\n\nfor i in map(int, input().split()):\n\n    while len(s) > 1 and min(s[-2], i)>=s[-1]:\n\n        a += min(i, s[-2])\n\n        del(s[-1])\n\n    s.append(i)\n\ns.sort()\n\nprint(a + sum(s[0: -2]))\n\n\n\n# Made By Mostafa_Khaled\n
from collections import defaultdict\n\nn, k = list(map(int, input().split()))\n\nconnections = defaultdict(set)\n\nfor _ in range(n-1):\n	u, v = list(map(int, input().split()))\n	connections[u].add(v)\n	connections[v].add(u)\n\nleafs = set()\nfor node in connections:\n	if len(connections[node])==1:\n		leafs.add(node)\n\nsteps = 0\nis_correct = True\nwhile is_correct and steps<=k:\n	new_leafs = set()\n	for x in leafs:\n		if len(connections[x])>1:\n			is_correct = False\n			#print("Len of %d more than one"%x)\n			break\n		root = list(connections[x])[0]\n		if len(connections[root])<4 and len(leafs)!=3:\n			is_correct = False\n			#print("x: %d Len of root %d less than three"%(x,root))\n			#print(connections[root])\n			break\n	if not is_correct:\n		break\n	for x in leafs:\n		root = list(connections[x])[0]\n		new_leafs.add(root)\n		connections[root].remove(x)\n	leafs = new_leafs\n	steps += 1\n	if len(leafs)==1 and len(connections[list(leafs)[0]])==0:\n		break\n\n#print("steps is %d"%steps)\nif is_correct and steps==k:\n	print("Yes")\nelse:\n	print('No')\n
import sys\nreadline = sys.stdin.readline\n\nH, W = map(int, readline().split())\nG = [[1 if s == '#' else 0 for s in readline().strip()] for _ in range(H)]\n\nDIREC = [(0, 1), (1, 0), (-1, 0), (0, -1)]\ndef calc():\n    zh = 0      \n    for i in range(H):\n        cnt = 0\n        for j in range(W):\n            if G[i][j]:\n                if cnt == 0:\n                    cnt = 1\n                    continue\n                if cnt == 1:\n                    continue\n                if cnt == 2:\n                    return -1\n            else:\n                if cnt == 0:\n                    continue\n                cnt = 2\n        if cnt == 0:\n            zh = 1\n    zw = 0\n    for j in range(W):\n        cnt = 0\n        for i in range(H):\n            if G[i][j]:\n                if cnt == 0:\n                    cnt = 1\n                    continue\n                if cnt == 1:\n                    continue\n                if cnt == 2:\n                    return -1\n            else:\n                if cnt == 0:\n                    continue\n                cnt = 2\n        if cnt == 0:\n            zw = 1\n    if zw^zh:\n        return -1\n    ans = 0\n    used = set()\n    geta = W\n    for i in range(H):\n        for j in range(W):\n            if G[i][j] == 0:\n                continue\n            if (i*geta + j) in used:\n                continue\n            ans += 1\n            stack = [i*geta + j]\n            while stack:\n                nh, nw = divmod(stack.pop(), geta)\n                for dh, dw in DIREC:\n                    fh, fw = nh+dh, nw+dw\n                    if not 0 <= fh < H or not 0 <= fw < W:\n                        continue\n                    if not G[fh][fw]:\n                        continue\n                    vf = fh*geta + fw\n                    if vf in used:\n                        continue\n                    stack.append(vf)\n                    used.add(vf)\n    return ans\nprint(calc())
import sys\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncur_max = 0\nlast_max = 1\nlast = dict()\nzeros = []\n\nfor i in range(len(a))[::-1]:\n    if a[i] == 0:\n        zeros.append(i)\n    elif a[i] not in last:\n        last[a[i]] = i\n\nstack = []\n\nfor i in range(len(a)):\n    if a[i] == 0:\n        a[i] = max(cur_max, 1)\n    elif a[i] > cur_max and last[a[i]] != i:\n        stack.append(cur_max)\n        cur_max = a[i]\n    elif cur_max != 0 and i == last[cur_max]:\n        cur_max = stack.pop()\n    elif a[i] < cur_max:\n        print("NO")\n        return\n\nif k > max(a):\n    if zeros:\n        print("YES")\n        a[zeros[0]] = k\n        print(*a)\n    else:\n        print("NO")\nelif k == max(a):\n    print("YES")\n    print(*a)\nelif k < max(a):\n    print("NO")
from fractions import gcd\nfrom random import randint, shuffle\nfrom collections import Counter\n\n\ndef read_numbers():\n    return list(map(int, input().split()))\n\n\ndef get_original_array(n, numbers):\n    cnt = Counter(numbers)\n\n    array = []\n    for new_number in sorted(numbers, reverse=True):\n        if cnt[new_number]:\n            cnt[new_number] -= 1\n            for number in array:\n                table_entry = gcd(new_number, number)\n                cnt[table_entry] -= 2\n            array.append(new_number)\n    assert cnt.most_common()[0][1] == 0\n    return array\n\n\ndef test(n):\n    print(n)\n    array = [randint(0, 10**9) for _ in range(n)]\n    table = [gcd(a, b) for a in array for b in array]\n    shuffle(table)\n    print(sorted(array) == sorted(get_original_array(n, table)))\n\ndef __starting_point():\n#    n = 4\n#    numbers = [2, 1, 2, 3, 4, 3, 2, 6, 1, 1, 2, 2, 1, 2, 3, 2]\n#    print(get_original_array(n, numbers))\n#    test(10)\n#    test(100)\n#    test(200)\n#    test(300)\n#    test(400)\n#    test(500)\n#else:\n    n = int(input())\n    numbers = read_numbers()\n    print(' '.join(map(str, get_original_array(n, numbers))))\n\n__starting_point()
import sys\nimport copy\ninput = sys.stdin.readline\n\nn=int(input())\nP=[list(map(int,input().split())) for i in range(n)]\n\nSET_X=set()\nSET_Y=set()\n\nfor x,y in P:\n    SET_X.add(x)\n    SET_Y.add(y)\n\nCX=sorted(SET_X)\nCY=sorted(SET_Y)\n\nLEN=len(CX)\nMAX=len(CX)-1\n\nDICT_X={x:i for i,x in enumerate(CX)}\nDICT_Y={x:i for i,x in enumerate(CY)}\n\nfor i in range(n):\n    P[i]=[DICT_X[P[i][0]],DICT_Y[P[i][1]]]\n\ncheck=[0]*len(CX)\n\n# BIT(BIT-indexed tree)\n\nBIT=[0]*(LEN+1)# 1-indexedなtree\n\ndef update(v,w):# vにwを加える\n    while v<=LEN:\n        BIT[v]+=w\n        v+=(v&(-v))# 自分を含む大きなノードへ. たとえばv=3→v=4\n\ndef getvalue(v):# [1,v]の区間の和を求める\n    ANS=0\n    while v!=0:\n        ANS+=BIT[v]\n        v-=(v&(-v))# 自分より小さい2ベキのノードへ. たとえばv=3→v=2へ\n    return ANS\n\n\nLIST_Y=[[] for i in range(len(CY))]\nfor x,y in P:\n    LIST_Y[y].append(x)\n\nfor i in range(len(CY)):\n    LIST_Y[i].sort()\n\nANS=0\nfor y in range(len(CY)-1,-1,-1):\n    for x in LIST_Y[y]:\n        #print(x,check)\n        if check[x]==0:\n            check[x]=1\n            update(x+1,1)\n\n    ANS+=getvalue(LIST_Y[y][0]+1)*(getvalue(MAX+1)-getvalue(LIST_Y[y][0]+1)+1)\n\n    for i in range(1,len(LIST_Y[y])):\n        #print(getvalue(LIST_Y[y][i]+1)-getvalue(LIST_Y[y][i-1]+1)),getvalue(MAX+1)\n        ANS+=(getvalue(LIST_Y[y][i]+1)-getvalue(LIST_Y[y][i-1]+1))*(getvalue(MAX+1)-getvalue(LIST_Y[y][i]+1)+1)\n\n    #print(ANS)\n\nprint(ANS)\n\n        \n        \n        \n
n = int(input())\nd = []\nfor i in range(n):\n    d.append(input())\n\nfor i in range(n):\n    if d[i].count('E') == n:\n        break\nelse:\n    for i in range(n):\n        print(i+1, d[i].index('.')+1)\n    return\n\nfor i in range(n):\n    res = 0\n    for j in range(n):\n        if d[j][i] == 'E':\n            res += 1\n    if res == n:\n        break\nelse:\n    for i in range(n):\n        for j in range(n):\n            if d[j][i] == '.':\n                print(j+1, i+1)\n                break\n    return\nprint(-1)
def solve(a,l,r,k):\n    out = sorted(a[:l]+a[r:],reverse=True)\n    inside = sorted(a[l:r])\n    cur = sum(a[l:r])\n    for i in range(min(k,len(inside),len(out))):\n        if out[i] > inside[i]:\n            cur += out[i]-inside[i]\n        else:\n            break\n    return cur\n\nn,k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\nassert len(a) == n\n\nbest = a[0]\nfor l in range(n):\n    for r in range(l+1,n+1):\n        cur = solve(a,l,r,k)\n        if cur > best:\n            best = cur\n\nprint(best)\n
class Ortree():\n    def __init__(self, n, As):\n        size = 1\n        while n > size:\n            size *= 2\n        self.size = size\n        data = [0] * size + As[:] + [0] * (size - n)\n        for idx in range(self.size - 1, 0, -1):\n            idx2 = idx << 1\n            data[idx] = data[idx2] | data[idx2 + 1]\n        self.data = data\n    \n    def update(self, idx, val):\n        pos = idx + self.size\n        self.data[pos] = val\n        pos >>= 1\n        while pos:\n            pos2 = pos << 1\n            self.data[pos] = self.data[pos2] | self.data[pos2 + 1]\n            pos >>= 1\n        return self.data[1]\n\n\ndef solve(n, k, x, As):\n    As.sort(reverse= True)\n    xk = x**k\n    if n == 1:\n        As[0] *= xk\n        return As[0]\n    if is_simplecase(xk, As):\n        As[0] *= xk\n        return cumor(As)\n    return complexcase(n, xk, As)\n    \n\ndef cumor(As):\n    result = 0\n    for a in As:\n        result |= a\n    return result\n\ndef is_simplecase(xk, As):\n    len0 = len(bin(As[0] * xk))\n    len1 = len(bin(As[1] * xk))\n    return len0 > len1\n\ndef complexcase(n, xk, As):\n    len0 = len(bin(As[0] * xk))\n    for i, a in enumerate(As[1:], 1):\n        if len(bin(a * xk)) < len0:\n            end = i\n            rest = cumor(As[end:])\n            break\n    else:\n        end = n\n        rest = 0\n    ortree = Ortree(end, As[:end])\n    record = rest\n    for i in range(end):\n        score = ortree.update(i, As[i] * xk) | rest\n        if record < score:\n            record = score\n        ortree.update(i, As[i])\n    return record\n\nn, k, x = map(int, input().split())\nAs = list(map(int, input().split()))\nprint(solve(n, k, x, As))
from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,datetime\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 998244353\neps = 10**-7\ndef inp(): return int(input())\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\n\nK,N = inpl()\nMAX = K+N+10\nfac = [1]*(MAX+1)\nfor i in range(1,MAX+1):\n	fac[i] = (fac[i-1]*i)%mod\n\ngyakugen = [1]*(MAX+1)\ngyakugen[MAX] = pow(fac[MAX],mod-2,mod)\nfor i in range(MAX,0,-1):\n	gyakugen[i-1] = (gyakugen[i]*i)%mod\n\ndef Comb(n,k):#nCk\n	return (fac[n]*gyakugen[k]*gyakugen[n-k])%mod\n\n#K=k,N=n,0pair = 0\ndef calc(k,n,i):\n	#i=2に帰着させる\n	pairs = (i-2)//2\n	k -= pairs\n	n -= pairs\n\n	#色々と例外処理\n	if n < 0 or k <= 0:\n		return 0\n	elif k == 1 and n >= 2:\n		return 0\n\n	if n == 0: 	 #球が0個なら1通り\n		ans = 1\n	else:\n		ans = 0\n		#i=2の時の数え上げ\n		for x in range(2):\n			ball = n-x	#球\n			box = k-1	#箱\n			ans += Comb(box-1+ball,ball)%mod\n\n	ans *= pow(2,pairs,mod)	#0pairの選び方\n	return ans % mod\n\nans = []\nfor i in range(2,K+2):\n	if i%2 == 0:\n		pairs = (i-2)//2\n		tmp = 0\n		for p0 in range(pairs+1): #p0 = 0pairの数\n			tmp1 = calc(K-p0*2 , N , i-p0*2) %mod #k-p0*2,i-p0*2で0pairが0組\n			tmp2 = Comb(pairs,p0) %mod #0pairの選び方\n			tmp += tmp1 * tmp2\n			tmp %= mod\n	ans.append(tmp)\n	print(tmp)\n\nans = ans[::-1]\nfor i in range(1,K):\n	print((ans[i]))\n
def bfs(source):\n    q = [0] * (n + 1);\n    fa = [-1] * n\n    l, r = [1] * 2\n    fa[source] = source\n    q[1] = source\n    while l <= r:\n        x = q[l]\n        l += 1\n        for y in e[x]:\n            if  fa[y] == -1:\n                fa[y] = x\n                r += 1\n                q[r] = y\n    i = r;\n    while i >= 1:\n        x = q[i]\n        for y in e[x]:\n            if fa[y] == x:\n                sum[x] += sum[y]\n                dp[x] += dp[y] + min(sum[y], m - sum[y])\n        i -= 1\n\nn, m =[int(x) for x in input().split()]\nm <<= 1\nt = [int(x) for x in input().split()]\ne = [list() for i in range(n)]\nsum = [0] * n\ndp = [0] * n\n#print(len(e), e)\nfor i in range(n - 1):\n    x, y = [int(a) for a in input().split()]\n    e[x - 1].append(y - 1)\n    e[y - 1].append(x - 1)\nfor x in t:\n    sum[x - 1] = 1\nbfs(0)\nprint(dp[0])
s = input() \nzero = set() # 前面的一个以0结尾的串的索引\none  = set() # 前面的一个以1结尾的串的索引\nans  = []    # 结果的串\nfor i in range(0,len(s)):\n    if(s[i] == '0'):\n        if one:\n            k = one.pop()\n            zero.add(k)\n            ans[k].append(i+1)\n        else:\n            zero.add(len(ans))\n            ans.append([i+1])\n    else:\n        if not zero:\n            print(-1)\n            return\n        k = zero.pop()\n        one.add(k)\n        ans[k].append(i+1)\nif(one):\n    print(-1)\n    return\nprint(len(ans))\nprint('\n'.join([str(len(x))+' '+' '.join(map(str,x)) for x in ans]))\n
import sys\nfrom collections import defaultdict, Counter\n\nP = 10 ** 9 + 7\n\ndef factmod(n):\n    res = 1\n    for i in range(2, n+1):\n        res *= i\n        res %= P\n\n    return res\n\ndef solve():\n    n, m = list(map(int, input().split()))\n    colour = {i:0 for i in range(1, m+1)}\n    colour_map = {}\n    for i, line in enumerate(sys.stdin):\n        A = [int(x) for x in line.split()]\n        count = Counter(A)\n\n        if count[A[0]] == 1:\n            count.pop(A[0])\n        else:\n            count[A[0]] -= 1\n\n        for c in count:\n            p = (colour[c], i, count[c])\n            if p in colour_map:\n                colour[c] = colour_map[p]\n            else:\n                colour[c] = colour_map[p] = len(colour_map) + 1\n\n    count = Counter(list(colour.values()))\n\n    res = 1\n    for c in count:\n        res *= factmod(count[c])\n        res %= P\n\n    return res\n\nprint(solve())\n
n = int(input())\nl = tuple(map(int, input().split()))\n\na = []\nfor i in range(n - 1):\n    a.append(abs(l[i] - l[i + 1]))\n\nev = [(a[i] if i % 2 == 0 else -a[i]) for i in range(n - 1)]\nod = [-i for i in ev]\nod[0] = 0\n\ndp = [ev[0]]\nst = ["ev"]\n\n# print(a)\n# print(ev)\n# print(od)\n\nvmax = dp[0]\n\nevsum = evans = 0\nodsum = odans = 0\n\nfor i in range(0, n - 1):\n    evsum += ev[i]\n    odsum += od[i]\n    evans = max(evsum, evans)\n    odans = max(odsum, odans)\n    if evsum < 0 and i % 2 == 1:\n        evsum = 0\n    if odsum < 0 and i % 2 == 0:\n        odsum = 0\n\n# print(evans, odans)\n\nprint(max(evans, odans))\n
n,a= int(input()),list(map(int,input().split()))\nf,m= [0]*(n+1),10**9+7\nfor i in range(n):\n	if a[i]==i+1:\n		f[i+1]=f[i]+2\n	else:\n		f[i+1]=(2+f[i]*2-f[a[i]-1])%m\nprint(f[n]%m)\n
import sys\ninput = sys.stdin.readline\n\nn=int(input())\nlr=[list(map(int,input().split())) for i in range(n)]\n\nL=[lr[i][0] for i in range(n)]\nR=[lr[i][1] for i in range(n)]\nL.sort()\nR.sort()\n\nANS=0\n\nfor i in range(n):\n    ANS+=max(L[i],R[i])\n\nprint(ANS+n)\n
p = 1000000007\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nm = int(input())\n\nd = [1] * 300001\ntd = [0] * 300001\nL = b[0]\nfor i in range(1, n):\n	if a[i - 1] != 1:\n		t = m % a[i - 1]\n		if L < t:\n			print(0)\n			return\n		m //= a[i - 1]\n		for j in range((L - t) // a[i - 1] + 1):\n			d[j] = d[t]\n			t += a[i - 1]\n		L = j\n	k = 0\n	for j in range(L + b[i] + 1):\n		if j <= L:\n			k += d[j]\n		k %= p\n		td[j] = k\n		if j >= b[i]:\n			k -= d[j - b[i]]\n	L += b[i]\n	for j in range(L + 1):\n		d[j] = td[j]\nprint(d[m] if m <= L else 0)
def main():\n    n, m, b, mod = list(map(int, input().split()))\n    row_zero = [1] + [0] * b\n    b += 1\n    dp = [[0] * b for _ in range(m)]\n    for a in list(map(int, input().split())):\n        cur = row_zero\n        for nxt in dp:\n            for i, u in zip(list(range(a, b)), cur):\n                nxt[i] = (nxt[i] + u) % mod\n            cur = nxt\n    print(sum(dp[-1]) % mod)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
#!/usr/bin/env python3\n\n\ndef main():\n    n = int(input())\n    ps = [int(x) for x in input().split()]\n    v = set('aeiouy')\n    for p in ps:\n        s = input()\n        ss = sum(1 for x in s if x in v)\n        if ss != p:\n            print('NO')\n            return\n    print('YES')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n = int(input())\na = sorted(list(map(int, input().split())))\n\nans = 0\nif n == 1:\n    ans = a[0]\nelse:\n    mult = 2\n    for i in range(n - 1):\n        ans += mult * a[i]\n        mult += 1\n    ans += (mult - 1) * a[-1]\nprint(ans)\n\n
import itertools\n\nunfold = itertools.chain.from_iterable\n\nspeedup = 400000\n\ndef jumps(a):\n    d = speedup\n    while d < a - 1:\n        c = (a + d - 1) // d\n        d = (a + c - 2) // (c - 1)\n        yield d\n\n\ndef calc(d):\n    return sum(d - 1 - (i - 1) % d for i in a)\n\ndef ans():\n    for d, pd in zip(D, D[1:]):\n        d -= 1\n        cd = calc(d)\n        if cd <= k:\n            return d\n        if d == pd:\n            continue\n        cpd = calc(pd)\n        if d - pd >= (cd - k) * (d - pd) / (cd - cpd):\n            return d - (cd - k) * (d - pd) / (cd - cpd)\n    return 1\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nspeedup = min(speedup, 2 * int(max(a) ** 0.5))\n\nD = sorted(set(range(1, speedup + 1)).union([max(a) + k + 1]).union(set(\n    unfold(map(jumps, a)))), reverse=True)\n    \nprint('%d' % ans())
n=int(input())\na=input().split()\nones=a.count("1")\ntwos=n-ones\nif ones==0 or twos==0:\n    print(" ".join(a))\nelse:\n    print("2 1"+" 2"*(twos-1)+" 1"*(ones-1))
n, m = map(int, input().split())\nt = [int(input().split()[0]) for i in range(n)]\np = [0] * (m + 1)\nfor i, j in enumerate(t): p[j] = min(p[j], min(p[: j])) - 1\nprint(n + min(p))
n, k = map(int, input().split())\nt = list(map(int, input().split()))\nif k == 1: print(len(set(t)))\nelse:\n    p = [set() for i in range(30)]\n    for i in t:\n        j = 0\n        while i % k == 0:\n            i //= k\n            j += 1\n        p[j].add(i)\n    for j in range(1, 30):\n        p[j] -= p[j - 1]\n    print(sum(len(i) for i in p))
"""\nCodeforces Contest 260 Div 1 Problem A\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\ndef main():\n    n, = read()\n    ar = read()\n    a = [0] * 100001\n    for i in ar: a[i] += 1\n\n    dp = [0] * 100001\n    dp[1] = a[1]\n    for i in range(2, 100001):\n        dp[i] = max(a[i] * i + dp[i-2], dp[i-1])\n    print(dp[-1])\n\n################################### NON-SOLUTION STUFF BELOW\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return map(int, inputs.split())\n\ndef write(s="\n"):\n    if isinstance(s, list): s = " ".join(map(str, s))\n    s = str(s)\n    print(s, end="")\n\nmain()
# dp[i] := i 項目以降を見たときの場合の数\n#       = dp[i+1] + (Σ_{3<=d<=N-1} dp[i+d]) + (n-1)**2\n\n# i 項目と i+1 項目について、\n#   (1) i 項目が 1 の場合\n#   (2) i 項目が 1 で無く、i+1 項目が 1 の場合\n#   (3) i 項目も i+1 項目も 1 で無い場合\n# で場合分けしてそれぞれを足している\n# これを累積和で高速化する\n\n# 初期化がややこしい\n\nN = int(input())\nmod = 10**9+7\ndp = [N] * (N+1)\ndp[N-1] = N\ndp[N-2] = N*N\nc = N * (N+1) + N-1\nconst = (N-1)**2\nfor i in range(N-3, -1, -1):\n    ans = c - dp[i+2] + const\n    dp[i] = ans\n    c = (c + ans - 1) % mod\nprint((dp[0]%mod))\n
n,m=map(int,input().split())\nA=[int(i)-1 for i in input().split()]\nds=[0]*m\nde=[[] for i in range(m)]\nh,dec=0,0\nfor i in range(n-1):\n  if A[i+1]-A[i]>0:\n    h+=A[i+1]-A[i]\n  else:\n    h+=A[i+1]+1\n    dec+=1\n  de[A[i+1]].append((i,(A[i+1]-A[i])%m))\nfor i in range(m):\n  for a in de[i]:\n    ds[(i-a[1]+1)%m]+=1\nans=float("inf")\nfor i in range(m):\n  for a in de[i]:\n    h+=a[1]-1\n    dec-=1\n  h-=dec\n  ans=min(h,ans)\n  if i<=m-2:\n    dec+=ds[i+1]\n  \nprint(ans)
m,p,c=0,0,0\ns=(input())\nfor i in  s:\n    if i=='-':\n        c-=1\n    else:\n        c+=1    \n    m=min(m,c)\n    p=max(p,c)\nprint(p-m)\n
import sys\nn=int(input())\nf={\n 'AND':(lambda a:a[0]&a[1]),\n 'OR':(lambda a:a[0]|a[1]),\n 'XOR':(lambda a:a[0]^a[1]),\n 'NOT':(lambda a:a[0]^1),\n}\ng={'0':(lambda a:0), '1':(lambda a:1)}\nd=[(g[v[0]],[]) if o=='IN' else (f[o],[int(a)-1 for a in v]) for o,*v in map(str.split,sys.stdin.read().strip().split('\n'))]\nt=[0]\nfor i in t:\n t.extend(d[i][1])\nv=[0 for _ in range(n)]\nfor i in t[::-1]:\n o,a=d[i]\n v[i]=o([v[x] for x in a])\nf=[0 for _ in range(n)]\nf[0]=1\nfor i in t:\n if f[i]<1: continue\n o,a=d[i]\n b=[v[x]for x in a]\n assert o(b)==v[i]\n for j,k in enumerate(a):\n  b[j]^=1\n  f[k]=(o(b)!=v[i])\n  b[j]^=1\nprint(''.join(str(f[i]^v[0]) for i in range(n) if not d[i][1]))
from collections import defaultdict\n\nn, m, p = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nu = defaultdict(int)\nfor i in b: u[i] += 1\n\nans = []\nfor q in range(p):\n    c = a[q: n: p]\n    if len(c) < m: break\n\n    v = defaultdict(int)\n    for i in c[: m]: v[i] += 1\n\n    d = q + 1\n    if u == v: ans.append(d)\n\n    for j, k in zip(c[: len(c) - m], c[m: ]):\n        v[j] -= 1\n        if v[j] == 0: v.pop(j)\n        v[k] += 1\n\n        d += p\n        if u == v: ans.append(d)\n\nans.sort()\nprint(len(ans))\nprint(' '.join(map(str, ans)))
def cin():\n    return list(map(int, input().split()))\n\ndef dfs(n):\n    if not C[n]:\n        C[n]=True\n        s[0]+=1\n    for i in B[n]:\n        if not C[i]:dfs(i)\n\nn,m,k=cin()\nA=cin()\nA=[i-1 for i in A]\nB=[list([]) for i in range(n)]\nC=[False for i in range(n)]\nans=mx=0\nfor i in range(m):\n    a,b=[i-1 for i in cin()]\n    B[a].append(b)\n    B[b].append(a)\n\nfor i in range(k):\n    s=[0]\n    dfs(A[i])\n    ans+=s[0]*(s[0]-1)//2\n    mx=max(mx,s[0])\n\nans-=mx*(mx-1)//2\nfor i in range(n):\n    if not C[i]:\n        s=[0]\n        dfs(i)\n        mx+=s[0]\n\nprint(ans-m+mx*(mx-1)//2)\n
n = int(input())\nA = list(map(int, input().split()))\nA.sort()\nB = [0] * n\nans = 0\nfor i in range(n):\n    if B[i] == 0:\n        ans += 1\n        B[i] = 1\n        for j in range(n):\n            if A[j] % A[i] == 0:\n                B[j] = 1\nprint(ans)
from collections import defaultdict, deque\n\ndef main():\n    n,m = map(int, input().split())\n    cap = [None]*(m+1)\n    same_cap = defaultdict(list)\n    q = deque()\n\n    def apply_cap(a, c):\n        if cap[a] is not None:\n            return cap[a] == c\n        q.append((a,c))\n        while q:\n            b = q.pop()\n            if b[1] == c:\n                if cap[b[0]] is None:\n                    cap[b[0]] = c\n                    q.extend(same_cap[b[0]])\n                    same_cap[b[0]] = []\n                elif cap[b[0]]!=c:\n                    return False\n\n        return True\n\n    def same(a,b):\n        same_cap[b].append((a,True))\n        same_cap[a].append((b,False))\n\n        if cap[a] == False:\n            return apply_cap(b, False)\n\n        if cap[b] == True:\n            return apply_cap(a, True)\n\n        return True\n\n    def process(p,c):\n        lp = p[0]\n        lc = c[0]\n        for i in range(1, min(lp,lc)+1):\n            if p[i]>c[i]:\n                return apply_cap(p[i], True) and apply_cap(c[i], False)\n            if p[i]<c[i]:\n                return same(p[i], c[i])\n        return lp<=lc\n\n    p = list(map(int, input().split()))\n    for i in range(n-1):\n        c = list(map(int, input().split()))\n        if not process(p, c):\n            print ('No')\n            break\n        p = c\n    else:\n        print ('Yes')\n        res = []\n        for i,b in enumerate(cap):\n            if b:\n                res.append(i)\n        print(len(res))\n        print(' '.join(map(str,res)))\n\nmain()
n = int(input())\np = [i for i in range(n + 1)]\n\nk = 1\nwhile(2 * k <= n):\n  k *= 2\nm = n + 1\nwhile m > 0:\n  while k >= m:\n    k //= 2\n  for i in range(m - k):\n    if k - i - 1 >= 0:\n      p[k + i], p[k - i - 1] = p[k - i - 1], p[k + i]\n  m = k - i - 1\n\nprint(n * (n + 1))\nprint(' '.join(map(str, p)))
import sys\n\n\n# > 0 anti-clock, < 0 clockwise, == 0 same line\ndef orientation(p1, p2, p3):\n    return (p2[0] - p1[0])*(p3[1] - p1[1]) - (p2[1] - p1[1])*(p3[0] - p1[0])\n\n\ndef dot(p1, p2, p3, p4):\n    return (p2[0]-p1[0])*(p4[0]-p3[0]) + (p2[1]-p1[1])*(p4[1]-p3[1])\n\n\ndef theta(p1, p2):\n    dx = p2[0] - p1[0]\n    dy = p2[1] - p1[1]\n    if abs(dx) < 0.1 and abs(dy) < 0.1:\n        t = 0\n    else:\n        t = dy/(abs(dx) + abs(dy))\n        if abs(t) < 0.1 ** 10:\n            t = 0\n    if dx < 0:\n        t = 2 - t\n    elif dy < 0:\n        t = 4 + t\n\n    return t*90\n\n\ndef dist_sq(p1, p2):\n    return (p1[0] - p2[0])*(p1[0] - p2[0]) + (p1[1] - p2[1])*(p1[1] - p2[1])\n\n\ndef chull(points):\n    # let 0 element to be smallest, reorder elements\n    pi = [x for x in range(len(points))]\n    min_y = points[0][1]\n    min_x = points[0][0]\n    min_ind = 0\n    for i in range(len(points)):\n        if points[i][1] < min_y or points[i][1] == min_y and points[i][0] < min_x:\n            min_y = points[i][1]\n            min_x = points[i][0]\n            min_ind = i\n    pi[0] = min_ind\n    pi[min_ind] = 0\n    th = [theta(points[pi[0]], points[x]) for x in range(len(points))]\n    pi.sort(key=lambda x: th[x])\n    # process equals\n    unique = [pi[0], pi[1]]\n    for i in range(2, len(pi)):\n        if th[pi[i]] != th[unique[-1]]:\n            unique.append(pi[i])\n        else:\n            if dist_sq(points[pi[0]], points[unique[-1]]) < dist_sq(points[pi[0]], points[pi[i]]):\n                unique[-1] = pi[i] # put max\n    pi = unique\n    stack = []\n    for i in range(min(len(pi), 3)):\n        stack.append(points[pi[i]])\n    if len(stack) < 3:\n        return stack\n    for i in range(3, len(pi)):\n        while len(stack) >= 2:\n            o = orientation(stack[-2], stack[-1], points[pi[i]])\n            if o > 0:\n                stack.append(points[pi[i]])\n                break\n            elif o < 0:\n                stack.pop()\n            else:  # ==\n                if dist_sq(stack[-2], stack[-1]) < dist_sq(stack[-2], points[pi[i]]):\n                    stack.pop()\n                else:\n                    break  # skip i-th point\n    return stack\n\n\ndef z_func(s):\n    slen, l, r = len(s), 0, 0\n    z = [0]*slen\n    z[0] = slen\n    for i in range(1, slen):\n        if i <= r: z[i] = min(r-i+1, z[i-l])\n        while i+z[i] < slen and s[z[i]] == s[i+z[i]]: z[i] += 1\n        if i+z[i]-1 > r: l, r = i, i+z[i]-1\n    return z\n\nn,m = map(int, sys.stdin.readline().strip().split())\na = []\nfor _ in range(n):\n    x,y = map(int, sys.stdin.readline().strip().split())\n    a.append((x, y))\nb = []\nfor _ in range(m):\n    x, y = map(int, sys.stdin.readline().strip().split())\n    b.append((x, y))\n\nah = chull(a)\nbh = chull(b)\nif len(ah) == len(bh):\n    if len(ah) == 2:\n        if dist_sq(ah[0], ah[1]) == dist_sq(bh[0], bh[1]):\n            print('YES')\n        else:\n            print('NO')\n    else:\n        da = []\n        for i in range(len(ah)):\n            dot_a = dot(ah[i-2], ah[i-1], ah[i-1], ah[i])\n            da.append((dist_sq(ah[i], ah[i-1]), dot_a))\n        db = []\n        for i in range(len(bh)):\n            dot_b = dot(bh[i - 2], bh[i - 1], bh[i - 1], bh[i])\n            db.append((dist_sq(bh[i], bh[i-1]), dot_b))\n        l = r = 0\n        daab = []\n        daab.extend(db)\n        daab.append(-1)\n        daab.extend(da)\n        daab.extend(da)\n        zab = z_func(daab)\n        found = False\n        for i in range(len(db)+1, len(daab)-len(db)+1):\n            if zab[i] == len(db):\n                found = True\n                break\n        if found:\n            print('YES')\n        else:\n            print('NO')\nelse:\n    print('NO')
MOD = 10 ** 9 + 7\nBAD = ([0, 0, 1, 1], [0, 1, 0, 1], [1, 1, 1, 0], [1, 1, 1, 1])\n\ndef zfunc(s):\n    z = [0] * len(s)\n    l = r = 0\n    for i in range(1, len(s)):\n        if i <= r:\n            z[i] = min(r - i + 1, z[i - l])\n        while i + z[i] < len(s) and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            l, r = i, i + z[i] - 1\n    return z\n\nn = int(input())\ns = []\nsm = 0\nfor i in range(1, n + 1):\n    s.append(int(input()))\n    cur = 0\n    f = [0] * (i + 1)\n    sum4 = f[i] = 1\n    for j in range(i - 1, -1, -1):\n        if j + 4 < i:\n            sum4 -= f[j + 5]\n        if j + 4 <= i and s[j : j + 4] in BAD:\n            f[j] -= f[j + 4]\n        f[j] = (f[j] + sum4) % MOD\n        sum4 += f[j]\n    z = zfunc(s[::-1])\n    new = i - max(z)\n    sm = (sm + sum(f[:new])) % MOD\n    print(sm)\n
class UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nimport sys\n\ninput = sys.stdin.readline\n\nfor _ in range(int(input())):\n    N,M = list(map(int,input().split()))\n    uf = UnionFindVerSize(N)\n    for _ in range(M):\n        a,b = list(map(int,input().split()))\n        uf.unite(a-1,b-1)\n\n    if N%2==1:\n        all = N*(N-1)//2-M\n        if all%2==0:\n            print("Second")\n        else:\n            print("First")\n    else:\n        all = N*(N-1)//2-M\n        s1 = uf.get_size(0)\n        sN = uf.get_size(N-1)\n        if s1%2==sN%2:\n            if s1%2==0:\n                if all%2==0:\n                    print("Second")\n                else:\n                    print("First")\n            else:\n                if all%2==1:\n                    print("Second")\n                else:\n                    print("First")\n        else:\n            print("First")\n\n#odd,even->even,even first\n#odd,even->odd,odd first\n#odd,odd->even,even second\n#odd,odd->odd,odd first\n#even,even->even,even first\n#even,even->odd,odd second\n
s = input()\nm = chr(ord('z') + 1)\nans = []\nf = 0\nfor i in s:\n    if i > m:\n        ans.append('Ann')\n    else:\n        ans.append('Mike')\n    m = min(m, i)\nprint('\n'.join(ans))
def g(i):\n    u[i] = 0\n    for j in p[i]:\n        if v[j] < 0 or u[v[j]] and g(v[j]):\n            v[j] = i\n            return 1\n    return 0\n\nf = lambda: map(int, input().split())\nn, m = f()\ns = k = 0\nd = [[]]\nfor i in f():\n    j = 2\n    t = []\n    while j * j <= i:\n        while i % j == 0:\n            t.append((j, k))\n            k += 1\n            i //= j\n        j += 1\n    if i > 1:\n        t.append((i, k))\n        k += 1\n    d.append(t)\np = [[] for i in range(k)]\nfor q in range(m):\n    a, b = f()\n    if b % 2: a, b = b, a\n    for x, i in d[a]:\n        for y, j in d[b]:\n            if x == y: p[i].append(j)\nv = [-1] * k\nfor i in range(k):\n    u = [1] * k\n    s += g(i)\nprint(s)
import string\n\nrd = lambda: list(map(int, input().split()))\n\nn, k = rd()\nif k>26 or k>n or k==1 and n>1:\n  print(-1)\nelif k==1 and n==1:\n  print('a')\nelse:\n  print(('ab'*(n+1>>1))[:n-k+2]+string.ascii_lowercase[2:k])
n = int(input())\n*A, = list(map(int, input().split()))\n\nseq = []\ncur = 1; cnt = 0\nfor a in A:\n    if cur == a:\n        cnt += 1\n    else:\n        seq.append(cnt)\n        cur = a; cnt = 1\nif cnt > 0:\n    seq.append(cnt)\nans = max(seq)\n\nl = len(seq)\ndp = [[0]*4 for i in range(l+1)]\nfor i in range(l):\n    one = i % 2 #12\n    s = seq[i]\n    for j in range(4):\n        dp[i+1][j] = max(dp[i+1][j], dp[i][j])\n        if not one: # 2\n            if j % 2 == 0:\n                dp[i+1][j] = max(dp[i+1][j], dp[i][j] + s)\n            else:\n                if j == 1:\n                    dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + s)\n        else: # 1\n            if j % 2 == 1:\n                dp[i+1][j] = max(dp[i+1][j], dp[i][j] + s)\n            else:\n                dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + s)\n#    print(dp[i+1])\nprint(max(dp[l]))\n\n\n\n
def put():\n  return list(map(int, input().split()))\n\ndef dfs(x,flag=1):\n    s,vis,ans   = [x],[0]*n,['+']*m\n    vis[x]= 1\n    while s:\n        i = s.pop()\n        for j,k in graph[i]:\n            if vis[j]==0:\n                if k*flag<0:\n                    ans[abs(k)-1]='-'\n                elif k*flag>0:\n                    ans[abs(k)-1]='+'\n                if flag==1 or k==0:\n                    s.append(j)\n                    vis[j]=1\n    return ''.join(ans), sum(vis)\n\nn,m,s = put()\ngraph = [[] for i in range(n)]\nk=1\nfor _ in range(m):\n    z,x,y = put()\n    x,y = x-1,y-1\n    if z==1:\n        graph[x].append((y, 0))\n    else:\n        graph[x].append((y, k))\n        graph[y].append((x,-k))\n        k+=1\nm = k-1\nx,y = dfs(s-1, 1)\nprint(y)\nprint(x)\nx,y = dfs(s-1,-1)\nprint(y)\nprint(x)\n
def end(x) :\n    if x == 0 :\n        return "1869";\n    if x == 6 :\n        return "1968";\n    if x == 5 :\n        return "1689";\n    if x == 4 :\n        return "6891";\n    if x == 3 :\n        return  "1689";\n    if x == 2 :\n        return  "1986";\n    if x == 1 :\n        return  "1896";\n\nd = [0] * 10;\nfor c in input() :\n    d[int(c)] += 1;\nfor i in [1,6,8,9] :\n    d[i] -= 1;\n\ns = "";\nost = 0;\n\nfor i in range(10) :\n    for j in range(d[i]):\n        ost = (ost * 10 + i) % 7;\n\nost = (1869, 1896, 1986, 1698, 6198, 1689, 1968)[ost * 10000 % 7];\n\nfor c in (1,2,3,4,5,6,7,8,9) :\n    s += str(c) * d[c];\n\nprint((s + str(ost) + "0" * d[0]));\n
from collections import deque\nn,m=map(int,input().split())\na=[set() for i in range(n+1)]\nfor i in range(m):\n    x,y=map(int,input().split())  \n    a[x].add(y)\n    a[y].add(x)\nif n not in a[1]:\n    t=True\nelse:\n    t=False\nq=deque()\nq.append(1)\nz = [-1 for i in range(n+1)]\nz[1] = 0\nwhile len(q) > 0:\n    v = q.popleft()\n    for i in range(1, n+1):\n        if t ^ (i in a[v]):\n            continue\n        if z[i]==-1:\n            z[i]=z[v]+1\n            q.append(i)\n            if i == n:\n                print(z[i])\n                return\nprint(-1) 
3\n# Copyright (C) 2017 Sayutin Dmitry.\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; version 3\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; If not, see <http://www.gnu.org/licenses/>.\n\ndef main():\n    mod = 10 ** 9 + 7\n    pws = [None for i in range(4 * (10 ** 5))]\n    pws[0] = 1\n    for i in range(1, (4 * (10 ** 5))):\n        pws[i] = 2 * pws[i - 1] % mod\n    \n    n = int(input())\n    seq = list(map(int, input().split()))\n\n    seq.sort()\n    \n    ans = 0\n    for i in range(n):\n        ans += seq[i] * (pws[i] - 1)\n        ans -= seq[i] * (pws[n - i - 1] - 1)\n        ans = ans % mod\n    print(ans)\n\nmain()\n
# 素因数分解\ndef prime_decomposition(n):\n    i = 2\n    table = []\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            table.append(i)\n        i += 1\n    if n > 1:\n        table.append(n)\n    return table\nimport sys\ninput = sys.stdin.readline\nN = int(input())\nA = list(map(int, input().split()))\n# かけらを移動させて共通因数を持つようにする\nsu = sum(A)\nif su == 1:\n    print(-1)\n    return\nprimes = sorted(set(prime_decomposition(su)))\nans = 10**18\n\nfor p in primes:\n    an = 0\n    half = p >> 1\n    cnt = 0\n    for a in A:\n        a %= p\n        cnt += a\n        if cnt <= half:\n            an += cnt\n        else:\n            if cnt < p:\n                an += p - cnt\n            else:\n                cnt -= p\n                if cnt <= half:\n                    an += cnt\n                else:\n                    an += p - cnt\n        if ans <= an:\n            break\n    else:\n        ans = min(ans, an)\nprint(ans)\n
n,m,k = list(map(int,input().split()))\n\nl = list(map(int,input().split()))\n\nout = 0\nd = 0\n\nwhile m > d:\n    nex = l[d]\n    page = (nex - d - 1)//k\n    add = 1\n    while d + add < m and (page * k) < l[d + add] - d  <= (page + 1) * k:\n        add += 1\n    d += add\n    out += 1\n\nprint(out)\n    \n
n = int(input())\ns = input()\nused = [0] * n\nfor i in range(n):\n  if s[i] == '0':\n    used[i] = False\n  else:\n    used[i] = True\na = [0] * n\nb = [0] * n\nfor i in range(n):\n  a[i], b[i] = list(map(int, input().split()))\n\nans = 0\nfor time in range(500):\n  for i in range(n):\n    if time >= b[i] and (time - b[i]) % a[i] == 0:\n      used[i] = not used[i]\n  cnt = 0\n  for i in range(n):\n    if used[i]:\n      cnt += 1\n  ans = max(ans, cnt)\nprint(ans)\n
n,k=list(map(int,input().split()))\n\nx=(n-(k-1)+1)//2\nSTR="0"*(x-1)+"1"\n\nANS=STR*(n//x+1)\nprint(ANS[:n])\n
3\n\nclass Matrix:\n    def __init__(self, n, m, arr=None):\n        self.n = n\n        self.m = m\n        self.arr = [[0] * m for i in range(n)]\n        if arr is not None:\n            for i in range(n):\n                for j in range(m):\n                    self.arr[i][j] = arr[i][j]\n\n    def __mul__(self, other):\n        assert self.m == other.n\n        ans = Matrix(self.n, other.m)\n        for i in range(self.n):\n            for j in range(other.m):\n                for k in range(self.m):\n                    ans.arr[i][j] = (ans.arr[i][j] + self.arr[i][k] * other.arr[k][j]) % (10 ** 9 + 7)\n        return ans\n\n    def __imul__(self, other):\n        self = self * other\n        return self\n\n    def __pow__(self, n):\n        if n == 0:\n            ans = Matrix(self.n, self.n)\n            for i in range(self.n):\n                ans.arr[i][i] = 1\n            return ans\n        elif n & 1 == 1:\n            return self * (self ** (n - 1))\n        else:\n            t = self ** (n >> 1)\n            return t * t\n\n    def __ipow__(self, n):\n        self = self ** n\n        return self\n\n    def __eq__(self, other):\n        if self.n != other.n or self.m != other.m:\n            return False\n        for i in range(self.n):\n            for j in range(self.m):\n                if self.arr[i][j] != other.arr[i][j]:\n                    return False\n        return True\n\n\ndef fpow(a, n):\n    if n == 0:\n        return 1\n    elif n & 1 == 1:\n        return (a * fpow(a, n - 1)) % (10 ** 9 + 7)\n    else:\n        t = fpow(a, n >> 1)\n        return (t * t) % (10 ** 9 + 7)\n\n\ntransform = Matrix(2, 2, [[1, 1], [0, 4]])\nmtx = transform\n\nk = int(input())\na = list(map(int, input().split()))\n"""\nf = False\nfor j in a:\n    if j % 2 == 0:\n        f = True\n        break\nif f:\n    print(a)\n    tp = 1\n    for j in a:\n        if f and j % 2 == 0:\n            j //= 2\n            f = False\n        print(j)\n        mtx **= j\n    ans = Matrix(2, 1, [[0], [1]])\n    ans = mtx * ans\n    print(ans.arr)\n    print("%d/%d" % (ans.arr[0][0], ans.arr[1][0]))\n"""\n\nx = 1\nfor j in a:\n    x = (x * j) % (10 ** 9 + 6)\n\nx = (x - 1) % (10 ** 9 + 6)\n\nif x % 2 == 0:\n    ans = (transform ** (x // 2)) * Matrix(2, 1, [[0], [1]])\n    print("%d/%d" % (ans.arr[0][0], fpow(2, x)))\nelse:\n    y = (x - 1) % (10 ** 9 + 6)\n    ans = (transform ** (y // 2)) * Matrix(2, 1, [[0], [1]])\n    print("%d/%d" % ((ans.arr[0][0] * 2 + 1) % (10 ** 9 + 7), (ans.arr[1][0] * 2) % (10 ** 9 + 7)))\n    \n
import sys\nimport threading\nfrom bisect import bisect_left\n\nn   = int(input())\na   = list(map(int, input().split()))\ne   = {}\ng   = [[] for i in range(n)]\nd   = [0]*(n+5)\nans = [0]*n\np   = [0]*(n+5)\n\nfor i in range(n-1):\n        c, w = map(int, input().split())\n        c-= 1\n        g[c].append(i+1)\n        e[i+1] = w\n\ndef dfs(i, h):\n    nonlocal ans, a, e, g, d, p\n    p[h]=0\n    for j in g[i]:\n        d[h+1] = d[h]+e[j] \n        dfs(j, h+1)\n    x = bisect_left(d, d[h]-a[i], 0, h+1)\n    #print(x-1, i, h, d[h], d[h], a[i])\n    if x>=0:\n        p[x-1]-=1\n    p[h-1]+=p[h]+1\n    ans[i]=p[h]\n\n\n\ndef solve():  \n    nonlocal ans\n    dfs(0, 0)\n    print(' '.join(map(str, ans)))\n\nmax_recur_size = 10**5*2 + 1000\nmax_stack_size = max_recur_size*500\nsys.setrecursionlimit(max_recur_size)\nthreading.stack_size(max_stack_size)\nthread = threading.Thread(target=solve)\nthread.start()
n = int(input())\nL = list(map(int, input().split()))\nans = 0\nM = []\nwhile max(L) != min(L):\n    ans += 1\n    k = max(L)\n    if L.count(k) == 3:\n        s = ''\n        for i in range(len(L)):\n            if L[i] == k:\n                s += '1'\n                L[i] -= 1\n            else:\n                s += '0'\n        M.append(s)    \n    else:      \n        max_1 = 0\n        max_2 = 1\n        if L[max_1] < L[max_2]:\n            max_1, max_2 = max_2, max_1\n        for i in range(2, n):\n            if L[i] > L[max_1]:\n                max_2, max_1 = max_1, i\n            elif L[i] > L[max_2]:\n                max_2 = i\n        s = ''\n        for i in range(n):\n            if i == max_1 or i == max_2:\n                s += '1'\n            else:\n                s += '0'\n        M.append(s)\n        L[max_1] -= 1\n        if L[max_1] < 0:\n            L[max_1] = 0\n        L[max_2] -= 1\n        if L[max_2] < 0:\n            L[max_2] = 0\nprint(max(L))\nprint(ans)\nfor i in M:\n    print(i)
from collections import defaultdict\nN, = list(map(int, input().split()))\n\ndef normal(xs):\n    return tuple(min((xs[j:] + xs[:j] for j in range(1, 5))))\n\ndd = defaultdict(int)\ncc = dict()\nnorm = dict()\nss = []\nfor _ in range(N):\n    xs = list(map(int, input().split()))\n    cnd = [tuple(xs[j:] + xs[:j]) for j in range(1, 5)]\n    x = min(cnd)\n    for item in cnd:\n        norm[item] = x\n    dd[x] += 1\n    cc[x] = (4 if x[0] == x[1] else 2)if x[0] == x[2] and x[1] == x[3] else 1\n    ss.append(x)\n\ndef icr(x):\n    dd[x] += 1\n\ndef dcr(x):\n    dd[x] -= 1\n\ndef f(ff, gg):\n    a,b,c,d=ff\n    e,h,g,f=gg\n    tl = [(a,e,f,b), (b,f,g,c), (c,g,h,d), (d,h,e,a)]\n    for cp in tl:\n        if cp not in norm:\n            return 0\n    r = 1\n    for cp in tl:\n        cp = norm[cp]\n        r *= dd[cp]*cc[cp]\n        dcr(cp)\n    for cp in tl:\n        cp = norm[cp]\n        icr(cp)\n    return r\n\nr = 0\nfor i in range(N):\n    ff = ss[i]\n    dcr(ff)\n    for j in range(i+1, N):\n        sl = ss[j]\n        dcr(sl)\n        x, y, z, w = sl\n        sls = [(x,y,z,w), (y,z,w,x), (z,w,x,y), (w,x,y,z)]\n        for s in sls:\n            r += f(ff, s)\n        icr(sl)\n    icr(ff)\nprint((r//3))\n
import sys\ninput = sys.stdin.readline\n\nNEGINF = -1000000\n\nn = int(input())\nadj = [[] for i in range(n)]\nparent = [-1] * n\n\nvisited = [False] * n\nfor _ in range(n - 1):\n    a, b = list(map(int, input().split()))\n    adj[a - 1].append(b - 1)\n    adj[b - 1].append(a - 1)\n\ntup = tuple()\nouts = [tup] * n\nq = [(0, 0)]\n\nwhile q:\n    node, type = q.pop()\n    if type == 0:\n        visited[node] = True\n        q.append((node, 1))\n        for v in adj[node]:\n            if not visited[v]:\n                parent[v] = node\n                q.append((v, 0))\n    else:\n        ones = [(0, node)]\n        twos = []\n        threes = []\n        for v in adj[node]:\n            if v != parent[node]:\n                a, b, c = outs[v]\n                ones.append((a[0] + 1, a[1], v))\n                twos.append((b[0] + 1, b[1], v))\n                threes.append(c)\n        ones.sort(reverse = True)\n        twos.sort(reverse = True)\n        threes.sort(reverse = True)\n\n        bestOne = (ones[0][0], ones[0][1])\n        \n        bestsTwo = [(NEGINF, (0, 0))]\n        if len(twos) > 0:\n            bestsTwo.append((twos[0][0], twos[0][1]))\n        if len(ones) > 1:\n            o1 = ones[0]\n            o2 = ones[1]\n            bestsTwo.append((o1[0] + o2[0], (o1[1], o2[1])))\n\n        bestsThree = [(NEGINF, (0, 0, 0))]\n        if len(threes) > 0:\n            bestsThree.append(threes[0])\n        if len(ones) > 2:\n            o1 = ones[0]\n            o2 = ones[1]\n            o3 = ones[2]\n            bestsThree.append((o1[0] + o2[0] + o3[0], (o1[1], o2[1], o3[1])))\n        if len(twos) > 0:\n            o1 = ones[0]\n            t1 = twos[0]\n            if o1[2] != t1[2]:\n                bestsThree.append((o1[0] + t1[0], (o1[1], t1[1][0], t1[1][1])))\n            else:\n                if len(twos) > 1:\n                    t2 = twos[1]\n                    bestsThree.append((o1[0] + t2[0], (o1[1], t2[1][0], t2[1][1])))\n                if len(ones) > 1:\n                    o2 = ones[1]\n                    bestsThree.append((o2[0] + t1[0], (o2[1], t1[1][0], t1[1][1])))\n                    \n\n        outs[node] = (bestOne, max(bestsTwo), max(bestsThree))\n\nfinal = outs[0][2]\nprint(final[0])\nprint(' '.join([str(x + 1) for x in final[1]]))\n
n = int(input())\n\nseq = sorted(list(map(int, input().split())))[::-1]\n\na = seq[0]\nlast = -1\nfor i in range(len(seq)):\n    if a % seq[i] == 0:\n        if last != seq[i]:\n            last = seq[i]\n        else:\n            b = seq[i]\n            break\n    else:\n        b = seq[i]\n        break\nprint(a, b)\n
import sys\ninput = sys.stdin.readline\n\ndef main():\n    n, m, k = map(int, input().split())\n    half = m // 2\n    se_s = []\n    for i in range(n):\n        lst = list(map(int, input().split()))\n        lst.sort(reverse = True)\n        total_sub = sum(lst[:half])\n        dp = [[0 for _ in range(k)] for _ in range(half + 1)]\n        for num2 in lst:\n            for i in range(half, 0, -1):\n                for num in dp[i - 1]:\n                    pos = (num + num2) % k\n                    dp[i][pos] = max(dp[i][pos], num + num2)\n        se_s.append(set(dp[-1]))\n    \n    ans = 0\n    ans_sub = set([0])\n    for se in se_s:\n        se_tmp = set()\n        for num in se:\n            for num2 in ans_sub:\n                se_tmp.add(num + num2)\n                if (num + num2) % k == 0:\n                    ans = max(ans, num + num2)\n        tmp = [0 for _ in range(k)]\n        for num in se_tmp:\n            tmp[num % k] = max(tmp[num % k], num)\n        ans_sub = set(tmp)\n        \n    print(ans)\n                \n    \nmain()
# AC\nimport sys\n\n\nclass Main:\n    def __init__(self):\n        self.buff = None\n        self.index = 0\n\n    def __next__(self):\n        if self.buff is None or self.index == len(self.buff):\n            self.buff = sys.stdin.readline().split()\n            self.index = 0\n        val = self.buff[self.index]\n        self.index += 1\n        return val\n\n    def next_int(self):\n        return int(next(self))\n\n    def solve(self):\n        n = self.next_int()\n        x = [self.next_int() for _ in range(0, n)]\n        d = 0\n        l = 0\n        r = n - 1\n        rs = []\n        while l <= r:\n            if x[l] <= d and x[r] <= d:\n                break\n            if x[l] <= d:\n                rs.append('R')\n                d = x[r]\n                r -= 1\n            elif x[r] <= d:\n                rs.append('L')\n                d = x[l]\n                l += 1\n            elif x[r] < x[l] or l == r:\n                rs.append('R')\n                d = x[r]\n                r -= 1\n            elif x[l] < x[r]:\n                rs.append('L')\n                d = x[l]\n                l += 1\n            else:\n                ll = l + 1\n                while x[ll] > x[ll - 1]:\n                    ll += 1\n                rr = r - 1\n                while x[rr] > x[rr + 1]:\n                    rr -= 1\n                if ll - l > r - rr:\n                    rs.append('L')\n                    d = x[l]\n                    l += 1\n                else:\n                    rs.append('R')\n                    d = x[r]\n                    r -= 1\n        print(len(rs))\n        print(''.join(rs))\n\n\ndef __starting_point():\n    Main().solve()\n\n__starting_point()
def main():\n    n = int(input())\n    a = list(sorted(set(map(int, input().split()))))\n    if len(a) > 3:\n        print(-1)\n    elif len(a) == 1:\n        print(0)\n    elif len(a) == 2:\n        d = a[1] - a[0]\n        if d & 1:\n            print(d)\n        else:\n            print(d >> 1)\n    else:\n        d = a[1] - a[0]\n        D = a[2] - a[1]\n        if d == D:\n            print(d)\n        else:\n            print(-1)\n    return 0\n\nmain()
x1, y1, x2, y2 = list(map( int, input().split() ))\nx3, y3, x4, y4 = list(map( int, input().split() ))\nx5, y5, x6, y6 = list(map( int, input().split() ))\n\ncovered = False\nif x3 <= x1 and y3 <= y1 and x4 >= x2 and y4 >= y2:\n    covered = True\nelif x5 <= x1 and y5 <= y1 and x6 >= x2 and y6 >= y2:\n    covered = True\nelif x1 >= x3 and x1 >= x5 and x2 <= x4 and x2 <= x6:\n    if min( y4, y6 ) >= max( y3, y5 ) and min( y3, y5 ) <= y1 and max( y4, y6 ) >= y2:\n        covered = True\nelif y1 >= y3 and y1 >= y5 and y2 <= y4 and y2 <= y6:\n    if min( x4, x6 ) >= max( x3, x5 ) and min( x3, x5 ) <= x1 and max( x4, x6 ) >= x2:\n        covered = True\n\nprint( "NO" if covered else "YES" )\n
darling = {}\nx = int(input())\nans = 0\nwhile (x not in darling):\n	darling[x] = 1\n	ans += 1\n	x += 1\n	while (x % 10 == 0):\n		x /= 10\n\nprint(ans)
import sys\ninput = sys.stdin.readline\n\nn=int(input())\nF=list(map(int,input().split()))\n\nUSE=[0]*(n+1)\n\nB=[]\nfor i in range(n):\n    USE[F[i]]=1\n    if F[i]==0:\n        B.append(i+1)\n\nA=[]\nfor i in range(1,n+1):\n    if USE[i]==0:\n        A.append(i)\n        \nfor i in range(len(A)-1):\n    if A[i]==B[i]:\n        A[i],A[i+1]=A[i+1],A[i]\n\nif A[-1]==B[-1]:\n    A[-1],A[-2]=A[-2],A[-1]\n\nind=0\n\nfor i in range(n):\n    if F[i]==0:\n        F[i]=A[ind]\n        ind+=1\n\nprint(*F)\n
def main():\n    n, k = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    colors = [[] for _ in range(k)]\n    seen = [0 for _ in range(5003)]\n    ans = [-1 for _ in range(n)]\n    for i, x in enumerate(a):\n        if seen[x] >= k:\n            print('NO')\n            return\n        ans[i] = seen[x]\n        colors[ans[i]].append(i)\n        seen[x] += 1\n\n    p = 0\n    for i in range(k):\n        if not colors[i]:\n            while p < i and len(colors[p]) == 1:\n                p += 1\n            if p == i:\n                print('NO')\n                return\n\n            colors[i].append(colors[p].pop())\n            ans[colors[i][-1]] = i\n\n    print('YES')\n    print(' '.join(str(x + 1) for x in ans))\n\nmain()\n
n, x, y = map(int, input().split())\ns = input()[-x:]\nres = s.count('1')\nif s[-y - 1] == '1': res -= 1\nelse: res += 1\n# print(s)\nprint(res)
for i in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    flag = False\n    for j in range(len(arr)):\n        for c in range(j + 2, len(arr)):\n            if arr[c] == arr[j]:\n                flag = True\n                break\n    print("YES" if flag else "NO")\n
def main():\n    n = int(input())\n    a = list(map(int, input()))\n    f = [0] + list(map(int, input().split()))\n    i = 0\n    while f[a[i]] <= a[i]:\n        i += 1\n        if i == n:\n            break\n    for j in range(i, n):\n        if f[a[j]] < a[j]:\n            break\n        else:\n            a[j] = f[a[j]]\n    print("".join(str(x) for x in a))\n    return 0\n\nmain()
mii = 3*10**4\n\nfactors = [set() for _ in range(mii + 1)]\nfactors[1] = set([1])\n\nfor k in range(2, mii + 1):\n    for p in range(2, mii + 1):\n        if k % p == 0:\n            factors[k] = set(ole*p for ole in factors[k//p]) | factors[k//p]\n            break\n        elif p * p > k:\n            factors[k] = set([1, k])\n            break\n\n# print(factors[:20])\n\nt = int(input())\nfor _ in range(t):\n\n    a, b, c = [int(x) for x in input().split()]\n\n\n    best_score = 10**15\n    best_trip = a, b, c\n\n    for k in range(1, mii + 1):\n        this_b = k\n        if c % this_b < this_b - (c % this_b):\n            this_c = this_b * (c // this_b)\n        else:\n            this_c = this_b * (c // this_b + 1)\n\n        this_c = max(this_c, this_b)\n\n        this_a = -1\n        loss_a = 10**15\n        for cur_a in factors[this_b]:\n            if abs(a - cur_a) < loss_a:\n                this_a = cur_a\n                loss_a = abs(a - cur_a)\n\n        cur_score = abs(a - this_a) + abs(b - this_b) + abs(c - this_c)\n        if cur_score < best_score:\n            best_score = cur_score\n            best_trip = this_a, this_b, this_c\n\n    print(best_score)\n    print(*best_trip)\n
n = int(input())\na = list(map(int, input().split()))\na.sort()\nprint(min(a[-1] - a[1], a[-2] - a[0]))\n
def ke(i):\n    return b[i]\nn,m=map(int,input().split())\na=[0]*m\nb=[0]*m\nc=[0]*m\ne=[]\nans=[0]*n\nfor i in range(m):\n    a[i],b[i],c[i]=map(int,input().split())\n    ans[b[i]-1]=m+1\n    e.append(i)\ne.sort(key=ke)\nfor i in range(m):\n    k=0\n    for j in range(a[e[i]]-1,b[e[i]]-1):\n        if ans[j]==0:\n            ans[j]=e[i]+1\n            k+=1\n        if k==c[e[i]]:\n            break\n    if k!=c[e[i]]:\n        print(-1)\n        return\nfor i in ans:\n    print(i,end=' ')
n, m = map(int, input().split())\nif m % n == 0:\n    k = m // n\n    res = 0\n    while k % 2 == 0:\n        k //= 2\n        res += 1\n    while k % 3 == 0:\n        k //= 3\n        res += 1\n    if k > 1:\n        print(-1)\n    else:\n        print(res)\nelse:\n    print(-1)
'''input\n3 4\naba\n'''\nn, k = map(int, input().split())\nt = input()\nfor i in range(1, n):\n	if t[i:] == t[:n-i]:\n		print(t[:i] * k + t[i:])\n		break\nelse:\n	print(t * k)
n = int(input())\na = list(map(int, input().split()))\nc = [ 0 for i in range(1000001) ]\ns = sum(a)\nans = []\nfor i in a: c[i] += 1\nfor i in range(n):\n    s -= a[i]\n    c[a[i]] -= 1\n    if s % 2 == 0 and s // 2 <= 1000000 and c[s // 2] > 0:\n        ans.append(i)\n    s += a[i]\n    c[a[i]] += 1\nprint(len(ans))\nfor i in ans:\n    print(i + 1, end=' ')\n\n
def sol(a,k):\n    n=len(a)\n    if(k==0):return 1\n    if(k==1):\n        v=set()\n        for x in a:\n            v.add(x)\n        return len(v)\n    if(n<k or n<1 or k<1):\n        return 0\n    if(n==k):\n        return 1\n    sz=max(3000,n)\n    v1=[0]*sz\n    v2=[0]*sz\n    v3=[0]*sz\n    v2[n-1]=1\n    v3[a[n-1]-1]=1\n    for i in range(n-2,-1,-1):\n        if(i<0):break\n        v2[i]=v2[i+1]\n        if(v3[a[i]-1]==0):\n            v2[i]+=1\n            v3[a[i]-1]=1\n    for j in range(1,k):\n        v3=[0]*sz\n        v1[n-1]=0\n        for i in range(n-2,-1,-1):\n            v1[i]=v1[i+1]\n            v1[i]=v1[i]+v2[i+1]\n            v1[i] = v1[i] - v3[a[i] - 1]\n            v3[a[i] - 1] = v2[i + 1]\n        v2=v1.copy()\n    return v1[0]\nn,k=list(map(int,input().split()))\ns=input()\nar=[]\nfor x in s:\n    ar.append(ord(x))\nans=0\ncur=n\nwhile cur>=0:\n    mx=min(k,sol(ar,cur))\n    k-=mx\n    ans+=(n-cur)*mx\n    cur-=1\nif(k!=0):\n    print(-1)\nelse:\n    print(ans)\n
import sys\ninput = sys.stdin.readline\n\nn,m,D=list(map(int,input().split()))\nE=[list(map(int,input().split())) for i in range(m)]\n\n\nEDGELIST=[[] for i in range(n+1)]\n\nfor x,y in E:\n    EDGELIST[x].append(y)\n    EDGELIST[y].append(x)\n\nGroup=[i for i in range(n+1)]\n\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\nONE=EDGELIST[1]\n\nfor x,y in E:\n    if x==1 or y==1:\n        continue\n    Union(x,y)\n\nONEU=[find(e) for e in ONE]\n\nif len(set(ONEU))>D or D>len(ONE):\n    print("NO")\n    return\nelse:\n    print("YES")\n\nUSED=set()\nANS=[]\nfrom collections import deque\nQUE=deque()\ncheck=[0]*(n+1)\ncheck[1]=1\n\nfor j in range(len(ONE)):\n    if find(ONE[j]) in USED:\n        continue\n    else:\n        ANS.append([1,ONE[j]])\n        QUE.append(ONE[j])\n        USED.add(find(ONE[j]))\n        check[ONE[j]]=1\n        D-=1\n\nj=0\nfor i in range(D):\n    while check[ONE[j]]==1:\n        j+=1\n    ANS.append([1,ONE[j]])\n    QUE.append(ONE[j])\n    check[ONE[j]]=1\n    \n\nwhile QUE:\n    x=QUE.popleft()\n    check[x]=1\n\n    for to in EDGELIST[x]:\n        if check[to]==0:\n            ANS.append([x,to])\n            QUE.append(to)\n            check[to]=1\n        \n#print(ANS)\nfor x,y in ANS:\n    print(x,y)\n\n\n    \n    \n    \n
h1, m1 = list(map(int, input().split(':')))\nh2, m2 = list(map(int, input().split(':')))\nz = h1 * 60 + m1 + h2 * 60 + m2\nz //= 2\nprint(str(z // 60 // 10) + str(z // 60 % 10) + ':' + str(z % 60 // 10) + str(z % 60 % 10))
"""\nCodeforces April Fools Contest 2014 Problem F\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\nclass InputHandlerObject(object):\n    inputs = []\n\n    def getInput(self, n = 0):\n        res = ""\n        inputs = self.inputs\n        if not inputs: inputs.extend(input().split(" "))\n        if n == 0:\n            res = inputs[:]\n            inputs[:] = []\n        while n > len(inputs):\n            inputs.extend(input().split(" "))\n        if n > 0:\n            res = inputs[:n]\n            inputs[:n] = []\n        return res\nInputHandler = InputHandlerObject()\ng = InputHandler.getInput\n\n############################## SOLUTION ##############################\nx = int(input())\na = [1, 1, 1, 2, 1, 2, 1, 5, 2, 2, 1, 5, 1, 2, 1, 14, 1, 5, 1, 5, 2, 2, 1, 15, 2, 2, 5, 4, 1, 4, 1, 51, 1, 2, 1, 14, 1, 2, 2, 14, 1, 6, 1, 4, 2, 2, 1, 52, 2, 5, 1, 5, 1, 15, 2, 13, 2, 2, 1, 13, 1, 2, 4, 267]\nprint(a[x-1])
n = int(input())\na = []\nfor i in range(n):\n    inp = input().split()\n    a.append((int(inp[0]),int(inp[1])))\n#End of Input Part\n\nfirst = []\nsecond = []\nfor i in range(n):\n    first.append(a[i][0])\n    second.append(a[i][1])\n\n# Sort Them\nfirst.sort(reverse = True)\nsecond.sort()\n\nbestAnswer = 0\nfor i in range(n):\n    l = first[0]\n    r = second[0]\n    if(l==a[i][0]):\n        l = first[1]\n    if(r==a[i][1]):\n        r = second[1]\n    curLength = r-l\n    bestAnswer = max(bestAnswer,curLength)\n\n#Print Answer\nprint(bestAnswer)
#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\n    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit\n    \nN, = getIntList()\n#print(N)\nza = getIntList()\n\nmh = max(za)\nza.append(mh)\n\nduo = [(mh,0)]\n\nfor i in range(N+1):\n    h = za[i]\n    while duo:\n        if i%2 != duo[-1][1]%2:\n            dprint(i )\n            print('NO')\n            return\n        if h >= duo[-1][0]:\n            lh = duo[-1][0]\n            duo.pop()\n            if h== lh:\n                break\n        else:\n            break\n    duo.append( (h,i+1))\n    #dprint(duo)\nprint('YES')\n            \n    \n    \n    \n\n\n\n\n\n\n
import sys\nimport itertools\n\ninputs = sys.stdin.read().split()\nlen_string = int(inputs[0])\ndesired_size = int(inputs[1])\nstring = inputs[2]\n\nsize = 0\ncost = 0\ncur_set = set()\ncur_set.add(string)\nfor i in range(len_string, -1, -1):\n    cur_size = len(cur_set)\n    if size+cur_size >= desired_size:\n        cost += (desired_size-size)*(len_string-i)\n        size = desired_size\n        break\n    cost += cur_size*(len_string-i)\n    size += cur_size\n    \n    new_set = set()\n    for substr in cur_set:\n        for i in range(len(substr)):\n            new_set.add(substr[:i]+substr[(i+1):])\n    cur_set = new_set\n\nif size >= desired_size: sys.stdout.write(str(cost)+"\n")\nelse: sys.stdout.write("-1\n")
A, B, C = list(map(int, input().split()))\n\ng = min(A//3,B//2,C//2)\n\nA -= g*3\nB -= g*2\nC -= g*2\n\nL = [0,0,1,2,0,2,1]\ndef calc(today, x):\n    if x[L[today]] == 0:\n        return 0\n    y = [xx for xx in x]\n    y[L[today]] -= 1\n    return calc((today+1)%7, y) + 1\n\nma = 0\nfor i in range(7):\n    ma = max(ma, calc(i, [A,B,C]))\n\nprint(ma+g*7)\n
def is_symmetric(a):\n	return a[0][1]==a[1][0]\nfor _ in range(int(input())):\n	def two_ints():\n		return list(map(int,input().split()))\n	n, m = map(int,input().split())\n	tiles = [[two_ints(),two_ints()] for i in range(n)]\n	print("YES" if m%2==0 and any([is_symmetric(tile) for tile in tiles]) else "NO")
n = int(input())\nif n * (n + 1) // 2 % 2 == 1:\n    print(1)\nelse:\n    print(0)
MOD=10**9+7\nn=int(input())\ns=[c=='(' for c in input()]\nm=len(s)\nz=[[0,0]]\nfor v in s:\n a=z[-1][v]\n z[-1][v]=len(z)\n z.append(z[a][:])\nz[m][0]=z[m][1]=m\ndp=[[0 for _ in range(m+1)] for _ in range(n+1)]\ndp[0][0]=1\nfor _ in range(2*n):\n ndp=[[0 for _ in range(m+1)] for _ in range(n+1)]\n for i in range(n+1):\n  for j in range(m+1):\n   if dp[i][j]<1:continue\n   if i>0:ndp[i-1][z[j][0]]=(ndp[i-1][z[j][0]]+dp[i][j])%MOD\n   if i<n:ndp[i+1][z[j][1]]=(ndp[i+1][z[j][1]]+dp[i][j])%MOD\n dp=ndp\nprint(dp[0][m])
import sys\nimport queue\n\nINFINITY = 10**10\n\ndef main():\n    n = input()\n    print(solve(n))\n\n\ndef solve(n):\n    if int(n) < 1000:\n        return brute(n)\n        \n    forward = min([calc(str(n), last_digits) for last_digits in ["00", "25", "50", "75"]])\n    reverse = min([calc(str(n), last_digits) + 1 for last_digits in ["52", "05", "57"]])\n    res = min(forward, reverse)\n    \n    if res >= INFINITY:\n        res = -1\n    \n    return res\n\n\ndef calc(n, last_digits):\n    if not last_digits:\n        return 0\n    \n    idx = n.rfind(last_digits[-1])\n    if idx == -1:\n        return INFINITY\n    \n    res = len(n) - idx - 1\n    n = n[:idx] + n[(idx+1):]\n    last_digits = last_digits[:-1]\n    \n    extra = 0\n    if n and n[0] == '0':\n        idx = len(n)\n        for digit in "123456789":\n            if n.find(digit) != -1:\n                idx = min(idx, n.find(digit))\n        \n        if idx == len(n):\n            return idx\n        \n        n = swap(n, 0, idx)\n        extra = idx\n    \n    return res + calc(n, last_digits) + extra\n\n\ndef brute(n):\n    q = queue.Queue()\n    dis = dict()\n    \n    q.put(str(n))\n    dis[str(n)] = 0\n    \n    while not q.empty():\n        s = q.get()\n        if int(s) % 25 == 0:\n            return dis[s]\n        \n        for i in range(1, len(s)):\n            j = i - 1\n            t = swap(s, i, j)\n            \n            if t not in dis and t[0] != '0':\n                dis[t] = dis[s] + 1\n                q.put(t)\n    \n    return -1\n\n\ndef swap(s, i, j):\n    chars = list(s)\n    chars[i], chars[j] = chars[j], chars[i]\n    return "".join(char for char in chars)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
\nalp = "abcdefghijklmnopqrstuvwxyz"\n\ndic = {}\nfor i,s in enumerate(alp):\n    dic[s] = i\n\nlis = [0] * 27\n\nn = int(input())\nS = input()\nans = []\n\nfor i,s in enumerate(S):\n\n    ind = dic[s]\n\n    ans.append(max(lis[ind+1:]) + 1)\n\n    lis[ind] = ans[-1]\n\nprint(max(ans))\nprint(" ".join(map(str,ans)))\n
n = int(input())\narr = [input() for _ in range(n)]\n\narr.sort(key = lambda x : len(x))\n\nfor u, v in zip(arr[:-1], arr[1:]):\n    if u not in v:\n        print('NO')\n        return\n\nprint('YES')\nprint('\n'.join(x for x in arr))
input = __import__('sys').stdin.readline\nMIS = lambda: map(int,input().split())\n\nn, k = MIS()\nprob = list(MIS())\nwhile prob and prob[0] <= k: prob.pop(0)\nwhile prob and prob[-1] <= k: prob.pop()\nprint(n - len(prob))
import math\na,b = [int(x) for x in input().split()]\n\narea = a+b\nt = int(math.sqrt(area))\nsa = int(math.sqrt(a))\nsb = int(math.sqrt(b))\n\nD = []\nDA = []\nDB = []\nfor i in range(1,t+1):\n    if area % i == 0:\n        if i*i != area:\n            D.append(i)\n            D.append(area//i)\n        else:\n            D.append(i)\n\nfor i in range(1,sa+1):\n    if a % i == 0:\n        if i*i != a:\n            DA.append(i)\n            DA.append(a//i)\n        else:\n            DA.append(i)\n            \nfor i in range(1,sb+1):\n    if b % i == 0:\n        if i*i != b:\n            DB.append(i)\n            DB.append(b//i)\n        else:\n            DB.append(i)\nDA.sort()\nDB.sort()\nD.sort()\n\nstart = ((len(D)+1)//2)-1\ndiv = len(D)\n\ndef closestdiv(t,D):\n    low = 0\n    high = len(D)-1\n    while high - low > 1:\n        guess = (high+low)//2\n        if D[guess] > t:\n            high = guess\n        else:\n            low = guess\n    if D[high] <= t:\n        return high\n    else:\n        return low\n    \nwhile start > -1:\n    t = D[start]\n    s = D[-start-1]\n    if DA[-closestdiv(t,DA)-1] <= s:\n        print(2*t+2*s)\n        break\n    elif DB[-closestdiv(t,DB)-1] <= s:\n        print(2*t+2*s)\n        break\n    start -= 1
from collections import deque\nn = int(input())\ns = input()\ngraph = {}\nfor i in range(n):\n    graph[i] = set()\nrb = set()\nfor i in range(n):\n    for j in range(i + 1, n):\n        if s[i] > s[j]:\n            graph[i].add(j)\n            graph[j].add(i)\n            rb.add((i, j))\n            rb.add((j, i))\ngroup = [0] * n\nused = [0] * n\nfor p in range(n):\n    if not used[p]:\n        used[p] = 1\n        q = deque([p])\n        group[p] = 0\n        while q:\n            v = q.popleft()\n            for u in graph[v]:\n                if not used[u]:\n                    used[u] = 1\n                    q.append(u)\n                    group[u] = 1 - group[v]\ng1, g2 = set(), set()\nfor i in range(n):\n    if group[i] == 0:\n        g1.add(i)\n    else:\n        g2.add(i)\nfor p in g1:\n    for p2 in g1:\n        if (p, p2) in rb:\n            print('NO')\n            return\nfor p in g2:\n    for p2 in g2:\n        if (p, p2) in rb:\n            print('NO')\n            return\nprint('YES')\nfor i in range(n):\n    if i in g1:\n        print('0', end='')\n    else:\n        print('1', end='')
a,b = map(int,input().split())\nfor i in range(1,100000):\n    if i*8//100==a and i*10//100==b:\n        print(i)\n        break\nelse:\n    print(-1)
\n"""\n\nb[i] = a[i] - i - 1\n\nb[i] <= b[i+1] < 2b[i] + i - 1\n\nsum(b) == r\n"""\n\ndef solve(n, k):\n\n    r = n - k*(k+1)//2\n    if r < 0:\n        return None\n\n    b0 = r//k\n\n    r -= b0*k\n\n    seq = [None]*k\n    seq[0] = b0\n    b = b0\n\n    for i in range(1,k):\n        bn = b*2 + i - 1\n\n        h = r//(k-i)\n        if h > 0:\n            if h+b > bn:\n                h = bn - b\n            r -= h*(k-i)\n            b = h+b\n        seq[i] = b\n    if r != 0:\n        return None\n    A = [b+i+1 for i,b in enumerate(seq)]\n    return A\n\n\ndef main():\n    n,k = map(int,input().split())\n    res = solve(n,k)\n    if res is None:\n        print('NO')\n    else:\n        print('YES')\n        print(*res)\nmain()
'''input\n5 20\n45 -6\n34 -15\n10 34\n1 27\n40 -45\n\n\n'''\nimport sys\nfrom collections import defaultdict as dd\n\nmod=10**9+7\n\ndef ri(flag=0):\n	if flag==0:\n		return [int(i) for i in sys.stdin.readline().split()]\n	else:\n		return int(sys.stdin.readline())\n\n\nn, r = ri()\n\neventspos = []\neventsneg = []\nfor i in range(n):\n	temp =ri()\n	if temp[1]>=0:\n		eventspos.append(temp)\n	else:\n		eventsneg.append(temp)\n\neventspos.sort()\neventsneg.sort(key = lambda x: x[0]+x[1])\neventsneg.reverse()\n\nstatus =1\n\nans=0 \n\nfor i in range(len(eventspos)):\n	if eventspos[i][0] <= r:\n		r+= eventspos[i][1]\n		ans+=1\n	else:\n		status = 0\n\n\ncheck = [0 for i in range(r+1)]\n\n#print(eventsneg)\n\nfor i in range(len(eventsneg)):\n	for j in range(eventsneg[i][0] , r+1):\n		if j+eventsneg[i][1]>=0:\n			check[j+eventsneg[i][1]] = max(check[j+eventsneg[i][1]] , check[j]+1) \n\n\n\n# if status and r>=0 and sum(check)==len(check):\n# 	print("YES")\n# else:\n# 	print("NO")\n\n#print(eventsneg,eventspos)\n\nprint(max(check) + ans	)\n
n=int(input())\na=list(map(int,input().split()))\n\nc=[0]*1001\n\nfor i in range (len(a)):\n	c[a[i]]+=1\n\nsym=0\nsin=0\n\nfor i in range (1001):\n	sym+=(c[i]//4)\n	if(c[i]%2==1):\n		sin+=1\n\nif(n%2==0 and sym==((n*n)//4)):\n	mat= [([0]*(n//2)) for i in range (n//2)]\n	ar=[]\n	for i in range (1001):\n		while(c[i]>=4):\n			ar.append(i)\n			c[i]-=4\n	\n	k=0\n	for i in range (n//2):\n		for j in range (n//2):\n			mat[i][j]=ar[k]\n			k+=1\n\n	newm=[([0]*n) for i in range (n)]\n	for i in range (n//2):\n		for j in range (n//2):\n			newm[i][j]=mat[i][j]\n			newm[n-i-1][j]=mat[i][j]\n			newm[n-i-1][n-j-1]=mat[i][j]\n			newm[i][n-j-1]=mat[i][j]\n\n	print("YES")\n	for i in range (n):\n		for j in range (n):\n			print(newm[i][j],end=" ")\n		print()\n\n	\nelif(n%2==1 and (((sym>=(((n//2) *(n//2)) ) ) and (sin==1)))):\n	mat= [([0]*(n//2)) for i in range (n//2)]\n	ar=[]\n	for i in range (1001):\n		while(c[i]>=4):\n			ar.append(i)\n			c[i]-=4\n	\n	k=0\n	for i in range (n//2):\n		for j in range (n//2):\n			mat[i][j]=ar[k]\n			ar.pop(k)\n\n	newm=[([0]*n) for i in range (n)]\n	for i in range (n//2):\n		for j in range (n//2):\n			newm[i][j]=mat[i][j]\n			newm[n-i-1][j]=mat[i][j]\n			newm[n-i-1][n-j-1]=mat[i][j]\n			newm[i][n-j-1]=mat[i][j]\n\n	na=len(ar)\n	ar2=[]\n	for i in range (na):\n		ar2.append(ar[i])\n		ar2.append(ar[i])\n\n	for i in range (1001):\n		while(c[i]>=2):\n			ar2.append(i)\n			c[i]-=2\n\n	#print(ar)\n	for i in range (n//2):\n		newm[n//2 ][i]=ar2[0]\n		newm[n//2 ][n-i-1]=ar2[0]\n		ar2.pop(0)\n		newm[i][n//2 ]=ar2[0]\n		newm[n-i-1][n//2 ]=ar2[0]\n		ar2.pop(0)\n\n	for i in range (1001):\n		if(c[i]==1):\n			newm[n//2][n//2]=i\n	\n	print("YES")\n	for i in range (n):\n		for j in range (n):\n			print(newm[i][j],end=" ")\n		print()\n\nelse:\n	print("NO")\n
def sign(x):\n    return (x > 0) - (x < 0)\n\n\ndef key(ab):\n    a, b = ab\n    return (2, -a - b) if b < 0 else (1, a)\n\n\ndef main():\n    n, r = list(map(int, input().split()))\n    for a, b in sorted((tuple(map(int, input().split())) for _ in range(n)), key=key):\n        if r < a:\n            r = -1\n            break\n        r += b\n    if r < 0:\n        print("NO")\n    else:\n        print("YES")\n\n\nmain()\n
\nfrom collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_str(): return list(sys.stdin.readline().split())\n\nN,M,d = inpl()\nCC = inpl()\n\nif sum(CC) + (d-1)*(M+1) < N:\n    print("NO")\nelse:\n    x = 0\n    ans = [0]*(d-1)\n    i = 0\n    for i in range(M):\n        ans += [i+1] * CC[i]\n        ans += [0] * (d-1)\n\n    L = len(ans) - N\n    ans2 = []\n    for a in ans:\n        if a == 0 and L > 0:\n            L -= 1\n        else:\n            ans2.append(a)\n\n    print("YES")\n    print(" ".join(map(str,ans2)))\n
s = input()\nt = input()\nl, r = [0]*len(t), [0]*len(t)\nli, ri = 0, len(s) - 1\nfor i in range(len(t)):\n    while s[ li ] != t[ i ]:\n        li += 1\n    while s[ ri ] != t[ - i - 1 ]:\n        ri -= 1\n    l[ i ] = li\n    r[ -i -1 ] = ri\n    li += 1\n    ri -= 1\n\nprint( max( [ r[ 0 ], len(s) - l[ -1 ] - 1 ] + [ max( 0, r[ i ] - l[ i - 1 ] ) - 1 for i in range( 1, len(t) ) ] ) )\n
r=float(input())\na=0\nh=0\nfor i in range(1,11):\n    for j in range(1,11):\n        c=pow(j*j+i*i/4.,0.5)\n        rtest=i*j*0.5/c\n        if abs(rtest-r)<0.00001:\n            a=i\n            h=j\nprint(a,h)
n,d,k=list(map(int,input().strip().split()))\nans=[]\nif (d>n-1):\n	print ("NO")\n	return\nif (k<2 and n>2):\n	print ("NO")\n	return\nl1=[0 for i in range(d+2)]\ncount=d\ncnt=d+2\ndef insert(par,v,r,e):\n	nonlocal count\n	nonlocal cnt\n	if count==n-1:\n		print ("YES")\n		for o in ans:\n			print(o[0],o[1])\n		return\n	else:\n		ans.append([par,v])\n		cnt=cnt+1\n		count=count+1\n	if (e==0):\n		return \n	while(r!=0):\n		insert(v,cnt,k-1,e-1)\n		r=r-1\n	return \nfor i in range(1,d+1):\n	ans.append([i,i+1])\nfor i in range(1,d+2):\n	l1[i]=min(i-1,d+1-i)\nfor i in range(2,d+1):\n	r=k-2\n	while(r!=0):\n		insert(i,cnt,k-1,l1[i]-1)\n		r=r-1\nif (count<n-1):\n	print ("NO")\nelse:\n	print ("YES")\n	for o in ans:\n		print(o[0],o[1])\n	return\n
\na,b,x=list(map(int,input().split()))\nif(a>b):\n    s='0'\n    a-=1\nelse:\n    s='1'\n    b-=1\nfor i in range(x-1):\n    if(s[-1]=='1'):\n        s+='0'\n        a-=1\n    else:\n        s+='1'\n        b-=1\nif(s[-1]=='1'):\n    s+='1'*(b)\n    s+='0'*a\nelse:\n    s+='0'*a\n    s+='1'*b\nprint(s)\n\n
n = int(input())\ns = input()\nt = input()\n#n = 1\n#s2 = ["aa", "ab", "ac", "ba", "bb", "bc", "ca", "cb", "cc"]\nus = ["abc", "acb", "bac", "bca", "cab", "cba"]\nflag = 0\nfor u in us:\n    if (s in u or t in u):\n        continue\n    if (n > 1 and (s in (u[2] + u[0]) or t in (u[2] + u[0]))):\n        continue\n    flag = 1\n    print("YES")\n    print(u * n)\n    return\n\nif (not flag):\n    for u in us:\n        if (s in u or t in u):\n            continue\n        print("YES")\n        print(u[0] * n + u[1] * n + u[2] * n)\n        return
n = int(input())\na = list(map(int, input().split()))\na = [0] + a\nfor i in range(1, n):\n  a[i] += a[i - 1]\nmi = min(a)\na = list([x - mi + 1 for x in a])\nprint(-1 if set(a) != set(range(1, n + 1)) else ' '.join(map(str, a)))\n
n = int(input())\nA = list(map(int, input().split()))\nfor i in range(n):\n    A[i] %= 2\nprint(min(n - A.count(0), A.count(0)))
import math\nn=int(input())\nans=0\nnum=int(math.sqrt(n)+1)\nfor i in range(1,num)[::-1]:\n    if n%i==0:\n        ans=i+(n//i)-2\n        break\nprint(ans)
import sys\ninput = sys.stdin.readline\n\nx = int(input())\n# 묵 찌 빠\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nMAX = min(a[0], b[1])+min(a[1], b[2])+min(a[2], b[0])\nMIN = 0\ntmp = min(a[0], b[0]+b[2])\na[0] -= tmp\nttmp = min(a[1], b[0]+b[1])\na[1] -= ttmp\ntttmp = min(a[2], b[1]+b[2])\na[2] -= tttmp\nprint(sum(a), MAX)\n
n = int(input())\na = [int(x) for x in input().split()]\n\nres = {}\n\nfor i in range(n):\n  sm = 0\n  for j in range(i, n):\n    sm += a[j]\n    if sm in res:\n      res[sm].append((i, j))\n    else:\n      res[sm] = [(i, j)]\n\nbest = 0\nbestI = -1\nfor key in res:\n  r = -1\n  cnt = 0\n  for (a,b) in sorted(res[key]):\n    if a > r:\n      cnt += 1\n      r = b\n    elif b < r:\n      r = b\n  if cnt > best:\n    best = cnt\n    bestI = key\n\nx = []\nr = -1\nfor (a, b) in sorted(res[bestI]):\n  if a > r:\n    x.append(str(a+1) + " " + str(b+1))\n    r = b\n  elif b < r:\n    r = b\n    x.pop()\n    x.append(str(a+1) + " " + str(b+1))\n  \nprint(best)\nprint("\n".join(x))\n
"""\nCodeforces April Fools 2018 Problem C\n\nAuthor  : chaotic_iak\nLanguage: Python 3.5.2\n"""\n\n################################################### SOLUTION\n\ndef initialize_solution():\n    pass\n\ndef main():\n    n, = read()\n    a = read()\n    for i in range(n-1):\n        if abs(a[i] - a[i+1]) >= 2:\n            return "NO"\n    return "YES"\n\n########################################## PROBLEM CONSTANTS\n\nREAD_FROM_FILE = None\nOUTPUT_PREFIX = None\nINTERACTIVE = False\n\n#################################################### HELPERS\n\nimport sys\n\ndef read(callback=int, split=True):\n    if READ_FROM_FILE:\n        ipt = sfile.readline().strip()\n    else:\n        ipt = input().strip()\n    if INTERACTIVE and ipt == "WRONG_ANSWER":\n        return\n    if split:\n        return list(map(callback, ipt.split()))\n    else:\n        return callback(ipt)\n\ndef write(value, end="\n"):\n    if value is None: return\n    try:\n        if not isinstance(value, str):\n            value = " ".join(map(str, value))\n    except:\n        pass\n    if READ_FROM_FILE:\n        tfile.write(str(value, end=end))\n    else:\n        print(value, end=end)\n    if INTERACTIVE:\n        sys.stdout.flush()\n\nsfile = None\ntfile = None\nif READ_FROM_FILE:\n    sfile = open(READ_FROM_FILE + ".in", "r")\n    sfile.seek(0)\n    tfile = open(READ_FROM_FILE + ".out", "w")\nif OUTPUT_PREFIX is None:\n    result = main()\n    if result is not None:\n        write(result)\nelse:\n    initialize_solution()\n    TOTAL_CASES, = read()\n    for CASE_NUMBER in range(1, TOTAL_CASES+1):\n        write(OUTPUT_PREFIX.replace("%d", str(CASE_NUMBER)), end="")\n        result = main()\n        if result is not None:\n            write(result)\nif sfile is not None: sfile.close()\nif tfile is not None: tfile.close()\n
#      \nimport collections, atexit, math, sys\nfrom functools import cmp_to_key\n#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\nimport bisect \ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\n\ndef memo(func):  \n    cache={}  \n    def wrap(*args):  \n        if args not in cache:  \n            cache[args]=func(*args)  \n        return cache[args]  \n    return wrap\n\n@memo\ndef comb (n,k):\n    if k==0: return 1\n    if n==k: return 1\n    return comb(n-1,k-1) + comb(n-1,k)\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\n    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit\n    \nN, = getIntList()\ns = input()\nt = input()\n\nzs = list(s)\nzt = list(t)\nzs.sort()\nzt.sort()\nif zs != zt:\n    print(-1)\n    return\n\nzs = list(s)\n\nres = []\nfor i in range(N):\n    if zs[i] == t[i]: continue\n    for j in range(i+1,N):\n        if zs[j] == t[i]: break\n    for k in range(j-1,i-1, -1):\n        res.append(k)\n        zs[k],zs[k+1] = zs[k+1],zs[k]\n\nprint(len(res))\nfor x in res:\n    print(x+1,end = ' ')\n\n    \n\n\n\n\n\n\n\n
n = int(input())\n\n\ndef test(a, s):\n    k = [''] * len(a)\n    d = {}\n    for i in range(len(a)):\n        tof = True\n        if a[i] == s[:len(a[i])]:\n            if a[i] not in d:\n                d[a[i]] = 'P'\n                tof = False\n                k[i] = 'P'\n        if not tof:\n            continue\n        if a[i] == s[len(s) - len(a[i]):]:\n            if a[i] not in d or d[a[i]] == 'P':\n                d[a[i]] = 'S'\n                tof = False\n                k[i] = 'S'\n        if tof:\n            return [-1]\n    return k\n        \n\n\nk = ['', '', '', '']\na = []\nfor i in range(2 * n - 2):\n    s = input()\n    a.append(s)\n    if len(s) == 1:\n        if k[0] == '':\n            k[0] = s\n        else:\n            k[1] = s\n    if len(s) == n - 1:\n        if k[2] == '':\n            k[2] = s\n        else:\n            k[3] = s\nm = k[2] + k[0]\nr = test(a, m)\nif r != [-1]:\n    for i in r:\n        print(i, end='')\n    return\nm = k[2] + k[1]\nr = test(a, m)\nif r != [-1]:\n    for i in r:\n        print(i, end='')\n    return\nm = k[3] + k[0]\nr = test(a, m)\nif r != [-1]:\n    for i in r:\n        print(i, end='')\n    return\nm = k[3] + k[1]\nr = test(a, m)\nif r != [-1]:\n    for i in r:\n        print(i, end='')\n\n
b =[1,1,2,7,4]\na =list(map(int,input().split()))\nans = 100\nfor i in range(5):\n    ans = min(a[i]//b[i],ans)\nprint(ans)\n\n
n = int(input())\na = list(map(int, input().split()))\n\nans = 0\nfor i in range(1, n - 1):\n    if a[i - 1] == 1 and a[i] == 0 and a[i + 1] == 1:\n        a[i + 1] = 0\n        ans += 1\nprint(ans)\n
from  math import gcd\nn = int(input())\na=  list(map(int, input().split()))\nk  = 0\nfor i in range(n):\n    k = gcd(a[i], k)\n\nans = 0\n\ndef fact(n):\n    nonlocal ans\n    d = 1\n    while d* d <= n:\n        if n % d == 0:\n            ans += 1\n            if n // d != d:\n                ans += 1\n        d += 1\nfact(k)\nprint(ans)
\ndef mi():\n	return map(int, input().split())\n\nfrom collections import Counter\nn = list(mi())[0]\na = Counter(list(mi()))\nma= -1\nfor i in a:\n	if a[i]>ma:\n		ma = a[i]\nprint (ma)
def mini(arr, n, k): \n	lo = [0 for i in range(n + 1)] \n	o = -1\n	\n	for i in range(n): \n		if (arr[i] == 1): \n			o = i \n		lo[i] = o\n	a= 0; i = 0\n	while(i < n): \n		pos = lo[min(i + k - 1, n - 1)] \n		if (pos == -1 or pos + k <= i): \n			return -1\n		i = pos + k \n		a+= 1\n	return a\nn,k=list(map(int,input().split()))\narr=[int(i) for i in input().split()]\nprint(mini(arr, n, k)) \n\n\n
N = int(input())\nANS = 1\nfor i in range(1,N-1):\n  ANS += (N-1)//i\n  \nprint(ANS)
def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\n\nn = ii()\ns = input().strip()\na = [0] * (n + 1)\nm = [0] * (n + 1)\nfor i in range(n):\n    a[i] = a[i - 1] + (1 if s[i] == '(' else -1)\n    m[i] = min(m[i - 1], a[i])\n\nans = 0\nmm = a[n - 1]\nfor j in range(n - 1, -1, -1):\n    mm = min(mm, a[j])\n    if s[j] == '(':\n        if a[n - 1] == 2 and mm == 2 and m[j - 1] >= 0:\n            ans += 1\n    else:\n        if a[n - 1] == -2 and mm == -2 and m[j - 1] >= 0:\n            ans += 1\n\nprint(ans)\n
import sys\ninput = sys.stdin.readline\ns = input()\nt = input()\nl, r = [0]*len(t), [0]*len(t)\nli, ri = 0, len(s) - 1\nfor i in range(len(t)):\n    while s[ li ] != t[ i ]:\n        li += 1\n    while s[ ri ] != t[ - i - 1 ]:\n        ri -= 1\n    l[ i ] = li\n    r[ -i -1 ] = ri\n    li += 1\n    ri -= 1\n\nprint( max( [ r[ 0 ], len(s) - l[ -1 ] - 1 ] + [ max( 0, r[ i ] - l[ i - 1 ] ) - 1 for i in range( 1, len(t) ) ] ) )\n
a,b,c,d=map(int,input().split())\nprint(max(a*c,a*d,b*c,b*d))
n = int(input())\ndn = list(map(int, input().split()))\ndn.sort()\na = dn[n // 2 - 1]\nb = dn[n // 2]\n\nprint((b-a))\n
def main():\n    import sys\n    input = sys.stdin.readline\n\n    N, H, L, R = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n\n    dp = [[-1] * H for _ in range(N+1)]\n    dp[0][0] = 0\n    for i, a in enumerate(A):\n        for t in range(H):\n            if dp[i][t] >= 0:\n                dp[i+1][(t+a)%H] = max(dp[i+1][(t+a)%H], dp[i][t] + int(L <= (t+a)%H <= R))\n                dp[i + 1][(t + a-1) % H] = max(dp[i + 1][(t + a-1) % H], dp[i][t] + int(L <= (t + a-1) % H <= R))\n    print(max(dp[-1]))\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n = int(input())\na = list(map(int, input().split()))\n\nans = [1]\nt = 1\n\nfor i in range(n - 1):\n    if a[i + 1] / a[i] <= 2:\n        t += 1\n\n    else:\n        t = 1\n\n    ans.append(t)\n\nprint(max(ans))\n
import math\nfrom collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    MAX = 10**7 + 1\n    res = MAX * MAX\n\n    #MAX_P = int(math.sqrt(MAX))\n    MAX_P = 3163\n\n    primes = []\n    p = 2\n    sieve = [True] * (MAX_P+1)\n    while p < MAX_P:\n        if sieve[p]:\n            primes.append(p)\n            k = 2\n            while k * p < MAX_P:\n                sieve[k * p] = False\n                k += 1\n        p += 1\n\n    np = len(primes)\n    cand1 = {}\n    cand2 = {}\n    ind1 = {}\n    ind2 = {}\n\n    res = MAX * MAX\n    for index in range(n):\n        val = a[index]\n        if val >= res:\n            continue\n\n        divisors = [1]\n        p = 0\n        while val > 0 and p < np:\n            while val % primes[p] == 0:\n                divisors += [d * primes[p] for d in divisors]\n                val //= primes[p]\n            p += 1\n        if val > 1:\n            divisors += [d * val for d in divisors]\n\n        for d in set(divisors):\n            if d not in cand1:\n                cand1[d] = a[index]\n                ind1[d] = index\n            else:\n                if d not in cand2:\n                    if a[index] < cand1[d]:\n                        cand2[d] = cand1[d]\n                        ind2[d] = ind1[d]\n                        cand1[d] = a[index]\n                        ind1[d] = index\n                    else:\n                        cand2[d] = a[index]\n                        ind2[d] = index\n                else:\n                    if a[index] < cand1[d]:\n                        cand2[d] = cand1[d]\n                        ind2[d] = ind1[d]\n                        cand1[d] = a[index]\n                        ind1[d] = index\n                    elif a[index] < cand2[d]:\n                        cand2[d] = a[index]\n                        ind2[d] = index\n                    else:\n                        continue\n                if res > cand1[d] // d * cand2[d]:\n                    x, y = ind1[d], ind2[d]\n                    res = cand1[d] // d * cand2[d]\n\n    print(min(x+1, y+1), max(x+1, y+1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
from sys import stdin, stdout\nfrom math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial\nfrom random import randint\n\nn = int(stdin.readline())\ns = list(stdin.readline().strip())\na, b, c = s.count('0'), s.count('1'), s.count('2')\nd = n // 3\n\nfor i in range(len(s)):\n    if s[i] == '2' and c > d:\n        if a < d:\n            s[i] = '0'\n            a += 1\n            c -= 1\n        else:\n            s[i] = '1'\n            b += 1\n            c -= 1\n    elif s[i] == '1' and b > d:\n        if a < d:\n            s[i] = '0'\n            a += 1\n            b -= 1\n\nfor i in range(len(s) - 1, -1, -1):\n    if s[i] == '1' and b > d:\n        if c < d:\n            s[i] = '2'\n            b -= 1\n            c += 1\n    elif s[i] == '0' and a > d:\n        if c < d:\n            s[i] = '2'\n            a -= 1\n            c += 1\n        elif b < d:\n            s[i] = '1'\n            a -= 1\n            b += 1\n\n\nstdout.write(''.join(s))
import sys\n\nN, M = list(map(int, input().split()))\n\na = [False]*(N+1)\nfor i in range(M):\n    a[int(input())] = True\n\nb = [0]*(N+1)\n\nif N < 2:\n    print((1))\n    return\n\nb[-1] = 1\n\nfor i in reversed(list(range(0, N))):\n    if a[i]:\n        b[i] = 0\n        continue\n    if i == N-1:\n        b[i] = b[i+1]\n    else:\n        b[i] = (b[i+1] + b[i+2])%(10**9+7)\n\nprint((b[0]))\n\n\n\n
x, k, d = map(int, input().split())\nif x < 0:\n    x *= -1\ncnt = min(k, x//d+1)\nx -= cnt * d\nif abs(x) < x+d:\n    x += d\n    cnt -= 1\n    x -= d * ((k-cnt)%2)\nelse:\n    x += d * ((k-cnt)%2)\nprint(abs(x))
TASK = "stars"\n# FIN = open(TASK + ".in")\n# FOUT = open(TASK + ".out", "w")\n\na = [1, 0, 0, 0, 1, 0, 1, 0, 2, 1, 1, 2, 0, 1, 0, 0]\nans = 0\nn = int(input())\nif n == 0:\n    print(1)\n    return\nwhile (n > 0):\n    tmp = n % 16\n    ans += a[tmp]\n    n //= 16\n\nprint(ans)\n\n# FIN.close()\n# FOUT.close()\n
a = [ 4, 22, 27, 58, 85, 94, 121, 166, 202, 265, 274, 319, 346, 355, 378, 382, 391, 438, 454, 483, 517, 526, 535, 562, 576, 588, 627, 634, 636, 645]\n\nprint(a[int(input()) - 1])
x = int(input())\nprint(x%2)
n = int(input())\na = list(map(int, input().split()))\nprint(max(a) ^ a[-1])
def read_int():\n    return int(input())\n\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\n\nt = read_int()\nfor case_num in range(t):\n    n, k = read_ints()\n    i = 1\n    largest = 1\n    while i * i <= n:\n        if n % i == 0:\n            if i <= k:\n                largest = max(largest, i)\n            if n // i <= k:\n                largest = max(largest, n // i)\n        i += 1\n    print(n // largest)\n
n,m = map(int,input().split())\ns = [list(map(int,input().split())) for i in range(m)]\np = list(map(int,input().split()))\nans = 0\nfor i in range(2 ** n):\n    t = ['off'] * n\n    x = i\n    j = 0\n    while x > 0:\n        if x % 2 != 0:\n            t[j] = 'on'\n        x = x // 2\n        j += 1\n    flg = True\n    for j in range(m):\n        z = 0\n        for k in range(1,s[j][0]+1):\n            if t[s[j][k]-1] == 'on':\n                z += 1\n        if z % 2 != p[j]:\n            flg = False\n            break\n    if flg:\n        ans += 1\nprint(ans)
import math\nA,B,H,M = map(int,input().split())\nif H >= 12:\n    H -= 12\nchoperminute = 360/60 ##一分で長針が何度動くか\ntanperminute = 30/60 ##一分で短針が何度動くか\n\ntankaku = H*30 + tanperminute*M\nchokaku = choperminute*M\n\nif chokaku >= tankaku:\n    angle = chokaku -tankaku\nelse:\n    angle = tankaku - chokaku\n    \nif angle > 180:\n    angle = 360 -angle\n    \nansjyou = (A**2) + (B**2) - (2*A*B*math.cos(math.radians(angle)))\nprint(ansjyou**0.5)
MAXN = 200001\n\ndef less_sum(s, m):\n    n = len(s)\n    a = 0\n    b = 0\n    res = 0\n    last = 0\n\n    count = [0 for i in range(-MAXN, MAXN+1)]\n\n    count[0] = 1\n    x = 0\n    last = 1\n\n    for i in range(n):\n        if s[i] > m:\n            b += 1\n        else:\n            a += 1\n        x = a-b\n        #print(x)\n        #print(count[-2], count[-1], count[0], count[1], count[2])\n        if s[i] > m:\n            last -= count[x+1]\n        else:\n            last += count[x]\n        #print(x, last)\n        res += last\n        count[x] += 1\n        last += 1\n    \n    #print(res)\n\n    return res\n\nn, m = map(int, input().split(' '))\ns = list(map(int, input().split(' ')))[0:n]\n\n#print(m, s)\n\nprint(less_sum(s, m) - less_sum(s, m-1))
from copy import deepcopy\nn,m = map(int,input().split())\na = list(map(int,input().split()))\nb = [list(map(int,input().split())) for i in range(m)]\nbest1 = -1\nbest2 = -1\nbest3 = []\nfor i in range(n):\n    tmp = 0\n    tmp2 = 0\n    tmp3 = []\n    c = deepcopy(a)\n    for j in range(m):\n        x,y = b[j]\n        x-=1;y-=1\n        if x<= i and i <= y:\n            continue\n        for k in range(x,y+1):\n            c[k] -= 1\n        tmp3.append(j+1)\n        tmp2 += 1\n    kon = max(c)-min(c)\n    if best1 < kon:\n        best1 = kon\n        best2 = tmp2\n        best3 = tmp3\nprint(best1)\nprint(best2)\nprint(*best3)
n = int(input())\nfor i in range(n):\n    s = input()\n    if len(s) == len(set(s)) and abs(ord(min(s)) - ord(max(s))) == len(s) - 1:\n        print('Yes')\n    else:\n        print('No')
import sys\n\n# a very nice implementation of a minimum segment tree with \n# some inspiration taken from https://codeforces.com/blog/entry/18051\n# this implementation should be able to be modified to do pretty\n# much anything one would want to do with segment trees apart from\n# persistance.\n# note that especially in python this implementation is much much better\n# than most other approches because how slow python can be with function\n# calls.\n\n# currently it allows for two operations, both running in o(log n),\n# 'add(l,r,value)' adds value to [l,r)\n# 'find_min(l,r)' finds the index with the smallest value\n\nclass super_seg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n: m *= 2\n        \n        self.n = n\n        self.m = m\n        self.data = [0]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\n        self.query = [0]*(2*m)\n    \n    # push the query on seg_ind to its children\n    def push(self,seg_ind):\n        # let the children know of the queries\n        q = self.query[seg_ind]\n\n        self.query[2*seg_ind]   += q\n        self.query[2*seg_ind+1] += q\n        \n        self.data[2*seg_ind]   += q\n        self.data[2*seg_ind+1] += q\n\n        # remove queries from seg_ind\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\n        self.query[seg_ind] = 0\n\n    # updates the node seg_ind to know of all queries\n    # applied to it via its ancestors\n    def update(self,seg_ind):\n        # find all indecies to be updated\n        seg_ind //= 2\n        inds = []\n        while seg_ind>0:\n            inds.append(seg_ind)\n            seg_ind//=2\n       \n        # push the queries down the segment tree\n        for ind in reversed(inds):\n            self.push(ind)\n\n    # make the changes to seg_ind be known to its ancestors\n    def build(self,seg_ind):\n        seg_ind//=2\n        while seg_ind>0:\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\n            seg_ind //= 2\n\n    # lazily add value to [l,r)\n    def add(self,l,r,value):\n        l += self.m\n        r += self.m\n        \n        l0 = l\n        r0 = r\n\n        while l<r:\n            if l%2==1:\n                self.query[l]+= value\n                self.data[l] += value\n                l+=1\n            if r%2==1:\n                r-=1\n                self.query[r]+= value\n                self.data[r] += value\n            l//=2\n            r//=2\n\n        # tell all nodes above of the updated\n        # area of the updates\n        self.build(l0)\n        self.build(r0-1)\n    \n    # min of data[l,r)\n    def min(self,l,r):\n        l += self.m\n        r += self.m\n\n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n        \n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        return min(self.data[ind] for ind in segs)\n\n\n    # find index of smallest value in data[l,r)\n    def find_min(self,l,r):\n        l += self.m\n        r += self.m\n        \n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n\n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        ind = min(segs, key=lambda i:self.data[i])\n        mini = self.data[ind]\n       \n        # dig down in search of mini\n        while ind<self.m:\n            self.push(ind)\n\n            if self.data[2*ind]==mini:\n                ind *= 2\n            else:\n                ind = 2*ind+1\n        \n        return ind-self.m,mini\n\n\nn,m = [int(x) for x in input().split()]\n\nA = [int(x) for x in input().split()]\n\ninter = []\ninter2 = []\nfor _ in range(m):\n    l,r = [int(x) for x in input().split()]\n    l -= 1\n    inter.append((l,r))\n    inter2.append((r,l))\n\ninter_copy = inter[:]\n\ninter.sort()\ninter2.sort()\n\nAneg = super_seg([-a for a in A])\n\nbesta = -1\nbesta_ind = -1\n\nj1 = 0\nj2 = 0\nfor i in range(n):\n    # Only segments containing i should be active\n    # Activate\n    while j1<m and inter[j1][0]<=i:\n        l,r = inter[j1]\n        Aneg.add(l,r,1)\n        j1 += 1\n    # Deactivate\n    while j2<m and inter2[j2][0]<=i:\n        r,l = inter2[j2]\n        Aneg.add(l,r,-1)\n        j2 += 1\n    Amax = -Aneg.min(0,n)\n    Ai = -Aneg.min(i,i+1)\n    if Amax-Ai>besta:\n        besta = Amax-Ai\n        besta_ind = i\n\nints = [j for j in range(m) if inter_copy[j][0]<=besta_ind<inter_copy[j][1]]\n\nprint(besta)\nprint(len(ints))\nprint(*[x+1 for x in ints])
x=int(input())\na=list(map(int,input().strip().split()))\ny=[]\nc=0\nf1=1\nf2=1\nl=0\nr=x-1\nop=[]\nwhile(f1 or f2):\n    if(l>r):\n        break\n    if(a[l]<c):\n        f1=0\n    if(a[r]<c):\n        f2=0\n    if(f1 and f2):\n        if(a[l]<=a[r]):\n            c=a[l]\n            l=l+1\n            op.append('L')\n        else:\n            c=a[r]\n            r=r-1\n            op.append('R')\n    elif(f1):\n        c=a[l]\n        l=l+1\n        op.append('L')\n    elif(f2):\n        c=a[r]\n        r=r-1\n        op.append('R')\nprint(len(op))\nprint("".join(op))\n
n = int(input())\nmass = list(map(int, input().split()))\nleft = [1] * n\nright = [1] * n\nfor i in range(1, n):\n    if mass[i] > mass[i - 1]:\n        left[i] = left[i - 1] + 1\nfor i in range(n - 2, -1, -1):\n    if mass[i] < mass[i + 1]:\n        right[i] = right[i + 1] + 1\nmx = 1\nfor i in range(n):\n    if i == 0:\n        mx = max(right[0], mx)\n    elif i == n - 1:\n        mx = max(mx, left[n - 1])\n    elif mass[i + 1] > mass[i - 1]:\n        mx = max(mx, left[i - 1] + right[i + 1])\n    mx = max(mx, left[i])\n    mx = max(mx, right[i])\nprint(mx)\n
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nfrom collections import defaultdict\nfrom collections import deque\nimport math\nimport copy\n \n#T = int(input())\n#N = int(input())\n#s1 = input()\n#s2 = input()\nN,K = [int(x) for x in stdin.readline().split()]\narr = [int(x) for x in stdin.readline().split()]\narr.sort()\n\nfreq = {}\n\nfor i in range(N):\n    num = arr[i]\n    if num not in freq:\n        freq[num] = []\n        \n    round = 0\n    freq[num].append(0)\n    while num!=0:\n        round += 1\n        num = num//2\n        if num not in freq:\n            freq[num] = []\n            \n        freq[num].append(round)\n\nres = 999999999999\nfor key in freq:\n    if len(freq[key])<K:\n        continue\n    else:\n        s = sum(freq[key][:K])\n        res = min(res,s)\n        \nprint(res)\n        \n
#-*-coding:utf-8-*-\nimport sys\ninput=sys.stdin.readline\n\ndef main():\n    n,a,b = map(int,input().split())\n    a_count=0\n    d,r=divmod(n,a+b)\n    a_count+=a*d\n    if r > a:\n        a_count+=a\n    else:\n        a_count+=r\n    print(a_count)\n\ndef __starting_point():\n    main()\n__starting_point()
for q in range(int(input())):\n    n = int(input())\n    D = list(map(int, input().split()))\n    D.sort()\n    z = D[0] * D[-1]\n    if z == -1:\n        print(-1)\n    else:\n        Dz = set()\n        for i in range(2, int(z ** 0.5) + 1):\n            if z % i == 0:\n                Dz.add(i)\n                Dz.add(z // i)\n        if Dz == set(D):\n            print(z)\n        else:\n            print(-1)
n=int(input())\nar=list(map(int,input().split()))\ns=set()\na=[]\nfor x in ar[::-1]:\n    if x not in s:\n        a.append(x)\n    s.add(x)\nprint(len(a))\nprint(*a[::-1])
def f(n):\n    a=0\n    while(n>0):\n        a+=n%10\n        n//=10\n    return a\nn=int(input())\nwhile f(n)%4!=0:\n    n+=1\nprint(n)\n
import sys\ninput = sys.stdin.readline\n\nt=int(input())\nfor tests in range(t):\n    S=input().strip()\n    m=int(input())\n    B=list(map(int,input().split()))\n\n    LIST=[0]*26\n\n    for s in S:\n        LIST[ord(s)-97]+=1\n\n    ANS=[0]*m\n    ind=25\n\n    while max(B)>=0:\n        L=[]\n        for i in range(m):\n            if B[i]==0:\n                L.append(i)\n                B[i]=-1\n\n        LEN=len(L)\n\n        while LIST[ind]<LEN:\n            ind-=1\n\n        for l in L:\n            ANS[l]=ind\n\n        ind-=1\n\n        for l in L:\n            for i in range(m):\n                B[i]-=abs(i-l)\n\n    #print(ANS)\n    print("".join([chr(a+97) for a in ANS]))\n                \n        \n\n    \n\n    \n    \n
N = int(input())\nal = [chr(ord('a') + i) for i in range(26)]\n\nans = ''\nwhile N>0:\n    N -=1\n    ans += al[N%26]\n    N //= 26\n\nprint(ans[::-1])
n = int(input())\narr = input()\nfinal = len(arr)\narr = arr.split()\nlens = [0 for x in range(n)]\nvisit = [0 for x in range(n)]\ncnt = 0\nans = 0\nfor i in range(n):\n  if visit[i]:\n    continue\n  lens[cnt] = len(arr[i])\n  for j in range(i+1,n):\n    if arr[j]==arr[i]:\n      arr[j] = cnt\n      visit[j] = 1\n  arr[i] = cnt\n  cnt += 1\nfor i in range(n):\n  for j in range(i,n):\n    temp = arr[i:j+1]\n    ind = 1\n    found = 0\n    len2 = j-i+1\n    cur = 0\n    kmp = [0 for x in range(len2)]\n    while ind < len2:\n      if temp[ind] == temp[cur]:\n        cur += 1\n        kmp[ind] = cur\n        ind += 1\n      else:\n        if cur != 0:\n          cur -= 1\n        else:\n          kmp[ind] = 0\n          ind += 1\n    ind = 0\n    cur = 0\n    while ind < n:\n      if arr[ind] == temp[cur]:\n        ind += 1\n        cur += 1\n      if cur == len2:\n        found += 1\n        cur = 0\n      elif ind < n and temp[cur] != arr[ind]:\n        if cur != 0:\n          cur = kmp[cur-1]\n        else:\n          ind += 1\n    if found>1:\n      res = 0\n      for k in temp:\n        res += (lens[k]-1)*(found)\n      res += (len(temp)-1)*(found)\n      ans = max(ans,res)\nprint(final-ans)
\ndef mi():\n	return map(int, input().split())\n\nn, k = mi()\na = list(mi())\nfor i in range(n):\n	a[i] = [a[i],i]\n\na.sort(reverse= True)\n\na = a[:k]\ns = 0\nind = []\nfor i in a:\n	s+=i[0]\n	ind.append(i[1])\nind.sort()\nfor i in range(k):\n	ind[i]+=1\nind1 = ind.copy()\nfor i in range(1,len(ind)):\n	ind[i]-=ind1[i-1]\nind[-1] = n-sum(ind[:k-1])\nprint (s)\nfor i in ind:\n	print (i, end = ' ')
from sys import stdin\n\ntt = 1\n\nfor loop in range(tt):\n\n    dic = {}\n    dic[0] = 1\n\n    n = int(stdin.readline())\n\n    a = list(map(int,stdin.readline().split()))\n    now = 0\n    ans = 0\n\n    for i in a:\n        now += i\n        if now in dic:\n            ans += 1\n            dic = {}\n            dic[0] = 1\n            now = i\n            \n        dic[now] = 1\n\n    print (ans)
import sys\ninput = sys.stdin.readline\nrInt = lambda: int(input())\nmInt = lambda: list(map(int, input().split()))\nrLis = lambda: list(map(int, input().split()))\n\nt = int(input())\n\nfor _ in range(t):\n    n, m = mInt()\n    if n == 1:\n        print(0)\n    elif n == 2:\n        print(m)\n    else:\n        print(2 * m)\n
K = int(input())\n\na = [7] * (K + 1)\na[0] %= K\nfor i in range(1, K+1):\n    a[i] = (10*a[i-1] + 7) % K\n\nans = [i+1 for i, ai in enumerate(a) if ai == 0]\n\nif len(ans) > 0:\n    print((ans[0]))\nelse:\n    print((-1))\n
def main():\n    n, m = map(int, input().split())\n    def intCompare(x):\n        if int(x) == m:\n            return 0\n        if int(x) < m:\n            return -1\n        return 1\n    p = list(map(intCompare, input().split()))\n    ret = 0\n    ind = p.index(0)\n    tem = 0\n    ret0 = [0] * 400001\n    ret1 = [0] * 400001\n    set0 = set()\n    for i in range(ind, -1, -1):\n        tem += p[i]\n        ret0[tem] += 1\n        set0.add(tem)\n    tem = 0\n    for i in range(ind, n):\n        tem += p[i]\n        ret1[tem] += 1\n    for i in set0:\n        ret += ret0[i] * (ret1[-i] + ret1[1-i]) \n    print(ret)\n    return 0\nmain()
n, m = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\na.sort(reverse=True)\n\ndef check(d):\n    s=0\n    for i in range(len(a)):\n        s+=max(0,a[i]-i//d)\n    return s>=m\nif sum(a)<m:\n    print(-1)\nelse:\n    l, r = 1,n\n    mid = l+r>>1\n    while l<r:\n        if check(mid):\n            r=mid\n        else:\n            l=mid+1\n        mid=l+r>>1\n    print(l)\n
n = int(input())\nT = input().split(' ')\nfor i in range(n):\n    T[i] = int(T[i])\nm = n+1\nif n == 1:\n    print(0)\nelse:\n    for a in range(-1, 2):\n        for b in range(-1, 2):\n            c = True\n            p = (T[1]+b) - (T[0]+a)\n            tot = 0\n            if a!=0:\n                tot+=1\n            if b!=0:\n                tot+=1\n            el = T[1]+b\n            for j in range(2, n):\n                if abs((T[j] - el) - p) <= 1:\n                    el += p\n                    if T[j] != el:\n                        tot+=1\n                else:\n                    c = False\n            if c:\n                m = min(m, tot)\n    if m <= n:\n        print(m)\n    else:\n        print(-1)\n
import bisect\n\nn,k=list(map(int,input().split()))\nA=list(map(int,input().split()))\nA.sort()\n\nDP=[[0]*(k+1) for i in range(n)]\n\nfor i in range(n):\n    x=bisect.bisect_right(A,A[i]+5)-1\n    #print(i,x)\n    for j in range(k-1,-1,-1):\n        DP[i][j]=max(DP[i][j],DP[i-1][j])        \n        DP[x][j+1]=max(DP[i-1][j]+x-i+1,DP[x][j+1])\n\nprint(max([DP[i][-1] for i in range(n)]))\n
N, K, M = map(int,input().split())\nA = list(map(int,input().split()))\ndef score():\n    max_aim = M*N\n    last_score = max_aim - sum(A)\n    if last_score <=0:\n        return 0\n    elif 0 < last_score <= K:\n        return last_score\n    elif  K < last_score:\n        return -1\n    \nprint(score())
n,k,q = [int(x) for x in input().split()]\na = []\nfor i in range(q):\n  a.append(int(input()))\nres = [0] * n\nfor i in range(q):\n  res[a[i]-1] += 1\nb = q - k\n#print(res)\nfor i in range(n):\n  if res[i] > b:\n    print("Yes")\n  else:\n    print("No")
import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nA=[list(map(int,input().split())) for i in range(n)]\n\nfor i in range(m):\n    #一行目をi-1まで0にする\n\n    ANSR=[0]*n\n    ANSC=[0]*m\n\n    for j in range(i):\n        if A[0][j]==1:\n            ANSC[j]=1\n\n    for j in range(i,m):\n        if A[0][j]==0:\n            ANSC[j]=1\n\n    for r in range(1,n):\n        B=set()\n        for c in range(m):\n            if ANSC[c]==0:\n                B.add(A[r][c])\n            else:\n                B.add(1-A[r][c])\n\n        if len(B)>=2:\n            break\n        if max(B)==0:\n            ANSR[r]=1\n\n    else:\n        print("YES")\n        print("".join(map(str,ANSR)))\n        print("".join(map(str,ANSC)))\n        return\n\nANSR=[0]*n\nANSC=[0]*m\n\nfor j in range(m):\n    if A[0][j]==1:\n        ANSC[j]=1\n\nflag=0\nfor r in range(1,n):\n    if flag==0:\n        B=[]\n        for c in range(m):\n            if ANSC[c]==0:\n                B.append(A[r][c])\n            else:\n                B.append(1-A[r][c])\n\n        if max(B)==0:\n            continue\n        elif min(B)==1:\n            ANSR[r]=1\n            continue\n        else:\n            OI=B.index(1)\n            if min(B[OI:])==1:\n                flag=1\n                continue\n\n            OO=B.index(0)\n            if max(B[OO:])==0:\n                flag=1\n                ANSR[r]=1\n                continue\n\n            else:\n                print("NO")\n                return\n\n    else:\n\n        B=set()\n        for c in range(m):\n            if ANSC[c]==0:\n                B.add(A[r][c])\n            else:\n                B.add(1-A[r][c])\n\n        if len(B)>=2:\n            break\n        if max(B)==0:\n            ANSR[r]=1\n\nelse:\n    print("YES")\n    print("".join(map(str,ANSR)))\n    print("".join(map(str,ANSC)))\n    return\n\nprint("NO")\n\n    \n\n    \n
import sys\nimport time\n\nfor line in sys.stdin:\n    ll = len(line) - 1\n    fail = 0\n    for i in range(ll):\n        if i == ll - 1 - i:\n            if int(line[i]) not in [3, 7]:\n                fail = 1\n            continue\n        x = int(line[i])\n        y = int(line[ll - 1 - i])\n        if (x, y) not in [(3, 3), (4, 6), (6, 4), (7, 7), (8, 0), (0, 8), (5, 9), (9, 5)]:\n            fail = 1\n    if fail:\n        print("No")\n    if not fail:\n        print("Yes")\n
n, b, a = map(int, input().split())\nA = list(map(int, input().split()))\na0 = a\nans = 0\nfor elem in A:\n	if a + b == 0:\n		break\n	if elem == 0:\n		if a > 0:\n			a -= 1\n			ans += 1\n		else:\n			b -= 1\n			ans += 1\n	else:\n		if a == a0:\n			a -= 1\n			ans += 1\n		elif b > 0:\n			b -= 1\n			a += 1\n			ans += 1\n		else:\n			a -= 1\n			ans += 1\nprint(ans)
res = 0\nval = 0\nsub = False\nfor c in input()+'+':\n  if c == '+' or c == '-':\n     if sub: val *= -1\n     res += val\n     val = 0\n     sub = (c == '-')\n  val *= 10\n  val += ord(c) - ord('0')\nprint(res)
n, k = list(map(int, input().split()))\nif n > k*(k-1):\n    print("NO")\nelse:\n    print("YES")\n    cnt = 0\n    for delta in range(k):\n        for c in range(1, k+1):\n            if cnt < n:\n                cnt +=1\n                print(c, 1+(c+delta)%k)\n            else:\n                break\n
import sys\nfrom math import *\n\ndef minp():\n	return sys.stdin.readline().strip()\n\ndef mint():\n	return int(minp())\n\ndef mints():\n	return map(int, minp().split())\n\nn, k, x = mints()\na = list(mints())\nd = [None]*(n+1)\np = [None]*(n+1)\nfor i in range(0,k):\n	d[i] = a[i]\nfor xx in range(2,x+1):\n	d,p = p,d\n	for nn in range(n):\n		m = None\n		for i in range(max(0,nn-k),nn):\n			if p[i] != None:\n				if m == None:\n					m = p[i]\n				else:\n					m = max(m, p[i])\n		if m != None:\n			d[nn] = m + a[nn]\n		else:\n			d[nn] = None\nm = -1\nfor i in range(n-k,n):\n	if d[i] != None:\n		m = max(m, d[i])\nprint(m)
import heapq\n\nn, k = list(map(int, input().split()))\ns = input()\n\nmostRecent = n\nbest = []\nfor room in range(n-1, -1, -1):\n    if s[room] == '1':\n        mostRecent = room\n    best.append(mostRecent)\n\nbest = best[::-1]\n\ndp = [0]\n\nvals = [(0,0)]\n\nfor room in range(1, n + 1):\n    new = dp[-1] + room\n    if room - k - 1 >= 0:\n        bestRout = best[room - k - 1]\n        if bestRout <= (room - 1):\n            covered = bestRout - k\n\n            if covered >= 0:\n                try:\n                    while len(vals) > 0 and vals[0][1] < covered:\n                        heapq.heappop(vals)\n                    if len(vals) > 0:\n                        add = vals[0][0]\n                        new2 = (bestRout + 1) + add\n                        new = min(new2, new)\n                except Exception:\n                    pass\n            else:\n                new2 = (bestRout + 1)\n                new = min(new2, new)\n\n\n\n    dp.append(new)\n    heapq.heappush(vals, (new, room))\n\nprint(new)\n    \n
S = input()\nT = input()\n\ns = [[] for i in range(26)]\nt = [[] for i in range(26)]\n\nfor i in range(len(S)):\n    s[ord(S[i])-97].append(i)\n    t[ord(T[i])-97].append(i)\n\ns = sorted(s)\nt = sorted(t)\nif s == t:\n    print("Yes")\nelse:\n    print("No")
N, M, X = list(map(int, input().split()))\nA = [0]*N\n\nfor i in range(N):\n    A[i] = list(map(int, input().split()))\n\nmin_sump = -1\nfor i in range(2**(N+1)):\n    sump = 0\n    sume = [0]*M\n    for j in range(N):\n        ns = "0" + str(N) +"b"\n        bi = format(i,ns)\n        if bi[-1-j] == "1":\n            sump += A[j][0]\n            sume = list(map(sum, zip(sume, A[j][1:])))\n    if all([i >= X for i in sume]):\n        if min_sump == -1:\n            min_sump = sump\n        else:\n            min_sump = min(min_sump,sump)\n\nprint(min_sump)
import sys\nsys.setrecursionlimit(10 ** 6)\n\nD,G=map(int,input().split())\np=[]\nc=[]\nfor i in range(D):\n  a,b=map(int,input().split())\n  p += [a]\n  c += [b]\n\ndef solve(bit):\n  if bit >= (1<<D):\n    return 1000\n  p_sum=0\n  num=0\n  for i in range(D):\n    if bit & (1<<i):\n      p_sum += c[i] + p[i] * 100*(i+1)\n      num += p[i]\n  if p_sum >= G:\n    return min(num,solve(bit+1))\n  else:\n    for i in reversed(range(D)):\n      if bit & 1<<i:\n        continue\n      for j in range(p[i]):\n        if p_sum >= G:\n          break\n        p_sum += 100*(i+1)\n        num += 1\n      else:\n        return solve(bit+1)\n    return min(num,solve(bit+1))\n\nprint(solve(0))
n=int(input())\narr=list(map(int,input().split()))\narr1=[]\narr2=[]\ncount1=0\ncount2=0\nfor i in range(n):\n	if(i%2==0):\n		count1+=arr[i]\n	else:\n		count2+=arr[i]\nans=0\ntemp1=0\ntemp2=0\nfor i in range(n):\n	if(i%2==0):\n		val1=temp1+count2-temp2\n		val2=temp2+count1-temp1-arr[i]\n		if(val1==val2):\n			ans+=1\n		temp1+=arr[i]\n	else:\n		val1=temp1+count2-temp2-arr[i]\n		val2=temp2+count1-temp1\n		if(val1==val2):\n			ans+=1\n		temp2+=arr[i]\nprint(ans)\n
n, k, x = list(map(int, input().split()))\na = [None] + list(map(int, input().split()))\n\nlo, hi = 0, 10 ** 9 * 5000\nq = [None] * (n + 1)\n\ndef get(mid):\n    f, r = 0, 0\n    q[0] = 0, 0, 0\n    for i in range(1, n + 1):\n        if q[r][2] == i - k - 1: r += 1\n        cur = q[r][0] + a[i] - mid, q[r][1] + 1, i\n        while r <= f and q[f] <= cur: f -= 1\n        f += 1\n        q[f] = cur\n    if q[r][2] == n - k: r += 1\n    return q[r]\n\nwhile lo < hi:\n    mid = (lo + hi + 1) >> 1\n    _, cnt, _ = get(mid)\n    if cnt >= x:\n        lo = mid\n    else:\n        hi = mid - 1\n\nsm, _, _ = get(lo)\nans = max(-1, sm + x * lo)\nprint(ans)\n
N=int(input())\n\nans ="No"\nfor i in range(N//4+1):\n	for j in range(N//7+1):\n		if 4*i + 7*j == N:\n			ans = "Yes"\n		    \nprint(ans)
import sys\n# import math\n# import bisect\n# import numpy as np\n# from decimal import Decimal\n# from numba import njit, i8, u1, b1 #JIT compiler\n# from itertools import combinations, product\n# from collections import Counter, deque, defaultdict\n\n# sys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\nINF = 10 ** 9\nPI = 3.14159265358979323846\n\ndef read_str():      return sys.stdin.readline().strip()\ndef read_int():      return int(sys.stdin.readline().strip())\ndef read_ints():     return map(int, sys.stdin.readline().strip().split())\ndef read_ints2(x):   return map(lambda num: int(num) - x, sys.stdin.readline().strip().split())\ndef read_str_list(): return list(sys.stdin.readline().strip().split())\ndef read_int_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef GCD(a: int, b: int) -> int: return b if a%b==0 else GCD(b, a%b)\ndef LCM(a: int, b: int) -> int: return (a * b) // GCD(a, b)\n\ndef solve(info):\n    for Cx in range(101):\n        for Cy in range(101):\n            height = abs(Cx - info[0][0]) + abs(Cy - info[0][1]) + info[0][2]\n            flag = True\n            for x,y,h in info[1:]:\n                val = max(height - abs(Cx - x) - abs(Cy - y), 0)\n                if h == val:\n                    continue\n                else:\n                    flag = False\n                    break\n            if flag:\n                return Cx, Cy, height\n\ndef Main():\n    n = read_int()\n    info = [tuple(read_ints()) for _ in range(n)]\n    info.sort(key=lambda x: x[2], reverse=True)\n\n    print(*solve(info))\n\ndef __starting_point():\n    Main()\n__starting_point()
s=input();n=len(s)-1;print(sum(s[i]!=s[n-i]for i in range(n+1))//2)
import sys\n \nn = int(input())\n \nfor a in range(1,10):\n    if n % a == 0 and n // a <= 9:\n        print("Yes")\n        return\nprint("No")
n = int(input())\nl = list(map(int,input().split()))\ncnt = 0\nfor i in range(0,n-2):\n    for j in range(i+1,n-1):\n        for k in range(j+1,n):\n            x = [l[i],l[j],l[k]]\n            ma = sorted(x)[2]\n            _ma = sorted(x)[0] + sorted(x)[1]\n            if l[i] != l[j] and l[i] != l[k] and l[j] != l[k] and ma < _ma:\n                cnt += 1\nprint(cnt)
a,b = map(int,input().split())\nprint(a*b if a < 10 and b < 10 else -1)
# -*- coding: utf-8 -*-\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    x = sorted(list(map(int, input().split())))\n    diff = list()\n\n    for i, j in zip(x, x[1:]):\n        diff.append(abs(i - j))\n\n    diff = sorted(diff, reverse=True)\n    print((sum(diff) - sum(diff[:n - 1])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
import sys\nimport os\n\nclass Path():\n    def __init__(self, idx, s, d):\n        self.idx = idx\n        self.s = s\n        self.d = d\n\n    def __eq__(self, rhs):\n        return self.s == rhs.s and self.d == rhs.d\n\n    def __hash__(self):\n        return self.s * 100000 + self.d\n\ndef shortestPath(n, k, paths):\n    ps = dict()\n    for p in paths:\n        if p.s not in ps:\n            ps[p.s] = [p]\n        else:\n            ps[p.s].append(p)\n\n        if p.d not in ps:\n            ps[p.d] = [p]\n        else:\n            ps[p.d].append(p)\n\n    d = set()\n    open = set()\n\n    d.add(1)\n    for e in paths:\n        if e.s == 1 or e.d == 1:\n            open.add(e)\n\n    general_edges = []\n    general_choices = []\n    while len(d) < n:\n        newd = set()\n        choices = dict()\n        for e in open:\n            oe = e.s\n            if e.s in d:\n                oe = e.d\n\n            newd.add(oe)\n\n            if oe not in choices:\n                choices[oe] = [e.idx]\n            else:\n                choices[oe].append(e.idx)\n\n        d.update(newd)\n        for oe, p in choices.items():\n            if len(p) > 1:\n                general_choices.append(p)\n            else:\n                general_edges.append(p[0])\n\n        open = set()\n        for node in newd:\n            for p in ps[node]:\n                if (p.s in d) != (p.d in d):\n                    open.add(p)\n\n    maxk = 1\n    for choice in general_choices:\n        maxk *= len(choice)\n\n    k = min(k, maxk)\n    print(k)\n    output = ['0'] * len(paths)\n    for e in general_edges:\n        output[e] = '1'\n    for e in general_choices:\n        output[e[0]] = '1'\n\n    for i in range(k):\n        print(''.join(output))\n\n        for choice in general_choices:\n            done = False\n            for i in range(len(choice) - 1):\n                if output[choice[i]] == '1':\n                    output[choice[i]] = '0'\n                    output[choice[i + 1]] = '1'\n                    done = True\n                    break\n\n            if done:\n                break\n\n            output[choice[len(choice) - 1]] = '0'\n            output[choice[0]] = '1'\n\ndef main():\n    n, m, k = (int(x) for x in input().split())\n    paths = []\n    for i in range(m):\n        path = [int(x) for x in input().split()]\n        paths.append(Path(i, path[0], path[1]))\n    shortestPath(n, k, paths)\n\ndef __starting_point():\n    main()\n__starting_point()
n = int(input())\na = list(map(int, input().split()))\nq = (10 ** 6) * [-1]\npnt = -1\nans = "YES"\nfor i in range(n):\n    if pnt == -1:\n        pnt += 1\n        q[pnt] = a[i]\n    else :\n        if q[pnt] == a[i] or abs(q[pnt] - a[i]) % 2 == 0:\n            q[pnt] = -1\n            pnt -= 1\n        else:\n            pnt += 1\n            q[pnt] = a[i]\nif pnt > 0 :\n    ans = "NO"\nprint(ans)\n        \n
H, n = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\nt = 0\nmiPt = H\nfor a in d:\n  t += 1\n  H += a\n  miPt = min(miPt, H)\n  if H <= 0:\n    print(t)\n    return\n\nif sum(d) >= 0:\n  print(-1)\n  return\n\njump = max(0, miPt // -sum(d) - 2)\nH -= jump * -sum(d)\nt += n * jump\nfor i in range(100000000000000000):\n  t += 1\n  H += d[i % n]\n  if H <= 0:\n    print(t)\n    return\n
n = int(input())\ns = input()\na = [[0] * 26 for _ in range(26)]\nfor i in range(n -1):\n    a[ord(s[i]) - ord('A')][ord(s[i + 1]) - ord('A')] += 1\n\nmx = -1\n\nfor i in range(26):\n    for j in range(26):\n        if a[i][j] > mx:\n            mx = a[i][j]\n            ans = chr(i + ord('A')) + chr(j + ord('A'))\n\nprint(ans)\n
s = input()[::-1]\nt = input()[::-1]\ni = 0\nwhile i < min(len(s),len(t)) and s[i] == t[i]:\n    i += 1\nprint(len(s) - i + len(t) - i)\n
from fractions import gcd\nfrom functools import reduce\n\nn, x = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\nprint((reduce(gcd, [abs(i-x) for i in c])))\n
s = input()\n\n\ndef is_palinedrome(st):\n    for i in range(len(st)//2):\n        if st[i] != st[-(i+1)]:\n            return False\n    return True\n\n\ns_pali = is_palinedrome(s)\nsub_pali_left = is_palinedrome(s[:len(s)//2])\nsub_pali_right = is_palinedrome(s[len(s)//2+1:])\n\nif s_pali and sub_pali_left and sub_pali_right:\n    print('Yes')\nelse:\n    print('No')\n
a, b = input().split()\na = int(a)\nb1, b2 = b.split('.')\nb3 = int(b1)*100 + int(b2)\n\nprint((a*b3//100))\n
t = int(input())\nfor i in range(t):\n	n = int(input())\n	print((n-1)//2)\n
\nfrom queue import Queue\nfrom random import shuffle\nimport sys\nimport math\nimport os.path\n\n\nsys.setrecursionlimit(100000)\n\n# LOG\n\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\n# INPUT\n\ndef ni():\n    return map(int, input().split())\n\n\ndef nio(offset):\n    return map(lambda x: int(x) + offset, input().split())\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n\n# CONVERT\ndef toString(aList, sep=" "):\n    return sep.join(str(x) for x in aList)\n\n\ndef toMapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\n\n# SORT\ndef sortId(arr):\n    return sorted(range(len(arr)), key=lambda k: arr[k])\n\n\n# MAIN\n\nn,m,s = ni()\n\ns -= 1\n\nadj = [[] for _ in range(n)]\n\nfor i in range(m):\n    u,v = nio(-1)\n    if (v != s):\n        adj[u].append(v)\n\nstack = []\n\nvisited= [False]*n\n\ndef dfs(x):\n    nonlocal visited\n    nonlocal stack\n    visited[x] = True\n    for y in adj[x]:\n        if not visited[y]:\n            dfs(y)\n\n    stack.append(x)\n\n\nfor i in range(n):\n    if not visited[i]:\n        dfs(i)\n\n# log(adj)\n# log(visited)\n# log(stack)\n\ncount = -1\n\ndef loang(x):\n    nonlocal visited\n    visited[x] = False\n    for y in adj[x]:\n        if visited[y]:\n            loang(y)\n\n\nfor x in stack[::-1]:\n    if visited[x]:\n        count += 1\n        loang(x)\n\nprint(count)
n=int(input())\narr=list(map(int,input().split()))\narr=sorted(arr)\ns=set()\nfor val in arr:\n  if val!=1 and val-1 not in s:\n      s.add(val-1)\n  elif val not in s:\n    s.add(val)\n  elif val+1 not in s:\n    s.add(val+1)\nprint(len(s))
import bisect\n\nn,m = map(int,input().split())\n\nQ = []\nP = [[] for _ in range(n)]\nfor i in range(m):\n    p,y = map(int,input().split())\n    Q.append([p,y])\n    P[p-1].append(y)\n\nP_1 = [sorted(l) for l in P]\n\nfor p,y in Q:\n    a = str(p).zfill(6)\n    b = str(bisect.bisect(P_1[p-1], y)).zfill(6)\n    print(a+b)
N = int(input())\nA = list(map(int,input().split()))\nA_list = [float('inf')] * N\n\nans = min(A)\nwhile max(A_list) > 0:\n    mi = ans\n    for i,a in enumerate(A):\n        amari = a % mi\n        A_list[i] = amari\n        if amari != 0:\n            ans = min(ans,amari)\n\nprint(ans)
"""\nCodeforces April Fools Contest 2014 Problem I\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n"""\n\nclass InputHandlerObject(object):\n    inputs = []\n\n    def getInput(self, n = 0):\n        res = ""\n        inputs = self.inputs\n        if not inputs: inputs.extend(input().split(" "))\n        if n == 0:\n            res = inputs[:]\n            inputs[:] = []\n        while n > len(inputs):\n            inputs.extend(input().split(" "))\n        if n > 0:\n            res = inputs[:n]\n            inputs[:n] = []\n        return res\nInputHandler = InputHandlerObject()\ng = InputHandler.getInput\n\n############################## SOLUTION ##############################\n\n# ?(_/____+_______*__-_____*______-___):-__<___,___<____,____<_____,_____<______,______<_______.\n\ngolorp = input().split(":-")\ngolorp[0] = golorp[0][2:]\n\nct = 0\njaws = []\nfor x in range(len(golorp[0])):\n    if golorp[0][x] == "_":\n        ct += 1\n    else:\n        jaws.append(ct)\n        ct = 0\n\nct = 0\nconditionsraw = []\nfor x in range(len(golorp[1])):\n    if golorp[1][x] == "_":\n        ct += 1\n    else:\n        conditionsraw.append(ct)\n        conditionsraw.append(golorp[1][x])\n        ct = 0\n\nconditions = []\nfor x in range(0, len(conditionsraw)//4):\n    if conditionsraw[4*x+1] == ">":\n        conditions.append((conditionsraw[4*x+2], conditionsraw[4*x]))\n    else:\n        conditions.append((conditionsraw[4*x], conditionsraw[4*x+2]))\n\ninedges = [[-1]] * (max(jaws) + 1)\noutedges = [[-1]] * (max(jaws) + 1)\nval = [-1] * (max(jaws) + 1)\nprocessed = [False] * (max(jaws) + 1)\nfor x in jaws:\n    inedges[x] = []\n    outedges[x] = []\n\nfor x, y in conditions:\n    inedges[y].append(x)\n    outedges[x].append(y)\n\nfor i in range(10):\n    for x in jaws:\n        if not inedges[x] and not processed[x]:\n            val[x] += 1\n            processed[x] = True\n            for y in outedges[x]:\n                val[y] = max(val[y], val[x])\n                inedges[y].remove(x)\n\nfailure = False\nfor x in jaws:\n    if not processed[x] or val[x] > 9:\n        failure = True\n        break\n\nif failure:\n    print("false")\nelse:\n    s = ""\n    for x in jaws:\n        s += str(val[x])\n    print(s)
from collections import*\nn, m, k = map(int, input().split())\nb = [[int(v) for v in input().split()] for _ in range(n)]\nif m < n:\n    a = [[b[j][i] for j in range(n)] for i in range(m)]\n    b = a\n    m, n = n, m\ncntrs = [Counter() for _ in range(n)]\nd = (n + m-1) // 2\nfor i in range(1<<d):\n    ones = bin(i).count('1')\n    z = d - ones\n    if ones >= n or z >= m: continue\n    xor = b[0][0]\n    x, y = 0, 0\n    for j in range(d):\n        if i&(1<<j):\n            x += 1\n        else:\n            y += 1\n        xor ^= b[x][y]\n    cntrs[x][xor] += 1\nsm = 0\nsleft = n + m - 2 - d\nfor i in range(1<<sleft):\n    ones = bin(i).count('1')\n    z = sleft - ones\n    if ones >= n or z >= m: continue\n    xor = b[n-1][m-1]\n    x, y = n-1, m-1\n    for j in range(sleft):\n        if i&(1<<j):\n            x -= 1\n        else:\n            y -= 1\n        xor ^= b[x][y]\n    xor ^= b[x][y] ^ k\n    sm += cntrs[x][xor]\nprint(sm)
n = int(input())\ns = input()\nfor d in range(1, n+1):\n    if n%d == 0:\n        t1 = s[:d]\n        t2 = s[d:]\n        s = t1[::-1] + t2\nprint(s)
a,                   b = map(int,input().split())\nprint(a+b)
import re\n\ns = input()\nops = re.split('([+-])', s)\nassert len(ops) % 2 == 1\nops = ['+'] + ops\n\ntotal = 0\nfor i in range(0, len(ops), 2):\n    if ops[i] == '+':\n        total += int(ops[i+1])\n    elif ops[i] == '-':\n        total -= int(ops[i+1])\n    else:\n        assert False\n\nfor b in bytes(str(total), 'ascii'):\n    print('+' * b + '.>')\n
l = [0]\n\ndef count(size):\n    nums = (10**size - 10**(size - 1))\n    small =  l[size-1] + size\n    large = l[size-1] + nums * size\n    if len(l) <= size:\n        l.append(large)\n    return (nums * (small + large))//2\n\ndef test(minSize, size, val):\n    out = minSize * val + size * ((val + 1) * val)//2\n    return out\n\nq = int(input())\nfor _ in range(q):\n    want = int(input())\n\n    size = 1\n    while want > count(size):\n        want -= count(size)\n        size += 1\n\n    minSize = l[size - 1]\n\n    lo = 0 #Impossible\n    hi = (10**size - 10**(size - 1)) #Possible\n\n    while hi - lo > 1:\n        testV = (lo + hi) // 2\n        out = test(minSize, size, testV)\n\n        if out < want:\n            lo = testV\n        else:\n            hi = testV\n\n    want -= test(minSize, size, lo)\n\n    newS = 1\n    while 9 * (10**(newS - 1)) * newS < want:\n        want -= 9 * (10**(newS - 1)) * newS\n        newS += 1\n\n    want -= 1\n\n    more = want//newS\n    dig = want % newS\n    value = 10**(newS - 1) + more\n    print(str(value)[dig])\n\n    \n
def readinput():\n    n=int(input())\n    return n\n\ndef main(n):\n    stock=[]\n    for _ in range(10):\n        stock.append([])\n\n    stock[0].append('')\n    for m in range(1,10):\n        for i in range(len(stock[m-1])):\n            stock[m].append(stock[m-1][i]+'3')\n            stock[m].append(stock[m-1][i]+'5')\n            stock[m].append(stock[m-1][i]+'7')\n    #print(stock)\n    count=0\n    for m in range(3,10):\n        for i in range(len(stock[m])):\n            if int(stock[m][i]) <= n and '3' in stock[m][i] and '5' in stock[m][i] and '7' in stock[m][i]:\n                count+=1\n                #print(stock[m][i])\n    return count\n\ndef __starting_point():\n    n=readinput()\n    ans=main(n)\n    print(ans)\n\n__starting_point()
s = list(input())\n\nans = 0\nfor i in range(1, len(s)):\n  if s[i] == s[i-1]:\n    ans += 1\n    if s[i] == '1':\n      s[i] = '0'\n    else:\n      s[i] = '1'\n    \nprint(ans)
n = int(input())\na = [int(x) for x in input().split()]\n\nflag = True\n\nfor x in a:\n    if x % 2 == 0:\n        if x % 3 and x % 5:\n            flag = False\n\nif flag:\n    print('APPROVED')\nelse:\n    print('DENIED')\n
# 高橋君はタップダンスをすることにしました。タップダンスの動きは文字列 S で表され、 S の各文字は L, R, U, D のいずれかです。\n# 各文字は足を置く位置を表しており、 1 文字目から順番に踏んでいきます。 S が以下の 2 条件を満たすとき、またその時に限り、 S を「踏みやすい」文字列といいます。\n# 奇数文字目がすべて R, U, D のいずれか。 偶数文字目がすべて L, U, D のいずれか。 S が「踏みやすい」文字列なら Yes を、そうでなければ No を出力してください。\n\n\nS = str(input())\n\nif 'L' in S[0::2] or 'R' in S[1::2]:\n        print('No')\n\nelse:\n    print('Yes')
#70 C - Five Transportations\nN = int(input())\nlis = [int(input()) for _ in range(5)]\nmini = min(lis)\ngroup = (N+mini-1)//mini\n\nans = 5 + group - 1\nprint(ans)
n = int(input())\nmod = 10**9 + 7\nall09 = ((2 * 10**n) % mod - (2 * 9**n) % mod) % mod\nof09 = ((10**n) % mod - 8**n % mod) % mod\nprint((all09-of09)%mod)
#!/usr/bin/env python3\nimport sys\nfrom itertools import chain\nimport numpy as np\n\n\ndef solve(X: int):\n    if X <= 2:\n        return 2\n    flags = np.array([True for i in range(3, X + 112, 2)])\n    for i in range(len(flags)):\n        if flags[i]:\n            prime = i * 2 + 3\n            flags[i::prime] = False\n            if prime >= X:\n                return prime\n\n\n\n\ndef main():\n    X = int(input())  # type: int\n    answer = solve(X)\n    print(answer)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n = int(input())\nv = list(map(int, input().split()))\nodd = [0] * (10 ** 5 + 5)\neven = [0] * (10 ** 5 + 5)\nfor i in range(n):\n    if i % 2 == 0:\n        even[v[i]] += 1\n    else:\n        odd[v[i]] += 1\nsum_odd = sum(odd)\nsum_even = sum(even)\nans = sum_odd + sum_even\nmax_odd = max(odd)\nmax_even = max(even)\nif odd.index(max_odd) != even.index(max_even):\n    print(sum_odd + sum_even - max_even - max_odd)\nelse:\n    odd.sort()\n    even.sort()\n    if odd[-1] - odd[-2] > even[-1] - even[-2]:\n        ans -= odd[-1] + even[-2]\n    else:\n        ans -= odd[-2] + even[-1]\n    print(ans)
N,A,B,C = map(int,input().split())\nl = [int(input()) for _ in range(N)]\nans = float("inf")\nfor i in range(4**N):\n    a,b,c = [],[],[]\n    cost = 0\n    for j in range(N):\n        r = (i//(4**j)) % 4\n        if r == 1:\n            a.append(l[j])\n        elif r == 2:\n            b.append(l[j])\n        elif r == 3:\n            c.append(l[j])\n    if a and b and c:\n        cost += sum(max((len(x)-1), 0)*10 for x in [a,b,c])\n        a = sum(a)\n        b = sum(b)\n        c = sum(c)\n        cost += sum(abs(x-y) for x,y in [(a,A),(b,B),(c,C)])\n        ans = min(ans, cost)\nprint(ans)
n = int(input())\ns = list(input())\nfor a in range(len(s)):\n    s[a] = chr(ord(s[a]) + n)\n    if ord(s[a])>90:\n        s[a] = chr(ord(s[a])-26)\nc=s[0]\nfor b in range(len(s)-1):\n    c = c + s[b+1]\nprint(c)
#!/usr/bin/env python\nfrom collections import Counter\nfrom math import sqrt\nm = 2750131 + 100\n\nf = list(range(m))\n\nfor d in range(2, int(sqrt(m)) + 10):\n    if f[d] == d:\n        i, k = 2, d << 1\n        while k < m:\n            if f[k] == k:\n                f[k] = i\n            k += d\n            i += 1\n\nnp = list(range(m))\nc = 1\nfor i in range(2, m):\n    if f[i] == i:\n        np[i] = c\n        c += 1\n\nn = int(input())\nb = sorted(list(map(int, input().split())), reverse=True)\nd = Counter(b)\na = []\ni, la = 0, 0\nwhile la < n:\n    if d[b[i]] > 0:\n        la += 1\n        if f[b[i]] == b[i]:\n            a.append(np[b[i]])\n            d[b[i]] -= 1\n            d[np[b[i]]] -= 1\n        else:\n            a.append(b[i])\n            d[b[i]] -= 1\n            d[f[b[i]]] -= 1\n    i += 1\nprint(*a)\n
IN = input\nrint = lambda: int(IN())\nrmint = lambda: map(int, IN().split())\nrlist = lambda: list(rmint())\n\nn, k = rmint()\npr = [i for i in range(-1, n - 1)]\nnx = [i for i in range(+1, n + 1)]\nans = [0] * n\np = [0] * n\ni = 0\nfor g in rlist():\n    p[n-(g-1)-1] = i\n    i += 1\n\n\ndef dl(x, t):\n    ans[x] = t\n    if nx[x] < n: pr[nx[x]] = pr[x]\n    if pr[x] >= 0: nx[pr[x]] = nx[x]\n\n\nt = 1\nfor c in p:\n    #print(ans)\n    #print(pr)\n    #print(nx)\n    if ans[c]: continue\n    dl(c, t)\n    j = pr[c]\n    for i in range(k):\n        if j < 0: break\n        dl(j, t)\n        j = pr[j]\n    j = nx[c]\n    for i in range(k):\n        if j >= n: break\n        dl(j, t)\n        j = nx[j]\n    t = 3 - t\nfor o in ans: print(o, end='')\n
mod = 998244353\n\nn = int(input())\n\na = list(map(int, input().split()))\n\nd = {}\n\nfor i in range(n):\n	if a[i] not in d:\n		d[a[i]] = (i, i)\n	else:\n		d[a[i]] = (d[a[i]][0], i)\n\nd2 = {}\n\nfor k, v in list(d.items()):\n	if v[0] != v[1]:\n		d2[k] = v\n\nactive, ans = 0, 1\n\nfor i in range(n - 1):\n	if a[i] in d2:\n		if i == d2[a[i]][0]:\n			active += 1\n		if i == d2[a[i]][1]:\n			active -= 1\n	if active == 0:\n		ans = (ans * 2) % mod\n\nprint(ans)\n
from collections import defaultdict\nmaxn = 2000000000\n\nmk = []\nbs = 1\n\nwhile bs <= maxn:\n    mk.append(bs)\n    bs *= 2\n\nn = int(input())\nls = [int(i) for i in input().split()]\n\ndic = defaultdict(int)\nfor i in ls:\n    dic[i] += 1\n\ncnt = 0\nfor i in ls:\n    dic[i] -= 1\n    flag = False\n    for j in mk:\n        if dic[j - i] > 0:\n            flag = True\n            break\n\n    if not flag:\n        cnt += 1\n    dic[i] += 1\n\nprint(cnt)\n
s =input()\n\nfrom collections import Counter\ncount = Counter(s)\nc0 = count["0"]\nc1 = count["1"]\n\nprint(min(c0,c1)*2)
n,m = map(int,input().split())\n\nmin_i = 1\nmax_i = n\n\nfor i in range(m):\n    l,r = map(int,input().split())\n    min_i = max(min_i,l)\n    max_i = min(max_i,r)\n\nif max_i-min_i>=0:\n    print(max_i-min_i+1)\nelse:\n    print(0)
n = int(input())\nh = list(map(int, input().split()))\nres = 0\n\nwhile True:\n    if sum(h) == 0:\n        break\n\n    i = 0\n    while i < n:\n        if h[i] == 0:\n            i += 1\n        else:\n            res += 1\n            while i < n and h[i] > 0:\n                h[i] -= 1\n                i += 1\n\nprint(res)\n
stops, cap = map(int,input().split())\n\na = list(map(int,input().split()))\n\nstart_max = cap\nstart_min = 0\n\ncurrent = 0\nfor x in a:\n    current += x\n    start_max = min(cap-current, start_max)\n    start_min = max(start_min,-current)\n    if abs(current) > cap:\n        print (0)\n        break\nelse:\n    if start_max<start_min:\n        print (0)\n    else:\n        print (start_max-start_min + 1)
def powof3(x):\n    ans=0\n    while(x%3==0):\n        x=x//3\n        ans+=1\n    return ans\n\n\nn=int(input())\na=list(map(int,input().split()))\nfor i in range(n):\n    a[i]=[-1*powof3(a[i]),a[i]]\na.sort()\nfor i in range(n):\n    a[i]=a[i][1]\nprint(*a)
n = int(input())\npoints = set(int(x) for x in input().strip().split())\npowers = [2**i for i in range(31)]\n\nfor point in points:\n    for power in powers:\n        if point + power in points and point + power + power in points:\n            print(3)\n            print(point, point + power, point + power + power)\n            return\n\nfor point in points:\n    for power in powers:\n        if point + power in points:\n            print(2)\n            print(point, point + power)\n            return\n\nprint(1)\nprint(points.pop())\n
A,B,K = map(int,input().split())\nif A >= K:\n    print(A-K,B)\nelif K-A<B:\n    print(0,B-(K-A))\nelse:\n    print(0,0)
X = int(input())\n\ndeposit = 100\ny_later = 0\n\nwhile deposit < X:\n    y_later += 1\n    deposit += deposit // 100\n\nprint(y_later)
import math\nK = int(input())\nrst = 0\nfor i in range(1, K + 1):\n    for j in range(1, K + 1):\n        tmp = math.gcd(i, j)\n        for k in range(1, K + 1):\n            rst += math.gcd(tmp, k)\nprint(rst)
N = int(input())\na = list(map(int,input().split()))\naa = []\nfor i in a:\n    aa.append(i-1)\nprint(sum(aa))
num = input()\n\ncnt = 0\nfor _ in range(int(num)):\n  a = input()\n  b = list(a)\n  if b[0] == b[2]:\n    cnt += 1\n    if cnt >= 3:\n      print('Yes')\n      break\n  else:\n    cnt = 0\n\nif cnt <= 2:\n  print('No')\n\n
r=int(input())\nprint(r**2)
_n = input()\nlines = list(map(int, input().split()))\nlines.sort()\nlongest = lines.pop()\nif sum(lines) > longest:\n  print("Yes")\nelse:\n  print("No")
N, M = map(int, input().split())\nSC = [list(map(int, input().split())) for _ in range(M)]\nfor n in range(10**N):\n    n = str(n)\n    if len(n) != N:\n        continue\n    if all([n[SC[i][0]-1] == str(SC[i][1]) for i in range(M)]):\n        print(n)\n        return\n\nprint(-1)
n,k = map(int,input().split())\n\ncnt1,cnt2 = 0,0\nif k%2 == 1:\n    for i in range(1,n+1):\n        if i%k == 0:\n            cnt1 +=1\n    print(cnt1**3)\nelse:\n    for i in range(1,n+1):\n        if  i%k == k//2:\n            cnt2 += 1\n    for i in range(1,n+1):\n        if i%k == 0:\n            cnt1 +=1\n    print(cnt1**3+cnt2**3)
from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf,comb\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\n\nn = INT()\n\nif n == 0:\n    print(0)\n    return\n\nans = deque()\ni = 0\nwhile n != 0:\n    tmp = ( n % 2**(i+1) ) // 2**i\n    ans.appendleft(tmp)\n    n -= tmp * (-2)**i\n    i += 1\nprint(*list(ans),sep="")
N,M=map(int, input().split())\nAB=sorted([list(map(int, input().split())) for _ in range(N)])\n\ncnt=0\ngokei=0\nfor ab in AB:\n	if M-cnt>ab[1]:\n		gokei+=ab[1]*ab[0]\n		cnt+=ab[1]\n	else:\n		gokei+=(M-cnt)*ab[0]\n		cnt+=M-cnt\n	\n	if cnt==M:\n		print(gokei)\n		return
N = int(input())\nH = [int(i) for i in input().split()]\ncount = 0\nans = 0\nfor i in range(N-1):\n    if(H[i] >= H[i+1]):\n        count += 1\n    else:\n        ans = max(ans,count)\n        count = 0\nprint(max(ans,count))
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nfrom collections import defaultdict\nfrom collections import deque\nimport math\nimport copy\n \n#T = int(input())\n#N = int(input())\n#s1 = input()\n#s2 = input()\nN,K = [int(x) for x in stdin.readline().split()]\narr = [int(x) for x in stdin.readline().split()]\narr.sort()\n\nfreq = {}\n\nfor i in range(N):\n    num = arr[i]\n    if num not in freq:\n        freq[num] = []\n        \n    round = 0\n    freq[num].append(0)\n    while num!=0:\n        round += 1\n        num = num//2\n        if num not in freq:\n            freq[num] = []\n            \n        freq[num].append(round)\n\nres = 999999999999\nfor key in freq:\n    if len(freq[key])<K:\n        continue\n    else:\n        s = sum(freq[key][:K])\n        res = min(res,s)\n        \nprint(res)\n        \n
#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == "\n":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    n,k = LI()\n    a = LI()\n    a.sort()\n    d = defaultdict(lambda : 0)\n    c = defaultdict(lambda : 0)\n    s = [0]\n    for i in a:\n        d[i] += i\n        c[i] += 1\n        s.append(s[-1]+i)\n    ans = float("inf")\n    p = -1\n    for i in a:\n        if i == p:\n            continue\n        if k <= c[i]:\n            ans = 0\n            break\n        l,r = bisect.bisect_left(a,i),bisect.bisect_right(a,i)\n        m = r\n        if m >= k:\n            ns = l*(i-1)-s[l]\n            su = ns+k-c[i]\n            if su < ans:\n                ans = su\n        m = n-l\n        if m >= k:\n            ns = s[n]-s[r]-(n-r)*(i+1)\n            su = ns+k-c[i]\n            if su < ans:\n                ans = su\n        ns = s[n]-s[r]-(n-r)*(i+1)+l*(i-1)-s[l]\n        su = ns+k-c[i]\n        if su < ans:\n            ans = su\n        p = i\n    print(ans)\n    return\n\n#Solve\ndef __starting_point():\n    solve()\n\n__starting_point()
q = int(input())\nfor i in range(q):\n	n, a, b = list(map(int, input().split()))\n	if n % 2 == 0:\n		print(min(n * a, n // 2 * b))\n	else:\n		print(min(n * a, (n // 2) * b + a))\n
import itertools\nimport bisect\n\nn, x = map(int, input().split())\nl = list(map(int, input().split()))\n\na = list(itertools.accumulate(l, initial=0))\nprint(bisect.bisect_right(a, x))
import collections\nn = int(input())\nwords = [input() for _ in range(n)]\nok = True\nfor i in range(n-1):\n    if words[i][-1] != words[i+1][0]:\n        ok = False\ncount = collections.Counter(words)\nfor i in count.values():\n    if i != 1:\n        ok = False\nprint("Yes" if ok else "No")
import math\na,b = list(map(int,input().split()))\n\ndef lcm(x,y):\n    return (x * y) // math.gcd(x, y)\n\nprint((lcm(a,b)))\n\n
S = input()\n\nl = len(S)\n\nprint("x" * l)
n = int(input())\nhl = list(map(int, input().split()))\nflg = True\n\nhmax = hl[0]\nfor h in hl:\n    hmax = max(hmax, h)\n    if h >= hmax-1:\n        continue\n    else:\n        flg = False\n\nif flg:\n    print('Yes')\nelse:\n    print('No')
n,m,c=map(int,input().split())\nb=list(map(int,input().split()))\nr=0\nfor _ in range(n):\n  a=list(map(int,input().split()))\n  d=0\n  for jj in range(m):\n    d+=a[jj]*b[jj]\n  if d+c>0:\n    r+=1\nprint(r)
n = int(input())\nprint(((1000 - n % 1000) % 1000))\n
# -*- coding: utf-8 -*-\n"""\nCreated on Thu Sep 10 11:20:10 2020\n\n@author: liang\n"""\n\nN = int(input())\nA = [int(i) for i in input().split()]\nB = [int(i) for i in input().split()]\n\nans = 0\nfor i in range(N):\n    ans += min(B[i], A[i]+A[i+1])\n    if B[i] > A[i]:\n        A[i+1] -= B[i] - A[i]\n    if A[i+1] < 0:\n        A[i+1] = 0\nprint(ans)
def readinput():\n    n,m,x,y=list(map(int,input().split()))\n    xx=list(map(int,input().split()))\n    yy=list(map(int,input().split()))\n    return n,m,x,y,xx,yy\n\ndef main(n,m,x,y,xx,yy):\n    xx.append(x)\n    yy.append(y)\n    xx.sort()\n    yy.sort()\n    if xx[-1]<yy[0]:\n        return 'No War'\n    else:\n        return 'War'\n\ndef __starting_point():\n    n,m,x,y,xx,yy=readinput()\n    ans=main(n,m,x,y,xx,yy)\n    print(ans)\n\n__starting_point()
\nimport math\nfrom functools import reduce\n\nurl = "https://atcoder.jp//contests/abc070/tasks/abc070_c"\n\ndef lcm_base(x, y):\n    return (x * y) // math.gcd(x, y)\n\ndef lcm(*numbers):\n    return reduce(lcm_base, numbers, 1)\n\ndef main():\n    count = int(input())\n    clocks = []\n    for i in range(count):\n        clocks.append(int(input()))\n    print((lcm(*clocks)))\n\ndef __starting_point():\n    main()\n\n__starting_point()
n = int(input())\nw = list(map(int,input().split()))\n# s1とs2の差の絶対値をリスト化\ndifference_list = []\n# １からｎまでリストに入れて、i番目までとi番目からの合計の差をscoreに代入 \nfor i in range(n):\n    score = abs(sum(w[:i])-sum(w[i:]))\n    # scoreの値をdifference_listに追加\n    difference_list.append(score)\n# difference_listの最小値を出力\nprint(min(difference_list))
import sys\ninput = sys.stdin.readline\n\nn, m = list(map(int, input().split()))\narr = [[] for i in range(m)]\n\nfor _ in range(n):\n    l = list(map(int, input().split()))\n    for i in range(m):\n        arr[i].append(l[i])\n\nout = 0\nfor i in range(m):\n    l = arr[i]\n    \n    best = list(range(0, -n, -1))\n    for j in range(n):\n        v = l[j] - i - 1\n        \n        if v % m == 0:\n            correct = v // m\n            if 0 <= correct < n:\n                best[j - correct] += 1\n    out += (n - max(best))\n\nprint(out)\n
def solve():\n    n = int(input())\n    A = [int(k) for k in input().split()]\n    \n    A.sort()\n    \n    ans = 0\n    \n    for i in range(0,n,2):\n        ans += (A[i+1] - A[i])\n        \n    print (ans)\n    \nsolve()
n = int(input())\na = list(map(int, input().split()))\nb = []\nfor i in range(len(a)):\n    b.append(a[i])\nfor i in range(len(a)):\n    b.append(a[i])\nq = 0\nr = set()\nfor i in b:\n    if i:\n        q += 1\n    else:\n        r.add(q)\n        q = 0\nprint(max(r))
\n# arr = [\n# 1, # 1\n# 0,\n# 0,\n# 1, # think so\n# 1, # not sure\n# 0, # not sure\n# 0, # 2\n# 1,\n# 1, # think so\n# 1,\n# 0,\n# 0,\n# 1,\n# 0,\n# 1,\n# 0,\n# ]\n\narr = [\n1, # 1\n0,\n0,\n1, # think so\n0, # not sure\n1, # not sure\n0, # 2\n1,\n1, # think so\n1,\n0,\n0,\n1,\n0,\n1,\n0,\n]\n\nn = int(input()) - 1\nprint(arr[n])\n\n# assert n in {1, 7} or n <= \n\n
# python3\n\n\ndef main():\n    n = int(input())\n\n    hard, soft = 0, 0\n    while n:\n        n -= 1\n        if input().split()[1] == "hard":\n            hard += 1\n        else:\n            soft += 1\n\n    if hard < soft:\n        hard, soft = soft, hard\n\n    assert soft <= hard\n    side = 1\n    while side ** 2 / 2 < soft or side ** 2 / 2 + (side & 1) < hard:\n        side += 1\n\n    print(side)\n\n\nmain()\n
# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n# input = io.StringIO(os.read(0, os.fstat(0).st_size).decode()).readline\nii = lambda:int(input())\nkk=lambda:map(int,input().split())\n# k2=lambda:map(lambda x:int(x)-1, input().split())\nll=lambda:list(kk())\nn = ii()\n\nparents, rank = [-1]*n, [0]*n\nloc = [i for i in range(n)]\ndef findParent(x):\n	stack = []\n	curr = x\n	while parents[curr] != -1:\n		stack.append(curr)\n		curr = parents[curr]\n	for v in stack:\n		parents[v] = curr\n	return curr\ndef union(x, y):\n	best = None\n	xP, yP = findParent(x), findParent(y)\n	if rank[x] < rank[y]: best=parents[xP] = yP;\n	elif rank[x] > rank[y]: best=parents[yP] = xP\n	else:\n		best=parents[yP] = xP\n		rank[xP]+=1\n	if values[loc[best]] == 0:\n		loc[best] = loc[xP] if yP is best else loc[yP]\n\na = kk()\nvalues = [0]*n\ntbp=[]\nfor x in kk(): values[x]+=1\nfor i in range(n):\n	if values[i] == 0: union(i, (i+1)%n)\nfor v in a:\n	p = loc[findParent((n-v)%n)]\n\n	tbp.append((v+p)%n)\n	values[p]-=1\n	if values[p] == 0: union(p, (p+1)%n)\nprint(*tbp)
import collections as col\nimport itertools as its\nimport sys\nimport operator\nfrom bisect import bisect_left, bisect_right\nfrom copy import copy, deepcopy\n\n\nclass Solver:\n    def __init__(self):\n        pass\n    \n    def solve(self):\n        a = int(input())\n        b = int(input())\n        c = int(input())\n        d = int(input())\n        l11 = a ^ b\n        l12 = c | d\n        l13 = b & c\n        l14 = a ^ d\n        l21 = l11 & l12\n        l22 = l13 | l14\n        print(l21 ^ l22)\n\n\ndef __starting_point():\n    s = Solver()\n    s.solve()\n\n__starting_point()
D, T, S=map(int,input().split())\nif D > T*S:\n    print('No')\nelse:\n    print('Yes')
a = list(list(map(int,input().split())) for _ in range(3))\nn = int(input())\nb = list(int(input()) for _ in range(n))\n\nfor i in range(3):\n    for j in range(3):\n        if a[i][j] in b:\n            a[i][j] = 0\n\nfor i in range(3):\n    if a[i][0] == a[i][1] == a[i][2] or a[0][i] == a[1][i] == a[2][i] or a[0][0] == a[1][1] == a[2][2] or a[2][0] == a[1][1] == a[0][2]:\n        print("Yes")\n        break\nelse:\n     print("No")
N,M=map(int,input().split())\nA=list(map(int,input().split()))\nfor i in range(M):\n    N-=A[i]\nif N>=0:\n    print(N)\nelse:\n    print("-1")
D, N = list(map(int, input().split()))\n\nans = 0\nif D == 0:\n    if N % 100 != 0:\n        print(N)\n    else:\n        print((101))\nelif D == 1:\n    if N % 100 != 0:\n        for i in range(N):\n            ans += 100**D\n        print(ans)\n    else:\n        for i in range(N):\n            ans += 100**D\n        print((ans + 100))\nelse:\n    if N % 100 != 0:\n        for i in range(N):\n            ans += 100**D\n        print(ans)\n    else:\n        for i in range(N):\n            ans += 100**D\n        print((ans + 10000))\n
import sys\ninput = sys.stdin.readline # for speed up\n#sys.setrecursionlimit(10**9)\n\nn=int(input())\na=list(map(int,input().split()))\n\nl=[0]*(n+2)\nr=[0]*(n+2)\nl[1]=a[0]\nr[n]=a[n-1]\nimport math \nfor ii in range(1,n):\n  l[ii+1]=math.gcd(l[ii],a[ii])\n  r[n-ii]=math.gcd(r[n-ii+1],a[n-1-ii])\n#print(r)\n#print(l)\nans=0\nfor ii in range(1,n+1):\n  ans=max(ans,math.gcd(l[ii-1],r[ii+1]))\n  #print(l[ii-1],r[ii+1])\nprint(ans)\n
N = int(input())\nA = list(map(int, input().split()))\ndct = dict(enumerate(A))\nad = sorted(dct.items(), key=lambda x:x[1])\nans = []\nfor i in ad:\n    j = i[0] + 1\n    ans.append(j)\na = map(str, ans)\nb = ' '.join(a)\nprint(b)
import math\nA,B,X = map(int,input().split())\ndef Price(N):\n    d = math.floor(math.log10(N))+1\n    return A*N+B*d\nif Price(1) > X:\n    Answer = 0\nelse:\n    lef = 1\n    rig = 10**9\n    for i in range(100):\n        mid = (lef+rig)//2\n        if Price(mid) <= X:\n            Answer = mid\n            lef = mid\n        else:\n            rig = mid\n    if Price(rig) <= X:\n        Answer = rig\nprint(Answer)
n, limit = map(int, input().split())\nlst = list(map(int, input().split()))\ncount = 0\nfor i in range(n):\n    if lst[i] >= limit:\n        count += 1\n\nprint(count)
n, m = map(int, input().split())\na = list(map(int, input().split()))\nget = 0\ncount = 0\n\nfor i in a:\n    get += i\n\nfor i in a:\n    if i*4*m >= get:\n        count += 1\n\nif count >= m:\n    print("Yes")\nelse:\n    print("No")
h,w,k = list(map(int,input().split()))\nc_list = []\nfor i in range(h):\n  c_list.append(list(str(input())))\nh_TF_list = []\nw_TF_list = []\nfor i in range(2**h):\n  p_m_list = [False for i in range(h)]\n  for j in range(h):\n    if ((i >>j) & 1):\n      p_m_list[j] = True\n  h_TF_list.append(p_m_list)\nfor i in range(2**w):\n  p_m_list = [False for i in range(w)]\n  for j in range(w):\n    if ((i >>j) & 1):\n      p_m_list[j] = True\n  w_TF_list.append(p_m_list)\ncount = 0\nfor h_list in h_TF_list:\n  for w_list in w_TF_list:\n    p = 0\n    for i in range(h):\n      for j in range(w):\n        if c_list[i][j] == "#" and h_list[i] == True and w_list[j] == True:\n          p += 1\n    if p == k:\n      count += 1\nprint(count)\n
l, r = list(map(int, input().split()))\n\nif (r-l)//2019 >= 1:\n    print((0))\nelse:\n    ans = float('inf')\n    for i in range(l, r+1):\n        for j in range(l, r+1):\n            if i != j:\n                ans = min(ans, (i*j)%2019)\n\n    print(ans)\n
s = input()\nif s[0] == 'A' and s[2:-1].count('C') == 1 and s.replace('A','').replace('C','').islower():\n    print('AC')\nelse:\n    print('WA')
S = input()\nK = int(input())\n\nif len(S) == 1:\n    print(S)\nelse:\n    flg = False\n    while S[0] == '1':\n        S = S[1:]\n        K -= 1\n\n        if K == 0:\n            print(1)\n            flg = True\n            break\n    \n    if not flg:\n        if S[0] == '2':\n            if K.bit_length() - 1 >= 5000000000000000:\n                print(S[1])\n            else:\n                print(S[0])\n        else:\n            print(S[0])
n = int(input())\np = [int(e) for e in input().split()]\nz = 0\nfor i in range(n):\n  if p[i] != i + 1:\n    z += 1\nif z <= 2:\n  print('YES')\nelse:\n  print('NO')
n=input()\nls=''\nt=0\nfor i in range(len(n)):\n    if int(n[i])%3==0:\n        ls=''\n        t+=1\n    else:\n        ls+=n[i]\n        for j in range(0,len(ls)):\n            if int(ls[j:])%3==0:\n                t+=1\n                ls=''\n                break\nprint(t)\n    \n\n\n\n'''\n////////////////      //////        ///////      //             ///////     //  //   //\n////          //    ///   ///     ///    ///     //            ///  ///     ////     //\n////    ////       ///     ///   ///      ///    //           /////////     ////     ///////\n////     /////    ///       /// ///        ///   //          ///    ///     ////     //   //\n//////////////     ///////////   ///////////     //////     ///     ///     //  //   //   //\n'''\n\n
import collections\nimport math\ninput()\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ncounts = collections.defaultdict(int)\narbitrary = 0\nfor ai, bi in zip(a, b):\n    if ai == 0:\n        if bi == 0:\n            arbitrary += 1\n    else:\n        if bi == 0:\n            counts[(0, 0)] += 1\n        else:\n            if (ai < 0 and bi < 0) or (ai >= 0 and bi < 0):\n                ai = -ai\n                bi = -bi\n\n            g = math.gcd(-bi, ai)\n            counts[(-bi // g, ai // g)] += 1\n\nif counts:\n    print(max(counts.values()) + arbitrary)\nelse:\n    print(arbitrary)\n
ii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\n\nfrom collections import defaultdict as dd\n\nn = ii()\na, b = input().strip(), input().strip()\nda, db = dd(list), dd(list)\nqa, qb = [], []\nfor i in range(n):\n    if a[i] == '?':\n        qa.append(i)\n    else:\n        da[a[i]].append(i)\n    if b[i] == '?':\n        qb.append(i)\n    else:\n        db[b[i]].append(i)\n\nans = []\nfor c in 'abcdefghijklmnopqrstuvwxyz':\n    u, v = da[c], db[c]\n    while u and v:\n        ans.append((u.pop(), v.pop()))\n    while u and qb:\n        ans.append((u.pop(), qb.pop()))\n    while v and qa:\n        ans.append((qa.pop(), v.pop()))\nwhile qa and qb:\n    ans.append((qa.pop(), qb.pop()))\n\nprint(len(ans))\nprint(*('%d %d' % (i + 1, j + 1) for i, j in ans), sep='\n')
n = int(input())\na = [int(x) for x in input().split()]\n\nres = {}\n\nfor i in range(n):\n  sm = 0\n  for j in range(i, n):\n    sm += a[j]\n    if sm in res:\n      res[sm].append((i, j))\n    else:\n      res[sm] = [(i, j)]\n\nbest = 0\nbestI = -1\nfor key in res:\n  r = -1\n  cnt = 0\n  for (a,b) in sorted(res[key]):\n    if a > r:\n      cnt += 1\n      r = b\n    elif b < r:\n      r = b\n  if cnt > best:\n    best = cnt\n    bestI = key\n\nx = []\nr = -1\nfor (a, b) in sorted(res[bestI]):\n  if a > r:\n    x.append(str(a+1) + " " + str(b+1))\n    r = b\n  elif b < r:\n    r = b\n    x.pop()\n    x.append(str(a+1) + " " + str(b+1))\n  \nprint(best)\nprint("\n".join(x))\n
inp = input().split()\nn = int(inp[0])\nk = int(inp[1])\n\na = input().split()\nfor i in range(n):\n    a[i] = int(a[i])\n\n# End of Input\n\nbank  = {}\n\n# Preparation\nfor i in range(n):\n    arg = (len(str(a[i])),a[i]%k)\n    #print("Detect:",arg)\n    bank[arg] = bank.get(arg,0)+1\n\nans = 0\n# Query\nfor i in range(n):\n    ten = 1\n    for j in range(1,11):\n        ten*=10\n        frontMod = (a[i]*ten)%k\n        #print("FRONT MOD:",frontMod)\n        req = (k-frontMod)%k\n        #print("WANT:",req)\n\n        got = bank.get((j,req),0)\n        ans += got\n\n# Deal with Same Index\nfor i in range(n):\n    cur = str(a[i])\n    cur = cur*2\n    tst = int(cur)\n    if(tst%k==0):\n        ans-=1\n\n# Print Answer\nprint(ans)
n=int(input())\nl=list(map(int,input().split()))\nans=l[0]+l[n-2]\nfor i in range(n-2):\n    ans+=min(l[i],l[i+1])\nprint(ans)
N, M, Q = map(int, input().split())\nA = []\nfor i in range(Q):\n  A.append(list(map(int, input().split())))\ndef f(B, n):\n  ans = 0\n  if len(B) < N:\n    for i in range(n, M+1):\n      ans = max(ans, f(B+[i], i))\n  else:\n    for j in range(Q):\n      if B[A[j][1]-1] - B[A[j][0]-1] == A[j][2]:\n        ans += A[j][3]\n    return ans\n  return ans\nprint(f([], 1))
# coding: utf-8\n# Your code here!\nn=int(input())\na=list(map(int,input().split()))\nans=0\nfor i in range(n):\n    for j in range(i+1,n):\n        ans=max(abs(a[i]-a[j]),ans)\nprint(ans)
import itertools\nn = int(input())\nl = [list(map(int,input().split())) for _ in range(n)]\n\ndef factorization(n):\n    if n == 1:\n        return 1\n    return n * factorization(n-1)\n\nsize = factorization(n)\na = list(itertools.permutations(l,n))\ntotal = 0\nfor i in range(size):\n    for j in range(n-1):\n        x1 = a[i][j][0]\n        x2 = a[i][j+1][0]\n        y1 = a[i][j][1]\n        y2 = a[i][j+1][1]\n        x_total = (x1-x2)**2\n        y_total = (y1-y2)**2\n        total += (x_total + y_total)**.5\nprint(total/size)
a,b=map(int,input().split())\nif a > 2*b:\n  print(a-2*b)\nelse:\n  print("0")
import math\n\nN = int(input())\n\ndef f(a,b):\n    if len(str(a)) < len(str(b)):\n        return len(str(b))\n    else:\n        return len(str(a))\n\nans = 100000000000\nfor i in range(1,int(math.sqrt(N)+1)):\n    if N % i == 0:\n        ans = min(ans,f(i,N//i))\nprint(ans)\n
from collections import Counter\n\nn,m=map(int,input().split())\n\nlis=[]\ncnt=0\nfor i in range(n):\n  l=list(map(int,input().split()))\n  lis+=l[1:]\n  \nd=Counter(lis)\nfor i in d.values():\n  if i==n:\n    cnt+=1\n    \nprint(cnt)
def readinput():\n    n=int(input())\n    return n\n\ndef main(n):\n    if n%2==0:\n        return 0.5\n    else:\n        return (n//2+1)/n\n\n\ndef __starting_point():\n    n=readinput()\n    ans=main(n)\n    print(ans)\n\n__starting_point()
#ABC147　C　やってる途中\nn=int(input())\nl=[]\nfor i in range(n):\n  a=int(input())\n  l_=[]\n  for j in range(a):\n    xy=list(map(int,input().split()))\n    l_.append(xy)\n  l.append(l_)\nans=0\nfor i in range(2**n):\n  table=[0]*n\n  flag=False\n  for j in range(n):\n    if (i>>j)&1:\n      table[j]=1\n  for j in range(n):\n    for k in l[j]:\n   \n      if k[1]!=table[k[0]-1] and table[j]==1:\n        flag=True\n        break\n\n        if flag:\n          break\n\n  if flag==True:\n    continue\n\n\n  ans = max(ans, table.count(1))\n\n\nprint(ans)
K = int(input())\nS = input()\nif len(S) <= K:\n    print(S)\nelse:\n    print(S[0:K] + '...')
s = input()\nprint((s + "es" if s[len(s) - 1] == 's' else s + 's'))\n
n, k = map(int, input().split())\nsnukes = []\nfor _ in range(k):\n    okashi = int(input())\n    snukes += [int(v) for v in input().split()]\ntarget = 1\ncnt = 0\nl = list(set(snukes))\ns = [int(v) for v in range(1, n + 1)]\n\nfor p in s:\n    if p not in l:\n        cnt += 1\nprint(cnt)
N=int(input())\nS=input()\n\nans=S[0]\nfor s in S:\n  if ans[-1]!=s:\n    ans+=s\nprint(len(ans))
n = int(input())\na = list(map(int,input().split()))\n\ncnt = 0\nfor i in range(n):\n    while True:\n        if a[i]%2==0:\n            a[i]=a[i]//2\n            cnt +=1\n        else:\n            break\nprint(cnt)
A,B,C,K = list(map(int,input().split()))\nif K <= A + B :\n    print((min(A,K)))\nelse:\n    print((A - (K-A-B)))\n
X,Y=map(int,input().split())\n\nfor i in range(X+1):\n    if i*2+(X-i)*4==Y:\n        print("Yes")\n        break\n    elif i==X:print("No")
from collections import defaultdict\nN, M = list(map(int, input().split()))\n\nd = defaultdict(list)\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    d[a].append(b)\n    d[b].append(a)\n\n\ndef dfs(n, path):\n    count = 0\n    path.append(n)\n    if len(path) == N:\n        count += 1\n        return count\n    for i in d[n]:\n        if i not in path:\n            count += dfs(i, path)\n            path.pop()\n\n    return count\n\n\nprint((dfs(1, [])))\n
n,l=map(int,input().split())\nc=0\nm=100000\nfor i in range(1,n+1):\n  c+=l+i-1\n  m=min(m,abs(l+i-1))\nif l<0 and l-n<=0:\n  print(c+m)\nelse:\n  print(c-m)
n = int(input())\nans = 0\nfor i in range(n):\n    if (i+1) %3 > 0 and (i+1)%5 > 0:\n        ans += i+1\nprint(ans)\n
x,n=map(int,input().split())\np=list(map(int,input().split()))\na=101\nm=101-x\nfor i in range(102):\n  i=100-i\n  if i in p:\n    continue\n  M=abs(i-x)\n  if M<=m:\n    m=M\n    a=i\nprint(a)
H, W = map(int, input().split())\nh, w = map(int, input().split())\nprint((H-h) * (W-w))
n, k = map(int, input().split())\na = list(sorted(map(int, input().split())))\nx = -1\nif k == 0:\n    x = max(1, a[0] - 1)\nelse:\n    x = a[k - 1]\ns = 0\nfor i in range(n):\n    s += (a[i] <= x)\nif s == k:\n    print(x)\nelse:\n    print(-1)
n, m = map(int, input().split())\npole = []\nmetka = []\nfor i in range(n):\n    pole.append([])\n    metka.append([])\n    s = input()\n    for j in range(m):\n        pole[i].append(s[j])\n        if s[j] == '.':\n            metka[i].append(0)\n        else:\n            metka[i].append(1)\nk = 0\nans = []\n\nfor i in range(n):\n    for j in range(m):\n        if pole[i][j] == '*':\n            e = 0\n            while i - e - 1>= 0 and j - e - 1>= 0 and i + e + 1 < n and j + e + 1< m and pole[i - e - 1][j] == '*' and pole[i][j - e - 1] == '*' and pole[i + e + 1][j] == '*' and pole[i][j + e + 1] == '*':\n                e = e + 1\n                metka[i][j] = 0\n                metka[i - e][j] = 0\n                metka[i][j - e] = 0\n                metka[i + e][j] = 0\n                metka[i][j + e] = 0\n            if e != 0:\n                k = k + 1\n                ans.append((i + 1,j + 1, e))\nflag = True\nfor i in range(n):\n    if 1 in metka[i]:\n        flag = False\n        break\nif not flag:\n    print(-1)\nelse:\n    print(k)\n    for i in range(k):\n        print(ans[i][0], ans[i][1], ans[i][2], end='\n')
n = int(input())\ns = input()\nt = ''\nlst = '1'\nfor i in s:\n	if lst == '1':\n		lst = i\n		nw = ''\n	else:\n		if lst != i:\n			t += lst\n			t += i\n			lst = '1'\nprint (len(s) - len(t))\nprint (t)
n, m = map(int, input().split())\nclr = [-1 for i in range(0, n)]\neds = []\n\n\ndef dfs():\n    cur = 0\n    st = [-1 for i in range(0, n + 1)]\n    st[cur] = 0\n    cur += 1\n    while cur > 0:\n        v = st[cur - 1]\n        cur -= 1\n        for x in g[v]:\n            if clr[x] != -1:\n                if clr[x] == clr[v]:\n                    return False\n                continue\n            clr[x] = clr[v] ^ 1\n            st[cur] = x\n            cur += 1\n    return True\n\n\ng = [[] for i in range(0, n)]\nfor i in range(0, m):\n    u, v = map(int, input().split())\n    u -= 1\n    v -= 1\n    g[u].append(v)\n    g[v].append(u)\n    eds.append((u, v))\nclr[0] = 0\nif dfs():\n    print("YES")\n    print("".join("1" if clr[u] < clr[v] else "0" for (u, v) in eds))\nelse:\n    print("NO")
def mi():\n	return map(int, input().split())\n\nn,m = mi()\na = [0]*m\nfor i in range(n):\n	l,r = mi()\n	for i in range(l-1, r):\n		a[i] = 1\nprint (a.count(0))\nfor i in range(m):\n	if a[i]==0:\n		print (i+1, end = ' ')
from math import gcd\n\n\ndef f(x):\n    return x - (x // C + x // D - x // lcm)\n\n\nA, B, C, D = list(map(int, input().split()))\nlcm = C * D // gcd(C, D)\nprint((f(B) - f(A - 1)))\n
L=input()\nr=0\nfor l in L:\n	r+=int(l)\nprint('Yes' if r%9==0 else 'No')
N = int(input())\nres = N\nfor i in range(N+1):\n    cc = 0\n    t = i\n    while t > 0:\n        cc += t%6\n        t //= 6\n    t = N - i\n    while t > 0:\n        cc += t%9\n        t //= 9\n    if res > cc:\n        res = cc\nprint(res)
# abc103\nS = input()\nT = input()\ntemp = S\nfor i in range(len(S)):\n    if temp == T:\n        print("Yes")\n        return\n    else:\n        temp = temp[-1] + temp[:-1]\nprint("No")\n
s = input()\nt = input()\nm = 1000\nfor i in range(len(s) - len(t) + 1):\n  c = 0\n  for j in range(len(t)):\n    if s[i + j] != t[j]:\n      c += 1\n  m = min(m, c)\nprint(m)
A, B, K = map(int, input().split())\n\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n**.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n //i:\n                divisors.append(n//i)\n    divisors.sort()\n    return divisors\n\ndiv_A = make_divisors(A)\ndiv_B = make_divisors(B)\n\nl = []\nfor i in div_A:\n    for j in div_B:\n        if i == j:\n            l.append(i)\nprint(l[-K])
x = int(input())\nans = 0\n\nans = x // 500 * 1000\nx = x % 500\nans += x // 5 * 5\n\nprint(ans)
import numpy as np\nN = int(input())\nXi = list(map(int, input().split()))\nXi = np.array(Xi)\nmin = float('inf')\nfor i in range(1, 101):\n    tmp = np.sum(np.square(Xi - i))\n    if tmp < min:\n        min = tmp\nprint(min)
import math\na, b = list(map(int, input().split()))\nprint(math.ceil((b-a)/(a-1)) + 1)
s = list(input())\nt = list(input())\ncnt = 0\nfor i in range(3):\n  if s[i] == t[i]:\n    cnt += 1\nprint(cnt)
n = int(input())\np = list(map(int, input().split()))\ns = 0\nfor i in range(n - 2):\n    if p[i] < p[i + 1] < p[i + 2] or p[i] > p[i + 1] > p[i + 2]:\n        s += 1\nprint(s)\n
n=int(input())\nprint(sum([float(input().split()[1])for i in range(n)])/n+5)\n
n, m = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\na.sort(reverse=True)\n\ndef check(d):\n    s=0\n    for i in range(len(a)):\n        s+=max(0,a[i]-i//d)\n    return s>=m\nif sum(a)<m:\n    print(-1)\nelse:\n    l, r = 1,n\n    mid = l+r>>1\n    while l<r:\n        if check(mid):\n            r=mid\n        else:\n            l=mid+1\n        mid=l+r>>1\n    print(l)\n
from operator import itemgetter\n#int(input())\n#map(int,input().split())\n#[list(map(int,input().split())) for i in range(q)]\n#print("YES" * ans + "NO" * (1-ans))\nn,k =  map(int,input().split())\nsi = list(map(int,input().split()))\nnum = 10**5 * 2 + 1\nai = [0] * num\nfor i in range(n):\n    ai[si[i]] += 1\nnum3 = num\nnum = max(ai) + 1\nai2 = [[] for i in range(num)]\nfor i in range(num3):\n    if ai[i] != 0:\n        ai2[ai[i]] += [[i,1,ai[i]]]\ni = num-1\nwhile k > 0:\n    for j in ai2[i]:\n        if k == 0:\n            break\n        num2 =  j[2] // (j[1]+1)\n        ai2[num2] += [[j[0],j[1]+1,j[2]]]\n        print(j[0],end=" ")\n        k -= 1\n    i -= 1\n    \n
import sys\nimport copy\n\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nMAT=[list(map(int,input().split())) for i in range(n)]\n\n#n=15\n#m=10000\n#MAT=[list(range(j*j,j*j*(m+1),j*j)) for j in range(1,n+1)]\n\n\nif n==1:\n    ANS=10**10\n    for i in range(1,m):\n        if ANS>abs(MAT[0][i]-MAT[0][i-1]):\n            ANS=abs(MAT[0][i]-MAT[0][i-1])\n    print(ANS)\n    return\n\n\n\nEDGE0=[[10**10]*n for i in range(n)]#iが0行目,jが最終行\nEDGE1=[[10**10]*n for i in range(n)]\nMAX=0\nMIN=0\n\nif m!=1:    \n    for i in range(n):\n        for j in range(n):\n\n            EDGE1[i][j]=EDGE1[j][i]=min([abs(MAT[i][k]-MAT[j][k]) for k in range(m)])\n            \n            if EDGE1[i][j]>MAX:\n                MAX=EDGE1[i][j]\n\n            EDGE0[i][j]=min([abs(MAT[i][k]-MAT[j][k-1]) for k in range(1,m)])\nelse:\n    for i in range(n):\n        for j in range(n):\n\n            EDGE1[i][j]=EDGE1[j][i]=min([abs(MAT[i][k]-MAT[j][k]) for k in range(m)])\n            \n            if EDGE1[i][j]>MAX:\n                MAX=EDGE1[i][j]\n    \n\ndef Hamilton(start,USED,rest,last,weight):\n    #print(start,USED,rest,last,weight,last*(1<<n)+USED)\n    if MEMO[last*(1<<n)+USED]!=2:\n        return MEMO[last*(1<<n)+USED]\n    if rest==1:\n        for i in range(n):\n            if USED & (1<<i)==0:\n                final=i\n                break\n\n        if EDGE0[start][final]>=weight and EDGE1[last][final]>=weight:\n            #print(start,USED,rest,last,weight)\n\n            MEMO[last*(1<<n)+USED]=1\n            return 1\n        else:\n            #print(start,USED,weight,"!")\n            MEMO[last*(1<<n)+USED]=0\n            return 0\n\n    for j in range(n):\n        if USED & (1<<j)==0 and EDGE1[last][j]>=weight:\n            \n            NEXT=USED+(1<<j)\n            if Hamilton(start,NEXT,rest-1,j,weight)==1:\n                #print(start,USED,rest,last,weight)\n                MEMO[last*(1<<n)+USED]=1\n                return 1\n    else:\n        #print(start,USED,weight,"?")\n        MEMO[last*(1<<n)+USED]=0\n        return 0\n        \n    \nwhile MAX!=MIN:\n    #print(MAX,MIN)\n    aveweight=(MAX+MIN+1)//2\n\n    for start in range(n):\n        MEMO=[2]*(n*1<<(n+1))\n        START=1<<start\n        if Hamilton(start,START,n-1,start,aveweight)==1:\n            MIN=aveweight\n            break\n    else:\n        MAX=aveweight-1\n\nprint(MAX)\n
n = int(input())\ns = input()\n\nres = 0\nx_count = 0\n\nfor c in s:\n	if c == 'x':\n		x_count += 1\n	else:\n		x_count = 0\n\n	if x_count > 2:\n		res += 1\n\n\nprint(res)
r=int(input())\nprint(3*r**2)
S,W=list(map(int,input().split()))\nif W<S:\n    print('safe')\nelse:\n    print('unsafe')\n
S_list = list(map(int,input().split()))\nprint((int(S_list[0] * S_list[1] / 2)))\n
A, B, C = map(int, input().split())\nprint(min(B//A, C))
A,B=map(int,input().split())\nprint(A*B)
a,b,t=map(int,input().split())\nprint(b*(t//a))
k = int(input())\na,b = map(int,input().split())\nfor i in range(a,b+1):\n    if i%k==0:\n        print('OK')\n        return\nprint('NG')
T,X=map(int,input().split())\nprint(T/X)
a, b, c = map(int, input().split())\nx = c - (a - b)\nif x >= 0:\n  print(x)\nelse:\n  print(0)
import itertools\nimport bisect\n\nN = int(input())\nNums = [str(n) for n in range(1, N+1)]\n\np = int(''.join([n for n in input().split()]))\nq = int(''.join([n for n in input().split()]))\n\nper = itertools.permutations(Nums)\n\nnumlist = sorted([int(''.join(list(s))) for s in per])\n\na = bisect.bisect_left(numlist, p)\nb = bisect.bisect_left(numlist, q)\n\nprint(abs(a-b))
a = input()\n\natcg =["A","T","C","G"]\n\nresult =[]\nres= 0\nfor i in a:\n    if i in atcg:\n        res +=1\n    else:\n        res = 0\n    result.append(res)\n\nprint(max(result))
n=input()\n\ncount=0\nfor i in range(1,int(n)+1):\n  l=len(str(i))\n  if l%2!=0:\n    count+=1\nprint(count)
S = input()\nT = input()\ntigau = 0\n\nfor i in range(len(S)):\n  if S[i] != T[i]:\n    tigau += 1\n\nprint(tigau)
K, X = map(int, input().split())\n\nlists = [X]\n\nfor i in range(1, K):\n    if X + i <= 1000000:\n        lists.append(X + i)\n    if X - i >= -1000000:\n        lists.append(X - i)\n\nlists.sort()\nprint(*lists)
X = int(input())\n\nif X >= 30:\n    print("Yes")\nelse:\n    print("No")
import math\nn , d = list(map(int, input().split()))\n\nx = [list(map(int, input().split())) for _ in range(n)]\ncnt = 0\nsum_tmp = 0\n\nfor i in range(n):\n    for j in range(i+1, n):\n        for h in range(d):\n            sum_tmp += (x[i][h] - x[j][h]) ** 2\n        if math.sqrt(sum_tmp).is_integer():\n            cnt += 1\n        sum_tmp = 0\n\nprint(cnt)\n
s = input('')\n\n# Sが入力しづらければBad,そうでなければGood\nif s[0] == s[1] or s[1] == s[2] or s[2] == s[3]:\n    print('Bad')\nelse:\n    print('Good')
N = int(input())\nv = sorted(map(int, input().split()))\n\ntmp = v[0]\nfor i in range(1,N):\n  tmp = (tmp+v[i])/2.0\n  \nprint(tmp)
N = int(input())\nA = [int(i) for i in input().split()]\nB = [int(i) for i in input().split()]\nC = [int(i) for i in input().split()]\nans = 0\nfor i in range(N):\n    ans += B[A[i]-1]\n    if(A[i] == A[i-1]+1 and i != 0):\n        ans += C[A[i]-2]\nprint(ans)
_ = input()\nS = input()\nprint((S.count("ABC")))\n
#!/usr/bin/env python3\nimport itertools\n\nn = int(input())\n\n\ndata = [[] for i in range(5)]\n# print(data)\nfor i in range(n):\n    tmp = str(input())\n    if tmp[0] == "M":\n        data[0].append(tmp)\n    elif tmp[0] == "A":\n        data[1].append(tmp)\n    elif tmp[0] == "R":\n        data[2].append(tmp)\n    elif tmp[0] == "C":\n        data[3].append(tmp)\n    elif tmp[0] == "H":\n        data[4].append(tmp)\n\nans = 0\nfor i, j, k in itertools.combinations([0, 1, 2, 3, 4], 3):\n    ans += len(data[i])*len(data[j])*len(data[k])\nprint(ans)\n
n,m=map(int,input().split())\nif n==m:\n    print("Yes")\nelse:\n    print("No")
S=input()\nif S[2]==S[3] and S[4]==S[5]:\n    print("Yes")\nelse:\n    print("No")
n, t = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\nl = []\nflag = False\nfor i in range(n):\n    if a[i][1] <= t:\n        l.append(a[i][0])\n        flag = True\nif flag:\n    print(min(l))\nelse:\n    print('TLE')
n,a,b = map(int,input().split())\n\nprint(n*a if n*a < b else b)
from collections import defaultdict\nn = int(input())\ns_dict = defaultdict(int)\nfor i in range(n):\n  s_int = [0] * 26\n  s = list(input())\n  for si in s:\n    s_int[ord(si) - ord('a')] += 1\n  cnt = 0\n  for s_int_i in s_int:\n    cnt *= 10\n    cnt += s_int_i\n  s_dict[cnt] += 1\nans = 0\nfor key in s_dict:\n  ans += s_dict[key] * (s_dict[key] - 1) / 2\nprint(int(ans))
l = [0]\n\ndef count(size):\n    nums = (10**size - 10**(size - 1))\n    small =  l[size-1] + size\n    large = l[size-1] + nums * size\n    if len(l) <= size:\n        l.append(large)\n    return (nums * (small + large))//2\n\ndef test(minSize, size, val):\n    out = minSize * val + size * ((val + 1) * val)//2\n    return out\n\nq = int(input())\nfor _ in range(q):\n    want = int(input())\n\n    size = 1\n    while want > count(size):\n        want -= count(size)\n        size += 1\n\n    minSize = l[size - 1]\n\n    lo = 0 #Impossible\n    hi = (10**size - 10**(size - 1)) #Possible\n\n    while hi - lo > 1:\n        testV = (lo + hi) // 2\n        out = test(minSize, size, testV)\n\n        if out < want:\n            lo = testV\n        else:\n            hi = testV\n\n    want -= test(minSize, size, lo)\n\n    newS = 1\n    while 9 * (10**(newS - 1)) * newS < want:\n        want -= 9 * (10**(newS - 1)) * newS\n        newS += 1\n\n    want -= 1\n\n    more = want//newS\n    dig = want % newS\n    value = 10**(newS - 1) + more\n    print(str(value)[dig])\n\n    \n
import sys\ninput = sys.stdin.readline\n\nn,k=list(map(int,input().split()))\nR=[list(map(int,input().split())) for i in range(n-1)]\n\nRDICT={tuple(sorted([R[i][0],R[i][1]])):i for i in range(n-1)}\n\nC=[[] for i in range(n+1)]\n\nfor x,y in R:\n    C[x].append(y)\n    C[y].append(x)\n\nCLEN=[]\nfor i in range(1,n+1):\n    CLEN.append(len(C[i]))\n    \nfrom collections import Counter\ncounter=Counter(CLEN)\n\nCV=sorted(list(counter.keys()),reverse=True)\n\ncvsum=0\ncities=1\n\nfor cv in CV:\n    cvsum+=counter[cv]\n    if cvsum>k:\n        cities=cv\n        break\n\nprint(cities)\nANS=[0]*(n-1)\n\nfrom collections import deque\nQUE = deque()\nQUE.append([1,1])\nVISITED=[0]*(n+1)\n\nwhile QUE:\n    city,roadnum=QUE.pop()\n    VISITED[city]=1\n\n    for to in C[city]:\n        if VISITED[to]==0:\n            ANS[RDICT[tuple(sorted([city,to]))]]=roadnum\n            roadnum=roadnum%cities+1\n            QUE.append([to,roadnum])\n\nprint(*ANS)\n        \n    \n\n
n=int(input())\na=list(map(int,input().split()))\na.sort()\nprev=-2\nc=0\nfor i in a:\n    dif=i-prev\n    if dif > 1:\n        prev=i+1\n        c+=1\nac=0\nlc=-2\nfor i in a:\n    if lc < i-1:\n        lc=i-1\n        ac+=1\n    elif lc == i-1:\n        lc=i\n        ac+=1\n    elif lc == i:\n        lc=i+1\n        ac+=1\nprint(c,ac)\n
n = int(input())\n\nA = [-1]\nans = [1]\n\nfor i in range(n):\n    A.append(tuple(map(int, input().split())))\n\na = A[1][0]\nb = A[1][1]\n\nc = A[a][0]\nd = A[a][1]\n\nif b == c or b == d:\n    ans.append(a)\n    ans.append(b)\nelse:\n    ans.append(b)\n    ans.append(a)\n\nwhile len(ans) != n:\n    p = A[ans[-2]]\n    \n    if p[0] == ans[-1]:\n        ans.append(p[1])\n    else:\n        ans.append(p[0])\n\nfor i in ans:\n    print(i, end=' ')
n = int(input())\nA = list(map(int, input().split()))\n\nA.sort()\ni = 0\nj = 0\nans = 0\n\nwhile j < len(A):\n    ans = max(ans, j - i)\n    if i == j or A[j] - A[i] <= 5:\n        j += 1\n    else:\n        i += 1\n\nprint(max(ans, j - i))\n
q = int(input())\nfor query in range(q):\n	k, n, a, b = list(map(int,input().split()))\n	if n * b > k:  \n		print(-1)\n	else:\n		print(min(n, (k-n*b-1)//(a-b)))\n
def num(s):\n    ans1 = [0]*n\n    for q in range(n):\n        ans1[q] = s[q] == 'a'\n    sum1 = 0\n    for q in range(n):\n        w = sum1*(s[q] == 'b')\n        sum1 += ans1[q]\n        ans1[q] = w\n    sum1 = 0\n    for q in range(n):\n        w = sum1*(s[q] == 'c')\n        sum1 += ans1[q]\n        ans1[q] = w\n    sum1 = 0\n    for q in range(n):\n        sum1 += ans1[q]\n    return sum1 % C\n\n\nn = int(input())\ns = list(input())\nC, k = 10**9+7, 0\nans, ans1, deg = [0]*n, [0]*n, [1]\nfor q in range(n):\n    deg.append(deg[-1]*3 % C)\n    k += s[q] == '?'\nif k == 0:\n    print(num(s))\nelif k == 1:\n    ans = 0\n    for q in range(n):\n        if s[q] == '?':\n            for q1 in ['a', 'b', 'c']:\n                s[q] = q1\n                ans += num(s)\n            break\n    print(ans % C)\nelif k == 2:\n    ans = 0\n    ind1 = ind2 = -1\n    for q in range(n):\n        if s[q] == '?' and ind1 == -1:\n            ind1 = q\n        elif s[q] == '?':\n            ind2 = q\n    for q in ['aa', 'ab', 'ac', 'ba', 'bb', 'bc', 'ca', 'cb', 'cc']:\n        s[ind1], s[ind2] = q[0], q[1]\n        ans += num(s)\n    print(ans % C)\nelse:\n    ans = 0\n    for q1 in ['???', '??c', '?b?', '?bc', 'a??', 'a?c', 'ab?', 'abc']:\n        t = q1.count('?')\n        ans1 = [0] * n\n        for q in range(n):\n            ans1[q] = (s[q] == q1[0])*deg[k-t]\n        sum1 = 0\n        for q in range(n):\n            w = sum1 * (s[q] == q1[1])\n            sum1 += ans1[q]\n            ans1[q] = w % C\n        sum1 = 0\n        for q in range(n):\n            w = sum1 * (s[q] == q1[2])\n            sum1 += ans1[q]\n            ans1[q] = w % C\n        sum1 = 0\n        for q in range(n):\n            sum1 += ans1[q]\n        ans += sum1\n    print(ans % C)\n
import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nA=list(map(int,input().split()))\n\nSP=[list(map(int,input().split())) for i in range(m)]\n\nMIN=min(A)\nx=A.index(MIN)\nEDGE_x=[[x+1,i+1,A[x]+A[i]] for i in range(n) if x!=i]\n\nEDGE=EDGE_x+SP\n\nEDGE.sort(key=lambda x:x[2])\n\n#UnionFind\n\nGroup=[i for i in range(n+1)]\n\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\nANS=0\nfor i,j,x in EDGE:\n    if find(i)!=find(j):\n        ANS+=x\n        Union(i,j)\n\nprint(ANS)\n
import sys\na,m,n=list(map(int,input().split()))\naux=[0]*(a+1)\ninf=10**15\ndp=[aux.copy() for i in range(n+1)]\nm1=10**12\nm2=10**12\nfor i in range(m):\n    l,r=list(map(int,input().split()))\n    if l<m1:\n        m1=l\n    for j in range(l,r):\n        dp[0][j+1]=inf\ns=[]\nfor i in range(1,n+1):\n    x,w=list(map(int,input().split()))\n    s.append(tuple([x,w]))\n    if x<m2:\n        m2=x\nif m2>m1:\n    print(-1)\n    return\ns.sort()\n\nfor i in range(1,n+1):\n    x=s[i-1][0]\n    w=s[i-1][1]\n    for j in range(x+1):\n        dp[i][j]=dp[i-1][j]\n    for j in range(x+1,a+1):\n        if i!=1:\n            dp[i][j]=min(dp[0][j]+dp[i][j-1],dp[i-1][j],w*(j-x)+dp[i][x])\n        else:\n            dp[i][j]=min(dp[0][j]+dp[i][j-1],w*(j-x)+dp[i][x])\n            \nans=dp[-1][-1]\nif ans>=inf:\n    print(-1)\nelse:\n    print(ans)\n
from collections import Counter\nc=Counter(list(map(int,input().split())))\nif len(c)==2:print('Yes')\nelse:print('No')
N = int(input())\nT, A = map(int, input().split())\nH = list(map(int, input().split()))\n\nhigh = []\nabso = []\nfor i in range(N):\n    high.append(T - (H[i] * 0.006))\n\nn = 0\nwhile n <= N - 1:\n    abso.append(abs(A - high[n]))\n    n += 1\n\nanswer = abso.index(min(abso)) + 1\nprint(answer)
\nx,y = list(map(int,input().split()))\n\nprint((int((x * (x-1)) / 2  + (y * (y - 1))/2)))\n
\ndef main():\n    N, Q = map(int,input().split())\n    S = str(input())\n\n    sum_array = [0] * 100000\n\n    i = 0\n    while i < len(S):\n        if S[i] == 'A' and ((i + 1) < len(S)) and S[i + 1] == 'C':\n            sum_array[i] = 1\n            i += 2\n        else:\n            i += 1\n\n    sum = 0\n    for i in range(N):\n        sum += sum_array[i]\n        sum_array[i] = sum\n\n    #print("")\n    #print(sum_array)\n\n    ans_array = [0] * Q\n    for q in range(Q):\n        l, r = map(int,input().split())\n\n        l_sum = sum_array[l-1]\n        if l == 1:\n            l_sum = 0\n        elif sum_array[l-2] != l_sum:\n            l_sum = sum_array[l-2]\n\n        r_sum = sum_array[r-1]\n        if  sum_array[r-2] != r_sum:\n            r_sum = sum_array[r-2]\n\n        ans_array[q] = r_sum - l_sum\n    \n    for ans in ans_array:\n        print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()
n = [ int(i) for i in  input().split() ]\np = [ int(i) for i in input().split() ]\n\np = sorted(p)\nval = sum( p[:n[1]] )\nprint(val)\n\n\n\n
print((sum(sorted(list(map(int,input().split())))[0:2])))\n
x,a = map(int,input().split())\nprint(0 if x < a else 10)
n,k=map(int,input().split())\nprint(min(n%k,k-n%k))
a, b, c = map(int, input().split())\nif a+b+c >= 22:\n  print('bust')\nelse:\n  print('win')
n = int(input())\nprint((n if n%2==0 else n*2))\n
N,D=list(map(int,input().split()))\nprint(((N-1)//(2*D+1)+1))\n
n=int(input())%10\nif n==2 or n==4 or n==5 or n==7 or n==9:\n  print("hon")\nif n==0 or n==1 or n==6 or n==8:\n  print("pon")\nif n==3:\n  print("bon")
import itertools\nn = int(input())\nTako = list(map(int, input().split()))\nans = 0\nfor x,y in itertools.combinations(Tako,2):\n    ans += x*y\n\nprint(ans)
import copy\nn = int(input())\na = []\nfor i in range(n):\n  s = int(input())\n  a.append(s)\nb = copy.copy(a)\na.sort(reverse=True)\nc = b.index(a[0])\nfor j in b:\n  if j == b[c]:\n    print(a[1])\n  else:\n    print(a[0])
a, b = map(int, input().split())\nprint(max(a+a-1, a+b, b+b-1))
import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, K, *X = list(map(int, read().split()))\n\n    A = [abs(x - X[0]) for x in X]\n\n    ans = INF\n    for i in range(N - K + 1):\n        if ans > min(abs(X[i]), abs(X[i + K - 1])) + A[i + K - 1] - A[i]:\n            ans = min(abs(X[i]), abs(X[i + K - 1])) + A[i + K - 1] - A[i]\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
a,b = map(int, input().split())\nprint((((b-a)**2)-(a+b))//2)
import math\n\nH,A = list(map(int,input().split()))\n\nprint((math.ceil(H/A)))\n
a, b, c, d = list(map(int, input().split()))\ns = max(a, c)\ne = min(b, d)\nprint((e - s if e-s > 0 else 0))\n
N = int(input())\n\nif N >= 105:\n    if N >= 135:\n        if N >= 165:\n            if N >= 189:\n                if N >= 195:\n                    print((5))\n                else:\n                    print((4))\n            else:\n                print((3))\n        else:\n            print((2))\n    else:\n        print((1))\nelse:\n    print((0))\n\n
n, k = map(int, input().split())\nprint(int(n % k != 0))
N = int(input())\nlist_ = [111,222,333,444,555,666,777,888,999]\nfor i in list_:\n    if i >= N:\n        print(i)\n        return
A=list(map(int,input().split()))\n\nA.sort(reverse=True)\n\nprint((A[0]-A[2]))\n
from collections import defaultdict\n\nd = defaultdict(bool)\n\nn = int(input())\nfor i in range(1000000):\n\n    if d[n]:\n        print((i + 1))\n        return\n    d[n] = True\n    if n & 1:\n        n = n * 3 + 1\n    else:\n        n >>= 1\n
A,B,C,D=map(int,input().split());print("YNeos"[(A+D-1)//D<(C+B-1)//B::2])
n = int(input())\nvlst = list(map(int, input().split()))\nclst = list(map(int, input().split()))\nans = 0\nfor v, c in zip(vlst, clst):\n    ans += max(0, v - c)\nprint(ans)
h,w = map(int, input().split())\ncell = []\n\nfor i in range(h):\n    row = list(input())\n    if row != ["."]*w:\n        cell.append(row)\n\ncounter = []\nfor i in range(w):\n    flag = 0\n    for j in range(len(cell)):\n        if cell[j][i] == "#":\n            flag = 1\n            break\n    if flag == 1:\n            counter.append(i)\n\nfor a in cell:\n    ans = ''\n    for i in counter:\n        ans = ans + a[i]\n    print(ans)
R=int(input())\nprint(R*2*3.141592)
s = input()\n\nif len(set(s)) == 2 and s.count(s[0]) == 2 :\n  print('Yes')\nelse :\n  print('No')
A,B=map(int,input().split())\nprint(max(A+B,A-B,A*B))
N = int(input())\nH = list(map(int,input().split()))\n\ntop = H[0]\ncnt = 1\n\nfor i in range(1,N):\n  if top <= H[i]:\n    cnt += 1\n    top = H[i]\n\nprint(cnt)
n = int(input())\na = list(map(int, input().split()))\n\no = []\ncur = 0\nfor x in a:\n    if x == 1:\n        if cur > 0:\n            o.append(cur)\n        cur = 1\n    else:\n        cur += 1\n\no.append(cur)\nprint(len(o))\nprint(' '.join(str(x) for x in o))\n\n
from math import *\ntest = int(input())\nfor test_case in range(test):\n	n = int(input())\n	ct = 3\n	p = 2\n	while(1):\n		if(n%ct == 0):\n			print(n//ct)\n			break\n		p *= 2\n		ct += p
n, k = list(map(int, input().split()))\nfor i in range(k):\n    if n%10==0:\n        n //= 10\n    else:\n        n -= 1\nprint(n)\n
# AC\nimport sys\n\n\nclass Main:\n    def __init__(self):\n        self.buff = None\n        self.index = 0\n\n    def __next__(self):\n        if self.buff is None or self.index == len(self.buff):\n            self.buff = self.next_line()\n            self.index = 0\n        val = self.buff[self.index]\n        self.index += 1\n        return val\n\n    def next_line(self, _map=str):\n        return list(map(_map, sys.stdin.readline().split()))\n\n    def next_int(self):\n        return int(next(self))\n\n    def solve(self):\n        n = self.next_int()\n        x = sorted([self.next_int() for _ in range(0, n)])\n        ml = -1\n        _i = 0\n        _j = 0\n        j = 0\n        for i in range(0, n):\n            j = max(j, i)\n            while j + 1 < n and x[j + 1] == x[i]:\n                j += 1\n            while j + 2 < n and x[j + 2] == x[j] + 1:\n                j += 2\n                while j + 1 < n and x[j + 1] == x[j]:\n                    j += 1\n            jj = j\n            if j + 1 < n and x[j + 1] == x[j] + 1:\n                jj += 1\n            if jj - i > ml:\n                ml = jj - i\n                _i = i\n                _j = jj\n        a = []\n        b = []\n        i = _i\n        while i <= _j:\n            a.append(x[i])\n            i += 1\n            while i <= _j and x[i] == a[-1]:\n                b.append(x[i])\n                i += 1\n        print(ml + 1)\n        print(' '.join([str(x) for x in (a + b[::-1])]))\n\n\ndef __starting_point():\n    Main().solve()\n\n__starting_point()
#      \nimport collections, atexit, math, sys\nfrom functools import cmp_to_key\n#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\nimport bisect \ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\n\ndef memo(func):  \n    cache={}  \n    def wrap(*args):  \n        if args not in cache:  \n            cache[args]=func(*args)  \n        return cache[args]  \n    return wrap\n\n@memo\ndef comb (n,k):\n    if k==0: return 1\n    if n==k: return 1\n    return comb(n-1,k-1) + comb(n-1,k)\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\n    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit\n    \nN, M = getIntList()\ntotal = 0\nzz = [0 for i in range(N)]\nfor i in range(N):\n    a,b = getIntList()\n    total+=a\n    zz[i] = a-b\n\nzz.sort(reverse = True)\nif total <= M:\n    print(0)\n    return\nfor i in range(N):\n    total -= zz[i]\n    if total <= M:\n        print(i+1)\n        return\n\nprint(-1)\n\n\n\n
TC = int(input())\nwhile TC > 0:\n    n, a, b = list(map(int, input().split()))\n    ans = ""\n    for i in range(b):\n        ans += chr(ord('a') + i)\n    ans = ans * n\n    print(ans[:n])\n\n    TC -= 1\n\n
n, x, t = list(map(int, input().split()))\n\nans = 0\n\nwhile n > 0:\n    ans += t\n    n -= x\n\nprint(ans)\n
#!/usr/bin/env python3\n\nn = int(input())\n\nprint((n//3))\n
a,p = map(int,input().split())\nA = a*3 + p\nprint(A//2)
a,b = map(int, input().split())\nprint(a+b if b%a==0 else b-a)
print('YNeos'[input()+(T:=input())[-1]!=T::2])
A, B = map(int, input().split())\n \nif (A+B) %2 == 0: print((A+B) // 2)\nelse: print('IMPOSSIBLE')
N=int(input())\nX=N%10\ny=N//10\nY=y%10\nZ=N//100\nif X==7 or Y==7 or Z==7:\n  print("Yes")\nelse:\n  print("No")
def S(n):\n    c = 0\n    for i in range(len(n)):\n        c += int(n[i])\n    return c\n \nN = input()\nif int(N) % S(N) == 0:\n    print('Yes')\nelse:\n    print('No')
x1, y1, x2, y2 = map(int, input().split())\n\nprint(x2-(y2-y1), y2+(x2-x1), x1-(y2-y1), y1+(x2-x1))
s,t = input().split()\na,b = map(int,input().split())\nu = input()\n\nif u == s :\n  print(a-1,b)\nelse :\n  print(a,b-1)
n = int(input())\ns = list(input())\nm = n//2\n\nif n%2 != 0:\n  ans = "No"\nelse:\n  for i in range(m):\n    if s[i] != s[m+i]:\n      ans = "No"\n      break\n    ans = "Yes"\n\nprint(ans)
# -*- coding: utf-8 -*-\n"""\nCreated on Sat Sep 12 11:04:24 2020\n\n@author: liang\n"""\n\nW, H, x, y = map(int, input().split())\n\nans = [0] * 2\n\nans[0] = H*W/2\nif x == W/2 and y == H/2:\n    ans[1] = 1\nelse:\n    ans[1] = 0\nprint(" ".join(map(str, ans)))
import collections \nn = int(input())\nli = list(input().split())\nc = collections.Counter(li)\nif len(c) == 3:\n    print('Three')\nelse:\n    print('Four')
from sys import stdin, stdout\nfrom math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial\nfrom random import randint\n\nn, x, y = map(int, stdin.readline().split())\nvalues = list(map(int, stdin.readline().split()))\n\nif x > y:\n    stdout.write(str(n))\nelse:\n    v = sum(map(lambda v: int(v <= x), values))\n    stdout.write(str(v // 2 + (v & 1)))
def main():\n    import sys\n    from bisect import bisect_left\n    input = sys.stdin.readline\n\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    C = [a-b for a, b in zip(A, B)]\n    C.sort()\n\n    ans = 0\n    for i, c in enumerate(C):\n        j = bisect_left(C, -c+1)\n        ans += N-j\n        if c > 0:\n            ans -= 1\n    print(ans // 2)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n = int(input())\na = [int(x) for x in input().split()]\n\nprint(*[x - ((x ^ 1) & 1) for x in a])
def connected_components(neighbors):\n    seen = set()\n    def component(node):\n        nodes = set([node])\n        while nodes:\n            node = nodes.pop()\n            seen.add(node)\n            nodes |= neighbors[node] - seen\n            yield node\n    for node in neighbors:\n        if node not in seen:\n            yield component(node)\nfrom collections import defaultdict\ngraph = defaultdict(set)\nn,m = map(int,input().split())\nfor _ in range(m):\n    u,v = map(int,input().split())\n    graph[u].add(v)\n    graph[v].add(u)\n\ntotal = 0\nfor component in connected_components(graph):\n    nodes = list(component)\n    size = len(nodes)\n    seen = set()\n    current = nodes[0]\n    while len(seen) < size:\n        choice = list(graph[current])\n        if len(choice) != 2:break\n        seen.add(current)\n        possible = [c for c in choice if c not in seen]\n        if not possible: break\n        current = possible[0]\n    if len(seen) == size:\n        total+=1\nprint (total)
import sys\n\n\nn = int(input())\na = [int(t) for t in input().split(' ')]\nmx = [[] for _ in range(n)]\n\nlines = sys.stdin.readlines()\nfor i in range(n-1):\n    v1, v2 = (int(t) - 1 for t in lines[i].split(' '))\n    mx[v1].append(v2)\n    mx[v2].append(v1)\n\ncount = [[0, 0] for _ in range(n)]\n\ntotal = [a.count(1), a.count(2)]\nanswer = 0\n\nOBSERVE = 0\nCHECK = 1\n\nstack = [(OBSERVE, 0, -1)]\nwhile len(stack):\n    state, v, from_ = stack.pop()\n    if state == OBSERVE:\n        stack.append((CHECK, v, from_))\n        for nv in mx[v]:\n            if nv != from_:\n                stack.append((OBSERVE, nv, v))\n    else:\n        for nv in mx[v]:\n            if nv != from_:\n                if count[nv][0] == total[0] and count[nv][1] == 0 or count[nv][1] == total[1] and count[nv][0] == 0:\n                    answer += 1\n                count[v][0] += count[nv][0]\n                count[v][1] += count[nv][1]\n\n        if a[v] != 0:\n            count[v][a[v]-1] += 1\n\nprint(answer)\n
k = int(input())\na = reversed(input())\nb = reversed(input())\n\naa = [0] * (k + 1)\nbb = [0] * (k + 1)\nfor i, x in enumerate(a):\n    aa[i] = ord(x) - 97\nfor i, x in enumerate(b):\n    bb[i] = ord(x) - 97\n\ncarry = 0\ncc = [0] * (k + 1)\nfor i in range(k + 1):\n    cc[i] = aa[i] + bb[i] + carry\n    if cc[i] >= 26:\n        carry = 1\n        cc[i] -= 26\n    else:\n        carry = 0\n\ncarry = 0\nfor i in reversed(list(range(k+1))):\n    value = carry * 26 + cc[i]\n    carry = value % 2\n    cc[i] = value // 2\n\nanswer = ""\nfor x in reversed(cc[:-1]):\n    answer += chr(x + 97)\nprint(answer)\n\n
n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nuniq = []\nseen = set()\nfor i, x in enumerate(a):\n    if x not in seen:\n        seen.add(x)\n        uniq.append((i + 1, x))\n\nif len(uniq) < k:\n    print('NO')\nelse:\n    print('YES')\n    b = [str(i) for i, _ in uniq[:k]]\n    print(' '.join(b))\n
n = int(input())\na = list(map(int, input().split()))\ninf = 10 ** 6\ninc = [inf for i in range(0, n + 1)]\ndec = [-inf for i in range(0, n + 1)]\ntrinc = [-1 for i in range(0, n + 1)]\ntrdec = [-1 for i in range(0, n + 1)]\ninc[0] = -inf\ndec[0] = inf\n#inc means last dec was in i and we want minimize last inc\nfor i in range(0, n - 1):\n    if a[i + 1] < a[i]:\n        if inc[i + 1] > inc[i]:\n            inc[i + 1] = inc[i]\n            trinc[i + 1] = 1\n    if a[i + 1] > a[i]:\n        if dec[i + 1] < dec[i]:\n            dec[i + 1] = dec[i]\n            trdec[i + 1] = 1\n    if a[i + 1] > inc[i]:\n        if dec[i + 1] < a[i]:\n            dec[i + 1] = a[i]\n            trdec[i + 1] = 0\n    if a[i + 1] < dec[i]:\n        if inc[i + 1] > a[i]:\n            inc[i + 1] = a[i]\n            trinc[i + 1] = 0\nif inc[n - 1] == inf and dec[n - 1] == -inf:\n    print("NO")\n    return\nnow_inc = False\nans = [0 for i in range(0, n)]\nif inc[n - 1] != inf:\n    now_inc = True\nfor i in range(n - 1, -1, -1):\n    if now_inc:\n        ans[i] = 1\n        if trinc[i] == 0:\n            now_inc = False\n    else:\n        ans[i] = 0\n        if trdec[i] == 0:\n            now_inc = True\nprint("YES")\nprint(" ".join(str(x) for x in ans))\n
t = int(input())\nfor i in range(t):\n    d,v,l,r = list(map(int, input().split()))\n    ans = d // v\n    ans -= r//v - (l-1)//v\n    print(ans)\n
from math import *\n\nn = int(input())\nprint(factorial(n) // (factorial(n // 2) ** 2) * factorial(n//2-1) ** 2 // 2)\n
from collections import Counter, defaultdict\nfrom string import ascii_lowercase as al\n\nn, k = list(map(int, input().split()))\ns = list(input())\n\nC = defaultdict(int, Counter(s))\nC_ = defaultdict(int)\n\nk_ = k\nfor char in al:\n    temp = min(C[char], k_)\n\n    C_[char] += temp\n    k_ -= temp\n\nfor i, el in enumerate(s):\n    if C_[el] > 0:\n        s[i] = ''\n        C_[el] -= 1\n\nprint(''.join(s))\n
import collections\n\n\ndef main():\n    from sys import stdin, stdout\n\n    def read():\n        return stdin.readline().rstrip('\n')\n\n    def read_array(sep=None, maxsplit=-1):\n        return read().split(sep, maxsplit)\n\n    def read_int():\n        return int(read())\n\n    def read_int_array(sep=None, maxsplit=-1):\n        return [int(a) for a in read_array(sep, maxsplit)]\n\n    def write(*args, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\n')\n        stdout.write(sep.join(str(a) for a in args) + end)\n\n    def write_array(array, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\n')\n        stdout.write(sep.join(str(a) for a in array) + end)\n\n    def enough(days):\n        bought = []  # (type, amount)\n        bought_total = 0\n        used_from = days\n        for d in range(days, 0, -1):\n            used_from = min(d, used_from)\n            for t in offers.get(d, []):\n                if K[t] > 0:\n                    x = min(K[t], used_from)\n                    K[t] -= x\n                    bought.append((t, x))\n                    bought_total += x\n                    used_from -= x\n            if not used_from:\n                break\n        remaining_money = days - bought_total\n        ans = (total_transaction - bought_total) * 2 <= remaining_money\n        for t, a in bought:\n            K[t] += a\n        return ans\n\n    n, m = read_int_array()\n    K = read_int_array()\n    total_transaction = sum(K)\n    offers = collections.defaultdict(list)\n    for _ in range(m):\n        d, t = read_int_array()\n        offers[d].append(t-1)\n\n    low = total_transaction\n    high = low * 2\n    ans = high\n    while low <= high:\n        mid = (low + high) // 2\n        if enough(mid):\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    write(ans)\n\n\nmain()\n
n,m=map(int,input().split())\ng=[[*input()] for _ in range(n)]\nc=[[0 for _ in range(m)] for _ in range(n)]\nfor i in range(n):\n v=0\n for j in range(m):\n  v=(v+1)*(g[i][j]=='*')\n  c[i][j]=v\n v=0\n for j in range(m-1,-1,-1):\n  v=(v+1)*(g[i][j]=='*')\n  c[i][j]=min(c[i][j],v)\nfor j in range(m):\n v=0\n for i in range(n):\n  v=(v+1)*(g[i][j]=='*')\n  c[i][j]=min(c[i][j],v)\n v=0\n for i in range(n-1,-1,-1):\n  v=(v+1)*(g[i][j]=='*')\n  c[i][j]=min(c[i][j],v)\nfor i in range(n):\n for j in range(m):\n  if c[i][j]==1: c[i][j]=0\nfor i in range(n):\n v=0\n for j in range(m):\n  v=max(v-1,c[i][j])\n  if v:g[i][j]='.'\n v=0\n for j in range(m-1,-1,-1):\n  v=max(v-1,c[i][j])\n  if v:g[i][j]='.'\nfor j in range(m):\n v=0\n for i in range(n):\n  v=max(v-1,c[i][j])\n  if v:g[i][j]='.'\n for i in range(n-1,-1,-1):\n  v=max(v-1,c[i][j])\n  if v:g[i][j]='.'\nif all(g[i][j]=='.' for i in range(n) for j in range(m)):\n r=[(i+1,j+1,c[i][j]-1) for i in range(n) for j in range(m) if c[i][j]]\n print(len(r))\n for t in r: print(*t)\nelse:\n print(-1)
A,B,C=map(int,input())\nif A==C:\n  print('Yes')\nelse:\n  print('No')
a,b = map(int, input().split())\nif a == b:\n  print("Draw")\nelif a == 1 or (a > b and b != 1):\n  print("Alice")\nelse:\n  print("Bob")
print(' '.join(input().split(',')))
n,m=list(map(int,input().split()))\nab=[[int(x) for x in input().split()] for _ in range(n)]\ncd=[[int(x) for x in input().split()] for _ in range(m)]\n\nfor a,b in ab:\n  ans=list()\n  for c,d in cd:\n    ans.append(abs(a-c)+abs(b-d))\n  print((ans.index(min(ans))+1))\n
a = int(input())\n\nans = a + a**2 + a**3\n\nprint(ans)\n\n
n, m = map(int, input().split())\na = ["" for _ in range(n)]\nb = ["" for _ in range(m)]\nfor i in range(n):\n    a[i] = str(input())\nfor i in range(m):\n    b[i] = str(input())\ndef check(ini_x, ini_y):\n    nonlocal n, m, a, b\n    for x in range(m):\n        for y in range(m):\n            if a[ini_x + x][ini_y + y] != b[x][y]:\n                return False\n    return True\nfor i in range(n - m + 1):\n    for j in range(n - m + 1):\n        if check(i, j):\n            print("Yes")\n            return\nprint("No")
a=input().split()\na.sort(reverse=True)\nif len(set(a))==1:\n  print(12*int(a[0]))\nelse:\n  ans=int(a[0]+a[1])+int(a[2])\n  print(ans)
def main():\n    p = []\n    sum_cost = 0\n    n = int(input())\n    for i in range(n):\n        p.append(int(input()))\n    max_p = max(p)\n    p[p.index(max_p)] = max_p / 2\n    print((int(sum(p))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
import math\na = []\nfor i in range(5):\n    a.append(int(input()))\nsum = 0\nr =10\nfor i in range(5):\n  if a[i] % 10 ==0:\n    sum+=a[i]\n  elif a[i] % 10 !=0:\n    r = min(r,a[i]%10)\n    sum+= (10*math.ceil(a[i]/10))\nprint(sum-10+r)
n=int(input())\na=list(map(lambda x:1/int(x),input().split()))\nprint(1/sum(a))
n,k = map(int,input().split())\nL = sorted(list(int(input()) for _ in range(n)))\nm = 10**9\n\nfor i in range(n-k+1):\n  m = min(m, L[i+k-1]-L[i])\n\nprint(m)
S = input()\nans = 'A'\nif S.islower():\n  ans = 'a'\n\nprint(ans)
k,s=map(int,input().split())\nprint(len([2 for z in range(k+1) for y in range(k+1) if 0<=s-y-z<=k]))
s=input()\ns1=int(s[0]+s[1])\ns2=int(s[2]+s[3])\nif (0<s1<13)and(0<s2<13):\n    print("AMBIGUOUS")\nelif (0<s1<13):\n    print("MMYY")\nelif (0<s2<13):\n    print("YYMM")\nelse:\n    print("NA")
n=int(input())\nodd=(n+1)//2\neven=n//2\nprint(odd*even)
a,b = map(int,input().split())\nb += a\nif b>23:\n    print(b-24)\nelse:\n    print(b)
n, r = map(int, input().split())\n\nprint(r+100*(10-min(10, n)))
n, k = list(map(int, input().split()))\nans = 0\n\nwhile int(n) > 0:\n    n = n // k\n    ans += 1\n\nprint(ans)\n
print(-(-int(input()) // 2))
a, b = map(int, input().split())\nprint("Yay!" if a <= 8 and b <= 8 else ":(")
S=input()\na=1145141919810\nfor i in range(len(S)-2):\n  a=min(a,abs(753-int(S[i:i+3])))\nprint(a)
from bisect import *\nfrom collections import *\nfrom itertools import *\nimport functools\nimport sys\nimport math\nfrom decimal import *\nfrom copy import *\nfrom heapq import *\ngetcontext().prec = 30\nMAX = sys.maxsize\nMAXN = 10**6+1\nMOD = 10**9+7\nspf = [i for i in range(MAXN)]\ndef sieve():\n    for i in range(2,MAXN,2):\n        spf[i] = 2\n    for i in range(3,int(MAXN**0.5)+1):\n        if spf[i]==i:\n            for j in range(i*i,MAXN,i):\n                if spf[j]==j:\n                    spf[j]=i\n\ndef mhd(a,b):\n    return abs(a[0]-b[0])+abs(b[1]-a[1])\n\ndef charIN(x= ' '):\n    return(sys.stdin.readline().strip().split(x))\n\ndef arrIN(x = ' '):\n    return list(map(int,sys.stdin.readline().strip().split(x)))\n\ndef eld(x,y):\n    a = y[0]-x[0]\n    b = x[1]-y[1]\n    return (a*a+b*b)**0.5\n\ndef lgcd(a):\n    g = a[0]\n    for i in range(1,len(a)):\n        g = math.gcd(g,a[i])\n    return g\n\ndef ms(a):\n    msf = -MAX\n    meh = 0\n    st = en = be = 0\n    for i in range(len(a)):\n        meh+=a[i]\n        if msf<meh:\n            msf = meh\n            st = be\n            en = i\n        if meh<0:\n            meh = 0\n            be = i+1\n    return msf,st,en\n\ndef ncr(n,r):\n    num=den=1\n    for i in range(r):\n        num = (num*(n-i))%MOD\n        den = (den*(i+1))%MOD\n\n    return (num*(pow(den,MOD-2,MOD)))%MOD\n\n\n\ndef flush():\n    return sys.stdout.flush()\n\n'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''\nn = int(input())\na = arrIN()\nmx = max(a)\ncnt = 0\ntemp = []\nfor i in a:\n    cnt+=mx-i\n    temp.append(mx-i)\ng = lgcd(temp)\nprint(cnt//g,g)\n\n\n\n
def main():\n    n = int(input())\n    arr = sorted(map(int, input().split()))\n    j = 1\n    for x in arr:\n        if x >= j:\n            j += 1\n    print(j - 1)\n    return 0\n\nmain()
import math\nn,m=map(int,input().split())\nneigh=[]\nfor i in range(n):\n    neigh.append([])\nfor i in range(m):\n    a,b=map(int,input().split())\n    neigh[a-1].append(b-1)\n    neigh[b-1].append(a-1)\nseen=set()\nindex=[0]*n\ndiams=[]\ntrees=0\nfor i in range(n):\n    if i not in seen:\n        trees+=1\n        index[i]=trees\n        seen.add(i)\n        layer=[i]\n        prev=None\n        pars=[None]\n        while layer!=[]:\n            newlayer=[]\n            newpars=[]\n            for i in range(len(layer)):\n                vert=layer[i]\n                par=pars[i]\n                for child in neigh[vert]:\n                    if child!=par:\n                        newlayer.append(child)\n                        newpars.append(vert)\n                        index[child]=trees\n                        seen.add(child)\n            prev=layer\n            layer=newlayer\n            pars=newpars\n        far=prev[0]\n        layer=[[far]]\n        pars=[None]\n        prev=None\n        while layer!=[]:\n            newlayer=[]\n            newpars=[]\n            for i in range(len(layer)):\n                vert=layer[i][-1]\n                par=pars[i]\n                for child in neigh[vert]:\n                    if child!=par:\n                        newlayer.append(layer[i]+[child])\n                        newpars.append(vert)\n            prev=layer\n            layer=newlayer\n            pars=newpars\n        diam=prev[0]\n        lent=len(diam)\n        mid=diam[lent//2]\n        diams.append((lent-1,mid))\ndiams.sort(reverse=True)\nposs=[diams[0][0]]\nif len(diams)>1:\n    poss.append(math.ceil(diams[0][0]/2)+1+math.ceil(diams[1][0]/2))\nif len(diams)>2:\n    poss.append(math.ceil(diams[1][0]/2)+2+math.ceil(diams[2][0]/2))\nprint(max(poss))\ncent=diams[0][1]\nfor i in range(len(diams)-1):\n    print(cent+1,diams[i+1][1]+1)
n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\ng = {}\n\ndef dfs(v, p=-1):\n	c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n	c.sort(key=len, reverse=True)\n	r = []\n	i = 0\n	while c:\n		if i >= len(c[-1]):\n			c.pop()\n		else:\n			o = max(i, k - i - 1)\n			s = q = 0\n			for x in c:\n				if len(x) <= o:\n					q = max(q, x[i])\n				else:\n					s += x[o]\n					q = max(q, x[i] - x[o])\n			r.append(q + s)\n			i += 1\n	r.append(0)\n	for i in range(len(r) - 1, 0, -1):\n		r[i - 1] = max(r[i - 1], r[i])\n	while len(r) > 1 and r[-2] == 0:\n		r.pop()\n	o = (r[k] if k < len(r) else 0) + a[v]\n	r.insert(0, max(o, r[0]))\n	return r\n\n\nfor _ in range(1, n):\n	u, v = [int(x) - 1 for x in input().split()]\n	g.setdefault(u, set()).add(v)\n	g.setdefault(v, set()).add(u)\n\nprint(dfs(0)[0])\n
d,l = list(map(int,input().split()))\n\na = list(map(int,input().split()))\nletters = list(map(int,input().split()))\n\npos = [0] * (1+d)\n\nfor i,x in enumerate(a):\n    pos[i+1] = pos[i] + x\n\nres = []\ni = 1\nfor letter in letters:\n    while pos[i]<letter: i+=1\n    res.append(str(i) + " " + str(letter - pos[i-1]))\nprint('\n'.join(res))\n
A = list(map(int, input().split()))\nA.sort()\nprint(A[3] - A[0], A[3] - A[2], A[3] - A[1])\n
def deal(a,b,c='0'):\n    if(c=='0' or a==c):\n        if(a=='R'):\n            return 'B'\n        if(a=='B'):\n            return 'R'\n        if(a=='G'):\n            return 'B'\n    if(a=='R' and c=='B'):\n        b = 'G'\n    if (a == 'R' and c == 'G'):\n        b = 'B'\n    if (a == 'B' and c == 'R'):\n        b = 'G'\n    if (a == 'B' and c == 'G'):\n        b = 'R'\n    if (a == 'G' and c == 'B'):\n        b = 'R'\n    if (a == 'G' and c == 'R'):\n        b = 'B'\n    return b\nn = int(input())\nss = input()\ns = list(ss)\nanswer = [s[0]]\nnumber = 0\nfor i in range(0,n-1):\n    ans = ""\n    if (s[i]==s[i+1]):\n        number += 1\n        if(i==n-2):\n            ans = deal(s[i],s[i+1])\n        else:\n            ans = deal(s[i],s[i+1],s[i+2])\n        s[i+1] = ans\n        answer.append(ans)\n    else:\n        answer.append(s[i+1])\ns = "".join(answer)\nprint(number)\nprint(s)
from collections import *\ninput()\na = list(map(int, input().split()))\nm = defaultdict(int)\nfor x in reversed(a): m[x] = m[x + 1] + 1\nv = max(list(m.keys()), key=m.get)\nseq = []\nfor i, x in enumerate(a):\n    if v == x:\n        seq.append(i + 1)\n        v += 1\nprint(len(seq))\nprint(*seq)\n
a, b = map(int, input().split())\nif a == 2 or b == 2:\n  print('No')\nelse:\n  print('Yes')
train_fare, bus_fare = list(map(int, input().split()))\nprint((train_fare + bus_fare // 2))\n
n = int(input())\nprint(n*n*n)
n = int(input())\nif any(c == n for c in [3, 5, 7] ) :\n    print("YES")\nelse:\n    print("NO")
a='ABD'\nif int(input())<1000:a='ABC'\nprint(a)
a=int(input())\nb=int(input())\nc=int(input())\nd=int(input())\ne=int(input())\nx=int(input())\nls=[a,b,c,d,e]\nif (e-a)<=x:\n  print("Yay!")\nelse:\n  print(":(")
a = int(input())\ns = input()\nif a >= 3200:\n    print(s)\nelse:\n    print('red')
R = int(input())\nif R < 1200:\n    print("ABC")\nelif R < 2800:\n    print("ARC")\nelse:\n    print("AGC")
s = list(input())\n\nfor i in range(3):\n  if s[i] == '1':\n    s[i] = '9'\n  else:\n    s[i] = '1'\n\nt = ''\nfor i in range(3):\n  t += s[i]\n  \nprint(t)
import sys\nimport random\nfrom math import *\n \ndef input():\n    return sys.stdin.readline().strip()\n \ndef iinput():\n    return int(input())\n\ndef finput():\n    return float(input())\n\ndef tinput():\n    return input().split()\n\ndef linput():\n    return list(input())\n \ndef rinput():\n    return map(int, tinput())\n\ndef fiinput():\n    return map(float, tinput())\n \ndef rlinput():\n    return list(map(int, input().split()))\ndef trinput():\n    return tuple(rinput())\n\ndef srlinput():\n    return sorted(list(map(int, input().split())))\n\ndef YESNO(fl):\n    if fl:\n        print("NO")\n    else:\n        print("YES")\n    \n    \ndef main():   \n    #n = iinput() \n    #k = iinput() \n    #m = iinput() \n    #n = int(sys.stdin.readline().strip()) \n    #n, k = rinput()\n    #n, m = rinput()\n    #m, k = rinput()\n    #n, k, m = rinput()\n    #n, m, k = rinput()\n    #k, n, m = rinput()\n    #k, m, n = rinput() \n    #m, k, n = rinput()\n    #m, n, k = rinput()\n    #q = srlinput()\n    #q = rlinput()\n    s = input()\n    print(s[:2] + s[3::2])\n\n    \n    \n            \n            \n    \n    \n    \n    \nfor inytd in range(iinput()):\n    main()
q = int(input())\nfor _ in range(q):\n    a, b = list(map(int, input().split()))\n    print((b - a % b) % b)\n
n,k=list(map(int,input().split()))\na=list(map(int,input().split()))\nprefix=[a[0]]\nfor i in range(1,n):\n    prefix.append(prefix[-1]+a[i])\nans=[]\nfor i in range(n):\n    for j in range(i+k-1,n):\n        if(i==0):\n            ans.append(prefix[j]/(j-i+1))\n        else:\n            ans.append((prefix[j]-prefix[i-1])/(j-i+1))\nprint(max(ans))
for _ in range(int(input())):\n    n, m = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    p = set(map(int, input().split()))\n    for i in range(len(l)):\n        for j in range(len(l) - 1):\n            if l[j] > l[j + 1] and j + 1 in p:\n                l[j], l[j + 1] = l[j + 1], l[j]\n    ans = True\n    for i in range(len(l) - 1):\n        if l[i] > l[i + 1]:\n            ans = False\n            break\n    print('YES' if ans else 'NO')\n
n = int(input())\ns = input()\ni = 0\nd = 1\nt = []\nwhile i < n:\n    t.append(s[i])\n    i += d\n    d += 1\n\nprint(''.join(t))\n
import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nEDGE=[list(map(int,input().split())) for i in range(m)]\n\nEDGE.sort(key=lambda x:x[2])\n\nWCHANGE=[]\nfor i in range(1,m):\n    if EDGE[i-1][2]!=EDGE[i][2]:\n        WCHANGE.append(i)\n\nWCHANGE.append(m)\n\nGroup=[i for i in range(n+1)]\n\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\n\nNOW=0\nnoneed=[0]*m\nANS=0\nfor wc in WCHANGE:\n    for j in range(NOW,wc):\n\n        if find(EDGE[j][0])==find(EDGE[j][1]):\n            noneed[j]=1\n\n    for j in range(NOW,wc):\n        if noneed[j]==1:\n            continue      \n        x,y,w=EDGE[j]\n        if find(x)!=find(y):\n            Union(x,y)\n        else:\n            ANS+=1\n\n    NOW=wc\n\nprint(ANS)\n        \n
starts = ["RGB", "RBG", "BRG", "BGR", "GRB", "GBR"]\n\nN = int(input())\ns = input()\n\nmin_cost = float("inf")\nmin_str = ""\n\nfor k in starts:\n	sp = (k * -(-N // 3))[:N]\n	cost = sum(x != y for x, y in zip(s, sp))\n	if cost < min_cost:\n		min_cost = cost\n		min_str = sp\n\nprint(min_cost)\nprint(min_str)
N = int(input())\nx = [0] * N\nu = [0] * N\nfor i in range(N):\n    x[i], u[i] = list(map(str, input().split()))\n\nans = 0\nfor i in range(N):\n    if u[i] == 'JPY':\n        ans += float(x[i])\n    else:\n        ans += float(x[i]) * 380000\n\nprint(ans)\n
N, i = list(map(int, input().split()))\n\nprint(N - i + 1)
a = int(input())\np, q = input().split()\n\nans = ''\nfor i in range(a):\n    ans += p[i]\n    ans += q[i]\nprint(ans)\n
S = list(map(str,input()))\n\nif S[0] != S[1] or S[1] != S[2]:\n    print("Yes")\nelse:\n    print("No")
S = str(input())\nif "RRR" in S:\n    print(3)\nelif "RR" in S:\n    print(2)\nelif "R" in S:\n    print(1)\nelse:\n    print(0)
x,y,z=map(int,input().split())\nprint(z,end=' ')\nprint(x,end=' ')\nprint(y,end='')
# ABC127\n# A Ferris Wheel\na, b = list(map(int, input().split()))\nif a > 12:\n    print(b)\n    return\nelif a < 6:\n    print((0))\n    return\nelse:\n    print((b // 2))\n    return\n
S=input()\nprint((S.count('+')-S.count('-')))\n
import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    S = readline().strip()\n\n    y, m, d = list(map(int, S.split('/')))\n    if m <= 4:\n        print('Heisei')\n    elif m > 4:\n        print('TBD')\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件\n    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit\n    \nN  = getIntList()\nza  = getIntList()\n\ncc = collections.Counter(za)\nzt = []\nfor x in cc:\n    zt.append( cc[x] )\n\nzt.sort( )\n\nre = zt[-1] \n\ndef findmid(l,r, e):\n    if l>= len(zt):\n        return -1\n    if e<=zt[l]: return l;\n    if e>zt[r]: return -1\n    while l+1 <r:\n        mid = (l+r)//2\n        if zt[mid] < e:\n            l = mid\n        else:\n            r = mid\n    return r\nfor first in range(1, re//2 + 1):\n    nowr = 0\n    t = first\n    ind = -1\n    while 1:\n        ind = findmid(ind+1,len(zt)-1, t)\n        if ind<0:\n            break\n        nowr += t\n        t*=2\n    re = max(re, nowr)\nprint(re)\n\n\n\n\n\n\n\n\n
from collections import deque\nn, k = map(int, input().split())\nA = list(map(int, input().split()))\nB = deque()\nB.append(A[0])\nfor i in range(1, n):\n    if A[i] not in B:\n        if len(B) == k:\n            B.popleft()\n        B.append(A[i])\n    else:\n        pass\nprint(len(B))\nprint(*list(B)[::-1])
from collections import Counter\n\nn, q = map(int, input().split())\na = map(int, input().split())\nb = [int(input()) for _ in range(q)]\n\ncounts = 32 * [0]\n\nfor value, count in Counter(a).items():\n    counts[value.bit_length() - 1] = count\n\nfor bj in b:\n    ans = 0\n    \n    for i in reversed(range(32)):\n        count = min(bj >> i, counts[i])\n        ans += count\n        bj -= count << i\n    \n    if bj != 0:\n        print(-1)\n    else:\n        print(ans)
\nfrom queue import Queue\nimport sys\nimport math\nimport os.path\n\n# CONFIG\nsys.setrecursionlimit(10**9)\n\n# LOG\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\n# INPUT\ndef ni():\n    return list(map(int, input().split()))\n\n\ndef nio(offset):\n    return [int(x) + offset for x in input().split()]\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n\n# CONVERT\ndef toString(aList, sep=" "):\n    return sep.join(str(x) for x in aList)\n\n\ndef mapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\ndef countMap(arr):\n    m = {}\n    for x in arr:\n        m[x] = m.get(x,0) + 1\n    return m\n\ndef sortId(arr):\n    return sorted(list(range(arr)), key=lambda k: arr[k])\n\n# MAIN\n\nn, k = ni()\nc = nia()\nf = nia()\nh = [0] + (nia())\n\ncc = countMap(c)\ncf = countMap(f)\n\nn1 = n+1\nk1 = k+1\n\nnk1 = n*k+1\ndp = [[0]*nk1 for _ in range(n1)]\n\n\nfor ni in range(1,n1):\n    for ki in range(1,nk1):\n        mficount = min(k,ki) + 1        \n        for kii in range(mficount):\n            # log(ni,ki, kii, dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n            dp[ni][ki] = max(dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n    # log(dp[ni])\n\n# log(n,k)\n# log("c", cc)\n# log("f", cf)\n# log("h", h)\n# log(dp)\n\nres = 0\n\n\nfor fk,fv in list(cf.items()):\n    # log(fk, fv, cc.get(fk,0))\n    res += dp[fv][cc.get(fk,0)]\n\nprint(res)\n
def main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    dct = {}\n    k = -1\n    m = 0\n    for i in range(n):\n        try: dct[arr[i]] += 1\n        except: dct[arr[i]] = 1\n        if dct[arr[i]] > m:\n            m = dct[arr[i]]\n            k = arr[i]\n    \n    print(n - m)\n    \n    for i in range(n):\n        if arr[i] == k:\n            for j in range(i - 1, -1, -1):\n                if arr[j] > k: print(2, j + 1, j + 2)\n                else: print(1, j + 1, j + 2)\n            break\n    \n    while i != n:\n        if arr[i] > k: print(2, i + 1, i)\n        if arr[i] < k: print(1, i + 1, i)\n        i += 1\n    return 0\n\nmain()
import sys\nINF = 10**20\nMOD = 10**9 + 7\nI = lambda:list(map(int,input().split()))\nfrom math import gcd\nfrom math import ceil\nfrom collections import defaultdict as dd, Counter\nfrom bisect import bisect_left as bl, bisect_right as br\n\ndef solve():\n  n, k = I()\n  s = input()\n  ans = 0\n  last = -INF\n  for i in range(n):\n    if s[i] == '1':\n      if i - last <= k:\n        ans -= 1\n      last = i\n      count = 0\n      continue\n    if i - last > k:\n      ans += 1\n      last = i \n\n  print(ans)\n\nt, = I()\nwhile t:\n  t -= 1\n  solve()
from operator import itemgetter\nimport sys\ninput = sys.stdin.readline\n\n\nn, m = map(int, input().split())\ninfo = [list(map(int, input().split())) + [i] for i in range(n)]\ninfo = sorted(info, key = itemgetter(1))\nmax_num = info[-1][1]\n\nN = max_num\nINF = 0\nLV = (N-1).bit_length()\nN0 = 2**LV\ndata = [0]*(2*N0)\nlazy = [0]*(2*N0)\n\ndef gindex(l, r):\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & -L).bit_length()\n    rc = 0 if r & 1 else (R & -R).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if L < R and lc <= i:\n            yield L\n        L >>= 1; R >>= 1\n\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i-1]\n        if not v:\n            continue\n        lazy[2*i-1] += v; lazy[2*i] += v\n        data[2*i-1] += v; data[2*i] += v\n        lazy[i-1] = 0\n\ndef update(l, r, x):\n    *ids, = gindex(l, r)\n    propagates(*ids)\n\n    L = N0 + l; R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R-1] += x; data[R-1] += x\n        if L & 1:\n            lazy[L-1] += x; data[L-1] += x\n            L += 1\n        L >>= 1; R >>= 1\n    for i in ids:\n        data[i-1] = max(data[2*i-1], data[2*i])\n\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l; R = N0 + r\n\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R-1])\n        if L & 1:\n            s = max(s, data[L-1])\n            L += 1\n        L >>= 1; R >>= 1\n    return s\n\nans = []\nfor i in range(n):\n    l, r, j = info[i]\n    r += 1\n    if query(l, r) < m:\n        update(l, r, 1)\n    else:\n        ans.append(j+1)\nprint(len(ans))\nprint(*ans)
import sys\ninput = sys.stdin.readline\n\nq=int(input())\nfor testcase in range(q):\n    n=int(input())\n    A=sorted(set(map(int,input().split())),reverse=True)\n    L=len(A)\n\n    #print(A)\n    ANS=A[0]\n    for i in range(L):\n        NOW0=A[i]\n        NOW1=0\n\n        flag=0\n        for j in range(i+1,L):\n            if NOW0%A[j]!=0:\n                NOW1=A[j]\n                ANS=max(ANS,NOW0+NOW1)\n\n                for k in range(j+1,L):\n                    if NOW0%A[k]!=0 and NOW1%A[k]!=0:\n                        ANS=max(ANS,NOW0+NOW1+A[k])\n                        #print("!",ANS)\n                        break\n\n                break\n\n    print(ANS)\n        \n\n
for _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    ans = 1\n    for i in range(n - 1):\n        if A[i] + 1 == A[i + 1]:\n            ans = 2\n            break\n    print(ans)
q=int(input())\nfor t in range(q):\n    a,b,n,s=map(int,input().split())\n    v=min(a*n,s//n*n)\n    if s-v>b:\n        print("NO")\n    else:\n        print("YES")
n = int(input())\na = list(map(int, input().split()))\na.sort()\n\ninc = list()\ndec = list()\nfor x in a:\n    if inc and inc[-1] == x:\n        if dec and dec[-1] == x:\n            print('NO')\n            return\n        dec.append(x)\n    else:\n        inc.append(x)\n\nprint('YES')\nprint(len(inc))\nfor x in inc:\n    print(x, end=' ')\nprint()\nprint(len(dec))\nfor x in reversed(dec):\n    print(x, end=' ')\nprint()
from sys import stdin\n\nn,k = list(map(int, stdin.readline().strip().split(' ')))\n\nAB = []\nA = []\nB = []\n\nfor i in range(n):\n    t,a,b = list(map(int, stdin.readline().strip().split(' ')))\n    if a == 1 and b == 1:\n        AB.append(t)\n    elif a == 1:\n        A.append(t)\n    elif b == 1:\n        B.append(t)\n\nAB.sort()\nA.sort()\nB.sort()\n\nans = 0\nabi = 0\nai = 0\nbi = 0\nisPossible = True\nfor i in range(k):\n    if abi == len(AB) and (ai == len(A) or bi == len(B)):\n        isPossible = False\n        break\n    if abi == len(AB):\n        ans += (A[ai] + B[bi])\n        ai += 1\n        bi += 1\n        continue\n    if ai == len(A) or bi == len(B):\n        ans += AB[abi]\n        abi += 1\n        continue\n    if A[ai] + B[bi] <= AB[abi]:\n        ans += (A[ai] + B[bi])\n        ai += 1\n        bi += 1\n        continue\n    ans += AB[abi]\n    abi += 1\n    continue\nif isPossible:\n    print(ans)\nelse:\n    print(-1)\n\n\n
for ei in range(int(input())):\n    n, k = map(int, input().split())\n    A = list(map(int, input().split()))\n    ans = min(A) + k\n    for i in A:\n        if ans != -1 and abs(ans - i) > k:\n            ans = -1\n    print(ans)
#!/usr/bin/env python\nn = int(input())\na = list(map(int, input().split()))\nk = [None, 4, 8, 15, 16, 23, 42]\ns = [n, 0, 0, 0, 0, 0, 0]\nfor ai in a:\n    for i in range(6, 0, -1):\n        if ai == k[i] and s[i - 1] > 0:\n            s[i] += 1; s[i - 1] -= 1\n            break\nprint(n - 6 * s[-1])\n
for _ in range(int(input())):\n    a,b=map(int,input().split())\n    print((abs(a-b)+9)//10)
ntest = int(input())\nfor testcase in range(ntest):\n    x, y, n = list(map(int, input().split()))\n    t = (n - y) // x * x + y\n    print(t)\n
n, k = map(int, input().split())\nD = list(map(int, input().split()))\nz = {i: 0 for i in range(k)}\nfor i in range(n):\n    z[D[i] % k] += 1\ncnt = z[0] // 2\nfor q in range(1, k // 2 + k % 2):\n    cnt += min(z[q], z[k - q])\nif k % 2 == 0:\n    cnt += z[k // 2] // 2\nprint(cnt * 2)
N, K = map(int, input().split())\nS = input()\nprint("".join(c.lower() if i == K else c for i, c in enumerate(S, 1)))
n=int(input())\na=[]\nfor i in range(n):\n  t=list(input().split())\n  t[1]=int(t[1])\n  t.append(i)\n  a.append(t)\na.sort(key=lambda x:(x[0],-x[1]))\nfor t in a:\n  print(t[2]+1)
k,x = map(int,input().split())\nprint("Yes" if k*500 >= x else "No")
n,k = map(int,input().split())\n\nans = 0\n\nfor i in range(1,n+1):\n    if i>=k:\n        ans += (1/n)\n        continue\n    x = 1\n    while 1:\n        i *= 2\n        if i>=k:\n            break\n        else:x+=1\n    ans += (1/n)*(1/2)**x\nprint(ans)
S = input()\nW = ["SUN","MON","TUE","WED","THU","FRI","SAT"]\nprint(7-W.index(S))
r, D, x = map(int, input().split())\n\nfor i in range(10):\n    x = r * x - D\n    print(x)
input()\nnum = list(map(int, input().split()))\nmaxn = 0\nl, r = 0, len(num)-1\nj1, j2 = num[l], num[r]\nwhile l < r:\n    if j1 == j2:\n        maxn = max(j1, maxn)\n        l += 1\n        j1 += num[l]\n    elif j1 < j2:\n        l += 1\n        j1 += num[l]\n    else:\n        r -= 1\n        j2 += num[r]\nprint(maxn)\n
for testcase in range(int(input())):\n    vals = list(map(int, input().split()))\n    \n    ans = None\n    for a in vals:\n        for b in vals:\n            for c in vals:\n                if max(a, b) == vals[0] and max(a, c) == vals[1] and max(b, c) == vals[2]:\n                    ans = [a, b, c]\n    \n    if ans is None:\n        print("NO")\n    else:\n        print("YES")\n        print(*ans)\n                    \n
n, m, k = [int(_) for _ in input().split()]\na = [int(_) for _ in input().split()]\n\nb = k\ncount = 0\nfor obj in a[::-1]:\n    if obj > k:\n        break\n    if obj > b:\n        if m > 1:\n            m -= 1\n            b = k - obj\n            count += 1\n        else:\n            break\n    else:\n        b -= obj\n        count += 1\n\nprint(count)\n\n
n, k = map(int, input().split())\ns = set()\nst = input()\ninp = input().split()\nfor x in inp:\n    s.add(x)\ncurrent, ans = 0, 0\nfor x in st:\n    if x in s:\n        current += 1\n    else:\n        ans += (current * (current + 1)) // 2\n        current = 0\nans += (current * (current + 1)) // 2\nprint(ans)
for _ in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    a=[]\n    lis=[]\n    prevsign=-1\n    if l[0]>0:\n        prevsign=1\n    else:\n        prevsign=0\n    i=0\n    for i in l:\n        if (i>0 and prevsign==1) or (i<0 and prevsign==0):\n            lis.append(i)\n        else:\n            if prevsign==1:\n                a.append(max(lis))\n                lis=[]\n                lis.append(i)\n                prevsign=0\n            else:\n                a.append(max(lis))\n                lis=[]\n                lis.append(i)\n                prevsign=1\n    \n    if prevsign==1:\n        a.append(max(lis))\n        lis=[]\n        lis.append(i)\n        prevsign=0\n    else:\n        a.append(max(lis))\n        lis=[]\n        lis.append(i)\n        prevsign=1\n    print(sum(a))\n        \n
n, m = map(int, input().split())\ng = []\nfor i in range(n):\n    g.append([])\nfor i in range(m):\n    u, v = map(int, input().split())\n    u-=1\n    v-=1\n    g[u]+=[v]\n    g[v]+=[u]\n\nstart = max(range(n), key=lambda i: len(g[i]))\nedges = []\nvis = [False] * n\nq = [start]\nvis[start] = True\nwhile q:\n    u = q.pop(0)\n    for v in g[u]:\n        if vis[v]:\n            continue\n        vis[v] = True\n        edges.append((u, v))\n        q.append(v)\n\nfor u, v in edges:\n    print(u+1, v+1)
a=int(input())\n\nfor ufui in range(a):\n    val=int(input())\n\n    num=val//2 + 1\n    count=0\n\n    for i in range(num):\n        count=count+i*((2*i+1)**2 - (2*i-1)**2)\n\n    print (count)\n    \n
from heapq import heappush, heappop\n\nn = int(input())\na = list(map(int, input().split()))\nedge = [[] for _ in range(n)]\nrev = [[] for _ in range(n)]\ninf = 10**9\ncost = [inf]*n\nhq = []\n\nfor i, x in enumerate(a):\n    if i+x < n:\n        edge[i].append(i+x)\n        rev[i+x].append(i)\n        if (a[i] ^ a[i+x]) & 1:\n            cost[i] = 1\n    if i-x >= 0:\n        edge[i].append(i-x)\n        rev[i-x].append(i)\n        if (a[i] ^ a[i-x]) & 1:\n            cost[i] = 1\n\n    if cost[i] == 1:\n        hq.append((1, i))\n\nwhile hq:\n    c, v = heappop(hq)\n    if cost[v] < c:\n        continue\n    c += 1\n    for dest in rev[v]:\n        if cost[dest] > c:\n            cost[dest] = c\n            heappush(hq, (c, dest))\n\nfor i in range(n):\n    if cost[i] == inf:\n        cost[i] = -1\n\nprint(*cost)\n
#-------------Program--------------\n#----Kuzlyaev-Nikita-Codeforces----\n#-------------Round615-------------\n#----------------------------------\n\nt=int(input())\nfor i in range(t):\n    n=int(input())\n    a=[]\n    for i in range(2,int(n**0.5)+2):\n        if len(a)==2:\n            a.append(n)\n            break        \n        if n%i==0:\n            a.append(i)\n            n//=i\n    a=list(set(a))\n    if len(a)==3 and a.count(1)==0:\n        print('YES')\n        a.sort()\n        print(a[0],a[1],a[2])\n    else:\n        print('NO')\n
import sys\ninput = sys.stdin.readline\n\nn=int(input())\ns=list(input().strip())\n\nANS=0\nfor i in range(0,n,2):\n    if s[i]==s[i+1]:\n        ANS+=1\n        if s[i]=="a":\n            s[i]="b"\n        else:\n            s[i]="a"\n\nprint(ANS)\nprint("".join(s))\n
\n\ndef solve():\n    Point=[]\n    n=int(input())\n    for i in range(n):\n        x,y=list(map(int,input().split()))\n        Point.append((x,y))\n    data={}\n    for each in Point:\n        if each[0]<each[1]:\n            try:\n                tm=data[each[1]]\n            except KeyError:\n                data[each[1]]={}\n            try:\n                data[each[1]]['xi']=min(data[each[1]]['xi'],each[0])\n            except KeyError:\n                data[each[1]]['xi']=each[0]\n            try:\n                data[each[1]]['xa'] = max(data[each[1]]['xa'], each[0])\n            except KeyError:\n                data[each[1]]['xa'] = each[0]\n        else:\n            try:\n                tm=data[each[0]]\n            except KeyError:\n                data[each[0]]={}\n            try:\n                data[each[0]]['yi']=min(data[each[0]]['yi'],each[1])\n            except KeyError:\n                data[each[0]]['yi']=each[1]\n            try:\n                data[each[0]]['ya']=max(data[each[0]]['ya'],each[1])\n            except KeyError:\n                data[each[0]]['ya'] = each[1]\n    pre1=(0,0,0)\n    pre2=(0,0,0)\n    for each in sorted(data.keys()):\n        x1,y1,w1=pre1\n        x2,y2,w2=pre2\n        if len(data[each])==2:\n            if 'xa' in data[each]:\n                x3, y3 = data[each]['xa'], each\n                x4, y4 = data[each]['xi'], each\n            if 'ya' in data[each]:\n                x3, y3 = each, data[each]['ya']\n                x4, y4 = each, data[each]['yi']\n        else:\n            x3,y3=data[each]['xi'],each\n            x4,y4=each,data[each]['yi']\n        d=abs(x3-x4)+abs(y3-y4)\n        pre1 = (x3, y3, min(abs(x1 - x4) + abs(y1 - y4) + w1 + d, abs(x2 - x4) + abs(y2 - y4) + w2 + d))\n        pre2=(x4,y4,min(abs(x1-x3)+abs(y1-y3)+w1+d,abs(x2-x3)+abs(y2-y3)+w2+d))\n    print(min(pre1[2],pre2[2]))\n\ndef __starting_point():\n    solve()\n\n__starting_point()
a = int(input())\nb = int(input())\n\nc = 1+2+3\n\nprint((c - (a+b)))\n
L = int(input())\n\nans = (L / 3) ** 3\n\nprint(ans)
n = int(input())\nif n == 1:\n    print('Hello World')\nelse:\n    a = int(input())\n    b = int(input())\n    print(a+b)
a, b = map(int, input().split())\n\nif a <= b:\n    ans = str(a) * b\nelse:\n    ans = str(b) * a\nprint(ans)\nreturn
C = input()\nC = ord(C)\nC = C+1\nprint(chr(C))
S,T = map(str,input().split())\nprint(T + S)
n = int(input())\na = list(map(int, input().split()))\nodd = []\neven = []\nfor i in a:\n    if i%2:\n        odd.append(i)\n    else:\n        even.append(i)\nodd.sort()\neven.sort()\nif abs(len(odd) - len(even)) <= 1:\n    print(0)\nelse:\n    if len(odd) > len(even):\n        print(sum(odd[:len(odd)-len(even)-1]))\n    else:\n        print(sum(even[:len(even) - len(odd)-1]))\n
n, a, b, k = map(int, input().split())\nH = list(map(int, input().split()))\nfor i in range(n):\n    H[i] %= (a + b)\n    if H[i] == 0:\n        H[i] = a + b\nH.sort()\nans = 0\nfor x in H:\n    if x <= a:\n        ans += 1\n    else:\n        tok = (x + a - 1) // a - 1\n        if k >= tok:\n            k -= tok\n            ans += 1\nprint(ans)
import bisect\n\nn, m = map(int, input().split())\nls = list(map(int, input().split()))\n\nmls = []\nfor i in range(0, n):\n    mls.append((ls[i] % m, i))\n\nmls.sort()\n# print(mls)\n\nbk1 = set()\nbk2 = set()\n\naim = n // m\ncnt = 0\n\nmis = []\nfor i in range(m):\n    for j in range(aim):\n        mis.append(i)\n\np1 = 0\np2 = 0\n\nwhile p2 < n:\n    if mls[p1][0] > mis[p2]:\n        p2 += 1\n    else:\n        a = mis[p2] - mls[p1][0]\n        ls[mls[p1][1]] += a\n        cnt += a\n        bk2.add(p2)\n        p1 += 1\n        p2 += 1\n\nif p1 < n and p2 == n:\n    p1 = n\n    for i in range(p2):\n        if i not in bk2:\n            p1 -= 1\n            a = m - mls[p1][0] + mis[i]\n            ls[mls[p1][1]] += a\n            cnt += a\n\nprint(cnt)\nfor i in ls:\n    print(i, end=' ')\n\n
import collections\n\n\ndef main():\n    from sys import stdin, stdout\n\n    def read():\n        return stdin.readline().rstrip('\n')\n\n    def read_array(sep=None, maxsplit=-1):\n        return read().split(sep, maxsplit)\n\n    def read_int():\n        return int(read())\n\n    def read_int_array(sep=None, maxsplit=-1):\n        return [int(a) for a in read_array(sep, maxsplit)]\n\n    def write(*args, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\n')\n        stdout.write(sep.join(str(a) for a in args) + end)\n\n    def write_array(array, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\n')\n        stdout.write(sep.join(str(a) for a in array) + end)\n\n    def enough(days):\n        bought = []  # (type, amount)\n        bought_total = 0\n        used_from = days\n        for d in range(days, 0, -1):\n            used_from = min(d, used_from)\n            for t in offers.get(d, []):\n                if K[t] > 0:\n                    x = min(K[t], used_from)\n                    K[t] -= x\n                    bought.append((t, x))\n                    bought_total += x\n                    used_from -= x\n            if not used_from:\n                break\n        remaining_money = days - bought_total\n        ans = (total_transaction - bought_total) * 2 <= remaining_money\n        for t, a in bought:\n            K[t] += a\n        return ans\n\n    n, m = read_int_array()\n    K = read_int_array()\n    total_transaction = sum(K)\n    offers = collections.defaultdict(list)\n    for _ in range(m):\n        d, t = read_int_array()\n        offers[d].append(t-1)\n\n    low = total_transaction\n    high = low * 2\n    ans = high\n    while low <= high:\n        mid = (low + high) // 2\n        if enough(mid):\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    write(ans)\n\n\nmain()\n
for _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = {}\n    for i in A:\n        if i not in B:\n            B[i] = 0\n        B[i] += 1\n    ans = 'YES'\n    J = []\n    for i in B:\n        if B[i] % 2:\n            ans = 'NO'\n            break\n        else:\n            for _ in range(B[i] // 2):\n                J.append(i)\n    if ans == 'YES':\n        J.sort()\n        s = set()\n        for i in range(n):\n            s.add(J[i] * J[-i-1])\n        if len(s) != 1:\n            ans = 'NO'\n    print(ans)
import sys\ninput = sys.stdin.readline\n\nn,m,k=list(map(int,input().split()))\nEDGE=[list(map(int,input().split())) for i in range(m)]\n\nEDGE.sort(key=lambda x:x[2])\nEDGE=EDGE[:k]\n\nCOST_vertex=[[] for i in range(n+1)]\nfor a,b,c in EDGE:\n    COST_vertex[a].append((b,c))\n    COST_vertex[b].append((a,c))\n\nfor i in range(min(m,k)):\n    x,y,c=EDGE[i]\n    EDGE[i]=(c,x,y)\n\n\nUSED_SET=set()\n\nANS=[-1<<50]*k\n\nimport heapq\n\nwhile EDGE:\n    c,x,y = heapq.heappop(EDGE)\n\n    if (x,y) in  USED_SET or c>=-ANS[0]:\n        continue\n\n    else:\n        heapq.heappop(ANS)\n        heapq.heappush(ANS,-c)\n        USED_SET.add((x,y))\n        USED_SET.add((y,x))\n\n    for to,cost in COST_vertex[x]:\n        if to!=y and not((y,to) in USED_SET) and c+cost<-ANS[0]:\n            heapq.heappush(EDGE,(c+cost,y,to))\n            #USED_SET.add((y,to))\n            #USED_SET.add((to,y))\n\n    for to,cost in COST_vertex[y]:\n        if to!=x and not((x,to) in USED_SET) and c+cost<-ANS[0]:\n            heapq.heappush(EDGE,(c+cost,x,to))\n            #USED_SET.add((x,to))\n            #USED_SET.add((to,x))\n\nprint(-ANS[0])\n            \n
import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\n\nB=[(a,ind) for ind,a in enumerate(A)]\nB.sort()\n    \nDP=[0]*(n+1)\n\nfor i in range(3,n-2):\n    DP[i]=max(DP[i-1],DP[i-3]+B[i][0]-B[i-1][0])\n\n#print(DP)\n\nMAX=max(DP)\n\nx=DP.index(MAX)\n\nREMLIST=[]\n\nwhile x>0:\n    if DP[x]==DP[x-1]:\n        x-=1\n    else:\n        REMLIST.append(x)\n        x-=3\n\nREMLIST.sort()\nREMLIST.append(1<<60)\n\nprint(max(A)-min(A)-MAX,len(REMLIST))\n\nANS=[-1]*n\nremind=0\nNOW=1\n\nfor i in range(n):\n    if i==REMLIST[remind]:\n        NOW+=1\n        remind+=1\n    ANS[B[i][1]]=NOW\nprint(*ANS)\n\n\n
for _ in range(int(input())):\n    n = int(input())\n    # arr = list(map(int, input().split()))\n    # n, m = map(int, input().split())\n    arr = []\n    x = 1\n    while n > 0:\n        if (n % 10):\n            arr.append((n % 10) * x)\n        n //= 10\n        x *= 10\n    print(len(arr))\n    print(*arr)
for _ in range(int(input())):\n    n = int(input())\n    P = list(map(int, input().split()))\n    ans = [0] * n\n    for i in range(n):\n        if ans[i] == 0:\n            now = i\n            cnt = 0\n            cll = []\n            while True:\n                now = P[now] - 1\n                cnt += 1\n                cll.append(now)\n                if now == i:\n                    break\n            for u in cll:\n                ans[u] = cnt\n    print(' '.join(list(map(str, ans))))
for _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    s = sum(A)\n    print((s + n - 1) // n)
def ke(i):\n    return a[i]\nn,m=map(int,input().split())\na=list(map(int,input().split()))\nb=[]\nfor i in range(n):\n    b.append(i)\nb.sort(key=ke)\nans=[0]*n\nk=0\nfor i in range(1,n):\n    if a[b[i]]==a[b[i-1]]:\n        k+=1\n        ans[b[i]]=i-k\n    else:\n        k=0\n        ans[b[i]]=i\nfor i in range(m):\n    r1,r2=map(int,input().split())\n    if (a[r1-1]>a[r2-1]):\n        ans[r1-1]-=1\n    elif a[r1-1]<a[r2-1]:\n        ans[r2-1]-=1\nfor i in ans:\n    print(i, end=' ')
n,k=map(int,input().split())\naa=list(map(int,input().split()))\nbb=list(map(int,input().split()))\nab="abcdefghijklmnopqrstuvwxyz"\n#print(len(ab))\nss={}\nj=0\nit=[]\nfor i in aa:\n    ss[i]=j\n    j+=1\njj=0\nfor i in bb:\n    ind=ss[i]\n    j,ind=sorted([jj,ind])\n    it.append([j,ind])\n  #  print(i,jj,ind)\n    jj+=1\n    \nit.sort()\ndo=1\nma=it[0][1]\nres=[]\nst=it[0][0]\n\nfor i in it[1:]:\n    if i[0]<=ma:\n        ma=max(ma,i[1])\n        \n    else:\n        do+=1\n        res.append([st,ma])\n        st=i[0]\n        ma=i[1]\n\n    j+=1\nif res==[]:\n    res=[[0,n-1]]\nelse:\n    if res[-1][1]!=n-1:\n        res.append([res[-1][1]+1,n-1])\nif len(res)<k:\n    print("NO")\nelse:\n    print("YES")\n    if len(res)>k:\n      #  print(res[:k-1])\n       # print(res)\n        res=res[:k-1]+[[res[k-1][0],n-1]]\n    kk=-1\n    res.sort()\n    ll=[0]*n\n    for i in res:\n        kk+=1\n        for j in range(i[0],i[1]+1):\n            ll[aa[j]-1]=ab[kk]\n    for i in ll:\n        print(i,end="")\n    print()\n    \n\n    \n
n = int(input())\na = [int(x) for x in input().split()]\nb = [(a[i], i + 1) for i in range(n)]\nb.sort(reverse=True)\nans = 0\nfor i in range(n):\n    ans += b[i][0] * i + 1\nprint(ans)\nfor i in b:\n    print(i[1], end=' ')
n=int(input())\np=list(map(int,input().split()))\n\nc=1\n\nq=p[0]\n\nfor i in range(1,n):\n    q=min(q,p[i])\n    if p[i]<=q:\n        c+=1\n\nprint(c)
import collections\n\nN=int(input())\nL=list(map(int,input().split()))\nL=sorted(L)\nC=collections.Counter(L)\nD=list(C.keys())\nE=list(C.values())\nK=len(C)\nans=0\nfor i in range(K):\n	if D[i]==E[i]:\n		ans+=0\n	if D[i]>E[i]:\n		ans+=E[i]\n	if D[i]<E[i]:\n		ans+=(E[i]-D[i])\nprint(ans)\n
a=list(map(int,input().split()))\nfor i in range(len(a)):\n    if a[i]==0:\n        print(i+1)
H, W = map(int, input().split())\nans = float('inf')\nfor h in range(1,H):\n    S = [h * W]\n    w = W // 2\n    S += [(H-h) * w]\n    S += [(H-h) * (W-w)]\n    ans = min(ans,max(S)-min(S))\n\nfor h in range(1,H):\n    S = [h * W]\n    hb = (H-h) // 2\n    S += [hb * W]\n    S += [(H-h-hb) * W]\n    ans = min(ans,max(S)-min(S))\n\nfor w in range(1,W):\n    S = [H * w]\n    h = H // 2\n    S += [h * (W-w)]\n    S += [(H-h) * (W-w)]\n    ans = min(ans,max(S)-min(S))\n\nfor w in range(1,W):\n    S = [w * H]\n    wb = (W-w) // 2\n    S += [wb * H]\n    S += [(W-w-wb) * H]\n    ans = min(ans,max(S)-min(S))\n\nprint(ans)
#!/usr/bin/env python\n\nn = int(input())\na = list(map(int, input().split()))\n\nn2 = 0 \nn4 = 0 \nfor i in range(n):\n    if a[i]%4 == 0:\n        n4 += 1\n    elif a[i]%2 == 0:\n        n2 += 1\n\nok = True\nif n2 == 0:\n    if n4 >= n//2:\n        ok = True\n    else:\n        ok = False\nelse:\n    n1 = n-n2-n4\n    n1 += 1\n    nn = n1+n4\n    if n4 >= nn//2:\n        ok = True\n    else:\n        ok = False\n\nif ok: \n    print('Yes')\nelse:\n    print('No')
import sys\n\ninput = sys.stdin.readline\ns = list(input().strip())\nt = list(input().strip())\nif sorted(s) < sorted(t, reverse=True):\n    print("Yes")\nelse:\n    print("No")
a,b,c = map(int,input().split())\n\nmod = a % b\nans = 'NO'\nfor i in range(1,b):  \n  if (i*mod) % b == c:\n    ans = 'YES'\n    break\n  \nprint(ans)  
a,b=map(int, input().split())     \nprint(a*b-a-b+1)
#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**6)\n\nx, y, z = list(map(int, input().split()))\n\nprint(((x-z)//(y+z)))\n
N = int(input())\nab = [list(map(int, input().split())) for _ in range(N)]\ncd = [list(map(int, input().split())) for _ in range(N)]\nab.sort()\ncd.sort()\n\ng = [[] for _ in range(N)]\n\nfor i, pab in enumerate(ab):\n    for j, pcd in enumerate(cd):\n        if pab[0] < pcd[0] and pab[1] < pcd[1]:\n            g[j].append([pab[1],i])\n        \nans = 0\ns = set()\n\nfor gg in g:\n    gg.sort(reverse=True)\n    for ggg in gg:\n        if ggg[1] in s:continue\n        else:\n            ans += 1\n            s.add(ggg[1])\n            break\nprint(ans)\n
n,T = map(int,input().split())\nt = list(map(int,input().split()))\nans = 0\nfor i in range(n-1):\n    ans += min(T,t[i+1]-t[i])\nprint(ans+T)
n = int(input())\nd = {}\nmatr = [0] * (2 * n + 1)\nhead = n - 1\ntail = n\nfor i in range(n):\n	st, n = input().split()\n	n = int(n)\n	if st == 'L':\n		matr[head] = n\n		d[n] = head\n		head -= 1\n	elif st == 'R':\n		matr[tail] = n\n		d[n] = tail\n		tail += 1\n	else:\n		print(min(d[n] - head, tail - d[n]) - 1)\n
for i in range(int(input())):\n    \n    n=int(input())\n    moves=0\n    while n%2==0:\n        n=n//2\n        moves+=1\n    while n%3==0:\n        n=n//3\n        moves+=2\n    while n%5==0:\n        n=n//5\n        moves+=3\n    if n==1:\n        print(moves)\n    else :\n        print(-1)
t = int(input())\nfor _ in range(t):\n	n = int(input())\n	arr = [int(j) for j in input().split()]\n	flag = 0\n	for x in arr:\n		if x%2 != arr[0]%2:\n			flag = 1\n			break\n	if flag == 1:\n		print("NO")\n	else:\n		print("YES")
from math import ceil\n\nn = int(input())\n\nword1 = input()\nword2 = input()\n\ncombined = []\nfor i in range(ceil(n / 2)):\n    if i > n / 2 - 1:\n        combined.append([word1[i], word2[i]])\n    else:\n        combined.append([word1[i], word1[- i - 1], word2[i], word2[- i - 1]])\n\ncount = 0\nfor l in combined:\n    s = set(l)\n    if len(s) == 4:\n        count += 2\n    elif len(s) == 3:\n        count += 1\n        if l[0] == l[1]:\n            count += 1\n    elif len(s) == 2:\n        counter = 0\n        first_letter = l[0]\n        for letter in l:\n            if letter == first_letter:\n                counter += 1\n        if counter != 2:\n            count += 1\nprint(count)
t = int(input())\nfor i in range(t):\n    a, b, k = list(map(int, input().split()))\n    ans = (a - b) * (k // 2)\n    if k % 2 == 1:\n        ans += a\n    print(ans)\n
for _ in range(int(input())):\n	n = int(input())\n\n	bits = ['1']\n	while int(''.join(bits), 3) < n:\n		bits.append('1')\n	\n	\n	for i in range(len(bits)):\n		bits[i] = '0'\n		if int(''.join(bits), 3) < n:\n			bits[i] = '1'\n	\n	print(int(''.join(bits), 3))\n
t = int(input())\n# a = list(map(int, input().split()))\nfor _ in range(t):\n    a,b,x,y,n = map(int,input().split())\n    \n    options = []\n    a2 = max(a-n,x)\n    b2 = max(b-(n-(a-a2)),y)\n    options.append(a2*b2)\n    \n    b2 = max(b-n,y)\n    a2 = max(a-(n-(b-b2)),x)\n    options.append(a2*b2)\n    \n    print(min(options))
for _ in range(int(input())):\n    a, b = list(map(int, input().split()))\n    if a == b:\n        print(0)\n    else:\n        if a < b:\n            if (b - a) % 2:\n                print(1)\n            else:\n                print(2)\n        else:\n            if (b - a) % 2 == 0:\n                print(1)\n            else:\n                print(2)\n
#   ==========     //\\       //||     ||====//||\n#       ||        //  \\        ||     ||   // ||\n#       ||       //====\\       ||     ||  //  ||\n#       ||      //      \\      ||     || //   ||\n#   ========== //        \\  ========  ||//====|| \n#  code\n\n\ndef solve():\n    x = int(input())\n    ans = 0\n    ok = 0\n\n    for i in range(1, 10):\n        n = 0\n        for j in range(4):\n            n = n * 10 + i\n            ans += (j + 1)\n            if n == x:\n                ok = 1\n                break\n        if ok:\n            break\n    print(ans)\n\ndef main():\n    t = 1\n    t = int(input())\n    for _ in range(t):\n        solve()\n\ndef __starting_point():\n    main()\n__starting_point()
import sys\nk=int(input())\nL=[]\ndic=dict()\nflag=False\nfor i in range(k):\n    L.append([int(input())])\n    L[i].append(list(map(int,input().split())))\n    s=sum(L[i][1])\n    q=[]\n    for j in range(L[i][0]):\n        if flag:\n            return\n        t=s-L[i][1][j]\n        if t in dic:\n            x,y=dic[t]\n            print("YES")\n            print(i+1,j+1)\n            print(x,y)\n            flag=True\n        else:\n            q.append((t,i+1,j+1))\n    for a,b,c in q:\n        dic[a]=(b,c)\nprint("NO")\n
class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        \n        i = 0\n        while A[i] < 0 and K > 0:\n            A[i] *= -1\n            i += 1\n            K -= 1\n            \n        if K % 2 == 1 and 0 not in A:\n            return sum(A) - 2*min(A)\n        return sum(A)\n
class Solution:\n    def canThreePartsEqualSum(self, A: List[int]) -> bool:\n        \n#         if len(A)<3:\n#             return\n        \n#         i = 1\n#         j = len(A)-2\n        \n#         tgtsum = sum(A)/3\n#         sum1 = sum(A[:i])\n#         while i<(len(A)-2) and sum1!=tgtsum:\n#             sum1 = sum1 + A[i]\n#             i+=1\n        \n#         sum3=sum(A[j+1:])\n#         while j>1 and sum3!=tgtsum:\n#             # print (tgtsum, sum1, sum3, A[j])\n#             sum3 = sum3 + A[j]\n#             j-=1\n#         # print (i,j)\n#         if j>=i and sum1==tgtsum and sum3==tgtsum:\n#             return True\n#         else:\n#             return False\n\n        if len(A)<3:\n            return False\n        suma = sum(A)\n        if suma%3!=0:\n            return False\n        \n        runsum,target, count = 0,suma/3,0\n        \n        for val in A[:-1]:\n            runsum += val\n            if runsum==target:\n                count+=1\n                runsum=0\n                if count==2:\n                    return True\n        else:\n            return False\n
from collections import Counter\nn = int(input())\nss = [input() for _ in range(n)]\nss.sort()\nc = Counter()\nmc = 0\nfor s in ss:\n  c[s] += 1\n  mc = max(mc, c[s])\nseen = set()\nfor s in ss:\n  if c[s] == mc and s not in seen:\n    print(s)\n    seen.add(s)
n = int(input())\na = list(map(int, input().split()))\n\nans = 1e9\nfor p in range(-100, 101):\n  sub = 0\n  for q in a:\n    sub += pow(p - q, 2)\n  ans = min(ans, sub)\n\nprint(ans)\n
print((int(input()) - int(input())) % int(input()))
import math\nn, m = map(int, input().split())\nmod = 10**9+7\nif abs(n-m) > 1:\n    print(0)\n    return\n\ndog = math.factorial(n)\nmonkey = math.factorial(m)\nif abs(n-m) == 1:\n    ans = dog*monkey % mod\nelif n == m:\n    ans = dog*monkey*2 % mod\nprint(ans%mod)
n,m=list(map(int,input().split()))\nM=[[] for i in range(n)]\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    a-=1;b-=1\n    M[a].append(b)\n    M[b].append(a)\nyes="POSSIBLE";no="IMPOSSIBLE"\n\nfor i in M[0]:\n    if n-1 in M[i]:\n        print(yes);return\nprint(no)\n\n
s = input()\ni = 0\nanswer = str()\nfor j in s:\n    if i % 2 == 0:\n        answer += j\n    i += 1\nprint(answer)
s1,s2,s3 = input().split()\nprint("YES") if s1[-1]==s2[0] and s2[-1]==s3[0] else print("NO")
a = int(input())\nb = int(input())\nif a < b:\n  print("LESS")\nelif a > b:\n  print("GREATER")\nelse:\n  print("EQUAL")
def resolve():\n    n = int(input())\n    blue_cards = list()\n    for i in range(n):\n        card = input()\n        blue_cards.append(card)\n    blue_cards = sorted(blue_cards)\n    m = int(input())\n    red_cards = list()\n    for i in range(m):\n        card = input()\n        red_cards.append(card)\n    red_cards = sorted(red_cards)\n    former = ""\n    cards_points = []\n    for card in blue_cards:\n        point = 0\n        if former == card:\n            continue\n        else:\n            p = blue_cards.count(card)\n            m = red_cards.count(card)\n            point = p - m\n            cards_points.append(point)\n            former = card\n    cards_points = sorted(cards_points)\n    if cards_points[-1] < 0:\n        print(0)\n    else:\n        print(cards_points[-1])\nresolve()
d = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\nprint((d[input()]))\n
def mapt(fn, *args):\n    return tuple(map(fn, *args))\n\n\ndef Input():\n    return mapt(int, input().split(" "))\n\n\ndef main():\n    n = int(input())\n    a_1 = Input()\n    a_2 = Input()\n    ans = 0\n    for i in range(n):\n        ans = max(ans, sum(a_1[:i+1])+sum(a_2[i:n]))\n    print(ans)\n\nmain()
N, x = [int(n) for n in input().split(" ")]\nA = [int(a) for a in input().split(" ")]\n\ncnt = 0\nif A[0] > x:\n  cnt += A[0] - x\n  A[0] = x\n\nfor i in range(1, len(A)):\n  if A[i] + A[i - 1] > x:\n    cnt += A[i] + A[i - 1] - x\n    A[i] = x - A[i - 1]\n\nprint(cnt)
#!/usr/bin/env python3\n\nc = [list(map(int, input().split())) for i in range(3)]\n\n\na1 = 0\nb1, b2, b3 = c[0][0], c[0][1], c[0][2]\na2 = c[1][0]-b1\na3 = c[2][0]-b1\n\ncheck = []\ncheck.append(c[1][1] == a2+b2)\ncheck.append(c[2][1] == a3+b2)\ncheck.append(c[1][2] == a2+b3)\ncheck.append(c[2][2] == a3+b3)\n\nif sum(check) == 4:\n    print("Yes")\nelse:\n    print("No")\n
s = input()\nif s == 'ABC':\n    print('ARC')\nelse:\n    print('ABC')
a,b,x=list(map(int,input().split()))\nprint((b//x-(a-1)//x))\n
d=int(input())\nprint('Christmas'+' Eve'*(25-d))
#!/usr/bin/env python3\nimport sys\n\n\ndef solve(N: int):\n    if N >= 64:\n        print((64))\n    elif N >= 32:\n        print((32))\n    elif N >= 16:\n        print((16))\n    elif N >= 8:\n        print((8))\n    elif N >= 4:\n        print((4))\n    elif N >= 2:\n        print((2))\n    else:\n        print((1))\n    return\n\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    solve(N)\n\ndef __starting_point():\n    main()\n\n__starting_point()
import sys\n\n\ndef input(): return sys.stdin.readline().strip()\ndef I(): return int(input())\ndef LI(): return list(map(int, input().split()))\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef S(): return input()\ndef LS(): return input().split()\n\n\nINF = float('inf')\n\n\na, b, c, d = LI()\nprint(('Yes' if abs(a-c) <= d or (abs(a-b) <= d and abs(b-c) <= d) else 'No'))\n
def answer(s: str) -> str:\n    return ''.join(s[0].upper() for s in s.split())\n\n\ndef main():\n    s = input()\n    print(answer(s))\n\n\ndef __starting_point():\n    main()\n__starting_point()
a,b,c = map(int,input().split())\nprint("Yes" if a + b >= c else "No")
import sys\nimport heapq\nimport re\nfrom itertools import permutations\nfrom bisect import bisect_left, bisect_right\nfrom collections import Counter, deque\nfrom fractions import gcd\nfrom math import factorial, sqrt, ceil\nfrom functools import lru_cache, reduce\nINF = 1 << 60\nMOD = 1000000007\nsys.setrecursionlimit(10 ** 7)\n\n# UnionFind\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# ダイクストラ\ndef dijkstra_heap(s, edge, n):\n    #始点sから各頂点への最短距離\n    d = [10**20] * n\n    used = [True] * n #True:未確定\n    d[s] = 0\n    used[s] = False\n    edgelist = []\n    for a,b in edge[s]:\n        heapq.heappush(edgelist,a*(10**6)+b)\n    while len(edgelist):\n        minedge = heapq.heappop(edgelist)\n        #まだ使われてない頂点の中から最小の距離のものを探す\n        if not used[minedge%(10**6)]:\n            continue\n        v = minedge%(10**6)\n        d[v] = minedge//(10**6)\n        used[v] = False\n        for e in edge[v]:\n            if used[e[1]]:\n                heapq.heappush(edgelist,(e[0]+d[v])*(10**6)+e[1])\n    return d\n\n# 素因数分解\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n\n    if temp!=1:\n        arr.append([temp, 1])\n\n    if arr==[]:\n        arr.append([n, 1])\n\n    return arr\n\n# 2数の最小公倍数\ndef lcm(x, y):\n    return (x * y) // gcd(x, y)\n\n# リストの要素の最小公倍数\ndef lcm_list(numbers):\n    return reduce(lcm, numbers, 1)\n\n# リストの要素の最大公約数\ndef gcd_list(numbers):\n    return reduce(gcd, numbers)\n\n# 素数判定\ndef is_prime(n):\n    if n <= 1:\n        return False\n    p = 2\n    while True:\n        if p ** 2 > n:\n            break\n        if n % p == 0:\n            return False\n        p += 1\n    return True\n\n\n# limit以下の素数を列挙\ndef eratosthenes(limit):\n    A = [i for i in range(2, limit+1)]\n    P = []\n\n    while True:\n        prime = min(A)\n        \n        if prime > sqrt(limit):\n            break\n            \n        P.append(prime)\n            \n        i = 0\n        while i < len(A):\n            if A[i] % prime == 0:\n                A.pop(i)\n                continue\n            i += 1\n            \n    for a in A:\n        P.append(a)\n            \n    return P\n\n# 同じものを含む順列\ndef permutation_with_duplicates(L):\n\n    if L == []:\n        return [[]]\n\n    else:\n        ret = []\n\n        # set（集合）型で重複を削除、ソート\n        S = sorted(set(L))\n\n        for i in S:\n\n            data = L[:]\n            data.remove(i)\n\n            for j in permutation_with_duplicates(data):\n                ret.append([i] + j)\n\n        return ret\n\n\n# ここから書き始める\nn, a = map(int, input().split())            \nx = [i - a for i in map(int, input().split())]\ndp = [[0 for j in range(4901)] for i in range(n)]\ndp[0][2450] += 1\ndp[0][x[0] + 2450] += 1\nfor i in range(1, n):\n    for j in range(4901):\n        dp[i][j] = dp[i - 1][j]\n        if 0 <= j - x[i] < 4901:\n            dp[i][j] += dp[i - 1][j - x[i]]\nans = dp[n - 1][2450] - 1\nprint(ans)
n = int(input())\na = list(map(int, input().split()))\no = [a[i] for i in range(0,n,2)]\ne = [a[h] for h in range(1,n,2)]\nif n%2 == 0:\n    e.reverse()\n    l = e + o\n    print(*l)\nelse:\n    o.reverse()\n    l = o + e\n    print(*l)
h, n = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nif h <= sum(a):\n    print('Yes')\nelse:\n    print('No')\n
S = input()\nx = len(S)\n\nfor i in range(0, x, 2):\n  y = x - 2 - i\n  if S[:y//2] == S[y//2 : y]:\n    \n    print(len(S[:y]))\n    break
S = list(input())\nS.sort()\nif S == ['a', 'b', 'c']:\n    print("Yes")\nelse:\n    print("No")
n = int(input())\n\na = list(map(int, input().split()))\naord = sorted([i for i in range(n)], key=lambda x: a[x] * (n - x) * (x + 1))\n\nb = sorted(map(int, input().split()))[::-1]\nnew_b = [0] * n\nfor i in range(n):\n    new_b[aord[i]] = b[i]\nb = new_b\n\nm = 998244353\n\nc = [0] * n\nfor i in range(n):\n    c[i] = a[i] * b[i] % m\n\nans = 0\nfor i in range(n):\n    u = c[i] * (n - i) * (i + 1) % m\n    ans = (ans + u) % m\nprint(ans)\n
import sys\nimport copy\ninput = sys.stdin.readline\n\nn,m,k=list(map(int,input().split()))\nA=list(map(int,input().split()))\nSHOP=[list(map(int,input().split())) for i in range(m)]\n\nA=sorted(A)[:k]\nA=A[::-1]\n\nSHOP.sort(key=lambda x:x[0])\n\nfrom itertools import accumulate \n\nDP=[0]+list(accumulate(A))\nSUM=copy.deepcopy(DP)\n\nfor i in range(k+1):\n    for x,y in SHOP:\n        if x>i:\n            break\n        DP[i]=min(DP[i],DP[i-x]+SUM[i]-SUM[i-x]-SUM[i]+SUM[i-y],DP[i-1]+A[i-1])\n\nprint(DP[-1])\n        \n
from sys import stdin\nn = int(stdin.readline())\ng = dict()\nfor i in range(n-1):\n    u,v = map(int,stdin.readline().split())\n    g.setdefault(u-1,[]).append(v-1)\n    g.setdefault(v-1, []).append(u-1)\nst = [0]\nrank = [0]*n\ntree = [0]*n\nmsk = [0]*n\nrd = dict()\nwhile len(st)>0:\n    top = st.pop()\n    msk[top] = 1\n    for c in g[top]:\n        if msk[c] == 0:\n            st.append(c)\n            tree[c] = top\n            rank[c] = rank[top]+1\n            rd.setdefault(rank[c], []).append(c)\nmax_rank = max(rank)\nreach = [0]*n\nbuild = [0]*n\nans = 0\nfor r in range(max_rank, 2, -1):\n    for node in rd[r]:\n        if reach[node] == 0:\n            reach[node] = 1\n            reach[tree[node]] = 1\n            reach[tree[tree[node]]] = 1\n            build[tree[node]] = 1\nprint(sum(build))
from sys import *\nfrom collections import *\nfrom math import *\n\ninput = stdin.readline\n\ntc = int(input())\nfor tcase in range(tc):\n	n, k = map(int, input().split())\n	lo = 1\n	hi = 10 ** 19\n	ans = -1\n	while (lo <= hi):\n		mid = (lo + hi) // 2\n		divi = mid - mid // n\n		if (divi >= k):\n			ans = mid\n			hi = mid - 1\n		else:\n			lo = mid + 1\n	print(ans)
from collections import deque\nn, k = map(int, input().split())\nA = list(map(int, input().split()))\nB = deque()\nB.append(A[0])\nnc = {}\nfor i in set(A):\n    nc[i] = 0\nnc[A[0]] = 1\nfor i in range(1, n):\n    if nc[A[i]] == 0:\n        if len(B) == k:\n            nc[B[0]] -= 1\n            B.popleft()\n        B.append(A[i])\n        nc[A[i]] += 1\n    else:\n        pass\nprint(len(B))\nprint(*list(B)[::-1])
import sys\nimport math\nimport cProfile\n\nDEBUG = False\ndef log(s):\n    if DEBUG and False:\n        print(s)\n        \ndef calc_dmg(num, arr):\n    maximum = 0\n    if num - len(arr) < 0:\n        maximum = max(arr)\n    return sum(arr) + maximum\n\nif DEBUG:\n    sys.stdin = open('input.txt')\n    pr = cProfile.Profile()\n    pr.enable()\n\nn = sys.stdin.readline()\nn = int(n)\n\ndmg = [-sys.maxsize for _ in range(10)]\n\nfor i in range(n):\n    log(dmg)\n    cards = [_[:] for _ in [[-sys.maxsize] * 3] * 4]\n\n    k = sys.stdin.readline()\n    k = int(k)\n    for _ in range(k):\n        c, d = sys.stdin.readline().split()\n        c = int(c)\n        d = int(d)\n        cards[c].append(d)\n    cards[1].sort(reverse=True)\n    cards[2].sort(reverse=True)\n    cards[3].sort(reverse=True)\n    log(cards)\n\n    # dmg[j] = max(dmg[j],\n    #              dmg[j - 1] + D(one card),\n    #              dmg[j - 2] + D(two cards),\n    #              dmg[j - 3] + D(three cards))\n    # Plus, if 1 <= j <= 3, dmg[j] = max(dmg[j], D(cards))\n    new_dmg = []\n    for j in range(10):\n        use1 = max(cards[1][0], cards[2][0], cards[3][0])\n        use2 = max(cards[1][0] + cards[1][1],\n                   cards[1][0] + cards[2][0])\n        use3 = cards[1][0] + cards[1][1] + cards[1][2]\n\n        maximum = dmg[j]\n        if use1 > 0:\n            maximum = max(maximum, dmg[j - 1] + calc_dmg(j, [use1]))\n            if j == 1:\n                maximum = max(maximum, use1)\n        if use2 > 0:\n            maximum = max(maximum, dmg[j - 2] +\n                          calc_dmg(j, [cards[1][0], cards[1][1]]\n                          if cards[1][0] + cards[1][1] == use2\n                          else [cards[1][0], cards[2][0]]))\n            if j == 2:\n                maximum = max(maximum, use2)\n        if use3 > 0:\n            maximum = max(maximum, dmg[j - 3] +\n                          calc_dmg(j, [cards[1][0], cards[1][1], cards[1][2]]))\n            if j == 3:\n                maximum = max(maximum, use3)\n        new_dmg.append(maximum)\n    dmg = new_dmg\n\nlog(dmg)\nprint(max(dmg))\n\nif DEBUG:\n    pr.disable()\n    pr.print_stats()
# -*- coding: utf-8 -*-\n\nimport sys\nfrom operator import add\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nclass SegTree:\n \n    def __init__(self, n, func, init):\n\n        self.n = n\n        self.func = func\n        self.init = init\n\n        n2 = 1\n        while n2 < n:\n            n2 <<= 1\n        self.n2 = n2\n        self.tree = [self.init] * (n2 << 1)\n \n    def update(self, i, x):\n\n        i += self.n2\n        self.tree[i] = x\n        while i > 1:\n            self.tree[i >> 1] = x = self.func(x, self.tree[i ^ 1])\n            i >>= 1\n \n    def query(self, a, b):\n\n        l = a + self.n2\n        r = b + self.n2\n        s = self.init\n        while l < r:\n            if r & 1:\n                r -= 1\n                s = self.func(s, self.tree[r])\n            if l & 1:\n                s = self.func(s, self.tree[l])\n                l += 1\n            l >>= 1\n            r >>= 1\n        return s\n\nA = [ord(s)-97 for s in list(input())]\nN = len(A)\n\nst = [None] * 26\nfor i in range(26):\n    st[i] = SegTree(N, add, 0)\nfor i, a in enumerate(A):\n    st[a].update(i, 1)\n\nfor _ in range(INT()):\n    a, b, c = input().split()\n    if a == '1':\n        b = int(b)\n        cur = A[b-1]\n        nxt = ord(c) - 97\n        st[cur].update(b-1, 0)\n        st[nxt].update(b-1, 1)\n        A[b-1] = nxt\n    else:\n        b = int(b)\n        c = int(c)\n        cnt = 0\n        for i in range(26):\n            if st[i].query(b-1, c) >= 1:\n                cnt += 1\n        print(cnt)\n
for _ in range(int(input())):\n	for _ in range(9): print (input().replace('2','1'))
n, q = map(int, input().split())\npar = [int(v)-1 for v in input().split()]\nchs = [[] for i in range(n)]\nfor i, p in enumerate(par):\n    chs[p].append(i+1)\nvis = [0 for _ in range(n)]\nbel = [1 for _ in range(n)]\nstack = [0]\norder = [0]\nwhile stack:\n    v = stack[-1]\n    if len(chs[v]) == vis[v]:\n        if v != 0:\n            bel[par[v-1]] += bel[v]\n        stack.pop()\n        continue\n    ch = chs[v][vis[v]]\n    vis[v] += 1\n    order.append(ch)\n    stack.append(ch)\nFST = {}\nfor i, c in enumerate(order):\n    FST[c] = i\nout = []\nfor _ in range(q):\n    u, k = map(lambda x: int(x) - 1, input().split())\n    if k >= bel[u]:\n        out.append(-1)\n    else:\n        out.append(order[FST[u] + k] + 1)\nprint('\n'.join(map(str, out)))
a = int(input())\nfor i in range(a):\n    a1, b, c, n = list(map(int, input().split()))\n    t = max(a1, b, c)\n    if ((a1 + b + c + n) % 3 == 0 and t <= (a1 + b + c + n)//3 ):\n        print('YES')\n    else:\n        print('NO')\n
n, m = map(int, input().split())\nx = list(map(int, input().split()))\n\nfoo = [0 for _ in range(2+n)]\n\nfor i in range(1, m) :\n    p, q = x[i-1], x[i]\n\n    if p == q : continue\n\n    r = min(p, q)\n\n    s = max(p, q)\n\n    foo[0] += abs(p-q)\n    foo[r] -= abs(p-q)\n    foo[r] += max(p, q) - 1\n    foo[r+1] -= max(p, q) - 1\n\n    foo[r+1] += abs(p-q)-1\n    foo[s] -= abs(p-q)-1\n\n    foo[s] += min(p, q)\n    foo[s+1] -= min(p, q)\n\n    foo[s+1] += abs(p-q)\n    foo[n+1] -= abs(p-q)\n\n    # print(p, q, foo)\n\nfor i in range(1,n+1) :\n    foo[i] += foo[i-1]\n    print(foo[i], end=' ')\nprint()\n
import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nN, M = list(map(int, input().split()))\nX = [[] for i in range(N)]\nfor i in range(N-1):\n    x, y = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    X[x].append(y)\n    X[y].append(x)\n\nP = [-1] * N\nDE = [0] * N\n\ndef EulerTour(n, X, i0 = 0):\n    Q = [~i0, i0]\n    ct = -1\n    ET = []\n    ET1 = [0] * n\n    ET2 = [0] * n\n    de = -1\n    while Q:\n        i = Q.pop()\n        if i < 0:\n            ET2[~i] = ct\n            de -= 1\n            continue\n        if i >= 0:\n            ET.append(i)\n            ct += 1\n            if ET1[i] == 0: ET1[i] = ct\n            de += 1\n            DE[i] = de\n        for a in X[i][::-1]:\n            if a != P[i]:\n                P[a] = i\n                for k in range(len(X[a])):\n                    if X[a][k] == i:\n                        del X[a][k]\n                        break\n                Q.append(~a)\n                Q.append(a)\n    return (ET, ET1, ET2)\n\nET, ET1, ET2 = EulerTour(N, X, 0)\n\nfor _ in range(M):\n    A = [max(P[int(a) - 1], 0) for a in input().split()][1:]\n    mad = -1\n    for a in A:\n        if DE[a] > mad:\n            mad = DE[a]\n            maa = a\n    e = ET1[maa]\n    for a in A:\n        if not (ET1[a] <= e <= ET2[a]):\n            print("NO")\n            break\n    else:\n        print("YES")\n\n
from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\nM = mod = 998244353\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\n').split()]\ndef st():return input().rstrip('\n')\ndef val():return int(input().rstrip('\n'))\ndef li2():return [i for i in input().rstrip('\n')]\ndef li3():return [int(i) for i in input().rstrip('\n')]\n\n\nfor _ in range(val()):\n    n = val()\n    l = li()\n    \n    if max(l) == min(l):\n        print('NO')\n        continue\n    \n    print('YES')\n    root = l[0]\n    same = set()\n    other = -1\n    for i in range(1, n):\n        if l[i] == root:\n            same.add(i)\n        else:\n            other = i\n            print(1, i + 1)\n    \n    for i in same:\n        print(i + 1, other + 1)
q=int(input())\nfor t in range(q):\n    n,k=map(int,input().split())\n    a=input()\n    ko=0\n    used=[0]*n\n    ans=''\n    g=True\n    for i in range(n):\n        if a[i]=='1':\n            ko+=1\n        else:\n            if ko<=k:\n                k-=ko\n                ans=ans+'0'\n            else:\n                for j in range(ko-k):\n                    ans=ans+'1'\n                ans=ans+'0'\n                for j in range(k):\n                    ans=ans+'1'\n                for j in range(i+1,n):\n                    ans=ans+a[j]\n                print(ans)\n                g=False\n                break\n    if g==True:\n        for j in range(ko):\n            ans=ans+'1'\n        print(ans)
from operator import itemgetter\nimport sys\ninput = sys.stdin.readline\n\n\nn, m = map(int, input().split())\ninfo = [list(map(int, input().split())) + [i] for i in range(n)]\ninfo = sorted(info, key = itemgetter(1))\nmax_num = info[-1][1]\n\nN = max_num\nINF = 0\nLV = (N-1).bit_length()\nN0 = 2**LV\ndata = [0]*(2*N0)\nlazy = [0]*(2*N0)\n\ndef gindex(l, r):\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & -L).bit_length()\n    rc = 0 if r & 1 else (R & -R).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if L < R and lc <= i:\n            yield L\n        L >>= 1; R >>= 1\n\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i-1]\n        if not v:\n            continue\n        lazy[2*i-1] += v; lazy[2*i] += v\n        data[2*i-1] += v; data[2*i] += v\n        lazy[i-1] = 0\n\ndef update(l, r, x):\n    *ids, = gindex(l, r)\n    propagates(*ids)\n\n    L = N0 + l; R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R-1] += x; data[R-1] += x\n        if L & 1:\n            lazy[L-1] += x; data[L-1] += x\n            L += 1\n        L >>= 1; R >>= 1\n    for i in ids:\n        data[i-1] = max(data[2*i-1], data[2*i])\n\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l; R = N0 + r\n\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R-1])\n        if L & 1:\n            s = max(s, data[L-1])\n            L += 1\n        L >>= 1; R >>= 1\n    return s\n\nans = []\nfor i in range(n):\n    l, r, j = info[i]\n    r += 1\n    if query(l, r) < m:\n        update(l, r, 1)\n    else:\n        ans.append(j+1)\nprint(len(ans))\nprint(*ans)
\ndef bitadd(a,w,bit):\n \n    x = a\n    while x <= (len(bit)-1):\n        bit[x] += w\n        x += x & (-1 * x)\n \ndef bitsum(a,bit):\n \n    ret = 0\n    x = a\n    while x > 0:\n        ret += bit[x]\n        x -= x & (-1 * x)\n    return ret\n\n\nn = int(input())\n\nx = list(map(int,input().split()))\nv = list(map(int,input().split()))\n\nvlis = []\nfor i in v:\n    vlis.append(i)\nvlis.sort()\nvdic = {}\n\nfor i in range(n):\n    vdic[vlis[i]] = i+1\n#print (vdic)\n\n\n\nxv = []\nfor i in range(n):\n    xv.append([x[i],v[i]])\nxv.sort()\n\nans = 0\nBIT = [0] * (n+1)\nBIT2 = [0] * (n+1)\nfor i in range(n):\n\n    x,v = xv[i]\n\n    ans += x * bitsum(vdic[v],BIT2) - bitsum(vdic[v],BIT)\n    bitadd(vdic[v] , x , BIT)\n    bitadd(vdic[v] , 1 , BIT2)\n\nprint (ans)
n, m = list(map(int, input().split()))\nmaxN = 2 * (10 ** 5) + 10\nedges = [[] for i in range(0, maxN)]\nque = [[] for _ in range(0, maxN)]\nans = [0] * m\nsz = [1 for _ in range(0, n)]\np = [i for i in range(0, n)]\ntotal_sum = 0\n\ndef get(u):\n    if p[u] == u:\n        return u\n    p[u] = get(p[u])\n    return p[u]\n\n\ndef unite(u, v):\n    u = get(u)\n    v = get(v)\n    if u == v:\n        return\n    nonlocal total_sum\n    total_sum -= (sz[u] * (sz[u] - 1)) // 2\n    total_sum -= (sz[v] * (sz[v] - 1)) // 2\n    total_sum += ((sz[u] + sz[v]) * (sz[u] + sz[v] - 1)) // 2\n    if sz[u] < sz[v]:\n        p[u] = v\n        sz[v] += sz[u]\n    else:\n        p[v] = u\n        sz[u] += sz[v]\n\n\nfor i in range(1, n):\n    u, v, w = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    edges[w].append((u, v))\nques = list(map(int, input().split()))\n\nfor i in range(0, m):\n    que[ques[i]].append(i)\nfor i in range(0, maxN):\n    for u, v in edges[i]:\n        unite(u, v)\n    for id in que[i]:\n        ans[id] = total_sum\nprint(" ".join(str(x) for x in ans))\n\n\n\n\n\n
import sys\nimport math\ndef II():\n	return int(sys.stdin.readline())\n\ndef LI():\n	return list(map(int, sys.stdin.readline().split()))\n\ndef MI():\n	return list(map(int, sys.stdin.readline().split()))\n\ndef SI():\n	return sys.stdin.readline().strip()\nt = II()\nfor q in range(t):\n	n = II()\n	a = sorted(LI())\n	boo = True\n	for i in range(1,n):\n		if a[i]-a[i-1]>1:\n			boo = False\n			break\n	print("YES" if boo else "NO")\n
def mi():\n	return list(map(int, input().split()))\n\n'''\n4 4\n1010\n1101\n'''\nn,m = mi()\na = list(input())\nb = list(input())\n\npb = [0]*m\n\nif b[0]=='1':\n	pb[0] = 1\nfor i in range(1,m):\n	if b[i]=='1':\n		pb[i] = 1\n	pb[i]+=pb[i-1]\n\nans = 0\nif m>=n:\n	for i in range(n):\n		if a[i]=='1':\n			ans+=(pb[m-n+i]*pow(2,n-i-1,998244353))%998244353\n			ans%=998244353\n	print(ans%998244353)\nelse:\n	for i in range(n-m,n):\n		if a[i]=='1':\n			ans+=(pb[i-(n-m)]*pow(2,n-1-i,998244353))%998244353\n			ans%=998244353\n	print(ans%998244353)\n
for _ in range(int(input())):\n    n=int(input())\n    if(n%4!=0):\n        print('NO')\n    elif(n%4==0):\n        print('YES')\n        a=[]\n        for i in range(1,n//2+1):\n            a.append(i*2)\n        s=sum(a)\n        s1=0\n        for i in range(1,n//2):\n            x=i*2-1\n            a.append(x)\n            s1+=x\n        a.append(s-s1)\n        print(*a)
for _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    keke = dict()\n    for elem in ar:\n        if elem in keke:\n            keke[elem] += 1\n        else:\n            keke[elem] = 1\n    ans = 0\n    for i in range(n):\n        num = ar[i]\n        for j in range(i + 1, n):\n            num += ar[j]\n            if num in keke:\n                ans += keke[num]\n                keke[num] = 0\n    print(ans)
import sys\nfrom collections import deque\n\ninput=sys.stdin.readline\n\nt=1\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    val=set([0,2*10**5+1])\n    seg=[(0,2*10**5+1)]\n    for i in range(n):\n        l,r=list(map(int,input().split()))\n        val.add(l)\n        val.add(r)\n        seg.append((l,r))\n    val=list(val)\n    val.sort()\n    comp={i:e+1 for e,i in enumerate(val)}\n    for i in range(n+1):\n        l,r=seg[i]\n        seg[i]=(comp[l],comp[r])\n\n    deg=[0]*(n+1)\n    out=[[] for i in range(n+1)]\n    for i in range(n+1):\n        for j in range(i+1,n+1):\n            l,r=seg[i]\n            L,R=seg[j]\n            if L<=l and r<=R:\n                out[j].append(i)\n                deg[i]+=1\n            elif l<=L and R<=r:\n                out[i].append(j)\n                deg[j]+=1\n\n    ans=[0]\n    deq=deque(ans)\n\n    while deq:\n        v=deq.popleft()\n        for nv in out[v]:\n            deg[nv]-=1\n            if deg[nv]==0:\n                deq.append(nv)\n                ans.append(nv)\n\n    dp=[0]*(n+1)\n\n    def solve(v):\n        query=[[] for i in range(2*n+3)]\n        for nv in out[v]:\n            l,r=seg[nv]\n            query[r].append((l,dp[nv]))\n        subdp=[0]*(2*n+3)\n        for i in range(1,2*n+3):\n            res=subdp[i-1]\n            for l,val in query[i]:\n                test=subdp[l-1]+val\n                res=max(test,res)\n            subdp[i]=res\n\n        dp[v]=subdp[-1]+1\n\n    for v in ans[::-1]:\n        solve(v)\n\n    print(dp[0]-1)\n
a = int(input())\nfor i in range(a):\n    x, y = map(int, input().split())\n    t = x * 60 + y\n    print(24*60 - t)
for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    balance = 0\n    index = {0: 1}\n    ans = [10**9]\n    i = 1\n    for x in s:\n        if x == 'U':\n            balance += 10 ** 9\n        elif x == 'D':\n            balance -= 10 ** 9\n        elif x == 'L':\n            balance += 1\n        else:\n            balance -= 1\n        if balance in index:\n            ans = min(ans, [i + 1 - index[balance], index[balance], i])\n        index[balance] = i + 1\n        i += 1\n    if ans[0] == 10 ** 9:\n        print(-1)\n    else:\n        print(ans[1], ans[2])\n
from collections import defaultdict as dd\nfor _ in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    d=dd(int)\n    for i in a:\n        d[i]+=1\n    ma=0\n    r=len(d.keys())\n    for i in d.keys():\n        ma=max(ma,min(d[i]-1,r),min(d[i],r-1))\n    print(ma)
import traceback\nimport sys\nsys.setrecursionlimit(200010)\n\ntry:\n    # alpha = "abcdefghijklmnopqrstuvwxyz"\n\n    n = int(input())\n    a = [0]\n    a.extend(list(map(int, input().split())))\n    D = [[] for i in range(n+1)]\n    for i in range(n-1):\n        e1,e2 = (map(int, input().split()))\n        D[e1].append(e2)\n        D[e2].append(e1)\n\n    # for i in range(1,n+1):\n    #     if i not in D:\n    #         D[i] = []\n\n    visited = [False for i in range(n+1)]\n    cost = [a[i] for i in range(n+1)]\n    parent = [0 for i in range(n+1)]\n    val = 0\n\n    def dfs(s, depth):  \n        nonlocal visited\n        nonlocal cost  \n        nonlocal val  \n        nonlocal a\n        nonlocal D\n        stack = [(s,depth)]\n        while stack:\n            s, depth = stack[-1]\n            if visited[s]:\n                stack.pop()\n                cost[parent[s]]+=cost[s]\n                continue\n            else:    \n                visited[s] = True\n                val += depth*a[s]\n            for i in D[s]:\n                if not visited[i]:   \n                    parent[i] = s\n                    stack.append((i, depth+1))\n                    # cost[s]+=cost[i]\n\n    dfs(1, 0)\n\n    # ans = 1\n    max_cost = val\n    # print(max_cost)\n    visited = [False for i in range(n+1)]\n    cost[0] = sum(a)\n    def trav(s, some_val):\n        nonlocal cost  \n        nonlocal visited\n        nonlocal max_cost\n        nonlocal D \n        stack = [(s,some_val)]\n        while stack:\n            s, some_val = stack.pop()\n            visited[s] = True\n            # print(some_val, s)\n            if some_val>max_cost:\n                max_cost = some_val\n\n            for i in D[s]:\n                if not visited[i]:     \n                    # print(i, some_val, cost[s], cost[i])\n                    stack.append((i, some_val+(cost[0]-cost[i])-cost[i] ))\n\n\n    trav(1, val)\n    print(max_cost)\nexcept Exception as ex:\n    traceback.print_tb(ex.__traceback__)\n    print(ex)
t = int(input())\nfor _ in range(t):\n    n, k = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    \n    d = dict()\n    d[0] = 0\n    for v in l:\n        vv = (k - v) % k\n        if vv:\n            if vv not in d:\n                d[vv] = vv + 1\n            else:\n                d[vv] += k\n    print(max(d.values()))\n\n
class Solution:\n     def findContentChildren(self, g, s):\n         """\n         :type g: List[int]\n         :type s: List[int]\n         :rtype: int\n         """\n         res = 0\n         heapq.heapify(g)\n         s.sort()\n         for num in s:\n             if not g:\n                 break\n             elif g[0] <= num:\n                 res += 1\n                 heapq.heappop(g)\n         return res
class Solution:\n     def getRow(self, k):\n         """\n         :type k: int\n         :rtype: List[int]\n         """\n         res = [1]\n         cur = k\n         for i in range(k//2):\n             res += res[-1] * cur // (i+1),\n             cur -= 1\n         if k % 2 == 0:\n             res = res + res[:-1][::-1]\n         else:\n             res = res + res[::-1]\n         return res\n
class Solution:\n    def hammingWeight(self, n: int) -> int:\n        count = 0\n        while n!=0:\n            n &= (n-1)\n            count += 1\n        return count
class Solution:\n     def plusOne(self, digits):\n         """\n         :type digits: List[int]\n         :rtype: List[int]\n         """\n         carry=1\n         for i in range(len(digits)-1, -1, -1):\n             digits[i]+=carry\n             if digits[i] > 9:\n                 digits[i]-=10\n                 carry=1\n             else:\n                 carry=0    \n             if carry == 0:\n                 break    \n         if carry == 1:\n             digits.insert(0, 1)\n         return digits    
a,b=map(int,input().split(" "))\nprint(max(max(a+b,a*b),a-b))
def main():\n	N, D = [int(n) for n in input().split(" ")]\n	cnt = 0\n	for i in range(N):\n		X, Y = [int(x) for x in input().split(" ")]\n		if X ** 2 + Y ** 2 <= D ** 2:\n			cnt += 1\n	print(cnt)\n\nmain()\n
N = input()\nX = int(N)\nif X % sum(list(map(int, N))) == 0:\n    print("Yes")\nelse:\n    print("No")\n
N=int(input())\nA=list(map(int,input().split()))\n\nSUM=abs(A[0])\nfor i in range(N):\n  if i < N-1:\n    SUM += abs(A[i+1]-A[i])\n  else:\n    SUM += abs(0-A[i])\n\nnow=0\nfor i in range(N):\n  if i != N-1:\n    diff = abs(A[i+1]-now)-abs(A[i]-now)-abs(A[i+1]-A[i])\n    now = A[i]\n  else:\n    diff = abs(0-now)-abs(A[i]-now)-abs(0-A[i])\n  print(SUM + diff)
c = input()\n\nvo = ['a','e','i','o','u']\nprint('vowel' if c in vo else 'consonant')
s= input()\ncolor = "chokudai"\nd = []\n\nfor c in s:\n    if c != color:\n        d.append(c)\n        color = c\nprint(len(d)-1)
\n#ABC086B\na,b = input().split()\na += b\na = int(a)\nprint("Yes" if int((a**.5))**2 == a else "No")
# -1 0 1を足したもののうち最大値を数える\nn = int(input())\na = list(map(int, input().split()))\n# ai=0の場合もあるので-1がありえることに注意 適当にa[0]を-1の数とする\nd = [0] * (10**5 + 10)\nfor av in a:\n    for x in [-1, 0, 1]:\n        # 前述の通りa[0]を-1の数とする\n        d[av + x + 1] += 1\nprint(max(d))
print(int(input())**2 - int(input()))
a,b,c=map(int, input().split())     \nprint("YES" if b-a==c-b else "NO")
n = input()\nif '9' in n:\n    print('Yes')\nelse:\n    print('No')
import bisect\n\nN,M,X = map(int,input().split())\nA = list(map(int,input().split()))\n\nindex = bisect.bisect_left(A,X)\nans = min(M-index,index)\nprint(ans)
h,w=list(map(int,input().split()))\ndx=[0,1,0,-1] ; dy=[1,0,-1,0]\nA=[list(input()) for i in range(h)]\n\nfor i in range(h):\n    for  j in range(w):\n        if A[i][j]=="#":\n            for q,e in zip(dx,dy):\n                if 0<=i+q<h and 0<=j+e<w:\n                    if A[i+q][e+j]=="#":break\n            else:\n                print("No");return\nprint("Yes")\n
a,b,c=list(map(int,input().split()))\nprint(('Yes'if a+b==c or b+c==a or c+a==b else'No'))\n
a,b,c,d = map(int,input().split())\nab = a + b\ncd = c + d\nif ab > cd:\n    print('Left')\nelif ab < cd:\n    print('Right')\nelse:\n    print('Balanced')
n=int(input())\nF = [int(input().replace(" ",""),2) for _ in range(n)]\nP = [list(map(int,input().split())) for _ in range(n)]\n\ntotal = -10**9\nfor i in range(1,2**10):\n    pgain = 0\n    for f,p in zip(F,P):\n        pgain += p[bin(f&i).count("1")]\n    if total < pgain:\n        total = pgain\n        k = i\nprint(total)
a,b = list(map(int, input().split()))\ns = input()\ncount = 0\nans = 'Yes'\nfor i in range(a+b+1):\n  if i == a:\n    if s[i] != '-':\n      ans = 'No'\n      break\n  else:\n    if s[i] == '-':\n      ans = 'No'\n      break\nprint(ans)\n
W,a,b=map(int,input().split());print([abs(a-b)-W,0][abs(a-b)<=W])
a, b, k = map(int,input().split())\nfor i in range(a,min(b,a+k-1)+1):\n    print(i)\nfor i in range(max(b-k+1,a+k),b+1):\n    print(i)
A,S,C=map(str,input().split())\nprint("A"+S[0]+"C")
a, b, x = map(int, input().split())\nprint("YES" if a <= x and x <= a+b else "NO")
x, t = list(map(int, input().split()))\nprint((max(0, x - t)))\n
a=1\nfor i in[*open(0)][1].split():a*=int(i);a=[-1,a][0<=a<=10**18]\nprint(a)
n=int(input())\na=int(input())\nif n%500<=a:\n    print("Yes")\nelse:\n    print("No")
X,A,B=list(map(int,input().split()))\nif A-B>=0:\n    print("delicious")\nelif -A+B<=X:\n    print("safe")\nelse:\n    print("dangerous")\n
N = int (input ())\nx = 1\nwhile x**2 <= N:\n  x += 1\nx -= 1\nprint (x**2)
import sys\nreadline = sys.stdin.readline\ndef ceil(a, b):\n    return -(-a//b)\n\ndef main():\n    N = int(readline())\n    inp = [tuple(map(int, readline().rstrip().split())) for _ in range(N)]\n    scr_t, scr_a = 0, 0\n    for t, a in inp:\n        if t >= scr_t and a >= scr_a:\n            scr_t = t\n            scr_a = a\n        elif t < scr_t and a >= scr_a:\n            scr_t = t * ceil(scr_t, t)\n            scr_a = scr_t * a // t\n        elif a < scr_a and t >= scr_t:\n            scr_a = a * ceil(scr_a, a)\n            scr_t = scr_a * t // a\n        else:\n            if t / a >= scr_t / scr_a:\n                scr_a = a * ceil(scr_a, a)\n                scr_t = scr_a * t // a\n            else:\n                scr_t = t * ceil(scr_t, t)\n                scr_a = scr_t * a // t\n\n    print((scr_t + scr_a))\n\ndef __starting_point():\n    main()\n\n__starting_point()
import sys, math\nfrom itertools import combinations as c, product as p\nfrom collections import deque\nsys.setrecursionlimit(10**9)\nINF = float('inf')\nMOD = 10**9 + 7\n#MOD = 998244353\n\n\ndef si(): return input()\ndef ii(): return int(input())\ndef fi(): return float(input())\ndef lstr(): return input().split()\ndef lint(): return list(map(int, input().split()))\ndef lintdec(): return list(map(lambda x:int(x) - 1, input().split()))\ndef lnstr(n): return [input() for _ in range(n)]\ndef lnint(n): return [int(input()) for _ in range(n)]\ndef lint_list(n): return [lint() for _ in range(n)]\n\n\n\n############################################################\nS = si()\nprint('yes' if len(set(S)) == len(S) else 'no')
n=int(input())\ns=input()\n\ncnt=s[1:].count("E")\nans=cnt\n\nfor i in range(1,n):\n  if s[i-1]=="W":\n    cnt+=1\n  if s[i]=="E":\n    cnt-=1\n  ans=min(ans,cnt)\n\nprint(ans)
n,m = map(int, input().split())\nc = [0 for _ in range(n)]\nfor i in range(m):\n  a,b = map(int, input().split())\n  c[a-1] += 1\n  c[b-1] += 1\nfor j in range(n):\n  print(c[j])
N = int(input())\ns = []\n\nfor i in range(N):\n  s.append(int(input()))\n  \nS = sum(s)\n\nif S%10 != 0:\n  print(S)\nelse:\n  b = True\n  for j in range(N):\n    if  s[j]%10 == 0:\n      continue\n    else:\n      b = False\n  if b:\n    print(0)\n  else:\n    s.sort()\n    for k in range(N):\n      if s[k]%10 != 0:\n        print(S-s[k])\n        break
#\n# abc096 b\n#\nimport sys\nfrom io import StringIO\nimport unittest\nfrom collections import Counter\n\n\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n\n    def test_入力例_1(self):\n        input = """6\naabbca"""\n        output = """2"""\n        self.assertIO(input, output)\n\n    def test_入力例_2(self):\n        input = """10\naaaaaaaaaa"""\n        output = """1"""\n        self.assertIO(input, output)\n\n    def test_入力例_3(self):\n        input = """45\ntgxgdqkyjzhyputjjtllptdfxocrylqfqjynmfbfucbir"""\n        output = """9"""\n        self.assertIO(input, output)\n\n\ndef resolve():\n    N = int(input())\n    S = input()\n\n    ans = 0\n    for i in range(1, N-1):\n        x = Counter(S[0:i])\n        y = S[i:]\n        tmp = 0\n        for j in list(x.keys()):\n            if j in y:\n                tmp += 1\n        ans = max(ans, tmp)\n\n    print(ans)\n\n\ndef __starting_point():\n    # unittest.main()\n    resolve()\n\n__starting_point()
s=input()\n\nif s=='Sunny':\n  print('Cloudy')\nif s=='Cloudy':\n    print('Rainy')\nif s=='Rainy':\n    print('Sunny')\n  \n
n, a, b = (int(n) for n in input().split())\nprint(min(n * a, b))
n, m = list(map(int, input().split()))\n\nans = (1900 * m + 100 * (n - m)) * (2 ** m)\n\nprint(ans)\n
S = input()\nalphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n\nfor a in alphabet:\n    if a not in S:\n        print(a)\n        return\n        \nprint('None')\n\n\n
n = int(input())\nx = list(map(int,input().split()))\n\ny = sorted(x)\n\nans1 = y[n//2]\nans2 = y[n//2-1]\n\nfor i in x :\n    if i < ans1 :\n        print(ans1)\n    else :\n        print(ans2)\n
n=int(input())\na=[int(i) for i in input().split()]\n\n\na.sort()\n\ncount=0\n\n\ndef get_num(a):\n    count=1\n    taishou = a.pop()\n    while a!=[]:\n        second=a.pop()\n        if taishou==second:\n            count+=1\n        else:\n            a.append(second)\n            break\n    if count==1:\n        return taishou,0\n    elif count==2 or count==3:\n        return taishou,1\n    else:\n        return taishou,2\n\none=0\ntwo=0\n\n\nwhile a!=[] and (one==0 or two==0):\n    hen,length=get_num(a)\n    if length==1:\n        if one==0:\n            one=hen\n        else:\n            two=hen\n    elif length==2:\n        if one==0:\n            one=hen\n            two=hen\n        else:\n            two=hen\n\nprint((one*two))\n\n
n=int(input())\nd,x=map(int,input().split())\nfor i in range(n):\n  t=int(input())\n  x+=(d+t-1)//t\nprint(x)
a = int(input())\nb = int(input())\nc = int(input())\nx = int(input())\n\nans = 0\n\nfor i in range(a + 1):\n    for j in range(b + 1):\n        maisuuOf50 = (x - i * 500 - j * 100) / 50\n        if 0 <= maisuuOf50 <= c:\n            ans += 1\n\nprint(ans)\n
# 3 つの整数 A , B , C が与えられます。\n# 整数 C が A 以上 かつ B 以下であるかを判定してください。\n\nA,B,C = map(int,input().split())\n\nif C >= A and C <= B:\n    print('Yes')\n\nelse:\n    print('No')
n,x=list(map(int,input().split()))\ny = [int(input()) for i in range(n)]\ny.sort()\nc = 0\nfor i in range(n):\n  if c < x:\n    c +=y[i]\n  elif c > x:\n    print((i-1))\n    return\nd = sum(y)\nprint((((x-d)//y[0])+n))\n
n=int(input())\nstring_list=[input() for i in range(n)]\ncount = len(set(string_list))\nprint(count)
n = int(input())\na = list(map(int, input().split()))\n\nans = 0\nt = 400\nwhile t < 3201:\n  for i in a:\n    if i >= t-400 and i < t:\n      ans += 1\n      break\n  t += 400\n\ns = 0\nfor i in a:\n  if i >= 3200: s += 1\n\nif ans == 0: print(1, s)\nelse: print(ans, ans+s)
s = input()\nprint(s.count("o")*100+700)
# 入力\na, b = input().split()\n\n# 出力\n# a = 'H' のときatくんは正直者\nif a == 'H' and b == 'H':\n    print('H')\nelif a == 'D' and b == 'H':\n    print('D')\nelif a == 'H' and b =='D':\n    print('D')\nelif a == 'D' and b == 'D':\n    print('H')
\nS = input()\n\na = int(S[0])\nb = int(S[1])\nc = int(S[2])\nd = int(S[3])\n\nif a+b+c+d==7:\n    print('{}+{}+{}+{}=7'.format(a,b,c,d))\nelif a+b+c-d==7:\n    print('{}+{}+{}-{}=7'.format(a,b,c,d))\nelif a+b-c+d==7:\n    print('{}+{}-{}+{}=7'.format(a,b,c,d))\nelif a+b-c-d==7:\n    print('{}+{}-{}-{}=7'.format(a,b,c,d))\nelif a-b+c+d==7:\n    print('{}-{}+{}+{}=7'.format(a,b,c,d))\nelif a-b+c-d==7:\n    print('{}-{}+{}-{}=7'.format(a,b,c,d))\nelif a-b-c-d==7:\n    print('{}-{}-{}-{}=7'.format(a,b,c,d))\nelif a-b-c+d==7:\n    print('{}-{}-{}+{}=7'.format(a,b,c,d))
def i_input(): return int(input())\n\n\ndef i_map(): return list(map(int, input().split()))\n\n\ndef i_list(): return list(map(int, input().split()))\n\n\ndef i_row(N): return [int(input()) for _ in range(N)]\n\n\ndef i_row_list(N): return [list(map(int, input().split())) for _ in range(N)]\n\n\nn = i_input()\naa=i_list()\nshain=[0]*n\nfor a in aa:\n    shain[a-1]+=1\nfor s in shain:\n    print(s)\n\n\n
x=int(input())\nans=0\na=0\nfor i in range(1,x+1):\n  a+=i\n  ans+=1\n  if a>=x:\n    print(ans)\n    break
n = input()\nprint("Yes" if n[0] == n[1] == n[2] or n[1] == n[2] == n[3] else "No")
n = int(input())\na_list = sorted([int(x) for x in input().split()])\nb_list = sorted([int(x) for x in input().split()])\nc_list = sorted([int(x) for x in input().split()])\n\nimport bisect\nsum = 0\nfor b in b_list:\n    b_num = bisect.bisect_left(a_list,b)\n    c_num = bisect.bisect_right(c_list,b)\n    sum += b_num*(len(c_list)-c_num)\nprint(sum)
x,y=input().split()\nif ord(x)<ord(y):print('<')\nelif ord(x)>ord(y):print('>')\nelse:print('=')
# 愚直\nh, w = map(int, input().split())\ntable = [list(input()) for _ in range(h)]\nfor i in range(h):\n    for j in range(w):\n        if table[i][j] == ".":\n            num = 0\n            for y in [-1, 0, 1]:\n                for x in [-1, 0, 1]:\n                    if 0 <= i + y < h and 0 <= j + x < w:\n                        if table[i + y][j + x] == "#":\n                            num += 1\n            table[i][j] = str(num)\nfor t in table:\n    print("".join(t))
def solve():\n  N,M,K = map(int, input().split())\n  A = list(map(int, input().split()))\n  B = list(map(int, input().split()))\n  ret = 0\n\n  A_cusum = [0]\n  A_border_index = 0 # 超えるときのindex\n  for a_ in A:\n    A_end = A_cusum[-1]\n    if A_end+a_ > K:\n      break\n\n    A_cusum.append(A_end+a_)\n    \n  A_border_index = len(A_cusum)-1\n  ret = A_border_index\n\n  B_cusum = [0]\n  B_border_index = 0\n  \n  while A_border_index >= 0 and B_border_index < M:\n\n    while B_border_index < M:\n      B_end = B_cusum[-1]\n      b_ = B[B_border_index]\n\n      if A_cusum[A_border_index]+B_end+b_ > K:\n        break\n\n      B_cusum.append(B_end+b_)\n      B_border_index += 1\n\n    ret = max(ret, A_border_index+B_border_index)\n    A_border_index -= 1\n\n  print(ret)\n  \nsolve()
a,b,c,x,y = list(map(int,input().split()))\n\nif (a + b) <= 2 * c:\n  print((a * x + b * y))\nelse:\n  max_c = max(x,y)\n  min_c = min(x,y)\n  AB = 2 * c * max_c\n  if x > y:\n    SP = ((x - min_c) * a) + (2 * c * min_c)\n  else:\n    SP = ((y - min_c) * b) + (2 * c * min_c)\n  print((min(AB,SP)))\n
N = int(input())\nmod = 1000000007\nfrom collections import Counter\nY = Counter()\nfor i in range(2, N+1):\n    M = i\n    for j in range(2,i+1):\n        while M % j == 0:\n            Y[j] += 1\n            M //= j\n\ndef product(X):\n    res = 1\n    for x in X:\n        res *= x + 1\n        res %= mod\n    return res    \n\nans = product(Y.values())\nprint(ans)
x=int(input())\nm=-1000\nif 1<=x<=3:\n  print((1))\n  return\nelse:\n  for b in range(2,x+1):\n   for p in range(2,11):\n    if x>=b**p:\n      m=max(m,b**p)\n   \n\nprint(m)\n\n
N = int(input())\nds = []\nmochidan = 0\nfor i in range(N):\n    ds.append(int(input()))\n\nwhile ds:\n    tmp = max(ds)\n    ds = [j for j in ds if j < tmp]\n    mochidan += 1\n\nprint(mochidan)
s = input()\nfirst_a_index = s.index('A')\nlast_z_index = len(s) - list(reversed(s)).index('Z')\nprint(last_z_index - first_a_index)
n = int(input())\na = list(map(int, input().split()))\n\ncnt = 0\nfor i in range(n):\n    cnt = cnt | a[i]\n\nj = 0\nans = 0\nwhile 1:\n    if (cnt >> j & 1 == 0):\n        ans += 1\n        j += 1\n    else:\n        break\nprint(ans)
N = int(input())\n\n# N!を(10^9+7)で割った余りを求める\n# N!そのものを求める必要はなく、\n# x = i*x (mod 10^9+7) と更新していけばよい\nM = 10**9 + 7\ns = 1\nfor i in range(1, N+1):\n  s *= i\n  s %= M\n  \nprint(s)
N = int(input())\n \nans = int(N*(N+1)/2)\nprint(ans)
def main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    alice = 0\n    bob = 0\n    A.sort(reverse=True)\n    for i, a in enumerate(A):\n        if i%2 == 0:\n            alice += a\n        else:\n            bob += a\n    print((alice - bob))\n\ndef __starting_point():\n    main()\n\n__starting_point()
N, M = [int(n) for n in input().split()]\n\nsubmit = []\nAC = [0] * N\nWA = [0] * N\n\nfor i in range(M):\n    p, s = [n for n in input().split()]\n    p = int(p)\n\n    if AC[p-1] == 1:\n        continue\n\n    if s == 'AC':\n        AC[p-1] = 1\n \n    elif s == 'WA':\n        WA[p-1] += 1\n\npen = [x*y for x, y in zip(AC, WA)]\n\nprint(sum(AC), sum(pen))
n, k = map(int, input().split())\nH = list(map(int, input().split()))\nH.sort(reverse=True)\nprint(sum(H[k:]))
n = int(input())\nk = int(input())\nx = list(map(int,input().split()))\nans = 0\nfor i in range(n):\n    ans += 2*min(k-x[i],x[i])\nprint(ans)
a = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\n\nsum = (min(a, b) + min(c, d))\nprint(sum)
n = int(input())\na = [int(x) for x in input().split()]\na.sort()\nmod = 10 ** 9 + 7\n\ndef p(p):\n  ans = 1\n  for i in range(p):\n    ans *= 2\n    ans %= mod\n  return ans\n\nif n % 2 == 1:\n  res = True\n  for i in range(n):\n    if a[i] != ((i + 1) // 2) * 2:\n      res = False\n  if res:\n    print(p(n // 2))\n  else:\n    print(0)\n    \nelse:\n  res = True\n  for i in range(n):\n    if a[i] != (i // 2) * 2 + 1:\n      res = False\n  if res:\n    print(p(n // 2))\n  else:\n    print(0)
n, a, b = map(int, input().split())\n\nans = 0\nfor i in range(1, n + 1):\n    val = 0\n    for c in str(i):\n        val += int(c)\n    if a <= val <= b:\n        ans += i\nprint(ans)
N = input()\nprint("ABC"+N)
a,b=map(int,input().split())\n\nif a>b:\n    print(a-1)\nelse:\n    print(a)
#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n# FileName: 	sample\n# CreatedDate:  2020-10-10 20:29:20 +0900\n# LastModified: 2020-10-10 20:37:38 +0900\n#\n\n\nimport os\nimport sys\n# import numpy as np\n# import pandas as pd\n\n\ndef main():\n    N = int(input())\n    A = [0]\n    visited = [0]*(N+1)\n    for _ in range(N):\n        A.append(int(input()))\n    i = 1\n    cnt = 0\n    while visited[i] == 0:\n        if i == 2:\n            print(cnt)\n            return\n        cnt += 1\n        visited[i] = 1\n        i = A[i]\n    print((-1))\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
n=int(input())\nd=dict()\nfor _ in range(n):\n    hoge=int(input())\n    if d.get(hoge,0)==0:\n        d[hoge]=1\n    else:\n        d[hoge]+=1\nans=0\nfor i in d.values():\n    if i%2==1:\n        ans+=1\nprint(ans)
n,k=list(map(int,input().split()))\na=list(map(int,input().split()))\nfrom collections import Counter\ndic=Counter(a)\ndic=sorted(list(dic.items()),key=lambda x:x[1])\n\nans=0\ncnt=0\nl=max(len(dic)-k,0)\nfor i in dic:\n  if cnt==l:\n    break\n  ans=ans+i[1]\n  cnt=cnt+1\nprint(ans)\n
N = int(input())\n\nT = 0\nX = 0\nY = 0\n\nfor i in range(N):\n    t, x, y = list(map(int, input().split()))\n    dt = t - T\n    dx = abs(X - x)\n    dy = abs(Y - y)\n    dis = dx + dy\n    if dt < dis:\n        print("No")\n        break\n    if (dt - dis) % 2 == 1:\n        print("No")\n        break\n    T = t\n    X = x\n    Y = y\nelse:\n    print("Yes")\n
a, b = map(int, input().split())\nprint(((a + b) + (2 - 1)) // 2)
import sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\ndef NIJIGEN(H): return [list(input()) for i in range(H)]\ndef dfs(j):\n  if j not in finish:\n    finish.add(j)\n    for k in L[j]:\n      dfs(k)\nN,M=MAP()\ns=list()\nL=[[] for _ in range(N)]\nfor i in range(M):\n  a,b=MAP()\n  a-=1\n  b-=1\n  L[a].append(b)\n  L[b].append(a)\n  s.append([a,b])\nans=0\nfor i in range(M):\n  a,b=s[i]\n  L[a].remove(b)\n  L[b].remove(a)\n  finish=set()\n  dfs(a)\n  if len(finish)!=N:\n    ans+=1\n  L[a].append(b)\n  L[b].append(a)\nprint(ans)
import bisect,collections,copy,heapq,itertools,math,string\nimport sys\ndef I():\n    #1 line 1 int\n     return int(sys.stdin.readline().rstrip())\ndef LI():\n    #1 line n int\n     return list(map(int,sys.stdin.readline().rstrip().split()))\ndef S():\n    #1 line 1 string\n     return sys.stdin.readline().rstrip()\ndef LS():\n    #1 line n strings\n     return list(sys.stdin.readline().rstrip().split())\n\n\nxs=LI()\n\nif xs[0] == xs[1]:\n    print(xs[2])\nelif xs[0] == xs[2]:\n    print(xs[1])\nelse:\n    print(xs[0])
a, b, c, d, e, f = map(int, input().split())\ns = set()\nfor i in range(30 // a + 1):\n    for j in range(30 // b + 1):\n        if 0 < (a * i + b * j) * 100 <= f:\n            s = s | {a * i + b * j}\ns2 = set()\nfor i in range(3000 // c + 1):\n    for j in range(3000 // d + 1):\n        if c * i + d * j <= f:\n            s2 = s2 | {c * i + d * j}\nans = []\nfor i in s:\n    for j in s2:\n        if i * 100 + j <= f and j <= i * e:\n            ans.append([j / i * -1, i * 100 + j, j])\nans.sort()\nprint(ans[0][1], ans[0][2])
a = input()\nprint(f"{a[0]}{len(a[1:-1])}{a[-1]}")
a = input()\nb = input()\n\nif a[:: -1] == b:\n    print("YES")\nelse:\n    print("NO")
import sys\nstdin=sys.stdin\n\nip=lambda: int(sp())\nfp=lambda: float(sp())\nlp=lambda:list(map(int,stdin.readline().split()))\nsp=lambda:stdin.readline().rstrip()\nyp=lambda:print('Yes')\nnp=lambda:print('No')\n\ns=list(sp())\nk=ip()\n\nans=set()\n\nalpa=list(set(s))\nalpa.sort()\nch=0\nsiyou=[]\nfor i in range(len(alpa)):\n  if i<=2:\n    siyou.append(alpa[i])\n  else:\n    break\n    \nfor x in siyou:\n  for i in range(len(s)):\n    if s[i]==x:\n      st=''\n      for y in range(i,i+5):\n        if y<len(s):\n          st+=s[y]\n          ans.add(st)\n  if len(ans)>k:\n    break\n  \nans=list(ans)\nans.sort()\nprint(ans[k-1])\n    \n\n\n
def main():\n    w, h, n = list(map(int, input().split()))\n\n    x_min = 0\n    x_max = w\n    y_min = 0\n    y_max = h\n\n    for _ in range(n):\n        x, y, a = list(map(int, input().split()))\n        if a == 1:\n            x_min = max(x_min, x)\n        elif a == 2:\n            x_max = min(x_max, x)\n        elif a == 3:\n            y_min = max(y_min, y)\n        else:\n            y_max = min(y_max, y)\n\n    print((\n        (x_max - x_min) * (y_max - y_min)\n        if x_min < x_max and y_min < y_max else 0\n    ))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
def LIHW(h):\n    return [list(map(int, input().split())) for _ in range(h)]\n\n\nN = int(input())\nX = LIHW(N-1)\n\nfor i in range(N-1):\n    time = [0]*N\n    time[i] = X[i][1]+X[i][0]\n    for j in range(i+1, N-1):\n        if time[j-1] <= X[j][1]:\n            time[j] = X[j][1]+X[j][0]\n        else:\n            if (time[j-1]-X[j][1]) % X[j][2] == 0:\n                time[j] = time[j-1] + X[j][0]\n            else:\n                time[j] = time[j-1] + X[j][0]+X[j][2] - \\n                    ((time[j-1]-X[j][1]) % X[j][2])\n    print(time[j])\nprint(0)
H, W = map(int, input().split())\nfor _ in range(H):\n    C = input()\n    print(C)\n    print(C)
def N():\n    return int(input())\ndef L():\n    return list(map(int,input().split()))\ndef NL(n):\n    return [list(map(int,input().split())) for i in range(n)]\nmod = pow(10,9)+7\n\n#import numpy as np\nimport sys\nimport math\nimport collections\n\nn =N()\na = L()\ns = set()\nfor i in range(n):\n    if a[i] in s:\n        print("NO")\n        return\n    s.add(a[i])\nprint("YES")
for _ in range(int(input())):\n    n = int(input())\n    wt = list(map(int, input().split()))\n    count = {}\n    for x in wt:\n        if x not in count:\n            count[x] = 0\n        count[x] += 1\n    k = 0\n\n    for s in range(101):\n        temp = 0\n        temp2 = 0\n        for x in count:\n            if (s - x) in count:\n                if (s - x) == x:\n                    temp2 += count[x] // 2\n                else:\n                    temp += min(count[x], count[s -x])\n        \n        k = max(k, temp//2 + temp2)\n    print(k)\n
import sys\n\n    \ndef main():\n    #n = iinput()\n    #k = iinput() \n    #m = iinput() \n    #n = int(sys.stdin.readline().strip()) \n    #n, k = rinput()\n    #n, m = rinput()\n    #m, k = rinput()\n    #n, k, m = rinput()\n    #n, m, k = rinput()\n    #k, n, m = rinput()\n    #k, m, n = rinput() \n    #m, k, n = rinput()\n    #m, n, k = rinput()\n    #n, t = map(int, sys.stdin.readline().split())\n    #q = list(map(int, sys.stdin.readline().split()))\n    #q = linput()\n    n, x = list(map(int, sys.stdin.readline().split()))\n    if n < 3:\n        print(1)\n        return 0\n    print((n - 2 + x - 1) // x + 1)\n    \n    \n           \n        \n            \n    \n    \n    \n    \n    \n    \n            \n                \n        \n    \n            \n        \n\n            \n        \n    \n                \n    \n    \n    \n            \n    \n        \n    \n\nfor i in range(int(sys.stdin.readline().strip()) ):\n    main()\n    \n
from string import ascii_lowercase\n\nt = int(input())\n\nfor _ in range(t):\n    n, m = [int(x) for x in input().split()]\n\n    s = input()\n    count = {x : 0 for x in ascii_lowercase}\n    errors = [int(x) for x in input().split()]\n\n    errors = sorted(errors)\n\n    e_idx = 0\n    for j, c in enumerate(s):\n        while e_idx < m and errors[e_idx] <= j:\n            e_idx += 1\n        count[c] += (m - e_idx) + 1\n\n    print(*[count[c] for c in ascii_lowercase])\n
t=int(input())\nfor nt in range(t):\n	a,b,c=map(int,input().split())\n	print (max(0,abs(a-b)+abs(b-c)+abs(a-c)-4))
def read_int():\n    return int(input())\n\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\n\nt = read_int()\nfor case_num in range(t):\n    n = read_int()\n    a = list(read_ints())\n    cnt = [0 for i in range(101)]\n    even = 0\n    for ai in a:\n        cnt[ai] += 1\n        if ai % 2 == 0:\n            even += 1\n    odd = n - even\n    if even % 2 == 0:\n        print('YES')\n    else:\n        ok = False\n        for i in range(1, 100):\n            if cnt[i] > 0 and cnt[i + 1] > 0:\n                ok = True\n                break\n        print('YES' if ok else 'NO')\n
import sys\ninput = sys.stdin.readline\n\nimport heapq\n\ndef dijkstra(n, s, edges):\n    hq = [(0, s)]\n    cost = [float('inf')] * n\n    cost[s] = 0\n    while hq:\n        c, v = heapq.heappop(hq)\n        if c > cost[v]:\n            continue\n        for d, u in edges[v]:\n            tmp = d + cost[v]\n            if tmp < cost[u]:\n                cost[u] = tmp\n                heapq.heappush(hq, (tmp, u))\n    return cost\n\ndef main():\n    n, m, k = map(int, input().split())\n\n    edges = [[] for _ in range(n)]\n    xy = []\n    for _ in range(m):\n        x, y, t = map(int,input().split())\n        x -= 1\n        y -= 1\n        edges[x].append((t, y))\n        edges[y].append((t, x))\n        xy.append((x, y))\n    \n    dist = [[] for _ in range(n)]\n    for i in range(n):\n        dist[i] = dijkstra(n, i, edges)\n        \n    ab = [list(map(int, input().split())) for _ in range(k)]\n    ans = 10 ** 20\n    for x, y in xy:\n        tmp = 0\n        for a, b in ab:\n            a -= 1\n            b -= 1\n            tmp += min(dist[a][b], dist[a][x] + dist[b][y], dist[a][y] + dist[b][x])\n        ans = min(ans, tmp)\n    print(ans)\n    \nmain()
for _ in range(int(input())):\n	n = int(input())\n\n	bits = ['1']\n	while int(''.join(bits), 3) < n:\n		bits.append('1')\n	\n	\n	for i in range(len(bits)):\n		bits[i] = '0'\n		if int(''.join(bits), 3) < n:\n			bits[i] = '1'\n	\n	print(int(''.join(bits), 3))\n
for _ in range(int(input())):\n    n = int(input())\n    P = list(map(int, input().split()))\n    ans = [0] * n\n    for i in range(n):\n        if ans[i] == 0:\n            now = i\n            cnt = 0\n            cll = []\n            while True:\n                now = P[now] - 1\n                cnt += 1\n                cll.append(now)\n                if now == i:\n                    break\n            for u in cll:\n                ans[u] = cnt\n    print(' '.join(list(map(str, ans))))
from queue import deque\n\nn, m = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\n\nused = set(arr)\nq = deque()\nfor i in range(n):\n    q.append([arr[i] - 1, 1, -1])\n    q.append([arr[i] + 1, 1, 1])\n\nret = []\ns = 0\nwhile m:\n    x, l, dr = q.popleft()\n    a = x + dr\n    if not a in used:\n        q.append([a, l + 1, dr])\n    if not x in used:\n        used.add(x)\n        ret.append(x)\n        m -= 1\n        s += l\nprint(s)\nprint(*ret)
import sys\ninput = sys.stdin.readline\n\nt = int(input())\nout = []\n\nfor _ in range(t):\n    n = int(input())\n    pos = []\n    for __ in range(n):\n        pos.append(tuple(map(int, input().split())))\n    pos.sort()\n\n    currX = 0\n    currY = 0\n    s = ''\n    works = True\n    for x, y in pos:\n        if currX > x:\n            works = False\n            break\n        else:\n            s += 'R' * (x - currX)\n            currX = x\n        if currY > y:\n            works = False\n            break\n        else:\n            s += 'U' * (y - currY)\n            currY = y\n    if works:\n        out.append('YES')\n        out.append(s)\n    else:\n        out.append('NO')\nprint('\n'.join(out))\n            \n
import sys\n\n\ndef read_int():\n    return int(sys.stdin.readline())\n\n\ndef read_ints():\n    return list(map(int, sys.stdin.readline().split(' ')))\n\n\nt = read_int()\nfor case_num in range(t):\n    n, s = read_ints()\n    a = [0] + [int(i) for i in str(n)]\n    ds = sum(a)\n    cost = 0\n    idx = len(a) - 1\n    radix = 1\n    while ds > s:\n        if a[idx] > 0:\n            cost += (10 - a[idx]) * radix\n            ds -= a[idx]\n            a[idx] = 0\n            ds += 1\n            a[idx - 1] += 1\n            i = idx - 1\n            while a[i] >= 10:\n                a[i - 1] += 1\n                a[i] -= 10\n                ds -= 9\n                i -= 1\n        radix *= 10\n        idx -= 1\n    print(cost)\n
for _ in range(int(input())):\n	n=int(input())\n	s=list(map(int,input().split()))\n	l=s.index(1)\n	r=n-s[::-1].index(1)\n	ans=0\n	for i in range(l,r):\n		ans+=1-s[i]\n	print(ans)
n = int(input())\nfor i in range(n):\n	l, ch = map(int, input().split())\n	for j in range(l):\n		print(chr(j % ch + ord('a')), end='')\n	print()\n
from fractions import Fraction\nimport bisect\nimport os\nfrom collections import Counter\nimport bisect\nfrom collections import defaultdict\nimport math\nimport random\nimport heapq as hq\nfrom math import sqrt\nimport sys\nfrom functools import reduce, cmp_to_key\nfrom collections import deque\nimport threading\nfrom itertools import combinations\nfrom io import BytesIO, IOBase\nfrom itertools import accumulate\n\n\n# sys.setrecursionlimit(200000)\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef iinput():\n    return int(input())\n\n\ndef tinput():\n    return input().split()\n\n\ndef rinput():\n    return list(map(int, tinput()))\n\n\ndef rlinput():\n    return list(rinput())\n\n\n# mod = int(1e9)+7\n\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\n\n# ----------------------------------------------------\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\nfor _ in range(iinput()):\n    n = iinput()\n    a = rlinput()\n    moves = 0\n    i = 0\n    j = n-1\n    prev = 0\n    ans1 = 0\n    ans2 = 0\n    while i <= j:\n        temp = 0\n        f = False\n        while i<=j and i < n and temp <= prev:\n            temp += a[i]\n            f = True\n            i += 1\n        ans1 += temp\n        if f:\n            moves += 1\n        prev = temp\n        temp = 0\n        f = False\n        while j >= i and j > 0 and temp <= prev:\n            temp += a[j]\n            f = True\n            j -= 1\n        ans2 += temp\n        if f:\n            moves += 1\n        prev = temp\n    print(moves,ans1,ans2)\n
import sys\ninput = sys.stdin.readline\nrInt = lambda: int(input())\nmInt = lambda: list(map(int, input().split()))\nrLis = lambda: list(map(int, input().split()))\n\nt = int(input())\nfor _ in range(t):\n    n, k = mInt()\n    a = rLis()\n    b = rLis()\n    a.sort()\n    b.sort(reverse = True)\n    for i in range(k):\n        if a[i] < b[i]:\n            a[i] = b[i]\n    print(sum(a))\n
n, c = list(map(int, input().split()))\na = [int(ai) for ai in input().split()]\nb = [int(bi) for bi in input().split()]\n\ndpa, dpb = [0] * n, [0] * n\ndpa[1], dpb[1] = a[0], c + b[0]\nfor i in range(1, n - 1):\n    dpa[i + 1], dpb[i + 1] = min(dpa[i], dpb[i]) + a[i], min(dpa[i] + c, dpb[i]) + b[i]\n\nprint(*(min(dpa[i], dpb[i]) for i in range(n)))\n
#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == "\n":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    t = I()\n    for _ in range(t):\n        n,k = LI()\n        f = 1\n        p = 1\n        while f <= k:\n            f += p\n            p += 1\n        f -= p\n        p -= 2\n        k -= f\n        p = n-p\n        k = n-k\n        ans = "a"*(p-2)+"b"+"a"*(k-p+1)+"b"+"a"*(n-k-1)\n        print(ans)\n    return\n\n#Solve\ndef __starting_point():\n    solve()\n\n__starting_point()
import bisect\n\ndef solve(n,x_coords,y_coords,k,ans):\n    x_coords.sort()\n    dp = []\n    for i in range(n):\n        x = x_coords[i]\n        index = bisect.bisect(x_coords,x+k)-1\n        dp.append(index-i+1)\n\n    dp_max = []\n    for i in reversed(dp):\n        if not dp_max:\n            dp_max.append(i)\n        else:\n            dp_max.append(max(dp_max[-1],i))\n\n    dp_max.reverse()\n    max_val = 0\n    for i in range(n):\n        x = x_coords[i]\n        index = bisect.bisect(x_coords,x+k)-1\n        val = index-i+1\n        if index+1 < n:\n            val += dp_max[index+1]\n\n        max_val = max(max_val,val)\n\n    ans.append(str(max_val))\n\ndef main():\n    t = int(input())\n    ans = []\n    for i in range(t):\n        n,k = list(map(int,input().split()))\n        x_coords = list(map(int,input().split()))\n        y_coords = list(map(int,input().split()))\n        solve(n,x_coords,y_coords,k,ans)\n\n    print('\n'.join(ans))\n\n    \nmain()\n
import sys\nfrom heapq import *\ninput = sys.stdin.readline\n\nquer, m = list(map(int, input().split()))\n\nvals = list(range(m))\nq = []\nfor v in vals:\n    heappush(q, v)\n\nout = []\nfor _ in range(quer):\n    nex = int(input()) % m\n    vals[nex] += m\n    heappush(q, vals[nex])\n\n    new = heappop(q)\n    while vals[new % m] != new:\n        new = heappop(q)\n\n    out.append(new)\n    heappush(q, new)\n\nprint('\n'.join(map(str,out)))\n    \n
def read_int():\n    return int(input())\n\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\n\nt = read_int()\nfor case_num in range(t):\n    n, x, y = read_ints()\n    d = y - x\n    for i in range(n - 1, 0, -1):\n        if d % i == 0:\n            d //= i\n            l = min(n - (i + 1), (x - 1) // d)\n            ans = [x - l * d + i * d for i in range(n)]\n            print(' '.join(map(str, ans)))\n            break\n
import time\nimport random\n\nl = list(map(int, input().split()))\nassert len(l) == l[0] + 1\nl = l[1:]\nl.sort()\n\nv = [0 for i in range(10 ** 4)]\nfor i in range(4 * 10**5):\n    v[random.randrange(0, len(v))] = random.randrange(-1000, 1000)\n\nprint(' '.join(map(str, l)))\n
for _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    a, b = 0, 0\n    for elem in ar:\n        if elem % 2 == 0:\n            a = 1\n        else:\n            b = 1\n    if sum(ar) % 2 == 1:\n        print('YES')\n    elif a == 1 == b:\n        print('YES')\n    else:\n        print('NO')
T = int(input())\nfor _ in range(T):\n    n = int(input())\n    if n <= 3:\n        print(-1)\n    else:\n        left = []\n        for i in range(1, n + 1, 2):\n            left.append(i)\n        right = []\n        right.append(4)\n        right.append(2)\n        for i in range(6, n + 1, 2):\n            right.append(i)\n        right.reverse()\n\n        for i in left:\n            right.append(i)\n        \n        for i in right:\n            print(i, end = " ")\n        print("")
\n\nfor _ in range(int(input())):\n	n=int(input())\n	a=list(map(int,input().split()))\n\n	od=0\n	ev=0\n\n	for i in range(n):\n		if(i&1):\n			if(a[i]%2==0):\n				od+=1\n		else:\n			if(a[i]&1):\n				ev+=1\n\n	if(od!=ev):\n		print(-1)\n	else:\n		print(od)
n = int(input())\na = list(map(int, input().split()))\ng = [list() for _ in range(n)]\nfor _ in range(n-1):\n  u,v = list(map(int, input().split()))\n  g[u-1].append(v-1)\n  g[v-1].append(u-1)\nst = [x*2-1 for x in a] + [0]\np = [-1]*n\nq = [0]\nwhile q:\n  v = q.pop()\n  for x in g[v]:\n    if x == p[v]: continue\n    p[x] = v\n    q.append(x)\n      \nseen = [0]*n\nq = [0]\nwhile q:\n  v = q[-1]\n  if seen[v]:\n    q.pop()\n    if st[v] > 0:\n      st[p[v]] += st[v]\n  else:\n    for x in g[v]:\n      if x == p[v]: continue\n      q.append(x)\n    seen[v] = 1\n\nseen = [0]*n\nq = [0]\nwhile q:\n  v = q.pop()\n  for x in g[v]:\n    if x == p[v]: continue\n    c = st[v]\n    if st[x] > 0: c -= st[x]\n    if c > 0: st[x] += c\n    q.append(x)\n\nprint(*st[:n])\n
for testcase in range(int(input())):\n    n = int(input())\n    cnt2, cnt3 = 0, 0\n    while n % 2 == 0:\n        n //= 2\n        cnt2 += 1\n    while n % 3 == 0:\n        n //= 3\n        cnt3 += 1\n\n    if n > 1 or cnt3 < cnt2:\n        print(-1)\n        continue\n\n    print(2 * cnt3 - cnt2)\n
import sys\ndef countR(ip):\n    c=0\n    for i in ip:\n        if(i=='R'):\n            c+=1\n    return c\n    \ndef countB(ip):\n    c=0\n    for i in ip:\n        if(i=='B'):\n            c+=1\n    return c\n    \ndef countG(ip):\n    c=0\n    for i in ip:\n        if(i=='G'):\n            c+=1\n    return c\n# sys.stdin.readline()\nt=int(sys.stdin.readline())\nx='RGB'*680\ny='GBR'*680\nz='BRG'*680\nfor i in range(t):\n    n,k=list(map(int,sys.stdin.readline().strip().split()))\n    a=sys.stdin.readline().strip()\n    xk=x[:k]\n    yk=y[:k]\n    zk=z[:k]\n    # print(k,xk,zk)\n    # xc=[]\n    # yc=[]\n    # zc=[]\n    # xc.append(countR(xk))\n    # xc.append(countG(xk))\n    # xc.append(countB(xk))\n   \n    # yc.append(countR(yk))\n    # yc.append(countG(yk))\n    # yc.append(countB(yk))\n    \n    # zc.append(countR(zk))\n    # zc.append(countG(zk))\n    # zc.append(countB(zk))\n    op=2001\n    for j in range(n-k+1):\n        b=a[j:j+k]\n        # print(len(b),xc,zc)\n        # bc=[]\n        \n        # bc.append(countR(b))\n        # bc.append(countG(b))\n        # bc.append(countB(b))\n        xd=0\n        yd=0\n        zd=0\n        # print(a,b,xc,yc,zc,bc)\n        for jj in range(len(b)):\n            if(b[jj]!=xk[jj]):\n                xd+=1\n            if(b[jj]!=yk[jj]):\n                yd+=1\n            if(b[jj]!=zk[jj]):\n                zd+=1\n         # print(a,b,xd,yd,zd,z)\n        op=min(op,xd,yd,zd)\n    print(op)\n
for i in range(int(input())):\n    n=int(input())\n    l1=list(map(int,input().split()))\n    type1=0\n    type2=0\n    ans=0\n    for item in l1:\n        if item%3==0:\n            ans+=1\n        elif item%3==1:\n            type1+=1\n        else :\n            type2+=1\n    x=min(type1,type2)\n    ans+=x\n    type1-=x\n    type2-=x\n    ans+=(type1//3+type2//3)\n    print(ans)
q = int(input())\nfor qi in range(q):\n    n = int(input())\n    a = list(map(int, input().split()))\n    used = [False] * n\n    for t in range(n):\n        for i in range(len(a) - 1, 0, -1):\n            if used[i]:\n                continue\n            if a[i] < a[i - 1]:\n                a[i], a[i - 1] = a[i - 1], a[i]\n                used[i] = True\n    print(' '.join(str(x) for x in a))
'''input\n5\n4\n1 2 3 4\n3\n1 3 2\n5\n1 2 3 5 4\n1\n1\n5\n3 2 1 5 4\n\n'''\nimport sys\nfrom collections import defaultdict as dd\nfrom itertools import  permutations as pp\nfrom itertools import combinations as cc\nfrom collections import Counter as ccd\nfrom random import randint as rd\nfrom bisect import bisect_left as bl\nfrom  heapq import heappush as hpush\nfrom heapq import heappop as hpop\nmod=10**9+7\n\ndef ri(flag=0):\n	if flag==0:\n		return [int(i) for i in sys.stdin.readline().split()]\n	else:\n		return int(sys.stdin.readline())\n\n\n\nfor _ in range(ri(1)):\n	n = ri(1)\n	a= ri()\n	idx = a.index(1)\n\n	check1 = 1\n	check2 =1\n	for i in range(n):\n		if a[(idx+i)%n] == i+1:\n			pass\n		else:\n			check1=0\n	a=a[::-1]\n	idx = a.index(1)\n	for i in range(n):\n		if a[(idx+i)%n] == i+1:\n			pass\n		else:\n			check2=0\n\n	if check1==1 or check2==1:\n		print("YES")\n	else:\n		print("NO")
q = int(input())\nfor z in range(q):\n    n, k = map(int, input().split())\n    x = n // k\n    n -= x * k\n    m = min(k // 2, n)\n    print(x * k + m)
t=int(input())\nfor i in range (t):\n    n,k=map(int,input().split())\n    if n-k+1>0 and (n-k+1)%2==1:\n        print("YES")\n        print(*([1]*(k-1)), n-k+1)\n    elif n-k*2+2>0 and (n-k*2+2)%2==0:\n        print("YES")\n        print(*([2]*(k-1)), n-k*2+2)\n    else:\n        print("NO")
from sys import stdin,stdout\nimport sys\nimport math\n\nt=int(stdin.readline())\nfor i in range(t):\n    a=list(map(int,stdin.readline().split()))\n    print(sum(a)//2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n
t = int(input())\ndef gcd(a,b):\n    if b == 0:\n        return a\n    return gcd(b,a%b)\nfor _ in range(t):\n    n,k = map(int,input().split())\n    s = input()\n    occ = [0] * 26\n    for i in s:\n        occ[ord(i)-97] += 1\n    occ.sort()\n    occ.reverse()\n    for l in range(1,n+1):\n        cycle = gcd(l,k)\n        need = l//cycle\n        su = 0\n        for i in occ:\n            su += i//need\n        if su*need >= l:\n            wyn = l\n    print(wyn)
from sys import stdin\nc=int(stdin.readline().strip())\nfor cas in range(c):\n    n,m=list(map(int,stdin.readline().strip().split()))\n    s=list(map(int,stdin.readline().strip().split()))\n    sm=0\n    ans=[]\n    ind=-1\n    for i in range(n):\n        if m==1:\n            ind=i\n            break\n        sm+=s[i]\n        if sm%2!=0:\n            ans.append(i+1)\n            sm=0\n            m-=1\n    if ind==-1:\n        print("NO")\n        continue\n    sm=sum(s[ind::])\n    if sm%2!=0:\n        ans.append(n)\n        print("YES")\n        print(*ans)\n    else:\n        print("NO")\n\n    \n\n
class Solution:\n    def reverseBits(self, n: int) -> int:\n        rev = ''\n        for i in reversed(bin(n)[2:]):\n            rev = rev + i\n        rev = rev + '0'*(32-len(rev)) \n        \n        return int(rev, 2)
class Solution:\n     def generate(self, numRows):\n         """\n         :type numRows: int\n         :rtype: List[List[int]]\n         """\n         res = [[1]]\n         for i in range(1,numRows):\n             res.append(list(map(lambda x, y : x + y, res[-1]+[0], [0]+res[-1])))\n         return res[:numRows]\n          \n
# Enter your code here. Read input from STDIN. Print output to STDOUT\nimport re\nn=int(input())\nar=[]\nfor i in range(0,n):\n    s=input()\n    t=re.search(r"^[a-zA-Z][\w-]*@[a-zA-Z0-9]+\.[a-zA-Z]{1,3}$",s)\n    if t:\n        ar.append(s)\nar.sort()        \nprint(ar)\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\ndef sqr(a):\n    return a*a*a\nn=int(input())\nif(n==0):\n    print("[]")\nelif(n==1):\n    print("[0]")\nelse:\n    ar=[0]*n\n    ar[0]=0\n    ar[1]=1\n    for i in range(2,n):\n        ar[i]=ar[i-1]+ar[i-2]\n\n    ar=list(map(sqr,ar))\n    print(ar)\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\nxml_str=""\nn=int(input())\nfor i in range(0,n):\n    tmp_str=input()\n    xml_str=xml_str+tmp_str\n    \nimport xml.etree.ElementTree as etree\ntree = etree.ElementTree(etree.fromstring(xml_str))\nroot=tree.getroot()\nar=[]\ndef cnt_node(node):\n    return max( [0] + [cnt_node(child)+1 for child in node])\ncnt=cnt_node(root)\nprint(cnt)\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\nn=int(input())\nfor i in range(0,n):\n    tmp_str=input()\n    len_tmp_str=len(tmp_str)\n    if(len_tmp_str!=10):\n        ##print "LENGTH PROBLEM"\n        print("NO")\n    elif(tmp_str[0]!="7" and tmp_str[0]!="8" and tmp_str[0]!="9"):\n        ##print "START PROBLEM"        \n        print("NO")\n    else:\n        check=1\n        for i in tmp_str:\n            if(i>="0" and i<="9"):\n                continue\n            else:\n                check=0\n                break\n        if(check==1):\n            print("YES")\n        else:\n            ##print "NUMBER PROBLEM"            \n            print("NO")\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\nm=int(input())\nset_a_str_ar=input().strip().split()\nset_a_ar=list(map(int,set_a_str_ar))\nn=int(input())\nset_b_str_ar=input().strip().split()\nset_b_ar=list(map(int,set_b_str_ar))\n\nset_a_set=set(set_a_ar)\nset_b_set=set(set_b_ar)\nset_a_dif_set=set_a_set.difference(set_b_set)\nset_b_dif_set=set_b_set.difference(set_a_set)\nres_set=set_a_dif_set.union(set_b_dif_set)\nres_ar=list(res_set)\nres_ar.sort()\nfor i in res_ar:\n    print(i)\n
n = int(input())\ncol_list = list(input().split())\nmarks_col = col_list.index("MARKS")\nmarks_list = []\nfor i in range(n):\n    info_list = list(input().split())\n    marks_list.append(float(info_list[marks_col]))\nprint((sum(marks_list)/n))\n
#!/bin/python3\n\nimport sys\n\n\nN = int(input().strip())\nn= N\nw = 'Weird'\nnw = 'Not Weird'\nif n % 2 == 1:\n    print(w)\nelif n % 2 == 0 and (n>=2 and n<5):\n    print(nw)\nelif n % 2 == 0 and (n>=6 and n<=20):\n    print(w)\nelif n % 2 == 0 and (n>20):\n    print(nw)    \n
# Enter your code here. Read input from STDIN. Print output to STDOUT\nxml_str=""\nn=int(input())\nfor i in range(0,n):\n    tmp_str=input()\n    xml_str=xml_str+tmp_str\n    \ncnt=xml_str.count("='")\nprint(cnt)\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\n\nimport math\ndef custom_diff(a,b):\n    res0 = a[0] - b[0]\n    res1 = a[1] - b[1]\n    res2 = a[2] - b[2]\n    return [res0,res1,res2]\n\ndef dot_product(a,b):\n    return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]\n\ndef abs_val(a):\n    tmp_val=a[0]*a[0]+a[1]*a[1]+a[2]*a[2]\n    return math.sqrt(tmp_val)\n\n\n\ndef cross(a, b):\n    c = [a[1]*b[2] - a[2]*b[1],\n         a[2]*b[0] - a[0]*b[2],\n         a[0]*b[1] - a[1]*b[0]]\n\n    return c\n\na_str_ar=input().strip().split()\nb_str_ar=input().strip().split()\nc_str_ar=input().strip().split()\nd_str_ar=input().strip().split()\n\na=list(map(float,a_str_ar))\nb=list(map(float,b_str_ar))\nc=list(map(float,c_str_ar))\nd=list(map(float,d_str_ar))\n\nab=custom_diff(b,a)\nbc=custom_diff(c,b)\ncd=custom_diff(d,c)\n\nx=cross(ab,bc)\ny=cross(bc,cd)\n       \ncosphi_top=dot_product(x,y)\ncosphi_bottom=abs_val(x)*abs_val(y)\ncosphi=cosphi_top/cosphi_bottom\n\nres=math.degrees(math.acos(cosphi))\n\nprint(("%.2f" %res))\n
def is_vowel(letter):\n    return letter in ['a', 'e', 'i', 'o', 'u', 'y']\n\ndef score_words(words):\n    score = 0\n    for word in words:\n        num_vowels = 0\n        for letter in word:\n            if is_vowel(letter):\n                num_vowels += 1\n        if num_vowels % 2 == 0:\n            score += 2\n        else:\n            score += 1\n    return score\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\nimport re\ndef my_func(s):\n    s = s.upper()\n    ##res=re.match(r'^(?=[MDCLXVI])M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$',s)\n    res=re.search(r'^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$',s)\n    if(s=="MMMM"):\n        print("False")\n    else:\n        if res:\n            print("True")\n        else:\n            print("False")\nmy_func(input())\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\nn=int(input())\nar=[]\nfor i in range(0,n):\n    tmp_str=input()\n    tmp_str=tmp_str[len(tmp_str)-10:]\n    ar.append(tmp_str)\n    \nar.sort()\nfor i in range(0,len(ar)):\n    print(("+91 "+ar[i][:5]+" "+ar[i][5:]))\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\nn=int(input())\nar={}\nfor i in range(0,n):\n    s=input()\n    ss=s.split(" ")\n    n=ss[0]\n    m1=float(ss[1])\n    m2=float(ss[2])\n    m3=float(ss[3])\n    m_avg=(m1+m2+m3)/3.0\n    ar[n]="%.2f" % m_avg\ns_name=input()\nprint((ar[s_name]))\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\nar=[]\nn=int(input())\nfor i in range(0,n):\n    str_ar=input().strip().split()\n    user_name=str_ar[0]+" "+str_ar[1]\n    user_age=int(str_ar[2])\n    user_sex=str_ar[3]\n    user_new_name=""\n    if(user_sex=="M"):\n        user_new_name="Mr. "+user_name\n    else:\n        user_new_name="Ms. "+user_name\n    ar.append([user_new_name,user_age])\n\nl = sorted(ar, key=lambda tup: tup[1])\nfor i in range(0,n):\n    print((l[i][0]))\n
# Enter your code here. Read input from STDIN. Print output to STDOUT\nx=int(input())\ny=int(input())\nz=int(input())\nn=int(input())\nprint([ [i,j,k] for i in range(x+1) for j in range(y+1) for k in range(z+1) if i+j+k != n ])\n
# Enter your code here. Read input from STDIN. Print output to \n\n\nimport math\n\nclass ComplexNumber(object): \n    def __init__(self, real, compl): \n        self.real = real \n        self.compl = compl\n        pass\n    def __str__(self):\n        if (self.compl >= 0):\n            return '{0:.2f}'.format(self.real) +'+'+ '{0:.2f}'.format(self.compl) +'i' \n        return '{0:.2f}'.format(self.real) +'-'+ '{0:.2f}'.format(abs(self.compl)) +'i' \n    def __add__(x, y):\n        return ComplexNumber(x.real+y.real, x.compl+y.compl)\n    def __sub__(x, y):\n        return ComplexNumber(x.real-y.real, x.compl-y.compl)\n    def __mul__(x, y):\n        return ComplexNumber(x.real*y.real - x.compl*y.compl, x.compl*y.real + x.real*y.compl)\n    def __truediv__(x, y):\n        return ComplexNumber((x.real*y.real + x.compl*y.compl) / (y.real*y.real + y.compl*y.compl), \n                             (x.compl*y.real - x.real*y.compl) / (y.real*y.real + y.compl*y.compl))\n    def mod(self):\n        return ComplexNumber(math.sqrt(self.real*self.real + self.compl*self.compl), 0)\n    \nhelp = list(map(float, input().split(' ')))   \nx = ComplexNumber(help[0], help[1])    \nhelp = list(map(float, input().split(' ')))   \ny = ComplexNumber(help[0], help[1])    \n\nprint(x+y)\nprint(x-y)\nprint(x*y)\nprint(x/y)\nprint(x.mod())\nprint(y.mod())
q=str(input())\ne=str(input())\na=len(q)\nb=len(e)\nc=""\nif a==b:\n  for i in range(a):\n    c+=q[i]\n    c+=e[i]\nelse:\n  for i in range(b):\n    c+=q[i]\n    c+=e[i]\n  c+=q[a-1]\n\nprint(c)
from collections import deque\n\nS = input()\n\nans = deque([])\n\nfor s in S:\n    if s=="B":\n        if ans:\n            ans.pop()\n    else:\n        ans.append(s)\n        \nprint("".join(ans))
N = int(input())\nA = list(map(int,input().split()))\nT = 0\nfor i in range(len(A)-1):\n    if  (A[i] > A[i + 1]):\n        T += A[i] - A[i +1]\n        A[i+1] = A[i] \nprint(T)
A = input()\nB = input()\nC = input()\nturn = 'a'\nwhile True:\n  if turn == 'a':\n    if len(A) == 0:\n      print('A')\n      break\n    turn = A[0]\n    A = A[1:]\n  elif turn == 'b':\n    if len(B) == 0:\n      print('B')\n      break\n    turn = B[0]\n    B = B[1:]\n  else:\n    if len(C) == 0:\n      print('C')\n      break\n    turn = C[0]\n    C = C[1:]
haiku = list(map(int, input().split()))\nif haiku == [5, 5, 7] or haiku == [5, 7, 5] or haiku == [7, 5, 5]:\n	print("YES")\nelse:\n	print("NO")
n=int(input())\na,b=2,1\nfor i in range(n):\n    nxt=a+b\n    a,b=b,nxt\nprint(a)
\na = int(input())\nb = int(input())\nh = int(input())\ns = (a+b)*h/2\nprint(int(s))
(N), *D = [list(map(int, s.split())) for s in open(0)]\nV = D[0]\nA = V.pop(N[0]-1)\nM = 1000000000 + 7\nR=0\nfor value in reversed(V):\n    R = R + ((A) * value) % M\n    A = A + value\nprint(R % M)
rgb = list(map(int, input().split()))\n\nl = ''.join(str(n) for n in rgb)\nif int(l)%4 == 0:\n    print('YES')\nelse:\n    print('NO')
a,b,c=list(map(int,input().split()))\nk=int(input())\n\nx=max(a,b,c)\n\nprint(((a+b+c)-x+x*(2**k)))\n
import sys\nimport string\nw = input()\na_z = string.ascii_letters\nfor i in a_z:\n    if w.count(i) & 1:\n        print('No')\n        return\nprint('Yes')
n, k = list(map(int, input().split()))\nab = [list(map(int, input().split())) for _ in range(n)]\n\nab.sort()\n\nnum_sum = 0\n\nfor a, b in ab:\n    num_sum += b\n    if num_sum >= k:\n        print(a)\n        return\n
n,k=map(int,input().split())\nprint(k*(k-1)**(n-1))
k, n = map(int, input().split())\npoints = list(map(int, input().split()))\n\ndist = []\nfor i in range(n):\n    if i != n-1:\n        distance = points[i+1] - points[i]\n    else:\n        distance = points[0]+k - points[i]\n    dist.append(distance)\n\nmax = dist[0]\nfor j in range(1, len(dist), 1):\n    if max < dist[j]:\n        max = dist[j]\ndist.remove(max)\n\nans = 0\nfor k in dist:\n    ans += k\nprint(ans)
a,b,c,d=map(int, input().split())   \nprint(max(a*b,c*d))
c = int(input())\n\nr = ["AC", "WA", "TLE", "RE"]\na = { i:0 for i in r}\n\nfor i in range(c):\n    s = input()\n    a [s] += 1\n\nfor rr in r:\n    print(rr + " x " + str(a[rr]))
time=int(input())\nAns=48-time\nprint(Ans)
# A - Restricted\n# https://atcoder.jp/contests/abc063/tasks/abc063_a\n\nA, B = list(map(int, input().split()))\n\nresult = A + B\nif result >= 10:\n    print('error')\nelse:\n    print(result)\n
N=int(input())\nA=list(map(int, input().split()))\n\nprint(max(A)-min(A))
n1 = [1, 3, 5, 7, 8, 10, 12]\nn2 = [4, 6, 9, 11]\n\na, b = list(map(int, input().split()))\nprint(("Yes" if a in n1 and b in n1 or a in n2 and b in n2 else "No"))\n
a, b = map(int, input().split())\nif a*b %2 == 0:\n    print("Even")\nelse:\n    print("Odd")
n, m = [int(x) for x in input().split()]\nans = min(n, m // 2)\nans += (m - ans * 2) // 4\nprint(ans)
N = int(input())\nT = [int(TN) for TN in input().split()]\nSumT = sum(T)\nM = int(input())\nPX = [[] for TM in range(0,M)]\nfor TM in range(0,M):\n    PX[TM] = [int(TPX) for TPX in input().split()]\nfor TM in range(0,M):\n    print(SumT-T[PX[TM][0]-1]+PX[TM][1])
import itertools\n\ndef cal(N, target_num, keta):\n    answer = float('inf')\n    for p in itertools.product(target_num, repeat=keta):\n        temp = 0\n        for i, num in enumerate(p):\n            temp += num * 10**i\n            \n        if temp >= N:\n            answer = min(answer, temp)\n\n    return answer\n\ndef __starting_point():\n    N, K = map(int, input().split()) # N円の品物、K個の嫌いな数字\n    D = set(list(map(int, input().split()))) # 嫌いな数字のリスト\n    base = set(range(10))\n\n    target_num = base - D\n    keta = len(str(N))\n\n    answer = min(cal(N, target_num, keta), cal(N, target_num, keta+1))\n\n    print(answer)\n__starting_point()
N,M = map(int,input().split())\nhigh = list(map(int,input().split()))\nans = [0]*N\ncnt = 0\nfor i in range(M):\n    a,b = map(int,input().split())\n    ans[a-1] = max(high[b-1],ans[a-1])\n    ans[b-1] = max(ans[b-1],high[a-1])\n\nfor j in range(N):\n    if ans[j] < high[j]:\n        cnt += 1\nprint(cnt)
#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**6)\n\nn = int(input())\nk = int(input())\n\nans = 1\nfor i in range(n):\n    if ans*2 <= (ans+k):\n        ans *= 2\n    else:\n        ans += k\n    # print(ans)\nprint(ans)\n
X=int(input())\nprint(1-X)
import copy\n\ns=input()\nl=len(s)\nans=0\n\nif l==1:\n  ans+=int(s)\n  print(ans)\n  \nelse:\n  for i in range(2**(l-1)):\n    t=copy.deepcopy(s)\n    f=[]\n    ch=0\n    for j in range(l-1):\n      if ((i>>j)&1):\n        t=t[:j+1+ch]+'+'+t[j+1+ch:]\n        ch+=1\n     \n    if '+' in t:\n      \n      y=list(map(int,t.split('+')))\n      for u in y:\n        ans+=u\n    else:\n      ans+=int(t)\n      \n  print(ans)
import sys\nimport itertools\n\nsys.setrecursionlimit(10 ** 8)\nini = lambda: int(sys.stdin.readline())\ninl = lambda: [int(x) for x in sys.stdin.readline().split()]\nins = lambda: sys.stdin.readline().rstrip()\ndebug = lambda *a, **kw: print("\033[33m", *a, "\033[0m", **dict(file=sys.stderr, **kw))\n\nN = ini()\nA = inl()\n\n\ndef solve():\n    B = list(itertools.accumulate(A, initial=0))\n    s = 0\n    ans = 10 ** 12\n    for i in range(N - 1, 0, -1):\n        s += A[i]\n        ans = min(ans, abs(s - B[i]))\n\n    return ans\n\n\nprint(solve())\n
# １食８００円をN食食べた\nN = int( input() )\nx = int( 800 * N )\n\n#  １５食食べるごとに２００円もらえる\n\ny = N // 15 * 200\n\nprint( x - y )
cij = [list(input()) for _ in range(3)]\n\nprint(cij[0][0] + cij[1][1] + cij[2][2])
s=input()\ncount=0\nfor i in range(len(s)):\n    if(s[i]=="1"):\n        count+=1\nprint(count)
\nN = int(input())\nK = int(input())\nX = int(input())\nY = int(input())\nif K < N:\n    ans = K*X + (N-K)*Y\nelse:\n    ans = N*X\nprint(ans)
a, o, b = input().split()\nif o == '+':\n    print((int(a) + int(b)))\nelse:\n    print((int(a) - int(b)))\n
x = int(input())\n\nif x < 1200:\n    print('ABC')\nelse:\n    print('ARC')
# A - ringring\n# https://atcoder.jp/contests/abc066/tasks/abc066_a\n\na = list(map(int, input().split()))\n\na.sort()\nprint((a[0] + a[1]))\n
H, W = map(int, input().split())\ns = '#' * (W + 2)\ndata = []\ndata.append(s)\nfor i in range(H):\n    data.append('#' + str(input()) + '#')\ndata.append(s)\n   \nfor i in range(H + 2):\n    print(data[i])
N = int(input())\nS = input()\nres = 0\ntmp = 0\nfor s in S:\n  if s == 'I':\n    tmp += 1\n  elif s == 'D':\n    tmp -= 1\n  \n  res = max(res, tmp)\n\nprint(res)\n
a,b = map(int,input().split())\nans = 0\nfor i in range(a,b+1):\n    c = str(i)\n    l = len(c)\n    d = l // 2\n    cnt = 0\n    for i in range(d):\n        if c[i] == c[-i-1]:\n            cnt += 1\n    if cnt == d:\n        ans += 1\nprint(ans)
a=list(map(int,input().split()))\nprint(len(set(a)))
N,K=map(int,input().split())\nl=list(map(int,input().split()))\nl.sort(reverse=True)\nsum=0\nfor i in range(K) :\n  sum+=l[i]\nprint(sum)
x, a, b = (int(x) for x in input().split())\nif abs(a-x) < abs(b-x):\n    print("A")\nelse:\n    print("B")
s=input()\nprint("2018"+s[4:])
# ひっくりかえすのかとお保ったら180度反転だった\nn = int(input())\nd = []\nfor _ in range(n):\n    s = list(input())\n    d.append(s)\n\nd = sorted(d, key=lambda dd: len(dd), reverse=True)\nbase = {}\nfor c in d[0]:\n    if c not in base:\n        base[c] = 1\n    else:\n        base[c] += 1\n\nfor s in d[1:]:\n    tmp = {}\n    for c in s:\n        if c not in tmp:\n            tmp[c] = 1\n        else:\n            tmp[c] += 1\n    for k, v in base.items():\n        if k in tmp and base[k] >= 1:\n            base[k] = min(base[k], tmp[k])\n        else:\n            base[k] = -1\nans = []\nfor k, v in base.items():\n    if v > 0:\n        ans.append(k * v)\nans = sorted(ans)\nans = "".join(ans)\nprint(ans)
N = int(input())\nans = 0\nfor _ in range(N):\n  a, b = map(int, input().split())\n  ans += b - a + 1\nprint(ans)
a, b = map(int, input().split())\nprint((a - 1) * (b - 1))
A, B = map(int, input().split())\nC = A + B\n\nprint("Possible" if A%3==0 or B%3==0 or C%3==0 else "Impossible")
# -*- coding: utf-8 -*-\n"""\nCreated on Mon Sep 28 02:20:36 2020\n\n@author: liang\n"""\nS = input()\nT = input()\n\nS = S[::-1]\nT = T[::-1]\n\nres = list()\n\nfor i in range(len(S)-len(T)+1):\n    flag = True\n    for j in range(len(T)):\n        if S[i+j] == "?" or S[i+j] == T[j]:\n            continue\n        else:\n            flag = False\n    if flag == True:\n        ans = ""\n        for k in range(len(S)):\n            if i <= k <= i + len(T)-1:\n                #print(T[k-i])\n                ans += T[k-i]\n            elif S[k] != "?":\n                #print("B")\n                ans += S[k]\n            else:\n                #print("C")\n                ans += "a"\n        ans = ans[::-1]\n        res.append(ans)\n\nif res:\n    res.sort()\n    print((res[0]))\nelse:\n    print("UNRESTORABLE")\n#print(S)\n#print(T)\n
# 現在と目標のレーティングを取得\nR = int(input())\nG = int(input())\n\n# 目標のレーティングになるためのパフォーマンスの数値を計算\nTarget = (G * 2) - R\n\n# 計算結果を出力\nprint(Target)
#	!/usr/bin/env python3\n#	coding: UTF-8\n#	Modified: <23/Jan/2019 08:06:42 PM>\n\n\n#	✪ H4WK3yE乡\n#	Mohd. Farhan Tahir\n#	Indian Institute Of Information Technology (IIIT),Gwalior\n\n#	Question Link\n#\n#\n\n# ///==========Libraries, Constants and Functions=============///\n\n\nimport sys\n\ninf = float("inf")\nmod = 1000000007\n\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef get_ints(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef input(): return sys.stdin.readline()\n\n# ///==========MAIN=============///\n\n\ndef main():\n    for tc in range(int(input())):\n        l1, r1, l2, r2 = get_ints()\n        if l1 != l2:\n            print(l1, l2)\n        else:\n            print(l1, r2)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()
class Solution:\n    def hasCycle(self, head: ListNode) -> bool:\n        if head == None:\n            return False\n        \n        slow = head\n        fast = head.next\n        \n        while slow != fast:\n            if fast is None or fast.next is None:\n                return False\n            slow = slow.next\n            fast = fast.next.next\n        \n        return True
class Solution:\n     def twoSum(self, nums, target):\n         tmp = {}\n         for i in range(len(nums)):\n             if target - nums[i] in tmp:\n                 return(tmp[target - nums[i]], i)\n             else:\n                 tmp[nums[i]] = i;\n         \n         """\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[int]\n         """\n
